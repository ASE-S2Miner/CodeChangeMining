[{"original_method":"/** Choose a request to run. Does not check whether the SendableRequest is actually runnable at \n\t * the moment. The cooldown mechanism on the RGAs and SRGAs should ensure that it is usable \n\t * most of the time.\n\t * @return Either a chosen request or the time at which we should try again if all priorities \n\t * are waiting for requests to finish / cooldown periods to expire. */\n\tSelectorReturn chooseRequestInner(int fuzz, RandomSource random, OfferedKeysList offeredKeys, RequestStarter starter, boolean realTime, ClientContext context, long now) {\n\t\t// Priorities start at 0\n\t\tif(logMINOR) Logger.minor(this, \"removeFirst()\");\n\t\tboolean tryOfferedKeys = offeredKeys != null && random.nextBoolean();\n\t\tif(tryOfferedKeys) {\n\t\t\tif(offeredKeys.getWakeupTime(context, now) == 0)\n\t\t\t\treturn new SelectorReturn(offeredKeys);\n\t\t}\n\t\tlong l = choosePriority(fuzz, random, context, now);\n\t\tif(l > Integer.MAX_VALUE) {\n\t\t\tif(logMINOR) Logger.minor(this, \"No priority available for the next \"+TimeUtil.formatTime(l - now));\n\t\t\treturn null;\n\t\t}\n\t\tint choosenPriorityClass = (int)l;\n\t\tif(choosenPriorityClass == -1) {\n\t\t\tif(!tryOfferedKeys) {\n\t\t\t\tif(offeredKeys != null && offeredKeys.getWakeupTime(context, now) == 0)\n\t\t\t\t\treturn new SelectorReturn(offeredKeys);\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Nothing to do\");\n\t\t\treturn null;\n\t\t}\n\t\tlong wakeupTime = Long.MAX_VALUE;\nouter:\tfor(;choosenPriorityClass <= RequestStarter.MINIMUM_FETCHABLE_PRIORITY_CLASS;choosenPriorityClass++) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Using priority \"+choosenPriorityClass);\n\t\t\tSectoredRandomGrabArray<RequestClient> chosenTracker = priorities[choosenPriorityClass];\n\t\t\tif(chosenTracker == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests to run: chosen priority empty\");\n\t\t\t\tcontinue; // Try next priority\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t    long cooldownTime = chosenTracker.getWakeupTime(context, now);\n\t\t\t    if(cooldownTime > 0) {\n\t\t\t        if(cooldownTime < wakeupTime) wakeupTime = cooldownTime;\n\t\t\t        Logger.normal(this, \"Priority \"+choosenPriorityClass+\" is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t        continue outer;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Got priority tracker \"+chosenTracker);\n\t\t\t\tRemoveRandomReturn val;\n\t\t\t\tsynchronized(this) {\n\t\t\t\t    // We must hold the overall lock, just as in addToGrabArrays.\n\t\t\t\t    // This is important for keeping the cooldown tracker consistent amongst other \n\t\t\t\t    // things: We can get a race condition between thread A reading the tree, \n\t\t\t\t    // finding nothing and setCachedWakeup(), and thread B waking up a request, \n\t\t\t\t    // resulting in the request not being accessible.\n\t\t\t\t    val = chosenTracker.removeRandom(starter, context, now);\n\t\t\t\t}\n\t\t\t\tSendableRequest req;\n\t\t\t\tif(val == null) {\n\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned null - nothing to schedule, should remove priority\");\n\t\t\t\t\tcontinue outer;\n\t\t\t\t} else if(val.item == null) {\n\t\t\t\t\tif(val.wakeupTime == -1)\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned cooldown time of -1 - nothing to schedule, should remove priority\");\n\t\t\t\t\telse {\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned cooldown time of \"+(val.wakeupTime - now)+\" = \"+TimeUtil.formatTime(val.wakeupTime - now));\n\t\t\t\t\t\tif(val.wakeupTime > 0 && val.wakeupTime < wakeupTime)\n\t\t\t\t\t\t\twakeupTime = val.wakeupTime;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue outer;\n\t\t\t\t} else {\n\t\t\t\t\treq = (SendableRequest) val.item;\n\t\t\t\t}\n\t\t\t\tif(req.getPriorityClass() != choosenPriorityClass) {\n\t\t\t\t\t// Reinsert it : shouldn't happen if we are calling reregisterAll,\n\t\t\t\t\t// maybe we should ask people to report that error if seen\n\t\t\t\t\tLogger.normal(this, \"In wrong priority class: \"+req+\" (req.prio=\"+req.getPriorityClass()+\" but chosen=\"+choosenPriorityClass+ ')');\n\t\t\t\t\t// Remove it.\n\t\t\t\t\tSectoredRandomGrabArrayWithObject<RequestClient,ClientRequester> clientGrabber = (SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester>) chosenTracker.getGrabber(req.getClient());\n\t\t\t\t\tif(clientGrabber != null) {\n\t\t\t\t\t\tRandomGrabArray baseRGA = (RandomGrabArray) clientGrabber.getGrabber(req.getClientRequest());\n\t\t\t\t\t\tif(baseRGA != null) {\n\t\t\t\t\t\t\t// Must synchronize to avoid nasty race conditions with cooldown.\n\t\t\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\t\t\tbaseRGA.remove(req, context);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Okay, it's been removed already. Cool.\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.error(this, \"Could not find client grabber for client \"+req.getClient()+\" from \"+chosenTracker);\n\t\t\t\t\t}\n\t\t\t\t\tinnerRegister(req, context, null);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check recentSuccesses\n\t\t\t\t/** Choose a recently succeeded request.\n\t\t\t\t * 50% chance of using a recently succeeded request, if there is one.\n\t\t\t\t * We keep a list of recently succeeded BaseSendableGet's, because transient \n\t\t\t\t * requests are chosen individually. */\n\t\t\t\tif(!isInsertScheduler) {\n\t\t\t\t\tBaseSendableGet altReq = null;\n\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\tif(!recentSuccesses.isEmpty()) {\n\t\t\t\t\t\t\tif(random.nextBoolean()) {\n\t\t\t\t\t\t\t\taltReq = recentSuccesses.poll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(altReq != null && (altReq.isCancelled())) {\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring cancelled recently succeeded item \"+altReq);\n\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t}\n\t\t\t\t\tif(altReq != null && (l = altReq.getWakeupTime(context, now)) != 0) {\n\t\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring recently succeeded item, cooldown time = \"+l+((l > 0) ? \" (\"+TimeUtil.formatTime(l - now)+\")\" : \"\"));\n\t\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (altReq != null && altReq != req) {\n\t\t\t\t\t\tint prio = altReq.getPriorityClass();\n\t\t\t\t\t\tif(prio <= choosenPriorityClass) {\n\t\t\t\t\t\t\t// Use the recent one instead\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Recently succeeded (transient) req \"+altReq+\" (prio=\"+altReq.getPriorityClass()+\") is better than \"+req+\" (prio=\"+req.getPriorityClass()+\"), using that\");\n\t\t\t\t\t\t\t// Don't need to reregister, because removeRandom doesn't actually remove!\n\t\t\t\t\t\t\treq = altReq;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Don't use the recent one\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Chosen req \"+req+\" is better, reregistering recently succeeded \"+altReq);\n\t\t\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\t\t\trecentSuccesses.add(altReq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Now we have chosen a request.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" (prio \"+\n\t\t\t\t\t\treq.getPriorityClass()+\", client \"+req.getClient()+\", client-req \"+req.getClientRequest()+ ')');\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" of \"+req.getClientRequest());\n\t\t\t\tassert(req.realTimeFlag() == realTime);\n\t\t\t\treturn new SelectorReturn(req);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"No requests to run\");\n\t\treturn null;\n\t}","id":26000,"modified_method":"/** Choose a request to run. Does not check whether the SendableRequest is actually runnable at \n\t * the moment. The cooldown mechanism on the RGAs and SRGAs should ensure that it is usable \n\t * most of the time.\n\t * @return Either a chosen request or the time at which we should try again if all priorities \n\t * are waiting for requests to finish / cooldown periods to expire. */\n\tSelectorReturn chooseRequestInner(int fuzz, RandomSource random, OfferedKeysList offeredKeys, RequestStarter starter, boolean realTime, ClientContext context, long now) {\n\t\t// Priorities start at 0\n\t\tif(logMINOR) Logger.minor(this, \"removeFirst()\");\n\t\tboolean tryOfferedKeys = offeredKeys != null && random.nextBoolean();\n\t\tif(tryOfferedKeys) {\n\t\t\tif(offeredKeys.getWakeupTime(context, now) == 0)\n\t\t\t\treturn new SelectorReturn(offeredKeys);\n\t\t}\n\t\tlong l = choosePriority(fuzz, random, context, now);\n\t\tif(l > Integer.MAX_VALUE) {\n\t\t\tif(logMINOR) Logger.minor(this, \"No priority available for the next \"+TimeUtil.formatTime(l - now));\n\t\t\treturn null;\n\t\t}\n\t\tint choosenPriorityClass = (int)l;\n\t\tif(choosenPriorityClass == -1) {\n\t\t\tif(!tryOfferedKeys) {\n\t\t\t\tif(offeredKeys != null && offeredKeys.getWakeupTime(context, now) == 0)\n\t\t\t\t\treturn new SelectorReturn(offeredKeys);\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Nothing to do\");\n\t\t\treturn null;\n\t\t}\n\t\tlong wakeupTime = Long.MAX_VALUE;\nouter:\tfor(;choosenPriorityClass <= RequestStarter.MINIMUM_FETCHABLE_PRIORITY_CLASS;choosenPriorityClass++) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Using priority \"+choosenPriorityClass);\n\t\t\tSectoredRandomGrabArray<RequestClient,SectoredRandomGrabArraySimple<RequestClient,ClientRequester>> \n\t\t\t    chosenTracker = priorities[choosenPriorityClass];\n\t\t\tif(chosenTracker == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests to run: chosen priority empty\");\n\t\t\t\tcontinue; // Try next priority\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t    long cooldownTime = chosenTracker.getWakeupTime(context, now);\n\t\t\t    if(cooldownTime > 0) {\n\t\t\t        if(cooldownTime < wakeupTime) wakeupTime = cooldownTime;\n\t\t\t        Logger.normal(this, \"Priority \"+choosenPriorityClass+\" is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t        continue outer;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Got priority tracker \"+chosenTracker);\n\t\t\t\tRemoveRandomReturn val;\n\t\t\t\tsynchronized(this) {\n\t\t\t\t    // We must hold the overall lock, just as in addToGrabArrays.\n\t\t\t\t    // This is important for keeping the cooldown tracker consistent amongst other \n\t\t\t\t    // things: We can get a race condition between thread A reading the tree, \n\t\t\t\t    // finding nothing and setCachedWakeup(), and thread B waking up a request, \n\t\t\t\t    // resulting in the request not being accessible.\n\t\t\t\t    val = chosenTracker.removeRandom(starter, context, now);\n\t\t\t\t}\n\t\t\t\tSendableRequest req;\n\t\t\t\tif(val == null) {\n\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned null - nothing to schedule, should remove priority\");\n\t\t\t\t\tcontinue outer;\n\t\t\t\t} else if(val.item == null) {\n\t\t\t\t\tif(val.wakeupTime == -1)\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned cooldown time of -1 - nothing to schedule, should remove priority\");\n\t\t\t\t\telse {\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned cooldown time of \"+(val.wakeupTime - now)+\" = \"+TimeUtil.formatTime(val.wakeupTime - now));\n\t\t\t\t\t\tif(val.wakeupTime > 0 && val.wakeupTime < wakeupTime)\n\t\t\t\t\t\t\twakeupTime = val.wakeupTime;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue outer;\n\t\t\t\t} else {\n\t\t\t\t\treq = (SendableRequest) val.item;\n\t\t\t\t}\n\t\t\t\tif(req.getPriorityClass() != choosenPriorityClass) {\n\t\t\t\t\t// Reinsert it : shouldn't happen if we are calling reregisterAll,\n\t\t\t\t\t// maybe we should ask people to report that error if seen\n\t\t\t\t\tLogger.normal(this, \"In wrong priority class: \"+req+\" (req.prio=\"+req.getPriorityClass()+\" but chosen=\"+choosenPriorityClass+ ')');\n\t\t\t\t\t// Remove it.\n\t\t\t\t\tSectoredRandomGrabArrayWithObject<RequestClient,ClientRequester,RandomGrabArrayWithClient<ClientRequester>> clientGrabber = \n\t\t\t\t\t    chosenTracker.getGrabber(req.getClient());\n\t\t\t\t\tif(clientGrabber != null) {\n\t\t\t\t\t\tRandomGrabArray baseRGA = (RandomGrabArray) clientGrabber.getGrabber(req.getClientRequest());\n\t\t\t\t\t\tif(baseRGA != null) {\n\t\t\t\t\t\t\t// Must synchronize to avoid nasty race conditions with cooldown.\n\t\t\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\t\t\tbaseRGA.remove(req, context);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Okay, it's been removed already. Cool.\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.error(this, \"Could not find client grabber for client \"+req.getClient()+\" from \"+chosenTracker);\n\t\t\t\t\t}\n\t\t\t\t\tinnerRegister(req, context, null);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check recentSuccesses\n\t\t\t\t/** Choose a recently succeeded request.\n\t\t\t\t * 50% chance of using a recently succeeded request, if there is one.\n\t\t\t\t * We keep a list of recently succeeded BaseSendableGet's, because transient \n\t\t\t\t * requests are chosen individually. */\n\t\t\t\tif(!isInsertScheduler) {\n\t\t\t\t\tBaseSendableGet altReq = null;\n\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\tif(!recentSuccesses.isEmpty()) {\n\t\t\t\t\t\t\tif(random.nextBoolean()) {\n\t\t\t\t\t\t\t\taltReq = recentSuccesses.poll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(altReq != null && (altReq.isCancelled())) {\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring cancelled recently succeeded item \"+altReq);\n\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t}\n\t\t\t\t\tif(altReq != null && (l = altReq.getWakeupTime(context, now)) != 0) {\n\t\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring recently succeeded item, cooldown time = \"+l+((l > 0) ? \" (\"+TimeUtil.formatTime(l - now)+\")\" : \"\"));\n\t\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (altReq != null && altReq != req) {\n\t\t\t\t\t\tint prio = altReq.getPriorityClass();\n\t\t\t\t\t\tif(prio <= choosenPriorityClass) {\n\t\t\t\t\t\t\t// Use the recent one instead\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Recently succeeded (transient) req \"+altReq+\" (prio=\"+altReq.getPriorityClass()+\") is better than \"+req+\" (prio=\"+req.getPriorityClass()+\"), using that\");\n\t\t\t\t\t\t\t// Don't need to reregister, because removeRandom doesn't actually remove!\n\t\t\t\t\t\t\treq = altReq;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Don't use the recent one\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Chosen req \"+req+\" is better, reregistering recently succeeded \"+altReq);\n\t\t\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\t\t\trecentSuccesses.add(altReq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Now we have chosen a request.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" (prio \"+\n\t\t\t\t\t\treq.getPriorityClass()+\", client \"+req.getClient()+\", client-req \"+req.getClientRequest()+ ')');\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" of \"+req.getClientRequest());\n\t\t\t\tassert(req.realTimeFlag() == realTime);\n\t\t\t\treturn new SelectorReturn(req);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"No requests to run\");\n\t\treturn null;\n\t}","commit_id":"77419465714e500f0c35ad6f352bbba3c609d449","url":"https://github.com/freenet/fred"},{"original_method":"private SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester> makeSRGAForClient(short priorityClass,\n            RequestClient client, ClientContext context) {\n        SectoredRandomGrabArray<RequestClient> clientGrabber = priorities[priorityClass];\n        if(clientGrabber == null) {\n            clientGrabber = new SectoredRandomGrabArray<RequestClient>(null, this);\n            priorities[priorityClass] = clientGrabber;\n            if(logMINOR) Logger.minor(this, \"Registering client tracker for priority \"+priorityClass+\" : \"+clientGrabber);\n        }\n        // Request\n        SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester> requestGrabber = (SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester>) clientGrabber.getGrabber(client);\n        if(requestGrabber == null) {\n            requestGrabber = new SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester>(client, clientGrabber, this);\n            if(logMINOR)\n                Logger.minor(this, \"Creating new grabber: \"+requestGrabber+\" for \"+client+\" from \"+clientGrabber+\" : prio=\"+priorityClass);\n            clientGrabber.addGrabber(client, requestGrabber, context);\n            clientGrabber.clearWakeupTime(context);\n        }\n        return requestGrabber;\n    }","id":26001,"modified_method":"private SectoredRandomGrabArraySimple<RequestClient,ClientRequester> makeSRGAForClient(short priorityClass,\n            RequestClient client, ClientContext context) {\n        SectoredRandomGrabArray<RequestClient,SectoredRandomGrabArraySimple<RequestClient,ClientRequester>>\n            clientGrabber = priorities[priorityClass];\n        if(clientGrabber == null) {\n            clientGrabber = new SectoredRandomGrabArray<RequestClient,SectoredRandomGrabArraySimple<RequestClient,ClientRequester>>(null, this);\n            priorities[priorityClass] = clientGrabber;\n            if(logMINOR) Logger.minor(this, \"Registering client tracker for priority \"+priorityClass+\" : \"+clientGrabber);\n        }\n        // Request\n        SectoredRandomGrabArraySimple<RequestClient,ClientRequester> requestGrabber = clientGrabber.getGrabber(client);\n        if(requestGrabber == null) {\n            requestGrabber = new SectoredRandomGrabArraySimple<RequestClient,ClientRequester>(client, clientGrabber, this);\n            if(logMINOR)\n                Logger.minor(this, \"Creating new grabber: \"+requestGrabber+\" for \"+client+\" from \"+clientGrabber+\" : prio=\"+priorityClass);\n            clientGrabber.addGrabber(client, requestGrabber, context);\n            clientGrabber.clearWakeupTime(context);\n        }\n        return requestGrabber;\n    }","commit_id":"77419465714e500f0c35ad6f352bbba3c609d449","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Put a grabber. This lets us use things other than RandomGrabArrayWithClient's, so don't mix calls\n\t * to add() with calls to getGrabber/addGrabber!\n\t */\n\tpublic void addGrabber(T client, RemoveRandomWithObject<T> requestGrabber, ClientContext context) {\n\t    synchronized(root) {\n\t\tif(requestGrabber.getObject() != client)\n\t\t\tthrow new IllegalArgumentException(\"Client not equal to RemoveRandomWithObject's client: client=\"+client+\" rr=\"+requestGrabber+\" his object=\"+requestGrabber.getObject());\n\t\taddElement(client, requestGrabber);\n\t\tif(context != null) {\n\t\t    clearWakeupTime(context);\n\t\t}\n\t    }\n\t}","id":26002,"modified_method":"/**\n\t * Put a grabber.\n\t */\n\tpublic void addGrabber(T client, C requestGrabber, ClientContext context) {\n\t    synchronized(root) {\n\t\tif(requestGrabber.getObject() != client)\n\t\t\tthrow new IllegalArgumentException(\"Client not equal to RemoveRandomWithObject's client: client=\"+client+\" rr=\"+requestGrabber+\" his object=\"+requestGrabber.getObject());\n\t\taddElement(client, requestGrabber);\n\t\tif(context != null) {\n\t\t    clearWakeupTime(context);\n\t\t}\n\t    }\n\t}","commit_id":"77419465714e500f0c35ad6f352bbba3c609d449","url":"https://github.com/freenet/fred"},{"original_method":"private RemoveRandomReturn removeRandomTwoOnly(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tClientContext context, long now) {\n\t    synchronized(root) {\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\t// Another simple common case\n\t\tint x = context.fastWeakRandom.nextBoolean() ? 1 : 0;\n\t\tRemoveRandomWithObject<T> rga = grabArrays[x];\n\t\tRemoveRandomWithObject<T> firstRGA = rga;\n\t\tif(rga == null) {\n\t\t\tLogger.error(this, \"rga = null on \"+this);\n\t\t\tif(grabArrays[1-x] == null) {\n\t\t\t\tLogger.error(this, \"other rga is also null on \"+this);\n\t\t\t\tgrabArrays = new RemoveRandomWithObject[0];\n\t\t\t\tgrabClients = (T[]) new Object[0];\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"grabArrays[\"+(1-x)+\"] is valid but [\"+x+\"] is null, correcting...\");\n\t\t\t\tgrabArrays = new RemoveRandomWithObject[] { grabArrays[1-x] };\n\t\t\t\tgrabClients = (T[]) new Object[] { grabClients[1-x] };\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tRandomGrabArrayItem item = null;\n\t\tRemoveRandomReturn val = null;\n\t\tif(logMINOR) Logger.minor(this, \"Only 2, trying \"+rga);\n\t\tlong excludeTime = rga.getWakeupTime(context, now);\n\t\tif(excludeTime > 0) {\n\t\t\twakeupTime = excludeTime;\n\t\t\trga = null;\n\t\t\tfirstRGA = null;\n\t\t} else {\n\t\t\tval = rga.removeRandom(excluding, context, now);\n\t\t\tif(val != null) {\n\t\t\t\tif(val.item != null)\n\t\t\t\t\titem = val.item;\n\t\t\t\telse {\n\t\t\t\t\tif(wakeupTime > val.wakeupTime) wakeupTime = val.wakeupTime;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(item != null) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Returning (two items only) \"+item+\" for \"+rga);\n\t\t\treturn new RemoveRandomReturn(item);\n\t\t} else {\n\t\t\tx = 1-x;\n\t\t\trga = grabArrays[x];\n\t\t\tif(rga == null) {\n\t\t\t\tLogger.error(this, \"Other RGA is null later on on \"+this);\n\t\t\t\tgrabArrays = new RemoveRandomWithObject[] { grabArrays[1-x] };\n\t\t\t\tgrabClients = (T[]) new Object[] { grabClients[1-x] };\n                reduceWakeupTime(wakeupTime, context);\n\t\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t\t}\n\t\t\texcludeTime = rga.getWakeupTime(context, now);\n\t\t\tif(excludeTime > 0) {\n\t\t\t\tif(wakeupTime > excludeTime) wakeupTime = excludeTime;\n\t\t\t\trga = null;\n\t\t\t} else {\n\t\t\t\tval = rga.removeRandom(excluding, context, now);\n\t\t\t\tif(val != null) {\n\t\t\t\t\tif(val.item != null)\n\t\t\t\t\t\titem = val.item;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(wakeupTime > val.wakeupTime) wakeupTime = val.wakeupTime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(firstRGA != null && firstRGA.isEmpty() && rga != null && rga.isEmpty()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing both on \"+this+\" : \"+firstRGA+\" and \"+rga+\" are empty\");\n\t\t\t\tgrabArrays = new RemoveRandomWithObject[0];\n\t\t\t\tgrabClients = (T[]) new Object[0];\n\t\t\t} else if(firstRGA != null && firstRGA.isEmpty()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing first: \"+firstRGA+\" is empty on \"+this);\n\t\t\t\tgrabArrays = new RemoveRandomWithObject[] { grabArrays[x] }; // don't use RGA, it may be nulled out\n\t\t\t\tgrabClients = (T[]) new Object[] { grabClients[x] };\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Returning (two items only) \"+item+\" for \"+rga);\n\t\t\tif(item == null) {\n\t\t\t\tif(grabArrays.length == 0)\n\t\t\t\t\treturn null; // Remove this as well\n                reduceWakeupTime(wakeupTime, context);\n\t\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t\t} else return new RemoveRandomReturn(item);\n\t\t}\n\t    }\n\t}","id":26003,"modified_method":"private RemoveRandomReturn removeRandomTwoOnly(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tClientContext context, long now) {\n\t    synchronized(root) {\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\t// Another simple common case\n\t\tint x = context.fastWeakRandom.nextBoolean() ? 1 : 0;\n\t\tRemoveRandomWithObject<T> rga = grabArrays[x];\n\t\tRemoveRandomWithObject<T> firstRGA = rga;\n\t\tif(rga == null) {\n\t\t\tLogger.error(this, \"rga = null on \"+this);\n\t\t\tif(grabArrays[1-x] == null) {\n\t\t\t\tLogger.error(this, \"other rga is also null on \"+this);\n\t\t\t\tgrabArrays = (C[]) new RemoveRandomWithObject[0];\n\t\t\t\tgrabClients = (T[]) new Object[0];\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"grabArrays[\"+(1-x)+\"] is valid but [\"+x+\"] is null, correcting...\");\n\t\t\t\tgrabArrays = (C[]) new RemoveRandomWithObject[] { grabArrays[1-x] };\n\t\t\t\tgrabClients = (T[]) new Object[] { grabClients[1-x] };\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tRandomGrabArrayItem item = null;\n\t\tRemoveRandomReturn val = null;\n\t\tif(logMINOR) Logger.minor(this, \"Only 2, trying \"+rga);\n\t\tlong excludeTime = rga.getWakeupTime(context, now);\n\t\tif(excludeTime > 0) {\n\t\t\twakeupTime = excludeTime;\n\t\t\trga = null;\n\t\t\tfirstRGA = null;\n\t\t} else {\n\t\t\tval = rga.removeRandom(excluding, context, now);\n\t\t\tif(val != null) {\n\t\t\t\tif(val.item != null)\n\t\t\t\t\titem = val.item;\n\t\t\t\telse {\n\t\t\t\t\tif(wakeupTime > val.wakeupTime) wakeupTime = val.wakeupTime;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(item != null) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Returning (two items only) \"+item+\" for \"+rga);\n\t\t\treturn new RemoveRandomReturn(item);\n\t\t} else {\n\t\t\tx = 1-x;\n\t\t\trga = grabArrays[x];\n\t\t\tif(rga == null) {\n\t\t\t\tLogger.error(this, \"Other RGA is null later on on \"+this);\n\t\t\t\tgrabArrays = (C[]) new RemoveRandomWithObject[] { grabArrays[1-x] };\n\t\t\t\tgrabClients = (T[]) new Object[] { grabClients[1-x] };\n                reduceWakeupTime(wakeupTime, context);\n\t\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t\t}\n\t\t\texcludeTime = rga.getWakeupTime(context, now);\n\t\t\tif(excludeTime > 0) {\n\t\t\t\tif(wakeupTime > excludeTime) wakeupTime = excludeTime;\n\t\t\t\trga = null;\n\t\t\t} else {\n\t\t\t\tval = rga.removeRandom(excluding, context, now);\n\t\t\t\tif(val != null) {\n\t\t\t\t\tif(val.item != null)\n\t\t\t\t\t\titem = val.item;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(wakeupTime > val.wakeupTime) wakeupTime = val.wakeupTime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(firstRGA != null && firstRGA.isEmpty() && rga != null && rga.isEmpty()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing both on \"+this+\" : \"+firstRGA+\" and \"+rga+\" are empty\");\n\t\t\t\tgrabArrays = (C[]) new RemoveRandomWithObject[0];\n\t\t\t\tgrabClients = (T[]) new Object[0];\n\t\t\t} else if(firstRGA != null && firstRGA.isEmpty()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing first: \"+firstRGA+\" is empty on \"+this);\n\t\t\t\tgrabArrays = (C[]) new RemoveRandomWithObject[] { grabArrays[x] }; // don't use RGA, it may be nulled out\n\t\t\t\tgrabClients = (T[]) new Object[] { grabClients[x] };\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Returning (two items only) \"+item+\" for \"+rga);\n\t\t\tif(item == null) {\n\t\t\t\tif(grabArrays.length == 0)\n\t\t\t\t\treturn null; // Remove this as well\n                reduceWakeupTime(wakeupTime, context);\n\t\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t\t} else return new RemoveRandomReturn(item);\n\t\t}\n\t    }\n\t}","commit_id":"77419465714e500f0c35ad6f352bbba3c609d449","url":"https://github.com/freenet/fred"},{"original_method":"private int haveClient(T client) {\n\t    synchronized(root) {\n\t\tfor(int i=0;i<grabClients.length;i++) {\n\t\t\tif(grabClients[i] == client) return i;\n\t\t}\n\t\treturn -1;\n\t    }\n\t}","id":26004,"modified_method":"protected int haveClient(T client) {\n\t    synchronized(root) {\n\t\tfor(int i=0;i<grabClients.length;i++) {\n\t\t\tif(grabClients[i] == client) return i;\n\t\t}\n\t\treturn -1;\n\t    }\n\t}","commit_id":"77419465714e500f0c35ad6f352bbba3c609d449","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Get a grabber. This lets us use things other than RandomGrabArrayWithClient's, so don't mix calls\n\t * to add() with calls to getGrabber/addGrabber!\n\t */\n\tpublic RemoveRandomWithObject<T> getGrabber(T client) {\n\t    synchronized(root) {\n\t\tint idx = haveClient(client);\n\t\tif(idx == -1) return null;\n\t\telse return grabArrays[idx];\n\t    }\n\t}","id":26005,"modified_method":"/**\n\t * Get a grabber.\n\t */\n\tpublic C getGrabber(T client) {\n\t    synchronized(root) {\n\t\tint idx = haveClient(client);\n\t\tif(idx == -1) return null;\n\t\telse return grabArrays[idx];\n\t    }\n\t}","commit_id":"77419465714e500f0c35ad6f352bbba3c609d449","url":"https://github.com/freenet/fred"},{"original_method":"private RemoveRandomReturn removeRandomOneOnly(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tClientContext context, long now) {\n\t    synchronized(root) {\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\t// Optimise the common case\n\t\tRemoveRandomWithObject<T> rga = grabArrays[0];\n\t\tif(logMINOR) Logger.minor(this, \"Only one RGA: \"+rga);\n\t\tlong excludeTime = rga.getWakeupTime(context, now);\n\t\tif(excludeTime > 0)\n\t\t\treturn new RemoveRandomReturn(excludeTime);\n\t\tif(rga == null) {\n\t\t\tLogger.error(this, \"Only one entry and that is null\");\n\t\t\t// We are sure\n\t\t\tgrabArrays = new RemoveRandomWithObject[0];\n\t\t\tgrabClients = (T[]) new Object[0];\n\t\t\treturn null;\n\t\t}\n\t\tRemoveRandomReturn val = rga.removeRandom(excluding, context, now);\n\t\tRandomGrabArrayItem item = null;\n\t\tif(val != null) { // val == null => remove it\n\t\t\tif(val.item != null)\n\t\t\t\titem = val.item;\n\t\t\telse {\n\t\t\t\twakeupTime = val.wakeupTime;\n\t\t\t}\n\t\t}\n\t\tif(rga.isEmpty()) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Removing only grab array (0) : \"+rga);\n\t\t\tgrabArrays = new RemoveRandomWithObject[0];\n\t\t\tgrabClients = (T[]) new Object[0];\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Returning (one item only) \"+item+\" for \"+rga);\n\t\tif(item == null) {\n\t\t\tif(grabArrays.length == 0) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Arrays are empty on \"+this);\n\t\t\t\treturn null; // Remove this as well\n\t\t\t}\n            reduceWakeupTime(wakeupTime, context);\n\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t} else return new RemoveRandomReturn(item);\n\t    }\n\t}","id":26006,"modified_method":"private RemoveRandomReturn removeRandomOneOnly(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tClientContext context, long now) {\n\t    synchronized(root) {\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\t// Optimise the common case\n\t\tRemoveRandomWithObject<T> rga = grabArrays[0];\n\t\tif(logMINOR) Logger.minor(this, \"Only one RGA: \"+rga);\n\t\tlong excludeTime = rga.getWakeupTime(context, now);\n\t\tif(excludeTime > 0)\n\t\t\treturn new RemoveRandomReturn(excludeTime);\n\t\tif(rga == null) {\n\t\t\tLogger.error(this, \"Only one entry and that is null\");\n\t\t\t// We are sure\n\t\t\tgrabArrays = (C[]) new RemoveRandomWithObject[0];\n\t\t\tgrabClients = (T[]) new Object[0];\n\t\t\treturn null;\n\t\t}\n\t\tRemoveRandomReturn val = rga.removeRandom(excluding, context, now);\n\t\tRandomGrabArrayItem item = null;\n\t\tif(val != null) { // val == null => remove it\n\t\t\tif(val.item != null)\n\t\t\t\titem = val.item;\n\t\t\telse {\n\t\t\t\twakeupTime = val.wakeupTime;\n\t\t\t}\n\t\t}\n\t\tif(rga.isEmpty()) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Removing only grab array (0) : \"+rga);\n\t\t\tgrabArrays = (C[]) new RemoveRandomWithObject[0];\n\t\t\tgrabClients = (T[]) new Object[0];\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Returning (one item only) \"+item+\" for \"+rga);\n\t\tif(item == null) {\n\t\t\tif(grabArrays.length == 0) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Arrays are empty on \"+this);\n\t\t\t\treturn null; // Remove this as well\n\t\t\t}\n            reduceWakeupTime(wakeupTime, context);\n\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t} else return new RemoveRandomReturn(item);\n\t    }\n\t}","commit_id":"77419465714e500f0c35ad6f352bbba3c609d449","url":"https://github.com/freenet/fred"},{"original_method":"public SectoredRandomGrabArray(RemoveRandomParent parent, ClientRequestSelector root) {\n\t\tgrabClients = (T[]) new Object[0];\n\t\tgrabArrays = new RemoveRandomWithObject[0];\n\t\tthis.parent = parent;\n\t\tthis.root = root;\n\t}","id":26007,"modified_method":"public SectoredRandomGrabArray(RemoveRandomParent parent, ClientRequestSelector root) {\n\t\tgrabClients = (T[]) new Object[0];\n\t\tgrabArrays = (C[]) new RemoveRandomWithObject[0];\n\t\tthis.parent = parent;\n\t\tthis.root = root;\n\t}","commit_id":"77419465714e500f0c35ad6f352bbba3c609d449","url":"https://github.com/freenet/fred"},{"original_method":"private void removeElement(int x) {\n\t    synchronized(root) {\n\t\tfinal int grabArraysLength = grabArrays.length;\n\t\tint newLen = grabArraysLength > 1 ? grabArraysLength-1 : 0;\n\t\tRemoveRandomWithObject<T>[] newArray = new RemoveRandomWithObject[newLen];\n\t\tif(x > 0)\n\t\t\tSystem.arraycopy(grabArrays, 0, newArray, 0, x);\n\t\tif(x < grabArraysLength-1)\n\t\t\tSystem.arraycopy(grabArrays, x+1, newArray, x, grabArraysLength - (x+1));\n\t\tgrabArrays = newArray;\n\t\t\n\t\tObject[] newClients = new Object[newLen];\n\t\tif(x > 0)\n\t\t\tSystem.arraycopy(grabClients, 0, newClients, 0, x);\n\t\tif(x < grabArraysLength-1)\n\t\t\tSystem.arraycopy(grabClients, x+1, newClients, x, grabArraysLength - (x+1));\n\t\tgrabClients = (T[]) newClients;\n\t    }\n\t}","id":26008,"modified_method":"private void removeElement(int x) {\n\t    synchronized(root) {\n\t\tfinal int grabArraysLength = grabArrays.length;\n\t\tint newLen = grabArraysLength > 1 ? grabArraysLength-1 : 0;\n\t\tC[] newArray = (C[]) new RemoveRandomWithObject[newLen];\n\t\tif(x > 0)\n\t\t\tSystem.arraycopy(grabArrays, 0, newArray, 0, x);\n\t\tif(x < grabArraysLength-1)\n\t\t\tSystem.arraycopy(grabArrays, x+1, newArray, x, grabArraysLength - (x+1));\n\t\tgrabArrays = newArray;\n\t\t\n\t\tObject[] newClients = new Object[newLen];\n\t\tif(x > 0)\n\t\t\tSystem.arraycopy(grabClients, 0, newClients, 0, x);\n\t\tif(x < grabArraysLength-1)\n\t\t\tSystem.arraycopy(grabClients, x+1, newClients, x, grabArraysLength - (x+1));\n\t\tgrabClients = (T[]) newClients;\n\t    }\n\t}","commit_id":"77419465714e500f0c35ad6f352bbba3c609d449","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public void initialize(Configuration configuration) {\n        this.pluginConfig = configuration;\n    }","id":26009,"modified_method":"@Override\n    public void initialize(Configuration configuration) {\n        this.pluginConfig = configuration;\n        super.initialize(configuration);\n    }","commit_id":"4ef19d35e4a2939972e75704a8850bbbaaa9158a","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void initialize(org.graylog2.plugin.configuration.Configuration configuration) {\n    }","id":26010,"modified_method":"@Override\n    public void initialize(org.graylog2.plugin.configuration.Configuration configuration) {\n        this.pluginConfig = configuration;\n    }","commit_id":"4ef19d35e4a2939972e75704a8850bbbaaa9158a","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void sendEmail(String emailAddress, Stream stream, AlertCondition.CheckResult checkResult, List<Message> backlog) throws TransportConfigurationException, EmailException {\n        LOG.debug(\"Sending mail to \" + emailAddress);\n        if(!configuration.isEnabled()) {\n            throw new TransportConfigurationException(\"Email transport is not enabled in server configuration file!\");\n        }\n\n        final Email email = new SimpleEmail();\n        email.setHostName(configuration.getHostname());\n        email.setSmtpPort(configuration.getPort());\n        if (configuration.isUseSsl()) {\n            email.setSslSmtpPort(Integer.toString(configuration.getPort()));\n        }\n\n        if(configuration.isUseAuth()) {\n            email.setAuthenticator(new DefaultAuthenticator(\n                    configuration.getUsername(),\n                    configuration.getPassword()\n            ));\n        }\n\n        email.setSSLOnConnect(configuration.isUseSsl());\n        email.setStartTLSEnabled(configuration.isUseTls());\n        email.setFrom(configuration.getFromEmail());\n        email.setSubject(buildSubject(stream, checkResult, backlog));\n        email.setMsg(buildBody(stream, checkResult, backlog));\n        email.addTo(emailAddress);\n\n        email.send();\n    }","id":26011,"modified_method":"private void sendEmail(String emailAddress, Stream stream, AlertCondition.CheckResult checkResult, List<Message> backlog) throws TransportConfigurationException, EmailException {\n        LOG.debug(\"Sending mail to \" + emailAddress);\n        if(!configuration.isEnabled()) {\n            throw new TransportConfigurationException(\"Email transport is not enabled in server configuration file!\");\n        }\n\n        final Email email = new SimpleEmail();\n        if (Strings.isNullOrEmpty(configuration.getHostname())) {\n            throw new TransportConfigurationException(\"No hostname configured for email transport while trying to send alert email!\");\n        } else {\n            email.setHostName(configuration.getHostname());\n        }\n        email.setSmtpPort(configuration.getPort());\n        if (configuration.isUseSsl()) {\n            email.setSslSmtpPort(Integer.toString(configuration.getPort()));\n        }\n\n        if(configuration.isUseAuth()) {\n            email.setAuthenticator(new DefaultAuthenticator(\n                    Strings.nullToEmpty(configuration.getUsername()),\n                    Strings.nullToEmpty(configuration.getPassword())\n            ));\n        }\n\n        email.setSSLOnConnect(configuration.isUseSsl());\n        email.setStartTLSEnabled(configuration.isUseTls());\n        if (!Strings.isNullOrEmpty(pluginConfig.getString(\"sender\"))) {\n            email.setFrom(pluginConfig.getString(\"sender\"));\n        } else {\n            email.setFrom(configuration.getFromEmail());\n        }\n        email.setSubject(buildSubject(stream, checkResult, backlog));\n        email.setMsg(buildBody(stream, checkResult, backlog));\n        email.addTo(emailAddress);\n\n        email.send();\n    }","commit_id":"4ef19d35e4a2939972e75704a8850bbbaaa9158a","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * <p>reloadConfiguration<\/p>\n     * \n     * Triggers a reload of the Javamail delivery service's configuration\n     */\n    public void reloadConfiguration() {\n        m_JavamailConfigDao.reloadConfiguration();\n    }","id":26012,"modified_method":"public void reloadConfiguration() {\n        m_JavamailConfigDao.reloadConfiguration();\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} \n     * @throws ReportDeliveryException */\n    @Override\n    public void deliverReport(Report report, String fileName) throws ReportDeliveryException {\n        try {\n\n            JavaSendMailer sm = null;\n            String mailer = report.getMailer();\n            LOG.debug(\"deliverReport with mailer={}\", mailer);\n            if (mailer != null && mailer.length() > 0) {\n                sm = new JavaSendMailer(m_JavamailConfigDao.getSendMailConfig(mailer));\n            } else {\n                sm = new JavaSendMailer(m_JavamailConfigDao.getDefaultSendmailConfig());\n            }\n            MimeMessageHelper helper = new MimeMessageHelper(sm.getMessage().getMimeMessage(),true);\n                \n            helper.setTo(report.getRecipient());\n            helper.setSubject(\"OpenNMS Report: \" + report.getReportName());\n            helper.setText(\"OpenNMS Report: \"); // FIXME: sm.send() will override this.\n                \n            helper.addAttachment(fileName, new File(fileName));\n                \n            sm.setMessage(new MimeMailMessage(helper));\n            sm.send();\n\n        } catch (JavaMailerException e) {\n            LOG.error(\"Problem with JavaMailer {}\", e.getMessage(), e);\n            throw new ReportDeliveryException(\"Caught JavaMailerException: \" + e.getMessage());\n        } catch (MessagingException e) {\n            LOG.error(\"Problem with Messaging {}\", e.getMessage(), e);\n            throw new ReportDeliveryException(\"Caught MessagingException: \" + e.getMessage());\n        } catch (Throwable e) {\n            LOG.error(\"Unexpected exception: {}\",e.getMessage(), e);\n            throw new ReportDeliveryException(\"Caught unexpected \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        \n    }","id":26013,"modified_method":"@Override\n    public void deliverReport(Report report, String fileName) throws ReportDeliveryException {\n        try {\n\n            String mailer = report.getMailer();\n            LOG.debug(\"deliverReport with mailer={}\", mailer);\n            SendmailConfig config = null;\n            if (mailer != null && mailer.length() > 0) {\n                config = m_JavamailConfigDao.getSendMailConfig(mailer);\n            } else {\n                config = m_JavamailConfigDao.getDefaultSendmailConfig();\n            }\n            JavaSendMailer sm = new JavaSendMailer(config);\n            MimeMessage msg = new MimeMessage(sm.getSession());\n            MimeMessageHelper helper = new MimeMessageHelper(msg, true, config.getSendmailProtocol().getCharSet());\n            helper.setFrom(config.getSendmailMessage().getFrom());\n            helper.setTo(report.getRecipient());\n            helper.setSubject(\"OpenNMS Report: \" + report.getReportName());\n            if (\"text/html\".equals(config.getSendmailProtocol().getMessageContentType().toLowerCase())) {\n                helper.setText(config.getSendmailMessage().getBody().replaceAll(\"\\\\<[^>]*>\",\"\"), config.getSendmailMessage().getBody());\n            } else {\n                helper.setText(config.getSendmailMessage().getBody());\n            }\n            helper.addAttachment(fileName, new File(fileName));\n            sm.send(msg);\n\n        } catch (JavaMailerException e) {\n            LOG.error(\"Problem with JavaMailer {}\", e.getMessage(), e);\n            throw new ReportDeliveryException(\"Caught JavaMailerException: \" + e.getMessage());\n        } catch (MessagingException e) {\n            LOG.error(\"Problem with Messaging {}\", e.getMessage(), e);\n            throw new ReportDeliveryException(\"Caught MessagingException: \" + e.getMessage());\n        } catch (Throwable e) {\n            LOG.error(\"Unexpected exception: {}\",e.getMessage(), e);\n            throw new ReportDeliveryException(\"Caught unexpected \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>setJavamailConfigDao<\/p>\n     *\n     * @param javamailConfigDao a {@link org.opennms.netmgt.dao.api.JavaMailConfigurationDao} object.\n     */\n    public void setJavamailConfigDao(JavaMailConfigurationDao javamailConfigDao) {\n        m_JavamailConfigDao = javamailConfigDao;\n    }","id":26014,"modified_method":"/**\n     * Sets the JavaMail configuration DAO.\n     *\n     * @param javamailConfigDao the new JavaMail configuration DAO\n     */\n    public void setJavamailConfigDao(JavaMailConfigurationDao javamailConfigDao) {\n        m_JavamailConfigDao = javamailConfigDao;\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>getJavamailConfigDao<\/p>\n     *\n     * @return a {@link org.opennms.netmgt.dao.api.JavaMailConfigurationDao} object.\n     */\n    public JavaMailConfigurationDao getJavamailConfigDao() {\n        return m_JavamailConfigDao;\n    }","id":26015,"modified_method":"/**\n     * Gets the JavaMail configuration DAO.\n     *\n     * @return the JavaMail configuration DAO\n     */\n    public JavaMailConfigurationDao getJavamailConfigDao() {\n        return m_JavamailConfigDao;\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method uses a properties file reader to pull in opennms styled javamail properties and sets\n     * the actual javamail properties.  This is here to preserve the backwards compatibility but configuration\n     * will probably change soon.\n     * \n     * FIXME definitely will change soon, will be deprecated\n     * \n     * @throws IOException\n     */    \n    private void configureProperties(Properties sendmailConfigDefinedProps, boolean useJmProps) {\n        \n        //this loads the properties from the old style javamail-configuration.properties\n        //TODO: deprecate this\n        Properties props = null;\n        try {\n            props = JavaMailerConfig.getProperties();\n            \n            /* These strange properties from javamail-configuration.properties need to be translated into actual javax.mail properties\n             * FIXME: The precedence of the properties file vs. the SendmailConfiguration should probably be addressed here\n             * FIXME: if using a valid sendmail config, it probably doesn't make sense to use any of these properties\n             */\n            if (useJmProps) {\n                m_config.setDebug(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.debug\", m_config.isDebug()));\n                m_config.getSendmailHost().setHost(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.mailHost\", m_config.getSendmailHost().getHost()));\n                m_config.setUseJmta(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.useJMTA\", m_config.isUseJmta()));\n                m_config.getSendmailProtocol().setMailer(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.mailer\", m_config.getSendmailProtocol().getMailer()));\n                m_config.getSendmailProtocol().setTransport(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.transport\", m_config.getSendmailProtocol().getTransport()));\n                m_config.getSendmailMessage().setFrom(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.fromAddress\", m_config.getSendmailMessage().getFrom()));\n                m_config.setUseAuthentication(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.authenticate\", m_config.isUseAuthentication()));\n                m_config.getUserAuth().setUserName(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.authenticateUser\", m_config.getUserAuth().getUserName()));\n                m_config.getUserAuth().setPassword(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.authenticatePassword\", m_config.getUserAuth().getPassword()));\n                m_config.getSendmailProtocol().setMessageContentType(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.messageContentType\", m_config.getSendmailProtocol().getMessageContentType()));\n                m_config.getSendmailProtocol().setCharSet(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.charset\", m_config.getSendmailProtocol().getCharSet()));\n                m_config.getSendmailProtocol().setMessageEncoding(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.encoding\", m_config.getSendmailProtocol().getMessageEncoding()));\n                m_config.getSendmailProtocol().setStartTls(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.starttls.enable\", m_config.getSendmailProtocol().isStartTls()));\n                m_config.getSendmailProtocol().setQuitWait(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.quitwait\", m_config.getSendmailProtocol().isQuitWait()));\n                m_config.getSendmailHost().setPort(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.smtpport\", m_config.getSendmailHost().getPort()));\n                m_config.getSendmailProtocol().setSslEnable(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.smtpssl.enable\", m_config.getSendmailProtocol().isSslEnable()));\n            }\n        } catch (IOException e) {\n            LOG.info(\"configureProperties: could not load javamail.properties, continuing for is no longer required\", e);\n        }\n        \n        //this sets any javamail properties that were set in the SendmailConfig object\n        if (props == null) {\n            props = new Properties();\n        }\n        \n        props.putAll(sendmailConfigDefinedProps);\n        \n        if (!props.containsKey(\"mail.smtp.auth\")) {\n            props.setProperty(\"mail.smtp.auth\", String.valueOf(m_config.isUseAuthentication()));\n        }\n        if (!props.containsKey(\"mail.smtp.starttls.enable\")) {\n            props.setProperty(\"mail.smtp.starttls.enable\", String.valueOf(m_config.getSendmailProtocol().isStartTls()));\n        }\n        if (!props.containsKey(\"mail.smtp.quitwait\")) {\n            props.setProperty(\"mail.smtp.quitwait\", String.valueOf(m_config.getSendmailProtocol().isQuitWait()));\n        }\n        if (!props.containsKey(\"mail.smtp.port\")) {\n            props.setProperty(\"mail.smtp.port\", String.valueOf(m_config.getSendmailHost().getPort()));\n        }\n        if (m_config.getSendmailProtocol().isSslEnable()) {\n            if (!props.containsKey(\"mail.smtps.auth\")) {\n                props.setProperty(\"mail.smtps.auth\", String.valueOf(m_config.isUseAuthentication()));\n            }\n            if (!props.containsKey(\"mail.smtps.socketFactory.class\")) {\n                props.setProperty(\"mail.smtps.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\");\n            }\n            if (!props.containsKey(\"mail.smtps.socketFactory.port\")) {\n                props.setProperty(\"mail.smtps.socketFactory.port\", String.valueOf(m_config.getSendmailHost().getPort()));\n            }\n        }\n        \n        if (!props.containsKey(\"mail.smtp.quitwait\")) {\n            props.setProperty(\"mail.smtp.quitwait\", String.valueOf(m_config.getSendmailProtocol().isQuitWait()));\n        }\n        \n    }","id":26016,"modified_method":"/**\n     * Configure properties.\n     * <p>This method uses a properties file reader to pull in opennms styled javamail properties and sets\n     * the actual javamail properties.  This is here to preserve the backwards compatibility but configuration\n     * will probably change soon.<\/p>\n     * <p>FIXME definitely will change soon, will be deprecated.<\/p>\n     *\n     * @param sendmailConfigDefinedProps the sendmail configuration defined properties\n     * @param useJmProps a boolean representing the handling of the deprecated javamail-configuration.properties file.\n     */\n    private void configureProperties(Properties sendmailConfigDefinedProps, boolean useJmProps) {\n\n        //this loads the properties from the old style javamail-configuration.properties\n        //TODO: deprecate this\n        Properties props = null;\n        try {\n            props = JavaMailerConfig.getProperties();\n\n            /* These strange properties from javamail-configuration.properties need to be translated into actual javax.mail properties\n             * FIXME: The precedence of the properties file vs. the SendmailConfiguration should probably be addressed here\n             * FIXME: if using a valid sendmail config, it probably doesn't make sense to use any of these properties\n             */\n            if (useJmProps) {\n                m_config.setDebug(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.debug\", m_config.isDebug()));\n                m_config.getSendmailHost().setHost(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.mailHost\", m_config.getSendmailHost().getHost()));\n                m_config.setUseJmta(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.useJMTA\", m_config.isUseJmta()));\n                m_config.getSendmailProtocol().setMailer(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.mailer\", m_config.getSendmailProtocol().getMailer()));\n                m_config.getSendmailProtocol().setTransport(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.transport\", m_config.getSendmailProtocol().getTransport()));\n                m_config.getSendmailMessage().setFrom(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.fromAddress\", m_config.getSendmailMessage().getFrom()));\n                m_config.setUseAuthentication(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.authenticate\", m_config.isUseAuthentication()));\n                m_config.getUserAuth().setUserName(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.authenticateUser\", m_config.getUserAuth().getUserName()));\n                m_config.getUserAuth().setPassword(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.authenticatePassword\", m_config.getUserAuth().getPassword()));\n                m_config.getSendmailProtocol().setMessageContentType(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.messageContentType\", m_config.getSendmailProtocol().getMessageContentType()));\n                m_config.getSendmailProtocol().setCharSet(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.charset\", m_config.getSendmailProtocol().getCharSet()));\n                m_config.getSendmailProtocol().setMessageEncoding(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.encoding\", m_config.getSendmailProtocol().getMessageEncoding()));\n                m_config.getSendmailProtocol().setStartTls(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.starttls.enable\", m_config.getSendmailProtocol().isStartTls()));\n                m_config.getSendmailProtocol().setQuitWait(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.quitwait\", m_config.getSendmailProtocol().isQuitWait()));\n                m_config.getSendmailHost().setPort(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.smtpport\", m_config.getSendmailHost().getPort()));\n                m_config.getSendmailProtocol().setSslEnable(PropertiesUtils.getProperty(props, \"org.opennms.core.utils.smtpssl.enable\", m_config.getSendmailProtocol().isSslEnable()));\n            }\n        } catch (IOException e) {\n            LOG.info(\"configureProperties: could not load javamail.properties, continuing for is no longer required\", e);\n        }\n\n        //this sets any javamail properties that were set in the SendmailConfig object\n        if (props == null) {\n            props = new Properties();\n        }\n\n        props.putAll(sendmailConfigDefinedProps);\n\n        if (!props.containsKey(\"mail.smtp.auth\")) {\n            props.setProperty(\"mail.smtp.auth\", String.valueOf(m_config.isUseAuthentication()));\n        }\n        if (!props.containsKey(\"mail.smtp.starttls.enable\")) {\n            props.setProperty(\"mail.smtp.starttls.enable\", String.valueOf(m_config.getSendmailProtocol().isStartTls()));\n        }\n        if (!props.containsKey(\"mail.smtp.quitwait\")) {\n            props.setProperty(\"mail.smtp.quitwait\", String.valueOf(m_config.getSendmailProtocol().isQuitWait()));\n        }\n        if (!props.containsKey(\"mail.smtp.port\")) {\n            props.setProperty(\"mail.smtp.port\", String.valueOf(m_config.getSendmailHost().getPort()));\n        }\n        if (m_config.getSendmailProtocol().isSslEnable()) {\n            if (!props.containsKey(\"mail.smtps.auth\")) {\n                props.setProperty(\"mail.smtps.auth\", String.valueOf(m_config.isUseAuthentication()));\n            }\n            if (!props.containsKey(\"mail.smtps.socketFactory.class\")) {\n                props.setProperty(\"mail.smtps.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\");\n            }\n            if (!props.containsKey(\"mail.smtps.socketFactory.port\")) {\n                props.setProperty(\"mail.smtps.socketFactory.port\", String.valueOf(m_config.getSendmailHost().getPort()));\n            }\n        }\n\n        if (!props.containsKey(\"mail.smtp.quitwait\")) {\n            props.setProperty(\"mail.smtp.quitwait\", String.valueOf(m_config.getSendmailProtocol().isQuitWait()));\n        }\n\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>getConfig<\/p>\n     *\n     * @return a {@link org.opennms.netmgt.config.javamail.SendmailConfig} object.\n     */\n    public SendmailConfig getConfig() {\n        return m_config;\n    }","id":26017,"modified_method":"/**\n     * Gets the sendmail configuration.\n     *\n     * @return the sendmail configuration\n     */\n    public SendmailConfig getConfig() {\n        return m_config;\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>buildMimeMessage<\/p>\n     *\n     * @param msg a {@link org.opennms.netmgt.config.javamail.SendmailMessage} object.\n     * @return a {@link org.springframework.mail.javamail.MimeMailMessage} object.\n     */\n    public MimeMailMessage buildMimeMessage(SendmailMessage msg) {\n        //no need to set the same object again\n        if (m_config.getSendmailMessage() != msg) {\n            m_config.setSendmailMessage(msg);\n        }\n        MimeMailMessage mimeMsg = new MimeMailMessage(new MimeMessage(m_session));\n        mimeMsg.setFrom(m_config.getSendmailMessage().getFrom());\n        mimeMsg.setTo(m_config.getSendmailMessage().getTo());\n        mimeMsg.setSubject(m_config.getSendmailMessage().getSubject());\n        return mimeMsg;\n    }","id":26018,"modified_method":"/**\n     * Builds the mime message.\n     *\n     * @param msg the sendmail message\n     * @return the mime message\n     */\n    public MimeMessage buildMimeMessage(SendmailMessage msg) {\n        //no need to set the same object again\n        if (m_config.getSendmailMessage() != msg) {\n            m_config.setSendmailMessage(msg);\n        }\n        MimeMessage mimeMsg = new MimeMessage(m_session);\n        try {\n            MimeMessageHelper helper = new MimeMessageHelper(mimeMsg, false, m_config.getSendmailProtocol().getCharSet());\n            helper.setFrom(m_config.getSendmailMessage().getFrom());\n            helper.setTo(m_config.getSendmailMessage().getTo());\n            helper.setSubject(m_config.getSendmailMessage().getSubject());\n        } catch (MessagingException e) {\n            LOG.warn(\"found a problem building message: {}\", e.getMessage());\n        }\n        return mimeMsg;\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>getProperties<\/p>\n     *\n     * @return a {@link java.util.Properties} object.\n     */\n    public Properties getProperties() {\n        return m_properties;\n    }","id":26019,"modified_method":"/**\n     * Gets the properties.\n     *\n     * @return the properties\n     */\n    public Properties getProperties() {\n        return m_properties;\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Properties generatePropsFromConfig(List<JavamailProperty> javamailPropertyCollection) {\n        Properties props = new Properties();\n        for (JavamailProperty property : javamailPropertyCollection) {\n            props.put(property.getName(), property.getValue());\n        }\n        return props;\n    }","id":26020,"modified_method":"/**\n     * Generate props from configuration.\n     *\n     * @param javamailPropertyCollection the javamail property collection\n     * @return the properties\n     */\n    private Properties generatePropsFromConfig(List<JavamailProperty> javamailPropertyCollection) {\n        Properties props = new Properties();\n        for (JavamailProperty property : javamailPropertyCollection) {\n            props.put(property.getName(), property.getValue());\n        }\n        return props;\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>send<\/p>\n     *\n     * @throws org.opennms.javamail.JavaMailerException if any.\n     */\n    public void send() throws JavaMailerException {\n        m_message.setText(m_config.getSendmailMessage().getBody());\n        send(m_message);\n    }","id":26021,"modified_method":"/**\n     * Send.\n     *\n     * @throws JavaMailerException the java mailer exception\n     */\n    public void send() throws JavaMailerException {\n        try {\n            if (\"text/plain\".equals(m_config.getSendmailProtocol().getMessageContentType().toLowerCase())) {\n                m_message.setText(m_config.getSendmailMessage().getBody());\n            } else {\n                m_message.setContent(m_config.getSendmailMessage().getBody(), m_config.getSendmailProtocol().getMessageContentType());\n            }\n        } catch (MessagingException e) {\n            LOG.error(\"Java Mailer messaging exception: {}\", e, e);\n            throw new JavaMailerException(\"Java Mailer messaging exception: \" + e, e);\n        }\n        send(m_message);\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Using this constructor implies overriding sendmail configuration with properties\n     * from the deprecated javamail-configuration.properties file.\n     *\n     * @param config a {@link org.opennms.netmgt.config.javamail.SendmailConfig} object.\n     * @throws org.opennms.javamail.JavaMailerException if any.\n     */\n    public JavaSendMailer(SendmailConfig config) throws JavaMailerException {\n        this(config, true);\n    }","id":26022,"modified_method":"/**\n     * Instantiates a new java send mailer.\n     * <p>Using this constructor implies overriding sendmail configuration with properties\n     * from the deprecated javamail-configuration.properties file.<\/p>\n     *\n     * @param config the sendmail configuration\n     * @throws JavaMailerException the java mailer exception\n     */\n    public JavaSendMailer(SendmailConfig config) throws JavaMailerException {\n        this(config, true);\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>setProperties<\/p>\n     *\n     * @param properties a {@link java.util.Properties} object.\n     */\n    public void setProperties(Properties properties) {\n        m_properties = properties;\n    }","id":26023,"modified_method":"/**\n     * Sets the properties.\n     *\n     * @param properties the new properties\n     */\n    public void setProperties(Properties properties) {\n        m_properties = properties;\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Properties createProps(boolean useJmProps) throws IOException {\n        \n        Properties props = generatePropsFromConfig(m_config.getJavamailPropertyCollection());\n        configureProperties(props, useJmProps);\n        \n        //get rid of this\n        return Session.getDefaultInstance(new Properties()).getProperties();\n    }","id":26024,"modified_method":"/**\n     * Creates the props.\n     *\n     * @param useJmProps a boolean representing the handling of the deprecated javamail-configuration.properties file.\n     * @return the properties\n     * @throws IOException Signals that an I/O exception has occurred.\n     */\n    private Properties createProps(boolean useJmProps) throws IOException {\n\n        Properties props = generatePropsFromConfig(m_config.getJavamailPropertyCollection());\n        configureProperties(props, useJmProps);\n\n        //get rid of this\n        return Session.getDefaultInstance(new Properties()).getProperties();\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>setConfig<\/p>\n     *\n     * @param config a {@link org.opennms.netmgt.config.javamail.SendmailConfig} object.\n     */\n    public void setConfig(SendmailConfig config) {\n        m_config = config;\n    }","id":26025,"modified_method":"/**\n     * Sets the sendmail configuration.\n     *\n     * @param config the new sendmail configuration\n     */\n    public void setConfig(SendmailConfig config) {\n        m_config = config;\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Helper method to create an Authenticator based on Password Authentication\n     *\n     * @return a {@link javax.mail.Authenticator} object.\n     */\n    public Authenticator createAuthenticator() {\n        Authenticator auth;\n        if (m_config.isUseAuthentication()) {\n            auth = new Authenticator() {\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(m_config.getUserAuth().getUserName(), m_config.getUserAuth().getPassword());\n                }\n            };\n        } else {\n            auth = null;\n        }\n        return auth;\n    }","id":26026,"modified_method":"/**\n     * Creates the authenticator.\n     *\n     * @return the authenticator\n     */\n    public Authenticator createAuthenticator() {\n        Authenticator auth;\n        if (m_config.isUseAuthentication()) {\n            auth = new Authenticator() {\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(m_config.getUserAuth().getUserName(), m_config.getUserAuth().getPassword());\n                }\n            };\n        } else {\n            auth = null;\n        }\n        return auth;\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>getMessage<\/p>\n     *\n     * @return a {@link org.springframework.mail.javamail.MimeMailMessage} object.\n     */\n    public MimeMailMessage getMessage() {\n        return m_message;\n    }","id":26027,"modified_method":"/**\n     * Gets the message.\n     *\n     * @return the message\n     */\n    public MimeMessage getMessage() {\n        return m_message;\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void send(MimeMailMessage message) throws JavaMailerException {\n        Transport t = null;\n        try {\n            SendmailProtocol protoConfig = m_config.getSendmailProtocol();\n            t = m_session.getTransport(protoConfig.getTransport());\n            LOG.debug(\"for transport name '{}' got: {}@{}\", protoConfig.getTransport(), t.getClass().getName(), Integer.toHexString(t.hashCode()));\n\n            LoggingTransportListener listener = new LoggingTransportListener();\n            t.addTransportListener(listener);\n\n            if (t.getURLName().getProtocol().equals(\"mta\")) {\n                // JMTA throws an AuthenticationFailedException if we call connect()\n                LOG.debug(\"transport is 'mta', not trying to connect()\");\n            } else if (m_config.isUseAuthentication()) {\n                LOG.debug(\"authenticating to {}\", m_config.getSendmailHost().getHost());\n                t.connect(m_config.getSendmailHost().getHost(), m_config.getSendmailHost().getPort(), m_config.getUserAuth().getUserName(), m_config.getUserAuth().getPassword());\n            } else {\n                LOG.debug(\"not authenticating to {}\", m_config.getSendmailHost().getHost());\n                t.connect(m_config.getSendmailHost().getHost(), m_config.getSendmailHost().getPort(), null, null);\n            }\n\n            t.sendMessage(message.getMimeMessage(), message.getMimeMessage().getAllRecipients());\n            listener.assertAllMessagesDelivered();\n        } catch (NoSuchProviderException e) {\n            LOG.error(\"Couldn't get a transport: {}\", e, e);\n            throw new JavaMailerException(\"Couldn't get a transport: \" + e, e);\n        } catch (MessagingException e) {\n            LOG.error(\"Java Mailer messaging exception: {}\", e, e);\n            throw new JavaMailerException(\"Java Mailer messaging exception: \" + e, e);\n        } finally {\n            try {\n                if (t != null && t.isConnected()) {\n                    t.close();\n                }\n            } catch (MessagingException e) {\n                throw new JavaMailerException(\"Java Mailer messaging exception on transport close: \" + e, e);\n            }\n        }\n    }","id":26028,"modified_method":"/**\n     * Send.\n     *\n     * @param message the message\n     * @throws JavaMailerException the java mailer exception\n     */\n    public void send(MimeMessage message) throws JavaMailerException {\n        Transport t = null;\n        try {\n            SendmailProtocol protoConfig = m_config.getSendmailProtocol();\n            t = m_session.getTransport(protoConfig.getTransport());\n            LOG.debug(\"for transport name '{}' got: {}@{}\", protoConfig.getTransport(), t.getClass().getName(), Integer.toHexString(t.hashCode()));\n\n            LoggingTransportListener listener = new LoggingTransportListener();\n            t.addTransportListener(listener);\n\n            if (t.getURLName().getProtocol().equals(\"mta\")) {\n                // JMTA throws an AuthenticationFailedException if we call connect()\n                LOG.debug(\"transport is 'mta', not trying to connect()\");\n            } else if (m_config.isUseAuthentication()) {\n                LOG.debug(\"authenticating to {}\", m_config.getSendmailHost().getHost());\n                t.connect(m_config.getSendmailHost().getHost(), m_config.getSendmailHost().getPort(), m_config.getUserAuth().getUserName(), m_config.getUserAuth().getPassword());\n            } else {\n                LOG.debug(\"not authenticating to {}\", m_config.getSendmailHost().getHost());\n                t.connect(m_config.getSendmailHost().getHost(), m_config.getSendmailHost().getPort(), null, null);\n            }\n\n            t.sendMessage(message, message.getAllRecipients());\n            listener.assertAllMessagesDelivered();\n        } catch (NoSuchProviderException e) {\n            LOG.error(\"Couldn't get a transport: {}\", e, e);\n            throw new JavaMailerException(\"Couldn't get a transport: \" + e, e);\n        } catch (MessagingException e) {\n            LOG.error(\"Java Mailer messaging exception: {}\", e, e);\n            throw new JavaMailerException(\"Java Mailer messaging exception: \" + e, e);\n        } finally {\n            try {\n                if (t != null && t.isConnected()) {\n                    t.close();\n                }\n            } catch (MessagingException e) {\n                throw new JavaMailerException(\"Java Mailer messaging exception on transport close: \" + e, e);\n            }\n        }\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>setMessage<\/p>\n     *\n     * @param message a {@link org.springframework.mail.javamail.MimeMailMessage} object.\n     */\n    public void setMessage(MimeMailMessage message) {\n        m_message = message;\n    }","id":26029,"modified_method":"/**\n     * Sets the message.\n     *\n     * @param message the new message\n     */\n    public void setMessage(MimeMessage message) {\n        m_message = message;\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructs everything required to call send()\n     *\n     * @param config\n     *     SendmailConfig\n     * @param useJmProps\n     *     A boolean representing the handling of the deprecated javamail-configuration.properties file.\n     * @throws org.opennms.javamail.JavaMailerException if any.\n     */\n    public JavaSendMailer(SendmailConfig config, boolean useJmProps) throws JavaMailerException {\n        m_config = config;\n        try {\n            m_session = Session.getInstance(createProps(useJmProps), createAuthenticator());\n            m_message = buildMimeMessage(config.getSendmailMessage());\n            if (m_config.isDebug()) {\n                m_session.setDebugOut(new PrintStream(new LoggingByteArrayOutputStream()));\n            }\n            m_session.setDebug(m_config.isDebug());\n\n        } catch (IOException e) {\n            throw new JavaMailerException(\"IO problem creating session\", e);\n        }\n    }","id":26030,"modified_method":"/**\n     * Instantiates a new java send mailer.\n     * <p>Constructs everything required to call send().<\/p>\n     *\n     * @param config the sendmail configuration\n     * @param useJmProps a boolean representing the handling of the deprecated javamail-configuration.properties file.\n     * @throws JavaMailerException the java mailer exception\n     */\n    public JavaSendMailer(SendmailConfig config, boolean useJmProps) throws JavaMailerException {\n        m_config = config;\n        try {\n            m_session = Session.getInstance(createProps(useJmProps), createAuthenticator());\n            m_message = buildMimeMessage(config.getSendmailMessage());\n            if (m_config.isDebug()) {\n                m_session.setDebugOut(new PrintStream(new LoggingByteArrayOutputStream()));\n            }\n            m_session.setDebug(m_config.isDebug());\n\n        } catch (IOException e) {\n            throw new JavaMailerException(\"IO problem creating session\", e);\n        }\n    }","commit_id":"15f2eb79d9315857a92cf90ce47372c041b31394","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public FloodfillNetworkDatabaseFacade(RouterContext context) {\n        super(context);\n        _activeFloodQueries = new HashMap<Hash, FloodSearchJob>();\n         _verifiesInProgress = new ConcurrentHashSet<Hash>(8);\n\n        _context.statManager().createRequiredRateStat(\"netDb.successTime\", \"Time for successful lookup (ms)\", \"NetworkDatabase\", new long[] { 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.failedTime\", \"How long a failed search takes\", \"NetworkDatabase\", new long[] { 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.failedRetries\", \"How many additional queries for an iterative search\", \"NetworkDatabase\", new long[] { 60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.successRetries\", \"How many additional queries for an iterative search\", \"NetworkDatabase\", new long[] { 60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.failedAttemptedPeers\", \"How many peers we sent a search to when the search fails\", \"NetworkDatabase\", new long[] { 10*60*1000l });\n        _context.statManager().createRateStat(\"netDb.successPeers\", \"How many peers are contacted in a successful search\", \"NetworkDatabase\", new long[] { 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.failedPeers\", \"How many peers fail to respond to a lookup?\", \"NetworkDatabase\", new long[] { 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.searchCount\", \"Overall number of searches sent\", \"NetworkDatabase\", new long[] { 5*60*1000l, 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.searchMessageCount\", \"Overall number of mesages for all searches sent\", \"NetworkDatabase\", new long[] { 5*60*1000l, 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.searchReplyValidated\", \"How many search replies we get that we are able to validate (fetch)\", \"NetworkDatabase\", new long[] { 5*60*1000l, 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.searchReplyNotValidated\", \"How many search replies we get that we are NOT able to validate (fetch)\", \"NetworkDatabase\", new long[] { 5*60*1000l, 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.searchReplyValidationSkipped\", \"How many search replies we get from unreliable peers that we skip?\", \"NetworkDatabase\", new long[] { 5*60*1000l, 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.republishQuantity\", \"How many peers do we need to send a found leaseSet to?\", \"NetworkDatabase\", new long[] { 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n    }","id":26031,"modified_method":"public FloodfillNetworkDatabaseFacade(RouterContext context) {\n        super(context);\n        _activeFloodQueries = new HashMap<Hash, FloodSearchJob>();\n         _verifiesInProgress = new ConcurrentHashSet<Hash>(8);\n\n        _context.statManager().createRequiredRateStat(\"netDb.successTime\", \"Time for successful lookup (ms)\", \"NetworkDatabase\", new long[] { 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.failedTime\", \"How long a failed search takes\", \"NetworkDatabase\", new long[] { 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.failedRetries\", \"How many additional queries for an iterative search\", \"NetworkDatabase\", new long[] { 60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.successRetries\", \"How many additional queries for an iterative search\", \"NetworkDatabase\", new long[] { 60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.failedAttemptedPeers\", \"How many peers we sent a search to when the search fails\", \"NetworkDatabase\", new long[] { 10*60*1000l });\n        _context.statManager().createRateStat(\"netDb.successPeers\", \"How many peers are contacted in a successful search\", \"NetworkDatabase\", new long[] { 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.failedPeers\", \"How many peers fail to respond to a lookup?\", \"NetworkDatabase\", new long[] { 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.searchCount\", \"Overall number of searches sent\", \"NetworkDatabase\", new long[] { 5*60*1000l, 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.searchMessageCount\", \"Overall number of mesages for all searches sent\", \"NetworkDatabase\", new long[] { 5*60*1000l, 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.searchReplyValidated\", \"How many search replies we get that we are able to validate (fetch)\", \"NetworkDatabase\", new long[] { 5*60*1000l, 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.searchReplyNotValidated\", \"How many search replies we get that we are NOT able to validate (fetch)\", \"NetworkDatabase\", new long[] { 5*60*1000l, 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.searchReplyValidationSkipped\", \"How many search replies we get from unreliable peers that we skip?\", \"NetworkDatabase\", new long[] { 5*60*1000l, 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"netDb.republishQuantity\", \"How many peers do we need to send a found leaseSet to?\", \"NetworkDatabase\", new long[] { 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n        // for ISJ\n        _context.statManager().createRateStat(\"netDb.RILookupDirect\", \"Was an iterative RI lookup sent directly?\", \"NetworkDatabase\", new long[] { 60*60*1000 });\n    }","commit_id":"d22b05e114e6f853aaafe43a2563ba9f69985f37","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Send a DLM to the peer\n     */\n    private void sendQuery(Hash peer) {\n            TunnelManagerFacade tm = getContext().tunnelManager();\n            TunnelInfo outTunnel;\n            TunnelInfo replyTunnel;\n            boolean isClientReplyTunnel;\n            if (_fromLocalDest != null) {\n                outTunnel = tm.selectOutboundTunnel(_fromLocalDest, peer);\n                if (outTunnel == null)\n                    outTunnel = tm.selectOutboundExploratoryTunnel(peer);\n                replyTunnel = tm.selectInboundTunnel(_fromLocalDest, peer);\n                isClientReplyTunnel = replyTunnel != null;\n                if (!isClientReplyTunnel)\n                    replyTunnel = tm.selectInboundExploratoryTunnel(peer);\n            } else {\n                outTunnel = tm.selectOutboundExploratoryTunnel(peer);\n                replyTunnel = tm.selectInboundExploratoryTunnel(peer);\n                isClientReplyTunnel = false;\n            }\n            if ( (replyTunnel == null) || (outTunnel == null) ) {\n                failed();\n                return;\n            }\n\n            // As explained above, it's hard to keep the key itself out of the ff list,\n            // so let's just skip it for now if the outbound tunnel is zero-hop.\n            // Yes, that means we aren't doing double-lookup for a floodfill\n            // if it happens to be closest to itself and we are using zero-hop exploratory tunnels.\n            // If we don't, the OutboundMessageDistributor ends up logging erors for\n            // not being able to send to the floodfill, if we don't have an older netdb entry.\n            if (outTunnel.getLength() <= 1) {\n                if (peer.equals(_key)) {\n                    failed(peer, false);\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(getJobId() + \": not doing zero-hop self-lookup of \" + peer);\n                    return;\n                }\n                if (_facade.lookupLocallyWithoutValidation(peer) == null) {\n                    failed(peer, false);\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(getJobId() + \": not doing zero-hop lookup to unknown \" + peer);\n                    return;\n                }\n            }\n            \n            DatabaseLookupMessage dlm = new DatabaseLookupMessage(getContext(), true);\n            dlm.setFrom(replyTunnel.getPeer(0));\n            dlm.setMessageExpiration(getContext().clock().now() + SINGLE_SEARCH_MSG_TIME);\n            dlm.setReplyTunnel(replyTunnel.getReceiveTunnelId(0));\n            dlm.setSearchKey(_key);\n            dlm.setSearchType(_isLease ? DatabaseLookupMessage.Type.LS : DatabaseLookupMessage.Type.RI);\n            \n            if (_log.shouldLog(Log.INFO)) {\n                int tries;\n                synchronized(this) {\n                    tries = _unheardFrom.size() + _failedPeers.size();\n                }\n                _log.info(getJobId() + \": ISJ try \" + tries + \" for \" +\n                          (_isLease ? \"LS \" : \"RI \") +\n                          _key + \" to \" + peer +\n                          \" reply via client tunnel? \" + isClientReplyTunnel);\n            }\n            long now = getContext().clock().now();\n            _sentTime.put(peer, Long.valueOf(now));\n\n            I2NPMessage outMsg = null;\n            if (_isLease || getContext().getProperty(PROP_ENCRYPT_RI, DEFAULT_ENCRYPT_RI)) {\n                // Full ElG is fairly expensive so only do it for LS lookups\n                // if we have the ff RI, garlic encrypt it\n                RouterInfo ri = getContext().netDb().lookupRouterInfoLocally(peer);\n                if (ri != null) {\n                    // request encrypted reply\n                    if (DatabaseLookupMessage.supportsEncryptedReplies(ri)) {\n                        MessageWrapper.OneTimeSession sess;\n                        if (isClientReplyTunnel)\n                            sess = MessageWrapper.generateSession(getContext(), _fromLocalDest);\n                        else\n                            sess = MessageWrapper.generateSession(getContext());\n                        if (sess != null) {\n                            if (_log.shouldLog(Log.INFO))\n                                _log.info(getJobId() + \": Requesting encrypted reply from \" + peer + ' ' + sess.key + ' ' + sess.tag);\n                            dlm.setReplySession(sess.key, sess.tag);\n                        } // else client went away, but send it anyway\n                    }\n                    outMsg = MessageWrapper.wrap(getContext(), dlm, ri);\n                    // ElG can take a while so do a final check before we send it,\n                    // a response may have come in.\n                    if (_dead) {\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(getJobId() + \": aborting send, finished while wrapping msg to \" + peer);\n                        return;\n                    }\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(getJobId() + \": Encrypted DLM for \" + _key + \" to \" + peer);\n                }\n            }\n            if (outMsg == null)\n                outMsg = dlm;\n            getContext().tunnelDispatcher().dispatchOutbound(outMsg, outTunnel.getSendTunnelId(0), peer);\n\n            // The timeout job is always run (never cancelled)\n            // Note that the timeout is much shorter than the message expiration (see above)\n            Job j = new IterativeTimeoutJob(getContext(), peer, this);\n            long expire = Math.min(_expiration, now + SINGLE_SEARCH_TIME);\n            j.getTiming().setStartAfter(expire);\n            getContext().jobQueue().addJob(j);\n\n    }","id":26032,"modified_method":"/**\n     *  Send a DLM to the peer\n     */\n    private void sendQuery(Hash peer) {\n            TunnelManagerFacade tm = getContext().tunnelManager();\n            RouterInfo ri = getContext().netDb().lookupRouterInfoLocally(peer);\n            TunnelInfo outTunnel;\n            TunnelInfo replyTunnel;\n            boolean isClientReplyTunnel;\n            boolean isDirect;\n            if (_fromLocalDest != null) {\n                outTunnel = tm.selectOutboundTunnel(_fromLocalDest, peer);\n                if (outTunnel == null)\n                    outTunnel = tm.selectOutboundExploratoryTunnel(peer);\n                replyTunnel = tm.selectInboundTunnel(_fromLocalDest, peer);\n                isClientReplyTunnel = replyTunnel != null;\n                if (!isClientReplyTunnel)\n                    replyTunnel = tm.selectInboundExploratoryTunnel(peer);\n                isDirect = false;\n            } else if ((!_isLease) && ri != null && getContext().commSystem().isEstablished(peer)) {\n                // If it's a RI lookup, not from a client, and we're already connected, just ask directly\n                // This also saves the ElG encryption for us and the decryption for the ff\n                // There's no anonymity reason to use an expl. tunnel... the main reason\n                // is to limit connections to the ffs. But if we're already connected,\n                // do it the fast and easy way.\n                outTunnel = null;\n                replyTunnel = null;\n                isClientReplyTunnel = false;\n                isDirect = true;\n                getContext().statManager().addRateData(\"netDb.RILookupDirect\", 1);\n            } else {\n                outTunnel = tm.selectOutboundExploratoryTunnel(peer);\n                replyTunnel = tm.selectInboundExploratoryTunnel(peer);\n                isClientReplyTunnel = false;\n                isDirect = false;\n                getContext().statManager().addRateData(\"netDb.RILookupDirect\", 0);\n            }\n            if ((!isDirect) && (replyTunnel == null || outTunnel == null)) {\n                failed();\n                return;\n            }\n\n            // As explained above, it's hard to keep the key itself out of the ff list,\n            // so let's just skip it for now if the outbound tunnel is zero-hop.\n            // Yes, that means we aren't doing double-lookup for a floodfill\n            // if it happens to be closest to itself and we are using zero-hop exploratory tunnels.\n            // If we don't, the OutboundMessageDistributor ends up logging erors for\n            // not being able to send to the floodfill, if we don't have an older netdb entry.\n            if (outTunnel != null && outTunnel.getLength() <= 1) {\n                if (peer.equals(_key)) {\n                    failed(peer, false);\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(getJobId() + \": not doing zero-hop self-lookup of \" + peer);\n                    return;\n                }\n                if (_facade.lookupLocallyWithoutValidation(peer) == null) {\n                    failed(peer, false);\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(getJobId() + \": not doing zero-hop lookup to unknown \" + peer);\n                    return;\n                }\n            }\n            \n            DatabaseLookupMessage dlm = new DatabaseLookupMessage(getContext(), true);\n            if (isDirect) {\n                dlm.setFrom(getContext().routerHash());\n            } else {\n                dlm.setFrom(replyTunnel.getPeer(0));\n                dlm.setReplyTunnel(replyTunnel.getReceiveTunnelId(0));\n            }\n            dlm.setMessageExpiration(getContext().clock().now() + SINGLE_SEARCH_MSG_TIME);\n            dlm.setSearchKey(_key);\n            dlm.setSearchType(_isLease ? DatabaseLookupMessage.Type.LS : DatabaseLookupMessage.Type.RI);\n            \n            if (_log.shouldLog(Log.INFO)) {\n                int tries;\n                synchronized(this) {\n                    tries = _unheardFrom.size() + _failedPeers.size();\n                }\n                _log.info(getJobId() + \": ISJ try \" + tries + \" for \" +\n                          (_isLease ? \"LS \" : \"RI \") +\n                          _key + \" to \" + peer +\n                          \" direct? \" + isDirect +\n                          \" reply via client tunnel? \" + isClientReplyTunnel);\n            }\n            long now = getContext().clock().now();\n            _sentTime.put(peer, Long.valueOf(now));\n\n            I2NPMessage outMsg = null;\n            if (isDirect) {\n                // never wrap\n            } else if (_isLease || getContext().getProperty(PROP_ENCRYPT_RI, DEFAULT_ENCRYPT_RI)) {\n                // Full ElG is fairly expensive so only do it for LS lookups\n                // and for RI lookups on fast boxes.\n                // if we have the ff RI, garlic encrypt it\n                if (ri != null) {\n                    // request encrypted reply\n                    if (DatabaseLookupMessage.supportsEncryptedReplies(ri)) {\n                        MessageWrapper.OneTimeSession sess;\n                        if (isClientReplyTunnel)\n                            sess = MessageWrapper.generateSession(getContext(), _fromLocalDest);\n                        else\n                            sess = MessageWrapper.generateSession(getContext());\n                        if (sess != null) {\n                            if (_log.shouldLog(Log.INFO))\n                                _log.info(getJobId() + \": Requesting encrypted reply from \" + peer + ' ' + sess.key + ' ' + sess.tag);\n                            dlm.setReplySession(sess.key, sess.tag);\n                        } // else client went away, but send it anyway\n                    }\n                    outMsg = MessageWrapper.wrap(getContext(), dlm, ri);\n                    // ElG can take a while so do a final check before we send it,\n                    // a response may have come in.\n                    if (_dead) {\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(getJobId() + \": aborting send, finished while wrapping msg to \" + peer);\n                        return;\n                    }\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(getJobId() + \": Encrypted DLM for \" + _key + \" to \" + peer);\n                }\n            }\n            if (outMsg == null)\n                outMsg = dlm;\n            if (isDirect) {\n                OutNetMessage m = new OutNetMessage(getContext(), outMsg, outMsg.getMessageExpiration(),\n                                                    OutNetMessage.PRIORITY_MY_NETDB_LOOKUP, ri);\n                // Should always succeed, we are connected already\n                //m.setOnFailedReplyJob(onFail);\n                //m.setOnFailedSendJob(onFail);\n                //m.setOnReplyJob(onReply);\n                //m.setReplySelector(selector);\n                //getContext().messageRegistry().registerPending(m);\n                getContext().commSystem().processMessage(m);\n            } else {\n                getContext().tunnelDispatcher().dispatchOutbound(outMsg, outTunnel.getSendTunnelId(0), peer);\n            }\n\n            // The timeout job is always run (never cancelled)\n            // Note that the timeout is much shorter than the message expiration (see above)\n            Job j = new IterativeTimeoutJob(getContext(), peer, this);\n            long expire = Math.min(_expiration, now + SINGLE_SEARCH_TIME);\n            j.getTiming().setStartAfter(expire);\n            getContext().jobQueue().addJob(j);\n\n    }","commit_id":"d22b05e114e6f853aaafe43a2563ba9f69985f37","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    void success() {\n        // Sadly, we don't know for sure which one replied.\n        // If the reply is after expiration (which moves the hash from _unheardFrom to _failedPeers),\n        // we will credit the wrong one.\n        int tries;\n        Hash peer = null;\n        synchronized(this) {\n            if (_dead) return;\n            _dead = true;\n            tries = _unheardFrom.size() + _failedPeers.size();\n            if (_unheardFrom.size() == 1) {\n                peer = _unheardFrom.iterator().next();\n                _unheardFrom.clear();\n            }\n        }\n        _facade.complete(_key);\n        if (peer != null) {\n            Long timeSent = _sentTime.get(peer);\n            if (timeSent != null)\n                getContext().profileManager().dbLookupSuccessful(peer, getContext().clock().now() - timeSent.longValue());\n        }\n        long time = System.currentTimeMillis() - _created;\n        if (_log.shouldLog(Log.INFO))\n            _log.info(getJobId() + \": ISJ for \" + _key + \" successful after \" + time +\n                      \", peers queried: \" + tries);\n        getContext().statManager().addRateData(\"netDb.successTime\", time, 0);\n        getContext().statManager().addRateData(\"netDb.successRetries\", tries - 1, 0);\n        for (Job j : _onFind) {\n            getContext().jobQueue().addJob(j);\n        }\n        _onFind.clear();\n    }","id":26033,"modified_method":"@Override\n    void success() {\n        // Sadly, we don't know for sure which one replied.\n        // If the reply is after expiration (which moves the hash from _unheardFrom to _failedPeers),\n        // we will credit the wrong one.\n        int tries;\n        Hash peer = null;\n        synchronized(this) {\n            if (_dead) return;\n            _dead = true;\n            tries = _unheardFrom.size() + _failedPeers.size();\n            if (_unheardFrom.size() == 1) {\n                peer = _unheardFrom.iterator().next();\n                _unheardFrom.clear();\n            }\n        }\n        _facade.complete(_key);\n        if (peer != null) {\n            Long timeSent = _sentTime.get(peer);\n            if (timeSent != null)\n                getContext().profileManager().dbLookupSuccessful(peer, getContext().clock().now() - timeSent.longValue());\n        }\n        long time = System.currentTimeMillis() - _created;\n        if (_log.shouldLog(Log.INFO))\n            _log.info(getJobId() + \": ISJ for \" + _key + \" successful after \" + time +\n                      \", peers queried: \" + tries);\n        getContext().statManager().addRateData(\"netDb.successTime\", time);\n        getContext().statManager().addRateData(\"netDb.successRetries\", tries - 1);\n        for (Job j : _onFind) {\n            getContext().jobQueue().addJob(j);\n        }\n        _onFind.clear();\n    }","commit_id":"d22b05e114e6f853aaafe43a2563ba9f69985f37","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Total failure\n     */\n    @Override\n    void failed() {\n        synchronized (this) {\n            if (_dead) return;\n            _dead = true;\n        }\n        _facade.complete(_key);\n        if (getContext().commSystem().getReachabilityStatus() != CommSystemFacade.STATUS_DISCONNECTED)\n            _facade.lookupFailed(_key);\n        getContext().messageRegistry().unregisterPending(_out);\n        int tries;\n        synchronized(this) {\n            tries = _unheardFrom.size() + _failedPeers.size();\n            // blame the unheard-from (others already blamed in failed() above)\n            for (Hash h : _unheardFrom)\n                getContext().profileManager().dbLookupFailed(h);\n        }\n        long time = System.currentTimeMillis() - _created;\n        if (_log.shouldLog(Log.INFO)) {\n            long timeRemaining = _expiration - getContext().clock().now();\n            _log.info(getJobId() + \": ISJ for \" + _key + \" failed with \" + timeRemaining + \" remaining after \" + time +\n                      \", peers queried: \" + tries);\n        }\n        getContext().statManager().addRateData(\"netDb.failedTime\", time, 0);\n        getContext().statManager().addRateData(\"netDb.failedRetries\", Math.max(0, tries - 1), 0);\n        for (Job j : _onFailed) {\n            getContext().jobQueue().addJob(j);\n        }\n        _onFailed.clear();\n    }","id":26034,"modified_method":"/**\n     *  Total failure\n     */\n    @Override\n    void failed() {\n        synchronized (this) {\n            if (_dead) return;\n            _dead = true;\n        }\n        _facade.complete(_key);\n        if (getContext().commSystem().getReachabilityStatus() != CommSystemFacade.STATUS_DISCONNECTED)\n            _facade.lookupFailed(_key);\n        getContext().messageRegistry().unregisterPending(_out);\n        int tries;\n        synchronized(this) {\n            tries = _unheardFrom.size() + _failedPeers.size();\n            // blame the unheard-from (others already blamed in failed() above)\n            for (Hash h : _unheardFrom)\n                getContext().profileManager().dbLookupFailed(h);\n        }\n        long time = System.currentTimeMillis() - _created;\n        if (_log.shouldLog(Log.INFO)) {\n            long timeRemaining = _expiration - getContext().clock().now();\n            _log.info(getJobId() + \": ISJ for \" + _key + \" failed with \" + timeRemaining + \" remaining after \" + time +\n                      \", peers queried: \" + tries);\n        }\n        getContext().statManager().addRateData(\"netDb.failedTime\", time);\n        getContext().statManager().addRateData(\"netDb.failedRetries\", Math.max(0, tries - 1));\n        for (Job j : _onFailed) {\n            getContext().jobQueue().addJob(j);\n        }\n        _onFailed.clear();\n    }","commit_id":"d22b05e114e6f853aaafe43a2563ba9f69985f37","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tDDMDataProviderInstance dataProviderInstance)\n\t\tthrows Exception {\n\n\t\tDDMDataProvider ddmDataProvider =\n\t\t\t_ddmDataProviderTracker.getDDMDataProvider(\n\t\t\t\tdataProviderInstance.getType());\n\n\t\tif (ddmDataProvider == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\"No such DataProvider of type \" + dataProviderInstance.getType()\n\t\t\t);\n\t\t}\n\n\t\tlong userId = portletDataContext.getUserId(\n\t\t\tdataProviderInstance.getUserUuid());\n\n\t\tDDMDataProviderInstance importedProvider =\n\t\t\t(DDMDataProviderInstance)dataProviderInstance.clone();\n\n\t\timportedProvider.setGroupId(portletDataContext.getScopeGroupId());\n\n\t\tDDMDataProviderInstance existingProvider =\n\t\t\t_ddmDataProviderInstanceLocalService.\n\t\t\t\tfetchDDMDataProviderInstanceByUuidAndGroupId(\n\t\t\t\t\tdataProviderInstance.getUuid(),\n\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tdataProviderInstance);\n\n\t\tString definition = dataProviderInstance.getDefinition();\n\n\t\tDDMForm ddmForm = DDMFormFactory.create(\n\t\t\tDDMRESTDataProviderSettings.class);\n\n\t\tDDMFormValues ddmFormValues =\n\t\t\t_ddmFormValuesJSONDeserializer.deserialize(ddmForm, definition);\n\n\t\tif (existingProvider == null) {\n\t\t\tserviceContext.setUuid(dataProviderInstance.getUuid());\n\n\t\t\timportedProvider =\n\t\t\t\t_ddmDataProviderInstanceLocalService.addDataProviderInstance(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tdataProviderInstance.getNameMap(),\n\t\t\t\t\tdataProviderInstance.getDescriptionMap(), ddmFormValues,\n\t\t\t\t\tdataProviderInstance.getType(), serviceContext);\n\t\t}\n\t\telse {\n\t\t\timportedProvider.setDataProviderInstanceId(\n\t\t\t\texistingProvider.getDataProviderInstanceId());\n\n\t\t\timportedProvider =\n\t\t\t\t_ddmDataProviderInstanceLocalService.updateDataProviderInstance(\n\t\t\t\t\tuserId, existingProvider.getDataProviderInstanceId(),\n\t\t\t\t\tdataProviderInstance.getNameMap(),\n\t\t\t\t\tdataProviderInstance.getDescriptionMap(), ddmFormValues,\n\t\t\t\t\tserviceContext);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tdataProviderInstance, importedProvider);\n\t}","id":26035,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tDDMDataProviderInstance dataProviderInstance)\n\t\tthrows Exception {\n\n\t\tDDMDataProvider ddmDataProvider =\n\t\t\t_ddmDataProviderTracker.getDDMDataProvider(\n\t\t\t\tdataProviderInstance.getType());\n\n\t\tif (ddmDataProvider == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\"No such DataProvider of type \" + dataProviderInstance.getType()\n\t\t\t);\n\t\t}\n\n\t\tlong userId = portletDataContext.getUserId(\n\t\t\tdataProviderInstance.getUserUuid());\n\n\t\tDDMDataProviderInstance importedDataProviderInstance =\n\t\t\t(DDMDataProviderInstance)dataProviderInstance.clone();\n\n\t\timportedDataProviderInstance.setGroupId(\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tDDMDataProviderInstance existingDataProviderInstance =\n\t\t\t_ddmDataProviderInstanceLocalService.\n\t\t\t\tfetchDDMDataProviderInstanceByUuidAndGroupId(\n\t\t\t\t\tdataProviderInstance.getUuid(),\n\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tdataProviderInstance);\n\n\t\tDDMForm ddmForm = DDMFormFactory.create(ddmDataProvider.getSettings());\n\n\t\tDDMFormValues ddmFormValues =\n\t\t\t_ddmFormValuesJSONDeserializer.deserialize(\n\t\t\t\tddmForm, dataProviderInstance.getDefinition());\n\n\t\tif (existingDataProviderInstance == null) {\n\t\t\tserviceContext.setUuid(dataProviderInstance.getUuid());\n\n\t\t\timportedDataProviderInstance =\n\t\t\t\t_ddmDataProviderInstanceLocalService.addDataProviderInstance(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tdataProviderInstance.getNameMap(),\n\t\t\t\t\tdataProviderInstance.getDescriptionMap(), ddmFormValues,\n\t\t\t\t\tdataProviderInstance.getType(), serviceContext);\n\t\t}\n\t\telse {\n\t\t\timportedDataProviderInstance.setDataProviderInstanceId(\n\t\t\t\texistingDataProviderInstance.getDataProviderInstanceId());\n\n\t\t\timportedDataProviderInstance =\n\t\t\t\t_ddmDataProviderInstanceLocalService.updateDataProviderInstance(\n\t\t\t\t\tuserId,\n\t\t\t\t\texistingDataProviderInstance.getDataProviderInstanceId(),\n\t\t\t\t\tdataProviderInstance.getNameMap(),\n\t\t\t\t\tdataProviderInstance.getDescriptionMap(), ddmFormValues,\n\t\t\t\t\tserviceContext);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tdataProviderInstance, importedDataProviderInstance);\n\t}","commit_id":"3ca8f06844a3a3106d9e366890285e440ce98951","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic DDMDataProviderInstance updateStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tDDMDataProviderInstance dataProviderInstance)\n\t\tthrows PortalException {\n\n\t\tlong userId = portletDataContext.getUserId(\n\t\t\tdataProviderInstance.getUserUuid());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tdataProviderInstance);\n\n\t\tString definition = dataProviderInstance.getDefinition();\n\n\t\tDDMForm ddmForm = DDMFormFactory.create(\n\t\t\tDDMRESTDataProviderSettings.class);\n\n\t\tDDMFormValues ddmFormValues =\n\t\t\t_ddmFormValuesJSONDeserializer.deserialize(ddmForm, definition);\n\n\t\treturn _ddmDataProviderInstanceLocalService.updateDataProviderInstance(\n\t\t\tuserId, dataProviderInstance.getDataProviderInstanceId(),\n\t\t\tdataProviderInstance.getNameMap(),\n\t\t\tdataProviderInstance.getDescriptionMap(), ddmFormValues,\n\t\t\tserviceContext);\n\t}","id":26036,"modified_method":"@Override\n\tpublic DDMDataProviderInstance updateStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tDDMDataProviderInstance dataProviderInstance)\n\t\tthrows PortalException {\n\n\t\tlong userId = portletDataContext.getUserId(\n\t\t\tdataProviderInstance.getUserUuid());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tdataProviderInstance);\n\n\t\tDDMForm ddmForm = getDataProviderSettingsDDMForm(\n\t\t\tdataProviderInstance.getType());\n\n\t\tDDMFormValues ddmFormValues =\n\t\t\t_ddmFormValuesJSONDeserializer.deserialize(\n\t\t\t\tddmForm, dataProviderInstance.getDefinition());\n\n\t\treturn _ddmDataProviderInstanceLocalService.updateDataProviderInstance(\n\t\t\tuserId, dataProviderInstance.getDataProviderInstanceId(),\n\t\t\tdataProviderInstance.getNameMap(),\n\t\t\tdataProviderInstance.getDescriptionMap(), ddmFormValues,\n\t\t\tserviceContext);\n\t}","commit_id":"3ca8f06844a3a3106d9e366890285e440ce98951","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic DDMDataProviderInstance addStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tDDMDataProviderInstance dataProviderInstance)\n\t\tthrows PortalException {\n\n\t\tlong userId = portletDataContext.getUserId(\n\t\t\tdataProviderInstance.getUserUuid());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tdataProviderInstance);\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tserviceContext.setUuid(dataProviderInstance.getUuid());\n\t\t}\n\n\t\tString definition = dataProviderInstance.getDefinition();\n\n\t\tDDMForm ddmForm = DDMFormFactory.create(\n\t\t\tDDMRESTDataProviderSettings.class);\n\n\t\tDDMFormValues ddmFormValues =\n\t\t\t_ddmFormValuesJSONDeserializer.deserialize(ddmForm, definition);\n\n\t\treturn _ddmDataProviderInstanceLocalService.addDataProviderInstance(\n\t\t\tuserId, dataProviderInstance.getGroupId(),\n\t\t\tdataProviderInstance.getNameMap(),\n\t\t\tdataProviderInstance.getDescriptionMap(), ddmFormValues,\n\t\t\tdataProviderInstance.getType(), serviceContext);\n\t}","id":26037,"modified_method":"@Override\n\tpublic DDMDataProviderInstance addStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tDDMDataProviderInstance dataProviderInstance)\n\t\tthrows PortalException {\n\n\t\tlong userId = portletDataContext.getUserId(\n\t\t\tdataProviderInstance.getUserUuid());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tdataProviderInstance);\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tserviceContext.setUuid(dataProviderInstance.getUuid());\n\t\t}\n\n\t\tDDMForm ddmForm = getDataProviderSettingsDDMForm(\n\t\t\tdataProviderInstance.getType());\n\n\t\tDDMFormValues ddmFormValues =\n\t\t\t_ddmFormValuesJSONDeserializer.deserialize(\n\t\t\t\tddmForm, dataProviderInstance.getDefinition());\n\n\t\treturn _ddmDataProviderInstanceLocalService.addDataProviderInstance(\n\t\t\tuserId, dataProviderInstance.getGroupId(),\n\t\t\tdataProviderInstance.getNameMap(),\n\t\t\tdataProviderInstance.getDescriptionMap(), ddmFormValues,\n\t\t\tdataProviderInstance.getType(), serviceContext);\n\t}","commit_id":"3ca8f06844a3a3106d9e366890285e440ce98951","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * This is test case for https://issues.apache.org/jira/browse/CXF-6234\n     *\n     * It's using paths that will be rewritten by following catalog rule:\n     *\n     *     &lt;rewriteSystem systemIdStartString=\"http://apache.org/hello_world/types2/\"\n     *          rewritePrefix=\"/wsdl/others/\"/&gt;\n     *\n     */\n    @Test\n    public void testWSDLPublishWithCatalogsRewritePaths() {\n        Endpoint ep = Endpoint.publish(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort\",\n                new GreeterImpl());\n\n        String result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                + \"xsd=http://apache.org/hello_world/types2/hello_world_schema2.xsd\");\n        assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/types2/hello_world_schema.xsd\"));\n        assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/types2/hello_world_schema3.xsd\"));\n        assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/types2/d/hello_world_schema4.xsd\"));\n\n        result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                + \"xsd=http://apache.org/hello_world/types2/hello_world_schema.xsd\");\n        assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/types2/hello_world_schema2.xsd\"));\n\n        result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                + \"xsd=http://apache.org/hello_world/types2/hello_world_schema3.xsd\");\n        assertTrue(result.length() > 0);\n\n        result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                + \"xsd=http://apache.org/hello_world/types2/d/hello_world_schema4.xsd\");\n        assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/types2/d/d/hello_world_schema4.xsd\"));\n\n        result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                + \"xsd=http://apache.org/hello_world/types2/d/d/hello_world_schema4.xsd\");\n        assertTrue(result.length() > 0);\n\n        ep.stop();\n    }","id":26038,"modified_method":"/**\n     * This is test case for https://issues.apache.org/jira/browse/CXF-6234\n     *\n     * It's using paths that will be rewritten by following catalog rule:\n     *\n     *     &lt;rewriteSystem systemIdStartString=\"http://apache.org/hello_world/types2/\"\n     *          rewritePrefix=\"/wsdl/others/\"/&gt;\n     *\n     */\n    @Test\n    public void testWSDLPublishWithCatalogsRewritePaths() {\n        Endpoint ep = Endpoint.publish(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort\",\n                new GreeterImpl());\n        try {\n            // schemas in the same directory as WSDL\n\n            String result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"xsd=http://apache.org/hello_world/types2/hello_world_schema2.xsd\");\n            assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/types2/hello_world_schema.xsd\"));\n            assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/types2/hello_world_schema3.xsd\"));\n            assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/types2/d/hello_world_schema4.xsd\"));\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"xsd=http://apache.org/hello_world/types2/hello_world_schema.xsd\");\n            assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/types2/hello_world_schema2.xsd\"));\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"xsd=http://apache.org/hello_world/types2/hello_world_schema3.xsd\");\n            assertTrue(result.length() > 0);\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"xsd=http://apache.org/hello_world/types2/d/hello_world_schema4.xsd\");\n            assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/types2/d/d/hello_world_schema4.xsd\"));\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"xsd=http://apache.org/hello_world/types2/d/d/hello_world_schema4.xsd\");\n            assertFalse(result.contains(\"schemaLocation\"));\n\n            // schemas in separate directory which is not subdirectory of WSDL dir\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"wsdl=http://apache.org/hello_world/types2/hello_world_messages_catalog.wsdl\");\n            assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/schemas-in-separate-dir/schema.xsd\"));\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"xsd=http://apache.org/hello_world/schemas-in-separate-dir/schema.xsd\");\n            assertTrue(result,\n                    result.contains(\"xsd=http://apache.org/hello_world/schemas-in-separate-dir/d/included.xsd\"));\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"xsd=http://apache.org/hello_world/schemas-in-separate-dir/d/included.xsd\");\n            assertTrue(result,\n                    result.contains(\"xsd=http://apache.org/hello_world/schemas-in-separate-dir/d/d/included.xsd\"));\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"xsd=http://apache.org/hello_world/schemas-in-separate-dir/d/d/included.xsd\");\n            assertFalse(result, result.contains(\"schemaLocation\"));\n\n            // rewrite rule that doesn't begin with 'classpath:' but contains only the path\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"xsd=http://apache.org/hello_world/schemas-in-separate-dir-non-cp/another-schema.xsd\");\n            assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/schemas-in-separate-dir-non-cp/d/\"\n                    + \"another-included.xsd\"));\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"xsd=http://apache.org/hello_world/schemas-in-separate-dir-non-cp/d/another-included.xsd\");\n            assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/schemas-in-separate-dir-non-cp/d/d/\"\n                    + \"another-included.xsd\"));\n        } finally {\n            ep.stop();\n        }\n    }","commit_id":"a602c9df3e2e09855410f0e75af9b108620b7794","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testWSDLPublishWithCatalogs() throws Exception {\n        Endpoint ep = Endpoint.publish(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort\",\n                                       new GreeterImpl());\n\n        String result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                + \"xsd=hello_world_schema2.xsd\");\n        assertTrue(result, result.contains(\"xsd=hello_world_schema.xsd\"));\n        assertTrue(result, result.contains(\"xsd=hello_world_schema3.xsd\"));\n        assertTrue(result, result.contains(\"xsd=d/hello_world_schema4.xsd\"));\n\n        result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                + \"xsd=hello_world_schema3.xsd\");\n        assertTrue(result.length() > 0);\n\n        result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                + \"xsd=d/hello_world_schema4.xsd\");\n        assertTrue(result, result.contains(\"xsd=d/d/hello_world_schema4.xsd\"));\n\n        result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort\"\n                + \"?xsd=hello_world_schema.xsd\");\n        assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/types2/hello_world_schema2.xsd\"));\n\n        result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort\"\n                + \"?wsdl=hello_world_messages_catalog.wsdl\");\n        assertTrue(result, result.contains(\"xsd=hello_world_schema.xsd\"));\n\n        ep.stop();\n    }","id":26039,"modified_method":"@Test\n    public void testWSDLPublishWithCatalogs() throws Exception {\n        Endpoint ep = Endpoint.publish(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort\",\n                                       new GreeterImpl());\n\n        try {\n            String result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"xsd=hello_world_schema2.xsd\");\n            assertTrue(result, result.contains(\"xsd=hello_world_schema.xsd\"));\n            assertTrue(result, result.contains(\"xsd=hello_world_schema3.xsd\"));\n            assertTrue(result, result.contains(\"xsd=d/hello_world_schema4.xsd\"));\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"xsd=hello_world_schema3.xsd\");\n            assertTrue(result.length() > 0);\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort?\"\n                    + \"xsd=d/hello_world_schema4.xsd\");\n            assertTrue(result, result.contains(\"xsd=d/d/hello_world_schema4.xsd\"));\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort\"\n                    + \"?xsd=hello_world_schema.xsd\");\n            assertTrue(result, result.contains(\"xsd=http://apache.org/hello_world/types2/hello_world_schema2.xsd\"));\n\n            result = readUrl(\"http://localhost:\" + PORT + \"/SoapContext/SoapPort\"\n                    + \"?wsdl=hello_world_messages_catalog.wsdl\");\n            assertTrue(result, result.contains(\"xsd=hello_world_schema.xsd\"));\n        } finally {\n            ep.stop();\n        }\n    }","commit_id":"a602c9df3e2e09855410f0e75af9b108620b7794","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * If given decodedStart is relative path, resolves a real location of given schema and puts it into schema map.\n     *\n     * @param doneSchemas schema map\n     * @param decodedStart path referencing schema\n     * @param schemaReference referenced schema\n     */\n    private void putResolvedSchemaLocationIfRelative(Map<String, SchemaReference> doneSchemas, String decodedStart,\n                                                     SchemaReference schemaReference) {\n        try {\n            if (!(new URI(decodedStart).isAbsolute())) {\n                String resolved = schemaReference.getReferencedSchema().getDocumentBaseURI();\n                doneSchemas.put(resolved, schemaReference);\n            }\n        } catch (URISyntaxException ex) {\n            // ignore\n        }\n    }","id":26040,"modified_method":"private void processSchemaReference(SchemaReference schemaReference,\n                                        Bus bus,\n                                        Schema schema,\n                                        String docBase,\n                                        Map<String, SchemaReference> doneSchemas,\n                                        String base,\n                                        String parentResolved) {\n        OASISCatalogManager catalogs = OASISCatalogManager.getCatalogManager(bus);\n        String start = findSchemaLocation(doneSchemas, schemaReference, docBase);\n        String origLocation = schemaReference.getSchemaLocationURI();\n\n        if (start != null) {\n            String decodedStart;\n            String decodedOrigLocation;\n            // Always use the URL decoded version to ensure that we have a\n            // canonical representation of the import URL for lookup.\n            try {\n                decodedStart = URLDecoder.decode(start, \"utf-8\");\n                decodedOrigLocation = URLDecoder.decode(origLocation, \"utf-8\");\n            } catch (UnsupportedEncodingException e) {\n                throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                                LOG,\n                                start), e);\n            }\n\n            if (!doneSchemas.containsKey(decodedStart)) {\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                if (resolvedSchemaLocation == null) {\n                    resolvedSchemaLocation =\n                            resolveWithCatalogs(catalogs, schemaReference.getSchemaLocationURI(), base);\n                }\n                if (resolvedSchemaLocation == null) {\n                    try {\n                        //check to see if it's already in a URL format.  If so, leave it.\n                        new URL(start);\n                    } catch (MalformedURLException e) {\n                        doneSchemas.put(decodedStart, schemaReference);\n                        doneSchemas.put(schemaReference.getReferencedSchema().getDocumentBaseURI(), schemaReference);\n                        try {\n                            if (!(new URI(origLocation).isAbsolute()) && parentResolved != null) {\n                                resolvedSchemaLocation = resolveRelativePath(parentResolved, decodedOrigLocation);\n                                doneSchemas.put(resolvedSchemaLocation, schemaReference);\n                            }\n                        } catch (URISyntaxException e1) {\n                            // ignore\n                        }\n                        updateSchemaImports(bus, schemaReference.getReferencedSchema(), start, doneSchemas, base,\n                                resolvedSchemaLocation);\n                    }\n                } else if (doneSchemas.put(decodedStart, schemaReference) == null) {\n                    doneSchemas.put(resolvedSchemaLocation, schemaReference);\n                    String p = getAndSaveRelativeSchemaLocationIfCatalogResolved(doneSchemas,\n                            resolvedSchemaLocation,\n                            schema,\n                            schemaReference);\n                    updateSchemaImports(bus, schemaReference.getReferencedSchema(), p, doneSchemas, base,\n                            resolvedSchemaLocation);\n                }\n            }\n        }\n    }","commit_id":"a602c9df3e2e09855410f0e75af9b108620b7794","url":"https://github.com/apache/cxf"},{"original_method":"protected void updateSchemaImports(Bus bus,\n                                       Schema schema,\n                                       String docBase,\n                                       Map<String, SchemaReference> doneSchemas,\n                                       String base) {\n        OASISCatalogManager catalogs = OASISCatalogManager.getCatalogManager(bus);\n        Collection<List<?>>  imports = CastUtils.cast((Collection<?>)schema.getImports().values());\n        for (List<?> lst : imports) {\n            List<SchemaImport> impLst = CastUtils.cast(lst);\n            for (SchemaImport imp : impLst) {\n                String start = findSchemaLocation(doneSchemas, imp, docBase);\n\n                if (start != null) {\n                    String decodedStart = null;\n                    // Always use the URL decoded version to ensure that we have a\n                    // canonical representation of the import URL for lookup.\n                    try {\n                        decodedStart = URLDecoder.decode(start, \"utf-8\");\n                    } catch (UnsupportedEncodingException e) {\n                        throw new WSDLQueryException(\n                            new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                                LOG,\n                                start), e);\n                    }\n\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                        if (resolvedSchemaLocation == null) {\n                            resolvedSchemaLocation = resolveWithCatalogs(catalogs, imp.getSchemaLocationURI(), base);\n                        }\n                        if (resolvedSchemaLocation == null) {\n                            try {\n                                //check to see if it's already in a URL format.  If so, leave it.\n                                new URL(start);\n                            } catch (MalformedURLException e) {\n                                if (doneSchemas.put(decodedStart, imp) == null) {\n                                    putResolvedSchemaLocationIfRelative(doneSchemas, decodedStart, imp);\n                                    updateSchemaImports(bus, imp.getReferencedSchema(), start, doneSchemas, base);\n                                }\n                            }\n                        } else {\n                            if (doneSchemas.put(decodedStart, imp) == null) {\n                                doneSchemas.put(resolvedSchemaLocation, imp);\n                                String p = getAndSaveRelativeSchemaLocationIfCatalogResolved(doneSchemas,\n                                                                                             resolvedSchemaLocation,\n                                                                                             schema,\n                                                                                             imp);\n                                updateSchemaImports(bus, imp.getReferencedSchema(), p, doneSchemas, base);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        List<SchemaReference> includes = CastUtils.cast(schema.getIncludes());\n        for (SchemaReference included : includes) {\n            String start = findSchemaLocation(doneSchemas, included, docBase);\n\n            if (start != null) {\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                if (resolvedSchemaLocation == null) {\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        try {\n                            //check to see if it's aleady in a URL format.  If so, leave it.\n                            new URL(start);\n                        } catch (MalformedURLException e) {\n                            if (doneSchemas.put(decodedStart, included) == null) {\n                                putResolvedSchemaLocationIfRelative(doneSchemas, decodedStart, included);\n                                updateSchemaImports(bus, included.getReferencedSchema(), start, doneSchemas, base);\n                            }\n                        }\n                    }\n                } else if (!doneSchemas.containsKey(decodedStart)\n                    || !doneSchemas.containsKey(resolvedSchemaLocation)) {\n                    doneSchemas.put(decodedStart, included);\n                    doneSchemas.put(resolvedSchemaLocation, included);\n                    String p = getAndSaveRelativeSchemaLocationIfCatalogResolved(doneSchemas,\n                                                                                 resolvedSchemaLocation,\n                                                                                 schema,\n                                                                                 included);\n                    updateSchemaImports(bus, included.getReferencedSchema(), p, doneSchemas, base);\n                }\n            }\n        }\n        List<SchemaReference> redefines = CastUtils.cast(schema.getRedefines());\n        for (SchemaReference included : redefines) {\n            String start = findSchemaLocation(doneSchemas, included, docBase);\n\n            if (start != null) {\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                if (resolvedSchemaLocation == null) {\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        try {\n                            //check to see if it's aleady in a URL format.  If so, leave it.\n                            new URL(start);\n                        } catch (MalformedURLException e) {\n                            if (doneSchemas.put(decodedStart, included) == null) {\n                                putResolvedSchemaLocationIfRelative(doneSchemas, decodedStart, included);\n                                updateSchemaImports(bus, included.getReferencedSchema(), start, doneSchemas, base);\n                            }\n                        }\n                    }\n                } else if (!doneSchemas.containsKey(decodedStart)\n                    || !doneSchemas.containsKey(resolvedSchemaLocation)) {\n                    doneSchemas.put(decodedStart, included);\n                    doneSchemas.put(resolvedSchemaLocation, included);\n                    String p = getAndSaveRelativeSchemaLocationIfCatalogResolved(doneSchemas,\n                                                                                 resolvedSchemaLocation,\n                                                                                 schema,\n                                                                                 included);\n                    updateSchemaImports(bus, included.getReferencedSchema(), p, doneSchemas, base);\n                }\n            }\n        }\n    }","id":26041,"modified_method":"protected void updateSchemaImports(Bus bus,\n                                       Schema schema,\n                                       String docBase,\n                                       Map<String, SchemaReference> doneSchemas,\n                                       String base,\n                                       String parentResolved) {\n        Collection<List<?>>  imports = CastUtils.cast((Collection<?>)schema.getImports().values());\n        for (List<?> lst : imports) {\n            List<SchemaImport> impLst = CastUtils.cast(lst);\n            for (SchemaImport imp : impLst) {\n                processSchemaReference(imp, bus, schema, docBase, doneSchemas, base, parentResolved);\n            }\n        }\n\n        List<SchemaReference> includes = CastUtils.cast(schema.getIncludes());\n        for (SchemaReference included : includes) {\n            processSchemaReference(included, bus, schema, docBase, doneSchemas, base, parentResolved);\n        }\n        List<SchemaReference> redefines = CastUtils.cast(schema.getRedefines());\n        for (SchemaReference included : redefines) {\n            processSchemaReference(included, bus, schema, docBase, doneSchemas, base, parentResolved);\n        }\n    }","commit_id":"a602c9df3e2e09855410f0e75af9b108620b7794","url":"https://github.com/apache/cxf"},{"original_method":"protected void updateDefinition(Bus bus,\n                                    Definition def,\n                                    Map<String, Definition> done,\n                                    Map<String, SchemaReference> doneSchemas,\n                                    String base,\n                                    String docBase) {\n        OASISCatalogManager catalogs = OASISCatalogManager.getCatalogManager(bus);\n\n        Collection<List<?>> imports = CastUtils.cast((Collection<?>)def.getImports().values());\n        for (List<?> lst : imports) {\n            List<Import> impLst = CastUtils.cast(lst);\n            for (Import imp : impLst) {\n                String start = imp.getLocationURI();\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n\n                if (resolvedSchemaLocation == null) {\n                    try {\n                        //check to see if it's already in a URL format.  If so, leave it.\n                        new URL(start);\n                    } catch (MalformedURLException e) {\n                        try {\n                            start = getLocationURI(start, docBase);\n                            decodedStart = URLDecoder.decode(start, \"utf-8\");\n                        } catch (Exception e1) {\n                            //ignore\n                        }\n                        if (done.put(decodedStart, imp.getDefinition()) == null) {\n                            updateDefinition(bus, imp.getDefinition(), done, doneSchemas, base, start);\n                        }\n                    }\n                } else {\n                    if (done.put(decodedStart, imp.getDefinition()) == null) {\n                        done.put(resolvedSchemaLocation, imp.getDefinition());\n                        updateDefinition(bus, imp.getDefinition(), done, doneSchemas, base, start);\n                    }\n                }\n            }\n        }\n\n\n        /* This doesn't actually work.   Setting setSchemaLocationURI on the import\n        * for some reason doesn't actually result in the new URI being written\n        * */\n        Types types = def.getTypes();\n        if (types != null) {\n            for (ExtensibilityElement el\n                : CastUtils.cast(types.getExtensibilityElements(), ExtensibilityElement.class)) {\n                if (el instanceof Schema) {\n                    updateSchemaImports(bus, (Schema)el, docBase, doneSchemas, base);\n                }\n            }\n        }\n    }","id":26042,"modified_method":"protected void updateDefinition(Bus bus,\n                                    Definition def,\n                                    Map<String, Definition> done,\n                                    Map<String, SchemaReference> doneSchemas,\n                                    String base,\n                                    String docBase,\n                                    String parentResolvedLocation) {\n        OASISCatalogManager catalogs = OASISCatalogManager.getCatalogManager(bus);\n\n        Collection<List<?>> imports = CastUtils.cast((Collection<?>)def.getImports().values());\n        for (List<?> lst : imports) {\n            List<Import> impLst = CastUtils.cast(lst);\n            for (Import imp : impLst) {\n                String start = imp.getLocationURI();\n                String decodedStart;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n\n                if (resolvedSchemaLocation == null) {\n                    try {\n                        //check to see if it's already in a URL format.  If so, leave it.\n                        new URL(start);\n                    } catch (MalformedURLException e) {\n                        try {\n                            start = getLocationURI(start, docBase);\n                            decodedStart = URLDecoder.decode(start, \"utf-8\");\n                        } catch (Exception e1) {\n                            //ignore\n                        }\n                        if (done.put(decodedStart, imp.getDefinition()) == null) {\n                            if (imp.getDefinition() != null && imp.getDefinition().getDocumentBaseURI() != null) {\n                                done.put(imp.getDefinition().getDocumentBaseURI(), imp.getDefinition());\n                            }\n                            updateDefinition(bus, imp.getDefinition(), done, doneSchemas, base, start, null);\n                        }\n                    }\n                } else {\n                    if (done.put(decodedStart, imp.getDefinition()) == null) {\n                        done.put(resolvedSchemaLocation, imp.getDefinition());\n                        if (imp.getDefinition() != null && imp.getDefinition().getDocumentBaseURI() != null) {\n                            done.put(imp.getDefinition().getDocumentBaseURI(), imp.getDefinition());\n                        }\n                        updateDefinition(bus, imp.getDefinition(), done, doneSchemas, base, start,\n                                resolvedSchemaLocation);\n                    }\n                }\n            }\n        }\n\n\n        /* This doesn't actually work.   Setting setSchemaLocationURI on the import\n        * for some reason doesn't actually result in the new URI being written\n        * */\n        Types types = def.getTypes();\n        if (types != null) {\n            for (ExtensibilityElement el\n                : CastUtils.cast(types.getExtensibilityElements(), ExtensibilityElement.class)) {\n                if (el instanceof Schema) {\n                    updateSchemaImports(bus, (Schema)el, docBase, doneSchemas, base, parentResolvedLocation);\n                }\n            }\n        }\n    }","commit_id":"a602c9df3e2e09855410f0e75af9b108620b7794","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Write the contents of a wsdl Definition object to a file.\n     *\n     * @param message\n     * @param mp  a map of known wsdl Definition objects\n     * @param smp a map of known xsd SchemaReference objects\n     * @param wsdl name of the wsdl file to write\n     * @param base the request URL\n     * @param endpointInfo information for a web service 'port' inside of a service\n     * @return Document\n     * @throws WSDLException\n     */\n    public Document writeWSDLDocument(Message message,\n                                      Map<String, Definition> mp,\n                                      Map<String, SchemaReference> smp,\n                                      String wsdl,\n                                      String base,\n                                      EndpointInfo endpointInfo) throws WSDLException {\n\n        Document doc = null;\n        Bus bus = message.getExchange().getBus();\n        Definition def = lookupDefinition(bus, mp, wsdl, base);\n        String epurl = base;\n\n        synchronized (def) {\n            //writing a def is not threadsafe.  Sync on it to make sure\n            //we don't get any ConcurrentModificationExceptions\n            epurl = getPublishableEndpointUrl(def, epurl, endpointInfo);\n\n            WSDLWriter wsdlWriter = bus.getExtension(WSDLManager.class)\n                .getWSDLFactory().newWSDLWriter();\n            def.setExtensionRegistry(bus.getExtension(WSDLManager.class).getExtensionRegistry());\n            doc = wsdlWriter.getDocument(def);\n        }\n\n        updateDoc(doc, epurl, mp, smp, message, wsdl);\n        return doc;\n    }","id":26043,"modified_method":"/**\n     * Write the contents of a wsdl Definition object to a file.\n     *\n     * @param message\n     * @param mp  a map of known wsdl Definition objects\n     * @param smp a map of known xsd SchemaReference objects\n     * @param wsdl name of the wsdl file to write\n     * @param base the request URL\n     * @param endpointInfo information for a web service 'port' inside of a service\n     * @return Document\n     * @throws WSDLException\n     */\n    public Document writeWSDLDocument(Message message,\n                                      Map<String, Definition> mp,\n                                      Map<String, SchemaReference> smp,\n                                      String wsdl,\n                                      String base,\n                                      EndpointInfo endpointInfo) throws WSDLException {\n\n        Document doc;\n        Bus bus = message.getExchange().getBus();\n        Definition def = lookupDefinition(bus, mp, wsdl, base);\n        String epurl = base;\n\n        synchronized (def) {\n            //writing a def is not threadsafe.  Sync on it to make sure\n            //we don't get any ConcurrentModificationExceptions\n            epurl = getPublishableEndpointUrl(def, epurl, endpointInfo);\n\n            WSDLWriter wsdlWriter = bus.getExtension(WSDLManager.class)\n                .getWSDLFactory().newWSDLWriter();\n            def.setExtensionRegistry(bus.getExtension(WSDLManager.class).getExtensionRegistry());\n            doc = wsdlWriter.getDocument(def);\n        }\n\n        updateDoc(doc, epurl, mp, smp, message, wsdl);\n        return doc;\n    }","commit_id":"a602c9df3e2e09855410f0e75af9b108620b7794","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Create a wsdl Definition object from the endpoint information and register\n     * it in the local data structure for future reference.\n     *\n     * @param bus CXF's hub for access to internal constructs\n     * @param mp  a map of known wsdl Definition objects\n     * @param message\n     * @param smp a map of known xsd SchemaReference objects\n     * @param base the request URL\n     * @param endpointInfo information for a web service 'port' inside of a service\n     * @throws WSDLException\n     */\n    protected void updateWSDLKeyDefinition(Bus bus,\n                                           Map<String, Definition> mp,\n                                           Message message,\n                                           Map<String, SchemaReference> smp,\n                                           String base,\n                                           EndpointInfo endpointInfo) throws WSDLException {\n        if (!mp.containsKey(\"\")) {\n            ServiceWSDLBuilder builder =\n                new ServiceWSDLBuilder(bus, endpointInfo.getService());\n\n            builder.setUseSchemaImports(\n                MessageUtils.getContextualBoolean(message, WSDL_CREATE_IMPORTS, false));\n\n            // base file name is ignored if createSchemaImports == false!\n            builder.setBaseFileName(endpointInfo.getService().getName().getLocalPart());\n\n            Definition def = builder.build(new HashMap<String, SchemaInfo>());\n\n            mp.put(\"\", def);\n            updateDefinition(bus, def, mp, smp, base, \"\");\n        }\n\n    }","id":26044,"modified_method":"/**\n     * Create a wsdl Definition object from the endpoint information and register\n     * it in the local data structure for future reference.\n     *\n     * @param bus CXF's hub for access to internal constructs\n     * @param mp  a map of known wsdl Definition objects\n     * @param message\n     * @param smp a map of known xsd SchemaReference objects\n     * @param base the request URL\n     * @param endpointInfo information for a web service 'port' inside of a service\n     * @throws WSDLException\n     */\n    protected void updateWSDLKeyDefinition(Bus bus,\n                                           Map<String, Definition> mp,\n                                           Message message,\n                                           Map<String, SchemaReference> smp,\n                                           String base,\n                                           EndpointInfo endpointInfo) throws WSDLException {\n        if (!mp.containsKey(\"\")) {\n            ServiceWSDLBuilder builder =\n                new ServiceWSDLBuilder(bus, endpointInfo.getService());\n\n            builder.setUseSchemaImports(\n                MessageUtils.getContextualBoolean(message, WSDL_CREATE_IMPORTS, false));\n\n            // base file name is ignored if createSchemaImports == false!\n            builder.setBaseFileName(endpointInfo.getService().getName().getLocalPart());\n\n            Definition def = builder.build(new HashMap<String, SchemaInfo>());\n\n            mp.put(\"\", def);\n            updateDefinition(bus, def, mp, smp, base, \"\", \"\");\n        }\n\n    }","commit_id":"a602c9df3e2e09855410f0e75af9b108620b7794","url":"https://github.com/apache/cxf"},{"original_method":"public String map(RefMetaDataTracker tracker, char ref, LocusContext context) \n    {\n        String line = context.getLocation().getContig() + \" \" + context.getLocation().getStart() + \" \" ;\n\t\tHashMap<String,Integer> counts = countReadsBySample(context);\n        for (int i = 0; i < sample_names.size(); i++)\n        {\n            int count = counts.get(sample_names.get(i));\n            line += \" \" + count;\n        }\n        line += \"\\n\";\n        return line;\n    }","id":26045,"modified_method":"public String map(RefMetaDataTracker tracker, char ref, LocusContext context) \n    {\n        String line = context.getLocation().getContig() + \" \" + context.getLocation().getStart() + \" \" ;\n\n\t\tLocusContext[] contexts = filterLocusContext(context, sample_names, 0);\n\n\t\tHashMap<String,Integer> counts = countReadsBySample(context);\n        for (int i = 0; i < contexts.length; i++)\n        {\n\t\t\tList<SAMRecord> reads = contexts[i].getReads();\n\t\t\tList<Integer> offsets = contexts[i].getOffsets();\n\n\t\t\tout.printf(\"%s %s \", context.getLocation(), sample_names.get(i));\n\n\t\t\tint[] forward_counts = new int[4];\n\t\t\tint[] backward_counts = new int[4];\n\n\t\t\tfor (int j = 0; j < reads.size(); j++)\n\t\t\t{\n\t\t\t\tSAMRecord read = reads.get(j);\n\t\t\t\tint offset = offsets.get(j);\n\t\t\t\tboolean backward = read.getReadNegativeStrandFlag();\n\t\t\t\tchar base = Character.toUpperCase((char)(read.getReadBases()[offset]));\n\n\t\t\t\tif (BaseUtils.simpleBaseToBaseIndex(base) == -1) { continue; }\n\n\t\t\t\tif (backward) { base = Character.toLowerCase(base); }\n\n\t\t\t\tif (! backward) { forward_counts[BaseUtils.simpleBaseToBaseIndex(base)]++; }\n\t\t\t\telse { backward_counts[BaseUtils.simpleBaseToBaseIndex(base)]++; }\n\n\t\t\t\t//out.printf(\"%c\", base);\n\t\t\t}\n\t\t\tout.printf(\"A[%d] C[%d] G[%d] T[%d]   a[%d] c[%d] g[%d] t[%d]\",\n\t\t\t\t\t\t\tforward_counts[0],\n\t\t\t\t\t\t\tforward_counts[1],\n\t\t\t\t\t\t\tforward_counts[2],\n\t\t\t\t\t\t\tforward_counts[3],\n\t\t\t\t\t\t\tbackward_counts[0],\n\t\t\t\t\t\t\tbackward_counts[1],\n\t\t\t\t\t\t\tbackward_counts[2],\n\t\t\t\t\t\t\tbackward_counts[3]);\n\t\t\tout.printf(\"\\n\");\n        }\n        return \"\";\n    }","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String reduce(String line, String sum) \n    {\n        out.print(line);\n        return \"\";\n    }","id":26046,"modified_method":"public String reduce(String line, String sum) \n    {\n        //out.print(line);\n\t\tout.flush();\n        return \"\";\n    }","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String reduceInit() \n    { \n        String header = \"contig offset\";\n        for (int i = 0; i < sample_names.size(); i++)\n        {\n            header += \" \" + sample_names.get(i);\n        }\n        header += \"\\n\";\n        out.print(header);\n        return header;\n    }","id":26047,"modified_method":"public String reduceInit() \n    { \n\t\t/*\n        String header = \"contig offset\";\n        for (int i = 0; i < sample_names.size(); i++)\n        {\n            header += \" \" + sample_names.get(i);\n        }\n        header += \"\\n\";\n        out.print(header);\n        return header;\n\t\t*/\n\t\treturn \"\";\n    }","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void add(char ref, char read, byte qual) {\n        for (int i = 0; i < genotypes.length; i++) {\n            likelihoods[i] += calculateAlleleLikelihood(ref, read, genotypes[i], qual);\n        }\n    }","id":26048,"modified_method":"public void add(char ref, char read, byte qual) \n\t{ \n\t\tif (coverage == 0)\n\t\t{\n\t\t\tfor (int i = 0; i < likelihoods.length; i++)\n\t\t\t{\n\t\t\t\tlikelihoods[i] = 0;\n\t\t\t}\n\t\t}\n\t\tdouble sum = 0.0;\n        for (int i = 0; i < genotypes.length; i++) \n\t\t{\n\t\t\tdouble likelihood = calculateAlleleLikelihood(ref, read, genotypes[i], qual); \n            likelihoods[i] += likelihood;\n\t\t\tcoverage += 1;\n        }\n    }","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void initialize(double priorHomRef, double priorHet, double priorHomVar, double[] p2ndon, double[] p2ndoff) {\n        this.priorHomRef = priorHomRef;\n        this.priorHet = priorHet;\n        this.priorHomVar = priorHomVar;\n\n        likelihoods = new double[10];\n        genotypes = new String[10];\n\n        genotypes[0] = \"AA\";\n        genotypes[1] = \"AC\";\n        genotypes[2] = \"AG\";\n        genotypes[3] = \"AT\";\n        genotypes[4] = \"CC\";\n        genotypes[5] = \"CG\";\n        genotypes[6] = \"CT\";\n        genotypes[7] = \"GG\";\n        genotypes[8] = \"GT\";\n        genotypes[9] = \"TT\";\n\n        for (int genotypeIndex = 0; genotypeIndex < 10; genotypeIndex++) {\n            onNextBestBasePriors.put(genotypes[genotypeIndex], p2ndon[genotypeIndex]);\n            offNextBestBasePriors.put(genotypes[genotypeIndex], p2ndoff[genotypeIndex]);\n        }\n    }","id":26049,"modified_method":"private void initialize(double priorHomRef, double priorHet, double priorHomVar, double[] p2ndon, double[] p2ndoff) {\n        this.priorHomRef = priorHomRef;\n        this.priorHet = priorHet;\n        this.priorHomVar = priorHomVar;\n\n        likelihoods = new double[10];\n        genotypes = new String[10];\n\t\tcoverage = 0;\n\n\t\tfor (int i = 0; i < likelihoods.length; i++) { likelihoods[i] = Math.log10(0.1); }\n\n        genotypes[0] = \"AA\";\n        genotypes[1] = \"AC\";\n        genotypes[2] = \"AG\";\n        genotypes[3] = \"AT\";\n        genotypes[4] = \"CC\";\n        genotypes[5] = \"CG\";\n        genotypes[6] = \"CT\";\n        genotypes[7] = \"GG\";\n        genotypes[8] = \"GT\";\n        genotypes[9] = \"TT\";\n\n        for (int genotypeIndex = 0; genotypeIndex < 10; genotypeIndex++) {\n            onNextBestBasePriors.put(genotypes[genotypeIndex], p2ndon[genotypeIndex]);\n            offNextBestBasePriors.put(genotypes[genotypeIndex], p2ndoff[genotypeIndex]);\n        }\n    }","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String toString(char ref) {\n        this.sort();\n        String s = String.format(\"%s %f %f \", this.BestGenotype(), this.LodVsNextBest(), this.LodVsRef(ref));\n        for (int i = 0; i < sorted_genotypes.length; i++) {\n            if (i != 0) {\n                s = s + \" \";\n            }\n            s = s + sorted_genotypes[i] + \":\" + String.format(\"%.2f\", sorted_likelihoods[i]);\n        }\n        return s;\n    }","id":26050,"modified_method":"public String toString(char ref) {\n        this.sort();\n\t\tdouble sum = 0;\n        String s = String.format(\"%s %f %f \", this.BestGenotype(), this.LodVsNextBest(), this.LodVsRef(ref));\n        for (int i = 0; i < sorted_genotypes.length; i++) {\n            if (i != 0) {\n                s = s + \" \";\n            }\n            s = s + sorted_genotypes[i] + \":\" + String.format(\"%.2f\", sorted_likelihoods[i]);\n\t\t\tsum += Math.pow(10,sorted_likelihoods[i]);\n        }\n\t\ts = s + String.format(\" %f\", sum);\n        return s;\n    }","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"public AlleleFrequencyEstimate toAlleleFrequencyEstimate(GenomeLoc location, char ref, int depth, String bases, double[] posteriors, String sample_name) {\n        this.sort();\n        double qhat = Double.NaN;\n        double qstar = Double.NaN;\n        char alt = 'N';\n\n        if ((sorted_genotypes[0].charAt(0) == ref) && (sorted_genotypes[0].charAt(1) == ref)) {\n            // hom-ref\n            qhat = 0.0;\n            qstar = 0.0;\n            alt = 'N';\n        } else if ((sorted_genotypes[0].charAt(0) != ref) && (sorted_genotypes[0].charAt(1) != ref)) {\n            // hom-nonref\n            qhat = 1.0;\n            qstar = 1.0;\n            alt = sorted_genotypes[0].charAt(0);\n        } else {\n            // het\n            qhat = 0.5;\n            qstar = 0.5;\n\n            if (sorted_genotypes[0].charAt(0) != ref) {\n                alt = sorted_genotypes[0].charAt(0);\n            }\n            if (sorted_genotypes[0].charAt(1) != ref) {\n                alt = sorted_genotypes[0].charAt(1);\n            }\n        }\n\n        this.LodVsRef(ref); //HACK\n        //System.out.printf(\"DBG: %f %f\\n\", sorted_likelihoods[0], ref_likelihood);\n\n        return new AlleleFrequencyEstimate(location, ref, alt, 2, qhat, qstar, this.LodVsRef(ref), this.LodVsNextBest(), sorted_likelihoods[0], ref_likelihood, depth, bases, null, this.likelihoods, sample_name);\n    }","id":26051,"modified_method":"public AlleleFrequencyEstimate toAlleleFrequencyEstimate(GenomeLoc location, char ref, int depth, String bases, double[] posteriors, String sample_name) {\n        this.sort();\n        double qhat = Double.NaN;\n        double qstar = Double.NaN;\n        char alt = 'N';\n\n        if ((sorted_genotypes[0].charAt(0) == ref) && (sorted_genotypes[0].charAt(1) == ref)) {\n            // hom-ref\n            qhat = 0.0;\n            qstar = 0.0;\n            alt = 'N';\n        } else if ((sorted_genotypes[0].charAt(0) != ref) && (sorted_genotypes[0].charAt(1) != ref)) {\n            // hom-nonref\n            qhat = 1.0;\n            qstar = 1.0;\n            alt = sorted_genotypes[0].charAt(0);\n        } else {\n            // het\n            qhat = 0.5;\n            qstar = 0.5;\n\n            if (sorted_genotypes[0].charAt(0) != ref) {\n                alt = sorted_genotypes[0].charAt(0);\n            }\n            if (sorted_genotypes[0].charAt(1) != ref) {\n                alt = sorted_genotypes[0].charAt(1);\n            }\n        }\n\n        this.LodVsRef(ref); //HACK\n        //System.out.printf(\"DBG: %f %f\\n\", sorted_likelihoods[0], ref_likelihood);\n\n        AlleleFrequencyEstimate AFE = new AlleleFrequencyEstimate(location, ref, alt, 2, qhat, qstar, this.LodVsRef(ref), this.LodVsNextBest(), sorted_likelihoods[0], ref_likelihood, depth, bases, (double[][]) null, this.likelihoods, sample_name);\n\t\tAFE.genotypeLikelihoods = this;\n\t\treturn AFE;\n    }","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void onTraversalDone(String result) \n    {\n\t\ttry \n\t\t{\n\t\t\tdiscovery_output_file.flush();\n\t\t\tdiscovery_output_file.close();\n\t\t\tindividual_output_file.flush();\n\t\t\tindividual_output_file.close();\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\te.printStackTrace(); \n\t\t}\n\t\treturn;\n    }","id":26052,"modified_method":"public void onTraversalDone(String[] result) \n    {\n\t\ttry \n\t\t{\n\t\t\tdiscovery_output_file.flush();\n\t\t\tdiscovery_output_file.close();\n\t\t\tindividual_output_file.flush();\n\t\t\tindividual_output_file.close();\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\te.printStackTrace(); \n\t\t}\n\t\tout.println(\"PoolCaller done.\\n\");\n\t\treturn;\n    }","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"public AlleleFrequencyEstimate map(RefMetaDataTracker tracker, char ref, LocusContext context) \n    {\n\t\tif (ref == 'N') { return null; }\n\t\tref = Character.toUpperCase(ref);\n\n        // seperate each context.\n        LocusContext forward  = filterLocusContextByStrand(context, \"+\");\n        LocusContext backward = filterLocusContextByStrand(context, \"-\");\n\n\t\tif (forward.getReads().size() == 0) { return null; }\n\t\tif (backward.getReads().size() == 0) { return null; }\n\n\t\tAlleleFrequencyEstimate estimate_both     = EM(tracker, ref, context);\n\t\tAlleleFrequencyEstimate estimate_forward  = EM(tracker, ref, forward);\n\t\tAlleleFrequencyEstimate estimate_backward = EM(tracker, ref, backward);\n\n\t\tdiscovery_output_file.printf(\"%s %c %f %c %f\\n\",\n\t\t\t\testimate_both.asPoolTabularString(),\n\t\t\t\testimate_forward.alt,\n\t\t\t\testimate_forward.lodVsRef,\n\t\t\t\testimate_backward.alt,\n\t\t\t\testimate_backward.lodVsRef);\n\t\t//discovery_output_file.printf(\"%s\\n\", estimate_forward.asPoolTabularString());\n\t\t//discovery_output_file.printf(\"%s\\n\", estimate_backward.asPoolTabularString());\n\t\t//discovery_output_file.printf(\"\\n\");\n\n\t\treturn null;\n\t}","id":26053,"modified_method":"public AlleleFrequencyEstimate[] map(RefMetaDataTracker tracker, char ref, LocusContext context) \n    {\n\t\tif (ref == 'N') { return null; }\n\t\tref = Character.toUpperCase(ref);\n\n        // seperate each context.\n        LocusContext forward  = filterLocusContextByStrand(context, \"+\");\n        LocusContext backward = filterLocusContextByStrand(context, \"-\");\n\n\t\tif (forward.getReads().size() == 0) { return null; }\n\t\tif (backward.getReads().size() == 0) { return null; }\n\n\t\t// Pick the alternate base\n\t\tchar alt = 'N';\n\t\t{\n\t\t\tEM_Result result_both = EM(tracker, ref, context, -1, 'N', 1, lodThreshold, callers);\n\t\t\tint[] counts = new int[4];\n\t\t\tif (result_both.individuals == null) { return null; }\n\t\t\tfor (int i = 0; i < result_both.individuals.length; i++)\n\t\t\t{\n\t\t\t\tif (result_both.individuals[i] == null) { continue; }\n\t\t\t\tif (result_both.individuals[i].lodVsRef >= lodThreshold) \n\t\t\t\t{\n\t\t\t\t\tcounts[BaseUtils.simpleBaseToBaseIndex(result_both.individuals[i].alt)] += 1;\n\t\t\t\t}\n\t\t\t\tInteger[] perm = Utils.SortPermutation(counts);\n\t\t\t\talt = BaseUtils.baseIndexToSimpleBase(perm[3]);\t\n\t\t\t}\n\t\t}\n\n\t\tdouble EM_alt_freq;\n\t\tif (MAX_ITERATIONS == 1) { EM_alt_freq = -1; }\n\t\telse                     { EM_alt_freq = 0.5; }\n\n\t\tEM_Result result_both     = EM(tracker, ref, context, EM_alt_freq, alt, MAX_ITERATIONS, lodThreshold, callers);\n\t\tEM_Result result_forward  = EM(tracker, ref, forward, EM_alt_freq, alt, MAX_ITERATIONS, lodThreshold, callers);\n\t\tEM_Result result_backward = EM(tracker, ref, backward, EM_alt_freq, alt, MAX_ITERATIONS, lodThreshold, callers);\n\n\t\tEM_Result null_both       = EM(tracker, ref, context,  0, alt, 1, 1e-3, callers);\n\t\tEM_Result null_forward    = EM(tracker, ref, forward,  0, alt, 1, 1e-3, callers);\n\t\tEM_Result null_backward   = EM(tracker, ref, backward, 0, alt, 1, 1e-3, callers);\n\n\t\tif (result_both.pool == null) { return null; }\n\t\tAlleleFrequencyEstimate estimate_both = result_both.pool;\n\n\t\tdouble lod_forward;\n\t\tdouble lod_backward;\n\t\tdouble lod_both;\n\t\tdouble strand_score;\n\t\tchar forward_alt;\n\t\tchar backward_alt;\n\n\t\tif ((result_forward.pool == null) ||\n\t\t    (result_backward.pool == null) ||\n\t\t\t(null_both == null) ||\n\t\t\t(null_forward == null) ||\n\t\t    (null_backward == null))\n\t\t{\n\t\t\tlod_forward = 0;\n\t\t\tlod_backward = 0;\n\t\t\tlod_both = 0;\n\t\t\tstrand_score = 0;\n\t\t\tforward_alt = 'N';\n\t\t\tbackward_alt = 'N';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tAlleleFrequencyEstimate estimate_forward       = result_forward.pool;\n\t\t\tAlleleFrequencyEstimate estimate_backward      = result_backward.pool;\n\n\t\n\t\t\tdouble p_D_both     = 0;\n\t\t\tdouble p_D_forward  = 0;\n\t\t\tdouble p_D_backward = 0;\n\t\t\tdouble p_D_null_both = 0;\n\t\t\tdouble p_D_null_forward = 0;\n\t\t\tdouble p_D_null_backward = 0;\n\t\t\tfor (int i = 0; i < result_both.individuals.length; i++)\n\t\t\t{\n\t\t\t\tdouble sum_both = 0;\n\t\t\t\tdouble sum_forward = 0;\n\t\t\t\tdouble sum_backward = 0;\n\t\n\t\t\t\tdouble sum_null_both     = 0;\n\t\t\t\tdouble sum_null_forward  = 0;\n\t\t\t\tdouble sum_null_backward = 0;\n\t\n\t\t\t\tfor (int j = 0; j < result_both.individuals[i].genotypeLikelihoods.likelihoods.length; j++)\n\t\t\t\t{\n\t\t\t\t\tsum_both     += Math.pow(10, result_both.individuals[i].genotypeLikelihoods.likelihoods[j]);\n\t\t\t\t\tsum_forward  += Math.pow(10, result_forward.individuals[i].genotypeLikelihoods.likelihoods[j]);\n\t\t\t\t\tsum_backward += Math.pow(10, result_backward.individuals[i].genotypeLikelihoods.likelihoods[j]);\n\t\t\t\t\tsum_null_both += Math.pow(10, null_both.individuals[i].genotypeLikelihoods.likelihoods[j]);\n\t\t\t\t\tsum_null_forward += Math.pow(10, null_forward.individuals[i].genotypeLikelihoods.likelihoods[j]);\n\t\t\t\t\tsum_null_backward += Math.pow(10, null_backward.individuals[i].genotypeLikelihoods.likelihoods[j]);\n\t\t\t\t}\n\t\n\t\t\t\tp_D_both     += Math.log10(sum_both);\n\t\t\t\tp_D_forward  += Math.log10(sum_forward);\n\t\t\t\tp_D_backward += Math.log10(sum_backward);\n\t\n\t\t\t\tp_D_null_both     += Math.log10(sum_null_both);\n\t\t\t\tp_D_null_forward  += Math.log10(sum_null_forward);\n\t\t\t\tp_D_null_backward += Math.log10(sum_null_backward);\n\t\t\t}\n\t\t\tforward_alt = estimate_forward.alt;\n\t\t\tbackward_alt = estimate_backward.alt;\n\t\t\tlod_forward  = (p_D_forward  + p_D_null_backward) - p_D_null_both;\n\t\t\tlod_backward = (p_D_backward + p_D_null_backward) - p_D_null_both;\n\t\t\tlod_both     = p_D_both - p_D_null_both;\n\t\t\tstrand_score = Math.max(lod_forward - lod_both, lod_backward - lod_both);\n\t\t}\n\n\t\tSystem.out.printf(\"DBG %s %f %f %f %f\\n\", context.getLocation(), result_both.pool.pBest, null_both.pool.pBest, result_both.pool.pRef, null_both.pool.pBest);\n\n\t\tdiscovery_output_file.printf(\"%s %c %c %f\\n\",\n\t\t\t\testimate_both.asPoolTabularString(),\n\t\t\t\tforward_alt,\n\t\t\t\tbackward_alt,\n\t\t\t\tstrand_score);\n\n\t\treturn result_both.individuals;\n\t}","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String reduce(AlleleFrequencyEstimate alleleFreq, String sum) \n    {\n\t\tif (calls == null) { return \"\"; }\n\t\tfor (int i = 0; i < callers.size(); i++)\n\t\t{\n\t\t\tif (calls == null) { System.err.printf(\"calls == null\\n\"); }\n\t\t\tif (calls[i] == null) { System.err.printf(\"calls[%d] == null\\n\", i); }\n\t\t\tif (caller_sums == null) { System.err.printf(\"caller_sums == null\\n\"); }\n\t\t\tif (callers.get(i) == null) { System.err.printf(\"callers[%d] == null\\n\", i); }\n\t\t\tif (caller_sums.get(i) == null) { System.err.printf(\"caller_sums[%d] == null\\n\", i); }\n\t\t\tcaller_sums.set(i, callers.get(i).reduce(calls[i], caller_sums.get(i))); \n\t\t}\n        return \"\";\n    }","id":26054,"modified_method":"public String[] reduce(AlleleFrequencyEstimate[] alleleFreqs, String[] sum) \n    {\n\t\tif (alleleFreqs == null) { return sum; }\n\t\tfor (int i = 0; i < callers.size(); i++)\n\t\t{\n\t\t\tsum[i] = callers.get(i).reduce(alleleFreqs[i], sum[i]);\n\t\t}\n        return sum;\n    }","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"private AlleleFrequencyEstimate EM(RefMetaDataTracker tracker, char ref, LocusContext context)\n\t{\n\t\tif (context.getReads().size() == 0) { return null; }\n        LocusContext[] contexts = filterLocusContext(context, sample_names, 0);\n\n        // EM Loop:\n\t    double EM_alt_freq;\n\t    double EM_N = 0;\n\t\tcalls = null;\n\n\t\t// this line is kinda hacky\n\t\tif (MAX_ITERATIONS == 1) { EM_alt_freq = -1; }\n\t\telse { EM_alt_freq = 0.5; }\n\n        // (this loop is the EM cycle)\n        double[] trajectory = new double[MAX_ITERATIONS + 1]; trajectory[0] = EM_alt_freq;\n        double[] likelihood_trajectory = new double[MAX_ITERATIONS + 1]; likelihood_trajectory[0] = 0.0;\n        boolean is_a_snp = false;\n\n\t\t// Pick the alternate base\n\t\tchar alt = 'N';\n\t\t{\n        \tReadBackedPileup pileup = new ReadBackedPileup(ref, context);\n\t\t\tString bases = pileup.getBases();\n\t\t\tint A = 0;\n\t\t\tint C = 0;\n\t\t\tint G = 0; \n\t\t\tint T = 0;\n\t\t\tint max_count = -1;\n\t\t\tfor (int i = 0; i < bases.length(); i++)\n\t\t\t{\n\t\t\t\tchar b = bases.charAt(i);\n\t\t\t\tif (b == ref) { continue; }\n\t\t\t\tswitch (b)\n\t\t\t\t{\n\t\t\t\t\tcase 'A' : A += 1; if (A > max_count) { max_count = A; alt = 'A'; } break;\n\t\t\t\t\tcase 'C' : C += 1; if (C > max_count) { max_count = C; alt = 'C'; } break;\n\t\t\t\t\tcase 'G' : G += 1; if (G > max_count) { max_count = G; alt = 'G'; } break;\n\t\t\t\t\tcase 'T' : T += 1; if (T > max_count) { max_count = T; alt = 'T'; } break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        for (int iterations = 0; iterations < MAX_ITERATIONS; iterations++)\n        { \n\t        // 6. Re-call from shallow coverage using the estimated frequency as a prior, \n\t        //    and compare to true deep calls, \n\t        //    and compute new MAF estimate.\n\t        calls = new AlleleFrequencyEstimate[sample_names.size()];\n\t        EM_N        = 0.0;\n            double EM_sum = 0.0;\n            double likelihood = 0.0;\n            is_a_snp = false;\n\n\t        for (int i = 0; i < sample_names.size(); i++)\n\t        {\n\t                callers.get(i).setAlleleFrequencyPrior(EM_alt_freq, alt);\n\t                calls[i] = callers.get(i).map(tracker, ref, contexts[i]);\n\t                String genotype = calls[i].genotype();\n\n\t\t\t\t\tif (calls[i].depth == 0) { continue; }\n\n                    likelihood += calls[i].pBest;\n\t\n                    if (! FRACTIONAL_COUNTS)\n                    {\n\t                \t\t//System.out.printf(\"DBG: %s %f %f\\n\",\n\t\t\t\t\t\t\t//\t\t\t\tcontext.getLocation(),\n\t                        //              calls[i].lodVsNextBest,\n\t                        //              calls[i].lodVsRef);\n\t\t\t\t            EM_sum += calls[i].emperical_allele_frequency() * calls[i].N;\n\t\t\t\t            EM_N   += calls[i].N;\n                    }\n                    else\n                    {\n\t                    for (int j = 0; j <= calls[i].N; j++)\n\t                    {\n                            if (Double.isInfinite(calls[i].posteriors[j])) { calls[i].posteriors[j] = -10000; }\n\t                        System.out.printf(\"DBG3: %d %f %d\\n\", j, calls[i].posteriors[j], calls[i].N);\n\t                        EM_sum += Math.pow(10,calls[i].posteriors[j]) * (double)j;\n\t                        EM_N   += calls[i].N;\n\t                    }\n                    }   \n\n            }\n\t        EM_alt_freq = Math.min(EM_sum / EM_N, 0.99999);\n            trajectory[iterations+1] = EM_alt_freq;\n            likelihood_trajectory[iterations+1] = likelihood;\n\n\t\t\tif (likelihood_trajectory[iterations] == likelihood_trajectory[iterations+1]) { break; }\n\n            //System.out.printf(\"DBGTRAJ %s %f %f %f %f %f %f\\n\", \n\t\t\t//\t\t\t\t\t\tcontext.getLocation(),\n\t\t\t//\t\t\t\t\t\tEM_sum, \n\t\t\t//\t\t\t\t\t\tEM_N, \n\t\t\t//\t\t\t\t\t\ttrajectory[iterations], \n\t\t\t//\t\t\t\t\t\ttrajectory[iterations+1], \n\t\t\t//\t\t\t\t\t\tlikelihood_trajectory[iterations],\n\t\t\t//\t\t\t\t\t\tlikelihood_trajectory[iterations+1]);\n        }\n\n        // 7. Output some statistics.\n\t\tdouble discovery_likelihood = 0;\n\t\tdouble discovery_null = 0;\n\t\tdouble discovery_prior = 0;\n\t\tdouble discovery_null_prior = 0;\n\t\tint n_ref = 0;\n\t\tint n_het = 0;\n\t\tint n_hom = 0;\n\t\tfor (int i = 1; i < EM_N-1; i++)\n\t\t{\n\t\t\t//discovery_prior += 1e-3/(double)i;\n\t\t}\n\t\t//discovery_prior = Math.log10(discovery_prior);\n\t\t//discovery_null_prior = Math.log10(1.0 - discovery_prior);\n\t\tfor (int i = 0; i < sample_names.size(); i++)\n\t\t{\n\t\t\tif (calls[i].depth == 0) { continue; }\n\n\t\t\tdiscovery_likelihood += calls[i].pBest;\n\t\t\tdiscovery_null       += calls[i].pRef;\n\t\t\t//System.out.printf(\"DBG %f %f %c %s\\n\", calls[i].pBest, calls[i].pRef, ref, calls[i].bases);\n\t\t\n\t\t\tif (calls[i].qhat == 0.0) { n_ref += 1; }\t\n\t\t\tif (calls[i].qhat == 0.5) { n_het += 1; }\t\n\t\t\tif (calls[i].qhat == 1.0) { n_hom += 1; }\t\n\t\t}\n\t\tdouble discovery_lod = (discovery_likelihood + discovery_prior) - (discovery_null + discovery_null_prior);\n\t\tif (discovery_lod <= 0) { alt = 'N'; }\n\t\t//discovery_output_file.printf(\"%s %c %c %f %f %f %f %f %f %d %d %d\\n\", context.getLocation(), ref, alt, EM_alt_freq, discovery_likelihood, discovery_null, discovery_prior, discovery_lod, EM_N, n_ref, n_het, n_hom);\n\n\t\tAlleleFrequencyEstimate estimate = new AlleleFrequencyEstimate(context.getLocation(), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\talt, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(int)EM_N, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tEM_alt_freq, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tEM_alt_freq, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdiscovery_lod,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdiscovery_likelihood + discovery_prior,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdiscovery_null + discovery_prior,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontext.getReads().size(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(String)null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(double[][])null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(double[])null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(String)null);\n\t\testimate.n_ref = n_ref; // HACK\n\t\testimate.n_het = n_het; // HACK\n\t\testimate.n_hom = n_hom; // HACK\n\t\treturn estimate;\n\n\n        //for (int i = 0; i < likelihood_trajectory.length; i++)\n        //{\n        //    System.out.printf(\"TRAJECTORY %f %f\\n\", trajectory[i], likelihood_trajectory[i]);\n        //}\n        //System.out.print(\"\\n\\n\");\n    }","id":26055,"modified_method":"private EM_Result EM(RefMetaDataTracker tracker, char ref, LocusContext context, double EM_alt_freq, char alt, int MAX_ITERATIONS, double lodThreshold, List<SingleSampleGenotyper> callers)\n\t{\n\t\tif (context.getReads().size() == 0) { return null; }\n        LocusContext[] contexts = filterLocusContext(context, sample_names, 0);\n\n        // EM Loop:\n\t    double EM_N = 0;\n\t\tAlleleFrequencyEstimate[] calls = null;\n\n        // (this loop is the EM cycle)\n        double[] trajectory = new double[MAX_ITERATIONS + 1]; trajectory[0] = EM_alt_freq;\n        double[] likelihood_trajectory = new double[MAX_ITERATIONS + 1]; likelihood_trajectory[0] = 0.0;\n        boolean is_a_snp = false;\n\n        for (int iterations = 0; iterations < MAX_ITERATIONS; iterations++)\n        { \n\t        // 6. Re-call from shallow coverage using the estimated frequency as a prior, \n\t        //    and compare to true deep calls, \n\t        //    and compute new MAF estimate.\n\t        calls = new AlleleFrequencyEstimate[sample_names.size()];\n\t        EM_N        = 0.0;\n            double EM_sum = 0.0;\n            double likelihood = 0.0;\n            is_a_snp = false;\n\n\t        for (int i = 0; i < sample_names.size(); i++)\n\t        {\n\t                callers.get(i).setAlleleFrequencyPrior(EM_alt_freq, alt);\n\t                calls[i] = callers.get(i).map(tracker, ref, contexts[i]);\n\t                String genotype = calls[i].genotype();\n\n\t\t\t\t\tif (calls[i].depth == 0) { continue; }\n\n                    likelihood += calls[i].pBest;\n\t\n                    if (! FRACTIONAL_COUNTS)\n                    {\n\t\t\t\t\t\t\tif (Math.abs(calls[i].lodVsRef) >= lodThreshold) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tEM_sum += calls[i].emperical_allele_frequency() * calls[i].N;\n\t\t\t\t\t            EM_N   += calls[i].N;\n\t\t\t\t\t\t\t}\n                    }\n                    else\n                    {\n\t                    for (int j = 0; j <= calls[i].N; j++)\n\t                    {\n                            if (Double.isInfinite(calls[i].posteriors[j])) { calls[i].posteriors[j] = -10000; }\n\t                        System.out.printf(\"DBG3: %d %f %d\\n\", j, calls[i].posteriors[j], calls[i].N);\n\t                        EM_sum += Math.pow(10,calls[i].posteriors[j]) * (double)j;\n\t                        EM_N   += calls[i].N;\n\t                    }\n                    }   \n\n            }\n\t        EM_alt_freq = Math.min(EM_sum / EM_N, 0.99999);\n            trajectory[iterations+1] = EM_alt_freq;\n            likelihood_trajectory[iterations+1] = likelihood;\n\n\t\t\tif (likelihood_trajectory[iterations] == likelihood_trajectory[iterations+1]) { break; }\n\n\t\t\t/*\n            System.out.printf(\"DBGTRAJ %s %f %f %f %f %f %f\\n\", \n\t\t\t\t\t\t\t\t\tcontext.getLocation(),\n\t\t\t\t\t\t\t\t\tEM_sum, \n\t\t\t\t\t\t\t\t\tEM_N, \n\t\t\t\t\t\t\t\t\ttrajectory[iterations], \n\t\t\t\t\t\t\t\t\ttrajectory[iterations+1], \n\t\t\t\t\t\t\t\t\tlikelihood_trajectory[iterations],\n\t\t\t\t\t\t\t\t\tlikelihood_trajectory[iterations+1]);\n\t\t\t*/\n        }\n\n        // 7. Output some statistics.\n\t\tdouble discovery_likelihood = 0;\n\t\tdouble discovery_null = 0;\n\t\tdouble discovery_prior = 0;\n\t\tdouble discovery_null_prior = 0;\n\t\tint n_ref = 0;\n\t\tint n_het = 0;\n\t\tint n_hom = 0;\n\t\tfor (int i = 1; i < EM_N-1; i++)\n\t\t{\n\t\t\t//discovery_prior += 1e-3/(double)i;\n\t\t}\n\t\t//discovery_prior = Math.log10(discovery_prior);\n\t\t//discovery_null_prior = Math.log10(1.0 - discovery_prior);\n\t\tfor (int i = 0; i < sample_names.size(); i++)\n\t\t{\n\t\t\tif (calls[i].depth == 0) { continue; }\n\n\t\t\tif (calls[i].lodVsRef < lodThreshold) { continue; }\n\n\t\t\tdiscovery_likelihood += calls[i].pBest;\n\t\t\tdiscovery_null       += calls[i].pRef;\n\t\t\n\t\t\tif (calls[i].qhat == 0.0) { n_ref += 1; }\t\n\t\t\tif (calls[i].qhat == 0.5) { n_het += 1; }\t\n\t\t\tif (calls[i].qhat == 1.0) { n_hom += 1; }\t\n\t\t}\n\t\tdouble discovery_lod = (discovery_likelihood + discovery_prior) - (discovery_null + discovery_null_prior);\n\t\tif (discovery_lod <= 0) { alt = 'N'; }\n\t\t//discovery_output_file.printf(\"%s %c %c %f %f %f %f %f %f %d %d %d\\n\", context.getLocation(), ref, alt, EM_alt_freq, discovery_likelihood, discovery_null, discovery_prior, discovery_lod, EM_N, n_ref, n_het, n_hom);\n\n\t\tif (EM_N == 0) { return new EM_Result(); }\n\n\t\tAlleleFrequencyEstimate estimate = new AlleleFrequencyEstimate(context.getLocation(), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\talt, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(int)EM_N, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tEM_alt_freq, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tEM_alt_freq, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdiscovery_lod,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdiscovery_likelihood + discovery_prior,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdiscovery_null + discovery_prior,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontext.getReads().size(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(String)null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(double[][])null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(double[])null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(String)null);\n\t\testimate.n_ref = n_ref; // HACK\n\t\testimate.n_het = n_het; // HACK\n\t\testimate.n_hom = n_hom; // HACK\n\t\treturn new EM_Result(estimate, calls);\n\n\n        //for (int i = 0; i < likelihood_trajectory.length; i++)\n        //{\n        //    System.out.printf(\"TRAJECTORY %f %f\\n\", trajectory[i], likelihood_trajectory[i]);\n        //}\n        //System.out.print(\"\\n\\n\");\n    }","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() \n    { \n\t\ttry\n\t\t{\n\t\t\tdiscovery_output_file = new PrintStream(DISCOVERY_OUTPUT);\n\t\t\tindividual_output_file = new PrintStream(new GZIPOutputStream(new FileOutputStream(INDIVIDUAL_OUTPUT)));\n\t\t\tindividual_output_file.println(AlleleFrequencyEstimate.asTabularStringHeader());\n\t\t} \n\t\tcatch (Exception e)\n\t\t{\n\t\t\te.printStackTrace(); \n\t\t\tSystem.exit(-1);\n\t\t}\n\n        GenomeAnalysisEngine toolkit = this.getToolkit();\n        this.header = toolkit.getEngine().getSAMHeader();\n        List<SAMReadGroupRecord> read_groups = header.getReadGroups();\n\n        /*\n        GenomeAnalysisEngine toolkit = this.getToolkit();\n        SAMFileHeader header = toolkit.getSamReader().getFileHeader();\n        List<SAMReadGroupRecord> read_groups = header.getReadGroups();\n        */\n\n        sample_names    = new ArrayList<String>();\n        callers         = new ArrayList<SingleSampleGenotyper>();\n\t\tcaller_sums     = new ArrayList<String>();\n\n        random = new Random(42);\n\n\t\tHashSet<String> unique_sample_names = new HashSet<String>();\n\n        for (int i = 0; i < read_groups.size(); i++)\n        {\n            String sample_name = read_groups.get(i).getSample();\n\n\t\t\tif (SAMPLE_NAME_REGEX != null) { sample_name = sample_name.replaceAll(SAMPLE_NAME_REGEX, \"$1\"); }\n\n\t\t\tif (unique_sample_names.contains(sample_name)) { continue; }\n\t\t\tunique_sample_names.add(sample_name);\n            sample_names.add(sample_name);\n            System.out.println(\"SAMPLE: \" + sample_name);\n\n            SingleSampleGenotyper caller = new SingleSampleGenotyper();\n\t\t\tcaller.VARIANTS_FILE = null;\n\t\t\tcaller.METRICS_FILE = null;\n            caller.LOD_THRESHOLD = lodThreshold;\n            caller.IGNORE_SECONDARY_BASES = true;\n            caller.SUPPRESS_METRICS = true;\n\t\t\tcaller.SAMPLE_NAME_REGEX = SAMPLE_NAME_REGEX;\n            caller.initialize();\n\t\t\tcaller.variantsOut = individual_output_file;\n\t\t\tcaller_sums.add(caller.reduceInit());\n            callers.add(caller);\n        } \n    }","id":26056,"modified_method":"public void initialize() \n    { \n\t\ttry\n\t\t{\n\t\t\tdiscovery_output_file = new PrintStream(DISCOVERY_OUTPUT);\n\t\t\tindividual_output_file = new PrintStream(new GZIPOutputStream(new FileOutputStream(INDIVIDUAL_OUTPUT)));\n\t\t\tindividual_output_file.println(AlleleFrequencyEstimate.asTabularStringHeader());\n\t\t} \n\t\tcatch (Exception e)\n\t\t{\n\t\t\te.printStackTrace(); \n\t\t\tSystem.exit(-1);\n\t\t}\n\n        GenomeAnalysisEngine toolkit = this.getToolkit();\n        this.header = toolkit.getEngine().getSAMHeader();\n        List<SAMReadGroupRecord> read_groups = header.getReadGroups();\n\n        sample_names    = new ArrayList<String>();\n        callers         = new ArrayList<SingleSampleGenotyper>();\n\n        random = new Random(42);\n\n\t\tHashSet<String> unique_sample_names = new HashSet<String>();\n\n        for (int i = 0; i < read_groups.size(); i++)\n        {\n            String sample_name = read_groups.get(i).getSample();\n\n\t\t\tif (SAMPLE_NAME_REGEX != null) { sample_name = sample_name.replaceAll(SAMPLE_NAME_REGEX, \"$1\"); }\n\n\t\t\tif (unique_sample_names.contains(sample_name)) { continue; }\n\t\t\tunique_sample_names.add(sample_name);\n            sample_names.add(sample_name);\n            System.out.println(\"SAMPLE: \" + sample_name);\n\n            SingleSampleGenotyper caller = new SingleSampleGenotyper();\n\t\t\tcaller.VARIANTS_FILE = null;\n\t\t\tcaller.METRICS_FILE = null;\n            caller.LOD_THRESHOLD = lodThreshold;\n            caller.IGNORE_SECONDARY_BASES = true;\n            caller.SUPPRESS_METRICS = true;\n\t\t\tcaller.SAMPLE_NAME_REGEX = SAMPLE_NAME_REGEX;\n            caller.initialize();\n\t\t\tcaller.variantsOut = individual_output_file;\n            callers.add(caller);\n        } \n    }","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String reduceInit() \n    { \n\t\tdiscovery_output_file.printf(\"loc ref alt EM_alt_freq discovery_likelihood discovery_null discovery_prior discovery_lod EM_N n_ref n_het n_hom fw_alt fw_lod bw_alt bw_lod\\n\");\n\t\tfor (int i = 0; i < callers.size(); i++)\n\t\t{\n\t\t\tcallers.get(i).reduceInit(); \n\t\t}\n\t\treturn \"\";\n    }","id":26057,"modified_method":"public String[] reduceInit() \n    { \n\t\tdiscovery_output_file.printf(\"loc ref alt EM_alt_freq discovery_likelihood discovery_null discovery_prior discovery_lod EM_N n_ref n_het n_hom fw_alt bw_alt strand_score\\n\");\n\t\tString[] single_sample_reduce_sums = new String[callers.size()];\n\t\tfor (int i = 0; i < callers.size(); i++)\n\t\t{\n\t\t\tsingle_sample_reduce_sums[i] = callers.get(i).reduceInit(); \n\t\t}\n\t\treturn single_sample_reduce_sums;\n    }","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Initialize values appropriately for the reduce step.\n     *\n     * @return an empty string\n     */\n    public String reduceInit() {\n        confident_ref_interval_contig  = \"\";\n        confident_ref_interval_start   = 0;\n        confident_ref_interval_LOD_sum = 0;\n        confident_ref_interval_length  = 0;\n        last_position_considered       = -1;\n        inside_confident_ref_interval  = false;\n        return \"\";\n    }","id":26058,"modified_method":"/**\n     * Initialize values appropriately for the reduce step.\n     *\n     * @return an empty string\n     */\n    public String reduceInit() {\n        return \"\";\n    }","commit_id":"4f6d26849ffdcc6ee36b3f97a42b5513a42a2384","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n   public GetTranslationHistoryResult execute(GetTranslationHistoryAction action, ExecutionContext context) throws ActionException\n   {\n      identity.checkLoggedIn();\n      log.debug(\"get translation history for text flow id {}\", action.getTransUnitId());\n\n      HLocale hLocale;\n      try\n      {\n         hLocale = localeServiceImpl.validateLocaleByProjectIteration(action.getWorkspaceId().getLocaleId(), action.getWorkspaceId().getProjectIterationId().getProjectSlug(), action.getWorkspaceId().getProjectIterationId().getIterationSlug());\n      }\n      catch (ZanataServiceException e)\n      {\n         throw new ActionException(e);\n      }\n\n      HTextFlow hTextFlow = textFlowDAO.findById(action.getTransUnitId().getId(), false);\n\n      HTextFlowTarget hTextFlowTarget = hTextFlow.getTargets().get(hLocale.getId());\n      Map<Integer,HTextFlowTargetHistory> history = Maps.newHashMap();\n      TransHistoryItem latest = null;\n      SimpleDateFormat dateFormat = new SimpleDateFormat();\n      if (hTextFlowTarget != null)\n      {\n         latest = new TransHistoryItem(hTextFlowTarget.getVersionNum().toString(), hTextFlowTarget.getContents(),\n               hTextFlowTarget.getState(), hTextFlowTarget.getLastModifiedBy().getName(),\n               dateFormat.format(hTextFlowTarget.getLastChanged()));\n         // history translation\n         history = hTextFlowTarget.getHistory();\n      }\n\n      Iterable<TransHistoryItem> historyItems = Iterables.transform(history.values(), new TargetHistoryToTransHistoryItemFunction(dateFormat));\n      log.debug(\"found {} history for text flow id {}\", Iterables.size(historyItems), action.getTransUnitId());\n      return new GetTranslationHistoryResult(historyItems, latest);\n   }","id":26059,"modified_method":"@Override\n   public GetTranslationHistoryResult execute(GetTranslationHistoryAction action, ExecutionContext context) throws ActionException\n   {\n      identity.checkLoggedIn();\n      log.debug(\"get translation history for text flow id {}\", action.getTransUnitId());\n\n      HLocale hLocale;\n      try\n      {\n         hLocale = localeServiceImpl.validateLocaleByProjectIteration(action.getWorkspaceId().getLocaleId(), action.getWorkspaceId().getProjectIterationId().getProjectSlug(), action.getWorkspaceId().getProjectIterationId().getIterationSlug());\n      }\n      catch (ZanataServiceException e)\n      {\n         throw new ActionException(e);\n      }\n\n      HTextFlow hTextFlow = textFlowDAO.findById(action.getTransUnitId().getId(), false);\n\n      HTextFlowTarget hTextFlowTarget = hTextFlow.getTargets().get(hLocale.getId());\n      Map<Integer,HTextFlowTargetHistory> history = Maps.newHashMap();\n      TransHistoryItem latest = null;\n      SimpleDateFormat dateFormat = new SimpleDateFormat();\n      if (hTextFlowTarget != null)\n      {\n         String lastModifiedBy = \"unknown\";\n         String lastModifiedDate = \"unknown\";\n         if (hTextFlowTarget.getLastModifiedBy() != null)\n         {\n            lastModifiedBy = hTextFlowTarget.getLastModifiedBy().getName();\n            lastModifiedDate = dateFormat.format(hTextFlowTarget.getLastChanged());\n         }\n         latest = new TransHistoryItem(hTextFlowTarget.getVersionNum().toString(), hTextFlowTarget.getContents(),\n               hTextFlowTarget.getState(), lastModifiedBy, lastModifiedDate);\n         // history translation\n         history = hTextFlowTarget.getHistory();\n      }\n\n      Iterable<TransHistoryItem> historyItems = Iterables.transform(history.values(), new TargetHistoryToTransHistoryItemFunction(dateFormat));\n      log.debug(\"found {} history for text flow id {}\", Iterables.size(historyItems), action.getTransUnitId());\n      return new GetTranslationHistoryResult(historyItems, latest);\n   }","commit_id":"909ce30898cbb98e5e89147830fd6c2581af7c1e","url":"https://github.com/zanata/zanata-server"},{"original_method":"private TranslationStatistics getMessageStats(TransUnitCount unitCount, LocaleId locale, Date lastChanged, String lastModifiedBy)\n   {\n      TranslationStatistics stats = new TranslationStatistics(unitCount, locale.getId());\n      stats.setLastTranslated(getLastTranslated(lastChanged, lastModifiedBy));\n      \n      return stats;\n   }","id":26060,"modified_method":"private TranslationStatistics getMessageStats(TransUnitCount unitCount, LocaleId locale, Date lastChanged, String lastModifiedBy)\n   {\n      TranslationStatistics stats = new TranslationStatistics(unitCount, locale.getId());\n      stats.setLastTranslatedBy(lastModifiedBy);\n      stats.setLastTranslatedDate(lastChanged);\n      stats.setLastTranslated(getLastTranslated(lastChanged, lastModifiedBy));\n      \n      return stats;\n   }","commit_id":"324961ecb662261dfb147f1a6d06634ad34e0e69","url":"https://github.com/zanata/zanata-server"},{"original_method":"private TranslationStatistics getWordsStats(TransUnitWords wordCount, LocaleId locale, Date lastChanged, String lastModifiedBy)\n   {\n      TranslationStatistics stats = new TranslationStatistics(wordCount, locale.getId());\n      stats.setLastTranslated(getLastTranslated(lastChanged, lastModifiedBy));\n      \n      return stats;\n   }","id":26061,"modified_method":"private TranslationStatistics getWordsStats(TransUnitWords wordCount, LocaleId locale, Date lastChanged, String lastModifiedBy)\n   {\n      TranslationStatistics stats = new TranslationStatistics(wordCount, locale.getId());\n      stats.setLastTranslatedBy(lastModifiedBy);\n      stats.setLastTranslatedDate(lastChanged);\n      stats.setLastTranslated(getLastTranslated(lastChanged, lastModifiedBy));\n      \n      return stats;\n   }","commit_id":"324961ecb662261dfb147f1a6d06634ad34e0e69","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public ContainerTranslationStatistics getStatistics(String projectSlug, String iterationSlug, String docId, boolean includeWordStats, String[] locales)\n   {\n      LocaleId[] localeIds;\n\n      // if no locales are specified, search in all locales\n      if (locales.length == 0)\n      {\n         List<HLocale> iterationLocales = localeServiceImpl.getSupportedLangugeByProjectIteration(projectSlug, iterationSlug);\n         localeIds = new LocaleId[iterationLocales.size()];\n         for (int i = 0, iterationLocalesSize = iterationLocales.size(); i < iterationLocalesSize; i++)\n         {\n            HLocale loc = iterationLocales.get(i);\n            localeIds[i] = loc.getLocaleId();\n         }\n      }\n      else\n      {\n         localeIds = new LocaleId[locales.length];\n         for (int i = 0; i < locales.length; i++)\n         {\n            localeIds[i] = new LocaleId(locales[i]);\n         }\n      }\n\n      HDocument document = documentDAO.getByProjectIterationAndDocId(projectSlug, iterationSlug, docId);\n\n      if (document == null)\n      {\n         throw new NoSuchEntityException(projectSlug + \"/\" + iterationSlug + \"/\" + docId);\n      }\n\n      Map<LocaleId, CommonContainerTranslationStatistics> statsMap = documentDAO.getStatistics(document.getId(), localeIds);\n\n      ContainerTranslationStatistics docStats = new ContainerTranslationStatistics();\n      docStats.setId(docId);\n      docStats.addRef(new Link(URI.create(zPathService.generatePathForDocument(document)), \"statSource\", \"DOC\"));\n\n      long docTotalMssgs = documentDAO.getTotalCountForDocument(document);\n\n      long docTotalWords = 0;\n      if (includeWordStats)\n      {\n         docTotalWords = documentDAO.getTotalWordCountForDocument(document);\n      }\n\n      for (LocaleId locale : localeIds)\n      {\n         CommonContainerTranslationStatistics stats = statsMap.get(locale);\n         \n         // trans unit level stats\n         TranslationStatistics transUnitStats;\n         if (stats == null)\n         {\n            transUnitStats = new TranslationStatistics(new TransUnitCount(0, 0, (int) docTotalMssgs), locale.getId());\n         }\n         else\n         {\n            transUnitStats = stats.getStats(locale.getId(), StatUnit.MESSAGE);\n         }\n         DocumentStatus docStat = translationStateCacheImpl.getDocStats(document.getId(), locale);\n\n         transUnitStats.setLastTranslated(getLastTranslated(docStat.getLastTranslatedDate(), docStat.getLastTranslatedBy()));\n         transUnitStats.setRemainingHours(getRemainingHours(transUnitStats.getDraft(), transUnitStats.getUntranslated()));\n         docStats.addStats(transUnitStats);\n\n         // word level stats\n         if (includeWordStats)\n         {\n            TranslationStatistics wordsStats;\n            if (stats == null)\n            {\n               wordsStats = new TranslationStatistics(new TransUnitWords(0, 0, (int) docTotalWords), locale.getId());\n            }\n            else\n            {\n               wordsStats = stats.getStats(locale.getId(), StatUnit.WORD);\n            }\n            wordsStats.setLastTranslated(getLastTranslated(docStat.getLastTranslatedDate(), docStat.getLastTranslatedBy()));\n            wordsStats.setRemainingHours(getRemainingHours(wordsStats.getDraft(), wordsStats.getUntranslated()));\n            docStats.addStats(wordsStats);\n         }\n      }\n\n      return docStats;\n   }","id":26062,"modified_method":"@Override\n   public ContainerTranslationStatistics getStatistics(String projectSlug, String iterationSlug, String docId, boolean includeWordStats, String[] locales)\n   {\n      LocaleId[] localeIds;\n\n      // if no locales are specified, search in all locales\n      if (locales.length == 0)\n      {\n         List<HLocale> iterationLocales = localeServiceImpl.getSupportedLangugeByProjectIteration(projectSlug, iterationSlug);\n         localeIds = new LocaleId[iterationLocales.size()];\n         for (int i = 0, iterationLocalesSize = iterationLocales.size(); i < iterationLocalesSize; i++)\n         {\n            HLocale loc = iterationLocales.get(i);\n            localeIds[i] = loc.getLocaleId();\n         }\n      }\n      else\n      {\n         localeIds = new LocaleId[locales.length];\n         for (int i = 0; i < locales.length; i++)\n         {\n            localeIds[i] = new LocaleId(locales[i]);\n         }\n      }\n\n      HDocument document = documentDAO.getByProjectIterationAndDocId(projectSlug, iterationSlug, docId);\n\n      if (document == null)\n      {\n         throw new NoSuchEntityException(projectSlug + \"/\" + iterationSlug + \"/\" + docId);\n      }\n\n      Map<LocaleId, CommonContainerTranslationStatistics> statsMap = documentDAO.getStatistics(document.getId(), localeIds);\n\n      ContainerTranslationStatistics docStats = new ContainerTranslationStatistics();\n      docStats.setId(docId);\n      docStats.addRef(new Link(URI.create(zPathService.generatePathForDocument(document)), \"statSource\", \"DOC\"));\n\n      long docTotalMssgs = documentDAO.getTotalCountForDocument(document);\n\n      long docTotalWords = 0;\n      if (includeWordStats)\n      {\n         docTotalWords = documentDAO.getTotalWordCountForDocument(document);\n      }\n\n      for (LocaleId locale : localeIds)\n      {\n         CommonContainerTranslationStatistics stats = statsMap.get(locale);\n         \n         // trans unit level stats\n         TranslationStatistics transUnitStats;\n         if (stats == null)\n         {\n            transUnitStats = new TranslationStatistics(new TransUnitCount(0, 0, (int) docTotalMssgs), locale.getId());\n         }\n         else\n         {\n            transUnitStats = stats.getStats(locale.getId(), StatUnit.MESSAGE);\n         }\n         DocumentStatus docStat = translationStateCacheImpl.getDocStats(document.getId(), locale);\n\n         transUnitStats.setLastTranslatedBy(docStat.getLastTranslatedBy());\n         transUnitStats.setLastTranslatedDate(docStat.getLastTranslatedDate());\n         transUnitStats.setLastTranslated(getLastTranslated(docStat.getLastTranslatedDate(), docStat.getLastTranslatedBy()));\n         \n         transUnitStats.setRemainingHours(getRemainingHours(transUnitStats.getDraft(), transUnitStats.getUntranslated()));\n         docStats.addStats(transUnitStats);\n\n         // word level stats\n         if (includeWordStats)\n         {\n            TranslationStatistics wordsStats;\n            if (stats == null)\n            {\n               wordsStats = new TranslationStatistics(new TransUnitWords(0, 0, (int) docTotalWords), locale.getId());\n            }\n            else\n            {\n               wordsStats = stats.getStats(locale.getId(), StatUnit.WORD);\n            }\n            \n            wordsStats.setLastTranslatedBy(docStat.getLastTranslatedBy());\n            wordsStats.setLastTranslatedDate(docStat.getLastTranslatedDate());\n            \n            wordsStats.setRemainingHours(getRemainingHours(wordsStats.getDraft(), wordsStats.getUntranslated()));\n            docStats.addStats(wordsStats);\n         }\n      }\n\n      return docStats;\n   }","commit_id":"324961ecb662261dfb147f1a6d06634ad34e0e69","url":"https://github.com/zanata/zanata-server"},{"original_method":"@CachedMethodResult\n   public List<Status> getAllStatus()\n   {\n      HProjectIteration iteration = projectIterationDAO.getBySlug(this.projectSlug, this.iterationSlug);\n\n      List<HLocale> locale = this.getDisplayLocales();\n      String[] localeIds = getLocaleIds(locale);\n\n      ContainerTranslationStatistics iterationStats = statisticsServiceImpl.getStatistics(this.projectSlug, this.iterationSlug, false, true, localeIds);\n\n      Long total;\n      if (statsOption == WORD)\n      {\n         total = projectIterationDAO.getTotalWordCountForIteration(iteration.getId());\n      }\n      else\n      {\n         total = projectIterationDAO.getTotalCountForIteration(iteration.getId());\n      }\n\n      for (HLocale var : locale)\n      {\n         TranslationStatistics stats = iterationStats.getStats(var.getLocaleId().getId(), statsOption);\n         if (stats == null)\n         {\n            stats = new TranslationStatistics(statsOption);\n            stats.setUntranslated(total);\n//            stats.setTotal(total);\n\n            HTextFlowTarget lastTranslatedTarget = localeServiceImpl.getLastTranslated(projectSlug, iterationSlug, var.getLocaleId());\n\n            StringBuilder lastTranslated = new StringBuilder();\n            if (lastTranslatedTarget != null)\n            {\n               lastTranslated.append(DateUtil.formatShortDate(lastTranslatedTarget.getLastChanged()));\n               if (lastTranslatedTarget.getLastModifiedBy() != null)\n               {\n                  lastTranslated.append(\" by \");\n                  lastTranslated.append(lastTranslatedTarget.getLastModifiedBy().getAccount().getUsername());\n                  \n               }\n            }\n            stats.setLastTranslated(lastTranslated.toString());\n         }\n\n\n         if (!statsMap.containsKey(var.getLocaleId()))\n         {\n            boolean isMember = authenticatedAccount != null ? personDAO.isMemberOfLanguageTeam(authenticatedAccount.getPerson(), var) : false;\n\n            Status op = new Status(var.getLocaleId().getId(), var.retrieveNativeName(), stats, isMember);\n            statsMap.put(var.getLocaleId(), op);\n         }\n         else\n         {\n            statsMap.get(var.getLocaleId()).setStats(stats);\n         }\n      }\n\n      List<Status> result = new ArrayList<Status>(statsMap.values());\n      Collections.sort(result);\n      return result;\n   }","id":26063,"modified_method":"@CachedMethodResult\n   public List<Status> getAllStatus()\n   {\n      HProjectIteration iteration = projectIterationDAO.getBySlug(this.projectSlug, this.iterationSlug);\n\n      List<HLocale> locale = this.getDisplayLocales();\n      String[] localeIds = getLocaleIds(locale);\n\n      ContainerTranslationStatistics iterationStats = statisticsServiceImpl.getStatistics(this.projectSlug, this.iterationSlug, false, true, localeIds);\n\n      Long total;\n      if (statsOption == WORD)\n      {\n         total = projectIterationDAO.getTotalWordCountForIteration(iteration.getId());\n      }\n      else\n      {\n         total = projectIterationDAO.getTotalCountForIteration(iteration.getId());\n      }\n\n      for (HLocale var : locale)\n      {\n         TranslationStatistics stats = iterationStats.getStats(var.getLocaleId().getId(), statsOption);\n         if (stats == null)\n         {\n            stats = new TranslationStatistics(statsOption);\n            stats.setUntranslated(total);\n//            stats.setTotal(total);\n\n            HTextFlowTarget lastTranslatedTarget = localeServiceImpl.getLastTranslated(projectSlug, iterationSlug, var.getLocaleId());\n\n            if (lastTranslatedTarget != null)\n            {\n               stats.setLastTranslatedBy(lastTranslatedTarget.getLastModifiedBy().getAccount().getUsername());\n               stats.setLastTranslatedDate(lastTranslatedTarget.getLastChanged());\n               stats.setLastTranslated(getLastTranslated(lastTranslatedTarget.getLastChanged(), lastTranslatedTarget.getLastModifiedBy().getAccount().getUsername()));\n            }\n         }\n\n\n         if (!statsMap.containsKey(var.getLocaleId()))\n         {\n            boolean isMember = authenticatedAccount != null ? personDAO.isMemberOfLanguageTeam(authenticatedAccount.getPerson(), var) : false;\n\n            Status op = new Status(var.getLocaleId().getId(), var.retrieveNativeName(), stats, isMember);\n            statsMap.put(var.getLocaleId(), op);\n         }\n         else\n         {\n            statsMap.get(var.getLocaleId()).setStats(stats);\n         }\n      }\n\n      List<Status> result = new ArrayList<Status>(statsMap.values());\n      Collections.sort(result);\n      return result;\n   }","commit_id":"324961ecb662261dfb147f1a6d06634ad34e0e69","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void generatesDocumentStatsOnTuUpdate() {\n        ArrayList<String> sources = new ArrayList<String>();\n        sources.add(\"this is the source\");\n        boolean plural = false;\n\n        ArrayList<String> targets = new ArrayList<String>();\n        targets.add(\"this is the target\");\n\n        TransUnit newTransUnit =\n                TransUnit.Builder.newTransUnitBuilder().setId(12345L)\n                        .setResId(\"resId\").setLocaleId(\"es\").setPlural(plural)\n                        .setSources(sources)\n                        .setSourceComment(\"this is the source comment\")\n                        .setTargets(targets).setStatus(ContentState.Approved)\n                        .setLastModifiedBy(\"lastModifiedBy\")\n                        .setLastModifiedTime(new Date())\n                        .setMsgContext(\"msgContext\").setRowIndex(1)\n                        .setVerNum(1).build();\n        TransUnitUpdateInfo updateInfo =\n                new TransUnitUpdateInfo(true, true, new DocumentId(2222L,\n                        \"match/exact/filter\"), newTransUnit, 3, 0,\n                        ContentState.NeedReview);\n        TransUnitUpdatedEvent mockEvent = mock(TransUnitUpdatedEvent.class);\n\n        when(mockEvent.getUpdateInfo()).thenReturn(updateInfo);\n\n        documentListPresenter.bind();\n        documentListPresenter.setDocuments(buildSampleDocumentArray());\n        documentListPresenter.onTransUnitUpdated(mockEvent);\n\n        verify(mockEventBus, times(2)).fireEvent(\n                capturedEventBusEvent.capture());\n\n        DocumentStatsUpdatedEvent docStatsEvent = null;\n        for (GwtEvent event : capturedEventBusEvent.getAllValues()) {\n            if (event.getAssociatedType().equals(\n                    DocumentStatsUpdatedEvent.getType())) {\n                docStatsEvent = (DocumentStatsUpdatedEvent) event;\n            }\n        }\n\n        assertThat(\n                \"a document stats event should be fired when a TU update event occurs, not found\",\n                docStatsEvent, notNullValue());\n\n        // document stats\n        assertThat(\n                \"document id in document stats event shoudl match updated TU document id\",\n                docStatsEvent.getDocId(), equalTo(new DocumentId(2222L, \"\")));\n\n        // check actual counts (approved/fuzzy/untranslated)\n        // default TUs: 1/2/3\n        // approving 1 fuzzy, expect 2/1/3\n        assertThat(\n                \"document Approved TU count should increase by 1 when a TU is updated from NeedsReview to Approved\",\n                docStatsEvent.getNewStats()\n                        .getStats(LocaleId.ES.toString(), StatUnit.MESSAGE)\n                        .getApproved(), is(new Long(2)));\n        assertThat(\n                \"document NeedsReview TU count should decrease by 1 when a TU is updated from NeedsReview to Approved\",\n                docStatsEvent.getNewStats()\n                        .getStats(LocaleId.ES.toString(), StatUnit.MESSAGE)\n                        .getDraft(), is(new Long(1)));\n        assertThat(\n                \"document Untranslated TU count should remain the same when a TU is updated from NeedsReview to Approved\",\n                docStatsEvent.getNewStats()\n                        .getStats(LocaleId.ES.toString(), StatUnit.MESSAGE)\n                        .getUntranslated(), is(new Long(3)));\n\n        // default words: 4/5/6\n        // approving 3 fuzzy so expect 7/2/6\n        assertThat(\n                \"document Approved words should increase when TU changes to Approved\",\n                docStatsEvent.getNewStats()\n                        .getStats(LocaleId.ES.toString(), StatUnit.WORD)\n                        .getApproved(), is(new Long(7)));\n        assertThat(\n                \"document NeedsReview words should decrease when a TU changes from NeedsReview\",\n                docStatsEvent.getNewStats()\n                        .getStats(LocaleId.ES.toString(), StatUnit.WORD)\n                        .getDraft(), is(new Long(2)));\n        assertThat(\n                \"document Untranslated words should not change when TU changes between NeedsReview and Approved\",\n                docStatsEvent.getNewStats()\n                        .getStats(LocaleId.ES.toString(), StatUnit.WORD)\n                        .getDraft(), is(new Long(2)));\n    }","id":26064,"modified_method":"@Test\n    public void generatesDocumentStatsOnTuUpdate() {\n        ArrayList<String> sources = new ArrayList<String>();\n        sources.add(\"this is the source\");\n        boolean plural = false;\n\n        ArrayList<String> targets = new ArrayList<String>();\n        targets.add(\"this is the target\");\n\n        TransUnit newTransUnit =\n                TransUnit.Builder.newTransUnitBuilder().setId(12345L)\n                        .setResId(\"resId\").setLocaleId(\"es\").setPlural(plural)\n                        .setSources(sources)\n                        .setSourceComment(\"this is the source comment\")\n                        .setTargets(targets).setStatus(ContentState.Approved)\n                        .setLastModifiedBy(\"lastModifiedBy\")\n                        .setLastModifiedTime(new Date())\n                        .setMsgContext(\"msgContext\")\n                        .setSourceRefs(\"srcRef\")\n                        .setSourceFlags(\"srcFlag\")\n                        .setRowIndex(1)\n                        .setVerNum(1).build();\n        TransUnitUpdateInfo updateInfo =\n                new TransUnitUpdateInfo(true, true, new DocumentId(2222L,\n                        \"match/exact/filter\"), newTransUnit, 3, 0,\n                        ContentState.NeedReview);\n        TransUnitUpdatedEvent mockEvent = mock(TransUnitUpdatedEvent.class);\n\n        when(mockEvent.getUpdateInfo()).thenReturn(updateInfo);\n\n        documentListPresenter.bind();\n        documentListPresenter.setDocuments(buildSampleDocumentArray());\n        documentListPresenter.onTransUnitUpdated(mockEvent);\n\n        verify(mockEventBus, times(2)).fireEvent(\n                capturedEventBusEvent.capture());\n\n        DocumentStatsUpdatedEvent docStatsEvent = null;\n        for (GwtEvent event : capturedEventBusEvent.getAllValues()) {\n            if (event.getAssociatedType().equals(\n                    DocumentStatsUpdatedEvent.getType())) {\n                docStatsEvent = (DocumentStatsUpdatedEvent) event;\n            }\n        }\n\n        assertThat(\n                \"a document stats event should be fired when a TU update event occurs, not found\",\n                docStatsEvent, notNullValue());\n\n        // document stats\n        assertThat(\n                \"document id in document stats event shoudl match updated TU document id\",\n                docStatsEvent.getDocId(), equalTo(new DocumentId(2222L, \"\")));\n\n        // check actual counts (approved/fuzzy/untranslated)\n        // default TUs: 1/2/3\n        // approving 1 fuzzy, expect 2/1/3\n        assertThat(\n                \"document Approved TU count should increase by 1 when a TU is updated from NeedsReview to Approved\",\n                docStatsEvent.getNewStats()\n                        .getStats(LocaleId.ES.toString(), StatUnit.MESSAGE)\n                        .getApproved(), is(new Long(2)));\n        assertThat(\n                \"document NeedsReview TU count should decrease by 1 when a TU is updated from NeedsReview to Approved\",\n                docStatsEvent.getNewStats()\n                        .getStats(LocaleId.ES.toString(), StatUnit.MESSAGE)\n                        .getDraft(), is(new Long(1)));\n        assertThat(\n                \"document Untranslated TU count should remain the same when a TU is updated from NeedsReview to Approved\",\n                docStatsEvent.getNewStats()\n                        .getStats(LocaleId.ES.toString(), StatUnit.MESSAGE)\n                        .getUntranslated(), is(new Long(3)));\n\n        // default words: 4/5/6\n        // approving 3 fuzzy so expect 7/2/6\n        assertThat(\n                \"document Approved words should increase when TU changes to Approved\",\n                docStatsEvent.getNewStats()\n                        .getStats(LocaleId.ES.toString(), StatUnit.WORD)\n                        .getApproved(), is(new Long(7)));\n        assertThat(\n                \"document NeedsReview words should decrease when a TU changes from NeedsReview\",\n                docStatsEvent.getNewStats()\n                        .getStats(LocaleId.ES.toString(), StatUnit.WORD)\n                        .getDraft(), is(new Long(2)));\n        assertThat(\n                \"document Untranslated words should not change when TU changes between NeedsReview and Approved\",\n                docStatsEvent.getNewStats()\n                        .getStats(LocaleId.ES.toString(), StatUnit.WORD)\n                        .getDraft(), is(new Long(2)));\n    }","commit_id":"46ab129a0f665cc7aac39986b838f2c9b628aa76","url":"https://github.com/zanata/zanata-server"},{"original_method":"private ArrayList<TransUnit> generateTransUnitSampleData(LocaleId localeId,\n            int numRows, int start) {\n        ArrayList<TransUnit> units = new ArrayList<TransUnit>();\n        for (int i = start; i < start + numRows; i++) {\n            boolean plural = (i % 5 == 0);\n            int stateNum = Random.nextInt(ContentState.values().length);\n            ContentState state = ContentState.values()[stateNum];\n            ArrayList<String> sources = new ArrayList<String>();\n            ArrayList<String> targets = new ArrayList<String>();\n\n            sources.add(i % 2 == 0 ? \"\\n<hellow \\nnum=\\\"\" + (i + 1)\n                    + \"\\\" /> %s\\n\"\n                    : \"\\n<hellow \\nnum=\\\"\"\n                            + (i + 1)\n                            + \"\\\" /> %s &amp; &RHEL; &quot;looooooooooooooooooooooooooooooooooooooonggggggggggggggggggggggggggggggggggggstringgggggggggggggggggggggggggggggggggggggg\");\n            if (plural) {\n                sources.add(i % 2 == 0 ? \"\\n<hellow \\nnum=\\\"\" + (i + 2)\n                        + \"\\\" /> %s\\n\"\n                        : \"\\n<hellow \\nnum=\\\"\"\n                                + (i + 2)\n                                + \"\\\" /> %s &amp; &RHEL; &quot;looooooooooooooooooooooooooooooooooooooonggggggggggggggggggggggggggggggggggggstringgggggggggggggggggggggggggggggggggggggg\");\n            }\n            String sourceComment = \"comment \" + (i + 1);\n\n            if (state != ContentState.New) {\n                targets.add(\"<world> \\\"\" + (i + 1) + \"\\\"<\/world>\");\n                if (plural) {\n                    targets.add(\"<world> \\\"\" + (i + 2) + \"\\\"<\/world>\");\n                }\n            }\n\n            TransUnitId tuid = new TransUnitId(i + 1);\n            TransUnit.Builder builder =\n                    TransUnit.Builder.newTransUnitBuilder().setId(tuid)\n                            .setResId(tuid.toString()).setLocaleId(localeId)\n                            .setPlural(plural).setSources(sources)\n                            .setSourceComment(sourceComment)\n                            .setTargets(targets).setStatus(state)\n                            .setLastModifiedBy(\"peter\")\n                            .setMsgContext(\"msgContext\").setRowIndex(i)\n                            .setVerNum(1);\n\n            units.add(builder.build());\n        }\n        return units;\n    }","id":26065,"modified_method":"private ArrayList<TransUnit> generateTransUnitSampleData(LocaleId localeId,\n            int numRows, int start) {\n        ArrayList<TransUnit> units = new ArrayList<TransUnit>();\n        for (int i = start; i < start + numRows; i++) {\n            boolean plural = (i % 5 == 0);\n            int stateNum = Random.nextInt(ContentState.values().length);\n            ContentState state = ContentState.values()[stateNum];\n            ArrayList<String> sources = new ArrayList<String>();\n            ArrayList<String> targets = new ArrayList<String>();\n\n            sources.add(i % 2 == 0 ? \"\\n<hellow \\nnum=\\\"\" + (i + 1)\n                    + \"\\\" /> %s\\n\"\n                    : \"\\n<hellow \\nnum=\\\"\"\n                            + (i + 1)\n                            + \"\\\" /> %s &amp; &RHEL; &quot;looooooooooooooooooooooooooooooooooooooonggggggggggggggggggggggggggggggggggggstringgggggggggggggggggggggggggggggggggggggg\");\n            if (plural) {\n                sources.add(i % 2 == 0 ? \"\\n<hellow \\nnum=\\\"\" + (i + 2)\n                        + \"\\\" /> %s\\n\"\n                        : \"\\n<hellow \\nnum=\\\"\"\n                                + (i + 2)\n                                + \"\\\" /> %s &amp; &RHEL; &quot;looooooooooooooooooooooooooooooooooooooonggggggggggggggggggggggggggggggggggggstringgggggggggggggggggggggggggggggggggggggg\");\n            }\n            String sourceComment = \"comment \" + (i + 1);\n\n            if (state != ContentState.New) {\n                targets.add(\"<world> \\\"\" + (i + 1) + \"\\\"<\/world>\");\n                if (plural) {\n                    targets.add(\"<world> \\\"\" + (i + 2) + \"\\\"<\/world>\");\n                }\n            }\n\n            TransUnitId tuid = new TransUnitId(i + 1);\n            TransUnit.Builder builder =\n                    TransUnit.Builder.newTransUnitBuilder().setId(tuid)\n                            .setResId(tuid.toString()).setLocaleId(localeId)\n                            .setPlural(plural).setSources(sources)\n                            .setSourceComment(sourceComment)\n                            .setTargets(targets).setStatus(state)\n                            .setLastModifiedBy(\"peter\")\n                            .setMsgContext(\"msgContext\")\n                            .setSourceRefs(\"srcRef\")\n                            .setSourceFlags(\"srcFlag\")\n                            .setRowIndex(i)\n                            .setVerNum(1);\n\n            units.add(builder.build());\n        }\n        return units;\n    }","commit_id":"46ab129a0f665cc7aac39986b838f2c9b628aa76","url":"https://github.com/zanata/zanata-server"},{"original_method":"private Builder(TransUnit transUnit) {\n            this.status = transUnit.status;\n            this.id = transUnit.id;\n            this.resId = transUnit.resId;\n            this.localeId = transUnit.localeId;\n            this.plural = transUnit.plural;\n            this.sources = nullToEmpty(transUnit.sources);\n            this.sourceComment = transUnit.sourceComment;\n            this.targets = nullToEmpty(transUnit.targets);\n            this.msgContext = transUnit.msgContext;\n            this.lastModifiedBy = transUnit.lastModifiedBy;\n            this.lastModifiedTime = transUnit.lastModifiedTime;\n            this.rowIndex = transUnit.rowIndex;\n            this.verNum = transUnit.verNum;\n            this.commentsCount = transUnit.commentsCount;\n            this.revisionComment = transUnit.revisionComment;\n        }","id":26066,"modified_method":"private Builder(TransUnit transUnit) {\n            this.status = transUnit.status;\n            this.id = transUnit.id;\n            this.resId = transUnit.resId;\n            this.localeId = transUnit.localeId;\n            this.plural = transUnit.plural;\n            this.sources = nullToEmpty(transUnit.sources);\n            this.sourceComment = transUnit.sourceComment;\n            this.targets = nullToEmpty(transUnit.targets);\n            this.msgContext = transUnit.msgContext;\n            this.sourceRefs = transUnit.sourceRefs;\n            this.sourceFlags = transUnit.sourceFlags;\n            this.lastModifiedBy = transUnit.lastModifiedBy;\n            this.lastModifiedTime = transUnit.lastModifiedTime;\n            this.rowIndex = transUnit.rowIndex;\n            this.verNum = transUnit.verNum;\n            this.commentsCount = transUnit.commentsCount;\n            this.revisionComment = transUnit.revisionComment;\n        }","commit_id":"46ab129a0f665cc7aac39986b838f2c9b628aa76","url":"https://github.com/zanata/zanata-server"},{"original_method":"private TransUnit(Builder builder) {\n        this.id = builder.id;\n        this.resId = builder.resId;\n        this.localeId = builder.localeId;\n        this.plural = builder.plural;\n        this.sources = builder.sources;\n        this.sourceComment = builder.sourceComment;\n        this.targets = builder.targets;\n        this.status = builder.status;\n        this.lastModifiedBy = builder.lastModifiedBy;\n        this.lastModifiedTime = builder.lastModifiedTime;\n        this.msgContext = builder.msgContext;\n        this.rowIndex = builder.rowIndex;\n        this.verNum = builder.verNum;\n        this.targetComment = builder.targetComment;\n        this.commentsCount = builder.commentsCount;\n        this.revisionComment = builder.revisionComment;\n    }","id":26067,"modified_method":"private TransUnit(Builder builder) {\n        this.id = builder.id;\n        this.resId = builder.resId;\n        this.localeId = builder.localeId;\n        this.plural = builder.plural;\n        this.sources = builder.sources;\n        this.sourceComment = builder.sourceComment;\n        this.targets = builder.targets;\n        this.status = builder.status;\n        this.lastModifiedBy = builder.lastModifiedBy;\n        this.lastModifiedTime = builder.lastModifiedTime;\n        this.msgContext = builder.msgContext;\n        this.sourceRefs = builder.sourceRefs;\n        this.sourceFlags = builder.sourceFlags;\n        this.rowIndex = builder.rowIndex;\n        this.verNum = builder.verNum;\n        this.targetComment = builder.targetComment;\n        this.commentsCount = builder.commentsCount;\n        this.revisionComment = builder.revisionComment;\n    }","commit_id":"46ab129a0f665cc7aac39986b838f2c9b628aa76","url":"https://github.com/zanata/zanata-server"},{"original_method":"public TransUnitDetailsPanel() {\n        initWidget(uiBinder.createAndBindUi(this));\n        // this is to remove the .header class so that it won't get style from\n        // menu.css\n        disclosurePanel.getHeader().getParent().setStyleName(\"l--pad-h-quarter txt--important txt--mini\");\n    }","id":26068,"modified_method":"public TransUnitDetailsPanel() {\n        initWidget(uiBinder.createAndBindUi(this));\n        // this is to remove the .header class so that it won't get style from\n        // menu.css\n        disclosurePanel.getHeader().getParent().setStyleName(\"l--pad-left-quarter txt--mini\");\n    }","commit_id":"46ab129a0f665cc7aac39986b838f2c9b628aa76","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setDetails(TransUnit transUnit) {\n        resId.setText(transUnit.getResId());\n\n        String context = Strings.nullToEmpty(transUnit.getMsgContext());\n        msgContext.setText(context);\n\n        String comment = Strings.nullToEmpty(transUnit.getSourceComment());\n        sourceComment.setText(comment);\n\n        String person = transUnit.getLastModifiedBy();\n        if (Strings.isNullOrEmpty(person)) {\n            lastModifiedBy.setText(\"\");\n            lastModifiedTime.setText(\"\");\n        } else {\n            lastModifiedBy.setText(person);\n            lastModifiedTime.setText(DateUtil.formatShortDate(transUnit\n                    .getLastModifiedTime()));\n        }\n\n        StringBuilder headerSummary = new StringBuilder();\n        if (!context.isEmpty()) {\n            headerSummary.append(\" MsgCtx: \").append(context);\n        }\n        if (!comment.isEmpty()) {\n            headerSummary.append(\" Comment: \").append(comment);\n        }\n        metaInfo = headerSummary.toString();\n\n        String transUnitId = \"\";\n        if (!GWT.isProdMode()) {\n            transUnitId = \"Id: \" + transUnit.getId().toString();\n        }\n        headerLabel.setText(transUnitId\n                + messages.transUnitDetailsHeadingWithInfo(\n                        transUnit.getRowIndex(), metaInfo));\n    }","id":26069,"modified_method":"public void setDetails(TransUnit transUnit) {\n        resId.setText(transUnit.getResId());\n\n        String context = Strings.nullToEmpty(transUnit.getMsgContext());\n        setSourceMetaData(msgContext, context);\n\n        String reference = Strings.nullToEmpty(transUnit.getSourceRefs());\n        setSourceMetaData(refs, reference);\n\n        String comment = Strings.nullToEmpty(transUnit.getSourceComment());\n        setSourceMetaData(sourceComment, comment);\n\n        flags.setText(Strings.nullToEmpty(transUnit.getSourceFlags()));\n        setSourceMetaData(flags, transUnit.getSourceFlags());\n\n        String person = Strings.nullToEmpty(transUnit.getLastModifiedBy());\n        lastModifiedBy.setText(person);\n\n        String date =\n                transUnit.getLastModifiedTime() != null ? DateUtil\n                        .formatShortDate(transUnit\n                                .getLastModifiedTime()) : \"\";\n\n        lastModifiedTime.setText(date);\n\n        if (Strings.isNullOrEmpty(person)\n                || Strings.isNullOrEmpty(date)) {\n            lastModified.addStyleName(\"is-hidden\");\n        }\n\n        metaInfo = append(metaInfo, getHeader(\"MsgCtx\", context));\n        metaInfo = append(metaInfo, getHeader(\"Comment\", comment));\n        metaInfo = append(metaInfo, getHeader(\"Refs\", reference));\n\n        String transUnitId = \"\";\n        if (!GWT.isProdMode()) {\n            transUnitId = \"Id: \" + transUnit.getId().toString();\n        }\n        headerLabel.setText(transUnitId\n                + messages.transUnitDetailsHeadingWithInfo(\n                        transUnit.getRowIndex(), metaInfo));\n    }","commit_id":"46ab129a0f665cc7aac39986b838f2c9b628aa76","url":"https://github.com/zanata/zanata-server"},{"original_method":"public TransUnit transform(HTextFlow hTextFlow, HTextFlowTarget target,\n            HLocale hLocale) {\n        String msgContext = null;\n        if (hTextFlow.getPotEntryData() != null) {\n            msgContext = hTextFlow.getPotEntryData().getContext();\n        }\n\n        int nPlurals =\n                resourceUtils.getNumPlurals(hTextFlow.getDocument(), hLocale);\n        ArrayList<String> sourceContents =\n                GwtRpcUtil.getSourceContents(hTextFlow);\n        ArrayList<String> targetContents =\n                GwtRpcUtil.getTargetContentsWithPadding(hTextFlow, target,\n                        nPlurals);\n\n        TransUnit.Builder builder =\n                TransUnit.Builder\n                        .newTransUnitBuilder()\n                        .setId(hTextFlow.getId())\n                        .setResId(hTextFlow.getResId())\n                        .setLocaleId(hLocale.getLocaleId())\n                        .setPlural(hTextFlow.isPlural())\n                        .setSources(sourceContents)\n                        .setSourceComment(\n                            commentToString(hTextFlow.getComment()))\n                        .setTargets(targetContents)\n                        .setTargetComment(\n                            target == null ? null : commentToString(target\n                                .getComment()))\n                        .setMsgContext(msgContext)\n                        .setRowIndex(hTextFlow.getPos())\n                        .setVerNum(\n                            target == null ? NULL_TARGET_VERSION_NUM\n                                : target.getVersionNum())\n                        .setCommentsCount(getCommentCount(target));\n\n        if (target != null) {\n            builder.setStatus(target.getState());\n            if (target.getLastModifiedBy() != null) {\n                builder.setLastModifiedBy(target.getLastModifiedBy().getName());\n            }\n            builder.setLastModifiedTime(target.getLastChanged());\n            builder.setRevisionComment(target.getRevisionComment());\n        }\n        return builder.build();\n    }","id":26070,"modified_method":"public TransUnit transform(HTextFlow hTextFlow, HTextFlowTarget target,\n            HLocale hLocale) {\n        HPotEntryData potEntryData = hTextFlow.getPotEntryData();\n        String msgContext = null, refs = null, flags = null;\n        if (potEntryData != null) {\n            msgContext = potEntryData.getContext();\n            refs = potEntryData.getReferences();\n            flags = potEntryData.getFlags();\n        }\n\n        int nPlurals =\n                resourceUtils.getNumPlurals(hTextFlow.getDocument(), hLocale);\n        ArrayList<String> sourceContents =\n                GwtRpcUtil.getSourceContents(hTextFlow);\n        ArrayList<String> targetContents =\n                GwtRpcUtil.getTargetContentsWithPadding(hTextFlow, target,\n                        nPlurals);\n\n        TransUnit.Builder builder =\n                TransUnit.Builder\n                        .newTransUnitBuilder()\n                        .setId(hTextFlow.getId())\n                        .setResId(hTextFlow.getResId())\n                        .setLocaleId(hLocale.getLocaleId())\n                        .setPlural(hTextFlow.isPlural())\n                        .setSources(sourceContents)\n                    .setSourceComment(\n                        commentToString(hTextFlow.getComment()))\n                    .setTargets(targetContents)\n                    .setTargetComment(\n                        target == null ? null : commentToString(target\n                            .getComment()))\n                    .setMsgContext(msgContext)\n                    .setSourceRefs(refs)\n                    .setSourceFlags(flags)\n                    .setRowIndex(hTextFlow.getPos())\n                    .setVerNum(\n                        target == null ? NULL_TARGET_VERSION_NUM\n                            : target.getVersionNum())\n                    .setCommentsCount(getCommentCount(target));\n\n        if (target != null) {\n            builder.setStatus(target.getState());\n            if (target.getLastModifiedBy() != null) {\n                builder.setLastModifiedBy(target.getLastModifiedBy().getName());\n            }\n            builder.setLastModifiedTime(target.getLastChanged());\n            builder.setRevisionComment(target.getRevisionComment());\n        }\n        return builder.build();\n    }","commit_id":"46ab129a0f665cc7aac39986b838f2c9b628aa76","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Initializes Wonder EOF programmatically (for use in test cases and main methods).  You do\n     * not need to call this method if you already called initApp.  This is lighter-weight than \n     * initApp, and tries to just get enough configured to make EOF work properly.  This method\n     * assumes you are running your app from a .woa folder.\n     * \n     * @param args the commandline arguments for your application\n     */\n    public static void initEOF(String[] args) {\n    \tERXExtensions.initEOF(new File(\".\"), args);\n    }","id":26071,"modified_method":"/**\n     * Initializes Wonder EOF programmatically (for use in test cases and main methods).  You do\n     * not need to call this method if you already called initApp.  This is lighter-weight than \n     * initApp, and tries to just get enough configured to make EOF work properly.  This method\n     * assumes you are running your app from a .woa folder.\n     * \n     * <p>This is equivalent to calling <code>initEOF(new File(\".\"), args)<\/code>.<\/p>\n     * \n     * @param args the commandline arguments for your application\n     * @throws IllegalArgumentException if the current dir or mainBundleFolder is not a *.woa bundle.\n     */\n    public static void initEOF(final String[] args) {\n    \tERXExtensions.initEOF(new File(\".\"), args);\n    }","commit_id":"6ba03599adf4e85243440f6366421271b435bf70","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Initializes Wonder EOF programmatically (for use in test cases and main methods).  You do\n     * not need to call this method if you already called initApp.  This is lighter-weight than \n     * initApp, and tries to just get enough configured to make EOF work properly.\n     * \n     * @param mainBundleFolder the folder of your main bundle\n     * @param args the commandline arguments for your application\n     */\n    public static void initEOF(File mainBundleFolder, String[] args) {\n    \tif (_eofInitialized) {\n    \t\treturn;\n    \t}\n    \ttry {\n\t    \tFile currentFolder = new File(\".\").getCanonicalFile();\n\t    \tif (!currentFolder.getName().endsWith(\".woa\")) {\n\t    \t\tcurrentFolder = mainBundleFolder;\n\t\t    \tif (!currentFolder.getName().endsWith(\".woa\")) {\n\t\t    \t\tthrow new IllegalArgumentException(\"You must run your application from the .woa folder to call this method.\");\n\t\t    \t}\n\t    \t}\n\t        System.setProperty(\"webobjects.user.dir\", mainBundleFolder.getCanonicalPath());\n\t        ERXApplication.setup(args);\n\t        ((ERXExtensions) ERXFrameworkPrincipal.sharedInstance(ERXExtensions.class)).bundleDidLoad(null);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new NSForwardException(e);\n\t\t}\n\t\t_eofInitialized = true;\n    }","id":26072,"modified_method":"/**\n     * Initializes Wonder EOF programmatically (for use in test cases and main methods).  You do\n     * not need to call this method if you already called initApp.  This is lighter-weight than \n     * initApp, and tries to just get enough configured to make EOF work properly.\n     * \n     * <p>This is equivalent to calling <code>initEOF(mainBundleFolder, args, true, true, true)<\/code>.<\/p>\n     * \n     * @param mainBundleFolder the folder of your main bundle\n     * @param args the commandline arguments for your application\n     * @throws IllegalArgumentException if the current dir or mainBundleFolder is not a *.woa bundle.\n     */\n    public static void initEOF(final File mainBundleFolder, final String[] args) {\n    \tinitEOF(mainBundleFolder, args, true, true, true);\n    }","commit_id":"6ba03599adf4e85243440f6366421271b435bf70","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Hack to create a bundle after the app is loaded. Useful for the insistence of EOF on JavaXXXAdaptor bundles. \n     * @param name\n     */\n    public static NSBundle createBundleIfNeeded(String name) {\n    \tString path = \"/tmp/\" + name + \".framework/Resources/Java\";\n    \tnew File(path).mkdirs();\n    \ttry {\n\t\t\tERXFileUtilities.stringToFile(\"{Has_WOComponents=NO;}\", new File(\"/tmp/\" + name + \".framework/Resources/Info.plist\"));\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tNSForwardException._runtimeExceptionForThrowable(e);\n\t\t}\n    \treturn NSBundle._bundleWithPathShouldCreateIsJar(path, true, false);\n    }","id":26073,"modified_method":"/**\n     * Hack to create a bundle after the app is loaded. Useful for the insistence of EOF on JavaXXXAdaptor bundles. \n     * @param name\n     * @return a new bundle under the system temp directory\n     */\n    public static NSBundle createBundleIfNeeded(String name) {\n    \tFile sysTempDir = new File(System.getProperty(\"java.io.tmpdir\", \"/tmp\"));\n    \t\n    \tFile newTempDir;\n        final int maxAttempts = 5;\n        int attemptCount = 0;\n        do {\n            attemptCount++;\n            if(attemptCount > maxAttempts)\n            {\n            \tthrow NSForwardException._runtimeExceptionForThrowable(new IOException(\n                        \"The highly improbable has occurred! Failed to \" +\n                        \"create a unique temporary directory after \" +\n                        maxAttempts + \" attempts.\"));\n            }\n            // create unique dir in tmp to work with\n            String dirName = name + UUID.randomUUID().toString();\n            newTempDir = new File(sysTempDir, dirName);\n            \n        } while (newTempDir.exists());\n        \n        if (newTempDir.mkdirs()) {\n        \t// create basic framework bundle structure\n        \tFile fwkResourcesDir = new File(new File(newTempDir , name + \".framework\"), \"Resources\");\n        \tFile fwkJavaDir = new File(fwkResourcesDir, \"Java\");\n        \tfwkJavaDir.mkdirs();\n        \t\n        \ttry {\n    \t\t\tERXFileUtilities.stringToFile(\"{Has_WOComponents=NO;}\", new File(fwkResourcesDir, \"Info.plist\"));\n    \t\t}\n    \t\tcatch (IOException e) {\n    \t\t\tthrow NSForwardException._runtimeExceptionForThrowable(e);\n    \t\t}\n    \t\treturn loadBundleIfNeeded(fwkJavaDir);\n        }\n        throw NSForwardException._runtimeExceptionForThrowable(new IOException(\"Failed to create temp dir named \" + newTempDir.getAbsolutePath()));\n    }","commit_id":"6ba03599adf4e85243440f6366421271b435bf70","url":"https://github.com/wocommunity/wonder"},{"original_method":"private void setup(NSDictionary dict, int maxCheckoutSecond) {\n        dbDriver = (String) dict.objectForKey(\"driver\");\n        dbServer = (String) dict.objectForKey(\"URL\");\n        dbLogin = (String) dict.objectForKey(\"username\");\n        dbPassword = (String) dict.objectForKey(\"password\");\n        \n        minimumConnections = ERXValueUtilities.intValueWithDefault(\n                (String) dict.objectForKey(\"minConnections\"), 1);\n        maximumConnections = ERXValueUtilities.intValueWithDefault(\n                (String) dict.objectForKey(\"maxConnections\"), 1);\n        maxCheckoutMillis = ERXValueUtilities.intValueWithDefault(\n                (String) dict.objectForKey(\"maxCheckout\"), maxCheckoutSecond) * 1000;\n        maxConnectionMillis = ERXValueUtilities.bigDecimalValueWithDefault(\n                (String) dict.objectForKey(\"connectionRecycle\"), BigDecimal.valueOf(1)).longValue() * 86400000;\n        \n        if (maxConnectionMillis < 30000) { // Recycle no less than 30 seconds.\n            maxConnectionMillis = 30000;\n        }\n\n        // Initialize the pool of connections with the mininum connections:\n        // Problems creating connections may be caused during reboot when\n        // the servlet is started before the database is ready. Handle this\n        // by waiting and trying again. The loop allows 5 minutes for\n        // db reboot.\n        boolean success = false;\n        int maxTries = 20;\n\n        wrappers = new ConnectionWrapper[maximumConnections];\n\n        for (int tries = 1; tries < 20 && !success; tries++) {\n            try {\n                for (int j = 0; j < minimumConnections; j++) {\n                    createWrapper();\n                }\n                success = true;\n            } catch (SQLException e) {\n                log.error(\"Can't create connection \" + tries + \" of \" + maxTries + \", will retry in 15 seconds: \" + e, e);\n                try {\n                    Thread.sleep(15000);\n                } catch (InterruptedException e1) {\n                }\n            }\n        }\n        if (!success) { \n            throw new IllegalStateException(\"All attempts at connecting to Database exhausted: \" + this);\n        }\n\n        Connection con = getConnection();\n        try {\n            supportsTransactions = (con.getTransactionIsolation() != 0);\n\n            if(supportsTransactions) {\n                con.setAutoCommit(false);\n            }\n        } catch (SQLException ex) {\n            log.error(ex, ex);\n        } finally {\n            freeConnection(con);\n        }\n\n       reaper = new Thread() {\n            /**\n             * Housekeeping thread. Runs in the background with low CPU overhead.\n             * Connections are checked for warnings and closure and are periodically\n             * restarted. This thread is a catchall for corrupted connections and\n             * prevents the buildup of open cursors. (Open cursors result when the\n             * application fails to close a Statement). This method acts as fault\n             * tolerance for bad connection/statement programming.\n             */\n            public void run() {\n                while (true) {\n                    synchronized (wrappers) {\n                        for (int i = 0; i < activeConnections; i++) {\n                            ConnectionWrapper connection = wrappers[i];\n                            connection.clearWarnings();\n                        }\n                    }\n                    synchronized (wrappers) {\n                        for (int i = 0; i < activeConnections; i++) { \n                            ConnectionWrapper connection = wrappers[i];\n                            try {\n                                connection.reap(maxCheckoutMillis, maxConnectionMillis);\n                            } catch (SQLException e) {\n                                log.error(\"Error while reaping: \" + connection);\n                            }\n                        }\n                    }\n                    try {\n                        Thread.sleep(20000);\n                    } catch (InterruptedException e) {\n                        return;\n                    }\n                }\n            }        \n\n            /**\n             * Less safe shutdown. Uses default timeout value. This method simply\n             * calls the <code>destroy()<\/code> method with a <code>millis<\/code>\n             * value of 10000 (10 seconds) and ignores <code>SQLException<\/code>\n             * thrown by that method.\n             * \n             * @see #destroy(int)\n             */\n            public void destroy() {\n                try {\n                    ERXJDBCConnectionBroker.this.destroy(10000);\n                } catch (SQLException e) {\n                }\n            }\n        };\n\n        pinger = new Thread(new Runnable() {\n            boolean b = ERXProperties.booleanForKeyWithDefault(\"er.extensions.ERXJDBCConnectionBroker.connectionPingEnabled\", false);\n            int wait = ERXProperties.intForKeyWithDefault(\"er.extensions.ERXJDBCConnectionBroker.connectionPingInterval\", 60 * 5);\n\n            public void run() {\n                log.debug(\"Starting up ConnectionPing\");\n                while (b) {\n                    synchronized (wrappers) {\n                        for (int i = 0; i < wrappers.length; i++) {\n                            ConnectionWrapper connection = wrappers[i];\n                            connection.ping();\n                        }\n                    }\n                    try {\n                        Thread.sleep(wait * 1000);\n                    } catch (InterruptedException e) {\n                        return;\n                    }\n                }\n            }\n\n        });\n\n        reaper.start();\n        pinger.start();\n        \n        log.info(\"Started Broker : \" + this);\n    }","id":26074,"modified_method":"private void setup(NSDictionary dict, int maxCheckoutSecond) {\n        dbDriver = (String) dict.objectForKey(\"driver\");\n        dbServer = (String) dict.objectForKey(\"URL\");\n        dbLogin = (String) dict.objectForKey(\"username\");\n        dbPassword = (String) dict.objectForKey(\"password\");\n        \n        if (dbDriver == null || dbDriver.length() == 0) {\n        \tJDBCAdaptor jdbcAdaptor = new JDBCAdaptor(\"JDBC\");\n        \tjdbcAdaptor.setConnectionDictionary(dict);\n        \tJDBCPlugIn plugIn = jdbcAdaptor.plugIn();\n        \tdbDriver = plugIn.defaultDriverName();\n        }\n        \n        minimumConnections = ERXValueUtilities.intValueWithDefault(\n                (String) dict.objectForKey(\"minConnections\"), 1);\n        maximumConnections = ERXValueUtilities.intValueWithDefault(\n                (String) dict.objectForKey(\"maxConnections\"), 1);\n        maxCheckoutMillis = ERXValueUtilities.intValueWithDefault(\n                (String) dict.objectForKey(\"maxCheckout\"), maxCheckoutSecond) * 1000;\n        maxConnectionMillis = ERXValueUtilities.bigDecimalValueWithDefault(\n                (String) dict.objectForKey(\"connectionRecycle\"), BigDecimal.valueOf(1)).longValue() * 86400000;\n        \n        if (maxConnectionMillis < 30000) { // Recycle no less than 30 seconds.\n            maxConnectionMillis = 30000;\n        }\n\n        // Initialize the pool of connections with the mininum connections:\n        // Problems creating connections may be caused during reboot when\n        // the servlet is started before the database is ready. Handle this\n        // by waiting and trying again. The loop allows 5 minutes for\n        // db reboot.\n        boolean success = false;\n        int maxTries = 20;\n\n        wrappers = new ConnectionWrapper[maximumConnections];\n\n        for (int tries = 1; tries < 20 && !success; tries++) {\n            try {\n                for (int j = 0; j < minimumConnections; j++) {\n                    createWrapper();\n                }\n                success = true;\n            } catch (SQLException e) {\n                log.error(\"Can't create connection \" + tries + \" of \" + maxTries + \", will retry in 15 seconds: \" + e, e);\n                try {\n                    Thread.sleep(15000);\n                } catch (InterruptedException e1) {\n                }\n            }\n        }\n        if (!success) { \n            throw new IllegalStateException(\"All attempts at connecting to Database exhausted: \" + this);\n        }\n\n        Connection con = getConnection();\n        try {\n            supportsTransactions = (con.getTransactionIsolation() != 0);\n\n            if(supportsTransactions) {\n                con.setAutoCommit(false);\n            }\n        } catch (SQLException ex) {\n            log.error(ex, ex);\n        } finally {\n            freeConnection(con);\n        }\n\n       reaper = new Thread() {\n            /**\n             * Housekeeping thread. Runs in the background with low CPU overhead.\n             * Connections are checked for warnings and closure and are periodically\n             * restarted. This thread is a catchall for corrupted connections and\n             * prevents the buildup of open cursors. (Open cursors result when the\n             * application fails to close a Statement). This method acts as fault\n             * tolerance for bad connection/statement programming.\n             */\n            public void run() {\n                while (true) {\n                    synchronized (wrappers) {\n                        for (int i = 0; i < activeConnections; i++) {\n                            ConnectionWrapper connection = wrappers[i];\n                            connection.clearWarnings();\n                        }\n                    }\n                    synchronized (wrappers) {\n                        for (int i = 0; i < activeConnections; i++) { \n                            ConnectionWrapper connection = wrappers[i];\n                            try {\n                                connection.reap(maxCheckoutMillis, maxConnectionMillis);\n                            } catch (SQLException e) {\n                                log.error(\"Error while reaping: \" + connection);\n                            }\n                        }\n                    }\n                    try {\n                        Thread.sleep(20000);\n                    } catch (InterruptedException e) {\n                        return;\n                    }\n                }\n            }        \n\n            /**\n             * Less safe shutdown. Uses default timeout value. This method simply\n             * calls the <code>destroy()<\/code> method with a <code>millis<\/code>\n             * value of 10000 (10 seconds) and ignores <code>SQLException<\/code>\n             * thrown by that method.\n             * \n             * @see #destroy(int)\n             */\n            public void destroy() {\n                try {\n                    ERXJDBCConnectionBroker.this.destroy(10000);\n                } catch (SQLException e) {\n                }\n            }\n        };\n\n        pinger = new Thread(new Runnable() {\n            boolean b = ERXProperties.booleanForKeyWithDefault(\"er.extensions.ERXJDBCConnectionBroker.connectionPingEnabled\", false);\n            int wait = ERXProperties.intForKeyWithDefault(\"er.extensions.ERXJDBCConnectionBroker.connectionPingInterval\", 60 * 5);\n\n            public void run() {\n                log.debug(\"Starting up ConnectionPing\");\n                while (b) {\n                    synchronized (wrappers) {\n                        for (int i = 0; i < wrappers.length; i++) {\n                            ConnectionWrapper connection = wrappers[i];\n                            connection.ping();\n                        }\n                    }\n                    try {\n                        Thread.sleep(wait * 1000);\n                    } catch (InterruptedException e) {\n                        return;\n                    }\n                }\n            }\n\n        });\n\n        reaper.start();\n        pinger.start();\n        \n        log.info(\"Started Broker : \" + this);\n    }","commit_id":"179f4d6425a8f1bac2e1b61b8f2e412026bceaf6","url":"https://github.com/wocommunity/wonder"},{"original_method":"private Connection createConnection() throws SQLException {\n        try {\n            Class.forName(dbDriver);\n            return DriverManager.getConnection(dbServer, dbLogin, dbPassword);\n        } catch (ClassNotFoundException e2) {\n            NSForwardException._runtimeExceptionForThrowable(e2);\n        }\n        return null;\n    }","id":26075,"modified_method":"private Connection createConnection() throws SQLException {\n        try {\n            Class.forName(dbDriver);\n            Connection conn = DriverManager.getConnection(dbServer, dbLogin, dbPassword);\n            return conn;\n        } catch (ClassNotFoundException e2) {\n            throw NSForwardException._runtimeExceptionForThrowable(e2);\n        }\n    }","commit_id":"179f4d6425a8f1bac2e1b61b8f2e412026bceaf6","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Sets up a given framework principal class to recieve notification\n     * when it is safe for the framework to be initialized.\n     * @param c principal class\n     */\n    public static void setUpFrameworkPrincipalClass(Class c) {\n        try {\n            NSLog.debug.appendln(\"Loaded items: \" + initializedFrameworks);\n            if(observer == null) {\n                observer = new Observer();\n                NSNotificationCenter center = NSNotificationCenter.defaultCenter();\n                center.addObserver(observer,\n                        new NSSelector(\"finishInitialization\",  ERXConstant.NotificationClassArray),\n                        // WOApplication.ApplicationWillFinishLaunchingNotification,\n                        ERXApplication.ApplicationDidCreateNotification,\n                        null);\n               \n            }\n            if (initializedFrameworks.objectForKey(c.getName()) == null) {\n                NSLog.debug.appendln(\"Starting up: \" + c.getName());\n                try {\n                    Field f = c.getField(\"REQUIRES\");\n                    Class requires[] = (Class[]) f.get(c);\n                    for (int i = 0; i < requires.length; i++) {\n                        Class requirement = requires[i];\n                        setUpFrameworkPrincipalClass(requirement);\n                    }\n                } catch (NoSuchFieldException e) {\n                    // nothing\n                    // NSLog.debug.appendln(\"No requirements: \" + c.getName());\n                } catch (IllegalAccessException e) {\n                    NSLog.err.appendln(\"Can't read field REQUIRES from \" + c.getName() + \", check if it is 'public static Class[] REQUIRES= new Class[] {...}' in this class\");\n                    NSForwardException._runtimeExceptionForThrowable(e);\n                }\n                ERXFrameworkPrincipal principal = (ERXFrameworkPrincipal)c.newInstance();\n                initializedFrameworks.setObjectForKey(principal,c.getName());\n                principal.initialize();\n                launchingFrameworks.addObject(principal);\n                NSLog.debug.appendln(\"Initialized : \" + c.getName());\n\n            } else {\n                NSLog.debug.appendln(\"Was already inited: \" + c.getName());\n            }\n        } catch (InstantiationException e) {\n            throw NSForwardException._runtimeExceptionForThrowable(e);\n        } catch (IllegalAccessException e) {\n            throw NSForwardException._runtimeExceptionForThrowable(e);\n        }\n    }","id":26076,"modified_method":"/**\n     * Sets up a given framework principal class to recieve notification\n     * when it is safe for the framework to be initialized.\n     * @param c principal class\n     */\n    public static void setUpFrameworkPrincipalClass(Class c) {\n        try {\n            NSLog.debug.appendln(\"Loaded items: \" + initializedFrameworks);\n            if(observer == null) {\n                observer = new Observer();\n                NSNotificationCenter center = NSNotificationCenter.defaultCenter();\n                center.addObserver(observer,\n                        new NSSelector(\"finishInitialization\",  ERXConstant.NotificationClassArray),\n                        // WOApplication.ApplicationWillFinishLaunchingNotification,\n                        ERXApplication.ApplicationDidCreateNotification,\n                        null);\n               \n            }\n            if (initializedFrameworks.objectForKey(c.getName()) == null) {\n                NSLog.debug.appendln(\"Starting up: \" + c.getName());\n                try {\n                    Field f = c.getField(\"REQUIRES\");\n                    Class requires[] = (Class[]) f.get(c);\n                    for (int i = 0; i < requires.length; i++) {\n                        Class requirement = requires[i];\n                        setUpFrameworkPrincipalClass(requirement);\n                    }\n                } catch (NoSuchFieldException e) {\n                    // nothing\n                    // NSLog.debug.appendln(\"No requirements: \" + c.getName());\n                } catch (IllegalAccessException e) {\n                    NSLog.err.appendln(\"Can't read field REQUIRES from \" + c.getName() + \", check if it is 'public static Class[] REQUIRES= new Class[] {...}' in this class\");\n                    throw NSForwardException._runtimeExceptionForThrowable(e);\n                }\n                ERXFrameworkPrincipal principal = (ERXFrameworkPrincipal)c.newInstance();\n                initializedFrameworks.setObjectForKey(principal,c.getName());\n                principal.initialize();\n                launchingFrameworks.addObject(principal);\n                NSLog.debug.appendln(\"Initialized : \" + c.getName());\n\n            } else {\n                NSLog.debug.appendln(\"Was already inited: \" + c.getName());\n            }\n        } catch (InstantiationException e) {\n            throw NSForwardException._runtimeExceptionForThrowable(e);\n        } catch (IllegalAccessException e) {\n            throw NSForwardException._runtimeExceptionForThrowable(e);\n        }\n    }","commit_id":"ee3f20dddcc509de784b5f6b22b305a896e7a907","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static void cleanByteBuffer(ByteBuffer buf) {\n        ((DirectBuffer)buf).cleaner().clean();\n    }","id":26077,"modified_method":"public static void cleanByteBuffer(ByteBuffer buf) {\n        if (buf == null) return;\n        if (!buf.isDirect()) return;\n        final Cleaner cleaner = ((DirectBuffer)buf).cleaner();\n        if (cleaner != null) cleaner.clean();\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void pushExportBuffer(\n            long exportGeneration,\n            int partitionId,\n            String signature,\n            long uso,\n            long bufferPtr,\n            ByteBuffer buffer,\n            boolean sync,\n            boolean endOfStream) {\n        ExportManager instance = instance();\n        try {\n            ExportGeneration generation = instance.m_generations.get(exportGeneration);\n            if (generation == null) {\n                DBBPool.deleteCharArrayMemory(bufferPtr);\n                /*\n                 * If the generation was already drained it is fine for a buffer to come late and miss it\n                 */\n                synchronized(instance) {\n                    if (!instance.m_generationGhosts.contains(exportGeneration)) {\n                        assert(false);\n                        exportLog.error(\"Could not a find an export generation \" + exportGeneration +\n                        \". Should be impossible. Discarding export data\");\n                    }\n                }\n                return;\n            }\n\n            /*\n             * Due to issues double freeing and using after free,\n             * copy the buffer onto the heap and rely on GC.\n             *\n             * This should buy enough time to diagnose the root cause.\n             */\n            if (buffer != null) {\n                ByteBuffer buf = ByteBuffer.allocate(buffer.remaining());\n                buf.put(buffer);\n                buf.flip();\n                DBBPool.deleteCharArrayMemory(bufferPtr);\n                buffer = buf;\n                bufferPtr = 0;\n            }\n            generation.pushExportBuffer(partitionId, signature, uso, bufferPtr, buffer, sync, endOfStream);\n        } catch (Exception e) {\n            //Don't let anything take down the execution site thread\n            exportLog.error(\"Error pushing export buffer\", e);\n        }\n    }","id":26078,"modified_method":"public static void pushExportBuffer(\n            long exportGeneration,\n            int partitionId,\n            String signature,\n            long uso,\n            long bufferPtr,\n            ByteBuffer buffer,\n            boolean sync,\n            boolean endOfStream) {\n        ExportManager instance = instance();\n        try {\n            ExportGeneration generation = instance.m_generations.get(exportGeneration);\n            if (generation == null) {\n                DBBPool.deleteCharArrayMemory(bufferPtr);\n                /*\n                 * If the generation was already drained it is fine for a buffer to come late and miss it\n                 */\n                synchronized(instance) {\n                    if (!instance.m_generationGhosts.contains(exportGeneration)) {\n                        assert(false);\n                        exportLog.error(\"Could not a find an export generation \" + exportGeneration +\n                        \". Should be impossible. Discarding export data\");\n                    }\n                }\n                return;\n            }\n\n            generation.pushExportBuffer(partitionId, signature, uso, bufferPtr, buffer, sync, endOfStream);\n        } catch (Exception e) {\n            //Don't let anything take down the execution site thread\n            exportLog.error(\"Error pushing export buffer\", e);\n        }\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public synchronized void parseAndTruncate(BinaryDequeTruncator truncator) throws IOException {\n        assertions();\n        if (m_finishedSegments.isEmpty()) {\n            exportLog.debug(\"PBD \" + m_nonce + \" has no finished segments\");\n            return;\n        }\n        //+16 because I am not sure if the max chunk size is enforced right\n        ByteBuffer readBuffer = ByteBuffer.allocateDirect(DequeSegment.m_chunkSize + 16);\n\n        /*\n         * Iterator all the objects in all the segments and pass them to the truncator\n         * When it finds the truncation point\n         */\n        Long lastSegmentIndex = null;\n        for (Map.Entry<Long, DequeSegment> entry : m_finishedSegments.entrySet()) {\n            readBuffer.clear();\n            DequeSegment segment = entry.getValue();\n            long segmentIndex = entry.getKey();\n\n            File segmentFile = segment.m_file;\n            RandomAccessFile ras = new RandomAccessFile(segmentFile, \"rw\");\n            FileChannel fc = ras.getChannel();\n            try {\n                /*\n                 * Read the entire segment into memory\n                 */\n                while (readBuffer.hasRemaining()) {\n                    int read = fc.read(readBuffer);\n                    if (read == -1) {\n                        break;\n                    }\n                }\n                readBuffer.flip();\n\n                //Get the number of objects and then iterator over them\n                int numObjects = readBuffer.getInt();\n                exportLog.debug(\"PBD \" + m_nonce + \" has \" + numObjects + \" objects to parse and truncate\");\n                for (int ii = 0; ii < numObjects; ii++) {\n                    final int nextObjectLength = readBuffer.getInt();\n                    //Copy the next object into a separate heap byte buffer\n                    //do the old limit stashing trick to avoid buffer overflow\n                    ByteBuffer nextObject = ByteBuffer.allocate(nextObjectLength);\n                    final int oldLimit = readBuffer.limit();\n                    readBuffer.limit(readBuffer.position() + nextObjectLength);\n\n                    nextObject.put(readBuffer).flip();\n\n                    //Put back the original limit\n                    readBuffer.limit(oldLimit);\n\n                    //Handoff the object to the truncator and await a decision\n                    ByteBuffer retval = truncator.parse(nextObject);\n                    if (retval == null) {\n                        //Nothing to do, leave the object alone and move to the next\n                        continue;\n                    } else {\n                        long startSize = fc.size();\n                        //If the returned bytebuffer is empty, remove the object and truncate the file\n                        if (retval.remaining() == 0) {\n                            if (ii == 0) {\n                                /*\n                                 * If truncation is occuring at the first object\n                                 * Whammo! Delete the file. Do it by setting the lastSegmentIndex\n                                 * to 1 previous. We may end up with an empty finished segment\n                                 * set.\n                                 */\n                                lastSegmentIndex = segmentIndex - 1;\n                            } else {\n                                //Don't forget to update the number of entries in the file\n                                ByteBuffer numObjectsBuffer = ByteBuffer.allocate(4);\n                                numObjectsBuffer.putInt(0, ii);\n                                fc.position(0);\n                                while (numObjectsBuffer.hasRemaining()) {\n                                    fc.write(numObjectsBuffer);\n                                }\n                                fc.truncate(readBuffer.position() - (nextObjectLength + 4));\n                            }\n\n                        } else {\n                            readBuffer.position(readBuffer.position() - (nextObjectLength + 4));\n                            readBuffer.putInt(retval.remaining());\n                            readBuffer.put(retval);\n                            readBuffer.flip();\n\n                            readBuffer.putInt(0, ii + 1);\n                            /*\n                             * SHOULD REALLY make a copy of the original and then swap them with renaming\n                             */\n                            fc.position(0);\n                            fc.truncate(0);\n\n                            while (readBuffer.hasRemaining()) {\n                                fc.write(readBuffer);\n                            }\n                        }\n                        long endSize = fc.size();\n                        m_sizeInBytes.addAndGet(endSize - startSize);\n                        //Set last segment and break the loop over this segment\n                        if (lastSegmentIndex == null) {\n                            lastSegmentIndex = segmentIndex;\n                        }\n                        break;\n                    }\n                }\n\n                //If this is set the just processed segment was the last one\n                if (lastSegmentIndex != null) {\n                    break;\n                }\n            } finally {\n                fc.close();\n                DBBPool.cleanByteBuffer(readBuffer);\n            }\n        }\n\n        /*\n         * If it was found that no truncation is necessary, lastSegmentIndex will be null.\n         * Return and the parseAndTruncate is a noop.\n         */\n        if (lastSegmentIndex == null)  {\n            return;\n        }\n        /*\n         * Now truncate all the segments after the truncation point\n         */\n        Iterator<Map.Entry<Long, DequeSegment>> iterator = m_finishedSegments.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<Long, DequeSegment> entry = iterator.next();\n            if (entry.getKey() <= lastSegmentIndex) {\n                continue;\n            }\n            DequeSegment ds = entry.getValue();\n            iterator.remove();\n            ds.closeAndDelete();\n        }\n\n        //The write segment may have the wrong index, delete it\n        m_writeSegment.closeAndDelete();\n\n        /*\n         * Reset the poll and write segments\n         */\n        //Find the first and last segment for polling and writing (after)\n        m_currentPollSegmentIndex = 0L;\n        Long writeSegmentIndex = 0L;\n        try {\n            m_currentPollSegmentIndex = m_finishedSegments.firstKey();\n            writeSegmentIndex = m_finishedSegments.lastKey() + 1;\n        } catch (NoSuchElementException e) {}\n\n        m_writeSegment =\n            new DequeSegment(\n                    writeSegmentIndex,\n                    new VoltFile(m_path, m_nonce + \".\" + writeSegmentIndex + \".pbd\"));\n        m_writeSegment.open();\n        m_writeSegment.initNumEntries();\n        if (m_finishedSegments.isEmpty()) {\n            assert(m_writeSegment.m_index.equals(m_currentPollSegmentIndex));\n        }\n        assertions();\n    }","id":26079,"modified_method":"@Override\n    public synchronized void parseAndTruncate(BinaryDequeTruncator truncator) throws IOException {\n        assertions();\n        if (m_segments.isEmpty()) {\n            exportLog.debug(\"PBD \" + m_nonce + \" has no finished segments\");\n            return;\n        }\n\n        /*\n         * Iterator all the objects in all the segments and pass them to the truncator\n         * When it finds the truncation point\n         */\n        Long lastSegmentIndex = null;\n        ByteBuffer decompressionBuffer = ByteBuffer.allocateDirect(1024 * 512);\n        for (PBDSegment segment : m_segments) {\n            long segmentIndex = segment.m_index;\n\n            File segmentFile = segment.m_file;\n            RandomAccessFile ras = new RandomAccessFile(segmentFile, \"rw\");\n            FileChannel fc = ras.getChannel();\n            ByteBuffer readBuffer = fc.map(MapMode.READ_WRITE, 0, fc.size());\n            final long buffAddr = ((DirectBuffer)readBuffer).address();\n            try {\n                //Get the number of objects and then iterator over them\n                int numObjects = readBuffer.getInt();\n                exportLog.debug(\"PBD \" + m_nonce + \" has \" + numObjects + \" objects to parse and truncate\");\n                for (int ii = 0; ii < numObjects; ii++) {\n                    final int nextObjectLength = readBuffer.getInt();\n                    final int nextObjectFlags = readBuffer.getInt();\n                    final boolean compressed = nextObjectFlags == PBDSegment.FLAG_COMPRESSED;\n                    final int uncompressedLength = compressed ? (int)Snappy.uncompressedLength(buffAddr + readBuffer.position(), nextObjectLength) : nextObjectLength;\n                    //Copy the next object into a separate heap byte buffer\n                    //do the old limit stashing trick to avoid buffer overflow\n                    ByteBuffer nextObject = null;\n                    if (compressed) {\n                        decompressionBuffer.clear();\n                        if (decompressionBuffer.remaining() < uncompressedLength ) {\n                            DBBPool.cleanByteBuffer(decompressionBuffer);\n                            decompressionBuffer = ByteBuffer.allocateDirect(uncompressedLength);\n                        }\n                        nextObject = decompressionBuffer;\n                        final long sourceAddr = (buffAddr + readBuffer.position());\n                        final long destAddr = ((DirectBuffer)nextObject).address();\n                        Snappy.rawUncompress(sourceAddr, nextObjectLength, destAddr);\n                        readBuffer.position(readBuffer.position() + nextObjectLength);\n                    } else {\n                        final int oldLimit = readBuffer.limit();\n                        readBuffer.limit(readBuffer.position() + nextObjectLength);\n                        nextObject = readBuffer.slice();\n                        readBuffer.position(readBuffer.limit());\n                        readBuffer.limit(oldLimit);\n                    }\n\n                    //Handoff the object to the truncator and await a decision\n                    ByteBuffer retval = truncator.parse(nextObject);\n                    if (retval == null) {\n                        DBBPool.cleanByteBuffer(nextObject);\n                        //Nothing to do, leave the object alone and move to the next\n                        continue;\n                    } else {\n                        long startSize = fc.size();\n                        //If the returned bytebuffer is empty, remove the object and truncate the file\n                        if (retval.remaining() == 0) {\n                            if (ii == 0) {\n                                /*\n                                 * If truncation is occuring at the first object\n                                 * Whammo! Delete the file. Do it by setting the lastSegmentIndex\n                                 * to 1 previous. We may end up with an empty finished segment\n                                 * set.\n                                 */\n                                lastSegmentIndex = segmentIndex - 1;\n                            } else {\n                                //Don't forget to update the number of entries in the file\n                                ByteBuffer numObjectsBuffer = ByteBuffer.allocate(4);\n                                numObjectsBuffer.putInt(0, ii);\n                                fc.position(0);\n                                while (numObjectsBuffer.hasRemaining()) {\n                                    fc.write(numObjectsBuffer);\n                                }\n                                fc.truncate(readBuffer.position() - (nextObjectLength + PBDSegment.m_objectHeaderBytes));\n                            }\n\n                        } else {\n                            //Partial object truncation\n                            ByteBuffer copy = ByteBuffer.allocate(retval.remaining());\n                            copy.put(retval);\n                            copy.flip();\n                            readBuffer.position(readBuffer.position() - (nextObjectLength + PBDSegment.m_objectHeaderBytes));\n                            readBuffer.putInt(copy.remaining());\n                            readBuffer.putInt(0);\n                            readBuffer.put(copy);\n\n                            readBuffer.putInt(0, ii + 1);\n\n                            /*\n                             * SHOULD REALLY make a copy of the original and then swap them with renaming\n                             */\n                            fc.truncate(readBuffer.position());\n                        }\n                        //Set last segment and break the loop over this segment\n                        if (lastSegmentIndex == null) {\n                            lastSegmentIndex = segmentIndex;\n                        }\n                        DBBPool.cleanByteBuffer(nextObject);\n                        break;\n                    }\n                }\n\n                //If this is set the just processed segment was the last one\n                if (lastSegmentIndex != null) {\n                    break;\n                }\n            } finally {\n                fc.close();\n                DBBPool.cleanByteBuffer(readBuffer);\n            }\n        }\n        DBBPool.cleanByteBuffer(decompressionBuffer);\n\n        /*\n         * If it was found that no truncation is necessary, lastSegmentIndex will be null.\n         * Return and the parseAndTruncate is a noop.\n         */\n        if (lastSegmentIndex == null)  {\n            return;\n        }\n        /*\n         * Now truncate all the segments after the truncation point\n         */\n        Iterator<PBDSegment> iterator = m_segments.descendingIterator();\n        while (iterator.hasNext()) {\n            PBDSegment segment = iterator.next();\n            if (segment.m_index <= lastSegmentIndex) {\n                break;\n            }\n            iterator.remove();\n            segment.closeAndDelete();\n        }\n\n        /*\n         * Reset the poll and write segments\n         */\n        //Find the first and last segment for polling and writing (after)\n        Long newSegmentIndex = 0L;\n        if (m_segments.peekLast() != null) newSegmentIndex = m_segments.peekLast().m_index + 1;\n\n        PBDSegment newSegment =\n            new PBDSegment(\n                    newSegmentIndex,\n                    new VoltFile(m_path, m_nonce + \".\" + newSegmentIndex + \".pbd\"));\n        newSegment.open(true);\n        m_segments.offer(newSegment);\n        assertions();\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public synchronized boolean isEmpty() throws IOException {\n        assertions();\n        if (m_writeSegment == null) {\n            throw new IOException(\"Closed\");\n        }\n        DequeSegment segment = m_finishedSegments.get(m_currentPollSegmentIndex);\n        if (segment == null) {\n            assert(m_writeSegment.m_index.equals(m_currentPollSegmentIndex));\n            //See if we can steal the write segment, otherwise return null\n            if (m_writeSegment.getNumEntries() > 0) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return segment.m_objectReadIndex >= segment.getNumEntries();\n    }","id":26080,"modified_method":"@Override\n    public synchronized boolean isEmpty() throws IOException {\n        assertions();\n        if (m_closed) {\n            throw new IOException(\"Closed\");\n        }\n\n        PBDSegment segment = m_segments.peek();\n        if (segment == null) {\n            return true;\n        }\n        if (segment.hasMoreEntries()) return false;\n        for (PBDSegment s : m_segments) {\n            if (segment.hasMoreEntries()) return false;\n        }\n        return true;\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private BBContainer poll() throws IOException {\n            if (m_fc == null) {\n                open();\n            }\n\n            //No more entries to read\n            int numEntries = getNumEntries();\n            if (m_objectReadIndex >= numEntries) {\n                return null;\n            }\n\n            m_objectReadIndex++;\n\n            //If this is the last object to read from this segment\n            //increment the poll segment index so that the next poll\n            //selects the correct segment\n            if (m_objectReadIndex >= numEntries) {\n                m_currentPollSegmentIndex++;\n\n                /*\n                 * Check that the poll segment index we are pointing to\n                 * actually contains more entries to be polled.\n                 * If someone pushes entries into the deque after they have polled\n                 * entries from the head segment you can end up in a scenario where\n                 * the next segment is actually empty and not the place to poll from\n                 * next. It's a pretty messed up scenario and it is up to the caller to\n                 * make sense of it.\n                 *\n                 */\n                while (m_finishedSegments.containsKey(m_currentPollSegmentIndex)) {\n                    DequeSegment ds = m_finishedSegments.get(m_currentPollSegmentIndex);\n                    if (ds.hasMoreEntries()) break;\n                    //The deque segment that follows has no more entries, check the next one\n                    //or point to the current write segment\n                    m_currentPollSegmentIndex++;\n                    //If this is going to point to the write segment, sanity check the indexes match\n                    if (!m_finishedSegments.containsKey(m_currentPollSegmentIndex) && m_writeSegment != null) {\n                        assert(m_writeSegment.m_index.intValue() == m_currentPollSegmentIndex);\n                    }\n                }\n\n            }\n\n            //Get the length prefix and then read the object\n            m_bufferForNumEntries.clear();\n            while (m_bufferForNumEntries.hasRemaining()) {\n                int read = m_fc.read(m_bufferForNumEntries);\n                if (read == -1) {\n                    throw new EOFException();\n                }\n            }\n            m_bufferForNumEntries.flip();\n            int length = m_bufferForNumEntries.getInt();\n            if (length < 1) {\n                throw new IOException(\"Read an invalid length\");\n            }\n\n            ByteBuffer resultBuffer = ByteBuffer.allocate(length);\n            while (resultBuffer.hasRemaining()) {\n                int read = m_fc.read(resultBuffer);\n                if (read == -1) {\n                    throw new EOFException();\n                }\n            }\n            resultBuffer.flip();\n\n            return new BBContainer( resultBuffer ) {\n                private boolean discarded = false;\n\n                private final Throwable t = new Throwable();\n                @Override\n                public void discard() {\n                    if (!discarded) {\n                        discarded = true;\n                        m_discardsUntilDeletion--;\n                        if (m_discardsUntilDeletion == 0) {\n                            m_finishedSegments.remove(m_index);\n                            try {\n                                closeAndDelete();\n                            } catch (IOException e) {\n                                exportLog.error(\"Error closing and deleting binary deque segment\", e);\n                            }\n                        }\n                    } else {\n                        exportLog.error(\"An export buffer was discarded multiple times\");\n                    }\n                }\n\n                @Override\n                public void finalize() {\n                    if (!discarded && !m_closed) {\n                        exportLog.error(m_file + \" had a buffer that was finalized without being discarded\");\n                        StringWriter sw  = new StringWriter();\n                        PrintWriter pw = new PrintWriter(sw);\n                        t.printStackTrace(pw);\n                        exportLog.error(sw.toString());\n                        discard();\n                    }\n                }\n            };\n        }","id":26081,"modified_method":"@Override\n    public synchronized void offer(BBContainer object) throws IOException {\n        assertions();\n        if (m_closed) {\n            throw new IOException(\"Closed\");\n        }\n\n        PBDSegment tail = m_segments.peekLast();\n        //If we are mostly empty, don't do compression, otherwise compress to reduce space and IO\n        final boolean compress = object.b.isDirect() && m_segments.size() > 1 || tail.sizeInBytes() > 1024 * 512;\n        if (!tail.offer(object, compress)) {\n            //Check to see if the tail is completely consumed so we can close and delete it\n            if (!tail.hasMoreEntries() && tail.m_discardCount == tail.getNumEntries()) {\n                m_segments.pollLast();\n                tail.closeAndDelete();\n            }\n            Long nextIndex = tail.m_index + 1;\n            tail = new PBDSegment(nextIndex, new VoltFile(m_path, m_nonce + \".\" + nextIndex + \".pbd\"));\n            tail.open(true);\n            m_segments.offer(tail);\n            final boolean success = tail.offer(object, compress);\n            if (!success) {\n                throw new IOException(\"Failed to offer object in PBD\");\n            }\n        }\n        assertions();\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create a persistent binary deque with the specified nonce and storage back at the specified path.\n     * Existing files will\n     * @param nonce\n     * @param path\n     * @throws IOException\n     */\n    public PersistentBinaryDeque(final String nonce, final File path) throws IOException {\n        m_path = path;\n        m_nonce = nonce;\n\n        if (!path.exists() || !path.canRead() || !path.canWrite() || !path.canExecute() || !path.isDirectory()) {\n            throw new IOException(path + \" is not usable ( !exists || !readable \" +\n                    \"|| !writable || !executable || !directory)\");\n        }\n\n        //Parse the files in the directory by name to find files\n        //that are part of this deque\n        path.listFiles(new FileFilter() {\n\n            @Override\n            public boolean accept(File pathname) {\n                // PBD file names have three parts: nonce.seq.pbd\n                // nonce may contain '.', seq is a sequence number.\n                String[] parts = pathname.getName().split(\"\\\\.\");\n                String parsedNonce = null;\n                String seqNum = null;\n                String extension = null;\n\n                // If more than 3 parts, it means nonce contains '.', assemble them.\n                if (parts.length > 3) {\n                    Joiner joiner = Joiner.on('.').skipNulls();\n                    parsedNonce = joiner.join(Arrays.asList(parts).subList(0, parts.length - 2));\n                    seqNum = parts[parts.length - 2];\n                    extension = parts[parts.length - 1];\n                } else if (parts.length == 3) {\n                    parsedNonce = parts[0];\n                    seqNum = parts[1];\n                    extension = parts[2];\n                }\n\n                if (nonce.equals(parsedNonce) && \"pbd\".equals(extension)) {\n                    if (pathname.length() == 4) {\n                        //Doesn't have any objects, just the object count\n                        pathname.delete();\n                        return false;\n                    }\n                    Long index = Long.valueOf(seqNum);\n                    DequeSegment ds = new DequeSegment( index, pathname);\n                    m_finishedSegments.put( index, ds);\n                    m_sizeInBytes.addAndGet(ds.sizeInBytes());\n                }\n                return false;\n            }\n\n        });\n\n        Long lastKey = null;\n        for (Long key : m_finishedSegments.keySet()) {\n            if (lastKey == null) {\n                lastKey = key;\n            } else {\n                if (lastKey + 1 != key) {\n                    throw new IOException(\"Missing \" + nonce +\n                            \" pbd segments between \" + lastKey + \" and \" + key + \" in directory \" + path +\n                            \". The data files found in the export overflow directory were inconsistent.\");\n                }\n                lastKey = key;\n            }\n        }\n        //Find the first and last segment for polling and writing (after)\n        Long writeSegmentIndex = 0L;\n        try {\n            m_currentPollSegmentIndex = m_finishedSegments.firstKey();\n            writeSegmentIndex = m_finishedSegments.lastKey() + 1;\n        } catch (NoSuchElementException e) {}\n\n        m_writeSegment =\n            new DequeSegment(\n                    writeSegmentIndex,\n                    new VoltFile(m_path, m_nonce + \".\" + writeSegmentIndex + \".pbd\"));\n        m_writeSegment.open();\n        m_writeSegment.initNumEntries();\n        assertions();\n    }","id":26082,"modified_method":"/**\n     * Create a persistent binary deque with the specified nonce and storage back at the specified path.\n     * Existing files will\n     * @param nonce\n     * @param path\n     * @throws IOException\n     */\n    public PersistentBinaryDeque(final String nonce, final File path) throws IOException {\n        EELibraryLoader.loadExecutionEngineLibrary(true);\n        m_path = path;\n        m_nonce = nonce;\n\n        if (!path.exists() || !path.canRead() || !path.canWrite() || !path.canExecute() || !path.isDirectory()) {\n            throw new IOException(path + \" is not usable ( !exists || !readable \" +\n                    \"|| !writable || !executable || !directory)\");\n        }\n\n        final TreeMap<Long, PBDSegment> segments = new TreeMap<Long, PBDSegment>();\n        //Parse the files in the directory by name to find files\n        //that are part of this deque\n        try {\n            path.listFiles(new FileFilter() {\n\n                @Override\n                public boolean accept(File pathname) {\n                    // PBD file names have three parts: nonce.seq.pbd\n                    // nonce may contain '.', seq is a sequence number.\n                    String[] parts = pathname.getName().split(\"\\\\.\");\n                    String parsedNonce = null;\n                    String seqNum = null;\n                    String extension = null;\n\n                    // If more than 3 parts, it means nonce contains '.', assemble them.\n                    if (parts.length > 3) {\n                        Joiner joiner = Joiner.on('.').skipNulls();\n                        parsedNonce = joiner.join(Arrays.asList(parts).subList(0, parts.length - 2));\n                        seqNum = parts[parts.length - 2];\n                        extension = parts[parts.length - 1];\n                    } else if (parts.length == 3) {\n                        parsedNonce = parts[0];\n                        seqNum = parts[1];\n                        extension = parts[2];\n                    }\n\n                    if (nonce.equals(parsedNonce) && \"pbd\".equals(extension)) {\n                        if (pathname.length() == 4) {\n                            //Doesn't have any objects, just the object count\n                            pathname.delete();\n                            return false;\n                        }\n                        Long index = Long.valueOf(seqNum);\n                        PBDSegment qs = new PBDSegment( index, pathname );\n                        try {\n                            qs.open(false);\n                        } catch (IOException e) {\n                            new RuntimeException(e);\n                        }\n                        segments.put( index, qs);\n                    }\n                    return false;\n                }\n\n            });\n        } catch (RuntimeException e) {\n            if (e.getCause() instanceof IOException) {\n                throw new IOException(e);\n            }\n            Throwables.propagate(e);\n        }\n\n        Long lastKey = null;\n        for (Map.Entry<Long, PBDSegment> e : segments.entrySet()) {\n            final Long key = e.getKey();\n            if (lastKey == null) {\n                lastKey = key;\n            } else {\n                if (lastKey + 1 != key) {\n                    throw new IOException(\"Missing \" + nonce +\n                            \" pbd segments between \" + lastKey + \" and \" + key + \" in directory \" + path +\n                            \". The data files found in the export overflow directory were inconsistent.\");\n                }\n                lastKey = key;\n            }\n            m_segments.offer(e.getValue());\n        }\n\n        //Find the first and last segment for polling and writing (after)\n        Long writeSegmentIndex = 0L;\n        try {\n            writeSegmentIndex = segments.lastKey() + 1;\n        } catch (NoSuchElementException e) {}\n\n        PBDSegment writeSegment =\n            new PBDSegment(\n                    writeSegmentIndex,\n                    new VoltFile(m_path, m_nonce + \".\" + writeSegmentIndex + \".pbd\"));\n        m_segments.offer(writeSegment);\n        writeSegment.open(true);\n        assertions();\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void assertions() {\n        //Closed\n        if (m_writeSegment == null) return;\n        try  {\n            if (!m_finishedSegments.isEmpty()) {\n                for (Map.Entry<Long, DequeSegment> e : m_finishedSegments.entrySet()) {\n                    if (e.getValue().hasMoreEntries() && !e.getKey().equals(m_currentPollSegmentIndex)) {\n                        assert false : \"Current poll segment index should point to first segment that has entries\";\n                    } else if (e.getValue().hasMoreEntries()) {\n                        //Break because the current poll segment index obviously only matches\n                        //up to the first buffer with remaining entries\n                        break;\n                    }\n                }\n            } else if (m_currentPollSegmentIndex != m_writeSegment.m_index.intValue()) {\n                assert false : \"If there are no finished segments with more entries then \" +\n                               \"the current poll segment index should point to the write segment\";\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            assert false : \"This code shouldn't throw an exception\";\n        }\n    }","id":26083,"modified_method":"private void assertions() {\n        /*\n         * None of these assertions were ass\n         */\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public synchronized void sync() throws IOException {\n        if (m_writeSegment == null) {\n            throw new IOException(\"Closed\");\n        }\n        m_writeSegment.sync();\n        for (DequeSegment segment : m_finishedSegments.values()) {\n            segment.sync();\n        }\n    }","id":26084,"modified_method":"@Override\n    public synchronized void sync() throws IOException {\n        if (m_closed) {\n            throw new IOException(\"Closed\");\n        }\n        for (PBDSegment segment : m_segments) {\n            segment.sync();\n        }\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public synchronized void close() throws IOException {\n        if (m_writeSegment == null) {\n            throw new IOException(\"Closed\");\n        }\n        if (m_writeSegment.getNumEntries() > 0) {\n            m_finishedSegments.put(m_writeSegment.m_index, m_writeSegment);\n        } else {\n            m_writeSegment.closeAndDelete();\n        }\n        m_writeSegment = null;\n        for (DequeSegment segment : m_finishedSegments.values()) {\n            segment.close();\n        }\n        m_closed = true;\n    }","id":26085,"modified_method":"@Override\n    public synchronized void close() throws IOException {\n        if (m_closed) {\n            return;\n        }\n        if (!m_segments.peekLast().hasMoreEntries()) {\n            m_segments.pollLast().closeAndDelete();\n        }\n        for (PBDSegment segment : m_segments) {\n            segment.close();\n        }\n        m_closed = true;\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public synchronized void push(BBContainer[][] objects) throws IOException {\n        assertions();\n        if (m_writeSegment == null) {\n            throw new IOException(\"Closed\");\n        }\n        ArrayDeque<ArrayDeque<BBContainer[]>> segments = new ArrayDeque<ArrayDeque<BBContainer[]>>();\n        ArrayDeque<BBContainer[]> currentSegment = new ArrayDeque<BBContainer[]>();\n\n        //Take the objects that were provided and separate them into deques of objects\n        //that will fit in a single write segment\n        int available = DequeSegment.m_chunkSize - 4;\n        for (BBContainer object[] : objects) {\n            int needed = 4;\n            for (BBContainer obj : object) {\n                needed += obj.b.remaining();\n            }\n\n            if (available - needed < 0) {\n                if (needed > DequeSegment.m_chunkSize - 4) {\n                    throw new IOException(\"Maximum object size is \" + (DequeSegment.m_chunkSize - 4));\n                }\n                segments.offer( currentSegment );\n                currentSegment = new ArrayDeque<BBContainer[]>();\n                available = DequeSegment.m_chunkSize - 4;\n            }\n            available -= needed;\n            currentSegment.add(object);\n        }\n\n        segments.add(currentSegment);\n        assert(segments.size() > 0);\n\n        //Calculate the index for the first segment to push at the front\n        //This will be the index before the first segment available for read or\n        //before the write segment if there are no finished segments\n        Long nextIndex = 0L;\n        if (m_finishedSegments.size() > 0) {\n            nextIndex = m_finishedSegments.firstKey() - 1;\n        } else {\n            nextIndex = m_writeSegment.m_index - 1;\n        }\n\n        while (segments.peek() != null) {\n            ArrayDeque<BBContainer[]> currentSegmentContents = segments.poll();\n            DequeSegment writeSegment =\n                new DequeSegment(\n                        nextIndex,\n                        new VoltFile(m_path, m_nonce + \".\" + nextIndex + \".pbd\"));\n            m_currentPollSegmentIndex = nextIndex;\n            writeSegment.open();\n            writeSegment.initNumEntries();\n            nextIndex--;\n\n            while (currentSegmentContents.peek() != null) {\n                writeSegment.offer(currentSegmentContents.pollFirst());\n            }\n\n            writeSegment.m_fc.position(4);\n            m_finishedSegments.put(writeSegment.m_index, writeSegment);\n        }\n        assertions();\n    }","id":26086,"modified_method":"@Override\n    public synchronized void push(BBContainer objects[]) throws IOException {\n        assertions();\n        if (m_closed) {\n            throw new IOException(\"Closed\");\n        }\n\n        ArrayDeque<ArrayDeque<BBContainer>> segments = new ArrayDeque<ArrayDeque<BBContainer>>();\n        ArrayDeque<BBContainer> currentSegment = new ArrayDeque<BBContainer>();\n\n        //Take the objects that were provided and separate them into deques of objects\n        //that will fit in a single write segment\n        int available = PBDSegment.m_chunkSize - 4;\n        for (BBContainer object : objects) {\n            int needed = PBDSegment.m_objectHeaderBytes + object.b.remaining();\n\n            if (available - needed < 0) {\n                if (needed > PBDSegment.m_chunkSize - 4) {\n                    throw new IOException(\"Maximum object size is \" + (PBDSegment.m_chunkSize - 4));\n                }\n                segments.offer( currentSegment );\n                currentSegment = new ArrayDeque<BBContainer>();\n                available = PBDSegment.m_chunkSize - 4;\n            }\n            available -= needed;\n            currentSegment.add(object);\n        }\n\n        segments.add(currentSegment);\n        assert(segments.size() > 0);\n\n        //Calculate the index for the first segment to push at the front\n        //This will be the index before the first segment available for read or\n        //before the write segment if there are no finished segments\n        Long nextIndex = 0L;\n        if (m_segments.size() > 0) {\n            nextIndex = m_segments.peek().m_index - 1;\n        }\n\n        while (segments.peek() != null) {\n            ArrayDeque<BBContainer> currentSegmentContents = segments.poll();\n            PBDSegment writeSegment =\n                new PBDSegment(\n                        nextIndex,\n                        new VoltFile(m_path, m_nonce + \".\" + nextIndex + \".pbd\"));\n            writeSegment.open(true);\n            nextIndex--;\n\n            while (currentSegmentContents.peek() != null) {\n                writeSegment.offer(currentSegmentContents.pollFirst(), false);\n            }\n\n            m_segments.push(writeSegment);\n        }\n        assertions();\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public long sizeInBytes() {\n        assertions();\n        return m_sizeInBytes.get();\n    }","id":26087,"modified_method":"@Override\n    public long sizeInBytes() {\n        assertions();\n        long size = 0;\n        for (PBDSegment segment : m_segments) {\n            size += segment.sizeInBytes();\n        }\n        return size;\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public synchronized void closeAndDelete() throws IOException {\n        m_writeSegment.closeAndDelete();\n        for (DequeSegment ds : m_finishedSegments.values()) {\n            ds.closeAndDelete();\n        }\n    }","id":26088,"modified_method":"@Override\n    public synchronized void closeAndDelete() throws IOException {\n        for (PBDSegment qs : m_segments) {\n            qs.closeAndDelete();\n        }\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"StreamBlock(BBContainer cont, long uso, boolean isPersisted) {\n        m_buffer = cont;\n        m_uso = uso;\n        m_totalUso = m_buffer.b.capacity();\n        m_isPersisted = isPersisted;\n    }","id":26089,"modified_method":"StreamBlock(BBContainer cont, long uso, boolean isPersisted) {\n        m_buffer = cont;\n        m_uso = uso;\n        m_buffer.b.position(8);\n        m_totalUso = m_buffer.b.remaining();\n        m_isPersisted = isPersisted;\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Wrapper around the common operation of pulling an element out of the persistent deque.\n     * The behavior is complicated (and might change) since the persistent deque can throw an IOException.\n     * The poll always removes the element from the persistent queue\n     * (although not necessarily removing the file backing, that happens at deleteContents) and will add\n     * a reference to the block to the in memory deque unless actuallyPoll is true.\n     * @param actuallyPoll\n     * @return\n     */\n    private StreamBlock pollPersistentDeque(boolean actuallyPoll) {\n        BBContainer cont = null;\n        try {\n            cont = m_persistentDeque.poll();\n        } catch (IOException e) {\n            exportLog.error(e);\n        }\n\n        if (cont == null) {\n            return null;\n        } else {\n            //If the container is not null, unpack it.\n            final BBContainer fcont = cont;\n            long uso = cont.b.getLong();\n            ByteBuffer buf = cont.b.slice();\n            //Pass the stream block a subset of the bytes, provide\n            //a container that discards the original returned by the persistent deque\n            StreamBlock block = new StreamBlock( new BBContainer(buf) {\n                    @Override\n                    public void discard() {\n                        fcont.discard();\n                    }\n                },\n                uso,\n                true);\n\n            //Optionally store a reference to the block in the in memory deque\n            if (!actuallyPoll) {\n                m_memoryDeque.offer(block);\n            }\n            return block;\n        }\n    }","id":26090,"modified_method":"/**\n     * Wrapper around the common operation of pulling an element out of the persistent deque.\n     * The behavior is complicated (and might change) since the persistent deque can throw an IOException.\n     * The poll always removes the element from the persistent queue\n     * (although not necessarily removing the file backing, that happens at deleteContents) and will add\n     * a reference to the block to the in memory deque unless actuallyPoll is true.\n     * @param actuallyPoll\n     * @return\n     */\n    private StreamBlock pollPersistentDeque(boolean actuallyPoll) {\n        BBContainer cont = null;\n        try {\n            cont = m_persistentDeque.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY);\n        } catch (IOException e) {\n            exportLog.error(e);\n        }\n\n        if (cont == null) {\n            return null;\n        } else {\n            //If the container is not null, unpack it.\n            final BBContainer fcont = cont;\n            long uso = cont.b.getLong(0);\n            //Pass the stream block a subset of the bytes, provide\n            //a container that discards the original returned by the persistent deque\n            StreamBlock block = new StreamBlock( new BBContainer(fcont.b) {\n                    @Override\n                    public void discard() {\n                        fcont.discard();\n                    }\n                },\n                uso,\n                true);\n\n            //Optionally store a reference to the block in the in memory deque\n            if (!actuallyPoll) {\n                m_memoryDeque.offer(block);\n            }\n            return block;\n        }\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void sync(boolean nofsync) throws IOException {\n        if (m_memoryDeque.peek() != null && !m_memoryDeque.peek().isPersisted()) {\n            ArrayDeque<BBContainer[]> buffersToPush = new ArrayDeque<BBContainer[]>();\n            while (m_memoryDeque.peek() != null) {\n                StreamBlock sb = m_memoryDeque.peek();\n                if (sb.isPersisted()) {\n                    break;\n                }\n                m_memoryDeque.poll();\n                buffersToPush.offer(sb.asBufferChain());\n            }\n\n            if (!buffersToPush.isEmpty()) {\n                m_persistentDeque.push(buffersToPush.toArray(new BBContainer[0][0]));\n            }\n            ArrayList<StreamBlock> blocks = new ArrayList<StreamBlock>();\n            for (int ii = 0; ii < buffersToPush.size(); ii++) {\n                blocks.add(pollPersistentDeque(true));\n            }\n            for (int ii = blocks.size() - 1; ii >= 0; ii--) {\n                m_memoryDeque.offerFirst(blocks.get(ii));\n            }\n        }\n\n        if (!nofsync) {\n            m_persistentDeque.sync();\n        }\n    }","id":26091,"modified_method":"public void sync(boolean nofsync) throws IOException {\n        if (m_memoryDeque.peek() != null && !m_memoryDeque.peek().isPersisted()) {\n            ArrayDeque<BBContainer> buffersToPush = new ArrayDeque<BBContainer>();\n            while (m_memoryDeque.peek() != null) {\n                StreamBlock sb = m_memoryDeque.peek();\n                if (sb.isPersisted()) {\n                    break;\n                }\n                m_memoryDeque.poll();\n                buffersToPush.offer(sb.asBBContainer());\n            }\n\n            if (!buffersToPush.isEmpty()) {\n                m_persistentDeque.push(buffersToPush.toArray(new BBContainer[0]));\n            }\n            ArrayList<StreamBlock> blocks = new ArrayList<StreamBlock>();\n            for (int ii = 0; ii < buffersToPush.size(); ii++) {\n                blocks.add(pollPersistentDeque(true));\n            }\n            for (int ii = blocks.size() - 1; ii >= 0; ii--) {\n                m_memoryDeque.offerFirst(blocks.get(ii));\n            }\n        }\n\n        if (!nofsync) {\n            m_persistentDeque.sync();\n        }\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void offer(StreamBlock streamBlock) throws IOException {\n        //Already have two blocks, put it in the deque\n        if (m_memoryDeque.size() > 1) {\n            m_persistentDeque.offer(streamBlock.asBufferChain());\n        } else {\n            //Don't offer into the memory deque if there is anything waiting to be\n            //polled out of the persistent deque. Check the persistent deque\n            if (pollPersistentDeque(false) != null) {\n               m_persistentDeque.offer( streamBlock.asBufferChain());\n            } else {\n            //Persistent deque is empty put this in memory\n               m_memoryDeque.offer(streamBlock);\n            }\n        }\n    }","id":26092,"modified_method":"public void offer(StreamBlock streamBlock) throws IOException {\n        //Already have two blocks, put it in the deque\n        if (m_memoryDeque.size() > 1) {\n            m_persistentDeque.offer(streamBlock.asBBContainer());\n        } else {\n            //Don't offer into the memory deque if there is anything waiting to be\n            //polled out of the persistent deque. Check the persistent deque\n            if (pollPersistentDeque(false) != null) {\n               m_persistentDeque.offer( streamBlock.asBBContainer());\n            } else {\n            //Persistent deque is empty put this in memory\n               m_memoryDeque.offer(streamBlock);\n            }\n        }\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testOfferThanPoll() throws Exception {\n        assertNull(m_pbd.poll());\n\n        //Make sure a single file with the appropriate data is created\n        m_pbd.offer(defaultContainer);\n        File files[] = TEST_DIR.listFiles();\n        assertEquals( 1, files.length);\n        assertEquals( \"pbd_nonce.0.pbd\", files[0].getName());\n\n        //Now make sure the current write file is stolen and a new write file created\n        BBContainer retval = m_pbd.poll();\n        defaultBuffer.clear();\n        assertTrue(retval.b.equals(defaultBuffer));\n\n\n        TreeSet<String> names = getSortedDirectoryListing();\n        assertEquals( 2, names.size());\n        assertTrue(names.contains(\"pbd_nonce.0.pbd\"));\n        assertTrue(names.contains(\"pbd_nonce.1.pbd\"));\n\n        //Discarding the buffer should cause the file containing it to be deleted\n        retval.discard();\n\n        files = TEST_DIR.listFiles();\n        assertEquals( 1, files.length);\n        assertEquals( \"pbd_nonce.1.pbd\", files[0].getName());\n    }","id":26093,"modified_method":"@Test\n    public void testOfferThanPoll() throws Exception {\n        assertNull(m_pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY));\n\n        //Make sure a single file with the appropriate data is created\n        m_pbd.offer(defaultContainer);\n        File files[] = TEST_DIR.listFiles();\n        assertEquals( 1, files.length);\n        assertEquals( \"pbd_nonce.0.pbd\", files[0].getName());\n\n        //Now make sure the current write file is stolen and a new write file created\n        BBContainer retval = m_pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY);\n        defaultBuffer.clear();\n        retval.discard();\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testEmptyTruncation() throws Exception {\n        TreeSet<String> listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 1);\n        m_pbd.close();\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 0);\n\n        m_pbd = new PersistentBinaryDeque( TEST_NONCE, TEST_DIR );\n\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 1);\n\n        m_pbd.parseAndTruncate(new BinaryDequeTruncator() {\n            @Override\n            public ByteBuffer parse(ByteBuffer b) {\n                fail();\n                return null;\n            }\n\n        });\n\n        for (int ii = 0; ii < 96; ii++) {\n            m_pbd.offer(new BBContainer[] { DBBPool.wrapBB(getFilledBuffer(ii)) });\n        }\n\n        for (long ii = 0; ii < 96; ii++) {\n            BBContainer cont = m_pbd.poll();\n            assertNotNull(cont);\n            assertEquals(cont.b.remaining(), 1024 * 1024 * 2);\n            while (cont.b.remaining() > 7) {\n                assertEquals(cont.b.getLong(), ii);\n            }\n            cont.discard();\n        }\n    }","id":26094,"modified_method":"@Test\n    public void testEmptyTruncation() throws Exception {\n        TreeSet<String> listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 1);\n        m_pbd.close();\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 0);\n\n        m_pbd = new PersistentBinaryDeque( TEST_NONCE, TEST_DIR );\n\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 1);\n\n        m_pbd.parseAndTruncate(new BinaryDequeTruncator() {\n            @Override\n            public ByteBuffer parse(ByteBuffer b) {\n                fail();\n                return null;\n            }\n\n        });\n\n        for (int ii = 0; ii < 96; ii++) {\n            m_pbd.offer( DBBPool.wrapBB(getFilledBuffer(ii)) );\n        }\n\n        for (long ii = 0; ii < 96; ii++) {\n            BBContainer cont = m_pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY);\n            assertNotNull(cont);\n            assertEquals(cont.b.remaining(), 1024 * 1024 * 2);\n            while (cont.b.remaining() > 15) {\n                assertEquals(cont.b.getLong(), ii);\n                cont.b.getLong();\n            }\n            cont.discard();\n        }\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testOfferFailsWhenClosed() throws Exception {\n        m_pbd.close();\n        try {\n            m_pbd.offer(new BBContainer[] { DBBPool.wrapBB(ByteBuffer.allocate(20)) });\n        } catch (IOException e) {\n            return;\n        }\n        fail();\n    }","id":26095,"modified_method":"@Test\n    public void testOfferFailsWhenClosed() throws Exception {\n        m_pbd.close();\n        try {\n            m_pbd.offer(DBBPool.wrapBB(ByteBuffer.allocate(20)) );\n        } catch (IOException e) {\n            return;\n        }\n        fail();\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testNonceWithDots() throws Exception {\n        PersistentBinaryDeque pbd = new PersistentBinaryDeque(\"ha.ha\", TEST_DIR);\n        pbd.offer(defaultContainer);\n        pbd.close();\n\n        pbd = new PersistentBinaryDeque(\"ha.ha\", TEST_DIR);\n        BBContainer bb = pbd.poll();\n        defaultBuffer.clear();\n        assertEquals(defaultBuffer, bb.b);\n        pbd.close();\n    }","id":26096,"modified_method":"@Test\n    public void testNonceWithDots() throws Exception {\n        PersistentBinaryDeque pbd = new PersistentBinaryDeque(\"ha.ha\", TEST_DIR);\n        pbd.offer(defaultContainer);\n        pbd.close();\n\n        pbd = new PersistentBinaryDeque(\"ha.ha\", TEST_DIR);\n        BBContainer bb = pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY);\n        defaultBuffer.clear();\n        assertEquals(defaultBuffer, bb.b);\n        pbd.close();\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testPushMultipleSegments() throws Exception {\n        m_pbd.push(new BBContainer[][] {\n                new BBContainer[] { DBBPool.wrapBB(ByteBuffer.allocateDirect(1024 * 1024 * 32)) },\n                new BBContainer[] { DBBPool.wrapBB(ByteBuffer.allocateDirect(1024 * 1024 * 32)) },\n                new BBContainer[] { DBBPool.wrapBB(ByteBuffer.allocateDirect(1024 * 1024 * 32)) }});\n    }","id":26097,"modified_method":"@Test\n    public void testPushMultipleSegments() throws Exception {\n        m_pbd.push(new BBContainer[] {\n                DBBPool.wrapBB(ByteBuffer.allocateDirect(1024 * 1024 * 32)) ,\n                DBBPool.wrapBB(ByteBuffer.allocateDirect(1024 * 1024 * 32)) ,\n                DBBPool.wrapBB(ByteBuffer.allocateDirect(1024 * 1024 * 32)) });\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testTruncatorWithEmptyBufferReturn() throws Exception {\n        assertNull(m_pbd.poll());\n\n        for (int ii = 0; ii < 96; ii++) {\n            m_pbd.offer(new BBContainer[] { DBBPool.wrapBB(getFilledBuffer(ii)) });\n        }\n\n        m_pbd.close();\n\n        m_pbd = new PersistentBinaryDeque( TEST_NONCE, TEST_DIR );\n\n        TreeSet<String> listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 5);\n\n        m_pbd.parseAndTruncate(new BinaryDequeTruncator() {\n            private long m_objectsParsed = 0;\n            @Override\n            public ByteBuffer parse(ByteBuffer b) {\n                if (b.getLong(0) != m_objectsParsed) {\n                    System.out.println(\"asd\");\n                }\n                assertEquals(b.getLong(0), m_objectsParsed);\n                assertEquals(b.remaining(), 1024 * 1024 * 2 );\n                if (b.getLong(0) == 45) {\n                    b.limit(b.remaining() / 2);\n                    return ByteBuffer.allocate(0);\n                }\n                while (b.remaining() > 7) {\n                    assertEquals(b.getLong(), m_objectsParsed);\n                }\n                m_objectsParsed++;\n                return null;\n            }\n\n        });\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 3);\n\n        for (int ii = 46; ii < 96; ii++) {\n            m_pbd.offer(new BBContainer[] { DBBPool.wrapBB(getFilledBuffer(ii)) });\n        }\n\n        long blocksFound = 0;\n        BBContainer cont = null;\n        while ((cont = m_pbd.poll()) != null) {\n            try {\n                ByteBuffer buffer = cont.b;\n                if (blocksFound == 45) {\n                    blocksFound++;//white lie, so we expect the right block contents\n                }\n                assertEquals(buffer.remaining(), 1024 * 1024 * 2);\n                while (buffer.remaining() > 7) {\n                    assertEquals(buffer.getLong(), blocksFound);\n                }\n            } finally {\n                blocksFound++;\n                cont.discard();\n            }\n        }\n        assertEquals(blocksFound, 96);\n    }","id":26098,"modified_method":"@Test\n    public void testTruncatorWithEmptyBufferReturn() throws Exception {\n        assertNull(m_pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY));\n\n        for (int ii = 0; ii < 150; ii++) {\n            m_pbd.offer( DBBPool.wrapBB(getFilledBuffer(ii)) );\n        }\n\n        m_pbd.close();\n\n        m_pbd = new PersistentBinaryDeque( TEST_NONCE, TEST_DIR );\n\n        TreeSet<String> listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 5);\n\n        m_pbd.parseAndTruncate(new BinaryDequeTruncator() {\n            private long m_objectsParsed = 0;\n            @Override\n            public ByteBuffer parse(ByteBuffer b) {\n                if (b.getLong(0) != m_objectsParsed) {\n                    System.out.println(\"asd\");\n                }\n                assertEquals(b.getLong(0), m_objectsParsed);\n                assertEquals(b.remaining(), 1024 * 1024 * 2 );\n                if (b.getLong(0) == 45) {\n                    b.limit(b.remaining() / 2);\n                    return ByteBuffer.allocate(0);\n                }\n                while (b.remaining() > 15) {\n                    assertEquals(b.getLong(), m_objectsParsed);\n                    b.getLong();\n                }\n                m_objectsParsed++;\n                return null;\n            }\n\n        });\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 2);\n\n        for (int ii = 46; ii < 96; ii++) {\n            m_pbd.offer( DBBPool.wrapBB(getFilledBuffer(ii)) );\n        }\n\n        long blocksFound = 0;\n        BBContainer cont = null;\n        while ((cont = m_pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY)) != null) {\n            try {\n                ByteBuffer buffer = cont.b;\n                if (blocksFound == 45) {\n                    blocksFound++;//white lie, so we expect the right block contents\n                }\n                assertEquals(buffer.remaining(), 1024 * 1024 * 2);\n                while (buffer.remaining() > 15) {\n                    assertEquals(buffer.getLong(), blocksFound);\n                    buffer.getLong();\n                }\n            } finally {\n                blocksFound++;\n                cont.discard();\n            }\n        }\n        assertEquals(blocksFound, 96);\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testTruncator() throws Exception {\n        assertNull(m_pbd.poll());\n\n        for (int ii = 0; ii < 96; ii++) {\n            m_pbd.offer(new BBContainer[] { DBBPool.wrapBB(getFilledBuffer(ii)) });\n        }\n\n        m_pbd.close();\n\n        m_pbd = new PersistentBinaryDeque( TEST_NONCE, TEST_DIR );\n\n        TreeSet<String> listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 5);\n\n        m_pbd.parseAndTruncate(new BinaryDequeTruncator() {\n            private long m_objectsParsed = 0;\n            @Override\n            public ByteBuffer parse(ByteBuffer b) {\n                assertEquals(b.getLong(0), m_objectsParsed);\n                assertEquals(b.remaining(), 1024 * 1024 * 2 );\n                if (b.getLong(0) == 45) {\n                    b.limit(b.remaining() / 2);\n                    return b.slice();\n                }\n                while (b.remaining() > 7) {\n                    assertEquals(b.getLong(), m_objectsParsed);\n                }\n                m_objectsParsed++;\n                return null;\n            }\n\n        });\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 3);\n\n        for (int ii = 46; ii < 96; ii++) {\n            m_pbd.offer(new BBContainer[] { DBBPool.wrapBB(getFilledBuffer(ii)) });\n        }\n\n        long blocksFound = 0;\n        BBContainer cont = null;\n        while ((cont = m_pbd.poll()) != null) {\n            try {\n                ByteBuffer buffer = cont.b;\n                if (blocksFound == 45) {\n                    assertEquals(buffer.remaining(), 1024 * 1024);\n                } else {\n                    assertEquals(buffer.remaining(), 1024 * 1024 * 2);\n                }\n                while (buffer.remaining() > 7) {\n                    assertEquals(buffer.getLong(), blocksFound);\n                }\n            } finally {\n                blocksFound++;\n                cont.discard();\n            }\n        }\n        assertEquals(blocksFound, 96);\n    }","id":26099,"modified_method":"@Test\n    public void testTruncator() throws Exception {\n        assertNull(m_pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY));\n\n        for (int ii = 0; ii < 160; ii++) {\n            m_pbd.offer( DBBPool.wrapBB(getFilledBuffer(ii)) );\n        }\n\n        m_pbd.close();\n\n        m_pbd = new PersistentBinaryDeque( TEST_NONCE, TEST_DIR );\n\n        TreeSet<String> listing = getSortedDirectoryListing();\n        System.out.println(listing);\n        assertEquals(listing.size(), 5);\n\n        m_pbd.parseAndTruncate(new BinaryDequeTruncator() {\n            private long m_objectsParsed = 0;\n            @Override\n            public ByteBuffer parse(ByteBuffer b) {\n                assertEquals(b.getLong(0), m_objectsParsed);\n                assertEquals(b.remaining(), 1024 * 1024 * 2 );\n                if (b.getLong(0) == 45) {\n                    b.limit(b.remaining() / 2);\n                    return b.slice();\n                }\n                while (b.remaining() > 15) {\n                    assertEquals(b.getLong(), m_objectsParsed);\n                    b.getLong();\n                }\n                m_objectsParsed++;\n                return null;\n            }\n\n        });\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 2);\n\n        for (int ii = 46; ii < 96; ii++) {\n            m_pbd.offer( DBBPool.wrapBB(getFilledBuffer(ii)) );\n        }\n\n        long blocksFound = 0;\n        BBContainer cont = null;\n        while ((cont = m_pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY)) != null) {\n            try {\n                ByteBuffer buffer = cont.b;\n                if (blocksFound == 45) {\n                    assertEquals(buffer.remaining(), 1024 * 1024);\n                } else {\n                    assertEquals(buffer.remaining(), 1024 * 1024 * 2);\n                }\n                while (buffer.remaining() > 15) {\n                    assertEquals(buffer.getLong(), blocksFound);\n                    buffer.getLong();\n                }\n            } finally {\n                blocksFound++;\n                cont.discard();\n            }\n        }\n        assertEquals(blocksFound, 96);\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private static ByteBuffer getFilledBuffer(long fillValue) {\n        ByteBuffer buf = ByteBuffer.allocateDirect(1024 * 1024 * 2);\n        while (buf.remaining() > 7) {\n            buf.putLong(fillValue);\n        }\n        buf.clear();\n        return buf;\n    }","id":26100,"modified_method":"private static ByteBuffer getFilledBuffer(long fillValue) {\n        ByteBuffer buf = ByteBuffer.allocateDirect(1024 * 1024 * 2);\n        Random r = new Random(42);\n        while (buf.remaining() > 15) {\n            buf.putLong(fillValue);\n            buf.putLong(r.nextLong());\n        }\n        buf.clear();\n        return buf;\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testPushMaxSize() throws Exception {\n        try {\n            m_pbd.push(new BBContainer[][] {\n                new BBContainer[] { DBBPool.wrapBB(ByteBuffer.allocateDirect(1024 * 1024 * 64)) }});\n        } catch (IOException e) {\n            return;\n        }\n        fail();\n    }","id":26101,"modified_method":"@Test\n    public void testPushMaxSize() throws Exception {\n        try {\n            m_pbd.push(new BBContainer[] {\n                 DBBPool.wrapBB(ByteBuffer.allocateDirect(1024 * 1024 * 64)) });\n        } catch (IOException e) {\n            return;\n        }\n        fail();\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testTruncateFirstElement() throws Exception {\n        TreeSet<String> listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 1);\n\n        for (int ii = 0; ii < 96; ii++) {\n            m_pbd.offer(new BBContainer[] { DBBPool.wrapBB(getFilledBuffer(ii)) });\n        }\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 4);\n\n        m_pbd.close();\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 4);\n\n        m_pbd = new PersistentBinaryDeque( TEST_NONCE, TEST_DIR );\n\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 5);\n\n        m_pbd.parseAndTruncate(new BinaryDequeTruncator() {\n            @Override\n            public ByteBuffer parse(ByteBuffer b) {\n                return ByteBuffer.allocate(0);\n            }\n\n        });\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 1);\n        assertNull(m_pbd.poll());\n    }","id":26102,"modified_method":"@Test\n    public void testTruncateFirstElement() throws Exception {\n        TreeSet<String> listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 1);\n\n        for (int ii = 0; ii < 150; ii++) {\n            m_pbd.offer( DBBPool.wrapBB(getFilledBuffer(ii)) );\n        }\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 4);\n\n        m_pbd.close();\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 4);\n\n        m_pbd = new PersistentBinaryDeque( TEST_NONCE, TEST_DIR );\n\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 5);\n\n        m_pbd.parseAndTruncate(new BinaryDequeTruncator() {\n            @Override\n            public ByteBuffer parse(ByteBuffer b) {\n                return ByteBuffer.allocate(0);\n            }\n\n        });\n\n        listing = getSortedDirectoryListing();\n        assertEquals(listing.size(), 1);\n        assertNull(m_pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY));\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testOfferThenPushThenPoll() throws Exception {\n        assertTrue(m_pbd.isEmpty());\n        //Make it create two full segments\n        for (int ii = 0; ii < 64; ii++) {\n            defaultBuffer.clear();\n            m_pbd.offer(defaultContainer);\n            assertFalse(m_pbd.isEmpty());\n        }\n        assertEquals(((1024 * 1024 * 2) + 4) * 64, m_pbd.sizeInBytes());\n        File files[] = TEST_DIR.listFiles();\n        assertEquals( 3, files.length);\n\n        //Now create two buffers with different data to push at the front\n        final ByteBuffer buffer1 = getFilledBuffer(16);\n        final ByteBuffer buffer2 = getFilledBuffer(32);\n        BBContainer pushContainers[][] = new BBContainer[2][];\n        pushContainers[0] = new BBContainer[] { DBBPool.wrapBB(buffer1) };\n        pushContainers[1] = new BBContainer[] { DBBPool.wrapBB(buffer2) };\n\n        m_pbd.push(pushContainers);\n\n        //Expect this to create a single new file\n        TreeSet<String> names = getSortedDirectoryListing();\n        assertEquals( 4, names.size());\n        assertTrue(names.first().equals(\"pbd_nonce.-1.pbd\"));\n        assertTrue(names.contains(\"pbd_nonce.0.pbd\"));\n        assertTrue(names.contains(\"pbd_nonce.1.pbd\"));\n        assertTrue(names.last().equals(\"pbd_nonce.2.pbd\"));\n\n        //Poll the two at the front and check that the contents are what is expected\n        BBContainer retval1 = m_pbd.poll();\n        buffer1.clear();\n        assert(retval1.b.equals(buffer1));\n\n\n        BBContainer retval2 = m_pbd.poll();\n        buffer2.clear();\n        assertTrue(retval2.b.equals(buffer2));\n\n        //Expect the file for the two polled objects to still be there\n        //until the discard\n        names = getSortedDirectoryListing();\n        assertEquals( 4, names.size());\n\n        assertEquals(((1024 * 1024 * 2) + 4) * 66, m_pbd.sizeInBytes());\n\n        retval1.discard();\n        assertEquals(((1024 * 1024 * 2) + 4) * 66, m_pbd.sizeInBytes());\n        retval2.discard();\n\n        assertEquals(((1024 * 1024 * 2) + 4) * 64, m_pbd.sizeInBytes());\n\n        names = getSortedDirectoryListing();\n        assertEquals( 3, names.size());\n        assertTrue(names.first().equals(\"pbd_nonce.0.pbd\"));\n\n        //Now poll the rest and make sure the data is correct\n        for (int ii = 0; ii < 64; ii++) {\n            defaultBuffer.clear();\n            BBContainer retval = m_pbd.poll();\n            assertTrue(defaultBuffer.equals(retval.b));\n            retval.discard();\n        }\n\n        assertEquals( 0, m_pbd.sizeInBytes());\n        assertTrue(m_pbd.isEmpty());\n\n        //Expect just the current write segment\n        names = getSortedDirectoryListing();\n        assertEquals( 1, names.size());\n        assertTrue(names.first().equals(\"pbd_nonce.3.pbd\"));\n    }","id":26103,"modified_method":"@Test\n    public void testOfferThenPushThenPoll() throws Exception {\n        assertTrue(m_pbd.isEmpty());\n        //Make it create two full segments\n        for (int ii = 0; ii < 96; ii++) {\n            defaultBuffer.clear();\n            m_pbd.offer(defaultContainer);\n            assertFalse(m_pbd.isEmpty());\n        }\n        //Compression results in a weird magic number\n        assertEquals( 134393970, m_pbd.sizeInBytes());\n        File files[] = TEST_DIR.listFiles();\n        assertEquals( 3, files.length);\n\n        //Now create two buffers with different data to push at the front\n        final ByteBuffer buffer1 = getFilledBuffer(16);\n        final ByteBuffer buffer2 = getFilledBuffer(32);\n        BBContainer pushContainers[] = new BBContainer[2];\n        pushContainers[0] = DBBPool.wrapBB(buffer1);\n        pushContainers[1] = DBBPool.wrapBB(buffer2);\n\n        m_pbd.push(pushContainers);\n        assertEquals( 138588290, m_pbd.sizeInBytes());\n\n        //Expect this to create a single new file\n        TreeSet<String> names = getSortedDirectoryListing();\n        assertEquals( 4, names.size());\n        assertTrue(names.first().equals(\"pbd_nonce.-1.pbd\"));\n        assertTrue(names.contains(\"pbd_nonce.0.pbd\"));\n        assertTrue(names.contains(\"pbd_nonce.1.pbd\"));\n        assertTrue(names.last().equals(\"pbd_nonce.2.pbd\"));\n\n        //Poll the two at the front and check that the contents are what is expected\n        BBContainer retval1 = m_pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY);\n        buffer1.clear();\n        assert(retval1.b.equals(buffer1));\n        assertEquals(136491130, m_pbd.sizeInBytes());\n\n        BBContainer retval2 = m_pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY);\n        buffer2.clear();\n        assertTrue(retval2.b.equals(buffer2));\n        assertEquals(134393970, m_pbd.sizeInBytes());\n\n\n        //Expect the file for the two polled objects to still be there\n        //until the discard\n        names = getSortedDirectoryListing();\n        assertEquals( 4, names.size());\n        retval1.discard();\n        retval2.discard();\n\n        assertEquals(134393970, m_pbd.sizeInBytes());\n\n        names = getSortedDirectoryListing();\n        assertEquals( 3, names.size());\n        assertTrue(names.first().equals(\"pbd_nonce.0.pbd\"));\n\n        //Now poll the rest and make sure the data is correct\n        for (int ii = 0; ii < 96; ii++) {\n            defaultBuffer.clear();\n            BBContainer retval = m_pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY);\n            assertTrue(defaultBuffer.equals(retval.b));\n            retval.discard();\n        }\n\n        assertEquals( 0, m_pbd.sizeInBytes());\n        assertTrue(m_pbd.isEmpty());\n\n        //Expect just the current write segment\n        names = getSortedDirectoryListing();\n        assertEquals( 1, names.size());\n        assertTrue(names.first().equals(\"pbd_nonce.2.pbd\"));\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testMissingSegment() throws Exception {\n        for (int ii = 0; ii < 10; ii++) {\n            m_pbd.offer(new BBContainer[] { DBBPool.wrapBB(ByteBuffer.allocate(20)) });\n            m_pbd.poll();\n        }\n        m_pbd.close();\n        File toDelete = new File(TEST_DIR + File.separator + TEST_NONCE + \".4.pbd\");\n        assertTrue(toDelete.exists());\n        assertTrue(toDelete.delete());\n        try {\n            m_pbd = new PersistentBinaryDeque( TEST_NONCE, TEST_DIR);\n        } catch (IOException e) {\n            return;\n        }\n        fail();\n    }","id":26104,"modified_method":"@Test\n    public void testMissingSegment() throws Exception {\n        for (int ii = 0; ii < 256; ii++) {\n            m_pbd.offer(DBBPool.wrapBB(getFilledBuffer(64)) );\n        }\n        m_pbd.close();\n        File toDelete = new File(TEST_DIR + File.separator + TEST_NONCE + \".4.pbd\");\n        assertTrue(toDelete.exists());\n        assertTrue(toDelete.delete());\n        try {\n            m_pbd = new PersistentBinaryDeque( TEST_NONCE, TEST_DIR);\n        } catch (IOException e) {\n            return;\n        }\n        fail();\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testOfferMaxSize() throws Exception {\n        try {\n            m_pbd.offer(new BBContainer[] { DBBPool.wrapBB(ByteBuffer.allocateDirect(1024 * 1024 * 64)) });\n        } catch (IOException e) {\n            return;\n        }\n        fail();\n    }","id":26105,"modified_method":"@Test\n    public void testOfferMaxSize() throws Exception {\n        try {\n            m_pbd.offer( DBBPool.wrapBB(ByteBuffer.allocateDirect(1024 * 1024 * 64)) );\n        } catch (IOException e) {\n            return;\n        }\n        fail();\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testOfferCloseThenReopen() throws Exception {\n        //Make it create two full segments\n        for (int ii = 0; ii < 64; ii++) {\n            defaultBuffer.clear();\n            m_pbd.offer(defaultContainer);\n        }\n        File files[] = TEST_DIR.listFiles();\n        assertEquals( 3, files.length);\n\n        m_pbd.sync();\n        m_pbd.close();\n\n        m_pbd = new PersistentBinaryDeque( TEST_NONCE, TEST_DIR );\n\n        //Now poll all of it and make sure the data is correct\n        for (int ii = 0; ii < 64; ii++) {\n            defaultBuffer.clear();\n            BBContainer retval = m_pbd.poll();\n            assertTrue(defaultBuffer.equals(retval.b));\n            retval.discard();\n        }\n\n        //Expect just the current write segment\n        TreeSet<String> names = getSortedDirectoryListing();\n        assertEquals( 1, names.size());\n        assertTrue(names.first().equals(\"pbd_nonce.3.pbd\"));\n    }","id":26106,"modified_method":"@Test\n    public void testOfferCloseThenReopen() throws Exception {\n        //Make it create two full segments\n        for (int ii = 0; ii < 96; ii++) {\n            defaultBuffer.clear();\n            m_pbd.offer(defaultContainer);\n        }\n        File files[] = TEST_DIR.listFiles();\n        assertEquals( 3, files.length);\n\n        m_pbd.sync();\n        m_pbd.close();\n\n        m_pbd = new PersistentBinaryDeque( TEST_NONCE, TEST_DIR );\n\n        //Now poll all of it and make sure the data is correct\n        for (int ii = 0; ii < 96; ii++) {\n            defaultBuffer.clear();\n            BBContainer retval = m_pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY);\n            assertTrue(defaultBuffer.equals(retval.b));\n            retval.discard();\n        }\n\n        //Expect just the current write segment\n        TreeSet<String> names = getSortedDirectoryListing();\n        assertEquals( 1, names.size());\n        assertTrue(names.first().equals(\"pbd_nonce.3.pbd\"));\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testPushFailsWhenClosed() throws Exception {\n        m_pbd.close();\n        try {\n            m_pbd.push(new BBContainer[][] { new BBContainer[] { DBBPool.wrapBB(ByteBuffer.allocate(20)) } });\n        } catch (IOException e) {\n            return;\n        }\n        fail();\n    }","id":26107,"modified_method":"@Test\n    public void testPushFailsWhenClosed() throws Exception {\n        m_pbd.close();\n        try {\n            m_pbd.push(new BBContainer[] { DBBPool.wrapBB(ByteBuffer.allocate(20)) });\n        } catch (IOException e) {\n            return;\n        }\n        fail();\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void testPollWhileClosed() throws Exception {\n        m_pbd.close();\n        try {\n            m_pbd.poll();\n        } catch (IOException e) {\n            return;\n        }\n        fail();\n    }","id":26108,"modified_method":"@Test\n    public void testPollWhileClosed() throws Exception {\n        m_pbd.close();\n        try {\n            m_pbd.poll(PersistentBinaryDeque.UNSAFE_CONTAINER_FACTORY);\n        } catch (IOException e) {\n            return;\n        }\n        fail();\n    }","commit_id":"bcf74174dd9dc647f128f19d9dc99ca5d42c44a2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void login(\n\t\t\tHttpServletRequest req, HttpServletResponse res, String login,\n\t\t\tString password, boolean rememberMe)\n\t\tthrows Exception {\n\n\t\tCookieKeys.validateSupportCookie(req);\n\n\t\tHttpSession ses = req.getSession();\n\n\t\tlong userId = GetterUtil.getLong(login);\n\n\t\tint authResult = Authenticator.FAILURE;\n\n\t\tCompany company = PortalUtil.getCompany(req);\n\n\t\tMap headerMap = new HashMap();\n\n\t\tEnumeration enu1 = req.getHeaderNames();\n\n\t\twhile (enu1.hasMoreElements()) {\n\t\t\tString name = (String)enu1.nextElement();\n\n\t\t\tEnumeration enu2 = req.getHeaders(name);\n\n\t\t\tList headers = new ArrayList();\n\n\t\t\twhile (enu2.hasMoreElements()) {\n\t\t\t\tString value = (String)enu2.nextElement();\n\n\t\t\t\theaders.add(value);\n\t\t\t}\n\n\t\t\theaderMap.put(name, (String[])headers.toArray(new String[0]));\n\t\t}\n\n\t\tMap parameterMap = req.getParameterMap();\n\n\t\tif (company.getAuthType().equals(CompanyImpl.AUTH_TYPE_EA)) {\n\t\t\tauthResult = UserLocalServiceUtil.authenticateByEmailAddress(\n\t\t\t\tcompany.getCompanyId(), login, password, headerMap,\n\t\t\t\tparameterMap);\n\n\t\t\tuserId = UserLocalServiceUtil.getUserIdByEmailAddress(\n\t\t\t\tcompany.getCompanyId(), login);\n\t\t}\n\t\telse if (company.getAuthType().equals(CompanyImpl.AUTH_TYPE_SN)) {\n\t\t\tauthResult = UserLocalServiceUtil.authenticateByScreenName(\n\t\t\t\tcompany.getCompanyId(), login, password, headerMap,\n\t\t\t\tparameterMap);\n\n\t\t\tuserId = UserLocalServiceUtil.getUserIdByScreenName(\n\t\t\t\tcompany.getCompanyId(), login);\n\t\t}\n\t\telse if (company.getAuthType().equals(CompanyImpl.AUTH_TYPE_ID)) {\n\t\t\tauthResult = UserLocalServiceUtil.authenticateByUserId(\n\t\t\t\tcompany.getCompanyId(), userId, password, headerMap,\n\t\t\t\tparameterMap);\n\t\t}\n\n\t\tif (authResult == Authenticator.SUCCESS) {\n\t\t\tif (PropsValues.SESSION_ENABLE_PHISHING_PROTECTION) {\n\n\t\t\t\t// Invalidate the previous session to prevent phishing\n\n\t\t\t\tBoolean httpsInitial = (Boolean)ses.getAttribute(\n\t\t\t\t\tWebKeys.HTTPS_INITIAL);\n\n\t\t\t\tLastPath lastPath = (LastPath)ses.getAttribute(\n\t\t\t\t\tWebKeys.LAST_PATH);\n\n\t\t\t\ttry {\n\t\t\t\t\tses.invalidate();\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ise) {\n\n\t\t\t\t\t// This only happens in Geronimo\n\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(ise.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tses = req.getSession(true);\n\n\t\t\t\tif (httpsInitial != null) {\n\t\t\t\t\tses.setAttribute(WebKeys.HTTPS_INITIAL, httpsInitial);\n\t\t\t\t}\n\n\t\t\t\tif (lastPath != null) {\n\t\t\t\t\tses.setAttribute(WebKeys.LAST_PATH, lastPath);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set cookies\n\n\t\t\tString domain = PropsValues.SESSION_COOKIE_DOMAIN;\n\n\t\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\n\t\t\tString userIdString = String.valueOf(userId);\n\n\t\t\tses.setAttribute(\"j_username\", userIdString);\n\t\t\tses.setAttribute(\"j_password\", user.getPassword());\n\t\t\tses.setAttribute(\"j_remoteuser\", userIdString);\n\n\t\t\tses.setAttribute(WebKeys.USER_PASSWORD, password);\n\n\t\t\tCookie idCookie = new Cookie(\n\t\t\t\tCookieKeys.ID,\n\t\t\t\tUserLocalServiceUtil.encryptUserId(userIdString));\n\n\t\t\tif (Validator.isNotNull(PropsValues.SESSION_COOKIE_DOMAIN)) {\n\t\t\t\tidCookie.setDomain(PropsValues.SESSION_COOKIE_DOMAIN);\n\t\t\t}\n\n\t\t\tidCookie.setPath(StringPool.SLASH);\n\n\t\t\tCookie passwordCookie = new Cookie(\n\t\t\t\tCookieKeys.PASSWORD,\n\t\t\t\tEncryptor.encrypt(company.getKeyObj(), password));\n\n\t\t\tif (Validator.isNotNull(domain)) {\n\t\t\t\tpasswordCookie.setDomain(domain);\n\t\t\t}\n\n\t\t\tpasswordCookie.setPath(StringPool.SLASH);\n\n\t\t\tint loginMaxAge = PropsValues.COMPANY_SECURITY_AUTO_LOGIN_MAX_AGE;\n\n\t\t\tif (PropsValues.SESSION_DISABLED) {\n\t\t\t\trememberMe = true;\n\t\t\t}\n\n\t\t\tif (rememberMe) {\n\t\t\t\tidCookie.setMaxAge(loginMaxAge);\n\t\t\t\tpasswordCookie.setMaxAge(loginMaxAge);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tidCookie.setMaxAge(0);\n\t\t\t\tpasswordCookie.setMaxAge(0);\n\t\t\t}\n\n\t\t\tCookie loginCookie = new Cookie(CookieKeys.LOGIN, login);\n\n\t\t\tif (Validator.isNotNull(domain)) {\n\t\t\t\tloginCookie.setDomain(domain);\n\t\t\t}\n\n\t\t\tloginCookie.setPath(StringPool.SLASH);\n\t\t\tloginCookie.setMaxAge(loginMaxAge);\n\n\t\t\tCookie screenNameCookie = new Cookie(\n\t\t\t\tCookieKeys.SCREEN_NAME,\n\t\t\t\tEncryptor.encrypt(company.getKeyObj(), user.getScreenName()));\n\n\t\t\tif (Validator.isNotNull(domain)) {\n\t\t\t\tscreenNameCookie.setDomain(domain);\n\t\t\t}\n\n\t\t\tscreenNameCookie.setPath(StringPool.SLASH);\n\t\t\tscreenNameCookie.setMaxAge(loginMaxAge);\n\n\t\t\tCookieKeys.addCookie(res, idCookie);\n\t\t\tCookieKeys.addCookie(res, passwordCookie);\n\t\t\tCookieKeys.addCookie(res, loginCookie);\n\t\t\tCookieKeys.addCookie(res, screenNameCookie);\n\t\t}\n\t\telse {\n\t\t\tthrow new AuthException();\n\t\t}\n\t}","id":26109,"modified_method":"public static void login(\n\t\t\tHttpServletRequest req, HttpServletResponse res, String login,\n\t\t\tString password, boolean rememberMe)\n\t\tthrows Exception {\n\n\t\tCookieKeys.validateSupportCookie(req);\n\n\t\tHttpSession ses = req.getSession();\n\n\t\tlong userId = GetterUtil.getLong(login);\n\n\t\tint authResult = Authenticator.FAILURE;\n\n\t\tCompany company = PortalUtil.getCompany(req);\n\n\t\tMap headerMap = new HashMap();\n\n\t\tEnumeration enu1 = req.getHeaderNames();\n\n\t\twhile (enu1.hasMoreElements()) {\n\t\t\tString name = (String)enu1.nextElement();\n\n\t\t\tEnumeration enu2 = req.getHeaders(name);\n\n\t\t\tList headers = new ArrayList();\n\n\t\t\twhile (enu2.hasMoreElements()) {\n\t\t\t\tString value = (String)enu2.nextElement();\n\n\t\t\t\theaders.add(value);\n\t\t\t}\n\n\t\t\theaderMap.put(name, (String[])headers.toArray(new String[0]));\n\t\t}\n\n\t\tMap parameterMap = req.getParameterMap();\n\n\t\tif (company.getAuthType().equals(CompanyImpl.AUTH_TYPE_EA)) {\n\t\t\tauthResult = UserLocalServiceUtil.authenticateByEmailAddress(\n\t\t\t\tcompany.getCompanyId(), login, password, headerMap,\n\t\t\t\tparameterMap);\n\n\t\t\tuserId = UserLocalServiceUtil.getUserIdByEmailAddress(\n\t\t\t\tcompany.getCompanyId(), login);\n\t\t}\n\t\telse if (company.getAuthType().equals(CompanyImpl.AUTH_TYPE_SN)) {\n\t\t\tauthResult = UserLocalServiceUtil.authenticateByScreenName(\n\t\t\t\tcompany.getCompanyId(), login, password, headerMap,\n\t\t\t\tparameterMap);\n\n\t\t\tuserId = UserLocalServiceUtil.getUserIdByScreenName(\n\t\t\t\tcompany.getCompanyId(), login);\n\t\t}\n\t\telse if (company.getAuthType().equals(CompanyImpl.AUTH_TYPE_ID)) {\n\t\t\tauthResult = UserLocalServiceUtil.authenticateByUserId(\n\t\t\t\tcompany.getCompanyId(), userId, password, headerMap,\n\t\t\t\tparameterMap);\n\t\t}\n\n\t\tif (authResult == Authenticator.SUCCESS) {\n\t\t\tif (PropsValues.SESSION_ENABLE_PHISHING_PROTECTION) {\n\n\t\t\t\t// Invalidate the previous session to prevent phishing\n\n\t\t\t\tBoolean httpsInitial = (Boolean)ses.getAttribute(\n\t\t\t\t\tWebKeys.HTTPS_INITIAL);\n\n\t\t\t\tLastPath lastPath = (LastPath)ses.getAttribute(\n\t\t\t\t\tWebKeys.LAST_PATH);\n\n\t\t\t\ttry {\n\t\t\t\t\tses.invalidate();\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ise) {\n\n\t\t\t\t\t// This only happens in Geronimo\n\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(ise.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tses = req.getSession(true);\n\n\t\t\t\tif (httpsInitial != null) {\n\t\t\t\t\tses.setAttribute(WebKeys.HTTPS_INITIAL, httpsInitial);\n\t\t\t\t}\n\n\t\t\t\tif (lastPath != null) {\n\t\t\t\t\tses.setAttribute(WebKeys.LAST_PATH, lastPath);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set cookies\n\n\t\t\tString domain = CookieKeys.getDomain(req);\n\n\t\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\n\t\t\tString userIdString = String.valueOf(userId);\n\n\t\t\tses.setAttribute(\"j_username\", userIdString);\n\t\t\tses.setAttribute(\"j_password\", user.getPassword());\n\t\t\tses.setAttribute(\"j_remoteuser\", userIdString);\n\n\t\t\tses.setAttribute(WebKeys.USER_PASSWORD, password);\n\n\t\t\tCookie idCookie = new Cookie(\n\t\t\t\tCookieKeys.ID,\n\t\t\t\tUserLocalServiceUtil.encryptUserId(userIdString));\n\n\t\t\tif (Validator.isNotNull(domain)) {\n\t\t\t\tidCookie.setDomain(domain);\n\t\t\t}\n\n\t\t\tidCookie.setPath(StringPool.SLASH);\n\n\t\t\tCookie passwordCookie = new Cookie(\n\t\t\t\tCookieKeys.PASSWORD,\n\t\t\t\tEncryptor.encrypt(company.getKeyObj(), password));\n\n\t\t\tif (Validator.isNotNull(domain)) {\n\t\t\t\tpasswordCookie.setDomain(domain);\n\t\t\t}\n\n\t\t\tpasswordCookie.setPath(StringPool.SLASH);\n\n\t\t\tint loginMaxAge = PropsValues.COMPANY_SECURITY_AUTO_LOGIN_MAX_AGE;\n\n\t\t\tif (PropsValues.SESSION_DISABLED) {\n\t\t\t\trememberMe = true;\n\t\t\t}\n\n\t\t\tif (rememberMe) {\n\t\t\t\tidCookie.setMaxAge(loginMaxAge);\n\t\t\t\tpasswordCookie.setMaxAge(loginMaxAge);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tidCookie.setMaxAge(0);\n\t\t\t\tpasswordCookie.setMaxAge(0);\n\t\t\t}\n\n\t\t\tCookie loginCookie = new Cookie(CookieKeys.LOGIN, login);\n\n\t\t\tif (Validator.isNotNull(domain)) {\n\t\t\t\tloginCookie.setDomain(domain);\n\t\t\t}\n\n\t\t\tloginCookie.setMaxAge(loginMaxAge);\n\t\t\tloginCookie.setPath(StringPool.SLASH);\n\n\t\t\tCookie screenNameCookie = new Cookie(\n\t\t\t\tCookieKeys.SCREEN_NAME,\n\t\t\t\tEncryptor.encrypt(company.getKeyObj(), user.getScreenName()));\n\n\t\t\tif (Validator.isNotNull(domain)) {\n\t\t\t\tscreenNameCookie.setDomain(domain);\n\t\t\t}\n\n\t\t\tscreenNameCookie.setMaxAge(loginMaxAge);\n\t\t\tscreenNameCookie.setPath(StringPool.SLASH);\n\n\t\t\tCookieKeys.addCookie(res, idCookie);\n\t\t\tCookieKeys.addCookie(res, passwordCookie);\n\t\t\tCookieKeys.addCookie(res, loginCookie);\n\t\t\tCookieKeys.addCookie(res, screenNameCookie);\n\t\t}\n\t\telse {\n\t\t\tthrow new AuthException();\n\t\t}\n\t}","commit_id":"63879b619c0b69954667c22d3213ef93cdf040c9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest req,\n\t\t\tHttpServletResponse res)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tHttpSession ses = req.getSession();\n\n\t\t\tEventsProcessor.process(PropsUtil.getArray(\n\t\t\t\tPropsUtil.LOGOUT_EVENTS_PRE), req, res);\n\n\t\t\tCookie cookie = new Cookie(CookieKeys.ID, StringPool.BLANK);\n\n\t\t\tcookie.setMaxAge(0);\n\t\t\tcookie.setPath(StringPool.SLASH);\n\n\t\t\tCookieKeys.addCookie(res, cookie);\n\n\t\t\tcookie = new Cookie(CookieKeys.PASSWORD, StringPool.BLANK);\n\n\t\t\tcookie.setMaxAge(0);\n\t\t\tcookie.setPath(StringPool.SLASH);\n\n\t\t\tCookieKeys.addCookie(res, cookie);\n\n\t\t\ttry {\n\t\t\t\tses.invalidate();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tEventsProcessor.process(PropsUtil.getArray(\n\t\t\t\tPropsUtil.LOGOUT_EVENTS_POST), req, res);\n\n\t\t\treturn mapping.findForward(ActionConstants.COMMON_REFERER);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treq.setAttribute(PageContext.EXCEPTION, e);\n\n\t\t\treturn mapping.findForward(ActionConstants.COMMON_ERROR);\n\t\t}\n\t}","id":26110,"modified_method":"public ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest req,\n\t\t\tHttpServletResponse res)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tHttpSession ses = req.getSession();\n\n\t\t\tEventsProcessor.process(PropsUtil.getArray(\n\t\t\t\tPropsUtil.LOGOUT_EVENTS_PRE), req, res);\n\n\t\t\tString domain = CookieKeys.getDomain(req);\n\n\t\t\tCookie idCookie = new Cookie(CookieKeys.ID, StringPool.BLANK);\n\n\t\t\tif (Validator.isNotNull(domain)) {\n\t\t\t\tidCookie.setDomain(domain);\n\t\t\t}\n\n\t\t\tidCookie.setMaxAge(0);\n\t\t\tidCookie.setPath(StringPool.SLASH);\n\n\t\t\tCookie passwordCookie = new Cookie(\n\t\t\t\tCookieKeys.PASSWORD, StringPool.BLANK);\n\n\t\t\tif (Validator.isNotNull(domain)) {\n\t\t\t\tpasswordCookie.setDomain(domain);\n\t\t\t}\n\n\t\t\tpasswordCookie.setMaxAge(0);\n\t\t\tpasswordCookie.setPath(StringPool.SLASH);\n\n\t\t\tCookieKeys.addCookie(res, idCookie);\n\t\t\tCookieKeys.addCookie(res, passwordCookie);\n\n\t\t\ttry {\n\t\t\t\tses.invalidate();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tEventsProcessor.process(PropsUtil.getArray(\n\t\t\t\tPropsUtil.LOGOUT_EVENTS_POST), req, res);\n\n\t\t\treturn mapping.findForward(ActionConstants.COMMON_REFERER);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treq.setAttribute(PageContext.EXCEPTION, e);\n\n\t\t\treturn mapping.findForward(ActionConstants.COMMON_ERROR);\n\t\t}\n\t}","commit_id":"63879b619c0b69954667c22d3213ef93cdf040c9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void apply(String taskName) {\n        if (!taskName.startsWith(PREFIX)) {\n            return;\n        }\n\n        String targetTaskName = taskName.substring(PREFIX.length());\n        if (Character.isLowerCase(targetTaskName.charAt(0))) {\n            return;\n        }\n\n        Task task = tasks.findByName(StringUtils.uncapitalize(targetTaskName));\n        if (task == null) {\n            return;\n        }\n\n        Delete clean = tasks.create(taskName, Delete.class);\n        clean.delete(task.getOutputs().getFiles());\n    }","id":26111,"modified_method":"public void apply(String taskName) {\n        if (!taskName.startsWith(PREFIX)) {\n            return;\n        }\n        if (taskName.equals(PREFIX)) {\n            return;\n        }\n        String targetTaskName = taskName.substring(PREFIX.length());\n        if (Character.isLowerCase(targetTaskName.charAt(0))) {\n            return;\n        }\n\n        Task task = tasks.findByName(StringUtils.uncapitalize(targetTaskName));\n        if (task == null) {\n            return;\n        }\n\n        Delete clean = tasks.create(taskName, Delete.class);\n        clean.delete(task.getOutputs().getFiles());\n    }","commit_id":"9a56608c6b0cd909a3165008be6f2771b10e5331","url":"https://github.com/gradle/gradle"},{"original_method":"private void addDeprecationWarningsAboutCustomLifecycleTasks(ProjectInternal project) {\n        project.getTasks().all(new Action<Task>() {\n            @Override\n            public void execute(Task task) {\n                if (task.getName().equals(BUILD_TASK_NAME)) {\n                    DeprecationLogger.nagUserOfDeprecated(String.format(CUSTOM_LIFECYCLE_TASK_DEPRECATION_MSG, BUILD_TASK_NAME));\n                }\n                if (task.getName().equals(CHECK_TASK_NAME)) {\n                    DeprecationLogger.nagUserOfDeprecated(String.format(CUSTOM_LIFECYCLE_TASK_DEPRECATION_MSG, CHECK_TASK_NAME));\n                }\n            }\n        });\n    }","id":26112,"modified_method":"private void addDeprecationWarningsAboutCustomLifecycleTasks(ProjectInternal project) {\n        project.getTasks().all(new Action<Task>() {\n            @Override\n            public void execute(Task task) {\n                if (task.getName().equals(BUILD_TASK_NAME)) {\n                    DeprecationLogger.nagUserOfDeprecated(String.format(CUSTOM_LIFECYCLE_TASK_DEPRECATION_MSG, BUILD_TASK_NAME));\n                }\n                if (task.getName().equals(CHECK_TASK_NAME)) {\n                    DeprecationLogger.nagUserOfDeprecated(String.format(CUSTOM_LIFECYCLE_TASK_DEPRECATION_MSG, CHECK_TASK_NAME));\n                }\n                if (task.getName().equals(CLEAN_TASK_NAME)) {\n                    DeprecationLogger.nagUserOfDeprecated(String.format(CUSTOM_LIFECYCLE_TASK_DEPRECATION_MSG, CLEAN_TASK_NAME));\n                }\n            }\n        });\n    }","commit_id":"9a56608c6b0cd909a3165008be6f2771b10e5331","url":"https://github.com/gradle/gradle"},{"original_method":"private void addClean(final Project project) {\n        Delete clean = project.getTasks().create(CLEAN_TASK_NAME, Delete.class);\n        clean.setDescription(\"Deletes the build directory.\");\n        clean.setGroup(BUILD_GROUP);\n        clean.delete(new Callable<File>() {\n            public File call() throws Exception {\n                return project.getBuildDir();\n            }\n        });\n    }","id":26113,"modified_method":"private void addClean(final ProjectInternal project) {\n        project.getTasks().addPlaceholderAction(CLEAN_TASK_NAME, Delete.class, new Action<Delete>() {\n            @Override\n            public void execute(Delete clean) {\n                clean.setDescription(\"Deletes the build directory.\");\n                clean.setGroup(VERIFICATION_GROUP);\n                clean.delete(new Callable<File>() {\n                    public File call() throws Exception {\n                        return project.getBuildDir();\n                    }\n                });\n            }\n        });\n    }","commit_id":"9a56608c6b0cd909a3165008be6f2771b10e5331","url":"https://github.com/gradle/gradle"},{"original_method":"private void addCheck(Project project) {\n        Task checkTask = project.getTasks().create(CHECK_TASK_NAME);\n        checkTask.setDescription(\"Runs all checks.\");\n        checkTask.setGroup(VERIFICATION_GROUP);\n    }","id":26114,"modified_method":"private void addCheck(ProjectInternal project) {\n        project.getTasks().addPlaceholderAction(CHECK_TASK_NAME, DefaultTask.class, new Action<DefaultTask>() {\n            @Override\n            public void execute(DefaultTask checkTask) {\n                checkTask.setDescription(\"Runs all checks.\");\n                checkTask.setGroup(VERIFICATION_GROUP);\n            }\n        });\n    }","commit_id":"a1a5a756d913612126cd3b2f2618de3300bc79dd","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(Project project) {\n        addClean(project);\n        addCleanRule(project);\n        addAssemble(project);\n        addCheck(project);\n        addBuild(project);\n    }","id":26115,"modified_method":"public void apply(ProjectInternal project) {\n        addClean(project);\n        addCleanRule(project);\n        addAssemble(project);\n        addCheck(project);\n        addBuild(project);\n    }","commit_id":"a1a5a756d913612126cd3b2f2618de3300bc79dd","url":"https://github.com/gradle/gradle"},{"original_method":"private void addBuild(Project project) {\n        DefaultTask buildTask = project.getTasks().create(BUILD_TASK_NAME, DefaultTask.class);\n        buildTask.setDescription(\"Assembles and tests this project.\");\n        buildTask.setGroup(BUILD_GROUP);\n        buildTask.dependsOn(ASSEMBLE_TASK_NAME);\n        buildTask.dependsOn(CHECK_TASK_NAME);\n    }","id":26116,"modified_method":"private void addBuild(ProjectInternal project) {\n        project.getTasks().addPlaceholderAction(BUILD_TASK_NAME, DefaultTask.class, new Action<DefaultTask>() {\n            @Override\n            public void execute(DefaultTask buildTask) {\n                buildTask.setDescription(\"Assembles and tests this project.\");\n                buildTask.setGroup(BUILD_GROUP);\n                buildTask.dependsOn(ASSEMBLE_TASK_NAME);\n                buildTask.dependsOn(CHECK_TASK_NAME);\n            }\n        });\n    }","commit_id":"a1a5a756d913612126cd3b2f2618de3300bc79dd","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(Project project) {\n        project.getPluginManager().apply(LifecycleBasePlugin.class);\n\n        BasePluginConvention convention = new BasePluginConvention(project);\n        project.getConvention().getPlugins().put(\"base\", convention);\n\n        configureBuildConfigurationRule(project);\n        configureUploadRules(project);\n        configureUploadArchivesTask();\n        configureArchiveDefaults(project, convention);\n        configureConfigurations(project);\n        configureAssemble(project);\n    }","id":26117,"modified_method":"public void apply(Project project) {\n        project.getPluginManager().apply(LifecycleBasePlugin.class);\n\n        BasePluginConvention convention = new BasePluginConvention(project);\n        project.getConvention().getPlugins().put(\"base\", convention);\n\n        configureBuildConfigurationRule(project);\n        configureUploadRules(project);\n        configureUploadArchivesTask();\n        configureArchiveDefaults(project, convention);\n        configureConfigurations(project);\n        configureAssemble((ProjectInternal) project);\n    }","commit_id":"15abedd96b043edba62a49ee245d9a115e3015ff","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureAssemble(Project project) {\n        Task assembleTask = project.getTasks().getByName(ASSEMBLE_TASK_NAME);\n        assembleTask.dependsOn(project.getConfigurations().getByName(Dependency.ARCHIVES_CONFIGURATION).getAllArtifacts().getBuildDependencies());\n    }","id":26118,"modified_method":"private void configureAssemble(final ProjectInternal project) {\n        // Note, this is implicitly retaining the project instance which is a problem for reuse\n        project.getModelRegistry().configure(ModelActionRole.Mutate, ActionBackedModelAction.of(ModelReference.of(\"tasks.assemble\", Task.class), new SimpleModelRuleDescriptor(\"BasePlugin#configureAssemble\"), new Action<Task>() {\n            @Override\n            public void execute(Task task) {\n                task.dependsOn(project.getConfigurations().getByName(Dependency.ARCHIVES_CONFIGURATION).getAllArtifacts().getBuildDependencies());\n            }\n        }));\n    }","commit_id":"15abedd96b043edba62a49ee245d9a115e3015ff","url":"https://github.com/gradle/gradle"},{"original_method":"private void addAssemble(Project project) {\n        Task assembleTask = project.getTasks().create(ASSEMBLE_TASK_NAME, AssembleBinariesTask.class);\n        assembleTask.setDescription(\"Assembles the outputs of this project.\");\n        assembleTask.setGroup(BUILD_GROUP);\n    }","id":26119,"modified_method":"private void addAssemble(ProjectInternal project) {\n        project.getTasks().addPlaceholderAction(ASSEMBLE_TASK_NAME, AssembleBinariesTask.class, new Action<TaskInternal>() {\n            @Override\n            public void execute(TaskInternal assembleTask) {\n                assembleTask.setDescription(\"Assembles the outputs of this project.\");\n                assembleTask.setGroup(BUILD_GROUP);\n            }\n        });\n    }","commit_id":"15abedd96b043edba62a49ee245d9a115e3015ff","url":"https://github.com/gradle/gradle"},{"original_method":"private void addDeprecationWarningsAboutCustomLifecycleTasks(ProjectInternal project) {\n        project.getTasks().all(new Action<Task>() {\n            @Override\n            public void execute(Task task) {\n                if (task.getName().equals(BUILD_TASK_NAME)) {\n                    DeprecationLogger.nagUserOfDeprecated(String.format(CUSTOM_LIFECYCLE_TASK_DEPRECATION_MSG, BUILD_TASK_NAME));\n                }\n                if (task.getName().equals(CHECK_TASK_NAME)) {\n                    DeprecationLogger.nagUserOfDeprecated(String.format(CUSTOM_LIFECYCLE_TASK_DEPRECATION_MSG, CHECK_TASK_NAME));\n                }\n                if (task.getName().equals(CLEAN_TASK_NAME)) {\n                    DeprecationLogger.nagUserOfDeprecated(String.format(CUSTOM_LIFECYCLE_TASK_DEPRECATION_MSG, CLEAN_TASK_NAME));\n                }\n            }\n        });\n    }","id":26120,"modified_method":"private void addDeprecationWarningsAboutCustomLifecycleTasks(ProjectInternal project) {\n        project.getTasks().all(new Action<Task>() {\n            @Override\n            public void execute(Task task) {\n                if (PLACEHOLDER_TASKS.contains(task.getName())) {\n                    DeprecationLogger.nagUserOfDeprecated(String.format(CUSTOM_LIFECYCLE_TASK_DEPRECATION_MSG, task.getName()));\n                }\n            }\n        });\n    }","commit_id":"15abedd96b043edba62a49ee245d9a115e3015ff","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(Project project) {\n        addClean(project);\n        addCleanRule(project);\n        addAssemble(project);\n        addCheck(project);\n        addBuild(project);\n    }","id":26121,"modified_method":"public void apply(ProjectInternal project) {\n        addClean(project);\n        addCleanRule(project);\n        addAssemble(project);\n        addCheck(project);\n        addBuild(project);\n    }","commit_id":"71be0aad6f1e10a87150b335df6eca237c2c7acc","url":"https://github.com/gradle/gradle"},{"original_method":"private void addCheck(Project project) {\n        Task checkTask = project.getTasks().create(CHECK_TASK_NAME);\n        checkTask.setDescription(\"Runs all checks.\");\n        checkTask.setGroup(VERIFICATION_GROUP);\n    }","id":26122,"modified_method":"private void addCheck(ProjectInternal project) {\n        project.getTasks().addPlaceholderAction(CHECK_TASK_NAME, DefaultTask.class, new Action<DefaultTask>() {\n            @Override\n            public void execute(DefaultTask checkTask) {\n                checkTask.setDescription(\"Runs all checks.\");\n                checkTask.setGroup(VERIFICATION_GROUP);\n            }\n        });\n    }","commit_id":"71be0aad6f1e10a87150b335df6eca237c2c7acc","url":"https://github.com/gradle/gradle"},{"original_method":"private void addBuild(Project project) {\n        DefaultTask buildTask = project.getTasks().create(BUILD_TASK_NAME, DefaultTask.class);\n        buildTask.setDescription(\"Assembles and tests this project.\");\n        buildTask.setGroup(BUILD_GROUP);\n        buildTask.dependsOn(ASSEMBLE_TASK_NAME);\n        buildTask.dependsOn(CHECK_TASK_NAME);\n    }","id":26123,"modified_method":"private void addBuild(ProjectInternal project) {\n        project.getTasks().addPlaceholderAction(BUILD_TASK_NAME, DefaultTask.class, new Action<DefaultTask>() {\n            @Override\n            public void execute(DefaultTask buildTask) {\n                buildTask.setDescription(\"Assembles and tests this project.\");\n                buildTask.setGroup(BUILD_GROUP);\n                buildTask.dependsOn(ASSEMBLE_TASK_NAME);\n                buildTask.dependsOn(CHECK_TASK_NAME);\n            }\n        });\n    }","commit_id":"71be0aad6f1e10a87150b335df6eca237c2c7acc","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * @param locale\n     * @throws MavenReportException\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return;\n        }\n\n        List sourcePaths = getSourcePaths();\n\n        List files = getFiles( sourcePaths );\n\n        List packageNames = getPackageNames( sourcePaths, files );\n\n        List filesWithUnnamedPackages = getFilesWithUnnamedPackages( sourcePaths, files );\n\n        if ( !canGenerateReport( files ) )\n        {\n            return;\n        }\n\n        // ----------------------------------------------------------------------\n        // Find the javadoc executable and version\n        // ----------------------------------------------------------------------\n\n        String jExecutable;\n        try\n        {\n            jExecutable = getJavadocExecutable();\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc command: \" + e.getMessage(), e );\n        }\n\n        float jVersion;\n        try\n        {\n            jVersion = getJavadocVersion( new File( jExecutable ) );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc version: \" + e.getMessage(), e );\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc version: \" + e.getMessage(), e );\n        }\n        if ( StringUtils.isNotEmpty( javadocVersion ) )\n        {\n            try\n            {\n                fJavadocVersion = Float.parseFloat( javadocVersion );\n            }\n            catch ( NumberFormatException e )\n            {\n                throw new MavenReportException( \"Unable to parse javadoc version: \" + e.getMessage(), e );\n            }\n\n            if ( fJavadocVersion != jVersion )\n            {\n                getLog().warn( \"Are you sure about the <javadocVersion/> parameter? It seems to be \" + jVersion );\n            }\n        }\n        else\n        {\n            fJavadocVersion = jVersion;\n        }\n\n        File javadocOutputDirectory = new File( getOutputDirectory() );\n        javadocOutputDirectory.mkdirs();\n\n        // ----------------------------------------------------------------------\n        // Copy default resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyDefaultStylesheet( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy default stylesheet: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Copy javadoc resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyJavadocResources( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy javadoc resources: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc options\n        // ----------------------------------------------------------------------\n\n        StringBuffer options = new StringBuffer();\n        if ( StringUtils.isNotEmpty( this.locale ) )\n        {\n            options.append( \"-locale \" );\n            options.append( quotedArgument( this.locale ) );\n            options.append( \" \" );\n        }\n\n        String classpath = getClasspath();\n        if ( classpath.length() > 0 )\n        {\n            options.append( \"-classpath \" );\n            options.append( quotedPathArgument( classpath ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc arguments\n        // ----------------------------------------------------------------------\n\n        Commandline cmd = new Commandline();\n\n        // Set the proxy host and port\n        if ( StringUtils.isNotEmpty( proxyHost ) && proxyPort > 0 )\n        {\n            cmd.createArgument().setValue( \"-J-DproxyHost=\" + proxyHost );\n            cmd.createArgument().setValue( \"-J-DproxyPort=\" + proxyPort );\n        }\n\n        addMemoryArg( cmd, \"-Xmx\", this.maxmemory );\n\n        addMemoryArg( cmd, \"-Xms\", this.minmemory );\n\n        if ( StringUtils.isNotEmpty( additionalJOption ) )\n        {\n            cmd.createArgument().setValue( additionalJOption );\n        }\n\n        List arguments = new ArrayList();\n\n        cmd.setWorkingDirectory( javadocOutputDirectory.getAbsolutePath() );\n        cmd.setExecutable( jExecutable );\n\n        // General javadoc arguments\n        addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n        if ( StringUtils.isNotEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletpath\", quotedPathArgument( getDocletPath() ) );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", quotedPathArgument( extdirs ) );\n\n        if ( old && isJavaDocVersionAtLeast( SINCE_JAVADOC_1_4 ) )\n        {\n            getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        if ( ( StringUtils.isNotEmpty( overview ) ) && ( new File( overview ).exists() ) )\n        {\n            addArgIfNotEmpty( arguments, \"-overview\", quotedPathArgument( overview ) );\n        }\n        arguments.add( getAccessLevel() );\n        addArgIf( arguments, quiet, \"-quiet\", SINCE_JAVADOC_1_4 );\n        addArgIfNotEmpty( arguments, \"-source\", quotedArgument( source ), SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, null, additionalparam );\n\n        if ( ( StringUtils.isEmpty( sourcepath ) ) && ( StringUtils.isNotEmpty( subpackages ) ) )\n        {\n            sourcepath = StringUtils.join( sourcePaths.iterator(), File.pathSeparator );\n        }\n\n        addArgIfNotEmpty( arguments, \"-sourcepath\", quotedPathArgument( getSourcePath( sourcePaths ) ) );\n\n        if ( StringUtils.isNotEmpty( sourcepath ) )\n        {\n            addArgIfNotEmpty( arguments, \"-subpackages\", subpackages, SINCE_JAVADOC_1_4 );\n        }\n\n        addArgIfNotEmpty( arguments, \"-exclude\", getExcludedPackages( sourcePaths ), SINCE_JAVADOC_1_4 );\n\n        // ----------------------------------------------------------------------\n        // Wrap arguments for default doclet\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isEmpty( doclet ) )\n        {\n            addArgIf( arguments, author, \"-author\" );\n            addArgIfNotEmpty( arguments, \"-bottom\", quotedArgument( getBottomText( project.getInceptionYear() ) ),\n                              false, false );\n            addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-charset\", quotedArgument( charset ) );\n            addArgIfNotEmpty( arguments, \"-d\", quotedPathArgument( javadocOutputDirectory.toString() ) );\n            addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-docencoding\", quotedArgument( docencoding ) );\n            addArgIfNotEmpty( arguments, \"-doctitle\", quotedArgument( doctitle ), false, false );\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", quotedPathArgument( excludedocfilessubdir ),\n                              SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-footer\", quotedArgument( footer ), false, false );\n            if ( groups != null )\n            {\n                for ( int i = 0; i < groups.length; i++ )\n                {\n                    if ( groups[i] == null || StringUtils.isEmpty( groups[i].getTitle() )\n                        || StringUtils.isEmpty( groups[i].getPackages() ) )\n                    {\n                        getLog().info( \"A group option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String groupTitle = StringUtils.replace( groups[i].getTitle(), \",\", \"&#44;\" );\n                        addArgIfNotEmpty( arguments, \"-group\", quotedArgument( groupTitle ) + \" \"\n                            + quotedArgument( groups[i].getPackages() ), true );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-header\", quotedArgument( header ), false, false );\n            addArgIfNotEmpty( arguments, \"-helpfile\", quotedPathArgument( helpfile ) );\n            addArgIf( arguments, keywords, \"-keywords\", SINCE_JAVADOC_1_4_2 );\n\n            if ( !isOffline )\n            {\n                addLinkArguments( arguments );\n                addLinkofflineArguments( arguments );\n                addArgIf( arguments, linksource, \"-linksource\", SINCE_JAVADOC_1_4 );\n            }\n            else\n            {\n                addLinkofflineArguments( arguments );\n            }\n\n            addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n            addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n            addArgIf( arguments, nocomment, \"-nocomment\", SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nohelp, \"-nohelp\" );\n            addArgIf( arguments, noindex, \"-noindex\" );\n            addArgIf( arguments, nonavbar, \"-nonavbar\" );\n            addArgIfNotEmpty( arguments, \"-noqualifier\", quotedArgument( noqualifier ), SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nosince, \"-nosince\" );\n            addArgIf( arguments, notimestamp, \"-notimestamp\", SINCE_JAVADOC_1_5 );\n            addArgIf( arguments, notree, \"-notree\" );\n            addArgIfNotEmpty( arguments, \"-packagesheader\", packagesheader, SINCE_JAVADOC_1_4_2 );\n            addArgIf( arguments, serialwarn, \"-serialwarn\" );\n            addArgIfNotEmpty( arguments, \"-sourcetab\", sourcetab, SINCE_JAVADOC_1_5 );\n            addArgIf( arguments, splitindex, \"-splitindex\" );\n            addArgIfNotEmpty( arguments, \"-stylesheetfile\",\n                              quotedPathArgument( getStylesheetFile( javadocOutputDirectory ) ) );\n\n            addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglet ), SINCE_JAVADOC_1_4 );\n            if ( taglets != null )\n            {\n                for ( int i = 0; i < taglets.length; i++ )\n                {\n                    if ( ( taglets[i] == null ) || ( StringUtils.isEmpty( taglets[i].getTagletClass() ) ) )\n                    {\n                        getLog().info( \"A taglet option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglets[i].getTagletClass() ),\n                                          SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-tagletpath\", quotedPathArgument( getTagletPath() ), SINCE_JAVADOC_1_4 );\n\n            if ( tags != null )\n            {\n                for ( int i = 0; i < tags.length; i++ )\n                {\n                    if ( ( tags[i] == null ) || ( StringUtils.isEmpty( tags[i].getName() ) )\n                        || ( StringUtils.isEmpty( tags[i].getPlacement() ) ) )\n                    {\n                        getLog().info( \"A tag option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String value = \"\\\"\" + tags[i].getName() + \":\" + tags[i].getPlacement();\n                        if ( StringUtils.isNotEmpty( tags[i].getHead() ) )\n                        {\n                            value += \":\" + quotedArgument( tags[i].getHead() );\n                        }\n                        value += \"\\\"\";\n                        addArgIfNotEmpty( arguments, \"-tag\", value, SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n\n            addArgIf( arguments, use, \"-use\" );\n            addArgIf( arguments, version, \"-version\" );\n            addArgIfNotEmpty( arguments, \"-windowtitle\", quotedArgument( windowtitle ), false, false );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write options file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( options.length() > 0 )\n        {\n            addCommandLineOptions( cmd, options, arguments, javadocOutputDirectory );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write packages file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( !packageNames.isEmpty() )\n        {\n            addCommandLinePackages( cmd, javadocOutputDirectory, packageNames );\n\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !filesWithUnnamedPackages.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, filesWithUnnamedPackages );\n            }\n        }\n        else\n        {\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !files.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, files );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Execute command line\n        // ----------------------------------------------------------------------\n\n        getLog().debug( Commandline.toString( cmd.getCommandline() ) );\n\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + Commandline.toString( cmd.getCommandline() ) );\n                throw new MavenReportException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to execute javadoc command: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Handle Javadoc warnings\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( err.getOutput() ) )\n        {\n            getLog().info( \"Javadoc Warnings\" );\n\n            StringTokenizer token = new StringTokenizer( err.getOutput(), \"\\n\" );\n            while ( token.hasMoreTokens() )\n            {\n                String current = token.nextToken().trim();\n\n                getLog().warn( current );\n            }\n        }\n    }","id":26124,"modified_method":"/**\n     * @param locale\n     * @throws MavenReportException\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return;\n        }\n\n        List sourcePaths = getSourcePaths();\n\n        List files = getFiles( sourcePaths );\n\n        List packageNames = getPackageNames( sourcePaths, files );\n\n        List filesWithUnnamedPackages = getFilesWithUnnamedPackages( sourcePaths, files );\n\n        if ( !canGenerateReport( files ) )\n        {\n            return;\n        }\n\n        // ----------------------------------------------------------------------\n        // Find the javadoc executable and version\n        // ----------------------------------------------------------------------\n\n        String jExecutable;\n        try\n        {\n            jExecutable = getJavadocExecutable();\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc command: \" + e.getMessage(), e );\n        }\n\n        float jVersion;\n        try\n        {\n            jVersion = getJavadocVersion( new File( jExecutable ) );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc version: \" + e.getMessage(), e );\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc version: \" + e.getMessage(), e );\n        }\n        if ( StringUtils.isNotEmpty( javadocVersion ) )\n        {\n            try\n            {\n                fJavadocVersion = Float.parseFloat( javadocVersion );\n            }\n            catch ( NumberFormatException e )\n            {\n                throw new MavenReportException( \"Unable to parse javadoc version: \" + e.getMessage(), e );\n            }\n\n            if ( fJavadocVersion != jVersion )\n            {\n                getLog().warn( \"Are you sure about the <javadocVersion/> parameter? It seems to be \" + jVersion );\n            }\n        }\n        else\n        {\n            fJavadocVersion = jVersion;\n        }\n\n        File javadocOutputDirectory = new File( getOutputDirectory() );\n        javadocOutputDirectory.mkdirs();\n\n        // ----------------------------------------------------------------------\n        // Copy default resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyDefaultStylesheet( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy default stylesheet: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Copy javadoc resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyJavadocResources( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy javadoc resources: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc options\n        // ----------------------------------------------------------------------\n\n        StringBuffer options = new StringBuffer();\n        if ( StringUtils.isNotEmpty( this.locale ) )\n        {\n            options.append( \"-locale \" );\n            options.append( quotedArgument( this.locale ) );\n            options.append( \" \" );\n        }\n\n        String classpath = getClasspath();\n        if ( classpath.length() > 0 )\n        {\n            options.append( \"-classpath \" );\n            options.append( quotedPathArgument( classpath ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc arguments\n        // ----------------------------------------------------------------------\n\n        Commandline cmd = new Commandline();\n\n        // Set the proxy host and port\n        if ( StringUtils.isNotEmpty( proxyHost ) && proxyPort > 0 )\n        {\n            cmd.createArgument().setValue( \"-J-DproxyHost=\" + proxyHost );\n            cmd.createArgument().setValue( \"-J-DproxyPort=\" + proxyPort );\n        }\n\n        addMemoryArg( cmd, \"-Xmx\", this.maxmemory );\n\n        addMemoryArg( cmd, \"-Xms\", this.minmemory );\n\n        if ( StringUtils.isNotEmpty( additionalJOption ) )\n        {\n            cmd.createArgument().setValue( additionalJOption );\n        }\n\n        List arguments = new ArrayList();\n\n        cmd.setWorkingDirectory( javadocOutputDirectory.getAbsolutePath() );\n        cmd.setExecutable( jExecutable );\n\n        // General javadoc arguments\n        addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n        if ( StringUtils.isNotEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletpath\", quotedPathArgument( getDocletPath() ) );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", quotedPathArgument( extdirs ) );\n\n        if ( old && isJavaDocVersionAtLeast( SINCE_JAVADOC_1_4 ) )\n        {\n            getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        if ( ( StringUtils.isNotEmpty( overview ) ) && ( new File( overview ).exists() ) )\n        {\n            addArgIfNotEmpty( arguments, \"-overview\", quotedPathArgument( overview ) );\n        }\n        arguments.add( getAccessLevel() );\n        addArgIf( arguments, quiet, \"-quiet\", SINCE_JAVADOC_1_4 );\n        addArgIfNotEmpty( arguments, \"-source\", quotedArgument( source ), SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, null, additionalparam );\n\n        if ( ( StringUtils.isEmpty( sourcepath ) ) && ( StringUtils.isNotEmpty( subpackages ) ) )\n        {\n            sourcepath = StringUtils.join( sourcePaths.iterator(), File.pathSeparator );\n        }\n\n        addArgIfNotEmpty( arguments, \"-sourcepath\", quotedPathArgument( getSourcePath( sourcePaths ) ) );\n\n        if ( StringUtils.isNotEmpty( sourcepath ) )\n        {\n            addArgIfNotEmpty( arguments, \"-subpackages\", subpackages, SINCE_JAVADOC_1_4 );\n        }\n\n        addArgIfNotEmpty( arguments, \"-exclude\", getExcludedPackages( sourcePaths ), SINCE_JAVADOC_1_4 );\n\n        // ----------------------------------------------------------------------\n        // Wrap arguments for default doclet\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isEmpty( doclet ) )\n        {\n            addArgIf( arguments, author, \"-author\" );\n            addArgIfNotEmpty( arguments, \"-bottom\", quotedArgument( getBottomText( project.getInceptionYear() ) ),\n                              false, false );\n            addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-charset\", quotedArgument( charset ) );\n            addArgIfNotEmpty( arguments, \"-d\", quotedPathArgument( javadocOutputDirectory.toString() ) );\n            addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-docencoding\", quotedArgument( docencoding ) );\n            addArgIfNotEmpty( arguments, \"-doctitle\", quotedArgument( doctitle ), false, false );\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", quotedPathArgument( excludedocfilessubdir ),\n                              SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-footer\", quotedArgument( footer ), false, false );\n            if ( groups != null )\n            {\n                for ( int i = 0; i < groups.length; i++ )\n                {\n                    if ( groups[i] == null || StringUtils.isEmpty( groups[i].getTitle() )\n                        || StringUtils.isEmpty( groups[i].getPackages() ) )\n                    {\n                        getLog().info( \"A group option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String groupTitle = StringUtils.replace( groups[i].getTitle(), \",\", \"&#44;\" );\n                        addArgIfNotEmpty( arguments, \"-group\", quotedArgument( groupTitle ) + \" \"\n                            + quotedArgument( groups[i].getPackages() ), true );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-header\", quotedArgument( header ), false, false );\n            addArgIfNotEmpty( arguments, \"-helpfile\", quotedPathArgument( helpfile ) );\n            addArgIf( arguments, keywords, \"-keywords\", SINCE_JAVADOC_1_4_2 );\n\n            if ( !isOffline )\n            {\n                addLinkArguments( arguments );\n                addLinkofflineArguments( arguments );\n            }\n            else\n            {\n                addLinkofflineArguments( arguments );\n            }\n\n            addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n            addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n            addArgIf( arguments, nocomment, \"-nocomment\", SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nohelp, \"-nohelp\" );\n            addArgIf( arguments, noindex, \"-noindex\" );\n            addArgIf( arguments, nonavbar, \"-nonavbar\" );\n            addArgIfNotEmpty( arguments, \"-noqualifier\", quotedArgument( noqualifier ), SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nosince, \"-nosince\" );\n            addArgIf( arguments, notimestamp, \"-notimestamp\", SINCE_JAVADOC_1_5 );\n            addArgIf( arguments, notree, \"-notree\" );\n            addArgIfNotEmpty( arguments, \"-packagesheader\", packagesheader, SINCE_JAVADOC_1_4_2 );\n            addArgIf( arguments, serialwarn, \"-serialwarn\" );\n            addArgIf( arguments, linksource, \"-linksource\", SINCE_JAVADOC_1_4 );\n            if ( fJavadocVersion == SINCE_JAVADOC_1_4_2 )\n            {\n                addArgIfNotEmpty( arguments, \"-linksourcetab\", sourcetab );\n            }\n            else\n            {\n                addArgIfNotEmpty( arguments, \"-sourcetab\", sourcetab, SINCE_JAVADOC_1_5 );\n            }\n            addArgIf( arguments, splitindex, \"-splitindex\" );\n            addArgIfNotEmpty( arguments, \"-stylesheetfile\",\n                              quotedPathArgument( getStylesheetFile( javadocOutputDirectory ) ) );\n\n            addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglet ), SINCE_JAVADOC_1_4 );\n            if ( taglets != null )\n            {\n                for ( int i = 0; i < taglets.length; i++ )\n                {\n                    if ( ( taglets[i] == null ) || ( StringUtils.isEmpty( taglets[i].getTagletClass() ) ) )\n                    {\n                        getLog().info( \"A taglet option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglets[i].getTagletClass() ),\n                                          SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-tagletpath\", quotedPathArgument( getTagletPath() ), SINCE_JAVADOC_1_4 );\n\n            if ( tags != null )\n            {\n                for ( int i = 0; i < tags.length; i++ )\n                {\n                    if ( ( tags[i] == null ) || ( StringUtils.isEmpty( tags[i].getName() ) )\n                        || ( StringUtils.isEmpty( tags[i].getPlacement() ) ) )\n                    {\n                        getLog().info( \"A tag option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String value = \"\\\"\" + tags[i].getName() + \":\" + tags[i].getPlacement();\n                        if ( StringUtils.isNotEmpty( tags[i].getHead() ) )\n                        {\n                            value += \":\" + quotedArgument( tags[i].getHead() );\n                        }\n                        value += \"\\\"\";\n                        addArgIfNotEmpty( arguments, \"-tag\", value, SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n\n            addArgIf( arguments, use, \"-use\" );\n            addArgIf( arguments, version, \"-version\" );\n            addArgIfNotEmpty( arguments, \"-windowtitle\", quotedArgument( windowtitle ), false, false );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write options file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( options.length() > 0 )\n        {\n            addCommandLineOptions( cmd, options, arguments, javadocOutputDirectory );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write packages file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( !packageNames.isEmpty() )\n        {\n            addCommandLinePackages( cmd, javadocOutputDirectory, packageNames );\n\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !filesWithUnnamedPackages.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, filesWithUnnamedPackages );\n            }\n        }\n        else\n        {\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !files.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, files );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Execute command line\n        // ----------------------------------------------------------------------\n\n        getLog().debug( Commandline.toString( cmd.getCommandline() ) );\n\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + Commandline.toString( cmd.getCommandline() ) );\n                throw new MavenReportException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to execute javadoc command: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Handle Javadoc warnings\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( err.getOutput() ) )\n        {\n            getLog().info( \"Javadoc Warnings\" );\n\n            StringTokenizer token = new StringTokenizer( err.getOutput(), \"\\n\" );\n            while ( token.hasMoreTokens() )\n            {\n                String current = token.nextToken().trim();\n\n                getLog().warn( current );\n            }\n        }\n    }","commit_id":"99ff0e9172eac57d6ecd0c4881280a890f317434","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Add Standard Javadoc Options.\n     * <br/>\n     * The <a href=\"package-summary.html#Standard_Javadoc_Options\">package documentation<\/a> details the\n     * Standard Javadoc Options wrapped by this Plugin.\n     *\n     * @param arguments not null\n     * @param sourcePaths not null\n     * @throws MavenReportException if any\n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/javadoc.html#javadocoptions\">\n     * http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/javadoc.html#javadocoptions<\/a>\n     */\n    private void addJavadocOptions( List arguments, List sourcePaths )\n        throws MavenReportException\n    {\n        validateJavadocOptions();\n\n        // see com.sun.tools.javadoc.Start#parseAndExecute(String argv[])\n        addArgIfNotEmpty( arguments, \"-locale\", JavadocUtil.quotedArgument( this.locale ) );\n\n\n        addArgIfNotEmpty( arguments, \"-bootclasspath\", JavadocUtil.quotedPathArgument( getBootclassPath() ) );\n\n        addArgIfNotEmpty( arguments, \"-classpath\", JavadocUtil.quotedPathArgument( getClasspath() ) );\n\n        if ( StringUtils.isNotEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", JavadocUtil.quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletpath\", JavadocUtil.quotedPathArgument( getDocletPath() ) );\n        }\n        if ( StringUtils.isEmpty( encoding ) )\n        {\n            getLog().warn(\n                           \"Source files encoding has not been set, using platform encoding \"\n                               + ReaderFactory.FILE_ENCODING + \", i.e. build is platform dependent!\" );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", JavadocUtil.quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", JavadocUtil.quotedPathArgument( extdirs ) );\n\n        if ( old && isJavaDocVersionAtLeast( SINCE_JAVADOC_1_4 ) )\n        {\n            if ( getLog().isWarnEnabled() )\n            {\n                getLog().warn( \"Javadoc 1.4+ doesn't support the -1.1 switch anymore. Ignore this option.\" );\n            }\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        if ( ( getOverview() != null ) && ( getOverview().exists() ) )\n        {\n            addArgIfNotEmpty( arguments, \"-overview\",\n                              JavadocUtil.quotedPathArgument( getOverview().getAbsolutePath() ) );\n        }\n        arguments.add( getAccessLevel() );\n        addArgIf( arguments, quiet, \"-quiet\", SINCE_JAVADOC_1_5 );\n        addArgIfNotEmpty( arguments, \"-source\", JavadocUtil.quotedArgument( source ), SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, null, additionalparam );\n\n        if ( ( StringUtils.isEmpty( sourcepath ) ) && ( StringUtils.isNotEmpty( subpackages ) ) )\n        {\n            sourcepath = StringUtils.join( sourcePaths.iterator(), File.pathSeparator );\n        }\n\n        addArgIfNotEmpty( arguments, \"-sourcepath\", JavadocUtil.quotedPathArgument( getSourcePath( sourcePaths ) ) );\n\n        if ( StringUtils.isNotEmpty( sourcepath ) )\n        {\n            addArgIfNotEmpty( arguments, \"-subpackages\", subpackages, SINCE_JAVADOC_1_4 );\n        }\n\n        addArgIfNotEmpty( arguments, \"-exclude\", getExcludedPackages( sourcePaths ), SINCE_JAVADOC_1_4 );\n    }","id":26125,"modified_method":"/**\n     * Add Standard Javadoc Options.\n     * <br/>\n     * The <a href=\"package-summary.html#Standard_Javadoc_Options\">package documentation<\/a> details the\n     * Standard Javadoc Options wrapped by this Plugin.\n     *\n     * @param arguments not null\n     * @param sourcePaths not null\n     * @throws MavenReportException if any\n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/javadoc.html#javadocoptions\">\n     * http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/javadoc.html#javadocoptions<\/a>\n     */\n    private void addJavadocOptions( List arguments, List sourcePaths )\n        throws MavenReportException\n    {\n        validateJavadocOptions();\n\n        // see com.sun.tools.javadoc.Start#parseAndExecute(String argv[])\n        addArgIfNotEmpty( arguments, \"-locale\", JavadocUtil.quotedArgument( this.locale ) );\n\n\n        addArgIfNotEmpty( arguments, \"-bootclasspath\", JavadocUtil.quotedPathArgument( getBootclassPath() ) );\n\n        addArgIfNotEmpty( arguments, \"-classpath\", JavadocUtil.quotedPathArgument( getClasspath() ) );\n\n        if ( isJavaDocVersionAtLeast( SINCE_JAVADOC_1_5 ) )\n        {\n            addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_5 );\n        }\n        if ( StringUtils.isNotEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", JavadocUtil.quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletpath\", JavadocUtil.quotedPathArgument( getDocletPath() ) );\n        }\n        if ( StringUtils.isEmpty( encoding ) )\n        {\n            getLog().warn(\n                           \"Source files encoding has not been set, using platform encoding \"\n                               + ReaderFactory.FILE_ENCODING + \", i.e. build is platform dependent!\" );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", JavadocUtil.quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", JavadocUtil.quotedPathArgument( extdirs ) );\n\n        if ( old && isJavaDocVersionAtLeast( SINCE_JAVADOC_1_4 ) )\n        {\n            if ( getLog().isWarnEnabled() )\n            {\n                getLog().warn( \"Javadoc 1.4+ doesn't support the -1.1 switch anymore. Ignore this option.\" );\n            }\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        if ( ( getOverview() != null ) && ( getOverview().exists() ) )\n        {\n            addArgIfNotEmpty( arguments, \"-overview\",\n                              JavadocUtil.quotedPathArgument( getOverview().getAbsolutePath() ) );\n        }\n        arguments.add( getAccessLevel() );\n\n        if ( isJavaDocVersionAtLeast( SINCE_JAVADOC_1_5 ) )\n        {\n            addArgIf( arguments, quiet, \"-quiet\", SINCE_JAVADOC_1_5 );\n        }\n        addArgIfNotEmpty( arguments, \"-source\", JavadocUtil.quotedArgument( source ), SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, null, additionalparam );\n\n        if ( ( StringUtils.isEmpty( sourcepath ) ) && ( StringUtils.isNotEmpty( subpackages ) ) )\n        {\n            sourcepath = StringUtils.join( sourcePaths.iterator(), File.pathSeparator );\n        }\n\n        addArgIfNotEmpty( arguments, \"-sourcepath\", JavadocUtil.quotedPathArgument( getSourcePath( sourcePaths ) ) );\n\n        if ( StringUtils.isNotEmpty( sourcepath ) )\n        {\n            addArgIfNotEmpty( arguments, \"-subpackages\", subpackages, SINCE_JAVADOC_1_4 );\n        }\n\n        addArgIfNotEmpty( arguments, \"-exclude\", getExcludedPackages( sourcePaths ), SINCE_JAVADOC_1_4 );\n    }","commit_id":"49566b9eaf85819bbc09f81d02631abe8016e6d0","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Add Standard Doclet Options.\n     * <br/>\n     * The <a href=\"package-summary.html#Standard_Doclet_Options\">package documentation<\/a> details the\n     * Standard Doclet Options wrapped by this Plugin.\n     *\n     * @param javadocOutputDirectory not null\n     * @param arguments not null\n     * @throws MavenReportException if any\n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/javadoc.html#standard\">\n     * http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/javadoc.html#standard<\/a>\n     */\n    private void addStandardDocletOptions( File javadocOutputDirectory, List arguments )\n        throws MavenReportException\n    {\n        validateStandardDocletOptions();\n\n        addArgIf( arguments, author, \"-author\" );\n        addArgIfNotEmpty( arguments, \"-bottom\", JavadocUtil.quotedArgument( getBottomText() ), false, false );\n        addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n        addArgIfNotEmpty( arguments, \"-charset\", JavadocUtil.quotedArgument( getCharset() ) );\n        addArgIfNotEmpty( arguments, \"-d\", JavadocUtil.quotedPathArgument( javadocOutputDirectory.toString() ) );\n        addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", SINCE_JAVADOC_1_4 );\n        addArgIfNotEmpty( arguments, \"-docencoding\", JavadocUtil.quotedArgument( getDocencoding() ) );\n        addArgIfNotEmpty( arguments, \"-doctitle\", JavadocUtil.quotedArgument( getDoctitle() ), false, false );\n        if ( docfilessubdirs )\n        {\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\",\n                              JavadocUtil.quotedPathArgument( excludedocfilessubdir ), SINCE_JAVADOC_1_4 );\n        }\n        addArgIfNotEmpty( arguments, \"-footer\", JavadocUtil.quotedArgument( footer ), false, false );\n        addGroups( arguments );\n        addArgIfNotEmpty( arguments, \"-header\", JavadocUtil.quotedArgument( header ), false, false );\n        addArgIfNotEmpty( arguments, \"-helpfile\", JavadocUtil.quotedPathArgument( helpfile ) );\n        addArgIf( arguments, keywords, \"-keywords\", SINCE_JAVADOC_1_4_2 );\n\n        if ( !isOffline )\n        {\n            addLinkArguments( arguments );\n        }\n        addLinkofflineArguments( arguments );\n\n        addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n        addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n        addArgIf( arguments, nocomment, \"-nocomment\", SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, nohelp, \"-nohelp\" );\n        addArgIf( arguments, noindex, \"-noindex\" );\n        addArgIf( arguments, nonavbar, \"-nonavbar\" );\n        addArgIf( arguments, nooverview, \"-nooverview\" );\n        addArgIfNotEmpty( arguments, \"-noqualifier\", JavadocUtil.quotedArgument( noqualifier ), SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, nosince, \"-nosince\" );\n        addArgIf( arguments, notimestamp, \"-notimestamp\", SINCE_JAVADOC_1_5 );\n        addArgIf( arguments, notree, \"-notree\" );\n        addArgIfNotEmpty( arguments, \"-packagesheader\", JavadocUtil.quotedArgument( packagesheader ),\n                          SINCE_JAVADOC_1_4_2 );\n        if ( fJavadocVersion >= SINCE_JAVADOC_1_4 && fJavadocVersion < SINCE_JAVADOC_1_5 ) // Sun bug: 4714350\n        {\n            addArgIf( arguments, quiet, \"-quiet\" );\n        }\n        addArgIf( arguments, serialwarn, \"-serialwarn\" );\n        addArgIf( arguments, linksource, \"-linksource\", SINCE_JAVADOC_1_4 );\n        if ( fJavadocVersion == SINCE_JAVADOC_1_4_2 )\n        {\n            addArgIfNotEmpty( arguments, \"-linksourcetab\", sourcetab );\n        }\n        else\n        {\n            addArgIfNotEmpty( arguments, \"-sourcetab\", sourcetab, SINCE_JAVADOC_1_5 );\n        }\n        addArgIf( arguments, splitindex, \"-splitindex\" );\n        addArgIfNotEmpty( arguments, \"-stylesheetfile\",\n                          JavadocUtil.quotedPathArgument( getStylesheetFile( javadocOutputDirectory ) ) );\n\n        addArgIfNotEmpty( arguments, \"-taglet\", JavadocUtil.quotedArgument( taglet ), SINCE_JAVADOC_1_4 );\n        addTaglets( arguments );\n        addTagletsFromTagletArtifacts( arguments );\n        addArgIfNotEmpty( arguments, \"-tagletpath\", JavadocUtil.quotedPathArgument( getTagletPath() ),\n                          SINCE_JAVADOC_1_4 );\n        addTags( arguments );\n\n        addArgIfNotEmpty( arguments, \"-top\", JavadocUtil.quotedArgument( top ), false, false, SINCE_JAVADOC_1_6 );\n        addArgIf( arguments, use, \"-use\" );\n        addArgIf( arguments, version, \"-version\" );\n        addArgIfNotEmpty( arguments, \"-windowtitle\", JavadocUtil.quotedArgument( getWindowtitle() ), false, false );\n    }","id":26126,"modified_method":"/**\n     * Add Standard Doclet Options.\n     * <br/>\n     * The <a href=\"package-summary.html#Standard_Doclet_Options\">package documentation<\/a> details the\n     * Standard Doclet Options wrapped by this Plugin.\n     *\n     * @param javadocOutputDirectory not null\n     * @param arguments not null\n     * @throws MavenReportException if any\n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/javadoc.html#standard\">\n     * http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/javadoc.html#standard<\/a>\n     */\n    private void addStandardDocletOptions( File javadocOutputDirectory, List arguments )\n        throws MavenReportException\n    {\n        validateStandardDocletOptions();\n\n        addArgIf( arguments, author, \"-author\" );\n        addArgIfNotEmpty( arguments, \"-bottom\", JavadocUtil.quotedArgument( getBottomText() ), false, false );\n        if ( !isJavaDocVersionAtLeast( SINCE_JAVADOC_1_5 ) )\n        {\n            addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n        }\n        addArgIfNotEmpty( arguments, \"-charset\", JavadocUtil.quotedArgument( getCharset() ) );\n        addArgIfNotEmpty( arguments, \"-d\", JavadocUtil.quotedPathArgument( javadocOutputDirectory.toString() ) );\n        addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", SINCE_JAVADOC_1_4 );\n        addArgIfNotEmpty( arguments, \"-docencoding\", JavadocUtil.quotedArgument( getDocencoding() ) );\n        addArgIfNotEmpty( arguments, \"-doctitle\", JavadocUtil.quotedArgument( getDoctitle() ), false, false );\n        if ( docfilessubdirs )\n        {\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\",\n                              JavadocUtil.quotedPathArgument( excludedocfilessubdir ), SINCE_JAVADOC_1_4 );\n        }\n        addArgIfNotEmpty( arguments, \"-footer\", JavadocUtil.quotedArgument( footer ), false, false );\n        addGroups( arguments );\n        addArgIfNotEmpty( arguments, \"-header\", JavadocUtil.quotedArgument( header ), false, false );\n        addArgIfNotEmpty( arguments, \"-helpfile\", JavadocUtil.quotedPathArgument( helpfile ) );\n        addArgIf( arguments, keywords, \"-keywords\", SINCE_JAVADOC_1_4_2 );\n\n        if ( !isOffline )\n        {\n            addLinkArguments( arguments );\n        }\n        addLinkofflineArguments( arguments );\n\n        addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n        addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n        addArgIf( arguments, nocomment, \"-nocomment\", SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, nohelp, \"-nohelp\" );\n        addArgIf( arguments, noindex, \"-noindex\" );\n        addArgIf( arguments, nonavbar, \"-nonavbar\" );\n        addArgIf( arguments, nooverview, \"-nooverview\" );\n        addArgIfNotEmpty( arguments, \"-noqualifier\", JavadocUtil.quotedArgument( noqualifier ), SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, nosince, \"-nosince\" );\n        addArgIf( arguments, notimestamp, \"-notimestamp\", SINCE_JAVADOC_1_5 );\n        addArgIf( arguments, notree, \"-notree\" );\n        addArgIfNotEmpty( arguments, \"-packagesheader\", JavadocUtil.quotedArgument( packagesheader ),\n                          SINCE_JAVADOC_1_4_2 );\n        if ( !isJavaDocVersionAtLeast( SINCE_JAVADOC_1_5 ) ) // Sun bug: 4714350\n        {\n            addArgIf( arguments, quiet, \"-quiet\", SINCE_JAVADOC_1_4 );\n        }\n        addArgIf( arguments, serialwarn, \"-serialwarn\" );\n        addArgIf( arguments, linksource, \"-linksource\", SINCE_JAVADOC_1_4 );\n        if ( fJavadocVersion == SINCE_JAVADOC_1_4_2 )\n        {\n            addArgIfNotEmpty( arguments, \"-linksourcetab\", sourcetab );\n        }\n        addArgIfNotEmpty( arguments, \"-sourcetab\", sourcetab, SINCE_JAVADOC_1_5 );\n        addArgIf( arguments, splitindex, \"-splitindex\" );\n        addArgIfNotEmpty( arguments, \"-stylesheetfile\",\n                          JavadocUtil.quotedPathArgument( getStylesheetFile( javadocOutputDirectory ) ) );\n\n        addArgIfNotEmpty( arguments, \"-taglet\", JavadocUtil.quotedArgument( taglet ), SINCE_JAVADOC_1_4 );\n        addTaglets( arguments );\n        addTagletsFromTagletArtifacts( arguments );\n        addArgIfNotEmpty( arguments, \"-tagletpath\", JavadocUtil.quotedPathArgument( getTagletPath() ),\n                          SINCE_JAVADOC_1_4 );\n        addTags( arguments );\n\n        addArgIfNotEmpty( arguments, \"-top\", JavadocUtil.quotedArgument( top ), false, false, SINCE_JAVADOC_1_6 );\n        addArgIf( arguments, use, \"-use\" );\n        addArgIf( arguments, version, \"-version\" );\n        addArgIfNotEmpty( arguments, \"-windowtitle\", JavadocUtil.quotedArgument( getWindowtitle() ), false, false );\n    }","commit_id":"49566b9eaf85819bbc09f81d02631abe8016e6d0","url":"https://github.com/apache/maven-plugins"},{"original_method":"@NotNull\n  private PsiReference[] getPackageReferences(final @NotNull VirtualFile contextFile,\n                                              final @Nullable VirtualFile packagesFolder,\n                                              final @NotNull String relPathFromPackagesFolderToReferencedFile,\n                                              final int startIndex) {\n    final VirtualFile parentFile = contextFile.getParent();\n    if (packagesFolder == null || parentFile == null) return PsiReference.EMPTY_ARRAY;\n\n    String relPathFromContextFileToPackagesFolder = FileUtil.getRelativePath(parentFile.getPath(), packagesFolder.getPath(), '/');\n    if (relPathFromContextFileToPackagesFolder == null) return PsiReference.EMPTY_ARRAY;\n\n    relPathFromContextFileToPackagesFolder += \"/\";\n    final FileReferenceSet referenceSet =\n      new FileReferenceSet(relPathFromContextFileToPackagesFolder + relPathFromPackagesFolderToReferencedFile, this, 0, null, false, true);\n    final FileReference[] references = referenceSet.getAllReferences();\n\n    final int nestedLevel = StringUtil.countChars(relPathFromContextFileToPackagesFolder, '/');\n    final int shift = startIndex - relPathFromContextFileToPackagesFolder.length();\n    return references.length < nestedLevel ?\n           PsiReference.EMPTY_ARRAY :\n           shiftReferences(Arrays.copyOfRange(references, nestedLevel, references.length), shift);\n  }","id":26127,"modified_method":"@NotNull\n  private PsiReference[] getPackageReferences(final @NotNull VirtualFile contextFile,\n                                              final @Nullable VirtualFile packagesFolder,\n                                              final @NotNull String relPathFromPackagesFolderToReferencedFile,\n                                              final int startIndex) {\n    final VirtualFile parentFile = contextFile.getParent();\n    if (packagesFolder == null || parentFile == null) return PsiReference.EMPTY_ARRAY;\n\n    String relPathFromContextFileToPackagesFolder = FileUtil.getRelativePath(parentFile.getPath(), packagesFolder.getPath(), '/');\n    if (relPathFromContextFileToPackagesFolder == null) return PsiReference.EMPTY_ARRAY;\n\n    relPathFromContextFileToPackagesFolder += \"/\";\n    final FileReferenceSet referenceSet =\n      new FileReferenceSet(relPathFromContextFileToPackagesFolder + relPathFromPackagesFolderToReferencedFile, this, 0, null, false, true);\n    final FileReference[] references = referenceSet.getAllReferences();\n\n    final int nestedLevel = StringUtil.countChars(relPathFromContextFileToPackagesFolder, '/');\n    final int shift = startIndex - relPathFromContextFileToPackagesFolder.length() + 1;\n    return references.length < nestedLevel ?\n           PsiReference.EMPTY_ARRAY :\n           shiftReferences(Arrays.copyOfRange(references, nestedLevel, references.length), shift);\n  }","commit_id":"22b3279e697c62e13d9fd724515d039298778964","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  public PsiReference[] getReferences() {\n    final String url = StringUtil.unquoteString(getText());\n    if (url.startsWith(PACKAGE_PREFIX)) {\n      final VirtualFile file = DartResolveUtil.getRealVirtualFile(getContainingFile());\n      if (file == null) return PsiReference.EMPTY_ARRAY;\n\n      final DartUrlResolver dartUrlResolver = DartUrlResolver.getInstance(getProject(), file);\n\n      final int slashIndex = url.indexOf('/');\n      if (slashIndex > 0) {\n        final Ref<VirtualFile> packageDirRef = new Ref<VirtualFile>();\n        final String packageName = url.substring(PACKAGE_PREFIX.length(), slashIndex);\n        dartUrlResolver.processLivePackages(new PairConsumer<String, VirtualFile>() {\n          public void consume(final String packageName1, final VirtualFile packageDir) {\n            if (packageName.equals(packageName1)) {\n              packageDirRef.set(packageDir);\n            }\n          }\n        });\n\n        if (!packageDirRef.isNull()) {\n          return getPackageReferences(file, packageDirRef.get(), url.substring(slashIndex + 1), slashIndex + 1);\n        }\n      }\n\n      final String relPath = url.substring(PACKAGE_PREFIX.length());\n      final VirtualFile[] packageRoots = dartUrlResolver.getPackageRoots();\n\n      if (packageRoots.length == 0) return PsiReference.EMPTY_ARRAY;\n      if (packageRoots.length == 1) return getPackageReferences(file, packageRoots[0], relPath, PACKAGE_PREFIX.length() + 1);\n\n      final Collection<PsiReference> result = new SmartList<PsiReference>();\n      for (VirtualFile packageRoot : packageRoots) {\n        if (packageRoot.findFileByRelativePath(relPath) != null) {\n          ContainerUtil.addAll(result, getPackageReferences(file, packageRoot, relPath, PACKAGE_PREFIX.length() + 1));\n        }\n      }\n\n      return result.toArray(new PsiReference[result.size()]);\n    }\n\n    final FileReferenceSet referenceSet = new FileReferenceSet(url, this, 1, null, false, true);\n    return ArrayUtil.mergeArrays(super.getReferences(), referenceSet.getAllReferences());\n  }","id":26128,"modified_method":"@NotNull\n  @Override\n  public PsiReference[] getReferences() {\n    final String url = StringUtil.unquoteString(getText());\n    if (url.startsWith(PACKAGE_PREFIX)) {\n      final VirtualFile file = DartResolveUtil.getRealVirtualFile(getContainingFile());\n      if (file == null) return PsiReference.EMPTY_ARRAY;\n\n      final DartUrlResolver dartUrlResolver = DartUrlResolver.getInstance(getProject(), file);\n\n      final int slashIndex = url.indexOf('/');\n      if (slashIndex > 0) {\n        final Ref<VirtualFile> packageDirRef = new Ref<VirtualFile>();\n        final String packageName = url.substring(PACKAGE_PREFIX.length(), slashIndex);\n        dartUrlResolver.processLivePackages(new PairConsumer<String, VirtualFile>() {\n          public void consume(final String packageName1, final VirtualFile packageDir) {\n            if (packageName.equals(packageName1)) {\n              packageDirRef.set(packageDir);\n            }\n          }\n        });\n\n        if (!packageDirRef.isNull()) {\n          return getPackageReferences(file, packageDirRef.get(), url.substring(slashIndex + 1), slashIndex + 1);\n        }\n      }\n\n      final String relPath = url.substring(PACKAGE_PREFIX.length());\n      final VirtualFile[] packageRoots = dartUrlResolver.getPackageRoots();\n\n      if (packageRoots.length == 0) return PsiReference.EMPTY_ARRAY;\n      if (packageRoots.length == 1) return getPackageReferences(file, packageRoots[0], relPath, PACKAGE_PREFIX.length());\n\n      final Collection<PsiReference> result = new SmartList<PsiReference>();\n      for (VirtualFile packageRoot : packageRoots) {\n        if (packageRoot.findFileByRelativePath(relPath) != null) {\n          ContainerUtil.addAll(result, getPackageReferences(file, packageRoot, relPath, PACKAGE_PREFIX.length()));\n        }\n      }\n\n      return result.toArray(new PsiReference[result.size()]);\n    }\n\n    final FileReferenceSet referenceSet = new FileReferenceSet(url, this, 1, null, false, true);\n    return ArrayUtil.mergeArrays(super.getReferences(), referenceSet.getAllReferences());\n  }","commit_id":"22b3279e697c62e13d9fd724515d039298778964","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testNoRecursiveImports() throws Exception {\n    myFixture.configureByText(\"file2.dart\", \"inFile2(){}\");\n    myFixture.configureByText(\"file1.dart\", \"import 'file2.dart'\\n inFile1(){}\");\n    myFixture.configureByText(\"file.dart\", \"library fileLib;\\n\" +\n                                           \"import 'file1.dart';\\n\" +\n                                           \"part 'filePart1.dart';\\n\" +\n                                           \"part 'filePart2.dart';\\n\" +\n                                           \"inFile(){}\");\n    myFixture.configureByText(\"filePart1.dart\", \"part of fileLib;\\n\" +\n                                                \"inFilePart1(){}\");\n    myFixture.configureByText(\"filePart2.dart\", \"part of fileLib;\\n\" +\n                                                \"inFilePart2(){\\n\" +\n                                                \"  <caret expected='filePart1.dart -> inFilePart1'>inFilePart1()\\n\" +\n                                                \"  <caret expected='filePart2.dart -> inFilePart2'>inFilePart2()\\n\" +\n                                                \"  <caret expected='file.dart -> inFile'>inFile()\\n\" +\n                                                \"  <caret expected='file1.dart -> inFile1'>inFile1()\\n\" +\n                                                \"  <caret expected=''>inFile2()\\n\" +\n                                                \"}\");\n    doTest();\n  }","id":26129,"modified_method":"public void testNoRecursiveImports() throws Exception {\n    myFixture.addFileToProject(\"file2.dart\", \"inFile2(){}\");\n    myFixture.addFileToProject(\"file1.dart\", \"import 'file2.dart'\\n inFile1(){}\");\n    myFixture.addFileToProject(\"file.dart\", \"library fileLib;\\n\" +\n                                            \"import 'file1.dart';\\n\" +\n                                            \"part 'filePart1.dart';\\n\" +\n                                            \"part 'filePart2.dart';\\n\" +\n                                            \"inFile(){}\");\n    myFixture.addFileToProject(\"filePart1.dart\", \"part of fileLib;\\n\" +\n                                                 \"inFilePart1(){}\");\n    myFixture.configureByText(\"filePart2.dart\", \"part of fileLib;\\n\" +\n                                                \"inFilePart2(){\\n\" +\n                                                \"  <caret expected='filePart1.dart -> inFilePart1'>inFilePart1()\\n\" +\n                                                \"  <caret expected='filePart2.dart -> inFilePart2'>inFilePart2()\\n\" +\n                                                \"  <caret expected='file.dart -> inFile'>inFile()\\n\" +\n                                                \"  <caret expected='file1.dart -> inFile1'>inFile1()\\n\" +\n                                                \"  <caret expected=''>inFile2()\\n\" +\n                                                \"}\");\n    doTest();\n  }","commit_id":"22b3279e697c62e13d9fd724515d039298778964","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testResolveWithExports() throws Exception {\n    myFixture.configureByText(\"file1.dart\", \"inFile1(){}\\n\" +\n                                            \"inFile1HiddenLater(){}\");\n    myFixture.configureByText(\"file2.dart\", \"inFile2(){}\");\n    myFixture.configureByText(\"file3.dart\", \"inFile3(){}\");\n    myFixture.configureByText(\"file4.dart\", \"inFile4(){}\");\n    myFixture.configureByText(\"file5.dart\", \"inFile5(){}\");\n    myFixture.configureByText(\"file6.dart\", \"export 'file1.dart;\\n\" +\n                                            \"export 'file2.dart' show xxx, inFile2, yyy;\\n\" +\n                                            \"export 'file3.dart' show xxx, yyy;\\n\" +\n                                            \"export 'file4.dart' hide xxx, inFile4, yyy;\\n\" +\n                                            \"export 'file5.dart' hide xxx, yyy;\\n\" +\n                                            \"export 'file1.dart';\\n\" +\n                                            \"export 'file.dart';\\n\" +\n                                            \"inFile6(){}\");\n    myFixture.configureByText(\"file7.dart\", \"export 'file6.dart' hide inFile1HiddenLater;\\n\" +\n                                            \"inFile7(){}\");\n    myFixture.configureByText(\"file8.dart\", \"inFile8(){}\");\n    myFixture.configureByText(\"file.dart\", \"library fileLib;\\n\" +\n                                           \"import 'file7.dart';\\n\" +\n                                           \"export 'file8.dart';\\n\" +\n                                           \"part 'filePart1.dart';\\n\" +\n                                           \"inFile(){}\");\n    myFixture.configureByText(\"filePart1.dart\", \"part of fileLib;\\n\" +\n                                                \"foo(){\\n\" +\n                                                \"  <caret expected='file.dart -> inFile'>inFile()\\n\" +\n                                                \"  <caret expected=''>inFile8()\\n\" +\n                                                \"  <caret expected='file7.dart -> inFile7'>inFile7()\\n\" +\n                                                \"  <caret expected='file6.dart -> inFile6'>inFile6()\\n\" +\n                                                \"  <caret expected='file5.dart -> inFile5'>inFile5()\\n\" +\n                                                \"  <caret expected=''>inFile4()\\n\" +\n                                                \"  <caret expected=''>inFile3()\\n\" +\n                                                \"  <caret expected='file2.dart -> inFile2'>inFile2()\\n\" +\n                                                \"  <caret expected='file1.dart -> inFile1'>inFile1()\\n\" +\n                                                \"  <caret expected=''>inFile1HiddenLater()\\n\" +\n                                                \"}\");\n    doTest();\n  }","id":26130,"modified_method":"public void testResolveWithExports() throws Exception {\n    myFixture.addFileToProject(\"file1.dart\", \"inFile1(){}\\n\" +\n                                             \"inFile1HiddenLater(){}\");\n    myFixture.addFileToProject(\"file2.dart\", \"inFile2(){}\");\n    myFixture.addFileToProject(\"file3.dart\", \"inFile3(){}\");\n    myFixture.addFileToProject(\"file4.dart\", \"inFile4(){}\");\n    myFixture.addFileToProject(\"file5.dart\", \"inFile5(){}\");\n    myFixture.addFileToProject(\"file6.dart\", \"export 'file1.dart;\\n\" +\n                                             \"export 'file2.dart' show xxx, inFile2, yyy;\\n\" +\n                                             \"export 'file3.dart' show xxx, yyy;\\n\" +\n                                             \"export 'file4.dart' hide xxx, inFile4, yyy;\\n\" +\n                                             \"export 'file5.dart' hide xxx, yyy;\\n\" +\n                                             \"export 'file1.dart';\\n\" +\n                                             \"export 'file.dart';\\n\" +\n                                             \"inFile6(){}\");\n    myFixture.addFileToProject(\"file7.dart\", \"export 'file6.dart' hide inFile1HiddenLater;\\n\" +\n                                             \"inFile7(){}\");\n    myFixture.addFileToProject(\"file8.dart\", \"inFile8(){}\");\n    myFixture.addFileToProject(\"file.dart\", \"library fileLib;\\n\" +\n                                            \"import 'file7.dart';\\n\" +\n                                            \"export 'file8.dart';\\n\" +\n                                            \"part 'filePart1.dart';\\n\" +\n                                            \"inFile(){}\");\n    myFixture.configureByText(\"filePart1.dart\", \"part of fileLib;\\n\" +\n                                                \"foo(){\\n\" +\n                                                \"  <caret expected='file.dart -> inFile'>inFile()\\n\" +\n                                                \"  <caret expected=''>inFile8()\\n\" +\n                                                \"  <caret expected='file7.dart -> inFile7'>inFile7()\\n\" +\n                                                \"  <caret expected='file6.dart -> inFile6'>inFile6()\\n\" +\n                                                \"  <caret expected='file5.dart -> inFile5'>inFile5()\\n\" +\n                                                \"  <caret expected=''>inFile4()\\n\" +\n                                                \"  <caret expected=''>inFile3()\\n\" +\n                                                \"  <caret expected='file2.dart -> inFile2'>inFile2()\\n\" +\n                                                \"  <caret expected='file1.dart -> inFile1'>inFile1()\\n\" +\n                                                \"  <caret expected=''>inFile1HiddenLater()\\n\" +\n                                                \"}\");\n    doTest();\n  }","commit_id":"22b3279e697c62e13d9fd724515d039298778964","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private static String getPresentableElementPosition(final @Nullable PsiElement element) {\n    if (element == null) return \"\";\n\n    final StringBuilder buf = new StringBuilder(element.getText());\n    DartComponentName componentName = PsiTreeUtil.getParentOfType(element, DartComponentName.class);\n    while (componentName != null) {\n      buf.insert(0, componentName.getName() + \" -> \");\n      componentName = PsiTreeUtil.getParentOfType(componentName, DartComponentName.class);\n    }\n    buf.insert(0, element.getContainingFile().getName() + \" -> \");\n\n    return buf.toString();\n  }","id":26131,"modified_method":"@NotNull\n  private static String getPresentableElementPosition(final @Nullable PsiElement element) {\n    if (element == null) return \"\";\n\n    final StringBuilder buf = new StringBuilder(element.getText());\n    DartComponentName componentName = PsiTreeUtil.getParentOfType(element, DartComponentName.class);\n    while (componentName != null) {\n      buf.insert(0, componentName.getName() + \" -> \");\n      componentName = PsiTreeUtil.getParentOfType(componentName, DartComponentName.class);\n    }\n    String path = element instanceof PsiDirectoryImpl ? ((PsiDirectoryImpl)element).getVirtualFile().getPath()\n                                                      : element.getContainingFile().getVirtualFile().getPath();\n    if (path.startsWith(\"/src/\")) path = path.substring(\"/src/\".length());\n    if (buf.length() > 0) buf.insert(0, \" -> \");\n    buf.insert(0, path);\n\n    return buf.toString();\n  }","commit_id":"22b3279e697c62e13d9fd724515d039298778964","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n    public int compare(Pair<PsiFile, BDDFrameworkType> pair1, Pair<PsiFile, BDDFrameworkType> pair2) {\n      if (pair1 == null && pair2 == null) {\n        return 0;\n      } else if (pair1 == null) {\n        return -1;\n      } else if (pair2 == null) {\n        return 1;\n      }\n\n      return pair1.getFirst().getName().compareTo(pair2.getFirst().getName());\n    }","id":26132,"modified_method":"@Override\n    public int compare(Pair<PsiFile, BDDFrameworkType> pair1, Pair<PsiFile, BDDFrameworkType> pair2) {\n      if (pair1 == null && pair2 == null) {\n        return 0;\n      }\n      else if (pair1 == null) {\n        return -1;\n      }\n      else if (pair2 == null) {\n        return 1;\n      }\n\n      return pair1.getFirst().getVirtualFile().getPath().compareTo(pair2.getFirst().getVirtualFile().getPath());\n    }","commit_id":"0f93688589b9ad0a0a31ba8c228eb258906677f9","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n\t * Optimized implementation: first checks if a range index is defined\n\t * on the nodes in the left argument. If that fails, check if we can use\n\t * the fulltext index to speed up the search. Otherwise, fall back to\n\t * {@link #nodeSetCompare(NodeSet, Sequence)}.\n\t */\n\tprotected Sequence quickNodeSetCompare(Sequence contextSequence) throws XPathException {\n\t\t\n\t\t/* TODO think about optimising fallback to NodeSetCompare() in the for loop!!!\n\t\t * At the moment when we fallback to NodeSetCompare() we are in effect throwing away any nodes\n\t\t * we have already processed in quickNodeSetCompare() and reprocessing all the nodes in NodeSetCompare().\n\t\t * Instead - Could we create a NodeCompare() (based on NodeSetCompare() code) to only compare a single node and then union the result?\n\t\t * - deliriumsky \n\t\t */\n\t\t\n\t\t/* TODO think about caching of results in this function...\n\t\t * also examine and check if correct (line near the end) -\n\t\t * \t boolean canCache = contextSequence instanceof NodeSet && (getRight().getDependencies() & Dependency.VARS) == 0 && (getLeft().getDependencies() & Dependency.VARS) == 0;\n\t\t *  - deliriumsky \n\t\t */\n\t\t\n        // if the context sequence hasn't changed we can return a cached result\n\t\tif(cached != null && cached.isValid(contextSequence))\n\t\t{\n            if(context.getProfiler().isEnabled())\n            {\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"OPTIMIZATION\", \"Returned cached result\");\n            }\n            \n\t\t\treturn(cached.getResult());\n\t\t}\t\t\n      \n\t\t//get the NodeSet on the left\n\t\tNodeSet nodes = (NodeSet) getLeft().eval(contextSequence);\t\t\n        if(!(nodes instanceof VirtualNodeSet) && nodes.isEmpty()) //nothing on the left, so nothing to do\n        {\n            return(Sequence.EMPTY_SEQUENCE);\n        }\n    \n        //get the Sequence on the right\n\t\tSequence rightSeq = getRight().eval(contextSequence);\n\t\tif(rightSeq.isEmpty())\t//nothing on the right, so nothing to do\n\t\t{\n            return(Sequence.EMPTY_SEQUENCE);\n\t\t}\n        \n        \n\t\t//Holds the result\n\t\tNodeSet result = null;\n\t\t\n\t\t//get the type of a possible index\n\t\tint indexType = nodes.getIndexType();\n\t\t\n\t\t//See if we have a range index defined on the nodes in this sequence\n        //TODO : use isSubType ??? -pb\n\t    if(indexType != Type.ITEM)\n\t    {\n\t    \t//Get the documents from the node set\n\t\t\tDocumentSet docs = nodes.getDocumentSet();\n\t\n\t\t\t//Iterate through the right hand sequence\n\t\t\tfor(SequenceIterator itRightSeq = rightSeq.iterate(); itRightSeq.hasNext();)\n\t    \t{\n\t\t\t\t//Get the index Key\n\t\t\t\tItem key = itRightSeq.nextItem().atomize();\n\t\t\t\t\n\t\t\t\t//if key has truncation convert to string\n\t\t        if(truncation != Constants.TRUNC_NONE)\n\t\t        {\n\t\t        \t//truncation is only possible on strings\n\t\t        \tkey = key.convertTo(Type.STRING);\n\t\t        }\n\t\t        //else if key is not the same type as the index\n                //TODO : use isSubType ??? -pb\n\t\t        else if(key.getType() != indexType)\n\t\t        {\n\t\t        \t//try and convert the key to the index type \n\t            \ttry\n\t\t\t\t\t{\n\t            \t\tkey = key.convertTo(indexType);\n\t\t\t\t\t}\n\t            \tcatch(XPathException xpe)\n\t\t\t\t\t{\n\t\t\t        \t//Could not convert the key to a suitable type for the index, fallback to nodeSetCompare()\n\t\t                if(context.getProfiler().isEnabled())\n\t\t                {\n\t\t                    context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"falling back to nodeSetCompare (\" + xpe.getMessage() + \")\");\n\t\t                }\n\t\t                \n\t\t\t            return nodeSetCompare(nodes, contextSequence);\n\t\t\t\t\t}\n\t\t        }\n\t\t        \n\t\t        // If key implements org.exist.storage.Indexable, we can use the index\n\t\t        if(key instanceof Indexable && Type.subTypeOf(key.getType(), indexType))\n\t\t        {\n\t\t        \tif(truncation == Constants.TRUNC_NONE)\n\t\t        \t{\n\t\t\t        \t//key without truncation, find key\n\t                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"OPTIMIZATION\", \"Using value index to find key '\" + Type.getTypeName(key.getType()) + \"(\" + key.getStringValue() + \")'\");\n\t                    \n\t                    if(result == null)\t//if first iteration\n\t                    {\n\t                    \tresult = context.getBroker().getValueIndex().find(relation, docs, nodes, (Indexable)key);\n\t                    }\n\t                    else\n\t                    {\n\t                    \tresult = result.union(context.getBroker().getValueIndex().find(relation, docs, nodes, (Indexable)key));\n\t                    }\n\t                }\n\t\t        \telse\n\t\t        \t{\n\t\t\t        \t//key with truncation, match key\n\t                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"OPTIMIZATION\", \"Using value index to match key '\" + Type.getTypeName(key.getType()) + \"(\" + key.getStringValue() + \")'\");\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(result == null) //if first iteration\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tresult = context.getBroker().getValueIndex().match(docs, nodes, key.getStringValue().replace('%', '*'), DBBroker.MATCH_WILDCARDS);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tresult = result.union(context.getBroker().getValueIndex().match(docs, nodes, key.getStringValue().replace('%', '*'), DBBroker.MATCH_WILDCARDS));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (EXistException e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new XPathException(getASTNode(), e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t        }\n\t\t        else\n\t\t        {\n\t\t        \t//the datatype of our key does not\n\t\t        \t//implement org.exist.storage.Indexable or is not of the correct type\n\t                if(context.getProfiler().isEnabled())\n\t                {\n\t                    context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"falling back to nodeSetCompare (key is of type: \" + Type.getTypeName(key.getType()) + \")\");\n\t                }\n                    return(nodeSetCompare(nodes, contextSequence));\n\t            }\n        \n\t\t//removed by Pierrick Brihaye\n        //REMOVED : a *general* comparison should not be dependant of the settings of a fulltext index\n        /*\n\t    } else if (key.getType() == Type.ATOMIC || Type.subTypeOf(key.getType(), Type.STRING)) {\n\t        if (!nodes.hasMixedContent() && relation == Constants.EQ \n\t            && nodes.hasTextIndex()) {\n\t\t        // we can use the fulltext index\n\t\t        String cmp = rightSeq.getStringValue();\n\t\t        if(cmp.length() < NativeTextEngine.MAX_WORD_LENGTH)\n\t\t            nodes = useFulltextIndex(cmp, nodes, docs);\n\t\t        \n\t\t        // now compare the input node set to the search expression\n\t\t\t\tresult =\n\t\t\t\t\tcontext.getBroker().getNodesEqualTo(nodes, docs, relation, truncation, cmp, getCollator(contextSequence));\n\t\n\t\t\t} else {\n\t\t\t    \n\t\t\t    // no usable index found. Fall back to a sequential scan of the nodes\n\t\t\t    result =\n\t\t\t\t\tcontext.getBroker().getNodesEqualTo(nodes, docs, relation, truncation, rightSeq.getStringValue(), \n\t\t\t\t\t        getCollator(contextSequence));\n\t\t\t}\n        */\n\t    \t\n/* end */\t}\n\n\t\t}\n\t    else\n\t    {\n\t    \t//no range index defined on the nodes in this sequence, so fallback to nodeSetCompare\n            if(context.getProfiler().isEnabled())\n            {\n                context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"falling back to nodeSetCompare (no index available)\");\n            }\n\n            return(nodeSetCompare(nodes, contextSequence));\n\t\t}\n        \n\t\t// can this result be cached? Don't cache if the result depends on local variables.\n\t    boolean canCache = contextSequence instanceof NodeSet && \n\t    \t!Dependency.dependsOnVar(getLeft()) && \n\t    \t!Dependency.dependsOnVar(getRight());\n\t\tif(canCache)\n\t\t{\n\t\t\tcached = new CachedResult((NodeSet)contextSequence, result);\n\t\t}\n\t\t\n\t\t//return the result of the range index lookup(s) :-)\n\t\treturn result;\n\t}","id":26133,"modified_method":"/**\n\t * Optimized implementation: first checks if a range index is defined\n\t * on the nodes in the left argument. If that fails, check if we can use\n\t * the fulltext index to speed up the search. Otherwise, fall back to\n\t * {@link #nodeSetCompare(NodeSet, Sequence)}.\n\t */\n\tprotected Sequence quickNodeSetCompare(Sequence contextSequence) throws XPathException {\n\t\t\n\t\t/* TODO think about optimising fallback to NodeSetCompare() in the for loop!!!\n\t\t * At the moment when we fallback to NodeSetCompare() we are in effect throwing away any nodes\n\t\t * we have already processed in quickNodeSetCompare() and reprocessing all the nodes in NodeSetCompare().\n\t\t * Instead - Could we create a NodeCompare() (based on NodeSetCompare() code) to only compare a single node and then union the result?\n\t\t * - deliriumsky \n\t\t */\n\t\t\n\t\t/* TODO think about caching of results in this function...\n\t\t * also examine and check if correct (line near the end) -\n\t\t * \t boolean canCache = contextSequence instanceof NodeSet && (getRight().getDependencies() & Dependency.VARS) == 0 && (getLeft().getDependencies() & Dependency.VARS) == 0;\n\t\t *  - deliriumsky \n\t\t */\n\t\t\n        // if the context sequence hasn't changed we can return a cached result\n\t\tif(cached != null && cached.isValid(contextSequence))\n\t\t{\n            if(context.getProfiler().isEnabled())\n            {\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"OPTIMIZATION\", \"Returned cached result\");\n            }\n            \n\t\t\treturn(cached.getResult());\n\t\t}\t\t\n      \n\t\t//get the NodeSet on the left\n\t\tNodeSet nodes = (NodeSet) getLeft().eval(contextSequence);\t\t\n        if(!(nodes instanceof VirtualNodeSet) && nodes.isEmpty()) //nothing on the left, so nothing to do\n        {\n            return(Sequence.EMPTY_SEQUENCE);\n        }\n    \n        //get the Sequence on the right\n\t\tSequence rightSeq = getRight().eval(contextSequence);\n\t\tif(rightSeq.isEmpty())\t//nothing on the right, so nothing to do\n\t\t{\n            return(Sequence.EMPTY_SEQUENCE);\n\t\t}\n        \n        \n\t\t//Holds the result\n\t\tNodeSet result = null;\n\t\t\n\t\t//get the type of a possible index\n\t\tint indexType = nodes.getIndexType();\n\t\t\n\t\t//See if we have a range index defined on the nodes in this sequence\n        //TODO : use isSubType ??? -pb\n\t    if(indexType != Type.ITEM)\n\t    {\n\t    \t//Get the documents from the node set\n\t\t\tDocumentSet docs = nodes.getDocumentSet();\n\t\n\t\t\t//Iterate through the right hand sequence\n\t\t\tfor(SequenceIterator itRightSeq = rightSeq.iterate(); itRightSeq.hasNext();)\n\t    \t{\n\t\t\t\t//Get the index Key\n\t\t\t\tItem key = itRightSeq.nextItem().atomize();\n\t\t\t\t\n\t\t\t\t//if key has truncation convert to string\n\t\t        if(truncation != Constants.TRUNC_NONE)\n\t\t        {\n\t\t        \t//truncation is only possible on strings\n\t\t        \tkey = key.convertTo(Type.STRING);\n\t\t        }\n\t\t        //else if key is not the same type as the index\n                //TODO : use isSubType ??? -pb\n\t\t        else if(key.getType() != indexType)\n\t\t        {\n\t\t        \t//try and convert the key to the index type \n\t            \ttry\n\t\t\t\t\t{\n\t            \t\tkey = key.convertTo(indexType);\n\t\t\t\t\t}\n\t            \tcatch(XPathException xpe)\n\t\t\t\t\t{\n\t\t\t        \t//Could not convert the key to a suitable type for the index, fallback to nodeSetCompare()\n\t\t                if(context.getProfiler().isEnabled())\n\t\t                {\n\t\t                    context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"Falling back to nodeSetCompare (\" + xpe.getMessage() + \")\");\n\t\t                }\n\t\t                \n\t\t\t            return nodeSetCompare(nodes, contextSequence);\n\t\t\t\t\t}\n\t\t        }\n\t\t        \n\t\t        // If key implements org.exist.storage.Indexable, we can use the index\n\t\t        if(key instanceof Indexable && Type.subTypeOf(key.getType(), indexType))\n\t\t        {\n\t\t        \tif(truncation == Constants.TRUNC_NONE)\n\t\t        \t{\n\t\t\t        \t//key without truncation, find key\n\t                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"OPTIMIZATION\", \"Using value index '\" + context.getBroker().getValueIndex().toString() + \n\t                    \t\t\"' to find key '\" + Type.getTypeName(key.getType()) + \"(\" + key.getStringValue() + \")'\");\n\t                    \n\t                    NodeSet ns = context.getBroker().getValueIndex().find(relation, docs, nodes, (Indexable)key);\n\t                    if(result == null)\t//if first iteration\n\t                    {\n\t                    \tresult = ns;\n\t                    }\n\t                    else\n\t                    {\n\t                    \tresult = result.union(ns);\n\t                    }\n\t                }\n\t\t        \telse\n\t\t        \t{\n\t\t\t        \t//key with truncation, match key\n\t                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"OPTIMIZATION\", \"Using value index '\" + context.getBroker().getValueIndex().toString() + \n\t                    \t\t\"' to match key '\" + Type.getTypeName(key.getType()) + \"(\" + key.getStringValue() + \")'\");\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNodeSet ns = context.getBroker().getValueIndex().match(docs, nodes, key.getStringValue().replace('%', '*'), DBBroker.MATCH_WILDCARDS);\n\t\t\t\t\t\t\tif(result == null) //if first iteration\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tresult = ns;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tresult = result.union(ns);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (EXistException e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new XPathException(getASTNode(), e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t        }\n\t\t        else\n\t\t        {\n\t\t        \t//the datatype of our key does not\n\t\t        \t//implement org.exist.storage.Indexable or is not of the correct type\n\t                if(context.getProfiler().isEnabled())\n\t                {\n\t                    context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"Falling back to nodeSetCompare (key is of type: \" + Type.getTypeName(key.getType()) + \")\");\n\t                }\n                    return(nodeSetCompare(nodes, contextSequence));\n\t            }\n        \n\t\t//removed by Pierrick Brihaye\n        //REMOVED : a *general* comparison should not be dependant of the settings of a fulltext index\n        /*\n\t    } else if (key.getType() == Type.ATOMIC || Type.subTypeOf(key.getType(), Type.STRING)) {\n\t        if (!nodes.hasMixedContent() && relation == Constants.EQ \n\t            && nodes.hasTextIndex()) {\n\t\t        // we can use the fulltext index\n\t\t        String cmp = rightSeq.getStringValue();\n\t\t        if(cmp.length() < NativeTextEngine.MAX_WORD_LENGTH)\n\t\t            nodes = useFulltextIndex(cmp, nodes, docs);\n\t\t        \n\t\t        // now compare the input node set to the search expression\n\t\t\t\tresult =\n\t\t\t\t\tcontext.getBroker().getNodesEqualTo(nodes, docs, relation, truncation, cmp, getCollator(contextSequence));\n\t\n\t\t\t} else {\n\t\t\t    \n\t\t\t    // no usable index found. Fall back to a sequential scan of the nodes\n\t\t\t    result =\n\t\t\t\t\tcontext.getBroker().getNodesEqualTo(nodes, docs, relation, truncation, rightSeq.getStringValue(), \n\t\t\t\t\t        getCollator(contextSequence));\n\t\t\t}\n        */\n\t    \t\n/* end */\t}\n\n\t\t}\n\t    else\n\t    {\n\t    \t//no range index defined on the nodes in this sequence, so fallback to nodeSetCompare\n            if(context.getProfiler().isEnabled())\n            {\n                context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"OPTIMIZATION FALLBACK\", \"falling back to nodeSetCompare (no index available)\");\n            }\n\n            return(nodeSetCompare(nodes, contextSequence));\n\t\t}\n        \n\t\t// can this result be cached? Don't cache if the result depends on local variables.\n\t    boolean canCache = contextSequence instanceof NodeSet && \n\t    \t!Dependency.dependsOnVar(getLeft()) && \n\t    \t!Dependency.dependsOnVar(getRight());\n\t\tif(canCache)\n\t\t{\n\t\t\tcached = new CachedResult((NodeSet)contextSequence, result);\n\t\t}\n\t\t\n\t\t//return the result of the range index lookup(s) :-)\n\t\treturn result;\n\t}","commit_id":"307c3bcbf7a543b265a3db193680f417fe3850f3","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem)\n\t\tthrows XPathException {\n\t\tif(contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\t\tSequence seq = getArgument(0).eval(contextSequence);\n\t\tif(seq.getLength() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tString value; \n\t\ttry {\n\t\t\tvalue = URIUtils.iriToURI(seq.getStringValue());\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new XPathException(e.getMessage());\n\t\t}\n\t\treturn new StringValue(value);\n\t}","id":26134,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        \n\t\tif(contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n        \n        Sequence result;\n\t\tSequence seq = getArgument(0).eval(contextSequence);\n\t\tif(seq.getLength() == 0)\n\t\t\tresult = Sequence.EMPTY_SEQUENCE;\n        else {\n    \t\tString value; \n    \t\ttry {\n    \t\t\tvalue = URIUtils.iriToURI(seq.getStringValue());\n    \t\t} catch (UnsupportedEncodingException e) {\n    \t\t\tthrow new XPathException(e.getMessage());\n    \t\t}\n    \t\tresult = new StringValue(value);\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;\n        \n\t}","commit_id":"f62ee12db6af8b804509528509adf32712758877","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\n\t\t\tthrows XPathException {\n\t\tMap prefixes = new HashMap();\n\t\tNodeValue node = (NodeValue) args[0].itemAt(0);\n\t\tif (node.getImplementationType() == NodeValue.PERSISTENT_NODE) {\n\t\t\tNodeProxy proxy = (NodeProxy) node;\n\t\t\tNodeSet ancestors = proxy.getAncestors(false, true);\n\t\t\tfor (Iterator i = ancestors.iterator(); i.hasNext(); ) {\n\t\t\t\tproxy = (NodeProxy) i.next();\n\t\t\t\tcollectNamespacePrefixes((ElementImpl) proxy.getNode(), prefixes);\n\t\t\t}\n\t\t} else {\n\t\t\tNode next = (Node) node;\n\t\t\tdo {\n\t\t\t\tcollectNamespacePrefixes((Element) next, prefixes);\n\t\t\t\tnext = next.getParentNode();\n\t\t\t} while (next != null && next.getNodeType() == Node.ELEMENT_NODE);\n\t\t}\n\t\t\n\t\tValueSequence result = new ValueSequence();\n\t\tString prefix;\n\t\tfor (Iterator i = prefixes.keySet().iterator(); i.hasNext(); ) {\n\t\t\tprefix = (String) i.next();\n\t\t\tresult.add(new StringValue(prefix));\n\t\t}\n\t\treturn result;\n\t}","id":26135,"modified_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\tthrows XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n        }\n        \n\t\tMap prefixes = new HashMap();\n\t\tNodeValue node = (NodeValue) args[0].itemAt(0);\n\t\tif (node.getImplementationType() == NodeValue.PERSISTENT_NODE) {\n\t\t\tNodeProxy proxy = (NodeProxy) node;\n\t\t\tNodeSet ancestors = proxy.getAncestors(false, true);\n\t\t\tfor (Iterator i = ancestors.iterator(); i.hasNext(); ) {\n\t\t\t\tproxy = (NodeProxy) i.next();\n\t\t\t\tcollectNamespacePrefixes((ElementImpl) proxy.getNode(), prefixes);\n\t\t\t}\n\t\t} else {\n\t\t\tNode next = (Node) node;\n\t\t\tdo {\n\t\t\t\tcollectNamespacePrefixes((Element) next, prefixes);\n\t\t\t\tnext = next.getParentNode();\n\t\t\t} while (next != null && next.getNodeType() == Node.ELEMENT_NODE);\n\t\t}\n\t\t\n\t\tValueSequence result = new ValueSequence();\n\t\tString prefix;\n\t\tfor (Iterator i = prefixes.keySet().iterator(); i.hasNext(); ) {\n\t\t\tprefix = (String) i.next();\n\t\t\tresult.add(new StringValue(prefix));\n\t\t}\n\t\t\n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;          \n\t}","commit_id":"f62ee12db6af8b804509528509adf32712758877","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\n\t\t\tthrows XPathException {\n\t\tif(args[0].getLength() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tAtomicValue srch = args[1].itemAt(0).atomize();\n\t\tCollator collator;\n\t\tif(getSignature().getArgumentCount() == 3) {\n\t\t\tString collation = args[2].getStringValue();\n\t\t\tcollator = context.getCollator(collation);\n\t\t} else\n\t\t\tcollator = context.getDefaultCollator();\n\t\tSequence result = new ValueSequence();\n\t\tint j = 1;\n\t\tfor (SequenceIterator i = args[0].iterate(); i.hasNext(); j++) {\n\t\t\tAtomicValue next = i.nextItem().atomize();\n\t\t\tif(GeneralComparison.compareAtomic(collator, next, srch, context.isBackwardsCompatible(),\n\t\t\t\t\tConstants.TRUNC_NONE, Constants.EQ))\n\t\t\t\tresult.add(new IntegerValue(j));\n\t\t}\n\t\treturn result;\n\t}","id":26136,"modified_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\tthrows XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n        }\n        \n        Sequence result;\n\t\tif (args[0].getLength() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n        else {\n    \t\tAtomicValue srch = args[1].itemAt(0).atomize();\n    \t\tCollator collator;\n    \t\tif (getSignature().getArgumentCount() == 3) {\n    \t\t\tString collation = args[2].getStringValue();\n    \t\t\tcollator = context.getCollator(collation);\n    \t\t} else\n    \t\t\tcollator = context.getDefaultCollator();\n    \t\tresult = new ValueSequence();\n    \t\tint j = 1;\n    \t\tfor (SequenceIterator i = args[0].iterate(); i.hasNext(); j++) {\n    \t\t\tAtomicValue next = i.nextItem().atomize();\n    \t\t\tif (GeneralComparison.compareAtomic(collator, next, srch, context.isBackwardsCompatible(),\n    \t\t\t\t\tConstants.TRUNC_NONE, Constants.EQ))\n                    //TODO : break here ? -pb\n    \t\t\t\tresult.add(new IntegerValue(j));\n    \t\t}    \t\t\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result; \n        \n\t}","commit_id":"f62ee12db6af8b804509528509adf32712758877","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n\t\tSequence seq1 = getArgument(0).eval(contextSequence, contextItem);\n\t\tSequence seq2 = getArgument(2).eval(contextSequence, contextItem);\n\t\tif (seq1.getLength() == 0) return seq2;\n\t\tif (seq2.getLength() == 0) return seq1;\n\t\tint pos = \n\t\t\t((DoubleValue)getArgument(1).eval(contextSequence, contextItem).convertTo(Type.DOUBLE)).getInt();\n\t\tpos--;\n\t\tSequence result = new ValueSequence();\n\t\tif (pos <= 0) {\n\t\t\tresult.addAll(seq2);\n\t\t\tresult.addAll(seq1);\n\t\t} else if (pos >= seq1.getLength()) {\n\t\t\tresult.addAll(seq1);\n\t\t\tresult.addAll(seq2);\n\t\t} else {\n\t\t\tfor (int i=0; i<seq1.getLength(); i++) {\n\t\t\t\tif (i == pos) result.addAll(seq2);\n\t\t\t\tresult.add(seq1.itemAt(i));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":26137,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        \n        Sequence result;\n\t\tSequence seq1 = getArgument(0).eval(contextSequence, contextItem);\n\t\tSequence seq2 = getArgument(2).eval(contextSequence, contextItem);\n\t\tif (seq1.getLength() == 0)\n\t\t    result = seq2;\n        else if (seq2.getLength() == 0) \n            result = seq1;\n        else {\n    \t\tint pos = \n    \t\t\t((DoubleValue)getArgument(1).eval(contextSequence, contextItem).convertTo(Type.DOUBLE)).getInt();\n    \t\tpos--;\n    \t\tresult = new ValueSequence();\n    \t\tif (pos <= 0) {\n    \t\t\tresult.addAll(seq2);\n    \t\t\tresult.addAll(seq1);\n    \t\t} else if (pos >= seq1.getLength()) {\n    \t\t\tresult.addAll(seq1);\n    \t\t\tresult.addAll(seq2);\n    \t\t} else {\n    \t\t\tfor (int i=0; i<seq1.getLength(); i++) {\n    \t\t\t\tif (i == pos) result.addAll(seq2);\n    \t\t\t\tresult.add(seq1.itemAt(i));\n    \t\t\t}\n    \t\t}\n        }\n\n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;  \n        \n\t}","commit_id":"f62ee12db6af8b804509528509adf32712758877","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem)\n\t\tthrows XPathException {\n\t\tSequence seq = getArgument(0).eval(contextSequence, contextItem);\n\t\tIntegerValue posArg = (IntegerValue)\n\t\t\tgetArgument(1).eval(contextSequence, contextItem).convertTo(Type.INTEGER);\n\t\tlong pos = posArg.getValue();\n\t\tif(pos < 1 || pos > seq.getLength())\n\t\t\tthrow new XPathException(\"Invalid position: \" + pos);\n\t\tItem item = seq.itemAt((int)pos - 1);\n\t\tif(item == null) {\n\t\t\tLOG.debug(\"Item is null: \" + seq.getClass().getName() + \"; len = \" + seq.getLength());\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\t}\n\t\treturn item.toSequence();\n\t}","id":26138,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        \n\t\tSequence seq = getArgument(0).eval(contextSequence, contextItem);\n\t\tIntegerValue posArg = (IntegerValue)\n\t\t\tgetArgument(1).eval(contextSequence, contextItem).convertTo(Type.INTEGER);\n\t\tlong pos = posArg.getValue();\n\t\tif (pos < 1 || pos > seq.getLength())\n\t\t\tthrow new XPathException(\"Invalid position: \" + pos);\n\t\tItem item = seq.itemAt((int)pos - 1);\n        \n        Sequence result;\n\t\tif(item == null) {\n            //TODO : throw an exception ? -pb\n\t\t\tLOG.debug(\"Item is null: \" + seq.getClass().getName() + \"; len = \" + seq.getLength());\n\t\t\tresult = Sequence.EMPTY_SEQUENCE;\n\t\t}\n        else result = item.toSequence();\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;          \n\t}","commit_id":"f62ee12db6af8b804509528509adf32712758877","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem)\n\t\tthrows XPathException {\n\t\tif (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\t\tif (!(Type.subTypeOf(contextSequence.getItemType(), Type.NODE)))\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tString lang =\n\t\t\tgetArgument(0)\n\t\t\t\t.eval(contextSequence)\n\t\t\t\t.getStringValue();\n\t\tQName qname = new QName(\"lang\", context.getURIForPrefix(\"xml\"), \"xml\");\n\t\tNodeSet attribs = context.getBroker().getElementIndex().getAttributesByName(contextSequence.toNodeSet().getDocumentSet(), qname, null);\n\t\tNodeSet temp = new ExtArrayNodeSet();\n\t\tNodeProxy p;\n\t\tString langValue;\n\t\tint hyphen;\n\t\tboolean include;\n\t\tfor (Iterator i = attribs.iterator(); i.hasNext();) {\n\t\t\tinclude = false;\n\t\t\tp = (NodeProxy) i.next();\n\t\t\tlangValue = p.getNodeValue();\n\t\t\tinclude = lang.equalsIgnoreCase(langValue);\n\t\t\tif (!include) {\n\t\t\t\thyphen = langValue.indexOf('-');\n\t\t\t\tif (hyphen != Constants.STRING_NOT_FOUND) {\n\t\t\t\t\tlangValue = langValue.substring(0, hyphen);\n\t\t\t\t\tinclude = lang.equalsIgnoreCase(langValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (include) {\n                long parentID = XMLUtil.getParentId(p);                \n\t\t\t\tif (parentID != NodeProxy.DOCUMENT_NODE_GID) {\n                    NodeProxy parent = new NodeProxy(p.getDocument(), parentID);\n                    parent.setNodeType(Node.ELEMENT_NODE);\n\t\t\t\t\ttemp.add(parent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (temp.getLength() > 0) {\n\t\t\tNodeSet result =\n\t\t\t\t((NodeSet) contextSequence).selectAncestorDescendant(\n\t\t\t\t\ttemp,\n\t\t\t\t\tNodeSet.DESCENDANT,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse);\n\t\t\tfor (Iterator i = result.iterator(); i.hasNext();) {\n\t\t\t\tp = (NodeProxy) i.next();\n\t\t\t\tp.addContextNode(p);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn Sequence.EMPTY_SEQUENCE;\n\t}","id":26139,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        \n\t\tif (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n        \n        Sequence result;\n\t\tif (!(Type.subTypeOf(contextSequence.getItemType(), Type.NODE)))\n            result = Sequence.EMPTY_SEQUENCE;\n        else {\n            String lang = getArgument(0).eval(contextSequence).getStringValue();\n            QName qname = new QName(\"lang\", context.getURIForPrefix(\"xml\"), \"xml\");\n    \t\tNodeSet attribs = context.getBroker().getElementIndex().getAttributesByName(contextSequence.toNodeSet().getDocumentSet(), qname, null);\n    \t\tNodeSet temp = new ExtArrayNodeSet();\n    \t\tNodeProxy p;\n    \t\tString langValue;\n    \t\tint hyphen;\n    \t\tboolean include;\n    \t\tfor (Iterator i = attribs.iterator(); i.hasNext();) {\n    \t\t\tinclude = false;\n    \t\t\tp = (NodeProxy) i.next();\n    \t\t\tlangValue = p.getNodeValue();\n    \t\t\tinclude = lang.equalsIgnoreCase(langValue);\n    \t\t\tif (!include) {\n    \t\t\t\thyphen = langValue.indexOf('-');\n    \t\t\t\tif (hyphen != Constants.STRING_NOT_FOUND) {\n    \t\t\t\t\tlangValue = langValue.substring(0, hyphen);\n    \t\t\t\t\tinclude = lang.equalsIgnoreCase(langValue);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif (include) {\n                    long parentID = XMLUtil.getParentId(p);                \n    \t\t\t\tif (parentID != NodeProxy.DOCUMENT_NODE_GID) {\n                        NodeProxy parent = new NodeProxy(p.getDocument(), parentID);\n                        parent.setNodeType(Node.ELEMENT_NODE);\n    \t\t\t\t\ttemp.add(parent);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tif (temp.getLength() > 0) {\n    \t\t\tresult =\n    \t\t\t\t((NodeSet) contextSequence).selectAncestorDescendant(\n    \t\t\t\t\ttemp,\n    \t\t\t\t\tNodeSet.DESCENDANT,\n    \t\t\t\t\ttrue,\n    \t\t\t\t\tfalse);\n    \t\t\tfor (Iterator i = ((NodeSet)result).iterator(); i.hasNext();) {\n    \t\t\t\tp = (NodeProxy) i.next();\n    \t\t\t\tp.addContextNode(p);\n    \t\t\t}                \n    \t\t}\n            else result = Sequence.EMPTY_SEQUENCE;\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;          \n\t}","commit_id":"f62ee12db6af8b804509528509adf32712758877","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem)\n\t\tthrows XPathException {\n\t    final int len = contextSequence.getLength();\n\t\tif(contextSequence == null || len == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\treturn new IntegerValue(len);\n\t}","id":26140,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        \n        Sequence result;\n\t\tif (contextSequence == null)\n            result = Sequence.EMPTY_SEQUENCE;\n        else {\n            final int len = contextSequence.getLength();\n            if (len == 0) \n                result = Sequence.EMPTY_SEQUENCE;\n            else\n                result = new IntegerValue(len);\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;           \n\t\t\n\t}","commit_id":"f62ee12db6af8b804509528509adf32712758877","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if(contextItem != null)\n            contextSequence = contextItem.toSequence();\n        Item item = null;\n        // check if the node is passed as an argument or should be taken from\n        // the context sequence\n        if(getArgumentCount() > 0) {\n            Sequence seq = getArgument(0).eval(contextSequence);\n            if(seq.getLength() > 0)\n                item = seq.itemAt(0);\n        } else {\n            if(contextSequence.getLength() > 0)\n                item = contextSequence.itemAt(0);\n            else\n                throw new XPathException(getASTNode(), \"undefined context item\");\n        }\n        if(item == null)\n            return Sequence.EMPTY_SEQUENCE;\n        if(!Type.subTypeOf(item.getType(), Type.NODE))\n            throw new XPathException(getASTNode(), \"context item is not a node; got: \" +\n                    Type.getTypeName(item.getType()));\n        \n        Node n = ((NodeValue)item).getNode();\n        switch(n.getNodeType()) {\n            case Node.ELEMENT_NODE:\n            case Node.ATTRIBUTE_NODE:\n                return new StringValue(n.getLocalName());\n            case Node.PROCESSING_INSTRUCTION_NODE:\n                return new StringValue(((ProcessingInstruction)n).getTarget());\n            default:\n                return new StringValue(\"\");\n        }\n    }","id":26141,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        \n        if(contextItem != null)\n            contextSequence = contextItem.toSequence();\n                \n        Item item = null;\n        // check if the node is passed as an argument or should be taken from\n        // the context sequence\n        if(getArgumentCount() > 0) {\n            Sequence seq = getArgument(0).eval(contextSequence);\n            if (seq.getLength() > 0)\n                item = seq.itemAt(0);\n        } else {\n            if (contextSequence.getLength() > 0)\n                item = contextSequence.itemAt(0);\n            else\n                throw new XPathException(getASTNode(), \"undefined context item\");\n        }\n        \n        Sequence result;\n        if (item == null)\n            result = Sequence.EMPTY_SEQUENCE;\n        else {\n            if(!Type.subTypeOf(item.getType(), Type.NODE))\n                throw new XPathException(getASTNode(), \"context item is not a node; got: \" +\n                        Type.getTypeName(item.getType()));\n            \n            Node n = ((NodeValue)item).getNode();\n            switch(n.getNodeType()) {\n                case Node.ELEMENT_NODE:\n                case Node.ATTRIBUTE_NODE:\n                    result = new StringValue(n.getLocalName());\n                case Node.PROCESSING_INSTRUCTION_NODE:\n                    result = new StringValue(((ProcessingInstruction)n).getTarget());\n                default:\n                    result = new StringValue(\"\");\n            }\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;          \n    }","commit_id":"f62ee12db6af8b804509528509adf32712758877","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * @param contextSequence\n     * @param contextItem\n     * @param stringArg\n     * @return\n\t * @throws XPathException\n     */\n    private Sequence evalWithIndex(Sequence contextSequence, Item contextItem, Sequence input) throws XPathException {\n        String pattern = translateRegexp(getArgument(1).eval(contextSequence, contextItem).getStringValue());\n        NodeSet nodes = input.toNodeSet();\n        \n        int flags = 0; \n        boolean caseSensitive = true;\n        if(getSignature().getArgumentCount() == 3) {\n            String flagsArg = getArgument(2).eval(contextSequence, contextItem).getStringValue();\n            caseSensitive = (flagsArg.indexOf('i') == Constants.STRING_NOT_FOUND);\n            flags = parseFlags(flagsArg);\n        }\n        \n        // get the type of a possible index\n\t\tint indexType = nodes.getIndexType();\n\t\tif(Type.subTypeOf(indexType, Type.STRING)) {\n\t\t    DocumentSet docs = nodes.getDocumentSet();\n\t\t    try {\n\t\t    \tif (context.isProfilingEnabled())\n\t\t    \t\tcontext.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"Using index for fn:matches\", \"Regex: \" + pattern);\n\t\t\t\treturn context.getBroker().getValueIndex().match(docs, nodes, pattern, \n\t\t\t\t\t\tDBBroker.MATCH_REGEXP, flags, caseSensitive);\n\t\t\t} catch (EXistException e) {\n\t\t\t\tthrow new XPathException(getASTNode(), e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t    ExtArrayNodeSet result = new ExtArrayNodeSet();\n\t\t    for(Iterator i = nodes.iterator(); i.hasNext(); ) {\n\t\t        NodeProxy node = (NodeProxy) i.next();\n\t\t        if(match(node.getStringValue(), pattern, flags))\n\t\t            result.add(node);\n\t\t    }\n\t\t    return result;\n\t\t}\n    }","id":26142,"modified_method":"/**\n     * @param contextSequence\n     * @param contextItem\n     * @param stringArg\n     * @return\n\t * @throws XPathException\n     */\n    private Sequence evalWithIndex(Sequence contextSequence, Item contextItem, Sequence input) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }  \n        \n        boolean caseSensitive = true;\n        int flags = 0;       \n        if(getSignature().getArgumentCount() == 3) {\n            String flagsArg = getArgument(2).eval(contextSequence, contextItem).getStringValue();\n            caseSensitive = (flagsArg.indexOf('i') == Constants.STRING_NOT_FOUND);\n            flags = parseFlags(flagsArg);\n        }\n        \n        Sequence result;\n        String pattern = translateRegexp(getArgument(1).eval(contextSequence, contextItem).getStringValue());\n        NodeSet nodes = input.toNodeSet();\n        // get the type of a possible index\n\t\tint indexType = nodes.getIndexType();\n\t\tif(Type.subTypeOf(indexType, Type.STRING)) {\n\t\t    DocumentSet docs = nodes.getDocumentSet();\n\t\t    try {                \n                NativeValueIndex index = context.getBroker().getValueIndex(); \n                //TODO : check index' case compatibility with flags' one ? -pb \n\t\t    \tif (context.isProfilingEnabled())\n\t\t    \t\tcontext.getProfiler().message(this, Profiler.OPTIMIZATIONS, \"Using index \" + index.toString(), \"Regex: \" + pattern);\n                result = index.match(docs, nodes, pattern, DBBroker.MATCH_REGEXP, flags, caseSensitive);\n\t\t\t} catch (EXistException e) {\n\t\t\t\tthrow new XPathException(getASTNode(), e.getMessage(), e);\n\t\t\t}\n\t\t} else {\n\t\t    result = new ExtArrayNodeSet();\n\t\t    for(Iterator i = nodes.iterator(); i.hasNext(); ) {\n\t\t        NodeProxy node = (NodeProxy) i.next();\n\t\t        if (match(node.getStringValue(), pattern, flags))\n\t\t            result.add(node);\n\t\t    }          \n\t\t}\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;           \n        \n    }","commit_id":"f62ee12db6af8b804509528509adf32712758877","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem)\n\t\tthrows XPathException {\n\t    if(contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\t    \n\t\tSequence input = getArgument(0).eval(contextSequence, contextItem);\n\t\tif(input.getLength() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n        \n\t\tif(inPredicate && (getDependencies() & Dependency.CONTEXT_ITEM) == 0) {\n\t\t    return evalWithIndex(contextSequence, contextItem, input);\n        } else {\n\t\t    return evalGeneric(contextSequence, contextItem, input);\n        }\n\t}","id":26143,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        \n\t    if (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\t    \n        Sequence result;\n\t\tSequence input = getArgument(0).eval(contextSequence, contextItem);\n\t\tif (input.getLength() == 0)\n            result = Sequence.EMPTY_SEQUENCE;        \n        else if (inPredicate && !Dependency.dependsOn(getDependencies(), Dependency.CONTEXT_ITEM)) {\n            if (context.isProfilingEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"\", \"Index evaluation\");            \n            result = evalWithIndex(contextSequence, contextItem, input);\n        } else {\n            if (context.isProfilingEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATION_FLAGS, \"\", \"Generic evaluation\");            \n            result = evalGeneric(contextSequence, contextItem, input);\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;          \n\t}","commit_id":"f62ee12db6af8b804509528509adf32712758877","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem)\n\t\tthrows XPathException {\n\t\tif (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\t\tSequence arg = getArgument(0).eval(contextSequence, contextItem);\n\t\tif(arg.getLength() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tCollator collator = getCollator(contextSequence, contextItem, 2);\n\t\tSequenceIterator iter = arg.unorderedIterator();\n\t\tItem nextItem;\n\t\tAtomicValue nextValue;\n\t\tnextItem = iter.nextItem();\n\t\tnextValue = nextItem.atomize();\n\t\tAtomicValue max = nextValue;\n\t\tif(max.getType() == Type.ATOMIC)\n\t\t\tmax = max.convertTo(Type.DOUBLE);\t\t\n\t\twhile(iter.hasNext()) {\n\t\t\tnextItem = iter.nextItem();\n\t\t\tnextValue = nextItem.atomize();\n\t\t\tif(nextValue.getType() == Type.ATOMIC)\n\t\t\t\tnextValue = nextValue.convertTo(Type.DOUBLE);\n\t\t\tif(Type.subTypeOf(nextValue.getType(), Type.NUMBER) &&\n\t\t\t\t((NumericValue)nextValue).isNaN())\n\t\t\t\treturn DoubleValue.NaN;\n\t\t\t\t\n\t\t\tmax = max.max(collator, nextValue);\n\t\t}\n//\t\tTODO : return a ComputableValue ?\n\t\treturn max;\n\t}","id":26144,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        } \n        \n\t\tif (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n        \n        Sequence result;\n\t\tSequence arg = getArgument(0).eval(contextSequence, contextItem);\n\t\tif(arg.getLength() == 0)\n            result = Sequence.EMPTY_SEQUENCE;\n        else {\n    \t\tCollator collator = getCollator(contextSequence, contextItem, 2);\n    \t\tSequenceIterator iter = arg.unorderedIterator();            \n            Item nextItem = iter.nextItem();\n            AtomicValue nextValue = nextItem.atomize();\n            //TODO : use sub-type method here that eventually will throw an exception ? -pb\n    \t\tif(nextValue.getType() == Type.ATOMIC)\n                nextValue = nextValue.convertTo(Type.DOUBLE);\n            ComputableValue max = (ComputableValue)nextValue;\n    \t\twhile(iter.hasNext()) {\n    \t\t\tnextItem = iter.nextItem();\n    \t\t\tnextValue = nextItem.atomize();\n                //TODO : use sub-type method here that eventually will throw an exception ? -pb\n    \t\t\tif (nextValue.getType() == Type.ATOMIC)\n    \t\t\t\tnextValue = nextValue.convertTo(Type.DOUBLE);\n                //TODO : use ComputableValue.max with the collator ! -pb\n    \t\t\tif (Type.subTypeOf(nextValue.getType(), Type.NUMBER) && ((NumericValue)nextValue).isNaN()) {\n    \t\t\t    result = DoubleValue.NaN;\n                    break;\n                }\t\n                //Ugly type-casting -pb\n                max = (ComputableValue) max.max(collator, nextValue);\n    \t\t}           \n            result = max;\n        }\n\n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;   \n        \n\t}","commit_id":"f62ee12db6af8b804509528509adf32712758877","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem)\n\t\tthrows XPathException {\n\t\tif (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\t\tSequence arg = getArgument(0).eval(contextSequence, contextItem);\n\t\tif (arg.getLength() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tCollator collator = getCollator(contextSequence, contextItem, 2);\n\t\tSequenceIterator iter = arg.iterate();\n\t\tItem nextItem;\n\t\tAtomicValue nextValue;\n\t\tnextItem = iter.nextItem();\n\t\tnextValue = nextItem.atomize();\n\t\tAtomicValue min = nextValue;\n\t\twhile (iter.hasNext()) {\n\t\t\tnextItem = iter.nextItem();\n\t\t\tnextValue = nextItem.atomize();\n\t\t\tif (nextValue.getType() == Type.ATOMIC)\n\t\t\t\tnextValue = nextValue.convertTo(Type.DOUBLE);\n\t\t\tif (Type.subTypeOf(nextValue.getType(), Type.NUMBER)\n\t\t\t\t&& ((NumericValue) nextValue).isNaN())\n\t\t\t\treturn DoubleValue.NaN;\n\n\t\t\tmin = min.min(collator, nextValue);\n\t\t}\n//\t\tTODO : return a ComputableValue ?\n\t\treturn min;\n\t}","id":26145,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        \n\t\tif (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n        \n        Sequence result;\n\t\tSequence arg = getArgument(0).eval(contextSequence, contextItem);\n\t\tif (arg.getLength() == 0)\n\t\t\tresult = Sequence.EMPTY_SEQUENCE;\n        else {\n    \t\tCollator collator = getCollator(contextSequence, contextItem, 2);\n    \t\tSequenceIterator iter = arg.iterate();\n            Item nextItem = iter.nextItem();\n            AtomicValue nextValue = nextItem.atomize();\n            //TODO : use sub-type method here that eventually will throw an exception ? -pb\n            if (nextValue.getType() == Type.ATOMIC)\n                nextValue = nextValue.convertTo(Type.DOUBLE);            \n            ComputableValue min = (ComputableValue)nextValue;\n    \t\twhile (iter.hasNext()) {\n    \t\t\tnextItem = iter.nextItem();\n    \t\t\tnextValue = nextItem.atomize();\n                //TODO : use sub-type method here that eventually will throw an exception ? -pb\n    \t\t\tif (nextValue.getType() == Type.ATOMIC)\n    \t\t\t\tnextValue = nextValue.convertTo(Type.DOUBLE);\n                //TODO : use ComputableValue.max with the collector ! -pb\n    \t\t\tif (Type.subTypeOf(nextValue.getType(), Type.NUMBER) && ((NumericValue) nextValue).isNaN()) {\n    \t\t\t\tresult = DoubleValue.NaN;\n                    break;\n                }\n                //Ugly type-casting -pb\n    \t\t\tmin = (ComputableValue) min.min(collator, nextValue);\n            }           \n            result = min;\n        }\n    \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;   \n    }","commit_id":"f62ee12db6af8b804509528509adf32712758877","url":"https://github.com/eXist-db/exist"},{"original_method":"private boolean electPrimariesAndUnassignDanglingReplicas(RoutingAllocation allocation) {\n        boolean changed = false;\n        RoutingNodes routingNodes = allocation.routingNodes();\n        for (MutableShardRouting shardEntry : routingNodes.unassigned()) {\n            if (shardEntry.primary() && !shardEntry.assignedToNode()) {\n                boolean elected = false;\n                // primary and not assigned, go over and find a replica that is assigned and active (since it might be relocating)\n                for (RoutingNode routingNode : routingNodes) {\n\n                    for (MutableShardRouting shardEntry2 : routingNode) {\n                        if (shardEntry.shardId().equals(shardEntry2.shardId()) && shardEntry2.active()) {\n                            assert shardEntry2.assignedToNode();\n                            assert !shardEntry2.primary();\n\n                            changed = true;\n                            routingNodes.swapPrimaryFlag(shardEntry, shardEntry2);\n\n                            if (shardEntry2.relocatingNodeId() != null) {\n                                // its also relocating, make sure to move the other routing to primary\n                                RoutingNode node = routingNodes.node(shardEntry2.relocatingNodeId());\n                                if (node != null) {\n                                    for (MutableShardRouting shardRouting : node) {\n                                        if (shardRouting.shardId().equals(shardEntry2.shardId()) && !shardRouting.primary()) {\n                                            routingNodes.swapPrimaryFlag(shardRouting);\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n\n                            elected = true;\n                            break;\n                        }\n                    }\n\n                    if (elected) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // go over and remove dangling replicas that are initializing, but we couldn't elect primary ones...\n        List<ShardRouting> shardsToFail = null;\n        for (MutableShardRouting shardEntry : routingNodes.unassigned()) {\n            if (shardEntry.primary() && !shardEntry.assignedToNode()) {\n                for (RoutingNode routingNode : routingNodes) {\n                    for (MutableShardRouting shardEntry2 : routingNode) {\n                        if (shardEntry.shardId().equals(shardEntry2.shardId()) && !shardEntry2.active()) {\n                            changed = true;\n                            if (shardsToFail == null) {\n                                shardsToFail = new ArrayList<ShardRouting>();\n                            }\n                            shardsToFail.add(shardEntry2);\n                        }\n                    }\n                }\n            }\n        }\n        if (shardsToFail != null) {\n            for (ShardRouting shardToFail : shardsToFail) {\n                applyFailedShard(allocation, shardToFail, false);\n            }\n        }\n        return changed;\n    }","id":26146,"modified_method":"private boolean electPrimariesAndUnassignDanglingReplicas(RoutingAllocation allocation) {\n        boolean changed = false;\n        RoutingNodes routingNodes = allocation.routingNodes();\n        if (!routingNodes.hasUnassignedPrimaries()) {\n            // move out if we don't have unassigned primaries\n            return changed;\n        }\n        for (MutableShardRouting shardEntry : routingNodes.unassigned()) {\n            if (shardEntry.primary()) {\n                MutableShardRouting candidate = allocation.routingNodes().activeReplica(shardEntry);\n                if (candidate != null) {\n                    routingNodes.swapPrimaryFlag(shardEntry, candidate);\n                    if (candidate.relocatingNodeId() != null) {\n                        changed = true;\n                        // its also relocating, make sure to move the other routing to primary\n                        RoutingNode node = routingNodes.node(candidate.relocatingNodeId());\n                        if (node != null) {\n                            for (MutableShardRouting shardRouting : node) {\n                                if (shardRouting.shardId().equals(candidate.shardId()) && !shardRouting.primary()) {\n                                    routingNodes.swapPrimaryFlag(shardRouting);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // go over and remove dangling replicas that are initializing, but we couldn't elect primary ones...\n        List<ShardRouting> shardsToFail = null;\n        if (routingNodes.hasUnassignedPrimaries()) {\n            for (MutableShardRouting shardEntry : routingNodes.unassigned()) {\n                if (shardEntry.primary()) {\n                    for(MutableShardRouting routing : routingNodes.assignedShards(shardEntry)) {\n                        if (!routing.primary()) {\n                            changed = true;\n                            if (shardsToFail == null) {\n                                shardsToFail = new ArrayList<ShardRouting>();\n                            }\n                            shardsToFail.add(routing);\n                        }\n                    }\n                }\n            }\n            if (shardsToFail != null) {\n                for (ShardRouting shardToFail : shardsToFail) {\n                    applyFailedShard(allocation, shardToFail, false);\n                }\n            }\n        }\n        return changed;\n    }","commit_id":"314499cee078e42353b3373901368152d7c4fa4e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void activeShardsRemove(MutableShardRouting shard) {\n        Set<MutableShardRouting> replicaSet = assignedShards.get(shard.shardId());\n        if (replicaSet != null) {\n            if (replicaSet.contains(shard)) {\n                replicaSet.remove(shard);\n            } else {\n                assert false : \"Illegal state\";\n                Iterator<MutableShardRouting> iterator = replicaSet.iterator();\n                while(iterator.hasNext()) {\n                    if (shard.equals(iterator.next())) {\n                        iterator.remove();\n                    }\n                }\n            }\n        }\n    }","id":26147,"modified_method":"private void assignedShardsRemove(MutableShardRouting shard) {\n        Set<MutableShardRouting> replicaSet = assignedShards.get(shard.shardId());\n        if (replicaSet != null) {\n            if (replicaSet.contains(shard)) {\n                replicaSet.remove(shard);\n            } else {\n                assert false : \"Illegal state\";\n                Iterator<MutableShardRouting> iterator = replicaSet.iterator();\n                while(iterator.hasNext()) {\n                    if (shard.equals(iterator.next())) {\n                        iterator.remove();\n                    }\n                }\n            }\n        }\n    }","commit_id":"314499cee078e42353b3373901368152d7c4fa4e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Returns the active primary shard for the given ShardRouting or <code>null<\/code> if\n     * no primary is found or the primary is not active.\n     */\n    public MutableShardRouting activePrimary(ShardRouting shard) {\n        assert !shard.primary();\n        for (MutableShardRouting shardRouting : activeShards(shard.shardId())) {\n            if (shardRouting.primary()) {\n                if (shardRouting.active()) {\n                    return shardRouting;\n                }\n                break;\n            }\n        }\n        return null;\n    }","id":26148,"modified_method":"/**\n     * Returns the active primary shard for the given ShardRouting or <code>null<\/code> if\n     * no primary is found or the primary is not active.\n     */\n    public MutableShardRouting activePrimary(ShardRouting shard) {\n        assert !shard.primary();\n        for (MutableShardRouting shardRouting : assignedShards(shard.shardId())) {\n            if (shardRouting.primary() && shardRouting.active()) {\n                return shardRouting;\n            }\n        }\n        return null;\n    }","commit_id":"314499cee078e42353b3373901368152d7c4fa4e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void activeShardsAdd(MutableShardRouting shard) {\n        if (shard.unassigned()) {\n            // no unassigned\n            return;\n        }\n        Set<MutableShardRouting> replicaSet = assignedShards.get(shard.shardId());\n        if (replicaSet == null) {\n            replicaSet = new IdentityHashSet<MutableShardRouting>();\n            assignedShards.put(shard.shardId(), replicaSet);\n        }\n        replicaSet.add(shard);\n    }","id":26149,"modified_method":"private void assignedShardsAdd(MutableShardRouting shard) {\n        if (shard.unassigned()) {\n            // no unassigned\n            return;\n        }\n        Set<MutableShardRouting> replicaSet = assignedShards.get(shard.shardId());\n        if (replicaSet == null) {\n            replicaSet = new IdentityHashSet<MutableShardRouting>();\n            assignedShards.put(shard.shardId(), replicaSet);\n        }\n        replicaSet.add(shard);\n    }","commit_id":"314499cee078e42353b3373901368152d7c4fa4e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public RoutingNodes(ClusterState clusterState) {\n        this.metaData = clusterState.metaData();\n        this.blocks = clusterState.blocks();\n        this.routingTable = clusterState.routingTable();\n\n        Map<String, List<MutableShardRouting>> nodesToShards = newHashMap();\n        // fill in the nodeToShards with the \"live\" nodes\n        for (ObjectCursor<DiscoveryNode> cursor : clusterState.nodes().dataNodes().values()) {\n            nodesToShards.put(cursor.value.id(), new ArrayList<MutableShardRouting>());\n        }\n\n        // fill in the inverse of node -> shards allocated\n        // also fill replicaSet information\n        for (IndexRoutingTable indexRoutingTable : routingTable.indicesRouting().values()) {\n            for (IndexShardRoutingTable indexShard : indexRoutingTable) {\n                for (ShardRouting shard : indexShard) {\n                    // to get all the shards belonging to an index, including the replicas,\n                    // we define a replica set and keep track of it. A replica set is identified\n                    // by the ShardId, as this is common for primary and replicas.\n                    // A replica Set might have one (and not more) replicas with the state of RELOCATING.\n                    if (shard.assignedToNode()) {\n                        List<MutableShardRouting> entries = nodesToShards.get(shard.currentNodeId());\n                        if (entries == null) {\n                            entries = newArrayList();\n                            nodesToShards.put(shard.currentNodeId(), entries);\n                        }\n                        MutableShardRouting sr = new MutableShardRouting(shard);\n                        entries.add(sr);\n                        activeShardsAdd(sr);\n                        if (shard.relocating()) {\n                            entries = nodesToShards.get(shard.relocatingNodeId());\n                            relocatingShards++;\n                            if (entries == null) {\n                                entries = newArrayList();\n                                nodesToShards.put(shard.relocatingNodeId(), entries);\n                            }\n                            // add the counterpart shard with relocatingNodeId reflecting the source from which\n                            // it's relocating from.\n                            sr = new MutableShardRouting(shard.index(), shard.id(), shard.relocatingNodeId(),\n                                    shard.currentNodeId(), shard.primary(), ShardRoutingState.INITIALIZING, shard.version());\n                            entries.add(sr);\n                            activeShardsAdd(sr);\n                        } else if (!shard.active()) { // shards that are initializing without being relocated\n                            if (shard.primary()) {\n                                inactivePrimaryCount++;\n                            }\n                            inactiveShardCount++;\n                        }\n                    } else {\n                        MutableShardRouting sr = new MutableShardRouting(shard);\n                        activeShardsAdd(sr);\n                        unassignedShards.add(sr);\n                    }\n                }\n            }\n        }\n        for (Map.Entry<String, List<MutableShardRouting>> entry : nodesToShards.entrySet()) {\n            String nodeId = entry.getKey();\n            this.nodesToShards.put(nodeId, new RoutingNode(nodeId, clusterState.nodes().get(nodeId), entry.getValue()));\n        }\n    }","id":26150,"modified_method":"public RoutingNodes(ClusterState clusterState) {\n        this.metaData = clusterState.metaData();\n        this.blocks = clusterState.blocks();\n        this.routingTable = clusterState.routingTable();\n\n        Map<String, List<MutableShardRouting>> nodesToShards = newHashMap();\n        // fill in the nodeToShards with the \"live\" nodes\n        for (ObjectCursor<DiscoveryNode> cursor : clusterState.nodes().dataNodes().values()) {\n            nodesToShards.put(cursor.value.id(), new ArrayList<MutableShardRouting>());\n        }\n\n        // fill in the inverse of node -> shards allocated\n        // also fill replicaSet information\n        for (IndexRoutingTable indexRoutingTable : routingTable.indicesRouting().values()) {\n            for (IndexShardRoutingTable indexShard : indexRoutingTable) {\n                for (ShardRouting shard : indexShard) {\n                    // to get all the shards belonging to an index, including the replicas,\n                    // we define a replica set and keep track of it. A replica set is identified\n                    // by the ShardId, as this is common for primary and replicas.\n                    // A replica Set might have one (and not more) replicas with the state of RELOCATING.\n                    if (shard.assignedToNode()) {\n                        List<MutableShardRouting> entries = nodesToShards.get(shard.currentNodeId());\n                        if (entries == null) {\n                            entries = newArrayList();\n                            nodesToShards.put(shard.currentNodeId(), entries);\n                        }\n                        MutableShardRouting sr = new MutableShardRouting(shard);\n                        entries.add(sr);\n                        assignedShardsAdd(sr);\n                        if (shard.relocating()) {\n                            entries = nodesToShards.get(shard.relocatingNodeId());\n                            relocatingShards++;\n                            if (entries == null) {\n                                entries = newArrayList();\n                                nodesToShards.put(shard.relocatingNodeId(), entries);\n                            }\n                            // add the counterpart shard with relocatingNodeId reflecting the source from which\n                            // it's relocating from.\n                            sr = new MutableShardRouting(shard.index(), shard.id(), shard.relocatingNodeId(),\n                                    shard.currentNodeId(), shard.primary(), ShardRoutingState.INITIALIZING, shard.version());\n                            entries.add(sr);\n                            assignedShardsAdd(sr);\n                        } else if (!shard.active()) { // shards that are initializing without being relocated\n                            if (shard.primary()) {\n                                inactivePrimaryCount++;\n                            }\n                            inactiveShardCount++;\n                        }\n                    } else {\n                        MutableShardRouting sr = new MutableShardRouting(shard);\n                        assignedShardsAdd(sr);\n                        unassignedShards.add(sr);\n                    }\n                }\n            }\n        }\n        for (Map.Entry<String, List<MutableShardRouting>> entry : nodesToShards.entrySet()) {\n            String nodeId = entry.getKey();\n            this.nodesToShards.put(nodeId, new RoutingNode(nodeId, clusterState.nodes().get(nodeId), entry.getValue()));\n        }\n    }","commit_id":"314499cee078e42353b3373901368152d7c4fa4e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Calculates RoutingNodes statistics by iterating over all {@link MutableShardRouting}s\n     * in the cluster to ensure the book-keeping is correct.\n     * For performance reasons, this should only be called from asserts\n     *\n     * @return this method always returns <code>true<\/code> or throws an assertion error. If assertion are not enabled\n     *         this method does nothing.\n     */\n    public static boolean assertShardStats(RoutingNodes routingNodes) {\n        boolean run = false;\n        assert (run = true); // only run if assertions are enabled!\n        if (!run) {\n            return true;\n        }\n        int unassignedPrimaryCount = 0;\n        int inactivePrimaryCount = 0;\n        int inactiveShardCount = 0;\n        int relocating = 0;\n        final Set<ShardId> seenShards = newHashSet();\n        Map<String, Integer> indicesAndShards = new HashMap<String, Integer>();\n        for (RoutingNode node : routingNodes) {\n            for (MutableShardRouting shard : node) {\n                if (!shard.active() && shard.relocatingNodeId() == null) {\n                    if (!shard.relocating()) {\n                        inactiveShardCount++;\n                        if (shard.primary()) {\n                            inactivePrimaryCount++;\n                        }\n                    }\n                }\n                if (shard.relocating()) {\n                    relocating++;\n                }\n                seenShards.add(shard.shardId());\n                Integer i = indicesAndShards.get(shard.index());\n                if (i == null) {\n                    i = shard.id();\n                }\n                indicesAndShards.put(shard.index(), Math.max(i, shard.id()));\n            }\n        }\n        // Assert that the active shard routing are identical.\n        Set<Map.Entry<String, Integer>> entries = indicesAndShards.entrySet();\n        Set<MutableShardRouting> shards = newHashSet();\n        for (Map.Entry<String, Integer> e : entries) {\n            String index = e.getKey();\n            for (int i = 0; i < e.getValue(); i++) {\n                for (RoutingNode routingNode : routingNodes) {\n                    for (MutableShardRouting shardRouting : routingNode) {\n                        if (shardRouting.index().equals(index) && shardRouting.id() == i) {\n                            shards.add(shardRouting);\n                        }\n                    }\n                }\n                Set<MutableShardRouting> mutableShardRoutings = routingNodes.activeShards(new ShardId(index, i));\n                for (MutableShardRouting r : mutableShardRoutings) {\n                    assert shards.contains(r);\n                    shards.remove(r);\n                }\n                assert shards.isEmpty();\n            }\n        }\n\n        for (MutableShardRouting shard : routingNodes.unassigned()) {\n            if (shard.primary()) {\n                unassignedPrimaryCount++;\n            }\n            seenShards.add(shard.shardId());\n        }\n\n        assert unassignedPrimaryCount == routingNodes.unassignedShards.numPrimaries() :\n                \"Unassigned primaries is [\" + unassignedPrimaryCount + \"] but RoutingNodes returned unassigned primaries [\" + routingNodes.unassigned().numPrimaries() + \"]\";\n        assert inactivePrimaryCount == routingNodes.inactivePrimaryCount :\n                \"Inactive Primary count [\" + inactivePrimaryCount + \"] but RoutingNodes returned inactive primaries [\" + routingNodes.inactivePrimaryCount + \"]\";\n        assert inactiveShardCount == routingNodes.inactiveShardCount :\n                \"Inactive Shard count [\" + inactiveShardCount + \"] but RoutingNodes returned inactive shards [\" + routingNodes.inactiveShardCount + \"]\";\n        assert routingNodes.getRelocatingShardCount() == relocating : \"Relocating shards mismatch [\" + routingNodes.getRelocatingShardCount() + \"] but expected [\" + relocating + \"]\";\n        return true;\n    }","id":26151,"modified_method":"/**\n     * Calculates RoutingNodes statistics by iterating over all {@link MutableShardRouting}s\n     * in the cluster to ensure the book-keeping is correct.\n     * For performance reasons, this should only be called from asserts\n     *\n     * @return this method always returns <code>true<\/code> or throws an assertion error. If assertion are not enabled\n     *         this method does nothing.\n     */\n    public static boolean assertShardStats(RoutingNodes routingNodes) {\n        boolean run = false;\n        assert (run = true); // only run if assertions are enabled!\n        if (!run) {\n            return true;\n        }\n        int unassignedPrimaryCount = 0;\n        int inactivePrimaryCount = 0;\n        int inactiveShardCount = 0;\n        int relocating = 0;\n        final Set<ShardId> seenShards = newHashSet();\n        Map<String, Integer> indicesAndShards = new HashMap<String, Integer>();\n        for (RoutingNode node : routingNodes) {\n            for (MutableShardRouting shard : node) {\n                if (!shard.active() && shard.relocatingNodeId() == null) {\n                    if (!shard.relocating()) {\n                        inactiveShardCount++;\n                        if (shard.primary()) {\n                            inactivePrimaryCount++;\n                        }\n                    }\n                }\n                if (shard.relocating()) {\n                    relocating++;\n                }\n                seenShards.add(shard.shardId());\n                Integer i = indicesAndShards.get(shard.index());\n                if (i == null) {\n                    i = shard.id();\n                }\n                indicesAndShards.put(shard.index(), Math.max(i, shard.id()));\n            }\n        }\n        // Assert that the active shard routing are identical.\n        Set<Map.Entry<String, Integer>> entries = indicesAndShards.entrySet();\n        Set<MutableShardRouting> shards = newHashSet();\n        for (Map.Entry<String, Integer> e : entries) {\n            String index = e.getKey();\n            for (int i = 0; i < e.getValue(); i++) {\n                for (RoutingNode routingNode : routingNodes) {\n                    for (MutableShardRouting shardRouting : routingNode) {\n                        if (shardRouting.index().equals(index) && shardRouting.id() == i) {\n                            shards.add(shardRouting);\n                        }\n                    }\n                }\n                Set<MutableShardRouting> mutableShardRoutings = routingNodes.assignedShards(new ShardId(index, i));\n                for (MutableShardRouting r : mutableShardRoutings) {\n                    assert shards.contains(r);\n                    shards.remove(r);\n                }\n                assert shards.isEmpty();\n            }\n        }\n\n        for (MutableShardRouting shard : routingNodes.unassigned()) {\n            if (shard.primary()) {\n                unassignedPrimaryCount++;\n            }\n            seenShards.add(shard.shardId());\n        }\n\n        assert unassignedPrimaryCount == routingNodes.unassignedShards.numPrimaries() :\n                \"Unassigned primaries is [\" + unassignedPrimaryCount + \"] but RoutingNodes returned unassigned primaries [\" + routingNodes.unassigned().numPrimaries() + \"]\";\n        assert inactivePrimaryCount == routingNodes.inactivePrimaryCount :\n                \"Inactive Primary count [\" + inactivePrimaryCount + \"] but RoutingNodes returned inactive primaries [\" + routingNodes.inactivePrimaryCount + \"]\";\n        assert inactiveShardCount == routingNodes.inactiveShardCount :\n                \"Inactive Shard count [\" + inactiveShardCount + \"] but RoutingNodes returned inactive shards [\" + routingNodes.inactiveShardCount + \"]\";\n        assert routingNodes.getRelocatingShardCount() == relocating : \"Relocating shards mismatch [\" + routingNodes.getRelocatingShardCount() + \"] but expected [\" + relocating + \"]\";\n        return true;\n    }","commit_id":"314499cee078e42353b3373901368152d7c4fa4e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Cancels the give shard from the Routing nodes internal statistics and cancels\n     * the relocation if the shard is relocating.\n     * @param shard\n     */\n    private void remove(MutableShardRouting shard) {\n        if (!shard.active() && shard.relocatingNodeId() == null) {\n            inactiveShardCount--;\n            assert inactiveShardCount >= 0;\n            if (shard.primary()) {\n                inactivePrimaryCount--;\n            }\n        } else if (shard.relocating()) {\n            cancelRelocation(shard);\n        }\n        activeShardsRemove(shard);\n    }","id":26152,"modified_method":"/**\n     * Cancels the give shard from the Routing nodes internal statistics and cancels\n     * the relocation if the shard is relocating.\n     * @param shard\n     */\n    private void remove(MutableShardRouting shard) {\n        if (!shard.active() && shard.relocatingNodeId() == null) {\n            inactiveShardCount--;\n            assert inactiveShardCount >= 0;\n            if (shard.primary()) {\n                inactivePrimaryCount--;\n            }\n        } else if (shard.relocating()) {\n            cancelRelocation(shard);\n        }\n        assignedShardsRemove(shard);\n    }","commit_id":"314499cee078e42353b3373901368152d7c4fa4e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Assign a shard to a node. This will increment the inactiveShardCount counter\n     * and the inactivePrimaryCount counter if the shard is the primary.\n     * In case the shard is already assigned and started, it will be marked as \n     * relocating, which is accounted for, too, so the number of concurrent relocations\n     * can be retrieved easily.\n     * This method can be called several times for the same shard, only the first time\n     * will change the state.\n     *\n     * INITIALIZING => INITIALIZING\n     * UNASSIGNED   => INITIALIZING\n     * STARTED      => RELOCATING\n     * RELOCATING   => RELOCATING\n     *\n     * @param shard the shard to be assigned\n     * @param nodeId the nodeId this shard should initialize on or relocate from\n     */\n    public void assign(MutableShardRouting shard, String nodeId) {\n        // state will not change if the shard is already initializing.\n        ShardRoutingState oldState = shard.state();\n        shard.assignToNode(nodeId);\n        node(nodeId).add(shard);\n        if (oldState == ShardRoutingState.UNASSIGNED) {\n            inactiveShardCount++;\n            if (shard.primary()) {\n                inactivePrimaryCount++;\n            }\n        }\n\n        if (shard.state() == ShardRoutingState.RELOCATING) {\n            relocatingShards++;\n        }\n        activeShardsAdd(shard);\n    }","id":26153,"modified_method":"/**\n     * Assign a shard to a node. This will increment the inactiveShardCount counter\n     * and the inactivePrimaryCount counter if the shard is the primary.\n     * In case the shard is already assigned and started, it will be marked as \n     * relocating, which is accounted for, too, so the number of concurrent relocations\n     * can be retrieved easily.\n     * This method can be called several times for the same shard, only the first time\n     * will change the state.\n     *\n     * INITIALIZING => INITIALIZING\n     * UNASSIGNED   => INITIALIZING\n     * STARTED      => RELOCATING\n     * RELOCATING   => RELOCATING\n     *\n     * @param shard the shard to be assigned\n     * @param nodeId the nodeId this shard should initialize on or relocate from\n     */\n    public void assign(MutableShardRouting shard, String nodeId) {\n        // state will not change if the shard is already initializing.\n        ShardRoutingState oldState = shard.state();\n        shard.assignToNode(nodeId);\n        node(nodeId).add(shard);\n        if (oldState == ShardRoutingState.UNASSIGNED) {\n            inactiveShardCount++;\n            if (shard.primary()) {\n                inactivePrimaryCount++;\n            }\n        }\n\n        if (shard.state() == ShardRoutingState.RELOCATING) {\n            relocatingShards++;\n        }\n        assignedShardsAdd(shard);\n    }","commit_id":"314499cee078e42353b3373901368152d7c4fa4e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Returns <code>true<\/code> iff all replicas are active for the given shard routing. Otherwise <code>false<\/code>\n     */\n    public boolean allReplicasActive(ShardRouting shardRouting) {\n        final Set<MutableShardRouting> shards = activeShards(shardRouting.shardId());\n        if (shards.isEmpty() || shards.size() < this.routingTable.index(shardRouting.index()).shard(shardRouting.id()).size()) {\n            return false; // if we are empty nothing is active if we have less than total at least one is unassigned\n        }\n        for (MutableShardRouting shard : shards) {\n            if (!shard.active()) {\n                return false;\n            }\n        }\n        return true;\n    }","id":26154,"modified_method":"/**\n     * Returns <code>true<\/code> iff all replicas are active for the given shard routing. Otherwise <code>false<\/code>\n     */\n    public boolean allReplicasActive(ShardRouting shardRouting) {\n        final Set<MutableShardRouting> shards = assignedShards(shardRouting.shardId());\n        if (shards.isEmpty() || shards.size() < this.routingTable.index(shardRouting.index()).shard(shardRouting.id()).size()) {\n            return false; // if we are empty nothing is active if we have less than total at least one is unassigned\n        }\n        for (MutableShardRouting shard : shards) {\n            if (!shard.active()) {\n                return false;\n            }\n        }\n        return true;\n    }","commit_id":"314499cee078e42353b3373901368152d7c4fa4e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected void runReplicateTest(IndexShardRoutingTable shardRoutingTable, int assignedReplicas, int totalShards) throws InterruptedException, ExecutionException {\n        final ShardIterator shardIt = shardRoutingTable.shardsIt();\n        final ShardId shardId = shardIt.shardId();\n        final Request request = new Request(shardId);\n        final PlainActionFuture<Response> listener = new PlainActionFuture<>();\n        logger.debug(\"expecting [{}] assigned replicas, [{}] total shards. using state: \\n{}\", assignedReplicas, totalShards, clusterService.state().prettyPrint());\n\n        Releasable reference = getOrCreateIndexShardOperationsCounter();\n        assertIndexShardCounter(2);\n        // TODO: set a default timeout\n        TransportReplicationAction<Request, Request, Response>.ReplicationPhase replicationPhase =\n                action.new ReplicationPhase(request,\n                        new Response(),\n                        request.shardId(), createTransportChannel(listener), reference, null);\n\n        assertThat(replicationPhase.totalShards(), equalTo(totalShards));\n        assertThat(replicationPhase.pending(), equalTo(assignedReplicas));\n        replicationPhase.run();\n        final CapturingTransport.CapturedRequest[] capturedRequests = transport.capturedRequests();\n        transport.clear();\n\n        assertThat(capturedRequests.length, equalTo(assignedReplicas));\n        Set<String> nodesSentTo = new HashSet<>();\n        boolean executeOnReplica =\n            action.shouldExecuteReplication(clusterService.state().getMetaData().index(shardId.getIndex()).getSettings());\n        for (CapturingTransport.CapturedRequest capturedRequest : capturedRequests) {\n            // no duplicate requests\n            assertTrue(nodesSentTo.add(capturedRequest.node.getId()));\n            // the request is hitting the correct shard\n            Request replicationRequest = (Request)capturedRequest.request;\n            assertEquals(request.shardId, replicationRequest.shardId);\n        }\n\n        // requests were sent to the correct shard copies\n        List<ShardRouting> shards =\n            clusterService.state().getRoutingTable().index(shardId.getIndex()).shard(shardId.id()).shards();\n        for (ShardRouting shard : shards) {\n            if (!shard.primary() && !executeOnReplica) {\n                continue;\n            }\n            if (shard.unassigned()) {\n                continue;\n            }\n            if (!clusterService.state().getNodes().localNodeId().equals(shard.currentNodeId())) {\n                assertThat(nodesSentTo, hasItem(shard.currentNodeId()));\n            }\n            if (shard.relocating()) {\n                assertThat(nodesSentTo, hasItem(shard.relocatingNodeId()));\n            }\n        }\n\n        if (assignedReplicas > 0) {\n            assertThat(\"listener is done, but there are outstanding replicas\", listener.isDone(), equalTo(false));\n        }\n        int pending = replicationPhase.pending();\n        int criticalFailures = 0; // failures that should fail the shard\n        int successful = 1;\n        List<CapturingTransport.CapturedRequest> failures = new ArrayList<>();\n        for (CapturingTransport.CapturedRequest capturedRequest : capturedRequests) {\n            if (randomBoolean()) {\n                Throwable t;\n                boolean criticalFailure = randomBoolean();\n                if (criticalFailure) {\n                    t = new CorruptIndexException(\"simulated\", (String) null);\n                    criticalFailures++;\n                } else {\n                    t = new IndexShardNotStartedException(shardId, IndexShardState.RECOVERING);\n                }\n                logger.debug(\"--> simulating failure on {} with [{}]\", capturedRequest.node, t.getClass().getSimpleName());\n                transport.handleResponse(capturedRequest.requestId, t);\n                if (criticalFailure) {\n                    CapturingTransport.CapturedRequest[] shardFailedRequests = transport.capturedRequests();\n                    transport.clear();\n                    assertEquals(1, shardFailedRequests.length);\n                    CapturingTransport.CapturedRequest shardFailedRequest = shardFailedRequests[0];\n                    // get the shard the request was sent to\n                    ShardRouting routing = clusterService.state().getRoutingNodes().node(capturedRequest.node.id()).get(request.shardId.id());\n                    // and the shard that was requested to be failed\n                    ShardStateAction.ShardRoutingEntry shardRoutingEntry = (ShardStateAction.ShardRoutingEntry)shardFailedRequest.request;\n                    // the shard the request was sent to and the shard to be failed should be the same\n                    assertTrue(shardRoutingEntry.getShardRouting().isSameAllocation(routing));\n                    failures.add(shardFailedRequest);\n                    transport.handleResponse(shardFailedRequest.requestId, TransportResponse.Empty.INSTANCE);\n                }\n            } else {\n                successful++;\n                transport.handleResponse(capturedRequest.requestId, TransportResponse.Empty.INSTANCE);\n            }\n            pending--;\n            assertThat(replicationPhase.pending(), equalTo(pending));\n            assertThat(replicationPhase.successful(), equalTo(successful));\n        }\n        assertThat(listener.isDone(), equalTo(true));\n        Response response = listener.get();\n        final ReplicationResponse.ShardInfo shardInfo = response.getShardInfo();\n        assertThat(shardInfo.getFailed(), equalTo(criticalFailures));\n        assertThat(shardInfo.getFailures(), arrayWithSize(criticalFailures));\n        assertThat(shardInfo.getSuccessful(), equalTo(successful));\n        assertThat(shardInfo.getTotal(), equalTo(totalShards));\n\n        assertThat(\"failed to see enough shard failures\", failures.size(), equalTo(criticalFailures));\n        for (CapturingTransport.CapturedRequest capturedRequest : transport.capturedRequests()) {\n            assertThat(capturedRequest.action, equalTo(ShardStateAction.SHARD_FAILED_ACTION_NAME));\n        }\n        // all replicas have responded so the counter should be decreased again\n        assertIndexShardCounter(1);\n    }","id":26155,"modified_method":"protected void runReplicateTest(IndexShardRoutingTable shardRoutingTable, int assignedReplicas, int totalShards) throws InterruptedException, ExecutionException {\n        final ShardIterator shardIt = shardRoutingTable.shardsIt();\n        final ShardId shardId = shardIt.shardId();\n        final Request request = new Request(shardId);\n        final PlainActionFuture<Response> listener = new PlainActionFuture<>();\n        logger.debug(\"expecting [{}] assigned replicas, [{}] total shards. using state: \\n{}\", assignedReplicas, totalShards, clusterService.state().prettyPrint());\n\n        Releasable reference = getOrCreateIndexShardOperationsCounter();\n        assertIndexShardCounter(2);\n        // TODO: set a default timeout\n        TransportReplicationAction<Request, Request, Response>.ReplicationPhase replicationPhase =\n                action.new ReplicationPhase(request,\n                        new Response(),\n                        request.shardId(), createTransportChannel(listener), reference, null);\n\n        assertThat(replicationPhase.totalShards(), equalTo(totalShards));\n        assertThat(replicationPhase.pending(), equalTo(assignedReplicas));\n        replicationPhase.run();\n        final CapturingTransport.CapturedRequest[] capturedRequests = transport.capturedRequests();\n        transport.clear();\n\n        assertThat(capturedRequests.length, equalTo(assignedReplicas));\n        HashMap<String, Request> nodesSentTo = new HashMap<>();\n        boolean executeOnReplica =\n            action.shouldExecuteReplication(clusterService.state().getMetaData().index(shardId.getIndex()).getSettings());\n        for (CapturingTransport.CapturedRequest capturedRequest : capturedRequests) {\n            // no duplicate requests\n            Request replicationRequest = (Request) capturedRequest.request;\n            assertNull(nodesSentTo.put(capturedRequest.node.getId(), replicationRequest));\n            // the request is hitting the correct shard\n            assertEquals(request.shardId, replicationRequest.shardId);\n        }\n\n        // no request was sent to the local node\n        assertThat(nodesSentTo.keySet(), not(hasItem(clusterService.state().getNodes().localNodeId())));\n\n        // requests were sent to the correct shard copies\n        for (ShardRouting shard : clusterService.state().getRoutingTable().shardRoutingTable(shardId.getIndex(), shardId.id())) {\n            if (shard.primary() == false && executeOnReplica == false) {\n                continue;\n            }\n            if (shard.unassigned()) {\n                continue;\n            }\n            if (shard.primary() == false) {\n                nodesSentTo.remove(shard.currentNodeId());\n            }\n            if (shard.relocating()) {\n                nodesSentTo.remove(shard.relocatingNodeId());\n            }\n        }\n\n        assertThat(nodesSentTo.entrySet(), is(empty()));\n\n        if (assignedReplicas > 0) {\n            assertThat(\"listener is done, but there are outstanding replicas\", listener.isDone(), equalTo(false));\n        }\n        int pending = replicationPhase.pending();\n        int criticalFailures = 0; // failures that should fail the shard\n        int successful = 1;\n        List<CapturingTransport.CapturedRequest> failures = new ArrayList<>();\n        for (CapturingTransport.CapturedRequest capturedRequest : capturedRequests) {\n            if (randomBoolean()) {\n                Throwable t;\n                boolean criticalFailure = randomBoolean();\n                if (criticalFailure) {\n                    t = new CorruptIndexException(\"simulated\", (String) null);\n                    criticalFailures++;\n                } else {\n                    t = new IndexShardNotStartedException(shardId, IndexShardState.RECOVERING);\n                }\n                logger.debug(\"--> simulating failure on {} with [{}]\", capturedRequest.node, t.getClass().getSimpleName());\n                transport.handleResponse(capturedRequest.requestId, t);\n                if (criticalFailure) {\n                    CapturingTransport.CapturedRequest[] shardFailedRequests = transport.capturedRequests();\n                    transport.clear();\n                    assertEquals(1, shardFailedRequests.length);\n                    CapturingTransport.CapturedRequest shardFailedRequest = shardFailedRequests[0];\n                    // get the shard the request was sent to\n                    ShardRouting routing = clusterService.state().getRoutingNodes().node(capturedRequest.node.id()).get(request.shardId.id());\n                    // and the shard that was requested to be failed\n                    ShardStateAction.ShardRoutingEntry shardRoutingEntry = (ShardStateAction.ShardRoutingEntry)shardFailedRequest.request;\n                    // the shard the request was sent to and the shard to be failed should be the same\n                    assertEquals(shardRoutingEntry.getShardRouting(), routing);\n                    failures.add(shardFailedRequest);\n                    transport.handleResponse(shardFailedRequest.requestId, TransportResponse.Empty.INSTANCE);\n                }\n            } else {\n                successful++;\n                transport.handleResponse(capturedRequest.requestId, TransportResponse.Empty.INSTANCE);\n            }\n            pending--;\n            assertThat(replicationPhase.pending(), equalTo(pending));\n            assertThat(replicationPhase.successful(), equalTo(successful));\n        }\n        assertThat(listener.isDone(), equalTo(true));\n        Response response = listener.get();\n        final ReplicationResponse.ShardInfo shardInfo = response.getShardInfo();\n        assertThat(shardInfo.getFailed(), equalTo(criticalFailures));\n        assertThat(shardInfo.getFailures(), arrayWithSize(criticalFailures));\n        assertThat(shardInfo.getSuccessful(), equalTo(successful));\n        assertThat(shardInfo.getTotal(), equalTo(totalShards));\n\n        assertThat(\"failed to see enough shard failures\", failures.size(), equalTo(criticalFailures));\n        for (CapturingTransport.CapturedRequest capturedRequest : transport.capturedRequests()) {\n            assertThat(capturedRequest.action, equalTo(ShardStateAction.SHARD_FAILED_ACTION_NAME));\n        }\n        // all replicas have responded so the counter should be decreased again\n        assertIndexShardCounter(1);\n    }","commit_id":"c291c1714295dd0ab7024f50518fc39fa21d742d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private ASTNode findChildAfter(@NotNull final ASTNode child, final int endOffset) {\n    TreeElement fileNode = TreeUtil.getFileElement((TreeElement)child);\n    return fileNode.findLeafElementAt(endOffset);\n    /*\n    ASTNode result = child;\n    while (result != null && result.getTextRange().getEndOffset() < endOffset) {\n      result = TreeUtil.nextLeaf(result);\n    }\n    return result;\n    */\n  }","id":26156,"modified_method":"private static ASTNode findChildAfter(@NotNull final ASTNode child, final int endOffset) {\n    TreeElement fileNode = TreeUtil.getFileElement((TreeElement)child);\n    final LeafElement leaf = fileNode.findLeafElementAt(endOffset);\n    if (leaf != null && leaf.getStartOffset() == endOffset) {\n      final ASTNode prev = TreeUtil.prevLeaf(leaf);\n      if (prev != null) return prev;\n    }\n    return leaf;\n    /*\n    ASTNode result = child;\n    while (result != null && result.getTextRange().getEndOffset() < endOffset) {\n      result = TreeUtil.nextLeaf(result);\n    }\n    return result;\n    */\n  }","commit_id":"312024702cb55f8e0520c5a8d35ec4260b59b1f4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiElement getUpperElement(final PsiElement e, final TextRange selectionRange) {\n    final PsiElement parent = e.getParent();\n\n    if (PsiUtil.isInJspFile(e.getContainingFile()) && e.getLanguage()instanceof JavaLanguage) {\n      final JspFile psiFile = PsiUtil.getJspFile(e.getContainingFile());\n      if (e.getParent().getTextLength() == psiFile.getTextLength()) {\n        PsiFile baseRoot = psiFile.getBaseLanguageRoot();\n        PsiElement elt = baseRoot.getNode().findLeafElementAt(e.getTextRange().getStartOffset()).getPsi();\n        return elt;\n      }\n    }\n\n    return parent;\n  }","id":26157,"modified_method":"@NotNull\n  private static PsiElement getUpperElement(final PsiElement e, final TextRange selectionRange) {\n    final PsiElement parent = e.getParent();\n\n    if (PsiUtil.isInJspFile(e.getContainingFile()) && e.getLanguage()instanceof JavaLanguage && !(e instanceof PsiErrorElement)) {\n      final JspFile psiFile = PsiUtil.getJspFile(e.getContainingFile());\n      if (e.getParent().getTextLength() == psiFile.getTextLength()) {\n        PsiFile baseRoot = psiFile.getBaseLanguageRoot();\n        final ASTNode node = baseRoot.getNode();\n        if (node == null) return parent;\n        final ASTNode leafElementAt = node.findLeafElementAt(e.getTextRange().getStartOffset());\n        return leafElementAt != null ? leafElementAt.getPsi() : parent;\n      }\n    }\n\n    return parent;\n  }","commit_id":"8121e67fb3a8c57c9659e0096bbdc944519539f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int replaceWithPSI(final TextRange textRange, int blockLength, final String whiteSpace) {\n    final int offset = textRange.getEndOffset();\n    final ASTNode leafElement = findElementAt(offset);\n\n      if (leafElement != null) {\n        LOG.assertTrue(leafElement.getPsi().isValid());\n        final int oldElementLength = leafElement.getTextRange().getLength();\n        if (false/*leafElement.getTextRange().getStartOffset() < textRange.getStartOffset()*/) {\n          final int newElementLength = new Helper(StdFileTypes.JAVA, myProject).shiftIndentInside(leafElement, getSpaceCount(whiteSpace))\n            .getTextRange().getLength();\n          blockLength = blockLength - oldElementLength + newElementLength;\n        }\n        else {\n          changeWhiteSpaceBeforeLeaf(whiteSpace, leafElement, textRange);\n          if (leafElement.textContains('\\n')\n              && whiteSpace.indexOf('\\n') >= 0) {\n            try {\n              Indent lastLineIndent = getLastLineIndent(leafElement.getText());\n              Indent whiteSpaceIndent = createIndentOn(getLastLine(whiteSpace));\n              final int shift = calcShift(lastLineIndent, whiteSpaceIndent);\n              final int newElementLength = new Helper(StdFileTypes.JAVA, myProject).shiftIndentInside(leafElement, shift).getTextRange()\n                .getLength();\n              blockLength = blockLength - oldElementLength + newElementLength;\n            }\n            catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n\n        return blockLength;\n      } else {\n        changeLastWhiteSpace(whiteSpace);\n        return 0;\n      }\n    }","id":26158,"modified_method":"private int replaceWithPSI(final TextRange textRange, int blockLength, final String whiteSpace) {\n    final int offset = textRange.getEndOffset();\n    final ASTNode leafElement = findElementAt(offset);\n\n      if (leafElement != null) {\n        LOG.assertTrue(leafElement.getPsi().isValid());\n        final int oldElementLength = leafElement.getTextRange().getLength();\n        changeWhiteSpaceBeforeLeaf(whiteSpace, leafElement, textRange);\n        if (leafElement.textContains('\\n')\n            && whiteSpace.indexOf('\\n') >= 0) {\n          try {\n            Indent lastLineIndent = getLastLineIndent(leafElement.getText());\n            Indent whiteSpaceIndent = createIndentOn(getLastLine(whiteSpace));\n            final int shift = calcShift(lastLineIndent, whiteSpaceIndent);\n            final int newElementLength = new Helper(StdFileTypes.JAVA, myProject).shiftIndentInside(leafElement, shift).getTextRange()\n              .getLength();\n            blockLength = blockLength - oldElementLength + newElementLength;\n          }\n          catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n\n        return blockLength;\n      } else {\n        changeLastWhiteSpace(whiteSpace);\n        return 0;\n      }\n    }","commit_id":"7b5433c738e02de12bd4f820851b04e2a95fb7ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ASTNode findElementAt(final int offset) {\n    final PsiElement[] psiRoots = myASTNode.getPsi().getContainingFile().getPsiRoots();\n    for (int i = psiRoots.length -1; i >= 0; i--) {\n      PsiElement psiRoot = psiRoots[i];\n      final ASTNode found = psiRoot.getNode().findLeafElementAt(offset);\n      if (found != null) {\n        if (!(found.getPsi()instanceof JspText) && found.getTextRange().getStartOffset() == offset) {\n          return found;\n        }\n      }\n    }\n    return myASTNode.findLeafElementAt(offset);\n  }","id":26159,"modified_method":"private ASTNode findElementAt(final int offset) {\n    final PsiElement[] psiRoots = myASTNode.getPsi().getContainingFile().getPsiRoots();\n    for (int i = psiRoots.length -1; i >= 0; i--) {\n      PsiElement psiRoot = psiRoots[i];\n      final ASTNode found = psiRoot.getNode().findLeafElementAt(offset);\n      if (found != null) {\n        if (!(found.getPsi()instanceof JspText) && found.getTextRange().getStartOffset() == offset) {\n          if (found.getElementType() == ElementType.XML_COMMENT_START) {\n            return found.getTreeParent();\n          } else {\n            return found;\n          }\n        }\n      }\n    }\n    final ASTNode found = myASTNode.findLeafElementAt(offset);\n    if (found.getElementType() == ElementType.XML_COMMENT_START) {\n      return found.getTreeParent();\n    } else {\n      return found;\n    }\n  }","commit_id":"7b5433c738e02de12bd4f820851b04e2a95fb7ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Indent getIndent() {\n    if (myNode.getElementType() == ElementType.XML_PROLOG\n        || myNode.getElementType() == ElementType.XML_DOCTYPE\n        || SourceTreeToPsiMap.treeElementToPsi(myNode) instanceof XmlDocument) {\n      return getFormatter().getNoneIndent();\n    }\n    else if (myNode.getElementType() == ElementType.XML_COMMENT && myNode.textContains('\\n')) {\n      return getFormatter().createAbsoluteNoneIndent();\n    }\n\n    /*\n    if (myNode.getElementType() == ElementType.JSP_SCRIPTLET || myNode.getElementType() == ElementType.JSP_DECLARATION) {\n      return getFormatter().getNoneIndent();\n    }\n    if (myNode.getElementType() == ElementType.JSP_XML_TEXT) {\n      return getFormatter().createNormalIndent();\n    }\n    if (myNode.getElementType() == ElementType.XML_TEXT) {\n      if (myNode.getPsi().getParent() instanceof JspXmlRootTag) {\n        return getFormatter().getNoneIndent();\n      } else {\n        return null;\n      }\n    }\n    else if (myNode.getElementType() == ElementType.XML_PROLOG || SourceTreeToPsiMap.treeElementToPsi(myNode) instanceof XmlDocument) {\n      return getFormatter().getNoneIndent();\n    }\n    else if (myNode.getElementType() == ElementType.XML_COMMENT && myNode.textContains('\\n')) {\n      return getFormatter().createAbsoluteNoneIndent();\n    }\n    else if (myNode.getElementType() == ElementType.XML_DOCUMENT) {\n      return getFormatter().getNoneIndent();\n    }\n    else if (myNode.getElementType() == ElementType.XML_TAG) {\n      return getFormatter().getNoneIndent();\n    }    \n    else {\n      return null;\n    }\n    */\n    return myIndent;\n  }","id":26160,"modified_method":"public Indent getIndent() {\n    if (myNode.getElementType() == ElementType.XML_PROLOG\n        || myNode.getElementType() == ElementType.XML_DOCTYPE\n        || SourceTreeToPsiMap.treeElementToPsi(myNode) instanceof XmlDocument) {\n      return getFormatter().getNoneIndent();\n    }\n    /*\n    else if (myNode.getElementType() == ElementType.XML_COMMENT && myNode.textContains('\\n')) {\n      return getFormatter().createAbsoluteNoneIndent();\n    }\n    */\n\n    /*\n    if (myNode.getElementType() == ElementType.JSP_SCRIPTLET || myNode.getElementType() == ElementType.JSP_DECLARATION) {\n      return getFormatter().getNoneIndent();\n    }\n    if (myNode.getElementType() == ElementType.JSP_XML_TEXT) {\n      return getFormatter().createNormalIndent();\n    }\n    if (myNode.getElementType() == ElementType.XML_TEXT) {\n      if (myNode.getPsi().getParent() instanceof JspXmlRootTag) {\n        return getFormatter().getNoneIndent();\n      } else {\n        return null;\n      }\n    }\n    else if (myNode.getElementType() == ElementType.XML_PROLOG || SourceTreeToPsiMap.treeElementToPsi(myNode) instanceof XmlDocument) {\n      return getFormatter().getNoneIndent();\n    }\n    else if (myNode.getElementType() == ElementType.XML_COMMENT && myNode.textContains('\\n')) {\n      return getFormatter().createAbsoluteNoneIndent();\n    }\n    else if (myNode.getElementType() == ElementType.XML_DOCUMENT) {\n      return getFormatter().getNoneIndent();\n    }\n    else if (myNode.getElementType() == ElementType.XML_TAG) {\n      return getFormatter().getNoneIndent();\n    }    \n    else {\n      return null;\n    }\n    */\n    return myIndent;\n  }","commit_id":"7b5433c738e02de12bd4f820851b04e2a95fb7ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected List<Block> buildChildren() {\n\n    final ArrayList<Block> result = new ArrayList<Block>();\n\n    if (myNode.getElementType() == ElementType.XML_ATTRIBUTE_VALUE) {\n      return result;\n    }\n\n    if (myNode.getElementType() == ElementType.XML_TEXT) {\n      if (myXmlFormattingPolicy.getShouldKeepWhiteSpaces()) {\n        return result;\n      }\n\n      final ASTNode treeParent = myNode.getTreeParent();\n      final XmlTag tag = getTag(treeParent);\n      if (tag != null) {\n        if (myXmlFormattingPolicy.keepWhiteSpacesInsideTag(tag)) {\n          return result;\n        }\n      }\n    }\n\n    if (myNode instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(myNode);\n      ASTNode child = myNode.getFirstChildNode();\n      while (child != null) {\n        if (!FormatterUtil.containsWhiteSpacesOnly(child) && child.getTextLength() > 0) {\n          result.add(createChildBlock(child, null, null, getChildDefaultIndent()));\n        }\n        child = child.getTreeNext();\n      }\n    }\n    return result;\n  }","id":26161,"modified_method":"protected List<Block> buildChildren() {\n\n    final ArrayList<Block> result = new ArrayList<Block>();\n\n    if (myNode.getElementType() == ElementType.XML_ATTRIBUTE_VALUE || myNode.getElementType() == ElementType.XML_COMMENT) {\n      return result;\n    }\n\n    if (myNode.getElementType() == ElementType.XML_TEXT) {\n      if (myXmlFormattingPolicy.getShouldKeepWhiteSpaces()) {\n        return result;\n      }\n\n      final ASTNode treeParent = myNode.getTreeParent();\n      final XmlTag tag = getTag(treeParent);\n      if (tag != null) {\n        if (myXmlFormattingPolicy.keepWhiteSpacesInsideTag(tag)) {\n          return result;\n        }\n      }\n    }\n\n    if (myNode instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(myNode);\n      ASTNode child = myNode.getFirstChildNode();\n      while (child != null) {\n        if (!FormatterUtil.containsWhiteSpacesOnly(child) && child.getTextLength() > 0) {\n          result.add(createChildBlock(child, null, null, getChildDefaultIndent()));\n        }\n        child = child.getTreeNext();\n      }\n    }\n    return result;\n  }","commit_id":"7b5433c738e02de12bd4f820851b04e2a95fb7ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testConfigurationDefaults() throws Exception\n    {\n        JmsConnector c = (JmsConnector)muleContext.getRegistry().lookupConnector(\"jmsConnector\");\n        assertNotNull(c);\n\n        assertFalse(c.isEagerConsumer());\n        \n        ConnectionFactory cf = (ConnectionFactory) c.getConnectionFactory();\n        assertTrue(cf instanceof ActiveMQConnectionFactory);\n        assertEquals(ActiveMQJmsConnector.DEFAULT_BROKER_URL, ((ActiveMQConnectionFactory) cf).getBrokerURL());\n        \n        assertNotNull(c.getTopicResolver());\n        assertTrue(\"Wrong topic resolver configured on the connector.\",\n                   c.getTopicResolver() instanceof DefaultJmsTopicResolver);\n    }","id":26162,"modified_method":"public void testConfigurationDefaults() throws Exception\n    {\n        JmsConnector c = (JmsConnector)muleContext.getRegistry().lookupConnector(\"jmsConnector\");\n        assertNotNull(c);\n\n        assertFalse(c.isEagerConsumer());\n        \n        ConnectionFactory cf = c.getConnectionFactory();\n        assertTrue(cf instanceof ActiveMQConnectionFactory);\n        assertEquals(ActiveMQJmsConnector.DEFAULT_BROKER_URL, ((ActiveMQConnectionFactory) cf).getBrokerURL());\n        \n        assertNotNull(c.getTopicResolver());\n        assertTrue(\"Wrong topic resolver configured on the connector.\",\n                   c.getTopicResolver() instanceof DefaultJmsTopicResolver);\n    }","commit_id":"335321e0b40889a93173f0e6bca1f5d1ac05025c","url":"https://github.com/mulesoft/mule"},{"original_method":"private void testConfigurationBuilder2Objects(MuleContext muleContext)\n    {\n        // Test Registry contents for existance of object configured by\n        // TestConfigurationBuilder2\n        assertEquals(TEST_STRING_VALUE2, muleContext.getRegistry().lookupObject(TEST_STRING_KEY2));\n        assertNotNull(muleContext.getRegistry().lookupModel(TEST_MODEL_NAME));\n        assertEquals(TEST_MODEL_NAME,\n            ((UMOModel) muleContext.getRegistry().lookupModel(TEST_MODEL_NAME)).getName());\n    }","id":26163,"modified_method":"private void testConfigurationBuilder2Objects(MuleContext muleContext)\n    {\n        // Test Registry contents for existance of object configured by\n        // TestConfigurationBuilder2\n        assertEquals(TEST_STRING_VALUE2, muleContext.getRegistry().lookupObject(TEST_STRING_KEY2));\n        assertNotNull(muleContext.getRegistry().lookupModel(TEST_MODEL_NAME));\n        assertEquals(TEST_MODEL_NAME, muleContext.getRegistry().lookupModel(TEST_MODEL_NAME).getName());\n    }","commit_id":"335321e0b40889a93173f0e6bca1f5d1ac05025c","url":"https://github.com/mulesoft/mule"},{"original_method":"private void testConfigurationBuilder1Objects(MuleContext muleContext)\n    {\n        // Test Registry contents for existance of object configured by\n        // TestConfigurationBuilder\n        assertEquals(TEST_STRING_VALUE, muleContext.getRegistry().lookupObject(TEST_STRING_KEY));\n        assertNotNull(muleContext.getRegistry().lookupConnector(TEST_CONNECTOR_NAME));\n        assertEquals(TEST_CONNECTOR_NAME, ((UMOConnector) muleContext.getRegistry().lookupConnector(\n            TEST_CONNECTOR_NAME)).getName());\n    }","id":26164,"modified_method":"private void testConfigurationBuilder1Objects(MuleContext muleContext)\n    {\n        // Test Registry contents for existance of object configured by\n        // TestConfigurationBuilder\n        assertEquals(TEST_STRING_VALUE, muleContext.getRegistry().lookupObject(TEST_STRING_KEY));\n        assertNotNull(muleContext.getRegistry().lookupConnector(TEST_CONNECTOR_NAME));\n        assertEquals(TEST_CONNECTOR_NAME, muleContext.getRegistry().lookupConnector(TEST_CONNECTOR_NAME).getName());\n    }","commit_id":"335321e0b40889a93173f0e6bca1f5d1ac05025c","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Test providerProperties set on JmsConnector are not passed to the underlying\n     * ConnectionFactory.\n     */\n    public void testProviderPropertiesNotPassed() throws Exception\n    {\n        JmsConnector c = (JmsConnector)muleContext.getRegistry().lookupConnector(\"jmsConnector1\");\n        assertNotNull(c);\n\n        ConnectionFactory cf = (ConnectionFactory) c.getConnectionFactory();\n        assertTrue(cf instanceof TestConnectionFactory);\n        assertEquals(\"Provider properties should not be passed to the ConnectionFactory.\", \"NOT_SET\",\n            ((TestConnectionFactory)cf).getProviderProperty());\n    }","id":26165,"modified_method":"/**\n     * Test providerProperties set on JmsConnector are not passed to the underlying\n     * ConnectionFactory.\n     */\n    public void testProviderPropertiesNotPassed() throws Exception\n    {\n        JmsConnector c = (JmsConnector)muleContext.getRegistry().lookupConnector(\"jmsConnector1\");\n        assertNotNull(c);\n\n        ConnectionFactory cf = c.getConnectionFactory();\n        assertTrue(cf instanceof TestConnectionFactory);\n        assertEquals(\"Provider properties should not be passed to the ConnectionFactory.\", \"NOT_SET\",\n            ((TestConnectionFactory)cf).getProviderProperty());\n    }","commit_id":"335321e0b40889a93173f0e6bca1f5d1ac05025c","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Test connectionFactoryProperties set on JmsConnector are actually passed to\n     * the underlying ConnectionFactory.\n     */\n    public void testConnectionFactoryPropertiesPassed() throws Exception\n    {\n        JmsConnector c = (JmsConnector)muleContext.getRegistry().lookupConnector(\"jmsConnector2\");\n        assertNotNull(c);\n\n        ConnectionFactory cf = (ConnectionFactory) c.getConnectionFactory();\n        assertTrue(cf instanceof TestConnectionFactory);\n        assertEquals(\"ConnectionFactory properties should be passed to the ConnectionFactory.\", \"TEST_VALUE\",\n            ((TestConnectionFactory)cf).getConnectionFactoryProperty());\n    }","id":26166,"modified_method":"/**\n     * Test connectionFactoryProperties set on JmsConnector are actually passed to\n     * the underlying ConnectionFactory.\n     */\n    public void testConnectionFactoryPropertiesPassed() throws Exception\n    {\n        JmsConnector c = (JmsConnector)muleContext.getRegistry().lookupConnector(\"jmsConnector2\");\n        assertNotNull(c);\n\n        ConnectionFactory cf = c.getConnectionFactory();\n        assertTrue(cf instanceof TestConnectionFactory);\n        assertEquals(\"ConnectionFactory properties should be passed to the ConnectionFactory.\", \"TEST_VALUE\",\n            ((TestConnectionFactory)cf).getConnectionFactoryProperty());\n    }","commit_id":"335321e0b40889a93173f0e6bca1f5d1ac05025c","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doSetUp() throws Exception\n    {\n        super.doSetUp();\n        \n        JmsConnector connector = (JmsConnector) muleContext.getRegistry().lookupConnector(\"jmsConnector\");\n        ConnectionFactory cf = (ConnectionFactory) connector.getConnectionFactory();\n        \n        session = cf.createConnection().createSession(false, Session.AUTO_ACKNOWLEDGE);                \n    }","id":26167,"modified_method":"protected void doSetUp() throws Exception\n    {\n        super.doSetUp();\n        \n        JmsConnector connector = (JmsConnector) muleContext.getRegistry().lookupConnector(\"jmsConnector\");\n        ConnectionFactory cf = connector.getConnectionFactory();\n        \n        session = cf.createConnection().createSession(false, Session.AUTO_ACKNOWLEDGE);                \n    }","commit_id":"335321e0b40889a93173f0e6bca1f5d1ac05025c","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testActiveMqDefault() throws Exception\n    {\n        JmsConnector c = (JmsConnector)muleContext.getRegistry().lookupConnector(\"activeMqConnectorDefaults\");\n        assertNotNull(c);\n        assertTrue(c instanceof ActiveMQJmsConnector);\n\n        assertNotNull(c.getConnectionFactory());\n        ConnectionFactory cf = (ConnectionFactory) c.getConnectionFactory();\n        assertTrue(cf instanceof ActiveMQConnectionFactory);\n        assertEquals(ActiveMQJmsConnector.DEFAULT_BROKER_URL, ((ActiveMQConnectionFactory) cf).getBrokerURL());\n    }","id":26168,"modified_method":"public void testActiveMqDefault() throws Exception\n    {\n        JmsConnector c = (JmsConnector)muleContext.getRegistry().lookupConnector(\"activeMqConnectorDefaults\");\n        assertNotNull(c);\n        assertTrue(c instanceof ActiveMQJmsConnector);\n\n        assertNotNull(c.getConnectionFactory());\n        ConnectionFactory cf = c.getConnectionFactory();\n        assertTrue(cf instanceof ActiveMQConnectionFactory);\n        assertEquals(ActiveMQJmsConnector.DEFAULT_BROKER_URL, ((ActiveMQConnectionFactory) cf).getBrokerURL());\n    }","commit_id":"335321e0b40889a93173f0e6bca1f5d1ac05025c","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testActiveMqBrokerURL() throws Exception\n    {\n        JmsConnector c = (JmsConnector)muleContext.getRegistry().lookupConnector(\"activeMqConnectorBroker\");\n        assertNotNull(c);\n        assertTrue(c instanceof ActiveMQJmsConnector);\n\n        assertNotNull(c.getConnectionFactory());\n        ConnectionFactory cf = (ConnectionFactory) c.getConnectionFactory();\n        assertTrue(cf instanceof ActiveMQConnectionFactory);\n        assertEquals(\"tcp://localhost:1234\", ((ActiveMQConnectionFactory) cf).getBrokerURL());\n    }","id":26169,"modified_method":"public void testActiveMqBrokerURL() throws Exception\n    {\n        JmsConnector c = (JmsConnector)muleContext.getRegistry().lookupConnector(\"activeMqConnectorBroker\");\n        assertNotNull(c);\n        assertTrue(c instanceof ActiveMQJmsConnector);\n\n        assertNotNull(c.getConnectionFactory());\n        ConnectionFactory cf = c.getConnectionFactory();\n        assertTrue(cf instanceof ActiveMQConnectionFactory);\n        assertEquals(\"tcp://localhost:1234\", ((ActiveMQConnectionFactory) cf).getBrokerURL());\n    }","commit_id":"335321e0b40889a93173f0e6bca1f5d1ac05025c","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testendpointActivationOK() throws Exception\n    {\n        MuleActivationSpec activationSpec = new MuleActivationSpec();\n        activationSpec.setResourceAdapter(resourceAdapter);\n        activationSpec.setModelName(\"jcaModel\");\n        activationSpec.setEndpoint(\"test://testEndpoint\");\n        MessageEndpointFactory endpointFactory = new MockEndpointFactory();\n\n        assertEquals(0, resourceAdapter.endpoints.size());\n\n        resourceAdapter.endpointActivation(endpointFactory, activationSpec);\n        assertEquals(1, resourceAdapter.endpoints.size());\n\n        MuleEndpointKey key = new MuleEndpointKey(endpointFactory, (MuleActivationSpec) activationSpec);\n        UMOComponent component = (UMOComponent) resourceAdapter.endpoints.get(key);\n\n        assertEquals(\"JcaComponent#\" + endpointFactory.hashCode(), component.getName());\n        testJcaComponent(component);\n        testEndpoint(component);\n        assertEquals(endpointFactory, component.getServiceFactory().getOrCreate());\n\n        // Additional activation with same endpointFactory does not increase size of\n        // endpoint cache.\n        resourceAdapter.endpointActivation(endpointFactory, activationSpec);\n        assertEquals(1, resourceAdapter.endpoints.size());\n\n        // Additional activation with new EndpointFactory instance increments size of\n        // endpoint cahce\n        resourceAdapter.endpointActivation(new MockEndpointFactory(), activationSpec);\n        assertEquals(2, resourceAdapter.endpoints.size());\n\n    }","id":26170,"modified_method":"public void testendpointActivationOK() throws Exception\n    {\n        MuleActivationSpec activationSpec = new MuleActivationSpec();\n        activationSpec.setResourceAdapter(resourceAdapter);\n        activationSpec.setModelName(\"jcaModel\");\n        activationSpec.setEndpoint(\"test://testEndpoint\");\n        MessageEndpointFactory endpointFactory = new MockEndpointFactory();\n\n        assertEquals(0, resourceAdapter.endpoints.size());\n\n        resourceAdapter.endpointActivation(endpointFactory, activationSpec);\n        assertEquals(1, resourceAdapter.endpoints.size());\n\n        MuleEndpointKey key = new MuleEndpointKey(endpointFactory, activationSpec);\n        UMOComponent component = (UMOComponent) resourceAdapter.endpoints.get(key);\n\n        assertEquals(\"JcaComponent#\" + endpointFactory.hashCode(), component.getName());\n        testJcaComponent(component);\n        testEndpoint(component);\n        assertEquals(endpointFactory, component.getServiceFactory().getOrCreate());\n\n        // Additional activation with same endpointFactory does not increase size of\n        // endpoint cache.\n        resourceAdapter.endpointActivation(endpointFactory, activationSpec);\n        assertEquals(1, resourceAdapter.endpoints.size());\n\n        // Additional activation with new EndpointFactory instance increments size of\n        // endpoint cahce\n        resourceAdapter.endpointActivation(new MockEndpointFactory(), activationSpec);\n        assertEquals(2, resourceAdapter.endpoints.size());\n\n    }","commit_id":"335321e0b40889a93173f0e6bca1f5d1ac05025c","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testLifeCycleMethods() throws Exception\n    {\n        PooledObjectFactory of = new PooledObjectFactory(UniqueComponent.class, getDefaultPoolingProfile());\n        of.initialise();        \n\n        String id = UUID.getUUID();\n        Object obj = ((PooledObjectFactory) of).makeObject(id);\n        assertNotNull(obj);\n        assertTrue(((PooledObjectFactory) of).validateObject(id, obj));\n        ((PooledObjectFactory) of).activateObject(id, obj);\n        ((PooledObjectFactory) of).passivateObject(id, obj);\n        ((PooledObjectFactory) of).destroyObject(id, obj);\n    }","id":26171,"modified_method":"public void testLifeCycleMethods() throws Exception\n    {\n        PooledObjectFactory of = new PooledObjectFactory(UniqueComponent.class, getDefaultPoolingProfile());\n        of.initialise();        \n\n        String id = UUID.getUUID();\n        Object obj = of.makeObject(id);\n        assertNotNull(obj);\n        assertTrue(of.validateObject(id, obj));\n        of.activateObject(id, obj);\n        of.passivateObject(id, obj);\n        of.destroyObject(id, obj);\n    }","commit_id":"335321e0b40889a93173f0e6bca1f5d1ac05025c","url":"https://github.com/mulesoft/mule"},{"original_method":"protected HttpResponse createResponse(Object src, String encoding, UMOMessage msg)\n        throws IOException, TransformerException\n    {\n        HttpResponse response = new HttpResponse();\n\n        int status = msg.getIntProperty(HttpConnector.HTTP_STATUS_PROPERTY, HttpConstants.SC_OK);\n        String version = msg.getStringProperty(HttpConnector.HTTP_VERSION_PROPERTY, HttpConstants.HTTP11);\n        String etag = msg.getStringProperty(HttpConstants.HEADER_ETAG, null);\n        \n        String date;\n        synchronized (format)\n        {\n            date = format.format(new Date());\n        }\n\n        String contentType = msg.getStringProperty(HttpConstants.HEADER_CONTENT_TYPE,\n            HttpConstants.DEFAULT_CONTENT_TYPE);\n\n        response.setStatusLine(HttpVersion.parse(version), status);\n        response.setHeader(new Header(HttpConstants.HEADER_CONTENT_TYPE, contentType));\n        response.setHeader(new Header(HttpConstants.HEADER_DATE, date));\n        response.setHeader(new Header(HttpConstants.HEADER_SERVER, server));\n        if (msg.getProperty(HttpConstants.HEADER_EXPIRES) == null)\n        {\n            response.setHeader(new Header(HttpConstants.HEADER_EXPIRES, date));\n        }\n        if (etag != null)\n        {\n            response.setHeader(new Header(HttpConstants.HEADER_ETAG, etag));\n        }\n        response.setFallbackCharset(encoding);\n\n        Collection headerNames = HttpConstants.RESPONSE_HEADER_NAMES.values();\n        String headerName, value;\n        for (Iterator iterator = headerNames.iterator(); iterator.hasNext();)\n        {\n            headerName = (String)iterator.next();\n            value = msg.getStringProperty(headerName, null);\n            if (value != null)\n            {\n                response.setHeader(new Header(headerName, value));\n            }\n        }\n\n        // Custom responseHeaderNames\n        Map customHeaders = (Map)msg.getProperty(HttpConnector.HTTP_CUSTOM_HEADERS_MAP_PROPERTY);\n        if (customHeaders != null)\n        {\n            Map.Entry entry;\n            for (Iterator iterator = customHeaders.entrySet().iterator(); iterator.hasNext();)\n            {\n                entry = (Map.Entry)iterator.next();\n                if (entry.getValue() != null)\n                {\n                    response.setHeader(new Header(entry.getKey().toString(), entry.getValue().toString()));\n                }\n            }\n        }\n\n        // Mule properties\n        String user = msg.getStringProperty(MuleProperties.MULE_USER_PROPERTY, null);\n        if (user != null)\n        {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_USER_PROPERTY, user));\n        }\n        if (msg.getCorrelationId() != null)\n        {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_CORRELATION_ID_PROPERTY,\n                msg.getCorrelationId()));\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                                          + MuleProperties.MULE_CORRELATION_GROUP_SIZE_PROPERTY,\n                String.valueOf(msg.getCorrelationGroupSize())));\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                                          + MuleProperties.MULE_CORRELATION_SEQUENCE_PROPERTY,\n                String.valueOf(msg.getCorrelationSequence())));\n        }\n        if (msg.getReplyTo() != null)\n        {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_REPLY_TO_PROPERTY,\n                msg.getReplyTo().toString()));\n        }\n        if (src instanceof InputStream)\n        {\n            response.setBody((InputStream)src);\n        }\n        else if (src instanceof String)\n        {\n            response.setBodyString(src.toString());\n        }\n        else\n        {\n            try\n            {\n                response.setBody(new ByteArrayInputStream((byte[])msg.getPayloadAsBytes()));\n            }\n            catch (Exception e)\n            {\n                throw new TransformerException(this, e);\n            }\n        }\n        return response;\n    }","id":26172,"modified_method":"protected HttpResponse createResponse(Object src, String encoding, UMOMessage msg)\n        throws IOException, TransformerException\n    {\n        HttpResponse response = new HttpResponse();\n\n        int status = msg.getIntProperty(HttpConnector.HTTP_STATUS_PROPERTY, HttpConstants.SC_OK);\n        String version = msg.getStringProperty(HttpConnector.HTTP_VERSION_PROPERTY, HttpConstants.HTTP11);\n        String etag = msg.getStringProperty(HttpConstants.HEADER_ETAG, null);\n        \n        String date;\n        synchronized (format)\n        {\n            date = format.format(new Date());\n        }\n\n        String contentType = msg.getStringProperty(HttpConstants.HEADER_CONTENT_TYPE,\n            HttpConstants.DEFAULT_CONTENT_TYPE);\n\n        response.setStatusLine(HttpVersion.parse(version), status);\n        response.setHeader(new Header(HttpConstants.HEADER_CONTENT_TYPE, contentType));\n        response.setHeader(new Header(HttpConstants.HEADER_DATE, date));\n        response.setHeader(new Header(HttpConstants.HEADER_SERVER, server));\n        if (msg.getProperty(HttpConstants.HEADER_EXPIRES) == null)\n        {\n            response.setHeader(new Header(HttpConstants.HEADER_EXPIRES, date));\n        }\n        if (etag != null)\n        {\n            response.setHeader(new Header(HttpConstants.HEADER_ETAG, etag));\n        }\n        response.setFallbackCharset(encoding);\n\n        Collection headerNames = HttpConstants.RESPONSE_HEADER_NAMES.values();\n        String headerName, value;\n        for (Iterator iterator = headerNames.iterator(); iterator.hasNext();)\n        {\n            headerName = (String)iterator.next();\n            value = msg.getStringProperty(headerName, null);\n            if (value != null)\n            {\n                response.setHeader(new Header(headerName, value));\n            }\n        }\n\n        // Custom responseHeaderNames\n        Map customHeaders = (Map)msg.getProperty(HttpConnector.HTTP_CUSTOM_HEADERS_MAP_PROPERTY);\n        if (customHeaders != null)\n        {\n            Map.Entry entry;\n            for (Iterator iterator = customHeaders.entrySet().iterator(); iterator.hasNext();)\n            {\n                entry = (Map.Entry)iterator.next();\n                if (entry.getValue() != null)\n                {\n                    response.setHeader(new Header(entry.getKey().toString(), entry.getValue().toString()));\n                }\n            }\n        }\n\n        // Mule properties\n        String user = msg.getStringProperty(MuleProperties.MULE_USER_PROPERTY, null);\n        if (user != null)\n        {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_USER_PROPERTY, user));\n        }\n        if (msg.getCorrelationId() != null)\n        {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_CORRELATION_ID_PROPERTY,\n                msg.getCorrelationId()));\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                                          + MuleProperties.MULE_CORRELATION_GROUP_SIZE_PROPERTY,\n                String.valueOf(msg.getCorrelationGroupSize())));\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                                          + MuleProperties.MULE_CORRELATION_SEQUENCE_PROPERTY,\n                String.valueOf(msg.getCorrelationSequence())));\n        }\n        if (msg.getReplyTo() != null)\n        {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_REPLY_TO_PROPERTY,\n                msg.getReplyTo().toString()));\n        }\n        if (src instanceof InputStream)\n        {\n            response.setBody((InputStream)src);\n        }\n        else if (src instanceof String)\n        {\n            response.setBodyString(src.toString());\n        }\n        else\n        {\n            try\n            {\n                response.setBody(new ByteArrayInputStream(msg.getPayloadAsBytes()));\n            }\n            catch (Exception e)\n            {\n                throw new TransformerException(this, e);\n            }\n        }\n        return response;\n    }","commit_id":"335321e0b40889a93173f0e6bca1f5d1ac05025c","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerStandardTransportEndpoints(JdbcConnector.JDBC, ADDRESS_ATTRIBUTES).addAlias(QUERY_KEY, URIBuilder.PATH);\n        registerBeanDefinitionParser(\"connector\", new MuleOrphanDefinitionParser(JdbcConnector.class, true));\n        registerBeanDefinitionParser(\"dataSource\", new ObjectFactoryWrapper(\"dataSourceFactory\"));\n        MuleDefinitionParser connectorQuery = new ChildSingletonMapDefinitionParser(\"query\");\n        MuleDefinitionParser endpointQuery = new NestedMapDefinitionParser(\"properties\", \"queries\");\n        endpointQuery.addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"query\", new ParentContextDefinitionParser(\"connector\", connectorQuery).otherwise(endpointQuery));\n        registerBeanDefinitionParser(\"extractors\", new ParentDefinitionParser());\n        registerBeanDefinitionParser(\"transaction-factory\", new TransactionFactoryDefinitionParser(JdbcTransactionFactory.class));\n    }","id":26173,"modified_method":"public void init()\n    {\n        registerStandardTransportEndpoints(JdbcConnector.JDBC, ADDRESS_ATTRIBUTES).addAlias(QUERY_KEY, URIBuilder.PATH);\n        registerBeanDefinitionParser(\"connector\", new MuleOrphanDefinitionParser(JdbcConnector.class, true));\n        registerBeanDefinitionParser(\"dataSource\", new ObjectFactoryWrapper(\"dataSourceFactory\"));\n        MuleDefinitionParser connectorQuery = new ChildSingletonMapDefinitionParser(\"query\");\n        MuleDefinitionParser endpointQuery = new NestedMapDefinitionParser(\"properties\", \"queries\");\n        endpointQuery.addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"query\", new ParentContextDefinitionParser(\"connector\", connectorQuery).otherwise(endpointQuery));\n        registerBeanDefinitionParser(\"extractors\", new ParentDefinitionParser());\n        registerBeanDefinitionParser(\"transaction\", new TransactionDefinitionParser(JdbcTransactionFactory.class));\n    }","commit_id":"fd9c74ca731a0887eedab0e7977e78a5bc5df40c","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerJmsTransportEndpoints();\n\n        registerBeanDefinitionParser(\"connector\", new JmsConnectorDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new JmsConnectorDefinitionParser());\n        registerBeanDefinitionParser(\"activemq-connector\", new JmsConnectorDefinitionParser(ActiveMQJmsConnector.class));\n        registerBeanDefinitionParser(\"activemq-xa-connector\", new JmsConnectorDefinitionParser(ActiveMQXAJmsConnector.class));\n        \n        registerBeanDefinitionParser(\"weblogic-connector\", new JmsConnectorDefinitionParser(WeblogicJmsConnector.class));\n        registerBeanDefinitionParser(\"websphere-connector\", new JmsConnectorDefinitionParser(WebsphereJmsConnector.class));\n\n        registerBeanDefinitionParser(\"transaction-factory\", new TransactionFactoryDefinitionParser(JmsTransactionFactory.class));\n        registerBeanDefinitionParser(\"client-ack-transaction-factory\", new TransactionFactoryDefinitionParser(JmsClientAcknowledgeTransactionFactory.class));\n        registerBeanDefinitionParser(\"xa-transaction-factory\", new TransactionFactoryDefinitionParser(XaTransactionFactory.class));        \n\n        registerBeanDefinitionParser(\"jmsmessage-to-object-transformer\", new TransformerDefinitionParser(JMSMessageToObject.class));\n\n        registerBeanDefinitionParser(\"object-to-jmsmessage-transformer\", new TransformerDefinitionParser(ObjectToJMSMessage.class));\n        registerBeanDefinitionParser(\"property-filter\", new FilterDefinitionParser(JmsPropertyFilter.class));\n        registerBeanDefinitionParser(\"selector\", new ChildDefinitionParser(FilterDefinitionParser.FILTER, JmsSelectorFilter.class));\n    }","id":26174,"modified_method":"public void init()\n    {\n        registerJmsTransportEndpoints();\n\n        registerBeanDefinitionParser(\"connector\", new JmsConnectorDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new JmsConnectorDefinitionParser());\n        registerBeanDefinitionParser(\"activemq-connector\", new JmsConnectorDefinitionParser(ActiveMQJmsConnector.class));\n        registerBeanDefinitionParser(\"activemq-xa-connector\", new JmsConnectorDefinitionParser(ActiveMQXAJmsConnector.class));\n        \n        registerBeanDefinitionParser(\"weblogic-connector\", new JmsConnectorDefinitionParser(WeblogicJmsConnector.class));\n        registerBeanDefinitionParser(\"websphere-connector\", new JmsConnectorDefinitionParser(WebsphereJmsConnector.class));\n\n        registerBeanDefinitionParser(\"transaction\", new TransactionDefinitionParser(JmsTransactionFactory.class));\n        registerBeanDefinitionParser(\"client-ack-transaction\", new TransactionDefinitionParser(JmsClientAcknowledgeTransactionFactory.class));\n        registerBeanDefinitionParser(\"xa-transaction\", new TransactionDefinitionParser(XaTransactionFactory.class));        \n\n        registerBeanDefinitionParser(\"jmsmessage-to-object-transformer\", new TransformerDefinitionParser(JMSMessageToObject.class));\n\n        registerBeanDefinitionParser(\"object-to-jmsmessage-transformer\", new TransformerDefinitionParser(ObjectToJMSMessage.class));\n        registerBeanDefinitionParser(\"property-filter\", new FilterDefinitionParser(JmsPropertyFilter.class));\n        registerBeanDefinitionParser(\"selector\", new ChildDefinitionParser(FilterDefinitionParser.FILTER, JmsSelectorFilter.class));\n    }","commit_id":"fd9c74ca731a0887eedab0e7977e78a5bc5df40c","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testTransactionFactory()\n    {\n        TestTransactionFactory factory = (TestTransactionFactory) managementContext.getRegistry().lookupObject(\"txFactory\");\n        assertNotNull(factory);\n        assertEquals(\"foo\", factory.getValue());\n    }","id":26175,"modified_method":"public void testCustomTransactions() throws EndpointException, InitialisationException\n    {\n        UMOImmutableEndpoint endpoint3 = managementContext.getRegistry().lookupEndpointBuilder(\"endpoint3\").buildInboundEndpoint();\n        assertNotNull(endpoint3);\n        TestTransactionFactory factory = (TestTransactionFactory) endpoint3.getTransactionConfig().getFactory();\n        assertNotNull(factory);\n        assertEquals(\"foo\", factory.getValue());\n    }","commit_id":"fd9c74ca731a0887eedab0e7977e78a5bc5df40c","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doSetUp() throws Exception\n    {\n        super.doSetUp();\n\n        JmsConnector connector = (JmsConnector) managementContext.getRegistry().lookupConnector(\"jmsConnector\");\n        ConnectionFactory cf = (ConnectionFactory) connector.getConnectionFactory();\n\n        session = cf.createConnection().createSession(false, Session.AUTO_ACKNOWLEDGE);\n    }","id":26176,"modified_method":"protected void doSetUp() throws Exception\n    {\n        super.doSetUp();\n\n        JmsConnector connector = (JmsConnector) managementContext.getRegistry().lookupConnector(\"jmsConnector\");\n        ConnectionFactory cf = connector.getConnectionFactory();\n\n        session = cf.createConnection().createSession(false, Session.AUTO_ACKNOWLEDGE);\n    }","commit_id":"fd9c74ca731a0887eedab0e7977e78a5bc5df40c","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-property\", new EnvironmentPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"admin-agent\", new MuleAdminAgentDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-component-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        //registerBeanDefinitionParser(\"mule-configuration\", new ManagementContextDefinitionParser());\n        registerBeanDefinitionParser(\"component-threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleConfiguration.DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultComponentExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n        registerMuleBeanDefinitionParser(\"notifications\", new NamedDefinitionParser(MuleProperties.OBJECT_NOTIFICATION_MANAGER)).addAlias(\"dynamic\", \"notificationDynamic\");\n        registerBeanDefinitionParser(\"notification\", new NotificationDefinitionParser());\n        registerBeanDefinitionParser(\"disable-notification\", new NotificationDisableDefinitionParser());\n        registerMuleBeanDefinitionParser(\"notification-listener\", new ChildDefinitionParser(\"allListenerSubscriptionPair\", ListenerSubscriptionPair.class)).addAlias(\"ref\", \"listener\").addReference(\"listener\");\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleConfiguration.DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleConfiguration.DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser(\"dispatcherConnectionStrategy\"));\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser(\"receiverConnectionStrategy\"));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n        registerBeanDefinitionParser(\"transformers\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"responseTransformers\", new ParentDefinitionParser()).addAlias(\"transformer\", \"responseTransformer\");\n\n        registerBeanDefinitionParser(\"transformer\", new TransformerRefDefinitionParser());\n\n        registerBeanDefinitionParser(\"custom-transformer\", new TransformerDefinitionParser());\n        registerBeanDefinitionParser(\"no-action-transformer\", new TransformerDefinitionParser(NoActionTransformer.class));\n        registerBeanDefinitionParser(\"message-properties-transformer\", new TransformerDefinitionParser(MessagePropertiesTransformer.class));\n\n        registerBeanDefinitionParser(\"base64-encoder-transformer\", new TransformerDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"base64-decoder-transformer\", new TransformerDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"xml-entity-encoder-transformer\", new TransformerDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"xml-entity-decoder-transformer\", new TransformerDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"gzip-compress-transformer\", new TransformerDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"gzip-uncompress-transformer\", new TransformerDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"encrypt-transformer\", new TransformerDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"decrypt-transformer\", new TransformerDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"byte-array-to-hex-string-transformer\", new TransformerDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"hex-string-to-byte-array-transformer\", new TransformerDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"byte-array-to-object-transformer\", new TransformerDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"object-to-byte-array-transformer\", new TransformerDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"object-to-string-transformer\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"byte-array-to-serializable-transformer\", new TransformerDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"serializable-to-byte-array-transformer\", new TransformerDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"byte-array-to-string-transformer\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"string-to-byte-array-transformer\", new TransformerDefinitionParser(ObjectToByteArray.class));\n\n        registerBeanDefinitionParser(\"append-string-transformer\", new TransformerDefinitionParser(StringAppendTransformer.class));\n\n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"resin-transaction-manager\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new GenericEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new GenericEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"transaction\", new TransactionConfigDefinitionParser());\n        registerBeanDefinitionParser(\"custom-transaction-factory\", new TransactionFactoryDefinitionParser());\n        registerMuleBeanDefinitionParser(\"transaction-factory\", new ParentDefinitionParser()).addAlias(\"ref\", \"factory\");\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new MuleOrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new MuleOrphanDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new MuleOrphanDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new MuleOrphanDefinitionParser(PropertiesContainerContext.class, true));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n//        registerBeanDefinitionParser(\"model-seda-optimised\", new OrphanDefinitionParser(OptimisedSedaModel.class, true));\n//        registerBeanDefinitionParser(\"model-pipeline\", new OrphanDefinitionParser(PipelineModel.class, true));\n\n        registerBeanDefinitionParser(\"entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", DefaultEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"legacy-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", LegacyEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"custom-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\"));\n\n        registerBeanDefinitionParser(\"custom-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\"));\n        registerBeanDefinitionParser(\"callable-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"property-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", MethodHeaderPropertyEntryPointResolver.class)).addAlias(\"property\", \"methodProperty\");\n        registerBeanDefinitionParser(\"method-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ExplicitMethodEntryPointResolver.class));\n        registerBeanDefinitionParser(\"reflection-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ReflectionEntryPointResolver.class));\n        registerBeanDefinitionParser(\"no-arguments-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", NoArgumentsEntryPointResolver.class));\n        registerBeanDefinitionParser(\"array-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ArrayEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"include-entry-point\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"exclude-entry-point\", new ParentDefinitionParser()).addAlias(\"method\", \"ignoredMethod\");\n        registerMuleBeanDefinitionParser(\"exclude-object-methods\", new IgnoreObjectMethodsDefinitionParser());\n\n        // Services\n        registerBeanDefinitionParser(\"seda-component\", new ServiceDefinitionParser(SedaComponent.class));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(SedaComponent.class));\n\n        // Pojo Components\n        registerBeanDefinitionParser(\"component\", new ComponentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"binding\", new BindingDefinitionParser(\"nestedRouter.routers\", NestedRouter.class)).addCollection(\"nestedRouter.routers\");\n\n        // Other Components\n        registerBeanDefinitionParser(\"bridge-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"pass-through-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimplePojoServiceDefinitionParser(LogComponent.class));\n        registerBeanDefinitionParser(\"echo-component\", new SimplePojoServiceDefinitionParser(EchoComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimplePojoServiceDefinitionParser(NullComponent.class));\n\n        // Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new ObjectFactoryDefinitionParser(SingletonObjectFactory.class));\n        registerBeanDefinitionParser(\"prototype-object\", new ObjectFactoryDefinitionParser(PrototypeObjectFactory.class));\n        registerBeanDefinitionParser(\"pooled-object\", new ObjectFactoryDefinitionParser(PooledObjectFactory.class));\n        registerBeanDefinitionParser(\"spring-factory-bean\", new SpringFactoryBeanDefinitionParser());\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound-router\", new ChildDefinitionParser(\"inboundRouter\", InboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound-router\", new ChildDefinitionParser(\"outboundRouter\", OutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"async-reply-router\", new ChildDefinitionParser(\"responseRouter\", ResponseRouterCollection.class));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new ForwardingRouterDefinitionParser());\n        registerBeanDefinitionParser(\"inbound-pass-through-router\", new RouterDefinitionParser(\"router\", InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(\"router\", SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(\"router\", WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser(\"router\"));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(\"router\", MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(\"router\", CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"outbound-pass-through-router\", new RouterDefinitionParser(\"router\", OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(\"router\", FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(\"router\", ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(\"router\", EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(\"router\", ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(\"router\", FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(\"router\", MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(\"router\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(\"router\", StaticRecipientList.class));\n        registerBeanDefinitionParser(\"recipients\", new ChildListDefinitionParser(\"recipients\"));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(\"router\", TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(\"router\", null));\n        registerMuleBeanDefinitionParser(\"reply-to\", new ParentDefinitionParser()).addAlias(\"address\", \"replyTo\");\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-async-reply-router\", new RouterDefinitionParser(\"router\", null));\n        registerBeanDefinitionParser(\"single-async-reply-router\", new RouterDefinitionParser(\"router\", SingleResponseRouter.class));\n\n        //Property Extractors\n        registerBeanDefinitionParser(\"function-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", FunctionPropertyExtractor.class));\n        registerBeanDefinitionParser(\"correlation-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", CorrelationPropertiesExtractor.class));\n        registerBeanDefinitionParser(\"custom-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\"));\n        registerBeanDefinitionParser(\"map-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MapPayloadPropertyExtractor.class));\n        registerBeanDefinitionParser(\"message-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MessageHeaderPropertyExtractor.class));\n        //registerBeanDefinitionParser(\"payload-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", PayloadPropertyExtractor.class));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerMuleBeanDefinitionParser(\"filter\", new ParentDefinitionParser()).addAlias(\"ref\", \"filter\");\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new ChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        //Utils / Standard Types\n        registerMuleBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"property\", new ChildMapEntryDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"add-message-properties\", new ChildMapDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"add-message-property\", new ChildMapEntryDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerBeanDefinitionParser(\"delete-message-property\", new ChildListEntryDefinitionParser(\"deleteProperties\", ChildMapEntryDefinitionParser.KEY));\n        registerMuleBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerMuleBeanDefinitionParser(\"jndi-provider-property\", new ChildMapEntryDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n\n        //Security\n        registerMuleBeanDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\").addIgnored(\"name\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleBeanDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new ChildDefinitionParser(\"securityFilter\", MuleEncryptionEndpointSecurityFilter.class));\n    }","id":26177,"modified_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-property\", new EnvironmentPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"admin-agent\", new MuleAdminAgentDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-component-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        //registerBeanDefinitionParser(\"mule-configuration\", new ManagementContextDefinitionParser());\n        registerBeanDefinitionParser(\"component-threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleConfiguration.DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultComponentExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n        registerMuleBeanDefinitionParser(\"notifications\", new NamedDefinitionParser(MuleProperties.OBJECT_NOTIFICATION_MANAGER)).addAlias(\"dynamic\", \"notificationDynamic\");\n        registerBeanDefinitionParser(\"notification\", new NotificationDefinitionParser());\n        registerBeanDefinitionParser(\"disable-notification\", new NotificationDisableDefinitionParser());\n        registerMuleBeanDefinitionParser(\"notification-listener\", new ChildDefinitionParser(\"allListenerSubscriptionPair\", ListenerSubscriptionPair.class)).addAlias(\"ref\", \"listener\").addReference(\"listener\");\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleConfiguration.DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleConfiguration.DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser(\"dispatcherConnectionStrategy\"));\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser(\"receiverConnectionStrategy\"));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n        registerBeanDefinitionParser(\"transformers\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"responseTransformers\", new ParentDefinitionParser()).addAlias(\"transformer\", \"responseTransformer\");\n\n        registerBeanDefinitionParser(\"transformer\", new TransformerRefDefinitionParser());\n\n        registerBeanDefinitionParser(\"custom-transformer\", new TransformerDefinitionParser());\n        registerBeanDefinitionParser(\"no-action-transformer\", new TransformerDefinitionParser(NoActionTransformer.class));\n        registerBeanDefinitionParser(\"message-properties-transformer\", new TransformerDefinitionParser(MessagePropertiesTransformer.class));\n\n        registerBeanDefinitionParser(\"base64-encoder-transformer\", new TransformerDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"base64-decoder-transformer\", new TransformerDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"xml-entity-encoder-transformer\", new TransformerDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"xml-entity-decoder-transformer\", new TransformerDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"gzip-compress-transformer\", new TransformerDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"gzip-uncompress-transformer\", new TransformerDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"encrypt-transformer\", new TransformerDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"decrypt-transformer\", new TransformerDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"byte-array-to-hex-string-transformer\", new TransformerDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"hex-string-to-byte-array-transformer\", new TransformerDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"byte-array-to-object-transformer\", new TransformerDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"object-to-byte-array-transformer\", new TransformerDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"object-to-string-transformer\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"byte-array-to-serializable-transformer\", new TransformerDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"serializable-to-byte-array-transformer\", new TransformerDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"byte-array-to-string-transformer\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"string-to-byte-array-transformer\", new TransformerDefinitionParser(ObjectToByteArray.class));\n\n        registerBeanDefinitionParser(\"append-string-transformer\", new TransformerDefinitionParser(StringAppendTransformer.class));\n\n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"resin-transaction-manager\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new GenericEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new GenericEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"custom-transaction\", new TransactionDefinitionParser());\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new MuleOrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new MuleOrphanDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new MuleOrphanDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new MuleOrphanDefinitionParser(PropertiesContainerContext.class, true));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n//        registerBeanDefinitionParser(\"model-seda-optimised\", new OrphanDefinitionParser(OptimisedSedaModel.class, true));\n//        registerBeanDefinitionParser(\"model-pipeline\", new OrphanDefinitionParser(PipelineModel.class, true));\n\n        registerBeanDefinitionParser(\"entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", DefaultEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"legacy-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", LegacyEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"custom-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\"));\n\n        registerBeanDefinitionParser(\"custom-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\"));\n        registerBeanDefinitionParser(\"callable-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"property-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", MethodHeaderPropertyEntryPointResolver.class)).addAlias(\"property\", \"methodProperty\");\n        registerBeanDefinitionParser(\"method-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ExplicitMethodEntryPointResolver.class));\n        registerBeanDefinitionParser(\"reflection-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ReflectionEntryPointResolver.class));\n        registerBeanDefinitionParser(\"no-arguments-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", NoArgumentsEntryPointResolver.class));\n        registerBeanDefinitionParser(\"array-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ArrayEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"include-entry-point\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"exclude-entry-point\", new ParentDefinitionParser()).addAlias(\"method\", \"ignoredMethod\");\n        registerMuleBeanDefinitionParser(\"exclude-object-methods\", new IgnoreObjectMethodsDefinitionParser());\n\n        // Services\n        registerBeanDefinitionParser(\"seda-component\", new ServiceDefinitionParser(SedaComponent.class));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(SedaComponent.class));\n\n        // Pojo Components\n        registerBeanDefinitionParser(\"component\", new ComponentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"binding\", new BindingDefinitionParser(\"nestedRouter.routers\", NestedRouter.class)).addCollection(\"nestedRouter.routers\");\n\n        // Other Components\n        registerBeanDefinitionParser(\"bridge-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"pass-through-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimplePojoServiceDefinitionParser(LogComponent.class));\n        registerBeanDefinitionParser(\"echo-component\", new SimplePojoServiceDefinitionParser(EchoComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimplePojoServiceDefinitionParser(NullComponent.class));\n\n        // Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new ObjectFactoryDefinitionParser(SingletonObjectFactory.class));\n        registerBeanDefinitionParser(\"prototype-object\", new ObjectFactoryDefinitionParser(PrototypeObjectFactory.class));\n        registerBeanDefinitionParser(\"pooled-object\", new ObjectFactoryDefinitionParser(PooledObjectFactory.class));\n        registerBeanDefinitionParser(\"spring-factory-bean\", new SpringFactoryBeanDefinitionParser());\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound-router\", new ChildDefinitionParser(\"inboundRouter\", InboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound-router\", new ChildDefinitionParser(\"outboundRouter\", OutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"async-reply-router\", new ChildDefinitionParser(\"responseRouter\", ResponseRouterCollection.class));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new ForwardingRouterDefinitionParser());\n        registerBeanDefinitionParser(\"inbound-pass-through-router\", new RouterDefinitionParser(\"router\", InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(\"router\", SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(\"router\", WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser(\"router\"));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(\"router\", MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(\"router\", CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"outbound-pass-through-router\", new RouterDefinitionParser(\"router\", OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(\"router\", FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(\"router\", ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(\"router\", EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(\"router\", ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(\"router\", FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(\"router\", MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(\"router\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(\"router\", StaticRecipientList.class));\n        registerBeanDefinitionParser(\"recipients\", new ChildListDefinitionParser(\"recipients\"));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(\"router\", TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(\"router\", null));\n        registerMuleBeanDefinitionParser(\"reply-to\", new ParentDefinitionParser()).addAlias(\"address\", \"replyTo\");\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-async-reply-router\", new RouterDefinitionParser(\"router\", null));\n        registerBeanDefinitionParser(\"single-async-reply-router\", new RouterDefinitionParser(\"router\", SingleResponseRouter.class));\n\n        //Property Extractors\n        registerBeanDefinitionParser(\"function-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", FunctionPropertyExtractor.class));\n        registerBeanDefinitionParser(\"correlation-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", CorrelationPropertiesExtractor.class));\n        registerBeanDefinitionParser(\"custom-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\"));\n        registerBeanDefinitionParser(\"map-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MapPayloadPropertyExtractor.class));\n        registerBeanDefinitionParser(\"message-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MessageHeaderPropertyExtractor.class));\n        //registerBeanDefinitionParser(\"payload-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", PayloadPropertyExtractor.class));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerMuleBeanDefinitionParser(\"filter\", new ParentDefinitionParser()).addAlias(\"ref\", \"filter\");\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new ChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        //Utils / Standard Types\n        registerMuleBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"property\", new ChildMapEntryDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"add-message-properties\", new ChildMapDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"add-message-property\", new ChildMapEntryDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerBeanDefinitionParser(\"delete-message-property\", new ChildListEntryDefinitionParser(\"deleteProperties\", ChildMapEntryDefinitionParser.KEY));\n        registerMuleBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerMuleBeanDefinitionParser(\"jndi-provider-property\", new ChildMapEntryDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n\n        //Security\n        registerMuleBeanDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\").addIgnored(\"name\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleBeanDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new ChildDefinitionParser(\"securityFilter\", MuleEncryptionEndpointSecurityFilter.class));\n    }","commit_id":"fd9c74ca731a0887eedab0e7977e78a5bc5df40c","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void checkDomElement(DomElement element, DomElementAnnotationHolder holder, DomHighlightingHelper helper) {\n    final int oldSize = holder.getSize();\n    if (element instanceof GenericDomValue) {\n      final GenericDomValue genericDomValue = (GenericDomValue)element;\n      if (shouldCheckResolveProblems(genericDomValue)) {\n        helper.checkResolveProblems(genericDomValue, holder);\n      }\n    }\n    for (final Class<? extends T> aClass : getDomClasses()) {\n      helper.runAnnotators(element, holder, aClass);\n    }\n    if (oldSize != holder.getSize()) return;\n\n    if (!helper.checkRequired(element, holder).isEmpty()) return;\n    if (element instanceof GenericDomValue) {\n      helper.checkExtendClass((GenericDomValue)element, holder);\n    } else {\n      helper.checkNameIdentity(element, holder);\n    }\n  }","id":26178,"modified_method":"/**\n   * The default implementations checks for resolve problems (if {@link #shouldCheckResolveProblems(com.intellij.util.xml.GenericDomValue)} returns true),\n   * then runs annotators (see {@link com.intellij.util.xml.DomFileDescription#createAnnotator()}),\n   * checks for {@link @com.intellij.util.xml.Required} and {@link @com.intellij.util.xml.ExtendClass} annotation problems, checks\n   * for name identity (see {@link @com.intellij.util.xml.NameValue} annotation).\n   * @param element element to check\n   * @param holder a place to add problems to\n   * @param helper helper object\n   */\n  protected void checkDomElement(DomElement element, DomElementAnnotationHolder holder, DomHighlightingHelper helper) {\n    final int oldSize = holder.getSize();\n    if (element instanceof GenericDomValue) {\n      final GenericDomValue genericDomValue = (GenericDomValue)element;\n      if (shouldCheckResolveProblems(genericDomValue)) {\n        helper.checkResolveProblems(genericDomValue, holder);\n      }\n    }\n    for (final Class<? extends T> aClass : getDomClasses()) {\n      helper.runAnnotators(element, holder, aClass);\n    }\n    if (oldSize != holder.getSize()) return;\n\n    if (!helper.checkRequired(element, holder).isEmpty()) return;\n    if (element instanceof GenericDomValue) {\n      helper.checkExtendClass((GenericDomValue)element, holder);\n    } else {\n      helper.checkNameIdentity(element, holder);\n    }\n  }","commit_id":"70976a601e6606ddfd1a75e2df0a7e94a8521806","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean shouldCheckResolveProblems(GenericDomValue value) {\n    return true;\n  }","id":26179,"modified_method":"/**\n   * One may want to create several inspections that check for unresolved DOM references of different types. Through this method one can control\n   * these types. \n   * @param value GenericDomValue containing references in question\n   * @return whether to check for resolve problems\n   */\n  protected boolean shouldCheckResolveProblems(GenericDomValue value) {\n    return true;\n  }","commit_id":"70976a601e6606ddfd1a75e2df0a7e94a8521806","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final Set<Class<? extends T>> getDomClasses() {\n    return myDomClasses;\n  }","id":26180,"modified_method":"/**\n   * @return the classes passed earlier to the constructor\n   */\n  public final Set<Class<? extends T>> getDomClasses() {\n    return myDomClasses;\n  }","commit_id":"70976a601e6606ddfd1a75e2df0a7e94a8521806","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void checkDomElement(DomElement element, DomElementAnnotationHolder holder, DomHighlightingHelper helper) {\n    throw new UnsupportedOperationException();\n  }","id":26181,"modified_method":"/**\n   * Check particular DOM element for problems. The inspection implementor should focus on this method.\n   * The default implementation throws {@link UnsupportedOperationException}.\n   * See {@link com.intellij.util.xml.highlighting.BasicDomElementsInspection}\n   * @param element element to check\n   * @param holder a place to add problems to\n   * @param helper helper object\n   */\n  protected void checkDomElement(DomElement element, DomElementAnnotationHolder holder, DomHighlightingHelper helper) {\n    throw new UnsupportedOperationException();\n  }","commit_id":"70976a601e6606ddfd1a75e2df0a7e94a8521806","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void checkFileElement(DomFileElement<T> domFileElement, final DomElementAnnotationHolder holder) {\n    final DomHighlightingHelper helper =\n      DomElementAnnotationsManager.getInstance(domFileElement.getManager().getProject()).getHighlightingHelper();\n    final Ref<Boolean> ref = new Ref<Boolean>(Boolean.FALSE);\n    domFileElement.accept(new DomElementVisitor() {\n      public void visitDomElement(DomElement element) {\n        final Boolean old = ref.get();\n        ref.set(Boolean.FALSE);\n        element.acceptChildren(this);\n        if (ref.get().booleanValue()) {\n          ref.set(old);\n          return;\n        }\n        final int oldSize = holder.getSize();\n        checkDomElement(element, holder, helper);\n        ref.set(oldSize != holder.getSize());\n      }\n    });\n  }","id":26182,"modified_method":"/**\n   * This method is called internally in {@link com.intellij.util.xml.highlighting.DomElementAnnotationsManager#getProblemHolder(com.intellij.util.xml.DomElement)},\n   * it should add some problems to the annotation holder. The default implementation performs recursive tree traversal, and calls\n   * {@link #checkDomElement(com.intellij.util.xml.DomElement, DomElementAnnotationHolder, DomHighlightingHelper)} for each element. \n   * @param domFileElement file element to check\n   * @param holder the place to store problems\n   */\n  public void checkFileElement(DomFileElement<T> domFileElement, final DomElementAnnotationHolder holder) {\n    final DomHighlightingHelper helper =\n      DomElementAnnotationsManager.getInstance(domFileElement.getManager().getProject()).getHighlightingHelper();\n    domFileElement.accept(new DomElementVisitor() {\n      public void visitDomElement(DomElement element) {\n        element.acceptChildren(this);\n        checkDomElement(element, holder, helper);\n      }\n    });\n  }","commit_id":"70976a601e6606ddfd1a75e2df0a7e94a8521806","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DomElementsProblemsHolderImpl(final DomFileElement element) {\n    myElement = element;\n    myRootType = DomReflectionUtil.getRawType(myElement.getRootElement().getDomElementType());\n  }","id":26183,"modified_method":"public DomElementsProblemsHolderImpl(final DomFileElement element) {\n    myElement = element;\n    myRootType = (Class<? extends DomElement>)DomReflectionUtil.getRawType(myElement.getRootElement().getDomElementType());\n  }","commit_id":"70976a601e6606ddfd1a75e2df0a7e94a8521806","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void calculateAllProblems() {\n    boolean hasInspections = false;\n    final InspectionProjectProfileManager profileManager = InspectionProjectProfileManager.getInstance(myElement.getManager().getProject());\n    final InspectionProfile profile = profileManager.getInspectionProfile(myElement.getFile());\n    for (final InspectionProfileEntry profileEntry : profile.getInspectionTools()) {\n      hasInspections |= processProfileEntry(profile.isToolEnabled(HighlightDisplayKey.find(profileEntry.getShortName())), profileEntry);\n    }\n    if (!hasInspections) {\n      runInspection(MockDomInspection.INSTANCE);\n    }\n  }","id":26184,"modified_method":"public final void calculateAllProblems() {\n    boolean hasInspections = false;\n    final InspectionProjectProfileManager profileManager = InspectionProjectProfileManager.getInstance(myElement.getManager().getProject());\n    final InspectionProfile profile = profileManager.getInspectionProfile(myElement.getFile());\n    for (final InspectionProfileEntry profileEntry : profile.getInspectionTools()) {\n      hasInspections |= processProfileEntry(profile.isToolEnabled(HighlightDisplayKey.find(profileEntry.getShortName())), profileEntry);\n    }\n    if (!hasInspections) {\n      runInspection(new MockDomInspection(myRootType));\n    }\n  }","commit_id":"70976a601e6606ddfd1a75e2df0a7e94a8521806","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MockDomInspection() {\n    super(DomElement.class);\n  }","id":26185,"modified_method":"public MockDomInspection() {\n    this(DomElement.class);\n  }","commit_id":"70976a601e6606ddfd1a75e2df0a7e94a8521806","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Class<?> getDecoderType(Class<? extends Decoder> decoder) {\n        return (Class<?>) Util.getGenericType(Decoder.class, decoder);\n    }","id":26186,"modified_method":"public static Class<?> getDecoderType(Class<? extends Decoder> decoder) {\n        return Util.getGenericType(Decoder.class, decoder).getClazz();\n    }","commit_id":"337ee1d975016215c31334c5f7e30e9d2ecddc79","url":"https://github.com/apache/tomcat"},{"original_method":"static Class<?> getMessageType(MessageHandler listener) {\n        return (Class<?>) Util.getGenericType(MessageHandler.class,\n                listener.getClass());\n    }","id":26187,"modified_method":"static Class<?> getMessageType(MessageHandler listener) {\n        return Util.getGenericType(MessageHandler.class,\n                listener.getClass()).getClazz();\n    }","commit_id":"337ee1d975016215c31334c5f7e30e9d2ecddc79","url":"https://github.com/apache/tomcat"},{"original_method":"private static <T> Object getGenericType(Class<T> type,\n            Class<? extends T> clazz) {\n\n        // Look to see if this class implements the interface of interest\n\n        // Get all the interfaces\n        Type[] interfaces = clazz.getGenericInterfaces();\n        for (Type iface : interfaces) {\n            // Only need to check interfaces that use generics\n            if (iface instanceof ParameterizedType) {\n                ParameterizedType pi = (ParameterizedType) iface;\n                // Look for the interface of interest\n                if (pi.getRawType() instanceof Class) {\n                    if (type.isAssignableFrom((Class<?>) pi.getRawType())) {\n                        return getTypeParameter(\n                                clazz, pi.getActualTypeArguments()[0]);\n                    }\n                }\n            }\n        }\n\n        // Interface not found on this class. Look at the superclass.\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends T> superClazz =\n                (Class<? extends T>) clazz.getSuperclass();\n\n        Object result = getGenericType(type, superClazz);\n        if (result instanceof Class<?>) {\n            // Superclass implements interface and defines explicit type for\n            // the interface of interest\n            return result;\n        } else if (result instanceof Integer) {\n            // Superclass implements interface and defines unknown type for\n            // the interface of interest\n            // Map that unknown type to the generic types defined in this class\n            ParameterizedType superClassType =\n                    (ParameterizedType) clazz.getGenericSuperclass();\n            return getTypeParameter(clazz,\n                    superClassType.getActualTypeArguments()[\n                            ((Integer) result).intValue()]);\n        } else {\n            // Error will be logged further up the call stack\n            return null;\n        }\n    }","id":26188,"modified_method":"private static <T> TypeResult getGenericType(Class<T> type,\n            Class<? extends T> clazz) {\n\n        // Look to see if this class implements the interface of interest\n\n        // Get all the interfaces\n        Type[] interfaces = clazz.getGenericInterfaces();\n        for (Type iface : interfaces) {\n            // Only need to check interfaces that use generics\n            if (iface instanceof ParameterizedType) {\n                ParameterizedType pi = (ParameterizedType) iface;\n                // Look for the interface of interest\n                if (pi.getRawType() instanceof Class) {\n                    if (type.isAssignableFrom((Class<?>) pi.getRawType())) {\n                        return getTypeParameter(\n                                clazz, pi.getActualTypeArguments()[0]);\n                    }\n                }\n            }\n        }\n\n        // Interface not found on this class. Look at the superclass.\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends T> superClazz =\n                (Class<? extends T>) clazz.getSuperclass();\n\n        TypeResult superClassTypeResult = getGenericType(type, superClazz);\n        int dimension = superClassTypeResult.getDimension();\n        if (superClassTypeResult.getIndex() == -1 && dimension == 0) {\n            // Superclass implements interface and defines explicit type for\n            // the interface of interest\n            return superClassTypeResult;\n        }\n\n        if (superClassTypeResult.getIndex() > -1) {\n            // Superclass implements interface and defines unknown type for\n            // the interface of interest\n            // Map that unknown type to the generic types defined in this class\n            ParameterizedType superClassType =\n                    (ParameterizedType) clazz.getGenericSuperclass();\n            TypeResult result = getTypeParameter(clazz,\n                    superClassType.getActualTypeArguments()[\n                            superClassTypeResult.getIndex()]);\n            result.incrementDimension(superClassTypeResult.getDimension());\n            if (result.getClazz() != null && result.getDimension() > 0) {\n                superClassTypeResult = result;\n            } else {\n                return result;\n            }\n        }\n\n        if (superClassTypeResult.getDimension() > 0) {\n            StringBuilder className = new StringBuilder();\n            for (int i = 0; i < dimension; i++) {\n                className.append('[');\n            }\n            className.append('L');\n            className.append(superClassTypeResult.getClazz().getCanonicalName());\n            className.append(';');\n\n            Class<?> arrayClazz;\n            try {\n                arrayClazz = Class.forName(className.toString());\n            } catch (ClassNotFoundException e) {\n                throw new IllegalArgumentException(e);\n            }\n\n            return new TypeResult(arrayClazz, -1, 0);\n        }\n\n        // Error will be logged further up the call stack\n        return null;\n    }","commit_id":"337ee1d975016215c31334c5f7e30e9d2ecddc79","url":"https://github.com/apache/tomcat"},{"original_method":"static Class<?> getEncoderType(Class<? extends Encoder> encoder) {\n        return (Class<?>) Util.getGenericType(Encoder.class, encoder);\n    }","id":26189,"modified_method":"static Class<?> getEncoderType(Class<? extends Encoder> encoder) {\n        return Util.getGenericType(Encoder.class, encoder).getClazz();\n    }","commit_id":"337ee1d975016215c31334c5f7e30e9d2ecddc79","url":"https://github.com/apache/tomcat"},{"original_method":"private static Object getTypeParameter(Class<?> clazz, Type argType) {\n        if (argType instanceof Class<?>) {\n            return argType;\n        } else if (argType instanceof ParameterizedType) {\n            return ((ParameterizedType) argType).getRawType();\n        } else {\n            TypeVariable<?>[] tvs = clazz.getTypeParameters();\n            for (int i = 0; i < tvs.length; i++) {\n                if (tvs[i].equals(argType)) {\n                    return Integer.valueOf(i);\n                }\n            }\n            return null;\n        }\n    }","id":26190,"modified_method":"private static TypeResult getTypeParameter(Class<?> clazz, Type argType) {\n        if (argType instanceof Class<?>) {\n            return new TypeResult((Class<?>) argType, -1, 0);\n        } else if (argType instanceof ParameterizedType) {\n            return new TypeResult((Class<?>)((ParameterizedType) argType).getRawType(), -1, 0);\n        } else if (argType instanceof GenericArrayType) {\n            Type arrayElementType = ((GenericArrayType) argType).getGenericComponentType();\n            TypeResult result = getTypeParameter(clazz, arrayElementType);\n            result.incrementDimension(1);\n            return result;\n        } else {\n            TypeVariable<?>[] tvs = clazz.getTypeParameters();\n            for (int i = 0; i < tvs.length; i++) {\n                if (tvs[i].equals(argType)) {\n                    return new TypeResult(null, i, 0);\n                }\n            }\n            return null;\n        }\n    }","commit_id":"337ee1d975016215c31334c5f7e30e9d2ecddc79","url":"https://github.com/apache/tomcat"},{"original_method":"private Object convert(Object value, Type targetType) {\n            if (targetType instanceof ParameterizedType) {\n                ParameterizedType parameterizedTargetType = (ParameterizedType) targetType;\n                if (parameterizedTargetType.getRawType().equals(DomainObjectSet.class)) {\n                    Type targetElementType = getElementType(parameterizedTargetType);\n                    List<Object> convertedElements = new ArrayList<Object>();\n                    for (Object element : (Iterable) value) {\n                        convertedElements.add(convert(element, targetElementType));\n                    }\n                    return new ImmutableDomainObjectSet(convertedElements);\n                }\n            }\n            if (targetType instanceof Class) {\n                if (((Class) targetType).isPrimitive()) {\n                    return value;\n                }\n                return adapt((Class) targetType, value, override);\n            }\n            throw new UnsupportedOperationException(String.format(\"Cannot convert object of %s to %s.\", value.getClass(), targetType));\n        }","id":26191,"modified_method":"private Object convert(Object value, Type targetType) {\n            if (targetType instanceof ParameterizedType) {\n                ParameterizedType parameterizedTargetType = (ParameterizedType) targetType;\n                if (parameterizedTargetType.getRawType() instanceof Class) {\n                    Class<?> rawClass = (Class<?>) parameterizedTargetType.getRawType();\n                    if (Iterable.class.isAssignableFrom(rawClass)) {\n                        Type targetElementType = getElementType(parameterizedTargetType, 0);\n                        Collection<Object> convertedElements = collectionMapper.createEmptyCollection(rawClass);\n                        for (Object element : (Iterable<?>) value) {\n                            convertedElements.add(convert(element, targetElementType));\n                        }\n                        if (rawClass.equals(DomainObjectSet.class)) {\n                            return new ImmutableDomainObjectSet(convertedElements);\n                        } else {\n                            return convertedElements;\n                        }\n                    }\n                    if (Map.class.isAssignableFrom(rawClass)) {\n                        Type targetKeyType = getElementType(parameterizedTargetType, 0);\n                        Type targetValueType = getElementType(parameterizedTargetType, 1);\n                        Map<Object, Object> convertedElements = collectionMapper.createEmptyMap(rawClass);\n                        for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {\n                            convertedElements.put(convert(entry.getKey(), targetKeyType), convert(entry.getValue(), targetValueType));\n                        }\n                        return convertedElements;\n                    }\n                }\n            }\n            if (targetType instanceof Class) {\n                if (((Class) targetType).isPrimitive()) {\n                    return value;\n                }\n                return adapt((Class) targetType, value, override);\n            }\n            throw new UnsupportedOperationException(String.format(\"Cannot convert object of %s to %s.\", value.getClass(), targetType));\n        }","commit_id":"2ccd8f077485ac2d34cc4b8ff91c972d9ecca786","url":"https://github.com/gradle/gradle"},{"original_method":"private Type getElementType(ParameterizedType type) {\n            Type elementType = type.getActualTypeArguments()[0];\n            if (elementType instanceof WildcardType) {\n                WildcardType wildcardType = (WildcardType) elementType;\n                return wildcardType.getUpperBounds()[0];\n            }\n            return elementType;\n        }","id":26192,"modified_method":"private Type getElementType(ParameterizedType type, int index) {\n            Type elementType = type.getActualTypeArguments()[index];\n            if (elementType instanceof WildcardType) {\n                WildcardType wildcardType = (WildcardType) elementType;\n                return wildcardType.getUpperBounds()[0];\n            }\n            return elementType;\n        }","commit_id":"2ccd8f077485ac2d34cc4b8ff91c972d9ecca786","url":"https://github.com/gradle/gradle"},{"original_method":"public void invoke(MethodInvocation invocation) throws Throwable {\n            // TODO - cache method lookup\n            Method targetMethod = locateMethod(invocation);\n            if (targetMethod == null) {\n                return;\n            }\n\n            Object returnValue;\n            try {\n                returnValue = targetMethod.invoke(invocation.getDelegate(), invocation.getParameters());\n            } catch (InvocationTargetException e) {\n                throw e.getCause();\n            }\n\n            if (returnValue == null || invocation.getReturnType().isInstance(returnValue)) {\n                invocation.setResult(returnValue);\n                return;\n            }\n\n            invocation.setResult(convert(returnValue, invocation.getGenericReturnType()));\n        }","id":26193,"modified_method":"public void invoke(MethodInvocation invocation) throws Throwable {\n            // TODO - cache method lookup\n            Method targetMethod = locateMethod(invocation);\n            if (targetMethod == null) {\n                return;\n            }\n\n            Object returnValue;\n            try {\n                returnValue = targetMethod.invoke(invocation.getDelegate(), invocation.getParameters());\n            } catch (InvocationTargetException e) {\n                throw e.getCause();\n            }\n\n            if (returnValue == null) {\n                invocation.setResult(returnValue);\n                return;\n            }\n\n            invocation.setResult(convert(returnValue, invocation.getGenericReturnType()));\n        }","commit_id":"2ccd8f077485ac2d34cc4b8ff91c972d9ecca786","url":"https://github.com/gradle/gradle"},{"original_method":"private static Object getMessageType(Class<? extends MessageHandler> clazz) {\n\n        // Look to see if this class implements the generic MessageHandler<>\n        // interface\n\n        // Get all the interfaces\n        Type[] interfaces = clazz.getGenericInterfaces();\n        for (Type iface : interfaces) {\n            // Only need to check interfaces that use generics\n            if (iface instanceof ParameterizedType) {\n                ParameterizedType pi = (ParameterizedType) iface;\n                // Look for the MessageHandler<> interface\n                if (pi.getRawType().equals(MessageHandler.Basic.class)\n                        || pi.getRawType().equals(MessageHandler.Async.class)) {\n                    // Whichever interface it is, there is only one generic\n                    // type.\n                    return getTypeParameter(\n                            clazz, pi.getActualTypeArguments()[0]);\n                }\n            }\n        }\n\n        // Interface not found on this class. Look at the superclass.\n        Class<? extends MessageHandler> superClazz =\n                (Class<? extends MessageHandler>) clazz.getSuperclass();\n\n        Object result = getMessageType(superClazz);\n        if (result instanceof Class<?>) {\n            // Superclass implements interface and defines explicit type for\n            // MessageHandler<>\n            return result;\n        } else if (result instanceof Integer) {\n            // Superclass implements interface and defines unknown type for\n            // MessageHandler<>\n            // Map that unknown type to the generic types defined in this class\n            ParameterizedType superClassType =\n                    (ParameterizedType) clazz.getGenericSuperclass();\n            return getTypeParameter(clazz,\n                    superClassType.getActualTypeArguments()[\n                            ((Integer) result).intValue()]);\n        } else {\n            // Error will be logged further up the call stack\n            return null;\n        }\n    }","id":26194,"modified_method":"private static Object getGenericType(Class<? extends MessageHandler> clazz) {\n\n        // Look to see if this class implements the generic MessageHandler<>\n        // interface\n\n        // Get all the interfaces\n        Type[] interfaces = clazz.getGenericInterfaces();\n        for (Type iface : interfaces) {\n            // Only need to check interfaces that use generics\n            if (iface instanceof ParameterizedType) {\n                ParameterizedType pi = (ParameterizedType) iface;\n                // Look for the MessageHandler<> interface\n                if (pi.getRawType() instanceof Class) {\n                    if (MessageHandler.class.isAssignableFrom(\n                            (Class<?>) pi.getRawType())) {\n                        return getTypeParameter(\n                                clazz, pi.getActualTypeArguments()[0]);\n                    }\n                }\n            }\n        }\n\n        // Interface not found on this class. Look at the superclass.\n        Class<? extends MessageHandler> superClazz =\n                (Class<? extends MessageHandler>) clazz.getSuperclass();\n\n        Object result = getGenericType(superClazz);\n        if (result instanceof Class<?>) {\n            // Superclass implements interface and defines explicit type for\n            // MessageHandler<>\n            return result;\n        } else if (result instanceof Integer) {\n            // Superclass implements interface and defines unknown type for\n            // MessageHandler<>\n            // Map that unknown type to the generic types defined in this class\n            ParameterizedType superClassType =\n                    (ParameterizedType) clazz.getGenericSuperclass();\n            return getTypeParameter(clazz,\n                    superClassType.getActualTypeArguments()[\n                            ((Integer) result).intValue()]);\n        } else {\n            // Error will be logged further up the call stack\n            return null;\n        }\n    }","commit_id":"600eee03cd5b8993968089002e60204a9724fff6","url":"https://github.com/apache/tomcat"},{"original_method":"protected static Class<?> getMessageType(MessageHandler listener) {\n        return (Class<?>) getMessageType(listener.getClass());\n    }","id":26195,"modified_method":"protected static Class<?> getMessageType(MessageHandler listener) {\n        return (Class<?>) getGenericType(listener.getClass());\n    }","commit_id":"600eee03cd5b8993968089002e60204a9724fff6","url":"https://github.com/apache/tomcat"},{"original_method":"public void mutate(TaskContainer container, Inputs inputs) {\n            BinaryContainer binaries = inputs.get(0, ModelType.of(BinaryContainer.class)).getInstance();\n            for (BinarySpec binary : binaries.withType(binaryType)) {\n                NamedEntityInstantiator<Task> instantiator = new Instantiator<Task>(binary, container);\n                DefaultCollectionBuilder<Task> collectionBuilder = new DefaultCollectionBuilder<Task>(\n                        subject.getPath(),\n                        instantiator,\n                        new SimpleModelRuleDescriptor(\"Project.<init>.binaries()\"),\n                        inputs,\n                        modelRegistry);\n\n                Object[] args = new Object[inputs.size() + 1];\n                args[0] = collectionBuilder;\n                args[binaryParameterIndex] = binary;\n\n                for (ModelRuleInput<?> modelRuleInput : inputs.getRuleInputs()) {\n                    Object instance = modelRuleInput.getView().getInstance();\n                    if(instance == binaries){\n                        continue;\n                    }\n                    for(int i = 0; i< args.length; i++){\n                        if(args[i]==null){\n                            args[i] = instance;\n                            break;\n                        }\n                    }\n                }\n                ruleDefinition.getRuleInvoker().invoke(args);\n            }\n        }","id":26196,"modified_method":"public void mutate(TaskContainer container, Inputs inputs) {\n            BinaryContainer binaries = inputs.get(0, ModelType.of(BinaryContainer.class)).getInstance();\n            for (T binary : binaries.withType(binaryType)) {\n                NamedEntityInstantiator<Task> instantiator = new Instantiator<Task>(binary, container);\n                DefaultCollectionBuilder<Task> collectionBuilder = new DefaultCollectionBuilder<Task>(\n                        getSubject().getPath(),\n                        instantiator,\n                        new SimpleModelRuleDescriptor(\"Project.<init>.tasks()\"),\n                        inputs,\n                        modelRegistry);\n\n                invoke(inputs, collectionBuilder, binary, binaries);\n            }\n        }","commit_id":"5867161dbbf7cb5cfc72f637f990e277ffa1c05c","url":"https://github.com/gradle/gradle"},{"original_method":"public BinaryTaskRule(ModelReference<TaskContainer> subject, final Class<T> binaryType, MethodRuleDefinition<R> ruleDefinition, ModelRegistry modelRegistry) {\n            this.subject = subject;\n            this.binaryType = binaryType;\n            this.ruleDefinition = ruleDefinition;\n            this.modelRegistry = modelRegistry;\n\n            final List<ModelReference<?>> references = ruleDefinition.getReferences().subList(1, ruleDefinition.getReferences().size());\n            final List<ModelReference<?>> filteredReferences = CollectionUtils.filter(references, new Spec<ModelReference<?>>() {\n                public boolean isSatisfiedBy(ModelReference<?> element) {\n                    if(element.getType().equals(ModelType.of(binaryType))){\n                        binaryParameterIndex = references.indexOf(element) + 1;\n                        return false;\n                    }\n                    return true;\n                }\n            });\n\n            ImmutableList.Builder<ModelReference<?>> allInputs = ImmutableList.builder();\n            allInputs.add(ModelReference.of(\"binaries\", BinaryContainer.class));\n            allInputs.addAll(filteredReferences);\n\n            this.inputs =  allInputs.build();\n        }","id":26197,"modified_method":"public BinaryTaskRule(ModelReference<TaskContainer> subject, final Class<T> binaryType, MethodRuleDefinition<R> ruleDefinition, ModelRegistry modelRegistry) {\n            super(subject, binaryType, ruleDefinition, ModelReference.of(\"binaries\", BinaryContainer.class));\n            this.binaryType = binaryType;\n            this.modelRegistry = modelRegistry;\n        }","commit_id":"5867161dbbf7cb5cfc72f637f990e277ffa1c05c","url":"https://github.com/gradle/gradle"},{"original_method":"private <T extends BinarySpec> void validateComponentType(Class<T> expectedBinaryType, Class<? extends ComponentSpec<T>> componentType) {\n        if (componentType == null) {\n            throw new InvalidComponentModelException(String.format(\"%s method must have one parameter extending %s. Found no parameter extending %s.\", annotationType.getSimpleName(),\n                    ComponentSpec.class.getSimpleName(),\n                    ComponentSpec.class.getSimpleName()));\n        }\n\n        for (Type type : componentType.getGenericInterfaces()) {\n            if (type instanceof ParameterizedType) {\n                ParameterizedType parameterizedType = (ParameterizedType) type;\n                if (parameterizedType.getRawType().equals(ComponentSpec.class)) {\n                    for (Type givenBinaryType : parameterizedType.getActualTypeArguments()) {\n                        if (((Class<?>) givenBinaryType).isAssignableFrom(expectedBinaryType)) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        throw new InvalidComponentModelException(String.format(\"%s method parameter of type %s does not support binaries of type %s.\", annotationType.getSimpleName(),\n                componentType.getSimpleName(),\n                expectedBinaryType.getSimpleName()));\n\n    }","id":26198,"modified_method":"private <T extends BinarySpec> void validateComponentType(Class<T> expectedBinaryType, Class<? extends ComponentSpec<T>> componentType) {\n        if (componentType == null) {\n            throw new InvalidComponentModelException(String.format(\"%s method must have one parameter extending %s. Found no parameter extending %s.\", annotationType.getSimpleName(),\n                    ComponentSpec.class.getSimpleName(),\n                    ComponentSpec.class.getSimpleName()));\n        }\n\n        for (Type type : componentType.getGenericInterfaces()) {\n            if (type instanceof ParameterizedType) {\n                ParameterizedType parameterizedType = (ParameterizedType) type;\n                if (ComponentSpec.class.isAssignableFrom((Class<?>)parameterizedType.getRawType())) {\n                    for (Type givenBinaryType : parameterizedType.getActualTypeArguments()) {\n                        if (((Class<?>) givenBinaryType).isAssignableFrom(expectedBinaryType)) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        throw new InvalidComponentModelException(String.format(\"%s method parameter of type %s does not support binaries of type %s.\", annotationType.getSimpleName(),\n                componentType.getSimpleName(),\n                expectedBinaryType.getSimpleName()));\n\n    }","commit_id":"5867161dbbf7cb5cfc72f637f990e277ffa1c05c","url":"https://github.com/gradle/gradle"},{"original_method":"public ComponentBinariesRule(ModelReference<BinaryContainer> subject, Class<? extends ComponentSpec<S>> componentType, Class<S> binaryType, MethodRuleDefinition<R> ruleDefinition, ModelRegistry modelRegistry) {\n            this.subject = subject;\n            this.componentType = componentType;\n            this.binaryType = binaryType;\n            this.ruleDefinition = ruleDefinition;\n            this.modelRegistry = modelRegistry;\n\n        }","id":26199,"modified_method":"public ComponentBinariesRule(ModelReference<BinaryContainer> subject, final Class<? extends ComponentSpec<S>> componentType, final Class<S> binaryType, MethodRuleDefinition<R> ruleDefinition, ModelRegistry modelRegistry) {\n            super(subject, componentType, ruleDefinition, ModelReference.of(\"componentSpecs\", ComponentSpecContainer.class));\n            this.componentType = componentType;\n            this.binaryType = binaryType;\n            this.modelRegistry = modelRegistry;\n        }","commit_id":"5867161dbbf7cb5cfc72f637f990e277ffa1c05c","url":"https://github.com/gradle/gradle"},{"original_method":"public void mutate(final BinaryContainer binaries, final Inputs inputs) {\n            ComponentSpecContainer componentSpecs = inputs.get(0, ModelType.of(ComponentSpecContainer.class)).getInstance();\n\n\n            for (final ComponentSpec<S> componentSpec : componentSpecs.withType(componentType)) {\n                NamedEntityInstantiator<S> namedEntityInstantiator = new Instantiator<S>(binaryType, componentSpec, binaries);\n                DefaultCollectionBuilder<S> collectionBuilder = new DefaultCollectionBuilder<S>(\n                        subject.getPath(),\n                        namedEntityInstantiator,\n                        new SimpleModelRuleDescriptor(\"Project.<init>.binaries()\"),\n                        inputs,\n                        modelRegistry);\n\n                ruleDefinition.getRuleInvoker().invoke(collectionBuilder, componentSpec);\n            }\n        }","id":26200,"modified_method":"public void mutate(final BinaryContainer binaries, final Inputs inputs) {\n            ComponentSpecContainer componentSpecs = inputs.get(0, ModelType.of(ComponentSpecContainer.class)).getInstance();\n\n            for (final ComponentSpec<S> componentSpec : componentSpecs.withType(componentType)) {\n                NamedEntityInstantiator<S> namedEntityInstantiator = new Instantiator<S>(binaryType, componentSpec, binaries);\n                CollectionBuilder<S> collectionBuilder = new DefaultCollectionBuilder<S>(\n                        getSubject().getPath(),\n                        namedEntityInstantiator,\n                        new SimpleModelRuleDescriptor(\"Project.<init>.binaries()\"),\n                        inputs,\n                        modelRegistry);\n                invoke(inputs, collectionBuilder, componentSpec, componentSpecs);\n            }\n        }","commit_id":"5867161dbbf7cb5cfc72f637f990e277ffa1c05c","url":"https://github.com/gradle/gradle"},{"original_method":"private List getRequiredTypeInfo(Object converter) {\n\t\tList typeInfo = new ArrayList(2);\n\t\tif (converter instanceof ConverterInfo) {\n\t\t\tConverterInfo info = (ConverterInfo) converter;\n\t\t\ttypeInfo.add(info.getSourceType());\n\t\t\ttypeInfo.add(info.getTargetType());\n\t\t\treturn typeInfo;\n\t\t}\n\t\tClass classToIntrospect = converter.getClass();\n\t\twhile (classToIntrospect != null) {\n\t\t\tType[] genericInterfaces = classToIntrospect.getGenericInterfaces();\n\t\t\tfor (Type genericInterface : genericInterfaces) {\n\t\t\t\tif (genericInterface instanceof ParameterizedType) {\n\t\t\t\t\tParameterizedType pInterface = (ParameterizedType) genericInterface;\n\t\t\t\t\tif (Converter.class.equals(pInterface.getRawType())\n\t\t\t\t\t\t\t|| SuperConverter.class.isAssignableFrom((Class) pInterface.getRawType())) {\n\t\t\t\t\t\tClass s = getParameterClass(pInterface.getActualTypeArguments()[0], converter.getClass());\n\t\t\t\t\t\tClass t = getParameterClass(pInterface.getActualTypeArguments()[1], converter.getClass());\n\t\t\t\t\t\ttypeInfo.add(getParameterClass(s, converter.getClass()));\n\t\t\t\t\t\ttypeInfo.add(getParameterClass(t, converter.getClass()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tclassToIntrospect = classToIntrospect.getSuperclass();\n\t\t}\n\t\tif (typeInfo.size() != 2) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to extract source and target class arguments from Converter [\"\n\t\t\t\t\t+ converter.getClass().getName() + \"]; does the Converter specify the <S, T> generic types?\");\n\t\t}\n\t\treturn typeInfo;\n\t}","id":26201,"modified_method":"private List getRequiredTypeInfo(Object converter) {\n\t\tList typeInfo = new ArrayList(2);\n\t\tif (converter instanceof ConverterInfo) {\n\t\t\tConverterInfo info = (ConverterInfo) converter;\n\t\t\ttypeInfo.add(info.getSourceType());\n\t\t\ttypeInfo.add(info.getTargetType());\n\t\t\treturn typeInfo;\n\t\t}\n\t\tClass classToIntrospect = converter.getClass();\n\t\twhile (classToIntrospect != null) {\n\t\t\tType[] genericInterfaces = classToIntrospect.getGenericInterfaces();\n\t\t\tfor (Type genericInterface : genericInterfaces) {\n\t\t\t\tif (genericInterface instanceof ParameterizedType) {\n\t\t\t\t\tParameterizedType pInterface = (ParameterizedType) genericInterface;\n\t\t\t\t\tif (Converter.class.isAssignableFrom((Class) pInterface.getRawType())\n\t\t\t\t\t\t\t|| SuperConverter.class.isAssignableFrom((Class) pInterface.getRawType())) {\n\t\t\t\t\t\tClass s = getParameterClass(pInterface.getActualTypeArguments()[0], converter.getClass());\n\t\t\t\t\t\tClass t = getParameterClass(pInterface.getActualTypeArguments()[1], converter.getClass());\n\t\t\t\t\t\ttypeInfo.add(getParameterClass(s, converter.getClass()));\n\t\t\t\t\t\ttypeInfo.add(getParameterClass(t, converter.getClass()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tclassToIntrospect = classToIntrospect.getSuperclass();\n\t\t}\n\t\tif (typeInfo.size() != 2) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to extract source and target class arguments from Converter [\"\n\t\t\t\t\t+ converter.getClass().getName() + \"]; does the Converter specify the <S, T> generic types?\");\n\t\t}\n\t\treturn typeInfo;\n\t}","commit_id":"796a457d9fdf396c6fe242dc3cc7e88841b2d6a6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Register the Converter with this conversion service.\n\t * @param converter the converter to register\n\t */\n\tpublic void addConverter(Converter converter) {\n\t\tList typeInfo = getRequiredTypeInfo(converter);\n\t\tClass sourceType = (Class) typeInfo.get(0);\n\t\tClass targetType = (Class) typeInfo.get(1);\n\t\t// index forward\n\t\tMap sourceMap = getSourceMap(sourceType);\n\t\tsourceMap.put(targetType, converter);\n\t\t// index reverse\n\t\tsourceMap = getSourceMap(targetType);\n\t\tsourceMap.put(sourceType, new ReverseConverter(converter));\n\t}","id":26202,"modified_method":"/**\n\t * Register the Converter with this conversion service.\n\t * @param converter the converter to register\n\t */\n\tpublic void addConverter(Converter converter) {\n\t\tList typeInfo = getRequiredTypeInfo(converter);\n\t\tClass sourceType = (Class) typeInfo.get(0);\n\t\tClass targetType = (Class) typeInfo.get(1);\n\t\t// index forward\n\t\tMap sourceMap = getSourceMap(sourceType);\n\t\tsourceMap.put(targetType, converter);\n\t\tif (converter instanceof TwoWayConverter) {\n\t\t\t// index reverse\n\t\t\tsourceMap = getSourceMap(targetType);\n\t\t\tsourceMap.put(sourceType, new ReverseConverter((TwoWayConverter) converter));\n\t\t}\n\t}","commit_id":"796a457d9fdf396c6fe242dc3cc7e88841b2d6a6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public ReverseConverter(Converter converter) {\n\t\tthis.converter = converter;\n\t}","id":26203,"modified_method":"public ReverseConverter(TwoWayConverter converter) {\n\t\tthis.converter = converter;\n\t}","commit_id":"796a457d9fdf396c6fe242dc3cc7e88841b2d6a6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public Object convertValue(Object value, TypeDescriptor typeDescriptor) throws EvaluationException {\r\n\t\ttry {\r\n\t\t\treturn conversionService.convert(value, typeDescriptor);\r\n\t\t} catch (ConverterNotFoundException cenfe) {\r\n\t\t\tthrow new SpelException(cenfe, SpelMessages.TYPE_CONVERSION_ERROR, value.getClass(), typeDescriptor.asString());\r\n\t\t} catch (ConversionException ce) {\r\n\t\t\tthrow new SpelException(ce, SpelMessages.TYPE_CONVERSION_ERROR, value.getClass(), typeDescriptor.asString());\r\n\t\t}\r\n\t}","id":26204,"modified_method":"public Object convertValue(Object value, TypeDescriptor typeDescriptor) throws EvaluationException {\r\n\t\ttry {\r\n\t\t\treturn conversionService.convert(value, typeDescriptor);\r\n\t\t} catch (ConverterNotFoundException cenfe) {\r\n\t\t\tthrow new SpelException(cenfe, SpelMessages.TYPE_CONVERSION_ERROR, value.getClass(), typeDescriptor.asString());\r\n\t\t} catch (ConvertException ce) {\r\n\t\t\tthrow new SpelException(ce, SpelMessages.TYPE_CONVERSION_ERROR, value.getClass(), typeDescriptor.asString());\r\n\t\t}\r\n\t}","commit_id":"796a457d9fdf396c6fe242dc3cc7e88841b2d6a6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void initPersistentComponent(final PersistentStateComponent<Object> component) {\n    final String name = getComponentName(component);\n\n    myComponents.put(name, component);\n    if (optimizeTestLoading()) return;\n\n    Object state = null;\n    //todo: defaults merging\n    final StateStorage defaultsStorage = getDefaultsStorage();\n    if (defaultsStorage != null) {\n      try {\n\n        Class stateClass = getComponentStateClass(component);\n        state = defaultsStorage.getState(component, name, stateClass, null);\n      }\n      catch (StateStorage.StateStorageException e) {\n        LOG.error(e);\n      }\n    }\n\n    try {\n      Storage storageSpec = getComponentStorage(component, StateStorageChooser.Operation.READ);\n      StateStorage stateStorage = getStateStorage(storageSpec);\n\n      if (stateStorage == null) return;\n\n      Class stateClass = getComponentStateClass(component);\n      state = stateStorage.getState(component, name, stateClass, state);\n    }\n    catch (StateStorage.StateStorageException e) {\n      LOG.error(e);\n    }\n    catch (Throwable e) {\n      LOG.error(e);\n    }\n\n    if (state != null) {\n      component.loadState(state);\n    }\n  }","id":26205,"modified_method":"private <T> void initPersistentComponent(final PersistentStateComponent<T> component) {\n    final String name = getComponentName(component);\n\n    myComponents.put(name, component);\n    if (optimizeTestLoading()) return;\n\n    Class<T> stateClass = getComponentStateClass(component);\n\n    T state = null;\n    //todo: defaults merging\n    final StateStorage defaultsStorage = getDefaultsStorage();\n    if (defaultsStorage != null) {\n      try {\n\n        state = defaultsStorage.getState(component, name, stateClass, null);\n      }\n      catch (StateStorage.StateStorageException e) {\n        LOG.error(e);\n      }\n    }\n\n    try {\n      Storage storageSpec = getComponentStorage(component, StateStorageChooser.Operation.READ);\n      StateStorage stateStorage = getStateStorage(storageSpec);\n\n      if (stateStorage == null) return;\n\n      state = stateStorage.getState(component, name, stateClass, state);\n    }\n    catch (StateStorage.StateStorageException e) {\n      LOG.error(e);\n    }\n    catch (Throwable e) {\n      LOG.error(e);\n    }\n\n    if (state != null) {\n      component.loadState(state);\n    }\n  }","commit_id":"b1d282916c97a0ee2f13fcf24d46312cf4ee1055","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getComponentName(final PersistentStateComponent<Object> persistentStateComponent) {\n    final State stateSpec = getStateSpec(persistentStateComponent);\n    assert stateSpec != null;\n    return stateSpec.name();\n  }","id":26206,"modified_method":"private static String getComponentName(final PersistentStateComponent<?> persistentStateComponent) {\n    final State stateSpec = getStateSpec(persistentStateComponent);\n    assert stateSpec != null;\n    return stateSpec.name();\n  }","commit_id":"b1d282916c97a0ee2f13fcf24d46312cf4ee1055","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Class getComponentStateClass(final PersistentStateComponent<Object> persistentStateComponent) {\n    final Class persistentStateComponentClass = PersistentStateComponent.class;\n    Class componentClass = persistentStateComponent.getClass();\n\n    nextSuperClass: while (true) {\n      final Class[] interfaces = ReflectionCache.getInterfaces(componentClass);\n\n      for (Class anInterface : interfaces) {\n        if (anInterface.equals(persistentStateComponentClass)) {\n          break nextSuperClass;\n        }\n      }\n\n      componentClass = componentClass.getSuperclass();\n    }\n\n    final Type type =\n      ReflectionUtil.resolveVariable(persistentStateComponentClass.getTypeParameters()[0], componentClass);\n\n    return ReflectionUtil.getRawType(type);\n  }","id":26207,"modified_method":"private static <T> Class<T> getComponentStateClass(final PersistentStateComponent<T> persistentStateComponent) {\n    final Class persistentStateComponentClass = PersistentStateComponent.class;\n    Class componentClass = persistentStateComponent.getClass();\n\n    nextSuperClass: while (true) {\n      final Class[] interfaces = ReflectionCache.getInterfaces(componentClass);\n\n      for (Class anInterface : interfaces) {\n        if (anInterface.equals(persistentStateComponentClass)) {\n          break nextSuperClass;\n        }\n      }\n\n      componentClass = componentClass.getSuperclass();\n    }\n\n    final Type type =\n      ReflectionUtil.resolveVariable(persistentStateComponentClass.getTypeParameters()[0], componentClass);\n\n    return (Class<T>)ReflectionUtil.getRawType(type);\n  }","commit_id":"b1d282916c97a0ee2f13fcf24d46312cf4ee1055","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n        public Void visitClassDescriptor(ClassDescriptor descriptor, StringBuilder builder) {\n            String keyword = descriptor.getKind() == ClassKind.TRAIT ? \"trait\" : \"class\";\n            renderClassDescriptor(descriptor, builder, keyword);\n            return super.visitClassDescriptor(descriptor, builder);\n        }","id":26208,"modified_method":"@Override\n        public Void visitClassDescriptor(ClassDescriptor descriptor, StringBuilder builder) {\n            String keyword;\n            switch (descriptor.getKind()) {\n                case TRAIT:\n                    keyword = \"trait\";\n                    break;\n                case ENUM_CLASS:\n                    keyword = \"enum class\";\n                    break;\n                case OBJECT:\n                    keyword = \"object\";\n                    break;\n                default:\n                    keyword = \"class\";\n            }\n            renderClassDescriptor(descriptor, builder, keyword);\n            return super.visitClassDescriptor(descriptor, builder);\n        }","commit_id":"e9bac5ce16e3726b767bbdcc9c3ec6af06fd6af5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void renderClassDescriptor(ClassDescriptor descriptor, StringBuilder builder, String keyword) {\n            if (descriptor.getKind() != ClassKind.TRAIT) {\n                renderModality(descriptor.getModality(), builder);\n            }\n            builder.append(renderKeyword(keyword)).append(\" \");\n            renderName(descriptor, builder);\n            renderTypeParameters(descriptor.getTypeConstructor().getParameters(), builder);\n            if (!descriptor.equals(JetStandardClasses.getNothing())) {\n                Collection<? extends JetType> supertypes = descriptor.getTypeConstructor().getSupertypes();\n                if (!supertypes.isEmpty()) {\n                    builder.append(\" : \");\n                    for (Iterator<? extends JetType> iterator = supertypes.iterator(); iterator.hasNext(); ) {\n                        JetType supertype = iterator.next();\n                        builder.append(renderType(supertype));\n                        if (iterator.hasNext()) {\n                            builder.append(\", \");\n                        }\n                    }\n                }\n            }\n        }","id":26209,"modified_method":"public void renderClassDescriptor(ClassDescriptor descriptor, StringBuilder builder, String keyword) {\n            if (descriptor.getKind() != ClassKind.TRAIT) {\n                renderModality(descriptor.getModality(), builder);\n            }\n            builder.append(renderKeyword(keyword));\n            if (descriptor.getKind() != ClassKind.OBJECT) {\n                builder.append(\" \");\n                renderName(descriptor, builder);\n                renderTypeParameters(descriptor.getTypeConstructor().getParameters(), builder);\n            }\n            if (!descriptor.equals(JetStandardClasses.getNothing())) {\n                Collection<? extends JetType> supertypes = descriptor.getTypeConstructor().getSupertypes();\n                if (!supertypes.isEmpty()) {\n                    builder.append(\" : \");\n                    for (Iterator<? extends JetType> iterator = supertypes.iterator(); iterator.hasNext(); ) {\n                        JetType supertype = iterator.next();\n                        builder.append(renderType(supertype));\n                        if (iterator.hasNext()) {\n                            builder.append(\", \");\n                        }\n                    }\n                }\n            }\n        }","commit_id":"e9bac5ce16e3726b767bbdcc9c3ec6af06fd6af5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void renderProperty(PropertyDescriptor descriptor, StringBuilder builder) {\n        if (!startFromName) {\n            renderAnnotations(descriptor, builder);\n            renderVisibility(descriptor.getVisibility(), builder);\n            renderModality(descriptor.getModality(), builder);\n            renderValVarPrefix(descriptor, builder);\n        }\n\n        renderTypeParameters(descriptor.getTypeParameters(), builder);\n\n        ReceiverParameterDescriptor receiver = descriptor.getReceiverParameter();\n        if (receiver != null) {\n            builder.append(escape(renderType(receiver.getType()))).append(\".\");\n        }\n        renderName(descriptor, builder);\n        builder.append(\" : \").append(escape(renderType(descriptor.getType())));\n    }","id":26210,"modified_method":"private void renderProperty(PropertyDescriptor descriptor, StringBuilder builder) {\n        if (!startFromName) {\n            renderAnnotations(descriptor, builder);\n            renderVisibility(descriptor.getVisibility(), builder);\n            renderModality(descriptor.getModality(), builder);\n            renderValVarPrefix(descriptor, builder);\n        }\n\n        if (renderTypeParameters(descriptor.getTypeParameters(), builder)) {\n            builder.append(\" \");\n        }\n\n        ReceiverParameterDescriptor receiver = descriptor.getReceiverParameter();\n        if (receiver != null) {\n            builder.append(escape(renderType(receiver.getType()))).append(\".\");\n        }\n        renderName(descriptor, builder);\n        builder.append(\" : \").append(escape(renderType(descriptor.getType())));\n\n        renderWhereSuffix(descriptor.getTypeParameters(), builder);\n    }","commit_id":"08d20022770376a732eaca19c58167f6b652a92d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public String renderType(JetType type) {\n        if (type == null) {\n            return escape(\"[NULL]\");\n        }\n        else if (JetStandardClasses.isUnit(type)) {\n            return escape(\"Unit\" + (type.isNullable() ? \"?\" : \"\"));\n        }\n        else if (JetStandardClasses.isTupleType(type)) {\n            return escape(renderTupleType(type));\n        }\n        else if (JetStandardClasses.isReceiverFunctionType(type)) {\n            return escape(renderReceiverFunctionType(type));\n        }\n        else if (JetStandardClasses.isFunctionType(type)) {\n            return escape(renderFunctionType(type, false));\n        }\n        else {\n            return escape(type.toString());\n        }\n    }","id":26211,"modified_method":"public String renderType(JetType type) {\n        if (type == null) {\n            return escape(\"[NULL]\");\n        }\n        else if (JetStandardClasses.isUnit(type)) {\n            return escape(\"Unit\" + (type.isNullable() ? \"?\" : \"\"));\n        }\n        else if (JetStandardClasses.isTupleType(type)) {\n            return escape(renderTupleType(type));\n        }\n        else if (JetStandardClasses.isFunctionType(type)) {\n            return escape(renderFunctionType(type));\n        }\n        else {\n            return escape(type.toString());\n        }\n    }","commit_id":"78b7c32cd595a17a13932e4dde3345f3d8544931","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected String renderTupleType(JetType type) {\n        StringBuilder sb = new StringBuilder(\"#(\");\n        for (Iterator<TypeProjection> iterator = type.getArguments().iterator(); iterator.hasNext(); ) {\n            TypeProjection argument = iterator.next();\n            sb.append(renderType(argument.getType()));\n            if (iterator.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\")\");\n\n        if (type.isNullable()) {\n            sb.append(\"?\");\n        }\n\n        return sb.toString();\n    }","id":26212,"modified_method":"protected String renderTupleType(JetType type) {\n        StringBuilder sb = new StringBuilder(\"#(\");\n        appendTypes(sb, JetStandardClasses.getTupleElementTypes(type));\n        sb.append(\")\");\n\n        if (type.isNullable()) {\n            sb.append(\"?\");\n        }\n\n        return sb.toString();\n    }","commit_id":"78b7c32cd595a17a13932e4dde3345f3d8544931","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected String renderReceiverFunctionType(JetType type) {\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(renderType(type.getArguments().get(0).getType())).append(\".\").append(renderFunctionType(type, true));\n\n        return appendNullability(type, sb);\n    }","id":26213,"modified_method":"private String renderFunctionType(JetType type) {\n        StringBuilder sb = new StringBuilder();\n\n        JetType receiverType = JetStandardClasses.getReceiverType(type);\n        if (receiverType != null) {\n            sb.append(renderType(receiverType));\n            sb.append(\".\");\n        }\n\n        sb.append(\"(\");\n        appendTypes(sb, JetStandardClasses.getParameterTypesFromFunctionType(type));\n        sb.append(\") -> \");\n        sb.append(renderType(JetStandardClasses.getReturnTypeFromFunctionType(type)));\n\n        if (type.isNullable()) {\n            return \"(\" + sb + \")?\";\n        }\n        return sb.toString();\n    }","commit_id":"78b7c32cd595a17a13932e4dde3345f3d8544931","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void renderTypeParameters(List<TypeParameterDescriptor> typeParameters, StringBuilder builder) {\n            if (!typeParameters.isEmpty()) {\n                builder.append(lt());\n                for (Iterator<TypeParameterDescriptor> iterator = typeParameters.iterator(); iterator.hasNext(); ) {\n                    TypeParameterDescriptor typeParameterDescriptor = iterator.next();\n                    typeParameterDescriptor.accept(subVisitor, builder);\n                    if (iterator.hasNext()) {\n                        builder.append(\", \");\n                    }\n                }\n                builder.append(\"> \");\n            }\n        }","id":26214,"modified_method":"private boolean renderTypeParameters(List<TypeParameterDescriptor> typeParameters, StringBuilder builder) {\n            if (!typeParameters.isEmpty()) {\n                builder.append(lt());\n                for (Iterator<TypeParameterDescriptor> iterator = typeParameters.iterator(); iterator.hasNext(); ) {\n                    TypeParameterDescriptor typeParameterDescriptor = iterator.next();\n                    typeParameterDescriptor.accept(subVisitor, builder);\n                    if (iterator.hasNext()) {\n                        builder.append(\", \");\n                    }\n                }\n                builder.append(\"> \");\n                return true;\n            }\n            return false;\n        }","commit_id":"78b7c32cd595a17a13932e4dde3345f3d8544931","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private String appendNullability(JetType type, StringBuilder sb) {\n        String rendered = sb.toString();\n        if (type.isNullable()) {\n            rendered = \"(\" + rendered + \")?\";\n        }\n        return rendered;\n    }","id":26215,"modified_method":"private void appendTypes(StringBuilder result, List<JetType> types) {\n        for (Iterator<JetType> iterator = types.iterator(); iterator.hasNext(); ) {\n            result.append(renderType(iterator.next()));\n            if (iterator.hasNext()) {\n                result.append(\", \");\n            }\n        }\n    }","commit_id":"78b7c32cd595a17a13932e4dde3345f3d8544931","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n        public Void visitFunctionDescriptor(FunctionDescriptor descriptor, StringBuilder builder) {\n            renderModality(descriptor.getModality(), builder);\n            builder.append(renderKeyword(\"fun\")).append(\" \");\n            renderTypeParameters(descriptor.getTypeParameters(), builder);\n\n            ReceiverDescriptor receiver = descriptor.getReceiverParameter();\n            if (receiver.exists()) {\n                builder.append(escape(renderType(receiver.getType()))).append(\".\");\n            }\n\n            renderName(descriptor, builder);\n            renderValueParameters(descriptor, builder);\n            builder.append(\" : \").append(escape(renderType(descriptor.getReturnType())));\n            return super.visitFunctionDescriptor(descriptor, builder);\n        }","id":26216,"modified_method":"@Override\n        public Void visitFunctionDescriptor(FunctionDescriptor descriptor, StringBuilder builder) {\n            renderModality(descriptor.getModality(), builder);\n            builder.append(renderKeyword(\"fun\")).append(\" \");\n            if (renderTypeParameters(descriptor.getTypeParameters(), builder)) {\n                builder.append(\" \");\n            }\n\n            ReceiverDescriptor receiver = descriptor.getReceiverParameter();\n            if (receiver.exists()) {\n                builder.append(escape(renderType(receiver.getType()))).append(\".\");\n            }\n\n            renderName(descriptor, builder);\n            renderValueParameters(descriptor, builder);\n            builder.append(\" : \").append(escape(renderType(descriptor.getReturnType())));\n            return super.visitFunctionDescriptor(descriptor, builder);\n        }","commit_id":"78b7c32cd595a17a13932e4dde3345f3d8544931","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static List<ValueParameterDescriptor> getValueParameters(@NotNull FunctionDescriptor functionDescriptor, @NotNull JetType type) {\n        assert isFunctionType(type);\n        List<TypeProjection> arguments = type.getArguments();\n        int first = RECEIVER_FUNCTION_TYPE_CONSTRUCTORS.contains(type.getConstructor()) ? 1 : 0;\n        int last = arguments.size() - 2;\n        List<ValueParameterDescriptor> valueParameters = Lists.newArrayList();\n        for (int i = first; i <= last; i++) {\n            JetType parameterType =  arguments.get(i).getType();\n            ValueParameterDescriptorImpl valueParameterDescriptor = new ValueParameterDescriptorImpl(functionDescriptor, i - first, Collections.<AnnotationDescriptor>emptyList(), \"p\" + i, false, parameterType, false, null);\n            valueParameters.add(valueParameterDescriptor);\n        }\n        return valueParameters;\n    }","id":26217,"modified_method":"@NotNull\n    public static List<ValueParameterDescriptor> getValueParameters(@NotNull FunctionDescriptor functionDescriptor, @NotNull JetType type) {\n        assert isFunctionType(type);\n        int receiverOffset = getReceiverType(type) != null ? 1 : 0;\n        List<ValueParameterDescriptor> valueParameters = Lists.newArrayList();\n        List<JetType> parameterTypes = getParameterTypesFromFunctionType(type);\n        for (int i = 0; i < parameterTypes.size(); i++) {\n            JetType parameterType = parameterTypes.get(i);\n            ValueParameterDescriptorImpl valueParameterDescriptor = new ValueParameterDescriptorImpl(\n                    functionDescriptor, i, Collections.<AnnotationDescriptor>emptyList(),\n                    \"p\" + (i + receiverOffset), false, parameterType, false, null);\n            valueParameters.add(valueParameterDescriptor);\n        }\n        return valueParameters;\n    }","commit_id":"78b7c32cd595a17a13932e4dde3345f3d8544931","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**A method for handling a LWC event*/\n    public void LWCChanged(LWCEvent e)\n    {\n        Object message = e.key;\n        try\n        {\n            if (message == LWKey.LinkAdded)\n            {\n                addLinkConnection((LWComponent)e.getSource(), (LWLink)e.getComponent());\n            }\n            else if (message == LWKey.LinkRemoved)\n            {\n                removeLinkConnection((LWComponent)e.getSource(), (LWLink)e.getComponent());\n            }\n            else if (message == LWKey.ChildrenAdded)\n            {\n                ArrayList childrenList = e.getComponents();\n                for (Iterator i = childrenList.iterator(); i.hasNext();) {\n                    LWComponent c = (LWComponent) i.next();\n                    if (c instanceof LWLink)\n                        continue; // will be handled by a LinkAdded event\n                    addHierarchyTreeNode((LWContainer)e.getSource(), c);\n                }\n            }\n            else if (message == LWKey.ChildrenRemoved)\n            {\n                ArrayList childrenList = e.getComponents();\n                for (Iterator i = childrenList.iterator(); i.hasNext();) {\n                    LWComponent c = (LWComponent) i.next();\n                     if (c instanceof LWLink)\n                        continue; // will be handled by a LinkRemoved event\n                     deleteHierarchyTreeNode((LWContainer)e.getSource(), c);\n                }\n            }\n            /*\n            else if (message == LWKey.HierarchyChanged)\n            {   \n                //System.err.println(this + \" needs to rebuild child list from scratch for \" + e.getSource());\n                LWContainer container = (LWContainer)e.getSource();  \n                System.out.println(\"the container it needs to change is \" + container.toString());\n                \n                ArrayList nodes = new ArrayList();\n                HierarchyNode rootNode = getRootNode();\n                \n                if (container instanceof LWMap)\n                {    \n                    //rootNode.setLWComponent(container);\n                    nodes.add(rootNode);\n                }\n                \n                nodes.addAll(findHierarchyNodeByComponentID(rootNode, container.getID()));\n                \n                for (Iterator i = nodes.iterator(); i.hasNext();)\n                { \n                    HierarchyNode hierarchyNode = (HierarchyNode)i.next();\n                    \n                    for (osid.hierarchy.NodeIterator ni = hierarchyNode.getChildren(); ni.hasNext();)\n                    {\n                      HierarchyNode node = (HierarchyNode)ni.next();\n                      \n                      System.out.println(\"deleting the node:\" + node.getDisplayName());\n                      deleteHierarchyNode(node); \n                    }\n                    \n                    for (Iterator li = container.getLinks().iterator(); li.hasNext();)\n                    {\n                        LWLink link = (LWLink)li.next();       \n                        addHierarchyTreeNode(container, link);\n                    }\n                    \n                    for (Iterator ci = container.getChildIterator(); ci.hasNext();)\n                    {\n                        LWComponent component = (LWComponent)ci.next();\n                        addHierarchyTreeNode(container, component);\n                    }\n                }\n            }\n            */\n        }\n        \n        catch(osid.hierarchy.HierarchyException he)\n        {\n            System.err.println(he.getMessage());\n            he.printStackTrace();\n        }\n    }","id":26218,"modified_method":"/**A method for handling a LWC event*/\n    public void LWCChanged(LWCEvent e)\n    {\n        Object message = e.key;\n        try\n        {\n            if (message == LWKey.LinkAdded)\n            {\n                addLinkConnection((LWComponent)e.getSource(), (LWLink)e.getComponent());\n            }\n            else if (message == LWKey.LinkRemoved)\n            {\n                removeLinkConnection((LWComponent)e.getSource(), (LWLink)e.getComponent());\n            }\n            else if (message == LWKey.ChildrenAdded)\n            {\n                for (LWComponent c : e.getComponents()) {\n                    if (c instanceof LWLink)\n                        continue; // will be handled by a LinkAdded event\n                    addHierarchyTreeNode((LWContainer)e.getSource(), c);\n                }\n            }\n            else if (message == LWKey.ChildrenRemoved)\n            {\n                for (LWComponent c : e.getComponents()) {\n                     if (c instanceof LWLink)\n                        continue; // will be handled by a LinkRemoved event\n                     deleteHierarchyTreeNode((LWContainer)e.getSource(), c);\n                }\n            }\n            /*\n            else if (message == LWKey.HierarchyChanged)\n            {   \n                //System.err.println(this + \" needs to rebuild child list from scratch for \" + e.getSource());\n                LWContainer container = (LWContainer)e.getSource();  \n                System.out.println(\"the container it needs to change is \" + container.toString());\n                \n                ArrayList nodes = new ArrayList();\n                HierarchyNode rootNode = getRootNode();\n                \n                if (container instanceof LWMap)\n                {    \n                    //rootNode.setLWComponent(container);\n                    nodes.add(rootNode);\n                }\n                \n                nodes.addAll(findHierarchyNodeByComponentID(rootNode, container.getID()));\n                \n                for (Iterator i = nodes.iterator(); i.hasNext();)\n                { \n                    HierarchyNode hierarchyNode = (HierarchyNode)i.next();\n                    \n                    for (osid.hierarchy.NodeIterator ni = hierarchyNode.getChildren(); ni.hasNext();)\n                    {\n                      HierarchyNode node = (HierarchyNode)ni.next();\n                      \n                      System.out.println(\"deleting the node:\" + node.getDisplayName());\n                      deleteHierarchyNode(node); \n                    }\n                    \n                    for (Iterator li = container.getLinks().iterator(); li.hasNext();)\n                    {\n                        LWLink link = (LWLink)li.next();       \n                        addHierarchyTreeNode(container, link);\n                    }\n                    \n                    for (Iterator ci = container.getChildIterator(); ci.hasNext();)\n                    {\n                        LWComponent component = (LWComponent)ci.next();\n                        addHierarchyTreeNode(container, component);\n                    }\n                }\n            }\n            */\n        }\n        \n        catch(osid.hierarchy.HierarchyException he)\n        {\n            System.err.println(he.getMessage());\n            he.printStackTrace();\n        }\n    }","commit_id":"685cd92f605034e6723d7b25e0eae41731954d42","url":"https://github.com/VUE/VUE"},{"original_method":"private void updateSelectionActions(List<RadComponent> selection) {\n    boolean update = isVisible(myDynamicGroup);\n\n    for (AnAction action : myDynamicGroup.getChildActionsOrStubs()) {\n      action.unregisterCustomShortcutSet(myShortcuts);\n    }\n    myDynamicGroup.removeAll();\n\n    Set<RadComponent> parents = RadComponent.getParents(selection);\n    for (RadComponent parent : parents) {\n      parent.getLayout().addSelectionActions(myDesigner, myDynamicGroup, myShortcuts, selection);\n    }\n    for (RadComponent component : selection) {\n      component.addSelectionActions(myDesigner, myDynamicGroup, myShortcuts, selection);\n    }\n    update |= isVisible(myDynamicGroup);\n\n    if (update) {\n      update();\n    }\n  }","id":26219,"modified_method":"private void updateSelectionActions(List<RadComponent> selection) {\n    boolean update = isVisible(myDynamicGroup);\n\n    for (AnAction action : myDynamicGroup.getChildActionsOrStubs()) {\n      action.unregisterCustomShortcutSet(myShortcuts);\n    }\n    myDynamicGroup.removeAll();\n\n    for (RadComponent parent : RadComponent.getParents(selection)) {\n      parent.getLayout().addSelectionActions(myDesigner, myDynamicGroup, myShortcuts, selection);\n    }\n    for (RadComponent component : selection) {\n      component.addSelectionActions(myDesigner, myDynamicGroup, myShortcuts, selection);\n    }\n    update |= isVisible(myDynamicGroup);\n\n    if (update) {\n      update();\n    }\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void showFeedback() {\n    createFeedback();\n\n    if (!myContainer.getChildren().isEmpty()) {\n      FeedbackLayer layer = myContext.getArea().getFeedbackLayer();\n      Point location = myContext.getLocation();\n      myChildTarget = null;\n\n      if (myHorizontal) {\n        for (RadComponent child : myContainer.getChildren()) {\n          Rectangle childBounds = child.getBounds(layer);\n          if (childBounds.x <= location.x && location.x <= childBounds.getMaxX()) {\n            myChildTarget = child;\n            break;\n          }\n        }\n      }\n      else {\n        for (RadComponent child : myContainer.getChildren()) {\n          Rectangle childBounds = child.getBounds(layer);\n          if (childBounds.y <= location.y && location.y <= childBounds.getMaxY()) {\n            myChildTarget = child;\n            break;\n          }\n        }\n      }\n      if (myChildTarget == null) {\n        myChildTarget = getSideChildTarget();\n      }\n\n      Rectangle targetBounds = myChildTarget.getBounds(layer);\n      if (myHorizontal) {\n        myInsertBefore = location.x < targetBounds.getCenterX();\n\n        if (myInsertBefore) {\n          myInsertFeedback.setLocation(targetBounds.x, myBounds.y);\n        }\n        else {\n          myInsertFeedback.setLocation(targetBounds.x + targetBounds.width, myBounds.y);\n        }\n      }\n      else {\n        myInsertBefore = location.y < targetBounds.getCenterY();\n\n        if (myInsertBefore) {\n          myInsertFeedback.setLocation(myBounds.x, targetBounds.y);\n        }\n        else {\n          myInsertFeedback.setLocation(myBounds.x, targetBounds.y + targetBounds.height);\n        }\n      }\n\n      layer.repaint();\n    }\n  }","id":26220,"modified_method":"@Override\n  public void showFeedback() {\n    createFeedback();\n\n    if (!myContainer.getChildren().isEmpty()) {\n      FeedbackLayer layer = myContext.getArea().getFeedbackLayer();\n      Point location = myContext.getLocation();\n      myChildTarget = null;\n\n      if (myHorizontal) {\n        for (RadComponent child : myContainer.getChildren()) {\n          Rectangle childBounds = child.getBounds(layer);\n          Rectangle margins = ((RadViewComponent)child).getMargins();\n          if (childBounds.x - margins.x <= location.x && location.x <= childBounds.getMaxX() + margins.width) {\n            myChildTarget = child;\n            break;\n          }\n        }\n      }\n      else {\n        for (RadComponent child : myContainer.getChildren()) {\n          Rectangle childBounds = child.getBounds(layer);\n          Rectangle margins = ((RadViewComponent)child).getMargins();\n          if (childBounds.y - margins.y <= location.y && location.y <= childBounds.getMaxY() + margins.height) {\n            myChildTarget = child;\n            break;\n          }\n        }\n      }\n      if (myChildTarget == null) {\n        myChildTarget = getSideChildTarget();\n      }\n\n      Rectangle targetBounds = myChildTarget.getBounds(layer);\n      Rectangle targetMargins = ((RadViewComponent)myChildTarget).getMargins();\n      if (myHorizontal) {\n        myInsertBefore = location.x < targetBounds.getCenterX();\n\n        if (myInsertBefore) {\n          myInsertFeedback.setLocation(targetBounds.x - targetMargins.x, myBounds.y);\n        }\n        else {\n          myInsertFeedback.setLocation(targetBounds.x + targetBounds.width + targetMargins.width, myBounds.y);\n        }\n      }\n      else {\n        myInsertBefore = location.y < targetBounds.getCenterY();\n\n        if (myInsertBefore) {\n          myInsertFeedback.setLocation(myBounds.x, targetBounds.y - targetMargins.y);\n        }\n        else {\n          myInsertFeedback.setLocation(myBounds.x, targetBounds.y + targetBounds.height + targetMargins.height);\n        }\n      }\n\n      layer.repaint();\n    }\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void paint(DecorationLayer layer, Graphics2D g, RadComponent component) {\n    Rectangle bounds = component.getBounds(layer);\n\n    g.setColor(BorderStaticDecorator.COLOR);\n    g.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);\n\n    g.setStroke(STROKE);\n\n    if (isHorizontal()) {\n      for (RadComponent child : component.getChildren()) {\n        Rectangle childBounds = child.getBounds(layer);\n        g.drawLine(childBounds.x + childBounds.width, bounds.y, childBounds.x + childBounds.width, bounds.y + bounds.height);\n      }\n    }\n    else {\n      for (RadComponent child : component.getChildren()) {\n        Rectangle childBounds = child.getBounds(layer);\n        g.drawLine(bounds.x, childBounds.y + childBounds.height, bounds.x + bounds.width, childBounds.y + childBounds.height);\n      }\n    }\n  }","id":26221,"modified_method":"@Override\n  protected void paint(DecorationLayer layer, Graphics2D g, RadComponent component) {\n    Rectangle bounds = component.getBounds(layer);\n\n    g.setColor(BorderStaticDecorator.COLOR);\n    g.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);\n\n    g.setStroke(STROKE);\n\n    if (isHorizontal()) {\n      for (RadComponent child : component.getChildren()) {\n        Rectangle childBounds = child.getBounds(layer);\n        int x = childBounds.x + childBounds.width + ((RadViewComponent)child).getMargins().width;\n        g.drawLine(x, bounds.y, x, bounds.y + bounds.height);\n      }\n    }\n    else {\n      for (RadComponent child : component.getChildren()) {\n        Rectangle childBounds = child.getBounds(layer);\n        int y = childBounds.y + childBounds.height + ((RadViewComponent)child).getMargins().height;\n        g.drawLine(bounds.x, y, bounds.x + bounds.width, y);\n      }\n    }\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FrameLayoutOperation(RadViewComponent container, OperationContext context) {\n    super(container, context);\n\n    if (context.isMove()) {\n      myExcludes = new HashSet<Pair<Gravity, Gravity>>();\n\n      for (RadComponent component : context.getComponents()) {\n        myExcludes.add(RadFrameLayout.gravity(component));\n      }\n    }\n  }","id":26222,"modified_method":"public FrameLayoutOperation(RadViewComponent container, OperationContext context) {\n    super(container, context);\n\n    if (context.isMove()) {\n      myExcludes = new HashSet<Pair<Gravity, Gravity>>();\n\n      for (RadComponent component : context.getComponents()) {\n        myExcludes.add(Gravity.getSides(component));\n      }\n    }\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void execute() throws Exception {\n    super.execute();\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        if (myGravity == null) {\n          for (RadComponent component : myComponents) {\n            XmlTag tag = ((RadViewComponent)component).getTag();\n\n            XmlAttribute attribute = tag.getAttribute(\"android:layout_gravity\");\n            if (attribute != null) {\n              attribute.delete();\n            }\n\n            tag.setAttribute(myHorizontal ? \"android:layout_height\" : \"android:layout_width\", \"fill_parent\");\n          }\n        }\n        else {\n          for (RadComponent component : myComponents) {\n            XmlTag tag = ((RadViewComponent)component).getTag();\n\n            XmlAttribute attribute = tag.getAttribute(myHorizontal ? \"android:layout_height\" : \"android:layout_width\");\n            if (attribute != null && (\"match_parent\".equals(attribute.getValue()) || \"fill_parent\".equals(attribute.getValue()))) {\n              attribute.setValue(\"wrap_content\");\n            }\n\n            tag.setAttribute(\"android:layout_gravity\", myHorizontal ?\n                                                       Gravity.getValue(null, myGravity) : Gravity.getValue(myGravity, null));\n          }\n        }\n      }\n    });\n  }","id":26223,"modified_method":"@Override\n  public void execute() throws Exception {\n    if (super.canExecute()) {\n      super.execute();\n    }\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        execute(myHorizontal, myGravity, myComponents);\n      }\n    });\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LinearLayoutOperation(RadViewComponent container, OperationContext context, boolean horizontal) {\n    super(container, context, horizontal);\n\n    if (context.isMove()) {\n      myExcludes = new ArrayList<Gravity>();\n      for (RadComponent component : context.getComponents()) {\n        String fill;\n        if (myHorizontal) {\n          fill = ((RadViewComponent)component).getTag().getAttributeValue(\"android:layout_height\");\n        }\n        else {\n          fill = ((RadViewComponent)component).getTag().getAttributeValue(\"android:layout_width\");\n        }\n\n        if (\"match_parent\".equals(fill) || \"fill_parent\".equals(fill)) {\n          myExcludes.add(null);\n        }\n        else {\n          Pair<Gravity, Gravity> gravity = RadFrameLayout.gravity(component);\n          myExcludes.add(myHorizontal ? gravity.second : gravity.first);\n        }\n      }\n    }\n  }","id":26224,"modified_method":"public LinearLayoutOperation(RadViewComponent container, OperationContext context, boolean horizontal) {\n    super(container, context, horizontal);\n\n    if (context.isMove() && context.getComponents().size() == 1) {\n      myExclude = getGravity(myHorizontal, context.getComponents().get(0));\n    }\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void showFeedback() {\n    super.showFeedback();\n\n    if (myChildTarget == null) {\n      myFeedback.setBounds(myBounds);\n    }\n    else if (myHorizontal) {\n      Rectangle childBounds = myChildTarget.getBounds(myContext.getArea().getFeedbackLayer());\n      myFeedback.setBounds(childBounds.x, myBounds.y, childBounds.width, myBounds.height);\n    }\n    else {\n      Rectangle childBounds = myChildTarget.getBounds(myContext.getArea().getFeedbackLayer());\n      myFeedback.setBounds(myBounds.x, childBounds.y, myBounds.width, childBounds.height);\n    }\n\n    Point location = myContext.getLocation();\n    Gravity gravity = myHorizontal ? calculateVertical(myBounds, location) : calculateHorizontal(myBounds, location);\n\n    myFeedback.setGravity(gravity);\n\n    myTextFeedback.clear();\n    myTextFeedback.bold(gravity == null ? \"fill_parent\" : gravity.name());\n    myTextFeedback.centerTop(myBounds);\n\n    myGravity = gravity;\n  }","id":26225,"modified_method":"@Override\n  public void showFeedback() {\n    super.showFeedback();\n\n    Point location = myContext.getLocation();\n    Gravity gravity = myHorizontal ? calculateVertical(myBounds, location) : calculateHorizontal(myBounds, location);\n\n    myFeedback.setGravity(gravity);\n\n    myTextFeedback.clear();\n    myTextFeedback.bold(gravity == null ? \"fill_parent\" : gravity.name());\n    myTextFeedback.centerTop(myBounds);\n\n    myGravity = gravity;\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean canExecute() {\n    if (myContext.isMove()) {\n      return !isExclude(myGravity);\n    }\n    return true;\n  }","id":26226,"modified_method":"@Override\n  public boolean canExecute() {\n    return super.canExecute() || (myComponents.size() == 1 && myGravity != myExclude);\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Gravity calculateHorizontal(Rectangle bounds, Point location) {\n    Gravity horizontal = null;\n    double width = bounds.width / 4.0;\n    double left = bounds.x + width;\n    double center = bounds.x + 2 * width;\n    double right = bounds.x + 3 * width;\n\n    if (location.x < left) {\n      horizontal = Gravity.left;\n    }\n    else if (left < location.x && location.x < center) {\n      horizontal = Gravity.center;\n    }\n    else if (center < location.x && location.x < right) {\n      horizontal = Gravity.right;\n    }\n\n    return horizontal;\n  }","id":26227,"modified_method":"@Nullable\n  private static Gravity calculateHorizontal(Rectangle bounds, Point location) {\n    Gravity horizontal = Gravity.right;\n    double width = bounds.width / 4.0;\n    double left = bounds.x + width;\n    double center = bounds.x + 2 * width;\n    double fill = bounds.x + 3 * width;\n\n    if (location.x < left) {\n      horizontal = Gravity.left;\n    }\n    else if (left < location.x && location.x < center) {\n      horizontal = Gravity.center;\n    }\n    else if (center < location.x && location.x < fill) {\n      horizontal = null;\n    }\n\n    return horizontal;\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Gravity calculateVertical(Rectangle bounds, Point location) {\n    Gravity vertical = null;\n    double height = bounds.height / 4.0;\n    double top = bounds.y + height;\n    double center = bounds.y + 2 * height;\n    double bottom = bounds.y + 3 * height;\n\n    if (location.y < top) {\n      vertical = Gravity.top;\n    }\n    else if (top < location.y && location.y < center) {\n      vertical = Gravity.center;\n    }\n    else if (center < location.y && location.y < bottom) {\n      vertical = Gravity.bottom;\n    }\n\n    return vertical;\n  }","id":26228,"modified_method":"@Nullable\n  private static Gravity calculateVertical(Rectangle bounds, Point location) {\n    Gravity vertical = Gravity.bottom;\n    double height = bounds.height / 4.0;\n    double top = bounds.y + height;\n    double center = bounds.y + 2 * height;\n    double fill = bounds.y + 3 * height;\n\n    if (location.y < top) {\n      vertical = Gravity.top;\n    }\n    else if (top < location.y && location.y < center) {\n      vertical = Gravity.center;\n    }\n    else if (center < location.y && location.y < fill) {\n      vertical = null;\n    }\n\n    return vertical;\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void createFeedback() {\n    super.createFeedback();\n    if (myFeedback == null) {\n      FeedbackLayer layer = myContext.getArea().getFeedbackLayer();\n\n      myFeedback = new GravityFeedback();\n      layer.add(myFeedback);\n\n      myTextFeedback = new TextFeedback();\n      myTextFeedback.setBorder(IdeBorderFactory.createEmptyBorder(0, 3, 2, 0));\n      layer.add(myTextFeedback);\n\n      layer.repaint();\n    }\n  }","id":26229,"modified_method":"@Override\n  protected void createFeedback() {\n    super.createFeedback();\n\n    if (myFeedback == null) {\n      FeedbackLayer layer = myContext.getArea().getFeedbackLayer();\n\n      myFeedback = new GravityFeedback();\n      myFeedback.setBounds(myBounds);\n      layer.add(myFeedback, 0);\n\n      myTextFeedback = new TextFeedback();\n      myTextFeedback.setBorder(IdeBorderFactory.createEmptyBorder(0, 3, 2, 0));\n      layer.add(myTextFeedback);\n\n      layer.repaint();\n    }\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean paintHorizontalCell(Graphics2D g2d, Gravity gravity, boolean selection) {\n      int x = 0;\n      int width = getWidth();\n\n      int y = 0;\n      int height = (getHeight() - 3) / 4;\n      if (gravity == Gravity.center) {\n        y = height + 1;\n      }\n      else if (gravity == Gravity.bottom) {\n        y = 2 * height + 2;\n      }\n      else if (gravity == null) {\n        y = getHeight() - height;\n      }\n\n      int hSpace = Math.min(5, Math.max(1, getWidth() / 30));\n      if (hSpace > 1) {\n        x += hSpace;\n        width -= 2 * hSpace;\n      }\n\n      int vSpace = Math.min(5, Math.max(1, getHeight() / 30));\n      if (vSpace > 1) {\n        y += vSpace;\n        height -= 2 * vSpace;\n      }\n\n      if (selection) {\n        if (myGravity == gravity) {\n          Color oldColor = g2d.getColor();\n          g2d.setColor(LightColors.YELLOW);\n          g2d.fillRect(x, y, width, height);\n          g2d.setColor(oldColor);\n\n          return true;\n        }\n      }\n      else {\n        g2d.fillRect(x, y, width, height);\n      }\n\n      return false;\n    }","id":26230,"modified_method":"private void paintHorizontalCell(Graphics g) {\n      int y = 0;\n      int height = (getHeight() - 3) / 4;\n      if (myGravity == Gravity.center) {\n        y = height + 1;\n      }\n      else if (myGravity == null) {\n        y = 2 * height + 2;\n      }\n      else if (myGravity == Gravity.bottom) {\n        y = getHeight() - height;\n      }\n\n      int vSpace = Math.min(5, Math.max(1, getHeight() / 30));\n      if (vSpace > 1) {\n        y += vSpace;\n        height -= 2 * vSpace;\n      }\n\n      if (myContainer.getChildren().isEmpty()) {\n        g.fillRect(0, y, 2, height);\n        g.fillRect(myBounds.width - SIZE, y, SIZE, height);\n      }\n      else {\n        g.fillRect(myInsertFeedback.getX() - myBounds.x + SIZE, y, SIZE, height);\n      }\n    }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean paintVerticalCell(Graphics2D g2d, Gravity gravity, boolean selection) {\n      int x = 0;\n      int width = (getWidth() - 3) / 4;\n      if (gravity == Gravity.center) {\n        x = width + 1;\n      }\n      else if (gravity == Gravity.right) {\n        x = 2 * width + 2;\n      }\n      else if (gravity == null) {\n        x = getWidth() - width;\n      }\n\n      int y = 0;\n      int height = getHeight();\n\n      int hSpace = Math.min(5, Math.max(1, getWidth() / 30));\n      if (hSpace > 1) {\n        x += hSpace;\n        width -= 2 * hSpace;\n      }\n\n      int vSpace = Math.min(5, Math.max(1, getHeight() / 30));\n      if (vSpace > 1) {\n        y += vSpace;\n        height -= 2 * vSpace;\n      }\n\n      if (selection) {\n        if (myGravity == gravity) {\n          Color oldColor = g2d.getColor();\n          g2d.setColor(LightColors.YELLOW);\n          g2d.fillRect(x, y, width, height);\n          g2d.setColor(oldColor);\n\n          return true;\n        }\n      }\n      else {\n        g2d.fillRect(x, y, width, height);\n      }\n\n      return false;\n    }","id":26231,"modified_method":"private void paintVerticalCell(Graphics g) {\n      int x = 0;\n      int width = (getWidth() - 3) / 4;\n      if (myGravity == Gravity.center) {\n        x = width + 1;\n      }\n      else if (myGravity == null) {\n        x = 2 * width + 2;\n      }\n      else if (myGravity == Gravity.right) {\n        x = getWidth() - width;\n      }\n\n      int hSpace = Math.min(5, Math.max(1, getWidth() / 30));\n      if (hSpace > 1) {\n        x += hSpace;\n        width -= 2 * hSpace;\n      }\n\n      if (myContainer.getChildren().isEmpty()) {\n        g.fillRect(x, 0, width, SIZE);\n        g.fillRect(x, myBounds.height - SIZE, width, SIZE);\n      }\n      else {\n        g.fillRect(x, myInsertFeedback.getY() - myBounds.y + SIZE, width, SIZE);\n      }\n    }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public ComponentDecorator getChildSelectionDecorator(RadComponent component, List<RadComponent> selection) {\n    mySelectionDecorator.clear();\n    if (selection.size() == 1) {\n      FrameLayoutMarginOperation.points(mySelectionDecorator);\n    }\n    ResizeOperation.points(mySelectionDecorator);\n    return mySelectionDecorator;\n  }","id":26232,"modified_method":"@Override\n  public ComponentDecorator getChildSelectionDecorator(RadComponent component, List<RadComponent> selection) {\n    if (mySelectionDecorator == null) {\n      mySelectionDecorator = new ResizeSelectionDecorator(Color.red, 1) {\n        @Override\n        protected boolean visible(RadComponent component, ResizePoint point) {\n          if (point.getType() == LayoutMarginOperation.TYPE) {\n            Pair<Gravity, Gravity> gravity = Gravity.getSides(component);\n            int direction = ((DirectionResizePoint)point).getDirection();\n\n            if (direction == Position.WEST) { // left\n              return gravity.first == Gravity.left || gravity.first == Gravity.center;\n            }\n            if (direction == Position.EAST) { // right\n              return gravity.first == Gravity.right || gravity.first == Gravity.center;\n            }\n            if (direction == Position.NORTH) { // top\n              return gravity.second == Gravity.top || gravity.second == Gravity.center;\n            }\n            if (direction == Position.SOUTH) { // bottom\n              return gravity.second == Gravity.bottom || gravity.second == Gravity.center;\n            }\n          }\n          return true;\n        }\n      };\n    }\n\n    mySelectionDecorator.clear();\n    if (selection.size() == 1) {\n      LayoutMarginOperation.points(mySelectionDecorator);\n    }\n    ResizeOperation.points(mySelectionDecorator);\n\n    return mySelectionDecorator;\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public EditOperation processChildOperation(OperationContext context) {\n    if (context.isCreate() || context.isPaste() || context.isAdd() || context.isMove()) {\n      if (context.isTree()) {\n        return new TreeDropToOperation(myContainer, context);\n      }\n      return new FrameLayoutOperation((RadViewComponent)myContainer, context);\n    }\n    else if (context.is(ResizeOperation.TYPE)) {\n      return new ResizeOperation(context);\n    }\n    else if (context.is(FrameLayoutMarginOperation.TYPE)) {\n      return new FrameLayoutMarginOperation(context);\n    }\n    return null;\n  }","id":26233,"modified_method":"@Override\n  public EditOperation processChildOperation(OperationContext context) {\n    if (context.isCreate() || context.isPaste() || context.isAdd() || context.isMove()) {\n      if (context.isTree()) {\n        return new TreeDropToOperation(myContainer, context);\n      }\n      return new FrameLayoutOperation((RadViewComponent)myContainer, context);\n    }\n    else if (context.is(ResizeOperation.TYPE)) {\n      return new ResizeOperation(context);\n    }\n    else if (context.is(LayoutMarginOperation.TYPE)) {\n      return new LayoutMarginOperation(context);\n    }\n    return null;\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void addSelectionActions(final DesignerEditorPanel designer,\n                                  DefaultActionGroup actionGroup,\n                                  JComponent shortcuts,\n                                  final List<RadComponent> selection) {\n    if (selection.size() != 1) {\n      return;\n    }\n\n    AbstractComboBoxAction<Pair<Boolean, Gravity>> action = new AbstractComboBoxAction<Pair<Boolean, Gravity>>() {\n      private Pair<Gravity, Gravity> myGravity;\n\n      @Override\n      protected boolean addSeparator(DefaultActionGroup actionGroup, Pair<Boolean, Gravity> item) {\n        if (item == null) {\n          actionGroup.addSeparator();\n          return true;\n        }\n        return false;\n      }\n\n      @NotNull\n      @Override\n      protected DefaultActionGroup createPopupActionGroup(JComponent button) {\n        myGravity = gravity(selection.get(0));\n        return super.createPopupActionGroup(button);\n      }\n\n      @Override\n      protected void update(Pair<Boolean, Gravity> item, Presentation presentation, boolean popup) {\n        if (popup) {\n          Gravity selection = item.first ? myGravity.first : myGravity.second;\n          presentation.setIcon(selection == item.second ? CHECKED : null);\n          presentation.setText(item.second.name());\n        }\n      }\n\n      @Override\n      protected boolean selectionChanged(Pair<Boolean, Gravity> item) {\n        Gravity oldSelection = item.first ? myGravity.first : myGravity.second;\n        if (oldSelection != item.second) {\n          final String gravity =\n            item.first ? Gravity.getValue(item.second, myGravity.second) : Gravity.getValue(myGravity.first, item.second);\n          designer.getToolProvider().execute(new ThrowableRunnable<Exception>() {\n            @Override\n            public void run() throws Exception {\n              ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                @Override\n                public void run() {\n                  ((RadViewComponent)selection.get(0)).getTag().setAttribute(\"android:layout_gravity\", gravity);\n                }\n              });\n            }\n          }, \"Change attribute 'gravity'\", true);\n        }\n\n        return false;\n      }\n\n      @Override\n      public void setSelection(Pair<Boolean, Gravity> selection) {\n      }\n    };\n    Presentation presentation = action.getTemplatePresentation();\n    presentation.setDescription(\"Gravity\");\n    presentation.setIcon(IconLoader.getIcon(\"/com/intellij/android/designer/icons/gravity.png\"));\n    action.setItems(ITEMS, null);\n\n    actionGroup.add(action);\n  }","id":26234,"modified_method":"@Override\n  public void addSelectionActions(final DesignerEditorPanel designer,\n                                  DefaultActionGroup actionGroup,\n                                  JComponent shortcuts,\n                                  final List<RadComponent> selection) {\n    if (selection.size() != 1) {\n      return;\n    }\n\n    AbstractComboBoxAction<Pair<Boolean, Gravity>> action = new AbstractComboBoxAction<Pair<Boolean, Gravity>>() {\n      private Pair<Gravity, Gravity> myGravity;\n\n      @Override\n      protected boolean addSeparator(DefaultActionGroup actionGroup, Pair<Boolean, Gravity> item) {\n        if (item == null) {\n          actionGroup.addSeparator();\n          return true;\n        }\n        return false;\n      }\n\n      @NotNull\n      @Override\n      protected DefaultActionGroup createPopupActionGroup(JComponent button) {\n        myGravity = Gravity.getSides(selection.get(0));\n        return super.createPopupActionGroup(button);\n      }\n\n      @Override\n      protected void update(Pair<Boolean, Gravity> item, Presentation presentation, boolean popup) {\n        if (popup) {\n          Gravity selection = item.first ? myGravity.first : myGravity.second;\n          presentation.setIcon(selection == item.second ? CHECKED : null);\n          presentation.setText(item.second.name());\n        }\n      }\n\n      @Override\n      protected boolean selectionChanged(Pair<Boolean, Gravity> item) {\n        Gravity oldSelection = item.first ? myGravity.first : myGravity.second;\n        if (oldSelection != item.second) {\n          final String gravity =\n            item.first ? Gravity.getValue(item.second, myGravity.second) : Gravity.getValue(myGravity.first, item.second);\n          designer.getToolProvider().execute(new ThrowableRunnable<Exception>() {\n            @Override\n            public void run() throws Exception {\n              ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                @Override\n                public void run() {\n                  ((RadViewComponent)selection.get(0)).getTag().setAttribute(\"android:layout_gravity\", gravity);\n                }\n              });\n            }\n          }, \"Change attribute 'gravity'\", true);\n        }\n\n        return false;\n      }\n\n      @Override\n      public void setSelection(Pair<Boolean, Gravity> selection) {\n      }\n    };\n    Presentation presentation = action.getTemplatePresentation();\n    presentation.setDescription(\"Gravity\");\n    presentation.setIcon(Gravity.ICON);\n    action.setItems(ITEMS, null);\n\n    actionGroup.add(action);\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void addSelectionActions(DesignerEditorPanel designer,\n                                  DefaultActionGroup actionGroup,\n                                  JComponent shortcuts,\n                                  List<RadComponent> selection) {\n    super.addSelectionActions(designer, actionGroup, shortcuts, selection); // TODO: Auto-generated method stub\n  }","id":26235,"modified_method":"@Override\n  public void addSelectionActions(final DesignerEditorPanel designer,\n                                  DefaultActionGroup actionGroup,\n                                  JComponent shortcuts,\n                                  final List<RadComponent> selection) {\n    for (RadComponent component : selection) {\n      if (component.getParent() != myContainer) {\n        return;\n      }\n    }\n\n    createOrientationAction(designer, actionGroup, shortcuts, Arrays.asList(myContainer));\n\n    AbstractComboBoxAction<Gravity> action = new AbstractComboBoxAction<Gravity>() {\n      private Gravity mySelection;\n\n      @NotNull\n      @Override\n      protected DefaultActionGroup createPopupActionGroup(JComponent button) {\n        boolean horizontal = isHorizontal();\n        Gravity unknown = horizontal ? Gravity.left : Gravity.top;\n        setItems(horizontal ? VERTICALS : HORIZONTALS, unknown);\n\n        Iterator<RadComponent> I = selection.iterator();\n        mySelection = LinearLayoutOperation.getGravity(horizontal, I.next());\n\n        while (I.hasNext()) {\n          if (mySelection != LinearLayoutOperation.getGravity(horizontal, I.next())) {\n            mySelection = unknown;\n            break;\n          }\n        }\n\n        return super.createPopupActionGroup(button);\n      }\n\n      @Override\n      protected void update(Gravity item, Presentation presentation, boolean popup) {\n        if (popup) {\n          presentation.setIcon(mySelection == item ? CHECKED : null);\n          presentation.setText(item == null ? \"fill\" : item.name());\n        }\n      }\n\n      @Override\n      protected boolean selectionChanged(final Gravity item) {\n        designer.getToolProvider().execute(new ThrowableRunnable<Exception>() {\n          @Override\n          public void run() throws Exception {\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              @Override\n              public void run() {\n                LinearLayoutOperation.execute(isHorizontal(), item, selection);\n              }\n            });\n          }\n        }, \"Change attribute 'gravity'\", true);\n\n        return false;\n      }\n\n      @Override\n      public void update() {\n      }\n    };\n    Presentation presentation = action.getTemplatePresentation();\n    presentation.setDescription(\"Gravity\");\n    presentation.setIcon(Gravity.ICON);\n\n    actionGroup.add(action);\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void addContainerSelectionActions(DesignerEditorPanel designer,\n                                           DefaultActionGroup actionGroup,\n                                           JComponent shortcuts,\n                                           List<RadComponent> selection) {\n    super.addContainerSelectionActions(designer, actionGroup, shortcuts, selection); // TODO: Auto-generated method stub\n  }","id":26236,"modified_method":"@Override\n  public void addContainerSelectionActions(DesignerEditorPanel designer,\n                                           DefaultActionGroup actionGroup,\n                                           JComponent shortcuts,\n                                           List<RadComponent> selection) {\n    if (selection.get(selection.size() - 1) != myContainer) {\n      return;\n    }\n    for (RadComponent component : selection) {\n      if (!(component.getLayout() instanceof RadLinearLayout)) {\n        return;\n      }\n    }\n\n    createOrientationAction(designer, actionGroup, shortcuts, selection);\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public EditOperation processChildOperation(OperationContext context) {\n    if (context.isCreate() || context.isPaste() || context.isAdd() || context.isMove()) {\n      if (context.isTree()) {\n        return new TreeDropToOperation(myContainer, context);\n      }\n      return new LinearLayoutOperation((RadViewComponent)myContainer, context, isHorizontal());\n    }\n    else if (context.is(ResizeOperation.TYPE)) {\n      return new ResizeOperation(context);\n    }\n    return null;\n  }","id":26237,"modified_method":"@Override\n  public EditOperation processChildOperation(OperationContext context) {\n    if (context.isCreate() || context.isPaste() || context.isAdd() || context.isMove()) {\n      if (context.isTree()) {\n        return new TreeDropToOperation(myContainer, context);\n      }\n      return new LinearLayoutOperation((RadViewComponent)myContainer, context, isHorizontal());\n    }\n    else if (context.is(ResizeOperation.TYPE)) {\n      return new ResizeOperation(context);\n    }\n    else if (context.is(LayoutMarginOperation.TYPE)) {\n      return new LayoutMarginOperation(context);\n    }\n    return null;\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public ComponentDecorator getChildSelectionDecorator(RadComponent component, List<RadComponent> selection) {\n    mySelectionDecorator.clear();\n    if (selection.size() == 1) {\n      // XXX\n    }\n    ResizeOperation.points(mySelectionDecorator);\n    return mySelectionDecorator;\n  }","id":26238,"modified_method":"@Override\n  public ComponentDecorator getChildSelectionDecorator(RadComponent component, List<RadComponent> selection) {\n    if (mySelectionDecorator == null) {\n      mySelectionDecorator = new ResizeSelectionDecorator(Color.red, 1) {\n        @Override\n        protected boolean visible(RadComponent component, ResizePoint point) {\n          if (point.getType() == LayoutMarginOperation.TYPE) {\n            boolean horizontal = isHorizontal();\n            Pair<Gravity, Gravity> gravity = Gravity.getSides(component);\n            int direction = ((DirectionResizePoint)point).getDirection();\n\n            if (direction == Position.WEST) { // left\n              return horizontal || gravity.first != Gravity.right;\n            }\n            if (direction == Position.EAST) { // right\n              return horizontal || gravity.first != Gravity.left;\n            }\n            if (direction == Position.NORTH) { // top\n              return !horizontal || gravity.second != Gravity.bottom;\n            }\n            if (direction == Position.SOUTH) { // bottom\n              return !horizontal || gravity.second != Gravity.top;\n            }\n          }\n          return true;\n        }\n      };\n    }\n\n    mySelectionDecorator.clear();\n    if (selection.size() == 1) {\n      LayoutMarginOperation.points(mySelectionDecorator);\n    }\n    ResizeOperation.points(mySelectionDecorator);\n\n    return mySelectionDecorator;\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setViewInfo(ViewInfo viewInfo) {\n    myViewInfo = viewInfo;\n  }","id":26239,"modified_method":"public void setViewInfo(ViewInfo viewInfo) {\n    myViewInfo = viewInfo;\n    myMargins = null;\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Pair<Integer, Integer> getDefaultSize(String value, int size) {\n    int wrap = -1;\n    int fill = -1;\n\n    if (\"wrap_content\".equals(value)) {\n      wrap = size;\n    }\n    else if (\"fill_parent\".equals(value) || \"match_parent\".equals(value)) {\n      fill = size;\n    }\n\n    return new Pair<Integer, Integer>(wrap, fill);\n  }","id":26240,"modified_method":"private static Pair<Integer, Integer> getDefaultSize(String value, int size) {\n    int wrap = -1;\n    int fill = -1;\n\n    if (\"wrap_content\".equals(value)) {\n      wrap = size;\n    }\n    else if (isFill(value)) {\n      fill = size;\n    }\n\n    return new Pair<Integer, Integer>(wrap, fill);\n  }","commit_id":"a09f87c37818841e32c2e417ec1bc2101ebd711e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Loading the descriptors in this case means filtering the descriptor from the master {@link ExtensionList}.\n     */\n    @Override\n    protected List<ExtensionComponent<D>> load() {\n        List<ExtensionComponent<D>> r = new ArrayList<ExtensionComponent<D>>();\n        for( ExtensionComponent<Descriptor> c : hudson.getExtensionList(Descriptor.class).getComponents() ) {\n            Descriptor d = c.getInstance();\n            try {\n                if(d.getT()==describableType)\n                    r.add((ExtensionComponent)c);\n            } catch (IllegalStateException e) {\n                LOGGER.log(Level.SEVERE, d.getClass() + \" doesn't extend Descriptor with a type parameter\", e); // skip this one\n            }\n        }\n        return r;\n    }","id":26241,"modified_method":"/**\n     * Loading the descriptors in this case means filtering the descriptor from the master {@link ExtensionList}.\n     */\n    @Override\n    protected List<ExtensionComponent<D>> load() {\n        return _load(jenkins.getExtensionList(Descriptor.class).getComponents());\n    }","commit_id":"e78b8a2650dd83f483781d38a6d52376925d43c0","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Signals a refork each time a configurable amount of tests is run.\n     *\n     * @param decisionContextItemData the amount of tests currently executed by the fork.\n     * @return true if the fork needs to restart.\n     */\n    public boolean determineReforkNeeded(Object decisionContextItemData) {\n        final Long amountOfTestsExecutedByFork = (Long) decisionContextItemData;\n\n        return amountOfTestsExecutedByFork % reforkEveryThisAmountOfTests == 0;\n    }","id":26242,"modified_method":"/**\n     * Signals a refork each time a configurable amount of tests is run.\n     *\n     * @param decisionContextItemData the amount of tests currently executed by the fork.\n     * @return true if the fork needs to restart.\n     */\n    public boolean determineReforkNeeded(Pipeline pipeline, int forkId, Object decisionContextItemData) {\n        final Long amountOfTestsExecutedByFork = (Long) decisionContextItemData;\n\n        final boolean restartNeeded = amountOfTestsExecutedByFork % reforkEveryThisAmountOfTests == 0;\n\n        if ( restartNeeded ) {\n            logger.info(\"pipeline {}, fork {} : restart needed, amount of tests executed = {}\",\n                    new Object[]{\n                            pipeline.getName(),\n                            forkId,\n                            amountOfTestsExecutedByFork\n                    });\n        }\n\n        return restartNeeded;\n    }","commit_id":"619f75e0a77549a3f68f7fe150bb7ac4bb08259c","url":"https://github.com/gradle/gradle"},{"original_method":"public void process(ReportInfo reportInfo) {\n        if (TestClassProcessResultReportInfo.class == reportInfo.getClass()) {\n            final TestClassProcessResultReportInfo testClassInfo = (TestClassProcessResultReportInfo) reportInfo;\n\n            final Pipeline pipeline = testClassInfo.getPipeline();\n            final TestClassProcessResult classResult = testClassInfo.getTestClassProcessResult();\n            final List<TestMethodProcessResult> methodResults = classResult.getMethodResults();\n\n            final Map<TestMethodProcessResultState, Integer> stateCounts\n                    = new HashMap<TestMethodProcessResultState, Integer>();\n\n            for (final TestMethodProcessResult methodResult : methodResults) {\n                final TestMethodProcessResultState mappedState = methodProcessResultStateMapping.get(\n                        methodResult.getState());\n\n                Integer stateCount = stateCounts.get(mappedState);\n                if (stateCount == null) {\n                    stateCount = 1;\n                } else {\n                    stateCount++;\n                }\n                stateCounts.put(mappedState, stateCount);\n            }\n\n            final List<TestMethodProcessResultState> noneZeroStates = new ArrayList<TestMethodProcessResultState>();\n\n            for (final TestMethodProcessResultState state : TestMethodProcessResultStates.values()) {\n                final Integer stateCount = stateCounts.get(state);\n                if (stateCount != null) {\n                    noneZeroStates.add(state);\n                }\n            }\n\n            boolean show = false;\n            final List<TestMethodProcessResultState> toShowStates = config.getToShowStates();\n            final Iterator<TestMethodProcessResultState> toShowStatesIterator = toShowStates.iterator();\n            while (!show && toShowStatesIterator.hasNext()) {\n                show = noneZeroStates.contains(toShowStatesIterator.next());\n            }\n\n            if (show) {\n                final int failureCount = stateCounts.get(TestMethodProcessResultStates.FAILURE) == null ? 0\n                        : stateCounts.get(TestMethodProcessResultStates.FAILURE);\n                final int errorCount = stateCounts.get(TestMethodProcessResultStates.ERROR) == null ? 0\n                        : stateCounts.get(TestMethodProcessResultStates.ERROR);\n                final int successCount = stateCounts.get(TestMethodProcessResultStates.SUCCESS) == null ? 0\n                        : stateCounts.get(TestMethodProcessResultStates.SUCCESS);\n\n                logger.info(\"pipeline {}, fork {} : Test {} : success#{}, failure#{}, error#{}\", new Object[]{\n                        pipeline.getConfig().getName(), reportInfo.getForkId(),\n                        classResult.getTestClassRunInfo().getTestClassName(), successCount, failureCount, errorCount\n                });\n\n                if (failureCount > 0 || errorCount > 0) {\n                    for (final TestMethodProcessResult methodResult : methodResults) {\n                        if (methodResult.getState() == TestMethodProcessResultStates.ERROR\n                                || methodResult.getState() == TestMethodProcessResultStates.FAILURE) {\n                            logger.info(\"pipeline {}, fork {} : Test {} :\", new Object[]{\n                                    pipeline.getConfig().getName(), reportInfo.getForkId(),\n                                    classResult.getTestClassRunInfo().getTestClassName() + \".\" + methodResult\n                                            .getMethodName()\n                            });\n                            logger.info(\"cause\", methodResult.getThrownException());\n                        }\n                    }\n                }\n            }\n        }\n        // else unsupported reportInfo -> warning ?\n    }","id":26243,"modified_method":"public void process(ReportInfo reportInfo) {\n        if (TestClassProcessResultReportInfo.class == reportInfo.getClass()) {\n            final TestClassProcessResultReportInfo testClassInfo = (TestClassProcessResultReportInfo) reportInfo;\n\n            final Pipeline pipeline = testClassInfo.getPipeline();\n            final TestClassProcessResult classResult = testClassInfo.getTestClassProcessResult();\n            final List<TestMethodProcessResult> methodResults = classResult.getMethodResults();\n\n            final Map<TestMethodProcessResultState, Integer> stateCounts\n                    = new HashMap<TestMethodProcessResultState, Integer>();\n\n            for (final TestMethodProcessResult methodResult : methodResults) {\n                final TestMethodProcessResultState mappedState = methodProcessResultStateMapping.get(\n                        methodResult.getState());\n\n                Integer stateCount = stateCounts.get(mappedState);\n                if (stateCount == null) {\n                    stateCount = 1;\n                } else {\n                    stateCount++;\n                }\n                stateCounts.put(mappedState, stateCount);\n            }\n\n            final List<TestMethodProcessResultState> noneZeroStates = new ArrayList<TestMethodProcessResultState>();\n\n            for (final TestMethodProcessResultState state : TestMethodProcessResultStates.values()) {\n                final Integer stateCount = stateCounts.get(state);\n                if (stateCount != null) {\n                    noneZeroStates.add(state);\n                }\n            }\n\n            boolean show = false;\n            final List<TestMethodProcessResultState> toShowStates = config.getToShowStates();\n            final Iterator<TestMethodProcessResultState> toShowStatesIterator = toShowStates.iterator();\n            while (!show && toShowStatesIterator.hasNext()) {\n                show = noneZeroStates.contains(toShowStatesIterator.next());\n            }\n\n            if (show) {\n                final int failureCount = stateCounts.get(TestMethodProcessResultStates.FAILURE) == null ? 0\n                        : stateCounts.get(TestMethodProcessResultStates.FAILURE);\n                final int errorCount = stateCounts.get(TestMethodProcessResultStates.ERROR) == null ? 0\n                        : stateCounts.get(TestMethodProcessResultStates.ERROR);\n                final int successCount = stateCounts.get(TestMethodProcessResultStates.SUCCESS) == null ? 0\n                        : stateCounts.get(TestMethodProcessResultStates.SUCCESS);\n\n                logger.info(\"pipeline {}, fork {} : Test {} : success#{}, failure#{}, error#{}\", new Object[]{\n                        pipeline.getName(), reportInfo.getForkId(),\n                        classResult.getTestClassRunInfo().getTestClassName(), successCount, failureCount, errorCount\n                });\n\n                if (failureCount > 0 || errorCount > 0) {\n                    for (final TestMethodProcessResult methodResult : methodResults) {\n                        if (methodResult.getState() == TestMethodProcessResultStates.ERROR\n                                || methodResult.getState() == TestMethodProcessResultStates.FAILURE) {\n                            logger.info(\"pipeline {}, fork {} : Test {} :\", new Object[]{\n                                    pipeline.getName(), reportInfo.getForkId(),\n                                    classResult.getTestClassRunInfo().getTestClassName() + \".\" + methodResult\n                                            .getMethodName()\n                            });\n                            logger.info(\"cause\", methodResult.getThrownException());\n                        }\n                    }\n                }\n            }\n        }\n        // else unsupported reportInfo -> warning ?\n    }","commit_id":"619f75e0a77549a3f68f7fe150bb7ac4bb08259c","url":"https://github.com/gradle/gradle"},{"original_method":"boolean isReforkNeeded(NextActionRequestMessage message) {\n        boolean reforkNeeded = false;\n\n        final ReforkController reforkController = pipeline.getReforkController();\n        if (reforkController != null) {\n            final ReforkDecisionContext reforkDecisionContext = message.getReforkDecisionContext();\n\n            if (reforkDecisionContext != null) {\n                reforkNeeded = reforkController.reforkNeeded(reforkDecisionContext);\n            }\n        }\n\n        return reforkNeeded;\n    }","id":26244,"modified_method":"boolean isReforkNeeded(NextActionRequestMessage message) {\n        boolean reforkNeeded = false;\n\n        final ReforkController reforkController = pipeline.getReforkController();\n        if (reforkController != null) {\n            final ReforkDecisionContext reforkDecisionContext = message.getReforkDecisionContext();\n\n            if (reforkDecisionContext != null) {\n                reforkNeeded = reforkController.reforkNeeded(pipeline, message.getForkId(), reforkDecisionContext);\n            }\n        }\n\n        return reforkNeeded;\n    }","commit_id":"619f75e0a77549a3f68f7fe150bb7ac4bb08259c","url":"https://github.com/gradle/gradle"},{"original_method":"public Pipeline(PipelinesManager manager, int id, NativeTest testTask, PipelineConfig config) {\n        this.manager = manager;\n        this.id = id;\n        this.testTask = testTask;\n        this.config = config;\n        this.runInfoQueue = new ArrayBlockingQueue<TestClassRunInfo>(1000);\n        this.runInfoQueueProducer = new BlockingQueueItemProducer<TestClassRunInfo>(runInfoQueue, 100L,\n                TimeUnit.MILLISECONDS);\n        this.reforkController = new ReforkControllerImpl();\n        this.reports = new ArrayList<Report>();\n        this.listeners = new ArrayList<PipelineListener>();\n    }","id":26245,"modified_method":"public Pipeline(PipelinesManager manager, int id, NativeTest testTask, PipelineConfig config) {\n        if ( manager == null ) throw new IllegalArgumentException(\"manager is null!\");\n        if ( id <= 0 ) throw new IllegalArgumentException(\"id <= 0!\");\n        if ( testTask == null ) throw new IllegalArgumentException(\"testTask is null!\");\n        if ( config == null ) throw new IllegalArgumentException(\"config is null!\");\n\n        this.manager = manager;\n        this.id = id;\n        this.testTask = testTask;\n        this.config = config;\n        this.runInfoQueue = new ArrayBlockingQueue<TestClassRunInfo>(1000);\n        this.runInfoQueueProducer = new BlockingQueueItemProducer<TestClassRunInfo>(runInfoQueue, 100L,\n                TimeUnit.MILLISECONDS);\n        this.reforkController = new ReforkControllerImpl();\n        this.reports = new ArrayList<Report>();\n        this.listeners = new ArrayList<PipelineListener>();\n    }","commit_id":"619f75e0a77549a3f68f7fe150bb7ac4bb08259c","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Handle messages received from the fork.\n     */\n    public void messageReceived(IoSession ioSession, Object message) {\n        if (message != null) {\n            final Class<?> messageClass = message.getClass();\n            final TestControlMessageHandler handler = messageClassHandlers.get(messageClass);\n\n            if (handler != null) {\n                try {\n                    final int forkId = ((TestClientControlMessage) message).getForkId();\n                    final TestServerClientHandle client = clientHandles.get(forkId);\n                    if (client == null) {\n                        ioSession.write(new WaitActionMesssage(pipeline.getId(), 1000L));\n                    } else {\n                        handler.handle(ioSession, message, client);\n                    }\n                } catch (Throwable t) {\n                    LOGGER.error(\"failed to handle \" + message, t);\n                }\n            } else {\n                LOGGER.error(\"received unknown message of type {} on pipeline \", messageClass,\n                        pipeline.getConfig().getName());\n                ioSession.write(new StopForkActionMessage(pipeline.getId()));\n            }\n        }\n    }","id":26246,"modified_method":"/**\n     * Handle messages received from the fork.\n     */\n    public void messageReceived(IoSession ioSession, Object message) {\n        if (message != null) {\n            final Class<?> messageClass = message.getClass();\n            final TestControlMessageHandler handler = messageClassHandlers.get(messageClass);\n\n            if (handler != null) {\n                try {\n                    final int forkId = ((TestClientControlMessage) message).getForkId();\n                    final TestServerClientHandle client = clientHandles.get(forkId);\n                    if (client == null) {\n                        ioSession.write(new WaitActionMesssage(pipeline.getId(), 1000L));\n                    } else {\n                        handler.handle(ioSession, message, client);\n                    }\n                } catch (Throwable t) {\n                    LOGGER.error(\"failed to handle \" + message, t);\n                }\n            } else {\n                LOGGER.error(\"received unknown message of type {} on pipeline \", messageClass,\n                        pipeline.getName());\n                ioSession.write(new StopForkActionMessage(pipeline.getId()));\n            }\n        }\n    }","commit_id":"619f75e0a77549a3f68f7fe150bb7ac4bb08259c","url":"https://github.com/gradle/gradle"},{"original_method":"public void stopped(int forkId) {\n        LOGGER.info(\"pipeline {}, fork {} : stopped\", pipelineDispatcher.getPipeline().getConfig().getName(), forkId);\n\n        pipelineDispatcher.forkStopped(forkId);\n    }","id":26247,"modified_method":"public void stopped(int forkId) {\n        LOGGER.info(\"pipeline {}, fork {} : stopped\", pipelineDispatcher.getPipeline().getName(), forkId);\n\n        pipelineDispatcher.forkStopped(forkId);\n    }","commit_id":"619f75e0a77549a3f68f7fe150bb7ac4bb08259c","url":"https://github.com/gradle/gradle"},{"original_method":"public void aborted(int forkId) {\n        LOGGER.info(\"pipeline {}, fork {} : aborted\", pipelineDispatcher.getPipeline().getConfig().getName(), forkId);\n\n        pipelineDispatcher.forkAborted(forkId);\n    }","id":26248,"modified_method":"public void aborted(int forkId) {\n        LOGGER.info(\"pipeline {}, fork {} : aborted\", pipelineDispatcher.getPipeline().getName(), forkId);\n\n        pipelineDispatcher.forkAborted(forkId);\n    }","commit_id":"619f75e0a77549a3f68f7fe150bb7ac4bb08259c","url":"https://github.com/gradle/gradle"},{"original_method":"public void starting(int forkId) {\n        LOGGER.info(\"pipeline {}, fork {} : started\", pipelineDispatcher.getPipeline().getConfig().getName(), forkId);\n\n        pipelineDispatcher.forkStarting(forkId);\n    }","id":26249,"modified_method":"public void starting(int forkId) {\n        LOGGER.info(\"pipeline {}, fork {} : started\", pipelineDispatcher.getPipeline().getName(), forkId);\n\n        pipelineDispatcher.forkStarting(forkId);\n    }","commit_id":"619f75e0a77549a3f68f7fe150bb7ac4bb08259c","url":"https://github.com/gradle/gradle"},{"original_method":"public void failed(int forkId, Throwable cause) {\n        LOGGER.info(\"pipeline {}, fork {} : failed\", pipelineDispatcher.getPipeline().getConfig().getName(), forkId);\n\n        pipelineDispatcher.forkFailed(forkId, cause);\n    }","id":26250,"modified_method":"public void failed(int forkId, Throwable cause) {\n        LOGGER.info(\"pipeline {}, fork {} : failed\", pipelineDispatcher.getPipeline().getName(), forkId);\n\n        pipelineDispatcher.forkFailed(forkId, cause);\n    }","commit_id":"619f75e0a77549a3f68f7fe150bb7ac4bb08259c","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean reforkNeeded(ReforkDecisionContext reforkDecisionContext) {\n        boolean reforkNeeded = false;\n\n        final Iterator<ReforkReasonKey> itemsIterator = itemProcessorsOrdered.iterator();\n\n        while (!reforkNeeded && itemsIterator.hasNext()) {\n            final ReforkReasonKey currentItemKey = itemsIterator.next();\n            final Object currentItemData = reforkDecisionContext.getData(currentItemKey);\n\n            if (currentItemData != null) {\n                final ReforkReasonDataProcessor currentItemDataProcessor = itemProcessors.get(currentItemKey);\n\n                reforkNeeded = currentItemDataProcessor.determineReforkNeeded(currentItemData);\n            }\n        }\n\n        return reforkNeeded;\n    }","id":26251,"modified_method":"public boolean reforkNeeded(Pipeline pipeline, int forkId, ReforkDecisionContext reforkDecisionContext) {\n        boolean reforkNeeded = false;\n\n        final Iterator<ReforkReasonKey> itemsIterator = itemProcessorsOrdered.iterator();\n\n        while (!reforkNeeded && itemsIterator.hasNext()) {\n            final ReforkReasonKey currentItemKey = itemsIterator.next();\n            final Object currentItemData = reforkDecisionContext.getData(currentItemKey);\n\n            if (currentItemData != null) {\n                final ReforkReasonDataProcessor currentItemDataProcessor = itemProcessors.get(currentItemKey);\n\n                reforkNeeded = currentItemDataProcessor.determineReforkNeeded(pipeline, forkId, currentItemData);\n            }\n        }\n\n        return reforkNeeded;\n    }","commit_id":"619f75e0a77549a3f68f7fe150bb7ac4bb08259c","url":"https://github.com/gradle/gradle"},{"original_method":"public SNode getRepresentative(final SNode node) {\n    if (node == null || !TypesUtil.isVariable(node)) {\n      return node;\n    }\n    SNode nameRepresentative = getNameRepresentative(node);\n    SNode parent = myRepresentatives.get(nameRepresentative);\n    SNode current = nameRepresentative;\n    if (parent != null) {\n      List<SNode> path = new LinkedList<SNode>();\n      while (parent != null) {\n        if (current != nameRepresentative) {\n          path.add(current);\n        }\n        current = parent;\n        parent = myRepresentatives.get(parent);\n      }\n      if (path.size() > 1) {\n        for (SNode elem : path) {\n          substituteRepresentative(elem, current);\n        }\n      }\n    }\n    return getNameRepresentative(current);\n  }","id":26252,"modified_method":"public SNode getRepresentative(final SNode node) {\n    if (node == null || !TypesUtil.isVariable(node)) {\n      return node;\n    }\n    SNode nameRepresentative = getNameRepresentative(node);\n    SNode parent = myRepresentatives.get(nameRepresentative);\n    SNode current = nameRepresentative;\n    if (parent != null) {\n      List<SNode> path = new LinkedList<SNode>();\n      while (parent != null) {\n        if (current != nameRepresentative) {\n          path.add(current);\n        }\n        current = parent;\n        parent = myRepresentatives.get(parent);\n      }\n      if (path.size() > 1) {\n        for (SNode elem : path) {\n          substituteRepresentative(elem, current);\n        }\n      }\n    }\n    assert getNameRepresentative(current) == current;\n    return current;\n  }","commit_id":"54cfafaa0913b08de2303c082cd1c39bc4903ea7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Map<Set<SNode>, Set<InequalityBlock>> getInequalityGroups(Set<Block> inequalities) {\n    Map<SNode, Set<SNode>> components = new HashMap<SNode, Set<SNode>>();\n    Map<Set<SNode>, Set<InequalityBlock>> groupsToInequalities = new HashMap<Set<SNode>, Set<InequalityBlock>>();\n    for (Block block : inequalities) {\n      InequalityBlock inequality = (InequalityBlock) block;\n      inequality.expand(myState);\n      List<SNode> variables = TypesUtil.getVariables(inequality.getRightNode());\n      variables.addAll(TypesUtil.getVariables(inequality.getLeftNode()));\n      if (variables.size() == 0) {\n        continue;\n      }\n      Set<SNode> currentResult = new HashSet<SNode>(variables);\n\n      Set<InequalityBlock> currentInequalities = new HashSet<InequalityBlock>();\n      currentInequalities.add(inequality);\n      for (SNode var : variables) {\n        var = myState.getRepresentative(var);\n        Set<SNode> varGroup = components.get(var);\n        if (varGroup != null) {\n          currentResult.addAll(varGroup);\n        }\n        components.put(var, currentResult);\n        Set<InequalityBlock> remove = groupsToInequalities.remove(varGroup);\n        if (remove != null) {\n          currentInequalities.addAll(remove);\n        }\n      }\n      groupsToInequalities.put(currentResult, currentInequalities);\n    }\n    return groupsToInequalities;\n  }","id":26253,"modified_method":"public Map<Set<SNode>, Set<InequalityBlock>> getInequalityGroups(Set<Block> inequalities) {\n    Map<SNode, Set<SNode>> components = new HashMap<SNode, Set<SNode>>();\n    Map<Set<SNode>, Set<InequalityBlock>> groupsToInequalities = new HashMap<Set<SNode>, Set<InequalityBlock>>();\n    for (Block block : inequalities) {\n      InequalityBlock inequality = (InequalityBlock) block;\n\n      List<SNode> variables = TypesUtil.getVariables(myState.expand(inequality.getRightNode()));\n      variables.addAll(TypesUtil.getVariables(myState.expand(inequality.getLeftNode())));\n      if (variables.size() == 0) {\n        continue;\n      }\n      Set<SNode> currentResult = new HashSet<SNode>();\n\n      Set<InequalityBlock> currentInequalities = new HashSet<InequalityBlock>();\n      currentInequalities.add(inequality);\n      for (SNode var : variables) {\n        var = myState.getRepresentative(var);\n        currentResult.add(var);\n        Set<SNode> varGroup = components.remove(var);\n        if (varGroup != null) {\n          currentResult.addAll(varGroup);\n          for (SNode var2 : varGroup) {\n            if (!variables.contains(var2)) {\n              components.put(var2, currentResult);\n            }\n          }\n        }\n        components.put(var, currentResult);\n        Set<InequalityBlock> remove = groupsToInequalities.remove(varGroup);\n        if (remove != null) {\n          currentInequalities.addAll(remove);\n        }\n      }\n      groupsToInequalities.put(currentResult, currentInequalities);\n    }\n    return groupsToInequalities;\n  }","commit_id":"54cfafaa0913b08de2303c082cd1c39bc4903ea7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void iteration( List<InequalityBlock> inequalities) {\n     //todo switch input <--> output if input is deeply concrete?\n    solveOnlyConcrete = false;\n    Set<SNode> nodes = new LinkedHashSet<SNode>();\n    ManyToManyMap<SNode, SNode> inputsToOutputs = new ManyToManyMap<SNode, SNode>();\n    ManyToManyMap<SNode, InequalityBlock> nodesToBlocks = new ManyToManyMap<SNode, InequalityBlock>();\n    for (InequalityBlock inequality : inequalities) {\n      inequality.expand(myState);\n      SNode input = myState.getRepresentative(inequality.getInput());\n      SNode output = myState.getRepresentative(inequality.getOutput());\n      if (input != null) {\n        if (input != output) {\n          inputsToOutputs.addLink(input, output);\n          nodesToBlocks.addLink(input, inequality);\n          nodes.add(input);\n          if (!TypesUtil.isVariable(input) && !TypesUtil.isVariable(output)) {\n            for (SNode inputVar : TypesUtil.getVariables(input)) {\n              for (SNode outputVar : TypesUtil.getVariables(output)) {\n                inputsToOutputs.addLink(myState.getRepresentative(inputVar), myState.getRepresentative(outputVar));\n              }\n            }\n          }\n        }\n        nodesToBlocks.addLink(output, inequality);\n        nodes.add(output);\n      }\n\n    }\n    \n  //  System.out.println(nodes);\n    if (nodes.isEmpty()) {\n      return;\n    }\n    List<SNode> sortedNodes = sort(inputsToOutputs, nodes);\n\n    Map<SNode, InequalityBlock> typesToBlocks = new HashMap<SNode, InequalityBlock>();\n    //System.out.println(sortedNodes);\n\n    for (SNode node : sortedNodes) {\n      //todo shallow concrete\n      if (!TypesUtil.isVariable(node)) {\n        continue;\n      }\n      Set<InequalityBlock> blocks = nodesToBlocks.getByFirst(node);\n      Set<SNode> superTypes = new LinkedHashSet<SNode>();\n      Set<SNode> subTypes = new LinkedHashSet<SNode>();\n      for (InequalityBlock block : blocks) {\n        if (block.getRelationKind().isCheckOnly()) {\n          continue;\n        }\n        SNode left = myState.getRepresentative(block.getLeftNode());\n        SNode right = myState.getRepresentative(block.getRightNode());\n        if (right == left) {\n          continue;\n        }\n        if (left == node && !TypesUtil.isVariable(right)) {\n          superTypes.add(right);\n          typesToBlocks.put(right, block);\n        }\n        if (right == node && !TypesUtil.isVariable(left)) {\n          subTypes.add(left);\n          typesToBlocks.put(left, block);\n        } \n      }\n      SubTyping subTyping = new SubTyping(myState);\n      if (TypesUtil.isVariable(node)) {\n        SNode result = null;\n        EquationInfo info = null;\n        if (!subTypes.isEmpty()) {\n          result = subTyping.createLCS(subTypes);\n          InequalityBlock block = typesToBlocks.get(result);\n          info = (block != null) ? block.getEquationInfo() : typesToBlocks.get(subTypes.iterator().next()).getEquationInfo();\n        } else if (!superTypes.isEmpty()) {\n          result = subTyping.createMeet(superTypes);\n          InequalityBlock block = typesToBlocks.get(result);\n          info = (block != null) ? block.getEquationInfo() : typesToBlocks.get(superTypes.iterator().next()).getEquationInfo();\n        }\n        if (result != null) {\n          myState.addEquation(node, result, info);\n        }\n      } else {\n      }\n    }\n  }","id":26254,"modified_method":"private void iteration( List<InequalityBlock> inequalities) {\n    solveOnlyConcrete = false;\n    Set<SNode> nodes = new LinkedHashSet<SNode>();\n    ManyToManyMap<SNode, SNode> inputsToOutputs = new ManyToManyMap<SNode, SNode>();\n    ManyToManyMap<SNode, InequalityBlock> nodesToBlocks = new ManyToManyMap<SNode, InequalityBlock>();\n    for (InequalityBlock inequality : inequalities) {\n\n      SNode input = myState.getRepresentative(inequality.getInput());\n      SNode output = myState.getRepresentative(inequality.getOutput());\n      if (input != null) {\n        if (input != output) {\n          inputsToOutputs.addLink(input, output);\n          nodesToBlocks.addLink(input, inequality);\n          nodes.add(input);\n          if (!TypesUtil.isVariable(input) && !TypesUtil.isVariable(output)) {\n            for (SNode inputVar : TypesUtil.getVariables(input)) {\n              for (SNode outputVar : TypesUtil.getVariables(output)) {\n                inputsToOutputs.addLink(myState.getRepresentative(inputVar), myState.getRepresentative(outputVar));\n              }\n            }\n          }\n        }\n        nodesToBlocks.addLink(output, inequality);\n        nodes.add(output);\n      }\n\n    }\n    \n  //  System.out.println(nodes);\n    if (nodes.isEmpty()) {\n      return;\n    }\n    List<SNode> sortedNodes = sort(inputsToOutputs, nodes);\n\n    Map<SNode, InequalityBlock> typesToBlocks = new HashMap<SNode, InequalityBlock>();\n    //System.out.println(sortedNodes);\n\n    for (SNode node : sortedNodes) {\n      //todo shallow concrete\n      if (!TypesUtil.isVariable(node)) {\n        continue;\n      }\n      Set<InequalityBlock> blocks = nodesToBlocks.getByFirst(node);\n      Set<SNode> superTypes = new LinkedHashSet<SNode>();\n      Set<SNode> subTypes = new LinkedHashSet<SNode>();\n      for (InequalityBlock block : blocks) {\n        if (block.getRelationKind().isCheckOnly()) {\n          continue;\n        }\n        SNode left = myState.getRepresentative(block.getLeftNode());\n        SNode right = myState.getRepresentative(block.getRightNode());\n        if (right == left) {\n          continue;\n        }\n        if (left == node && !TypesUtil.isVariable(right)) {\n          superTypes.add(right);\n          typesToBlocks.put(right, block);\n        }\n        if (right == node && !TypesUtil.isVariable(left)) {\n          subTypes.add(left);\n          typesToBlocks.put(left, block);\n        } \n      }\n      SubTyping subTyping = new SubTyping(myState);\n      if (TypesUtil.isVariable(node)) {\n        SNode result = null;\n        EquationInfo info = null;\n        if (!subTypes.isEmpty()) {\n          result = subTyping.createLCS(subTypes);\n          InequalityBlock block = typesToBlocks.get(result);\n          info = (block != null) ? block.getEquationInfo() : typesToBlocks.get(subTypes.iterator().next()).getEquationInfo();\n        } else if (!superTypes.isEmpty()) {\n          result = subTyping.createMeet(superTypes);\n          InequalityBlock block = typesToBlocks.get(result);\n          info = (block != null) ? block.getEquationInfo() : typesToBlocks.get(superTypes.iterator().next()).getEquationInfo();\n        }\n        if (result != null) {\n          myState.addEquation(node, result, info);\n        }\n      } else {\n      }\n    }\n  }","commit_id":"54cfafaa0913b08de2303c082cd1c39bc4903ea7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private List<InequalityBlock> getInequalitiesToSolve() {\n    List<InequalityBlock> result = new LinkedList<InequalityBlock>();\n    Set<Block> set = myState.getBlocks(BlockKind.INEQUALITY);\n    for (Block block : set) {\n      InequalityBlock inequality = (InequalityBlock) block;\n      if (!inequality.getRelationKind().isCheckOnly()) {\n        inequality.expand(myState);\n        result.add(inequality);\n      }\n    }\n    return result;\n  }","id":26255,"modified_method":"private List<InequalityBlock> getInequalitiesToSolve() {\n    List<InequalityBlock> result = new LinkedList<InequalityBlock>();\n    Set<Block> set = myState.getBlocks(BlockKind.INEQUALITY);\n    for (Block block : set) {\n      InequalityBlock inequality = (InequalityBlock) block;\n      if (!inequality.getRelationKind().isCheckOnly()) {\n        result.add(inequality);\n      }\n    }\n    return result;\n  }","commit_id":"54cfafaa0913b08de2303c082cd1c39bc4903ea7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected MPSTreeNode rebuild() {\n    setRootVisible(false);\n    return createNode(myState);\n  }","id":26256,"modified_method":"@Override\n  protected MPSTreeNode rebuild() {\n    setRootVisible(false);\n    return createNode();\n  }","commit_id":"54cfafaa0913b08de2303c082cd1c39bc4903ea7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode getRepresentative(final SNode node) {\n    if (node == null || !TypesUtil.isVariable(node)) {\n      return node;\n    }\n    SNode nameRepresentative = getNameRepresentative(node);\n    SNode parent = myRepresentatives.get(nameRepresentative);\n    SNode current = nameRepresentative;\n    if (parent != null) {\n      List<SNode> path = new LinkedList<SNode>();\n      while (parent != null) {\n        if (current != nameRepresentative) {\n          path.add(current);\n        }\n        current = parent;\n        parent = myRepresentatives.get(parent);\n      }\n      if (path.size() > 1) {\n        for (SNode elem : path) {\n          substituteRepresentative(elem, current);\n        }\n      }\n    }\n    return getNameRepresentative(current);\n  }","id":26257,"modified_method":"public SNode getRepresentative(final SNode node) {\n    if (node == null || !TypesUtil.isVariable(node)) {\n      return node;\n    }\n    SNode nameRepresentative = getNameRepresentative(node);\n    SNode parent = myRepresentatives.get(nameRepresentative);\n    SNode current = nameRepresentative;\n    if (parent != null) {\n      List<SNode> path = new LinkedList<SNode>();\n      while (parent != null) {\n        if (current != nameRepresentative) {\n          path.add(current);\n        }\n        current = parent;\n        parent = myRepresentatives.get(parent);\n      }\n      if (path.size() > 1) {\n        for (SNode elem : path) {\n          substituteRepresentative(elem, current);\n        }\n      }\n    }\n    assert getNameRepresentative(current) == current;\n    return current;\n  }","commit_id":"931cc647f911b99c47baf0e94b441c183f47e38b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private List<InequalityBlock> getInequalitiesToSolve() {\n    List<InequalityBlock> result = new LinkedList<InequalityBlock>();\n    Set<Block> set = myState.getBlocks(BlockKind.INEQUALITY);\n    for (Block block : set) {\n      InequalityBlock inequality = (InequalityBlock) block;\n      if (!inequality.getRelationKind().isCheckOnly()) {\n        inequality.expand(myState);\n        result.add(inequality);\n      }\n    }\n    return result;\n  }","id":26258,"modified_method":"private List<InequalityBlock> getInequalitiesToSolve() {\n    List<InequalityBlock> result = new LinkedList<InequalityBlock>();\n    Set<Block> set = myState.getBlocks(BlockKind.INEQUALITY);\n    for (Block block : set) {\n      InequalityBlock inequality = (InequalityBlock) block;\n      if (!inequality.getRelationKind().isCheckOnly()) {\n        result.add(inequality);\n      }\n    }\n    return result;\n  }","commit_id":"931cc647f911b99c47baf0e94b441c183f47e38b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void iteration( List<InequalityBlock> inequalities) {\n     //todo switch input <--> output if input is deeply concrete?\n    solveOnlyConcrete = false;\n    Set<SNode> nodes = new LinkedHashSet<SNode>();\n    ManyToManyMap<SNode, SNode> inputsToOutputs = new ManyToManyMap<SNode, SNode>();\n    ManyToManyMap<SNode, InequalityBlock> nodesToBlocks = new ManyToManyMap<SNode, InequalityBlock>();\n    for (InequalityBlock inequality : inequalities) {\n      inequality.expand(myState);\n      SNode input = myState.getRepresentative(inequality.getInput());\n      SNode output = myState.getRepresentative(inequality.getOutput());\n      if (input != null) {\n        if (input != output) {\n          inputsToOutputs.addLink(input, output);\n          nodesToBlocks.addLink(input, inequality);\n          nodes.add(input);\n          if (!TypesUtil.isVariable(input) && !TypesUtil.isVariable(output)) {\n            for (SNode inputVar : TypesUtil.getVariables(input)) {\n              for (SNode outputVar : TypesUtil.getVariables(output)) {\n                inputsToOutputs.addLink(myState.getRepresentative(inputVar), myState.getRepresentative(outputVar));\n              }\n            }\n          }\n        }\n        nodesToBlocks.addLink(output, inequality);\n        nodes.add(output);\n      }\n\n    }\n    \n  //  System.out.println(nodes);\n    if (nodes.isEmpty()) {\n      return;\n    }\n    List<SNode> sortedNodes = sort(inputsToOutputs, nodes);\n\n    Map<SNode, InequalityBlock> typesToBlocks = new HashMap<SNode, InequalityBlock>();\n    //System.out.println(sortedNodes);\n\n    for (SNode node : sortedNodes) {\n      //todo shallow concrete\n      if (!TypesUtil.isVariable(node)) {\n        continue;\n      }\n      Set<InequalityBlock> blocks = nodesToBlocks.getByFirst(node);\n      Set<SNode> superTypes = new LinkedHashSet<SNode>();\n      Set<SNode> subTypes = new LinkedHashSet<SNode>();\n      for (InequalityBlock block : blocks) {\n        if (block.getRelationKind().isCheckOnly()) {\n          continue;\n        }\n        SNode left = myState.getRepresentative(block.getLeftNode());\n        SNode right = myState.getRepresentative(block.getRightNode());\n        if (right == left) {\n          continue;\n        }\n        if (left == node && !TypesUtil.isVariable(right)) {\n          superTypes.add(right);\n          typesToBlocks.put(right, block);\n        }\n        if (right == node && !TypesUtil.isVariable(left)) {\n          subTypes.add(left);\n          typesToBlocks.put(left, block);\n        } \n      }\n      SubTyping subTyping = new SubTyping(myState);\n      if (TypesUtil.isVariable(node)) {\n        SNode result = null;\n        EquationInfo info = null;\n        if (!subTypes.isEmpty()) {\n          result = subTyping.createLCS(subTypes);\n          InequalityBlock block = typesToBlocks.get(result);\n          info = (block != null) ? block.getEquationInfo() : typesToBlocks.get(subTypes.iterator().next()).getEquationInfo();\n        } else if (!superTypes.isEmpty()) {\n          result = subTyping.createMeet(superTypes);\n          InequalityBlock block = typesToBlocks.get(result);\n          info = (block != null) ? block.getEquationInfo() : typesToBlocks.get(superTypes.iterator().next()).getEquationInfo();\n        }\n        if (result != null) {\n          myState.addEquation(node, result, info);\n        }\n      } else {\n      }\n    }\n  }","id":26259,"modified_method":"private void iteration( List<InequalityBlock> inequalities) {\n    solveOnlyConcrete = false;\n    Set<SNode> nodes = new LinkedHashSet<SNode>();\n    ManyToManyMap<SNode, SNode> inputsToOutputs = new ManyToManyMap<SNode, SNode>();\n    ManyToManyMap<SNode, InequalityBlock> nodesToBlocks = new ManyToManyMap<SNode, InequalityBlock>();\n    for (InequalityBlock inequality : inequalities) {\n\n      SNode input = myState.getRepresentative(inequality.getInput());\n      SNode output = myState.getRepresentative(inequality.getOutput());\n      if (input != null) {\n        if (input != output) {\n          inputsToOutputs.addLink(input, output);\n          nodesToBlocks.addLink(input, inequality);\n          nodes.add(input);\n          if (!TypesUtil.isVariable(input) && !TypesUtil.isVariable(output)) {\n            for (SNode inputVar : TypesUtil.getVariables(input)) {\n              for (SNode outputVar : TypesUtil.getVariables(output)) {\n                inputsToOutputs.addLink(myState.getRepresentative(inputVar), myState.getRepresentative(outputVar));\n              }\n            }\n          }\n        }\n        nodesToBlocks.addLink(output, inequality);\n        nodes.add(output);\n      }\n\n    }\n    \n  //  System.out.println(nodes);\n    if (nodes.isEmpty()) {\n      return;\n    }\n    List<SNode> sortedNodes = sort(inputsToOutputs, nodes);\n\n    Map<SNode, InequalityBlock> typesToBlocks = new HashMap<SNode, InequalityBlock>();\n    //System.out.println(sortedNodes);\n\n    for (SNode node : sortedNodes) {\n      //todo shallow concrete\n      if (!TypesUtil.isVariable(node)) {\n        continue;\n      }\n      Set<InequalityBlock> blocks = nodesToBlocks.getByFirst(node);\n      Set<SNode> superTypes = new LinkedHashSet<SNode>();\n      Set<SNode> subTypes = new LinkedHashSet<SNode>();\n      for (InequalityBlock block : blocks) {\n        if (block.getRelationKind().isCheckOnly()) {\n          continue;\n        }\n        SNode left = myState.getRepresentative(block.getLeftNode());\n        SNode right = myState.getRepresentative(block.getRightNode());\n        if (right == left) {\n          continue;\n        }\n        if (left == node && !TypesUtil.isVariable(right)) {\n          superTypes.add(right);\n          typesToBlocks.put(right, block);\n        }\n        if (right == node && !TypesUtil.isVariable(left)) {\n          subTypes.add(left);\n          typesToBlocks.put(left, block);\n        } \n      }\n      SubTyping subTyping = new SubTyping(myState);\n      if (TypesUtil.isVariable(node)) {\n        SNode result = null;\n        EquationInfo info = null;\n        if (!subTypes.isEmpty()) {\n          result = subTyping.createLCS(subTypes);\n          InequalityBlock block = typesToBlocks.get(result);\n          info = (block != null) ? block.getEquationInfo() : typesToBlocks.get(subTypes.iterator().next()).getEquationInfo();\n        } else if (!superTypes.isEmpty()) {\n          result = subTyping.createMeet(superTypes);\n          InequalityBlock block = typesToBlocks.get(result);\n          info = (block != null) ? block.getEquationInfo() : typesToBlocks.get(superTypes.iterator().next()).getEquationInfo();\n        }\n        if (result != null) {\n          myState.addEquation(node, result, info);\n        }\n      } else {\n      }\n    }\n  }","commit_id":"931cc647f911b99c47baf0e94b441c183f47e38b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Map<Set<SNode>, Set<InequalityBlock>> getInequalityGroups(Set<Block> inequalities) {\n    Map<SNode, Set<SNode>> components = new HashMap<SNode, Set<SNode>>();\n    Map<Set<SNode>, Set<InequalityBlock>> groupsToInequalities = new HashMap<Set<SNode>, Set<InequalityBlock>>();\n    for (Block block : inequalities) {\n      InequalityBlock inequality = (InequalityBlock) block;\n      inequality.expand(myState);\n      List<SNode> variables = TypesUtil.getVariables(inequality.getRightNode());\n      variables.addAll(TypesUtil.getVariables(inequality.getLeftNode()));\n      if (variables.size() == 0) {\n        continue;\n      }\n      Set<SNode> currentResult = new HashSet<SNode>(variables);\n\n      Set<InequalityBlock> currentInequalities = new HashSet<InequalityBlock>();\n      currentInequalities.add(inequality);\n      for (SNode var : variables) {\n        var = myState.getRepresentative(var);\n        Set<SNode> varGroup = components.get(var);\n        if (varGroup != null) {\n          currentResult.addAll(varGroup);\n        }\n        components.put(var, currentResult);\n        Set<InequalityBlock> remove = groupsToInequalities.remove(varGroup);\n        if (remove != null) {\n          currentInequalities.addAll(remove);\n        }\n      }\n      groupsToInequalities.put(currentResult, currentInequalities);\n    }\n    return groupsToInequalities;\n  }","id":26260,"modified_method":"public Map<Set<SNode>, Set<InequalityBlock>> getInequalityGroups(Set<Block> inequalities) {\n    Map<SNode, Set<SNode>> components = new HashMap<SNode, Set<SNode>>();\n    Map<Set<SNode>, Set<InequalityBlock>> groupsToInequalities = new HashMap<Set<SNode>, Set<InequalityBlock>>();\n    for (Block block : inequalities) {\n      InequalityBlock inequality = (InequalityBlock) block;\n\n      List<SNode> variables = TypesUtil.getVariables(myState.expand(inequality.getRightNode()));\n      variables.addAll(TypesUtil.getVariables(myState.expand(inequality.getLeftNode())));\n      if (variables.size() == 0) {\n        continue;\n      }\n      Set<SNode> currentResult = new HashSet<SNode>();\n\n      Set<InequalityBlock> currentInequalities = new HashSet<InequalityBlock>();\n      currentInequalities.add(inequality);\n      for (SNode var : variables) {\n        var = myState.getRepresentative(var);\n        currentResult.add(var);\n        Set<SNode> varGroup = components.remove(var);\n        if (varGroup != null) {\n          currentResult.addAll(varGroup);\n          for (SNode var2 : varGroup) {\n            if (!variables.contains(var2)) {\n              components.put(var2, currentResult);\n            }\n          }\n        }\n        components.put(var, currentResult);\n        Set<InequalityBlock> remove = groupsToInequalities.remove(varGroup);\n        if (remove != null) {\n          currentInequalities.addAll(remove);\n        }\n      }\n      groupsToInequalities.put(currentResult, currentInequalities);\n    }\n    return groupsToInequalities;\n  }","commit_id":"931cc647f911b99c47baf0e94b441c183f47e38b","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected MPSTreeNode rebuild() {\n    setRootVisible(false);\n    return createNode(myState);\n  }","id":26261,"modified_method":"@Override\n  protected MPSTreeNode rebuild() {\n    setRootVisible(false);\n    return createNode();\n  }","commit_id":"931cc647f911b99c47baf0e94b441c183f47e38b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean processEquation(SNode var, SNode type, EquationInfo info) {\n    SNode source = myState.getNodeMaps().getNode(var);\n    for (SNode innerVar : TypesUtil.getVariables(type, myState)) {\n      if (getRepresentative(innerVar, false).equals(var)){\n        reportRecursiveType(source, info);\n        return false;\n      }\n    }\n    myState.executeOperation(new AddEquationOperation(var, type, source, info));\n    return true;\n  }","id":26262,"modified_method":"private boolean processEquation(SNode var, SNode type, EquationInfo info) {\n    SNode source = myState.getNodeMaps().getNode(var);\n    for (SNode innerVar : TypesUtil.getVariables(expandNode(type, false))) {\n      if (getRepresentative(innerVar, false).equals(var)){\n        reportRecursiveType(source, info);\n        return false;\n      }\n    }\n    myState.executeOperation(new AddEquationOperation(var, type, source, info));\n    return true;\n  }","commit_id":"532ef2ed647c279b8c8756bec4425f5805deedc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Map<Set<SNode>, Set<InequalityBlock>> getInequalityGroups(Set<Block> inequalities) {\n    Map<SNode, Set<SNode>> components = new HashMap<SNode, Set<SNode>>(1);\n    Map<Set<SNode>, Set<InequalityBlock>> groupsToInequalities = new HashMap<Set<SNode>, Set<InequalityBlock>>();\n    Set<SNode> emptySet = new HashSet<SNode>(1);\n    for (Block block : inequalities) {\n      InequalityBlock inequality = (InequalityBlock) block;\n\n      Collection<SNode> variables = TypesUtil.getVariables(inequality.getRightNode(),myState);\n      variables.addAll(TypesUtil.getVariables(inequality.getLeftNode(), myState));\n      if (variables.size() == 0) {\n        Set<InequalityBlock> emptyBlocks = groupsToInequalities.get(emptySet);\n        if (emptyBlocks == null) {\n          emptyBlocks = new HashSet<InequalityBlock>(1);\n          groupsToInequalities.put(emptySet, emptyBlocks);\n        }\n        emptyBlocks.add(inequality);\n        continue;\n      }\n      Set<SNode> currentResult = new HashSet<SNode>();\n\n      Set<InequalityBlock> currentInequalities = new HashSet<InequalityBlock>();\n      currentInequalities.add(inequality);\n      for (SNode var : variables) {\n        var = myState.getRepresentative(var);\n        currentResult.add(var);\n        Set<SNode> varGroup = components.remove(var);\n        if (varGroup != null) {\n          currentResult.addAll(varGroup);\n          for (SNode var2 : varGroup) {\n            if (!variables.contains(var2)) {\n              components.put(var2, currentResult);\n            }\n          }\n        }\n        components.put(var, currentResult);\n        Set<InequalityBlock> remove = groupsToInequalities.remove(varGroup);\n        if (remove != null) {\n          currentInequalities.addAll(remove);\n        }\n      }\n      groupsToInequalities.put(currentResult, currentInequalities);\n    }\n    return groupsToInequalities;\n  }","id":26263,"modified_method":"public Map<Set<SNode>, Set<InequalityBlock>> getInequalityGroups(Set<Block> inequalities) {\n    Map<SNode, Set<SNode>> components = new HashMap<SNode, Set<SNode>>(1);\n    Map<Set<SNode>, Set<InequalityBlock>> groupsToInequalities = new HashMap<Set<SNode>, Set<InequalityBlock>>();\n    Set<SNode> emptySet = new HashSet<SNode>(1);\n    for (Block block : inequalities) {\n      InequalityBlock inequality = (InequalityBlock) block;\n\n      Collection<SNode> variables = TypesUtil.getVariables(myState.expand(inequality.getRightNode()));\n      variables.addAll(TypesUtil.getVariables(myState.expand(inequality.getLeftNode())));\n      if (variables.size() == 0) {\n        Set<InequalityBlock> emptyBlocks = groupsToInequalities.get(emptySet);\n        if (emptyBlocks == null) {\n          emptyBlocks = new HashSet<InequalityBlock>(1);\n          groupsToInequalities.put(emptySet, emptyBlocks);\n        }\n        emptyBlocks.add(inequality);\n        continue;\n      }\n      Set<SNode> currentResult = new HashSet<SNode>();\n\n      Set<InequalityBlock> currentInequalities = new HashSet<InequalityBlock>();\n      currentInequalities.add(inequality);\n      for (SNode var : variables) {\n        var = myState.getRepresentative(var);\n        currentResult.add(var);\n        Set<SNode> varGroup = components.remove(var);\n        if (varGroup != null) {\n          currentResult.addAll(varGroup);\n          for (SNode var2 : varGroup) {\n            if (!variables.contains(var2)) {\n              components.put(var2, currentResult);\n            }\n          }\n        }\n        components.put(var, currentResult);\n        Set<InequalityBlock> remove = groupsToInequalities.remove(varGroup);\n        if (remove != null) {\n          currentInequalities.addAll(remove);\n        }\n      }\n      groupsToInequalities.put(currentResult, currentInequalities);\n    }\n    return groupsToInequalities;\n  }","commit_id":"532ef2ed647c279b8c8756bec4425f5805deedc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean solveRelationForNode(SNode node, AbstractRelation relation) {\n    Map<SNode, RelationBlock> typesToBlocks = new THashMap<SNode, RelationBlock>();\n    assert TypesUtil.isVariable(node);\n    Set<RelationBlock> blocks = myNodesToBlocks.getByFirst(node);\n    blocks = getRelationBlocks(blocks, relation);\n    Set<SNode> rightTypes = new LinkedHashSet<SNode>();\n    Set<SNode> leftTypes = new LinkedHashSet<SNode>();\n    collectTransitive(node, rightTypes, true, blocks,typesToBlocks);\n    collectTransitive(node, leftTypes, false, blocks, typesToBlocks);\n    return relation.solve(node, leftTypes, rightTypes, myState, typesToBlocks);\n  }","id":26264,"modified_method":"private boolean solveRelationForNode(SNode node, AbstractRelation relation) {\n    Map<SNode, RelationBlock> typesToBlocks = new THashMap<SNode, RelationBlock>();\n    assert TypesUtil.isVariable(node);\n    Set<RelationBlock> blocks = myNodesToBlocks.getByFirst(node);\n    blocks = getRelationBlocks(blocks, relation);\n    Set<SNode> rightTypes = new LinkedHashSet<SNode>();\n    Set<SNode> leftTypes = new LinkedHashSet<SNode>();\n\n    collectNodesInRelation(node, leftTypes, rightTypes, blocks, typesToBlocks);\n    return relation.solve(node, leftTypes, rightTypes, myState, typesToBlocks);\n  }","commit_id":"532ef2ed647c279b8c8756bec4425f5805deedc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initializeMaps(List<RelationBlock> inequalities) {\n    myInputsToOutputs.clear();\n    myNodesToBlocks.clear();\n    myNodes.clear();\n    for (RelationBlock inequality : inequalities) {\n      if (inequality.isCheckOnly()) {\n        continue;\n      }\n      for (Pair<SNode, SNode> pair : inequality.getInputsAndOutputs()) {\n        SNode input = myState.getRepresentative(pair.first);\n        SNode output = myState.getRepresentative(pair.second);\n        Collection<SNode> inputVariables = myState.getRepresentatives(TypesUtil.getVariables(input, myState));\n        Collection<SNode> outputVariables = myState.getRepresentatives(TypesUtil.getVariables(output, myState));\n        myNodes.addAll(inputVariables);\n        myNodes.addAll(outputVariables);\n        for (SNode inputVar : inputVariables) {\n          for (SNode outputVar : outputVariables) {\n            addVariablesLink(inputVar, outputVar);\n          }\n          assert inputVar == myState.getRepresentative(inputVar);\n        }\n        if (input!=null) {\n          myNodesToBlocks.addLink(input, inequality);\n        }\n        if (output != null) {\n          myNodesToBlocks.addLink(output, inequality);\n        }\n      }\n    }\n  }","id":26265,"modified_method":"private void initializeMaps(List<RelationBlock> inequalities) {\n    myInputsToOutputs.clear();\n    myNodesToBlocks.clear();\n    myNodes.clear();\n    for (RelationBlock inequality : inequalities) {\n      if (inequality.isCheckOnly()) {\n        continue;\n      }\n      for (Pair<SNode, SNode> pair : inequality.getInputsAndOutputs()) {\n        SNode input = myState.getRepresentative(pair.first);\n        SNode output = myState.getRepresentative(pair.second);\n        Collection<SNode> inputVariables = myState.getRepresentatives(TypesUtil.getVariables(myState.expand(input)));\n        Collection<SNode> outputVariables = myState.getRepresentatives(TypesUtil.getVariables(myState.expand(output)));\n        myNodes.addAll(inputVariables);\n        myNodes.addAll(outputVariables);\n        for (SNode inputVar : inputVariables) {\n          for (SNode outputVar : outputVariables) {\n            addVariablesLink(inputVar, outputVar);\n          }\n          assert inputVar == myState.getRepresentative(inputVar);\n        }\n        if (input!=null) {\n          myNodesToBlocks.addLink(input, inequality);\n        }\n        if (output != null) {\n          myNodesToBlocks.addLink(output, inequality);\n        }\n      }\n    }\n  }","commit_id":"532ef2ed647c279b8c8756bec4425f5805deedc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public List<SNode> getVariables(State state) {\n    List<SNode> variables;\n    variables = TypesUtil.getVariables(myLeftNode, state);\n    variables.addAll(TypesUtil.getVariables(myRightNode,state ));\n    return variables;\n  }","id":26266,"modified_method":"@Override\n  public List<SNode> getVariables(State state) {\n    List<SNode> variables;\n    if (state == null) {\n      variables = TypesUtil.getVariables(myLeftNode);\n      variables.addAll(TypesUtil.getVariables(myRightNode));\n    } else {\n      variables = TypesUtil.getVariables(state.expand(myLeftNode));\n      variables.addAll(TypesUtil.getVariables(state.expand(myRightNode)));\n    }\n    return variables;\n  }","commit_id":"532ef2ed647c279b8c8756bec4425f5805deedc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void getVariablesInside(SNode node, List<SNode> result, State state) {\n    if (node == null) {\n      return;\n    }\n    if (state != null) {\n      node = state.getRepresentative(node);\n    }\n    if (isVariable(node)) {\n      result.add(node);\n      return;\n    }\n    for (SNode child : node.getChildren()) {\n      getVariablesInside(child, result, state);\n    }\n    for (SNode referent : node.getReferents()) {\n      if (state!= null) {\n        referent = state.getRepresentative(referent);\n      }\n      if (referent != null && isVariable(referent)) {\n        result.add(referent);\n      }\n    }\n  }","id":26267,"modified_method":"private static void getVariablesInside(SNode node, List<SNode> result) {\n    if (node == null) {\n      return;\n    }\n    if (isVariable(node)) {\n      result.add(node);\n      return;\n    }\n    for (SNode child : node.getChildren()) {\n      getVariablesInside(child, result);\n    }\n    for (SNode referent : node.getReferents()) {\n      if (referent != null && isVariable(referent)) {\n        result.add(referent);\n      }\n    }\n  }","commit_id":"532ef2ed647c279b8c8756bec4425f5805deedc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> getVariables(SNode node, State state) {\n    List<SNode> result = new LinkedList<SNode>();\n    getVariablesInside(node, result, state);\n    return result;\n  }","id":26268,"modified_method":"public static List<SNode> getVariables(SNode node) {\n    List<SNode> result = new LinkedList<SNode>();\n    getVariablesInside(node, result);\n    return result;\n  }","commit_id":"532ef2ed647c279b8c8756bec4425f5805deedc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public List<SNode> getVariables(State state) {\n    return TypesUtil.getVariables(myArgument,state);\n  }","id":26269,"modified_method":"@Override\n  public List<SNode> getVariables(State state) {\n    return TypesUtil.getVariables(myArgument);\n  }","commit_id":"532ef2ed647c279b8c8756bec4425f5805deedc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void visitParameter(@NotNull PsiParameter variable) {\n      super.visitParameter(variable);\n      final PsiElement declarationScope = variable.getDeclarationScope();\n      if (!(declarationScope instanceof PsiMethod)) {\n        return;\n      }\n      final PsiMethod method = (PsiMethod)declarationScope;\n      if (m_ignoreForConstructors && method.isConstructor()) {\n        return;\n      }\n      if (m_ignoreForAbstractMethods) {\n        if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n          return;\n        }\n        final PsiClass containingClass = method.getContainingClass();\n        if (containingClass != null && containingClass.isInterface()) {\n          return;\n        }\n      }\n      if (m_ignoreForPropertySetters && PropertyUtil.isSimplePropertySetter(method)) {\n        return;\n      }\n      final PsiClass aClass = checkFieldName(variable, method);\n      if (aClass ==  null) {\n        return;\n      }\n      registerVariableError(variable, aClass);\n    }","id":26270,"modified_method":"@Override\n    public void visitParameter(@NotNull PsiParameter variable) {\n      super.visitParameter(variable);\n      final PsiElement declarationScope = variable.getDeclarationScope();\n      if (!(declarationScope instanceof PsiMethod)) {\n        return;\n      }\n      final PsiMethod method = (PsiMethod)declarationScope;\n      if (m_ignoreForConstructors && method.isConstructor()) {\n        return;\n      }\n      if (m_ignoreForAbstractMethods) {\n        if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n          return;\n        }\n        final PsiClass containingClass = method.getContainingClass();\n        if (containingClass != null && containingClass.isInterface()) {\n          return;\n        }\n      }\n      if (m_ignoreForPropertySetters) {\n        final String methodName = method.getName();\n        if (methodName.startsWith(HardcodedMethodConstants.SET) && PsiType.VOID.equals(method.getReturnType())) {\n          return;\n        }\n\n        if (PropertyUtil.isSimplePropertySetter(method)) {\n          return;\n        }\n      }\n      final PsiClass aClass = checkFieldName(variable, method);\n      if (aClass ==  null) {\n        return;\n      }\n      registerVariableError(variable, aClass);\n    }","commit_id":"e2675a988a841e689307d069cb09e40fbe1d4712","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * priority: inside class C: local variable, c.method, c.property, c.getter\n   * in other places: local variable, c.method, c.getter, c.property\n   */\n  @NotNull\n  private GroovyResolveResult[] resolveMethodOrProperty(boolean allVariants, @Nullable GrExpression upToArgument) {\n    final String name = getReferenceName();\n    if (name == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    GrReferenceResolveRunner resolveRunner = new GrReferenceResolveRunner(this);\n\n    PropertyResolverProcessor propertyResolver = new PropertyResolverProcessor(name, this);\n    resolveRunner.resolveImpl(propertyResolver);\n    final GroovyResolveResult[] propertyCandidates = propertyResolver.getCandidates();\n\n    if (!allVariants) { //search for local variables\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        final PsiElement element = candidate.getElement();\n        if (element instanceof GrVariable && !(element instanceof GrField || element instanceof GrBindingVariable)) {\n          return propertyCandidates;\n        }\n      }\n    }\n\n    final MethodResolverProcessor methodProcessor = new MethodResolverProcessor(\n      name, this, false,\n      PsiImplUtil.getQualifierType(this),\n      PsiUtil.getArgumentTypes(this, false, upToArgument, false),\n      getTypeArguments(),\n      allVariants\n    );\n    processMethods(resolveRunner, methodProcessor);\n    final GroovyResolveResult[] methodCandidates = hasMemberPointer() ? collapseReflectedMethods(methodProcessor.getCandidates())\n                                                                      : methodProcessor.getCandidates();\n    assertAllAreValid(methodCandidates);\n\n    if (!allVariants && methodProcessor.hasApplicableCandidates()) {\n      return methodCandidates;\n    }\n\n    //search for fields inside its class\n    if (!allVariants) {\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        final PsiElement element = candidate.getElement();\n        if (element instanceof GrField) {\n          final PsiClass containingClass = ((PsiField)element).getContainingClass();\n          if (containingClass != null && PsiTreeUtil.isContextAncestor(containingClass, this, true)) return propertyCandidates;\n        }\n      }\n    }\n\n    List<GroovyResolveResult> allCandidates = new ArrayList<GroovyResolveResult>();\n    ContainerUtil.addAll(allCandidates, propertyCandidates);\n    ContainerUtil.addAll(allCandidates, methodCandidates);\n\n    filterOutBindings(allCandidates);\n\n    //search for getters\n    for (String getterName : GroovyPropertyUtils.suggestGettersName(name)) {\n      AccessorResolverProcessor getterResolver =\n        new AccessorResolverProcessor(getterName, name, this, true, PsiImplUtil.getQualifierType(this), getTypeArguments());\n      resolveRunner.resolveImpl(getterResolver);\n      final GroovyResolveResult[] candidates = getterResolver.getCandidates(); //can be only one candidate\n      if (!allVariants && candidates.length == 1) {\n        return candidates;\n      }\n      ContainerUtil.addAll(allCandidates, candidates);\n    }\n\n    if (!allCandidates.isEmpty()) {\n      return allCandidates.toArray(new GroovyResolveResult[allCandidates.size()]);\n    }\n    return GroovyResolveResult.EMPTY_ARRAY;\n  }","id":26271,"modified_method":"/**\n   * priority: inside class C: local variable, c.method, c.property, c.getter\n   * in other places: local variable, c.method, c.getter, c.property\n   */\n  @NotNull\n  private GroovyResolveResult[] resolveMethodOrProperty(boolean allVariants, @Nullable GrExpression upToArgument) {\n    if (true) {\n      final GroovyResolverProcessor processor = GroovyResolverProcessorBuilder.builder()\n        .setAllVariants(allVariants).setUpToArgument(upToArgument).build(this);\n      new GrReferenceResolveRunner(this).resolveImpl(processor);\n      return processor.getCandidatesArray();\n    }\n    final String name = getReferenceName();\n    if (name == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    GrReferenceResolveRunner resolveRunner = new GrReferenceResolveRunner(this);\n\n    PropertyResolverProcessor propertyResolver = new PropertyResolverProcessor(name, this);\n    resolveRunner.resolveImpl(propertyResolver);\n    final GroovyResolveResult[] propertyCandidates = propertyResolver.getCandidates();\n\n    if (!allVariants) { //search for local variables\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        final PsiElement element = candidate.getElement();\n        if (element instanceof GrVariable && !(element instanceof GrField || element instanceof GrBindingVariable)) {\n          return propertyCandidates;\n        }\n      }\n    }\n\n    final MethodResolverProcessor methodProcessor = new MethodResolverProcessor(\n      name, this, false,\n      PsiImplUtil.getQualifierType(this),\n      PsiUtil.getArgumentTypes(this, false, upToArgument, false),\n      getTypeArguments(),\n      allVariants\n    );\n    processMethods(resolveRunner, methodProcessor);\n    final GroovyResolveResult[] methodCandidates = hasMemberPointer() ? collapseReflectedMethods(methodProcessor.getCandidates())\n                                                                      : methodProcessor.getCandidates();\n    assertAllAreValid(methodCandidates);\n\n    if (!allVariants && methodProcessor.hasApplicableCandidates()) {\n      return methodCandidates;\n    }\n\n    //search for fields inside its class\n    if (!allVariants) {\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        final PsiElement element = candidate.getElement();\n        if (element instanceof GrField) {\n          final PsiClass containingClass = ((PsiField)element).getContainingClass();\n          if (containingClass != null && PsiTreeUtil.isContextAncestor(containingClass, this, true)) return propertyCandidates;\n        }\n      }\n    }\n\n    List<GroovyResolveResult> allCandidates = new ArrayList<GroovyResolveResult>();\n    ContainerUtil.addAll(allCandidates, propertyCandidates);\n    ContainerUtil.addAll(allCandidates, methodCandidates);\n\n    filterOutBindings(allCandidates);\n\n    //search for getters\n    for (String getterName : GroovyPropertyUtils.suggestGettersName(name)) {\n      AccessorResolverProcessor getterResolver =\n        new AccessorResolverProcessor(getterName, name, this, true, PsiImplUtil.getQualifierType(this), getTypeArguments());\n      resolveRunner.resolveImpl(getterResolver);\n      final GroovyResolveResult[] candidates = getterResolver.getCandidates(); //can be only one candidate\n      if (!allVariants && candidates.length == 1) {\n        return candidates;\n      }\n      ContainerUtil.addAll(allCandidates, candidates);\n    }\n\n    if (!allCandidates.isEmpty()) {\n      return allCandidates.toArray(new GroovyResolveResult[allCandidates.size()]);\n    }\n    return GroovyResolveResult.EMPTY_ARRAY;\n  }","commit_id":"6128b56d8c2ba81977383a260d0d61abdd05386d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private GroovyResolveResult[] resolveTypeOrPropertyInner() {\n    PsiElement nameElement = getReferenceNameElement();\n    String name = getReferenceName();\n\n    if (name == null || nameElement == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    IElementType nameType = nameElement.getNode().getElementType();\n    if (nameType == GroovyTokenTypes.kTHIS) {\n      GroovyResolveResult[] results = GrThisReferenceResolver.resolveThisExpression(this);\n      if (results != null) {\n        return results;\n      }\n    }\n    else if (nameType == GroovyTokenTypes.kSUPER) {\n      GroovyResolveResult[] results = GrSuperReferenceResolver.resolveSuperExpression(this);\n      if (results != null) {\n        return results;\n      }\n    }\n\n    if (true) {\n      GroovyResolverProcessor processor = new GroovyResolverProcessor(this, name, false);\n      new GrReferenceResolveRunner(this).resolveImpl(processor);\n      return processor.getCandidates();\n    }\n\n    EnumSet<ElementClassHint.DeclarationKind> kinds = getParent() instanceof GrReferenceExpression\n                                           ? ClassHint.RESOLVE_KINDS_CLASS_PACKAGE\n                                           : ClassHint.RESOLVE_KINDS_CLASS;\n\n    GroovyResolveResult[] classCandidates = null;\n\n    GrReferenceResolveRunner resolveRunner = new GrReferenceResolveRunner(this);\n\n    ResolverProcessor processor = new PropertyResolverProcessor(name, this);\n    resolveRunner.resolveImpl(processor);\n    final GroovyResolveResult[] fieldCandidates = processor.getCandidates();\n\n    if (hasAt()) {\n      return fieldCandidates;\n    }\n\n\n    boolean canBeClassOrPackage = ResolveUtil.canBeClassOrPackage(this);\n\n    if (canBeClassOrPackage && findClassOrPackageAtFirst()) {\n      ResolverProcessor classProcessor = new ClassResolverProcessor(name, this, kinds);\n      resolveRunner.resolveImpl(classProcessor);\n      classCandidates = classProcessor.getCandidates();\n      if (classCandidates.length > 0 && containsPackage(classCandidates)) {\n        final PsiElement firstNonReferenceExprParent = PsiTreeUtil.skipParentsOfType(this, GrReferenceExpressionImpl.class);\n        final GrReferenceExpressionImpl topRef = (GrReferenceExpressionImpl)PsiTreeUtil.findFirstParent(this, new Condition<PsiElement>() {\n          @Override\n          public boolean value(PsiElement parent) {\n            return parent.getParent() == firstNonReferenceExprParent && parent instanceof GrReferenceExpressionImpl;\n          }\n        });\n        if (topRef != null) {\n          final String fqn = topRef.getTextSkipWhiteSpaceAndComments();\n          if (JavaPsiFacade.getInstance(getProject()).findClass(fqn, getResolveScope()) != null) {\n            return classCandidates;\n          }\n        }\n      }\n    }\n\n    //if reference expression is in class we need to return field instead of accessor method\n    for (GroovyResolveResult candidate : fieldCandidates) {\n      final PsiElement element = candidate.getElement();\n      if (element instanceof PsiField) {\n        final PsiClass containingClass = ((PsiField)element).getContainingClass();\n        if (containingClass != null && PsiUtil.getContextClass(this) == containingClass) return fieldCandidates;\n      }\n      else if (!(element instanceof GrBindingVariable)) {\n        return fieldCandidates;\n      }\n    }\n\n    if (classCandidates != null && classCandidates.length > 0) return classCandidates;\n\n    final boolean isLValue = PsiUtil.isLValue(this);\n    String[] accessorNames = isLValue ? GroovyPropertyUtils.suggestSettersName(name) : GroovyPropertyUtils.suggestGettersName(name);\n    List<GroovyResolveResult> accessorResults = new ArrayList<GroovyResolveResult>();\n    for (String accessorName : accessorNames) {\n      AccessorResolverProcessor accessorResolver =\n        new AccessorResolverProcessor(accessorName, name, this, !isLValue, PsiImplUtil.getQualifierType(this), getTypeArguments());\n      resolveRunner.resolveImpl(accessorResolver);\n      final GroovyResolveResult[] candidates = accessorResolver.getCandidates();\n\n      //can be only one correct candidate or some incorrect\n      if (candidates.length == 1 && candidates[0].isStaticsOK() && candidates[0].isAccessible()) {\n        return candidates;\n      }\n      else {\n        ContainerUtil.addAll(accessorResults, candidates);\n      }\n    }\n\n    final ArrayList<GroovyResolveResult> fieldList = ContainerUtil.newArrayList(fieldCandidates);\n    filterOutBindings(fieldList);\n    if (!fieldList.isEmpty()) {\n      return fieldList.toArray(new GroovyResolveResult[fieldList.size()]);\n    }\n\n    if (classCandidates == null && canBeClassOrPackage ) {\n      ResolverProcessor classProcessor = new ClassResolverProcessor(name, this, kinds);\n      resolveRunner.resolveImpl(classProcessor);\n      classCandidates = classProcessor.getCandidates();\n    }\n\n    if (classCandidates != null && classCandidates.length > 0) return classCandidates;\n    if (!accessorResults.isEmpty()) return new GroovyResolveResult[]{accessorResults.get(0)};\n    return GroovyResolveResult.EMPTY_ARRAY;\n  }","id":26272,"modified_method":"@NotNull\n  private GroovyResolveResult[] resolveTypeOrPropertyInner() {\n    PsiElement nameElement = getReferenceNameElement();\n    String name = getReferenceName();\n\n    if (name == null || nameElement == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    IElementType nameType = nameElement.getNode().getElementType();\n    if (nameType == GroovyTokenTypes.kTHIS) {\n      GroovyResolveResult[] results = GrThisReferenceResolver.resolveThisExpression(this);\n      if (results != null) {\n        return results;\n      }\n    }\n    else if (nameType == GroovyTokenTypes.kSUPER) {\n      GroovyResolveResult[] results = GrSuperReferenceResolver.resolveSuperExpression(this);\n      if (results != null) {\n        return results;\n      }\n    }\n\n    if (true) {\n      final GroovyResolverProcessor processor = GroovyResolverProcessorBuilder.builder().build(this);\n      new GrReferenceResolveRunner(this).resolveImpl(processor);\n      return processor.getCandidatesArray();\n    }\n\n    EnumSet<ElementClassHint.DeclarationKind> kinds = getParent() instanceof GrReferenceExpression\n                                           ? ClassHint.RESOLVE_KINDS_CLASS_PACKAGE\n                                           : ClassHint.RESOLVE_KINDS_CLASS;\n\n    GroovyResolveResult[] classCandidates = null;\n\n    GrReferenceResolveRunner resolveRunner = new GrReferenceResolveRunner(this);\n\n    ResolverProcessor processor = new PropertyResolverProcessor(name, this);\n    resolveRunner.resolveImpl(processor);\n    final GroovyResolveResult[] fieldCandidates = processor.getCandidates();\n\n    if (hasAt()) {\n      return fieldCandidates;\n    }\n\n\n    boolean canBeClassOrPackage = ResolveUtil.canBeClassOrPackage(this);\n\n    if (canBeClassOrPackage && findClassOrPackageAtFirst()) {\n      ResolverProcessor classProcessor = new ClassResolverProcessor(name, this, kinds);\n      resolveRunner.resolveImpl(classProcessor);\n      classCandidates = classProcessor.getCandidates();\n      if (classCandidates.length > 0 && containsPackage(classCandidates)) {\n        final PsiElement firstNonReferenceExprParent = PsiTreeUtil.skipParentsOfType(this, GrReferenceExpressionImpl.class);\n        final GrReferenceExpressionImpl topRef = (GrReferenceExpressionImpl)PsiTreeUtil.findFirstParent(this, new Condition<PsiElement>() {\n          @Override\n          public boolean value(PsiElement parent) {\n            return parent.getParent() == firstNonReferenceExprParent && parent instanceof GrReferenceExpressionImpl;\n          }\n        });\n        if (topRef != null) {\n          final String fqn = topRef.getTextSkipWhiteSpaceAndComments();\n          if (JavaPsiFacade.getInstance(getProject()).findClass(fqn, getResolveScope()) != null) {\n            return classCandidates;\n          }\n        }\n      }\n    }\n\n    //if reference expression is in class we need to return field instead of accessor method\n    for (GroovyResolveResult candidate : fieldCandidates) {\n      final PsiElement element = candidate.getElement();\n      if (element instanceof PsiField) {\n        final PsiClass containingClass = ((PsiField)element).getContainingClass();\n        if (containingClass != null && PsiUtil.getContextClass(this) == containingClass) return fieldCandidates;\n      }\n      else if (!(element instanceof GrBindingVariable)) {\n        return fieldCandidates;\n      }\n    }\n\n    if (classCandidates != null && classCandidates.length > 0) return classCandidates;\n\n    final boolean isLValue = PsiUtil.isLValue(this);\n    String[] accessorNames = isLValue ? GroovyPropertyUtils.suggestSettersName(name) : GroovyPropertyUtils.suggestGettersName(name);\n    List<GroovyResolveResult> accessorResults = new ArrayList<GroovyResolveResult>();\n    for (String accessorName : accessorNames) {\n      AccessorResolverProcessor accessorResolver =\n        new AccessorResolverProcessor(accessorName, name, this, !isLValue, PsiImplUtil.getQualifierType(this), getTypeArguments());\n      resolveRunner.resolveImpl(accessorResolver);\n      final GroovyResolveResult[] candidates = accessorResolver.getCandidates();\n\n      //can be only one correct candidate or some incorrect\n      if (candidates.length == 1 && candidates[0].isStaticsOK() && candidates[0].isAccessible()) {\n        return candidates;\n      }\n      else {\n        ContainerUtil.addAll(accessorResults, candidates);\n      }\n    }\n\n    final ArrayList<GroovyResolveResult> fieldList = ContainerUtil.newArrayList(fieldCandidates);\n    filterOutBindings(fieldList);\n    if (!fieldList.isEmpty()) {\n      return fieldList.toArray(new GroovyResolveResult[fieldList.size()]);\n    }\n\n    if (classCandidates == null && canBeClassOrPackage ) {\n      ResolverProcessor classProcessor = new ClassResolverProcessor(name, this, kinds);\n      resolveRunner.resolveImpl(classProcessor);\n      classCandidates = classProcessor.getCandidates();\n    }\n\n    if (classCandidates != null && classCandidates.length > 0) return classCandidates;\n    if (!accessorResults.isEmpty()) return new GroovyResolveResult[]{accessorResults.get(0)};\n    return GroovyResolveResult.EMPTY_ARRAY;\n  }","commit_id":"6128b56d8c2ba81977383a260d0d61abdd05386d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean execute(@NotNull PsiElement element, @NotNull ResolveState state) {\n    if (!(element instanceof PsiNamedElement)) return true;\n    final PsiNamedElement namedElement = (PsiNamedElement)element;\n\n    final PsiElement resolveContext = state.get(ClassHint.RESOLVE_CONTEXT);\n\n    final GroovyResolveKind kind = computeKindAndCheckName(namedElement, resolveContext);\n    if (!myAcceptableKinds.contains(kind)) return true;\n\n    if (kind != GroovyResolveKind.PROPERTY && kind != GroovyResolveKind.METHOD) {\n      if (!myCandidates.get(kind).isEmpty()) return true;\n    }\n\n    final GroovyResolveResultImpl candidate;\n    {\n      PsiSubstitutor substitutor = state.get(PsiSubstitutor.KEY);\n      if (substitutor == null) substitutor = PsiSubstitutor.EMPTY;\n\n      if (kind == GroovyResolveKind.PROPERTY && mySubstitutorComputer.getValue() != null) {\n        substitutor = mySubstitutorComputer.getValue().obtainSubstitutor(substitutor, (PsiMethod)element, resolveContext);\n      }\n\n      final SpreadState spreadState = state.get(SpreadState.SPREAD_STATE);\n      final boolean isAccessible = isAccessible(myRef, namedElement);\n      final boolean isStaticsOK = isStaticsOK(myRef, namedElement, resolveContext, false);\n\n      candidate = new GroovyResolveResultImpl(\n        namedElement, resolveContext, spreadState, substitutor, isAccessible, isStaticsOK, kind == GroovyResolveKind.PROPERTY, true\n      );\n    }\n    (candidate.isValidResult() ? myCandidates : myInapplicableCandidates).putValue(kind, candidate);\n    return true;\n  }","id":26273,"modified_method":"@Override\n  public boolean execute(@NotNull PsiElement element, @NotNull ResolveState state) {\n    if (!(element instanceof PsiNamedElement)) return true;\n    final PsiNamedElement namedElement = (PsiNamedElement)element;\n\n    final PsiElement resolveContext = state.get(ClassHint.RESOLVE_CONTEXT);\n\n    final GroovyResolveKind kind = computeKindAndCheckName(namedElement, resolveContext);\n    if (!myAcceptableKinds.contains(kind)) return true;\n\n    if (kind == GroovyResolveKind.METHOD && myStopExecutingMethods) {\n      return true;\n    }\n    else if (kind != GroovyResolveKind.PROPERTY && kind != GroovyResolveKind.METHOD) {\n      if (!myCandidates.get(kind).isEmpty()) return true;\n    }\n\n    final GroovyResolveResultImpl candidate;\n    {\n      final PsiSubstitutor substitutor = getSubstitutor(state);\n      final SpreadState spreadState = state.get(SpreadState.SPREAD_STATE);\n      final boolean isAccessible = isAccessible(myRef, namedElement);\n      final boolean isStaticsOK = isStaticsOK(myRef, namedElement, resolveContext, false);\n\n      if (kind == GroovyResolveKind.METHOD || kind == GroovyResolveKind.PROPERTY) {\n        final PsiMethod method = (PsiMethod)namedElement;\n        final boolean isApplicable = kind == GroovyResolveKind.PROPERTY || isApplicable(myArgumentTypes, method, null, myRef, true);\n\n        final NotNullComputable<PsiSubstitutor> substitutorComputer;\n        if (kind == GroovyResolveKind.METHOD) {\n          substitutorComputer = new NotNullCachedComputableWrapper<PsiSubstitutor>(new NotNullComputable<PsiSubstitutor>() {\n            @NotNull\n            @Override\n            public PsiSubstitutor compute() {\n              return myMethodSubstitutorComputer.getValue().obtainSubstitutor(substitutor, method, resolveContext);\n            }\n          });\n        }\n        else {\n          substitutorComputer = new NotNullCachedComputableWrapper<PsiSubstitutor>(new NotNullComputable<PsiSubstitutor>() {\n            @NotNull\n            @Override\n            public PsiSubstitutor compute() {\n              return myPropertySubstitutorComputer.getValue().obtainSubstitutor(substitutor, method, resolveContext);\n            }\n          });\n        }\n        candidate = new GroovyMethodResult(\n          method, resolveContext, spreadState,\n          substitutor, substitutorComputer,\n          kind == GroovyResolveKind.PROPERTY,\n          isAccessible, isStaticsOK, isApplicable\n        );\n      }\n      else {\n        candidate = new GroovyResolveResultImpl(\n          namedElement, resolveContext, spreadState, substitutor, isAccessible, isStaticsOK, false, true\n        );\n      }\n    }\n    (candidate.isValidResult() ? myCandidates : myInapplicableCandidates).putValue(kind, candidate);\n    return true;\n  }","commit_id":"6128b56d8c2ba81977383a260d0d61abdd05386d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void handleEvent(@NotNull Event event, @Nullable Object associated) {\n  }","id":26274,"modified_method":"@Override\n  public void handleEvent(@NotNull Event event, @Nullable Object associated) {\n    if (JavaScopeProcessorEvent.CHANGE_LEVEL == event && !myCandidates.get(GroovyResolveKind.METHOD).isEmpty()) {\n      myStopExecutingMethods = true;\n    }\n  }","commit_id":"6128b56d8c2ba81977383a260d0d61abdd05386d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private GroovyResolveKind computeKindAndCheckName(PsiNamedElement element, PsiElement resolveContext) {\n    final String importedName = resolveContext instanceof GrImportStatement ? ((GrImportStatement)resolveContext).getImportedName() : null;\n    if (element instanceof PsiMethod) {\n      if (myIsLValue.getValue()) {\n        if ((importedName != null &&\n             GroovyPropertyUtils.isSimplePropertySetter((PsiMethod)element, null) &&\n             (isAppropriatePropertyNameForSetter(importedName, myName) || myName.equals(importedName)) ||\n             importedName == null && GroovyPropertyUtils.isSimplePropertySetter((PsiMethod)element, myName))) {\n          return GroovyResolveKind.PROPERTY;\n        }\n      }\n      else {\n        if (importedName == null) {\n          if (GroovyPropertyUtils.isSimplePropertyGetter((PsiMethod)element, myName)) {\n            return GroovyResolveKind.PROPERTY;\n          }\n        }\n        else {\n          if (GroovyPropertyUtils.isSimplePropertyGetter((PsiMethod)element, null) &&\n              (isAppropriatePropertyNameForGetter((PsiMethod)element, importedName, myName) ||\n               myName.equals(importedName))) {\n            return GroovyResolveKind.PROPERTY;\n          }\n        }\n      }\n    }\n    if (importedName == null) {\n      if (myName.equals(element.getName())) {\n        if (element instanceof PsiClass) {\n          return GroovyResolveKind.CLASS;\n        }\n        else if (element instanceof PsiPackage) {\n          return GroovyResolveKind.PACKAGE;\n        }\n        if (element instanceof PsiMethod) {\n          return GroovyResolveKind.METHOD;\n        }\n        else if (element instanceof PsiField) {\n          return GroovyResolveKind.FIELD;\n        }\n        else if (element instanceof PsiVariable) {\n          return GroovyResolveKind.VARIABLE;\n        }\n      }\n    }\n    else {\n      if (myName.equals(importedName)) {\n        if (element instanceof PsiClass) {\n          return GroovyResolveKind.CLASS;\n        }\n        if (element instanceof PsiMethod) {\n          return GroovyResolveKind.METHOD;\n        }\n        else if (element instanceof PsiField) {\n          return GroovyResolveKind.FIELD;\n        }\n      }\n    }\n    return null;\n  }","id":26275,"modified_method":"private GroovyResolveKind computeKindAndCheckName(PsiNamedElement element, PsiElement resolveContext) {\n    final String importedName = resolveContext instanceof GrImportStatement ? ((GrImportStatement)resolveContext).getImportedName() : null;\n    if (element instanceof PsiMethod) {\n      if (importedName == null) {\n        if (myIsLValue) {\n          if (GroovyPropertyUtils.isSimplePropertySetter((PsiMethod)element, myName)) {\n            return GroovyResolveKind.PROPERTY;\n          }\n        }\n        else {\n          if (GroovyPropertyUtils.isSimplePropertyGetter((PsiMethod)element, myName)) {\n            return GroovyResolveKind.PROPERTY;\n          }\n        }\n      }\n      else {\n        if (myIsLValue) {\n          if (GroovyPropertyUtils.isSimplePropertySetter((PsiMethod)element, null) &&\n              (isAppropriatePropertyNameForSetter(importedName, myName) || myName.equals(importedName))) {\n            return GroovyResolveKind.PROPERTY;\n          }\n        }\n        else {\n          if (GroovyPropertyUtils.isSimplePropertyGetter((PsiMethod)element, null) &&\n              (isAppropriatePropertyNameForGetter((PsiMethod)element, importedName, myName) ||\n               myName.equals(importedName))) {\n            return GroovyResolveKind.PROPERTY;\n          }\n        }\n\n        // import static Foo.foo; setFoo(1) or getFoo()\n        if (importedName.equals(GroovyPropertyUtils.getPropertyNameByGetterName(myName, true)) ||\n            importedName.equals(GroovyPropertyUtils.getPropertyNameBySetterName(myName))) {\n          return GroovyResolveKind.METHOD;\n        }\n      }\n    }\n    if (importedName == null) {\n      if (myName.equals(element.getName())) {\n        if (element instanceof PsiClass) {\n          return GroovyResolveKind.CLASS;\n        }\n        else if (element instanceof PsiPackage) {\n          return GroovyResolveKind.PACKAGE;\n        }\n        if (element instanceof PsiMethod) {\n          return GroovyResolveKind.METHOD;\n        }\n        else if (element instanceof PsiField) {\n          return GroovyResolveKind.FIELD;\n        }\n        else if (element instanceof PsiVariable) {\n          return GroovyResolveKind.VARIABLE;\n        }\n      }\n    }\n    else {\n      if (myName.equals(importedName)) {\n        if (element instanceof PsiClass) {\n          return GroovyResolveKind.CLASS;\n        }\n        if (element instanceof PsiMethod) {\n          return GroovyResolveKind.METHOD;\n        }\n        else if (element instanceof PsiField) {\n          return GroovyResolveKind.FIELD;\n        }\n      }\n    }\n    return null;\n  }","commit_id":"6128b56d8c2ba81977383a260d0d61abdd05386d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GroovyResolverProcessor(@NotNull GrReferenceExpression ref, @NotNull String name, boolean byShape) {\n    myRef = ref;\n    myName = name;\n    myAcceptableKinds = computeKinds(myRef);\n    myByShape = byShape;\n    myTypeArguments = myRef.getTypeArguments();\n    myIsPartOfFqn = ResolveUtil.isPartOfFQN(myRef);\n  }","id":26276,"modified_method":"GroovyResolverProcessor(@NotNull final GrReferenceExpression ref, @Nullable GrExpression myUpToArgument) {\n    myRef = ref;\n    myName = getReferenceName(ref);\n    myAcceptableKinds = computeKinds(ref);\n\n    myIsLValue = PsiUtil.isLValue(myRef);\n\n    myThisType = PsiImplUtil.getQualifierType(ref);\n    final PsiType[] argumentTypes = PsiUtil.getArgumentTypes(ref, false, myUpToArgument, false);\n    myArgumentTypes = eraseTypes(argumentTypes);\n    myTypeArguments = ref.getTypeArguments();\n    myPropertySubstitutorComputer = new NotNullLazyValue<SubstitutorComputer>() {\n      @NotNull\n      @Override\n      protected SubstitutorComputer compute() {\n        return new SubstitutorComputer(myThisType, PsiType.EMPTY_ARRAY, myTypeArguments, ref, ref);\n      }\n    };\n    myMethodSubstitutorComputer = new NotNullLazyValue<SubstitutorComputer>() {\n      @NotNull\n      @Override\n      protected SubstitutorComputer compute() {\n        return new SubstitutorComputer(myThisType, argumentTypes, myTypeArguments, ref, ref.getParent());\n      }\n    };\n  }","commit_id":"6128b56d8c2ba81977383a260d0d61abdd05386d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public GroovyResolveResult[] getCandidates() {\n    Pair<Boolean, GroovyResolveResult[]> candidates;\n\n    // we do not care about other stuff if we have field operator (.@)\n    if (myRef.hasAt()) {\n      candidates = getCandidates(GroovyResolveKind.FIELD);\n      return candidates.first ? candidates.second : GroovyResolveResult.EMPTY_ARRAY;\n    }\n\n    // return package if whole ref text is valid class name\n    if (myAcceptableKinds.contains(GroovyResolveKind.PACKAGE) && myIsPartOfFqn) {\n      candidates = getCandidates(GroovyResolveKind.PACKAGE);\n      if (candidates.first) {\n        final GroovyResolveResult candidate = candidates.second[0];\n        final PsiElement element = candidate.getElement();\n        assert element instanceof PsiPackage;\n        final GrReferenceExpressionImpl topRef = getContextReferenceExpression(myRef);\n        if (topRef != null) {\n          final String fqn = topRef.getTextSkipWhiteSpaceAndComments();\n          if (JavaPsiFacade.getInstance(myRef.getProject()).findClass(fqn, myRef.getResolveScope()) != null) {\n            return candidates.second;\n          }\n        }\n      }\n    }\n\n    candidates = getCandidates(GroovyResolveKind.VARIABLE);\n    if (candidates.first) {\n      return candidates.second;\n    }\n\n    candidates = getCandidates(GroovyResolveKind.FIELD);\n    if (candidates.first) {\n      assert candidates.second.length == 1;\n      final GroovyResolveResult candidate = candidates.second[0];\n      final PsiElement element = candidate.getElement();\n      if (element instanceof PsiField) {\n        final PsiClass containingClass = ((PsiField)element).getContainingClass();\n        if (containingClass != null && PsiUtil.getContextClass(myRef) == containingClass) return candidates.second;\n      }\n      else if (!(element instanceof GrBindingVariable)) {\n        return candidates.second;\n      }\n    }\n\n    if (myIsPartOfFqn) {\n      candidates = getCandidates(GroovyResolveKind.PACKAGE, GroovyResolveKind.CLASS);\n      if (candidates.first) {\n        return candidates.second;\n      }\n    }\n\n    candidates = getCandidates(GroovyResolveKind.PROPERTY);\n    if (candidates.first) {\n      final GroovyResolveResult[] results = candidates.second;\n      return results.length <= 1 ? results : new GroovyResolveResult[]{results[0]};\n    }\n\n    candidates = getCandidates(GroovyResolveKind.FIELD);\n    if (candidates.first) {\n      return candidates.second;\n    }\n\n    candidates = getCandidates(GroovyResolveKind.PACKAGE, GroovyResolveKind.CLASS);\n    if (candidates.first) {\n      return candidates.second;\n    }\n\n    candidates = getCandidates(GroovyResolveKind.PROPERTY);\n    if (candidates.first) {\n      return candidates.second;\n    }\n\n    for (GroovyResolveKind kind : myAcceptableKinds) {\n      Collection<GroovyResolveResult> results = myInapplicableCandidates.get(kind);\n      if (!results.isEmpty()) return results.toArray(new GroovyResolveResult[results.size()]);\n    }\n\n    return GroovyResolveResult.EMPTY_ARRAY;\n  }","id":26277,"modified_method":"@NotNull\n  public abstract List<GroovyResolveResult> getCandidates();","commit_id":"6128b56d8c2ba81977383a260d0d61abdd05386d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static GrReferenceExpressionImpl getContextReferenceExpression(GrReferenceExpression ref) {\n    final PsiElement firstNonReferenceExprParent = PsiTreeUtil.skipParentsOfType(ref, GrReferenceExpressionImpl.class);\n    return (GrReferenceExpressionImpl)PsiTreeUtil.findFirstParent(ref, new Condition<PsiElement>() {\n      @Override\n      public boolean value(PsiElement parent) {\n        return parent.getParent() == firstNonReferenceExprParent && parent instanceof GrReferenceExpressionImpl;\n      }\n    });\n  }","id":26278,"modified_method":"@NotNull\n  private static String getReferenceName(@NotNull GrReferenceExpression ref) {\n    final String name = ref.getReferenceName();\n    assert name != null : \"Reference name cannot be null\";\n    return name;\n  }","commit_id":"6128b56d8c2ba81977383a260d0d61abdd05386d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private Pair<Boolean, GroovyResolveResult[]> getCandidates(@NotNull GroovyResolveKind... kinds) {\n    final Collection<GroovyResolveResult> results = ContainerUtil.newSmartList();\n    for (GroovyResolveKind kind : kinds) {\n      results.addAll(myCandidates.get(kind));\n    }\n    return !results.isEmpty() ? Pair.create(true, results.toArray(new GroovyResolveResult[results.size()]))\n                              : Pair.create(false, (GroovyResolveResult[])null);\n  }","id":26279,"modified_method":"@NotNull\n  protected Pair<Boolean, List<GroovyResolveResult>> getCandidates(@NotNull GroovyResolveKind... kinds) {\n    final List<GroovyResolveResult> results = ContainerUtil.newSmartList();\n    for (GroovyResolveKind kind : kinds) {\n      results.addAll(myCandidates.get(kind));\n    }\n    return !results.isEmpty() ? Pair.create(true, results) : Pair.create(false, (List<GroovyResolveResult>)null);\n  }","commit_id":"6128b56d8c2ba81977383a260d0d61abdd05386d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tprotected <K extends Serializable, V extends Serializable>\n\t\tvoid handlePortalCacheClusterEvent(\n\t\t\tPortalCacheClusterEvent portalCacheClusterEvent) {\n\n\t\tString cacheName = portalCacheClusterEvent.getCacheName();\n\n\t\tPortalCache<K, V> portalCache =\n\t\t\t(PortalCache<K, V>)_portalCacheManager.getCache(cacheName);\n\n\t\tif ((portalCache == null) && (_hibernateCacheManager != null)) {\n\t\t\tportalCache = (PortalCache<K, V>)_hibernateCacheManager.getCache(\n\t\t\t\tcacheName);\n\t\t}\n\n\t\tif (portalCache == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortalCacheClusterEventType portalCacheClusterEventType =\n\t\t\tportalCacheClusterEvent.getEventType();\n\n\t\tboolean replicate = ClusterReplicationThreadLocal.isReplicate();\n\n\t\tClusterReplicationThreadLocal.setReplicate(false);\n\n\t\ttry {\n\t\t\tif (portalCacheClusterEventType.equals(\n\t\t\t\t\tPortalCacheClusterEventType.REMOVE_ALL)) {\n\n\t\t\t\tportalCache.removeAll();\n\t\t\t}\n\t\t\telse if (portalCacheClusterEventType.equals(\n\t\t\t\t\t\tPortalCacheClusterEventType.PUT) ||\n\t\t\t\t\t portalCacheClusterEventType.equals(\n\t\t\t\t\t\tPortalCacheClusterEventType.UPDATE)) {\n\n\t\t\t\t\tK key = (K)portalCacheClusterEvent.getElementKey();\n\t\t\t\t\tV value = (V)portalCacheClusterEvent.getElementValue();\n\n\t\t\t\tif (value == null) {\n\t\t\t\t\tportalCache.remove(key);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tportalCache.put(\n\t\t\t\t\t\tkey, value, portalCacheClusterEvent.getTimeToLive());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportalCache.remove((K)portalCacheClusterEvent.getElementKey());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tClusterReplicationThreadLocal.setReplicate(replicate);\n\t\t}\n\t}","id":26280,"modified_method":"protected void handlePortalCacheClusterEvent(\n\t\tPortalCacheClusterEvent portalCacheClusterEvent) {\n\n\t\tString cacheName = portalCacheClusterEvent.getCacheName();\n\n\t\tPortalCache<Serializable, Serializable> portalCache =\n\t\t\t(PortalCache<Serializable, Serializable>)\n\t\t\t\t_portalCacheManager.getCache(cacheName);\n\n\t\tif ((portalCache == null) && (_hibernateCacheManager != null)) {\n\t\t\tportalCache = (PortalCache<Serializable, Serializable>)\n\t\t\t\t_hibernateCacheManager.getCache(cacheName);\n\t\t}\n\n\t\tif (portalCache == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortalCacheClusterEventType portalCacheClusterEventType =\n\t\t\tportalCacheClusterEvent.getEventType();\n\n\t\tboolean replicate = ClusterReplicationThreadLocal.isReplicate();\n\n\t\tClusterReplicationThreadLocal.setReplicate(false);\n\n\t\ttry {\n\t\t\tif (portalCacheClusterEventType.equals(\n\t\t\t\t\tPortalCacheClusterEventType.REMOVE_ALL)) {\n\n\t\t\t\tportalCache.removeAll();\n\t\t\t}\n\t\t\telse if (portalCacheClusterEventType.equals(\n\t\t\t\t\t\tPortalCacheClusterEventType.PUT) ||\n\t\t\t\t\t portalCacheClusterEventType.equals(\n\t\t\t\t\t\tPortalCacheClusterEventType.UPDATE)) {\n\n\t\t\t\tSerializable key = portalCacheClusterEvent.getElementKey();\n\t\t\t\tSerializable value = portalCacheClusterEvent.getElementValue();\n\n\t\t\t\tif (value == null) {\n\t\t\t\t\tportalCache.remove(key);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tportalCache.put(\n\t\t\t\t\t\tkey, value, portalCacheClusterEvent.getTimeToLive());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportalCache.remove(portalCacheClusterEvent.getElementKey());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tClusterReplicationThreadLocal.setReplicate(replicate);\n\t\t}\n\t}","commit_id":"d7ee531ef83fa59f174b51e62f184411afcf5d1d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void notifyElementPut(Ehcache ehcache, Element element)\n\t\tthrows CacheException {\n\n\t\tif (!_replicatePuts || !ClusterReplicationThreadLocal.isReplicate()) {\n\t\t\treturn;\n\t\t}\n\n\t\tSerializable key = (Serializable)element.getObjectKey();\n\n\t\tPortalCacheClusterEvent portalCacheClusterEvent =\n\t\t\tnew PortalCacheClusterEvent(\n\t\t\t\tehcache.getName(), key, PortalCacheClusterEventType.PUT);\n\n\t\tif (_replicatePutsViaCopy) {\n\t\t\tSerializable value = (Serializable)element.getObjectValue();\n\t\t\tint timeToLive = element.getTimeToLive();\n\n\t\t\tportalCacheClusterEvent.setElementValue(value);\n\t\t\tportalCacheClusterEvent.setTimeToLive(timeToLive);\n\t\t}\n\n\t\tPortalCacheClusterLinkUtil.sendEvent(portalCacheClusterEvent);\n\t}","id":26281,"modified_method":"@Override\n\tpublic void notifyElementPut(Ehcache ehcache, Element element)\n\t\tthrows CacheException {\n\n\t\tif (!_replicatePuts || !ClusterReplicationThreadLocal.isReplicate()) {\n\t\t\treturn;\n\t\t}\n\n\t\tSerializable key = (Serializable)element.getObjectKey();\n\n\t\tPortalCacheClusterEvent portalCacheClusterEvent =\n\t\t\tnew PortalCacheClusterEvent(\n\t\t\t\tehcache.getName(), key, PortalCacheClusterEventType.PUT);\n\n\t\tif (_replicatePutsViaCopy) {\n\t\t\tportalCacheClusterEvent.setElementValue(\n\t\t\t\t(Serializable)element.getObjectValue());\n\t\t\tportalCacheClusterEvent.setTimeToLive(element.getTimeToLive());\n\t\t}\n\n\t\tPortalCacheClusterLinkUtil.sendEvent(portalCacheClusterEvent);\n\t}","commit_id":"d7ee531ef83fa59f174b51e62f184411afcf5d1d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void notifyElementUpdated(Ehcache ehcache, Element element)\n\t\tthrows CacheException {\n\n\t\tif (!_replicateUpdates ||\n\t\t\t!ClusterReplicationThreadLocal.isReplicate()) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tSerializable key = (Serializable)element.getObjectKey();\n\n\t\tPortalCacheClusterEvent portalCacheClusterEvent =\n\t\t\tnew PortalCacheClusterEvent(\n\t\t\t\tehcache.getName(), key, PortalCacheClusterEventType.UPDATE);\n\n\t\tif (_replicateUpdatesViaCopy) {\n\t\t\tSerializable value = (Serializable)element.getObjectValue();\n\t\t\tint timeToLive = element.getTimeToLive();\n\n\t\t\tportalCacheClusterEvent.setElementValue(value);\n\t\t\tportalCacheClusterEvent.setTimeToLive(timeToLive);\n\t\t}\n\n\t\tPortalCacheClusterLinkUtil.sendEvent(portalCacheClusterEvent);\n\t}","id":26282,"modified_method":"@Override\n\tpublic void notifyElementUpdated(Ehcache ehcache, Element element)\n\t\tthrows CacheException {\n\n\t\tif (!_replicateUpdates ||\n\t\t\t!ClusterReplicationThreadLocal.isReplicate()) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tSerializable key = (Serializable)element.getObjectKey();\n\n\t\tPortalCacheClusterEvent portalCacheClusterEvent =\n\t\t\tnew PortalCacheClusterEvent(\n\t\t\t\tehcache.getName(), key, PortalCacheClusterEventType.UPDATE);\n\n\t\tif (_replicateUpdatesViaCopy) {\n\t\t\tportalCacheClusterEvent.setElementValue(\n\t\t\t\t(Serializable)element.getObjectValue());\n\t\t\tportalCacheClusterEvent.setTimeToLive(element.getTimeToLive());\n\t\t}\n\n\t\tPortalCacheClusterLinkUtil.sendEvent(portalCacheClusterEvent);\n\t}","commit_id":"d7ee531ef83fa59f174b51e62f184411afcf5d1d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void notifyElementUpdated(Ehcache ehcache, Element element)\n\t\tthrows CacheException {\n\n\t\tif (!_replicateUpdates ||\n\t\t\t!ClusterReplicationThreadLocal.isReplicate()) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tSerializable key = (Serializable)element.getObjectKey();\n\n\t\tCacheManager cacheManager = ehcache.getCacheManager();\n\n\t\tPortalCacheClusterEvent portalCacheClusterEvent =\n\t\t\tnew PortalCacheClusterEvent(\n\t\t\t\tcacheManager.getName(), ehcache.getName(), key,\n\t\t\t\tPortalCacheClusterEventType.UPDATE);\n\n\t\tif (_replicateUpdatesViaCopy) {\n\t\t\tportalCacheClusterEvent.setElementValue(\n\t\t\t\t(Serializable)element.getObjectValue());\n\t\t\tportalCacheClusterEvent.setTimeToLive(element.getTimeToLive());\n\t\t}\n\n\t\tPortalCacheClusterLinkUtil.sendEvent(portalCacheClusterEvent);\n\t}","id":26283,"modified_method":"@Override\n\tpublic void notifyElementUpdated(Ehcache ehcache, Element element)\n\t\tthrows CacheException {\n\n\t\tif (!ClusterReplicationThreadLocal.isReplicate()) {\n\t\t\treturn;\n\t\t}\n\n\t\t_clusterLinkCacheReplicator.notifyEntryUpdated(\n\t\t\t_getPortalCache(ehcache), (K)element.getObjectKey(),\n\t\t\t(V)element.getObjectValue(), element.getTimeToLive());\n\t}","commit_id":"779effdf0011a5e472d82102570492adff24cc8a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void notifyElementRemoved(Ehcache ehcache, Element element)\n\t\tthrows CacheException {\n\n\t\tif (!_replicateRemovals ||\n\t\t\t!ClusterReplicationThreadLocal.isReplicate()) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tCacheManager cacheManager = ehcache.getCacheManager();\n\t\tSerializable key = (Serializable)element.getObjectKey();\n\n\t\tPortalCacheClusterEvent portalCacheClusterEvent =\n\t\t\tnew PortalCacheClusterEvent(\n\t\t\t\tcacheManager.getName(), ehcache.getName(), key,\n\t\t\t\tPortalCacheClusterEventType.REMOVE);\n\n\t\tPortalCacheClusterLinkUtil.sendEvent(portalCacheClusterEvent);\n\t}","id":26284,"modified_method":"@Override\n\tpublic void notifyElementRemoved(Ehcache ehcache, Element element)\n\t\tthrows CacheException {\n\n\t\tif (!ClusterReplicationThreadLocal.isReplicate()) {\n\t\t\treturn;\n\t\t}\n\n\t\t_clusterLinkCacheReplicator.notifyEntryRemoved(\n\t\t\t_getPortalCache(ehcache), (K)element.getObjectKey(),\n\t\t\t(V)element.getObjectValue(), element.getTimeToLive());\n\t}","commit_id":"779effdf0011a5e472d82102570492adff24cc8a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void notifyElementPut(Ehcache ehcache, Element element)\n\t\tthrows CacheException {\n\n\t\tif (!_replicatePuts || !ClusterReplicationThreadLocal.isReplicate()) {\n\t\t\treturn;\n\t\t}\n\n\t\tCacheManager cacheManager = ehcache.getCacheManager();\n\t\tSerializable key = (Serializable)element.getObjectKey();\n\n\t\tPortalCacheClusterEvent portalCacheClusterEvent =\n\t\t\tnew PortalCacheClusterEvent(\n\t\t\t\tcacheManager.getName(), ehcache.getName(), key,\n\t\t\t\tPortalCacheClusterEventType.PUT);\n\n\t\tif (_replicatePutsViaCopy) {\n\t\t\tportalCacheClusterEvent.setElementValue(\n\t\t\t\t(Serializable)element.getObjectValue());\n\t\t\tportalCacheClusterEvent.setTimeToLive(element.getTimeToLive());\n\t\t}\n\n\t\tPortalCacheClusterLinkUtil.sendEvent(portalCacheClusterEvent);\n\t}","id":26285,"modified_method":"@Override\n\tpublic void notifyElementPut(Ehcache ehcache, Element element)\n\t\tthrows CacheException {\n\n\t\tif (!ClusterReplicationThreadLocal.isReplicate()) {\n\t\t\treturn;\n\t\t}\n\n\t\t_clusterLinkCacheReplicator.notifyEntryPut(\n\t\t\t_getPortalCache(ehcache), (K)element.getObjectKey(),\n\t\t\t(V)element.getObjectValue(), element.getTimeToLive());\n\t}","commit_id":"779effdf0011a5e472d82102570492adff24cc8a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void notifyRemoveAll(Ehcache ehcache) {\n\t\tif (!_replicateRemovals ||\n\t\t\t!ClusterReplicationThreadLocal.isReplicate()) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tCacheManager cacheManager = ehcache.getCacheManager();\n\n\t\tPortalCacheClusterEvent portalCacheClusterEvent =\n\t\t\tnew PortalCacheClusterEvent(\n\t\t\t\tcacheManager.getName(), ehcache.getName(), null,\n\t\t\t\tPortalCacheClusterEventType.REMOVE_ALL);\n\n\t\tPortalCacheClusterLinkUtil.sendEvent(portalCacheClusterEvent);\n\t}","id":26286,"modified_method":"@Override\n\tpublic void notifyRemoveAll(Ehcache ehcache) {\n\t\tif (!ClusterReplicationThreadLocal.isReplicate()) {\n\t\t\treturn;\n\t\t}\n\n\t\t_clusterLinkCacheReplicator.notifyRemoveAll(_getPortalCache(ehcache));\n\t}","commit_id":"779effdf0011a5e472d82102570492adff24cc8a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public EhcachePortalCacheClusterReplicator(Properties properties) {\n\t\t_replicatePuts = GetterUtil.getBoolean(\n\t\t\tproperties.getProperty(_REPLICATE_PUTS), true);\n\t\t_replicatePutsViaCopy = GetterUtil.getBoolean(\n\t\t\tproperties.getProperty(_REPLICATE_PUTS_VIA_COPY));\n\t\t_replicateRemovals = GetterUtil.getBoolean(\n\t\t\tproperties.getProperty(_REPLICATE_REMOVALS), true);\n\t\t_replicateUpdates = GetterUtil.getBoolean(\n\t\t\tproperties.getProperty(_REPLICATE_UPDATES), true);\n\t\t_replicateUpdatesViaCopy = GetterUtil.getBoolean(\n\t\t\tproperties.getProperty(_REPLICATE_UPDATES_VIA_COPY));\n\t}","id":26287,"modified_method":"public EhcachePortalCacheClusterReplicator(Properties properties) {\n\t\t_clusterLinkCacheReplicator = new ClusterLinkCacheReplicator<>(\n\t\t\tproperties);\n\t}","commit_id":"779effdf0011a5e472d82102570492adff24cc8a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getName() {\n        ModuleComponentIdentifier id = (ModuleComponentIdentifier)module.getPublishedAs();\n        return id.getGroup() + \":\" + id.getModule() + \":\" + id.getVersion();\n    }","id":26288,"modified_method":"public String getName() {\n        ModuleComponentIdentifier id = getId();\n        return id.getGroup() + \":\" + id.getModule() + \":\" + id.getVersion();\n    }","commit_id":"356bc0bd981fcf40f9cd0e245da715d1e293825d","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleComponentIdentifier getId() {\n        return (ModuleComponentIdentifier)module.getPublishedAs();\n    }","id":26289,"modified_method":"public ModuleComponentIdentifier getId() {\n        return DefaultModuleComponentIdentifier.newId(module.getModuleVersion());\n    }","commit_id":"356bc0bd981fcf40f9cd0e245da715d1e293825d","url":"https://github.com/gradle/gradle"},{"original_method":"private boolean matchesSelected(ResolvedDependencyResult candidate) {\n        ModuleComponentIdentifier selected = (ModuleComponentIdentifier)candidate.getSelected().getPublishedAs();\n        String selectedCandidate = selected.getGroup() + \":\" + selected.getModule() + \":\" + selected.getVersion();\n        return selectedCandidate.contains(stringNotation);\n    }","id":26290,"modified_method":"private boolean matchesSelected(ResolvedDependencyResult candidate) {\n        ModuleVersionIdentifier selected = candidate.getSelected().getModuleVersion();\n        String selectedCandidate = selected.getGroup() + \":\" + selected.getModule() + \":\" + selected.getVersion();\n        return selectedCandidate.contains(stringNotation);\n    }","commit_id":"356bc0bd981fcf40f9cd0e245da715d1e293825d","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleDescriptorAdapter(ModuleVersionIdentifier identifier, ModuleDescriptor moduleDescriptor) {\n        this(identifier, moduleDescriptor, DefaultModuleComponentIdentifier.newId(identifier.getGroup(), identifier.getName(), identifier.getVersion()));\n    }","id":26291,"modified_method":"public ModuleDescriptorAdapter(ModuleVersionIdentifier identifier, ModuleDescriptor moduleDescriptor) {\n        this(identifier, moduleDescriptor, DefaultModuleComponentIdentifier.newId(identifier));\n    }","commit_id":"356bc0bd981fcf40f9cd0e245da715d1e293825d","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected ModuleComponentIdentifier getActual() {\n        return (ModuleComponentIdentifier)dependency.getSelected().getPublishedAs();\n    }","id":26292,"modified_method":"@Override\n    protected ModuleComponentIdentifier getActual() {\n        return DefaultModuleComponentIdentifier.newId(dependency.getSelected().getModuleVersion());\n    }","commit_id":"356bc0bd981fcf40f9cd0e245da715d1e293825d","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleComponentIdentifier getActual() {\n        return (ModuleComponentIdentifier)dependency.getSelected().getPublishedAs();\n    }","id":26293,"modified_method":"public ModuleComponentIdentifier getActual() {\n        return DefaultModuleComponentIdentifier.newId(dependency.getSelected().getModuleVersion());\n    }","commit_id":"356bc0bd981fcf40f9cd0e245da715d1e293825d","url":"https://github.com/gradle/gradle"},{"original_method":"private void showReviewPane(boolean showHistory)\n   {\n      // show in external window if we shift-click\n      Event currentEvent = Event.getCurrentEvent();\n      if ((currentEvent != null) && currentEvent.getShiftKey())\n      {\n         satelliteManager_.openSatellite(\"review_changes\", \n                                         getPreferredReviewPanelSize());\n      }\n      else\n      {\n         ReviewPresenter rpres = pReviewPresenter_.get();\n         if (view_.getSelectedItemCount() > 0)\n            rpres.setSelectedPaths(view_.getSelectedItems());\n         VCSPopup.show(rpres,\n                       pHistoryPresenter_.get(),\n                       showHistory);\n      }\n   }","id":26294,"modified_method":"private void showReviewPane(boolean showHistory)\n   {\n      // show in external window if we shift-click\n      Event currentEvent = Event.getCurrentEvent();\n      if ((currentEvent != null) && currentEvent.getShiftKey())\n      {\n         \n         VCSApplicationParams params = VCSApplicationParams.create(\n                                             showHistory, \n                                             view_.getSelectedItems());\n         satelliteManager_.openSatellite(\"review_changes\",     \n                                         params,\n                                         getPreferredReviewPanelSize());\n      }\n      else\n      {\n         ReviewPresenter rpres = pReviewPresenter_.get();\n         if (view_.getSelectedItemCount() > 0)\n            rpres.setSelectedPaths(view_.getSelectedItems());\n         VCSPopup.show(rpres,\n                       pHistoryPresenter_.get(),\n                       showHistory);\n      }\n   }","commit_id":"a20536314d8c12c38749bc4bbd4ec6a2c02f51a6","url":"https://github.com/rstudio/rstudio"},{"original_method":"public native void initialize(String name) /*-{\n      \n      // global flag used to conditionalize behavior\n      $wnd.isRStudioSatellite = true;\n      $wnd.RStudioSatelliteName = name;\n      \n      // export setSessionInfo callback\n      var satellite = this;     \n      $wnd.setRStudioSatelliteSessionInfo = $entry(\n         function(sessionInfo) {\n            satellite.@org.rstudio.studio.client.common.satellite.Satellite::setSessionInfo(Lcom/google/gwt/core/client/JavaScriptObject;)(sessionInfo);\n         }\n      ); \n      \n      // export event notification callback\n      $wnd.dispatchEventToRStudioSatellite = $entry(\n         function(clientEvent) {\n            satellite.@org.rstudio.studio.client.common.satellite.Satellite::dispatchEvent(Lcom/google/gwt/core/client/JavaScriptObject;)(clientEvent);\n         }\n      ); \n      \n      // register (this will call the setSessionInfo back)\n      $wnd.opener.registerAsRStudioSatellite(name, $wnd);\n   }-*/;","id":26295,"modified_method":"private native void initializeNative(String name) /*-{\n      \n      // global flag used to conditionalize behavior\n      $wnd.isRStudioSatellite = true;\n      $wnd.RStudioSatelliteName = name;\n      \n      // export setSessionInfo callback\n      var satellite = this;     \n      $wnd.setRStudioSatelliteSessionInfo = $entry(\n         function(sessionInfo) {\n            satellite.@org.rstudio.studio.client.common.satellite.Satellite::setSessionInfo(Lcom/google/gwt/core/client/JavaScriptObject;)(sessionInfo);\n         }\n      ); \n      \n      // export setParams callback\n      $wnd.setRStudioSatelliteParams = $entry(\n         function(params) {\n            satellite.@org.rstudio.studio.client.common.satellite.Satellite::setParams(Lcom/google/gwt/core/client/JavaScriptObject;)(params);\n         }\n      ); \n      \n      // export notifyReactivated callback\n      $wnd.notifyRStudioSatelliteReactivated = $entry(\n         function(params) {\n            satellite.@org.rstudio.studio.client.common.satellite.Satellite::notifyReactivated(Lcom/google/gwt/core/client/JavaScriptObject;)(params);\n         }\n      ); \n      \n      // export event notification callback\n      $wnd.dispatchEventToRStudioSatellite = $entry(\n         function(clientEvent) {\n            satellite.@org.rstudio.studio.client.common.satellite.Satellite::dispatchEvent(Lcom/google/gwt/core/client/JavaScriptObject;)(clientEvent);\n         }\n      ); \n      \n      // register (this will call the setSessionInfo back)\n      $wnd.opener.registerAsRStudioSatellite(name, $wnd);\n   }-*/;","commit_id":"a20536314d8c12c38749bc4bbd4ec6a2c02f51a6","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void registerAsSatellite(String name, JavaScriptObject wnd)\n   {\n      // get the satellite and add it to our list\n      WindowEx satelliteWnd = wnd.<WindowEx>cast();\n      satellites_.add(new ActiveSatellite(name, satelliteWnd));\n      \n      // call setSessionInfo\n      callSetSessionInfo(satelliteWnd, session_.getSessionInfo());\n   }","id":26296,"modified_method":"private void registerAsSatellite(String name, JavaScriptObject wnd)\n   {\n      // get the satellite and add it to our list\n      WindowEx satelliteWnd = wnd.<WindowEx>cast();\n      satellites_.add(new ActiveSatellite(name, satelliteWnd));\n      \n      // call setSessionInfo\n      callSetSessionInfo(satelliteWnd, session_.getSessionInfo());\n      \n      // call setParams\n      JavaScriptObject params = satelliteParams_.get(name);\n      if (params != null)\n         callSetParams(satelliteWnd, params);\n   }","commit_id":"a20536314d8c12c38749bc4bbd4ec6a2c02f51a6","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void openSatellite(String name, Size preferredSize)\n   {\n      // satellites can't launch other satellites -- this is because the \n      // delegating/forwarding of remote server calls and events doesn't\n      // cascade correctly -- it wouldn't be totally out of the question\n      // to make htis work but we'd rather not have this complexity\n      // if we don't need to.\n      if (isCurrentWindowSatellite())\n      {\n         Debug.log(\"Satellite windows can't launch other satellites\");\n         assert false;\n         return;\n      }\n \n      // in web mode try to activate any existing satellite of this name\n      // we have a special mechanism for doing this because if we relied\n      // on the default mechanism it would cause the target window to\n      // reload (NOTE: Desktop handles this with a special codepath)\n      if (!Desktop.isDesktop())\n      {\n         for (ActiveSatellite satellite : satellites_)\n         {\n            if (satellite.getName().equals(name))\n            {\n               WindowEx window = satellite.getWindow();\n               if (!window.isClosed())\n               {\n                  window.focus();\n                  return;\n               }\n            }\n         }\n      }\n      \n      // open the satellite\n      RStudioGinjector.INSTANCE.getGlobalDisplay().openSatelliteWindow(\n                                              name,\n                                              preferredSize.width,\n                                              preferredSize.height);\n   }","id":26297,"modified_method":"public void openSatellite(String name,\n                             JavaScriptObject params,\n                             Size preferredSize)\n   {\n      // satellites can't launch other satellites -- this is because the \n      // delegating/forwarding of remote server calls and events doesn't\n      // cascade correctly -- it wouldn't be totally out of the question\n      // to make htis work but we'd rather not have this complexity\n      // if we don't need to.\n      if (isCurrentWindowSatellite())\n      {\n         Debug.log(\"Satellite windows can't launch other satellites\");\n         assert false;\n         return;\n      }\n      \n      // in web mode try to activate any existing satellite of this name\n      // we have a special mechanism for doing this because if we relied\n      // on the default mechanism it would cause the target window to\n      // reload (NOTE: Desktop handles this with a special codepath)\n      if (!Desktop.isDesktop())\n      {\n         for (ActiveSatellite satellite : satellites_)\n         {\n            if (satellite.getName().equals(name))\n            {\n               WindowEx window = satellite.getWindow();\n               if (!window.isClosed())\n               {\n                  window.focus();\n                  callNotifyReactivated(window, params);\n                  return;\n               }\n            }\n         }\n      }\n      \n      // record satellite params for subsequent setting\n      if (params != null)\n         satelliteParams_.put(name, params);\n \n      // open the satellite - it will call us back on registerAsSatellite\n      // at which time we'll call setSessionInfo, setParams, etc.\n      RStudioGinjector.INSTANCE.getGlobalDisplay().openSatelliteWindow(\n                                              name,\n                                              preferredSize.width,\n                                              preferredSize.height);\n   }","commit_id":"a20536314d8c12c38749bc4bbd4ec6a2c02f51a6","url":"https://github.com/rstudio/rstudio"},{"original_method":"abstract protected void onInitialize(LayoutPanel mainPanel);","id":26298,"modified_method":"abstract protected void onInitialize(LayoutPanel mainPanel, \n                                        JavaScriptObject params);","commit_id":"a20536314d8c12c38749bc4bbd4ec6a2c02f51a6","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void go(RootLayoutPanel rootPanel, \n                  final Command dismissLoadingProgress)\n   {\n      // indicate that we are a satellite window\n      satellite_.initialize(\"review_panel\");\n      \n      // register for uncaught exceptions (do this after calling \n      // initSatelliteWindow b/c it depends on Server)\n      uncaughtExHandler_.register();\n      \n      // create the widget\n      Widget w = view_.getWidget();\n      rootPanel.add(w);\n      rootPanel.setWidgetTopBottom(w, 0, Style.Unit.PX, 0, Style.Unit.PX);\n      rootPanel.setWidgetLeftRight(w, 0, Style.Unit.PX, 0, Style.Unit.PX);\n      \n      // show the view\n      view_.show();\n      \n      // dismiss loading progress\n      dismissLoadingProgress.execute();\n   }","id":26299,"modified_method":"public void go(RootLayoutPanel rootPanel, \n                  final Command dismissLoadingProgress)\n   {\n      // indicate that we are a satellite window\n      satellite_.initialize(\"review_changes\",\n                            new CommandWithArg<JavaScriptObject> () {\n                               @Override\n                               public void execute(JavaScriptObject params)\n                               {\n                                  view_.reactivate(params);                \n                               }\n                            });\n      \n      // register for uncaught exceptions (do this after calling \n      // initSatelliteWindow b/c it depends on Server)\n      uncaughtExHandler_.register();\n      \n      // create the widget\n      Widget w = view_.getWidget();\n      rootPanel.add(w);\n      rootPanel.setWidgetTopBottom(w, 0, Style.Unit.PX, 0, Style.Unit.PX);\n      rootPanel.setWidgetLeftRight(w, 0, Style.Unit.PX, 0, Style.Unit.PX);\n      \n      // show the view\n      view_.show(satellite_.getParams());\n      \n      // dismiss loading progress\n      dismissLoadingProgress.execute();\n   }","commit_id":"a20536314d8c12c38749bc4bbd4ec6a2c02f51a6","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected void onInitialize(LayoutPanel mainPanel)\n   {\n      // set our window title\n      Window.setTitle(\"Review Changes\");\n      \n      // make sure vcs core is initialized\n      pVCSCore_.get();\n      \n      // show the vcs ui in our main panel\n      VCSPopup.show(mainPanel,\n                    pReviewPresenter_.get(),\n                    pHistoryPresenter_.get(), \n                    false);  \n   }","id":26300,"modified_method":"@Override\n   protected void onInitialize(LayoutPanel mainPanel, \n                               JavaScriptObject params)\n   {\n      // set our window title\n      Window.setTitle(\"Review Changes\");\n      \n      // make sure vcs core is initialized\n      pVCSCore_.get();\n      \n      // show the vcs ui in our main panel\n      VCSApplicationParams vcsParams = params.<VCSApplicationParams>cast();\n      ReviewPresenter rpres = pReviewPresenter_.get();\n      ArrayList<StatusAndPath> selected = vcsParams.getSelected();\n      if (selected.size() > 0)\n         rpres.setSelectedPaths(selected);\n      VCSPopup.show(mainPanel,\n                    rpres,\n                    pHistoryPresenter_.get(), \n                    vcsParams.getShowHistory());  \n   }","commit_id":"a20536314d8c12c38749bc4bbd4ec6a2c02f51a6","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void openSatelliteWindow(String name, int width, int height)\n   {\n      windowOpener_.openSatelliteWindow(this, name, width, height);\n   }","id":26301,"modified_method":"@Override\n   public void openSatelliteWindow(String name, int width, int height)\n   {\n      openSatelliteWindow(name, width, height, null);\n   }","commit_id":"968ada5d6985e645cf6e26456fc8ee69cea0b8a6","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void openSatelliteWindow(GlobalDisplay globalDisplay,\n                                   String mode,\n                                   int width,\n                                   int height)\n   {  \n      String windowName = SatelliteUtils.getSatelliteWindowName(mode);\n      Desktop.getFrame().prepareForSatelliteWindow(windowName, width, height);\n      super.openSatelliteWindow(globalDisplay, mode, width, height);\n   }","id":26302,"modified_method":"@Override\n   public void openSatelliteWindow(GlobalDisplay globalDisplay,\n                                   String mode,\n                                   int width,\n                                   int height, \n                                   NewWindowOptions options)\n   {  \n      String windowName = SatelliteUtils.getSatelliteWindowName(mode);\n      Desktop.getFrame().prepareForSatelliteWindow(windowName, width, height);\n      super.openSatelliteWindow(globalDisplay, mode, width, height, options);\n   }","commit_id":"968ada5d6985e645cf6e26456fc8ee69cea0b8a6","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void onRmdRenderCompleted(RmdRenderCompletedEvent event)\n   {\n      RmdRenderResult result = event.getResult();\n      if (result.getSucceeded())\n      {\n         // use the current scroll position for this file, if available\n         int scrollPosition = 0;\n         if (scrollPositions_.containsKey(result.getOutputFile()))\n         {\n            scrollPosition = scrollPositions_.get(result.getOutputFile());\n         }\n         RmdPreviewParams params = RmdPreviewParams.create(\n               result, scrollPosition);\n         satelliteManager_.openSatellite(RmdOutputSatellite.NAME,     \n                                         params,\n                                         new Size(960,1100));   \n      }\n   }","id":26303,"modified_method":"@Override\n   public void onRmdRenderCompleted(RmdRenderCompletedEvent event)\n   {\n      RmdRenderResult result = event.getResult();\n      if (result.getSucceeded())\n      {\n         // find the last known scroll position for this file\n         int scrollPosition = 0;\n         if (scrollPositions_.containsKey(result.getOutputFile()))\n         {\n            scrollPosition = scrollPositions_.get(result.getOutputFile());\n         }\n         RmdPreviewParams params = RmdPreviewParams.create(\n               result, scrollPosition);\n\n         WindowEx win = satelliteManager_.getSatelliteWindowObject(\n               RmdOutputSatellite.NAME);\n\n         // we're refreshing if the window is up and we're pulling the same\n         // output file as the last one\n         boolean isRefresh = win != null &&\n                             result_ != null && \n                             result_.getOutputFile().equals(\n                                   result.getOutputFile());\n         // if this isn't a refresh but there's a window up, cache the scroll\n         // position of the old document before we replace it\n         if (!isRefresh && result_ != null && win != null)\n         {\n            scrollPositions_.put(result_.getOutputFile(), \n                                 getScrollPosition(win));\n         }\n         if (win != null && !Desktop.isDesktop() && BrowseCap.isChrome())\n         {\n            // we're on Chrome, cache the scroll position unless we're switching\n            // docs and do a hard close/reopen\n            if (isRefresh)\n            {\n               params.setScrollPosition(getScrollPosition(win));\n            }\n            satelliteManager_.forceReopenSatellite(RmdOutputSatellite.NAME, \n                                                   params);\n         }\n         else\n         {\n            satelliteManager_.openSatellite(RmdOutputSatellite.NAME,     \n                                            params,\n                                            new Size(960,1100));   \n         }\n      }\n\n      // save the result so we know if the next render is a re-render of the\n      // same document\n      result_ = result;\n   }","commit_id":"968ada5d6985e645cf6e26456fc8ee69cea0b8a6","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void openSatellite(String name,\n                             JavaScriptObject params,\n                             Size preferredSize)\n   {\n      // satellites can't launch other satellites -- this is because the \n      // delegating/forwarding of remote server calls and events doesn't\n      // cascade correctly -- it wouldn't be totally out of the question\n      // to make this work but we'd rather not have this complexity\n      // if we don't need to.\n      if (isCurrentWindowSatellite())\n      {\n         Debug.log(\"Satellite windows can't launch other satellites\");\n         assert false;\n         return;\n      }\n\n      // check for a re-activation of an existing window\n      for (ActiveSatellite satellite : satellites_)\n      {\n         if (satellite.getName().equals(name))\n         {\n            WindowEx window = satellite.getWindow();\n            if (!window.isClosed())\n            {\n               // for web mode bring the window to the front, notify\n               // it that it has been reactivated, then exit. \n               if (!Desktop.isDesktop())\n               {\n                  // don't do this for chrome (since it doesn't allow\n                  // window.focus). for chrome we'll just fall through\n                  // and openSatelliteWindow will be called and the \n                  // window will be reloaded)\n                  if (!BrowseCap.isChrome())\n                  {\n                     window.focus();\n                     callNotifyReactivated(window, params);\n                     return;\n                  }\n                  else\n                  {\n                     // for Chrome, let the window know it's about to be \n                     // closed and reopened\n                     callNotifyPendingReactivate(window);\n                  }\n               }\n               // desktop mode: activate and return\n               else\n               {\n                  Desktop.getFrame().activateSatelliteWindow(\n                    SatelliteUtils.getSatelliteWindowName(satellite.getName()));\n                  callNotifyReactivated(window, params);\n                  return;\n               }\n            }\n         }\n      }\n      \n      // Start buffering events sent to this satellite. That way, we won't miss\n      // anything while the satellite is being loaded/reactivated\n      if (!pendingEventsBySatelliteName_.containsKey(name))\n      {\n         pendingEventsBySatelliteName_.put(name,\n                                           new ArrayList<JavaScriptObject>());\n      }\n\n      // record satellite params for subsequent setting (this value is read\n      // by the satellite within the call to registerAsSatellite)\n      if (params != null)\n         satelliteParams_.put(name, params);\n \n      // open the satellite - it will call us back on registerAsSatellite\n      // at which time we'll call setSessionInfo, setParams, etc.\n      Size windowSize = ScreenUtils.getAdjustedWindowSize(preferredSize);\n      RStudioGinjector.INSTANCE.getGlobalDisplay().openSatelliteWindow(\n                                              name,\n                                              windowSize.width,\n                                              windowSize.height);\n   }","id":26304,"modified_method":"public void openSatellite(String name,\n                             JavaScriptObject params,\n                             Size preferredSize)\n   {\n      openSatellite(name, params, preferredSize, true, null);\n   }","commit_id":"968ada5d6985e645cf6e26456fc8ee69cea0b8a6","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void openSatelliteWindow(GlobalDisplay globalDisplay,\n                                   String viewName,\n                                   int width,\n                                   int height)\n   {\n      // build url\n      UrlBuilder urlBuilder = Window.Location.createUrlBuilder();\n      urlBuilder.setParameter(\"view\", viewName);\n      \n      // setup options\n      NewWindowOptions options = new NewWindowOptions();\n      options.setName(SatelliteUtils.getSatelliteWindowName(viewName));\n      options.setFocus(true);\n      \n      // open window (force web codepath b/c desktop needs this so\n      // that window.opener is hooked up)\n      webOpenMinimalWindow(globalDisplay,\n                           urlBuilder.buildString(),\n                           options,\n                           width,\n                           height,\n                           false);\n   }","id":26305,"modified_method":"public void openSatelliteWindow(GlobalDisplay globalDisplay,\n                                   String viewName,\n                                   int width,\n                                   int height, \n                                   NewWindowOptions options)\n   {\n      // build url\n      UrlBuilder urlBuilder = Window.Location.createUrlBuilder();\n      urlBuilder.setParameter(\"view\", viewName);\n      \n      // setup options\n      if (options == null)\n         options = new NewWindowOptions();\n      options.setName(SatelliteUtils.getSatelliteWindowName(viewName));\n      options.setFocus(true);\n      \n      // open window (force web codepath b/c desktop needs this so\n      // that window.opener is hooked up)\n      webOpenMinimalWindow(globalDisplay,\n                           urlBuilder.buildString(),\n                           options,\n                           width,\n                           height,\n                           false);\n   }","commit_id":"968ada5d6985e645cf6e26456fc8ee69cea0b8a6","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void webOpenMinimalWindow(GlobalDisplay globalDisplay,\n                                     String url,\n                                     NewWindowOptions options,\n                                     int width,\n                                     int height,\n                                     boolean showLocation)\n   {\n      String loc = showLocation ? \"1\" : \"0\";\n      String features = \"width=\" + width + \",\" +\n                        \"height=\" + height + \",\" +\n                        \"menubar=0,toolbar=0,location=\" + loc + \",\" +\n                        \"status=0,scrollbars=1,resizable=1,directories=0\";\n\n      openWindowInternal(globalDisplay, url, options, features, width, height);\n   }","id":26306,"modified_method":"private void webOpenMinimalWindow(GlobalDisplay globalDisplay,\n                                     String url,\n                                     NewWindowOptions options,\n                                     int width,\n                                     int height,\n                                     boolean showLocation)\n   {\n      String loc = showLocation ? \"1\" : \"0\";\n      String features = \"width=\" + width + \",\" +\n                        \"height=\" + height + \",\" +\n                        \"menubar=0,toolbar=0,location=\" + loc + \",\" +\n                        \"status=0,scrollbars=1,resizable=1,directories=0\";\n\n      // open window at specific position if specified\n      Point pos = options.getPosition();\n      if (pos != null)\n      {\n         features += \",left=\" + pos.x + \",top=\" + pos.y;\n      }\n         \n      openWindowInternal(globalDisplay, url, options, features, width, height);\n   }","commit_id":"968ada5d6985e645cf6e26456fc8ee69cea0b8a6","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void onRmdRenderCompleted(RmdRenderCompletedEvent event)\n   {\n      if (event.getResult().getSucceeded())\n      {\n         satelliteManager_.openSatellite(RmdOutputSatellite.NAME,     \n                                         event.getResult(),\n                                         new Size(960,1100));   \n      }\n   }","id":26307,"modified_method":"@Override\n   public void onRmdRenderCompleted(RmdRenderCompletedEvent event)\n   {\n      RmdRenderResult result = event.getResult();\n      if (result.getSucceeded())\n      {\n         // use the current scroll position for this file, if available\n         int scrollPosition = 0;\n         if (scrollPositions_.containsKey(result.getOutputFile()))\n         {\n            scrollPosition = scrollPositions_.get(result.getOutputFile());\n         }\n         RmdPreviewParams params = RmdPreviewParams.create(\n               result, scrollPosition);\n         satelliteManager_.openSatellite(RmdOutputSatellite.NAME,     \n                                         params,\n                                         new Size(960,1100));   \n      }\n   }","commit_id":"a5575b4fbe85d30bc6cb7efacd2fefe3fb857455","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public RmdOutput(EventBus eventBus, \n                    Commands commands,\n                    Binder binder,\n                    final SatelliteManager satelliteManager)\n   {\n      satelliteManager_ = satelliteManager;\n      \n      eventBus.addHandler(RmdRenderCompletedEvent.TYPE, this);\n\n      binder.bind(commands, this);\n   }","id":26308,"modified_method":"@Inject\n   public RmdOutput(EventBus eventBus, \n                    Commands commands,\n                    Binder binder,\n                    final SatelliteManager satelliteManager)\n   {\n      satelliteManager_ = satelliteManager;\n      \n      eventBus.addHandler(RmdRenderCompletedEvent.TYPE, this);\n\n      binder.bind(commands, this);\n      \n      exportRmdOutputClosedCallback();\n   }","commit_id":"a5575b4fbe85d30bc6cb7efacd2fefe3fb857455","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void refresh()\n   {\n      showUrl(server_.getApplicationURL(result_.getOutputUrl()));\n   }","id":26309,"modified_method":"@Override\n   public void refresh()\n   {\n      // cache the scroll position, so we can re-apply it when the page loads\n      scrollPosition_ = getScrollPosition();\n      showUrl(server_.getApplicationURL(params_.getOutputUrl()));\n   }","commit_id":"a5575b4fbe85d30bc6cb7efacd2fefe3fb857455","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected AnchorableFrame createFrame(String url)\n   {\n      AnchorableFrame frame = new AnchorableFrame();\n      frame.navigate(url);\n      return frame;\n   }","id":26310,"modified_method":"@Override\n   protected AnchorableFrame createFrame(String url)\n   {\n      AnchorableFrame frame = new AnchorableFrame();\n      frame.navigate(url);\n      frame.addLoadHandler(new LoadHandler()\n      {\n         @Override\n         public void onLoad(LoadEvent event)\n         {\n            getFrame().getIFrame().getContentDocument().setScrollTop(\n                  scrollPosition_);\n         }\n      });\n      return frame;\n   }","commit_id":"a5575b4fbe85d30bc6cb7efacd2fefe3fb857455","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Handler\n   public void onViewerPopout()\n   {\n      globalDisplay_.showHtmlFile(result_.getOutputFile());\n   }","id":26311,"modified_method":"@Handler\n   public void onViewerPopout()\n   {\n      globalDisplay_.showHtmlFile(params_.getOutputFile());\n   }","commit_id":"a5575b4fbe85d30bc6cb7efacd2fefe3fb857455","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public RmdOutputPresenter(Display view,\n                             GlobalDisplay globalDisplay,\n                             Binder binder,\n                             final Commands commands,\n                             EventBus eventBus)\n   {\n      view_ = view;\n      globalDisplay_ = globalDisplay;\n      \n      binder.bind(commands, this);  \n   }","id":26312,"modified_method":"@Inject\n   public RmdOutputPresenter(Display view,\n                             GlobalDisplay globalDisplay,\n                             Binder binder,\n                             final Commands commands,\n                             EventBus eventBus)\n   {\n      view_ = view;\n      globalDisplay_ = globalDisplay;\n      \n      binder.bind(commands, this);  \n      \n      initializeEvents();\n   }","commit_id":"a5575b4fbe85d30bc6cb7efacd2fefe3fb857455","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void showRenderResult(RmdRenderResult result)\n   {\n      Window.setTitle(result.getOutputFile());\n      presenter_.showOutput(result);\n   }","id":26313,"modified_method":"private void showRenderResult(RmdPreviewParams params)\n   {\n      Window.setTitle(params.getOutputFile());\n      presenter_.showOutput(params);\n   }","commit_id":"a5575b4fbe85d30bc6cb7efacd2fefe3fb857455","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected void onInitialize(LayoutPanel mainPanel, JavaScriptObject params)\n   {\n      presenter_ = pPresenter_.get();\n      showRenderResult((RmdRenderResult) params.cast());\n      \n      // make it fill the containing layout panel\n      Widget presWidget = presenter_.asWidget();\n      mainPanel.add(presWidget);\n      mainPanel.setWidgetLeftRight(presWidget, 0, Unit.PX, 0, Unit.PX);\n      mainPanel.setWidgetTopBottom(presWidget, 0, Unit.PX, 0, Unit.PX);\n   }","id":26314,"modified_method":"@Override\n   protected void onInitialize(LayoutPanel mainPanel, JavaScriptObject params)\n   {\n      presenter_ = pPresenter_.get();\n      showRenderResult((RmdPreviewParams) params.cast());\n      \n      // make it fill the containing layout panel\n      Widget presWidget = presenter_.asWidget();\n      mainPanel.add(presWidget);\n      mainPanel.setWidgetLeftRight(presWidget, 0, Unit.PX, 0, Unit.PX);\n      mainPanel.setWidgetTopBottom(presWidget, 0, Unit.PX, 0, Unit.PX);\n   }","commit_id":"a5575b4fbe85d30bc6cb7efacd2fefe3fb857455","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void reactivate(JavaScriptObject params)\n   {\n      showRenderResult((RmdRenderResult) params.cast());\n   }","id":26315,"modified_method":"@Override\n   public void reactivate(JavaScriptObject params)\n   {\n      showRenderResult((RmdPreviewParams) params.cast());\n   }","commit_id":"a5575b4fbe85d30bc6cb7efacd2fefe3fb857455","url":"https://github.com/rstudio/rstudio"},{"original_method":"protected DDMFormField getDDMFormField(JSONObject jsonObject) {\n\t\tString name = jsonObject.getString(\"name\");\n\t\tString type = jsonObject.getString(\"type\");\n\n\t\tDDMFormField ddmFormField = new DDMFormField(name, type);\n\n\t\tddmFormField.setDataType(jsonObject.getString(\"dataType\"));\n\t\tddmFormField.setIndexType(jsonObject.getString(\"indexType\"));\n\t\tddmFormField.setLocalizable(jsonObject.getBoolean(\"localizable\", true));\n\t\tddmFormField.setMultiple(jsonObject.getBoolean(\"multiple\"));\n\t\tddmFormField.setNamespace(jsonObject.getString(\"fieldNamespace\"));\n\t\tddmFormField.setReadOnly(jsonObject.getBoolean(\"readOnly\"));\n\t\tddmFormField.setRepeatable(jsonObject.getBoolean(\"repeatable\"));\n\t\tddmFormField.setRequired(jsonObject.getBoolean(\"required\"));\n\t\tddmFormField.setShowLabel(jsonObject.getBoolean(\"showLabel\", true));\n\n\t\tsetDDMFormFieldLocalizedValue(\n\t\t\tjsonObject.getJSONObject(\"label\"), ddmFormField.getLabel());\n\t\tsetDDMFormFieldLocalizedValue(\n\t\t\tjsonObject.getJSONObject(\"predefinedValue\"),\n\t\t\tddmFormField.getPredefinedValue());\n\t\tsetDDMFormFieldLocalizedValue(\n\t\t\tjsonObject.getJSONObject(\"style\"), ddmFormField.getStyle());\n\t\tsetDDMFormFieldLocalizedValue(\n\t\t\tjsonObject.getJSONObject(\"tip\"), ddmFormField.getTip());\n\n\t\tif (type.equals(\"radio\") || type.equals(\"select\")) {\n\t\t\tsetDDMFormFieldOptions(\n\t\t\t\tjsonObject.getJSONArray(\"options\"), ddmFormField);\n\t\t}\n\t\telse {\n\t\t\tsetNestedDDMFormField(\n\t\t\t\tjsonObject.getJSONArray(\"nestedFields\"), ddmFormField);\n\t\t}\n\n\t\treturn ddmFormField;\n\t}","id":26316,"modified_method":"protected DDMFormField getDDMFormField(JSONObject jsonObject)\n\t\tthrows PortalException {\n\n\t\tString name = jsonObject.getString(\"name\");\n\t\tString type = jsonObject.getString(\"type\");\n\n\t\tDDMFormField ddmFormField = new DDMFormField(name, type);\n\n\t\tsetDDMFormFieldProperties(jsonObject, ddmFormField);\n\n\t\tsetNestedDDMFormField(\n\t\t\tjsonObject.getJSONArray(\"nestedFields\"), ddmFormField);\n\n\t\treturn ddmFormField;\n\t}","commit_id":"7c113efdcf21e363a75dcd3001b4b07743a4b1dd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void setDDMFormFieldOptions(\n\t\tJSONArray jsonArray, DDMFormField ddmFormField) {\n\n\t\tDDMFormFieldOptions ddmFormFieldOptions = getDDMFormFieldOptions(\n\t\t\tjsonArray);\n\n\t\tddmFormField.setDDMFormFieldOptions(ddmFormFieldOptions);\n\t}","id":26317,"modified_method":"protected void setDDMFormFieldProperties(\n\t\t\tJSONObject jsonObject, DDMFormField ddmFormField)\n\t\tthrows PortalException {\n\n\t\tDDMForm ddmFormFieldTypeSettingsDDMForm =\n\t\t\tgetDDMFormFieldTypeSettingsDDMForm(ddmFormField.getType());\n\n\t\tfor (DDMFormField ddmFormFieldTypeSetting :\n\t\t\t\tddmFormFieldTypeSettingsDDMForm.getDDMFormFields()) {\n\n\t\t\tsetDDMFormFieldProperty(\n\t\t\t\tjsonObject, ddmFormField, ddmFormFieldTypeSetting);\n\t\t}\n\t}","commit_id":"7c113efdcf21e363a75dcd3001b4b07743a4b1dd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void setDDMFormFieldLocalizedValuesDefaultLocale(\n\t\tDDMFormField ddmFormField, Locale defaultLocale) {\n\n\t\tLocalizedValue label = ddmFormField.getLabel();\n\n\t\tlabel.setDefaultLocale(defaultLocale);\n\n\t\tLocalizedValue predefinedValue = ddmFormField.getPredefinedValue();\n\n\t\tpredefinedValue.setDefaultLocale(defaultLocale);\n\n\t\tLocalizedValue style = ddmFormField.getStyle();\n\n\t\tstyle.setDefaultLocale(defaultLocale);\n\n\t\tLocalizedValue tip = ddmFormField.getTip();\n\n\t\ttip.setDefaultLocale(defaultLocale);\n\n\t\tDDMFormFieldOptions ddmFormFieldOptions =\n\t\t\tddmFormField.getDDMFormFieldOptions();\n\n\t\tddmFormFieldOptions.setDefaultLocale(defaultLocale);\n\n\t\tfor (DDMFormField nestedDDMFormField :\n\t\t\t\tddmFormField.getNestedDDMFormFields()) {\n\n\t\t\tsetDDMFormFieldLocalizedValuesDefaultLocale(\n\t\t\t\tnestedDDMFormField, defaultLocale);\n\t\t}\n\t}","id":26318,"modified_method":"protected void setDDMFormFieldLocalizedValuesDefaultLocale(\n\t\tDDMFormField ddmFormField, Locale defaultLocale) {\n\n\t\tsetDDMFormFieldLocalizedValueDefaultLocale(\n\t\t\tddmFormField.getLabel(), defaultLocale);\n\n\t\tsetDDMFormFieldLocalizedValueDefaultLocale(\n\t\t\tddmFormField.getPredefinedValue(), defaultLocale);\n\n\t\tsetDDMFormFieldLocalizedValueDefaultLocale(\n\t\t\tddmFormField.getStyle(), defaultLocale);\n\n\t\tsetDDMFormFieldLocalizedValueDefaultLocale(\n\t\t\tddmFormField.getTip(), defaultLocale);\n\n\t\tDDMFormFieldOptions ddmFormFieldOptions =\n\t\t\tddmFormField.getDDMFormFieldOptions();\n\n\t\tif (ddmFormFieldOptions != null) {\n\t\t\tddmFormFieldOptions.setDefaultLocale(defaultLocale);\n\t\t}\n\n\t\tfor (DDMFormField nestedDDMFormField :\n\t\t\t\tddmFormField.getNestedDDMFormFields()) {\n\n\t\t\tsetDDMFormFieldLocalizedValuesDefaultLocale(\n\t\t\t\tnestedDDMFormField, defaultLocale);\n\t\t}\n\t}","commit_id":"7c113efdcf21e363a75dcd3001b4b07743a4b1dd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void setDDMFormFieldLocalizedValue(\n\t\tJSONObject jsonObject, LocalizedValue localizedValue) {\n\n\t\tif (jsonObject == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tIterator<String> itr = jsonObject.keys();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tString languageId = itr.next();\n\n\t\t\tlocalizedValue.addString(\n\t\t\t\tLocaleUtil.fromLanguageId(languageId),\n\t\t\t\tjsonObject.getString(languageId));\n\t\t}\n\t}","id":26319,"modified_method":"protected void setDDMFormFieldLocalizedValueDefaultLocale(\n\t\tLocalizedValue localizedValue, Locale defaultLocale) {\n\n\t\tif (localizedValue == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tlocalizedValue.setDefaultLocale(defaultLocale);\n\t}","commit_id":"7c113efdcf21e363a75dcd3001b4b07743a4b1dd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addLocalizedProperty(\n\t\tJSONObject jsonObject, String propertyName,\n\t\tLocalizedValue localizedValue) {\n\n\t\tMap<Locale, String> values = localizedValue.getValues();\n\n\t\tif (values.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tjsonObject.put(propertyName, toJSONObject(localizedValue));\n\t}","id":26320,"modified_method":"protected void addProperty(\n\t\tJSONObject jsonObject, String propertyName, Object propertyValue) {\n\n\t\tif (propertyValue == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tjsonObject.put(propertyName, propertyValue);\n\t}","commit_id":"7c113efdcf21e363a75dcd3001b4b07743a4b1dd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected JSONArray toJSONArray(DDMFormFieldOptions ddmFormFieldOptions) {\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (String optionValue : ddmFormFieldOptions.getOptionsValues()) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tjsonObject.put(\"value\", optionValue);\n\t\t\tjsonObject.put(\n\t\t\t\t\"label\",\n\t\t\t\ttoJSONObject(ddmFormFieldOptions.getOptionLabels(optionValue)));\n\n\t\t\tjsonArray.put(jsonObject);\n\t\t}\n\n\t\treturn jsonArray;\n\t}","id":26321,"modified_method":"protected JSONArray toJSONArray(DDMFormFieldOptions ddmFormFieldOptions) {\n\t\tSet<String> optionValues = ddmFormFieldOptions.getOptionsValues();\n\n\t\tif (optionValues.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (String optionValue : optionValues) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tjsonObject.put(\"value\", optionValue);\n\t\t\tjsonObject.put(\n\t\t\t\t\"label\",\n\t\t\t\ttoJSONObject(ddmFormFieldOptions.getOptionLabels(optionValue)));\n\n\t\t\tjsonArray.put(jsonObject);\n\t\t}\n\n\t\treturn jsonArray;\n\t}","commit_id":"7c113efdcf21e363a75dcd3001b4b07743a4b1dd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected JSONObject toJSONObject(LocalizedValue localizedValue) {\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tfor (Locale availableLocale : localizedValue.getAvailableLocales()) {\n\t\t\tjsonObject.put(\n\t\t\t\tLocaleUtil.toLanguageId(availableLocale),\n\t\t\t\tlocalizedValue.getString(availableLocale));\n\t\t}\n\n\t\treturn jsonObject;\n\t}","id":26322,"modified_method":"protected JSONObject toJSONObject(LocalizedValue localizedValue) {\n\t\tMap<Locale, String> values = localizedValue.getValues();\n\n\t\tif (values.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tfor (Locale availableLocale : localizedValue.getAvailableLocales()) {\n\t\t\tjsonObject.put(\n\t\t\t\tLocaleUtil.toLanguageId(availableLocale),\n\t\t\t\tlocalizedValue.getString(availableLocale));\n\t\t}\n\n\t\treturn jsonObject;\n\t}","commit_id":"7c113efdcf21e363a75dcd3001b4b07743a4b1dd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected JSONObject toJSONObject(DDMFormField ddmFormField) {\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\taddLocalizedProperty(jsonObject, \"label\", ddmFormField.getLabel());\n\t\taddLocalizedProperty(\n\t\t\tjsonObject, \"predefinedValue\", ddmFormField.getPredefinedValue());\n\t\taddLocalizedProperty(jsonObject, \"style\", ddmFormField.getStyle());\n\t\taddLocalizedProperty(jsonObject, \"tip\", ddmFormField.getTip());\n\t\taddNestedFields(jsonObject, ddmFormField.getNestedDDMFormFields());\n\t\taddOptions(jsonObject, ddmFormField.getDDMFormFieldOptions());\n\t\taddSimpleProperties(jsonObject, ddmFormField);\n\n\t\treturn jsonObject;\n\t}","id":26323,"modified_method":"protected JSONObject toJSONObject(DDMFormField ddmFormField) {\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\taddProperties(jsonObject, ddmFormField);\n\n\t\taddNestedFields(jsonObject, ddmFormField.getNestedDDMFormFields());\n\n\t\treturn jsonObject;\n\t}","commit_id":"7c113efdcf21e363a75dcd3001b4b07743a4b1dd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addOptions(\n\t\tJSONObject jsonObject, DDMFormFieldOptions ddmFormFieldOptions) {\n\n\t\tSet<String> optionValues = ddmFormFieldOptions.getOptionsValues();\n\n\t\tif (optionValues.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tjsonObject.put(\"options\", toJSONArray(ddmFormFieldOptions));\n\t}","id":26324,"modified_method":"protected void addProperty(\n\t\tJSONObject jsonObject, DDMFormField ddmFormField,\n\t\tDDMFormField ddmFormFieldTypeSetting) {\n\n\t\tObject property = ddmFormField.getProperty(\n\t\t\tddmFormFieldTypeSetting.getName());\n\n\t\tif (property == null) {\n\t\t\treturn;\n\t\t}\n\n\t\taddProperty(\n\t\t\tjsonObject, ddmFormFieldTypeSetting.getName(),\n\t\t\tserializeDDMFormFieldProperty(property, ddmFormFieldTypeSetting));\n\t}","commit_id":"7c113efdcf21e363a75dcd3001b4b07743a4b1dd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addSimpleProperties(\n\t\tJSONObject jsonObject, DDMFormField ddmFormField) {\n\n\t\tjsonObject.put(\"dataType\", ddmFormField.getDataType());\n\t\tjsonObject.put(\"fieldNamespace\", ddmFormField.getNamespace());\n\t\tjsonObject.put(\"indexType\", ddmFormField.getIndexType());\n\t\tjsonObject.put(\"localizable\", ddmFormField.isLocalizable());\n\t\tjsonObject.put(\"multiple\", ddmFormField.isMultiple());\n\t\tjsonObject.put(\"name\", ddmFormField.getName());\n\t\tjsonObject.put(\"readOnly\", ddmFormField.isReadOnly());\n\t\tjsonObject.put(\"repeatable\", ddmFormField.isRepeatable());\n\t\tjsonObject.put(\"required\", ddmFormField.isRequired());\n\t\tjsonObject.put(\"showLabel\", ddmFormField.isShowLabel());\n\t\tjsonObject.put(\"type\", ddmFormField.getType());\n\t}","id":26325,"modified_method":"protected void addProperties(\n\t\tJSONObject jsonObject, DDMFormField ddmFormField) {\n\n\t\tDDMForm ddmFormFieldTypeSettingsDDMForm =\n\t\t\tgetDDMFormFieldTypeSettingsDDMForm(ddmFormField.getType());\n\n\t\tfor (DDMFormField ddmFormFieldTypeSetting :\n\t\t\t\tddmFormFieldTypeSettingsDDMForm.getDDMFormFields()) {\n\n\t\t\taddProperty(jsonObject, ddmFormField, ddmFormFieldTypeSetting);\n\t\t}\n\t}","commit_id":"7c113efdcf21e363a75dcd3001b4b07743a4b1dd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void setDDMFormFieldLocalizedValuesDefaultLocale(\n\t\tDDMFormField ddmFormField, Locale defaultLocale) {\n\n\t\tLocalizedValue label = ddmFormField.getLabel();\n\n\t\tlabel.setDefaultLocale(defaultLocale);\n\n\t\tLocalizedValue predefinedValue = ddmFormField.getPredefinedValue();\n\n\t\tpredefinedValue.setDefaultLocale(defaultLocale);\n\n\t\tLocalizedValue style = ddmFormField.getStyle();\n\n\t\tstyle.setDefaultLocale(defaultLocale);\n\n\t\tLocalizedValue tip = ddmFormField.getTip();\n\n\t\ttip.setDefaultLocale(defaultLocale);\n\n\t\tDDMFormFieldOptions ddmFormFieldOptions =\n\t\t\tddmFormField.getDDMFormFieldOptions();\n\n\t\tddmFormFieldOptions.setDefaultLocale(defaultLocale);\n\n\t\tfor (DDMFormField nestedDDMFormField :\n\t\t\t\tddmFormField.getNestedDDMFormFields()) {\n\n\t\t\tsetDDMFormFieldLocalizedValuesDefaultLocale(\n\t\t\t\tnestedDDMFormField, defaultLocale);\n\t\t}\n\t}","id":26326,"modified_method":"protected void setDDMFormFieldLocalizedValuesDefaultLocale(\n\t\tDDMFormField ddmFormField, Locale defaultLocale) {\n\n\t\tsetDDMFormFieldLocalizedValueDefaultLocale(\n\t\t\tddmFormField.getLabel(), defaultLocale);\n\n\t\tsetDDMFormFieldLocalizedValueDefaultLocale(\n\t\t\tddmFormField.getPredefinedValue(), defaultLocale);\n\n\t\tsetDDMFormFieldLocalizedValueDefaultLocale(\n\t\t\tddmFormField.getStyle(), defaultLocale);\n\n\t\tsetDDMFormFieldLocalizedValueDefaultLocale(\n\t\t\tddmFormField.getTip(), defaultLocale);\n\n\t\tDDMFormFieldOptions ddmFormFieldOptions =\n\t\t\tddmFormField.getDDMFormFieldOptions();\n\n\t\tif (ddmFormFieldOptions != null) {\n\t\t\tddmFormFieldOptions.setDefaultLocale(defaultLocale);\n\t\t}\n\n\t\tfor (DDMFormField nestedDDMFormField :\n\t\t\t\tddmFormField.getNestedDDMFormFields()) {\n\n\t\t\tsetDDMFormFieldLocalizedValuesDefaultLocale(\n\t\t\t\tnestedDDMFormField, defaultLocale);\n\t\t}\n\t}","commit_id":"7c113efdcf21e363a75dcd3001b4b07743a4b1dd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Send the mail.\n     *\n     * @param item the queue item containing all the data for sending the mail\n     */\n    protected void sendMail(MailSenderQueueItem item)\n    {\n        MimeMessage message = item.getMessage();\n        MailResultListener listener = item.getListener();\n\n        try {\n            // Step 1: If the current Session in use is different from the one passed then close the current Transport,\n            // get a new one and reconnect. Also do that every 100 mails sent.\n            // TODO: explain why!\n            // TODO: Also explain why we don't use Transport.send()\n            if (item.getSession() != this.currentSession || (this.count % 100) == 0) {\n                closeTransport();\n                this.currentSession = item.getSession();\n                this.currentTransport = this.currentSession.getTransport(\"smtp\");\n                this.currentTransport.connect();\n            } else if (!this.currentTransport.isConnected()) {\n                this.currentTransport.connect();\n            }\n\n            // Step 2: Send the mail\n            this.currentTransport.sendMessage(message, message.getAllRecipients());\n            this.count++;\n\n            // Step 3: Notify the user of the success if a listener has been provided\n            if (listener != null) {\n                listener.onSuccess(message);\n            }\n        } catch (Exception e) {\n            // An error occurred, notify the user if a listener has been provided\n            if (listener != null) {\n                listener.onError(message, e);\n            }\n        }\n    }","id":26327,"modified_method":"/**\n     * Send the mail.\n     *\n     * @param item the queue item containing all the data for sending the mail\n     */\n    protected void sendMail(MailSenderQueueItem item)\n    {\n        MimeMessage message = item.getMessage();\n        MailListener listener = item.getListener();\n        // Mail ready to be sent, notify the user if a listener has been provided\n        if (listener != null) {\n            listener.onPrepare(message);\n        }\n        try {\n            // Step 1: If the current Session in use is different from the one passed then close the current Transport,\n            // get a new one and reconnect. Also do that every 100 mails sent.\n            // TODO: explain why!\n            // TODO: Also explain why we don't use Transport.send()\n            if (item.getSession() != this.currentSession || (this.count % 100) == 0) {\n                closeTransport();\n                this.currentSession = item.getSession();\n                this.currentTransport = this.currentSession.getTransport(\"smtp\");\n                this.currentTransport.connect();\n            } else if (!this.currentTransport.isConnected()) {\n                this.currentTransport.connect();\n            }\n\n            // Step 2: Send the mail\n            this.currentTransport.sendMessage(message, message.getAllRecipients());\n            this.count++;\n\n            // Step 3: Notify the user of the success if a listener has been provided\n            if (listener != null) {\n                listener.onSuccess(message);\n            }\n        } catch (Exception e) {\n            // An error occurred, notify the user if a listener has been provided\n            if (listener != null) {\n                listener.onError(message, e);\n            }\n        }\n    }","commit_id":"fc3041f8d167e78fdace2575ee9eaead8a0764cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void runWhenMailSendingFails() throws Exception\n    {\n        // Create a Session with an invalid host so that it generates an error\n        Properties properties = new Properties();\n        properties.setProperty(\"mail.smtp.host\", \"xwiki-unknown\");\n        Session session = Session.getDefaultInstance(properties);\n        MimeMessage message = new MimeMessage(session);\n        message.setSubject(\"subject\");\n        message.setFrom(InternetAddress.parse(\"john@doe.com\")[0]);\n        DefaultMailResultListener listener = new DefaultMailResultListener();\n        MailSenderQueueItem item = new MailSenderQueueItem(message, session, listener);\n\n        Queue<MailSenderQueueItem> mailQueue = new ConcurrentLinkedQueue<>();\n\n        // Send 2 mails. Both will fail but we want to verify that the second one is processed even though the first\n        // one failed.\n        mailQueue.add(item);\n        mailQueue.add(item);\n\n        DefaultMailSenderThread thread = this.mocker.getComponentUnderTest();\n        thread.startProcessing(mailQueue);\n\n        // This is the real test: we verify that there's been an error while sending each email and that it's been\n        // logged. This also proves that the Mail Sender Thread doesn't stop when there's an error sending an email.\n        boolean success = true;\n        try {\n            long time = System.currentTimeMillis();\n            while (listener.getExceptionQueue().size() != 2) {\n                if (System.currentTimeMillis() - time > 5000L) {\n                    success = false;\n                    break;\n                }\n                Thread.sleep(100L);\n            }\n        } finally {\n            thread.stopProcessing();\n            thread.join();\n        }\n        assertTrue(success);\n    }","id":26328,"modified_method":"@Test\n    public void runWhenMailSendingFails() throws Exception\n    {\n        // Create a Session with an invalid host so that it generates an error\n        Properties properties = new Properties();\n        properties.setProperty(\"mail.smtp.host\", \"xwiki-unknown\");\n        Session session = Session.getDefaultInstance(properties);\n        MimeMessage message = new MimeMessage(session);\n        message.setSubject(\"subject\");\n        message.setFrom(InternetAddress.parse(\"john@doe.com\")[0]);\n        MailListener listener = this.mocker.getInstance(MailListener.class, \"memory\");\n        MailSenderQueueItem item = new MailSenderQueueItem(message, session, listener);\n\n        Queue<MailSenderQueueItem> mailQueue = new ConcurrentLinkedQueue<>();\n\n        // Send 2 mails. Both will fail but we want to verify that the second one is processed even though the first\n        // one failed.\n        mailQueue.add(item);\n        mailQueue.add(item);\n\n        DefaultMailSenderThread thread = this.mocker.getComponentUnderTest();\n        thread.startProcessing(mailQueue);\n\n        // This is the real test: we verify that there's been an error while sending each email and that it's been\n        // logged. This also proves that the Mail Sender Thread doesn't stop when there's an error sending an email.\n        boolean success = true;\n        try {\n            long time = System.currentTimeMillis();\n            while (((Collection<MailStatus>)listener.getErrors()).size() != 2) {\n                if (System.currentTimeMillis() - time > 5000L) {\n                    success = false;\n                    break;\n                }\n                Thread.sleep(100L);\n            }\n        } finally {\n            thread.stopProcessing();\n            thread.join();\n        }\n        assertTrue(success);\n    }","commit_id":"fc3041f8d167e78fdace2575ee9eaead8a0764cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return an optional listener to call when the mail is sent successfully or when there's an error\n     */\n    public MailResultListener getListener()\n    {\n        return this.listener;\n    }","id":26329,"modified_method":"/**\n     * @return an optional listener to call when the mail is sent successfully or when there's an error\n     */\n    public MailListener getListener()\n    {\n        return this.listener;\n    }","commit_id":"fc3041f8d167e78fdace2575ee9eaead8a0764cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param message see {@link #getMessage()}\n     * @param session see {@link #getSession()}\n     * @param listener see {@link #getListener()}\n     */\n    public MailSenderQueueItem(MimeMessage message, Session session, MailResultListener listener)\n    {\n        this.message = message;\n        this.session = session;\n        this.listener = listener;\n        this.threadId = Thread.currentThread().getId();\n    }","id":26330,"modified_method":"/**\n     * @param message see {@link #getMessage()}\n     * @param session see {@link #getSession()}\n     * @param listener see {@link #getListener()}\n     */\n    public MailSenderQueueItem(MimeMessage message, Session session, MailListener listener)\n    {\n        this.message = message;\n        this.session = session;\n        this.listener = listener;\n        this.threadId = Thread.currentThread().getId();\n    }","commit_id":"fc3041f8d167e78fdace2575ee9eaead8a0764cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param message the wrapped {@link javax.mail.internet.MimeMessage}\n     * @param session the JavaMail session used to send the mail\n     * @param mailSender the component to send the mail\n     * @param execution used to get the Execution Context and store an error in it if the send fails\n     * @param configuration the mail sender configuration component\n     * @param componentManager used to dynamically load all {@link MimeBodyPartFactory} components\n     */\n    // Note: This method is package private voluntarily so that it's not part of the API (as this class is public),\n    // since it's only needed by the MailSenderScriptService and nobody else should be able to construct an instance\n    // of it!\n    MimeMessageWrapper(ExtendedMimeMessage message, Session session, MailSender mailSender, Execution execution,\n        MailSenderConfiguration configuration, ComponentManager componentManager)\n    {\n        this.message = message;\n        this.session = session;\n        this.mailSender = mailSender;\n        this.execution = execution;\n        this.configuration = configuration;\n        this.componentManager = componentManager;\n        this.listener = new DefaultMailResultListener();\n    }","id":26331,"modified_method":"/**\n     * @param message the wrapped {@link javax.mail.internet.MimeMessage}\n     * @param session the JavaMail session used to send the mail\n     * @param mailSender the component to send the mail\n     * @param execution used to get the Execution Context and store an error in it if the send fails\n     * @param configuration the mail sender configuration component\n     * @param componentManager used to dynamically load all {@link MimeBodyPartFactory} components\n     */\n    // Note: This method is package private voluntarily so that it's not part of the API (as this class is public),\n    // since it's only needed by the MailSenderScriptService and nobody else should be able to construct an instance\n    // of it!\n    MimeMessageWrapper(ExtendedMimeMessage message, Session session, MailSender mailSender, Execution execution,\n        MailSenderConfiguration configuration, ComponentManager componentManager)\n    {\n        this.message = message;\n        this.session = session;\n        this.mailSender = mailSender;\n        this.execution = execution;\n        this.configuration = configuration;\n        this.componentManager = componentManager;\n    }","commit_id":"fc3041f8d167e78fdace2575ee9eaead8a0764cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Send the mail synchronously (wait till the message is sent). Any error can be retrieved by calling\n     * {@link #getErrors()}.\n     */\n    public void send()\n    {\n        try {\n            checkPermissions();\n            this.mailSender.send(getMessage(), this.session);\n        } catch (MessagingException e) {\n            // Save the exception for reporting through the script services's getError() API\n            setError(e);\n        }\n    }","id":26332,"modified_method":"/**\n     * Send the mail synchronously (wait till the message is sent). Any error can be retrieved by calling\n     * {@link #getErrors()}.\n     */\n    public UUID send()\n    {\n        try {\n            checkPermissions();\n            return this.mailSender.send(getMessage(), this.session);\n        } catch (MessagingException e) {\n            // Save the exception for reporting through the script services's getError() API\n            setError(e);\n            return null;\n        }\n    }","commit_id":"fc3041f8d167e78fdace2575ee9eaead8a0764cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Send the mail asynchronously. You should use {@link #waitTillSent(long)} to make it blocking or simply use\n     * {@link #send()}. Any error can be retrieved by calling {@link #getErrors()}.\n     */\n    public void sendAsynchronously()\n    {\n        try {\n            checkPermissions();\n        } catch (MessagingException e) {\n            // Save the exception for reporting through the script services's getError() API\n            setError(e);\n            // Don't send the mail!\n            return;\n        }\n\n        // NOTE: we don't throw any error since the message is sent asynchronously. All errors can be found using\n        // the passed listener.\n        this.mailSender.sendAsynchronously(getMessage(), this.session, this.listener);\n    }","id":26333,"modified_method":"/**\n     * Send the mail asynchronously. You should use {@link #waitTillSent(long)} to make it blocking or simply use\n     * {@link #send()}. Any error can be retrieved by calling {@link #getErrors()}.\n     */\n    public UUID sendAsynchronously() throws MessagingException\n    {\n        try {\n            checkPermissions();\n        } catch (MessagingException e) {\n            // Save the exception for reporting through the script services's getError() API\n            setError(e);\n            // Don't send the mail!\n            return null;\n        }\n\n        // NOTE: we don't throw any error since the message is sent asynchronously. All errors can be found using\n        // the passed listener.\n        UUID Sender = this.mailSender.sendAsynchronously(getMessage(), this.session, this.listener);\n        return Sender;\n    }","commit_id":"fc3041f8d167e78fdace2575ee9eaead8a0764cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return a queue containing top errors raised during the send of all emails in the queue for the current thread\n     *         when the sending was done asynchronously. If the send was done synchronously and an error happened\n     *         then it's available through the script service's {@code #getLastError()} method.\n     */\n    public BlockingQueue<Exception> getErrors()\n    {\n        return this.listener.getExceptionQueue();\n    }","id":26334,"modified_method":"/**\n     * @return a queue containing top errors raised during the send of all emails in the queue for the current thread\n     *         when the sending was done asynchronously. If the send was done synchronously and an error happened\n     *         then it's available through the script service's {@code #getLastError()} method.\n     */\n    public Iterator<MailStatus> getErrors()\n    {\n        return this.listener.getErrors();\n    }","commit_id":"fc3041f8d167e78fdace2575ee9eaead8a0764cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void sendTextMail() throws Exception\n    {\n        // Set the EC\n        Execution execution = this.componentManager.getInstance(Execution.class);\n        execution.setContext(new ExecutionContext());\n\n        MimeMessageWrapper message = this.scriptService.createMessage(\"john@doe.com\", \"subject\");\n        message.addPart(\"text/plain\", \"some text here\");\n\n        // Send 3 mails (3 times the same mail) to verify we can send several emails at once.\n        message.sendAsynchronously();\n        message.sendAsynchronously();\n        message.sendAsynchronously();\n        message.waitTillSent(10000L);\n\n        // Verify that there are no errors\n        assertEquals(0, message.getErrors().size());\n\n        // Verify that the mails have been received (wait maximum 10 seconds).\n        this.mail.waitForIncomingEmail(10000L, 3);\n        MimeMessage[] messages = this.mail.getReceivedMessages();\n\n        assertEquals(3, messages.length);\n        assertEquals(\"subject\", messages[0].getHeader(\"Subject\")[0]);\n        assertEquals(\"john@doe.com\", messages[0].getHeader(\"To\")[0]);\n\n        assertEquals(1, ((MimeMultipart) messages[0].getContent()).getCount());\n\n        BodyPart textBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(0);\n        assertEquals(\"text/plain\", textBodyPart.getHeader(\"Content-Type\")[0]);\n        assertEquals(\"some text here\", textBodyPart.getContent());\n    }","id":26335,"modified_method":"@Test\n    public void sendTextMail() throws Exception\n    {\n        // Set the EC\n        Execution execution = this.componentManager.getInstance(Execution.class);\n        execution.setContext(new ExecutionContext());\n\n        MimeMessageWrapper message = this.scriptService.createMessage(\"john@doe.com\", \"subject\");\n        message.addPart(\"text/plain\", \"some text here\");\n\n        // Send 3 mails (3 times the same mail) to verify we can send several emails at once.\n        message.sendAsynchronously();\n        message.sendAsynchronously();\n        message.sendAsynchronously();\n        message.waitTillSent(10000L);\n\n        // Verify that there are no errors\n        assertFalse(message.getErrors().hasNext());\n\n        // Verify that the mails have been received (wait maximum 10 seconds).\n        this.mail.waitForIncomingEmail(10000L, 3);\n        MimeMessage[] messages = this.mail.getReceivedMessages();\n\n        assertEquals(3, messages.length);\n        assertEquals(\"subject\", messages[0].getHeader(\"Subject\")[0]);\n        assertEquals(\"john@doe.com\", messages[0].getHeader(\"To\")[0]);\n\n        assertEquals(1, ((MimeMultipart) messages[0].getContent()).getCount());\n\n        BodyPart textBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(0);\n        assertEquals(\"text/plain\", textBodyPart.getHeader(\"Content-Type\")[0]);\n        assertEquals(\"some text here\", textBodyPart.getContent());\n    }","commit_id":"fc3041f8d167e78fdace2575ee9eaead8a0764cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void sendHTMLAndCalendarInvitationMail() throws Exception\n    {\n        // Set the EC\n        Execution execution = this.componentManager.getInstance(Execution.class);\n        execution.setContext(new ExecutionContext());\n\n        MimeMessageWrapper message = this.scriptService.createMessage(\"john@doe.com\", \"subject\");\n        message.addPart(\"text/html\", \"<font size=\\\"\\\\\\\"2\\\\\\\"\\\">simple meeting invitation<\/font>\");\n        String calendarContent = \"BEGIN:VCALENDAR\\r\\n\"\n            + \"METHOD:REQUEST\\r\\n\"\n            + \"PRODID: Meeting\\r\\n\"\n            + \"VERSION:2.0\\r\\n\"\n            + \"BEGIN:VEVENT\\r\\n\"\n            + \"DTSTAMP:20140616T164100\\r\\n\"\n            + \"DTSTART:20140616T164100\\r\\n\"\n            + \"DTEND:20140616T194100\\r\\n\"\n            + \"SUMMARY:test request\\r\\n\"\n            + \"UID:324\\r\\n\"\n            + \"ATTENDEE;ROLE=REQ-PARTICIPANT;PARTSTAT=NEEDS-ACTION;RSVP=TRUE:MAILTO:john@doe.com\\r\\n\"\n            + \"ORGANIZER:MAILTO:john@doe.com\\r\\n\"\n            + \"LOCATION:on the net\\r\\n\"\n            + \"DESCRIPTION:learn some stuff\\r\\n\"\n            + \"SEQUENCE:0\\r\\n\"\n            + \"PRIORITY:5\\r\\n\"\n            + \"CLASS:PUBLIC\\r\\n\"\n            + \"STATUS:CONFIRMED\\r\\n\"\n            + \"TRANSP:OPAQUE\\r\\n\"\n            + \"BEGIN:VALARM\\r\\n\"\n            + \"ACTION:DISPLAY\\r\\n\"\n            + \"DESCRIPTION:REMINDER\\r\\n\"\n            + \"TRIGGER;RELATED=START:-PT00H15M00S\\r\\n\"\n            + \"END:VALARM\\r\\n\"\n            + \"END:VEVENT\\r\\n\"\n            + \"END:VCALENDAR\";\n        message.addPart(\"text/calendar;method=CANCEL\", calendarContent,\n            Collections.<String, Object>singletonMap(\"headers\",\n                Collections.singletonMap(\"Content-Class\", \"urn:content-classes:calendarmessage\")));\n\n        message.send();\n\n        // Verify that there are no errors\n        assertEquals(0, message.getErrors().size());\n\n        // Verify that the mail has been received (wait maximum 10 seconds).\n        this.mail.waitForIncomingEmail(10000L, 1);\n        MimeMessage[] messages = this.mail.getReceivedMessages();\n\n        assertEquals(1, messages.length);\n        assertEquals(\"subject\", messages[0].getHeader(\"Subject\")[0]);\n        assertEquals(\"john@doe.com\", messages[0].getHeader(\"To\")[0]);\n\n        assertEquals(2, ((MimeMultipart) messages[0].getContent()).getCount());\n\n        BodyPart htmlBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(0);\n        assertEquals(\"text/html\", htmlBodyPart.getHeader(\"Content-Type\")[0]);\n        assertEquals(\"<font size=\\\"\\\\\\\"2\\\\\\\"\\\">simple meeting invitation<\/font>\", htmlBodyPart.getContent());\n\n        BodyPart calendarBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(1);\n        assertEquals(\"text/calendar;method=CANCEL\", calendarBodyPart.getHeader(\"Content-Type\")[0]);\n        InputStream is = (InputStream) calendarBodyPart.getContent();\n        assertEquals(calendarContent, IOUtils.toString(is));\n    }","id":26336,"modified_method":"@Test\n    public void sendHTMLAndCalendarInvitationMail() throws Exception\n    {\n        // Set the EC\n        Execution execution = this.componentManager.getInstance(Execution.class);\n        execution.setContext(new ExecutionContext());\n\n        MimeMessageWrapper message = this.scriptService.createMessage(\"john@doe.com\", \"subject\");\n        message.addPart(\"text/html\", \"<font size=\\\"\\\\\\\"2\\\\\\\"\\\">simple meeting invitation<\/font>\");\n        String calendarContent = \"BEGIN:VCALENDAR\\r\\n\"\n            + \"METHOD:REQUEST\\r\\n\"\n            + \"PRODID: Meeting\\r\\n\"\n            + \"VERSION:2.0\\r\\n\"\n            + \"BEGIN:VEVENT\\r\\n\"\n            + \"DTSTAMP:20140616T164100\\r\\n\"\n            + \"DTSTART:20140616T164100\\r\\n\"\n            + \"DTEND:20140616T194100\\r\\n\"\n            + \"SUMMARY:test request\\r\\n\"\n            + \"UID:324\\r\\n\"\n            + \"ATTENDEE;ROLE=REQ-PARTICIPANT;PARTSTAT=NEEDS-ACTION;RSVP=TRUE:MAILTO:john@doe.com\\r\\n\"\n            + \"ORGANIZER:MAILTO:john@doe.com\\r\\n\"\n            + \"LOCATION:on the net\\r\\n\"\n            + \"DESCRIPTION:learn some stuff\\r\\n\"\n            + \"SEQUENCE:0\\r\\n\"\n            + \"PRIORITY:5\\r\\n\"\n            + \"CLASS:PUBLIC\\r\\n\"\n            + \"STATUS:CONFIRMED\\r\\n\"\n            + \"TRANSP:OPAQUE\\r\\n\"\n            + \"BEGIN:VALARM\\r\\n\"\n            + \"ACTION:DISPLAY\\r\\n\"\n            + \"DESCRIPTION:REMINDER\\r\\n\"\n            + \"TRIGGER;RELATED=START:-PT00H15M00S\\r\\n\"\n            + \"END:VALARM\\r\\n\"\n            + \"END:VEVENT\\r\\n\"\n            + \"END:VCALENDAR\";\n        message.addPart(\"text/calendar;method=CANCEL\", calendarContent,\n            Collections.<String, Object>singletonMap(\"headers\",\n                Collections.singletonMap(\"Content-Class\", \"urn:content-classes:calendarmessage\")));\n\n        message.send();\n\n        // Verify that there are no errors\n        assertFalse(message.getErrors().hasNext());\n\n        // Verify that the mail has been received (wait maximum 10 seconds).\n        this.mail.waitForIncomingEmail(10000L, 1);\n        MimeMessage[] messages = this.mail.getReceivedMessages();\n\n        assertEquals(1, messages.length);\n        assertEquals(\"subject\", messages[0].getHeader(\"Subject\")[0]);\n        assertEquals(\"john@doe.com\", messages[0].getHeader(\"To\")[0]);\n\n        assertEquals(2, ((MimeMultipart) messages[0].getContent()).getCount());\n\n        BodyPart htmlBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(0);\n        assertEquals(\"text/html\", htmlBodyPart.getHeader(\"Content-Type\")[0]);\n        assertEquals(\"<font size=\\\"\\\\\\\"2\\\\\\\"\\\">simple meeting invitation<\/font>\", htmlBodyPart.getContent());\n\n        BodyPart calendarBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(1);\n        assertEquals(\"text/calendar;method=CANCEL\", calendarBodyPart.getHeader(\"Content-Type\")[0]);\n        InputStream is = (InputStream) calendarBodyPart.getContent();\n        assertEquals(calendarContent, IOUtils.toString(is));\n    }","commit_id":"fc3041f8d167e78fdace2575ee9eaead8a0764cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public List<MailStatus> load(final String batchId, final MailState state) throws MailStoreException\n    {\n        XWikiHibernateBaseStore store = (XWikiHibernateBaseStore) this.hibernateStore;\n        try {\n            return store.executeRead(this.contextProvider.get(),\n                new XWikiHibernateBaseStore.HibernateCallback<List<MailStatus>>()\n                {\n                    @Override public List<MailStatus> doInHibernate(Session session)\n                        throws HibernateException, XWikiException\n                    {\n                        Query query =\n                            session.createQuery(FROM_QUERY + \" where mail_batchid=:batchid an mail_status=:state\");\n                        query.setParameter(\"batchid\", batchId).setParameter(\"state\", state);\n                        List<MailStatus> queryResult = (List<MailStatus>) query.list();\n                        return queryResult;\n                    }\n                });\n        } catch (Exception e) {\n            throw new MailStoreException(String.format(\"Failed to load mail statuses \"\n                + \"(for batch id [%s] and state [%s]) from the database.\", batchId, state), e);\n        }\n    }","id":26337,"modified_method":"@Override\n    public List<MailStatus> load(final String batchId, final MailState state) throws MailStoreException\n    {\n        XWikiHibernateBaseStore store = (XWikiHibernateBaseStore) this.hibernateStore;\n        try {\n            return store.executeRead(this.contextProvider.get(),\n                new XWikiHibernateBaseStore.HibernateCallback<List<MailStatus>>()\n                {\n                    @Override public List<MailStatus> doInHibernate(Session session)\n                        throws HibernateException, XWikiException\n                    {\n                        Query query =\n                            session.createQuery(FROM_QUERY + \" where mail_batchid=:batchid and mail_status=:state\");\n                        query.setParameter(\"batchid\", batchId).setParameter(\"state\", state);\n                        List<MailStatus> queryResult = (List<MailStatus>) query.list();\n                        return queryResult;\n                    }\n                });\n        } catch (Exception e) {\n            throw new MailStoreException(String.format(\"Failed to load mail statuses \"\n                + \"(for batch id [%s] and state [%s]) from the database.\", batchId, state), e);\n        }\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public UUID sendAsynchronously(Iterable<? extends MimeMessage> messages, Session session, MailListener listener)\n    {\n        UUID batchId = UUID.randomUUID();\n\n        // Pass the current wiki so that the mail message will be prepared and sent in the context of that wiki.\n        String wikiId = this.modelContext.getCurrentEntityReference().extractReference(EntityType.WIKI).getName();\n\n        getMailQueue().add(new MailSenderQueueItem(messages, session, listener, batchId, wikiId));\n\n        return batchId;\n    }","id":26338,"modified_method":"@Override\n    public MailResult sendAsynchronously(Iterable<? extends MimeMessage> messages, Session session,\n        MailListener listener)\n    {\n        UUID batchId = UUID.randomUUID();\n\n        // Pass the current wiki so that the mail message will be prepared and sent in the context of that wiki.\n        String wikiId = this.modelContext.getCurrentEntityReference().extractReference(EntityType.WIKI).getName();\n\n        this.mailQueueManager.addToQueue(new MailSenderQueueItem(messages, session, listener, batchId, wikiId));\n\n        return new DefaultMailResult(batchId, this.mailQueueManager);\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void initialize() throws InitializationException\n    {\n        // Start the Mail Sending Thread\n        this.mailSenderRunnable = new MailSenderRunnable(getMailQueue(), this.configuration, this.xwikiContextProvider,\n            this.executionContextManager);\n        this.mailSenderThread = new Thread(this.mailSenderRunnable);\n        this.mailSenderThread.setName(\"Mail Sender Thread\");\n        this.mailSenderThread.start();\n    }","id":26339,"modified_method":"@Override\n    public void initialize() throws InitializationException\n    {\n        this.mailQueueManager = new MailQueueManager();\n\n        // Start the Mail Sending Thread\n        this.mailSenderRunnable = new MailSenderRunnable(this.mailQueueManager, this.configuration,\n            this.xwikiContextProvider, this.executionContextManager);\n        this.mailSenderThread = new Thread(this.mailSenderRunnable);\n        this.mailSenderThread.setName(\"Mail Sender Thread\");\n        this.mailSenderThread.start();\n\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public UUID send(Iterable<? extends MimeMessage> messages, Session session) throws MessagingException\n    {\n        MailListener listener = getListener(\"memory\");\n        UUID batchId = sendAsynchronously(messages, session, listener);\n        waitTillSent(Long.MAX_VALUE);\n        return batchId;\n    }","id":26340,"modified_method":"@Override\n    public MailResult send(Iterable<? extends MimeMessage> messages, Session session)\n        throws MessagingException\n    {\n        MailListener listener = getListener(\"memory\");\n        MailResult result = sendAsynchronously(messages, session, listener);\n        result.waitTillSent(Long.MAX_VALUE);\n\n        // If some mails have failed to be sent, then raise an error\n        Iterator<MailStatus> statuses = listener.getMailStatusResult().getByState(MailState.FAILED);\n        if (statuses.hasNext()) {\n            StringBuilder builder =\n                new StringBuilder(\"Some messages have failed to be sent for the following reasons: [\");\n            while (statuses.hasNext()) {\n                MailStatus status = statuses.next();\n                builder.append(status.getError());\n            }\n            builder.append(']');\n            throw new MessagingException(builder.toString());\n        }\n\n        return result;\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private MailListener getListener(String hint) throws MessagingException\n    {\n        MailListener listener;\n        try {\n            listener = this.componentManager.getInstance(MailListener.class, hint);\n        } catch (ComponentLookupException e) {\n            throw new MessagingException(String.format(\"Failed to locate [%s] Event listener. \", hint), e);\n        }\n        return listener;\n    }","id":26341,"modified_method":"private MailListener getListener(String hint) throws MessagingException\n    {\n        MailListener listener;\n        try {\n            listener = this.componentManager.getInstance(MailListener.class, hint);\n        } catch (ComponentLookupException e) {\n            throw new MessagingException(String.format(\"Failed to locate Mail listener [%s].\", hint), e);\n        }\n        return listener;\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void sendTextMail() throws Exception\n    {\n        // Step 1: Create a JavaMail Session\n        Session session = Session.getInstance(this.configuration.getAllProperties());\n\n        // Step 2: Create the Message to send\n        MimeMessage message = new MimeMessage(session);\n        message.setSubject(\"subject\");\n        message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(\"john@doe.com\"));\n\n        // Step 3: Add the Message Body\n        Multipart multipart = new MimeMultipart(\"mixed\");\n        // Add text in the body\n        multipart.addBodyPart(this.defaultBodyPartFactory.create(\"some text here\",\n            Collections.<String, Object>singletonMap(\"mimetype\", \"text/plain\")));\n        message.setContent(multipart);\n\n        // We also test using some default BCC addresses from configuration in this test\n        this.configuration.setBCCAddresses(Arrays.asList(\"bcc1@doe.com\", \"bcc2@doe.com\"));\n\n        // Step 4: Send the mail and wait for it to be sent\n        // Send 3 mails (3 times the same mail) to verify we can send several emails at once.\n        this.sender.sendAsynchronously(Arrays.asList(message, message, message), session, this.listener);\n\n        // Verify that the mails have been received (wait maximum 10 seconds).\n        this.mail.waitForIncomingEmail(10000L, 3);\n        MimeMessage[] messages = this.mail.getReceivedMessages();\n\n        // Note: we're receiving 9 messages since we sent 3 with 3 recipients (2 BCC and 1 to)!\n        assertEquals(9, messages.length);\n\n        // Assert the email parts that are the same for all mails\n        assertEquals(\"subject\", messages[0].getHeader(\"Subject\", null));\n        assertEquals(1, ((MimeMultipart) messages[0].getContent()).getCount());\n        BodyPart textBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(0);\n        assertEquals(\"text/plain\", textBodyPart.getHeader(\"Content-Type\")[0]);\n        assertEquals(\"some text here\", textBodyPart.getContent());\n        assertEquals(\"john@doe.com\", messages[0].getHeader(\"To\", null));\n\n        // Note: We cannot assert that the BCC worked since by definition BCC information are not visible in received\n        // messages ;) But we chekced that we received 9 emails above so that's good enough.\n    }","id":26342,"modified_method":"@Test\n    public void sendTextMail() throws Exception\n    {\n        // Step 1: Create a JavaMail Session\n        Session session = Session.getInstance(this.configuration.getAllProperties());\n\n        // Step 2: Create the Message to send\n        MimeMessage message = new MimeMessage(session);\n        message.setSubject(\"subject\");\n        message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(\"john@doe.com\"));\n\n        // Step 3: Add the Message Body\n        Multipart multipart = new MimeMultipart(\"mixed\");\n        // Add text in the body\n        multipart.addBodyPart(this.defaultBodyPartFactory.create(\"some text here\",\n            Collections.<String, Object>singletonMap(\"mimetype\", \"text/plain\")));\n        message.setContent(multipart);\n\n        // We also test using some default BCC addresses from configuration in this test\n        this.configuration.setBCCAddresses(Arrays.asList(\"bcc1@doe.com\", \"bcc2@doe.com\"));\n\n        // Step 4: Send the mail and wait for it to be sent\n        // Send 3 mails (3 times the same mail) to verify we can send several emails at once.\n        MailListener memoryMailListener = this.componentManager.getInstance(MailListener.class, \"memory\");\n        this.sender.sendAsynchronously(Arrays.asList(message, message, message), session, memoryMailListener);\n\n        // Note: we don't test status reporting from the listener since this is already tested in the\n        // ScriptingIntegrartionTest test class.\n\n        // Verify that the mails have been received (wait maximum 10 seconds).\n        this.mail.waitForIncomingEmail(10000L, 3);\n        MimeMessage[] messages = this.mail.getReceivedMessages();\n\n        // Note: we're receiving 9 messages since we sent 3 with 3 recipients (2 BCC and 1 to)!\n        assertEquals(9, messages.length);\n\n        // Assert the email parts that are the same for all mails\n        assertEquals(\"subject\", messages[0].getHeader(\"Subject\", null));\n        assertEquals(1, ((MimeMultipart) messages[0].getContent()).getCount());\n        BodyPart textBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(0);\n        assertEquals(\"text/plain\", textBodyPart.getHeader(\"Content-Type\")[0]);\n        assertEquals(\"some text here\", textBodyPart.getContent());\n        assertEquals(\"john@doe.com\", messages[0].getHeader(\"To\", null));\n\n        // Note: We cannot assert that the BCC worked since by definition BCC information are not visible in received\n        // messages ;) But we chekced that we received 9 emails above so that's good enough.\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public String toString()\n    {\n        ToStringBuilder builder = new XWikiToStringBuilder(this);\n        builder.append(\"batchId\", this.batchId);\n        builder.append(\"threadId\", getThreadId());\n        builder.append(\"wikiId\", getWikiId());\n        return builder.toString();\n    }","id":26343,"modified_method":"@Override\n    public String toString()\n    {\n        ToStringBuilder builder = new XWikiToStringBuilder(this);\n        builder.append(\"batchId\", this.batchId);\n        builder.append(\"wikiId\", getWikiId());\n        return builder.toString();\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param messages see {@link #getMessages()}\n     * @param session see {@link #getSession()}\n     * @param listener see {@link #getListener()}\n     * @param batchId see {@link #getBatchId()}\n     * @param wikiId see {@link #getWikiId()}\n     */\n    public MailSenderQueueItem(Iterable<? extends MimeMessage> messages, Session session, MailListener listener,\n        UUID batchId, String wikiId)\n    {\n        this.messages = messages;\n        this.session = session;\n        this.listener = listener;\n        this.batchId = batchId;\n        this.threadId = Thread.currentThread().getId();\n        this.wikiId = wikiId;\n    }","id":26344,"modified_method":"/**\n     * @param messages see {@link #getMessages()}\n     * @param session see {@link #getSession()}\n     * @param listener see {@link #getListener()}\n     * @param batchId see {@link #getBatchId()}\n     * @param wikiId see {@link #getWikiId()}\n     */\n    public MailSenderQueueItem(Iterable<? extends MimeMessage> messages, Session session, MailListener listener,\n        UUID batchId, String wikiId)\n    {\n        this.messages = messages;\n        this.session = session;\n        this.listener = listener;\n        this.batchId = batchId;\n        this.wikiId = wikiId;\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void verifyToString() throws Exception\n    {\n        Session session = Session.getDefaultInstance(new Properties());\n        MimeMessage message = new MimeMessage(session);\n        UUID batchId = UUID.randomUUID();\n        MailSenderQueueItem item = new MailSenderQueueItem(Arrays.asList(message), session, null, batchId, \"wiki\");\n\n        assertEquals(\"batchId = [\" + batchId + \"], threadId = [\" + Thread.currentThread().getId()\n            + \"], wikiId = [wiki]\", item.toString());\n    }","id":26345,"modified_method":"@Test\n    public void verifyToString() throws Exception\n    {\n        Session session = Session.getDefaultInstance(new Properties());\n        MimeMessage message = new MimeMessage(session);\n        UUID batchId = UUID.randomUUID();\n        MailSenderQueueItem item = new MailSenderQueueItem(Arrays.asList(message), session, null, batchId, \"wiki\");\n\n        assertEquals(\"batchId = [\" + batchId + \"], wikiId = [wiki]\", item.toString());\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void runInternal()\n    {\n        do {\n            try {\n                // Handle next message in the queue\n                if (!this.mailQueue.isEmpty()) {\n                    // Important: only remove the mail item from the queue after the mail has been sent as\n                    // otherwise, MailSender.waitTillSent() may return before the mail is actually sent!\n                    MailSenderQueueItem mailItem = this.mailQueue.peek();\n                    try {\n                        sendMail(mailItem);\n                    } finally {\n                        this.mailQueue.remove(mailItem);\n                    }\n                }\n                // Make some pause to not overload the server\n                Thread.sleep(100L);\n            } catch (Exception e) {\n                // There was an unexpected problem, we stop this thread and log the problem.\n                LOGGER.debug(\"Mail Sender Thread was forcefully stopped\", e);\n                break;\n            }\n        } while (!this.shouldStop);\n    }","id":26346,"modified_method":"private void runInternal()\n    {\n        do {\n            try {\n                // Handle next message in the queue\n                if (this.mailQueueManager.hasMessageToSend()) {\n                    // Important: only remove the mail item from the queue after the mail has been sent as\n                    // otherwise, MailSender.waitTillSent() may return before the mail is actually sent!\n                    MailSenderQueueItem mailItem = this.mailQueueManager.peekMessage();\n                    try {\n                        sendMail(mailItem);\n                    } finally {\n                        this.mailQueueManager.removeMessageFromQueue(mailItem);\n                    }\n                }\n                // Make some pause to not overload the server\n                Thread.sleep(100L);\n            } catch (Exception e) {\n                // There was an unexpected problem, we stop this thread and log the problem.\n                LOGGER.debug(\"Mail Sender Thread was forcefully stopped\", e);\n                break;\n            }\n        } while (!this.shouldStop);\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param mailQueue the queue containing the mails to be sent\n     * @param configuration the mail sender configuration from which we extract default from and BCC email addresses\n     * @param xwikiContextProvider used to create a new XWiki Context when sending a mail (to provide isolation)\n     * @param executionContextManager used to create a new execution context when sending a mail (to provide isolation)\n     */\n    public MailSenderRunnable(Queue<MailSenderQueueItem> mailQueue, MailSenderConfiguration configuration,\n        Provider<XWikiContext> xwikiContextProvider, ExecutionContextManager executionContextManager)\n    {\n        this.mailQueue = mailQueue;\n        this.configuration = configuration;\n        this.xwikiContextProvider = xwikiContextProvider;\n        this.executionContextManager = executionContextManager;\n    }","id":26347,"modified_method":"/**\n     * @param mailQueueManager the manager to handle mail-sending-queue-related operations\n     * @param configuration the mail sender configuration from which we extract default from and BCC email addresses\n     * @param xwikiContextProvider used to create a new XWiki Context when sending a mail (to provide isolation)\n     * @param executionContextManager used to create a new execution context when sending a mail (to provide isolation)\n     */\n    public MailSenderRunnable(MailQueueManager mailQueueManager, MailSenderConfiguration configuration,\n        Provider<XWikiContext> xwikiContextProvider, ExecutionContextManager executionContextManager)\n    {\n        this.mailQueueManager = mailQueueManager;\n        this.configuration = configuration;\n        this.xwikiContextProvider = xwikiContextProvider;\n        this.executionContextManager = executionContextManager;\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void runInternalWhenMailSendingFails() throws Exception\n    {\n        // Create a Session with an invalid host so that it generates an error\n        Properties properties = new Properties();\n        properties.setProperty(\"mail.smtp.host\", \"xwiki-unknown\");\n        Session session = Session.getDefaultInstance(properties);\n        MimeMessage message = new MimeMessage(session);\n        message.setSubject(\"subject\");\n        message.setFrom(InternetAddress.parse(\"john@doe.com\")[0]);\n        MemoryMailListener listener = this.componentManager.getInstance(MailListener.class, \"memory\");\n        UUID batchId = UUID.randomUUID();\n        MailSenderQueueItem item = new MailSenderQueueItem(Arrays.asList(message), session, listener, batchId, \"wiki\");\n\n        Queue<MailSenderQueueItem> mailQueue = new ConcurrentLinkedQueue<>();\n\n        // Send 2 mails. Both will fail but we want to verify that the second one is processed even though the first\n        // one failed.\n        mailQueue.add(item);\n        mailQueue.add(item);\n\n        MailSenderRunnable runnable = new MailSenderRunnable(mailQueue, this.configuration, this.xwikiContextProvider,\n            this.executionContextManager);\n        Thread thread = new Thread(runnable);\n        thread.start();\n\n        // This is the real test: we verify that there's been an error while sending each email and that it's been\n        // logged. This also proves that the Mail Sender Thread doesn't stop when there's an error sending an email.\n        boolean success = true;\n        try {\n            long time = System.currentTimeMillis();\n            while (listener.getErrorsNumber() != 2) {\n                if (System.currentTimeMillis() - time > 5000L) {\n                    success = false;\n                    break;\n                }\n                Thread.sleep(100L);\n            }\n        } finally {\n            runnable.stopProcessing();\n            thread.interrupt();\n            thread.join();\n        }\n        assertTrue(success);\n    }","id":26348,"modified_method":"@Test\n    public void runInternalWhenMailSendingFails() throws Exception\n    {\n        // Create a Session with an invalid host so that it generates an error\n        Properties properties = new Properties();\n        properties.setProperty(\"mail.smtp.host\", \"xwiki-unknown\");\n        Session session = Session.getDefaultInstance(properties);\n        MimeMessage message = new MimeMessage(session);\n        message.setSubject(\"subject\");\n        message.setFrom(InternetAddress.parse(\"john@doe.com\")[0]);\n        MemoryMailListener listener = this.componentManager.getInstance(MailListener.class, \"memory\");\n        UUID batchId = UUID.randomUUID();\n        MailSenderQueueItem item = new MailSenderQueueItem(Arrays.asList(message), session, listener, batchId, \"wiki\");\n\n        MailQueueManager mailQueueManager = new MailQueueManager();\n\n        // Send 2 mails. Both will fail but we want to verify that the second one is processed even though the first\n        // one failed.\n        mailQueueManager.addToQueue(item);\n        mailQueueManager.addToQueue(item);\n\n        MailSenderRunnable runnable = new MailSenderRunnable(mailQueueManager, this.configuration,\n            this.xwikiContextProvider, this.executionContextManager);\n        Thread thread = new Thread(runnable);\n        thread.start();\n\n        // Wait for the mails to have been processed.\n        try {\n            mailQueueManager.waitTillSent(batchId, 10000L);\n        } finally {\n            runnable.stopProcessing();\n            thread.interrupt();\n            thread.join();\n        }\n\n        // This is the real test: we verify that there's been an error while sending each email.\n        Iterator<MailStatus> statuses = listener.getMailStatusResult().getByState(MailState.FAILED);\n        int errorCount = 0;\n        while (statuses.hasNext()) {\n            MailStatus status = statuses.next();\n            // Note: I would have liked to assert the exact message but it seems there can be different ones returned.\n            // During my tests I got 2 different ones:\n            // \"UnknownHostException: xwiki-unknown\"\n            // \"ConnectException: Connection refused\"\n            // Thus for now I only assert that there's an error set, but not its content.\n            assertTrue(status.getError() != null);\n            errorCount++;\n        }\n        assertEquals(2, errorCount);\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Send one mail synchronously with Memory MailListener .\n     *\n     * @param message the message that was tried to be sent\n     * @return UUID of the Batch mail\n     */\n    public UUID send(MimeMessage message)\n    {\n        return send(Arrays.asList(message));\n    }","id":26349,"modified_method":"/**\n     * Send one mail synchronously with Memory MailListener .\n     *\n     * @param message the message that was tried to be sent\n     * @return the result and status of the send batch\n     */\n    public ScriptMailResult send(MimeMessage message)\n    {\n        return send(Arrays.asList(message));\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Send the mail synchronously (wait till the message is sent). Any error can be retrieved by calling {@link\n     * #getErrors(UUID)}.\n     *\n     * @param messages the list of messages that was tried to be sent\n     * @param hint the component hint of a {@link org.xwiki.mail.MailListener} component\n     * @return UUID of the Batch mail\n     */\n    public UUID send(Iterable<? extends MimeMessage> messages, String hint)\n    {\n        try {\n            checkPermissions();\n            return this.mailSender.send(messages, createSession());\n        } catch (MessagingException e) {\n            // Save the exception for reporting through the script services's getLastError() API\n            setError(e);\n        }\n        return null;\n    }","id":26350,"modified_method":"/**\n     * Send the mail synchronously (wait till the message is sent). Any error can be retrieved by using the\n     * returned {@link ScriptMailResult}.\n     *\n     * @param messages the list of messages that was tried to be sent\n     * @param hint the component hint of a {@link org.xwiki.mail.MailListener} component\n     * @return the result and status of the send batch\n     */\n    public ScriptMailResult send(Iterable<? extends MimeMessage> messages, String hint)\n    {\n        ScriptMailResult scriptMailResult = sendAsynchronously(messages, hint);\n\n        // Wait for all messages from this batch to have been sent before returning\n        scriptMailResult.waitTillSent(Long.MAX_VALUE);\n\n        return scriptMailResult;\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Send the list of mails synchronously, using a Memory {@link }MailListener} to store the results.\n     *\n     * @param messages the list of messages that was tried to be sent\n     * @return UUID of the Batch mail\n     */\n    public UUID send(Iterable<? extends MimeMessage> messages)\n    {\n        return send(messages, \"memory\");\n    }","id":26351,"modified_method":"/**\n     * Send the list of mails synchronously, using a Memory {@link }MailListener} to store the results.\n     *\n     * @param messages the list of messages that was tried to be sent\n     * @return the result and status of the send batch\n     */\n    public ScriptMailResult send(Iterable<? extends MimeMessage> messages)\n    {\n        return send(messages, \"memory\");\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Send the mail asynchronously.\n     *\n     * @param messages the list of messages that was tried to be sent\n     * @param hint the component hint of a {@link org.xwiki.mail.MailListener} component\n     * @return UUID of the Batch mail\n     */\n    public UUID sendAsynchronously(List<? extends MimeMessage> messages, String hint)\n    {\n        final MailListener listener;\n        try {\n            listener = getListener(hint);\n            checkPermissions();\n        } catch (MessagingException e) {\n            // Save the exception for reporting through the script services's getLastError() API\n            setError(e);\n            // Don't send the mail!\n            return null;\n        }\n\n        // NOTE: we don't throw any error since the message is sent asynchronously. All errors can be found using\n        // the passed listener.\n        UUID sender = this.mailSender.sendAsynchronously(messages, createSession(), listener);\n        return sender;\n    }","id":26352,"modified_method":"/**\n     * Send the mail asynchronously.\n     *\n     * @param messages the list of messages that was tried to be sent\n     * @param hint the component hint of a {@link org.xwiki.mail.MailListener} component\n     * @return the result and status of the send batch\n     */\n    public ScriptMailResult sendAsynchronously(Iterable<? extends MimeMessage> messages, String hint)\n    {\n        final MailListener listener;\n        try {\n            checkPermissions();\n            listener = getListener(hint);\n        } catch (MessagingException e) {\n            // Save the exception for reporting through the script services's getLastError() API\n            setError(e);\n            // Don't send the mail!\n            return null;\n        }\n\n        // NOTE: we don't throw any error since the message is sent asynchronously. All errors can be found using\n        // the passed listener.\n        return new ScriptMailResult(this.mailSender.sendAsynchronously(messages, createSession(), listener),\n            listener.getMailStatusResult());\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void onPrepare(MimeMessage message)\n    {\n        // We're only interested in errors in the scripting API.\n    }","id":26353,"modified_method":"@Override\n    public void onPrepare(MimeMessage message)\n    {\n        try {\n            MailStatus status = createMailStatus(message);\n            status.setState(MailState.READY);\n            this.mailStatusResult.setStatus(status);\n        } catch (MessagingException e) {\n            this.logger.error(\"Invalid prepared message [{}]\", message, e);\n        }\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void onError(MimeMessage message, Exception e)\n    {\n        try {\n            this.batchId = message.getHeader(\"X-BatchID\", null);\n            this.errorQueue.add(new MailStatus(message.getHeader(\"X-MailID\", null), ExceptionUtils.getMessage(e)));\n        } catch (MessagingException ex) {\n            this.logger.warn(\"Failed to retrieve Message ID from message. Reason: [{}]\",\n                ExceptionUtils.getRootCauseMessage(e));\n        }\n    }","id":26354,"modified_method":"@Override\n    public void onError(MimeMessage message, Exception e)\n    {\n        try {\n            MailStatus status = createMailStatus(message);\n            status.setState(MailState.FAILED);\n            status.setError(e);\n            this.mailStatusResult.setStatus(status);\n        } catch (MessagingException ex) {\n            this.logger.error(\"Invalid error message [{}]\", message, ex);\n        }\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void onSuccess(MimeMessage message)\n    {\n        // We're only interested in errors in the scripting API.\n    }","id":26355,"modified_method":"@Override\n    public void onSuccess(MimeMessage message)\n    {\n        try {\n            MailStatus status = createMailStatus(message);\n            status.setState(MailState.SENT);\n            this.mailStatusResult.setStatus(status);\n        } catch (MessagingException e) {\n            this.logger.error(\"Invalid success message [{}]\", message, e);\n        }\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void errorAndRetrieveError() throws Exception\n    {\n        MemoryMailListener listener = this.mocker.getInstance(MailListener.class, \"memory\");\n        MimeMessage message = mock(MimeMessage.class);\n        listener.onError(message, new Exception(\"error\"));\n        assertTrue(listener.getErrors().hasNext());\n        String error = listener.getErrors().next().getError();\n        assertEquals(\"Exception: error\", error );\n    }","id":26356,"modified_method":"@Test\n    public void errorAndRetrieveError() throws Exception\n    {\n        MemoryMailListener listener = this.mocker.getInstance(MailListener.class, \"memory\");\n        MimeMessage message = mock(MimeMessage.class);\n        listener.onError(message, new Exception(\"error\"));\n        Iterator<MailStatus> results = listener.getMailStatusResult().getByState(MailState.FAILED);\n        assertTrue(\"These should be mails in error!\", results.hasNext());\n        String error = results.next().getError();\n        assertEquals(\"Exception: error\", error );\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void sendHTMLAndCalendarInvitationMail() throws Exception\n    {\n        // Set the EC\n        Execution execution = this.componentManager.getInstance(Execution.class);\n        execution.setContext(new ExecutionContext());\n\n        MimeMessageWrapper message = this.scriptService.createMessage(\"john@doe.com\", \"subject\");\n        message.addPart(\"text/html\", \"<font size=\\\"\\\\\\\"2\\\\\\\"\\\">simple meeting invitation<\/font>\");\n        String calendarContent = \"BEGIN:VCALENDAR\\r\\n\"\n            + \"METHOD:REQUEST\\r\\n\"\n            + \"PRODID: Meeting\\r\\n\"\n            + \"VERSION:2.0\\r\\n\"\n            + \"BEGIN:VEVENT\\r\\n\"\n            + \"DTSTAMP:20140616T164100\\r\\n\"\n            + \"DTSTART:20140616T164100\\r\\n\"\n            + \"DTEND:20140616T194100\\r\\n\"\n            + \"SUMMARY:test request\\r\\n\"\n            + \"UID:324\\r\\n\"\n            + \"ATTENDEE;ROLE=REQ-PARTICIPANT;PARTSTAT=NEEDS-ACTION;RSVP=TRUE:MAILTO:john@doe.com\\r\\n\"\n            + \"ORGANIZER:MAILTO:john@doe.com\\r\\n\"\n            + \"LOCATION:on the net\\r\\n\"\n            + \"DESCRIPTION:learn some stuff\\r\\n\"\n            + \"SEQUENCE:0\\r\\n\"\n            + \"PRIORITY:5\\r\\n\"\n            + \"CLASS:PUBLIC\\r\\n\"\n            + \"STATUS:CONFIRMED\\r\\n\"\n            + \"TRANSP:OPAQUE\\r\\n\"\n            + \"BEGIN:VALARM\\r\\n\"\n            + \"ACTION:DISPLAY\\r\\n\"\n            + \"DESCRIPTION:REMINDER\\r\\n\"\n            + \"TRIGGER;RELATED=START:-PT00H15M00S\\r\\n\"\n            + \"END:VALARM\\r\\n\"\n            + \"END:VEVENT\\r\\n\"\n            + \"END:VCALENDAR\";\n        message.addPart(\"text/calendar;method=CANCEL\", calendarContent,\n            Collections.<String, Object>singletonMap(\"headers\",\n                Collections.singletonMap(\"Content-Class\", \"urn:content-classes:calendarmessage\")));\n\n        UUID batchId = this.scriptService.send(Arrays.asList(message), \"memory\");\n\n        // Verify that there are no errors\n        assertNull(this.scriptService.getErrors(batchId));\n\n        // Verify that the mail has been received (wait maximum 10 seconds).\n        this.mail.waitForIncomingEmail(10000L, 1);\n        MimeMessage[] messages = this.mail.getReceivedMessages();\n\n        assertEquals(1, messages.length);\n        assertEquals(\"subject\", messages[0].getHeader(\"Subject\", null));\n        assertEquals(\"john@doe.com\", messages[0].getHeader(\"To\", null));\n\n        assertEquals(2, ((MimeMultipart) messages[0].getContent()).getCount());\n\n        BodyPart htmlBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(0);\n        assertEquals(\"text/html\", htmlBodyPart.getHeader(\"Content-Type\")[0]);\n        assertEquals(\"<font size=\\\"\\\\\\\"2\\\\\\\"\\\">simple meeting invitation<\/font>\", htmlBodyPart.getContent());\n\n        BodyPart calendarBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(1);\n        assertEquals(\"text/calendar;method=CANCEL\", calendarBodyPart.getHeader(\"Content-Type\")[0]);\n        InputStream is = (InputStream) calendarBodyPart.getContent();\n        assertEquals(calendarContent, IOUtils.toString(is));\n    }","id":26357,"modified_method":"@Test\n    public void sendHTMLAndCalendarInvitationMail() throws Exception\n    {\n        // Set the EC\n        Execution execution = this.componentManager.getInstance(Execution.class);\n        execution.setContext(new ExecutionContext());\n\n        MimeMessageWrapper message = this.scriptService.createMessage(\"john@doe.com\", \"subject\");\n        message.addPart(\"text/html\", \"<font size=\\\"\\\\\\\"2\\\\\\\"\\\">simple meeting invitation<\/font>\");\n        String calendarContent = \"BEGIN:VCALENDAR\\r\\n\"\n            + \"METHOD:REQUEST\\r\\n\"\n            + \"PRODID: Meeting\\r\\n\"\n            + \"VERSION:2.0\\r\\n\"\n            + \"BEGIN:VEVENT\\r\\n\"\n            + \"DTSTAMP:20140616T164100\\r\\n\"\n            + \"DTSTART:20140616T164100\\r\\n\"\n            + \"DTEND:20140616T194100\\r\\n\"\n            + \"SUMMARY:test request\\r\\n\"\n            + \"UID:324\\r\\n\"\n            + \"ATTENDEE;ROLE=REQ-PARTICIPANT;PARTSTAT=NEEDS-ACTION;RSVP=TRUE:MAILTO:john@doe.com\\r\\n\"\n            + \"ORGANIZER:MAILTO:john@doe.com\\r\\n\"\n            + \"LOCATION:on the net\\r\\n\"\n            + \"DESCRIPTION:learn some stuff\\r\\n\"\n            + \"SEQUENCE:0\\r\\n\"\n            + \"PRIORITY:5\\r\\n\"\n            + \"CLASS:PUBLIC\\r\\n\"\n            + \"STATUS:CONFIRMED\\r\\n\"\n            + \"TRANSP:OPAQUE\\r\\n\"\n            + \"BEGIN:VALARM\\r\\n\"\n            + \"ACTION:DISPLAY\\r\\n\"\n            + \"DESCRIPTION:REMINDER\\r\\n\"\n            + \"TRIGGER;RELATED=START:-PT00H15M00S\\r\\n\"\n            + \"END:VALARM\\r\\n\"\n            + \"END:VEVENT\\r\\n\"\n            + \"END:VCALENDAR\";\n        message.addPart(\"text/calendar;method=CANCEL\", calendarContent,\n            Collections.<String, Object>singletonMap(\"headers\",\n                Collections.singletonMap(\"Content-Class\", \"urn:content-classes:calendarmessage\")));\n\n        ScriptMailResult result = this.scriptService.send(Arrays.asList(message));\n\n        // Verify that there are no errors\n        assertNull(this.scriptService.getLastError());\n\n        // Wait for all mails to be sent\n        result.waitTillSent(10000L);\n\n        // Verify that all mails have been sent properly\n        assertFalse(\"There should not be any failed result!\",\n            result.getStatusResults().getByState(MailState.FAILED).hasNext());\n        assertFalse(\"There should not be any mails in the ready state!\",\n            result.getStatusResults().getByState(MailState.READY).hasNext());\n\n        // Verify that the mail has been received (wait maximum 10 seconds).\n        this.mail.waitForIncomingEmail(10000L, 1);\n        MimeMessage[] messages = this.mail.getReceivedMessages();\n\n        assertEquals(1, messages.length);\n        assertEquals(\"subject\", messages[0].getHeader(\"Subject\", null));\n        assertEquals(\"john@doe.com\", messages[0].getHeader(\"To\", null));\n\n        assertEquals(2, ((MimeMultipart) messages[0].getContent()).getCount());\n\n        BodyPart htmlBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(0);\n        assertEquals(\"text/html\", htmlBodyPart.getHeader(\"Content-Type\")[0]);\n        assertEquals(\"<font size=\\\"\\\\\\\"2\\\\\\\"\\\">simple meeting invitation<\/font>\", htmlBodyPart.getContent());\n\n        BodyPart calendarBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(1);\n        assertEquals(\"text/calendar;method=CANCEL\", calendarBodyPart.getHeader(\"Content-Type\")[0]);\n        InputStream is = (InputStream) calendarBodyPart.getContent();\n        assertEquals(calendarContent, IOUtils.toString(is));\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void sendTextMail() throws Exception\n    {\n        // Set the EC\n        Execution execution = this.componentManager.getInstance(Execution.class);\n        execution.setContext(new ExecutionContext());\n\n        MimeMessageWrapper message = this.scriptService.createMessage(\"john@doe.com\", \"subject\");\n        message.addPart(\"text/plain\", \"some text here\");\n\n        // Send 3 mails (3 times the same mail) to verify we can send several emails at once.\n        String hint = \"memory\";\n        List<MimeMessageWrapper> messagesList = Arrays.asList(message, message, message);\n        UUID batchId = this.scriptService.sendAsynchronously(messagesList, hint);\n\n        // Verify that there are no errors\n        assertNull(this.scriptService.getErrors(batchId));\n\n        // Verify that the mails have been received (wait maximum 10 seconds).\n        this.mail.waitForIncomingEmail(10000L, 3);\n        MimeMessage[] messages = this.mail.getReceivedMessages();\n\n        assertEquals(3, messages.length);\n        assertEquals(\"subject\", messages[0].getHeader(\"Subject\", null));\n        assertEquals(\"john@doe.com\", messages[0].getHeader(\"To\", null));\n\n        assertEquals(1, ((MimeMultipart) messages[0].getContent()).getCount());\n\n        BodyPart textBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(0);\n        assertEquals(\"text/plain\", textBodyPart.getHeader(\"Content-Type\")[0]);\n        assertEquals(\"some text here\", textBodyPart.getContent());\n    }","id":26358,"modified_method":"@Test\n    public void sendTextMail() throws Exception\n    {\n        // Set the EC\n        Execution execution = this.componentManager.getInstance(Execution.class);\n        execution.setContext(new ExecutionContext());\n\n        MimeMessageWrapper message = this.scriptService.createMessage(\"john@doe.com\", \"subject\");\n        message.addPart(\"text/plain\", \"some text here\");\n\n        // Send 3 mails (3 times the same mail) to verify we can send several emails at once.\n        List<MimeMessageWrapper> messagesList = Arrays.asList(message, message, message);\n        ScriptMailResult result = this.scriptService.sendAsynchronously(messagesList, \"memory\");\n\n        // Verify that there are no errors\n        assertNull(this.scriptService.getLastError());\n\n        // Wait for all mails to be sent\n        result.waitTillSent(10000L);\n\n        // Verify that all mails have been sent properly\n        assertFalse(\"There should not be any failed result!\",\n            result.getStatusResults().getByState(MailState.FAILED).hasNext());\n        assertFalse(\"There should not be any mails in the ready state!\",\n            result.getStatusResults().getByState(MailState.READY).hasNext());\n\n        // Verify that the mails have been received (wait maximum 10 seconds).\n        this.mail.waitForIncomingEmail(10000L, 3);\n        MimeMessage[] messages = this.mail.getReceivedMessages();\n\n        assertEquals(3, messages.length);\n        assertEquals(\"subject\", messages[0].getHeader(\"Subject\", null));\n        assertEquals(\"john@doe.com\", messages[0].getHeader(\"To\", null));\n\n        assertEquals(1, ((MimeMultipart) messages[0].getContent()).getCount());\n\n        BodyPart textBodyPart = ((MimeMultipart) messages[0].getContent()).getBodyPart(0);\n        assertEquals(\"text/plain\", textBodyPart.getHeader(\"Content-Type\")[0]);\n        assertEquals(\"some text here\", textBodyPart.getContent());\n    }","commit_id":"ab3c69bcf958bb2f6159192e0efcc66cd4d59239","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override public MimeMessage next()\n    {\n        if (hasNext()) {\n            MimeMessage mimeMessage = null;\n            try {\n                mimeMessage = createMessage();\n            } catch (MessagingException e) {\n                this.logger.error(\"Failed to create mime message. \"\n                    + \"Root reason: [{}]\", ExceptionUtils.getRootCauseMessage(e));\n                //TODO We need to save all the errors and display them in the status of all emails in the admin UI.\n            }\n            position++;\n            return mimeMessage;\n        } else {\n            throw new NoSuchElementException(\"There are no more elements\");\n        }\n    }","id":26359,"modified_method":"@Override public MimeMessage next()\n    {\n        MimeMessage mimeMessage = null;\n        try {\n            mimeMessage = createMessage();\n        } catch (MessagingException e) {\n            this.logger.error(\"Failed to create mime message. \"\n                + \"Root reason: [{}]\", ExceptionUtils.getRootCauseMessage(e));\n            //TODO We need to save all the errors and display them in the status of all emails in the admin UI.\n        }\n        position++;\n        return mimeMessage;\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override public Iterator<MimeMessage> create(DocumentReference groupReference, MimeMessageFactory factory,\n        Map<String, Object> parameters) throws MessagingException\n    {\n        GroupMimeMessageIterator iterator = new GroupMimeMessageIterator(groupReference, factory, parameters);\n        return iterator;\n    }","id":26360,"modified_method":"@Override\n    public Iterator<MimeMessage> create(DocumentReference groupReference, MimeMessageFactory factory,\n        Map<String, Object> parameters) throws MessagingException\n    {\n        ComponentManager cm = componentManagerProvider.get();\n        GroupMimeMessageIterator iterator = new GroupMimeMessageIterator(groupReference, factory, parameters, cm);\n        return iterator;\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void send(MimeMessage message, Session session) throws MessagingException\n    {\n        DefaultMailResultListener listener = new DefaultMailResultListener();\n        sendAsynchronously(message, session, listener);\n        waitTillSent(Long.MAX_VALUE);\n        BlockingQueue<Exception> errorQueue = listener.getExceptionQueue();\n        if (!errorQueue.isEmpty()) {\n            throw new MessagingException(String.format(\"Failed to send mail message [%s]\", message), errorQueue.peek());\n        }\n    }","id":26361,"modified_method":"@Override\n    public UUID send(MimeMessage message, Session session) throws MessagingException\n    {\n        MailListener listener = getListener(\"memory\");\n        UUID batchID = sendAsynchronously(message, session, listener);\n        waitTillSent(Long.MAX_VALUE);\n        Iterator<MailStatus> errors = listener.getErrors();\n        if (errors.hasNext()) {\n            throw new MessagingException(String.format(\"Failed to send mail message [%s]\", message),\n                errors.next().getException());\n        }\n        return batchID;\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void sendAsynchronously(MimeMessage message, Session session, MailResultListener listener)\n    {\n        try {\n            // If the user has not set the From header then use the default value from configuration and if it's not\n            // set then raise an error since a message must have a from set!\n            if (message.getFrom() == null) {\n                // Try using the From address in the Session\n                String from = this.configuration.getFromAddress();\n                if (from != null) {\n                    message.setFrom(new InternetAddress(from));\n                } else {\n                    throw new MessagingException(\"Missing the From Address for sending the mail. \"\n                        + \"You need to either define it in the Mail Configuration or pass it in your message.\");\n                }\n            }\n\n            // If the user has not set the BCC header then use the default value from configuration\n            Address[] bccAddresses = message.getRecipients(Message.RecipientType.BCC);\n            if (bccAddresses == null || bccAddresses.length == 0) {\n                for (String address : this.configuration.getBCCAddresses()) {\n                    message.addRecipient(Message.RecipientType.BCC, new InternetAddress(address));\n                }\n            }\n\n            // Push new mail message on the queue\n            getMailQueue().add(new MailSenderQueueItem(message, session, listener));\n        } catch (Exception e) {\n            // Save any exception in the listener\n            listener.onError(message, e);\n        }\n    }","id":26362,"modified_method":"@Override\n    public UUID sendAsynchronously(MimeMessage message, Session session, MailListener listener)\n    {\n        UUID batchID = UUID.randomUUID();\n        try {\n            // If the user has not set the From header then use the default value from configuration and if it's not\n            // set then raise an error since a message must have a from set!\n            message.setHeader(\"X-SenderID\", batchID.toString());\n            // Perform some basic verification to avoid NPEs in JavaMail\n            if (message.getFrom() == null) {\n                // Try using the From address in the Session\n                String from = this.configuration.getFromAddress();\n                if (from != null) {\n                    message.setFrom(new InternetAddress(from));\n                } else {\n                    throw new MessagingException(\"Missing the From Address for sending the mail. \"\n                        + \"You need to either define it in the Mail Configuration or pass it in your message.\");\n                }\n            }\n\n            // If the user has not set the BCC header then use the default value from configuration\n            Address[] bccAddresses = message.getRecipients(Message.RecipientType.BCC);\n            if (bccAddresses == null || bccAddresses.length == 0) {\n                for (String address : this.configuration.getBCCAddresses()) {\n                    message.addRecipient(Message.RecipientType.BCC, new InternetAddress(address));\n                }\n            }\n\n            // Push new mail message on the queue\n            getMailQueue().add(new MailSenderQueueItem(message, session, listener));\n        } catch (Exception e) {\n            // Save any exception in the listener\n            listener.onError(message, e);\n        }\n        return batchID;\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override public Iterator<MimeMessage> create(List<File> files, Map<String, Object> parameters)\n    {\n        SerializedFilesMimeMessageIterator iterator = new SerializedFilesMimeMessageIterator(files, parameters);\n        return iterator;\n    }","id":26363,"modified_method":"@Override public Iterator<MimeMessage> create(UUID batchID, Map<String, Object> parameters)\n        throws MessagingException\n    {\n        ComponentManager cm = componentManagerProvider.get();\n        SerializedFilesMimeMessageIterator iterator = new SerializedFilesMimeMessageIterator(batchID, parameters, cm);\n        return iterator;\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Iterator<MimeMessage> create(List<DocumentReference> userReferences, MimeMessageFactory factory,\n        Map<String, Object> parameters)\n    {\n        UsersMimeMessageIterator iterator = new UsersMimeMessageIterator(userReferences, factory, parameters);\n        return iterator;\n    }","id":26364,"modified_method":"@Override\n    public Iterator<MimeMessage> create(List<DocumentReference> userReferences, MimeMessageFactory factory,\n        Map<String, Object> parameters) throws MessagingException\n    {\n        ComponentManager cm = componentManagerProvider.get();\n        UsersMimeMessageIterator iterator = new UsersMimeMessageIterator(userReferences, factory, parameters, cm);\n        return iterator;\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private XWikiContext getXWikiContext()\n    {\n        return (XWikiContext) this.execution.getContext().getProperty(XWikiContext.EXECUTIONCONTEXT_KEY);\n    }","id":26365,"modified_method":"private XWikiContext getXWikiContext() throws MessagingException\n    {\n\n        XWikiContext xWikiContext;\n        try {\n            Execution execution = this.componentManager.getInstance(Execution.class);\n            xWikiContext = (XWikiContext) execution.getContext().getProperty(XWikiContext.EXECUTIONCONTEXT_KEY);\n        } catch (ComponentLookupException e) {\n            throw new MessagingException(\"Failed to find default Execution context\", e);\n        }\n        return xWikiContext;\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param groupReference the group that contains list of recipients\n     * @param factory to create MimeMessage\n     * @param parameters the parameters from which to extract the session, source and the headers\n     * @throws MessagingException when an error occurs when retrieving the number of users\n     */\n    public GroupMimeMessageIterator(DocumentReference groupReference, MimeMessageFactory factory,\n        Map<String, Object> parameters) throws MessagingException\n    {\n        this.factory = factory;\n        this.parameters = parameters;\n        this.groupReference = groupReference;\n\n        XWikiContext context = getXWikiContext();\n        try {\n            this.iteratorSize = context.getWiki().getDocument(groupReference, context).getXObjects(GROUPS_CLASS).size();\n        } catch (XWikiException e) {\n            throw new MessagingException(String.format(\n                \"Failed to find number of [%s] objects in group Document [%s]\", GROUPS_CLASS, groupReference), e);\n        }\n    }","id":26366,"modified_method":"/**\n     * @param groupReference the group that contains list of recipients\n     * @param factory to create MimeMessage\n     * @param parameters the parameters from which to extract the session, source and the headers\n     * @param componentManager used to dynamically load components\n     * @throws MessagingException when an error occurs when retrieving the number of users\n     */\n    public GroupMimeMessageIterator(DocumentReference groupReference, MimeMessageFactory factory,\n        Map<String, Object> parameters, ComponentManager componentManager) throws MessagingException\n    {\n        this.factory = factory;\n        this.parameters = parameters;\n        this.groupReference = groupReference;\n        this.componentManager = componentManager;\n\n        XWikiContext context = getXWikiContext();\n        try {\n            this.iteratorSize = context.getWiki().getDocument(groupReference, context).getXObjects(GROUPS_CLASS).size();\n        } catch (XWikiException e) {\n            throw new MessagingException(String.format(\n                \"Failed to find number of [%s] objects in group Document [%s]\", GROUPS_CLASS, groupReference), e);\n        }\n        this.documentAccessBridge = getAccessBridge();\n\n        this.stringResolver = getResolver();\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override protected MimeMessage createMessage() throws MessagingException\n    {\n        DocumentReference groupsClassReference = this.resolver.resolve(GROUPS_CLASS);\n        String userFullName =\n            this.documentAccessBridge.getProperty(this.groupReference, groupsClassReference, this.position, \"member\")\n                .toString();\n\n        DocumentReference userReference = documentReferenceResolver.resolve(userFullName);\n\n        String email = this.documentAccessBridge.getProperty(userReference, new DocumentReference(userReference\n            .getWikiReference().getName(), USER_SPACE, \"XWikiUsers\"), \"email\").toString();\n\n        Map<String, Object> parameters = (Map<String, Object>) this.parameters.get(\"parameters\");\n        Session session = (Session) this.parameters.get(\"session\");\n\n        MimeMessage mimeMessage = this.factory.createMessage(session, this.parameters.get(\"source\"), parameters);\n        mimeMessage.addRecipient(Message.RecipientType.TO, InternetAddress.parse(email)[0]);\n\n        return mimeMessage;\n    }","id":26367,"modified_method":"@Override protected MimeMessage createMessage() throws MessagingException\n    {\n        DocumentReference groupsClassReference = this.stringResolver.resolve(USER_SPACE + \".XWikiGroups\");\n        String userFullName =\n            this.documentAccessBridge.getProperty(this.groupReference, groupsClassReference, this.position, \"member\")\n                .toString();\n\n        DocumentReference userReference = this.stringResolver.resolve(userFullName);\n\n        String email = this.documentAccessBridge.getProperty(userReference, new DocumentReference(userReference\n            .getWikiReference().getName(), USER_SPACE, \"XWikiUsers\"), \"email\").toString();\n\n        Map<String, Object> parameters = (Map<String, Object>) this.parameters.get(\"parameters\");\n        Session session = (Session) this.parameters.get(\"session\");\n\n        MimeMessage mimeMessage = this.factory.createMessage(session, this.parameters.get(\"source\"), parameters);\n        mimeMessage.addRecipient(Message.RecipientType.TO, InternetAddress.parse(email)[0]);\n\n        return mimeMessage;\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Exception getException()\n    {\n        return exception;\n    }","id":26368,"modified_method":"/**\n     * @return the exception when an error occurs when sending the mail\n     */\n    public Exception getException()\n    {\n        return exception;\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public MailStatus(MimeMessage message, Exception exception)\n    {\n        this.message = message;\n        this.exception = exception;\n        this.date = new Date();\n    }","id":26369,"modified_method":"/**\n     *\n     * @param message to send\n     * @param exception when an error occurs when sending the mail\n     */\n    public MailStatus(MimeMessage message, Exception exception)\n    {\n        this.message = message;\n        this.exception = exception;\n        this.date = new Date();\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Date getDate(){\n        return this.date;\n    }","id":26370,"modified_method":"/**\n     * @return the date of status\n     */\n    public Date getDate() {\n        return this.date;\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public MimeMessage getMessage()\n    {\n        return message;\n    }","id":26371,"modified_method":"/**\n     * @return the message to send\n     */\n    public MimeMessage getMessage()\n    {\n        return message;\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param message the wrapped {@link javax.mail.internet.MimeMessage}\n     * @param session the JavaMail session used to send the mail\n     * @param mailSender the component to send the mail\n     * @param execution used to get the Execution Context and store an error in it if the send fails\n     * @param configuration the mail sender configuration component\n     * @param componentManager used to dynamically load all {@link MimeBodyPartFactory} components\n     */\n    // Note: This method is package private voluntarily so that it's not part of the API (as this class is public),\n    // since it's only needed by the MailSenderScriptService and nobody else should be able to construct an instance\n    // of it!\n    MimeMessageWrapper(ExtendedMimeMessage message, Session session, MailSender mailSender, Execution execution,\n        MailSenderConfiguration configuration, ComponentManager componentManager) throws MessagingException\n    {\n        this.message = message;\n        this.session = session;\n        this.mailSender = mailSender;\n        this.execution = execution;\n        this.configuration = configuration;\n        this.componentManager = componentManager;\n        try {\n            this.listener = this.componentManager.getInstance(MailListener.class, \"memory\");\n        } catch (ComponentLookupException e) {\n            throw new MessagingException(String.format(\"Failed to locate [%s] event lister. \", \"memory\"), e);\n        }\n    }","id":26372,"modified_method":"/**\n     * @param message the wrapped {@link javax.mail.internet.MimeMessage}\n     * @param session the JavaMail session used to send the mail\n     * @param mailSender the component to send the mail\n     * @param execution used to get the Execution Context and store an error in it if the send fails\n     * @param configuration the mail sender configuration component\n     * @param componentManager used to dynamically load all {@link MimeBodyPartFactory} components\n     */\n    // Note: This method is package private voluntarily so that it's not part of the API (as this class is public),\n    // since it's only needed by the MailSenderScriptService and nobody else should be able to construct an instance\n    // of it!\n    MimeMessageWrapper(ExtendedMimeMessage message, Session session, MailSender mailSender, Execution execution,\n        MailSenderConfiguration configuration, ComponentManager componentManager)\n    {\n        this.message = message;\n        this.session = session;\n        this.mailSender = mailSender;\n        this.execution = execution;\n        this.configuration = configuration;\n        this.componentManager = componentManager;\n        String hint = \"memory\";\n        try {\n            this.listener = getListener(hint);\n        } catch (MessagingException e) {\n            this.logger.error(String.format(\"Failed to locate [%s] event lister. \", hint)\n                + \"Root reason: [{}]\", ExceptionUtils.getRootCauseMessage(e));\n        }\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Send the mail synchronously (wait till the message is sent). Any error can be retrieved by calling\n     * {@link #getErrors()}.\n     */\n    public UUID send()\n    {\n        try {\n            checkPermissions();\n            return this.mailSender.send(getMessage(), this.session);\n        } catch (MessagingException e) {\n            // Save the exception for reporting through the script services's getError() API\n            setError(e);\n            return null;\n        }\n    }","id":26373,"modified_method":"/**\n     * Send the mail synchronously (wait till the message is sent). Any error can be retrieved by calling\n     * {@link #getErrors()}.\n     *\n     * @return UUID of the Batch mail\n     */\n    public UUID send()\n    {\n        try {\n            checkPermissions();\n            return this.mailSender.send(getMessage(), this.session);\n        } catch (MessagingException e) {\n            // Save the exception for reporting through the script services's getError() API\n            setError(e);\n            return null;\n        }\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Send the mail asynchronously. You should use {@link #waitTillSent(long)} to make it blocking or simply use\n     * {@link #send()}. Any error can be retrieved by calling {@link #getErrors()}.\n     */\n    public UUID sendAsynchronously() throws MessagingException\n    {\n        try {\n            checkPermissions();\n        } catch (MessagingException e) {\n            // Save the exception for reporting through the script services's getError() API\n            setError(e);\n            // Don't send the mail!\n            return null;\n        }\n\n        // NOTE: we don't throw any error since the message is sent asynchronously. All errors can be found using\n        // the passed listener.\n        UUID Sender = this.mailSender.sendAsynchronously(getMessage(), this.session, this.listener);\n        return Sender;\n    }","id":26374,"modified_method":"/**\n     * Send the mail asynchronously. You should use {@link #waitTillSent(long)} to make it blocking or simply use\n     * {@link #send()}. Any error can be retrieved by calling {@link #getErrors()}.\n     *\n     * @return UUID of the Batch mail\n     */\n    public UUID sendAsynchronously()\n    {\n        try {\n            checkPermissions();\n        } catch (MessagingException e) {\n            // Save the exception for reporting through the script services's getError() API\n            setError(e);\n            // Don't send the mail!\n            return null;\n        }\n\n        // NOTE: we don't throw any error since the message is sent asynchronously. All errors can be found using\n        // the passed listener.\n        UUID sender = this.mailSender.sendAsynchronously(getMessage(), this.session, this.listener);\n        return sender;\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override protected MimeMessage createMessage() throws MessagingException\n    {\n        File file = this.files.get(this.position);\n        Session session = (Session) this.parameters.get(\"session\");\n        try {\n            FileInputStream emailStream = new FileInputStream(file);\n            return new MimeMessage(session, emailStream);\n        } catch (FileNotFoundException e) {\n            throw new MessagingException(\n                String.format(\"Failed to create mime message from file [%s]\", file.getPath()), e);\n        }\n    }","id":26375,"modified_method":"@Override protected MimeMessage createMessage() throws MessagingException\n    {\n        File file = this.files[this.position];\n        Session session = (Session) this.parameters.get(\"session\");\n        try {\n            FileInputStream emailStream = new FileInputStream(file);\n            return new MimeMessage(session, emailStream);\n        } catch (FileNotFoundException e) {\n            throw new MessagingException(\n                String.format(\"Failed to create mime message from file [%s]\", file.getPath()), e);\n        }\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     *\n     * @param files the list of file that contains serialized MimeMessages\n     * @param parameters the parameters from which to extract the session\n     */\n    public SerializedFilesMimeMessageIterator(List<File> files, Map<String, Object> parameters)\n    {\n        this.iteratorSize = files.size();\n        this.files = files;\n        this.parameters = parameters;\n    }","id":26376,"modified_method":"/**\n     * @param batchID the name of the directory that contains serialized MimeMessages\n     * @param parameters the parameters from which to extract the session\n     * @param componentManager used to dynamically load components\n     * @throws MessagingException when an error occurs when retrieving messages\n     */\n    public SerializedFilesMimeMessageIterator(UUID batchID, Map<String, Object> parameters,\n        ComponentManager componentManager) throws MessagingException\n    {\n        this.componentManager = componentManager;\n        try {\n            this.environment = this.componentManager.getInstance(Environment.class);\n        } catch (ComponentLookupException e) {\n            throw new MessagingException(\"Failed to find default Environment\", e);\n        }\n        this.batchDirectory = new File(this.environment.getPermanentDirectory(), batchID.toString());\n        this.files = this.batchDirectory.listFiles();\n        this.iteratorSize = this.files.length;\n        this.parameters = parameters;\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param userReferences the list of recipients\n     * @param factory to create MimeMessage\n     * @param parameters the parameters from which to extract the session, source and the headers\n     */\n    public UsersMimeMessageIterator(List<DocumentReference> userReferences, MimeMessageFactory factory,\n        Map<String, Object> parameters)\n    {\n        this.factory = factory;\n        this.parameters = parameters;\n        this.iteratorSize = userReferences.size();\n        this.users = userReferences;\n    }","id":26377,"modified_method":"/**\n     * @param userReferences the list of recipients\n     * @param factory to create MimeMessage\n     * @param parameters the parameters from which to extract the session, source and the headers\n     * @param componentManager used to dynamically load components\n     * @throws MessagingException when an error occurs\n     */\n    public UsersMimeMessageIterator(List<DocumentReference> userReferences, MimeMessageFactory factory,\n        Map<String, Object> parameters, ComponentManager componentManager) throws MessagingException\n    {\n        this.factory = factory;\n        this.parameters = parameters;\n        this.iteratorSize = userReferences.size();\n        this.users = userReferences;\n        this.componentManager = componentManager;\n        this.documentAccessBridge = getAccessBridge();\n    }","commit_id":"8ec50693a0ce9c19be744d8852bec3d8156f3be8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Returns the class name of the configuration builder used to create\n     * this MuleServer.  \n     * @return FQN of the current config builder\n     */\n    public static String getConfigBuilderClassName() {\n        return configBuilderClassName;\n    }","id":26378,"modified_method":"/**\n     * Returns the class name of the configuration builder used to create\n     * this MuleServer.\n     * @return FQN of the current config builder\n     */\n    public static String getConfigBuilderClassName()\n    {\n        if (configBuilderClassName != null) {\n            return configBuilderClassName;\n        } else {\n            return MuleXmlConfigurationBuilder.class.getName();\n        }\n    }","commit_id":"703ba88dabfb0c1acc18573ac0f832f454992aa9","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * application entry point\n     */\n    public static void main(String[] args)\n    {\n        MuleServer server = new MuleServer();\n        List opts = Arrays.asList(args);\n        String config = null;\n\n        if (opts.size() > 0) {\n            config = getOption(\"-config\", opts);\n            if (config != null) {\n                server.setConfigurationResources(config);\n            }\n        } else {\n            logger.warn(\"A configuration file was not set, using default: \" + DEFAULT_CONFIGURATION);\n            URL configUrl = ClassHelper.getResource(DEFAULT_CONFIGURATION, MuleServer.class);\n            if (configUrl != null) {\n                config = configUrl.toExternalForm();\n                server.setConfigurationResources(config);\n            }\n        }\n\n        if (config == null) {\n            Message message = new Message(Messages.CONFIG_NOT_FOUND_USAGE);\n            logger.fatal(message.toString());\n            System.exit(0);\n        }\n\n        // save the class name, as we will dispose of the configBuilder instance later\n        configBuilderClassName = getOption(\"-configBuilderClassName\", opts);\n        if (configBuilderClassName != null) {\n            try {\n                configBuilder = (ConfigurationBuilder) ClassHelper.loadClass(configBuilderClassName, MuleServer.class).newInstance();\n            } catch (Exception e) {\n                logger.fatal(new Message(Messages.FAILED_LOAD_X, \"Builder: \" + configBuilderClassName), e);\n            }\n        } else {\n            // use this by default\n            try {\n                configBuilder = new MuleXmlConfigurationBuilder();\n            } catch (ConfigurationException e) {\n                logger.fatal(e.getMessage(), e);\n                System.exit(0);\n            }\n        }\n\n        server.start(false);\n    }","id":26379,"modified_method":"/**\n     * application entry point\n     */\n    public static void main(String[] args)\n    {\n        MuleServer server = new MuleServer();\n        List opts = Arrays.asList(args);\n        String config = null;\n\n        if (opts.size() > 0) {\n            config = getOption(\"-config\", opts);\n            if (config != null) {\n                server.setConfigurationResources(config);\n            }\n        } else {\n            logger.warn(\"A configuration file was not set, using default: \" + DEFAULT_CONFIGURATION);\n            URL configUrl = ClassHelper.getResource(DEFAULT_CONFIGURATION, MuleServer.class);\n            if (configUrl != null) {\n                config = configUrl.toExternalForm();\n                server.setConfigurationResources(config);\n            }\n        }\n\n        if (config == null) {\n            Message message = new Message(Messages.CONFIG_NOT_FOUND_USAGE);\n            logger.fatal(message.toString());\n            System.exit(1);\n        }\n\n        // save the ConfigrationBuilderClass name\n        String cfgBuilderClassName = getOption(\"-configBuilderClassName\", opts);\n        if (cfgBuilderClassName != null) {\n            try {\n                setConfigBuilderClassName(cfgBuilderClassName);\n            } catch (Exception e) {\n                logger.fatal(new Message(Messages.FAILED_LOAD_X, \"Builder: \" + cfgBuilderClassName), e);\n                System.exit(1);\n            }\n        }\n\n        server.start(false);\n    }","commit_id":"703ba88dabfb0c1acc18573ac0f832f454992aa9","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Initializes this daemon. Derived classes could add some extra behaviour\n     * if they wish.\n     */\n    protected void initialize() throws Exception\n    {\n        logger.info(\"Mule Server starting...\");\n\n        // registerShutdownHook();\n        // install an RMI security manager in case we expose any RMI objects\n        if (System.getSecurityManager() == null) {\n            // System.setSecurityManager(new RMISecurityManager());\n        }\n\n        // check the class name, not the instance (which is disposed when finished configuring)\n        if (StringUtils.isNotBlank(configBuilderClassName)) {\n            configBuilder = (ConfigurationBuilder) ClassHelper.loadClass(configBuilderClassName, MuleServer.class).newInstance();\n        }\n\n        if (!configBuilder.isConfigured()) {\n            if (configurationResources != null) {\n                configBuilder.configure(configurationResources);\n            } else {\n                logger.warn(\"A configuration file was not set, using default: \" + DEFAULT_CONFIGURATION);\n                configBuilder.configure(DEFAULT_CONFIGURATION);\n            }\n        }\n        logger.info(\"Mule Server initialized.\");\n\n        // We don't need a configuration builder now, keep only the config.\n        // This statement dereferences the builder and, e.g. in case of\n        // MuleXmlConfigurationBuilder frees up a lot of resources\n        // retained by commons-digester and parser.\n        configBuilder = null;\n    }","id":26380,"modified_method":"/**\n     * Initializes this daemon. Derived classes could add some extra behaviour\n     * if they wish.\n     */\n    protected void initialize() throws Exception\n    {\n        logger.info(\"Mule Server starting...\");\n\n        // registerShutdownHook();\n        // install an RMI security manager in case we expose any RMI objects\n        if (System.getSecurityManager() == null) {\n            // System.setSecurityManager(new RMISecurityManager());\n        }\n\n        // create a new ConfigurationBuilder that is disposed afterwards\n        Class cfgBuilderClass = ClassHelper.loadClass(getConfigBuilderClassName(), MuleServer.class);\n        ConfigurationBuilder cfgBuilder = (ConfigurationBuilder)cfgBuilderClass.newInstance();\n\n        if (!cfgBuilder.isConfigured()) {\n            if (configurationResources != null) {\n                cfgBuilder.configure(configurationResources);\n            } else {\n                logger.warn(\"A configuration file was not set, using default: \" + DEFAULT_CONFIGURATION);\n                cfgBuilder.configure(DEFAULT_CONFIGURATION);\n            }\n        }\n\n        logger.info(\"Mule Server initialized.\");\n    }","commit_id":"703ba88dabfb0c1acc18573ac0f832f454992aa9","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * application entry point\n     */\n    public static void main(String[] args)\n    {\n        MuleServer server = new MuleServer();\n        List opts = Arrays.asList(args);\n        String config = null;\n\n        if (opts.size() > 0) {\n            config = getOption(\"-config\", opts);\n            if (config != null) {\n                server.setConfigurationResources(config);\n            }\n        } else {\n            logger.warn(\"A configuration file was not set, using default: \" + DEFAULT_CONFIGURATION);\n            URL configUrl = ClassHelper.getResource(DEFAULT_CONFIGURATION, MuleServer.class);\n            if (configUrl != null) {\n                config = configUrl.toExternalForm();\n                server.setConfigurationResources(config);\n            }\n        }\n\n        if (config == null) {\n            Message message = new Message(Messages.CONFIG_NOT_FOUND_USAGE);\n            logger.fatal(message.toString());\n            System.exit(0);\n        }\n\n        // save the class name, as we will dispose of the configBuilder instance later\n        configBuilderClassName = getOption(\"-configBuilderClassName\", opts);\n        if (configBuilderClassName != null) {\n            try {\n                configBuilder = (ConfigurationBuilder) ClassHelper.loadClass(configBuilderClassName, MuleServer.class).newInstance();\n            } catch (Exception e) {\n                logger.fatal(new Message(Messages.FAILED_LOAD_X, \"Builder: \" + configBuilderClassName), e);\n            }\n        } else {\n            // use this by default\n            try {\n                configBuilder = new MuleXmlConfigurationBuilder();\n            } catch (ConfigurationException e) {\n                logger.fatal(e.getMessage(), e);\n                System.exit(0);\n            }\n        }\n\n        server.start(false);\n    }","id":26381,"modified_method":"/**\n     * application entry point\n     */\n    public static void main(String[] args)\n    {\n        MuleServer server = new MuleServer();\n        List opts = Arrays.asList(args);\n        String config = null;\n\n        if (opts.size() > 0) {\n            config = getOption(\"-config\", opts);\n            if (config != null) {\n                server.setConfigurationResources(config);\n            }\n        } else {\n            logger.warn(\"A configuration file was not set, using default: \" + DEFAULT_CONFIGURATION);\n            URL configUrl = ClassHelper.getResource(DEFAULT_CONFIGURATION, MuleServer.class);\n            if (configUrl != null) {\n                config = configUrl.toExternalForm();\n                server.setConfigurationResources(config);\n            }\n        }\n\n        if (config == null) {\n            Message message = new Message(Messages.CONFIG_NOT_FOUND_USAGE);\n            logger.fatal(message.toString());\n            System.exit(1);\n        }\n\n        // save the ConfigrationBuilderClass name\n        String cfgBuilderClassName = getOption(\"-configBuilderClassName\", opts);\n        if (cfgBuilderClassName != null) {\n            try {\n                setConfigBuilderClassName(cfgBuilderClassName);\n            } catch (Exception e) {\n                logger.fatal(new Message(Messages.FAILED_LOAD_X, \"Builder: \" + cfgBuilderClassName), e);\n                System.exit(1);\n            }\n        }\n\n        server.start(false);\n    }","commit_id":"055830585c4d362026dc5a856e6b9e54e4fd7295","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Returns the class name of the configuration builder used to create\n     * this MuleServer.  \n     * @return FQN of the current config builder\n     */\n    public static String getConfigBuilderClassName() {\n        return configBuilderClassName;\n    }","id":26382,"modified_method":"/**\n     * Returns the class name of the configuration builder used to create\n     * this MuleServer.\n     * @return FQN of the current config builder\n     */\n    public static String getConfigBuilderClassName()\n    {\n        if (configBuilderClassName != null) {\n            return configBuilderClassName;\n        } else {\n            return MuleXmlConfigurationBuilder.class.getName();\n        }\n    }","commit_id":"055830585c4d362026dc5a856e6b9e54e4fd7295","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Initializes this daemon. Derived classes could add some extra behaviour\n     * if they wish.\n     */\n    protected void initialize() throws Exception\n    {\n        logger.info(\"Mule Server starting...\");\n\n        // registerShutdownHook();\n        // install an RMI security manager in case we expose any RMI objects\n        if (System.getSecurityManager() == null) {\n            // System.setSecurityManager(new RMISecurityManager());\n        }\n\n        // check the class name, not the instance (which is disposed when finished configuring)\n        if (StringUtils.isNotBlank(configBuilderClassName)) {\n            configBuilder = (ConfigurationBuilder) ClassHelper.loadClass(configBuilderClassName, MuleServer.class).newInstance();\n        }\n\n        if (!configBuilder.isConfigured()) {\n            if (configurationResources != null) {\n                configBuilder.configure(configurationResources);\n            } else {\n                logger.warn(\"A configuration file was not set, using default: \" + DEFAULT_CONFIGURATION);\n                configBuilder.configure(DEFAULT_CONFIGURATION);\n            }\n        }\n        logger.info(\"Mule Server initialized.\");\n\n        // We don't need a configuration builder now, keep only the config.\n        // This statement dereferences the builder and, e.g. in case of\n        // MuleXmlConfigurationBuilder frees up a lot of resources\n        // retained by commons-digester and parser.\n        configBuilder = null;\n    }","id":26383,"modified_method":"/**\n     * Initializes this daemon. Derived classes could add some extra behaviour\n     * if they wish.\n     */\n    protected void initialize() throws Exception\n    {\n        logger.info(\"Mule Server starting...\");\n\n        // registerShutdownHook();\n        // install an RMI security manager in case we expose any RMI objects\n        if (System.getSecurityManager() == null) {\n            // System.setSecurityManager(new RMISecurityManager());\n        }\n\n        // create a new ConfigurationBuilder that is disposed afterwards\n        Class cfgBuilderClass = ClassHelper.loadClass(getConfigBuilderClassName(), MuleServer.class);\n        ConfigurationBuilder cfgBuilder = (ConfigurationBuilder)cfgBuilderClass.newInstance();\n\n        if (!cfgBuilder.isConfigured()) {\n            if (configurationResources != null) {\n                cfgBuilder.configure(configurationResources);\n            } else {\n                logger.warn(\"A configuration file was not set, using default: \" + DEFAULT_CONFIGURATION);\n                cfgBuilder.configure(DEFAULT_CONFIGURATION);\n            }\n        }\n\n        logger.info(\"Mule Server initialized.\");\n    }","commit_id":"055830585c4d362026dc5a856e6b9e54e4fd7295","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest request, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\tif(!ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, \"Unauthorized\", L10n.getString(\"Toadlet.unauthorized\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tWIZARD_STEP currentStep = WIZARD_STEP.valueOf(request.getParam(\"step\", WIZARD_STEP.WELCOME.toString()));\n\t\t\n\t\tif(currentStep == WIZARD_STEP.BROWSER_WARNING) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"browserWarningPageTitle\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode infoboxHeader = infobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tinfoboxHeader.addChild(\"#\", l10n(\"browserWarningShort\"));\n\t\t\tL10n.addL10nSubstitution(infoboxContent, \"FirstTimeWizardToadlet.browserWarning\", new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\tinfoboxContent.addChild(\"p\", l10n(\"browserWarningSuggestion\"));\n\t\t\t\n\t\t\tinfoboxContent.addChild(\"p\").addChild(\"a\", \"href\", \"?step=\"+WIZARD_STEP.SECURITY_NETWORK, L10n.getString(\"FirstTimeWizardToadlet.clickContinue\"));\n\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.SECURITY_NETWORK) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"networkSecurityPageTitle\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode infoboxHeader = infobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tinfoboxHeader.addChild(\"#\", l10nSec(\"networkThreatLevelShort\"));\n\t\t\tinfoboxContent.addChild(\"p\", l10nSec(\"networkThreatLevel\"));\n\t\t\tHTMLNode form = ctx.addFormChild(infoboxContent, \".\", \"networkSecurityForm\");\n\t\t\tHTMLNode div = form.addChild(\"div\", \"class\", \"opennetDiv\");\n\t\t\tString controlName = \"security-levels.networkThreatLevel\";\n\t\t\tfor(NETWORK_THREAT_LEVEL level : NETWORK_THREAT_LEVEL.values()) {\n\t\t\t\tHTMLNode input;\n\t\t\t\tinput = div.addChild(\"p\").addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"radio\", controlName, level.name() });\n\t\t\t\tinput.addChild(\"b\", l10nSec(\"networkThreatLevel.name.\"+level));\n\t\t\t\tinput.addChild(\"#\", \": \");\n\t\t\t\tL10n.addL10nSubstitution(input, \"SecurityLevels.networkThreatLevel.choice.\"+level, new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\t\tHTMLNode inner = input.addChild(\"p\").addChild(\"i\");\n\t\t\t\tL10n.addL10nSubstitution(inner, \"SecurityLevels.networkThreatLevel.desc.\"+level, new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\t}\n\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"networkSecurityF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.SECURITY_FRIENDS) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"friendsSecurityPageTitle\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode infoboxHeader = infobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tinfoboxHeader.addChild(\"#\", l10nSec(\"friendsThreatLevelShort\"));\n\t\t\tinfoboxContent.addChild(\"p\", l10nSec(\"friendsThreatLevel\"));\n\t\t\tHTMLNode form = ctx.addFormChild(infoboxContent, \".\", \"friendsSecurityForm\");\n\t\t\tHTMLNode div = form.addChild(\"div\", \"class\", \"opennetDiv\");\n\t\t\tString controlName = \"security-levels.friendsThreatLevel\";\n\t\t\tfor(FRIENDS_THREAT_LEVEL level : FRIENDS_THREAT_LEVEL.values()) {\n\t\t\t\tHTMLNode input;\n\t\t\t\tinput = div.addChild(\"p\").addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"radio\", controlName, level.name() });\n\t\t\t\tinput.addChild(\"b\", l10nSec(\"friendsThreatLevel.name.\"+level));\n\t\t\t\tinput.addChild(\"#\", \": \");\n\t\t\t\tL10n.addL10nSubstitution(input, \"SecurityLevels.friendsThreatLevel.choice.\"+level, new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\t\tHTMLNode inner = input.addChild(\"p\").addChild(\"i\");\n\t\t\t\tL10n.addL10nSubstitution(inner, \"SecurityLevels.friendsThreatLevel.desc.\"+level, new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\t}\n\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"friendsSecurityF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.SECURITY_PHYSICAL) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"physicalSecurityPageTitle\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode infoboxHeader = infobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tinfoboxHeader.addChild(\"#\", l10nSec(\"physicalThreatLevelShort\"));\n\t\t\tinfoboxContent.addChild(\"p\", l10nSec(\"physicalThreatLevel\"));\n\t\t\tHTMLNode form = ctx.addFormChild(infoboxContent, \".\", \"physicalSecurityForm\");\n\t\t\tHTMLNode div = form.addChild(\"div\", \"class\", \"opennetDiv\");\n\t\t\tString controlName = \"security-levels.physicalThreatLevel\";\n\t\t\tfor(PHYSICAL_THREAT_LEVEL level : PHYSICAL_THREAT_LEVEL.values()) {\n\t\t\t\tHTMLNode input;\n\t\t\t\tinput = div.addChild(\"p\").addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"radio\", controlName, level.name() });\n\t\t\t\tinput.addChild(\"b\", l10nSec(\"physicalThreatLevel.name.\"+level));\n\t\t\t\tinput.addChild(\"#\", \": \");\n\t\t\t\tL10n.addL10nSubstitution(input, \"SecurityLevels.physicalThreatLevel.choice.\"+level, new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\t\tHTMLNode inner = input.addChild(\"p\").addChild(\"i\");\n\t\t\t\tL10n.addL10nSubstitution(inner, \"SecurityLevels.physicalThreatLevel.desc.\"+level, new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\t}\n\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"physicalSecurityF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.NAME_SELECTION) {\n\t\t\t// Attempt to skip one step if possible: opennet nodes don't need a name\n\t\t\tif(Boolean.valueOf(request.getParam(\"opennet\"))) {\n\t\t\t\tsuper.writeTemporaryRedirect(ctx, \"step3\", TOADLET_URL+\"?step=\"+WIZARD_STEP.BANDWIDTH);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"step2Title\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode nnameInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode nnameInfoboxHeader = nnameInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode nnameInfoboxContent = nnameInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tnnameInfoboxHeader.addChild(\"#\", l10n(\"chooseNodeName\"));\n\t\t\tnnameInfoboxContent.addChild(\"#\", l10n(\"chooseNodeNameLong\"));\n\t\t\tHTMLNode nnameForm = ctx.addFormChild(nnameInfoboxContent, \".\", \"nnameForm\");\n\t\t\tnnameForm.addChild(\"input\", \"name\", \"nname\");\n\t\t\t\n\t\t\tnnameForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"nnameF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tnnameForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.BANDWIDTH) {\n\t\t\t// Attempt to skip one step if possible\n\t\t\tif(canAutoconfigureBandwidth()){\n\t\t\t\tsuper.writeTemporaryRedirect(ctx, \"step4\", TOADLET_URL+\"?step=\"+WIZARD_STEP.DATASTORE_SIZE);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"step3Title\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode bandwidthInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode bandwidthnfoboxHeader = bandwidthInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode bandwidthInfoboxContent = bandwidthInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tbandwidthnfoboxHeader.addChild(\"#\", l10n(\"bandwidthLimit\"));\n\t\t\tbandwidthInfoboxContent.addChild(\"#\", l10n(\"bandwidthLimitLong\"));\n\t\t\tHTMLNode bandwidthForm = ctx.addFormChild(bandwidthInfoboxContent, \".\", \"bwForm\");\n\t\t\tHTMLNode result = bandwidthForm.addChild(\"select\", \"name\", \"bw\");\n\t\t\t\n\t\t\tOption sizeOption = config.get(\"node\").getOption(\"outputBandwidthLimit\");\n\t\t\tif(!sizeOption.isDefault()) {\n\t\t\t\tint current = (Integer)sizeOption.getValue();\n\t\t\t\tresult.addChild(\"option\", new String[] { \"value\", \"selected\" }, new String[] { SizeUtil.formatSize(current), \"on\" }, l10n(\"currentSpeed\")+\" \"+SizeUtil.formatSize(current)+\"/s\");\n\t\t\t}\n\n\t\t\t// don't forget to update handlePost too if you change that!\n\t\t\tresult.addChild(\"option\", \"value\", \"8K\", l10n(\"bwlimitLowerSpeed\"));\n\t\t\t// Special case for 128kbps to increase performance at the cost of some link degradation. Above that we use 50% of the limit.\n\t\t\tresult.addChild(\"option\", \"value\", \"12K\", \"512+/128 kbps (12KB/s)\");\n\t\t\tif(!sizeOption.isDefault())\n\t\t\t\tresult.addChild(\"option\", \"value\", \"16K\", \"1024+/256 kbps (16KB/s)\");\n\t\t\telse\n\t\t\t\tresult.addChild(\"option\", new String[] { \"value\", \"selected\" }, new String[] { \"16K\", \"selected\" }, \"1024+/256 kbps (16KB/s)\");\n\t\t\tresult.addChild(\"option\", \"value\", \"32K\", \"1024+/512 kbps (32K/s)\");\n\t\t\tresult.addChild(\"option\", \"value\", \"64K\", \"1024+/1024 kbps (64K/s)\");\n\t\t\tresult.addChild(\"option\", \"value\", \"1000K\", l10n(\"bwlimitHigherSpeed\"));\n\t\t\t\n\t\t\tbandwidthForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"bwF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tbandwidthForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.DATASTORE_SIZE) {\n\t\t\t// Attempt to skip one step if possible\n\t\t\tif(canAutoconfigureDatastoreSize()) {\n\t\t\t\tsuper.writeTemporaryRedirect(ctx, \"step4\", TOADLET_URL+\"?step=\"+WIZARD_STEP.MEMORY);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"step4Title\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode bandwidthInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode bandwidthnfoboxHeader = bandwidthInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode bandwidthInfoboxContent = bandwidthInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tbandwidthnfoboxHeader.addChild(\"#\", l10n(\"datastoreSize\"));\n\t\t\tbandwidthInfoboxContent.addChild(\"#\", l10n(\"datastoreSizeLong\"));\n\t\t\tHTMLNode bandwidthForm = ctx.addFormChild(bandwidthInfoboxContent, \".\", \"dsForm\");\n\t\t\tHTMLNode result = bandwidthForm.addChild(\"select\", \"name\", \"ds\");\n\n\t\t\tOption sizeOption = config.get(\"node\").getOption(\"storeSize\");\n\t\t\tif(!sizeOption.isDefault()) {\n\t\t\t\tlong current = (Long)sizeOption.getValue();\n\t\t\t\tresult.addChild(\"option\", new String[] { \"value\", \"selected\" }, new String[] { SizeUtil.formatSize(current), \"on\" }, l10n(\"currentPrefix\")+\" \"+SizeUtil.formatSize(current));\n\t\t\t}\n\t\t\tresult.addChild(\"option\", \"value\", \"512M\", \"512MiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"1G\", \"1GiB\");\n\t\t\tif(!sizeOption.isDefault())\n\t\t\t\tresult.addChild(\"option\", \"value\", \"2G\", \"2GiB\");\n\t\t\telse\n\t\t\t\tresult.addChild(\"option\", new String[] { \"value\", \"selected\" }, new String[] { \"2G\", \"on\" }, \"2GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"3G\", \"3GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"5G\", \"5GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"10G\", \"10GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"20G\", \"20GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"30G\", \"30GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"50G\", \"50GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"100G\", \"100GiB\");\n\t\t\t\n\t\t\tbandwidthForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"dsF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tbandwidthForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.MEMORY) {\n\t\t\t// FIXME: Get rid of it when the db4o branch is merged or auto-detect it (be careful of classpath's bug @see <freenet.Node>)\n\t\t\t// Attempt to skip one step if possible\n\t\t\tif(!WrapperConfig.canChangeProperties()) {\n\t\t\t\tsuper.writeTemporaryRedirect(ctx, \"step6\", TOADLET_URL+\"?step=\"+WIZARD_STEP.CONGRATZ);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"step6Title\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode memoryInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode memoryInfoboxHeader = memoryInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode memoryInfoboxContent = memoryInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tmemoryInfoboxHeader.addChild(\"#\", l10n(\"memoryLimit\"));\n\t\t\tmemoryInfoboxContent.addChild(\"#\", l10n(\"memoryLimitLong\"));\n\t\t\t\n\t\t\tHTMLNode bandwidthForm = ctx.addFormChild(memoryInfoboxContent, \".\", \"memoryForm\");\n\t\t\tHTMLNode result = bandwidthForm.addChild(\"select\", \"name\", \"memory\");\n\t\t\tresult.addChild(\"option\", \"value\", \"64\", l10n(\"memory.64M\"));\n\t\t\tresult.addChild(\"option\", \"value\", \"128\", l10n(\"memory.128M\"));\n\t\t\tresult.addChild(\"option\", new String[] { \"value\", \"selected\" }, new String[] { \"192\", \"selected\" }, l10n(\"memory.192M\"));\n\t\t\tresult.addChild(\"option\", \"value\", \"256\", l10n(\"memory.256M\"));\n\t\t\tresult.addChild(\"option\", \"value\", \"512\", l10n(\"memory.512M\"));\n\n\t\t\tbandwidthForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"memoryF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tbandwidthForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\n\t\t}else if(currentStep == WIZARD_STEP.CONGRATZ) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"step7Title\"), true, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode congratzInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode congratzInfoboxHeader = congratzInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode congratzInfoboxContent = congratzInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\tcongratzInfoboxHeader.addChild(\"#\", l10n(\"congratz\"));\n\t\t\tcongratzInfoboxContent.addChild(\"p\", l10n(\"congratzLong\"));\n\t\t\t\n\t\t\tcongratzInfoboxContent.addChild(\"a\", \"href\", \"?step=\"+WIZARD_STEP.FINAL, L10n.getString(\"FirstTimeWizardToadlet.continueEnd\"));\n\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.FINAL) {\n\t\t\ttry {\n\t\t\t\tconfig.get(\"fproxy\").set(\"hasCompletedWizard\", true);\n                                config.store();\n\t\t\t\tthis.writeTemporaryRedirect(ctx, \"Return to home\", \"/\");\n\t\t\t} catch (ConfigException e) {\n\t\t\t\tLogger.error(this, e.getMessage(), e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"homepageTitle\"), false, ctx);\n\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\n\t\tHTMLNode welcomeInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\tHTMLNode welcomeInfoboxHeader = welcomeInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\tHTMLNode welcomeInfoboxContent = welcomeInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\twelcomeInfoboxHeader.addChild(\"#\", l10n(\"welcomeInfoboxTitle\"));\n\t\t\n\t\tHTMLNode firstParagraph = welcomeInfoboxContent.addChild(\"p\");\n\t\tfirstParagraph.addChild(\"#\", l10n(\"welcomeInfoboxContent1\"));\n\t\tHTMLNode secondParagraph = welcomeInfoboxContent.addChild(\"p\");\n\t\tsecondParagraph.addChild(\"a\", \"href\", \"?step=\"+WIZARD_STEP.BROWSER_WARNING).addChild(\"#\", L10n.getString(\"FirstTimeWizardToadlet.clickContinue\"));\n\t\t\n\t\tHTMLNode thirdParagraph = welcomeInfoboxContent.addChild(\"p\");\n\t\tthirdParagraph.addChild(\"a\", \"href\", \"?step=\"+WIZARD_STEP.FINAL).addChild(\"#\", l10n(\"skipWizard\"));\n\t\t\n\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t}","id":26384,"modified_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest request, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\tif(!ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, \"Unauthorized\", L10n.getString(\"Toadlet.unauthorized\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tWIZARD_STEP currentStep = WIZARD_STEP.valueOf(request.getParam(\"step\", WIZARD_STEP.WELCOME.toString()));\n\t\t\n\t\tif(currentStep == WIZARD_STEP.BROWSER_WARNING) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"browserWarningPageTitle\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode infoboxHeader = infobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tinfoboxHeader.addChild(\"#\", l10n(\"browserWarningShort\"));\n\t\t\tL10n.addL10nSubstitution(infoboxContent, \"FirstTimeWizardToadlet.browserWarning\", new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\tinfoboxContent.addChild(\"p\", l10n(\"browserWarningSuggestion\"));\n\t\t\t\n\t\t\tinfoboxContent.addChild(\"p\").addChild(\"a\", \"href\", \"?step=\"+WIZARD_STEP.SECURITY_NETWORK, L10n.getString(\"FirstTimeWizardToadlet.clickContinue\"));\n\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.SECURITY_NETWORK) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"networkSecurityPageTitle\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode infoboxHeader = infobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tinfoboxHeader.addChild(\"#\", l10nSec(\"networkThreatLevelShort\"));\n\t\t\tinfoboxContent.addChild(\"p\", l10nSec(\"networkThreatLevel\"));\n\t\t\tHTMLNode form = ctx.addFormChild(infoboxContent, \".\", \"networkSecurityForm\");\n\t\t\tHTMLNode div = form.addChild(\"div\", \"class\", \"opennetDiv\");\n\t\t\tString controlName = \"security-levels.networkThreatLevel\";\n\t\t\tfor(NETWORK_THREAT_LEVEL level : NETWORK_THREAT_LEVEL.values()) {\n\t\t\t\tHTMLNode input;\n\t\t\t\tinput = div.addChild(\"p\").addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"radio\", controlName, level.name() });\n\t\t\t\tinput.addChild(\"b\", l10nSec(\"networkThreatLevel.name.\"+level));\n\t\t\t\tinput.addChild(\"#\", \": \");\n\t\t\t\tL10n.addL10nSubstitution(input, \"SecurityLevels.networkThreatLevel.choice.\"+level, new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\t\tHTMLNode inner = input.addChild(\"p\").addChild(\"i\");\n\t\t\t\tL10n.addL10nSubstitution(inner, \"SecurityLevels.networkThreatLevel.desc.\"+level, new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\t}\n\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"networkSecurityF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.SECURITY_FRIENDS) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"friendsSecurityPageTitle\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode infoboxHeader = infobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tinfoboxHeader.addChild(\"#\", l10nSec(\"friendsThreatLevelShort\"));\n\t\t\tinfoboxContent.addChild(\"p\", l10nSec(\"friendsThreatLevel\"));\n\t\t\tHTMLNode form = ctx.addFormChild(infoboxContent, \".\", \"friendsSecurityForm\");\n\t\t\tHTMLNode div = form.addChild(\"div\", \"class\", \"opennetDiv\");\n\t\t\tString controlName = \"security-levels.friendsThreatLevel\";\n\t\t\tfor(FRIENDS_THREAT_LEVEL level : FRIENDS_THREAT_LEVEL.values()) {\n\t\t\t\tHTMLNode input;\n\t\t\t\tinput = div.addChild(\"p\").addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"radio\", controlName, level.name() });\n\t\t\t\tinput.addChild(\"b\", l10nSec(\"friendsThreatLevel.name.\"+level));\n\t\t\t\tinput.addChild(\"#\", \": \");\n\t\t\t\tL10n.addL10nSubstitution(input, \"SecurityLevels.friendsThreatLevel.choice.\"+level, new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\t\tHTMLNode inner = input.addChild(\"p\").addChild(\"i\");\n\t\t\t\tL10n.addL10nSubstitution(inner, \"SecurityLevels.friendsThreatLevel.desc.\"+level, new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\t}\n\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"friendsSecurityF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.SECURITY_PHYSICAL) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"physicalSecurityPageTitle\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode infoboxHeader = infobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tinfoboxHeader.addChild(\"#\", l10nSec(\"physicalThreatLevelShort\"));\n\t\t\tinfoboxContent.addChild(\"p\", l10nSec(\"physicalThreatLevel\"));\n\t\t\tHTMLNode form = ctx.addFormChild(infoboxContent, \".\", \"physicalSecurityForm\");\n\t\t\tHTMLNode div = form.addChild(\"div\", \"class\", \"opennetDiv\");\n\t\t\tString controlName = \"security-levels.physicalThreatLevel\";\n\t\t\tfor(PHYSICAL_THREAT_LEVEL level : PHYSICAL_THREAT_LEVEL.values()) {\n\t\t\t\tHTMLNode input;\n\t\t\t\tinput = div.addChild(\"p\").addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"radio\", controlName, level.name() });\n\t\t\t\tinput.addChild(\"b\", l10nSec(\"physicalThreatLevel.name.\"+level));\n\t\t\t\tinput.addChild(\"#\", \": \");\n\t\t\t\tL10n.addL10nSubstitution(input, \"SecurityLevels.physicalThreatLevel.choice.\"+level, new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\t\tHTMLNode inner = input.addChild(\"p\").addChild(\"i\");\n\t\t\t\tL10n.addL10nSubstitution(inner, \"SecurityLevels.physicalThreatLevel.desc.\"+level, new String[] { \"bold\", \"/bold\" }, new String[] { \"<b>\", \"<\/b>\" });\n\t\t\t}\n\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"physicalSecurityF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.NAME_SELECTION) {\n\t\t\t// Attempt to skip one step if possible: opennet nodes don't need a name\n\t\t\tif(Boolean.valueOf(request.getParam(\"opennet\"))) {\n\t\t\t\tsuper.writeTemporaryRedirect(ctx, \"step3\", TOADLET_URL+\"?step=\"+WIZARD_STEP.BANDWIDTH);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"step2Title\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode nnameInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode nnameInfoboxHeader = nnameInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode nnameInfoboxContent = nnameInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tnnameInfoboxHeader.addChild(\"#\", l10n(\"chooseNodeName\"));\n\t\t\tnnameInfoboxContent.addChild(\"#\", l10n(\"chooseNodeNameLong\"));\n\t\t\tHTMLNode nnameForm = ctx.addFormChild(nnameInfoboxContent, \".\", \"nnameForm\");\n\t\t\tnnameForm.addChild(\"input\", \"name\", \"nname\");\n\t\t\t\n\t\t\tnnameForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"nnameF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tnnameForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.BANDWIDTH) {\n\t\t\t// Attempt to skip one step if possible\n\t\t\tif(canAutoconfigureBandwidth()){\n\t\t\t\tsuper.writeTemporaryRedirect(ctx, \"step4\", TOADLET_URL+\"?step=\"+WIZARD_STEP.DATASTORE_SIZE);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"step3Title\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode bandwidthInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode bandwidthnfoboxHeader = bandwidthInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode bandwidthInfoboxContent = bandwidthInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tbandwidthnfoboxHeader.addChild(\"#\", l10n(\"bandwidthLimit\"));\n\t\t\tbandwidthInfoboxContent.addChild(\"#\", l10n(\"bandwidthLimitLong\"));\n\t\t\tHTMLNode bandwidthForm = ctx.addFormChild(bandwidthInfoboxContent, \".\", \"bwForm\");\n\t\t\tHTMLNode result = bandwidthForm.addChild(\"select\", \"name\", \"bw\");\n\t\t\t\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tOption<Integer> sizeOption = (Option<Integer>) config.get(\"node\").getOption(\"outputBandwidthLimit\");\n\t\t\tif(!sizeOption.isDefault()) {\n\t\t\t\tint current = sizeOption.getValue();\n\t\t\t\tresult.addChild(\"option\", new String[] { \"value\", \"selected\" }, new String[] { SizeUtil.formatSize(current), \"on\" }, l10n(\"currentSpeed\")+\" \"+SizeUtil.formatSize(current)+\"/s\");\n\t\t\t}\n\n\t\t\t// don't forget to update handlePost too if you change that!\n\t\t\tresult.addChild(\"option\", \"value\", \"8K\", l10n(\"bwlimitLowerSpeed\"));\n\t\t\t// Special case for 128kbps to increase performance at the cost of some link degradation. Above that we use 50% of the limit.\n\t\t\tresult.addChild(\"option\", \"value\", \"12K\", \"512+/128 kbps (12KB/s)\");\n\t\t\tif(!sizeOption.isDefault())\n\t\t\t\tresult.addChild(\"option\", \"value\", \"16K\", \"1024+/256 kbps (16KB/s)\");\n\t\t\telse\n\t\t\t\tresult.addChild(\"option\", new String[] { \"value\", \"selected\" }, new String[] { \"16K\", \"selected\" }, \"1024+/256 kbps (16KB/s)\");\n\t\t\tresult.addChild(\"option\", \"value\", \"32K\", \"1024+/512 kbps (32K/s)\");\n\t\t\tresult.addChild(\"option\", \"value\", \"64K\", \"1024+/1024 kbps (64K/s)\");\n\t\t\tresult.addChild(\"option\", \"value\", \"1000K\", l10n(\"bwlimitHigherSpeed\"));\n\t\t\t\n\t\t\tbandwidthForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"bwF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tbandwidthForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.DATASTORE_SIZE) {\n\t\t\t// Attempt to skip one step if possible\n\t\t\tif(canAutoconfigureDatastoreSize()) {\n\t\t\t\tsuper.writeTemporaryRedirect(ctx, \"step4\", TOADLET_URL+\"?step=\"+WIZARD_STEP.MEMORY);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"step4Title\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode bandwidthInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode bandwidthnfoboxHeader = bandwidthInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode bandwidthInfoboxContent = bandwidthInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tbandwidthnfoboxHeader.addChild(\"#\", l10n(\"datastoreSize\"));\n\t\t\tbandwidthInfoboxContent.addChild(\"#\", l10n(\"datastoreSizeLong\"));\n\t\t\tHTMLNode bandwidthForm = ctx.addFormChild(bandwidthInfoboxContent, \".\", \"dsForm\");\n\t\t\tHTMLNode result = bandwidthForm.addChild(\"select\", \"name\", \"ds\");\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tOption<Long> sizeOption = (Option<Long>) config.get(\"node\").getOption(\"storeSize\");\n\t\t\tif(!sizeOption.isDefault()) {\n\t\t\t\tlong current = sizeOption.getValue();\n\t\t\t\tresult.addChild(\"option\", new String[] { \"value\", \"selected\" }, new String[] { SizeUtil.formatSize(current), \"on\" }, l10n(\"currentPrefix\")+\" \"+SizeUtil.formatSize(current));\n\t\t\t}\n\t\t\tresult.addChild(\"option\", \"value\", \"512M\", \"512MiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"1G\", \"1GiB\");\n\t\t\tif(!sizeOption.isDefault())\n\t\t\t\tresult.addChild(\"option\", \"value\", \"2G\", \"2GiB\");\n\t\t\telse\n\t\t\t\tresult.addChild(\"option\", new String[] { \"value\", \"selected\" }, new String[] { \"2G\", \"on\" }, \"2GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"3G\", \"3GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"5G\", \"5GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"10G\", \"10GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"20G\", \"20GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"30G\", \"30GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"50G\", \"50GiB\");\n\t\t\tresult.addChild(\"option\", \"value\", \"100G\", \"100GiB\");\n\t\t\t\n\t\t\tbandwidthForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"dsF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tbandwidthForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.MEMORY) {\n\t\t\t// FIXME: Get rid of it when the db4o branch is merged or auto-detect it (be careful of classpath's bug @see <freenet.Node>)\n\t\t\t// Attempt to skip one step if possible\n\t\t\tif(!WrapperConfig.canChangeProperties()) {\n\t\t\t\tsuper.writeTemporaryRedirect(ctx, \"step6\", TOADLET_URL+\"?step=\"+WIZARD_STEP.CONGRATZ);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"step6Title\"), false, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode memoryInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode memoryInfoboxHeader = memoryInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode memoryInfoboxContent = memoryInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\n\t\t\tmemoryInfoboxHeader.addChild(\"#\", l10n(\"memoryLimit\"));\n\t\t\tmemoryInfoboxContent.addChild(\"#\", l10n(\"memoryLimitLong\"));\n\t\t\t\n\t\t\tHTMLNode bandwidthForm = ctx.addFormChild(memoryInfoboxContent, \".\", \"memoryForm\");\n\t\t\tHTMLNode result = bandwidthForm.addChild(\"select\", \"name\", \"memory\");\n\t\t\tresult.addChild(\"option\", \"value\", \"64\", l10n(\"memory.64M\"));\n\t\t\tresult.addChild(\"option\", \"value\", \"128\", l10n(\"memory.128M\"));\n\t\t\tresult.addChild(\"option\", new String[] { \"value\", \"selected\" }, new String[] { \"192\", \"selected\" }, l10n(\"memory.192M\"));\n\t\t\tresult.addChild(\"option\", \"value\", \"256\", l10n(\"memory.256M\"));\n\t\t\tresult.addChild(\"option\", \"value\", \"512\", l10n(\"memory.512M\"));\n\n\t\t\tbandwidthForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"memoryF\", L10n.getString(\"FirstTimeWizardToadlet.continue\")});\n\t\t\tbandwidthForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\")});\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\n\t\t}else if(currentStep == WIZARD_STEP.CONGRATZ) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"step7Title\"), true, ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\n\t\t\tHTMLNode congratzInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode congratzInfoboxHeader = congratzInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tHTMLNode congratzInfoboxContent = congratzInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\tcongratzInfoboxHeader.addChild(\"#\", l10n(\"congratz\"));\n\t\t\tcongratzInfoboxContent.addChild(\"p\", l10n(\"congratzLong\"));\n\t\t\t\n\t\t\tcongratzInfoboxContent.addChild(\"a\", \"href\", \"?step=\"+WIZARD_STEP.FINAL, L10n.getString(\"FirstTimeWizardToadlet.continueEnd\"));\n\n\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t} else if(currentStep == WIZARD_STEP.FINAL) {\n\t\t\ttry {\n\t\t\t\tconfig.get(\"fproxy\").set(\"hasCompletedWizard\", true);\n                                config.store();\n\t\t\t\tthis.writeTemporaryRedirect(ctx, \"Return to home\", \"/\");\n\t\t\t} catch (ConfigException e) {\n\t\t\t\tLogger.error(this, e.getMessage(), e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"homepageTitle\"), false, ctx);\n\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\n\t\tHTMLNode welcomeInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\tHTMLNode welcomeInfoboxHeader = welcomeInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\tHTMLNode welcomeInfoboxContent = welcomeInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\twelcomeInfoboxHeader.addChild(\"#\", l10n(\"welcomeInfoboxTitle\"));\n\t\t\n\t\tHTMLNode firstParagraph = welcomeInfoboxContent.addChild(\"p\");\n\t\tfirstParagraph.addChild(\"#\", l10n(\"welcomeInfoboxContent1\"));\n\t\tHTMLNode secondParagraph = welcomeInfoboxContent.addChild(\"p\");\n\t\tsecondParagraph.addChild(\"a\", \"href\", \"?step=\"+WIZARD_STEP.BROWSER_WARNING).addChild(\"#\", L10n.getString(\"FirstTimeWizardToadlet.clickContinue\"));\n\t\t\n\t\tHTMLNode thirdParagraph = welcomeInfoboxContent.addChild(\"p\");\n\t\tthirdParagraph.addChild(\"a\", \"href\", \"?step=\"+WIZARD_STEP.FINAL).addChild(\"#\", l10n(\"skipWizard\"));\n\t\t\n\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t}","commit_id":"f8f3a82ed849ce6d5388245ca6f521c76e4fd6e9","url":"https://github.com/freenet/fred"},{"original_method":"private void getCSV() {\n    InputStream inputStream = null;\n    try {\n      CsvInputMeta meta = new CsvInputMeta();\n      getInfo( meta );\n\n      String filename = transMeta.environmentSubstitute( meta.getFilename() );\n      String delimiter = transMeta.environmentSubstitute( meta.getDelimiter() );\n\n      FileObject fileObject = KettleVFS.getFileObject( filename );\n      if ( !( fileObject instanceof LocalFile ) ) {\n        // We can only use NIO on local files at the moment, so that's what we\n        // limit ourselves to.\n        //\n        throw new KettleException( BaseMessages.getString( PKG, \"CsvInput.Log.OnlyLocalFilesAreSupported\" ) );\n      }\n\n      wFields.table.removeAll();\n\n      inputStream = KettleVFS.getInputStream( fileObject );\n\n      InputStreamReader reader;\n      if ( Const.isEmpty( meta.getEncoding() ) ) {\n        reader = new InputStreamReader( inputStream );\n      } else {\n        reader = new InputStreamReader( inputStream, meta.getEncoding() );\n      }\n\n      EncodingType encodingType = EncodingType.guessEncodingType( reader.getEncoding() );\n\n      // Read a line of data to determine the number of rows...\n      //\n      String line =\n        TextFileInput.getLine(\n          log, reader, encodingType, TextFileInputMeta.FILE_FORMAT_MIXED, new StringBuilder( 1000 ) );\n\n      // Split the string, header or data into parts...\n      //\n      String[] fieldNames =\n        CsvInput.guessStringsFromLine( log, line, delimiter, meta.getEnclosure(), meta.getEscapeCharacter() );\n\n      if ( !meta.isHeaderPresent() ) {\n        // Don't use field names from the header...\n        // Generate field names F1 ... F10\n        //\n        DecimalFormat df = new DecimalFormat( \"000\" );\n        for ( int i = 0; i < fieldNames.length; i++ ) {\n          fieldNames[i] = \"Field_\" + df.format( i );\n        }\n      } else {\n        if ( !Const.isEmpty( meta.getEnclosure() ) ) {\n          for ( int i = 0; i < fieldNames.length; i++ ) {\n            if ( fieldNames[i].startsWith( meta.getEnclosure() )\n              && fieldNames[i].endsWith( meta.getEnclosure() ) && fieldNames[i].length() > 1 ) {\n              fieldNames[i] = fieldNames[i].substring( 1, fieldNames[i].length() - 1 );\n            }\n          }\n        }\n      }\n\n      // Trim the names to make sure...\n      //\n      for ( int i = 0; i < fieldNames.length; i++ ) {\n        fieldNames[i] = Const.trim( fieldNames[i] );\n      }\n\n      // Update the GUI\n      //\n      for ( int i = 0; i < fieldNames.length; i++ ) {\n        TableItem item = new TableItem( wFields.table, SWT.NONE );\n        item.setText( 1, fieldNames[i] );\n        item.setText( 2, ValueMeta.getTypeDesc( ValueMetaInterface.TYPE_STRING ) );\n      }\n      wFields.removeEmptyRows();\n      wFields.setRowNums();\n      wFields.optWidth( true );\n\n      // Now we can continue reading the rows of data and we can guess the\n      // Sample a few lines to determine the correct type of the fields...\n      //\n      String shellText = BaseMessages.getString( PKG, \"CsvInputDialog.LinesToSample.DialogTitle\" );\n      String lineText = BaseMessages.getString( PKG, \"CsvInputDialog.LinesToSample.DialogMessage\" );\n      EnterNumberDialog end = new EnterNumberDialog( shell, 100, shellText, lineText );\n      int samples = end.open();\n      if ( samples >= 0 ) {\n        getInfo( meta );\n\n        TextFileCSVImportProgressDialog pd =\n          new TextFileCSVImportProgressDialog( shell, meta, transMeta, reader, samples, true );\n        String message = pd.open();\n        if ( message != null ) {\n          wFields.removeAll();\n\n          // OK, what's the result of our search?\n          getData( meta, false );\n          wFields.removeEmptyRows();\n          wFields.setRowNums();\n          wFields.optWidth( true );\n\n          EnterTextDialog etd =\n            new EnterTextDialog(\n              shell, BaseMessages.getString( PKG, \"CsvInputDialog.ScanResults.DialogTitle\" ), BaseMessages\n                .getString( PKG, \"CsvInputDialog.ScanResults.DialogMessage\" ), message, true );\n          etd.setReadOnly();\n          etd.open();\n\n          // asyncUpdatePreview();\n        }\n      }\n    } catch ( IOException e ) {\n      new ErrorDialog( shell, BaseMessages.getString( PKG, \"CsvInputDialog.IOError.DialogTitle\" ), BaseMessages\n        .getString( PKG, \"CsvInputDialog.IOError.DialogMessage\" ), e );\n    } catch ( KettleException e ) {\n      new ErrorDialog( shell, BaseMessages.getString( PKG, \"System.Dialog.Error.Title\" ), BaseMessages.getString(\n        PKG, \"CsvInputDialog.ErrorGettingFileDesc.DialogMessage\" ), e );\n    } finally {\n      try {\n        inputStream.close();\n      } catch ( Exception e ) {\n        // Ignore close errors\n      }\n    }\n  }","id":26385,"modified_method":"private void getCSV() {\n    InputStream inputStream = null;\n    try {\n      CsvInputMeta meta = new CsvInputMeta();\n      getInfo( meta );\n\n      String filename = transMeta.environmentSubstitute( meta.getFilename() );\n      String delimiter = transMeta.environmentSubstitute( meta.getDelimiter() );\n\n      FileObject fileObject = KettleVFS.getFileObject( filename );\n      if ( !( fileObject instanceof LocalFile ) ) {\n        // We can only use NIO on local files at the moment, so that's what we\n        // limit ourselves to.\n        //\n        throw new KettleException( BaseMessages.getString( PKG, \"CsvInput.Log.OnlyLocalFilesAreSupported\" ) );\n      }\n\n      wFields.table.removeAll();\n\n      inputStream = KettleVFS.getInputStream( fileObject );\n\n      String realEncoding = transMeta.environmentSubstitute( meta.getEncoding() );\n      InputStreamReader reader;\n      if ( Const.isEmpty( realEncoding ) ) {\n        reader = new InputStreamReader( inputStream );\n      } else {\n        reader = new InputStreamReader( inputStream, realEncoding );\n      }\n\n      EncodingType encodingType = EncodingType.guessEncodingType( reader.getEncoding() );\n\n      // Read a line of data to determine the number of rows...\n      //\n      String line =\n        TextFileInput.getLine(\n          log, reader, encodingType, TextFileInputMeta.FILE_FORMAT_MIXED, new StringBuilder( 1000 ) );\n\n      // Split the string, header or data into parts...\n      //\n      String[] fieldNames =\n        CsvInput.guessStringsFromLine( log, line, delimiter, meta.getEnclosure(), meta.getEscapeCharacter() );\n\n      if ( !meta.isHeaderPresent() ) {\n        // Don't use field names from the header...\n        // Generate field names F1 ... F10\n        //\n        DecimalFormat df = new DecimalFormat( \"000\" );\n        for ( int i = 0; i < fieldNames.length; i++ ) {\n          fieldNames[i] = \"Field_\" + df.format( i );\n        }\n      } else {\n        if ( !Const.isEmpty( meta.getEnclosure() ) ) {\n          for ( int i = 0; i < fieldNames.length; i++ ) {\n            if ( fieldNames[i].startsWith( meta.getEnclosure() )\n              && fieldNames[i].endsWith( meta.getEnclosure() ) && fieldNames[i].length() > 1 ) {\n              fieldNames[i] = fieldNames[i].substring( 1, fieldNames[i].length() - 1 );\n            }\n          }\n        }\n      }\n\n      // Trim the names to make sure...\n      //\n      for ( int i = 0; i < fieldNames.length; i++ ) {\n        fieldNames[i] = Const.trim( fieldNames[i] );\n      }\n\n      // Update the GUI\n      //\n      for ( int i = 0; i < fieldNames.length; i++ ) {\n        TableItem item = new TableItem( wFields.table, SWT.NONE );\n        item.setText( 1, fieldNames[i] );\n        item.setText( 2, ValueMeta.getTypeDesc( ValueMetaInterface.TYPE_STRING ) );\n      }\n      wFields.removeEmptyRows();\n      wFields.setRowNums();\n      wFields.optWidth( true );\n\n      // Now we can continue reading the rows of data and we can guess the\n      // Sample a few lines to determine the correct type of the fields...\n      //\n      String shellText = BaseMessages.getString( PKG, \"CsvInputDialog.LinesToSample.DialogTitle\" );\n      String lineText = BaseMessages.getString( PKG, \"CsvInputDialog.LinesToSample.DialogMessage\" );\n      EnterNumberDialog end = new EnterNumberDialog( shell, 100, shellText, lineText );\n      int samples = end.open();\n      if ( samples >= 0 ) {\n        getInfo( meta );\n\n        TextFileCSVImportProgressDialog pd =\n          new TextFileCSVImportProgressDialog( shell, meta, transMeta, reader, samples, true );\n        String message = pd.open();\n        if ( message != null ) {\n          wFields.removeAll();\n\n          // OK, what's the result of our search?\n          getData( meta, false );\n          wFields.removeEmptyRows();\n          wFields.setRowNums();\n          wFields.optWidth( true );\n\n          EnterTextDialog etd =\n            new EnterTextDialog(\n              shell, BaseMessages.getString( PKG, \"CsvInputDialog.ScanResults.DialogTitle\" ), BaseMessages\n                .getString( PKG, \"CsvInputDialog.ScanResults.DialogMessage\" ), message, true );\n          etd.setReadOnly();\n          etd.open();\n\n          // asyncUpdatePreview();\n        }\n      }\n    } catch ( IOException e ) {\n      new ErrorDialog( shell, BaseMessages.getString( PKG, \"CsvInputDialog.IOError.DialogTitle\" ), BaseMessages\n        .getString( PKG, \"CsvInputDialog.IOError.DialogMessage\" ), e );\n    } catch ( KettleException e ) {\n      new ErrorDialog( shell, BaseMessages.getString( PKG, \"System.Dialog.Error.Title\" ), BaseMessages.getString(\n        PKG, \"CsvInputDialog.ErrorGettingFileDesc.DialogMessage\" ), e );\n    } finally {\n      try {\n        inputStream.close();\n      } catch ( Exception e ) {\n        // Ignore close errors\n      }\n    }\n  }","commit_id":"e343f2173ffd4b0cc0a7a5b7ac5c277f73f9671c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Object[] addSequence(RowMetaInterface inputRowMeta, Object[] inputRowData) throws KettleException\n\t{\n\t\tObject next = null;\n\t\t\n\t\tif (meta.isCounterUsed()) {\n\t\t\tsynchronized (data.counter) {\n\t\t\t\tlong prev = data.counter.getCounter();\n\t\t\t\t\n\t\t\t\tlong nval = prev + data.increment;\n\t\t\t\tif (data.increment > 0 && data.maximum > data.start && nval > data.maximum)\n\t\t\t\t\tnval = data.start;\n\t\t\t\tif (data.increment < 0 && data.maximum < data.start && nval < data.maximum)\n\t\t\t\t\tnval = data.start;\n\t\t\t\tdata.counter.setCounter(nval);\n\t\n\t\t\t\tnext = prev;\n\t\t\t}\n\t\t} else if (meta.isDatabaseUsed()) {\n\t\t\ttry {\n\t\t\t\tnext = data.getDb().getNextSequenceValue(environmentSubstitute(meta.getSchemaName()), \n\t\t\t\t\t\t                                 environmentSubstitute(meta.getSequenceName()), \n\t\t\t\t\t\t                                 meta.getValuename());\n\t\t\t} catch (KettleDatabaseException dbe) {\n\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"AddSequence.Exception.ErrorReadingSequence\", meta.getSequenceName()), dbe); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t\t} else {\n\t\t\t// This should never happen, but if it does, don't continue!!!\n\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"AddSequence.Exception.NoSpecifiedMethod\")); //$NON-NLS-1$\n\t\t}\n\t\t\n\t\tif (next!=null)\n\t\t{\n\t\t\tObject[] outputRowData = inputRowData;\n\t\t\tif (inputRowData.length<inputRowMeta.size()+1) {\n\t\t\t\toutputRowData = RowDataUtil.resizeArray(inputRowData, inputRowMeta.size()+1);\n\t\t\t}\n\t\t\toutputRowData[inputRowMeta.size()]=next;\n\t\t\treturn outputRowData;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"AddSequence.Exception.CouldNotFindNextValueForSequence\")+meta.getValuename()); //$NON-NLS-1$\n\t\t}\n\t}","id":26386,"modified_method":"public Object[] addSequence(RowMetaInterface inputRowMeta, Object[] inputRowData) throws KettleException\n\t{\n\t\tObject next = null;\n\t\t\n\t\tif (meta.isCounterUsed()) {\n\t\t\tsynchronized (data.counter) {\n\t\t\t\tlong prev = data.counter.getCounter();\n\t\t\t\t\n\t\t\t\tlong nval = prev + data.increment;\n\t\t\t\tif (data.increment > 0 && data.maximum > data.start && nval > data.maximum)\n\t\t\t\t\tnval = data.start;\n\t\t\t\tif (data.increment < 0 && data.maximum < data.start && nval < data.maximum)\n\t\t\t\t\tnval = data.start;\n\t\t\t\tdata.counter.setCounter(nval);\n\t\n\t\t\t\tnext = prev;\n\t\t\t}\n\t\t} else if (meta.isDatabaseUsed()) {\n\t\t\ttry {\n\t\t\t\tnext = data.getDb().getNextSequenceValue(data.realSchemaName, data.realSequenceName, meta.getValuename());\n\t\t\t} catch (KettleDatabaseException dbe) {\n\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"AddSequence.Exception.ErrorReadingSequence\", data.realSequenceName), dbe); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t\t} else {\n\t\t\t// This should never happen, but if it does, don't continue!!!\n\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"AddSequence.Exception.NoSpecifiedMethod\")); //$NON-NLS-1$\n\t\t}\n\t\t\n\t\tif (next!=null)\n\t\t{\n\t\t\tObject[] outputRowData = inputRowData;\n\t\t\tif (inputRowData.length<inputRowMeta.size()+1) {\n\t\t\t\toutputRowData = RowDataUtil.resizeArray(inputRowData, inputRowMeta.size()+1);\n\t\t\t}\n\t\t\toutputRowData[inputRowMeta.size()]=next;\n\t\t\treturn outputRowData;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"AddSequence.Exception.CouldNotFindNextValueForSequence\")+meta.getValuename()); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"dd79c709de153abbc29156eb1cbb12f9e5ee8da6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\t\t\n\t\tmeta=(AddSequenceMeta)smi;\n\t\tdata=(AddSequenceData)sdi;\n\n\t\tif (super.init(smi, sdi))\n\t\t{\n\t\t\tif (meta.isDatabaseUsed())\n\t\t\t{\n\t\t\t\tDatabase db = new Database(meta.getDatabase());\n\t\t\t\tdb.shareVariablesWith(this);\n\t\t\t\tdata.setDb( db );\t\t\t\n\t\t\t\ttry\n\t\t\t\t{\r\n\t\t\t\t\tif (getTransMeta().isUsingUniqueConnections()) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsynchronized (getTrans()) { data.getDb().connect(getTrans().getThreadName(), getPartitionID()); }\r\n\t\t\t\t\t} \r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdata.getDb().connect(getPartitionID()); \r\n\t\t\t\t\t}\n\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"AddSequence.Log.ConnectedDB\")); //$NON-NLS-1$\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tcatch(KettleDatabaseException dbe)\n\t\t\t\t{\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.CouldNotConnectToDB\")+dbe.getMessage()); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (meta.isCounterUsed())\n\t\t\t{\r\n\t\t\t\t// Do the environment translations of the counter values.\r\n\t\t\t\tboolean doAbort = false;\r\n\t\t\t\ttry \r\n\t\t\t\t{\r\n\t\t\t\t\tdata.start = Long.parseLong(environmentSubstitute(meta.getStartAt()));\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( NumberFormatException ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.CouldNotParseCounterValue\", \"start\", meta.getStartAt(), environmentSubstitute(meta.getStartAt()), ex.getMessage())); //$NON-NLS-1$\r\n\t\t\t\t\tdoAbort = true;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ttry \r\n\t\t\t\t{\r\n\t\t\t\t\tdata.increment = Long.parseLong(environmentSubstitute(meta.getIncrementBy()));\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( NumberFormatException ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.CouldNotParseCounterValue\", \"increment\", meta.getIncrementBy(), environmentSubstitute(meta.getIncrementBy()), ex.getMessage())); //$NON-NLS-1$\r\n\t\t\t\t\tdoAbort = true;\r\n\t\t\t\t}\t\t\t\t\r\n\r\n\t\t\t\ttry \r\n\t\t\t\t{\r\n\t\t\t\t\tdata.maximum = Long.parseLong(environmentSubstitute(meta.getMaxValue()));\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( NumberFormatException ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.CouldNotParseCounterValue\", \"increment\", meta.getMaxValue(), environmentSubstitute(meta.getMaxValue()), ex.getMessage())); //$NON-NLS-1$\r\n\t\t\t\t\tdoAbort = true;\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tif ( doAbort )\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\n                if (!Const.isEmpty(meta.getCounterName()))\n                {\n                    data.setLookup( \"@@sequence:\"+meta.getCounterName() ); //$NON-NLS-1$\n                }\n                else\n                {\n                    data.setLookup( \"@@sequence:\"+meta.getValuename() ); //$NON-NLS-1$\n                }\n\n\t\t\t\tif (getTransMeta().getCounters()!=null)\n\t\t\t\t{\n\t\t\t\t\t//check if counter exists\n\t\t\t\t\tsynchronized (getTransMeta().getCounters()){\n\t\t\t\t\t\tdata.counter=getTransMeta().getCounters().get(data.getLookup());\n\t\t\t\t\t\tif (data.counter==null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// create a new one\n\t\t\t\t\t\t\tdata.counter = new Counter(data.start, data.increment, data.maximum);\n\t\t\t\t\t\t\tgetTransMeta().getCounters().put(data.getLookup(), data.counter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Check whether counter characteristics are the same as a previously\n\t\t\t\t\t\t\t// defined counter with the same name.\n\t\t\t\t\t\t\tif ( (data.counter.getStart() != data.start) ||\n\t\t\t\t\t\t\t   \t (data.counter.getIncrement() != data.increment) ||\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t (data.counter.getMaximum() != data.maximum) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.CountersWithDifferentCharacteristics\", data.getLookup())); //$NON-NLS-1$\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.TransformationCountersHashtableNotAllocated\")); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.NeedToSelectSequence\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":26387,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\t\t\n\t\tmeta=(AddSequenceMeta)smi;\n\t\tdata=(AddSequenceData)sdi;\n\n\t\tif (super.init(smi, sdi))\n\t\t{\r\n\t\t\tdata.realSchemaName=environmentSubstitute(meta.getSchemaName());\r\n\t\t\tdata.realSequenceName=environmentSubstitute(meta.getSequenceName());\n\t\t\tif (meta.isDatabaseUsed())\n\t\t\t{\n\t\t\t\tDatabase db = new Database(meta.getDatabase());\n\t\t\t\tdb.shareVariablesWith(this);\n\t\t\t\tdata.setDb( db );\t\t\t\n\t\t\t\ttry\n\t\t\t\t{\r\n\t\t\t\t\tif (getTransMeta().isUsingUniqueConnections()) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsynchronized (getTrans()) { data.getDb().connect(getTrans().getThreadName(), getPartitionID()); }\r\n\t\t\t\t\t} \r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdata.getDb().connect(getPartitionID()); \r\n\t\t\t\t\t}\n\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"AddSequence.Log.ConnectedDB\")); //$NON-NLS-1$\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tcatch(KettleDatabaseException dbe)\n\t\t\t\t{\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.CouldNotConnectToDB\")+dbe.getMessage()); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (meta.isCounterUsed())\n\t\t\t{\r\n\t\t\t\t// Do the environment translations of the counter values.\r\n\t\t\t\tboolean doAbort = false;\r\n\t\t\t\ttry \r\n\t\t\t\t{\r\n\t\t\t\t\tdata.start = Long.parseLong(environmentSubstitute(meta.getStartAt()));\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( NumberFormatException ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.CouldNotParseCounterValue\", \"start\", meta.getStartAt(), environmentSubstitute(meta.getStartAt()), ex.getMessage())); //$NON-NLS-1$\r\n\t\t\t\t\tdoAbort = true;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ttry \r\n\t\t\t\t{\r\n\t\t\t\t\tdata.increment = Long.parseLong(environmentSubstitute(meta.getIncrementBy()));\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( NumberFormatException ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.CouldNotParseCounterValue\", \"increment\", meta.getIncrementBy(), environmentSubstitute(meta.getIncrementBy()), ex.getMessage())); //$NON-NLS-1$\r\n\t\t\t\t\tdoAbort = true;\r\n\t\t\t\t}\t\t\t\t\r\n\r\n\t\t\t\ttry \r\n\t\t\t\t{\r\n\t\t\t\t\tdata.maximum = Long.parseLong(environmentSubstitute(meta.getMaxValue()));\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( NumberFormatException ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.CouldNotParseCounterValue\", \"increment\", meta.getMaxValue(), environmentSubstitute(meta.getMaxValue()), ex.getMessage())); //$NON-NLS-1$\r\n\t\t\t\t\tdoAbort = true;\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tif ( doAbort )\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tString realCounterName=environmentSubstitute(meta.getCounterName());\n                if (!Const.isEmpty(realCounterName))\n                {\n                    data.setLookup( \"@@sequence:\"+meta.getCounterName() ); //$NON-NLS-1$\n                }\n                else\n                {\n                    data.setLookup( \"@@sequence:\"+meta.getValuename() ); //$NON-NLS-1$\n                }\n\n\t\t\t\tif (getTransMeta().getCounters()!=null)\n\t\t\t\t{\n\t\t\t\t\t//check if counter exists\n\t\t\t\t\tsynchronized (getTransMeta().getCounters()){\n\t\t\t\t\t\tdata.counter=getTransMeta().getCounters().get(data.getLookup());\n\t\t\t\t\t\tif (data.counter==null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// create a new one\n\t\t\t\t\t\t\tdata.counter = new Counter(data.start, data.increment, data.maximum);\n\t\t\t\t\t\t\tgetTransMeta().getCounters().put(data.getLookup(), data.counter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Check whether counter characteristics are the same as a previously\n\t\t\t\t\t\t\t// defined counter with the same name.\n\t\t\t\t\t\t\tif ( (data.counter.getStart() != data.start) ||\n\t\t\t\t\t\t\t   \t (data.counter.getIncrement() != data.increment) ||\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t (data.counter.getMaximum() != data.maximum) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.CountersWithDifferentCharacteristics\", data.getLookup())); //$NON-NLS-1$\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.TransformationCountersHashtableNotAllocated\")); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"AddSequence.Log.NeedToSelectSequence\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"dd79c709de153abbc29156eb1cbb12f9e5ee8da6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * \n\t */\n\tpublic AddSequenceData()\n\t{\n\t\tsuper();\n\n\t\tdb=null;\n\t}","id":26388,"modified_method":"/**\n\t * \n\t */\n\tpublic AddSequenceData()\n\t{\n\t\tsuper();\n\n\t\tdb=null;\r\n\t\trealSchemaName=null;\r\n\t\trealSequenceName=null;\n\t}","commit_id":"dd79c709de153abbc29156eb1cbb12f9e5ee8da6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void check(List<CheckResultInterface> remarks, TransMeta transMeta, StepMeta stepMeta, RowMetaInterface prev, String input[], String output[], RowMetaInterface info)\n\t{\n\t\tCheckResult cr;\n\t\tif (useDatabase)\n\t\t{\n\t\t\tDatabase db = new Database(database);\n\t\t\tdb.shareVariablesWith(transMeta);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdb.connect();\n\t\t\t\tif (db.checkSequenceExists(schemaName, sequenceName))\n\t\t\t\t{\n\t\t\t\t\tcr = new CheckResult(CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString(PKG, \"AddSequenceMeta.CheckResult.SequenceExists.Title\"), stepMeta); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcr = new CheckResult(CheckResultInterface.TYPE_RESULT_ERROR, BaseMessages.getString(PKG, \"AddSequenceMeta.CheckResult.SequenceCouldNotBeFound.Title\",sequenceName), stepMeta); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(KettleException e)\n\t\t\t{\n\t\t\t\tcr = new CheckResult(CheckResultInterface.TYPE_RESULT_ERROR, BaseMessages.getString(PKG, \"AddSequenceMeta.CheckResult.UnableToConnectDB.Title\")+Const.CR+e.getMessage(), stepMeta); //$NON-NLS-1$\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tdb.disconnect();\n\t\t\t}\n\t\t\tremarks.add(cr);\n\t\t}\n\t\t\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString(PKG, \"AddSequenceMeta.CheckResult.StepIsReceving.Title\"), stepMeta); //$NON-NLS-1$\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResultInterface.TYPE_RESULT_ERROR, BaseMessages.getString(PKG, \"AddSequenceMeta.CheckResult.NoInputReceived.Title\"), stepMeta); //$NON-NLS-1$\n\t\t\tremarks.add(cr);\n\t\t}\n\t}","id":26389,"modified_method":"public void check(List<CheckResultInterface> remarks, TransMeta transMeta, StepMeta stepMeta, RowMetaInterface prev, String input[], String output[], RowMetaInterface info)\n\t{\n\t\tCheckResult cr;\n\t\tif (useDatabase)\n\t\t{\n\t\t\tDatabase db = new Database(database);\n\t\t\tdb.shareVariablesWith(transMeta);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdb.connect();\n\t\t\t\tif (db.checkSequenceExists(transMeta.environmentSubstitute(schemaName), transMeta.environmentSubstitute(sequenceName)))\n\t\t\t\t{\n\t\t\t\t\tcr = new CheckResult(CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString(PKG, \"AddSequenceMeta.CheckResult.SequenceExists.Title\"), stepMeta); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcr = new CheckResult(CheckResultInterface.TYPE_RESULT_ERROR, BaseMessages.getString(PKG, \"AddSequenceMeta.CheckResult.SequenceCouldNotBeFound.Title\",sequenceName), stepMeta); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(KettleException e)\n\t\t\t{\n\t\t\t\tcr = new CheckResult(CheckResultInterface.TYPE_RESULT_ERROR, BaseMessages.getString(PKG, \"AddSequenceMeta.CheckResult.UnableToConnectDB.Title\")+Const.CR+e.getMessage(), stepMeta); //$NON-NLS-1$\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tdb.disconnect();\n\t\t\t}\n\t\t\tremarks.add(cr);\n\t\t}\n\t\t\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString(PKG, \"AddSequenceMeta.CheckResult.StepIsReceving.Title\"), stepMeta); //$NON-NLS-1$\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResultInterface.TYPE_RESULT_ERROR, BaseMessages.getString(PKG, \"AddSequenceMeta.CheckResult.NoInputReceived.Title\"), stepMeta); //$NON-NLS-1$\n\t\t\tremarks.add(cr);\n\t\t}\n\t}","commit_id":"dd79c709de153abbc29156eb1cbb12f9e5ee8da6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean connectToFTP() {\n    boolean retval = false;\n    try {\n      if ( ftpclient == null || !ftpclient.connected() ) {\n        // Create ftp client to host:port ...\n        ftpclient = new FTPClient();\n        String realServername = jobMeta.environmentSubstitute( wServerName.getText() );\n        ftpclient.setRemoteAddr( InetAddress.getByName( realServername ) );\n\n        if ( !Const.isEmpty( wProxyHost.getText() ) ) {\n          String realProxy_host = jobMeta.environmentSubstitute( wProxyHost.getText() );\n          ftpclient.setRemoteAddr( InetAddress.getByName( realProxy_host ) );\n          if ( Const.isEmpty( wPort.getText() ) ) {\n            ftpclient.setRemotePort( Const.toInt( wPort.getText(), 21 ) );\n          }\n\n          // FIXME: Proper default port for proxy\n          int port = Const.toInt( jobMeta.environmentSubstitute( wProxyHost.getText() ), 21 );\n          if ( port != 0 ) {\n            ftpclient.setRemotePort( port );\n          }\n        } else {\n          ftpclient.setRemoteAddr( InetAddress.getByName( realServername ) );\n\n        }\n\n        // login to ftp host ...\n        ftpclient.connect();\n        String realUsername =\n          jobMeta.environmentSubstitute( wUserName.getText() )\n            + ( !Const.isEmpty( wProxyHost.getText() ) ? \"@\" + realServername : \"\" )\n            + ( !Const.isEmpty( wProxyUsername.getText() ) ? \" \"\n              + jobMeta.environmentSubstitute( wProxyUsername.getText() ) : \"\" );\n\n        String realPassword =\n          jobMeta.environmentSubstitute( wPassword.getText() )\n            + ( !Const.isEmpty( wProxyPassword.getText() ) ? \" \"\n              + jobMeta.environmentSubstitute( wProxyPassword.getText() ) : \"\" );\n        // login now ...\n        ftpclient.login( realUsername, realPassword );\n        pwdFolder = ftpclient.pwd();\n      }\n      retval = true;\n    } catch ( Exception e ) {\n      MessageBox mb = new MessageBox( shell, SWT.OK | SWT.ICON_ERROR );\n      mb.setMessage( BaseMessages.getString( PKG, \"JobFTPDelete.ErrorConnect.NOK\", e.getMessage() ) + Const.CR );\n      mb.setText( BaseMessages.getString( PKG, \"JobFTPDelete.ErrorConnect.Title.Bad\" ) );\n      mb.open();\n    }\n    return retval;\n  }","id":26390,"modified_method":"private boolean connectToFTP() {\n    boolean retval = false;\n    try {\n      if ( ftpclient == null || !ftpclient.connected() ) {\n        // Create ftp client to host:port ...\n        ftpclient = new FTPClient();\n        String realServername = jobMeta.environmentSubstitute( wServerName.getText() );\n        int realPort = Const.toInt( jobMeta.environmentSubstitute( wPort.getText() ), 21 );\n        ftpclient.setRemoteAddr( InetAddress.getByName( realServername ) );\n        ftpclient.setRemotePort( realPort );\n\n        if ( !Const.isEmpty( wProxyHost.getText() ) ) {\n          String realProxy_host = jobMeta.environmentSubstitute( wProxyHost.getText() );\n          ftpclient.setRemoteAddr( InetAddress.getByName( realProxy_host ) );\n\n          int port = Const.toInt( jobMeta.environmentSubstitute( wProxyPort.getText() ), 21 );\n          if ( port != 0 ) {\n            ftpclient.setRemotePort( port );\n          }\n        }\n\n        // login to ftp host ...\n        ftpclient.connect();\n        String realUsername =\n          jobMeta.environmentSubstitute( wUserName.getText() )\n            + ( !Const.isEmpty( wProxyHost.getText() ) ? \"@\" + realServername : \"\" )\n            + ( !Const.isEmpty( wProxyUsername.getText() ) ? \" \"\n              + jobMeta.environmentSubstitute( wProxyUsername.getText() ) : \"\" );\n\n        String realPassword =\n          jobMeta.environmentSubstitute( wPassword.getText() )\n            + ( !Const.isEmpty( wProxyPassword.getText() ) ? \" \"\n              + jobMeta.environmentSubstitute( wProxyPassword.getText() ) : \"\" );\n        // login now ...\n        ftpclient.login( realUsername, realPassword );\n        pwdFolder = ftpclient.pwd();\n      }\n      retval = true;\n    } catch ( Exception e ) {\n      MessageBox mb = new MessageBox( shell, SWT.OK | SWT.ICON_ERROR );\n      mb.setMessage( BaseMessages.getString( PKG, \"JobFTPDelete.ErrorConnect.NOK\", e.getMessage() ) + Const.CR );\n      mb.setText( BaseMessages.getString( PKG, \"JobFTPDelete.ErrorConnect.Title.Bad\" ) );\n      mb.open();\n    }\n    return retval;\n  }","commit_id":"36ef1a5cd33fb37488baaea0509bd1c79ded9214","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryInterface open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        pwdFolder = null;\n        ftpclient = null;\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobFTP.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Job entry name line\n    wName =\n      new LabelText( shell, BaseMessages.getString( PKG, \"JobFTP.Name.Label\" ), BaseMessages.getString(\n        PKG, \"JobFTP.Name.Tooltip\" ) );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.top = new FormAttachment( 0, 0 );\n    fdName.left = new FormAttachment( 0, 0 );\n    fdName.right = new FormAttachment( 100, 0 );\n    wName.setLayoutData( fdName );\n\n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    // ////////////////////////\n    // START OF GENERAL TAB ///\n    // ////////////////////////\n\n    wGeneralTab = new CTabItem( wTabFolder, SWT.NONE );\n    wGeneralTab.setText( BaseMessages.getString( PKG, \"JobFTP.Tab.General.Label\" ) );\n\n    wGeneralComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wGeneralComp );\n\n    FormLayout generalLayout = new FormLayout();\n    generalLayout.marginWidth = 3;\n    generalLayout.marginHeight = 3;\n    wGeneralComp.setLayout( generalLayout );\n\n    // ////////////////////////\n    // START OF SERVER SETTINGS GROUP///\n    // /\n    wServerSettings = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wServerSettings );\n    wServerSettings.setText( BaseMessages.getString( PKG, \"JobFTP.ServerSettings.Group.Label\" ) );\n\n    FormLayout ServerSettingsgroupLayout = new FormLayout();\n    ServerSettingsgroupLayout.marginWidth = 10;\n    ServerSettingsgroupLayout.marginHeight = 10;\n\n    wServerSettings.setLayout( ServerSettingsgroupLayout );\n\n    // ServerName line\n    wServerName =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.Server.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.Server.Tooltip\" ) );\n    props.setLook( wServerName );\n    wServerName.addModifyListener( lsMod );\n    fdServerName = new FormData();\n    fdServerName.left = new FormAttachment( 0, 0 );\n    fdServerName.top = new FormAttachment( wName, margin );\n    fdServerName.right = new FormAttachment( 100, 0 );\n    wServerName.setLayoutData( fdServerName );\n\n    // Server port line\n    wPort =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.Port.Label\" ), BaseMessages.getString(\n          PKG, \"JobFTP.Port.Tooltip\" ) );\n    props.setLook( wPort );\n    wPort.addModifyListener( lsMod );\n    fdPort = new FormData();\n    fdPort.left = new FormAttachment( 0, 0 );\n    fdPort.top = new FormAttachment( wServerName, margin );\n    fdPort.right = new FormAttachment( 100, 0 );\n    wPort.setLayoutData( fdPort );\n\n    // UserName line\n    wUserName =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.User.Label\" ), BaseMessages.getString(\n          PKG, \"JobFTP.User.Tooltip\" ) );\n    props.setLook( wUserName );\n    wUserName.addModifyListener( lsMod );\n    fdUserName = new FormData();\n    fdUserName.left = new FormAttachment( 0, 0 );\n    fdUserName.top = new FormAttachment( wPort, margin );\n    fdUserName.right = new FormAttachment( 100, 0 );\n    wUserName.setLayoutData( fdUserName );\n\n    // Password line\n    wPassword =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.Password.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.Password.Tooltip\" ) );\n    props.setLook( wPassword );\n    wPassword.setEchoChar( '*' );\n    wPassword.addModifyListener( lsMod );\n    fdPassword = new FormData();\n    fdPassword.left = new FormAttachment( 0, 0 );\n    fdPassword.top = new FormAttachment( wUserName, margin );\n    fdPassword.right = new FormAttachment( 100, 0 );\n    wPassword.setLayoutData( fdPassword );\n\n    // OK, if the password contains a variable, we don't want to have the password hidden...\n    wPassword.getTextWidget().addModifyListener( new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        checkPasswordVisible();\n      }\n    } );\n\n    // Proxy host line\n    wProxyHost =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.ProxyHost.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.ProxyHost.Tooltip\" ) );\n    props.setLook( wProxyHost );\n    wProxyHost.addModifyListener( lsMod );\n    fdProxyHost = new FormData();\n    fdProxyHost.left = new FormAttachment( 0, 0 );\n    fdProxyHost.top = new FormAttachment( wPassword, 2 * margin );\n    fdProxyHost.right = new FormAttachment( 100, 0 );\n    wProxyHost.setLayoutData( fdProxyHost );\n\n    // Proxy port line\n    wProxyPort =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.ProxyPort.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.ProxyPort.Tooltip\" ) );\n    props.setLook( wProxyPort );\n    wProxyPort.addModifyListener( lsMod );\n    fdProxyPort = new FormData();\n    fdProxyPort.left = new FormAttachment( 0, 0 );\n    fdProxyPort.top = new FormAttachment( wProxyHost, margin );\n    fdProxyPort.right = new FormAttachment( 100, 0 );\n    wProxyPort.setLayoutData( fdProxyPort );\n\n    // Proxy username line\n    wProxyUsername =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.ProxyUsername.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.ProxyUsername.Tooltip\" ) );\n    props.setLook( wProxyUsername );\n    wProxyUsername.addModifyListener( lsMod );\n    fdProxyUsername = new FormData();\n    fdProxyUsername.left = new FormAttachment( 0, 0 );\n    fdProxyUsername.top = new FormAttachment( wProxyPort, margin );\n    fdProxyUsername.right = new FormAttachment( 100, 0 );\n    wProxyUsername.setLayoutData( fdProxyUsername );\n\n    // Proxy password line\n    wProxyPassword =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.ProxyPassword.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.ProxyPassword.Tooltip\" ) );\n    props.setLook( wProxyPassword );\n    wProxyPassword.setEchoChar( '*' );\n    wProxyPassword.addModifyListener( lsMod );\n    fdProxyPasswd = new FormData();\n    fdProxyPasswd.left = new FormAttachment( 0, 0 );\n    fdProxyPasswd.top = new FormAttachment( wProxyUsername, margin );\n    fdProxyPasswd.right = new FormAttachment( 100, 0 );\n    wProxyPassword.setLayoutData( fdProxyPasswd );\n\n    // OK, if the password contains a variable, we don't want to have the password hidden...\n    wProxyPassword.getTextWidget().addModifyListener( new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        checkProxyPasswordVisible();\n      }\n    } );\n\n    // Test connection button\n    wTest = new Button( wServerSettings, SWT.PUSH );\n    wTest.setText( BaseMessages.getString( PKG, \"JobFTP.TestConnection.Label\" ) );\n    props.setLook( wTest );\n    fdTest = new FormData();\n    wTest.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.TestConnection.Tooltip\" ) );\n    // fdTest.left = new FormAttachment(middle, 0);\n    fdTest.top = new FormAttachment( wProxyPassword, margin );\n    fdTest.right = new FormAttachment( 100, 0 );\n    wTest.setLayoutData( fdTest );\n\n    fdServerSettings = new FormData();\n    fdServerSettings.left = new FormAttachment( 0, margin );\n    fdServerSettings.top = new FormAttachment( wName, margin );\n    fdServerSettings.right = new FormAttachment( 100, -margin );\n    wServerSettings.setLayoutData( fdServerSettings );\n    // ///////////////////////////////////////////////////////////\n    // / END OF SERVER SETTINGS GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF Advanced SETTINGS GROUP///\n    // /\n    wAdvancedSettings = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wAdvancedSettings );\n    wAdvancedSettings.setText( BaseMessages.getString( PKG, \"JobFTP.AdvancedSettings.Group.Label\" ) );\n    FormLayout AdvancedSettingsgroupLayout = new FormLayout();\n    AdvancedSettingsgroupLayout.marginWidth = 10;\n    AdvancedSettingsgroupLayout.marginHeight = 10;\n    wAdvancedSettings.setLayout( AdvancedSettingsgroupLayout );\n\n    // Binary mode selection...\n    wlBinaryMode = new Label( wAdvancedSettings, SWT.RIGHT );\n    wlBinaryMode.setText( BaseMessages.getString( PKG, \"JobFTP.BinaryMode.Label\" ) );\n    props.setLook( wlBinaryMode );\n    fdlBinaryMode = new FormData();\n    fdlBinaryMode.left = new FormAttachment( 0, 0 );\n    fdlBinaryMode.top = new FormAttachment( wServerSettings, margin );\n    fdlBinaryMode.right = new FormAttachment( middle, 0 );\n    wlBinaryMode.setLayoutData( fdlBinaryMode );\n    wBinaryMode = new Button( wAdvancedSettings, SWT.CHECK );\n    props.setLook( wBinaryMode );\n    wBinaryMode.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.BinaryMode.Tooltip\" ) );\n    fdBinaryMode = new FormData();\n    fdBinaryMode.left = new FormAttachment( middle, margin );\n    fdBinaryMode.top = new FormAttachment( wServerSettings, margin );\n    fdBinaryMode.right = new FormAttachment( 100, 0 );\n    wBinaryMode.setLayoutData( fdBinaryMode );\n\n    // Timeout line\n    wTimeout =\n      new LabelTextVar(\n        jobMeta, wAdvancedSettings, BaseMessages.getString( PKG, \"JobFTP.Timeout.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.Timeout.Tooltip\" ) );\n    props.setLook( wTimeout );\n    wTimeout.addModifyListener( lsMod );\n    fdTimeout = new FormData();\n    fdTimeout.left = new FormAttachment( 0, 0 );\n    fdTimeout.top = new FormAttachment( wlBinaryMode, margin );\n    fdTimeout.right = new FormAttachment( 100, 0 );\n    wTimeout.setLayoutData( fdTimeout );\n\n    // active connection?\n    wlActive = new Label( wAdvancedSettings, SWT.RIGHT );\n    wlActive.setText( BaseMessages.getString( PKG, \"JobFTP.ActiveConns.Label\" ) );\n    props.setLook( wlActive );\n    fdlActive = new FormData();\n    fdlActive.left = new FormAttachment( 0, 0 );\n    fdlActive.top = new FormAttachment( wTimeout, margin );\n    fdlActive.right = new FormAttachment( middle, 0 );\n    wlActive.setLayoutData( fdlActive );\n    wActive = new Button( wAdvancedSettings, SWT.CHECK );\n    wActive.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.ActiveConns.Tooltip\" ) );\n    props.setLook( wActive );\n    fdActive = new FormData();\n    fdActive.left = new FormAttachment( middle, margin );\n    fdActive.top = new FormAttachment( wTimeout, margin );\n    fdActive.right = new FormAttachment( 100, 0 );\n    wActive.setLayoutData( fdActive );\n\n    // Control encoding line\n    //\n    // The drop down is editable as it may happen an encoding may not be present\n    // on one machine, but you may want to use it on your execution server\n    //\n    wlControlEncoding = new Label( wAdvancedSettings, SWT.RIGHT );\n    wlControlEncoding.setText( BaseMessages.getString( PKG, \"JobFTP.ControlEncoding.Label\" ) );\n    props.setLook( wlControlEncoding );\n    fdlControlEncoding = new FormData();\n    fdlControlEncoding.left = new FormAttachment( 0, 0 );\n    fdlControlEncoding.top = new FormAttachment( wActive, margin );\n    fdlControlEncoding.right = new FormAttachment( middle, 0 );\n    wlControlEncoding.setLayoutData( fdlControlEncoding );\n    wControlEncoding = new Combo( wAdvancedSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wControlEncoding.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.ControlEncoding.Tooltip\" ) );\n    wControlEncoding.setItems( encodings );\n    props.setLook( wControlEncoding );\n    fdControlEncoding = new FormData();\n    fdControlEncoding.left = new FormAttachment( middle, margin );\n    fdControlEncoding.top = new FormAttachment( wActive, margin );\n    fdControlEncoding.right = new FormAttachment( 100, 0 );\n    wControlEncoding.setLayoutData( fdControlEncoding );\n\n    fdAdvancedSettings = new FormData();\n    fdAdvancedSettings.left = new FormAttachment( 0, margin );\n    fdAdvancedSettings.top = new FormAttachment( wServerSettings, margin );\n    fdAdvancedSettings.right = new FormAttachment( 100, -margin );\n    wAdvancedSettings.setLayoutData( fdAdvancedSettings );\n    // ///////////////////////////////////////////////////////////\n    // / END OF Advanced SETTINGS GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdGeneralComp = new FormData();\n    fdGeneralComp.left = new FormAttachment( 0, 0 );\n    fdGeneralComp.top = new FormAttachment( 0, 0 );\n    fdGeneralComp.right = new FormAttachment( 100, 0 );\n    fdGeneralComp.bottom = new FormAttachment( 100, 0 );\n    wGeneralComp.setLayoutData( fdGeneralComp );\n\n    wGeneralComp.layout();\n    wGeneralTab.setControl( wGeneralComp );\n    props.setLook( wGeneralComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF GENERAL TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF Files TAB ///\n    // ////////////////////////\n\n    wFilesTab = new CTabItem( wTabFolder, SWT.NONE );\n    wFilesTab.setText( BaseMessages.getString( PKG, \"JobFTP.Tab.Files.Label\" ) );\n\n    wFilesComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wFilesComp );\n\n    FormLayout FilesLayout = new FormLayout();\n    FilesLayout.marginWidth = 3;\n    FilesLayout.marginHeight = 3;\n    wFilesComp.setLayout( FilesLayout );\n\n    // ////////////////////////\n    // START OF Remote SETTINGS GROUP///\n    // /\n    wRemoteSettings = new Group( wFilesComp, SWT.SHADOW_NONE );\n    props.setLook( wRemoteSettings );\n    wRemoteSettings.setText( BaseMessages.getString( PKG, \"JobFTP.RemoteSettings.Group.Label\" ) );\n\n    FormLayout RemoteSettinsgroupLayout = new FormLayout();\n    RemoteSettinsgroupLayout.marginWidth = 10;\n    RemoteSettinsgroupLayout.marginHeight = 10;\n\n    wRemoteSettings.setLayout( RemoteSettinsgroupLayout );\n\n    // Move to directory\n    wlFtpDirectory = new Label( wRemoteSettings, SWT.RIGHT );\n    wlFtpDirectory.setText( BaseMessages.getString( PKG, \"JobFTP.RemoteDir.Label\" ) );\n    props.setLook( wlFtpDirectory );\n    fdlFtpDirectory = new FormData();\n    fdlFtpDirectory.left = new FormAttachment( 0, 0 );\n    fdlFtpDirectory.top = new FormAttachment( 0, margin );\n    fdlFtpDirectory.right = new FormAttachment( middle, 0 );\n    wlFtpDirectory.setLayoutData( fdlFtpDirectory );\n\n    // Test remote folder button ...\n    wbTestChangeFolderExists = new Button( wRemoteSettings, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbTestChangeFolderExists );\n    wbTestChangeFolderExists.setText( BaseMessages.getString( PKG, \"JobFTP.TestFolderExists.Label\" ) );\n    fdbTestChangeFolderExists = new FormData();\n    fdbTestChangeFolderExists.right = new FormAttachment( 100, 0 );\n    fdbTestChangeFolderExists.top = new FormAttachment( 0, margin );\n    wbTestChangeFolderExists.setLayoutData( fdbTestChangeFolderExists );\n\n    wFtpDirectory =\n      new TextVar( jobMeta, wRemoteSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobFTP.RemoteDir.Tooltip\" ) );\n    props.setLook( wFtpDirectory );\n    wFtpDirectory.addModifyListener( lsMod );\n    fdFtpDirectory = new FormData();\n    fdFtpDirectory.left = new FormAttachment( middle, margin );\n    fdFtpDirectory.top = new FormAttachment( 0, margin );\n    fdFtpDirectory.right = new FormAttachment( wbTestChangeFolderExists, -margin );\n    wFtpDirectory.setLayoutData( fdFtpDirectory );\n\n    // Wildcard line\n    wWildcard =\n      new LabelTextVar(\n        jobMeta, wRemoteSettings, BaseMessages.getString( PKG, \"JobFTP.Wildcard.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.Wildcard.Tooltip\" ) );\n    props.setLook( wWildcard );\n    wWildcard.addModifyListener( lsMod );\n    fdWildcard = new FormData();\n    fdWildcard.left = new FormAttachment( 0, 0 );\n    fdWildcard.top = new FormAttachment( wFtpDirectory, margin );\n    fdWildcard.right = new FormAttachment( 100, 0 );\n    wWildcard.setLayoutData( fdWildcard );\n\n    // Remove files after retrieval...\n    wlRemove = new Label( wRemoteSettings, SWT.RIGHT );\n    wlRemove.setText( BaseMessages.getString( PKG, \"JobFTP.RemoveFiles.Label\" ) );\n    props.setLook( wlRemove );\n    fdlRemove = new FormData();\n    fdlRemove.left = new FormAttachment( 0, 0 );\n    fdlRemove.top = new FormAttachment( wWildcard, margin );\n    fdlRemove.right = new FormAttachment( middle, 0 );\n    wlRemove.setLayoutData( fdlRemove );\n    wRemove = new Button( wRemoteSettings, SWT.CHECK );\n    wRemove.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.RemoveFiles.Tooltip\" ) );\n    props.setLook( wRemove );\n    fdRemove = new FormData();\n    fdRemove.left = new FormAttachment( middle, margin );\n    fdRemove.top = new FormAttachment( wWildcard, margin );\n    fdRemove.right = new FormAttachment( 100, 0 );\n    wRemove.setLayoutData( fdRemove );\n\n    wRemove.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        if ( wRemove.getSelection() ) {\n          wMove.setSelection( false );\n          activateMoveTo();\n        }\n\n      }\n    } );\n\n    // Move files after the transfert?...\n    wlMove = new Label( wRemoteSettings, SWT.RIGHT );\n    wlMove.setText( BaseMessages.getString( PKG, \"JobFTP.MoveFiles.Label\" ) );\n    props.setLook( wlMove );\n    fdlMove = new FormData();\n    fdlMove.left = new FormAttachment( 0, 0 );\n    fdlMove.top = new FormAttachment( wRemove, margin );\n    fdlMove.right = new FormAttachment( middle, -margin );\n    wlMove.setLayoutData( fdlMove );\n    wMove = new Button( wRemoteSettings, SWT.CHECK );\n    props.setLook( wMove );\n    wMove.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.MoveFiles.Tooltip\" ) );\n    fdMove = new FormData();\n    fdMove.left = new FormAttachment( middle, margin );\n    fdMove.top = new FormAttachment( wRemove, margin );\n    fdMove.right = new FormAttachment( 100, 0 );\n    wMove.setLayoutData( fdMove );\n    wMove.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        activateMoveTo();\n        if ( wMove.getSelection() ) {\n          wRemove.setSelection( false );\n        }\n\n      }\n    } );\n\n    // Move to directory\n    wlMoveToDirectory = new Label( wRemoteSettings, SWT.RIGHT );\n    wlMoveToDirectory.setText( BaseMessages.getString( PKG, \"JobFTP.MoveFolder.Label\" ) );\n    props.setLook( wlMoveToDirectory );\n    fdlMoveToDirectory = new FormData();\n    fdlMoveToDirectory.left = new FormAttachment( 0, 0 );\n    fdlMoveToDirectory.top = new FormAttachment( wMove, margin );\n    fdlMoveToDirectory.right = new FormAttachment( middle, 0 );\n    wlMoveToDirectory.setLayoutData( fdlMoveToDirectory );\n\n    // Test remote folder button ...\n    wbTestFolderExists = new Button( wRemoteSettings, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbTestFolderExists );\n    wbTestFolderExists.setText( BaseMessages.getString( PKG, \"JobFTP.TestFolderExists.Label\" ) );\n    fdbTestFolderExists = new FormData();\n    fdbTestFolderExists.right = new FormAttachment( 100, 0 );\n    fdbTestFolderExists.top = new FormAttachment( wMove, margin );\n    wbTestFolderExists.setLayoutData( fdbTestFolderExists );\n\n    wMoveToDirectory =\n      new TextVar( jobMeta, wRemoteSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobFTP.MoveToDirectory.Tooltip\" ) );\n    wMoveToDirectory.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.MoveFolder.Tooltip\" ) );\n    props.setLook( wMoveToDirectory );\n    wMoveToDirectory.addModifyListener( lsMod );\n    fdMoveToDirectory = new FormData();\n    fdMoveToDirectory.left = new FormAttachment( middle, margin );\n    fdMoveToDirectory.top = new FormAttachment( wMove, margin );\n    fdMoveToDirectory.right = new FormAttachment( wbTestFolderExists, -margin );\n    wMoveToDirectory.setLayoutData( fdMoveToDirectory );\n\n    // create destination folder?...\n    wlCreateMoveFolder = new Label( wRemoteSettings, SWT.RIGHT );\n    wlCreateMoveFolder.setText( BaseMessages.getString( PKG, \"JobFTP.CreateMoveFolder.Label\" ) );\n    props.setLook( wlCreateMoveFolder );\n    fdlCreateMoveFolder = new FormData();\n    fdlCreateMoveFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateMoveFolder.top = new FormAttachment( wMoveToDirectory, margin );\n    fdlCreateMoveFolder.right = new FormAttachment( middle, 0 );\n    wlCreateMoveFolder.setLayoutData( fdlCreateMoveFolder );\n    wCreateMoveFolder = new Button( wRemoteSettings, SWT.CHECK );\n    wCreateMoveFolder.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.CreateMoveFolder.Tooltip\" ) );\n    props.setLook( wCreateMoveFolder );\n    fdCreateMoveFolder = new FormData();\n    fdCreateMoveFolder.left = new FormAttachment( middle, margin );\n    fdCreateMoveFolder.top = new FormAttachment( wMoveToDirectory, margin );\n    fdCreateMoveFolder.right = new FormAttachment( 100, 0 );\n    wCreateMoveFolder.setLayoutData( fdCreateMoveFolder );\n\n    fdRemoteSettings = new FormData();\n    fdRemoteSettings.left = new FormAttachment( 0, margin );\n    fdRemoteSettings.top = new FormAttachment( 0, 2 * margin );\n    fdRemoteSettings.right = new FormAttachment( 100, -margin );\n    wRemoteSettings.setLayoutData( fdRemoteSettings );\n    // ///////////////////////////////////////////////////////////\n    // / END OF Remote SETTINGSGROUP\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF LOCAL SETTINGS GROUP///\n    // /\n    wLocalSettings = new Group( wFilesComp, SWT.SHADOW_NONE );\n    props.setLook( wLocalSettings );\n    wLocalSettings.setText( BaseMessages.getString( PKG, \"JobFTP.LocalSettings.Group.Label\" ) );\n\n    FormLayout LocalSettinsgroupLayout = new FormLayout();\n    LocalSettinsgroupLayout.marginWidth = 10;\n    LocalSettinsgroupLayout.marginHeight = 10;\n\n    wLocalSettings.setLayout( LocalSettinsgroupLayout );\n\n    // TargetDirectory\n    wlTargetDirectory = new Label( wLocalSettings, SWT.RIGHT );\n    wlTargetDirectory.setText( BaseMessages.getString( PKG, \"JobFTP.TargetDir.Label\" ) );\n    props.setLook( wlTargetDirectory );\n    fdlTargetDirectory = new FormData();\n    fdlTargetDirectory.left = new FormAttachment( 0, 0 );\n    fdlTargetDirectory.top = new FormAttachment( wRemoteSettings, margin );\n    fdlTargetDirectory.right = new FormAttachment( middle, -margin );\n    wlTargetDirectory.setLayoutData( fdlTargetDirectory );\n\n    // Browse folders button ...\n    wbTargetDirectory = new Button( wLocalSettings, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbTargetDirectory );\n    wbTargetDirectory.setText( BaseMessages.getString( PKG, \"JobFTP.BrowseFolders.Label\" ) );\n    fdbTargetDirectory = new FormData();\n    fdbTargetDirectory.right = new FormAttachment( 100, 0 );\n    fdbTargetDirectory.top = new FormAttachment( wRemoteSettings, margin );\n    wbTargetDirectory.setLayoutData( fdbTargetDirectory );\n    wbTargetDirectory.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog ddialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wTargetDirectory.getText() != null ) {\n          ddialog.setFilterPath( jobMeta.environmentSubstitute( wTargetDirectory.getText() ) );\n        }\n\n        // Calling open() will open and run the dialog.\n        // It will return the selected directory, or\n        // null if user cancels\n        String dir = ddialog.open();\n        if ( dir != null ) {\n          // Set the text box to the new selection\n          wTargetDirectory.setText( dir );\n        }\n\n      }\n    } );\n\n    wTargetDirectory =\n      new TextVar( jobMeta, wLocalSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobFTP.TargetDir.Tooltip\" ) );\n    props.setLook( wTargetDirectory );\n    wTargetDirectory.addModifyListener( lsMod );\n    fdTargetDirectory = new FormData();\n    fdTargetDirectory.left = new FormAttachment( middle, margin );\n    fdTargetDirectory.top = new FormAttachment( wRemoteSettings, margin );\n    fdTargetDirectory.right = new FormAttachment( wbTargetDirectory, -margin );\n    wTargetDirectory.setLayoutData( fdTargetDirectory );\n\n    // Create multi-part file?\n    wlAddDate = new Label( wLocalSettings, SWT.RIGHT );\n    wlAddDate.setText( BaseMessages.getString( PKG, \"JobFTP.AddDate.Label\" ) );\n    props.setLook( wlAddDate );\n    fdlAddDate = new FormData();\n    fdlAddDate.left = new FormAttachment( 0, 0 );\n    fdlAddDate.top = new FormAttachment( wTargetDirectory, margin );\n    fdlAddDate.right = new FormAttachment( middle, -margin );\n    wlAddDate.setLayoutData( fdlAddDate );\n    wAddDate = new Button( wLocalSettings, SWT.CHECK );\n    props.setLook( wAddDate );\n    wAddDate.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.AddDate.Tooltip\" ) );\n    fdAddDate = new FormData();\n    fdAddDate.left = new FormAttachment( middle, margin );\n    fdAddDate.top = new FormAttachment( wTargetDirectory, margin );\n    fdAddDate.right = new FormAttachment( 100, 0 );\n    wAddDate.setLayoutData( fdAddDate );\n    wAddDate.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n    // Create multi-part file?\n    wlAddTime = new Label( wLocalSettings, SWT.RIGHT );\n    wlAddTime.setText( BaseMessages.getString( PKG, \"JobFTP.AddTime.Label\" ) );\n    props.setLook( wlAddTime );\n    fdlAddTime = new FormData();\n    fdlAddTime.left = new FormAttachment( 0, 0 );\n    fdlAddTime.top = new FormAttachment( wAddDate, margin );\n    fdlAddTime.right = new FormAttachment( middle, -margin );\n    wlAddTime.setLayoutData( fdlAddTime );\n    wAddTime = new Button( wLocalSettings, SWT.CHECK );\n    props.setLook( wAddTime );\n    wAddTime.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.AddTime.Tooltip\" ) );\n    fdAddTime = new FormData();\n    fdAddTime.left = new FormAttachment( middle, margin );\n    fdAddTime.top = new FormAttachment( wAddDate, margin );\n    fdAddTime.right = new FormAttachment( 100, 0 );\n    wAddTime.setLayoutData( fdAddTime );\n    wAddTime.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Specify date time format?\n    wlSpecifyFormat = new Label( wLocalSettings, SWT.RIGHT );\n    wlSpecifyFormat.setText( BaseMessages.getString( PKG, \"JobFTP.SpecifyFormat.Label\" ) );\n    props.setLook( wlSpecifyFormat );\n    fdlSpecifyFormat = new FormData();\n    fdlSpecifyFormat.left = new FormAttachment( 0, 0 );\n    fdlSpecifyFormat.top = new FormAttachment( wAddTime, margin );\n    fdlSpecifyFormat.right = new FormAttachment( middle, -margin );\n    wlSpecifyFormat.setLayoutData( fdlSpecifyFormat );\n    wSpecifyFormat = new Button( wLocalSettings, SWT.CHECK );\n    props.setLook( wSpecifyFormat );\n    wSpecifyFormat.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.SpecifyFormat.Tooltip\" ) );\n    fdSpecifyFormat = new FormData();\n    fdSpecifyFormat.left = new FormAttachment( middle, margin );\n    fdSpecifyFormat.top = new FormAttachment( wAddTime, margin );\n    fdSpecifyFormat.right = new FormAttachment( 100, 0 );\n    wSpecifyFormat.setLayoutData( fdSpecifyFormat );\n    wSpecifyFormat.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setDateTimeFormat();\n        setAddDateBeforeExtension();\n      }\n    } );\n\n    // Prepare a list of possible DateTimeFormats...\n    String[] dats = Const.getDateFormats();\n\n    // DateTimeFormat\n    wlDateTimeFormat = new Label( wLocalSettings, SWT.RIGHT );\n    wlDateTimeFormat.setText( BaseMessages.getString( PKG, \"JobFTP.DateTimeFormat.Label\" ) );\n    props.setLook( wlDateTimeFormat );\n    fdlDateTimeFormat = new FormData();\n    fdlDateTimeFormat.left = new FormAttachment( 0, 0 );\n    fdlDateTimeFormat.top = new FormAttachment( wSpecifyFormat, margin );\n    fdlDateTimeFormat.right = new FormAttachment( middle, -margin );\n    wlDateTimeFormat.setLayoutData( fdlDateTimeFormat );\n    wDateTimeFormat = new CCombo( wLocalSettings, SWT.BORDER | SWT.READ_ONLY );\n    wDateTimeFormat.setEditable( true );\n    props.setLook( wDateTimeFormat );\n    wDateTimeFormat.addModifyListener( lsMod );\n    fdDateTimeFormat = new FormData();\n    fdDateTimeFormat.left = new FormAttachment( middle, margin );\n    fdDateTimeFormat.top = new FormAttachment( wSpecifyFormat, margin );\n    fdDateTimeFormat.right = new FormAttachment( 100, 0 );\n    wDateTimeFormat.setLayoutData( fdDateTimeFormat );\n    for ( int x = 0; x < dats.length; x++ ) {\n      wDateTimeFormat.add( dats[x] );\n    }\n\n    // Add Date before extension?\n    wlAddDateBeforeExtension = new Label( wLocalSettings, SWT.RIGHT );\n    wlAddDateBeforeExtension.setText( BaseMessages.getString( PKG, \"JobFTP.AddDateBeforeExtension.Label\" ) );\n    props.setLook( wlAddDateBeforeExtension );\n    fdlAddDateBeforeExtension = new FormData();\n    fdlAddDateBeforeExtension.left = new FormAttachment( 0, 0 );\n    fdlAddDateBeforeExtension.top = new FormAttachment( wDateTimeFormat, margin );\n    fdlAddDateBeforeExtension.right = new FormAttachment( middle, -margin );\n    wlAddDateBeforeExtension.setLayoutData( fdlAddDateBeforeExtension );\n    wAddDateBeforeExtension = new Button( wLocalSettings, SWT.CHECK );\n    props.setLook( wAddDateBeforeExtension );\n    wAddDateBeforeExtension\n      .setToolTipText( BaseMessages.getString( PKG, \"JobFTP.AddDateBeforeExtension.Tooltip\" ) );\n    fdAddDateBeforeExtension = new FormData();\n    fdAddDateBeforeExtension.left = new FormAttachment( middle, margin );\n    fdAddDateBeforeExtension.top = new FormAttachment( wDateTimeFormat, margin );\n    fdAddDateBeforeExtension.right = new FormAttachment( 100, 0 );\n    wAddDateBeforeExtension.setLayoutData( fdAddDateBeforeExtension );\n    wAddDateBeforeExtension.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // OnlyNew files after retrieval...\n    wlOnlyNew = new Label( wLocalSettings, SWT.RIGHT );\n    wlOnlyNew.setText( BaseMessages.getString( PKG, \"JobFTP.DontOverwrite.Label\" ) );\n    props.setLook( wlOnlyNew );\n    fdlOnlyNew = new FormData();\n    fdlOnlyNew.left = new FormAttachment( 0, 0 );\n    fdlOnlyNew.top = new FormAttachment( wAddDateBeforeExtension, margin );\n    fdlOnlyNew.right = new FormAttachment( middle, 0 );\n    wlOnlyNew.setLayoutData( fdlOnlyNew );\n    wOnlyNew = new Button( wLocalSettings, SWT.CHECK );\n    wOnlyNew.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.DontOverwrite.Tooltip\" ) );\n    props.setLook( wOnlyNew );\n    fdOnlyNew = new FormData();\n    fdOnlyNew.left = new FormAttachment( middle, margin );\n    fdOnlyNew.top = new FormAttachment( wAddDateBeforeExtension, margin );\n    fdOnlyNew.right = new FormAttachment( 100, 0 );\n    wOnlyNew.setLayoutData( fdOnlyNew );\n    wOnlyNew.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        activeIfExists();\n        jobEntry.setChanged();\n      }\n    } );\n\n    // If File Exists\n    wlIfFileExists = new Label( wLocalSettings, SWT.RIGHT );\n    wlIfFileExists.setText( BaseMessages.getString( PKG, \"JobFTP.IfFileExists.Label\" ) );\n    props.setLook( wlIfFileExists );\n    fdlIfFileExists = new FormData();\n    fdlIfFileExists.left = new FormAttachment( 0, 0 );\n    fdlIfFileExists.right = new FormAttachment( middle, 0 );\n    fdlIfFileExists.top = new FormAttachment( wOnlyNew, margin );\n    wlIfFileExists.setLayoutData( fdlIfFileExists );\n    wIfFileExists = new CCombo( wLocalSettings, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobFTP.Skip.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobFTP.Give_Unique_Name.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobFTP.Fail.Label\" ) );\n    wIfFileExists.select( 0 ); // +1: starts at -1\n\n    props.setLook( wIfFileExists );\n\n    fdIfFileExists = new FormData();\n    fdIfFileExists.left = new FormAttachment( middle, margin );\n    fdIfFileExists.top = new FormAttachment( wOnlyNew, margin );\n    fdIfFileExists.right = new FormAttachment( 100, 0 );\n    wIfFileExists.setLayoutData( fdIfFileExists );\n\n    wIfFileExists.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n      }\n    } );\n\n    // Add filenames to result filenames...\n    wlAddFilenameToResult = new Label( wLocalSettings, SWT.RIGHT );\n    wlAddFilenameToResult.setText( BaseMessages.getString( PKG, \"JobFTP.AddFilenameToResult.Label\" ) );\n    props.setLook( wlAddFilenameToResult );\n    fdlAddFilenameToResult = new FormData();\n    fdlAddFilenameToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFilenameToResult.top = new FormAttachment( wIfFileExists, 2 * margin );\n    fdlAddFilenameToResult.right = new FormAttachment( middle, 0 );\n    wlAddFilenameToResult.setLayoutData( fdlAddFilenameToResult );\n    wAddFilenameToResult = new Button( wLocalSettings, SWT.CHECK );\n    wAddFilenameToResult.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.AddFilenameToResult.Tooltip\" ) );\n    props.setLook( wAddFilenameToResult );\n    fdAddFilenameToResult = new FormData();\n    fdAddFilenameToResult.left = new FormAttachment( middle, margin );\n    fdAddFilenameToResult.top = new FormAttachment( wIfFileExists, 2 * margin );\n    fdAddFilenameToResult.right = new FormAttachment( 100, 0 );\n    wAddFilenameToResult.setLayoutData( fdAddFilenameToResult );\n\n    fdLocalSettings = new FormData();\n    fdLocalSettings.left = new FormAttachment( 0, margin );\n    fdLocalSettings.top = new FormAttachment( wRemoteSettings, margin );\n    fdLocalSettings.right = new FormAttachment( 100, -margin );\n    wLocalSettings.setLayoutData( fdLocalSettings );\n    // ///////////////////////////////////////////////////////////\n    // / END OF LOCAL SETTINGSGROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdFilesComp = new FormData();\n    fdFilesComp.left = new FormAttachment( 0, 0 );\n    fdFilesComp.top = new FormAttachment( 0, 0 );\n    fdFilesComp.right = new FormAttachment( 100, 0 );\n    fdFilesComp.bottom = new FormAttachment( 100, 0 );\n    wFilesComp.setLayoutData( fdFilesComp );\n\n    wFilesComp.layout();\n    wFilesTab.setControl( wFilesComp );\n    props.setLook( wFilesComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF Files TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF Advanced TAB ///\n    // ////////////////////////\n\n    wAdvancedTab = new CTabItem( wTabFolder, SWT.NONE );\n    wAdvancedTab.setText( BaseMessages.getString( PKG, \"JobFTP.Tab.Advanced.Label\" ) );\n\n    wAdvancedComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wAdvancedComp );\n\n    FormLayout AdvancedLayout = new FormLayout();\n    AdvancedLayout.marginWidth = 3;\n    AdvancedLayout.marginHeight = 3;\n    wAdvancedComp.setLayout( AdvancedLayout );\n\n    // SuccessOngrouping?\n    // ////////////////////////\n    // START OF SUCCESS ON GROUP///\n    // /\n    wSuccessOn = new Group( wAdvancedComp, SWT.SHADOW_NONE );\n    props.setLook( wSuccessOn );\n    wSuccessOn.setText( BaseMessages.getString( PKG, \"JobFTP.SuccessOn.Group.Label\" ) );\n\n    FormLayout successongroupLayout = new FormLayout();\n    successongroupLayout.marginWidth = 10;\n    successongroupLayout.marginHeight = 10;\n\n    wSuccessOn.setLayout( successongroupLayout );\n\n    // Success Condition\n    wlSuccessCondition = new Label( wSuccessOn, SWT.RIGHT );\n    wlSuccessCondition.setText( BaseMessages.getString( PKG, \"JobFTP.SuccessCondition.Label\" ) + \" \" );\n    props.setLook( wlSuccessCondition );\n    fdlSuccessCondition = new FormData();\n    fdlSuccessCondition.left = new FormAttachment( 0, 0 );\n    fdlSuccessCondition.right = new FormAttachment( middle, 0 );\n    fdlSuccessCondition.top = new FormAttachment( 0, margin );\n    wlSuccessCondition.setLayoutData( fdlSuccessCondition );\n    wSuccessCondition = new CCombo( wSuccessOn, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobFTP.SuccessWhenAllWorksFine.Label\" ) );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobFTP.SuccessWhenAtLeat.Label\" ) );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobFTP.SuccessWhenNrErrorsLessThan.Label\" ) );\n    wSuccessCondition.select( 0 ); // +1: starts at -1\n\n    props.setLook( wSuccessCondition );\n    fdSuccessCondition = new FormData();\n    fdSuccessCondition.left = new FormAttachment( middle, 0 );\n    fdSuccessCondition.top = new FormAttachment( 0, margin );\n    fdSuccessCondition.right = new FormAttachment( 100, 0 );\n    wSuccessCondition.setLayoutData( fdSuccessCondition );\n    wSuccessCondition.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        activeSuccessCondition();\n\n      }\n    } );\n\n    // Success when number of errors less than\n    wlNrErrorsLessThan = new Label( wSuccessOn, SWT.RIGHT );\n    wlNrErrorsLessThan.setText( BaseMessages.getString( PKG, \"JobFTP.NrBadFormedLessThan.Label\" ) + \" \" );\n    props.setLook( wlNrErrorsLessThan );\n    fdlNrErrorsLessThan = new FormData();\n    fdlNrErrorsLessThan.left = new FormAttachment( 0, 0 );\n    fdlNrErrorsLessThan.top = new FormAttachment( wSuccessCondition, margin );\n    fdlNrErrorsLessThan.right = new FormAttachment( middle, -margin );\n    wlNrErrorsLessThan.setLayoutData( fdlNrErrorsLessThan );\n\n    wNrErrorsLessThan =\n      new TextVar( jobMeta, wSuccessOn, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobFTP.NrBadFormedLessThan.Tooltip\" ) );\n    props.setLook( wNrErrorsLessThan );\n    wNrErrorsLessThan.addModifyListener( lsMod );\n    fdNrErrorsLessThan = new FormData();\n    fdNrErrorsLessThan.left = new FormAttachment( middle, 0 );\n    fdNrErrorsLessThan.top = new FormAttachment( wSuccessCondition, margin );\n    fdNrErrorsLessThan.right = new FormAttachment( 100, -margin );\n    wNrErrorsLessThan.setLayoutData( fdNrErrorsLessThan );\n\n    fdSuccessOn = new FormData();\n    fdSuccessOn.left = new FormAttachment( 0, margin );\n    fdSuccessOn.top = new FormAttachment( 0, margin );\n    fdSuccessOn.right = new FormAttachment( 100, -margin );\n    wSuccessOn.setLayoutData( fdSuccessOn );\n    // ///////////////////////////////////////////////////////////\n    // / END OF Success ON GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdAdvancedComp = new FormData();\n    fdAdvancedComp.left = new FormAttachment( 0, 0 );\n    fdAdvancedComp.top = new FormAttachment( 0, 0 );\n    fdAdvancedComp.right = new FormAttachment( 100, 0 );\n    fdAdvancedComp.bottom = new FormAttachment( 100, 0 );\n    wAdvancedComp.setLayoutData( fdAdvancedComp );\n\n    wAdvancedComp.layout();\n    wAdvancedTab.setControl( wAdvancedComp );\n    props.setLook( wAdvancedComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF Advanced TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ///////////////////////////////////////////////////////////\n    // Start of Socks Proxy Tab\n    // ///////////////////////////////////////////////////////////\n    wSocksProxyTab = new CTabItem( wTabFolder, SWT.NONE );\n    wSocksProxyTab.setText( BaseMessages.getString( PKG, \"JobFTP.Tab.Socks.Label\" ) );\n\n    wSocksProxyComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wSocksProxyComp );\n\n    FormLayout SoxProxyLayout = new FormLayout();\n    SoxProxyLayout.marginWidth = 3;\n    SoxProxyLayout.marginHeight = 3;\n    wSocksProxyComp.setLayout( SoxProxyLayout );\n\n    // ////////////////////////////////////////////////////////\n    // Start of Proxy Group\n    // ////////////////////////////////////////////////////////\n    wSocksProxy = new Group( wSocksProxyComp, SWT.SHADOW_NONE );\n    props.setLook( wSocksProxy );\n    wSocksProxy.setText( BaseMessages.getString( PKG, \"JobFTP.SocksProxy.Group.Label\" ) );\n\n    FormLayout SocksProxyGroupLayout = new FormLayout();\n    SocksProxyGroupLayout.marginWidth = 10;\n    SocksProxyGroupLayout.marginHeight = 10;\n    wSocksProxy.setLayout( SocksProxyGroupLayout );\n\n    // host line\n    wSocksProxyHost =\n      new LabelTextVar(\n        jobMeta, wSocksProxy, BaseMessages.getString( PKG, \"JobFTP.SocksProxyHost.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.SocksProxyHost.Tooltip\" ) );\n    props.setLook( wSocksProxyHost );\n    wSocksProxyHost.addModifyListener( lsMod );\n    fdSocksProxyHost = new FormData();\n    fdSocksProxyHost.left = new FormAttachment( 0, 0 );\n    fdSocksProxyHost.top = new FormAttachment( wName, margin );\n    fdSocksProxyHost.right = new FormAttachment( 100, margin );\n    wSocksProxyHost.setLayoutData( fdSocksProxyHost );\n\n    // port line\n    wSocksProxyPort =\n      new LabelTextVar(\n        jobMeta, wSocksProxy, BaseMessages.getString( PKG, \"JobFTP.SocksProxyPort.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.SocksProxyPort.Tooltip\" ) );\n    props.setLook( wSocksProxyPort );\n    wSocksProxyPort.addModifyListener( lsMod );\n    fdSocksProxyPort = new FormData();\n    fdSocksProxyPort.left = new FormAttachment( 0, 0 );\n    fdSocksProxyPort.top = new FormAttachment( wSocksProxyHost, margin );\n    fdSocksProxyPort.right = new FormAttachment( 100, margin );\n    wSocksProxyPort.setLayoutData( fdSocksProxyPort );\n\n    // username line\n    wSocksProxyUsername =\n      new LabelTextVar(\n        jobMeta, wSocksProxy, BaseMessages.getString( PKG, \"JobFTP.SocksProxyUsername.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.SocksProxyPassword.Tooltip\" ) );\n    props.setLook( wSocksProxyUsername );\n    wSocksProxyUsername.addModifyListener( lsMod );\n    fdSocksProxyUsername = new FormData();\n    fdSocksProxyUsername.left = new FormAttachment( 0, 0 );\n    fdSocksProxyUsername.top = new FormAttachment( wSocksProxyPort, margin );\n    fdSocksProxyUsername.right = new FormAttachment( 100, margin );\n    wSocksProxyUsername.setLayoutData( fdSocksProxyUsername );\n\n    // password line\n    wSocksProxyPassword =\n      new LabelTextVar(\n        jobMeta, wSocksProxy, BaseMessages.getString( PKG, \"JobFTP.SocksProxyPassword.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.SocksProxyPassword.Tooltip\" ) );\n    props.setLook( wSocksProxyPort );\n    wSocksProxyPassword.setEchoChar( '*' );\n    wSocksProxyPassword.addModifyListener( lsMod );\n    fdSocksProxyPassword = new FormData();\n    fdSocksProxyPassword.left = new FormAttachment( 0, 0 );\n    fdSocksProxyPassword.top = new FormAttachment( wSocksProxyUsername, margin );\n    fdSocksProxyPassword.right = new FormAttachment( 100, margin );\n    wSocksProxyPassword.setLayoutData( fdSocksProxyPassword );\n\n    // OK, if the password contains a variable, we don't want to have the password hidden...\n    wSocksProxyPassword.getTextWidget().addModifyListener( new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        checkSocksProxyPasswordVisible();\n      }\n    } );\n\n    // ///////////////////////////////////////////////////////////////\n    // End of socks proxy group\n    // ///////////////////////////////////////////////////////////////\n\n    fdSocksProxyComp = new FormData();\n    fdSocksProxyComp.left = new FormAttachment( 0, margin );\n    fdSocksProxyComp.top = new FormAttachment( 0, margin );\n    fdSocksProxyComp.right = new FormAttachment( 100, -margin );\n    wSocksProxy.setLayoutData( fdSocksProxyComp );\n\n    wSocksProxyComp.layout();\n    wSocksProxyTab.setControl( wSocksProxyComp );\n    props.setLook( wSocksProxyComp );\n\n    // ////////////////////////////////////////////////////////\n    // End of Socks Proxy Tab\n    // ////////////////////////////////////////////////////////\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( wName, margin );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -50 );\n    wTabFolder.setLayoutData( fdTabFolder );\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    BaseStepDialog.positionBottomButtons( shell, new Button[] { wOK, wCancel }, margin, wTabFolder );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n    lsTest = new Listener() {\n      public void handleEvent( Event e ) {\n        test();\n      }\n    };\n    lsCheckFolder = new Listener() {\n      public void handleEvent( Event e ) {\n        checkRemoteFolder( false, true, wMoveToDirectory.getText() );\n      }\n    };\n    lsCheckChangeFolder = new Listener() {\n      public void handleEvent( Event e ) {\n        checkRemoteFolder( true, false, wFtpDirectory.getText() );\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n    wTest.addListener( SWT.Selection, lsTest );\n    wbTestFolderExists.addListener( SWT.Selection, lsCheckFolder );\n    wbTestChangeFolderExists.addListener( SWT.Selection, lsCheckChangeFolder );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n    wServerName.addSelectionListener( lsDef );\n    wUserName.addSelectionListener( lsDef );\n    wPassword.addSelectionListener( lsDef );\n    wFtpDirectory.addSelectionListener( lsDef );\n    wTargetDirectory.addSelectionListener( lsDef );\n    wFtpDirectory.addSelectionListener( lsDef );\n    wWildcard.addSelectionListener( lsDef );\n    wTimeout.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    activateMoveTo();\n    setDateTimeFormat();\n    setAddDateBeforeExtension();\n    activeSuccessCondition();\n    activeIfExists();\n\n    wTabFolder.setSelection( 0 );\n    BaseStepDialog.setSize( shell );\n\n    shell.open();\n    props.setDialogSize( shell, \"JobFTPDialogSize\" );\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return jobEntry;\n  }","id":26391,"modified_method":"public JobEntryInterface open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        pwdFolder = null;\n        ftpclient = null;\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobFTP.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Job entry name line\n    wName =\n      new LabelText( shell, BaseMessages.getString( PKG, \"JobFTP.Name.Label\" ), BaseMessages.getString(\n        PKG, \"JobFTP.Name.Tooltip\" ) );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.top = new FormAttachment( 0, 0 );\n    fdName.left = new FormAttachment( 0, 0 );\n    fdName.right = new FormAttachment( 100, 0 );\n    wName.setLayoutData( fdName );\n\n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    // ////////////////////////\n    // START OF GENERAL TAB ///\n    // ////////////////////////\n\n    wGeneralTab = new CTabItem( wTabFolder, SWT.NONE );\n    wGeneralTab.setText( BaseMessages.getString( PKG, \"JobFTP.Tab.General.Label\" ) );\n\n    wGeneralComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wGeneralComp );\n\n    FormLayout generalLayout = new FormLayout();\n    generalLayout.marginWidth = 3;\n    generalLayout.marginHeight = 3;\n    wGeneralComp.setLayout( generalLayout );\n\n    // ////////////////////////\n    // START OF SERVER SETTINGS GROUP///\n    // /\n    wServerSettings = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wServerSettings );\n    wServerSettings.setText( BaseMessages.getString( PKG, \"JobFTP.ServerSettings.Group.Label\" ) );\n\n    FormLayout ServerSettingsgroupLayout = new FormLayout();\n    ServerSettingsgroupLayout.marginWidth = 10;\n    ServerSettingsgroupLayout.marginHeight = 10;\n\n    wServerSettings.setLayout( ServerSettingsgroupLayout );\n\n    // ServerName line\n    wServerName =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.Server.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.Server.Tooltip\" ) );\n    props.setLook( wServerName );\n    wServerName.addModifyListener( lsMod );\n    fdServerName = new FormData();\n    fdServerName.left = new FormAttachment( 0, 0 );\n    fdServerName.top = new FormAttachment( wName, margin );\n    fdServerName.right = new FormAttachment( 100, 0 );\n    wServerName.setLayoutData( fdServerName );\n\n    // Server port line\n    wPort =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.Port.Label\" ), BaseMessages.getString(\n          PKG, \"JobFTP.Port.Tooltip\" ) );\n    props.setLook( wPort );\n    wPort.addModifyListener( lsMod );\n    fdPort = new FormData();\n    fdPort.left = new FormAttachment( 0, 0 );\n    fdPort.top = new FormAttachment( wServerName, margin );\n    fdPort.right = new FormAttachment( 100, 0 );\n    wPort.setLayoutData( fdPort );\n\n    // UserName line\n    wUserName =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.User.Label\" ), BaseMessages.getString(\n          PKG, \"JobFTP.User.Tooltip\" ) );\n    props.setLook( wUserName );\n    wUserName.addModifyListener( lsMod );\n    fdUserName = new FormData();\n    fdUserName.left = new FormAttachment( 0, 0 );\n    fdUserName.top = new FormAttachment( wPort, margin );\n    fdUserName.right = new FormAttachment( 100, 0 );\n    wUserName.setLayoutData( fdUserName );\n\n    // Password line\n    wPassword =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.Password.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.Password.Tooltip\" ) );\n    props.setLook( wPassword );\n    wPassword.setEchoChar( '*' );\n    wPassword.addModifyListener( lsMod );\n    fdPassword = new FormData();\n    fdPassword.left = new FormAttachment( 0, 0 );\n    fdPassword.top = new FormAttachment( wUserName, margin );\n    fdPassword.right = new FormAttachment( 100, 0 );\n    wPassword.setLayoutData( fdPassword );\n\n    // OK, if the password contains a variable, we don't want to have the password hidden...\n    wPassword.getTextWidget().addModifyListener( new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        checkPasswordVisible();\n      }\n    } );\n\n    // Proxy host line\n    wProxyHost =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.ProxyHost.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.ProxyHost.Tooltip\" ) );\n    props.setLook( wProxyHost );\n    wProxyHost.addModifyListener( lsMod );\n    fdProxyHost = new FormData();\n    fdProxyHost.left = new FormAttachment( 0, 0 );\n    fdProxyHost.top = new FormAttachment( wPassword, 2 * margin );\n    fdProxyHost.right = new FormAttachment( 100, 0 );\n    wProxyHost.setLayoutData( fdProxyHost );\n\n    // Proxy port line\n    wProxyPort =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.ProxyPort.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.ProxyPort.Tooltip\" ) );\n    props.setLook( wProxyPort );\n    wProxyPort.addModifyListener( lsMod );\n    fdProxyPort = new FormData();\n    fdProxyPort.left = new FormAttachment( 0, 0 );\n    fdProxyPort.top = new FormAttachment( wProxyHost, margin );\n    fdProxyPort.right = new FormAttachment( 100, 0 );\n    wProxyPort.setLayoutData( fdProxyPort );\n\n    // Proxy username line\n    wProxyUsername =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.ProxyUsername.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.ProxyUsername.Tooltip\" ) );\n    props.setLook( wProxyUsername );\n    wProxyUsername.addModifyListener( lsMod );\n    fdProxyUsername = new FormData();\n    fdProxyUsername.left = new FormAttachment( 0, 0 );\n    fdProxyUsername.top = new FormAttachment( wProxyPort, margin );\n    fdProxyUsername.right = new FormAttachment( 100, 0 );\n    wProxyUsername.setLayoutData( fdProxyUsername );\n\n    // Proxy password line\n    wProxyPassword =\n      new LabelTextVar(\n        jobMeta, wServerSettings, BaseMessages.getString( PKG, \"JobFTP.ProxyPassword.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.ProxyPassword.Tooltip\" ) );\n    props.setLook( wProxyPassword );\n    wProxyPassword.setEchoChar( '*' );\n    wProxyPassword.addModifyListener( lsMod );\n    fdProxyPasswd = new FormData();\n    fdProxyPasswd.left = new FormAttachment( 0, 0 );\n    fdProxyPasswd.top = new FormAttachment( wProxyUsername, margin );\n    fdProxyPasswd.right = new FormAttachment( 100, 0 );\n    wProxyPassword.setLayoutData( fdProxyPasswd );\n\n    // OK, if the password contains a variable, we don't want to have the password hidden...\n    wProxyPassword.getTextWidget().addModifyListener( new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        checkProxyPasswordVisible();\n      }\n    } );\n\n    // Test connection button\n    wTest = new Button( wServerSettings, SWT.PUSH );\n    wTest.setText( BaseMessages.getString( PKG, \"JobFTP.TestConnection.Label\" ) );\n    props.setLook( wTest );\n    fdTest = new FormData();\n    wTest.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.TestConnection.Tooltip\" ) );\n    // fdTest.left = new FormAttachment(middle, 0);\n    fdTest.top = new FormAttachment( wProxyPassword, margin );\n    fdTest.right = new FormAttachment( 100, 0 );\n    wTest.setLayoutData( fdTest );\n\n    fdServerSettings = new FormData();\n    fdServerSettings.left = new FormAttachment( 0, margin );\n    fdServerSettings.top = new FormAttachment( wName, margin );\n    fdServerSettings.right = new FormAttachment( 100, -margin );\n    wServerSettings.setLayoutData( fdServerSettings );\n    // ///////////////////////////////////////////////////////////\n    // / END OF SERVER SETTINGS GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF Advanced SETTINGS GROUP///\n    // /\n    wAdvancedSettings = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wAdvancedSettings );\n    wAdvancedSettings.setText( BaseMessages.getString( PKG, \"JobFTP.AdvancedSettings.Group.Label\" ) );\n    FormLayout AdvancedSettingsgroupLayout = new FormLayout();\n    AdvancedSettingsgroupLayout.marginWidth = 10;\n    AdvancedSettingsgroupLayout.marginHeight = 10;\n    wAdvancedSettings.setLayout( AdvancedSettingsgroupLayout );\n\n    // Binary mode selection...\n    wlBinaryMode = new Label( wAdvancedSettings, SWT.RIGHT );\n    wlBinaryMode.setText( BaseMessages.getString( PKG, \"JobFTP.BinaryMode.Label\" ) );\n    props.setLook( wlBinaryMode );\n    fdlBinaryMode = new FormData();\n    fdlBinaryMode.left = new FormAttachment( 0, 0 );\n    fdlBinaryMode.top = new FormAttachment( wServerSettings, margin );\n    fdlBinaryMode.right = new FormAttachment( middle, 0 );\n    wlBinaryMode.setLayoutData( fdlBinaryMode );\n    wBinaryMode = new Button( wAdvancedSettings, SWT.CHECK );\n    props.setLook( wBinaryMode );\n    wBinaryMode.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.BinaryMode.Tooltip\" ) );\n    fdBinaryMode = new FormData();\n    fdBinaryMode.left = new FormAttachment( middle, margin );\n    fdBinaryMode.top = new FormAttachment( wServerSettings, margin );\n    fdBinaryMode.right = new FormAttachment( 100, 0 );\n    wBinaryMode.setLayoutData( fdBinaryMode );\n\n    // Timeout line\n    wTimeout =\n      new LabelTextVar(\n        jobMeta, wAdvancedSettings, BaseMessages.getString( PKG, \"JobFTP.Timeout.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.Timeout.Tooltip\" ) );\n    props.setLook( wTimeout );\n    wTimeout.addModifyListener( lsMod );\n    fdTimeout = new FormData();\n    fdTimeout.left = new FormAttachment( 0, 0 );\n    fdTimeout.top = new FormAttachment( wlBinaryMode, margin );\n    fdTimeout.right = new FormAttachment( 100, 0 );\n    wTimeout.setLayoutData( fdTimeout );\n\n    // active connection?\n    wlActive = new Label( wAdvancedSettings, SWT.RIGHT );\n    wlActive.setText( BaseMessages.getString( PKG, \"JobFTP.ActiveConns.Label\" ) );\n    props.setLook( wlActive );\n    fdlActive = new FormData();\n    fdlActive.left = new FormAttachment( 0, 0 );\n    fdlActive.top = new FormAttachment( wTimeout, margin );\n    fdlActive.right = new FormAttachment( middle, 0 );\n    wlActive.setLayoutData( fdlActive );\n    wActive = new Button( wAdvancedSettings, SWT.CHECK );\n    wActive.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.ActiveConns.Tooltip\" ) );\n    props.setLook( wActive );\n    fdActive = new FormData();\n    fdActive.left = new FormAttachment( middle, margin );\n    fdActive.top = new FormAttachment( wTimeout, margin );\n    fdActive.right = new FormAttachment( 100, 0 );\n    wActive.setLayoutData( fdActive );\n\n    // Control encoding line\n    //\n    // The drop down is editable as it may happen an encoding may not be present\n    // on one machine, but you may want to use it on your execution server\n    //\n    wlControlEncoding = new Label( wAdvancedSettings, SWT.RIGHT );\n    wlControlEncoding.setText( BaseMessages.getString( PKG, \"JobFTP.ControlEncoding.Label\" ) );\n    props.setLook( wlControlEncoding );\n    fdlControlEncoding = new FormData();\n    fdlControlEncoding.left = new FormAttachment( 0, 0 );\n    fdlControlEncoding.top = new FormAttachment( wActive, margin );\n    fdlControlEncoding.right = new FormAttachment( middle, 0 );\n    wlControlEncoding.setLayoutData( fdlControlEncoding );\n    wControlEncoding = new Combo( wAdvancedSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wControlEncoding.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.ControlEncoding.Tooltip\" ) );\n    wControlEncoding.setItems( encodings );\n    props.setLook( wControlEncoding );\n    fdControlEncoding = new FormData();\n    fdControlEncoding.left = new FormAttachment( middle, margin );\n    fdControlEncoding.top = new FormAttachment( wActive, margin );\n    fdControlEncoding.right = new FormAttachment( 100, 0 );\n    wControlEncoding.setLayoutData( fdControlEncoding );\n\n    fdAdvancedSettings = new FormData();\n    fdAdvancedSettings.left = new FormAttachment( 0, margin );\n    fdAdvancedSettings.top = new FormAttachment( wServerSettings, margin );\n    fdAdvancedSettings.right = new FormAttachment( 100, -margin );\n    wAdvancedSettings.setLayoutData( fdAdvancedSettings );\n    // ///////////////////////////////////////////////////////////\n    // / END OF Advanced SETTINGS GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdGeneralComp = new FormData();\n    fdGeneralComp.left = new FormAttachment( 0, 0 );\n    fdGeneralComp.top = new FormAttachment( 0, 0 );\n    fdGeneralComp.right = new FormAttachment( 100, 0 );\n    fdGeneralComp.bottom = new FormAttachment( 100, 0 );\n    wGeneralComp.setLayoutData( fdGeneralComp );\n\n    wGeneralComp.layout();\n    wGeneralTab.setControl( wGeneralComp );\n    props.setLook( wGeneralComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF GENERAL TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF Files TAB ///\n    // ////////////////////////\n\n    wFilesTab = new CTabItem( wTabFolder, SWT.NONE );\n    wFilesTab.setText( BaseMessages.getString( PKG, \"JobFTP.Tab.Files.Label\" ) );\n\n    wFilesComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wFilesComp );\n\n    FormLayout FilesLayout = new FormLayout();\n    FilesLayout.marginWidth = 3;\n    FilesLayout.marginHeight = 3;\n    wFilesComp.setLayout( FilesLayout );\n\n    // ////////////////////////\n    // START OF Remote SETTINGS GROUP///\n    // /\n    wRemoteSettings = new Group( wFilesComp, SWT.SHADOW_NONE );\n    props.setLook( wRemoteSettings );\n    wRemoteSettings.setText( BaseMessages.getString( PKG, \"JobFTP.RemoteSettings.Group.Label\" ) );\n\n    FormLayout RemoteSettinsgroupLayout = new FormLayout();\n    RemoteSettinsgroupLayout.marginWidth = 10;\n    RemoteSettinsgroupLayout.marginHeight = 10;\n\n    wRemoteSettings.setLayout( RemoteSettinsgroupLayout );\n\n    // Move to directory\n    wlFtpDirectory = new Label( wRemoteSettings, SWT.RIGHT );\n    wlFtpDirectory.setText( BaseMessages.getString( PKG, \"JobFTP.RemoteDir.Label\" ) );\n    props.setLook( wlFtpDirectory );\n    fdlFtpDirectory = new FormData();\n    fdlFtpDirectory.left = new FormAttachment( 0, 0 );\n    fdlFtpDirectory.top = new FormAttachment( 0, margin );\n    fdlFtpDirectory.right = new FormAttachment( middle, 0 );\n    wlFtpDirectory.setLayoutData( fdlFtpDirectory );\n\n    // Test remote folder button ...\n    wbTestChangeFolderExists = new Button( wRemoteSettings, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbTestChangeFolderExists );\n    wbTestChangeFolderExists.setText( BaseMessages.getString( PKG, \"JobFTP.TestFolderExists.Label\" ) );\n    fdbTestChangeFolderExists = new FormData();\n    fdbTestChangeFolderExists.right = new FormAttachment( 100, 0 );\n    fdbTestChangeFolderExists.top = new FormAttachment( 0, margin );\n    wbTestChangeFolderExists.setLayoutData( fdbTestChangeFolderExists );\n\n    wFtpDirectory =\n      new TextVar( jobMeta, wRemoteSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobFTP.RemoteDir.Tooltip\" ) );\n    props.setLook( wFtpDirectory );\n    wFtpDirectory.addModifyListener( lsMod );\n    fdFtpDirectory = new FormData();\n    fdFtpDirectory.left = new FormAttachment( middle, margin );\n    fdFtpDirectory.top = new FormAttachment( 0, margin );\n    fdFtpDirectory.right = new FormAttachment( wbTestChangeFolderExists, -margin );\n    wFtpDirectory.setLayoutData( fdFtpDirectory );\n\n    // Wildcard line\n    wWildcard =\n      new LabelTextVar(\n        jobMeta, wRemoteSettings, BaseMessages.getString( PKG, \"JobFTP.Wildcard.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.Wildcard.Tooltip\" ) );\n    props.setLook( wWildcard );\n    wWildcard.addModifyListener( lsMod );\n    fdWildcard = new FormData();\n    fdWildcard.left = new FormAttachment( 0, 0 );\n    fdWildcard.top = new FormAttachment( wFtpDirectory, margin );\n    fdWildcard.right = new FormAttachment( 100, 0 );\n    wWildcard.setLayoutData( fdWildcard );\n\n    // Remove files after retrieval...\n    wlRemove = new Label( wRemoteSettings, SWT.RIGHT );\n    wlRemove.setText( BaseMessages.getString( PKG, \"JobFTP.RemoveFiles.Label\" ) );\n    props.setLook( wlRemove );\n    fdlRemove = new FormData();\n    fdlRemove.left = new FormAttachment( 0, 0 );\n    fdlRemove.top = new FormAttachment( wWildcard, margin );\n    fdlRemove.right = new FormAttachment( middle, 0 );\n    wlRemove.setLayoutData( fdlRemove );\n    wRemove = new Button( wRemoteSettings, SWT.CHECK );\n    wRemove.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.RemoveFiles.Tooltip\" ) );\n    props.setLook( wRemove );\n    fdRemove = new FormData();\n    fdRemove.left = new FormAttachment( middle, margin );\n    fdRemove.top = new FormAttachment( wWildcard, margin );\n    fdRemove.right = new FormAttachment( 100, 0 );\n    wRemove.setLayoutData( fdRemove );\n\n    wRemove.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        if ( wRemove.getSelection() ) {\n          wMove.setSelection( false );\n          activateMoveTo();\n        }\n\n      }\n    } );\n\n    // Move files after the transfert?...\n    wlMove = new Label( wRemoteSettings, SWT.RIGHT );\n    wlMove.setText( BaseMessages.getString( PKG, \"JobFTP.MoveFiles.Label\" ) );\n    props.setLook( wlMove );\n    fdlMove = new FormData();\n    fdlMove.left = new FormAttachment( 0, 0 );\n    fdlMove.top = new FormAttachment( wRemove, margin );\n    fdlMove.right = new FormAttachment( middle, -margin );\n    wlMove.setLayoutData( fdlMove );\n    wMove = new Button( wRemoteSettings, SWT.CHECK );\n    props.setLook( wMove );\n    wMove.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.MoveFiles.Tooltip\" ) );\n    fdMove = new FormData();\n    fdMove.left = new FormAttachment( middle, margin );\n    fdMove.top = new FormAttachment( wRemove, margin );\n    fdMove.right = new FormAttachment( 100, 0 );\n    wMove.setLayoutData( fdMove );\n    wMove.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        activateMoveTo();\n        if ( wMove.getSelection() ) {\n          wRemove.setSelection( false );\n        }\n\n      }\n    } );\n\n    // Move to directory\n    wlMoveToDirectory = new Label( wRemoteSettings, SWT.RIGHT );\n    wlMoveToDirectory.setText( BaseMessages.getString( PKG, \"JobFTP.MoveFolder.Label\" ) );\n    props.setLook( wlMoveToDirectory );\n    fdlMoveToDirectory = new FormData();\n    fdlMoveToDirectory.left = new FormAttachment( 0, 0 );\n    fdlMoveToDirectory.top = new FormAttachment( wMove, margin );\n    fdlMoveToDirectory.right = new FormAttachment( middle, 0 );\n    wlMoveToDirectory.setLayoutData( fdlMoveToDirectory );\n\n    // Test remote folder button ...\n    wbTestFolderExists = new Button( wRemoteSettings, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbTestFolderExists );\n    wbTestFolderExists.setText( BaseMessages.getString( PKG, \"JobFTP.TestFolderExists.Label\" ) );\n    fdbTestFolderExists = new FormData();\n    fdbTestFolderExists.right = new FormAttachment( 100, 0 );\n    fdbTestFolderExists.top = new FormAttachment( wMove, margin );\n    wbTestFolderExists.setLayoutData( fdbTestFolderExists );\n\n    wMoveToDirectory =\n      new TextVar( jobMeta, wRemoteSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobFTP.MoveToDirectory.Tooltip\" ) );\n    wMoveToDirectory.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.MoveFolder.Tooltip\" ) );\n    props.setLook( wMoveToDirectory );\n    wMoveToDirectory.addModifyListener( lsMod );\n    fdMoveToDirectory = new FormData();\n    fdMoveToDirectory.left = new FormAttachment( middle, margin );\n    fdMoveToDirectory.top = new FormAttachment( wMove, margin );\n    fdMoveToDirectory.right = new FormAttachment( wbTestFolderExists, -margin );\n    wMoveToDirectory.setLayoutData( fdMoveToDirectory );\n\n    // create destination folder?...\n    wlCreateMoveFolder = new Label( wRemoteSettings, SWT.RIGHT );\n    wlCreateMoveFolder.setText( BaseMessages.getString( PKG, \"JobFTP.CreateMoveFolder.Label\" ) );\n    props.setLook( wlCreateMoveFolder );\n    fdlCreateMoveFolder = new FormData();\n    fdlCreateMoveFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateMoveFolder.top = new FormAttachment( wMoveToDirectory, margin );\n    fdlCreateMoveFolder.right = new FormAttachment( middle, 0 );\n    wlCreateMoveFolder.setLayoutData( fdlCreateMoveFolder );\n    wCreateMoveFolder = new Button( wRemoteSettings, SWT.CHECK );\n    wCreateMoveFolder.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.CreateMoveFolder.Tooltip\" ) );\n    props.setLook( wCreateMoveFolder );\n    fdCreateMoveFolder = new FormData();\n    fdCreateMoveFolder.left = new FormAttachment( middle, margin );\n    fdCreateMoveFolder.top = new FormAttachment( wMoveToDirectory, margin );\n    fdCreateMoveFolder.right = new FormAttachment( 100, 0 );\n    wCreateMoveFolder.setLayoutData( fdCreateMoveFolder );\n\n    fdRemoteSettings = new FormData();\n    fdRemoteSettings.left = new FormAttachment( 0, margin );\n    fdRemoteSettings.top = new FormAttachment( 0, 2 * margin );\n    fdRemoteSettings.right = new FormAttachment( 100, -margin );\n    wRemoteSettings.setLayoutData( fdRemoteSettings );\n    // ///////////////////////////////////////////////////////////\n    // / END OF Remote SETTINGSGROUP\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF LOCAL SETTINGS GROUP///\n    // /\n    wLocalSettings = new Group( wFilesComp, SWT.SHADOW_NONE );\n    props.setLook( wLocalSettings );\n    wLocalSettings.setText( BaseMessages.getString( PKG, \"JobFTP.LocalSettings.Group.Label\" ) );\n\n    FormLayout LocalSettinsgroupLayout = new FormLayout();\n    LocalSettinsgroupLayout.marginWidth = 10;\n    LocalSettinsgroupLayout.marginHeight = 10;\n\n    wLocalSettings.setLayout( LocalSettinsgroupLayout );\n\n    // TargetDirectory\n    wlTargetDirectory = new Label( wLocalSettings, SWT.RIGHT );\n    wlTargetDirectory.setText( BaseMessages.getString( PKG, \"JobFTP.TargetDir.Label\" ) );\n    props.setLook( wlTargetDirectory );\n    fdlTargetDirectory = new FormData();\n    fdlTargetDirectory.left = new FormAttachment( 0, 0 );\n    fdlTargetDirectory.top = new FormAttachment( wRemoteSettings, margin );\n    fdlTargetDirectory.right = new FormAttachment( middle, -margin );\n    wlTargetDirectory.setLayoutData( fdlTargetDirectory );\n\n    // Browse folders button ...\n    wbTargetDirectory = new Button( wLocalSettings, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbTargetDirectory );\n    wbTargetDirectory.setText( BaseMessages.getString( PKG, \"JobFTP.BrowseFolders.Label\" ) );\n    fdbTargetDirectory = new FormData();\n    fdbTargetDirectory.right = new FormAttachment( 100, 0 );\n    fdbTargetDirectory.top = new FormAttachment( wRemoteSettings, margin );\n    wbTargetDirectory.setLayoutData( fdbTargetDirectory );\n    wbTargetDirectory.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog ddialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wTargetDirectory.getText() != null ) {\n          ddialog.setFilterPath( jobMeta.environmentSubstitute( wTargetDirectory.getText() ) );\n        }\n\n        // Calling open() will open and run the dialog.\n        // It will return the selected directory, or\n        // null if user cancels\n        String dir = ddialog.open();\n        if ( dir != null ) {\n          // Set the text box to the new selection\n          wTargetDirectory.setText( dir );\n        }\n\n      }\n    } );\n\n    wTargetDirectory =\n      new TextVar( jobMeta, wLocalSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobFTP.TargetDir.Tooltip\" ) );\n    props.setLook( wTargetDirectory );\n    wTargetDirectory.addModifyListener( lsMod );\n    fdTargetDirectory = new FormData();\n    fdTargetDirectory.left = new FormAttachment( middle, margin );\n    fdTargetDirectory.top = new FormAttachment( wRemoteSettings, margin );\n    fdTargetDirectory.right = new FormAttachment( wbTargetDirectory, -margin );\n    wTargetDirectory.setLayoutData( fdTargetDirectory );\n\n    // Create multi-part file?\n    wlAddDate = new Label( wLocalSettings, SWT.RIGHT );\n    wlAddDate.setText( BaseMessages.getString( PKG, \"JobFTP.AddDate.Label\" ) );\n    props.setLook( wlAddDate );\n    fdlAddDate = new FormData();\n    fdlAddDate.left = new FormAttachment( 0, 0 );\n    fdlAddDate.top = new FormAttachment( wTargetDirectory, margin );\n    fdlAddDate.right = new FormAttachment( middle, -margin );\n    wlAddDate.setLayoutData( fdlAddDate );\n    wAddDate = new Button( wLocalSettings, SWT.CHECK );\n    props.setLook( wAddDate );\n    wAddDate.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.AddDate.Tooltip\" ) );\n    fdAddDate = new FormData();\n    fdAddDate.left = new FormAttachment( middle, margin );\n    fdAddDate.top = new FormAttachment( wTargetDirectory, margin );\n    fdAddDate.right = new FormAttachment( 100, 0 );\n    wAddDate.setLayoutData( fdAddDate );\n    wAddDate.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n    // Create multi-part file?\n    wlAddTime = new Label( wLocalSettings, SWT.RIGHT );\n    wlAddTime.setText( BaseMessages.getString( PKG, \"JobFTP.AddTime.Label\" ) );\n    props.setLook( wlAddTime );\n    fdlAddTime = new FormData();\n    fdlAddTime.left = new FormAttachment( 0, 0 );\n    fdlAddTime.top = new FormAttachment( wAddDate, margin );\n    fdlAddTime.right = new FormAttachment( middle, -margin );\n    wlAddTime.setLayoutData( fdlAddTime );\n    wAddTime = new Button( wLocalSettings, SWT.CHECK );\n    props.setLook( wAddTime );\n    wAddTime.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.AddTime.Tooltip\" ) );\n    fdAddTime = new FormData();\n    fdAddTime.left = new FormAttachment( middle, margin );\n    fdAddTime.top = new FormAttachment( wAddDate, margin );\n    fdAddTime.right = new FormAttachment( 100, 0 );\n    wAddTime.setLayoutData( fdAddTime );\n    wAddTime.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Specify date time format?\n    wlSpecifyFormat = new Label( wLocalSettings, SWT.RIGHT );\n    wlSpecifyFormat.setText( BaseMessages.getString( PKG, \"JobFTP.SpecifyFormat.Label\" ) );\n    props.setLook( wlSpecifyFormat );\n    fdlSpecifyFormat = new FormData();\n    fdlSpecifyFormat.left = new FormAttachment( 0, 0 );\n    fdlSpecifyFormat.top = new FormAttachment( wAddTime, margin );\n    fdlSpecifyFormat.right = new FormAttachment( middle, -margin );\n    wlSpecifyFormat.setLayoutData( fdlSpecifyFormat );\n    wSpecifyFormat = new Button( wLocalSettings, SWT.CHECK );\n    props.setLook( wSpecifyFormat );\n    wSpecifyFormat.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.SpecifyFormat.Tooltip\" ) );\n    fdSpecifyFormat = new FormData();\n    fdSpecifyFormat.left = new FormAttachment( middle, margin );\n    fdSpecifyFormat.top = new FormAttachment( wAddTime, margin );\n    fdSpecifyFormat.right = new FormAttachment( 100, 0 );\n    wSpecifyFormat.setLayoutData( fdSpecifyFormat );\n    wSpecifyFormat.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setDateTimeFormat();\n        setAddDateBeforeExtension();\n      }\n    } );\n\n    // Prepare a list of possible DateTimeFormats...\n    String[] dats = Const.getDateFormats();\n\n    // DateTimeFormat\n    wlDateTimeFormat = new Label( wLocalSettings, SWT.RIGHT );\n    wlDateTimeFormat.setText( BaseMessages.getString( PKG, \"JobFTP.DateTimeFormat.Label\" ) );\n    props.setLook( wlDateTimeFormat );\n    fdlDateTimeFormat = new FormData();\n    fdlDateTimeFormat.left = new FormAttachment( 0, 0 );\n    fdlDateTimeFormat.top = new FormAttachment( wSpecifyFormat, margin );\n    fdlDateTimeFormat.right = new FormAttachment( middle, -margin );\n    wlDateTimeFormat.setLayoutData( fdlDateTimeFormat );\n    wDateTimeFormat = new CCombo( wLocalSettings, SWT.BORDER | SWT.READ_ONLY );\n    wDateTimeFormat.setEditable( true );\n    props.setLook( wDateTimeFormat );\n    wDateTimeFormat.addModifyListener( lsMod );\n    fdDateTimeFormat = new FormData();\n    fdDateTimeFormat.left = new FormAttachment( middle, margin );\n    fdDateTimeFormat.top = new FormAttachment( wSpecifyFormat, margin );\n    fdDateTimeFormat.right = new FormAttachment( 100, 0 );\n    wDateTimeFormat.setLayoutData( fdDateTimeFormat );\n    for ( String dat : dats ) {\n      wDateTimeFormat.add( dat );\n    }\n\n    // Add Date before extension?\n    wlAddDateBeforeExtension = new Label( wLocalSettings, SWT.RIGHT );\n    wlAddDateBeforeExtension.setText( BaseMessages.getString( PKG, \"JobFTP.AddDateBeforeExtension.Label\" ) );\n    props.setLook( wlAddDateBeforeExtension );\n    fdlAddDateBeforeExtension = new FormData();\n    fdlAddDateBeforeExtension.left = new FormAttachment( 0, 0 );\n    fdlAddDateBeforeExtension.top = new FormAttachment( wDateTimeFormat, margin );\n    fdlAddDateBeforeExtension.right = new FormAttachment( middle, -margin );\n    wlAddDateBeforeExtension.setLayoutData( fdlAddDateBeforeExtension );\n    wAddDateBeforeExtension = new Button( wLocalSettings, SWT.CHECK );\n    props.setLook( wAddDateBeforeExtension );\n    wAddDateBeforeExtension\n      .setToolTipText( BaseMessages.getString( PKG, \"JobFTP.AddDateBeforeExtension.Tooltip\" ) );\n    fdAddDateBeforeExtension = new FormData();\n    fdAddDateBeforeExtension.left = new FormAttachment( middle, margin );\n    fdAddDateBeforeExtension.top = new FormAttachment( wDateTimeFormat, margin );\n    fdAddDateBeforeExtension.right = new FormAttachment( 100, 0 );\n    wAddDateBeforeExtension.setLayoutData( fdAddDateBeforeExtension );\n    wAddDateBeforeExtension.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // OnlyNew files after retrieval...\n    wlOnlyNew = new Label( wLocalSettings, SWT.RIGHT );\n    wlOnlyNew.setText( BaseMessages.getString( PKG, \"JobFTP.DontOverwrite.Label\" ) );\n    props.setLook( wlOnlyNew );\n    fdlOnlyNew = new FormData();\n    fdlOnlyNew.left = new FormAttachment( 0, 0 );\n    fdlOnlyNew.top = new FormAttachment( wAddDateBeforeExtension, margin );\n    fdlOnlyNew.right = new FormAttachment( middle, 0 );\n    wlOnlyNew.setLayoutData( fdlOnlyNew );\n    wOnlyNew = new Button( wLocalSettings, SWT.CHECK );\n    wOnlyNew.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.DontOverwrite.Tooltip\" ) );\n    props.setLook( wOnlyNew );\n    fdOnlyNew = new FormData();\n    fdOnlyNew.left = new FormAttachment( middle, margin );\n    fdOnlyNew.top = new FormAttachment( wAddDateBeforeExtension, margin );\n    fdOnlyNew.right = new FormAttachment( 100, 0 );\n    wOnlyNew.setLayoutData( fdOnlyNew );\n    wOnlyNew.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        activeIfExists();\n        jobEntry.setChanged();\n      }\n    } );\n\n    // If File Exists\n    wlIfFileExists = new Label( wLocalSettings, SWT.RIGHT );\n    wlIfFileExists.setText( BaseMessages.getString( PKG, \"JobFTP.IfFileExists.Label\" ) );\n    props.setLook( wlIfFileExists );\n    fdlIfFileExists = new FormData();\n    fdlIfFileExists.left = new FormAttachment( 0, 0 );\n    fdlIfFileExists.right = new FormAttachment( middle, 0 );\n    fdlIfFileExists.top = new FormAttachment( wOnlyNew, margin );\n    wlIfFileExists.setLayoutData( fdlIfFileExists );\n    wIfFileExists = new CCombo( wLocalSettings, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobFTP.Skip.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobFTP.Give_Unique_Name.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobFTP.Fail.Label\" ) );\n    wIfFileExists.select( 0 ); // +1: starts at -1\n\n    props.setLook( wIfFileExists );\n\n    fdIfFileExists = new FormData();\n    fdIfFileExists.left = new FormAttachment( middle, margin );\n    fdIfFileExists.top = new FormAttachment( wOnlyNew, margin );\n    fdIfFileExists.right = new FormAttachment( 100, 0 );\n    wIfFileExists.setLayoutData( fdIfFileExists );\n\n    wIfFileExists.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n      }\n    } );\n\n    // Add filenames to result filenames...\n    wlAddFilenameToResult = new Label( wLocalSettings, SWT.RIGHT );\n    wlAddFilenameToResult.setText( BaseMessages.getString( PKG, \"JobFTP.AddFilenameToResult.Label\" ) );\n    props.setLook( wlAddFilenameToResult );\n    fdlAddFilenameToResult = new FormData();\n    fdlAddFilenameToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFilenameToResult.top = new FormAttachment( wIfFileExists, 2 * margin );\n    fdlAddFilenameToResult.right = new FormAttachment( middle, 0 );\n    wlAddFilenameToResult.setLayoutData( fdlAddFilenameToResult );\n    wAddFilenameToResult = new Button( wLocalSettings, SWT.CHECK );\n    wAddFilenameToResult.setToolTipText( BaseMessages.getString( PKG, \"JobFTP.AddFilenameToResult.Tooltip\" ) );\n    props.setLook( wAddFilenameToResult );\n    fdAddFilenameToResult = new FormData();\n    fdAddFilenameToResult.left = new FormAttachment( middle, margin );\n    fdAddFilenameToResult.top = new FormAttachment( wIfFileExists, 2 * margin );\n    fdAddFilenameToResult.right = new FormAttachment( 100, 0 );\n    wAddFilenameToResult.setLayoutData( fdAddFilenameToResult );\n\n    fdLocalSettings = new FormData();\n    fdLocalSettings.left = new FormAttachment( 0, margin );\n    fdLocalSettings.top = new FormAttachment( wRemoteSettings, margin );\n    fdLocalSettings.right = new FormAttachment( 100, -margin );\n    wLocalSettings.setLayoutData( fdLocalSettings );\n    // ///////////////////////////////////////////////////////////\n    // / END OF LOCAL SETTINGSGROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdFilesComp = new FormData();\n    fdFilesComp.left = new FormAttachment( 0, 0 );\n    fdFilesComp.top = new FormAttachment( 0, 0 );\n    fdFilesComp.right = new FormAttachment( 100, 0 );\n    fdFilesComp.bottom = new FormAttachment( 100, 0 );\n    wFilesComp.setLayoutData( fdFilesComp );\n\n    wFilesComp.layout();\n    wFilesTab.setControl( wFilesComp );\n    props.setLook( wFilesComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF Files TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF Advanced TAB ///\n    // ////////////////////////\n\n    wAdvancedTab = new CTabItem( wTabFolder, SWT.NONE );\n    wAdvancedTab.setText( BaseMessages.getString( PKG, \"JobFTP.Tab.Advanced.Label\" ) );\n\n    wAdvancedComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wAdvancedComp );\n\n    FormLayout AdvancedLayout = new FormLayout();\n    AdvancedLayout.marginWidth = 3;\n    AdvancedLayout.marginHeight = 3;\n    wAdvancedComp.setLayout( AdvancedLayout );\n\n    // SuccessOngrouping?\n    // ////////////////////////\n    // START OF SUCCESS ON GROUP///\n    // /\n    wSuccessOn = new Group( wAdvancedComp, SWT.SHADOW_NONE );\n    props.setLook( wSuccessOn );\n    wSuccessOn.setText( BaseMessages.getString( PKG, \"JobFTP.SuccessOn.Group.Label\" ) );\n\n    FormLayout successongroupLayout = new FormLayout();\n    successongroupLayout.marginWidth = 10;\n    successongroupLayout.marginHeight = 10;\n\n    wSuccessOn.setLayout( successongroupLayout );\n\n    // Success Condition\n    wlSuccessCondition = new Label( wSuccessOn, SWT.RIGHT );\n    wlSuccessCondition.setText( BaseMessages.getString( PKG, \"JobFTP.SuccessCondition.Label\" ) + \" \" );\n    props.setLook( wlSuccessCondition );\n    fdlSuccessCondition = new FormData();\n    fdlSuccessCondition.left = new FormAttachment( 0, 0 );\n    fdlSuccessCondition.right = new FormAttachment( middle, 0 );\n    fdlSuccessCondition.top = new FormAttachment( 0, margin );\n    wlSuccessCondition.setLayoutData( fdlSuccessCondition );\n    wSuccessCondition = new CCombo( wSuccessOn, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobFTP.SuccessWhenAllWorksFine.Label\" ) );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobFTP.SuccessWhenAtLeat.Label\" ) );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobFTP.SuccessWhenNrErrorsLessThan.Label\" ) );\n    wSuccessCondition.select( 0 ); // +1: starts at -1\n\n    props.setLook( wSuccessCondition );\n    fdSuccessCondition = new FormData();\n    fdSuccessCondition.left = new FormAttachment( middle, 0 );\n    fdSuccessCondition.top = new FormAttachment( 0, margin );\n    fdSuccessCondition.right = new FormAttachment( 100, 0 );\n    wSuccessCondition.setLayoutData( fdSuccessCondition );\n    wSuccessCondition.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        activeSuccessCondition();\n\n      }\n    } );\n\n    // Success when number of errors less than\n    wlNrErrorsLessThan = new Label( wSuccessOn, SWT.RIGHT );\n    wlNrErrorsLessThan.setText( BaseMessages.getString( PKG, \"JobFTP.NrBadFormedLessThan.Label\" ) + \" \" );\n    props.setLook( wlNrErrorsLessThan );\n    fdlNrErrorsLessThan = new FormData();\n    fdlNrErrorsLessThan.left = new FormAttachment( 0, 0 );\n    fdlNrErrorsLessThan.top = new FormAttachment( wSuccessCondition, margin );\n    fdlNrErrorsLessThan.right = new FormAttachment( middle, -margin );\n    wlNrErrorsLessThan.setLayoutData( fdlNrErrorsLessThan );\n\n    wNrErrorsLessThan =\n      new TextVar( jobMeta, wSuccessOn, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobFTP.NrBadFormedLessThan.Tooltip\" ) );\n    props.setLook( wNrErrorsLessThan );\n    wNrErrorsLessThan.addModifyListener( lsMod );\n    fdNrErrorsLessThan = new FormData();\n    fdNrErrorsLessThan.left = new FormAttachment( middle, 0 );\n    fdNrErrorsLessThan.top = new FormAttachment( wSuccessCondition, margin );\n    fdNrErrorsLessThan.right = new FormAttachment( 100, -margin );\n    wNrErrorsLessThan.setLayoutData( fdNrErrorsLessThan );\n\n    fdSuccessOn = new FormData();\n    fdSuccessOn.left = new FormAttachment( 0, margin );\n    fdSuccessOn.top = new FormAttachment( 0, margin );\n    fdSuccessOn.right = new FormAttachment( 100, -margin );\n    wSuccessOn.setLayoutData( fdSuccessOn );\n    // ///////////////////////////////////////////////////////////\n    // / END OF Success ON GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdAdvancedComp = new FormData();\n    fdAdvancedComp.left = new FormAttachment( 0, 0 );\n    fdAdvancedComp.top = new FormAttachment( 0, 0 );\n    fdAdvancedComp.right = new FormAttachment( 100, 0 );\n    fdAdvancedComp.bottom = new FormAttachment( 100, 0 );\n    wAdvancedComp.setLayoutData( fdAdvancedComp );\n\n    wAdvancedComp.layout();\n    wAdvancedTab.setControl( wAdvancedComp );\n    props.setLook( wAdvancedComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF Advanced TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ///////////////////////////////////////////////////////////\n    // Start of Socks Proxy Tab\n    // ///////////////////////////////////////////////////////////\n    wSocksProxyTab = new CTabItem( wTabFolder, SWT.NONE );\n    wSocksProxyTab.setText( BaseMessages.getString( PKG, \"JobFTP.Tab.Socks.Label\" ) );\n\n    wSocksProxyComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wSocksProxyComp );\n\n    FormLayout SoxProxyLayout = new FormLayout();\n    SoxProxyLayout.marginWidth = 3;\n    SoxProxyLayout.marginHeight = 3;\n    wSocksProxyComp.setLayout( SoxProxyLayout );\n\n    // ////////////////////////////////////////////////////////\n    // Start of Proxy Group\n    // ////////////////////////////////////////////////////////\n    wSocksProxy = new Group( wSocksProxyComp, SWT.SHADOW_NONE );\n    props.setLook( wSocksProxy );\n    wSocksProxy.setText( BaseMessages.getString( PKG, \"JobFTP.SocksProxy.Group.Label\" ) );\n\n    FormLayout SocksProxyGroupLayout = new FormLayout();\n    SocksProxyGroupLayout.marginWidth = 10;\n    SocksProxyGroupLayout.marginHeight = 10;\n    wSocksProxy.setLayout( SocksProxyGroupLayout );\n\n    // host line\n    wSocksProxyHost =\n      new LabelTextVar(\n        jobMeta, wSocksProxy, BaseMessages.getString( PKG, \"JobFTP.SocksProxyHost.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.SocksProxyHost.Tooltip\" ) );\n    props.setLook( wSocksProxyHost );\n    wSocksProxyHost.addModifyListener( lsMod );\n    fdSocksProxyHost = new FormData();\n    fdSocksProxyHost.left = new FormAttachment( 0, 0 );\n    fdSocksProxyHost.top = new FormAttachment( wName, margin );\n    fdSocksProxyHost.right = new FormAttachment( 100, margin );\n    wSocksProxyHost.setLayoutData( fdSocksProxyHost );\n\n    // port line\n    wSocksProxyPort =\n      new LabelTextVar(\n        jobMeta, wSocksProxy, BaseMessages.getString( PKG, \"JobFTP.SocksProxyPort.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.SocksProxyPort.Tooltip\" ) );\n    props.setLook( wSocksProxyPort );\n    wSocksProxyPort.addModifyListener( lsMod );\n    fdSocksProxyPort = new FormData();\n    fdSocksProxyPort.left = new FormAttachment( 0, 0 );\n    fdSocksProxyPort.top = new FormAttachment( wSocksProxyHost, margin );\n    fdSocksProxyPort.right = new FormAttachment( 100, margin );\n    wSocksProxyPort.setLayoutData( fdSocksProxyPort );\n\n    // username line\n    wSocksProxyUsername =\n      new LabelTextVar(\n        jobMeta, wSocksProxy, BaseMessages.getString( PKG, \"JobFTP.SocksProxyUsername.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.SocksProxyPassword.Tooltip\" ) );\n    props.setLook( wSocksProxyUsername );\n    wSocksProxyUsername.addModifyListener( lsMod );\n    fdSocksProxyUsername = new FormData();\n    fdSocksProxyUsername.left = new FormAttachment( 0, 0 );\n    fdSocksProxyUsername.top = new FormAttachment( wSocksProxyPort, margin );\n    fdSocksProxyUsername.right = new FormAttachment( 100, margin );\n    wSocksProxyUsername.setLayoutData( fdSocksProxyUsername );\n\n    // password line\n    wSocksProxyPassword =\n      new LabelTextVar(\n        jobMeta, wSocksProxy, BaseMessages.getString( PKG, \"JobFTP.SocksProxyPassword.Label\" ), BaseMessages\n          .getString( PKG, \"JobFTP.SocksProxyPassword.Tooltip\" ) );\n    props.setLook( wSocksProxyPort );\n    wSocksProxyPassword.setEchoChar( '*' );\n    wSocksProxyPassword.addModifyListener( lsMod );\n    fdSocksProxyPassword = new FormData();\n    fdSocksProxyPassword.left = new FormAttachment( 0, 0 );\n    fdSocksProxyPassword.top = new FormAttachment( wSocksProxyUsername, margin );\n    fdSocksProxyPassword.right = new FormAttachment( 100, margin );\n    wSocksProxyPassword.setLayoutData( fdSocksProxyPassword );\n\n    // OK, if the password contains a variable, we don't want to have the password hidden...\n    wSocksProxyPassword.getTextWidget().addModifyListener( new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        checkSocksProxyPasswordVisible();\n      }\n    } );\n\n    // ///////////////////////////////////////////////////////////////\n    // End of socks proxy group\n    // ///////////////////////////////////////////////////////////////\n\n    fdSocksProxyComp = new FormData();\n    fdSocksProxyComp.left = new FormAttachment( 0, margin );\n    fdSocksProxyComp.top = new FormAttachment( 0, margin );\n    fdSocksProxyComp.right = new FormAttachment( 100, -margin );\n    wSocksProxy.setLayoutData( fdSocksProxyComp );\n\n    wSocksProxyComp.layout();\n    wSocksProxyTab.setControl( wSocksProxyComp );\n    props.setLook( wSocksProxyComp );\n\n    // ////////////////////////////////////////////////////////\n    // End of Socks Proxy Tab\n    // ////////////////////////////////////////////////////////\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( wName, margin );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -50 );\n    wTabFolder.setLayoutData( fdTabFolder );\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    BaseStepDialog.positionBottomButtons( shell, new Button[] { wOK, wCancel }, margin, wTabFolder );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n    lsTest = new Listener() {\n      public void handleEvent( Event e ) {\n        test();\n      }\n    };\n    lsCheckFolder = new Listener() {\n      public void handleEvent( Event e ) {\n        checkRemoteFolder( false, true, wMoveToDirectory.getText() );\n      }\n    };\n    lsCheckChangeFolder = new Listener() {\n      public void handleEvent( Event e ) {\n        checkRemoteFolder( true, false, wFtpDirectory.getText() );\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n    wTest.addListener( SWT.Selection, lsTest );\n    wbTestFolderExists.addListener( SWT.Selection, lsCheckFolder );\n    wbTestChangeFolderExists.addListener( SWT.Selection, lsCheckChangeFolder );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n    wServerName.addSelectionListener( lsDef );\n    wUserName.addSelectionListener( lsDef );\n    wPassword.addSelectionListener( lsDef );\n    wFtpDirectory.addSelectionListener( lsDef );\n    wTargetDirectory.addSelectionListener( lsDef );\n    wFtpDirectory.addSelectionListener( lsDef );\n    wWildcard.addSelectionListener( lsDef );\n    wTimeout.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    activateMoveTo();\n    setDateTimeFormat();\n    setAddDateBeforeExtension();\n    activeSuccessCondition();\n    activeIfExists();\n\n    wTabFolder.setSelection( 0 );\n    BaseStepDialog.setSize( shell );\n\n    shell.open();\n    props.setDialogSize( shell, \"JobFTPDialogSize\" );\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return jobEntry;\n  }","commit_id":"36ef1a5cd33fb37488baaea0509bd1c79ded9214","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean connectToFTP( boolean checkfolder, boolean checkmoveToFolder ) {\n    boolean retval = false;\n    try {\n      if ( ftpclient == null || !ftpclient.connected() ) {\n        // Create ftp client to host:port ...\n        ftpclient = new FTPClient();\n        String realServername = jobMeta.environmentSubstitute( wServerName.getText() );\n        ftpclient.setRemoteAddr( InetAddress.getByName( realServername ) );\n\n        if ( !Const.isEmpty( wProxyHost.getText() ) ) {\n          String realProxy_host = jobMeta.environmentSubstitute( wProxyHost.getText() );\n          ftpclient.setRemoteAddr( InetAddress.getByName( realProxy_host ) );\n\n          // FIXME: Proper default port for proxy\n          int port = Const.toInt( jobMeta.environmentSubstitute( wProxyHost.getText() ), 21 );\n          if ( port != 0 ) {\n            ftpclient.setRemotePort( port );\n          }\n        } else {\n          ftpclient.setRemoteAddr( InetAddress.getByName( realServername ) );\n\n        }\n\n        // login to ftp host ...\n        ftpclient.connect();\n        String realUsername =\n          jobMeta.environmentSubstitute( wUserName.getText() )\n            + ( !Const.isEmpty( wProxyHost.getText() ) ? \"@\" + realServername : \"\" )\n            + ( !Const.isEmpty( wProxyUsername.getText() ) ? \" \"\n              + jobMeta.environmentSubstitute( wProxyUsername.getText() ) : \"\" );\n\n        String realPassword =\n          jobMeta.environmentSubstitute( wPassword.getText() )\n            + ( !Const.isEmpty( wProxyPassword.getText() ) ? \" \"\n              + jobMeta.environmentSubstitute( wProxyPassword.getText() ) : \"\" );\n        // login now ...\n        ftpclient.login( realUsername, realPassword );\n        pwdFolder = ftpclient.pwd();\n      }\n\n      String realFtpDirectory = \"\";\n      if ( !Const.isEmpty( wFtpDirectory.getText() ) ) {\n        realFtpDirectory = jobMeta.environmentSubstitute( wFtpDirectory.getText() );\n      }\n\n      if ( checkfolder ) {\n        if ( pwdFolder != null ) {\n          ftpclient.chdir( pwdFolder );\n        }\n        // move to spool dir ...\n        if ( !Const.isEmpty( realFtpDirectory ) ) {\n          ftpclient.chdir( realFtpDirectory );\n        }\n      }\n      if ( checkmoveToFolder ) {\n        if ( pwdFolder != null ) {\n          ftpclient.chdir( pwdFolder );\n        }\n\n        // move to folder ...\n\n        if ( !Const.isEmpty( wMoveToDirectory.getText() ) ) {\n          String realMoveDirectory = jobMeta.environmentSubstitute( wMoveToDirectory.getText() );\n          realMoveDirectory = realFtpDirectory + \"/\" + realMoveDirectory;\n          ftpclient.chdir( realMoveDirectory );\n        }\n      }\n\n      retval = true;\n    } catch ( Exception e ) {\n      MessageBox mb = new MessageBox( shell, SWT.OK | SWT.ICON_ERROR );\n      mb.setMessage( BaseMessages.getString( PKG, \"JobFTP.ErrorConnect.NOK\", e.getMessage() ) + Const.CR );\n      mb.setText( BaseMessages.getString( PKG, \"JobFTP.ErrorConnect.Title.Bad\" ) );\n      mb.open();\n    }\n    return retval;\n  }","id":26392,"modified_method":"private boolean connectToFTP( boolean checkfolder, boolean checkmoveToFolder ) {\n    boolean retval = false;\n    try {\n      if ( ftpclient == null || !ftpclient.connected() ) {\n        // Create ftp client to host:port ...\n        ftpclient = new FTPClient();\n        String realServername = jobMeta.environmentSubstitute( wServerName.getText() );\n        int realPort = Const.toInt( jobMeta.environmentSubstitute( wPort.getText() ), 21 );\n        ftpclient.setRemoteAddr( InetAddress.getByName( realServername ) );\n        ftpclient.setRemotePort( realPort );\n\n        if ( !Const.isEmpty( wProxyHost.getText() ) ) {\n          String realProxy_host = jobMeta.environmentSubstitute( wProxyHost.getText() );\n          ftpclient.setRemoteAddr( InetAddress.getByName( realProxy_host ) );\n\n          int port = Const.toInt( jobMeta.environmentSubstitute( wProxyPort.getText() ), 21 );\n          if ( port != 0 ) {\n            ftpclient.setRemotePort( port );\n          }\n        }\n\n        // login to ftp host ...\n        ftpclient.connect();\n        String realUsername =\n          jobMeta.environmentSubstitute( wUserName.getText() )\n            + ( !Const.isEmpty( wProxyHost.getText() ) ? \"@\" + realServername : \"\" )\n            + ( !Const.isEmpty( wProxyUsername.getText() ) ? \" \"\n              + jobMeta.environmentSubstitute( wProxyUsername.getText() ) : \"\" );\n\n        String realPassword =\n          jobMeta.environmentSubstitute( wPassword.getText() )\n            + ( !Const.isEmpty( wProxyPassword.getText() ) ? \" \"\n              + jobMeta.environmentSubstitute( wProxyPassword.getText() ) : \"\" );\n        // login now ...\n        ftpclient.login( realUsername, realPassword );\n        pwdFolder = ftpclient.pwd();\n      }\n\n      String realFtpDirectory = \"\";\n      if ( !Const.isEmpty( wFtpDirectory.getText() ) ) {\n        realFtpDirectory = jobMeta.environmentSubstitute( wFtpDirectory.getText() );\n      }\n\n      if ( checkfolder ) {\n        if ( pwdFolder != null ) {\n          ftpclient.chdir( pwdFolder );\n        }\n        // move to spool dir ...\n        if ( !Const.isEmpty( realFtpDirectory ) ) {\n          ftpclient.chdir( realFtpDirectory );\n        }\n      }\n      if ( checkmoveToFolder ) {\n        if ( pwdFolder != null ) {\n          ftpclient.chdir( pwdFolder );\n        }\n\n        // move to folder ...\n\n        if ( !Const.isEmpty( wMoveToDirectory.getText() ) ) {\n          String realMoveDirectory = jobMeta.environmentSubstitute( wMoveToDirectory.getText() );\n          realMoveDirectory = realFtpDirectory + \"/\" + realMoveDirectory;\n          ftpclient.chdir( realMoveDirectory );\n        }\n      }\n\n      retval = true;\n    } catch ( Exception e ) {\n      MessageBox mb = new MessageBox( shell, SWT.OK | SWT.ICON_ERROR );\n      mb.setMessage( BaseMessages.getString( PKG, \"JobFTP.ErrorConnect.NOK\", e.getMessage() ) + Const.CR );\n      mb.setText( BaseMessages.getString( PKG, \"JobFTP.ErrorConnect.Title.Bad\" ) );\n      mb.open();\n    }\n    return retval;\n  }","commit_id":"36ef1a5cd33fb37488baaea0509bd1c79ded9214","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean connectToFTP( boolean checkfolder, String remoteFoldername ) {\n    boolean retval = false;\n    try {\n      if ( ftpclient == null || !ftpclient.connected() ) {\n        // Create ftp client to host:port ...\n        ftpclient = new FTPClient();\n        String realServername = jobMeta.environmentSubstitute( wServerName.getText() );\n        ftpclient.setRemoteAddr( InetAddress.getByName( realServername ) );\n\n        if ( !Const.isEmpty( wProxyHost.getText() ) ) {\n          String realProxy_host = jobMeta.environmentSubstitute( wProxyHost.getText() );\n          ftpclient.setRemoteAddr( InetAddress.getByName( realProxy_host ) );\n\n          // FIXME: Proper default port for proxy\n          int port = Const.toInt( jobMeta.environmentSubstitute( wProxyHost.getText() ), 21 );\n          if ( port != 0 ) {\n            ftpclient.setRemotePort( port );\n          }\n        } else {\n          ftpclient.setRemoteAddr( InetAddress.getByName( realServername ) );\n        }\n\n        // login to ftp host ...\n        ftpclient.connect();\n        String realUsername =\n          jobMeta.environmentSubstitute( wUserName.getText() )\n            + ( !Const.isEmpty( wProxyHost.getText() ) ? \"@\" + realServername : \"\" )\n            + ( !Const.isEmpty( wProxyUsername.getText() ) ? \" \"\n              + jobMeta.environmentSubstitute( wProxyUsername.getText() ) : \"\" );\n\n        String realPassword =\n          jobMeta.environmentSubstitute( wPassword.getText() )\n            + ( !Const.isEmpty( wProxyPassword.getText() ) ? \" \"\n              + jobMeta.environmentSubstitute( wProxyPassword.getText() ) : \"\" );\n        // login now ...\n        ftpclient.login( realUsername, realPassword );\n\n        pwdFolder = ftpclient.pwd();\n      }\n\n      if ( checkfolder ) {\n        if ( pwdFolder != null ) {\n          ftpclient.chdir( pwdFolder );\n        }\n        // move to spool dir ...\n        if ( !Const.isEmpty( remoteFoldername ) ) {\n          String realFtpDirectory = jobMeta.environmentSubstitute( remoteFoldername );\n          ftpclient.chdir( realFtpDirectory );\n        }\n      }\n\n      retval = true;\n    } catch ( Exception e ) {\n      MessageBox mb = new MessageBox( shell, SWT.OK | SWT.ICON_ERROR );\n      mb.setMessage( BaseMessages.getString( PKG, \"JobFTPPUT.ErrorConnect.NOK\", e.getMessage() ) + Const.CR );\n      mb.setText( BaseMessages.getString( PKG, \"JobFTPPUT.ErrorConnect.Title.Bad\" ) );\n      mb.open();\n    }\n    return retval;\n  }","id":26393,"modified_method":"private boolean connectToFTP( boolean checkfolder, String remoteFoldername ) {\n    boolean retval = false;\n    try {\n      if ( ftpclient == null || !ftpclient.connected() ) {\n        // Create ftp client to host:port ...\n        ftpclient = new FTPClient();\n        String realServername = jobMeta.environmentSubstitute( wServerName.getText() );\n        int realPort = Const.toInt( jobMeta.environmentSubstitute( wServerPort.getText() ), 21 );\n        ftpclient.setRemoteAddr( InetAddress.getByName( realServername ) );\n        ftpclient.setRemotePort( realPort );\n\n        if ( !Const.isEmpty( wProxyHost.getText() ) ) {\n          String realProxy_host = jobMeta.environmentSubstitute( wProxyHost.getText() );\n          ftpclient.setRemoteAddr( InetAddress.getByName( realProxy_host ) );\n\n          int port = Const.toInt( jobMeta.environmentSubstitute( wProxyPort.getText() ), 21 );\n          if ( port != 0 ) {\n            ftpclient.setRemotePort( port );\n          }\n        }\n\n        // login to ftp host ...\n        ftpclient.connect();\n        String realUsername =\n          jobMeta.environmentSubstitute( wUserName.getText() )\n            + ( !Const.isEmpty( wProxyHost.getText() ) ? \"@\" + realServername : \"\" )\n            + ( !Const.isEmpty( wProxyUsername.getText() ) ? \" \"\n              + jobMeta.environmentSubstitute( wProxyUsername.getText() ) : \"\" );\n\n        String realPassword =\n          jobMeta.environmentSubstitute( wPassword.getText() )\n            + ( !Const.isEmpty( wProxyPassword.getText() ) ? \" \"\n              + jobMeta.environmentSubstitute( wProxyPassword.getText() ) : \"\" );\n        // login now ...\n        ftpclient.login( realUsername, realPassword );\n\n        pwdFolder = ftpclient.pwd();\n      }\n\n      if ( checkfolder ) {\n        if ( pwdFolder != null ) {\n          ftpclient.chdir( pwdFolder );\n        }\n        // move to spool dir ...\n        if ( !Const.isEmpty( remoteFoldername ) ) {\n          String realFtpDirectory = jobMeta.environmentSubstitute( remoteFoldername );\n          ftpclient.chdir( realFtpDirectory );\n        }\n      }\n\n      retval = true;\n    } catch ( Exception e ) {\n      MessageBox mb = new MessageBox( shell, SWT.OK | SWT.ICON_ERROR );\n      mb.setMessage( BaseMessages.getString( PKG, \"JobFTPPUT.ErrorConnect.NOK\", e.getMessage() ) + Const.CR );\n      mb.setText( BaseMessages.getString( PKG, \"JobFTPPUT.ErrorConnect.Title.Bad\" ) );\n      mb.open();\n    }\n    return retval;\n  }","commit_id":"36ef1a5cd33fb37488baaea0509bd1c79ded9214","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\n        if (event.getTargetId().equals(source.getControllerId()) && event.getSourceId().equals(target.getFirstTarget())) {\n            preventDamage(event, source, target.getFirstTarget(), game);\n            return true;\n        }\n        return false;\n    }","id":26394,"modified_method":"@Override\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\n        preventDamage(event, source, event.getSourceId(), game);\n        return true;\n    }","commit_id":"5932dc032357fcc85ff894772c61a6e953341bb9","url":"https://github.com/magefree/mage"},{"original_method":"public AuriokReplica(UUID ownerId) {\n        super(ownerId, 138, \"Auriok Replica\", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, \"{3}\");\n        this.expansionSetCode = \"SOM\";\n        this.subtype.add(\"Cleric\");\n        this.power = new MageInt(2);\n        this.toughness = new MageInt(2);\n\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AuriokReplicaEffect(), new ManaCostsImpl(\"{W}\"));\n        ability.addCost(new SacrificeSourceCost());\n        this.addAbility(ability);\n    }","id":26395,"modified_method":"public AuriokReplica(UUID ownerId) {\n        super(ownerId, 138, \"Auriok Replica\", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, \"{3}\");\n        this.expansionSetCode = \"SOM\";\n        this.subtype.add(\"Cleric\");\n        this.power = new MageInt(2);\n        this.toughness = new MageInt(2);\n\n        // {W}, Sacrifice Auriok Replica: Prevent all damage a source of your choice would deal to you this turn.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AuriokReplicaEffect(), new ManaCostsImpl(\"{W}\"));\n        ability.addTarget(new TargetSource());\n        ability.addCost(new SacrificeSourceCost());\n        this.addAbility(ability);\n    }","commit_id":"5932dc032357fcc85ff894772c61a6e953341bb9","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean applies(GameEvent event, Ability source, Game game) {\n        if (!this.used && super.applies(event, source, game)) {\n            if (event.getTargetId().equals(source.getControllerId()) && event.getSourceId().equals(target.getFirstTarget())) {\n                return true;\n            }\n        }\n        return false;\n    }","id":26396,"modified_method":"@Override\n    public boolean applies(GameEvent event, Ability source, Game game) {\n        if (super.applies(event, source, game)) {\n            if (event.getTargetId().equals(source.getControllerId()) && event.getSourceId().equals(this.getTargetPointer().getFirst(game, source))) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"5932dc032357fcc85ff894772c61a6e953341bb9","url":"https://github.com/magefree/mage"},{"original_method":"private void preventDamage(GameEvent event, Ability source, UUID target, Game game) {\n        GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, target, source.getId(), source.getControllerId(), event.getAmount(), false);\n        if (!game.replaceEvent(preventEvent)) {\n            int damage = event.getAmount();\n            event.setAmount(0);\n            game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, target, source.getId(), source.getControllerId(), damage));\n        }\n    }","id":26397,"modified_method":"private void preventDamage(GameEvent event, Ability source, UUID target, Game game) {\n        GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, target, source.getSourceId(), source.getControllerId(), event.getAmount(), false);\n        if (!game.replaceEvent(preventEvent)) {\n            int damage = event.getAmount();\n            event.setAmount(0);\n            game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, target, source.getSourceId(), source.getControllerId(), damage));\n        }\n    }","commit_id":"5932dc032357fcc85ff894772c61a6e953341bb9","url":"https://github.com/magefree/mage"},{"original_method":"public AuriokReplicaEffect(final AuriokReplicaEffect effect) {\n        super(effect);\n        this.target = effect.target.copy();\n    }","id":26398,"modified_method":"public AuriokReplicaEffect(final AuriokReplicaEffect effect) {\n        super(effect);\n    }","commit_id":"5932dc032357fcc85ff894772c61a6e953341bb9","url":"https://github.com/magefree/mage"},{"original_method":"public PayNoHeed(UUID ownerId) {\n        super(ownerId, 27, \"Pay No Heed\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{W}\");\n        this.expansionSetCode = \"M14\";\n\n        this.color.setWhite(true);\n\n        // Prevent all damage a source of your choice would deal this turn.\n        this.getSpellAbility().addEffect(new PayNoHeedEffect());\n        \n    }","id":26399,"modified_method":"public PayNoHeed(UUID ownerId) {\n        super(ownerId, 27, \"Pay No Heed\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{W}\");\n        this.expansionSetCode = \"M14\";\n\n        this.color.setWhite(true);\n\n        // Prevent all damage a source of your choice would deal this turn.\n        this.getSpellAbility().addEffect(new PayNoHeedEffect());\n        this.getSpellAbility().addTarget(new TargetSource());\n        \n    }","commit_id":"5932dc032357fcc85ff894772c61a6e953341bb9","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean applies(GameEvent event, Ability source, Game game) {\n        if (event instanceof DamageEvent && super.applies(event, source, game)) {\n            if (event.getSourceId().equals(target.getFirstTarget())) {\n                return true;\n            }\n        }\n        return false;\n    }","id":26400,"modified_method":"@Override\n    public boolean applies(GameEvent event, Ability source, Game game) {\n        if (super.applies(event, source, game)) {\n            if (event.getSourceId().equals(this.getTargetPointer().getFirst(game, source))) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"5932dc032357fcc85ff894772c61a6e953341bb9","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\n        if (event.getSourceId().equals(target.getFirstTarget())) {\n            preventDamage(event, source, target.getFirstTarget(), game);\n            return true;\n        }\n        return false;\n    }","id":26401,"modified_method":"@Override\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\n        preventDamage(event, source, event.getSourceId(), game);\n        return true;\n    }","commit_id":"5932dc032357fcc85ff894772c61a6e953341bb9","url":"https://github.com/magefree/mage"},{"original_method":"private void preventDamage(GameEvent event, Ability source, UUID target, Game game) {\n        GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, target, source.getId(), source.getControllerId(), event.getAmount(), false);\n        if (!game.replaceEvent(preventEvent)) {\n            int damage = event.getAmount();\n            event.setAmount(0);\n            game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, target, source.getId(), source.getControllerId(), damage));\n        }\n    }","id":26402,"modified_method":"private void preventDamage(GameEvent event, Ability source, UUID target, Game game) {\n        GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, target, source.getSourceId(), source.getControllerId(), event.getAmount(), false);\n        if (!game.replaceEvent(preventEvent)) {\n            int damage = event.getAmount();\n            event.setAmount(0);\n            game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, target, source.getSourceId(), source.getControllerId(), damage));\n        }\n    }","commit_id":"5932dc032357fcc85ff894772c61a6e953341bb9","url":"https://github.com/magefree/mage"},{"original_method":"public PayNoHeedEffect(final PayNoHeedEffect effect) {\n        super(effect);\n        this.target = effect.target.copy();\n    }","id":26403,"modified_method":"public PayNoHeedEffect(final PayNoHeedEffect effect) {\n        super(effect);\n    }","commit_id":"5932dc032357fcc85ff894772c61a6e953341bb9","url":"https://github.com/magefree/mage"},{"original_method":"public PayNoHeedEffect() {\n        super(Duration.EndOfTurn);\n        staticText = \"Prevent all damage a source of your choice would deal to you this turn\";\n    }","id":26404,"modified_method":"public PayNoHeedEffect() {\n        super(Duration.EndOfTurn);\n        staticText = \"Prevent all damage a source of your choice would deal this turn\";\n    }","commit_id":"5932dc032357fcc85ff894772c61a6e953341bb9","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean applies(GameEvent event, Ability source, Game game) {\n\t\tif (game.getTurn().getStepType() == PhaseStep.COMBAT_DAMAGE)\n\t\t\treturn super.applies(event, source, game);\n\t\treturn false;\n\t}","id":26405,"modified_method":"@Override\n\tpublic boolean applies(GameEvent event, Ability source, Game game) {\n        if (super.applies(event, source, game) && event instanceof DamageEvent) {\n            DamageEvent damageEvent = (DamageEvent) event;\n            return damageEvent.isCombatDamage();\n        }\n\t\treturn false;\n\t}","commit_id":"4936db8e455a43fb4d10dbe5467767904c7e672b","url":"https://github.com/magefree/mage"},{"original_method":"private String getManagementUri()\n    {\n        String managementUri = slashTerminatedUri( config.getString( configurationNamespace + MANAGEMENT_URI_KEY ) );\n        if ( managementUri != null )\n            return managementUri;\n        else\n            return hostPath(\"/db/manage/\");\n    }","id":26406,"modified_method":"private String getManagementUri()\n    {\n        String managementUri = slashTerminatedUri( config.getString( configurationNamespace + MANAGEMENT_URI_KEY ) );\n        if ( managementUri != null )\n            return managementUri;\n        else\n            return hostPath(Configurator.WEB_ADMIN_REST_API_PATH);\n    }","commit_id":"9603242007d4eaca95920f78b7087dff2bae14cf","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String getDataUri()\n    {\n        String dataUri = slashTerminatedUri( config.getString( configurationNamespace + DATA_URI_KEY ) );\n        if ( dataUri != null )\n            return dataUri;\n        else\n            return hostPath(\"/db/data/\");\n\n    }","id":26407,"modified_method":"private String getDataUri()\n    {\n        String dataUri = slashTerminatedUri( config.getString( configurationNamespace + DATA_URI_KEY ) );\n        if ( dataUri != null )\n            return dataUri;\n        else\n            return hostPath(Configurator.REST_API_PATH);\n\n    }","commit_id":"9603242007d4eaca95920f78b7087dff2bae14cf","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAcceptDuplicateKeysWithSameValue() throws IOException\n    {\n        File configFile = ServerTestUtils.createTempPropertyFile();\n\n        BufferedWriter writer = new BufferedWriter( new FileWriter( configFile ) );\n        writer.write( \"foo=bar\" );\n        writer.write( System.getProperty( \"line.separator\" ) );\n        writer.write( \"foo=bar\" );\n        writer.close();\n\n        Configurator configurator = new Configurator( configFile );\n        Configuration testConf = configurator.configuration();\n\n        assertNotNull( testConf );\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals( EXPECTED_VALUE, testConf.getString( \"foo\" ) );\n    }","id":26408,"modified_method":"@Test\n    public void shouldAcceptDuplicateKeysWithSameValue() throws IOException {\n        File configFile = PropertyFileBuilder.builder().withNameValue(\"foo\", \"bar\").withNameValue(\"foo\", \"bar\").build();\n\n        Configurator configurator = new Configurator(configFile);\n        Configuration testConf = configurator.configuration();\n\n        assertNotNull(testConf);\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals(EXPECTED_VALUE, testConf.getString(\"foo\"));\n    }","commit_id":"9603242007d4eaca95920f78b7087dff2bae14cf","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldProvideAConfiguration()\n    {\n        Configuration config = new Configurator( new Validator() ).configuration();\n        assertNotNull( config );\n    }","id":26409,"modified_method":"@Test\n    public void shouldProvideAConfiguration() throws IOException {\n        File configFile = PropertyFileBuilder.builder().build();\n        Configuration config = new Configurator(new Validator(), configFile).configuration();\n        assertNotNull(config);\n    }","commit_id":"9603242007d4eaca95920f78b7087dff2bae14cf","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldUseSpecifiedConfigFile() throws Exception\n    {\n        File configFile = ServerTestUtils.createTempPropertyFile();\n\n        FileWriter fstream = new FileWriter( configFile );\n        BufferedWriter out = new BufferedWriter( fstream );\n        out.write( \"foo=bar\" );\n        out.close();\n\n        Configuration testConf = new Configurator( new Validator(), configFile ).configuration();\n\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals( EXPECTED_VALUE, testConf.getString( \"foo\" ) );\n    }","id":26410,"modified_method":"@Test\n    public void shouldUseSpecifiedConfigFile() throws Exception {\n\n        File configFile = PropertyFileBuilder.builder().withNameValue(\"foo\", \"bar\").build();\n\n        Configuration testConf = new Configurator(new Validator(), configFile).configuration();\n\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals(EXPECTED_VALUE, testConf.getString(\"foo\"));\n    }","commit_id":"9603242007d4eaca95920f78b7087dff2bae14cf","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startWebServer() {\n\n        int webServerPort = getWebServerPort();\n        this.webServer = new Jetty6WebServer();\n        this.webServer.setNeoServer(this);\n\n        log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n        webServer.setPort(webServerPort);\n\n        log.info(\"Mounting webadmin at [%s]\", Configurator.WEB_ADMIN_PATH);\n        webServer.addStaticContent(Configurator.WEB_ADMIN_STATIC_WEB_CONTENT_LOCATION, Configurator.WEB_ADMIN_PATH);\n\n        log.info(\"Mounting management API at [%s]\", Configurator.WEB_ADMIN_REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.WEB_ADMIN_REST_API_PACKAGE }), Configurator.WEB_ADMIN_REST_API_PATH);\n\n        log.info(\"Mounting REST API at [%s]\", Configurator.REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.REST_API_PACKAGE }), Configurator.REST_API_PATH);\n\n        try {\n            webServer.start();\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%d], reason [%s]\", getWebServerPort(), e.getMessage());\n        }\n    }","id":26411,"modified_method":"private void startWebServer() {\n\n        int webServerPort = getWebServerPort();\n        this.webServer = new Jetty6WebServer();\n        this.webServer.setNeoServer(this);\n\n        log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n        webServer.setPort(webServerPort);\n\n        log.info(\"Mounting webadmin at [%s]\", Configurator.WEB_ADMIN_PATH);\n        webServer.addStaticContent(Configurator.WEB_ADMIN_STATIC_WEB_CONTENT_LOCATION, Configurator.WEB_ADMIN_PATH);\n\n        log.info(\"Mounting management API at [%s]\", Configurator.WEB_ADMIN_REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.WEB_ADMIN_REST_API_PACKAGE }), Configurator.WEB_ADMIN_REST_API_PATH);\n\n        log.info(\"Mounting REST API at [%s]\", Configurator.REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.REST_API_PACKAGE }), Configurator.REST_API_PATH);\n        \n        for(ThirdPartyJaxRsPackage tpp : configurator.getThirdpartyJaxRsClasses()) {\n            log.info(\"Mounting third-party JAX-RS package [%s] at [%s]\", tpp.getPackageName(), tpp.getMountPoint());\n            webServer.addJAXRSPackages(listFrom(new String[] { tpp.getPackageName() }), tpp.getMountPoint());\n        }\n\n        try {\n            webServer.start();\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%d], reason [%s]\", getWebServerPort(), e.getMessage());\n        }\n    }","commit_id":"9603242007d4eaca95920f78b7087dff2bae14cf","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String baseUri() throws UnknownHostException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"http\");\n        int webServerPort = getWebServerPort();\n        if (webServerPort == 443) {\n            sb.append(\"s\");\n\n        }\n        sb.append(\"://\");\n        sb.append(addressResolver.getHostname());\n\n        if (webServerPort != 80) {\n            sb.append(\":\");\n            sb.append(webServerPort);\n        }\n        sb.append(\"/\");\n\n        return sb.toString();\n    }","id":26412,"modified_method":"public URI baseUri() throws UnknownHostException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"http\");\n        int webServerPort = getWebServerPort();\n        if (webServerPort == 443) {\n            sb.append(\"s\");\n\n        }\n        sb.append(\"://\");\n        sb.append(addressResolver.getHostname());\n\n        if (webServerPort != 80) {\n            sb.append(\":\");\n            sb.append(webServerPort);\n        }\n        sb.append(\"/\");\n\n        try {\n            return new URI(sb.toString());\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"9603242007d4eaca95920f78b7087dff2bae14cf","url":"https://github.com/neo4j/neo4j"},{"original_method":"private URI generateUriFor(String serviceName) {\n        if (serviceName.startsWith(\"/\")) {\n            serviceName = serviceName.substring(1);\n        }\n        StringBuilder sb = new StringBuilder();\n        try {\n            sb.append(baseUri());\n            sb.append(serviceName);\n            sb.append(\"/\");\n\n            return new URI(sb.toString());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","id":26413,"modified_method":"private URI generateUriFor(String serviceName) {\n        if (serviceName.startsWith(\"/\")) {\n            serviceName = serviceName.substring(1);\n        }\n        StringBuilder sb = new StringBuilder();\n        try {\n            sb.append(baseUri().toString());\n            sb.append(serviceName);\n            sb.append(\"/\");\n\n            return new URI(sb.toString());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"9603242007d4eaca95920f78b7087dff2bae14cf","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        assertThat(appender.toString(), containsString(\"Starting Neo Server on port [\" + server.restApiUri().getPort() + \"]\"));\n    }","id":26414,"modified_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        InMemoryAppender appender = new InMemoryAppender(NeoServer.log);\n        NeoServer server = ServerBuilder.server().withPassingStartupHealthcheck().withRandomDatabaseDir().build();\n        server.start();\n        assertThat(appender.toString(), containsString(\"Starting Neo Server on port [\" + server.restApiUri().getPort() + \"]\"));\n        server.stop();\n    }","commit_id":"9603242007d4eaca95920f78b7087dff2bae14cf","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void whenServerIsStartedItshouldStartASingleDatabase() throws Exception {\n        assertNotNull(server.getDatabase());\n    }","id":26415,"modified_method":"@Test\n    public void whenServerIsStartedItshouldStartASingleDatabase() throws Exception {\n        NeoServer server = ServerBuilder.server().withPassingStartupHealthcheck().withRandomDatabaseDir().build();\n        server.start();\n        assertNotNull(server.getDatabase());\n        server.stop();\n    }","commit_id":"9603242007d4eaca95920f78b7087dff2bae14cf","url":"https://github.com/neo4j/neo4j"},{"original_method":"public File build() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n        if(dbTuningPropertyRule != null) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, dbTuningPropertyRule, temporaryConfigFile);\n        }\n        \n        \n        return temporaryConfigFile;\n    }","id":26416,"modified_method":"public File build() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n        if(dbTuningPropertyRule != null) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, dbTuningPropertyRule, temporaryConfigFile);\n        }\n        \n        for(Tuple t: nameValuePairs) {\n            writePropertyToFile(t.name, t.value, temporaryConfigFile);\n        }\n        \n        \n        return temporaryConfigFile;\n    }","commit_id":"9603242007d4eaca95920f78b7087dff2bae14cf","url":"https://github.com/neo4j/neo4j"},{"original_method":"private File createPropertyFile() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n        \n        if(action == WhatToDo.CREATE_GOOD_TUNING_FILE) {\n            File databaseTuningPropertyFile = createTempPropertyFile();\n            writePropertyToFile(\"neostore.nodestore.db.mapped_memory\", \"25M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.relationshipstore.db.mapped_memory\", \"50M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.mapped_memory\", \"90M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.strings.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.arrays.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, databaseTuningPropertyFile.getAbsolutePath(), temporaryConfigFile);\n        } else if(action == WhatToDo.CREATE_DANGLING_TUNING_FILE_PROPERTY) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, createTempPropertyFile().getAbsolutePath(), temporaryConfigFile);\n        } else if(action == WhatToDo.CREATE_CORRUPT_TUNING_FILE) {\n            File corruptTuningFile = trashFile();\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, corruptTuningFile.getAbsolutePath(), temporaryConfigFile);\n        }\n        \n        return temporaryConfigFile;\n    }","id":26417,"modified_method":"private File createPropertyFile() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n\n        if (action == WhatToDo.CREATE_GOOD_TUNING_FILE) {\n            File databaseTuningPropertyFile = createTempPropertyFile();\n            writePropertyToFile(\"neostore.nodestore.db.mapped_memory\", \"25M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.relationshipstore.db.mapped_memory\", \"50M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.mapped_memory\", \"90M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.strings.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.arrays.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, databaseTuningPropertyFile.getAbsolutePath(), temporaryConfigFile);\n        } else if (action == WhatToDo.CREATE_DANGLING_TUNING_FILE_PROPERTY) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, createTempPropertyFile().getAbsolutePath(), temporaryConfigFile);\n        } else if (action == WhatToDo.CREATE_CORRUPT_TUNING_FILE) {\n            File corruptTuningFile = trashFile();\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, corruptTuningFile.getAbsolutePath(), temporaryConfigFile);\n        }\n\n        if (thirdPartyPackages.keySet().size() > 0) {\n            writePropertiesToFile(Configurator.THIRD_PARTY_PACKAGES_KEY, thirdPartyPackages, temporaryConfigFile);\n        }\n        \n        return temporaryConfigFile;\n    }","commit_id":"9603242007d4eaca95920f78b7087dff2bae14cf","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String getManagementUri()\n    {\n        String managementUri = slashTerminatedUri( config.getString( configurationNamespace + MANAGEMENT_URI_KEY ) );\n        if ( managementUri != null )\n            return managementUri;\n        else\n            return hostPath(\"/db/manage/\");\n    }","id":26418,"modified_method":"private String getManagementUri()\n    {\n        String managementUri = slashTerminatedUri( config.getString( configurationNamespace + MANAGEMENT_URI_KEY ) );\n        if ( managementUri != null )\n            return managementUri;\n        else\n            return hostPath(Configurator.WEB_ADMIN_REST_API_PATH);\n    }","commit_id":"3ff0a355d69364598a2c0c4eb42c8572442159d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String getDataUri()\n    {\n        String dataUri = slashTerminatedUri( config.getString( configurationNamespace + DATA_URI_KEY ) );\n        if ( dataUri != null )\n            return dataUri;\n        else\n            return hostPath(\"/db/data/\");\n\n    }","id":26419,"modified_method":"private String getDataUri()\n    {\n        String dataUri = slashTerminatedUri( config.getString( configurationNamespace + DATA_URI_KEY ) );\n        if ( dataUri != null )\n            return dataUri;\n        else\n            return hostPath(Configurator.REST_API_PATH);\n\n    }","commit_id":"3ff0a355d69364598a2c0c4eb42c8572442159d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldUseSpecifiedConfigFile() throws Exception\n    {\n        File configFile = ServerTestUtils.createTempPropertyFile();\n\n        FileWriter fstream = new FileWriter( configFile );\n        BufferedWriter out = new BufferedWriter( fstream );\n        out.write( \"foo=bar\" );\n        out.close();\n\n        Configuration testConf = new Configurator( new Validator(), configFile ).configuration();\n\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals( EXPECTED_VALUE, testConf.getString( \"foo\" ) );\n    }","id":26420,"modified_method":"@Test\n    public void shouldUseSpecifiedConfigFile() throws Exception {\n\n        File configFile = PropertyFileBuilder.builder().withNameValue(\"foo\", \"bar\").build();\n\n        Configuration testConf = new Configurator(new Validator(), configFile).configuration();\n\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals(EXPECTED_VALUE, testConf.getString(\"foo\"));\n    }","commit_id":"3ff0a355d69364598a2c0c4eb42c8572442159d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAcceptDuplicateKeysWithSameValue() throws IOException\n    {\n        File configFile = ServerTestUtils.createTempPropertyFile();\n\n        BufferedWriter writer = new BufferedWriter( new FileWriter( configFile ) );\n        writer.write( \"foo=bar\" );\n        writer.write( System.getProperty( \"line.separator\" ) );\n        writer.write( \"foo=bar\" );\n        writer.close();\n\n        Configurator configurator = new Configurator( configFile );\n        Configuration testConf = configurator.configuration();\n\n        assertNotNull( testConf );\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals( EXPECTED_VALUE, testConf.getString( \"foo\" ) );\n    }","id":26421,"modified_method":"@Test\n    public void shouldAcceptDuplicateKeysWithSameValue() throws IOException {\n        File configFile = PropertyFileBuilder.builder().withNameValue(\"foo\", \"bar\").withNameValue(\"foo\", \"bar\").build();\n\n        Configurator configurator = new Configurator(configFile);\n        Configuration testConf = configurator.configuration();\n\n        assertNotNull(testConf);\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals(EXPECTED_VALUE, testConf.getString(\"foo\"));\n    }","commit_id":"3ff0a355d69364598a2c0c4eb42c8572442159d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldProvideAConfiguration()\n    {\n        Configuration config = new Configurator( new Validator() ).configuration();\n        assertNotNull( config );\n    }","id":26422,"modified_method":"@Test\n    public void shouldProvideAConfiguration() throws IOException {\n        File configFile = PropertyFileBuilder.builder().build();\n        Configuration config = new Configurator(new Validator(), configFile).configuration();\n        assertNotNull(config);\n    }","commit_id":"3ff0a355d69364598a2c0c4eb42c8572442159d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private URI generateUriFor(String serviceName) {\n        if (serviceName.startsWith(\"/\")) {\n            serviceName = serviceName.substring(1);\n        }\n        StringBuilder sb = new StringBuilder();\n        try {\n            sb.append(baseUri());\n            sb.append(serviceName);\n            sb.append(\"/\");\n\n            return new URI(sb.toString());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","id":26423,"modified_method":"private URI generateUriFor(String serviceName) {\n        if (serviceName.startsWith(\"/\")) {\n            serviceName = serviceName.substring(1);\n        }\n        StringBuilder sb = new StringBuilder();\n        try {\n            sb.append(baseUri().toString());\n            sb.append(serviceName);\n            sb.append(\"/\");\n\n            return new URI(sb.toString());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"3ff0a355d69364598a2c0c4eb42c8572442159d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String baseUri() throws UnknownHostException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"http\");\n        int webServerPort = getWebServerPort();\n        if (webServerPort == 443) {\n            sb.append(\"s\");\n\n        }\n        sb.append(\"://\");\n        sb.append(addressResolver.getHostname());\n\n        if (webServerPort != 80) {\n            sb.append(\":\");\n            sb.append(webServerPort);\n        }\n        sb.append(\"/\");\n\n        return sb.toString();\n    }","id":26424,"modified_method":"public URI baseUri() throws UnknownHostException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"http\");\n        int webServerPort = getWebServerPort();\n        if (webServerPort == 443) {\n            sb.append(\"s\");\n\n        }\n        sb.append(\"://\");\n        sb.append(addressResolver.getHostname());\n\n        if (webServerPort != 80) {\n            sb.append(\":\");\n            sb.append(webServerPort);\n        }\n        sb.append(\"/\");\n\n        try {\n            return new URI(sb.toString());\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"3ff0a355d69364598a2c0c4eb42c8572442159d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startWebServer() {\n\n        int webServerPort = getWebServerPort();\n        this.webServer = new Jetty6WebServer();\n        this.webServer.setNeoServer(this);\n\n        log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n        webServer.setPort(webServerPort);\n\n        log.info(\"Mounting webadmin at [%s]\", Configurator.WEB_ADMIN_PATH);\n        webServer.addStaticContent(Configurator.WEB_ADMIN_STATIC_WEB_CONTENT_LOCATION, Configurator.WEB_ADMIN_PATH);\n\n        log.info(\"Mounting management API at [%s]\", Configurator.WEB_ADMIN_REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.WEB_ADMIN_REST_API_PACKAGE }), Configurator.WEB_ADMIN_REST_API_PATH);\n\n        log.info(\"Mounting REST API at [%s]\", Configurator.REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.REST_API_PACKAGE }), Configurator.REST_API_PATH);\n\n        try {\n            webServer.start();\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%d], reason [%s]\", getWebServerPort(), e.getMessage());\n        }\n    }","id":26425,"modified_method":"private void startWebServer() {\n\n        int webServerPort = getWebServerPort();\n        this.webServer = new Jetty6WebServer();\n        this.webServer.setNeoServer(this);\n\n        log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n        webServer.setPort(webServerPort);\n\n        log.info(\"Mounting webadmin at [%s]\", Configurator.WEB_ADMIN_PATH);\n        webServer.addStaticContent(Configurator.WEB_ADMIN_STATIC_WEB_CONTENT_LOCATION, Configurator.WEB_ADMIN_PATH);\n\n        log.info(\"Mounting management API at [%s]\", Configurator.WEB_ADMIN_REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.WEB_ADMIN_REST_API_PACKAGE }), Configurator.WEB_ADMIN_REST_API_PATH);\n\n        log.info(\"Mounting REST API at [%s]\", Configurator.REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.REST_API_PACKAGE }), Configurator.REST_API_PATH);\n        \n        for(ThirdPartyJaxRsPackage tpp : configurator.getThirdpartyJaxRsClasses()) {\n            log.info(\"Mounting third-party JAX-RS package [%s] at [%s]\", tpp.getPackageName(), tpp.getMountPoint());\n            webServer.addJAXRSPackages(listFrom(new String[] { tpp.getPackageName() }), tpp.getMountPoint());\n        }\n\n        try {\n            webServer.start();\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%d], reason [%s]\", getWebServerPort(), e.getMessage());\n        }\n    }","commit_id":"3ff0a355d69364598a2c0c4eb42c8572442159d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        assertThat(appender.toString(), containsString(\"Starting Neo Server on port [\" + server.restApiUri().getPort() + \"]\"));\n    }","id":26426,"modified_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        InMemoryAppender appender = new InMemoryAppender(NeoServer.log);\n        NeoServer server = ServerBuilder.server().withPassingStartupHealthcheck().withRandomDatabaseDir().build();\n        server.start();\n        assertThat(appender.toString(), containsString(\"Starting Neo Server on port [\" + server.restApiUri().getPort() + \"]\"));\n        server.stop();\n    }","commit_id":"3ff0a355d69364598a2c0c4eb42c8572442159d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void whenServerIsStartedItshouldStartASingleDatabase() throws Exception {\n        assertNotNull(server.getDatabase());\n    }","id":26427,"modified_method":"@Test\n    public void whenServerIsStartedItshouldStartASingleDatabase() throws Exception {\n        NeoServer server = ServerBuilder.server().withPassingStartupHealthcheck().withRandomDatabaseDir().build();\n        server.start();\n        assertNotNull(server.getDatabase());\n        server.stop();\n    }","commit_id":"3ff0a355d69364598a2c0c4eb42c8572442159d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public File build() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n        if(dbTuningPropertyRule != null) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, dbTuningPropertyRule, temporaryConfigFile);\n        }\n        \n        \n        return temporaryConfigFile;\n    }","id":26428,"modified_method":"public File build() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n        if(dbTuningPropertyRule != null) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, dbTuningPropertyRule, temporaryConfigFile);\n        }\n        \n        for(Tuple t: nameValuePairs) {\n            writePropertyToFile(t.name, t.value, temporaryConfigFile);\n        }\n        \n        \n        return temporaryConfigFile;\n    }","commit_id":"3ff0a355d69364598a2c0c4eb42c8572442159d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private File createPropertyFile() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n        \n        if(action == WhatToDo.CREATE_GOOD_TUNING_FILE) {\n            File databaseTuningPropertyFile = createTempPropertyFile();\n            writePropertyToFile(\"neostore.nodestore.db.mapped_memory\", \"25M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.relationshipstore.db.mapped_memory\", \"50M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.mapped_memory\", \"90M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.strings.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.arrays.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, databaseTuningPropertyFile.getAbsolutePath(), temporaryConfigFile);\n        } else if(action == WhatToDo.CREATE_DANGLING_TUNING_FILE_PROPERTY) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, createTempPropertyFile().getAbsolutePath(), temporaryConfigFile);\n        } else if(action == WhatToDo.CREATE_CORRUPT_TUNING_FILE) {\n            File corruptTuningFile = trashFile();\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, corruptTuningFile.getAbsolutePath(), temporaryConfigFile);\n        }\n        \n        return temporaryConfigFile;\n    }","id":26429,"modified_method":"private File createPropertyFile() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n\n        if (action == WhatToDo.CREATE_GOOD_TUNING_FILE) {\n            File databaseTuningPropertyFile = createTempPropertyFile();\n            writePropertyToFile(\"neostore.nodestore.db.mapped_memory\", \"25M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.relationshipstore.db.mapped_memory\", \"50M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.mapped_memory\", \"90M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.strings.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.arrays.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, databaseTuningPropertyFile.getAbsolutePath(), temporaryConfigFile);\n        } else if (action == WhatToDo.CREATE_DANGLING_TUNING_FILE_PROPERTY) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, createTempPropertyFile().getAbsolutePath(), temporaryConfigFile);\n        } else if (action == WhatToDo.CREATE_CORRUPT_TUNING_FILE) {\n            File corruptTuningFile = trashFile();\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, corruptTuningFile.getAbsolutePath(), temporaryConfigFile);\n        }\n\n        if (thirdPartyPackages.keySet().size() > 0) {\n            writePropertiesToFile(Configurator.THIRD_PARTY_PACKAGES_KEY, thirdPartyPackages, temporaryConfigFile);\n        }\n        \n        return temporaryConfigFile;\n    }","commit_id":"3ff0a355d69364598a2c0c4eb42c8572442159d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String getManagementUri()\n    {\n        String managementUri = slashTerminatedUri( config.getString( configurationNamespace + MANAGEMENT_URI_KEY ) );\n        if ( managementUri != null )\n            return managementUri;\n        else\n            return hostPath(\"/db/manage/\");\n    }","id":26430,"modified_method":"private String getManagementUri()\n    {\n        String managementUri = slashTerminatedUri( config.getString( configurationNamespace + MANAGEMENT_URI_KEY ) );\n        if ( managementUri != null )\n            return managementUri;\n        else\n            return hostPath(Configurator.WEB_ADMIN_REST_API_PATH);\n    }","commit_id":"c02240fe7b1f9e04e06d798045fc0ed880348e9c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String getDataUri()\n    {\n        String dataUri = slashTerminatedUri( config.getString( configurationNamespace + DATA_URI_KEY ) );\n        if ( dataUri != null )\n            return dataUri;\n        else\n            return hostPath(\"/db/data/\");\n\n    }","id":26431,"modified_method":"private String getDataUri()\n    {\n        String dataUri = slashTerminatedUri( config.getString( configurationNamespace + DATA_URI_KEY ) );\n        if ( dataUri != null )\n            return dataUri;\n        else\n            return hostPath(Configurator.REST_API_PATH);\n\n    }","commit_id":"c02240fe7b1f9e04e06d798045fc0ed880348e9c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldUseSpecifiedConfigFile() throws Exception\n    {\n        File configFile = ServerTestUtils.createTempPropertyFile();\n\n        FileWriter fstream = new FileWriter( configFile );\n        BufferedWriter out = new BufferedWriter( fstream );\n        out.write( \"foo=bar\" );\n        out.close();\n\n        Configuration testConf = new Configurator( new Validator(), configFile ).configuration();\n\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals( EXPECTED_VALUE, testConf.getString( \"foo\" ) );\n    }","id":26432,"modified_method":"@Test\n    public void shouldUseSpecifiedConfigFile() throws Exception {\n\n        File configFile = PropertyFileBuilder.builder().withNameValue(\"foo\", \"bar\").build();\n\n        Configuration testConf = new Configurator(new Validator(), configFile).configuration();\n\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals(EXPECTED_VALUE, testConf.getString(\"foo\"));\n    }","commit_id":"c02240fe7b1f9e04e06d798045fc0ed880348e9c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldProvideAConfiguration()\n    {\n        Configuration config = new Configurator( new Validator() ).configuration();\n        assertNotNull( config );\n    }","id":26433,"modified_method":"@Test\n    public void shouldProvideAConfiguration() throws IOException {\n        File configFile = PropertyFileBuilder.builder().build();\n        Configuration config = new Configurator(new Validator(), configFile).configuration();\n        assertNotNull(config);\n    }","commit_id":"c02240fe7b1f9e04e06d798045fc0ed880348e9c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAcceptDuplicateKeysWithSameValue() throws IOException\n    {\n        File configFile = ServerTestUtils.createTempPropertyFile();\n\n        BufferedWriter writer = new BufferedWriter( new FileWriter( configFile ) );\n        writer.write( \"foo=bar\" );\n        writer.write( System.getProperty( \"line.separator\" ) );\n        writer.write( \"foo=bar\" );\n        writer.close();\n\n        Configurator configurator = new Configurator( configFile );\n        Configuration testConf = configurator.configuration();\n\n        assertNotNull( testConf );\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals( EXPECTED_VALUE, testConf.getString( \"foo\" ) );\n    }","id":26434,"modified_method":"@Test\n    public void shouldAcceptDuplicateKeysWithSameValue() throws IOException {\n        File configFile = PropertyFileBuilder.builder().withNameValue(\"foo\", \"bar\").withNameValue(\"foo\", \"bar\").build();\n\n        Configurator configurator = new Configurator(configFile);\n        Configuration testConf = configurator.configuration();\n\n        assertNotNull(testConf);\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals(EXPECTED_VALUE, testConf.getString(\"foo\"));\n    }","commit_id":"c02240fe7b1f9e04e06d798045fc0ed880348e9c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String baseUri() throws UnknownHostException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"http\");\n        int webServerPort = getWebServerPort();\n        if (webServerPort == 443) {\n            sb.append(\"s\");\n\n        }\n        sb.append(\"://\");\n        sb.append(addressResolver.getHostname());\n\n        if (webServerPort != 80) {\n            sb.append(\":\");\n            sb.append(webServerPort);\n        }\n        sb.append(\"/\");\n\n        return sb.toString();\n    }","id":26435,"modified_method":"public URI baseUri() throws UnknownHostException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"http\");\n        int webServerPort = getWebServerPort();\n        if (webServerPort == 443) {\n            sb.append(\"s\");\n\n        }\n        sb.append(\"://\");\n        sb.append(addressResolver.getHostname());\n\n        if (webServerPort != 80) {\n            sb.append(\":\");\n            sb.append(webServerPort);\n        }\n        sb.append(\"/\");\n\n        try {\n            return new URI(sb.toString());\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"c02240fe7b1f9e04e06d798045fc0ed880348e9c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private URI generateUriFor(String serviceName) {\n        if (serviceName.startsWith(\"/\")) {\n            serviceName = serviceName.substring(1);\n        }\n        StringBuilder sb = new StringBuilder();\n        try {\n            sb.append(baseUri());\n            sb.append(serviceName);\n            sb.append(\"/\");\n\n            return new URI(sb.toString());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","id":26436,"modified_method":"private URI generateUriFor(String serviceName) {\n        if (serviceName.startsWith(\"/\")) {\n            serviceName = serviceName.substring(1);\n        }\n        StringBuilder sb = new StringBuilder();\n        try {\n            sb.append(baseUri().toString());\n            sb.append(serviceName);\n            sb.append(\"/\");\n\n            return new URI(sb.toString());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"c02240fe7b1f9e04e06d798045fc0ed880348e9c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startWebServer() {\n\n        int webServerPort = getWebServerPort();\n        this.webServer = new Jetty6WebServer();\n        this.webServer.setNeoServer(this);\n\n        log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n        webServer.setPort(webServerPort);\n\n        log.info(\"Mounting webadmin at [%s]\", Configurator.WEB_ADMIN_PATH);\n        webServer.addStaticContent(Configurator.WEB_ADMIN_STATIC_WEB_CONTENT_LOCATION, Configurator.WEB_ADMIN_PATH);\n\n        log.info(\"Mounting management API at [%s]\", Configurator.WEB_ADMIN_REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.WEB_ADMIN_REST_API_PACKAGE }), Configurator.WEB_ADMIN_REST_API_PATH);\n\n        log.info(\"Mounting REST API at [%s]\", Configurator.REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.REST_API_PACKAGE }), Configurator.REST_API_PATH);\n\n        try {\n            webServer.start();\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%d], reason [%s]\", getWebServerPort(), e.getMessage());\n        }\n    }","id":26437,"modified_method":"private void startWebServer() {\n\n        int webServerPort = getWebServerPort();\n        this.webServer = new Jetty6WebServer();\n        this.webServer.setNeoServer(this);\n\n        log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n        webServer.setPort(webServerPort);\n\n        log.info(\"Mounting webadmin at [%s]\", Configurator.WEB_ADMIN_PATH);\n        webServer.addStaticContent(Configurator.WEB_ADMIN_STATIC_WEB_CONTENT_LOCATION, Configurator.WEB_ADMIN_PATH);\n\n        log.info(\"Mounting management API at [%s]\", Configurator.WEB_ADMIN_REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.WEB_ADMIN_REST_API_PACKAGE }), Configurator.WEB_ADMIN_REST_API_PATH);\n\n        log.info(\"Mounting REST API at [%s]\", Configurator.REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.REST_API_PACKAGE }), Configurator.REST_API_PATH);\n        \n        for(ThirdPartyJaxRsPackage tpp : configurator.getThirdpartyJaxRsClasses()) {\n            log.info(\"Mounting third-party JAX-RS package [%s] at [%s]\", tpp.getPackageName(), tpp.getMountPoint());\n            webServer.addJAXRSPackages(listFrom(new String[] { tpp.getPackageName() }), tpp.getMountPoint());\n        }\n\n        try {\n            webServer.start();\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%d], reason [%s]\", getWebServerPort(), e.getMessage());\n        }\n    }","commit_id":"c02240fe7b1f9e04e06d798045fc0ed880348e9c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void whenServerIsStartedItshouldStartASingleDatabase() throws Exception {\n        assertNotNull(server.getDatabase());\n    }","id":26438,"modified_method":"@Test\n    public void whenServerIsStartedItshouldStartASingleDatabase() throws Exception {\n        NeoServer server = ServerBuilder.server().withPassingStartupHealthcheck().withRandomDatabaseDir().build();\n        server.start();\n        assertNotNull(server.getDatabase());\n        server.stop();\n    }","commit_id":"c02240fe7b1f9e04e06d798045fc0ed880348e9c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        assertThat(appender.toString(), containsString(\"Starting Neo Server on port [\" + server.restApiUri().getPort() + \"]\"));\n    }","id":26439,"modified_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        InMemoryAppender appender = new InMemoryAppender(NeoServer.log);\n        NeoServer server = ServerBuilder.server().withPassingStartupHealthcheck().withRandomDatabaseDir().build();\n        server.start();\n        assertThat(appender.toString(), containsString(\"Starting Neo Server on port [\" + server.restApiUri().getPort() + \"]\"));\n        server.stop();\n    }","commit_id":"c02240fe7b1f9e04e06d798045fc0ed880348e9c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public File build() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n        if(dbTuningPropertyRule != null) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, dbTuningPropertyRule, temporaryConfigFile);\n        }\n        \n        \n        return temporaryConfigFile;\n    }","id":26440,"modified_method":"public File build() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n        if(dbTuningPropertyRule != null) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, dbTuningPropertyRule, temporaryConfigFile);\n        }\n        \n        for(Tuple t: nameValuePairs) {\n            writePropertyToFile(t.name, t.value, temporaryConfigFile);\n        }\n        \n        \n        return temporaryConfigFile;\n    }","commit_id":"c02240fe7b1f9e04e06d798045fc0ed880348e9c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private File createPropertyFile() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n        \n        if(action == WhatToDo.CREATE_GOOD_TUNING_FILE) {\n            File databaseTuningPropertyFile = createTempPropertyFile();\n            writePropertyToFile(\"neostore.nodestore.db.mapped_memory\", \"25M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.relationshipstore.db.mapped_memory\", \"50M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.mapped_memory\", \"90M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.strings.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.arrays.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, databaseTuningPropertyFile.getAbsolutePath(), temporaryConfigFile);\n        } else if(action == WhatToDo.CREATE_DANGLING_TUNING_FILE_PROPERTY) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, createTempPropertyFile().getAbsolutePath(), temporaryConfigFile);\n        } else if(action == WhatToDo.CREATE_CORRUPT_TUNING_FILE) {\n            File corruptTuningFile = trashFile();\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, corruptTuningFile.getAbsolutePath(), temporaryConfigFile);\n        }\n        \n        return temporaryConfigFile;\n    }","id":26441,"modified_method":"private File createPropertyFile() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n\n        if (action == WhatToDo.CREATE_GOOD_TUNING_FILE) {\n            File databaseTuningPropertyFile = createTempPropertyFile();\n            writePropertyToFile(\"neostore.nodestore.db.mapped_memory\", \"25M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.relationshipstore.db.mapped_memory\", \"50M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.mapped_memory\", \"90M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.strings.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.arrays.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, databaseTuningPropertyFile.getAbsolutePath(), temporaryConfigFile);\n        } else if (action == WhatToDo.CREATE_DANGLING_TUNING_FILE_PROPERTY) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, createTempPropertyFile().getAbsolutePath(), temporaryConfigFile);\n        } else if (action == WhatToDo.CREATE_CORRUPT_TUNING_FILE) {\n            File corruptTuningFile = trashFile();\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, corruptTuningFile.getAbsolutePath(), temporaryConfigFile);\n        }\n\n        if (thirdPartyPackages.keySet().size() > 0) {\n            writePropertiesToFile(Configurator.THIRD_PARTY_PACKAGES_KEY, thirdPartyPackages, temporaryConfigFile);\n        }\n        \n        return temporaryConfigFile;\n    }","commit_id":"c02240fe7b1f9e04e06d798045fc0ed880348e9c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String getDataUri()\n    {\n        String dataUri = slashTerminatedUri( config.getString( configurationNamespace + DATA_URI_KEY ) );\n        if ( dataUri != null )\n            return dataUri;\n        else\n            return hostPath(\"/db/data/\");\n\n    }","id":26442,"modified_method":"private String getDataUri()\n    {\n        String dataUri = slashTerminatedUri( config.getString( configurationNamespace + DATA_URI_KEY ) );\n        if ( dataUri != null )\n            return dataUri;\n        else\n            return hostPath(Configurator.REST_API_PATH);\n\n    }","commit_id":"3dda55b4514837a0e96092da216c626cb6234dc8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String getManagementUri()\n    {\n        String managementUri = slashTerminatedUri( config.getString( configurationNamespace + MANAGEMENT_URI_KEY ) );\n        if ( managementUri != null )\n            return managementUri;\n        else\n            return hostPath(\"/db/manage/\");\n    }","id":26443,"modified_method":"private String getManagementUri()\n    {\n        String managementUri = slashTerminatedUri( config.getString( configurationNamespace + MANAGEMENT_URI_KEY ) );\n        if ( managementUri != null )\n            return managementUri;\n        else\n            return hostPath(Configurator.WEB_ADMIN_REST_API_PATH);\n    }","commit_id":"3dda55b4514837a0e96092da216c626cb6234dc8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldProvideAConfiguration()\n    {\n        Configuration config = new Configurator( new Validator() ).configuration();\n        assertNotNull( config );\n    }","id":26444,"modified_method":"@Test\n    public void shouldProvideAConfiguration() throws IOException {\n        File configFile = PropertyFileBuilder.builder().build();\n        Configuration config = new Configurator(new Validator(), configFile).configuration();\n        assertNotNull(config);\n    }","commit_id":"3dda55b4514837a0e96092da216c626cb6234dc8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldUseSpecifiedConfigFile() throws Exception\n    {\n        File configFile = ServerTestUtils.createTempPropertyFile();\n\n        FileWriter fstream = new FileWriter( configFile );\n        BufferedWriter out = new BufferedWriter( fstream );\n        out.write( \"foo=bar\" );\n        out.close();\n\n        Configuration testConf = new Configurator( new Validator(), configFile ).configuration();\n\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals( EXPECTED_VALUE, testConf.getString( \"foo\" ) );\n    }","id":26445,"modified_method":"@Test\n    public void shouldUseSpecifiedConfigFile() throws Exception {\n\n        File configFile = PropertyFileBuilder.builder().withNameValue(\"foo\", \"bar\").build();\n\n        Configuration testConf = new Configurator(new Validator(), configFile).configuration();\n\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals(EXPECTED_VALUE, testConf.getString(\"foo\"));\n    }","commit_id":"3dda55b4514837a0e96092da216c626cb6234dc8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAcceptDuplicateKeysWithSameValue() throws IOException\n    {\n        File configFile = ServerTestUtils.createTempPropertyFile();\n\n        BufferedWriter writer = new BufferedWriter( new FileWriter( configFile ) );\n        writer.write( \"foo=bar\" );\n        writer.write( System.getProperty( \"line.separator\" ) );\n        writer.write( \"foo=bar\" );\n        writer.close();\n\n        Configurator configurator = new Configurator( configFile );\n        Configuration testConf = configurator.configuration();\n\n        assertNotNull( testConf );\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals( EXPECTED_VALUE, testConf.getString( \"foo\" ) );\n    }","id":26446,"modified_method":"@Test\n    public void shouldAcceptDuplicateKeysWithSameValue() throws IOException {\n        File configFile = PropertyFileBuilder.builder().withNameValue(\"foo\", \"bar\").withNameValue(\"foo\", \"bar\").build();\n\n        Configurator configurator = new Configurator(configFile);\n        Configuration testConf = configurator.configuration();\n\n        assertNotNull(testConf);\n        final String EXPECTED_VALUE = \"bar\";\n        assertEquals(EXPECTED_VALUE, testConf.getString(\"foo\"));\n    }","commit_id":"3dda55b4514837a0e96092da216c626cb6234dc8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startWebServer() {\n\n        int webServerPort = getWebServerPort();\n        this.webServer = new Jetty6WebServer();\n        this.webServer.setNeoServer(this);\n\n        log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n        webServer.setPort(webServerPort);\n\n        log.info(\"Mounting webadmin at [%s]\", Configurator.WEB_ADMIN_PATH);\n        webServer.addStaticContent(Configurator.WEB_ADMIN_STATIC_WEB_CONTENT_LOCATION, Configurator.WEB_ADMIN_PATH);\n\n        log.info(\"Mounting management API at [%s]\", Configurator.WEB_ADMIN_REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.WEB_ADMIN_REST_API_PACKAGE }), Configurator.WEB_ADMIN_REST_API_PATH);\n\n        log.info(\"Mounting REST API at [%s]\", Configurator.REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.REST_API_PACKAGE }), Configurator.REST_API_PATH);\n\n        try {\n            webServer.start();\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%d], reason [%s]\", getWebServerPort(), e.getMessage());\n        }\n    }","id":26447,"modified_method":"private void startWebServer() {\n\n        int webServerPort = getWebServerPort();\n        this.webServer = new Jetty6WebServer();\n        this.webServer.setNeoServer(this);\n\n        log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n        webServer.setPort(webServerPort);\n\n        log.info(\"Mounting webadmin at [%s]\", Configurator.WEB_ADMIN_PATH);\n        webServer.addStaticContent(Configurator.WEB_ADMIN_STATIC_WEB_CONTENT_LOCATION, Configurator.WEB_ADMIN_PATH);\n\n        log.info(\"Mounting management API at [%s]\", Configurator.WEB_ADMIN_REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.WEB_ADMIN_REST_API_PACKAGE }), Configurator.WEB_ADMIN_REST_API_PATH);\n\n        log.info(\"Mounting REST API at [%s]\", Configurator.REST_API_PATH);\n        webServer.addJAXRSPackages(listFrom(new String[] { Configurator.REST_API_PACKAGE }), Configurator.REST_API_PATH);\n        \n        for(ThirdPartyJaxRsPackage tpp : configurator.getThirdpartyJaxRsClasses()) {\n            log.info(\"Mounting third-party JAX-RS package [%s] at [%s]\", tpp.getPackageName(), tpp.getMountPoint());\n            webServer.addJAXRSPackages(listFrom(new String[] { tpp.getPackageName() }), tpp.getMountPoint());\n        }\n\n        try {\n            webServer.start();\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%d], reason [%s]\", getWebServerPort(), e.getMessage());\n        }\n    }","commit_id":"3dda55b4514837a0e96092da216c626cb6234dc8","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String baseUri() throws UnknownHostException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"http\");\n        int webServerPort = getWebServerPort();\n        if (webServerPort == 443) {\n            sb.append(\"s\");\n\n        }\n        sb.append(\"://\");\n        sb.append(addressResolver.getHostname());\n\n        if (webServerPort != 80) {\n            sb.append(\":\");\n            sb.append(webServerPort);\n        }\n        sb.append(\"/\");\n\n        return sb.toString();\n    }","id":26448,"modified_method":"public URI baseUri() throws UnknownHostException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"http\");\n        int webServerPort = getWebServerPort();\n        if (webServerPort == 443) {\n            sb.append(\"s\");\n\n        }\n        sb.append(\"://\");\n        sb.append(addressResolver.getHostname());\n\n        if (webServerPort != 80) {\n            sb.append(\":\");\n            sb.append(webServerPort);\n        }\n        sb.append(\"/\");\n\n        try {\n            return new URI(sb.toString());\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"3dda55b4514837a0e96092da216c626cb6234dc8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private URI generateUriFor(String serviceName) {\n        if (serviceName.startsWith(\"/\")) {\n            serviceName = serviceName.substring(1);\n        }\n        StringBuilder sb = new StringBuilder();\n        try {\n            sb.append(baseUri());\n            sb.append(serviceName);\n            sb.append(\"/\");\n\n            return new URI(sb.toString());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","id":26449,"modified_method":"private URI generateUriFor(String serviceName) {\n        if (serviceName.startsWith(\"/\")) {\n            serviceName = serviceName.substring(1);\n        }\n        StringBuilder sb = new StringBuilder();\n        try {\n            sb.append(baseUri().toString());\n            sb.append(serviceName);\n            sb.append(\"/\");\n\n            return new URI(sb.toString());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"3dda55b4514837a0e96092da216c626cb6234dc8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        assertThat(appender.toString(), containsString(\"Starting Neo Server on port [\" + server.restApiUri().getPort() + \"]\"));\n    }","id":26450,"modified_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        InMemoryAppender appender = new InMemoryAppender(NeoServer.log);\n        NeoServer server = ServerBuilder.server().withPassingStartupHealthcheck().withRandomDatabaseDir().build();\n        server.start();\n        assertThat(appender.toString(), containsString(\"Starting Neo Server on port [\" + server.restApiUri().getPort() + \"]\"));\n        server.stop();\n    }","commit_id":"3dda55b4514837a0e96092da216c626cb6234dc8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void whenServerIsStartedItshouldStartASingleDatabase() throws Exception {\n        assertNotNull(server.getDatabase());\n    }","id":26451,"modified_method":"@Test\n    public void whenServerIsStartedItshouldStartASingleDatabase() throws Exception {\n        NeoServer server = ServerBuilder.server().withPassingStartupHealthcheck().withRandomDatabaseDir().build();\n        server.start();\n        assertNotNull(server.getDatabase());\n        server.stop();\n    }","commit_id":"3dda55b4514837a0e96092da216c626cb6234dc8","url":"https://github.com/neo4j/neo4j"},{"original_method":"public File build() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n        if(dbTuningPropertyRule != null) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, dbTuningPropertyRule, temporaryConfigFile);\n        }\n        \n        \n        return temporaryConfigFile;\n    }","id":26452,"modified_method":"public File build() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n        if(dbTuningPropertyRule != null) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, dbTuningPropertyRule, temporaryConfigFile);\n        }\n        \n        for(Tuple t: nameValuePairs) {\n            writePropertyToFile(t.name, t.value, temporaryConfigFile);\n        }\n        \n        \n        return temporaryConfigFile;\n    }","commit_id":"3dda55b4514837a0e96092da216c626cb6234dc8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private File createPropertyFile() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n        \n        if(action == WhatToDo.CREATE_GOOD_TUNING_FILE) {\n            File databaseTuningPropertyFile = createTempPropertyFile();\n            writePropertyToFile(\"neostore.nodestore.db.mapped_memory\", \"25M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.relationshipstore.db.mapped_memory\", \"50M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.mapped_memory\", \"90M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.strings.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.arrays.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, databaseTuningPropertyFile.getAbsolutePath(), temporaryConfigFile);\n        } else if(action == WhatToDo.CREATE_DANGLING_TUNING_FILE_PROPERTY) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, createTempPropertyFile().getAbsolutePath(), temporaryConfigFile);\n        } else if(action == WhatToDo.CREATE_CORRUPT_TUNING_FILE) {\n            File corruptTuningFile = trashFile();\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, corruptTuningFile.getAbsolutePath(), temporaryConfigFile);\n        }\n        \n        return temporaryConfigFile;\n    }","id":26453,"modified_method":"private File createPropertyFile() throws IOException {\n        File temporaryConfigFile = createTempPropertyFile();\n        writePropertyToFile(Configurator.DATABASE_LOCATION_PROPERTY_KEY, dbDir, temporaryConfigFile);\n        if (portNo != null) {\n            writePropertyToFile(Configurator.WEBSERVER_PORT_PROPERTY_KEY, portNo, temporaryConfigFile);\n        }\n        writePropertyToFile(Configurator.WEBADMIN_NAMESPACE_PROPERTY_KEY + \".rrdb.location\", rrdbDir, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_PATH_PROPERTY_KEY, webAdminUri, temporaryConfigFile);\n        writePropertyToFile(Configurator.WEB_ADMIN_REST_API_PATH_PROPERTY_KEY, webAdminDataUri, temporaryConfigFile);\n\n        if (action == WhatToDo.CREATE_GOOD_TUNING_FILE) {\n            File databaseTuningPropertyFile = createTempPropertyFile();\n            writePropertyToFile(\"neostore.nodestore.db.mapped_memory\", \"25M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.relationshipstore.db.mapped_memory\", \"50M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.mapped_memory\", \"90M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.strings.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(\"neostore.propertystore.db.arrays.mapped_memory\", \"130M\", databaseTuningPropertyFile);\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, databaseTuningPropertyFile.getAbsolutePath(), temporaryConfigFile);\n        } else if (action == WhatToDo.CREATE_DANGLING_TUNING_FILE_PROPERTY) {\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, createTempPropertyFile().getAbsolutePath(), temporaryConfigFile);\n        } else if (action == WhatToDo.CREATE_CORRUPT_TUNING_FILE) {\n            File corruptTuningFile = trashFile();\n            writePropertyToFile(Configurator.DB_TUNING_PROPERTY_FILE_KEY, corruptTuningFile.getAbsolutePath(), temporaryConfigFile);\n        }\n\n        if (thirdPartyPackages.keySet().size() > 0) {\n            writePropertiesToFile(Configurator.THIRD_PARTY_PACKAGES_KEY, thirdPartyPackages, temporaryConfigFile);\n        }\n        \n        return temporaryConfigFile;\n    }","commit_id":"3dda55b4514837a0e96092da216c626cb6234dc8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void undeploy(final DeploymentUnit depUnit) {\n        Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        XBundle bundle = depUnit.getAttachment(OSGiConstants.INSTALLED_BUNDLE_KEY);\n        if (bundle != null && deployment.isAutoStart()) {\n            try {\n                bundle.stop();\n                depUnit.putAttachment(Attachments.BUNDLE_STATE_KEY, BundleState.RESOLVED);\n            } catch (BundleException ex) {\n                LOGGER.debugf(ex, \"Cannot stop bundle: %s\", bundle);\n            }\n        }\n    }","id":26454,"modified_method":"@Override\n    public void undeploy(final DeploymentUnit depUnit) {\n        Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        XBundle bundle = depUnit.getAttachment(OSGiConstants.INSTALLED_BUNDLE_KEY);\n        if (bundle != null && deployment.isAutoStart()) {\n            try {\n                bundle.stop(Bundle.STOP_TRANSIENT);\n                depUnit.putAttachment(Attachments.BUNDLE_STATE_KEY, BundleState.RESOLVED);\n            } catch (BundleException ex) {\n                LOGGER.debugf(ex, \"Cannot stop bundle: %s\", bundle);\n            }\n        }\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        XBundle bundle = depUnit.getAttachment(OSGiConstants.INSTALLED_BUNDLE_KEY);\n        if (bundle != null && deployment.isAutoStart() && bundle.isResolved()) {\n            try {\n                bundle.start();\n                depUnit.putAttachment(Attachments.BUNDLE_STATE_KEY, BundleState.ACTIVE);\n            } catch (BundleException ex) {\n                LOGGER.errorCannotStartBundle(ex, bundle);\n            }\n        }\n    }","id":26455,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        XBundle bundle = depUnit.getAttachment(OSGiConstants.INSTALLED_BUNDLE_KEY);\n        if (bundle != null && deployment.isAutoStart() && bundle.isResolved()) {\n            try {\n                bundle.start(Bundle.START_TRANSIENT | Bundle.START_ACTIVATION_POLICY);\n                depUnit.putAttachment(Attachments.BUNDLE_STATE_KEY, BundleState.ACTIVE);\n            } catch (BundleException ex) {\n                LOGGER.errorCannotStartBundle(ex, bundle);\n            }\n        }\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void restoreStorageState(final DeploymentPhaseContext phaseContext, final Deployment deployment) {\n        StorageStatePlugin storageProvider = (StorageStatePlugin) phaseContext.getServiceRegistry().getRequiredService(Services.STORAGE_STATE_PLUGIN).getValue();\n        StorageState storageState = storageProvider.getByLocation(deployment.getLocation());\n        if (storageState != null) {\n            deployment.addAttachment(StorageState.class, storageState);\n            deployment.setAutoStart(false);\n        }\n    }","id":26456,"modified_method":"private void restoreStorageState(final DeploymentPhaseContext phaseContext, final Deployment deployment) {\n        StorageStatePlugin storageProvider = (StorageStatePlugin) phaseContext.getServiceRegistry().getRequiredService(Services.STORAGE_STATE_PLUGIN).getValue();\n        StorageState storageState = storageProvider.getByLocation(deployment.getLocation());\n        if (storageState != null) {\n            deployment.addAttachment(StorageState.class, storageState);\n        }\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        final Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        if (deployment != null) {\n            ServiceName serviceName;\n            try {\n                final BundleManager bundleManager = depUnit.getAttachment(OSGiConstants.BUNDLE_MANAGER_KEY);\n                if (!deploymentTracker.isClosed() && deploymentTracker.hasDeploymentName(depUnit.getName())) {\n                    restoreStorageState(phaseContext, deployment);\n                    serviceName = bundleManager.installBundle(deployment, deploymentTracker.getBundleInstallListener());\n                    deploymentTracker.registerBundleInstallService(serviceName);\n                } else {\n                    serviceName = bundleManager.installBundle(deployment, null);\n                }\n            } catch (BundleException ex) {\n                throw new DeploymentUnitProcessingException(ex);\n            }\n            phaseContext.addDeploymentDependency(serviceName, OSGiConstants.INSTALLED_BUNDLE_KEY);\n            depUnit.putAttachment(BUNDLE_STATE_KEY, BundleState.INSTALLED);\n            depUnit.putAttachment(BUNDLE_INSTALL_SERVICE, serviceName);\n        }\n    }","id":26457,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        final Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        if (deployment != null) {\n            ServiceName serviceName;\n            try {\n                final BundleManager bundleManager = depUnit.getAttachment(OSGiConstants.BUNDLE_MANAGER_KEY);\n                if (!deploymentTracker.isComplete() && deploymentTracker.hasDeploymentName(depUnit.getName())) {\n                    restoreStorageState(phaseContext, deployment);\n                    serviceName = bundleManager.installBundle(deployment, deploymentTracker.getBundleInstallListener());\n                    deploymentTracker.registerBundleInstallService(serviceName);\n                } else {\n                    serviceName = bundleManager.installBundle(deployment, null);\n                }\n            } catch (BundleException ex) {\n                throw new DeploymentUnitProcessingException(ex);\n            }\n            phaseContext.addDeploymentDependency(serviceName, OSGiConstants.INSTALLED_BUNDLE_KEY);\n            depUnit.putAttachment(BUNDLE_STATE_KEY, BundleState.INSTALLED);\n            depUnit.putAttachment(BUNDLE_INSTALL_SERVICE, serviceName);\n        }\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void resolveBundle(DeploymentUnit depUnit, XBundle bundle) {\n        XBundleRevision brev = bundle.getBundleRevision();\n        XEnvironment env = depUnit.getAttachment(OSGiConstants.ENVIRONMENT_KEY);\n        XResolver resolver = depUnit.getAttachment(OSGiConstants.RESOLVER_KEY);\n        XResolveContext context = resolver.createResolveContext(env, Collections.singleton(brev), null);\n        try {\n            Map<Resource, Wiring> wiremap = resolver.resolveAndApply(context);\n            BundleWiring wiring = (BundleWiring) wiremap.get(brev);\n            depUnit.putAttachment(Attachments.BUNDLE_STATE_KEY, BundleState.RESOLVED);\n            depUnit.putAttachment(OSGiConstants.BUNDLE_WIRING_KEY, wiring);\n            Module module = brev.getModuleClassLoader().getModule();\n            depUnit.putAttachment(Attachments.MODULE, module);\n        } catch (ResolutionException ex) {\n            LOGGER.warnCannotResolve(ex.getUnresolvedRequirements());\n        }\n    }","id":26458,"modified_method":"static void resolveBundle(DeploymentPhaseContext phaseContext, XBundle bundle) {\n        XBundleRevision brev = bundle.getBundleRevision();\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        XEnvironment env = depUnit.getAttachment(OSGiConstants.ENVIRONMENT_KEY);\n        XResolver resolver = depUnit.getAttachment(OSGiConstants.RESOLVER_KEY);\n        XResolveContext context = resolver.createResolveContext(env, Collections.singleton(brev), null);\n        try {\n            resolver.resolveAndApply(context);\n            depUnit.putAttachment(Attachments.BUNDLE_STATE_KEY, BundleState.RESOLVED);\n            ModuleIdentifier identifier = brev.getModuleIdentifier();\n            ServiceName moduleService = ServiceModuleLoader.moduleServiceName(identifier);\n            phaseContext.addDeploymentDependency(moduleService, Attachments.MODULE);\n        } catch (ResolutionException ex) {\n            LOGGER.warnCannotResolve(ex.getUnresolvedRequirements());\n        }\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void undeploy(final DeploymentUnit depUnit) {\n        depUnit.removeAttachment(OSGiConstants.BUNDLE_WIRING_KEY);\n    }","id":26459,"modified_method":"@Override\n    public void undeploy(final DeploymentUnit depUnit) {\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        if (depUnit.hasAttachment(Attachments.MODULE))\n            return;\n\n        Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        XBundle bundle = depUnit.getAttachment(OSGiConstants.INSTALLED_BUNDLE_KEY);\n        if (bundle == null || deployment.isAutoStart() == false)\n            return;\n\n        // Only process the top level deployment\n        if (depUnit.getParent() != null)\n            return;\n\n        resolveBundle(depUnit, bundle);\n    }","id":26460,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        XBundle bundle = depUnit.getAttachment(OSGiConstants.INSTALLED_BUNDLE_KEY);\n        boolean bootstrapBundle = deploymentTracker.hasDeploymentName(depUnit.getName());\n        if (bundle == null || !deployment.isAutoStart() || bootstrapBundle)\n            return;\n\n        // Only process the top level deployment\n        if (depUnit.getParent() != null)\n            return;\n\n        resolveBundle(phaseContext, bundle);\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        if (depUnit.hasAttachment(Attachments.MODULE))\n            return;\n\n        Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        XBundle bundle = depUnit.getAttachment(OSGiConstants.INSTALLED_BUNDLE_KEY);\n        if (bundle == null || deployment.isAutoStart() == false)\n            return;\n\n        // Only process the sub deployments\n        if (depUnit.getParent() == null)\n            return;\n\n        BundleResolveProcessor.resolveBundle(depUnit, bundle);\n    }","id":26461,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        XBundle bundle = depUnit.getAttachment(OSGiConstants.INSTALLED_BUNDLE_KEY);\n        if (bundle == null || deployment.isAutoStart() == false)\n            return;\n\n        // Only process the sub deployments\n        if (depUnit.getParent() == null)\n            return;\n\n        BundleResolveProcessor.resolveBundle(phaseContext, bundle);\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void undeploy(final DeploymentUnit depUnit) {\n        depUnit.removeAttachment(OSGiConstants.BUNDLE_WIRING_KEY);\n    }","id":26462,"modified_method":"@Override\n    public void undeploy(final DeploymentUnit depUnit) {\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public synchronized void start(StartContext context) throws StartException {\n        ServiceController<?> controller = context.getController();\n        LOGGER.tracef(\"Starting: %s in mode %s\", controller.getName(), controller.getMode());\n        try {\n            ServiceContainer serviceContainer = context.getController().getServiceContainer();\n\n            // Setup the OSGi {@link Framework} properties\n            SubsystemState subsystemState = injectedSubsystemState.getValue();\n            Map<String, Object> props = new HashMap<String, Object>(subsystemState.getProperties());\n            setupIntegrationProperties(context, props);\n\n            // Register the URLStreamHandlerFactory\n            Module coreFrameworkModule = ((ModuleClassLoader) FrameworkBuilder.class.getClassLoader()).getModule();\n            Module.registerURLStreamHandlerFactoryModule(coreFrameworkModule);\n            Module.registerContentHandlerFactoryModule(coreFrameworkModule);\n\n            ServiceTarget serviceTarget = context.getChildTarget();\n            AutoInstallIntegration.addService(serviceTarget);\n            BundleInstallIntegration.addService(serviceTarget);\n            BundleContextBindingService.addService(serviceTarget);\n            FrameworkModuleIntegration.addService(serviceTarget, props);\n            JAXPServiceProvider.addService(serviceTarget);\n            ModuleLoaderIntegration.addService(serviceTarget);\n            ResolverService.addService(serviceTarget);\n            SystemServicesIntegration.addService(serviceTarget, resource);\n\n            // Configure the {@link Framework} builder\n            Activation activation = subsystemState.getActivationPolicy();\n            Mode initialMode = (activation == Activation.EAGER ? Mode.ACTIVE : Mode.ON_DEMAND);\n            FrameworkBuilder builder = new FrameworkBuilder(props, initialMode);\n            builder.setServiceContainer(serviceContainer);\n            builder.setServiceTarget(serviceTarget);\n\n            // Create the {@link Framework} services\n            builder.createFrameworkServices(true);\n\n        } catch (Throwable th) {\n            throw MESSAGES.startFailedToCreateFrameworkServices(th);\n        }\n    }","id":26463,"modified_method":"@Override\n    public synchronized void start(StartContext context) throws StartException {\n        ServiceController<?> controller = context.getController();\n        LOGGER.tracef(\"Starting: %s in mode %s\", controller.getName(), controller.getMode());\n        try {\n            ServiceContainer serviceContainer = context.getController().getServiceContainer();\n\n            // Setup the OSGi {@link Framework} properties\n            SubsystemState subsystemState = injectedSubsystemState.getValue();\n            Map<String, Object> props = new HashMap<String, Object>(subsystemState.getProperties());\n            setupIntegrationProperties(context, props);\n\n            // Register the URLStreamHandlerFactory\n            Module coreFrameworkModule = ((ModuleClassLoader) FrameworkBuilder.class.getClassLoader()).getModule();\n            Module.registerURLStreamHandlerFactoryModule(coreFrameworkModule);\n            Module.registerContentHandlerFactoryModule(coreFrameworkModule);\n\n            ServiceTarget serviceTarget = context.getChildTarget();\n            BootstrapBundlesIntegration.addService(serviceTarget);\n            BundleInstallIntegration.addService(serviceTarget);\n            BundleContextBindingService.addService(serviceTarget);\n            FrameworkModuleIntegration.addService(serviceTarget, props);\n            JAXPServiceProvider.addService(serviceTarget);\n            ModuleLoaderIntegration.addService(serviceTarget);\n            PersistentBundlesIntegration.addService(serviceTarget);\n            ResolverService.addService(serviceTarget);\n            SystemServicesIntegration.addService(serviceTarget, resource);\n\n            // Configure the {@link Framework} builder\n            Activation activation = subsystemState.getActivationPolicy();\n            Mode initialMode = (activation == Activation.EAGER ? Mode.ACTIVE : Mode.ON_DEMAND);\n            FrameworkBuilder builder = new FrameworkBuilder(props, initialMode);\n            builder.setServiceContainer(serviceContainer);\n            builder.setServiceTarget(serviceTarget);\n\n            // Create the {@link Framework} services\n            builder.createFrameworkServices(true);\n\n        } catch (Throwable th) {\n            throw MESSAGES.startFailedToCreateFrameworkServices(th);\n        }\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ServiceName getModuleSpecServiceName(ModuleIdentifier identifier) {\n        return MODULE_SPEC_SERVICE_PREFIX.append(identifier.getName()).append(identifier.getSlot());\n    }","id":26464,"modified_method":"private ServiceName getModuleSpecServiceName(ModuleIdentifier identifier) {\n        return ServiceModuleLoader.moduleSpecServiceName(identifier);\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ServiceName getModuleServiceName(ModuleIdentifier identifier) {\n        return MODULE_SERVICE_PREFIX.append(identifier.getName()).append(identifier.getSlot());\n    }","id":26465,"modified_method":"@Override\n    public ServiceName getModuleServiceName(ModuleIdentifier identifier) {\n        return ServiceModuleLoader.moduleServiceName(identifier);\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model,\n            final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) {\n\n        LOGGER.infoActivatingSubsystem();\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final Activation activationMode = getActivationMode(operation);\n        final InitialDeploymentTracker deploymentTracker = new InitialDeploymentTracker(context, activationMode);\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                newControllers.add(PersistentBundlesIntegration.addService(serviceTarget, deploymentTracker));\n                newControllers.add(FrameworkBootstrapService.addService(serviceTarget, resource, verificationHandler));\n                context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_OSGI_MANIFEST, new OSGiManifestStructureProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_BUNDLE_SUB_DEPLOYMENT, new BundleSubDeploymentMarkingProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_BUNDLE_INFO, new OSGiBundleInfoParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_PROPERTIES, new OSGiXServiceParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_DEPLOYMENT, new BundleDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_SUBSYSTEM_ACTIVATOR, new SubsystemActivateProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_BUNDLE_CONTEXT, new BundleContextDependencyProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.REGISTER, Phase.REGISTER_BUNDLE_INSTALL, new BundleInstallProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_RESOLVE_BUNDLE, new BundleResolveProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_RESOLVE_SUB_BUNDLE, new BundleResolveSubProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RESOLVER_MODULE, new ModuleRegisterProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_BUNDLE_ACTIVATE, new BundleActivateProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        // Perform boottime on subsystem extensions\n        ClassLoader classLoader = OSGiSubsystemExtension.class.getClassLoader();\n        Iterator<OSGiSubsystemExtension> services = ServiceLoader.load(OSGiSubsystemExtension.class, classLoader).iterator();\n        while(services.hasNext()) {\n            OSGiSubsystemExtension extension = services.next();\n            extension.performBoottime(context, operation, model, verificationHandler, newControllers);\n        }\n\n        // Add the subsystem state as a service\n        newControllers.add(SubsystemState.addService(serviceTarget, activationMode));\n    }","id":26466,"modified_method":"@Override\n    protected void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model,\n            final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) {\n\n        LOGGER.infoActivatingSubsystem();\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final Activation activationMode = getActivationMode(operation);\n        final InitialDeploymentTracker deploymentTracker = new InitialDeploymentTracker(context, verificationHandler);\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                newControllers.add(FrameworkBootstrapService.addService(serviceTarget, resource, verificationHandler));\n                context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_OSGI_MANIFEST, new OSGiManifestStructureProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_BUNDLE_SUB_DEPLOYMENT, new BundleSubDeploymentMarkingProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_BUNDLE_INFO, new OSGiBundleInfoParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_PROPERTIES, new OSGiXServiceParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_DEPLOYMENT, new BundleDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_SUBSYSTEM_ACTIVATOR, new SubsystemActivateProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_BUNDLE_CONTEXT, new BundleContextDependencyProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.REGISTER, Phase.REGISTER_BUNDLE_INSTALL, new BundleInstallProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_RESOLVE_BUNDLE, new BundleResolveProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_RESOLVE_SUB_BUNDLE, new BundleResolveSubProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RESOLVER_MODULE, new ModuleRegisterProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_BUNDLE_ACTIVATE, new BundleActivateProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        // Perform boottime on subsystem extensions\n        ClassLoader classLoader = OSGiSubsystemExtension.class.getClassLoader();\n        Iterator<OSGiSubsystemExtension> services = ServiceLoader.load(OSGiSubsystemExtension.class, classLoader).iterator();\n        while(services.hasNext()) {\n            OSGiSubsystemExtension extension = services.next();\n            extension.performBoottime(context, operation, model, verificationHandler, newControllers);\n        }\n\n        // Add the subsystem state as a service\n        newControllers.add(SubsystemState.addService(serviceTarget, activationMode));\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"public InitialDeploymentTracker(final OperationContext context, final Activation activationMode) {\n\n            final ServiceTarget serviceTarget = context.getServiceTarget();\n            final PersistentBundlesComplete installComplete = new PersistentBundlesComplete() {\n                @Override\n                protected boolean allServicesAdded(Set<ServiceName> trackedServices) {\n                    synchronized (bundleInstallServices) {\n                        return deploymentInstallComplete.get() && bundleInstallServices.size() == trackedServices.size();\n                    }\n                }\n            };\n            ServiceBuilder<Void> installCompleteBuilder = installComplete.install(serviceTarget);\n            installCompleteBuilder.setInitialMode(activationMode == Activation.EAGER ? Mode.ACTIVE : Mode.ON_DEMAND);\n\n            deploymentNames = getDeploymentNames(context);\n            deploymentCount = new AtomicInteger(deploymentNames.size());\n            if (deploymentCount.get() == 0) {\n                // Install the INITIAL_DEPLOYMENTS_COMPLETE service\n                initialDeploymentsComplete(serviceTarget);\n                // Install the PERSISTENT_BUNDLES_COMPLETE service\n                installCompleteBuilder.install();\n                return;\n            }\n\n            final Set<ServiceName> depUnitPhaseServices = new HashSet<ServiceName>();\n            for (String deploymentName : deploymentNames) {\n                ServiceName serviceName = Services.deploymentUnitName(deploymentName);\n                depUnitPhaseServices.add(serviceName.append(Phase.INSTALL.toString()));\n            }\n\n            final ServiceRegistry serviceRegistry = context.getServiceRegistry(false);\n            final ServiceTarget listenerTarget = serviceRegistry.getService(JBOSS_SERVER_CONTROLLER).getServiceContainer();\n            bundleInstallListener = installComplete.getListener();\n            ServiceListener<Object> listener = new AbstractServiceListener<Object>() {\n                @Override\n                public void transition(ServiceController<? extends Object> controller, Transition transition) {\n                    if (isClosed() == false) {\n                        ServiceName serviceName = controller.getName();\n                        synchronized (depUnitPhaseServices) {\n                            if (depUnitPhaseServices.contains(serviceName)) {\n                                switch (transition) {\n                                    case STARTING_to_UP:\n                                    case STARTING_to_START_FAILED:\n                                        depUnitPhaseServices.remove(serviceName);\n                                        int remaining = deploymentCount.decrementAndGet();\n                                        LOGGER.debugf(\"Initial deployment tracked: %s (remaining=%d)\", serviceName.getCanonicalName(), remaining);\n                                        if (deploymentCount.get() == 0) {\n                                            listenerTarget.removeListener(this);\n                                            initialDeploymentsComplete(serviceTarget);\n                                            installComplete.checkAndComplete();\n                                        }\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n            listenerTarget.addListener(Inheritance.ALL, listener);\n        }","id":26467,"modified_method":"public InitialDeploymentTracker(OperationContext context, ServiceVerificationHandler verificationHandler) {\n\n            serviceTarget = context.getServiceTarget();\n            deploymentNames = getDeploymentNames(context);\n\n            // Get the INSTALL phase service names\n            for (String deploymentName : deploymentNames) {\n                ServiceName serviceName = Services.deploymentUnitName(deploymentName);\n                deploymentPhaseServices.add(serviceName.append(Phase.INSTALL.toString()));\n            }\n\n            // Register this tracker with the server controller\n            if (!deploymentNames.isEmpty()) {\n                ServiceRegistry serviceRegistry = context.getServiceRegistry(false);\n                listenerTarget = serviceRegistry.getService(JBOSS_SERVER_CONTROLLER).getServiceContainer();\n                listenerTarget.addListener(Inheritance.ALL, this);\n            }\n\n            // Setup the bundle install listener\n            bundleInstallListener = new ServiceTracker<XBundle>() {\n\n                @Override\n                protected boolean allServicesAdded(Set<ServiceName> trackedServices) {\n                    return deploymentInstallComplete.get();\n                }\n\n                @Override\n                protected void complete() {\n                    installResolveService(serviceTarget, installedServices);\n                }\n            };\n\n            // Check the tracker for completeness\n            checkAndComplete();\n        }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void initialDeploymentsComplete(ServiceTarget serviceTarget) {\n            LOGGER.tracef(\"Initial deployments complete\");\n            final ServiceBuilder<Void> deploymentCompleteBuilder = serviceTarget.addService(INITIAL_DEPLOYMENTS_COMPLETE, new AbstractService<Void>() {\n                public void start(StartContext context) throws StartException {\n                    final ServiceController<?> controller = context.getController();\n                    LOGGER.tracef(\"Starting: %s in mode %s\", controller.getName(), controller.getMode());\n                }\n            });\n            deploymentInstallComplete.set(true);\n            deploymentCompleteBuilder.install();\n        }","id":26468,"modified_method":"private ServiceController<Void> initialDeploymentsComplete(ServiceTarget serviceTarget) {\n            return serviceTarget.addService(INITIAL_DEPLOYMENTS_COMPLETE, new AbstractService<Void>() {\n            }).install();\n        }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void registerBundleInstallService(ServiceName serviceName) {\n            synchronized (bundleInstallServices) {\n                LOGGER.tracef(\"Register bundle install service: %s\", serviceName);\n                bundleInstallServices.add(serviceName);\n            }\n        }","id":26469,"modified_method":"public void registerBundleInstallService(ServiceName serviceName) {\n            synchronized (installedServices) {\n                LOGGER.tracef(\"Register bundle install service: %s\", serviceName);\n                installedServices.add(serviceName);\n            }\n        }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ServiceListener<Bundle> getBundleInstallListener() {\n            return bundleInstallListener;\n        }","id":26470,"modified_method":"public ServiceListener<XBundle> getBundleInstallListener() {\n            return bundleInstallListener;\n        }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Always make the system context & the environment available\n        phaseContext.addDeploymentDependency(Services.SYSTEM_CONTEXT, OSGiConstants.SYSTEM_CONTEXT_KEY);\n        phaseContext.addDeploymentDependency(Services.ENVIRONMENT, OSGiConstants.ENVIRONMENT_KEY);\n\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        if (depUnit.hasAttachment(OSGiConstants.DEPLOYMENT_KEY)) {\n            phaseContext.getServiceRegistry().getRequiredService(Services.FRAMEWORK_ACTIVE).setMode(Mode.ACTIVE);\n            phaseContext.addDependency(IntegrationServices.AUTOINSTALL_COMPLETE, AttachmentKey.create(Object.class));\n            phaseContext.addDeploymentDependency(Services.BUNDLE_MANAGER, OSGiConstants.BUNDLE_MANAGER_KEY);\n            phaseContext.addDeploymentDependency(Services.RESOLVER, OSGiConstants.RESOLVER_KEY);\n        }\n    }","id":26471,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Always make the system context & the environment available\n        phaseContext.addDeploymentDependency(Services.SYSTEM_CONTEXT, OSGiConstants.SYSTEM_CONTEXT_KEY);\n        phaseContext.addDeploymentDependency(Services.ENVIRONMENT, OSGiConstants.ENVIRONMENT_KEY);\n\n        // Not a bundle deployment - do nothing\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        if (depUnit.hasAttachment(OSGiConstants.DEPLOYMENT_KEY)) {\n            phaseContext.getServiceRegistry().getRequiredService(Services.FRAMEWORK_ACTIVE).setMode(Mode.ACTIVE);\n            phaseContext.addDependency(IntegrationServices.BOOTSTRAP_BUNDLES_COMPLETE, AttachmentKey.create(Object.class));\n            phaseContext.addDeploymentDependency(Services.BUNDLE_MANAGER, OSGiConstants.BUNDLE_MANAGER_KEY);\n            phaseContext.addDeploymentDependency(Services.RESOLVER, OSGiConstants.RESOLVER_KEY);\n        }\n    }","commit_id":"0e5fe7e9148755f238634f0b1fcc008a679567be","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n        final ServiceName hqServiceName = MessagingServices.getHornetQServiceName(PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)));\n\n        final ConnectionFactoryConfiguration configuration = createConfiguration(context, name, operation);\n        final ConnectionFactoryService service = new ConnectionFactoryService(configuration);\n        final ServiceName serviceName = JMSServices.getConnectionFactoryBaseServiceName(hqServiceName).append(name);\n        newControllers.add(context.getServiceTarget().addService(serviceName, service)\n                .addDependency(JMSServices.getJmsManagerBaseServiceName(hqServiceName), JMSServerManager.class, service.getJmsServer())\n                .addListener(verificationHandler)\n                .setInitialMode(Mode.ACTIVE)\n                .install());\n    }","id":26472,"modified_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n        final ServiceName hqServiceName = MessagingServices.getHornetQServiceName(PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)));\n\n        final ConnectionFactoryConfiguration configuration = createConfiguration(context, name, model);\n        final ConnectionFactoryService service = new ConnectionFactoryService(configuration);\n        final ServiceName serviceName = JMSServices.getConnectionFactoryBaseServiceName(hqServiceName).append(name);\n        newControllers.add(context.getServiceTarget().addService(serviceName, service)\n                .addDependency(JMSServices.getJmsManagerBaseServiceName(hqServiceName), JMSServerManager.class, service.getJmsServer())\n                .addListener(verificationHandler)\n                .setInitialMode(Mode.ACTIVE)\n                .install());\n    }","commit_id":"5b43edc014be3e76ef58969ebe0b20f935de3985","url":"https://github.com/wildfly/wildfly"},{"original_method":"static ConnectionFactoryConfiguration createConfiguration(final OperationContext context, final String name, final ModelNode operation) throws OperationFailedException {\n        final ConnectionFactoryConfiguration config = new ConnectionFactoryConfigurationImpl(name, HornetQClient.DEFAULT_HA, JndiEntriesAttribute.getJndiBindings(operation));\n\n        config.setHA(HA.resolveModelAttribute(context, operation).asBoolean());\n        config.setAutoGroup(AUTO_GROUP.resolveModelAttribute(context, operation).asBoolean());\n        config.setBlockOnAcknowledge(BLOCK_ON_ACK.resolveModelAttribute(context, operation).asBoolean());\n        config.setBlockOnDurableSend(BLOCK_ON_DURABLE_SEND.resolveModelAttribute(context, operation).asBoolean());\n        config.setBlockOnNonDurableSend(BLOCK_ON_NON_DURABLE_SEND.resolveModelAttribute(context, operation).asBoolean());\n        config.setCacheLargeMessagesClient(CACHE_LARGE_MESSAGE_CLIENT.resolveModelAttribute(context, operation).asBoolean());\n        config.setCallTimeout(CALL_TIMEOUT.resolveModelAttribute(context, operation).asLong());\n        config.setClientFailureCheckPeriod(CLIENT_FAILURE_CHECK_PERIOD.resolveModelAttribute(context, operation).asInt());\n        final ModelNode clientId = CLIENT_ID.resolveModelAttribute(context, operation);\n        if (clientId.isDefined()) {\n            config.setClientID(clientId.asString());\n        }\n        config.setCompressLargeMessages(COMPRESS_LARGE_MESSAGES.resolveModelAttribute(context, operation).asBoolean());\n        config.setConfirmationWindowSize(CONFIRMATION_WINDOW_SIZE.resolveModelAttribute(context, operation).asInt());\n        config.setConnectionTTL(CONNECTION_TTL.resolveModelAttribute(context, operation).asLong());\n        if (operation.hasDefined(CONNECTOR)) {\n            ModelNode connectorRefs = operation.get(CONNECTOR);\n            List<String> connectorNames = new ArrayList<String>();\n            for (String connectorName : operation.get(CONNECTOR).keys()) {\n                ModelNode connectorRef = connectorRefs.get(connectorName);\n                connectorNames.add(connectorName);\n            }\n            config.setConnectorNames(connectorNames);\n        }\n        //config.setConnectorConfigs(connectorConfigs)\n        // config.setConnectorNames(connectors);\n        config.setConsumerMaxRate(CONSUMER_MAX_RATE.resolveModelAttribute(context, operation).asInt());\n        config.setConsumerWindowSize(CONSUMER_WINDOW_SIZE.resolveModelAttribute(context, operation).asInt());\n        final ModelNode discoveryGroupName = DISCOVERY_GROUP_NAME.resolveModelAttribute(context, operation);\n        if (discoveryGroupName.isDefined()) {\n            config.setDiscoveryGroupName(discoveryGroupName.asString());\n        }\n\n        config.setDupsOKBatchSize(DUPS_OK_BATCH_SIZE.resolveModelAttribute(context, operation).asInt());\n        config.setFailoverOnInitialConnection(FAILOVER_ON_INITIAL_CONNECTION.resolveModelAttribute(context, operation).asBoolean());\n\n        final ModelNode groupId = GROUP_ID.resolveModelAttribute(context, operation);\n        if(groupId.isDefined()) {\n            config.setGroupID(groupId.asString());\n        }\n\n        final ModelNode lbcn = LOAD_BALANCING_CLASS_NAME.resolveModelAttribute(context, operation);\n        if(lbcn.isDefined()) {\n            config.setLoadBalancingPolicyClassName(lbcn.asString());\n        }\n\n        config.setMaxRetryInterval(MAX_RETRY_INTERVAL.resolveModelAttribute(context, operation).asLong());\n        config.setMinLargeMessageSize(MIN_LARGE_MESSAGE_SIZE.resolveModelAttribute(context, operation).asInt());\n        config.setPreAcknowledge(PRE_ACK.resolveModelAttribute(context, operation).asBoolean());\n        config.setProducerMaxRate(PRODUCER_MAX_RATE.resolveModelAttribute(context, operation).asInt());\n        config.setProducerWindowSize(PRODUCER_WINDOW_SIZE.resolveModelAttribute(context, operation).asInt());\n        config.setReconnectAttempts(CONNECTION_FACTORY_RECONNECT_ATTEMPTS.resolveModelAttribute(context, operation).asInt());\n        config.setRetryInterval(RETRY_INTERVAL.resolveModelAttribute(context, operation).asLong());\n        config.setRetryIntervalMultiplier(RETRY_INTERVAL_MULTIPLIER.resolveModelAttribute(context, operation).asDouble());\n        config.setScheduledThreadPoolMaxSize(CONNECTION_SCHEDULED_THREAD_POOL_MAX_SIZE.resolveModelAttribute(context, operation).asInt());\n        config.setThreadPoolMaxSize(CONNECTION_THREAD_POOL_MAX_SIZE.resolveModelAttribute(context, operation).asInt());\n        config.setTransactionBatchSize(TRANSACTION_BATCH_SIZE.resolveModelAttribute(context, operation).asInt());\n        config.setUseGlobalPools(USE_GLOBAL_POOLS.resolveModelAttribute(context, operation).asBoolean());\n        config.setLoadBalancingPolicyClassName(LOAD_BALANCING_CLASS_NAME.resolveModelAttribute(context, operation).asString());\n\n        return config;\n    }","id":26473,"modified_method":"static ConnectionFactoryConfiguration createConfiguration(final OperationContext context, final String name, final ModelNode model) throws OperationFailedException {\n\n        final ModelNode entries = ENTRIES.resolveModelAttribute(context, model);\n        final String[] jndiBindings = JndiEntriesAttribute.getJndiBindings(entries);\n\n        final ConnectionFactoryConfiguration config = new ConnectionFactoryConfigurationImpl(name, HornetQClient.DEFAULT_HA, jndiBindings);\n\n        config.setHA(HA.resolveModelAttribute(context, model).asBoolean());\n        config.setAutoGroup(AUTO_GROUP.resolveModelAttribute(context, model).asBoolean());\n        config.setBlockOnAcknowledge(BLOCK_ON_ACK.resolveModelAttribute(context, model).asBoolean());\n        config.setBlockOnDurableSend(BLOCK_ON_DURABLE_SEND.resolveModelAttribute(context, model).asBoolean());\n        config.setBlockOnNonDurableSend(BLOCK_ON_NON_DURABLE_SEND.resolveModelAttribute(context, model).asBoolean());\n        config.setCacheLargeMessagesClient(CACHE_LARGE_MESSAGE_CLIENT.resolveModelAttribute(context, model).asBoolean());\n        config.setCallTimeout(CALL_TIMEOUT.resolveModelAttribute(context, model).asLong());\n        config.setClientFailureCheckPeriod(CLIENT_FAILURE_CHECK_PERIOD.resolveModelAttribute(context, model).asInt());\n        final ModelNode clientId = CLIENT_ID.resolveModelAttribute(context, model);\n        if (clientId.isDefined()) {\n            config.setClientID(clientId.asString());\n        }\n        config.setCompressLargeMessages(COMPRESS_LARGE_MESSAGES.resolveModelAttribute(context, model).asBoolean());\n        config.setConfirmationWindowSize(CONFIRMATION_WINDOW_SIZE.resolveModelAttribute(context, model).asInt());\n        config.setConnectionTTL(CONNECTION_TTL.resolveModelAttribute(context, model).asLong());\n        if (model.hasDefined(CONNECTOR)) {\n            ModelNode connectorRefs = model.get(CONNECTOR);\n            List<String> connectorNames = new ArrayList<String>();\n            for (String connectorName : model.get(CONNECTOR).keys()) {\n                ModelNode connectorRef = connectorRefs.get(connectorName);\n                connectorNames.add(connectorName);\n            }\n            config.setConnectorNames(connectorNames);\n        }\n        //config.setConnectorConfigs(connectorConfigs)\n        // config.setConnectorNames(connectors);\n        config.setConsumerMaxRate(CONSUMER_MAX_RATE.resolveModelAttribute(context, model).asInt());\n        config.setConsumerWindowSize(CONSUMER_WINDOW_SIZE.resolveModelAttribute(context, model).asInt());\n        final ModelNode discoveryGroupName = DISCOVERY_GROUP_NAME.resolveModelAttribute(context, model);\n        if (discoveryGroupName.isDefined()) {\n            config.setDiscoveryGroupName(discoveryGroupName.asString());\n        }\n\n        config.setDupsOKBatchSize(DUPS_OK_BATCH_SIZE.resolveModelAttribute(context, model).asInt());\n        config.setFailoverOnInitialConnection(FAILOVER_ON_INITIAL_CONNECTION.resolveModelAttribute(context, model).asBoolean());\n\n        final ModelNode groupId = GROUP_ID.resolveModelAttribute(context, model);\n        if(groupId.isDefined()) {\n            config.setGroupID(groupId.asString());\n        }\n\n        final ModelNode lbcn = LOAD_BALANCING_CLASS_NAME.resolveModelAttribute(context, model);\n        if(lbcn.isDefined()) {\n            config.setLoadBalancingPolicyClassName(lbcn.asString());\n        }\n\n        config.setMaxRetryInterval(MAX_RETRY_INTERVAL.resolveModelAttribute(context, model).asLong());\n        config.setMinLargeMessageSize(MIN_LARGE_MESSAGE_SIZE.resolveModelAttribute(context, model).asInt());\n        config.setPreAcknowledge(PRE_ACK.resolveModelAttribute(context, model).asBoolean());\n        config.setProducerMaxRate(PRODUCER_MAX_RATE.resolveModelAttribute(context, model).asInt());\n        config.setProducerWindowSize(PRODUCER_WINDOW_SIZE.resolveModelAttribute(context, model).asInt());\n        config.setReconnectAttempts(CONNECTION_FACTORY_RECONNECT_ATTEMPTS.resolveModelAttribute(context, model).asInt());\n        config.setRetryInterval(RETRY_INTERVAL.resolveModelAttribute(context, model).asLong());\n        config.setRetryIntervalMultiplier(RETRY_INTERVAL_MULTIPLIER.resolveModelAttribute(context, model).asDouble());\n        config.setScheduledThreadPoolMaxSize(CONNECTION_SCHEDULED_THREAD_POOL_MAX_SIZE.resolveModelAttribute(context, model).asInt());\n        config.setThreadPoolMaxSize(CONNECTION_THREAD_POOL_MAX_SIZE.resolveModelAttribute(context, model).asInt());\n        config.setTransactionBatchSize(TRANSACTION_BATCH_SIZE.resolveModelAttribute(context, model).asInt());\n        config.setUseGlobalPools(USE_GLOBAL_POOLS.resolveModelAttribute(context, model).asBoolean());\n        config.setLoadBalancingPolicyClassName(LOAD_BALANCING_CLASS_NAME.resolveModelAttribute(context, model).asString());\n\n        return config;\n    }","commit_id":"5b43edc014be3e76ef58969ebe0b20f935de3985","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n        final ModelNode selectorNode = SELECTOR.resolveModelAttribute(context, model);\n        final String selector = selectorNode.isDefined() ? selectorNode.asString() : null;\n        final ServiceName hqServiceName = MessagingServices.getHornetQServiceName(PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)));\n\n        final JMSQueueService service = new JMSQueueService(name, selector,\n                DURABLE.resolveModelAttribute(context, model).asBoolean(), JndiEntriesAttribute.getJndiBindings(operation));\n        final ServiceName serviceName = JMSServices.getJmsQueueBaseServiceName(hqServiceName).append(name);\n        newControllers.add(context.getServiceTarget().addService(serviceName, service)\n                .addDependency(JMSServices.getJmsManagerBaseServiceName(hqServiceName), JMSServerManager.class, service.getJmsServer())\n                .addListener(verificationHandler)\n                .setInitialMode(Mode.ACTIVE)\n                .install());\n\n    }","id":26474,"modified_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final ServiceName hqServiceName = MessagingServices.getHornetQServiceName(PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)));\n\n        final ModelNode selectorNode = SELECTOR.resolveModelAttribute(context, model);\n        final boolean durable = DURABLE.resolveModelAttribute(context, model).asBoolean();\n\n        final String selector = selectorNode.isDefined() ? selectorNode.asString() : null;\n        final ModelNode entries = ENTRIES.resolveModelAttribute(context, model);\n        final String[] jndiBindings = JndiEntriesAttribute.getJndiBindings(entries);\n        installServices(verificationHandler, newControllers, name, serviceTarget, hqServiceName, selector, durable, jndiBindings);\n\n    }","commit_id":"5b43edc014be3e76ef58969ebe0b20f935de3985","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n        final ServiceName hqServiceName = MessagingServices.getHornetQServiceName(PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)));\n\n        ENTRIES.resolveModelAttribute(context, model);\n\n        final JMSTopicService service = new JMSTopicService(name, JndiEntriesAttribute.getJndiBindings(operation));\n        final ServiceName serviceName = JMSServices.getJmsTopicBaseServiceName(hqServiceName).append(name);\n        newControllers.add(context.getServiceTarget().addService(serviceName, service)\n                .addDependency(JMSServices.getJmsManagerBaseServiceName(hqServiceName), JMSServerManager.class, service.getJmsServer())\n                .addListener(verificationHandler)\n                .setInitialMode(Mode.ACTIVE)\n                .install());\n    }","id":26475,"modified_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n        final ServiceName hqServiceName = MessagingServices.getHornetQServiceName(PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)));\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        final ModelNode entries = ENTRIES.resolveModelAttribute(context, model);\n        final String[] jndiBindings = JndiEntriesAttribute.getJndiBindings(entries);\n        installServices(verificationHandler, newControllers, name, hqServiceName, serviceTarget, jndiBindings);\n    }","commit_id":"5b43edc014be3e76ef58969ebe0b20f935de3985","url":"https://github.com/wildfly/wildfly"},{"original_method":"static String[] getJndiBindings(final ModelNode node) {\n        if (node.hasDefined(ENTRIES.getName())) {\n            final Set<String> bindings = new HashSet<String>();\n            for (final ModelNode entry : node.get(ENTRIES.getName()).asList()) {\n                bindings.add(entry.asString());\n            }\n            return bindings.toArray(new String[bindings.size()]);\n        }\n        return NO_BINDINGS;\n    }","id":26476,"modified_method":"public static String[] getJndiBindings(final ModelNode node) {\n        if (node.isDefined()) {\n            final Set<String> bindings = new HashSet<String>();\n            for (final ModelNode entry : node.asList()) {\n                bindings.add(entry.asString());\n            }\n            return bindings.toArray(new String[bindings.size()]);\n        }\n        return NO_BINDINGS;\n    }","commit_id":"5b43edc014be3e76ef58969ebe0b20f935de3985","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, 1, 0);\n        subsystem.registerXMLElementWriter(MessagingSubsystemParser.getInstance());\n\n        boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();\n\n        // Root resource\n        final ManagementResourceRegistration rootRegistration = subsystem.registerSubsystemModel(MessagingSubsystemRootResourceDefinition.INSTANCE);\n        rootRegistration.registerOperationHandler(DESCRIBE, MessagingSubsystemDescribeHandler.INSTANCE, MessagingSubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n        // HQ servers\n        final ManagementResourceRegistration serverRegistration = rootRegistration.registerSubModel(new HornetQServerResourceDefinition(registerRuntimeOnly));\n\n        // TODO convert the remaining resources to ResourceDefinition\n        // Runtime addresses\n        if (registerRuntimeOnly) {\n            final ManagementResourceRegistration coreAddress = serverRegistration.registerSubModel(CORE_ADDRESS_PATH, MessagingSubsystemProviders.CORE_ADDRESS);\n            coreAddress.setRuntimeOnly(true);\n            AddressControlHandler.INSTANCE.register(coreAddress);\n        }\n\n        // Address settings\n        final ManagementResourceRegistration addressSetting = serverRegistration.registerSubModel(ADDRESS_SETTING, MessagingSubsystemProviders.ADDRESS_SETTING);\n        addressSetting.registerOperationHandler(ADD, AddressSettingAdd.INSTANCE, MessagingSubsystemProviders.ADDRESS_SETTING_ADD);\n        addressSetting.registerOperationHandler(REMOVE, AddressSettingRemove.INSTANCE, MessagingSubsystemProviders.ADDRESS_SETTING_REMOVE);\n        AddressSettingsWriteHandler.INSTANCE.registerAttributes(addressSetting, registerRuntimeOnly);\n\n        // Broadcast groups\n        final ManagementResourceRegistration broadcastGroups = serverRegistration.registerSubModel(BROADCAST_GROUP_PATH, MessagingSubsystemProviders.BROADCAST_GROUP_RESOURCE);\n        broadcastGroups.registerOperationHandler(ADD, BroadcastGroupAdd.INSTANCE, BroadcastGroupAdd.INSTANCE);\n        broadcastGroups.registerOperationHandler(REMOVE, BroadcastGroupRemove.INSTANCE, BroadcastGroupRemove.INSTANCE);\n        BroadcastGroupWriteAttributeHandler.INSTANCE.registerAttributes(broadcastGroups, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            BroadcastGroupControlHandler.INSTANCE.register(broadcastGroups);\n        }\n        // getConnectorPairs, -- no, this is just the same as attribute connector-refs\n\n        // Discovery groups\n        final ManagementResourceRegistration discoveryGroups = serverRegistration.registerSubModel(DISCOVERY_GROUP_PATH, MessagingSubsystemProviders.DISCOVERY_GROUP_RESOURCE);\n        discoveryGroups.registerOperationHandler(ADD, DiscoveryGroupAdd.INSTANCE, DiscoveryGroupAdd.INSTANCE);\n        discoveryGroups.registerOperationHandler(REMOVE, DiscoveryGroupRemove.INSTANCE, DiscoveryGroupRemove.INSTANCE);\n        DiscoveryGroupWriteAttributeHandler.INSTANCE.registerAttributes(discoveryGroups, registerRuntimeOnly);\n\n        // Diverts\n        final ManagementResourceRegistration diverts = serverRegistration.registerSubModel(DIVERT_PATH, MessagingSubsystemProviders.DIVERT_RESOURCE);\n        diverts.registerOperationHandler(ADD, DivertAdd.INSTANCE, DivertAdd.INSTANCE);\n        diverts.registerOperationHandler(REMOVE, DivertRemove.INSTANCE, DivertRemove.INSTANCE);\n        DivertConfigurationWriteHandler.INSTANCE.registerAttributes(diverts, registerRuntimeOnly);\n\n        // Core queues\n        final ManagementResourceRegistration queue = serverRegistration.registerSubModel(PathElement.pathElement(QUEUE), MessagingSubsystemProviders.QUEUE_RESOURCE);\n        queue.registerOperationHandler(ADD, QueueAdd.INSTANCE, QueueAdd.INSTANCE, false);\n        queue.registerOperationHandler(REMOVE, QueueRemove.INSTANCE, QueueRemove.INSTANCE, false);\n        QueueConfigurationWriteHandler.INSTANCE.registerAttributes(queue, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            QueueReadAttributeHandler.INSTANCE.registerAttributes(queue);\n            QueueControlHandler.INSTANCE.registerOperations(queue);\n        }\n        // getExpiryAddress, setExpiryAddress, getDeadLetterAddress, setDeadLetterAddress  -- no -- just toggle the 'queue-address', make this a mutable attr of address-setting\n\n        final ManagementResourceRegistration acceptor = serverRegistration.registerSubModel(GENERIC_ACCEPTOR, MessagingSubsystemProviders.ACCEPTOR);\n        acceptor.registerOperationHandler(ADD, TransportConfigOperationHandlers.GENERIC_ADD, MessagingSubsystemProviders.ACCEPTOR_ADD);\n        acceptor.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.ACCEPTOR_REMOVE);\n        TransportConfigOperationHandlers.GENERIC_ATTR.registerAttributes(acceptor, registerRuntimeOnly);\n        createParamRegistration(acceptor);\n        if (registerRuntimeOnly) {\n            AcceptorControlHandler.INSTANCE.register(acceptor);\n        }\n\n\n        // remote acceptor\n        final ManagementResourceRegistration remoteAcceptor = serverRegistration.registerSubModel(REMOTE_ACCEPTOR, MessagingSubsystemProviders.REMOTE_ACCEPTOR);\n        remoteAcceptor.registerOperationHandler(ADD, TransportConfigOperationHandlers.REMOTE_ADD, MessagingSubsystemProviders.REMOTE_ACCEPTOR_ADD);\n        remoteAcceptor.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.ACCEPTOR_REMOVE);\n        TransportConfigOperationHandlers.REMOTE_ATTR.registerAttributes(remoteAcceptor, registerRuntimeOnly);\n        createParamRegistration(remoteAcceptor);\n        if (registerRuntimeOnly) {\n            AcceptorControlHandler.INSTANCE.register(remoteAcceptor);\n        }\n\n        // in-vm acceptor\n        final ManagementResourceRegistration inVMAcceptor = serverRegistration.registerSubModel(IN_VM_ACCEPTOR, MessagingSubsystemProviders.IN_VM_ACCEPTOR);\n        inVMAcceptor.registerOperationHandler(ADD, TransportConfigOperationHandlers.IN_VM_ADD, MessagingSubsystemProviders.IN_VM_ACCEPTOR_ADD);\n        inVMAcceptor.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.ACCEPTOR_REMOVE);\n        TransportConfigOperationHandlers.IN_VM_ATTR.registerAttributes(inVMAcceptor, registerRuntimeOnly);\n        createParamRegistration(inVMAcceptor);\n        if (registerRuntimeOnly) {\n            AcceptorControlHandler.INSTANCE.register(inVMAcceptor);\n        }\n\n        // connector\n        final ManagementResourceRegistration connector = serverRegistration.registerSubModel(GENERIC_CONNECTOR, MessagingSubsystemProviders.CONNECTOR);\n        connector.registerOperationHandler(ADD, TransportConfigOperationHandlers.GENERIC_ADD, MessagingSubsystemProviders.CONNECTOR_ADD);\n        connector.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.CONNECTOR_REMOVE);\n        TransportConfigOperationHandlers.GENERIC_ATTR.registerAttributes(connector, registerRuntimeOnly);\n        createParamRegistration(connector);\n\n        // remote connector\n        final ManagementResourceRegistration remoteConnector = serverRegistration.registerSubModel(REMOTE_CONNECTOR, MessagingSubsystemProviders.REMOTE_CONNECTOR);\n        remoteConnector.registerOperationHandler(ADD, TransportConfigOperationHandlers.REMOTE_ADD, MessagingSubsystemProviders.REMOTE_CONNECTOR_ADD);\n        remoteConnector.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.CONNECTOR_REMOVE);\n        TransportConfigOperationHandlers.REMOTE_ATTR.registerAttributes(remoteConnector, registerRuntimeOnly);\n        createParamRegistration(remoteConnector);\n\n        // in-vm connector\n        final ManagementResourceRegistration inVMConnector = serverRegistration.registerSubModel(IN_VM_CONNECTOR, MessagingSubsystemProviders.IN_VM_CONNECTOR);\n        inVMConnector.registerOperationHandler(ADD, TransportConfigOperationHandlers.IN_VM_ADD, MessagingSubsystemProviders.IN_VM_CONNECTOR_ADD);\n        inVMConnector.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.CONNECTOR_REMOVE);\n        TransportConfigOperationHandlers.IN_VM_ATTR.registerAttributes(inVMConnector, registerRuntimeOnly);\n        createParamRegistration(inVMConnector);\n\n        // Bridges\n        final ManagementResourceRegistration bridge = serverRegistration.registerSubModel(PathElement.pathElement(CommonAttributes.BRIDGE), MessagingSubsystemProviders.BRIDGE_RESOURCE);\n        bridge.registerOperationHandler(ADD, BridgeAdd.INSTANCE, BridgeAdd.INSTANCE, false);\n        bridge.registerOperationHandler(REMOVE, BridgeRemove.INSTANCE, BridgeRemove.INSTANCE, false);\n        BridgeWriteAttributeHandler.INSTANCE.registerAttributes(bridge, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            BridgeControlHandler.INSTANCE.register(bridge);\n        }\n\n        // Cluster connections\n        final ManagementResourceRegistration cluster = serverRegistration.registerSubModel(PathElement.pathElement(CommonAttributes.CLUSTER_CONNECTION),\n                MessagingSubsystemProviders.CLUSTER_CONNECTION_RESOURCE);\n        cluster.registerOperationHandler(ADD, ClusterConnectionAdd.INSTANCE, ClusterConnectionAdd.INSTANCE, false);\n        cluster.registerOperationHandler(REMOVE, ClusterConnectionRemove.INSTANCE, ClusterConnectionRemove.INSTANCE, false);\n        ClusterConnectionWriteAttributeHandler.INSTANCE.registerAttributes(cluster, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            ClusterConnectionControlHandler.INSTANCE.register(cluster);\n        }\n\n        // Grouping Handler\n        final ManagementResourceRegistration groupingHandler = serverRegistration.registerSubModel(GROUPING_HANDLER_PATH, MessagingSubsystemProviders.GROUPING_HANDLER_RESOURCE);\n        groupingHandler.registerOperationHandler(ADD, GroupingHandlerAdd.INSTANCE, GroupingHandlerAdd.INSTANCE);\n        groupingHandler.registerOperationHandler(REMOVE, GroupingHandlerRemove.INSTANCE, GroupingHandlerRemove.INSTANCE);\n        GroupingHandlerWriteAttributeHandler.INSTANCE.registerAttributes(groupingHandler, registerRuntimeOnly);\n\n        // Connector services\n        final ManagementResourceRegistration connectorService = serverRegistration.registerSubModel(PathElement.pathElement(CommonAttributes.CONNECTOR_SERVICE),\n                MessagingSubsystemProviders.CONNECTOR_SERVICE_RESOURCE);\n        connectorService.registerOperationHandler(ADD, ConnectorServiceAdd.INSTANCE, ConnectorServiceAdd.INSTANCE, false);\n        connectorService.registerOperationHandler(REMOVE, ConnectorServiceRemove.INSTANCE, ConnectorServiceRemove.INSTANCE, false);\n        ConnectorServiceWriteAttributeHandler.INSTANCE.registerAttributes(connectorService, registerRuntimeOnly);\n\n        final ManagementResourceRegistration connectorServiceParam = connectorService.registerSubModel(PathElement.pathElement(CommonAttributes.PARAM),\n                MessagingSubsystemProviders.CONNECTOR_SERVICE_PARAM_RESOURCE);\n        connectorServiceParam.registerOperationHandler(ADD, ConnectorServiceParamAdd.INSTANCE, ConnectorServiceParamAdd.INSTANCE, false);\n        connectorServiceParam.registerOperationHandler(REMOVE, ConnectorServiceParamRemove.INSTANCE, ConnectorServiceParamRemove.INSTANCE, false);\n        connectorServiceParam.registerReadWriteAttribute(CommonAttributes.VALUE.getName(), null, ConnectorServiceParamWriteAttributeHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n\n        // Messaging paths\n        for(final String path : CommonAttributes.PATHS) {\n            ManagementResourceRegistration bindings = serverRegistration.registerSubModel(PathElement.pathElement(PATH, path),\n                    new MessagingSubsystemProviders.PathProvider(path));\n            MessagingPathHandlers.register(bindings);\n        }\n\n        // Connection factories\n        final ManagementResourceRegistration cfs = serverRegistration.registerSubModel(CFS_PATH, MessagingSubsystemProviders.CF);\n        cfs.registerOperationHandler(ADD, ConnectionFactoryAdd.INSTANCE, MessagingSubsystemProviders.CF_ADD, false);\n        cfs.registerOperationHandler(REMOVE, ConnectionFactoryRemove.INSTANCE, MessagingSubsystemProviders.CF_REMOVE, false);\n        ConnectionFactoryWriteAttributeHandler.INSTANCE.registerAttributes(cfs);\n        if (registerRuntimeOnly) {\n            ConnectionFactoryReadAttributeHandler.INSTANCE.registerAttributes(cfs);\n        }\n        ConnectionFactoryAddJndiHandler.INSTANCE.registerOperation(cfs);\n        // getJNDIBindings (no -- same as \"entries\")\n\n        // Resource Adapter Pooled connection factories\n        final ManagementResourceRegistration resourceAdapters = serverRegistration.registerSubModel(RA_PATH, MessagingSubsystemProviders.RA);\n        resourceAdapters.registerOperationHandler(ADD, PooledConnectionFactoryAdd.INSTANCE, MessagingSubsystemProviders.RA_ADD, false);\n        resourceAdapters.registerOperationHandler(REMOVE, PooledConnectionFactoryRemove.INSTANCE, MessagingSubsystemProviders.RA_REMOVE);\n        PooledConnectionFactoryWriteAttributeHandler.INSTANCE.registerAttributes(resourceAdapters, registerRuntimeOnly);\n        // TODO how do ConnectionFactoryControl things relate?\n\n        // JMS Queues\n        final ManagementResourceRegistration queues = serverRegistration.registerSubModel(JMS_QUEUE_PATH, MessagingSubsystemProviders.JMS_QUEUE_RESOURCE);\n        queues.registerOperationHandler(ADD, JMSQueueAdd.INSTANCE, JMSQueueAdd.INSTANCE, false);\n        queues.registerOperationHandler(REMOVE, JMSQueueRemove.INSTANCE, JMSQueueRemove.INSTANCE, false);\n        JmsQueueConfigurationWriteHandler.INSTANCE.registerAttributes(queues, registerRuntimeOnly);\n        JMSQueueAddJndiHandler.INSTANCE.registerOperation(queues);\n        if (registerRuntimeOnly) {\n            JmsQueueReadAttributeHandler.INSTANCE.registerAttributes(queues);\n            JMSQueueControlHandler.INSTANCE.registerOperations(queues);\n        }\n        // setExpiryAddress, setDeadLetterAddress  -- no -- just toggle the 'queue-address', make this a mutable attr of address-setting\n        // getJNDIBindings (no -- same as \"entries\")\n\n        // JMS Topics\n        final ManagementResourceRegistration topics = serverRegistration.registerSubModel(TOPIC_PATH, MessagingSubsystemProviders.JMS_TOPIC_RESOURCE);\n        topics.registerOperationHandler(ADD, JMSTopicAdd.INSTANCE, JMSTopicAdd.INSTANCE, false);\n        topics.registerOperationHandler(REMOVE, JMSTopicRemove.INSTANCE, JMSTopicRemove.INSTANCE, false);\n        JMSTopicConfigurationWriteHandler.INSTANCE.registerAttributes(topics);\n        JMSTopicAddJndiHandler.INSTANCE.registerOperation(topics);\n        if (registerRuntimeOnly) {\n            JMSTopicReadAttributeHandler.INSTANCE.registerAttributes(topics);\n            JMSTopicControlHandler.INSTANCE.registerOperations(topics);\n        }\n        // getJNDIBindings (no -- same as \"entries\")\n\n        final ManagementResourceRegistration securitySettings = serverRegistration.registerSubModel(SECURITY_SETTING, MessagingSubsystemProviders.SECURITY_SETTING);\n        securitySettings.registerOperationHandler(ADD, SecuritySettingAdd.INSTANCE, SecuritySettingAdd.INSTANCE);\n        securitySettings.registerOperationHandler(REMOVE, SecuritySettingRemove.INSTANCE, SecuritySettingRemove.INSTANCE);\n\n        final ManagementResourceRegistration securityRole = securitySettings.registerSubModel(SECURITY_ROLE, MessagingSubsystemProviders.SECURITY_ROLE);\n        securityRole.registerOperationHandler(ADD, SecurityRoleAdd.INSTANCE, SecurityRoleAdd.INSTANCE);\n        securityRole.registerOperationHandler(REMOVE, SecurityRoleRemove.INSTANCE, SecurityRoleRemove.INSTANCE);\n        SecurityRoleAttributeHandler.INSTANCE.registerAttributes(securityRole, registerRuntimeOnly);\n    }","id":26477,"modified_method":"public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, 1, 0);\n        subsystem.registerXMLElementWriter(MessagingSubsystemParser.getInstance());\n\n        boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();\n\n        // Root resource\n        final ManagementResourceRegistration rootRegistration = subsystem.registerSubsystemModel(MessagingSubsystemRootResourceDefinition.INSTANCE);\n        rootRegistration.registerOperationHandler(DESCRIBE, MessagingSubsystemDescribeHandler.INSTANCE, MessagingSubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n        // HQ servers\n        final ManagementResourceRegistration serverRegistration = rootRegistration.registerSubModel(new HornetQServerResourceDefinition(registerRuntimeOnly));\n\n        // TODO convert the remaining resources to ResourceDefinition\n        // Runtime addresses\n        if (registerRuntimeOnly) {\n            final ManagementResourceRegistration coreAddress = serverRegistration.registerSubModel(CORE_ADDRESS_PATH, MessagingSubsystemProviders.CORE_ADDRESS);\n            coreAddress.setRuntimeOnly(true);\n            AddressControlHandler.INSTANCE.register(coreAddress);\n        }\n\n        // Address settings\n        final ManagementResourceRegistration addressSetting = serverRegistration.registerSubModel(ADDRESS_SETTING, MessagingSubsystemProviders.ADDRESS_SETTING);\n        addressSetting.registerOperationHandler(ADD, AddressSettingAdd.INSTANCE, MessagingSubsystemProviders.ADDRESS_SETTING_ADD);\n        addressSetting.registerOperationHandler(REMOVE, AddressSettingRemove.INSTANCE, MessagingSubsystemProviders.ADDRESS_SETTING_REMOVE);\n        AddressSettingsWriteHandler.INSTANCE.registerAttributes(addressSetting, registerRuntimeOnly);\n\n        // Broadcast groups\n        final ManagementResourceRegistration broadcastGroups = serverRegistration.registerSubModel(BROADCAST_GROUP_PATH, MessagingSubsystemProviders.BROADCAST_GROUP_RESOURCE);\n        broadcastGroups.registerOperationHandler(ADD, BroadcastGroupAdd.INSTANCE, BroadcastGroupAdd.INSTANCE);\n        broadcastGroups.registerOperationHandler(REMOVE, BroadcastGroupRemove.INSTANCE, BroadcastGroupRemove.INSTANCE);\n        BroadcastGroupWriteAttributeHandler.INSTANCE.registerAttributes(broadcastGroups, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            BroadcastGroupControlHandler.INSTANCE.register(broadcastGroups);\n        }\n        // getConnectorPairs, -- no, this is just the same as attribute connector-refs\n\n        // Discovery groups\n        final ManagementResourceRegistration discoveryGroups = serverRegistration.registerSubModel(DISCOVERY_GROUP_PATH, MessagingSubsystemProviders.DISCOVERY_GROUP_RESOURCE);\n        discoveryGroups.registerOperationHandler(ADD, DiscoveryGroupAdd.INSTANCE, DiscoveryGroupAdd.INSTANCE);\n        discoveryGroups.registerOperationHandler(REMOVE, DiscoveryGroupRemove.INSTANCE, DiscoveryGroupRemove.INSTANCE);\n        DiscoveryGroupWriteAttributeHandler.INSTANCE.registerAttributes(discoveryGroups, registerRuntimeOnly);\n\n        // Diverts\n        final ManagementResourceRegistration diverts = serverRegistration.registerSubModel(DIVERT_PATH, MessagingSubsystemProviders.DIVERT_RESOURCE);\n        diverts.registerOperationHandler(ADD, DivertAdd.INSTANCE, DivertAdd.INSTANCE);\n        diverts.registerOperationHandler(REMOVE, DivertRemove.INSTANCE, DivertRemove.INSTANCE);\n        DivertConfigurationWriteHandler.INSTANCE.registerAttributes(diverts, registerRuntimeOnly);\n\n        // Core queues\n        final ManagementResourceRegistration queue = serverRegistration.registerSubModel(PathElement.pathElement(QUEUE), MessagingSubsystemProviders.QUEUE_RESOURCE);\n        queue.registerOperationHandler(ADD, QueueAdd.INSTANCE, QueueAdd.INSTANCE, false);\n        queue.registerOperationHandler(REMOVE, QueueRemove.INSTANCE, QueueRemove.INSTANCE, false);\n        QueueConfigurationWriteHandler.INSTANCE.registerAttributes(queue, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            QueueReadAttributeHandler.INSTANCE.registerAttributes(queue);\n            QueueControlHandler.INSTANCE.registerOperations(queue);\n        }\n        // getExpiryAddress, setExpiryAddress, getDeadLetterAddress, setDeadLetterAddress  -- no -- just toggle the 'queue-address', make this a mutable attr of address-setting\n\n        final ManagementResourceRegistration acceptor = serverRegistration.registerSubModel(GENERIC_ACCEPTOR, MessagingSubsystemProviders.ACCEPTOR);\n        acceptor.registerOperationHandler(ADD, TransportConfigOperationHandlers.GENERIC_ADD, MessagingSubsystemProviders.ACCEPTOR_ADD);\n        acceptor.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.ACCEPTOR_REMOVE);\n        TransportConfigOperationHandlers.GENERIC_ATTR.registerAttributes(acceptor, registerRuntimeOnly);\n        createParamRegistration(acceptor);\n        if (registerRuntimeOnly) {\n            AcceptorControlHandler.INSTANCE.register(acceptor);\n        }\n\n\n        // remote acceptor\n        final ManagementResourceRegistration remoteAcceptor = serverRegistration.registerSubModel(REMOTE_ACCEPTOR, MessagingSubsystemProviders.REMOTE_ACCEPTOR);\n        remoteAcceptor.registerOperationHandler(ADD, TransportConfigOperationHandlers.REMOTE_ADD, MessagingSubsystemProviders.REMOTE_ACCEPTOR_ADD);\n        remoteAcceptor.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.ACCEPTOR_REMOVE);\n        TransportConfigOperationHandlers.REMOTE_ATTR.registerAttributes(remoteAcceptor, registerRuntimeOnly);\n        createParamRegistration(remoteAcceptor);\n        if (registerRuntimeOnly) {\n            AcceptorControlHandler.INSTANCE.register(remoteAcceptor);\n        }\n\n        // in-vm acceptor\n        final ManagementResourceRegistration inVMAcceptor = serverRegistration.registerSubModel(IN_VM_ACCEPTOR, MessagingSubsystemProviders.IN_VM_ACCEPTOR);\n        inVMAcceptor.registerOperationHandler(ADD, TransportConfigOperationHandlers.IN_VM_ADD, MessagingSubsystemProviders.IN_VM_ACCEPTOR_ADD);\n        inVMAcceptor.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.ACCEPTOR_REMOVE);\n        TransportConfigOperationHandlers.IN_VM_ATTR.registerAttributes(inVMAcceptor, registerRuntimeOnly);\n        createParamRegistration(inVMAcceptor);\n        if (registerRuntimeOnly) {\n            AcceptorControlHandler.INSTANCE.register(inVMAcceptor);\n        }\n\n        // connector\n        final ManagementResourceRegistration connector = serverRegistration.registerSubModel(GENERIC_CONNECTOR, MessagingSubsystemProviders.CONNECTOR);\n        connector.registerOperationHandler(ADD, TransportConfigOperationHandlers.GENERIC_ADD, MessagingSubsystemProviders.CONNECTOR_ADD);\n        connector.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.CONNECTOR_REMOVE);\n        TransportConfigOperationHandlers.GENERIC_ATTR.registerAttributes(connector, registerRuntimeOnly);\n        createParamRegistration(connector);\n\n        // remote connector\n        final ManagementResourceRegistration remoteConnector = serverRegistration.registerSubModel(REMOTE_CONNECTOR, MessagingSubsystemProviders.REMOTE_CONNECTOR);\n        remoteConnector.registerOperationHandler(ADD, TransportConfigOperationHandlers.REMOTE_ADD, MessagingSubsystemProviders.REMOTE_CONNECTOR_ADD);\n        remoteConnector.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.CONNECTOR_REMOVE);\n        TransportConfigOperationHandlers.REMOTE_ATTR.registerAttributes(remoteConnector, registerRuntimeOnly);\n        createParamRegistration(remoteConnector);\n\n        // in-vm connector\n        final ManagementResourceRegistration inVMConnector = serverRegistration.registerSubModel(IN_VM_CONNECTOR, MessagingSubsystemProviders.IN_VM_CONNECTOR);\n        inVMConnector.registerOperationHandler(ADD, TransportConfigOperationHandlers.IN_VM_ADD, MessagingSubsystemProviders.IN_VM_CONNECTOR_ADD);\n        inVMConnector.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.CONNECTOR_REMOVE);\n        TransportConfigOperationHandlers.IN_VM_ATTR.registerAttributes(inVMConnector, registerRuntimeOnly);\n        createParamRegistration(inVMConnector);\n\n        // Bridges\n        final ManagementResourceRegistration bridge = serverRegistration.registerSubModel(PathElement.pathElement(CommonAttributes.BRIDGE), MessagingSubsystemProviders.BRIDGE_RESOURCE);\n        bridge.registerOperationHandler(ADD, BridgeAdd.INSTANCE, BridgeAdd.INSTANCE, false);\n        bridge.registerOperationHandler(REMOVE, BridgeRemove.INSTANCE, BridgeRemove.INSTANCE, false);\n        BridgeWriteAttributeHandler.INSTANCE.registerAttributes(bridge, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            BridgeControlHandler.INSTANCE.register(bridge);\n        }\n\n        // Cluster connections\n        final ManagementResourceRegistration cluster = serverRegistration.registerSubModel(PathElement.pathElement(CommonAttributes.CLUSTER_CONNECTION),\n                MessagingSubsystemProviders.CLUSTER_CONNECTION_RESOURCE);\n        cluster.registerOperationHandler(ADD, ClusterConnectionAdd.INSTANCE, ClusterConnectionAdd.INSTANCE, false);\n        cluster.registerOperationHandler(REMOVE, ClusterConnectionRemove.INSTANCE, ClusterConnectionRemove.INSTANCE, false);\n        ClusterConnectionWriteAttributeHandler.INSTANCE.registerAttributes(cluster, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            ClusterConnectionControlHandler.INSTANCE.register(cluster);\n        }\n\n        // Grouping Handler\n        final ManagementResourceRegistration groupingHandler = serverRegistration.registerSubModel(GROUPING_HANDLER_PATH, MessagingSubsystemProviders.GROUPING_HANDLER_RESOURCE);\n        groupingHandler.registerOperationHandler(ADD, GroupingHandlerAdd.INSTANCE, GroupingHandlerAdd.INSTANCE);\n        groupingHandler.registerOperationHandler(REMOVE, GroupingHandlerRemove.INSTANCE, GroupingHandlerRemove.INSTANCE);\n        GroupingHandlerWriteAttributeHandler.INSTANCE.registerAttributes(groupingHandler, registerRuntimeOnly);\n\n        // Connector services\n        final ManagementResourceRegistration connectorService = serverRegistration.registerSubModel(PathElement.pathElement(CommonAttributes.CONNECTOR_SERVICE),\n                MessagingSubsystemProviders.CONNECTOR_SERVICE_RESOURCE);\n        connectorService.registerOperationHandler(ADD, ConnectorServiceAdd.INSTANCE, ConnectorServiceAdd.INSTANCE, false);\n        connectorService.registerOperationHandler(REMOVE, ConnectorServiceRemove.INSTANCE, ConnectorServiceRemove.INSTANCE, false);\n        ConnectorServiceWriteAttributeHandler.INSTANCE.registerAttributes(connectorService, registerRuntimeOnly);\n\n        final ManagementResourceRegistration connectorServiceParam = connectorService.registerSubModel(PathElement.pathElement(CommonAttributes.PARAM),\n                MessagingSubsystemProviders.CONNECTOR_SERVICE_PARAM_RESOURCE);\n        connectorServiceParam.registerOperationHandler(ADD, ConnectorServiceParamAdd.INSTANCE, ConnectorServiceParamAdd.INSTANCE, false);\n        connectorServiceParam.registerOperationHandler(REMOVE, ConnectorServiceParamRemove.INSTANCE, ConnectorServiceParamRemove.INSTANCE, false);\n        connectorServiceParam.registerReadWriteAttribute(CommonAttributes.VALUE.getName(), null, ConnectorServiceParamWriteAttributeHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n\n        // Messaging paths\n        for (final String path : CommonAttributes.PATHS) {\n            ManagementResourceRegistration bindings = serverRegistration.registerSubModel(PathElement.pathElement(PATH, path),\n                    new MessagingSubsystemProviders.PathProvider(path));\n            MessagingPathHandlers.register(bindings);\n        }\n\n        // Connection factories\n        final ManagementResourceRegistration cfs = serverRegistration.registerSubModel(CFS_PATH, MessagingSubsystemProviders.CF);\n        cfs.registerOperationHandler(ADD, ConnectionFactoryAdd.INSTANCE, MessagingSubsystemProviders.CF_ADD, false);\n        cfs.registerOperationHandler(REMOVE, ConnectionFactoryRemove.INSTANCE, MessagingSubsystemProviders.CF_REMOVE, false);\n        ConnectionFactoryWriteAttributeHandler.INSTANCE.registerAttributes(cfs);\n        if (registerRuntimeOnly) {\n            ConnectionFactoryReadAttributeHandler.INSTANCE.registerAttributes(cfs);\n        }\n        ConnectionFactoryAddJndiHandler.INSTANCE.registerOperation(cfs);\n        // getJNDIBindings (no -- same as \"entries\")\n\n        // Resource Adapter Pooled connection factories\n        final ManagementResourceRegistration resourceAdapters = serverRegistration.registerSubModel(RA_PATH, MessagingSubsystemProviders.RA);\n        resourceAdapters.registerOperationHandler(ADD, PooledConnectionFactoryAdd.INSTANCE, MessagingSubsystemProviders.RA_ADD, false);\n        resourceAdapters.registerOperationHandler(REMOVE, PooledConnectionFactoryRemove.INSTANCE, MessagingSubsystemProviders.RA_REMOVE);\n        PooledConnectionFactoryWriteAttributeHandler.INSTANCE.registerAttributes(resourceAdapters, registerRuntimeOnly);\n        // TODO how do ConnectionFactoryControl things relate?\n\n        // JMS Queues\n        final ManagementResourceRegistration queues = serverRegistration.registerSubModel(JMS_QUEUE_PATH, MessagingSubsystemProviders.JMS_QUEUE_RESOURCE);\n        queues.registerOperationHandler(ADD, JMSQueueAdd.INSTANCE, JMSQueueAdd.INSTANCE, false);\n        queues.registerOperationHandler(REMOVE, JMSQueueRemove.INSTANCE, JMSQueueRemove.INSTANCE, false);\n        JmsQueueConfigurationWriteHandler.INSTANCE.registerAttributes(queues, registerRuntimeOnly);\n        JMSQueueAddJndiHandler.INSTANCE.registerOperation(queues);\n        if (registerRuntimeOnly) {\n            JmsQueueReadAttributeHandler.INSTANCE.registerAttributes(queues);\n            JMSQueueControlHandler.INSTANCE.registerOperations(queues);\n        }\n        // setExpiryAddress, setDeadLetterAddress  -- no -- just toggle the 'queue-address', make this a mutable attr of address-setting\n        // getJNDIBindings (no -- same as \"entries\")\n\n        // JMS Topics\n        final ManagementResourceRegistration topics = serverRegistration.registerSubModel(TOPIC_PATH, MessagingSubsystemProviders.JMS_TOPIC_RESOURCE);\n        topics.registerOperationHandler(ADD, JMSTopicAdd.INSTANCE, JMSTopicAdd.INSTANCE, false);\n        topics.registerOperationHandler(REMOVE, JMSTopicRemove.INSTANCE, JMSTopicRemove.INSTANCE, false);\n        JMSTopicConfigurationWriteHandler.INSTANCE.registerAttributes(topics);\n        JMSTopicAddJndiHandler.INSTANCE.registerOperation(topics);\n        if (registerRuntimeOnly) {\n            JMSTopicReadAttributeHandler.INSTANCE.registerAttributes(topics);\n            JMSTopicControlHandler.INSTANCE.registerOperations(topics);\n        }\n        // getJNDIBindings (no -- same as \"entries\")\n\n        final ManagementResourceRegistration securitySettings = serverRegistration.registerSubModel(SECURITY_SETTING, MessagingSubsystemProviders.SECURITY_SETTING);\n        securitySettings.registerOperationHandler(ADD, SecuritySettingAdd.INSTANCE, SecuritySettingAdd.INSTANCE);\n        securitySettings.registerOperationHandler(REMOVE, SecuritySettingRemove.INSTANCE, SecuritySettingRemove.INSTANCE);\n\n        final ManagementResourceRegistration securityRole = securitySettings.registerSubModel(SECURITY_ROLE, MessagingSubsystemProviders.SECURITY_ROLE);\n        securityRole.registerOperationHandler(ADD, SecurityRoleAdd.INSTANCE, SecurityRoleAdd.INSTANCE);\n        securityRole.registerOperationHandler(REMOVE, SecurityRoleRemove.INSTANCE, SecurityRoleRemove.INSTANCE);\n        SecurityRoleAttributeHandler.INSTANCE.registerAttributes(securityRole, registerRuntimeOnly);\n\n        if (context.isRuntimeOnlyRegistrationValid()) {\n\n            ResourceDefinition deploymentsDef = new SimpleResourceDefinition(PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM, SUBSYSTEM_NAME), getResourceDescriptionResolver(\"deployed\"));\n            final ManagementResourceRegistration deploymentsRegistration = subsystem.registerDeploymentModel(deploymentsDef);\n            final ManagementResourceRegistration serverModel = deploymentsRegistration.registerSubModel(DeploymentHornetQServerResourceDefinition.INSTANCE);\n\n            // JMS Queues\n            final ManagementResourceRegistration deploymentQueue = serverModel.registerSubModel(JMS_QUEUE_PATH, MessagingSubsystemProviders.JMS_QUEUE_RESOURCE);\n            JmsQueueReadAttributeHandler.INSTANCE.registerAttributes(deploymentQueue);\n            JMSQueueControlHandler.INSTANCE.registerOperations(deploymentQueue);\n\n            // topics\n            final ManagementResourceRegistration deploymentTopics = serverModel.registerSubModel(TOPIC_PATH, MessagingSubsystemProviders.JMS_TOPIC_RESOURCE);\n            JMSTopicReadAttributeHandler.INSTANCE.registerAttributes(deploymentTopics);\n            JMSTopicControlHandler.INSTANCE.registerOperations(deploymentTopics);\n\n        }\n    }","commit_id":"5b43edc014be3e76ef58969ebe0b20f935de3985","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static int getLineIndentSize(@NotNull CharSequence line) {\n    return getLineIndent(line).length();\n  }","id":26478,"modified_method":"/**\n   * Returns indentation size as number of characters <tt>' '<\/tt> and <tt>'\\t'<\/tt> in the beginning of a line. \n   * It doesn't perform any expansion of tabs.\n   */\n  public static int getLineIndentSize(@NotNull CharSequence line) {\n    int stop;\n    for (stop = 0; stop < line.length(); stop++) {\n      final char c = line.charAt(stop);\n      if (!(c == ' ' || c == '\\t')) {\n        break;\n      }\n    }\n    return stop;\n  }","commit_id":"511fabfcf66e99104aa710049973ac18afb1de55","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static int getIndentSizeFromSettings(@NotNull Project project) {\n    final CodeStyleSettings codeStyleSettings = CodeStyleSettingsManager.getInstance(project).getCurrentSettings();\n    final CodeStyleSettings.IndentOptions indentOptions = codeStyleSettings.getIndentOptions(PythonFileType.INSTANCE);\n    return indentOptions.INDENT_SIZE;\n  }","id":26479,"modified_method":"/**\n   * Returns indentation size configured in the Python code style settings.\n   * \n   * @see #getIndentFromSettings(Project) \n   */\n  public static int getIndentSizeFromSettings(@NotNull Project project) {\n    final CodeStyleSettings codeStyleSettings = CodeStyleSettingsManager.getInstance(project).getCurrentSettings();\n    final CodeStyleSettings.IndentOptions indentOptions = codeStyleSettings.getIndentOptions(PythonFileType.INSTANCE);\n    return indentOptions.INDENT_SIZE;\n  }","commit_id":"511fabfcf66e99104aa710049973ac18afb1de55","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * If lines include non-empty lines, all empty lines or lines that contain only spaces are ignored.\n   * Otherwise (all line are empty) their common indent are returned as expected. If any two lines\n   * have different indentation (e.g. one contains tab character and another doesn't), empty prefix\n   * is returned.\n   */\n  @NotNull\n  public static String findCommonIndent(@NotNull Iterable<String> lines, boolean ignoreFirstLine) {\n    String minIndent = null;\n    boolean allLinesEmpty = true;\n    if (Iterables.isEmpty(lines)) {\n      return \"\";\n    }\n    boolean hasBadEmptyLineIndent = false;\n    for (String line : Iterables.skip(lines, ignoreFirstLine ? 1 : 0)) {\n      final boolean lineEmpty = StringUtil.isEmptyOrSpaces(line);\n      if (lineEmpty && !allLinesEmpty) {\n        continue;\n      }\n      final String indent = (String)getLineIndent(line);\n      if (minIndent == null || (!lineEmpty && allLinesEmpty) || minIndent.startsWith(indent)) {\n        minIndent = indent;\n      }\n      else if (!indent.startsWith(minIndent)) {\n        if (lineEmpty) {\n          hasBadEmptyLineIndent = true;\n        }\n        else {\n          return \"\";\n        }\n      }\n      allLinesEmpty &= lineEmpty;\n    }\n    if (allLinesEmpty && hasBadEmptyLineIndent) {\n      return \"\";\n    }\n    return StringUtil.notNullize(minIndent);\n  }","id":26480,"modified_method":"/**\n   * Finds maximum common indentation of the given lines. Indentation of empty lines and lines containing only whitespaces is ignored unless\n   * they're the only lines provided. In the latter case common indentation for such lines is returned. If mix of tabs and spaces was used\n   * for indentation and any two of lines taken into account contain incompatible combination of these symbols, i.e. it's impossible to \n   * decide which one can be used as prefix for another, empty string is returned.\n   *\n   * @param ignoreFirstLine whether the first line should be considered (useful for multiline string literals)\n   */\n  @NotNull\n  public static String findCommonIndent(@NotNull Iterable<String> lines, boolean ignoreFirstLine) {\n    String minIndent = null;\n    boolean allLinesEmpty = true;\n    if (Iterables.isEmpty(lines)) {\n      return \"\";\n    }\n    boolean hasBadEmptyLineIndent = false;\n    for (String line : Iterables.skip(lines, ignoreFirstLine ? 1 : 0)) {\n      final boolean lineEmpty = StringUtil.isEmptyOrSpaces(line);\n      if (lineEmpty && !allLinesEmpty) {\n        continue;\n      }\n      final String indent = getLineIndent(line);\n      if (minIndent == null || (!lineEmpty && allLinesEmpty) || minIndent.startsWith(indent)) {\n        minIndent = indent;\n      }\n      else if (!indent.startsWith(minIndent)) {\n        if (lineEmpty) {\n          hasBadEmptyLineIndent = true;\n        }\n        else {\n          return \"\";\n        }\n      }\n      allLinesEmpty &= lineEmpty;\n    }\n    if (allLinesEmpty && hasBadEmptyLineIndent) {\n      return \"\";\n    }\n    return StringUtil.notNullize(minIndent);\n  }","commit_id":"511fabfcf66e99104aa710049973ac18afb1de55","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static String getIndentFromSettings(@NotNull Project project) {\n    return StringUtil.repeatSymbol(' ', getIndentSizeFromSettings(project));\n  }","id":26481,"modified_method":"/**\n   * Returns indentation configured in the Python code style settings as plain space character repeated number times specified there.\n   * Note that it doesn't take into account usage of tab characters that might be configured there as well.\n   * \n   * @see #getIndentSizeFromSettings(Project) \n   */\n  @NotNull\n  public static String getIndentFromSettings(@NotNull Project project) {\n    return StringUtil.repeatSymbol(' ', getIndentSizeFromSettings(project));\n  }","commit_id":"511fabfcf66e99104aa710049973ac18afb1de55","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static String getLineIndent(@NotNull Document document, int lineNumber) {\n    final TextRange lineRange = TextRange.create(document.getLineStartOffset(lineNumber), document.getLineEndOffset(lineNumber));\n    final String line = document.getText(lineRange);\n    return (String)getLineIndent(line);\n  }","id":26482,"modified_method":"@NotNull\n  public static String getLineIndent(@NotNull Document document, int lineNumber) {\n    final TextRange lineRange = TextRange.create(document.getLineStartOffset(lineNumber), document.getLineEndOffset(lineNumber));\n    final String line = document.getText(lineRange);\n    return getLineIndent(line);\n  }","commit_id":"511fabfcf66e99104aa710049973ac18afb1de55","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static CharSequence getLineIndent(@NotNull CharSequence line) {\n    int stop;\n    for (stop = 0; stop < line.length(); stop++) {\n      final char c = line.charAt(stop);\n      if (!(c == ' ' || c == '\\t')) {\n        break;\n      }\n    }\n    return line.subSequence(0, stop);\n  }","id":26483,"modified_method":"/**\n   * Useful version of {@link #getLineIndent(String)} for custom character sequences like {@link com.jetbrains.python.toolbox.Substring}.\n   */\n  @NotNull\n  public static CharSequence getLineIndent(@NotNull CharSequence line) {\n    return line.subSequence(0, getLineIndentSize(line));\n  }","commit_id":"511fabfcf66e99104aa710049973ac18afb1de55","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static DocstringState canGenerateDocstring(@NotNull PsiElement element, int firstQuoteOffset, @NotNull Document document) {\n    if (firstQuoteOffset < 0 || firstQuoteOffset > document.getTextLength() - 3) {\n      return DocstringState.NONE;\n    }\n    final String quotes = document.getText(TextRange.from(firstQuoteOffset, 3));\n    if (!quotes.equals(\"\\\"\\\"\\\"\") && !quotes.equals(\"'''\")) {\n      return DocstringState.NONE;\n    }\n    final PyStringLiteralExpression pyString = DocStringUtil.getParentDefinitionDocString(element);\n    if (pyString != null) {\n\n      String nodeText = element.getText();\n      final int prefixLength = PyStringLiteralExpressionImpl.getPrefixLength(nodeText);\n      nodeText = nodeText.substring(prefixLength);\n\n      final String literalText = pyString.getText();\n      if (literalText.endsWith(nodeText) && nodeText.startsWith(quotes)) {\n        if (firstQuoteOffset == pyString.getTextOffset() + prefixLength) {\n          PsiErrorElement error = PsiTreeUtil.getNextSiblingOfType(pyString, PsiErrorElement.class);\n          if (error == null) {\n            error = PsiTreeUtil.getNextSiblingOfType(pyString.getParent(), PsiErrorElement.class);\n          }\n          if (error != null) {\n            return DocstringState.INCOMPLETE;\n          }\n  \n          if (nodeText.equals(quotes + quotes)) {\n            return DocstringState.EMPTY;\n          }\n  \n          if (nodeText.length() < 6 || !nodeText.endsWith(quotes)) {\n            return DocstringState.INCOMPLETE;\n          }\n          // Sometimes if incomplete docstring is followed by another declaration with a docstring, it might be treated\n          // as complete docstring, because we can't understand that closing quotes actually belong to another docstring.\n          final String docstringIndent = PyIndentUtil.getLineIndent(document, document.getLineNumber(firstQuoteOffset));\n          for (String line : LineTokenizer.tokenizeIntoList(nodeText, false)) {\n            final String lineIndent = (String)PyIndentUtil.getLineIndent(line);\n            final String lineContent = line.substring(lineIndent.length());\n            if ((lineContent.startsWith(\"def \") || lineContent.startsWith(\"class \")) &&\n                docstringIndent.length() > lineIndent.length() && docstringIndent.startsWith(lineIndent)) {\n              return DocstringState.INCOMPLETE;\n            }\n          }\n        }\n      }\n    }\n    return DocstringState.NONE;\n  }","id":26484,"modified_method":"@NotNull\n  public static DocstringState canGenerateDocstring(@NotNull PsiElement element, int firstQuoteOffset, @NotNull Document document) {\n    if (firstQuoteOffset < 0 || firstQuoteOffset > document.getTextLength() - 3) {\n      return DocstringState.NONE;\n    }\n    final String quotes = document.getText(TextRange.from(firstQuoteOffset, 3));\n    if (!quotes.equals(\"\\\"\\\"\\\"\") && !quotes.equals(\"'''\")) {\n      return DocstringState.NONE;\n    }\n    final PyStringLiteralExpression pyString = DocStringUtil.getParentDefinitionDocString(element);\n    if (pyString != null) {\n\n      String nodeText = element.getText();\n      final int prefixLength = PyStringLiteralExpressionImpl.getPrefixLength(nodeText);\n      nodeText = nodeText.substring(prefixLength);\n\n      final String literalText = pyString.getText();\n      if (literalText.endsWith(nodeText) && nodeText.startsWith(quotes)) {\n        if (firstQuoteOffset == pyString.getTextOffset() + prefixLength) {\n          PsiErrorElement error = PsiTreeUtil.getNextSiblingOfType(pyString, PsiErrorElement.class);\n          if (error == null) {\n            error = PsiTreeUtil.getNextSiblingOfType(pyString.getParent(), PsiErrorElement.class);\n          }\n          if (error != null) {\n            return DocstringState.INCOMPLETE;\n          }\n  \n          if (nodeText.equals(quotes + quotes)) {\n            return DocstringState.EMPTY;\n          }\n  \n          if (nodeText.length() < 6 || !nodeText.endsWith(quotes)) {\n            return DocstringState.INCOMPLETE;\n          }\n          // Sometimes if incomplete docstring is followed by another declaration with a docstring, it might be treated\n          // as complete docstring, because we can't understand that closing quotes actually belong to another docstring.\n          final String docstringIndent = PyIndentUtil.getLineIndent(document, document.getLineNumber(firstQuoteOffset));\n          for (String line : LineTokenizer.tokenizeIntoList(nodeText, false)) {\n            final String lineIndent = PyIndentUtil.getLineIndent(line);\n            final String lineContent = line.substring(lineIndent.length());\n            if ((lineContent.startsWith(\"def \") || lineContent.startsWith(\"class \")) &&\n                docstringIndent.length() > lineIndent.length() && docstringIndent.startsWith(lineIndent)) {\n              return DocstringState.INCOMPLETE;\n            }\n          }\n        }\n      }\n    }\n    return DocstringState.NONE;\n  }","commit_id":"511fabfcf66e99104aa710049973ac18afb1de55","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected byte[] URLtoByteArray(\n\t\t\tString location, Http.Method method, Map<String, String> headers,\n\t\t\tCookie[] cookies, Http.Auth auth, Http.Body body,\n\t\t\tList<Http.FilePart> fileParts, Map<String, String> parts,\n\t\t\tHttp.Response response, boolean followRedirects)\n\t\tthrows IOException {\n\n\t\tbyte[] bytes = null;\n\n\t\tHttpMethod httpMethod = null;\n\t\tHttpState httpState = null;\n\n\t\ttry {\n\t\t\t_cookies.set(null);\n\n\t\t\tif (location == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (!location.startsWith(Http.HTTP_WITH_SLASH) &&\n\t\t\t\t\t !location.startsWith(Http.HTTPS_WITH_SLASH)) {\n\n\t\t\t\tlocation = Http.HTTP_WITH_SLASH + location;\n\t\t\t}\n\n\t\t\tHostConfiguration hostConfiguration = getHostConfiguration(\n\t\t\t\tlocation);\n\n\t\t\tHttpClient httpClient = getClient(hostConfiguration);\n\n\t\t\tif (method.equals(Http.Method.POST) ||\n\t\t\t\tmethod.equals(Http.Method.PUT)) {\n\n\t\t\t\tif (method.equals(Http.Method.POST)) {\n\t\t\t\t\thttpMethod = new PostMethod(location);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thttpMethod = new PutMethod(location);\n\t\t\t\t}\n\n\t\t\t\tif (body != null) {\n\t\t\t\t\tRequestEntity requestEntity = new StringRequestEntity(\n\t\t\t\t\t\tbody.getContent(), body.getContentType(),\n\t\t\t\t\t\tbody.getCharset());\n\n\t\t\t\t\tEntityEnclosingMethod entityEnclosingMethod =\n\t\t\t\t\t\t(EntityEnclosingMethod)httpMethod;\n\n\t\t\t\t\tentityEnclosingMethod.setRequestEntity(requestEntity);\n\t\t\t\t}\n\t\t\t\telse if (method.equals(Http.Method.POST)) {\n\t\t\t\t\tPostMethod postMethod = (PostMethod)httpMethod;\n\n\t\t\t\t\tpostMethod.addRequestHeader(\n\t\t\t\t\t\tHttpHeaders.CONTENT_TYPE,\n\t\t\t\t\t\tContentTypes.APPLICATION_X_WWW_FORM_URLENCODED);\n\n\t\t\t\t\tprocessPostMethod(postMethod, fileParts, parts);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (method.equals(Http.Method.DELETE)) {\n\t\t\t\thttpMethod = new DeleteMethod(location);\n\t\t\t}\n\t\t\telse if (method.equals(Http.Method.HEAD)) {\n\t\t\t\thttpMethod = new HeadMethod(location);\n\t\t\t}\n\t\t\telse {\n\t\t\t\thttpMethod = new GetMethod(location);\n\t\t\t}\n\n\t\t\tif (headers != null) {\n\t\t\t\tfor (Map.Entry<String, String> header : headers.entrySet()) {\n\t\t\t\t\thttpMethod.addRequestHeader(\n\t\t\t\t\t\theader.getKey(), header.getValue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((method.equals(Http.Method.POST) ||\n\t\t\t\t method.equals(Http.Method.PUT)) &&\n\t\t\t\t((body != null) ||\n\t\t\t\t ((fileParts != null) && !fileParts.isEmpty()) |\n\t\t\t\t ((parts != null) && !parts.isEmpty()))) {\n\t\t\t}\n\t\t\telse if (!hasRequestHeader(httpMethod, HttpHeaders.CONTENT_TYPE)) {\n\t\t\t\thttpMethod.addRequestHeader(\n\t\t\t\t\tHttpHeaders.CONTENT_TYPE,\n\t\t\t\t\tContentTypes.APPLICATION_X_WWW_FORM_URLENCODED);\n\t\t\t}\n\n\t\t\tif (!hasRequestHeader(httpMethod, HttpHeaders.USER_AGENT)) {\n\t\t\t\thttpMethod.addRequestHeader(\n\t\t\t\t\tHttpHeaders.USER_AGENT, _DEFAULT_USER_AGENT);\n\t\t\t}\n\n\t\t\thttpState = new HttpState();\n\n\t\t\tif ((cookies != null) && (cookies.length > 0)) {\n\t\t\t\torg.apache.commons.httpclient.Cookie[] commonsCookies =\n\t\t\t\t\ttoCommonsCookies(cookies);\n\n\t\t\t\thttpState.addCookies(commonsCookies);\n\n\t\t\t\tHttpMethodParams httpMethodParams = httpMethod.getParams();\n\n\t\t\t\thttpMethodParams.setCookiePolicy(\n\t\t\t\t\tCookiePolicy.BROWSER_COMPATIBILITY);\n\t\t\t}\n\n\t\t\tif (auth != null) {\n\t\t\t\thttpMethod.setDoAuthentication(true);\n\n\t\t\t\thttpState.setCredentials(\n\t\t\t\t\tnew AuthScope(\n\t\t\t\t\t\tauth.getHost(), auth.getPort(), auth.getRealm()),\n\t\t\t\t\tnew UsernamePasswordCredentials(\n\t\t\t\t\t\tauth.getUsername(), auth.getPassword()));\n\t\t\t}\n\n\t\t\tproxifyState(httpState, hostConfiguration);\n\n\t\t\tboolean checkReadFileDescriptor =\n\t\t\t\tPortalSecurityManagerThreadLocal.isCheckReadFileDescriptor();\n\t\t\tboolean checkWriteFileDescriptor =\n\t\t\t\tPortalSecurityManagerThreadLocal.isCheckWriteFileDescriptor();\n\n\t\t\ttry {\n\t\t\t\tPortalSecurityManagerThreadLocal.setCheckReadFileDescriptor(\n\t\t\t\t\tfalse);\n\t\t\t\tPortalSecurityManagerThreadLocal.setCheckWriteFileDescriptor(\n\t\t\t\t\tfalse);\n\n\t\t\t\thttpClient.executeMethod(\n\t\t\t\t\thostConfiguration, httpMethod, httpState);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tPortalSecurityManagerThreadLocal.setCheckReadFileDescriptor(\n\t\t\t\t\tcheckReadFileDescriptor);\n\t\t\t\tPortalSecurityManagerThreadLocal.setCheckWriteFileDescriptor(\n\t\t\t\t\tcheckWriteFileDescriptor);\n\t\t\t}\n\n\t\t\tHeader locationHeader = httpMethod.getResponseHeader(\"location\");\n\n\t\t\tif ((locationHeader != null) && !locationHeader.equals(location)) {\n\t\t\t\tString redirect = locationHeader.getValue();\n\n\t\t\t\tif (followRedirects) {\n\t\t\t\t\treturn URLtoByteArray(\n\t\t\t\t\t\tredirect, Http.Method.GET, headers, cookies, auth, body,\n\t\t\t\t\t\tfileParts, parts, response, followRedirects);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresponse.setRedirect(redirect);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tInputStream inputStream = httpMethod.getResponseBodyAsStream();\n\n\t\t\tif (inputStream != null) {\n\t\t\t\tHeader contentLength = httpMethod.getResponseHeader(\n\t\t\t\t\tHttpHeaders.CONTENT_LENGTH);\n\n\t\t\t\tif (contentLength != null) {\n\t\t\t\t\tresponse.setContentLength(\n\t\t\t\t\t\tGetterUtil.getInteger(contentLength.getValue()));\n\t\t\t\t}\n\n\t\t\t\tHeader contentType = httpMethod.getResponseHeader(\n\t\t\t\t\tHttpHeaders.CONTENT_TYPE);\n\n\t\t\t\tif (contentType != null) {\n\t\t\t\t\tresponse.setContentType(contentType.getValue());\n\t\t\t\t}\n\n\t\t\t\tbytes = FileUtil.getBytes(inputStream);\n\t\t\t}\n\n\t\t\tfor (Header header : httpMethod.getResponseHeaders()) {\n\t\t\t\tresponse.addHeader(header.getName(), header.getValue());\n\t\t\t}\n\n\t\t\treturn bytes;\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (httpState != null) {\n\t\t\t\t\t_cookies.set(toServletCookies(httpState.getCookies()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (httpMethod != null) {\n\t\t\t\t\thttpMethod.releaseConnection();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\t}","id":26485,"modified_method":"protected byte[] URLtoByteArray(\n\t\t\tString location, Http.Method method, Map<String, String> headers,\n\t\t\tCookie[] cookies, Http.Auth auth, Http.Body body,\n\t\t\tList<Http.FilePart> fileParts, Map<String, String> parts,\n\t\t\tHttp.Response response, boolean followRedirects)\n\t\tthrows IOException {\n\n\t\tbyte[] bytes = null;\n\n\t\tHttpMethod httpMethod = null;\n\t\tHttpState httpState = null;\n\n\t\ttry {\n\t\t\t_cookies.set(null);\n\n\t\t\tif (location == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (!location.startsWith(Http.HTTP_WITH_SLASH) &&\n\t\t\t\t\t !location.startsWith(Http.HTTPS_WITH_SLASH)) {\n\n\t\t\t\tlocation = Http.HTTP_WITH_SLASH + location;\n\t\t\t}\n\n\t\t\tHostConfiguration hostConfiguration = getHostConfiguration(\n\t\t\t\tlocation);\n\n\t\t\tHttpClient httpClient = getClient(hostConfiguration);\n\n\t\t\tif (method.equals(Http.Method.POST) ||\n\t\t\t\tmethod.equals(Http.Method.PUT)) {\n\n\t\t\t\tif (method.equals(Http.Method.POST)) {\n\t\t\t\t\thttpMethod = new PostMethod(location);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thttpMethod = new PutMethod(location);\n\t\t\t\t}\n\n\t\t\t\tif (body != null) {\n\t\t\t\t\tRequestEntity requestEntity = new StringRequestEntity(\n\t\t\t\t\t\tbody.getContent(), body.getContentType(),\n\t\t\t\t\t\tbody.getCharset());\n\n\t\t\t\t\tEntityEnclosingMethod entityEnclosingMethod =\n\t\t\t\t\t\t(EntityEnclosingMethod)httpMethod;\n\n\t\t\t\t\tentityEnclosingMethod.setRequestEntity(requestEntity);\n\t\t\t\t}\n\t\t\t\telse if (method.equals(Http.Method.POST)) {\n\t\t\t\t\tPostMethod postMethod = (PostMethod)httpMethod;\n\n\t\t\t\t\tif (!hasRequestHeader(\n\t\t\t\t\t\t\tpostMethod, HttpHeaders.CONTENT_TYPE)) {\n\n\t\t\t\t\t\tpostMethod.addRequestHeader(\n\t\t\t\t\t\t\tHttpHeaders.CONTENT_TYPE,\n\t\t\t\t\t\t\tContentTypes.APPLICATION_X_WWW_FORM_URLENCODED);\n\t\t\t\t\t}\n\n\t\t\t\t\tprocessPostMethod(postMethod, fileParts, parts);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (method.equals(Http.Method.DELETE)) {\n\t\t\t\thttpMethod = new DeleteMethod(location);\n\t\t\t}\n\t\t\telse if (method.equals(Http.Method.HEAD)) {\n\t\t\t\thttpMethod = new HeadMethod(location);\n\t\t\t}\n\t\t\telse {\n\t\t\t\thttpMethod = new GetMethod(location);\n\t\t\t}\n\n\t\t\tif (headers != null) {\n\t\t\t\tfor (Map.Entry<String, String> header : headers.entrySet()) {\n\t\t\t\t\thttpMethod.addRequestHeader(\n\t\t\t\t\t\theader.getKey(), header.getValue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((method.equals(Http.Method.POST) ||\n\t\t\t\t method.equals(Http.Method.PUT)) &&\n\t\t\t\t((body != null) ||\n\t\t\t\t ((fileParts != null) && !fileParts.isEmpty()) |\n\t\t\t\t ((parts != null) && !parts.isEmpty()))) {\n\t\t\t}\n\t\t\telse if (!hasRequestHeader(httpMethod, HttpHeaders.CONTENT_TYPE)) {\n\t\t\t\thttpMethod.addRequestHeader(\n\t\t\t\t\tHttpHeaders.CONTENT_TYPE,\n\t\t\t\t\tContentTypes.APPLICATION_X_WWW_FORM_URLENCODED);\n\t\t\t}\n\n\t\t\tif (!hasRequestHeader(httpMethod, HttpHeaders.USER_AGENT)) {\n\t\t\t\thttpMethod.addRequestHeader(\n\t\t\t\t\tHttpHeaders.USER_AGENT, _DEFAULT_USER_AGENT);\n\t\t\t}\n\n\t\t\thttpState = new HttpState();\n\n\t\t\tif ((cookies != null) && (cookies.length > 0)) {\n\t\t\t\torg.apache.commons.httpclient.Cookie[] commonsCookies =\n\t\t\t\t\ttoCommonsCookies(cookies);\n\n\t\t\t\thttpState.addCookies(commonsCookies);\n\n\t\t\t\tHttpMethodParams httpMethodParams = httpMethod.getParams();\n\n\t\t\t\thttpMethodParams.setCookiePolicy(\n\t\t\t\t\tCookiePolicy.BROWSER_COMPATIBILITY);\n\t\t\t}\n\n\t\t\tif (auth != null) {\n\t\t\t\thttpMethod.setDoAuthentication(true);\n\n\t\t\t\thttpState.setCredentials(\n\t\t\t\t\tnew AuthScope(\n\t\t\t\t\t\tauth.getHost(), auth.getPort(), auth.getRealm()),\n\t\t\t\t\tnew UsernamePasswordCredentials(\n\t\t\t\t\t\tauth.getUsername(), auth.getPassword()));\n\t\t\t}\n\n\t\t\tproxifyState(httpState, hostConfiguration);\n\n\t\t\tboolean checkReadFileDescriptor =\n\t\t\t\tPortalSecurityManagerThreadLocal.isCheckReadFileDescriptor();\n\t\t\tboolean checkWriteFileDescriptor =\n\t\t\t\tPortalSecurityManagerThreadLocal.isCheckWriteFileDescriptor();\n\n\t\t\ttry {\n\t\t\t\tPortalSecurityManagerThreadLocal.setCheckReadFileDescriptor(\n\t\t\t\t\tfalse);\n\t\t\t\tPortalSecurityManagerThreadLocal.setCheckWriteFileDescriptor(\n\t\t\t\t\tfalse);\n\n\t\t\t\thttpClient.executeMethod(\n\t\t\t\t\thostConfiguration, httpMethod, httpState);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tPortalSecurityManagerThreadLocal.setCheckReadFileDescriptor(\n\t\t\t\t\tcheckReadFileDescriptor);\n\t\t\t\tPortalSecurityManagerThreadLocal.setCheckWriteFileDescriptor(\n\t\t\t\t\tcheckWriteFileDescriptor);\n\t\t\t}\n\n\t\t\tHeader locationHeader = httpMethod.getResponseHeader(\"location\");\n\n\t\t\tif ((locationHeader != null) && !locationHeader.equals(location)) {\n\t\t\t\tString redirect = locationHeader.getValue();\n\n\t\t\t\tif (followRedirects) {\n\t\t\t\t\treturn URLtoByteArray(\n\t\t\t\t\t\tredirect, Http.Method.GET, headers, cookies, auth, body,\n\t\t\t\t\t\tfileParts, parts, response, followRedirects);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresponse.setRedirect(redirect);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tInputStream inputStream = httpMethod.getResponseBodyAsStream();\n\n\t\t\tif (inputStream != null) {\n\t\t\t\tHeader contentLength = httpMethod.getResponseHeader(\n\t\t\t\t\tHttpHeaders.CONTENT_LENGTH);\n\n\t\t\t\tif (contentLength != null) {\n\t\t\t\t\tresponse.setContentLength(\n\t\t\t\t\t\tGetterUtil.getInteger(contentLength.getValue()));\n\t\t\t\t}\n\n\t\t\t\tHeader contentType = httpMethod.getResponseHeader(\n\t\t\t\t\tHttpHeaders.CONTENT_TYPE);\n\n\t\t\t\tif (contentType != null) {\n\t\t\t\t\tresponse.setContentType(contentType.getValue());\n\t\t\t\t}\n\n\t\t\t\tbytes = FileUtil.getBytes(inputStream);\n\t\t\t}\n\n\t\t\tfor (Header header : httpMethod.getResponseHeaders()) {\n\t\t\t\tresponse.addHeader(header.getName(), header.getValue());\n\t\t\t}\n\n\t\t\treturn bytes;\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (httpState != null) {\n\t\t\t\t\t_cookies.set(toServletCookies(httpState.getCookies()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (httpMethod != null) {\n\t\t\t\t\thttpMethod.releaseConnection();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"84ffbadeca043c9bfd4ef80220d1cf527986dc90","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void startProxy() throws Exception\n    {\n        proxy = new Server();\n        proxyConnector = new SelectChannelConnector();\n        proxy.addConnector(proxyConnector);\n        proxy.setHandler(new ProxyHandler());\n        proxy.start();\n    }","id":26486,"modified_method":"protected static void startProxy() throws Exception\n    {\n        proxy = new Server();\n        proxyConnector = new SelectChannelConnector();\n        proxy.addConnector(proxyConnector);\n        proxy.setHandler(new ConnectHandler());\n        proxy.start();\n    }","commit_id":"dddbe12c9709953ea14469c499833183d7812f24","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public ProxyHandler(String[] white, String[] black)\n    {\n        this(null, white,  black);\n    }","id":26487,"modified_method":"public ProxyHandler(String[] white, String[] black)\n    {\n        super(white,black);\n    }","commit_id":"dddbe12c9709953ea14469c499833183d7812f24","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public ProxyHandler()\n    {\n        this(null);\n    }","id":26488,"modified_method":"public ProxyHandler()\n    {\n        super();\n    }","commit_id":"dddbe12c9709953ea14469c499833183d7812f24","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public ProxyHandler(Handler handler, String[] white, String[] black)\n    {\n        setHandler(handler);\n        set(white, _white);\n        set(black, _black);\n    }","id":26489,"modified_method":"public ProxyHandler(Handler handler, String[] white, String[] black)\n    {\n        super(handler,white,black);\n    }","commit_id":"dddbe12c9709953ea14469c499833183d7812f24","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public ProxyHandler(Handler handler)\n    {\n        setHandler(handler);\n    }","id":26490,"modified_method":"public ProxyHandler(Handler handler)\n    {\n        super(handler);\n    }","commit_id":"dddbe12c9709953ea14469c499833183d7812f24","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testCONNECTAndPOSTWithContext() throws Exception\n    {\n        final String contextKey = \"contextKey\";\n        final String contextValue = \"contextValue\";\n\n        // Replace the default ProxyHandler with a subclass to test context information passing\n        stopProxy();\n        proxy.setHandler(new ProxyHandler()\n        {\n            @Override\n            protected boolean handleAuthentication(HttpServletRequest request, HttpServletResponse response, String address) throws ServletException, IOException\n            {\n                request.setAttribute(contextKey, contextValue);\n                return super.handleAuthentication(request, response, address);\n            }\n\n            @Override\n            protected SocketChannel connect(HttpServletRequest request, String host, int port) throws IOException\n            {\n                assertEquals(contextValue, request.getAttribute(contextKey));\n                return super.connect(request, host, port);\n            }\n\n            @Override\n            protected void prepareContext(HttpServletRequest request, ConcurrentMap<String, Object> context)\n            {\n                // Transfer data from the HTTP request to the connection context\n                assertEquals(contextValue, request.getAttribute(contextKey));\n                context.put(contextKey, request.getAttribute(contextKey));\n            }\n\n            @Override\n            protected int read(EndPoint endPoint, Buffer buffer, ConcurrentMap<String, Object> context) throws IOException\n            {\n                assertEquals(contextValue, context.get(contextKey));\n                return super.read(endPoint, buffer, context);\n            }\n\n            @Override\n            protected int write(EndPoint endPoint, Buffer buffer, ConcurrentMap<String, Object> context) throws IOException\n            {\n                assertEquals(contextValue, context.get(contextKey));\n                return super.write(endPoint, buffer, context);\n            }\n        });\n        proxy.start();\n\n        String hostPort = \"localhost:\" + serverConnector.getLocalPort();\n        String request = \"\" +\n                \"CONNECT \" + hostPort + \" HTTP/1.1\\r\\n\" +\n                \"Host: \" + hostPort + \"\\r\\n\" +\n                \"\\r\\n\";\n        Socket socket = newSocket();\n        try\n        {\n            OutputStream output = socket.getOutputStream();\n            BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            output.write(request.getBytes(\"UTF-8\"));\n            output.flush();\n\n            // Expect 200 OK from the CONNECT request\n            Response response = readResponse(input);\n            assertEquals(\"200\", response.getCode());\n\n            String body = \"0123456789ABCDEF\";\n            request = \"\" +\n                    \"POST /echo HTTP/1.1\\r\\n\" +\n                    \"Host: \" + hostPort + \"\\r\\n\" +\n                    \"Content-Length: \" + body.length() + \"\\r\\n\" +\n                    \"\\r\\n\" +\n                    body;\n            output.write(request.getBytes(\"UTF-8\"));\n            output.flush();\n\n            response = readResponse(input);\n            assertEquals(\"200\", response.getCode());\n            assertEquals(\"POST /echo\\r\\n\" + body, response.getBody());\n        }\n        finally\n        {\n            socket.close();\n        }\n    }","id":26491,"modified_method":"@Test\n    public void testCONNECTAndPOSTWithContext() throws Exception\n    {\n        final String contextKey = \"contextKey\";\n        final String contextValue = \"contextValue\";\n\n        // Replace the default ProxyHandler with a subclass to test context information passing\n        stopProxy();\n        proxy.setHandler(new ConnectHandler()\n        {\n            @Override\n            protected boolean handleAuthentication(HttpServletRequest request, HttpServletResponse response, String address) throws ServletException, IOException\n            {\n                request.setAttribute(contextKey, contextValue);\n                return super.handleAuthentication(request, response, address);\n            }\n\n            @Override\n            protected SocketChannel connect(HttpServletRequest request, String host, int port) throws IOException\n            {\n                assertEquals(contextValue, request.getAttribute(contextKey));\n                return super.connect(request, host, port);\n            }\n\n            @Override\n            protected void prepareContext(HttpServletRequest request, ConcurrentMap<String, Object> context)\n            {\n                // Transfer data from the HTTP request to the connection context\n                assertEquals(contextValue, request.getAttribute(contextKey));\n                context.put(contextKey, request.getAttribute(contextKey));\n            }\n\n            @Override\n            protected int read(EndPoint endPoint, Buffer buffer, ConcurrentMap<String, Object> context) throws IOException\n            {\n                assertEquals(contextValue, context.get(contextKey));\n                return super.read(endPoint, buffer, context);\n            }\n\n            @Override\n            protected int write(EndPoint endPoint, Buffer buffer, ConcurrentMap<String, Object> context) throws IOException\n            {\n                assertEquals(contextValue, context.get(contextKey));\n                return super.write(endPoint, buffer, context);\n            }\n        });\n        proxy.start();\n\n        String hostPort = \"localhost:\" + serverConnector.getLocalPort();\n        String request = \"\" +\n                \"CONNECT \" + hostPort + \" HTTP/1.1\\r\\n\" +\n                \"Host: \" + hostPort + \"\\r\\n\" +\n                \"\\r\\n\";\n        Socket socket = newSocket();\n        try\n        {\n            OutputStream output = socket.getOutputStream();\n            BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            output.write(request.getBytes(\"UTF-8\"));\n            output.flush();\n\n            // Expect 200 OK from the CONNECT request\n            Response response = readResponse(input);\n            assertEquals(\"200\", response.getCode());\n\n            String body = \"0123456789ABCDEF\";\n            request = \"\" +\n                    \"POST /echo HTTP/1.1\\r\\n\" +\n                    \"Host: \" + hostPort + \"\\r\\n\" +\n                    \"Content-Length: \" + body.length() + \"\\r\\n\" +\n                    \"\\r\\n\" +\n                    body;\n            output.write(request.getBytes(\"UTF-8\"));\n            output.flush();\n\n            response = readResponse(input);\n            assertEquals(\"200\", response.getCode());\n            assertEquals(\"POST /echo\\r\\n\" + body, response.getBody());\n        }\n        finally\n        {\n            socket.close();\n        }\n    }","commit_id":"dddbe12c9709953ea14469c499833183d7812f24","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public static void main(String[] args) throws Exception\n    {\n        Server server = new Server();\n        SelectChannelConnector connector = new SelectChannelConnector();\n        connector.setPort(8080);\n        server.addConnector(connector);\n\n        HandlerCollection handlers = new HandlerCollection();\n        server.setHandler(handlers);\n\n        ServletContextHandler context = new ServletContextHandler(handlers, \"/\", ServletContextHandler.SESSIONS);\n        ServletHolder proxyServlet = new ServletHolder(ProxyServlet.class);\n        proxyServlet.setInitParameter(\"whiteList\", \"google.com, www.eclipse.org\");\n        proxyServlet.setInitParameter(\"blackList\", \"google.com/calendar/*, www.eclipse.org/committers/\");\n        context.addServlet(proxyServlet, \"/*\");\n        \n        ProxyHandler proxy = new ProxyHandler();\n        proxy.setWhite(new String[]{\"mail.google.com\"});\n        proxy.addWhite(\"www.google.com\");\n        handlers.addHandler(proxy);\n\n        server.start();\n    }","id":26492,"modified_method":"public static void main(String[] args) throws Exception\n    {\n        Server server = new Server();\n        SelectChannelConnector connector = new SelectChannelConnector();\n        connector.setPort(8888);\n        server.addConnector(connector);\n\n        HandlerCollection handlers = new HandlerCollection();\n        server.setHandler(handlers);\n\n        // Setup proxy servlet\n        ServletContextHandler context = new ServletContextHandler(handlers, \"/\", ServletContextHandler.SESSIONS);\n        ServletHolder proxyServlet = new ServletHolder(ProxyServlet.class);\n        proxyServlet.setInitParameter(\"whiteList\", \"google.com, www.eclipse.org, localhost\");\n        proxyServlet.setInitParameter(\"blackList\", \"google.com/calendar/*, www.eclipse.org/committers/\");\n        context.addServlet(proxyServlet, \"/*\");\n        \n        \n        // Setup proxy handler to handle CONNECT methods\n        ConnectHandler proxy = new ConnectHandler();\n        proxy.setWhite(new String[]{\"mail.google.com\"});\n        proxy.addWhite(\"www.google.com\");\n        handlers.addHandler(proxy);\n\n        server.start();\n    }","commit_id":"dddbe12c9709953ea14469c499833183d7812f24","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void service(ServletRequest req, ServletResponse res) throws ServletException,\n            IOException\n    {\n        final int debug=_log.isDebugEnabled()?req.hashCode():0;\n\n        final HttpServletRequest request = (HttpServletRequest)req;\n        final HttpServletResponse response = (HttpServletResponse)res;\n        if (\"CONNECT\".equalsIgnoreCase(request.getMethod()))\n        {\n            handleConnect(request,response);\n        }\n        else\n        {\n            final InputStream in=request.getInputStream();\n            final OutputStream out=response.getOutputStream();\n\n            final Continuation continuation = ContinuationSupport.getContinuation(request);\n\n            if (!continuation.isInitial())\n                response.sendError(HttpServletResponse.SC_GATEWAY_TIMEOUT); // Need better test that isInitial\n            else\n            {\n                String uri=request.getRequestURI();\n                if (request.getQueryString()!=null)\n                    uri+=\"?\"+request.getQueryString();\n\n                HttpURI url=proxyHttpURI(request.getScheme(),\n                                         request.getServerName(),\n                                         request.getServerPort(),\n                                         uri);\n\n                if (debug!=0)\n                    _log.debug(debug+\" proxy \"+uri+\"-->\"+url);\n\n                if (url==null)\n                {\n                    response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                    return;\n                }\n\n                HttpExchange exchange = new HttpExchange()\n                {\n                    protected void onRequestCommitted() throws IOException\n                    {\n                    }\n\n                    protected void onRequestComplete() throws IOException\n                    {\n                    }\n\n                    protected void onResponseComplete() throws IOException\n                    {\n                        if (debug!=0)\n                            _log.debug(debug+\" complete\");\n                        continuation.complete();\n                    }\n\n                    protected void onResponseContent(Buffer content) throws IOException\n                    {\n                        if (debug!=0)\n                            _log.debug(debug+\" content\"+content.length());\n                        content.writeTo(out);\n                    }\n\n                    protected void onResponseHeaderComplete() throws IOException\n                    {\n                    }\n\n                    protected void onResponseStatus(Buffer version, int status, Buffer reason) throws IOException\n                    {\n                        if (debug!=0)\n                            _log.debug(debug+\" \"+version+\" \"+status+\" \"+reason);\n\n                        if (reason!=null && reason.length()>0)\n                            response.setStatus(status,reason.toString());\n                        else\n                            response.setStatus(status);\n                    }\n\n                    protected void onResponseHeader(Buffer name, Buffer value) throws IOException\n                    {\n                        String s = name.toString().toLowerCase();\n                        if (!_DontProxyHeaders.contains(s) ||\n                           (HttpHeaders.CONNECTION_BUFFER.equals(name) &&\n                            HttpHeaderValues.CLOSE_BUFFER.equals(value)))\n                        {\n                            if (debug!=0)\n                                _log.debug(debug+\" \"+name+\": \"+value);\n\n                            response.addHeader(name.toString(),value.toString());\n                        }\n                        else if (debug!=0)\n                                _log.debug(debug+\" \"+name+\"! \"+value);\n                    }\n\n                    protected void onConnectionFailed(Throwable ex)\n                    {\n                        onException(ex);\n                    }\n\n                    protected void onException(Throwable ex)\n                    {\n                        if (ex instanceof EofException)\n                        {\n                            Log.ignore(ex);\n                            return;\n                        }\n                        Log.warn(ex.toString());\n                        Log.debug(ex);\n                        if (!response.isCommitted())\n                            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                        continuation.complete();\n                    }\n\n                    protected void onExpire()\n                    {\n                        if (!response.isCommitted())\n                            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                        continuation.complete();\n                    }\n\n                };\n\n                exchange.setScheme(HttpSchemes.HTTPS.equals(request.getScheme())?HttpSchemes.HTTPS_BUFFER:HttpSchemes.HTTP_BUFFER);\n                exchange.setMethod(request.getMethod());\n                exchange.setURL(url.toString());\n                exchange.setVersion(request.getProtocol());\n\n                if (debug!=0)\n                    _log.debug(debug+\" \"+request.getMethod()+\" \"+url+\" \"+request.getProtocol());\n\n                // check connection header\n                String connectionHdr = request.getHeader(\"Connection\");\n                if (connectionHdr!=null)\n                {\n                    connectionHdr=connectionHdr.toLowerCase();\n                    if (connectionHdr.indexOf(\"keep-alive\")<0  &&\n                            connectionHdr.indexOf(\"close\")<0)\n                        connectionHdr=null;\n                }\n\n                // force host\n                if (_hostHeader!=null)\n                    exchange.setRequestHeader(\"Host\",_hostHeader);\n\n                // copy headers\n                boolean xForwardedFor=false;\n                boolean hasContent=false;\n                long contentLength=-1;\n                Enumeration<?> enm = request.getHeaderNames();\n                while (enm.hasMoreElements())\n                {\n                    // TODO could be better than this!\n                    String hdr=(String)enm.nextElement();\n                    String lhdr=hdr.toLowerCase();\n\n                    if (_DontProxyHeaders.contains(lhdr))\n                        continue;\n                    if (connectionHdr!=null && connectionHdr.indexOf(lhdr)>=0)\n                        continue;\n                    if (_hostHeader!=null && \"host\".equals(lhdr))\n                        continue;\n\n                    if (\"content-type\".equals(lhdr))\n                        hasContent=true;\n                    else if (\"content-length\".equals(lhdr))\n                    {\n                        contentLength=request.getContentLength();\n                        exchange.setRequestHeader(HttpHeaders.CONTENT_LENGTH,Long.toString(contentLength));\n                        if (contentLength>0)\n                            hasContent=true;\n                    }\n                    else if (\"x-forwarded-for\".equals(lhdr))\n                        xForwardedFor=true;\n\n                    Enumeration<?> vals = request.getHeaders(hdr);\n                    while (vals.hasMoreElements())\n                    {\n                        String val = (String)vals.nextElement();\n                        if (val!=null)\n                        {\n                            if (debug!=0)\n                                _log.debug(debug+\" \"+hdr+\": \"+val);\n\n                            exchange.setRequestHeader(hdr,val);\n                        }\n                    }\n                }\n\n                // Proxy headers\n                exchange.setRequestHeader(\"Via\",\"1.1 (jetty)\");\n                if (!xForwardedFor)\n                    exchange.addRequestHeader(\"X-Forwarded-For\",\n                            request.getRemoteAddr());\n\n                if (hasContent)\n                    exchange.setRequestContentSource(in);\n\n                continuation.suspend(response);\n                _client.send(exchange);\n\n            }\n        }\n    }","id":26493,"modified_method":"public void service(ServletRequest req, ServletResponse res) throws ServletException,\n            IOException\n    {\n        final int debug=_log.isDebugEnabled()?req.hashCode():0;\n\n        final HttpServletRequest request = (HttpServletRequest)req;\n        final HttpServletResponse response = (HttpServletResponse)res;\n        if (\"CONNECT\".equalsIgnoreCase(request.getMethod()))\n        {\n            handleConnect(request,response);\n        }\n        else\n        {\n            final InputStream in=request.getInputStream();\n            final OutputStream out=response.getOutputStream();\n\n            final Continuation continuation = ContinuationSupport.getContinuation(request);\n\n            if (!continuation.isInitial())\n                response.sendError(HttpServletResponse.SC_GATEWAY_TIMEOUT); // Need better test that isInitial\n            else\n            {\n                String uri=request.getRequestURI();\n                if (request.getQueryString()!=null)\n                    uri+=\"?\"+request.getQueryString();\n\n                HttpURI url=proxyHttpURI(request.getScheme(),\n                                         request.getServerName(),\n                                         request.getServerPort(),\n                                         uri);\n\n                if (debug!=0)\n                    _log.debug(debug+\" proxy \"+uri+\"-->\"+url);\n\n                if (url==null)\n                {\n                    response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                    return;\n                }\n\n                HttpExchange exchange = new HttpExchange()\n                {\n                    protected void onRequestCommitted() throws IOException\n                    {\n                    }\n\n                    protected void onRequestComplete() throws IOException\n                    {\n                    }\n\n                    protected void onResponseComplete() throws IOException\n                    {\n                        if (debug!=0)\n                            _log.debug(debug+\" complete\");\n                        continuation.complete();\n                    }\n\n                    protected void onResponseContent(Buffer content) throws IOException\n                    {\n                        if (debug!=0)\n                            _log.debug(debug+\" content\"+content.length());\n                        content.writeTo(out);\n                    }\n\n                    protected void onResponseHeaderComplete() throws IOException\n                    {\n                    }\n\n                    protected void onResponseStatus(Buffer version, int status, Buffer reason) throws IOException\n                    {\n                        if (debug!=0)\n                            _log.debug(debug+\" \"+version+\" \"+status+\" \"+reason);\n\n                        if (reason!=null && reason.length()>0)\n                            response.setStatus(status,reason.toString());\n                        else\n                            response.setStatus(status);\n                    }\n\n                    protected void onResponseHeader(Buffer name, Buffer value) throws IOException\n                    {\n                        String s = name.toString().toLowerCase();\n                        if (!_DontProxyHeaders.contains(s) ||\n                           (HttpHeaders.CONNECTION_BUFFER.equals(name) &&\n                            HttpHeaderValues.CLOSE_BUFFER.equals(value)))\n                        {\n                            if (debug!=0)\n                                _log.debug(debug+\" \"+name+\": \"+value);\n\n                            response.addHeader(name.toString(),value.toString());\n                        }\n                        else if (debug!=0)\n                                _log.debug(debug+\" \"+name+\"! \"+value);\n                    }\n\n                    protected void onConnectionFailed(Throwable ex)\n                    {\n                        onException(ex);\n                    }\n\n                    protected void onException(Throwable ex)\n                    {\n                        if (ex instanceof EofException)\n                        {\n                            Log.ignore(ex);\n                            return;\n                        }\n                        Log.warn(ex.toString());\n                        Log.debug(ex);\n                        if (!response.isCommitted())\n                            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                        continuation.complete();\n                    }\n\n                    protected void onExpire()\n                    {\n                        if (!response.isCommitted())\n                            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                        continuation.complete();\n                    }\n\n                };\n\n                exchange.setScheme(HttpSchemes.HTTPS.equals(request.getScheme())?HttpSchemes.HTTPS_BUFFER:HttpSchemes.HTTP_BUFFER);\n                exchange.setMethod(request.getMethod());\n                exchange.setURL(url.toString());\n                exchange.setVersion(request.getProtocol());\n\n                if (debug!=0)\n                    _log.debug(debug+\" \"+request.getMethod()+\" \"+url+\" \"+request.getProtocol());\n\n                // check connection header\n                String connectionHdr = request.getHeader(\"Connection\");\n                if (connectionHdr!=null)\n                {\n                    connectionHdr=connectionHdr.toLowerCase();\n                    if (connectionHdr.indexOf(\"keep-alive\")<0  &&\n                            connectionHdr.indexOf(\"close\")<0)\n                        connectionHdr=null;\n                }\n\n                // force host\n                if (_hostHeader!=null)\n                    exchange.setRequestHeader(\"Host\",_hostHeader);\n\n                // copy headers\n                boolean xForwardedFor=false;\n                boolean hasContent=false;\n                long contentLength=-1;\n                Enumeration<?> enm = request.getHeaderNames();\n                while (enm.hasMoreElements())\n                {\n                    // TODO could be better than this!\n                    String hdr=(String)enm.nextElement();\n                    String lhdr=hdr.toLowerCase();\n\n                    if (_DontProxyHeaders.contains(lhdr))\n                        continue;\n                    if (connectionHdr!=null && connectionHdr.indexOf(lhdr)>=0)\n                        continue;\n                    if (_hostHeader!=null && \"host\".equals(lhdr))\n                        continue;\n\n                    if (\"content-type\".equals(lhdr))\n                        hasContent=true;\n                    else if (\"content-length\".equals(lhdr))\n                    {\n                        contentLength=request.getContentLength();\n                        exchange.setRequestHeader(HttpHeaders.CONTENT_LENGTH,Long.toString(contentLength));\n                        if (contentLength>0)\n                            hasContent=true;\n                    }\n                    else if (\"x-forwarded-for\".equals(lhdr))\n                        xForwardedFor=true;\n\n                    Enumeration<?> vals = request.getHeaders(hdr);\n                    while (vals.hasMoreElements())\n                    {\n                        String val = (String)vals.nextElement();\n                        if (val!=null)\n                        {\n                            if (debug!=0)\n                                _log.debug(debug+\" \"+hdr+\": \"+val);\n\n                            exchange.setRequestHeader(hdr,val);\n                        }\n                    }\n                }\n\n                // Proxy headers\n                exchange.setRequestHeader(\"Via\",\"1.1 (jetty)\");\n                if (!xForwardedFor)\n                {\n                    exchange.addRequestHeader(\"X-Forwarded-For\",\n                            request.getRemoteAddr());\n                    exchange.addRequestHeader(\"X-Forwarded-Proto\",\n                            request.getScheme());\n                    exchange.addRequestHeader(\"X-Forwarded-Host\",\n                            request.getServerName());\n                    exchange.addRequestHeader(\"X-Forwarded-Server\",\n                            request.getLocalName());\n                }\n\n                if (hasContent)\n                    exchange.setRequestContentSource(in);\n\n                continuation.suspend(response);\n                _client.send(exchange);\n\n            }\n        }\n    }","commit_id":"dddbe12c9709953ea14469c499833183d7812f24","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void startProxy() throws Exception\n    {\n        proxy = new Server();\n        proxyConnector = new SelectChannelConnector();\n        proxy.addConnector(proxyConnector);\n        ProxyHandler proxyHandler = new ProxyHandler();\n        proxy.setHandler(proxyHandler);\n        proxy.start();\n    }","id":26494,"modified_method":"private void startProxy() throws Exception\n    {\n        proxy = new Server();\n        proxyConnector = new SelectChannelConnector();\n        proxy.addConnector(proxyConnector);\n        ConnectHandler proxyHandler = new ConnectHandler();\n        proxy.setHandler(proxyHandler);\n        proxy.start();\n    }","commit_id":"dddbe12c9709953ea14469c499833183d7812f24","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n  public boolean removeBlock(long userId, long blockId, long lockId) throws IOException {\n    Preconditions.checkState(mLockManager.validateLockId(userId, blockId, lockId));\n    return removeBlockNoLock(userId, blockId);\n  }","id":26495,"modified_method":"@Override\n  public boolean removeBlock(long userId, long blockId) throws IOException {\n    mEvictionLock.readLock().lock();\n    long lockId = mLockManager.lockBlock(userId, blockId, BlockLock.BlockLockType.WRITE).get();\n    boolean result = removeBlockNoLock(userId, blockId);\n    mLockManager.unlockBlock(lockId);\n    mEvictionLock.readLock().unlock();\n    return result;\n  }","commit_id":"6fe5ca8fbf37387bf40efe20b24ab4da37b7d960","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public Optional<Long> lockBlock(long userId, long blockId,\n                                  BlockLock.BlockLockType blockLockType) {\n    mEvictionLock.readLock().lock();\n    return mLockManager.lockBlock(userId, blockId, blockLockType);\n  }","id":26496,"modified_method":"@Override\n  public Optional<Long> lockBlock(long userId, long blockId,\n      BlockLock.BlockLockType blockLockType) {\n    return mLockManager.lockBlock(userId, blockId, blockLockType);\n  }","commit_id":"6fe5ca8fbf37387bf40efe20b24ab4da37b7d960","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean commitBlock(long userId, long blockId) {\n    mEvictionLock.writeLock().lock();\n    boolean result = commitBlockNoLock(userId, blockId);\n    mEvictionLock.writeLock().unlock();\n    return result;\n  }","id":26497,"modified_method":"@Override\n  public boolean commitBlock(long userId, long blockId) {\n    mEvictionLock.readLock().lock();\n    long lockId = mLockManager.lockBlock(userId, blockId, BlockLock.BlockLockType.WRITE).get();\n    boolean result = commitBlockNoLock(userId, blockId);\n    mLockManager.unlockBlock(lockId);\n    mEvictionLock.readLock().unlock();\n    return result;\n  }","commit_id":"6fe5ca8fbf37387bf40efe20b24ab4da37b7d960","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public Optional<TempBlockMeta> createBlockMeta(long userId, long blockId,\n      BlockStoreLocation location, long initialBlockSize) throws IOException {\n    mEvictionLock.writeLock().lock();\n    Optional<TempBlockMeta> optTempBlock =\n        createBlockMetaNoLock(userId, blockId, location, initialBlockSize);\n    mEvictionLock.writeLock().unlock();\n    return optTempBlock;\n  }","id":26498,"modified_method":"@Override\n  public Optional<TempBlockMeta> createBlockMeta(long userId, long blockId,\n      BlockStoreLocation location, long initialBlockSize) throws IOException {\n    mEvictionLock.readLock().lock();\n    Optional<TempBlockMeta> optTempBlock =\n        createBlockMetaNoLock(userId, blockId, location, initialBlockSize);\n    mEvictionLock.readLock().unlock();\n    return optTempBlock;\n  }","commit_id":"6fe5ca8fbf37387bf40efe20b24ab4da37b7d960","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean unlockBlock(long lockId) {\n    boolean result = mLockManager.unlockBlock(lockId);\n    mEvictionLock.readLock().unlock();\n    return result;\n  }","id":26499,"modified_method":"@Override\n  public boolean unlockBlock(long lockId) {\n    return mLockManager.unlockBlock(lockId);\n  }","commit_id":"6fe5ca8fbf37387bf40efe20b24ab4da37b7d960","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean moveBlock(long userId, long blockId, long lockId, BlockStoreLocation newLocation)\n      throws IOException {\n    Preconditions.checkState(mLockManager.validateLockId(userId, blockId, lockId));\n    return moveBlockNoLock(userId, blockId, newLocation);\n  }","id":26500,"modified_method":"@Override\n  public boolean moveBlock(long userId, long blockId, BlockStoreLocation newLocation)\n      throws IOException {\n    mEvictionLock.readLock().lock();\n    long lockId = mLockManager.lockBlock(userId, blockId, BlockLock.BlockLockType.WRITE).get();\n    boolean result = moveBlockNoLock(userId, blockId, newLocation);\n    mLockManager.unlockBlock(lockId);\n    mEvictionLock.readLock().unlock();\n    return result;\n  }","commit_id":"6fe5ca8fbf37387bf40efe20b24ab4da37b7d960","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean abortBlock(long userId, long blockId) throws IOException {\n    mEvictionLock.writeLock().lock();\n    boolean result = abortBlockNoLock(userId, blockId);\n    mEvictionLock.writeLock().unlock();\n    return result;\n  }","id":26501,"modified_method":"@Override\n  public boolean abortBlock(long userId, long blockId) throws IOException {\n    mEvictionLock.readLock().lock();\n    long lockId = mLockManager.lockBlock(userId, blockId, BlockLock.BlockLockType.WRITE).get();\n    boolean result = abortBlockNoLock(userId, blockId);\n    mLockManager.unlockBlock(lockId);\n    mEvictionLock.readLock().unlock();\n    return result;\n  }","commit_id":"6fe5ca8fbf37387bf40efe20b24ab4da37b7d960","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean freeSpaceNoLock(long userId, long size, BlockStoreLocation location)\n      throws IOException {\n    EvictionPlan plan = mEvictor.freeSpace(size, location);\n    // Step1: remove blocks to make room.\n    for (long blockId : plan.toEvict()) {\n      if (!removeBlockNoLock(userId, blockId)) {\n        return false;\n      }\n    }\n    // Step2: transfer blocks among tiers.\n    for (Pair<Long, BlockStoreLocation> entry : plan.toMove()) {\n      long blockId = entry.getFirst();\n      BlockStoreLocation newLocation = entry.getSecond();\n      if (!moveBlockNoLock(userId, blockId, newLocation)) {\n        return false;\n      }\n    }\n    return true;\n  }","id":26502,"modified_method":"private boolean freeSpaceNoLock(long userId, long size, BlockStoreLocation location)\n      throws IOException {\n    EvictionPlan plan = mEvictor.freeSpace(size, location);\n    // Step1: remove blocks to make room.\n    for (long blockId : plan.toEvict()) {\n      long lockId = mLockManager.lockBlock(userId, blockId, BlockLock.BlockLockType.WRITE).get();\n      boolean result = removeBlockNoLock(userId, blockId);\n      mLockManager.unlockBlock(lockId);\n      if (!result) {\n        return false;\n      }\n    }\n    // Step2: transfer blocks among tiers.\n    for (Pair<Long, BlockStoreLocation> entry : plan.toMove()) {\n      long blockId = entry.getFirst();\n      BlockStoreLocation newLocation = entry.getSecond();\n      long lockId = mLockManager.lockBlock(userId, blockId, BlockLock.BlockLockType.WRITE).get();\n      boolean result = moveBlockNoLock(userId, blockId, newLocation);\n      mLockManager.unlockBlock(lockId);\n      if (!result) {\n        return false;\n      }\n    }\n    return true;\n  }","commit_id":"6fe5ca8fbf37387bf40efe20b24ab4da37b7d960","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean freeSpace(long userId, long availableBytes, BlockStoreLocation location)\n      throws IOException {\n    mEvictionLock.writeLock().lock();\n    boolean result = freeSpaceNoEvictionLock(userId, availableBytes, location);\n    mEvictionLock.writeLock().unlock();\n    return result;\n  }","id":26503,"modified_method":"@Override\n  public void freeSpace(long userId, long availableBytes, BlockStoreLocation location)\n      throws IOException {\n    mEvictionLock.writeLock().lock();\n    try {\n      freeSpaceNoEvictionLock(userId, availableBytes, location);\n    } finally {\n      mEvictionLock.writeLock().unlock();\n    }\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean requestSpaceNoLock(long userId, long blockId, long moreBytes) throws IOException {\n    Optional<TempBlockMeta> optTempBlock = mMetaManager.getTempBlockMeta(blockId);\n    if (!optTempBlock.isPresent()) {\n      return false;\n    }\n    TempBlockMeta tempBlock = optTempBlock.get();\n    BlockStoreLocation location = tempBlock.getBlockLocation();\n    if (!freeSpaceNoEvictionLock(userId, moreBytes, location)) {\n      return false;\n    }\n\n    // Increase the size of this temp block\n    mMetaManager.resizeTempBlockMeta(tempBlock, tempBlock.getBlockSize() + moreBytes);\n    return true;\n  }","id":26504,"modified_method":"private void requestSpaceNoLock(long userId, long blockId, long moreBytes) throws IOException {\n    TempBlockMeta tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n\n    BlockStoreLocation location = tempBlockMeta.getBlockLocation();\n    freeSpaceNoEvictionLock(userId, moreBytes, location);\n    // Increase the size of this temp block\n    mMetaManager.resizeTempBlockMeta(tempBlockMeta, tempBlockMeta.getBlockSize() + moreBytes);\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean moveBlock(long userId, long blockId, BlockStoreLocation newLocation)\n      throws IOException {\n    mEvictionLock.readLock().lock();\n    // TODO: Handle absent\n    long lockId = mLockManager.lockBlock(userId, blockId, BlockLockType.WRITE).get();\n    boolean result = moveBlockNoLock(userId, blockId, newLocation);\n    mLockManager.unlockBlock(lockId);\n    mEvictionLock.readLock().unlock();\n    return result;\n  }","id":26505,"modified_method":"@Override\n  public void moveBlock(long userId, long blockId, BlockStoreLocation newLocation)\n      throws IOException {\n    mEvictionLock.readLock().lock();\n    try {\n      long lockId = mLockManager.lockBlock(userId, blockId, BlockLockType.WRITE);\n      try {\n        moveBlockNoLock(userId, blockId, newLocation);\n      } finally {\n        mLockManager.unlockBlock(lockId);\n      }\n    } finally {\n      // If we fail to lock, the block is no longer in tiered store\n      mEvictionLock.readLock().unlock();\n    }\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean abortBlockNoLock(long userId, long blockId) {\n    Optional<TempBlockMeta> optTempBlock = mMetaManager.getTempBlockMeta(blockId);\n    if (!optTempBlock.isPresent()) {\n      return false;\n    }\n    TempBlockMeta tempBlock = optTempBlock.get();\n    // Check the userId is the owner of this temp block\n    if (tempBlock.getUserId() != userId) {\n      return false;\n    }\n    String path = tempBlock.getPath();\n    boolean deleted = new File(path).delete();\n    if (!deleted) {\n      return false;\n    }\n    return mMetaManager.abortTempBlockMeta(tempBlock);\n  }","id":26506,"modified_method":"private void abortBlockNoLock(long userId, long blockId) throws IOException {\n    TempBlockMeta tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n    // Check the userId is the owner of this temp block\n    long ownerUserId = tempBlockMeta.getUserId();\n    if (ownerUserId != userId) {\n      throw new IOException(\"Failed to abort temp block \" + blockId + \": ownerUserId \"\n          + ownerUserId + \" but userId \" + userId);\n    }\n    String path = tempBlockMeta.getPath();\n    boolean deleted = new File(path).delete();\n    if (!deleted) {\n      throw new IOException(\"Failed to abort temp block \" + blockId + \": cannot delete \" + path);\n    }\n    mMetaManager.abortTempBlockMeta(tempBlockMeta);\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"private Optional<TempBlockMeta> createBlockMetaNoLock(long userId, long blockId,\n      BlockStoreLocation location, long initialBlockSize) throws IOException {\n    Optional<TempBlockMeta> optTempBlock =\n        mAllocator.allocateBlock(userId, blockId, initialBlockSize, location);\n    if (!optTempBlock.isPresent()) {\n      // Failed to allocate a temp block, let Evictor kick in to ensure sufficient space available.\n\n      // Upgrade to write lock to guard evictor.\n      mEvictionLock.readLock().unlock();\n      mEvictionLock.writeLock().lock();\n\n      boolean result = freeSpaceNoEvictionLock(userId, initialBlockSize, location);\n\n      // Downgrade to read lock again after eviction\n      mEvictionLock.readLock().lock();\n      mEvictionLock.writeLock().unlock();\n\n      // Not enough space in this block store, let's try to free some space.\n      if (!result) {\n        LOG.error(\"Cannot free {} bytes space in {}\", initialBlockSize, location);\n        return Optional.absent();\n      }\n      optTempBlock = mAllocator.allocateBlock(userId, blockId, initialBlockSize, location);\n      Preconditions.checkState(optTempBlock.isPresent(), \"Cannot allocate block {}:\", blockId);\n    }\n    // Add allocated temp block to metadata manager\n    mMetaManager.addTempBlockMeta(optTempBlock.get());\n    return optTempBlock;\n  }","id":26507,"modified_method":"private TempBlockMeta createBlockMetaNoLock(long userId, long blockId,\n      BlockStoreLocation location, long initialBlockSize) throws IOException {\n    Optional<TempBlockMeta> optTempBlock =\n        mAllocator.allocateBlock(userId, blockId, initialBlockSize, location);\n    if (!optTempBlock.isPresent()) {\n      // Failed to allocate a temp block, let Evictor kick in to ensure sufficient space available.\n\n      // Upgrade to write lock to guard evictor.\n      mEvictionLock.readLock().unlock();\n      mEvictionLock.writeLock().lock();\n      try {\n        freeSpaceNoEvictionLock(userId, initialBlockSize, location);\n      } finally {\n        // Downgrade to read lock again after eviction\n        mEvictionLock.readLock().lock();\n        mEvictionLock.writeLock().unlock();\n      }\n      optTempBlock = mAllocator.allocateBlock(userId, blockId, initialBlockSize, location);\n      Preconditions.checkState(optTempBlock.isPresent(), \"Cannot allocate block {}:\", blockId);\n    }\n    // Add allocated temp block to metadata manager\n    mMetaManager.addTempBlockMeta(optTempBlock.get());\n    return optTempBlock.get();\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public Optional<BlockMeta> getBlockMeta(long userId, long blockId, long lockId) {\n    Preconditions.checkState(mLockManager.validateLockId(userId, blockId, lockId));\n    return mMetaManager.getBlockMeta(blockId);\n  }","id":26508,"modified_method":"@Override\n  public BlockMeta getBlockMeta(long userId, long blockId, long lockId) throws IOException {\n    mLockManager.validateLockId(userId, blockId, lockId);\n    return mMetaManager.getBlockMeta(blockId);\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean commitBlockNoLock(long userId, long blockId) {\n    Optional<TempBlockMeta> optTempBlock = mMetaManager.getTempBlockMeta(blockId);\n    if (!optTempBlock.isPresent()) {\n      return false;\n    }\n    TempBlockMeta tempBlock = optTempBlock.get();\n\n    for (BlockMetaEventListener listener: mMetaEventListeners) {\n      listener.preCommitBlock(userId, blockId, tempBlock.getBlockLocation());\n    }\n    // Check the userId is the owner of this temp block\n    if (tempBlock.getUserId() != userId) {\n      return false;\n    }\n    String sourcePath = tempBlock.getPath();\n    String destPath = tempBlock.getCommitPath();\n    boolean renamed = new File(sourcePath).renameTo(new File(destPath));\n    if (!renamed) {\n      return false;\n    }\n    if (!mMetaManager.commitTempBlockMeta(tempBlock)) {\n      return false;\n    }\n\n    for (BlockMetaEventListener listener : mMetaEventListeners) {\n      listener.postCommitBlock(userId, blockId, tempBlock.getBlockLocation());\n    }\n    return true;\n  }","id":26509,"modified_method":"private void commitBlockNoLock(long userId, long blockId) throws IOException {\n    TempBlockMeta tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n    for (BlockMetaEventListener listener : mMetaEventListeners) {\n      listener.preCommitBlock(userId, blockId, tempBlockMeta.getBlockLocation());\n    }\n    // Check the userId is the owner of this temp block\n    long ownerUserId = tempBlockMeta.getUserId();\n    if (ownerUserId != userId) {\n      throw new IOException(\"Failed to commit temp block \" + blockId + \": ownerUserId \"\n          + ownerUserId + \" but userId \" + userId);\n    }\n    String sourcePath = tempBlockMeta.getPath();\n    String destPath = tempBlockMeta.getCommitPath();\n    boolean renamed = new File(sourcePath).renameTo(new File(destPath));\n    if (!renamed) {\n      throw new IOException(\"Failed to commit temp block \" + blockId + \": cannot rename from \"\n          + sourcePath + \" to \" + destPath);\n    }\n    mMetaManager.commitTempBlockMeta(tempBlockMeta);\n    for (BlockMetaEventListener listener : mMetaEventListeners) {\n      listener.postCommitBlock(userId, blockId, tempBlockMeta.getBlockLocation());\n    }\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean commitBlock(long userId, long blockId) {\n    mEvictionLock.readLock().lock();\n    boolean result = commitBlockNoLock(userId, blockId);\n    mEvictionLock.readLock().unlock();\n    return result;\n  }","id":26510,"modified_method":"@Override\n  public void commitBlock(long userId, long blockId) throws IOException {\n    mEvictionLock.readLock().lock();\n    try {\n      commitBlockNoLock(userId, blockId);\n    } finally {\n      mEvictionLock.readLock().unlock();\n    }\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean moveBlockNoLock(long userId, long blockId, BlockStoreLocation newLocation)\n      throws IOException {\n    for (BlockMetaEventListener listener: mMetaEventListeners) {\n      listener.preMoveBlock(userId, blockId, newLocation);\n    }\n    Optional<BlockMeta> optSrcBlock = mMetaManager.getBlockMeta(blockId);\n    if (!optSrcBlock.isPresent()) {\n      return false;\n    }\n    String srcPath = optSrcBlock.get().getPath();\n    Optional<BlockMeta> optDestBlock = mMetaManager.moveBlockMeta(userId, blockId, newLocation);\n    if (!optDestBlock.isPresent()) {\n      return false;\n    }\n    String destPath = optDestBlock.get().getPath();\n\n    if (!new File(srcPath).renameTo(new File(destPath))) {\n      return false;\n    }\n\n    for (BlockMetaEventListener listener: mMetaEventListeners) {\n      listener.postMoveBlock(userId, blockId, newLocation);\n    }\n    return true;\n  }","id":26511,"modified_method":"private void moveBlockNoLock(long userId, long blockId, BlockStoreLocation newLocation)\n      throws IOException {\n    for (BlockMetaEventListener listener : mMetaEventListeners) {\n      listener.preMoveBlock(userId, blockId, newLocation);\n    }\n    BlockMeta blockMeta = mMetaManager.getBlockMeta(blockId);\n    String srcPath = blockMeta.getPath();\n    blockMeta = mMetaManager.moveBlockMeta(blockId, newLocation);\n    String destPath = blockMeta.getPath();\n\n    if (!new File(srcPath).renameTo(new File(destPath))) {\n      throw new IOException(\"Failed to move block \" + blockId + \": cannot rename from \" + srcPath\n          + \" to \" + destPath);\n    }\n\n    for (BlockMetaEventListener listener : mMetaEventListeners) {\n      listener.postMoveBlock(userId, blockId, newLocation);\n    }\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean abortBlock(long userId, long blockId) {\n    mEvictionLock.readLock().lock();\n    boolean result = abortBlockNoLock(userId, blockId);\n    mEvictionLock.readLock().unlock();\n    return result;\n  }","id":26512,"modified_method":"@Override\n  public void abortBlock(long userId, long blockId) throws IOException {\n    mEvictionLock.readLock().lock();\n    try {\n      abortBlockNoLock(userId, blockId);\n    } finally {\n      mEvictionLock.readLock().unlock();\n    }\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public Optional<BlockWriter> getBlockWriter(long userId, long blockId) throws IOException {\n    Optional<TempBlockMeta> optBlock = mMetaManager.getTempBlockMeta(blockId);\n    if (!optBlock.isPresent()) {\n      return Optional.absent();\n    }\n    BlockWriter writer = new LocalFileBlockWriter(optBlock.get());\n    return Optional.of(writer);\n  }","id":26513,"modified_method":"@Override\n  public BlockWriter getBlockWriter(long userId, long blockId) throws IOException {\n    TempBlockMeta tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n    return new LocalFileBlockWriter(tempBlockMeta);\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean cleanupUser(long userId) {\n    mEvictionLock.readLock().lock();\n    mMetaManager.cleanupUser(userId);\n    mLockManager.cleanupUser(userId);\n    mEvictionLock.readLock().unlock();\n    return true;\n  }","id":26514,"modified_method":"@Override\n  public void cleanupUser(long userId) {\n    mEvictionLock.readLock().lock();\n    mMetaManager.cleanupUser(userId);\n    mLockManager.cleanupUser(userId);\n    mEvictionLock.readLock().unlock();\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean unlockBlock(long userId, long blockId) {\n    return mLockManager.unlockBlock(userId, blockId);\n  }","id":26515,"modified_method":"@Override\n  public void unlockBlock(long userId, long blockId) throws IOException {\n    mLockManager.unlockBlock(userId, blockId);\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean requestSpace(long userId, long blockId, long moreBytes) throws IOException {\n    // TODO: Change the lock to read lock and only upgrade to write lock if necessary\n    mEvictionLock.writeLock().lock();\n    boolean result = requestSpaceNoLock(userId, blockId, moreBytes);\n    mEvictionLock.writeLock().unlock();\n    return result;\n  }","id":26516,"modified_method":"@Override\n  public void requestSpace(long userId, long blockId, long moreBytes) throws IOException {\n    // TODO: Change the lock to read lock and only upgrade to write lock if necessary\n    mEvictionLock.writeLock().lock();\n    try {\n      requestSpaceNoLock(userId, blockId, moreBytes);\n    } finally {\n      mEvictionLock.writeLock().unlock();\n    }\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public Optional<TempBlockMeta> createBlockMeta(long userId, long blockId,\n      BlockStoreLocation location, long initialBlockSize) throws IOException {\n    mEvictionLock.readLock().lock();\n    Optional<TempBlockMeta> optTempBlock =\n        createBlockMetaNoLock(userId, blockId, location, initialBlockSize);\n    mEvictionLock.readLock().unlock();\n    return optTempBlock;\n  }","id":26517,"modified_method":"@Override\n  public TempBlockMeta createBlockMeta(long userId, long blockId, BlockStoreLocation location,\n      long initialBlockSize) throws IOException {\n    TempBlockMeta tempBlock;\n    mEvictionLock.readLock().lock();\n    try {\n      tempBlock = createBlockMetaNoLock(userId, blockId, location, initialBlockSize);\n    } finally {\n      mEvictionLock.readLock().unlock();\n    }\n    return tempBlock;\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean removeBlock(long userId, long blockId) throws IOException {\n    mEvictionLock.readLock().lock();\n    Optional<Long> optLock = mLockManager.lockBlock(userId, blockId, BlockLockType.WRITE);\n    // If we fail to lock, the block is no longer in tiered store, so return true\n    if (!optLock.isPresent()) {\n      mEvictionLock.readLock().unlock();\n      return true;\n    }\n    long lockId = optLock.get();\n    boolean result = removeBlockNoLock(userId, blockId);\n    mLockManager.unlockBlock(lockId);\n    mEvictionLock.readLock().unlock();\n    return result;\n  }","id":26518,"modified_method":"@Override\n  public void removeBlock(long userId, long blockId) throws IOException {\n    mEvictionLock.readLock().lock();\n    try {\n      long lockId = mLockManager.lockBlock(userId, blockId, BlockLockType.WRITE);\n      try {\n        removeBlockNoLock(userId, blockId);\n      } finally {\n        mLockManager.unlockBlock(lockId);\n      }\n    } finally {\n      // If we fail to lock, the block is no longer in tiered store\n      mEvictionLock.readLock().unlock();\n    }\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean freeSpaceNoEvictionLock(long userId, long availableBytes,\n      BlockStoreLocation location) throws IOException {\n    Optional<EvictionPlan> optPlan = mEvictor.freeSpace(availableBytes, location);\n    // Absent plan means failed to evict enough space.\n    if (!optPlan.isPresent()) {\n      LOG.error(\"Failed to free space: no eviction plan by evictor\");\n      return false;\n    }\n    EvictionPlan plan = optPlan.get();\n    // Step1: remove blocks to make room.\n    for (long blockId : plan.toEvict()) {\n      // TODO: Handle absent\n      long lockId = mLockManager.lockBlock(userId, blockId, BlockLockType.WRITE).get();\n      boolean result = removeBlockNoLock(userId, blockId);\n      mLockManager.unlockBlock(lockId);\n      if (!result) {\n        LOG.error(\"Failed to free space: cannot evict block {}\", blockId);\n        return false;\n      }\n    }\n    // Step2: transfer blocks among tiers.\n    for (Pair<Long, BlockStoreLocation> entry : plan.toMove()) {\n      long blockId = entry.getFirst();\n      BlockStoreLocation newLocation = entry.getSecond();\n      // TODO: Handle absent\n      long lockId = mLockManager.lockBlock(userId, blockId, BlockLockType.WRITE).get();\n      boolean result = moveBlockNoLock(userId, blockId, newLocation);\n      mLockManager.unlockBlock(lockId);\n      if (!result) {\n        LOG.error(\"Failed to free space: cannot move block {} to {}\", blockId, newLocation);\n        return false;\n      }\n    }\n    return true;\n  }","id":26519,"modified_method":"private void freeSpaceNoEvictionLock(long userId, long availableBytes, BlockStoreLocation location)\n      throws IOException {\n    Optional<EvictionPlan> optPlan = mEvictor.freeSpace(availableBytes, location);\n    // Absent plan means failed to evict enough space.\n    if (!optPlan.isPresent()) {\n      throw new IOException(\"Failed to free space: no eviction plan by evictor\");\n    }\n    EvictionPlan plan = optPlan.get();\n    // Step1: remove blocks to make room.\n    for (long blockId : plan.toEvict()) {\n      long lockId = mLockManager.lockBlock(userId, blockId, BlockLockType.WRITE);\n      try {\n        removeBlockNoLock(userId, blockId);\n      } catch (IOException e) {\n        throw new IOException(\"Failed to free space: cannot evict block \" + blockId);\n      } finally {\n        mLockManager.unlockBlock(lockId);\n      }\n    }\n    // Step2: transfer blocks among tiers.\n    for (Pair<Long, BlockStoreLocation> entry : plan.toMove()) {\n      long blockId = entry.getFirst();\n      BlockStoreLocation newLocation = entry.getSecond();\n      long lockId = mLockManager.lockBlock(userId, blockId, BlockLockType.WRITE);\n      try {\n        moveBlockNoLock(userId, blockId, newLocation);\n      } catch (IOException e) {\n        throw new IOException(\"Failed to free space: cannot move block \" + blockId + \" to \"\n            + newLocation);\n      } finally {\n        mLockManager.unlockBlock(lockId);\n      }\n    }\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean unlockBlock(long lockId) {\n    return mLockManager.unlockBlock(lockId);\n  }","id":26520,"modified_method":"@Override\n  public void unlockBlock(long lockId) throws IOException {\n    mLockManager.unlockBlock(lockId);\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public Optional<BlockReader> getBlockReader(long userId, long blockId, long lockId)\n      throws IOException {\n    Preconditions.checkState(mLockManager.validateLockId(userId, blockId, lockId));\n\n    Optional<BlockMeta> optBlock = mMetaManager.getBlockMeta(blockId);\n    if (!optBlock.isPresent()) {\n      return Optional.absent();\n    }\n    BlockReader reader = new LocalFileBlockReader(optBlock.get());\n    return Optional.of(reader);\n  }","id":26521,"modified_method":"@Override\n  public BlockReader getBlockReader(long userId, long blockId, long lockId) throws IOException {\n    mLockManager.validateLockId(userId, blockId, lockId);\n    BlockMeta blockMeta = mMetaManager.getBlockMeta(blockId);\n    return new LocalFileBlockReader(blockMeta);\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean removeBlockNoLock(long userId, long blockId) throws IOException {\n    for (BlockMetaEventListener listener: mMetaEventListeners) {\n      listener.preRemoveBlock(userId, blockId);\n    }\n\n    Optional<BlockMeta> optBlock = mMetaManager.getBlockMeta(blockId);\n    if (!optBlock.isPresent()) {\n      LOG.error(\"Block is not present\");\n      return false;\n    }\n    BlockMeta block = optBlock.get();\n    // Delete metadata of the block\n    if (!mMetaManager.removeBlockMeta(block)) {\n      LOG.error(\"Unable to remove metadata\");\n      return false;\n    }\n    // Delete the data file of the block\n    if (!new File(block.getPath()).delete()) {\n      return false;\n    }\n\n    for (BlockMetaEventListener listener: mMetaEventListeners) {\n      listener.postRemoveBlock(userId, blockId);\n    }\n    return true;\n  }","id":26522,"modified_method":"private void removeBlockNoLock(long userId, long blockId) throws IOException {\n    for (BlockMetaEventListener listener : mMetaEventListeners) {\n      listener.preRemoveBlock(userId, blockId);\n    }\n\n    BlockMeta blockMeta = mMetaManager.getBlockMeta(blockId);\n    // Delete metadata of the block\n    mMetaManager.removeBlockMeta(blockMeta);\n\n    // Delete the data file of the block\n    if (!new File(blockMeta.getPath()).delete()) {\n      throw new IOException(\"Failed to remove block \" + blockId + \": cannot delete \"\n          + blockMeta.getPath());\n    }\n\n    for (BlockMetaEventListener listener : mMetaEventListeners) {\n      listener.postRemoveBlock(userId, blockId);\n    }\n  }","commit_id":"a33caf487a1d8fce18b7c5b41243add50a4e99b4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Remove a block from current StorageDir\n   * \n   * @param blockId Id of the block to be removed.\n   * @return true if succeed, false otherwise\n   * @throws IOException\n   */\n  public boolean deleteBlock(long blockId) throws IOException {\n    Long accessTimeMs = mLastBlockAccessTimeMs.remove(blockId);\n    if (accessTimeMs != null) {\n      String blockfile = getBlockFilePath(blockId);\n      boolean result = false;\n      try {\n        // Should check lock status here \n        if (!isBlockLocked(blockId)) {\n          result = mFs.delete(blockfile, true);\n        } else {\n          mToRemoveBlockIdSet.add(blockId);\n        }\n      } finally {\n        if (result) {\n          deleteBlockId(blockId);\n          LOG.debug(\"Removed block file:{}\", blockfile);\n        } else {\n          mLastBlockAccessTimeMs.put(blockId, accessTimeMs);\n          LOG.error(\"Failed to delete block file! filename:{}\", blockfile);\n        }\n      }\n      return result;\n    } else {\n      LOG.warn(\"Block does not exist in current StorageDir! blockId:{}\", blockId);\n      return false;\n    }\n  }","id":26523,"modified_method":"/**\n   * Remove a block from current StorageDir, once user calls this method, the block will not be\n   * available any longer.\n   * \n   * @param blockId Id of the block to be removed.\n   * @return true if succeed, false otherwise\n   * @throws IOException\n   */\n  public boolean deleteBlock(long blockId) throws IOException {\n    Long accessTimeMs = mLastBlockAccessTimeMs.remove(blockId);\n    if (accessTimeMs != null) {\n      String blockfile = getBlockFilePath(blockId);\n      // Should check lock status here \n      if (!isBlockLocked(blockId)) {\n        if (!mFs.delete(blockfile, false)) {\n          LOG.error(\"Failed to delete block file! filename:{}\", blockfile);\n          return false;\n        }\n        deleteBlockId(blockId);\n      } else {\n        mToRemoveBlockIdSet.add(blockId);\n        LOG.debug(\"Add block file {} to remove list!\", blockfile);\n      }\n      return true;\n    } else {\n      LOG.warn(\"Block does not exist in current StorageDir! blockId:{}\", blockId);\n      return false;\n    }\n  }","commit_id":"6e9b9105de78c83b61c0d28768af0ae3ea7d4dc3","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Check whether the StorageDir contains certain block\n   * \n   * @param blockId Id of the block\n   * @return true if StorageDir contains the block, false otherwise\n   */\n  public boolean containsBlock(long blockId) {\n    return mLastBlockAccessTimeMs.containsKey(blockId) || isBlockLocked(blockId);\n  }","id":26524,"modified_method":"/**\n   * Check whether the StorageDir contains certain block\n   * \n   * @param blockId Id of the block\n   * @return true if StorageDir contains the block, false otherwise\n   */\n  public boolean containsBlock(long blockId) {\n    return mLastBlockAccessTimeMs.containsKey(blockId);\n  }","commit_id":"6e9b9105de78c83b61c0d28768af0ae3ea7d4dc3","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Unlock block by some user\n   * \n   * @param blockId Id of the block\n   * @param userId Id of the user\n   * @return true if success, false otherwise\n   */\n  public boolean unlockBlock(long blockId, long userId) {\n    if (!containsBlock(blockId)) {\n      return false;\n    }\n    mUserPerLockedBlock.remove(blockId, userId);\n    mLockedBlocksPerUser.remove(userId, blockId);\n    if (!mUserPerLockedBlock.containsKey(blockId) && mToRemoveBlockIdSet.contains(blockId)) {\n      try {\n        if (deleteBlock(blockId)) {\n          mToRemoveBlockIdSet.remove(blockId);\n        }\n      } catch (IOException e) {\n        LOG.error(e.getMessage(), e);\n        return false;\n      }\n    }\n    return true;\n  }","id":26525,"modified_method":"/**\n   * Unlock block by some user\n   * \n   * @param blockId Id of the block\n   * @param userId Id of the user\n   * @return true if success, false otherwise\n   */\n  public boolean unlockBlock(long blockId, long userId) {\n    if (mUserPerLockedBlock.remove(blockId, userId) \n        && mLockedBlocksPerUser.remove(userId, blockId)) {\n      if (!isBlockLocked(blockId) && mToRemoveBlockIdSet.contains(blockId)) {\n        try {\n          if (!mFs.delete(getBlockFilePath(blockId), false)) {\n            return false;\n          }\n          mToRemoveBlockIdSet.remove(blockId);\n          deleteBlockId(blockId);\n        } catch (IOException e) {\n          LOG.error(e.getMessage(), e);\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }","commit_id":"6e9b9105de78c83b61c0d28768af0ae3ea7d4dc3","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Lock the block by some user\n   * \n   * Used internally to make sure blocks are unmodified, but also used in\n   * {@link tachyon.client.TachyonFS} for caching blocks locally for users. When a user tries to\n   * read a block ({@link tachyon.client.TachyonFile#readByteBuffer(int)} ()}), the client will\n   * attempt to cache the block on the local users's node, while the user is reading from the local\n   * block, the given block is locked and unlocked once read.\n   * \n   * @param blockId The id of the block\n   * @param userId The id of the user who locks the block\n   * @return the StorageDir in which the block is locked\n   */\n  public StorageDir lockBlock(long blockId, long userId) {\n    StorageDir storageDir = getStorageDirByBlockId(blockId);\n    if (storageDir != null) {\n      if (storageDir.lockBlock(blockId, userId)) {\n        return storageDir;\n      }\n    }\n    LOG.warn(\"Failed to lock block! blockId:{}\", blockId);\n    return null;\n  }","id":26526,"modified_method":"/**\n   * Lock the block by some user\n   * \n   * Used internally to make sure blocks are unmodified, but also used in\n   * {@link tachyon.client.TachyonFS} for caching blocks locally for users. When a user tries to\n   * read a block ({@link tachyon.client.TachyonFile#readByteBuffer(int)} ()}), the client will\n   * attempt to cache the block on the local users's node, while the user is reading from the local\n   * block, the given block is locked and unlocked once read.\n   * \n   * @param blockId The id of the block\n   * @param userId The id of the user who locks the block\n   * @return the StorageDir in which the block is locked\n   */\n  public StorageDir lockBlock(long blockId, long userId) {\n    for (StorageTier tier : mStorageTiers) {\n      for (StorageDir dir : tier.getStorageDirs()) {\n        if (dir.lockBlock(blockId, userId)) {\n          return dir;\n        }\n      }\n    }\n    LOG.warn(\"Failed to lock block! blockId:{}\", blockId);\n    return null;\n  }","commit_id":"6e9b9105de78c83b61c0d28768af0ae3ea7d4dc3","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Unlock the block\n   * \n   * Used internally to make sure blocks are unmodified, but also used in\n   * {@link tachyon.client.TachyonFS} for cacheing blocks locally for users. When a user tries to\n   * read a block ({@link tachyon.client.TachyonFile#readByteBuffer(int)}), the client will attempt\n   * to cache the block on the local users's node, while the user is reading from the local block,\n   * the given block is locked and unlocked once read.\n   * \n   * @param blockId The id of the block\n   * @param userId The id of the user who unlocks the block\n   * @return true if success, false otherwise\n   */\n  public boolean unlockBlock(long blockId, long userId) {\n    StorageDir storageDir = getStorageDirByBlockId(blockId);\n    if (storageDir != null) {\n      return storageDir.unlockBlock(blockId, userId);\n    }\n    LOG.warn(\"Failed to unlock block! blockId:{}\", blockId);\n    return false;\n  }","id":26527,"modified_method":"/**\n   * Unlock the block\n   * \n   * Used internally to make sure blocks are unmodified, but also used in\n   * {@link tachyon.client.TachyonFS} for cacheing blocks locally for users. When a user tries to\n   * read a block ({@link tachyon.client.TachyonFile#readByteBuffer(int)}), the client will attempt\n   * to cache the block on the local users's node, while the user is reading from the local block,\n   * the given block is locked and unlocked once read.\n   * \n   * @param blockId The id of the block\n   * @param userId The id of the user who unlocks the block\n   * @return true if success, false otherwise\n   */\n  public boolean unlockBlock(long blockId, long userId) {\n    for (StorageTier tier : mStorageTiers) {\n      for (StorageDir dir : tier.getStorageDirs()) {\n        if (dir.unlockBlock(blockId, userId)) {\n          return true;\n        }\n      }\n    }\n    LOG.warn(\"Failed to unlock block! blockId:{}\", blockId);\n    return false;\n  }","commit_id":"6e9b9105de78c83b61c0d28768af0ae3ea7d4dc3","url":"https://github.com/amplab/tachyon"},{"original_method":"public void testFragmentHost() throws ManifestHolderDisposedException {\n    Set<ManifestHolder> fragmentHosts = myCache.getFragmentHosts(myFragmentHolder);\n    assertThat(fragmentHosts, notNullValue());\n    assertThat(fragmentHosts.size(), is(1));\n    assertThat(fragmentHosts.iterator().next().getBundleManifest().getBundleSymbolicName(), equalTo(\"foo.bar\"));\n  }","id":26528,"modified_method":"public void testFragmentHost() throws ManifestHolderDisposedException {\n    Set<ManifestHolder> fragmentHosts = myCache.getFragmentHosts(myFragmentHolder);\n    assertThat(fragmentHosts, notNullValue());\n    assertThat(fragmentHosts.size(), is(1));\n    assertThat(getManifest(fragmentHosts.iterator().next()).getBundleSymbolicName(), equalTo(\"foo.bar\"));\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testRequiredBundleWithVersion() throws ManifestHolderDisposedException {\n    ManifestHolder manifestHolder = myCache.whoIsRequiredBundle(\"foo.bam;bundle-version=1.2.0\");\n    assertThat(manifestHolder, notNullValue());\n    BundleManifest bundleManifest = manifestHolder.getBundleManifest();\n    assertThat(bundleManifest.getBundleSymbolicName(), equalTo(\"foo.bam\"));\n\n    // should pick largest available version\n    assertThat(bundleManifest.getBundleVersion().toString(), equalTo(\"1.2.3\"));\n  }","id":26529,"modified_method":"public void testRequiredBundleWithVersion() throws ManifestHolderDisposedException {\n    ManifestHolder manifestHolder = myCache.whoIsRequiredBundle(\"foo.bam;bundle-version=1.2.0\");\n    assertThat(manifestHolder, notNullValue());\n    BundleManifest bundleManifest = getManifest(manifestHolder);\n    assertThat(bundleManifest.getBundleSymbolicName(), equalTo(\"foo.bam\"));\n\n    // should pick largest available version\n    assertThat(bundleManifest.getBundleVersion().toString(), equalTo(\"1.2.3\"));\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private static ManifestHolder makeManifestHolder(@NotNull String fileName, @NotNull String manifestContents) {\n    return new TestManifestHolder((ManifestFile)createLightFile(fileName, manifestContents));\n  }","id":26530,"modified_method":"@NotNull\n  private static ManifestHolder makeManifestHolder(@NotNull String fileName, @NotNull ManifestMaker builder) {\n    return new TestManifestHolder((ManifestFile)createLightFile(fileName, builder.toString()));\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testSingleBundleLookup() throws ManifestHolderDisposedException {\n    List<ManifestHolder> manifestHolders = myCache.whoIs(\"foo.bar\");\n    assertThat(manifestHolders, notNullValue());\n    assertThat(manifestHolders.size(), is(1));\n    assertThat(manifestHolders.get(0).getBundleManifest().getBundleSymbolicName(), equalTo(\"foo.bar\"));\n  }","id":26531,"modified_method":"public void testSingleBundleLookup() throws ManifestHolderDisposedException {\n    List<ManifestHolder> manifestHolders = myCache.whoIs(\"foo.bar\");\n    assertThat(manifestHolders, notNullValue());\n    assertThat(manifestHolders.size(), is(1));\n    assertThat(getManifest(manifestHolders.get(0)).getBundleSymbolicName(), equalTo(\"foo.bar\"));\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Before\n  public void setUp() throws Exception {\n    super.setUp();\n    myCache = new BundleCache();\n    myCache.updateWith(makeManifestHolder(\"MANIFEST.MF\", bundleSymbolicName(\"foo.bar\").bundleVersion(\"1.0.0\").exportPackages(\"foo.bar\")\n      .toString()));\n\n    myCache.updateWith(makeManifestHolder(\"MANIFEST2.MF\", bundleSymbolicName(\"foo.bam\").bundleVersion(\"1.2.0\")\n      .exportPackages(\"foo.bam;version=1.2.0\").importPackages(\"foo.bar\").toString()));\n\n    myCache.updateWith(makeManifestHolder(\"MANIFEST3.MF\", bundleSymbolicName(\"foo.bam\").bundleVersion(\"1.2.3\")\n      .exportPackages(\"foo.bam; version=1.2.3\").importPackages(\"foo.bar\").toString()));\n    myCache.updateWith(\n      makeManifestHolder(\"MANIFEST4.MF\", bundleSymbolicName(\"foo.baz\").bundleVersion(\"1.2.1\").exportPackages(\"foo.baz;version=1.2.0\")\n        .importPackages(\"foo.bar\", \"foo.bam;version=\\\"[1.2.3,2.0.0)\\\"\").toString()));\n\n    myFragmentHolder = makeManifestHolder(\"MANIFEST5.MF\", bundleSymbolicName(\"foo.bar.narf\").bundleVersion(\"1.0.1\")\n      .exportPackages(\"foo.bar.narf;version=1.0.1\").importPackages(\"foo.bar\").fragmentHost(\"foo.bar\").toString());\n\n    myCache.updateWith(myFragmentHolder);\n  }","id":26532,"modified_method":"@Before\n  public void setUp() throws Exception {\n    super.setUp();\n\n    myCache = new BundleCache();\n    myCache.updateWith(makeManifestHolder(\n      \"MANIFEST.MF\",\n      bundleSymbolicName(\"foo.bar\").bundleVersion(\"1.0.0\").exportPackages(\"foo.bar\")));\n    myCache.updateWith(makeManifestHolder(\n      \"MANIFEST2.MF\",\n      bundleSymbolicName(\"foo.bam\").bundleVersion(\"1.2.0\").exportPackages(\"foo.bam;version=1.2.0\").importPackages(\"foo.bar\")));\n    myCache.updateWith(makeManifestHolder(\n      \"MANIFEST3.MF\",\n      bundleSymbolicName(\"foo.bam\").bundleVersion(\"1.2.3\").exportPackages(\"foo.bam; version=1.2.3\").importPackages(\"foo.bar\")));\n    myCache.updateWith(makeManifestHolder(\n      \"MANIFEST4.MF\",\n      bundleSymbolicName(\"foo.baz\").bundleVersion(\"1.2.1\").exportPackages(\"foo.baz;version=1.2.0\")\n        .importPackages(\"foo.bar\", \"foo.bam;version=\\\"[1.2.3,2.0.0)\\\"\")));\n    myCache.updateWith(myFragmentHolder = makeManifestHolder(\n      \"MANIFEST5.MF\",\n      bundleSymbolicName(\"foo.bar.naff\").bundleVersion(\"1.0.1\").exportPackages(\"foo.bar.naff;version=1.0.1\").importPackages(\"foo.bar\")\n        .fragmentHost(\"foo.bar\")));\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testRequiredBundleWithVersionRange() throws ManifestHolderDisposedException {\n    ManifestHolder manifestHolder = myCache.whoIsRequiredBundle(\"foo.bam;bundle-version=\\\"[1.2.0,1.2.3)\\\"\");\n    assertThat(manifestHolder, notNullValue());\n    BundleManifest bundleManifest = manifestHolder.getBundleManifest();\n    assertThat(bundleManifest.getBundleSymbolicName(), equalTo(\"foo.bam\"));\n    // 1.2.3 is not allowed by version range.\n    assertThat(bundleManifest.getBundleVersion().toString(), equalTo(\"1.2.0\"));\n  }","id":26533,"modified_method":"public void testRequiredBundleWithVersionRange() throws ManifestHolderDisposedException {\n    ManifestHolder manifestHolder = myCache.whoIsRequiredBundle(\"foo.bam;bundle-version=\\\"[1.2.0,1.2.3)\\\"\");\n    assertThat(manifestHolder, notNullValue());\n    BundleManifest bundleManifest = getManifest(manifestHolder);\n    assertThat(bundleManifest.getBundleSymbolicName(), equalTo(\"foo.bam\"));\n    // 1.2.3 is not allowed by version range.\n    assertThat(bundleManifest.getBundleVersion().toString(), equalTo(\"1.2.0\"));\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testConcurrentUpdates() {\n    Thread updateThread1 = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        for (int i = 0; i < 1000; i++) {\n          myCache.updateWith(makeManifestHolder(\"MANIFEST_T1_\" + i + \".MF\",  bundleSymbolicName(\"foo.bar.t1\").bundleVersion(\"1.0.\"+i).toString()));\n        }\n        System.out.println(\"T1 done\");\n      }\n    });\n    Thread updateThread2 = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        for (int i = 0; i < 1000; i++) {\n          myCache.updateWith(makeManifestHolder(\"MANIFEST_T2_\" + i + \".MF\", bundleSymbolicName(\"foo.bar.t2\").bundleVersion(\"1.0.\"+i).toString()));\n        }\n        System.out.println(\"T2 done\");\n      }\n    });\n    CancelableRunnable cancelableRunnable = new CancelableRunnable() {\n      @Override\n      public void run() {\n        for (int i = 0; i < 1000 && !requestStop; i++) {\n          myCache.whoIs(\"foo.bar.t1\");\n        }\n        System.out.println(\"T3 done\");\n      }\n    };\n    Thread readThread = new Thread(cancelableRunnable);\n\n    updateThread1.start();\n    updateThread2.start();\n    readThread.start();\n\n    long elapsed = 0;\n    long last = System.currentTimeMillis();\n    while (updateThread1.isAlive() || updateThread2.isAlive()) {\n      elapsed += System.currentTimeMillis() - last;\n      last = System.currentTimeMillis();\n      if (elapsed > 10000) { // should be easily doable within 10 seconds\n        fail(\"Probable deadlock in BundleCache\");\n      }\n      try {\n        //noinspection BusyWait\n        Thread.sleep(500);\n      }\n      catch (InterruptedException ignore) {\n        // ok\n      }\n    }\n    cancelableRunnable.requestStop = true;\n  }","id":26534,"modified_method":"public void testConcurrentUpdates() {\n    Thread updateThread1 = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        for (int i = 0; i < 1000; i++) {\n          myCache.updateWith(makeManifestHolder(\"MANIFEST_T1_\" + i + \".MF\",  bundleSymbolicName(\"foo.bar.t1\").bundleVersion(\"1.0.\"+i)));\n        }\n        System.out.println(\"T1 done\");\n      }\n    });\n    Thread updateThread2 = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        for (int i = 0; i < 1000; i++) {\n          myCache.updateWith(makeManifestHolder(\"MANIFEST_T2_\" + i + \".MF\", bundleSymbolicName(\"foo.bar.t2\").bundleVersion(\"1.0.\"+i)));\n        }\n        System.out.println(\"T2 done\");\n      }\n    });\n    CancelableRunnable cancelableRunnable = new CancelableRunnable() {\n      @Override\n      public void run() {\n        for (int i = 0; i < 1000 && !requestStop; i++) {\n          myCache.whoIs(\"foo.bar.t1\");\n        }\n        System.out.println(\"T3 done\");\n      }\n    };\n    Thread readThread = new Thread(cancelableRunnable);\n\n    updateThread1.start();\n    updateThread2.start();\n    readThread.start();\n\n    long elapsed = 0;\n    long last = System.currentTimeMillis();\n    while (updateThread1.isAlive() || updateThread2.isAlive()) {\n      elapsed += System.currentTimeMillis() - last;\n      last = System.currentTimeMillis();\n      if (elapsed > 10000) { // should be easily doable within 10 seconds\n        fail(\"Probable deadlock in BundleCache\");\n      }\n      try {\n        //noinspection BusyWait\n        Thread.sleep(500);\n      }\n      catch (InterruptedException ignore) {\n        // ok\n      }\n    }\n    cancelableRunnable.requestStop = true;\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testRequiredBundleWithoutVersion() throws ManifestHolderDisposedException {\n    ManifestHolder manifestHolder = myCache.whoIsRequiredBundle(\"foo.bam\");\n    assertThat(manifestHolder, notNullValue());\n    BundleManifest bundleManifest = manifestHolder.getBundleManifest();\n    assertThat(bundleManifest.getBundleSymbolicName(), equalTo(\"foo.bam\"));\n\n    // should pick largest available version\n    assertThat(bundleManifest.getBundleVersion().toString(), equalTo(\"1.2.3\"));\n  }","id":26535,"modified_method":"public void testRequiredBundleWithoutVersion() throws ManifestHolderDisposedException {\n    ManifestHolder manifestHolder = myCache.whoIsRequiredBundle(\"foo.bam\");\n    assertThat(manifestHolder, notNullValue());\n    BundleManifest bundleManifest = getManifest(manifestHolder);\n    assertThat(bundleManifest.getBundleSymbolicName(), equalTo(\"foo.bam\"));\n\n    // should pick largest available version\n    assertThat(bundleManifest.getBundleVersion().toString(), equalTo(\"1.2.3\"));\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Test\n  public void testVersionRangeRequireBundle() {\n    PsiFile provider1 = createLightFile(\"MANIFEST.MF\", Manifest1);\n    BundleManifestImpl providerManifest1 = new BundleManifestImpl((ManifestFile)provider1);\n\n    PsiFile provider2 = createLightFile(\"MANIFEST2.MF\", Manifest2);\n    BundleManifestImpl providerManifest2 = new BundleManifestImpl((ManifestFile)provider2);\n\n    PsiFile requestor = createLightFile(\"MANIFEST5.MF\", Manifest5);\n    BundleManifestImpl requestorManifest = new BundleManifestImpl((ManifestFile)requestor);\n\n    List<String> requiredBundles = requestorManifest.getRequiredBundles();\n    assertThat(requiredBundles.size(), is(1));\n    assertThat(providerManifest1.isRequiredBundle(requiredBundles.iterator().next()), is(false));\n    assertThat(providerManifest2.isRequiredBundle(requiredBundles.iterator().next()), is(true));\n  }","id":26536,"modified_method":"public void testVersionRangeRequireBundle() {\n    BundleManifest providerManifest1 = getManifest(Manifest1);\n    BundleManifest providerManifest2 = getManifest(Manifest2);\n    BundleManifest requestorManifest = getManifest(Manifest5);\n\n    List<String> requiredBundles = requestorManifest.getRequiredBundles();\n    assertThat(requiredBundles.size(), is(1));\n    assertThat(providerManifest1.isRequiredBundle(requiredBundles.get(0)), is(false));\n    assertThat(providerManifest2.isRequiredBundle(requiredBundles.get(0)), is(true));\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Test\n  public void testReexport() {\n    PsiFile provider = createLightFile(\"MANIFEST2.MF\", Manifest2);\n    BundleManifestImpl providerManifest = new BundleManifestImpl((ManifestFile)provider);\n\n    PsiFile requestor1 = createLightFile(\"MANIFEST5.MF\", Manifest5);\n    BundleManifestImpl requestorManifest1 = new BundleManifestImpl((ManifestFile)requestor1);\n\n    PsiFile requestor2 = createLightFile(\"MANIFEST7.MF\", Manifest7);\n    BundleManifestImpl requestorManifest2 = new BundleManifestImpl((ManifestFile)requestor2);\n\n    assertThat(requestorManifest1.reExportsBundle(providerManifest), is(false));\n    assertThat(requestorManifest2.reExportsBundle(providerManifest), is(true));\n  }","id":26537,"modified_method":"public void testReexport() {\n    BundleManifest providerManifest = getManifest(Manifest2);\n    BundleManifest requestorManifest1 = getManifest(Manifest5);\n    BundleManifest requestorManifest2 = getManifest(Manifest7);\n\n    assertThat(requestorManifest1.reExportsBundle(providerManifest), is(false));\n    assertThat(requestorManifest2.reExportsBundle(providerManifest), is(true));\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Test\n  public void testExportsPackage() {\n    PsiFile lightFile = createLightFile(\"MANIFEST.MF\", Manifest1);\n    BundleManifest bundleManifest = new BundleManifestImpl((ManifestFile)lightFile);\n\n    assertThat(bundleManifest.getBundleSymbolicName(), equalTo(\"foo.bar\"));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz\"), is(true));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.bam\"), is(true));\n    assertThat(bundleManifest.exportsPackage(\"narf.blah\"), is(false));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz;version=1.0.0\"), is(true));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz;version=2.0.0\"), is(false));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz;version=\\\"[1.0.0, 2.0.0)\\\"\"), is(true));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz;version=\\\"[1.1.0, 2.0.0)\\\"\"), is(false));\n  }","id":26538,"modified_method":"public void testExportsPackage() {\n    BundleManifest bundleManifest = getManifest(Manifest1);\n\n    assertThat(bundleManifest.getBundleSymbolicName(), equalTo(\"foo.bar\"));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz\"), is(true));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.bam\"), is(true));\n    assertThat(bundleManifest.exportsPackage(\"naff.blah\"), is(false));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz;version=1.0.0\"), is(true));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz;version=2.0.0\"), is(false));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz;version=\\\"[1.0.0, 2.0.0)\\\"\"), is(true));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz;version=\\\"[1.1.0, 2.0.0)\\\"\"), is(false));\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Test\n  public void testFragmenBundles() {\n    PsiFile potentialHost1File = createLightFile(\"MANIFEST.MF\", Manifest1);\n    BundleManifestImpl potentialHost1 = new BundleManifestImpl((ManifestFile)potentialHost1File);\n\n    PsiFile potentialHost2File = createLightFile(\"MANIFEST2.MF\", Manifest2);\n    BundleManifestImpl potentialHost2 = new BundleManifestImpl((ManifestFile)potentialHost2File);\n\n    PsiFile fragmenFile = createLightFile(\"MANIFEST8.MF\", Manifest8);\n    BundleManifestImpl fragment = new BundleManifestImpl((ManifestFile)fragmenFile);\n\n    assertThat(fragment.isFragmentBundle(), is(true));\n    assertThat(potentialHost1.isFragmentBundle(), is(false));\n    assertThat(potentialHost2.isFragmentBundle(), is(false));\n    assertThat(potentialHost1.isFragmentHostFor(fragment), is(false));\n    assertThat(potentialHost2.isFragmentHostFor(fragment), is(true));\n  }","id":26539,"modified_method":"public void testFragmentBundles() {\n    BundleManifest potentialHost1 = getManifest(Manifest1);\n    BundleManifest potentialHost2 = getManifest(Manifest2);\n    BundleManifest fragment = getManifest(Manifest8);\n\n    assertThat(fragment.isFragmentBundle(), is(true));\n    assertThat(potentialHost1.isFragmentBundle(), is(false));\n    assertThat(potentialHost2.isFragmentBundle(), is(false));\n    assertThat(potentialHost1.isFragmentHostFor(fragment), is(false));\n    assertThat(potentialHost2.isFragmentHostFor(fragment), is(true));\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Test\n  public void testMultipleRequirements() {\n    PsiFile requestor = createLightFile(\"MANIFEST6.MF\", Manifest6);\n    BundleManifestImpl requestorManifest = new BundleManifestImpl((ManifestFile)requestor);\n    List<String> requiredBundles = requestorManifest.getRequiredBundles();\n    assertThat(requiredBundles.size(), is(3));\n    assertThat(requiredBundles.get(0), equalTo(\"foo.bar;bundle-version=\\\"(2.0.0, 2.5.0]\\\"\"));\n    assertThat(requiredBundles.get(1), equalTo(\"foo.bam\"));\n    assertThat(requiredBundles.get(2), equalTo(\"foo.baz;bundle-version=10.0.5\"));\n  }","id":26540,"modified_method":"public void testMultipleRequirements() {\n    BundleManifest requestorManifest = getManifest(Manifest6);\n\n    List<String> requiredBundles = requestorManifest.getRequiredBundles();\n    assertThat(requiredBundles.size(), is(3));\n    assertThat(requiredBundles.get(0), equalTo(\"foo.bar;bundle-version=\\\"(2.0.0, 2.5.0]\\\"\"));\n    assertThat(requiredBundles.get(1), equalTo(\"foo.bam\"));\n    assertThat(requiredBundles.get(2), equalTo(\"foo.baz;bundle-version=10.0.5\"));\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Test\n  public void testVersionedRequireBundle() {\n    PsiFile provider1 = createLightFile(\"MANIFEST.MF\", Manifest1);\n    BundleManifestImpl providerManifest1 = new BundleManifestImpl((ManifestFile)provider1);\n\n    PsiFile provider2 = createLightFile(\"MANIFEST2.MF\", Manifest2);\n    BundleManifestImpl providerManifest2 = new BundleManifestImpl((ManifestFile)provider2);\n\n    PsiFile requestor = createLightFile(\"MANIFEST4.MF\", Manifest4);\n    BundleManifestImpl requestorManifest = new BundleManifestImpl((ManifestFile)requestor);\n\n    List<String> requiredBundles = requestorManifest.getRequiredBundles();\n    assertThat(requiredBundles.size(), is(1));\n    assertThat(providerManifest1.isRequiredBundle(requiredBundles.iterator().next()), is(true));\n    assertThat(providerManifest2.isRequiredBundle(requiredBundles.iterator().next()), is(true)); // 1.0.0 is implict [1.0.0, infinity], so should be true\n  }","id":26541,"modified_method":"public void testVersionedRequireBundle() {\n    BundleManifest providerManifest1 = getManifest(Manifest1);\n    BundleManifest providerManifest2 = getManifest(Manifest2);\n    BundleManifest requestorManifest = getManifest(Manifest4);\n\n    List<String> requiredBundles = requestorManifest.getRequiredBundles();\n    assertThat(requiredBundles.size(), is(1));\n    assertThat(providerManifest1.isRequiredBundle(requiredBundles.get(0)), is(true));\n    assertThat(providerManifest2.isRequiredBundle(requiredBundles.get(0)), is(true));  // 1.0.0 is implicit [1.0.0, INF], hence true\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Test\n  public void testSimpleRequireBundle() {\n    PsiFile provider1 = createLightFile(\"MANIFEST.MF\", Manifest1);\n    BundleManifestImpl providerManifest1 = new BundleManifestImpl((ManifestFile)provider1);\n\n    PsiFile provider2 = createLightFile(\"MANIFEST2.MF\", Manifest1);\n    BundleManifestImpl providerManifest2 = new BundleManifestImpl((ManifestFile)provider2);\n\n    PsiFile requestor = createLightFile(\"MANIFEST3.MF\", Manifest3);\n    BundleManifestImpl requestorManifest = new BundleManifestImpl((ManifestFile)requestor);\n\n    List<String> requiredBundles = requestorManifest.getRequiredBundles();\n    assertThat(requiredBundles.size(), is(1));\n    assertThat(providerManifest1.isRequiredBundle(requiredBundles.iterator().next()), is(true));\n    assertThat(providerManifest2.isRequiredBundle(requiredBundles.iterator().next()), is(true));\n  }","id":26542,"modified_method":"public void testSimpleRequireBundle() {\n    BundleManifest providerManifest1 = getManifest(Manifest1);\n    BundleManifest providerManifest2 = getManifest(Manifest1);\n    BundleManifest requestorManifest = getManifest(Manifest3);\n\n    List<String> requiredBundles = requestorManifest.getRequiredBundles();\n    assertThat(requiredBundles.size(), is(1));\n    assertThat(providerManifest1.isRequiredBundle(requiredBundles.get(0)), is(true));\n    assertThat(providerManifest2.isRequiredBundle(requiredBundles.get(0)), is(true));\n  }","commit_id":"aade13ba84fd682c90531e197ffb2ca127c86882","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static Locks createLockManager( Config config, LogService logging )\n    {\n        String key = config.get( GraphDatabaseFacadeFactory.Configuration.lock_manager );\n        for ( Locks.Factory candidate : Service.load( Locks.Factory.class ) )\n        {\n            String candidateId = candidate.getKeys().iterator().next();\n            if ( candidateId.equals( key ) )\n            {\n                return candidate.newInstance( ResourceTypes.values() );\n            }\n            else if ( key.equals( \"\" ) )\n            {\n                logging.getInternalLog( CommunityFacadeFactory.class )\n                        .info( \"No locking implementation specified, defaulting to '\" + candidateId + \"'\" );\n                return candidate.newInstance( ResourceTypes.values() );\n            }\n        }\n\n        if ( key.equals( \"community\" ) )\n        {\n            return new CommunityLockManger();\n        }\n        else if ( key.equals( \"\" ) )\n        {\n            logging.getInternalLog( CommunityFacadeFactory.class )\n                    .info( \"No locking implementation specified, defaulting to 'community'\" );\n            return new CommunityLockManger();\n        }\n        else if ( key.equals( \"none\" ) )\n        {\n            return new NoOpLocks();\n        }\n\n        throw new IllegalArgumentException( \"No lock manager found with the name '\" + key + \"'.\" );\n    }","id":26543,"modified_method":"public static Locks createLockManager( Config config, LogService logging )\n    {\n        String key = config.get( GraphDatabaseFacadeFactory.Configuration.lock_manager );\n        for ( Locks.Factory candidate : Service.load( Locks.Factory.class ) )\n        {\n            String candidateId = candidate.getKeys().iterator().next();\n            if ( candidateId.equals( key ) )\n            {\n                return candidate.newInstance( ResourceTypes.values() );\n            }\n            else if ( key.equals( \"\" ) )\n            {\n                logging.getInternalLog( CommunityFacadeFactory.class )\n                        .info( \"No locking implementation specified, defaulting to '\" + candidateId + \"'\" );\n                return candidate.newInstance( ResourceTypes.values() );\n            }\n        }\n\n        if ( key.equals( \"community\" ) )\n        {\n            return new CommunityLockManger();\n        }\n        else if ( key.equals( \"\" ) )\n        {\n            logging.getInternalLog( CommunityFacadeFactory.class )\n                    .info( \"No locking implementation specified, defaulting to 'community'\" );\n            return new CommunityLockManger();\n        }\n\n        throw new IllegalArgumentException( \"No lock manager found with the name '\" + key + \"'.\" );\n    }","commit_id":"8722fd3d927fd2364cee43ca24818aa0945a17f3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void releaseAll()\n        {\n            throw new UnsupportedOperationException();\n        }","id":26544,"modified_method":"@Override\n        public void releaseAll()\n        {\n            throw new UnsupportedOperationException( \"Should not be needed\" );\n        }","commit_id":"8722fd3d927fd2364cee43ca24818aa0945a17f3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void accept( Visitor visitor )\n    {\n\n    }","id":26545,"modified_method":"@Override\n    public void accept( Visitor visitor )\n    {\n        delegate.accept( visitor );\n    }","commit_id":"8722fd3d927fd2364cee43ca24818aa0945a17f3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void releaseExclusive( KernelStatement state, Locks.ResourceType type, long resourceId )\n    {\n        state.locks().releaseExclusive( type, resourceId );\n        state.assertOpen();\n    }","id":26546,"modified_method":"@Override\n    public void releaseExclusive( KernelStatement state, Locks.ResourceType type, long resourceId )\n    {\n        state.locks().delegate().releaseExclusive( type, resourceId );\n        state.assertOpen();\n    }","commit_id":"8722fd3d927fd2364cee43ca24818aa0945a17f3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void acquireShared(KernelStatement state, Locks.ResourceType resourceType, long resourceId )\n    {\n        state.locks().acquireShared( resourceType, resourceId );\n        state.assertOpen();\n    }","id":26547,"modified_method":"@Override\n    public void acquireShared(KernelStatement state, Locks.ResourceType resourceType, long resourceId )\n    {\n        state.locks().delegate().acquireShared( resourceType, resourceId );\n        state.assertOpen();\n    }","commit_id":"8722fd3d927fd2364cee43ca24818aa0945a17f3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void releaseShared( KernelStatement state, Locks.ResourceType type, long resourceId )\n    {\n        state.locks().releaseShared( type, resourceId );\n        state.assertOpen();\n    }","id":26548,"modified_method":"@Override\n    public void releaseShared( KernelStatement state, Locks.ResourceType type, long resourceId )\n    {\n        state.locks().delegate().releaseShared( type, resourceId );\n        state.assertOpen();\n    }","commit_id":"8722fd3d927fd2364cee43ca24818aa0945a17f3","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n\t * Examine null values.\n\t * Report any that are guaranteed to be dereferenced on\n\t * non-implicit-exception paths.\n\t * \n\t * @throws CFGBuilderException \n\t * @throws DataflowAnalysisException \n\t */\n\tprivate void examineNullValues() throws CFGBuilderException, DataflowAnalysisException {\n\t\tSet<LocationWhereValueBecomesNull> locationWhereValueBecomesNullSet =\n\t\t\tinvDataflow.getAnalysis().getLocationWhereValueBecomesNullSet();\n\t\tif (DEBUG_DEREFS) {\n\t\t\tSystem.out.println(\"----------------------- examineNullValues \" + locationWhereValueBecomesNullSet.size());\n\t\t}\n\t\t\n\t\tMap<ValueNumber, SortedSet<Location>> bugStatementLocationMap =\n\t\t\tnew HashMap<ValueNumber, SortedSet<Location>>();\n\t\t// Inspect the method for locations where a null value is guaranteed to\n\t\t// be dereferenced.  Add the dereference locations\n\t\tMap<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap =\n\t\t\tnew HashMap<ValueNumber, NullValueUnconditionalDeref>();\n\t\t\n       // Check every location\n\t\tfor (Iterator<Location> i = classContext.getCFG(method).locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\t\n\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\tSystem.out.println(\"At location \" + location);\n\t\t\t}\n\t\t\t{\n\t\t\t\tInstruction in = location.getHandle().getInstruction();\n                \n               if (in instanceof InvokeInstruction && in.produceStack(classContext.getConstantPoolGen()) == 1 || in instanceof GETFIELD || in instanceof GETSTATIC) {\n                    IsNullValueFrame invFrame = invDataflow.getFactAfterLocation(location);\n                    if (invFrame.getStackDepth() > 0) {\n                    IsNullValue isNullValue = invFrame.getTopValue();\n                    if (isNullValue.isNullOnSomePath()) {\n                        // OK, must be from return value\n                        ValueNumber vn = vnaDataflow.getFactAfterLocation(location).getTopValue();\n                        UnconditionalValueDerefSet uvd = uvdDataflow.getFactAfterLocation(location);\n                        if (uvd.isUnconditionallyDereferenced(vn)) {\n                            // System.out.println(\"Found it\");\n                            SortedSet<Location> knownNullAndDoomedAt = bugStatementLocationMap.get(vn);\n                            noteUnconditionallyDereferencedNullValue(  location,\n                                    bugStatementLocationMap,\n                                    nullValueGuaranteedDerefMap,\n                                    uvd, isNullValue, vn);\n                        }\n                    }\n                    }\n                }\n                \n                \n\t\t\t\tif (assertionMethods.isAssertionInstruction (in, classContext.getConstantPoolGen()) ) {\n\t\t\t\t\tif (DEBUG_DEREFS) \n\t\t\t\t\t\tSystem.out.println(\"Skipping because it is an assertion method \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\tcheckForUnconditionallyDereferencedNullValues(\n\t\t\t\t\tlocation,\n                    bugStatementLocationMap,\n\t\t\t\t\tnullValueGuaranteedDerefMap,\n                    vnaDataflow.getFactAtLocation(location), invDataflow.getFactAtLocation(location), uvdDataflow.getFactAfterLocation(location));\n\t\t}\n\t\tHashSet<ValueNumber> npeIfStatementCovered = new HashSet<ValueNumber>(nullValueGuaranteedDerefMap.keySet());\n        Map<ValueNumber, SortedSet<Location>> bugEdgeLocationMap =\n            new HashMap<ValueNumber, SortedSet<Location>>();\n        \n\t\t// Check every non-exception control edge\n\t\tfor (Iterator<Edge> i = classContext.getCFG(method).edgeIterator(); i.hasNext();) {\n\t\t\tEdge edge = i.next();\n\t\t\t\n\t\t\tif (edge.isExceptionEdge()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\tSystem.out.println(\"On edge \" + edge.formatAsString(false));\n\t\t\t}\n\t\t\t\n\t\t\tValueNumberFrame vnaFact = vnaDataflow.getResultFact(edge.getSource());\n            ValueNumberFrame vnaEdgeFact = vnaDataflow.getFactOnEdge(edge);\n            ValueNumberFrame vnaTargetFact = vnaDataflow.getStartFact(edge.getTarget());\n            \n\t\t\tIsNullValueFrame invFact = invDataflow.getFactAtMidEdge(edge);\n            \n                IsNullValueFrame invSourceFact = invDataflow.getResultFact(edge.getSource());\n                IsNullValueFrame invTargetFact = invDataflow.getStartFact(edge.getTarget());\n                UnconditionalValueDerefSet uvdSourceFact = uvdDataflow.getStartFact(edge.getSource());\n                UnconditionalValueDerefSet uvdTargetFact = uvdDataflow.getResultFact(edge.getTarget());\n                Location location = Location.getLastLocation(edge.getSource());\n                \n\t\t\tUnconditionalValueDerefSet uvdFact = uvdDataflow.getFactOnEdge(edge);\n            // UnconditionalValueDerefSet uvdFact = uvdDataflow.getStartFact(edge.getTarget());\n               \n            \n            if (uvdFact.isEmpty()) continue;\n\t\t\tif (location != null) {\n                \n                \n\t\t\t\tInstruction in = location.getHandle().getInstruction();\n\t\t\t\tif (assertionMethods.isAssertionInstruction(in, classContext.getConstantPoolGen())) {\n\t\t\t\t\tif (DEBUG_DEREFS) \n\t\t\t\t\t\tSystem.out.println(\"Skipping because it is an assertion method \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\tcheckForUnconditionallyDereferencedNullValues(\n\t\t\t\t\tlocation,\n                    bugEdgeLocationMap,\n\t\t\t\t\tnullValueGuaranteedDerefMap,\n                    vnaFact, invFact, uvdFact);\n\t\t\t}\n\t\t}\n        Map<ValueNumber, SortedSet<Location>> bugLocationMap = bugEdgeLocationMap;\n        bugLocationMap.putAll(bugStatementLocationMap);\n\t\t//\tFor each value number that is null somewhere in the\n\t\t// method, collect the set of locations where it becomes null.\n\t\t// FIXME: we may see some locations that are not guaranteed to be dereferenced (how to fix this?)\n\t\tMap<ValueNumber, Set<Location>> nullValueAssignmentMap =\n\t\t\tnew HashMap<ValueNumber, Set<Location>>();\n\t\tfor (LocationWhereValueBecomesNull lwvbn : locationWhereValueBecomesNullSet) {\n\t\t\tif (DEBUG_DEREFS) System.out.println(\"OOO \" + lwvbn);\n\t\t\tSet<Location> locationSet = nullValueAssignmentMap.get(lwvbn.getValueNumber());\n\t\t\tif (locationSet == null) {\n\t\t\t\tlocationSet = new HashSet<Location>();\n\t\t\t\tnullValueAssignmentMap.put(lwvbn.getValueNumber(), locationSet);\n\t\t\t}\n\t\t\tlocationSet.add(lwvbn.getLocation());\n\t\t\tif (DEBUG_DEREFS)\n\t\t\t\tSystem.out.println(lwvbn.getValueNumber() + \" becomes null at \" + lwvbn.getLocation());\n\t\t}\n\n\t\t// Report \n\t\tfor (Map.Entry<ValueNumber, NullValueUnconditionalDeref> e  : nullValueGuaranteedDerefMap.entrySet()) {\n\t\t\tValueNumber valueNumber = e.getKey();\n\t\t\tSet<Location> derefLocationSet = e.getValue().getDerefLocationSet();\n\t\t\tSet<Location> assignedNullLocationSet = nullValueAssignmentMap.get(valueNumber);\n\t\t\tif (assignedNullLocationSet == null) {\n\t\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\t\tString where = classContext.getJavaClass().getClassName() + \".\" + method.getName() + \":\" + method.getSignature();\n\t\t\t\t\tSystem.out.println(\"Problem at \" + where);\n\t\t\t\t\tfor (Location loc : derefLocationSet) {\n\t\t\t\t\t\tSystem.out.println(\"Dereference at \" + loc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// TODO: figure out why this is failing\n\t\t\t\tif (false) \n\t\t\t\tassert false: \"No assigned NullLocationSet for \" + valueNumber + \" in \" + nullValueAssignmentMap.keySet()\n\t\t\t\t+ \" while analyzing \" + classContext.getJavaClass().getClassName() + \".\" + method.getName();\n\t\t\t\tassignedNullLocationSet = TigerSubstitutes.emptySet();\n\t\t\t}\n            SortedSet<Location> knownNullAndDoomedAt = bugLocationMap.get(valueNumber);\n                 \n            BugAnnotation variableAnnotation = null;\n            try {\n                for (Location loc : derefLocationSet)  {\n                    variableAnnotation = NullDerefAndRedundantComparisonFinder.findAnnotationFromValueNumber(method, loc, valueNumber, vnaDataflow.getFactAtLocation(loc));\n                    if (variableAnnotation != null) break;\n                }\n                if (variableAnnotation == null) for (Location loc : knownNullAndDoomedAt) {\n                    variableAnnotation = NullDerefAndRedundantComparisonFinder.findAnnotationFromValueNumber(method, loc, valueNumber, vnaDataflow.getFactAtLocation(loc));\n                    if (variableAnnotation != null) break;\n                }\n                if (variableAnnotation == null) for (Location loc : assignedNullLocationSet) {\n                    variableAnnotation = NullDerefAndRedundantComparisonFinder.findAnnotationFromValueNumber(method, loc, valueNumber, vnaDataflow.getFactAtLocation(loc));\n                    if (variableAnnotation != null) break;\n                }\n                \n                \n            } catch (DataflowAnalysisException e2) {\n            }\n            if (variableAnnotation == null) variableAnnotation = new LocalVariableAnnotation(\"?\",-1,-1);\n\n            \n\n            if (PRUNE_GUARANTEED_DEREFERENCES) {\n                PostDominatorsAnalysis postDomAnalysis =\n                    classContext.getNonExceptionPostDominatorsAnalysis(method);\n            removeStrictlyPostDominatedLocations(derefLocationSet, postDomAnalysis);\n            \n            removeStrictlyPostDominatedLocations(knownNullAndDoomedAt, postDomAnalysis);\n            \n            removeStrictlyPostDominatedLocations(assignedNullLocationSet, postDomAnalysis);\n            }\n            \n            \n\t\t\tcollector.foundGuaranteedNullDeref(\n\t\t\t\t\tassignedNullLocationSet,\n\t\t\t\t\tderefLocationSet,\n\t\t\t\t\tknownNullAndDoomedAt,\n\t\t\t\t\tvnaDataflow, valueNumber, \n                    variableAnnotation, e.getValue().isAlwaysOnExceptionPath(),  npeIfStatementCovered.contains(valueNumber));\n\t\t}\n\t}","id":26549,"modified_method":"/**\n\t * Examine null values.\n\t * Report any that are guaranteed to be dereferenced on\n\t * non-implicit-exception paths.\n\t * \n\t * @throws CFGBuilderException \n\t * @throws DataflowAnalysisException \n\t */\n\tprivate void examineNullValues() throws CFGBuilderException, DataflowAnalysisException {\n\t\tSet<LocationWhereValueBecomesNull> locationWhereValueBecomesNullSet =\n\t\t\tinvDataflow.getAnalysis().getLocationWhereValueBecomesNullSet();\n\t\tif (DEBUG_DEREFS) {\n\t\t\tSystem.out.println(\"----------------------- examineNullValues \" + locationWhereValueBecomesNullSet.size());\n\t\t}\n\t\t\n\t\tMap<ValueNumber, SortedSet<Location>> bugStatementLocationMap =\n\t\t\tnew HashMap<ValueNumber, SortedSet<Location>>();\n\t\t// Inspect the method for locations where a null value is guaranteed to\n\t\t// be dereferenced.  Add the dereference locations\n\t\tMap<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap =\n\t\t\tnew HashMap<ValueNumber, NullValueUnconditionalDeref>();\n\t\t\n       // Check every location\n\t\tfor (Iterator<Location> i = classContext.getCFG(method).locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\t\n\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\tSystem.out.println(\"At location \" + location);\n\t\t\t}\n\t\t\tif (false) {\n\t\t\t\tInstruction in = location.getHandle().getInstruction();\n                \n               if (in instanceof InvokeInstruction && in.produceStack(classContext.getConstantPoolGen()) == 1 || in instanceof GETFIELD || in instanceof GETSTATIC) {\n                    IsNullValueFrame invFrame = invDataflow.getFactAfterLocation(location);\n                    if (invFrame.getStackDepth() > 0) {\n                    IsNullValue isNullValue = invFrame.getTopValue();\n                    if (isNullValue.isNullOnSomePath()) {\n                        // OK, must be from return value\n                        ValueNumber vn = vnaDataflow.getFactAfterLocation(location).getTopValue();\n                        UnconditionalValueDerefSet uvd = uvdDataflow.getFactAfterLocation(location);\n                        if (uvd.isUnconditionallyDereferenced(vn)) {\n                            // System.out.println(\"Found it\");\n                            SortedSet<Location> knownNullAndDoomedAt = bugStatementLocationMap.get(vn);\n                            noteUnconditionallyDereferencedNullValue(  location,\n                                    bugStatementLocationMap,\n                                    nullValueGuaranteedDerefMap,\n                                    uvd, isNullValue, vn);\n                        }\n                    }\n                    }\n                }\n                \n                \n\t\t\t\tif (assertionMethods.isAssertionInstruction (in, classContext.getConstantPoolGen()) ) {\n\t\t\t\t\tif (DEBUG_DEREFS) \n\t\t\t\t\t\tSystem.out.println(\"Skipping because it is an assertion method \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\tcheckForUnconditionallyDereferencedNullValues(\n\t\t\t\t\tlocation,\n                    bugStatementLocationMap,\n\t\t\t\t\tnullValueGuaranteedDerefMap,\n                    vnaDataflow.getFactAtLocation(location), invDataflow.getFactAtLocation(location), uvdDataflow.getFactAfterLocation(location));\n\t\t}\n\t\tHashSet<ValueNumber> npeIfStatementCovered = new HashSet<ValueNumber>(nullValueGuaranteedDerefMap.keySet());\n        Map<ValueNumber, SortedSet<Location>> bugEdgeLocationMap =\n            new HashMap<ValueNumber, SortedSet<Location>>();\n        \n\t\t// Check every non-exception control edge\n\t\tfor (Iterator<Edge> i = classContext.getCFG(method).edgeIterator(); i.hasNext();) {\n\t\t\tEdge edge = i.next();\n\t\t\t\n\t\t\tif (edge.isExceptionEdge()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\tSystem.out.println(\"On edge \" + edge.formatAsString(false));\n\t\t\t}\n\t\t\t\n\t\t\tValueNumberFrame vnaFact = vnaDataflow.getResultFact(edge.getSource());\n            ValueNumberFrame vnaEdgeFact = vnaDataflow.getFactOnEdge(edge);\n            ValueNumberFrame vnaTargetFact = vnaDataflow.getStartFact(edge.getTarget());\n            \n\t\t\tIsNullValueFrame invFact = invDataflow.getFactAtMidEdge(edge);\n            \n                IsNullValueFrame invSourceFact = invDataflow.getResultFact(edge.getSource());\n                IsNullValueFrame invTargetFact = invDataflow.getStartFact(edge.getTarget());\n                UnconditionalValueDerefSet uvdSourceFact = uvdDataflow.getStartFact(edge.getSource());\n                UnconditionalValueDerefSet uvdTargetFact = uvdDataflow.getResultFact(edge.getTarget());\n                Location location = Location.getLastLocation(edge.getSource());\n                \n\t\t\tUnconditionalValueDerefSet uvdFact = uvdDataflow.getFactOnEdge(edge);\n            // UnconditionalValueDerefSet uvdFact = uvdDataflow.getStartFact(edge.getTarget());\n               \n            \n            if (uvdFact.isEmpty()) continue;\n\t\t\tif (location != null) {\n                \n                \n\t\t\t\tInstruction in = location.getHandle().getInstruction();\n\t\t\t\tif (assertionMethods.isAssertionInstruction(in, classContext.getConstantPoolGen())) {\n\t\t\t\t\tif (DEBUG_DEREFS) \n\t\t\t\t\t\tSystem.out.println(\"Skipping because it is an assertion method \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\tcheckForUnconditionallyDereferencedNullValues(\n\t\t\t\t\tlocation,\n                    bugEdgeLocationMap,\n\t\t\t\t\tnullValueGuaranteedDerefMap,\n                    vnaFact, invFact, uvdFact);\n\t\t\t}\n\t\t}\n        Map<ValueNumber, SortedSet<Location>> bugLocationMap = bugEdgeLocationMap;\n        bugLocationMap.putAll(bugStatementLocationMap);\n\t\t//\tFor each value number that is null somewhere in the\n\t\t// method, collect the set of locations where it becomes null.\n\t\t// FIXME: we may see some locations that are not guaranteed to be dereferenced (how to fix this?)\n\t\tMap<ValueNumber, Set<Location>> nullValueAssignmentMap =\n\t\t\tnew HashMap<ValueNumber, Set<Location>>();\n\t\tfor (LocationWhereValueBecomesNull lwvbn : locationWhereValueBecomesNullSet) {\n\t\t\tif (DEBUG_DEREFS) System.out.println(\"OOO \" + lwvbn);\n\t\t\tSet<Location> locationSet = nullValueAssignmentMap.get(lwvbn.getValueNumber());\n\t\t\tif (locationSet == null) {\n\t\t\t\tlocationSet = new HashSet<Location>();\n\t\t\t\tnullValueAssignmentMap.put(lwvbn.getValueNumber(), locationSet);\n\t\t\t}\n\t\t\tlocationSet.add(lwvbn.getLocation());\n\t\t\tif (DEBUG_DEREFS)\n\t\t\t\tSystem.out.println(lwvbn.getValueNumber() + \" becomes null at \" + lwvbn.getLocation());\n\t\t}\n\n\t\t// Report \n\t\tfor (Map.Entry<ValueNumber, NullValueUnconditionalDeref> e  : nullValueGuaranteedDerefMap.entrySet()) {\n\t\t\tValueNumber valueNumber = e.getKey();\n\t\t\tSet<Location> derefLocationSet = e.getValue().getDerefLocationSet();\n\t\t\tSet<Location> assignedNullLocationSet = nullValueAssignmentMap.get(valueNumber);\n\t\t\tif (assignedNullLocationSet == null) {\n\t\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\t\tString where = classContext.getJavaClass().getClassName() + \".\" + method.getName() + \":\" + method.getSignature();\n\t\t\t\t\tSystem.out.println(\"Problem at \" + where);\n\t\t\t\t\tfor (Location loc : derefLocationSet) {\n\t\t\t\t\t\tSystem.out.println(\"Dereference at \" + loc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// TODO: figure out why this is failing\n\t\t\t\tif (false) \n\t\t\t\tassert false: \"No assigned NullLocationSet for \" + valueNumber + \" in \" + nullValueAssignmentMap.keySet()\n\t\t\t\t+ \" while analyzing \" + classContext.getJavaClass().getClassName() + \".\" + method.getName();\n\t\t\t\tassignedNullLocationSet = TigerSubstitutes.emptySet();\n\t\t\t}\n            SortedSet<Location> knownNullAndDoomedAt = bugLocationMap.get(valueNumber);\n                 \n            BugAnnotation variableAnnotation = null;\n            try {\n                for (Location loc : derefLocationSet)  {\n                    variableAnnotation = NullDerefAndRedundantComparisonFinder.findAnnotationFromValueNumber(method, loc, valueNumber, vnaDataflow.getFactAtLocation(loc));\n                    if (variableAnnotation != null) break;\n                }\n                if (variableAnnotation == null) for (Location loc : knownNullAndDoomedAt) {\n                    variableAnnotation = NullDerefAndRedundantComparisonFinder.findAnnotationFromValueNumber(method, loc, valueNumber, vnaDataflow.getFactAtLocation(loc));\n                    if (variableAnnotation != null) break;\n                }\n                if (variableAnnotation == null) for (Location loc : assignedNullLocationSet) {\n                    variableAnnotation = NullDerefAndRedundantComparisonFinder.findAnnotationFromValueNumber(method, loc, valueNumber, vnaDataflow.getFactAtLocation(loc));\n                    if (variableAnnotation != null) break;\n                }\n                \n                \n            } catch (DataflowAnalysisException e2) {\n            }\n            if (variableAnnotation == null) variableAnnotation = new LocalVariableAnnotation(\"?\",-1,-1);\n\n            \n\n            if (PRUNE_GUARANTEED_DEREFERENCES) {\n                PostDominatorsAnalysis postDomAnalysis =\n                    classContext.getNonExceptionPostDominatorsAnalysis(method);\n            removeStrictlyPostDominatedLocations(derefLocationSet, postDomAnalysis);\n            \n            removeStrictlyPostDominatedLocations(knownNullAndDoomedAt, postDomAnalysis);\n            \n            removeStrictlyPostDominatedLocations(assignedNullLocationSet, postDomAnalysis);\n            }\n            \n            \n\t\t\tcollector.foundGuaranteedNullDeref(\n\t\t\t\t\tassignedNullLocationSet,\n\t\t\t\t\tderefLocationSet,\n\t\t\t\t\tknownNullAndDoomedAt,\n\t\t\t\t\tvnaDataflow, valueNumber, \n                    variableAnnotation, e.getValue().isAlwaysOnExceptionPath(),  npeIfStatementCovered.contains(valueNumber));\n\t\t}\n\t}","commit_id":"12b899e69aa2b73acca9bb9a8cb72c1d52121cac","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Check for unconditionally dereferenced null values\n\t * at a particular location in the CFG.\n\t * @param thisLocation TODO\n\t * @param knownNullAndDoomedAt TODO\n\t * @param nullValueGuaranteedDerefMap map to be populated with null values and where they are derefed \n\t * @param vnaFrame                    value number frame to check\n\t * @param invFrame                    null-value frame to check\n\t * @param derefSet                    set of unconditionally derefed values at this location \n\t */\n\tprivate void checkForUnconditionallyDereferencedNullValues(\n\t\t\tLocation thisLocation,\n\t\t\tMap<ValueNumber, SortedSet<Location>> knownNullAndDoomedAt,\n\t\t\tMap<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap,\n\t\t\tValueNumberFrame vnaFrame, IsNullValueFrame invFrame, UnconditionalValueDerefSet derefSet) {\n\t\t\n\t\tif (DEBUG_DEREFS) {\n\t\t\tSystem.out.println(\"vna *** \" + vnaFrame);\n\t\t\tSystem.out.println(\"inv *** \" + invFrame);\n\t\t\tSystem.out.println(\"deref * \" + derefSet);\n\t\t}\n\t\t\n\t\t// Make sure the frames contain meaningful information\n\t\tif (!vnaFrame.isValid() || !invFrame.isValid() || vnaFrame.getNumSlots() != invFrame.getNumSlots())  {\n\t\t\treturn;\n\t\t}\n\t\tif (derefSet.isEmpty()) return;\n\t\t// See if there are any definitely-null values in the frame\n\t\tfor (int j = 0; j < invFrame.getNumSlots(); j++) {\n\t\t    IsNullValue isNullValue = invFrame.getValue(j); \n\t\t    ValueNumber valueNumber = vnaFrame.getValue(j);\n\t\t    if (isNullValue.isDefinitelyNull() && (derefSet.isUnconditionallyDereferenced(valueNumber) \n                  )) {\n                if (MY_DEBUG) {\n                    System.out.println(\"Found NP bug\");\n                    System.out.println(\"Location: \" + thisLocation);\n                    System.out.println(\"Value number: \" + valueNumber);\n                    System.out.println(\"IsNullValue frame: \" + invFrame);\n                    System.out.println(\"IsNullValue value: \" + isNullValue);\n                    System.out.println(\"Unconditional dere framef: \" + derefSet);\n                    System.out.println(\"Unconditionally dereferenced: \" + derefSet.isUnconditionallyDereferenced(valueNumber) );\n              \n                }\n                noteUnconditionallyDereferencedNullValue(\n\t\t                thisLocation,\n\t\t                knownNullAndDoomedAt,\n\t\t                nullValueGuaranteedDerefMap,\n\t\t                derefSet, isNullValue, valueNumber);\n\t\t    }\n\t\t}\n\n\t\t// See if there are any known-null values in the heap that\n\t\t// will be dereferenced in the future.\n\t\tfor (Map.Entry<ValueNumber, IsNullValue> entry : invFrame.getKnownValueMapEntrySet()) {\n\t\t    ValueNumber valueNumber = entry.getKey();\n\t\t    IsNullValue isNullValue = entry.getValue();\n\t\t    if (isNullValue.isDefinitelyNull() && derefSet.isUnconditionallyDereferenced(valueNumber) ) {\n               noteUnconditionallyDereferencedNullValue(\n\t\t                thisLocation,\n\t\t                knownNullAndDoomedAt,\n\t\t                nullValueGuaranteedDerefMap,\n\t\t                derefSet, isNullValue, valueNumber);\n\t\t    }\n\t\t}\n\t}","id":26550,"modified_method":"/**\n\t * Check for unconditionally dereferenced null values\n\t * at a particular location in the CFG.\n\t * @param thisLocation TODO\n\t * @param knownNullAndDoomedAt TODO\n\t * @param nullValueGuaranteedDerefMap map to be populated with null values and where they are derefed \n\t * @param vnaFrame                    value number frame to check\n\t * @param invFrame                    null-value frame to check\n\t * @param derefSet                    set of unconditionally derefed values at this location \n\t */\n\tprivate void checkForUnconditionallyDereferencedNullValues(\n\t\t\tLocation thisLocation,\n\t\t\tMap<ValueNumber, SortedSet<Location>> knownNullAndDoomedAt,\n\t\t\tMap<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap,\n\t\t\tValueNumberFrame vnaFrame, IsNullValueFrame invFrame, UnconditionalValueDerefSet derefSet) {\n\t\t\n\t\tif (DEBUG_DEREFS) {\n\t\t\tSystem.out.println(\"vna *** \" + vnaFrame);\n\t\t\tSystem.out.println(\"inv *** \" + invFrame);\n\t\t\tSystem.out.println(\"deref * \" + derefSet);\n\t\t}\n\t\t\n\t\t// Make sure the frames contain meaningful information\n\t\tif (!vnaFrame.isValid() || !invFrame.isValid() || vnaFrame.getNumSlots() != invFrame.getNumSlots())  {\n\t\t\treturn;\n\t\t}\n\t\tif (derefSet.isEmpty()) return;\n\t\t// See if there are any definitely-null values in the frame\n\t\tfor (int j = 0; j < invFrame.getNumSlots(); j++) {\n\t\t    IsNullValue isNullValue = invFrame.getValue(j); \n\t\t    ValueNumber valueNumber = vnaFrame.getValue(j);\n\t\t    if ((isNullValue.isDefinitelyNull() || isNullValue.isNullOnSomePath() && isNullValue.isReturnValue()) && (derefSet.isUnconditionallyDereferenced(valueNumber) \n                  )) {\n                if (MY_DEBUG) {\n                    System.out.println(\"Found NP bug\");\n                    System.out.println(\"Location: \" + thisLocation);\n                    System.out.println(\"Value number: \" + valueNumber);\n                    System.out.println(\"IsNullValue frame: \" + invFrame);\n                    System.out.println(\"IsNullValue value: \" + isNullValue);\n                    System.out.println(\"Unconditional dere framef: \" + derefSet);\n                    System.out.println(\"Unconditionally dereferenced: \" + derefSet.isUnconditionallyDereferenced(valueNumber) );\n              \n                }\n                noteUnconditionallyDereferencedNullValue(\n\t\t                thisLocation,\n\t\t                knownNullAndDoomedAt,\n\t\t                nullValueGuaranteedDerefMap,\n\t\t                derefSet, isNullValue, valueNumber);\n\t\t    }\n\t\t}\n\n\t\t// See if there are any known-null values in the heap that\n\t\t// will be dereferenced in the future.\n\t\tfor (Map.Entry<ValueNumber, IsNullValue> entry : invFrame.getKnownValueMapEntrySet()) {\n\t\t    ValueNumber valueNumber = entry.getKey();\n\t\t    IsNullValue isNullValue = entry.getValue();\n\t\t    if ((isNullValue.isDefinitelyNull() || isNullValue.isNullOnSomePath() && isNullValue.isReturnValue()) && derefSet.isUnconditionallyDereferenced(valueNumber) ) {\n               noteUnconditionallyDereferencedNullValue(\n\t\t                thisLocation,\n\t\t                knownNullAndDoomedAt,\n\t\t                nullValueGuaranteedDerefMap,\n\t\t                derefSet, isNullValue, valueNumber);\n\t\t    }\n\t\t}\n\t}","commit_id":"12b899e69aa2b73acca9bb9a8cb72c1d52121cac","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void foundNullDeref(Location location, ValueNumber valueNumber, IsNullValue refValue, ValueNumberFrame vnaFrame) {\n\t\tWarningPropertySet propertySet = new WarningPropertySet();\n\t\t\n\t\tboolean onExceptionPath = refValue.isException();\n\t\tif (onExceptionPath) {\n\t\t\tpropertySet.addProperty(GeneralWarningProperty.ON_EXCEPTION_PATH);\n\t\t}\n\n\t\tLocalVariableAnnotation variable = findLocalVariable(location, valueNumber, vnaFrame);\n\t\t\n\t\tif (refValue.isDefinitelyNull()) {\n\t\t\tString type = onExceptionPath ? \"NP_ALWAYS_NULL_EXCEPTION\" : \"NP_ALWAYS_NULL\";\n\t\t\tint priority = onExceptionPath ? NORMAL_PRIORITY : HIGH_PRIORITY;\n\t\t\treportNullDeref(propertySet, classContext, method, location, type, priority, variable);\n\t\t} else if (refValue.isNullOnSomePath()) {\n\t\t\tString type =  \"NP_NULL_ON_SOME_PATH\";\n\t\t\tint priority =  NORMAL_PRIORITY;\n\t\t\tif (onExceptionPath)  type = \"NP_NULL_ON_SOME_PATH_EXCEPTION\";\n\t\t\telse if (refValue.isReturnValue())\n\t\t\t\ttype = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\";\n\t\t\telse if (refValue.isParamValue()) {\n\t\t\t\tif (method.getName().equals(\"equals\") \n\t\t\t\t\t\t&& method.getSignature().equals(\"(Ljava/lang/Object;)Z\"))\n\t\t\t\t\ttype = \"NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT\";\n\t\t\t\telse\n\t\t\t\ttype = \"NP_ARGUMENT_MIGHT_BE_NULL\";\n\t\t\t}\n\t\t\tif (DEBUG) System.out.println(\"Reporting null on some path: value=\" + refValue);\n\t\t\treportNullDeref(propertySet, classContext, method, location, type, priority, variable);\n\t\t}\n\t}","id":26551,"modified_method":"public void foundNullDeref(ClassContext classContext, Location location, ValueNumber valueNumber, IsNullValue refValue, ValueNumberFrame vnaFrame) {\n\t\tWarningPropertySet propertySet = new WarningPropertySet();\n\t\t\n\t\tboolean onExceptionPath = refValue.isException();\n\t\tif (onExceptionPath) {\n\t\t\tpropertySet.addProperty(GeneralWarningProperty.ON_EXCEPTION_PATH);\n\t\t}\n\t\tint pc = location.getHandle().getPosition();\n\t\tLocalVariableAnnotation variable = findLocalVariable(location, valueNumber, vnaFrame);\n\t\tboolean duplicated = false;\n\t\ttry {\n\t\t\tCFG cfg = classContext.getCFG(method);\n\t\t\tduplicated = cfg.getLocationsContainingInstructionWithOffset(pc).size() > 1;\n\t\t} catch (CFGBuilderException e) {\n\t\t}\n\n\t\tif (!duplicated && refValue.isDefinitelyNull()) {\n\t\t\tString type = onExceptionPath ? \"NP_ALWAYS_NULL_EXCEPTION\" : \"NP_ALWAYS_NULL\";\n\t\t\tint priority = onExceptionPath ? NORMAL_PRIORITY : HIGH_PRIORITY;\n\t\t\treportNullDeref(propertySet, classContext, method, location, type, priority, variable);\n\t\t} else if (refValue.isNullOnSomePath() || duplicated &&  refValue.isDefinitelyNull()) {\n\t\t\tString type =  \"NP_NULL_ON_SOME_PATH\";\n\t\t\tint priority =  NORMAL_PRIORITY;\n\t\t\tif (onExceptionPath)  type = \"NP_NULL_ON_SOME_PATH_EXCEPTION\";\n\t\t\telse if (refValue.isReturnValue())\n\t\t\t\ttype = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\";\n\t\t\telse if (refValue.isParamValue()) {\n\t\t\t\tif (method.getName().equals(\"equals\") \n\t\t\t\t\t\t&& method.getSignature().equals(\"(Ljava/lang/Object;)Z\"))\n\t\t\t\t\ttype = \"NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT\";\n\t\t\t\telse\n\t\t\t\ttype = \"NP_ARGUMENT_MIGHT_BE_NULL\";\n\t\t\t}\n\t\t\tif (DEBUG) System.out.println(\"Reporting null on some path: value=\" + refValue);\n\t\t\treportNullDeref(propertySet, classContext, method, location, type, priority, variable);\n\t\t}\n\t}","commit_id":"afb3496f262fa06a6f2f3027c8c6fa3d09351688","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeNullCheck(ClassContext classContext, Method method, IsNullValueDataflow invDataflow,\n            BasicBlock basicBlock)\n\t\tthrows DataflowAnalysisException, CFGBuilderException {\n\t\t// Look for null checks where the value checked is definitely\n\t\t// null or null on some path.\n\t\t\n\t\tInstructionHandle exceptionThrowerHandle = basicBlock.getExceptionThrower();\n\t\tInstruction exceptionThrower = exceptionThrowerHandle.getInstruction();\n\t\t\n\t\t// Get the stack values at entry to the null check.\n\t\tIsNullValueFrame frame = invDataflow.getStartFact(basicBlock);\n\t\tif (!frame.isValid())\n\t\t\treturn;\n\n\t\t\n\t\t// Could the reference be null?\n\t\tIsNullValue refValue = frame.getInstance(exceptionThrower, classContext.getConstantPoolGen());\n\t\tif (!refValue.mightBeNull())\n\t\t\treturn;\n\t\t\n\t\t// Get the value number\n\t\tValueNumberFrame vnaFrame = classContext.getValueNumberDataflow(method).getStartFact(basicBlock);\n\t\tif (!vnaFrame.isValid())\n\t\t\treturn;\n\t\tValueNumber valueNumber = vnaFrame.getInstance(exceptionThrower, classContext.getConstantPoolGen());\n\t\t\n\t\t// Issue a warning\n\t\tcollector.foundNullDeref(new Location(exceptionThrowerHandle, basicBlock), valueNumber, refValue, vnaFrame);\n\t}","id":26552,"modified_method":"private void analyzeNullCheck(ClassContext classContext, Method method, IsNullValueDataflow invDataflow,\n            BasicBlock basicBlock)\n\t\tthrows DataflowAnalysisException, CFGBuilderException {\n\t\t// Look for null checks where the value checked is definitely\n\t\t// null or null on some path.\n\t\t\n\t\tInstructionHandle exceptionThrowerHandle = basicBlock.getExceptionThrower();\n\t\tInstruction exceptionThrower = exceptionThrowerHandle.getInstruction();\n\t\t\n\t\t// Get the stack values at entry to the null check.\n\t\tIsNullValueFrame frame = invDataflow.getStartFact(basicBlock);\n\t\tif (!frame.isValid())\n\t\t\treturn;\n\n\t\t\n\t\t// Could the reference be null?\n\t\tIsNullValue refValue = frame.getInstance(exceptionThrower, classContext.getConstantPoolGen());\n\t\tif (!refValue.mightBeNull())\n\t\t\treturn;\n\t\t\n\t\t// Get the value number\n\t\tValueNumberFrame vnaFrame = classContext.getValueNumberDataflow(method).getStartFact(basicBlock);\n\t\tif (!vnaFrame.isValid())\n\t\t\treturn;\n\t\tValueNumber valueNumber = vnaFrame.getInstance(exceptionThrower, classContext.getConstantPoolGen());\n\t\t\n\t\t// Issue a warning\n\t\tcollector.foundNullDeref(classContext, new Location(exceptionThrowerHandle, basicBlock), valueNumber, refValue, vnaFrame);\n\t}","commit_id":"afb3496f262fa06a6f2f3027c8c6fa3d09351688","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void examineReturnInstruction(Location location) throws DataflowAnalysisException, CFGBuilderException {\n\t\tif (DEBUG_NULLRETURN) {\n\t\t\tSystem.out.println(\"Checking null return at \" + location);\n\t\t}\n\t\t\n\t\tIsNullValueDataflow invDataflow = classContext.getIsNullValueDataflow(method);\n\t\tIsNullValueFrame frame = invDataflow.getFactAtLocation(location);\n\t\tif (!frame.isValid())\n\t\t\treturn;\n\t\tIsNullValue tos = frame.getTopValue();\n\t\tif (tos.mightBeNull()) {\n\t\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\t\t\t\t\t\t\n            String bugPattern = \"NP_NONNULL_RETURN_VIOLATION\";\n            String methodName = method.getName();\n            if (methodName.equals(\"clone\"))\n                bugPattern = \"NP_CLONE_COULD_RETURN_NULL\";\n            else if (methodName.equals(\"toString\"))\n                bugPattern = \"NP_TOSTRING_COULD_RETURN_NULL\";\n\t\t\tBugInstance warning = new BugInstance(bugPattern, tos.isDefinitelyNull() ?\n\t\t\t\t\tHIGH_PRIORITY : NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t.addSourceLine(classContext, methodGen, sourceFile, location.getHandle());\n\t\t\t\n\t\t\tbugReporter.reportBug(warning);\n\t\t}\n\t}","id":26553,"modified_method":"private void examineReturnInstruction(Location location) throws DataflowAnalysisException, CFGBuilderException {\n\t\tif (DEBUG_NULLRETURN) {\n\t\t\tSystem.out.println(\"Checking null return at \" + location);\n\t\t}\n\t\t\n\t\tIsNullValueDataflow invDataflow = classContext.getIsNullValueDataflow(method);\n\t\tIsNullValueFrame frame = invDataflow.getFactAtLocation(location);\n\t\tif (!frame.isValid())\n\t\t\treturn;\n\t\tIsNullValue tos = frame.getTopValue();\n\t\tif (tos.mightBeNull()) {\n\t\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\t\t\t\t\t\t\n            String bugPattern = \"NP_NONNULL_RETURN_VIOLATION\";\n            int priority = NORMAL_PRIORITY;\n            if (tos.isDefinitelyNull() && !tos.isException()) priority = HIGH_PRIORITY;\n            String methodName = method.getName();\n            if (methodName.equals(\"clone\")) {\n                bugPattern = \"NP_CLONE_COULD_RETURN_NULL\";\n                priority = NORMAL_PRIORITY;\n            }\n            else if (methodName.equals(\"toString\")) {\n                bugPattern = \"NP_TOSTRING_COULD_RETURN_NULL\";\n                priority = NORMAL_PRIORITY;\n            }\n\t\t\tBugInstance warning = new BugInstance(bugPattern,priority)\n\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t.addSourceLine(classContext, methodGen, sourceFile, location.getHandle());\n\t\t\t\n\t\t\tbugReporter.reportBug(warning);\n\t\t}\n\t}","commit_id":"e130b5aa1e4c5b506f8ab016be7e97910fb1c090","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n   * Perform aggregation on the Streams described by the {@code streamNames}, and no other Streams.\n   * If aggregation was previously done on other Streams, those must be cancelled.\n   *\n   * @param streamNames names of the streams to perform data sizes aggregation on\n   */\n  private void aggregate(Set<String> streamNames) {\n    Set<String> existingAggregators = Sets.newHashSet(aggregators.keySet());\n    for (String streamName : streamNames) {\n      if (existingAggregators.remove(streamName)) {\n        continue;\n      }\n\n      try {\n        StreamConfig config = streamAdmin.getConfig(streamName);\n        long filesSize = StreamUtils.fetchStreamFilesSize(config);\n        LOG.debug(\"Size of the files already present for stream {}: {}\", streamName, filesSize);\n        createSizeAggregator(streamName, filesSize, new AtomicInteger(config.getNotificationThresholdMB()));\n      } catch (IOException e) {\n        LOG.error(\"Could not compute sizes of files for stream {}\", streamName);\n        Throwables.propagate(e);\n      }\n    }\n\n    // Stop aggregating the heartbeats we used to listen to before the call to that method,\n    // but don't anymore\n    for (String outdatedStream : existingAggregators) {\n      StreamSizeAggregator aggregator = aggregators.remove(outdatedStream);\n      if (aggregator != null) {\n        aggregator.cancel();\n      }\n    }\n  }","id":26554,"modified_method":"/**\n   * Perform aggregation on the Streams described by the {@code streamNames}, and no other Streams.\n   * If aggregation was previously done on other Streams, those must be cancelled.\n   *\n   * @param streamNames names of the streams to perform data sizes aggregation on\n   */\n  private void aggregate(Set<String> streamNames) {\n    Set<String> existingAggregators = Sets.newHashSet(aggregators.keySet());\n    for (String streamName : streamNames) {\n      if (existingAggregators.remove(streamName)) {\n        continue;\n      }\n\n      try {\n        StreamConfig config = streamAdmin.getConfig(streamName);\n        long filesSize = StreamUtils.fetchStreamFilesSize(config);\n        LOG.debug(\"Size of the files already present for stream {}: {}\", streamName, filesSize);\n        createSizeAggregator(streamName, filesSize, config.getNotificationThresholdMB());\n      } catch (IOException e) {\n        LOG.error(\"Could not compute sizes of files for stream {}\", streamName);\n        Throwables.propagate(e);\n      }\n    }\n\n    // Stop aggregating the heartbeats we used to listen to before the call to that method,\n    // but don't anymore\n    for (String outdatedStream : existingAggregators) {\n      // We need to first cancel the aggregator and then remove it from the map of aggregators,\n      // to avoid race conditions in createSizeAggregator\n      StreamSizeAggregator aggregator = aggregators.get(outdatedStream);\n      if (aggregator != null) {\n        aggregator.cancel();\n      }\n      aggregators.remove(outdatedStream);\n    }\n  }","commit_id":"bd86a12fb0145a4de25c440972865e89a3023ec8","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Create a new aggregator for the {@code streamName}, and add it to the existing map of {@link Cancellable}\n   * {@code aggregators}. This method does not cancel previously existing aggregator associated to the\n   * {@code streamName}.\n   *\n   * @param streamName stream name to create a new aggregator for\n   * @param baseCount stream size from which to start aggregating\n   * @return the created {@link StreamSizeAggregator}\n   */\n  private StreamSizeAggregator createSizeAggregator(String streamName, long baseCount, final AtomicInteger threshold) {\n    LOG.debug(\"Creating size aggregator for stream {}\", streamName);\n    // Handle threshold changes\n    final Cancellable thresholdSubscription =\n      getStreamCoordinatorClient().addListener(streamName, new StreamPropertyListener() {\n        @Override\n        public void thresholdChanged(String streamName, int threshold) {\n          StreamSizeAggregator aggregator = aggregators.get(streamName);\n          if (aggregator == null) {\n            LOG.warn(\"StreamSizeAggregator should not be null for stream {}\", streamName);\n            return;\n          }\n          aggregator.setStreamThresholdMB(threshold);\n        }\n      });\n\n    // Handle stream truncation, by creating creating a new empty aggregator for the stream\n    // and cancelling the existing one\n    final Cancellable truncationSubscription =\n      getStreamCoordinatorClient().addListener(streamName, new StreamPropertyListener() {\n        @Override\n        public void generationChanged(String streamName, int generation) {\n          AtomicInteger currentThresold = threshold;\n          StreamSizeAggregator currentAggregator = aggregators.get(streamName);\n          if (currentAggregator != null) {\n            currentThresold = currentAggregator.getStreamThresholdMB();\n          }\n          Cancellable previousAggregator =\n            aggregators.replace(streamName, createSizeAggregator(streamName, 0, currentThresold));\n          if (previousAggregator != null) {\n            previousAggregator.cancel();\n          }\n        }\n      });\n\n    StreamSizeAggregator newAggregator = new StreamSizeAggregator(streamName, baseCount, threshold, new Cancellable() {\n      @Override\n      public void cancel() {\n        thresholdSubscription.cancel();\n        truncationSubscription.cancel();\n      }\n    });\n    aggregators.put(streamName, newAggregator);\n    return newAggregator;\n  }","id":26555,"modified_method":"/**\n   * Create a new aggregator for the {@code streamName}, and add it to the existing map of {@link Cancellable}\n   * {@code aggregators}. This method does not cancel previously existing aggregator associated to the\n   * {@code streamName}.\n   *\n   * @param streamName stream name to create a new aggregator for\n   * @param baseCount stream size from which to start aggregating\n   * @return the created {@link StreamSizeAggregator}\n   */\n  private StreamSizeAggregator createSizeAggregator(String streamName, long baseCount, int threshold) {\n    LOG.debug(\"Creating size aggregator for stream {}\", streamName);\n    // Handle threshold changes\n    final Cancellable thresholdSubscription =\n      getStreamCoordinatorClient().addListener(streamName, new StreamPropertyListener() {\n        @Override\n        public void thresholdChanged(String streamName, int threshold) {\n          StreamSizeAggregator aggregator = aggregators.get(streamName);\n          while (aggregator == null) {\n            Thread.yield();\n            aggregator = aggregators.get(streamName);\n          }\n          aggregator.setStreamThresholdMB(threshold);\n        }\n      });\n\n    // Handle stream truncation, by creating creating a new empty aggregator for the stream\n    // and cancelling the existing one\n    final Cancellable truncationSubscription =\n      getStreamCoordinatorClient().addListener(streamName, new StreamPropertyListener() {\n        @Override\n        public void generationChanged(String streamName, int generation) {\n          StreamSizeAggregator aggregator = aggregators.get(streamName);\n          while (aggregator == null) {\n            Thread.yield();\n            aggregator = aggregators.get(streamName);\n          }\n          aggregator.resetCount();\n        }\n      });\n\n    StreamSizeAggregator newAggregator = new StreamSizeAggregator(streamName, baseCount, threshold, new Cancellable() {\n      @Override\n      public void cancel() {\n        thresholdSubscription.cancel();\n        truncationSubscription.cancel();\n      }\n    });\n    aggregators.put(streamName, newAggregator);\n    return newAggregator;\n  }","commit_id":"bd86a12fb0145a4de25c440972865e89a3023ec8","url":"https://github.com/caskdata/cdap"},{"original_method":"protected StreamSizeAggregator(String streamName, long baseCount, AtomicInteger streamThresholdMB,\n                                   Cancellable cancellable) {\n      this.streamWriterSizes = Maps.newHashMap();\n      this.streamBaseCount = new AtomicLong(baseCount);\n      this.countFromFiles = new AtomicLong(baseCount);\n      this.streamThresholdMB = streamThresholdMB;\n      this.cancellable = cancellable;\n      this.isInit = true;\n      this.streamFeed = new NotificationFeed.Builder()\n        .setNamespace(Constants.DEFAULT_NAMESPACE)\n        .setCategory(Constants.Notification.Stream.STREAM_FEED_CATEGORY)\n        .setName(streamName)\n        .build();\n    }","id":26556,"modified_method":"protected StreamSizeAggregator(String streamName, long baseCount, int streamThresholdMB, Cancellable cancellable) {\n      this.streamWriterSizes = Maps.newHashMap();\n      this.streamBaseCount = new AtomicLong(baseCount);\n      this.countFromFiles = new AtomicLong(baseCount);\n      this.streamThresholdMB = new AtomicInteger(streamThresholdMB);\n      this.cancellable = cancellable;\n      this.isInit = true;\n      this.streamFeed = new NotificationFeed.Builder()\n        .setNamespace(Constants.DEFAULT_NAMESPACE)\n        .setCategory(Constants.Notification.Stream.STREAM_FEED_CATEGORY)\n        .setName(streamName)\n        .build();\n    }","commit_id":"bd86a12fb0145a4de25c440972865e89a3023ec8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void initialize() throws Exception {\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n      long filesSize = StreamUtils.fetchStreamFilesSize(config);\n      createSizeAggregator(streamSpec.getName(), filesSize, new AtomicInteger(config.getNotificationThresholdMB()));\n    }\n  }","id":26557,"modified_method":"@Override\n  protected void initialize() throws Exception {\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n      long filesSize = StreamUtils.fetchStreamFilesSize(config);\n      createSizeAggregator(streamSpec.getName(), filesSize, config.getNotificationThresholdMB());\n    }\n  }","commit_id":"bd86a12fb0145a4de25c440972865e89a3023ec8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void runOneIteration() throws Exception {\n    // Get stream size - which will be the entire size - and send a notification if the size is big enough\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      StreamSizeAggregator streamSizeAggregator = aggregators.get(streamSpec.getName());\n      if (streamSizeAggregator == null) {\n        // First time that we see this Stream here\n        StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n        streamSizeAggregator = createSizeAggregator(streamSpec.getName(), 0,\n                                                    new AtomicInteger(config.getNotificationThresholdMB()));\n      }\n      streamSizeAggregator.checkAggregatedSize();\n    }\n    isInit = false;\n  }","id":26558,"modified_method":"@Override\n  protected void runOneIteration() throws Exception {\n    // Get stream size - which will be the entire size - and send a notification if the size is big enough\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      StreamSizeAggregator streamSizeAggregator = aggregators.get(streamSpec.getName());\n      if (streamSizeAggregator == null) {\n        // First time that we see this Stream here\n        StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n        streamSizeAggregator = createSizeAggregator(streamSpec.getName(), 0, config.getNotificationThresholdMB());\n      }\n      streamSizeAggregator.checkAggregatedSize();\n    }\n    isInit = false;\n  }","commit_id":"bd86a12fb0145a4de25c440972865e89a3023ec8","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Create a new aggregator for the {@code streamName}, and add it to the existing map of {@link Cancellable}\n   * {@code aggregators}. This method does not cancel previously existing aggregator associated to the\n   * {@code streamName}.\n   *\n   * @param streamName stream name to create a new aggregator for\n   * @param baseCount stream size from which to start aggregating\n   * @return the created {@link StreamSizeAggregator}\n   */\n  private StreamSizeAggregator createSizeAggregator(String streamName, long baseCount, final AtomicInteger threshold) {\n\n    // Handle threshold changes\n    final Cancellable thresholdSubscription =\n      getStreamCoordinatorClient().addListener(streamName, new StreamPropertyListener() {\n        @Override\n        public void thresholdChanged(String streamName, int threshold) {\n          StreamSizeAggregator aggregator = aggregators.get(streamName);\n          if (aggregator == null) {\n            LOG.warn(\"StreamSizeAggregator should not be null for stream {}\", streamName);\n            return;\n          }\n          aggregator.setStreamThresholdMB(threshold);\n        }\n      });\n\n    // Handle stream truncation, by creating creating a new empty aggregator for the stream\n    // and cancelling the existing one\n    final Cancellable truncationSubscription =\n      getStreamCoordinatorClient().addListener(streamName, new StreamPropertyListener() {\n        @Override\n        public void generationChanged(String streamName, int generation) {\n          AtomicInteger currentThresold = threshold;\n          StreamSizeAggregator currentAggregator = aggregators.get(streamName);\n          if (currentAggregator != null) {\n            currentThresold = currentAggregator.getStreamThresholdMB();\n          }\n          Cancellable previousAggregator = aggregators.replace(streamName, createSizeAggregator(streamName, 0,\n                                                                                                currentThresold));\n          if (previousAggregator != null) {\n            previousAggregator.cancel();\n          }\n        }\n      });\n\n    StreamSizeAggregator newAggregator = new StreamSizeAggregator(streamName, baseCount, threshold, new Cancellable() {\n      @Override\n      public void cancel() {\n        thresholdSubscription.cancel();\n        truncationSubscription.cancel();\n      }\n    });\n    aggregators.put(streamName, newAggregator);\n    return newAggregator;\n  }","id":26559,"modified_method":"/**\n   * Create a new aggregator for the {@code streamName}, and add it to the existing map of {@link Cancellable}\n   * {@code aggregators}. This method does not cancel previously existing aggregator associated to the\n   * {@code streamName}.\n   *\n   * @param streamName stream name to create a new aggregator for\n   * @param baseCount stream size from which to start aggregating\n   * @return the created {@link StreamSizeAggregator}\n   */\n  private StreamSizeAggregator createSizeAggregator(String streamName, long baseCount, int threshold) {\n\n    // Handle threshold changes\n    final Cancellable thresholdSubscription =\n      getStreamCoordinatorClient().addListener(streamName, new StreamPropertyListener() {\n        @Override\n        public void thresholdChanged(String streamName, int threshold) {\n          StreamSizeAggregator aggregator = aggregators.get(streamName);\n          while (aggregator == null) {\n            Thread.yield();\n            aggregator = aggregators.get(streamName);\n          }\n          aggregator.setStreamThresholdMB(threshold);\n        }\n      });\n\n    // Handle stream truncation, by creating creating a new empty aggregator for the stream\n    // and cancelling the existing one\n    final Cancellable truncationSubscription =\n      getStreamCoordinatorClient().addListener(streamName, new StreamPropertyListener() {\n        @Override\n        public void generationChanged(String streamName, int generation) {\n          StreamSizeAggregator aggregator = aggregators.get(streamName);\n          while (aggregator == null) {\n            Thread.yield();\n            aggregator = aggregators.get(streamName);\n          }\n          aggregator.resetCount();\n        }\n      });\n\n    StreamSizeAggregator newAggregator = new StreamSizeAggregator(streamName, baseCount, threshold, new Cancellable() {\n      @Override\n      public void cancel() {\n        thresholdSubscription.cancel();\n        truncationSubscription.cancel();\n      }\n    });\n    aggregators.put(streamName, newAggregator);\n    return newAggregator;\n  }","commit_id":"bd86a12fb0145a4de25c440972865e89a3023ec8","url":"https://github.com/caskdata/cdap"},{"original_method":"protected StreamSizeAggregator(String streamName, long baseCount, AtomicInteger streamThresholdMB,\n                                   Cancellable cancellable) {\n      this.streamName = streamName;\n      this.streamInitSize = new AtomicLong(baseCount);\n      this.streamBaseCount = new AtomicLong(baseCount);\n      this.cancellable = cancellable;\n      this.streamFeed = new NotificationFeed.Builder()\n        .setNamespace(Constants.DEFAULT_NAMESPACE)\n        .setCategory(Constants.Notification.Stream.STREAM_FEED_CATEGORY)\n        .setName(streamName)\n        .build();\n      this.streamThresholdMB = streamThresholdMB;\n    }","id":26560,"modified_method":"protected StreamSizeAggregator(String streamName, long baseCount, int streamThresholdMB, Cancellable cancellable) {\n      this.streamName = streamName;\n      this.streamInitSize = new AtomicLong(baseCount);\n      this.streamBaseCount = new AtomicLong(baseCount);\n      this.cancellable = cancellable;\n      this.streamFeed = new NotificationFeed.Builder()\n        .setNamespace(Constants.DEFAULT_NAMESPACE)\n        .setCategory(Constants.Notification.Stream.STREAM_FEED_CATEGORY)\n        .setName(streamName)\n        .build();\n      this.streamThresholdMB = new AtomicInteger(streamThresholdMB);\n    }","commit_id":"bd86a12fb0145a4de25c440972865e89a3023ec8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ListenableFuture<StreamWriterHeartbeat> sendHeartbeat(StreamWriterHeartbeat heartbeat) throws IOException {\n    try {\n      return notificationService.publish(heartbeatFeed, heartbeat);\n    } catch (NotificationException e) {\n      throw new IOException(e);\n    }\n  }","id":26561,"modified_method":"@Override\n  public ListenableFuture<StreamWriterHeartbeat> sendHeartbeat(StreamWriterHeartbeat heartbeat) {\n    try {\n      return notificationService.publish(heartbeatFeed, heartbeat);\n    } catch (NotificationException e) {\n      throw new IllegalArgumentException(\"Streams' heartbeat notification feed has not been created\", e);\n    }\n  }","commit_id":"bd86a12fb0145a4de25c440972865e89a3023ec8","url":"https://github.com/caskdata/cdap"},{"original_method":"public static <S extends Sequence> HashedSequence<S> wrap(S base, SequenceComparator<S> cmp) {\n    int size = base.length();\n    int[] hashes = new int[size];\n    for (int i = 0; i < size; i++) {\n      hashes[i] = cmp.hash(base, i);\n    }\n    return new HashedSequence<S>(base, hashes);\n  }","id":26562,"modified_method":"public static <S extends Sequence> HashedSequence<S> wrap(S base, SequenceComparator<S> cmp) {\n    int size = base.length();\n    int[] hashes = new int[size];\n    Multimap<Integer, Integer> linesByHash = LinkedHashMultimap.create();\n    for (int i = 0; i < size; i++) {\n      hashes[i] = cmp.hash(base, i);\n      linesByHash.put(hashes[i], i + 1); // indices in array are shifted one line before\n    }\n    return new HashedSequence<S>(base, hashes, linesByHash);\n  }","commit_id":"8e47daa95471eae70745bb914a1a15e2442de1dc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private HashedSequence(S base, int[] hashes) {\n    this.base = base;\n    this.hashes = hashes;\n  }","id":26563,"modified_method":"private HashedSequence(S base, int[] hashes, Multimap<Integer, Integer> linesByHash) {\n    this.base = base;\n    this.hashes = hashes;\n    this.linesByHash = linesByHash;\n  }","commit_id":"8e47daa95471eae70745bb914a1a15e2442de1dc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@VisibleForTesting\n  void doDecorate(Resource resource) {\n    Collection<DefaultIssue> issues = Lists.newArrayList();\n    for (Issue issue : issueCache.byComponent(resource.getEffectiveKey())) {\n      issueCache.remove(issue);\n      issues.add((DefaultIssue) issue);\n    }\n    // issues = all the issues created by rule engines during this module scan and not excluded by filters\n\n    // all the issues that are not closed in db before starting this module scan, including manual issues\n    Collection<IssueDto> dbOpenIssues = initialOpenIssues.selectAndRemove(resource.getEffectiveKey());\n\n    SourceHashHolder sourceHashHolder = new SourceHashHolder(index, lastSnapshots, resource);\n\n    IssueTrackingResult trackingResult = tracking.track(sourceHashHolder, dbOpenIssues, issues);\n\n    // unmatched = issues that have been resolved + issues on disabled/removed rules + manual issues\n    addUnmatched(trackingResult.unmatched(), issues);\n\n    mergeMatched(trackingResult);\n\n    if (ResourceUtils.isProject(resource)) {\n      // issues that relate to deleted components\n      addIssuesOnDeletedComponents(issues);\n    }\n\n    for (DefaultIssue issue : issues) {\n      workflow.doAutomaticTransition(issue, changeContext);\n      handlers.execute(issue, changeContext);\n      issueCache.put(issue);\n    }\n  }","id":26564,"modified_method":"@VisibleForTesting\n  void doDecorate(Resource resource) {\n    Collection<DefaultIssue> issues = Lists.newArrayList();\n    for (Issue issue : issueCache.byComponent(resource.getEffectiveKey())) {\n      issueCache.remove(issue);\n      issues.add((DefaultIssue) issue);\n    }\n    // issues = all the issues created by rule engines during this module scan and not excluded by filters\n\n    // all the issues that are not closed in db before starting this module scan, including manual issues\n    Collection<IssueDto> dbOpenIssues = initialOpenIssues.selectAndRemove(resource.getEffectiveKey());\n\n    SourceHashHolder sourceHashHolder = new SourceHashHolder(index, lastSnapshots, resource);\n\n    IssueTrackingResult trackingResult = tracking.track(sourceHashHolder, dbOpenIssues, issues);\n\n    // unmatched = issues that have been resolved + issues on disabled/removed rules + manual issues\n    addUnmatched(trackingResult.unmatched(), sourceHashHolder, issues);\n\n    mergeMatched(trackingResult);\n\n    if (ResourceUtils.isProject(resource)) {\n      // issues that relate to deleted components\n      addIssuesOnDeletedComponents(issues);\n    }\n\n    for (DefaultIssue issue : issues) {\n      workflow.doAutomaticTransition(issue, changeContext);\n      handlers.execute(issue, changeContext);\n      issueCache.put(issue);\n    }\n  }","commit_id":"8e47daa95471eae70745bb914a1a15e2442de1dc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void addUnmatched(Collection<IssueDto> unmatchedIssues, Collection<DefaultIssue> issues) {\n    for (IssueDto unmatchedDto : unmatchedIssues) {\n      DefaultIssue unmatched = unmatchedDto.toDefaultIssue();\n      updateUnmatchedIssue(unmatched, false /* manual issues can be kept open */);\n      issues.add(unmatched);\n    }\n  }","id":26565,"modified_method":"private void addUnmatched(Collection<IssueDto> unmatchedIssues, SourceHashHolder sourceHashHolder, Collection<DefaultIssue> issues) {\n    for (IssueDto unmatchedDto : unmatchedIssues) {\n      DefaultIssue unmatched = unmatchedDto.toDefaultIssue();\n      if (StringUtils.isNotBlank(unmatchedDto.getReporter())) {\n        relocateManualIssue(unmatched, unmatchedDto, sourceHashHolder);\n      }\n      updateUnmatchedIssue(unmatched, false /* manual issues can be kept open */);\n      issues.add(unmatched);\n    }\n  }","commit_id":"8e47daa95471eae70745bb914a1a15e2442de1dc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void manual_issues_should_be_closed_if_manual_rule_is_not_found() throws Exception {\n    // \"Unmatched\" issues existed in previous scan but not in current one -> they have to be closed\n    Resource file = new File(\"Action.java\").setEffectiveKey(\"struts:Action.java\").setId(123);\n\n    // INPUT : one issue existing during previous scan\n    IssueDto unmatchedIssue = new IssueDto().setKee(\"ABCDE\").setReporter(\"freddy\").setStatus(\"OPEN\").setRuleKey_unit_test_only(\"manual\", \"Performance\");\n    when(ruleFinder.findByKey(RuleKey.of(\"manual\", \"Performance\"))).thenReturn(null);\n\n    IssueTrackingResult trackingResult = new IssueTrackingResult();\n    trackingResult.addUnmatched(unmatchedIssue);\n\n    when(tracking.track(isA(SourceHashHolder.class), anyCollection(), anyCollection())).thenReturn(trackingResult);\n\n    decorator.doDecorate(file);\n\n    verify(workflow, times(1)).doAutomaticTransition(any(DefaultIssue.class), any(IssueChangeContext.class));\n    verify(handlers, times(1)).execute(any(DefaultIssue.class), any(IssueChangeContext.class));\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(issueCache).put(argument.capture());\n\n    DefaultIssue issue = argument.getValue();\n    assertThat(issue.key()).isEqualTo(\"ABCDE\");\n    assertThat(issue.isNew()).isFalse();\n    assertThat(issue.isEndOfLife()).isTrue();\n    assertThat(issue.isOnDisabledRule()).isTrue();\n  }","id":26566,"modified_method":"@Test\n  public void manual_issues_should_be_closed_if_manual_rule_is_not_found() throws Exception {\n    // \"Unmatched\" issues existed in previous scan but not in current one -> they have to be closed\n    Resource file = new File(\"Action.java\").setEffectiveKey(\"struts:Action.java\").setId(123);\n\n    // INPUT : one issue existing during previous scan\n    IssueDto unmatchedIssue = new IssueDto().setKee(\"ABCDE\").setReporter(\"freddy\").setLine(1).setStatus(\"OPEN\").setRuleKey_unit_test_only(\"manual\", \"Performance\");\n    when(ruleFinder.findByKey(RuleKey.of(\"manual\", \"Performance\"))).thenReturn(null);\n\n    IssueTrackingResult trackingResult = new IssueTrackingResult();\n    trackingResult.addUnmatched(unmatchedIssue);\n\n    String source = \"public interface Action {}\";\n    when(index.getSource(file)).thenReturn(source);\n    when(lastSnapshots.getSource(file)).thenReturn(source);\n\n    when(tracking.track(isA(SourceHashHolder.class), anyCollection(), anyCollection())).thenReturn(trackingResult);\n\n    decorator.doDecorate(file);\n\n    verify(workflow, times(1)).doAutomaticTransition(any(DefaultIssue.class), any(IssueChangeContext.class));\n    verify(handlers, times(1)).execute(any(DefaultIssue.class), any(IssueChangeContext.class));\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(issueCache).put(argument.capture());\n\n    DefaultIssue issue = argument.getValue();\n    assertThat(issue.key()).isEqualTo(\"ABCDE\");\n    assertThat(issue.isNew()).isFalse();\n    assertThat(issue.isEndOfLife()).isTrue();\n    assertThat(issue.isOnDisabledRule()).isTrue();\n  }","commit_id":"8e47daa95471eae70745bb914a1a15e2442de1dc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void manual_issues_should_be_kept_open() throws Exception {\n    // \"Unmatched\" issues existed in previous scan but not in current one -> they have to be closed\n    Resource file = new File(\"Action.java\").setEffectiveKey(\"struts:Action.java\").setId(123);\n\n    // INPUT : one issue existing during previous scan\n    IssueDto unmatchedIssue = new IssueDto().setKee(\"ABCDE\").setReporter(\"freddy\").setStatus(\"OPEN\").setRuleKey_unit_test_only(\"manual\", \"Performance\");\n    when(ruleFinder.findByKey(RuleKey.of(\"manual\", \"Performance\"))).thenReturn(new Rule(\"manual\", \"Performance\"));\n\n    IssueTrackingResult trackingResult = new IssueTrackingResult();\n    trackingResult.addUnmatched(unmatchedIssue);\n\n    when(tracking.track(isA(SourceHashHolder.class), anyCollection(), anyCollection())).thenReturn(trackingResult);\n\n    decorator.doDecorate(file);\n\n    verify(workflow, times(1)).doAutomaticTransition(any(DefaultIssue.class), any(IssueChangeContext.class));\n    verify(handlers, times(1)).execute(any(DefaultIssue.class), any(IssueChangeContext.class));\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(issueCache).put(argument.capture());\n\n    DefaultIssue issue = argument.getValue();\n    assertThat(issue.key()).isEqualTo(\"ABCDE\");\n    assertThat(issue.isNew()).isFalse();\n    assertThat(issue.isEndOfLife()).isFalse();\n    assertThat(issue.isOnDisabledRule()).isFalse();\n  }","id":26567,"modified_method":"@Test\n  public void manual_issues_should_be_kept_if_matching_line_not_found() throws Exception {\n    // \"Unmatched\" issues existed in previous scan but not in current one -> they have to be closed\n    Resource file = new File(\"Action.java\").setEffectiveKey(\"struts:Action.java\").setId(123);\n\n    // INPUT : one issue existing during previous scan\n    final int issueOnLine = 6;\n    IssueDto unmatchedIssue = new IssueDto().setKee(\"ABCDE\").setReporter(\"freddy\").setLine(issueOnLine).setStatus(\"OPEN\").setRuleKey_unit_test_only(\"manual\", \"Performance\");\n    when(ruleFinder.findByKey(RuleKey.of(\"manual\", \"Performance\"))).thenReturn(new Rule(\"manual\", \"Performance\"));\n\n    IssueTrackingResult trackingResult = new IssueTrackingResult();\n    trackingResult.addUnmatched(unmatchedIssue);\n\n    String originalSource = \"public interface Action {\\n\"\n      + \"   void method1();\\n\"\n      + \"   void method2();\\n\"\n      + \"   void method3();\\n\"\n      + \"   void method4();\\n\"\n      + \"   void method5();\\n\" // Original issue here\n      + \"}\";\n    String newSource = \"public interface Action {\\n\"\n      + \"   void method1();\\n\"\n      + \"   void method2();\\n\"\n      + \"   void method3();\\n\"\n      + \"   void method4();\\n\"\n      + \"   void method6();\\n\" // Poof, no method5 anymore\n      + \"}\";\n    when(index.getSource(file)).thenReturn(newSource);\n    when(lastSnapshots.getSource(file)).thenReturn(originalSource);\n\n    when(tracking.track(isA(SourceHashHolder.class), anyCollection(), anyCollection())).thenReturn(trackingResult);\n\n    decorator.doDecorate(file);\n\n    verify(workflow, times(1)).doAutomaticTransition(any(DefaultIssue.class), any(IssueChangeContext.class));\n    verify(handlers, times(1)).execute(any(DefaultIssue.class), any(IssueChangeContext.class));\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(issueCache).put(argument.capture());\n\n    DefaultIssue issue = argument.getValue();\n    assertThat(issue.line()).isEqualTo(issueOnLine);\n    assertThat(issue.key()).isEqualTo(\"ABCDE\");\n    assertThat(issue.isNew()).isFalse();\n    assertThat(issue.isEndOfLife()).isFalse();\n    assertThat(issue.isOnDisabledRule()).isFalse();\n  }","commit_id":"8e47daa95471eae70745bb914a1a15e2442de1dc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void manual_issues_should_be_closed_if_manual_rule_is_removed() throws Exception {\n    // \"Unmatched\" issues existed in previous scan but not in current one -> they have to be closed\n    Resource file = new File(\"Action.java\").setEffectiveKey(\"struts:Action.java\").setId(123);\n\n    // INPUT : one issue existing during previous scan\n    IssueDto unmatchedIssue = new IssueDto().setKee(\"ABCDE\").setReporter(\"freddy\").setStatus(\"OPEN\").setRuleKey_unit_test_only(\"manual\", \"Performance\");\n    when(ruleFinder.findByKey(RuleKey.of(\"manual\", \"Performance\"))).thenReturn(new Rule(\"manual\", \"Performance\").setStatus(Rule.STATUS_REMOVED));\n\n    IssueTrackingResult trackingResult = new IssueTrackingResult();\n    trackingResult.addUnmatched(unmatchedIssue);\n\n    when(tracking.track(isA(SourceHashHolder.class), anyCollection(), anyCollection())).thenReturn(trackingResult);\n\n    decorator.doDecorate(file);\n\n    verify(workflow, times(1)).doAutomaticTransition(any(DefaultIssue.class), any(IssueChangeContext.class));\n    verify(handlers, times(1)).execute(any(DefaultIssue.class), any(IssueChangeContext.class));\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(issueCache).put(argument.capture());\n\n    DefaultIssue issue = argument.getValue();\n    assertThat(issue.key()).isEqualTo(\"ABCDE\");\n    assertThat(issue.isNew()).isFalse();\n    assertThat(issue.isEndOfLife()).isTrue();\n    assertThat(issue.isOnDisabledRule()).isTrue();\n  }","id":26568,"modified_method":"@Test\n  public void manual_issues_should_be_closed_if_manual_rule_is_removed() throws Exception {\n    // \"Unmatched\" issues existed in previous scan but not in current one -> they have to be closed\n    Resource file = new File(\"Action.java\").setEffectiveKey(\"struts:Action.java\").setId(123);\n\n    // INPUT : one issue existing during previous scan\n    IssueDto unmatchedIssue = new IssueDto().setKee(\"ABCDE\").setReporter(\"freddy\").setLine(1).setStatus(\"OPEN\").setRuleKey_unit_test_only(\"manual\", \"Performance\");\n    when(ruleFinder.findByKey(RuleKey.of(\"manual\", \"Performance\"))).thenReturn(new Rule(\"manual\", \"Performance\").setStatus(Rule.STATUS_REMOVED));\n\n    IssueTrackingResult trackingResult = new IssueTrackingResult();\n    trackingResult.addUnmatched(unmatchedIssue);\n\n    String source = \"public interface Action {}\";\n    when(index.getSource(file)).thenReturn(source);\n    when(lastSnapshots.getSource(file)).thenReturn(source);\n\n    when(tracking.track(isA(SourceHashHolder.class), anyCollection(), anyCollection())).thenReturn(trackingResult);\n\n    decorator.doDecorate(file);\n\n    verify(workflow, times(1)).doAutomaticTransition(any(DefaultIssue.class), any(IssueChangeContext.class));\n    verify(handlers, times(1)).execute(any(DefaultIssue.class), any(IssueChangeContext.class));\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(issueCache).put(argument.capture());\n\n    DefaultIssue issue = argument.getValue();\n    assertThat(issue.key()).isEqualTo(\"ABCDE\");\n    assertThat(issue.isNew()).isFalse();\n    assertThat(issue.isEndOfLife()).isTrue();\n    assertThat(issue.isOnDisabledRule()).isTrue();\n  }","commit_id":"8e47daa95471eae70745bb914a1a15e2442de1dc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void initHashes() {\n    hashedReference = HashedSequence.wrap(new StringText(referenceSource), StringTextComparator.IGNORE_WHITESPACE);\n    hashedSource = HashedSequence.wrap(new StringText(source), StringTextComparator.IGNORE_WHITESPACE);\n  }","id":26569,"modified_method":"private void initHashes() {\n    hashedReference = HashedSequence.wrap(new StringText(getReferenceSource()), StringTextComparator.IGNORE_WHITESPACE);\n    hashedSource = HashedSequence.wrap(new StringText(getSource()), StringTextComparator.IGNORE_WHITESPACE);\n  }","commit_id":"8e47daa95471eae70745bb914a1a15e2442de1dc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n                                 ActionForm formIn,\n                                 HttpServletRequest request,\n                                 HttpServletResponse response) {\n\n        DynaActionForm form = (DynaActionForm)formIn;\n        Map params = makeParamMap(request);\n        RequestContext ctx = new RequestContext(request);\n        User loggedInUser = ctx.getLoggedInUser();\n        Long scheduleId = ctx.getParamAsLong((\"schid\"));\n\n        if (ctx.hasParam(\"schid\")) {\n            params.put(\"schid\", scheduleId);\n            Map schedule = new HashMap();\n            try {\n                schedule = new TaskomaticApi().lookupScheduleById(loggedInUser, scheduleId);\n            }\n            catch (TaskomaticApiException e) {\n                createErrorMessage(request,\n                        \"repos.jsp.message.taskomaticdown\", null);\n            }\n            String scheduleName = (String) schedule.get(\"job_label\");\n            String bunchName = (String) schedule.get(\"bunch\");\n            request.setAttribute(\"schedulename\", scheduleName);\n            form.set(\"schedulename\", scheduleName);\n            request.setAttribute(\"bunch\", bunchName);\n            Boolean active = isActive(schedule);\n            request.setAttribute(\"active\", active);\n            if (!active) {\n                request.setAttribute(\"activetill\", schedule.get(\"active_till\"));\n            }\n        }\n\n        prepDropdowns(ctx);\n        if (!isSubmitted(form)) {\n            setupForm(request, form);\n            return getStrutsDelegate().forwardParams(\n                    mapping.findForward(\"default\"),\n                    request.getParameterMap());\n        }\n\n        RecurringEventPicker picker = RecurringEventPicker.prepopulatePicker(\n                request, \"date\", null);\n\n        if (picker.isDisabled()) {\n            if (scheduleId == null) {\n                prepDropdowns(ctx);\n                createErrorMessage(request, \"message.scheduledisabled\", null);\n\n                return getStrutsDelegate().forwardParams(\n                        mapping.findForward(\"default\"), params);\n            }\n            return getStrutsDelegate().forwardParams(\n                    mapping.findForward(\"disable\"), params);\n        }\n\n        String scheduleName = form.getString(\"schedulename\");\n        String bunchName = form.getString(\"bunch\");\n\n        try {\n            TaskomaticApi tapi = new TaskomaticApi();\n            tapi.scheduleSatBunch(loggedInUser,\n                    scheduleName,\n                    bunchName,\n                    picker.getCronEntry()\n                    );\n            if (ctx.hasParam(\"create_button\")) {\n                createSuccessMessage(request, \"message.schedulecreated\", scheduleName);\n            }\n            else {\n                createSuccessMessage(request, \"message.scheduleupdated\", scheduleName);\n            }\n            Map schedule = tapi.lookupScheduleByBunchAndLabel(loggedInUser, bunchName,\n                    scheduleName);\n            params.put(\"schid\", schedule.get(\"id\"));\n            return getStrutsDelegate().forwardParams(\n                    mapping.findForward(\"success\"), params);\n        }\n        catch (TaskomaticApiException e) {\n            createErrorMessage(request,\n                    \"repos.jsp.message.taskomaticdown\", null);\n            return getStrutsDelegate().forwardParams(\n                    mapping.findForward(\"default\"), params);\n        }\n    }","id":26570,"modified_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n                                 ActionForm formIn,\n                                 HttpServletRequest request,\n                                 HttpServletResponse response) {\n\n        DynaActionForm form = (DynaActionForm)formIn;\n        Map params = makeParamMap(request);\n        RequestContext ctx = new RequestContext(request);\n        User loggedInUser = ctx.getLoggedInUser();\n        Long scheduleId = ctx.getParamAsLong((\"schid\"));\n\n        if (ctx.hasParam(\"schid\")) {\n            params.put(\"schid\", scheduleId);\n            Map schedule = new HashMap();\n            try {\n                schedule = new TaskomaticApi().lookupScheduleById(loggedInUser, scheduleId);\n            }\n            catch (TaskomaticApiException e) {\n                createErrorMessage(request,\n                        \"repos.jsp.message.taskomaticdown\", null);\n            }\n            String scheduleName = (String) schedule.get(\"job_label\");\n            String bunchName = (String) schedule.get(\"bunch\");\n            request.setAttribute(\"schedulename\", scheduleName);\n            form.set(\"schedulename\", scheduleName);\n            request.setAttribute(\"bunch\", bunchName);\n            Boolean active = isActive(schedule);\n            request.setAttribute(\"active\", active);\n            if (!active) {\n                request.setAttribute(\"activetill\", schedule.get(\"active_till\"));\n            }\n        }\n\n        prepDropdowns(ctx);\n        if (!isSubmitted(form)) {\n            setupForm(request, form);\n            return getStrutsDelegate().forwardParams(\n                    mapping.findForward(\"default\"),\n                    request.getParameterMap());\n        }\n\n        RecurringEventPicker picker = RecurringEventPicker.prepopulatePicker(\n                request, \"date\", null);\n\n        if (picker.isDisabled() || StringUtils.isEmpty(picker.getCronEntry())) {\n            if (scheduleId == null) {\n                prepDropdowns(ctx);\n                createErrorMessage(request, \"message.scheduledisabled\", null);\n\n                return getStrutsDelegate().forwardParams(\n                        mapping.findForward(\"default\"), params);\n            }\n            return getStrutsDelegate().forwardParams(\n                    mapping.findForward(\"disable\"), params);\n        }\n\n        String scheduleName = form.getString(\"schedulename\");\n        String bunchName = form.getString(\"bunch\");\n\n        try {\n            TaskomaticApi tapi = new TaskomaticApi();\n            tapi.scheduleSatBunch(loggedInUser,\n                    scheduleName,\n                    bunchName,\n                    picker.getCronEntry()\n                    );\n            if (ctx.hasParam(\"create_button\")) {\n                createSuccessMessage(request, \"message.schedulecreated\", scheduleName);\n            }\n            else {\n                createSuccessMessage(request, \"message.scheduleupdated\", scheduleName);\n            }\n            Map schedule = tapi.lookupScheduleByBunchAndLabel(loggedInUser, bunchName,\n                    scheduleName);\n            params.put(\"schid\", schedule.get(\"id\"));\n            return getStrutsDelegate().forwardParams(\n                    mapping.findForward(\"success\"), params);\n        }\n        catch (TaskomaticApiException e) {\n            if (e.getMessage().contains(\"InvalidParamException\")) {\n                createErrorMessage(request,\n                        \"repos.jsp.message.invalidcron\", picker.getCronEntry());\n            }\n            else {\n                createErrorMessage(request,\n                        \"repos.jsp.message.taskomaticdown\", null);\n            }\n            return getStrutsDelegate().forwardParams(\n                    mapping.findForward(\"default\"), params);\n        }\n    }","commit_id":"74c41853fae70b9e3f81c1cd6a5b3bd6a5e8a177","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Draw the node as small rectangle with the given color.\n     *\n     * @param n  The node to draw.\n     * @param color The color of the node.\n     */\n    @Override\n    public void drawNode(Node n, Color color, int size, int radius, boolean fill) {\n        if (isZoomOk(null) && size > 1) {\n            Point p = nc.getPoint(n);\n            if ((p.x < 0) || (p.y < 0) || (p.x > nc.getWidth())\n                    || (p.y > nc.getHeight()))\n                return;\n\n            //profilerVisibleNodes++;\n\n            g.setColor(color);\n            if (fill) {\n                g.fillRect(p.x - radius, p.y - radius, size, size);\n                g.drawRect(p.x - radius, p.y - radius, size, size);\n            } else {\n                g.drawRect(p.x - radius, p.y - radius, size, size);\n            }\n\n            if(showNames > dist)\n            {\n                String name = getNodeName(n);\n                if (name!=null /* && annotate */)\n                {\n                    g.setColor(textColor);\n                    Font defaultFont = g.getFont();\n                    g.setFont (orderFont);\n                    g.drawString (name, p.x+radius+2, p.y+radius+2);\n                    g.setFont(defaultFont);\n                }\n            }\n        }\n    }","id":26571,"modified_method":"/**\n     * Draw the node as small rectangle with the given color.\n     *\n     * @param n  The node to draw.\n     * @param color The color of the node.\n     */\n    @Override\n    public void drawNode(Node n, Color color, int size, int radius, boolean fill) {\n        if (isZoomOk(null) && size > 1) {\n            Point p = nc.getPoint(n);\n            if ((p.x < 0) || (p.y < 0) || (p.x > nc.getWidth())\n                    || (p.y > nc.getHeight()))\n                return;\n\n            //profilerVisibleNodes++;\n\n            if (inactive || n.isDisabled()) {\n                g.setColor(inactiveColor);\n            } else {\n                g.setColor(color);\n            }\n            if (fill) {\n                g.fillRect(p.x - radius, p.y - radius, size, size);\n                g.drawRect(p.x - radius, p.y - radius, size, size);\n            } else {\n                g.drawRect(p.x - radius, p.y - radius, size, size);\n            }\n\n            if(showNames > dist)\n            {\n                String name = getNodeName(n);\n                if (name!=null /* && annotate */)\n                {\n                    if (inactive || n.isDisabled()) {\n                        g.setColor(inactiveColor);\n                    } else {\n                        g.setColor(textColor);\n                    }\n                    Font defaultFont = g.getFont();\n                    g.setFont (orderFont);\n                    g.drawString (name, p.x+radius+2, p.y+radius+2);\n                    g.setFont(defaultFont);\n                }\n            }\n        }\n    }","commit_id":"df732bb190b23a018a8e12d670d3c2e70611d6e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void drawNode(Node n) {\n        /* check, if the node is visible at all */\n        if((n.getEastNorth().east()  > maxEN.east() ) ||\n                (n.getEastNorth().north() > maxEN.north()) ||\n                (n.getEastNorth().east()  < minEN.east() ) ||\n                (n.getEastNorth().north() < minEN.north()))\n        {\n            n.mappaintVisibleCode = viewid;\n            return;\n        }\n        n.mappaintVisibleCode = 0;\n\n        IconElemStyle nodeStyle = (IconElemStyle)getPrimitiveStyle(n);\n\n        //if(profilerOmitDraw)\n        //    return;\n\n        if (nodeStyle != null && isZoomOk(nodeStyle) && showIcons > dist) {\n            drawNode(n, nodeStyle.icon, nodeStyle.annotate, data.isSelected(n));\n        } else if (n.highlighted) {\n            drawNode(n, highlightColor, selectedNodeSize, selectedNodeRadius, fillSelectedNode);\n        } else if (data.isSelected(n)) {\n            drawNode(n, selectedColor, selectedNodeSize, selectedNodeRadius, fillSelectedNode);\n        } else if (n.isTagged()) {\n            drawNode(n, nodeColor, taggedNodeSize, taggedNodeRadius, fillUnselectedNode);\n        } else if (n.isDisabled()) {\n            drawNode(n, inactiveColor, unselectedNodeSize, unselectedNodeRadius, fillUnselectedNode);\n        } else {\n            drawNode(n, nodeColor, unselectedNodeSize, unselectedNodeRadius, fillUnselectedNode);\n        }\n    }","id":26572,"modified_method":"public void drawNode(Node n) {\n        /* check, if the node is visible at all */\n        if((n.getEastNorth().east()  > maxEN.east() ) ||\n                (n.getEastNorth().north() > maxEN.north()) ||\n                (n.getEastNorth().east()  < minEN.east() ) ||\n                (n.getEastNorth().north() < minEN.north()))\n        {\n            n.mappaintVisibleCode = viewid;\n            return;\n        }\n        n.mappaintVisibleCode = 0;\n\n        IconElemStyle nodeStyle = (IconElemStyle)getPrimitiveStyle(n);\n\n        //if(profilerOmitDraw)\n        //    return;\n\n        if (nodeStyle != null && isZoomOk(nodeStyle) && showIcons > dist) {\n            if (inactive || n.isDisabled()) {\n                drawNode(n, nodeStyle.getDisabledIcon(), nodeStyle.annotate, data.isSelected(n));\n            } else {\n                drawNode(n, nodeStyle.icon, nodeStyle.annotate, data.isSelected(n));\n            }\n        } else if (n.highlighted) {\n            drawNode(n, highlightColor, selectedNodeSize, selectedNodeRadius, fillSelectedNode);\n        } else if (data.isSelected(n)) {\n            drawNode(n, selectedColor, selectedNodeSize, selectedNodeRadius, fillSelectedNode);\n        } else if (n.isTagged()) {\n            drawNode(n, nodeColor, taggedNodeSize, taggedNodeRadius, fillUnselectedNode);\n        } else if (inactive || n.isDisabled()) {\n            drawNode(n, inactiveColor, unselectedNodeSize, unselectedNodeRadius, fillUnselectedNode);\n        } else {\n            drawNode(n, nodeColor, unselectedNodeSize, unselectedNodeRadius, fillUnselectedNode);\n        }\n    }","commit_id":"df732bb190b23a018a8e12d670d3c2e70611d6e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void drawNode(Node n, ImageIcon icon, boolean annotate, Boolean selected) {\n        Point p = nc.getPoint(n);\n        if ((p.x < 0) || (p.y < 0) || (p.x > nc.getWidth()) || (p.y > nc.getHeight())) return;\n\n        //profilerVisibleNodes++;\n\n        int w = icon.getIconWidth(), h=icon.getIconHeight();\n        icon.paintIcon ( Main.map.mapView, g, p.x-w/2, p.y-h/2 );\n        if(showNames > dist)\n        {\n            String name = getNodeName(n);\n            if (name!=null && annotate)\n            {\n                g.setColor(textColor);\n                Font defaultFont = g.getFont();\n                g.setFont (orderFont);\n                g.drawString (name, p.x+w/2+2, p.y+h/2+2);\n                g.setFont(defaultFont);\n            }\n        }\n        if (selected)\n        {\n            g.setColor (  selectedColor );\n            g.drawRect (p.x-w/2-2, p.y-h/2-2, w+4, h+4);\n        }\n    }","id":26573,"modified_method":"protected void drawNode(Node n, ImageIcon icon, boolean annotate, Boolean selected) {\n        Point p = nc.getPoint(n);\n        if ((p.x < 0) || (p.y < 0) || (p.x > nc.getWidth()) || (p.y > nc.getHeight())) return;\n\n        //profilerVisibleNodes++;\n\n        int w = icon.getIconWidth(), h=icon.getIconHeight();\n        icon.paintIcon ( Main.map.mapView, g, p.x-w/2, p.y-h/2 );\n        if(showNames > dist)\n        {\n            String name = getNodeName(n);\n            if (name!=null && annotate)\n            {\n                if (inactive || n.isDisabled()) {\n                    g.setColor(inactiveColor);\n                } else {\n                    g.setColor(textColor);\n                }\n                Font defaultFont = g.getFont();\n                g.setFont (orderFont);\n                g.drawString (name, p.x+w/2+2, p.y+h/2+2);\n                g.setFont(defaultFont);\n            }\n        }\n        if (selected)\n        {\n            g.setColor (  selectedColor );\n            g.drawRect (p.x-w/2-2, p.y-h/2-2, w+4, h+4);\n        }\n    }","commit_id":"df732bb190b23a018a8e12d670d3c2e70611d6e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n   *\n   * {@inheritDoc}\n   */\n    @Override\n    public ActionForward execute(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        RequestContext context = new RequestContext(request);\n        User user =  context.getLoggedInUser();\n\n        long cid = context.getRequiredParam(\"cid\");\n        Channel chan = ChannelFactory.lookupByIdAndUser(cid, user);\n        request.setAttribute(\"channel_name\", chan.getName());\n        request.setAttribute(\"cid\",  chan.getId());\n\n\n        Map params = new HashMap();\n        params.put(RequestContext.CID, chan.getId().toString());\n\n        ListHelper helper = new ListHelper(this, request, params);\n        helper.execute();\n\n\n        TaskomaticApi taskomatic = new TaskomaticApi();\n        String oldCronExpr;\n        try {\n            oldCronExpr = taskomatic.getRepoSyncSchedule(chan, user);\n        }\n        catch (TaskomaticApiException except) {\n            params.put(\"inactive\", true);\n            request.setAttribute(\"inactive\", true);\n            createErrorMessage(request,\n                    \"repos.jsp.message.taskomaticdown\", null);\n            return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n\n        }\n\n\n\n\n\n        RecurringEventPicker picker = RecurringEventPicker.prepopulatePicker(\n                request, \"date\", oldCronExpr);\n\n\n        if (context.isSubmitted()) {\n            StrutsDelegate strutsDelegate = getStrutsDelegate();\n\n            // check user permissions first\n            if (!UserManager.verifyChannelAdmin(user, chan)) {\n                createErrorMessage(request,\n                        \"frontend.actions.channels.manager.add.permsfailure\", null);\n                return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n            }\n\n            if (chan.getSources().isEmpty()) {\n                createErrorMessage(request,\n                        \"repos.jsp.channel.norepos\", null);\n                return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n            }\n\n            try {\n                if (context.wasDispatched(\"repos.jsp.button-sync\")) {\n                    // schedule one time repo sync\n                    taskomatic.scheduleSingleRepoSync(chan, user);\n                    createSuccessMessage(request, \"message.syncscheduled\",\n                            chan.getName());\n\n                }\n                else if (context.wasDispatched(\"schedule.button\")) {\n                    if (picker.isDisabled() && oldCronExpr != null) {\n                        taskomatic.unscheduleRepoSync(chan, user);\n                        createSuccessMessage(request, \"message.syncschedule.disabled\",\n                                chan.getName());\n                    }\n                    else if (picker.getCronEntry() != null) {\n                        Date date = taskomatic.scheduleRepoSync(chan, user,\n                                picker.getCronEntry());\n                        createSuccessMessage(request, \"message.syncscheduled\",\n                                chan.getName());\n                    }\n                }\n            }\n            catch (TaskomaticApiException e) {\n                if (e.getMessage().contains(\"InvalidParamException\")) {\n                    createErrorMessage(request,\n                            \"repos.jsp.message.invalidcron\", picker.getCronEntry());\n                }\n                else {\n                    createErrorMessage(request,\n                            \"repos.jsp.message.schedulefailed\", null);\n                }\n                return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n            }\n\n            Map forwardParams = new HashMap();\n            forwardParams.put(\"cid\", chan.getId());\n            return getStrutsDelegate().forwardParams(mapping.findForward(\"success\"),\n                    forwardParams);\n        }\n\n        return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n    }","id":26574,"modified_method":"/**\n   *\n   * {@inheritDoc}\n   */\n    @Override\n    public ActionForward execute(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        RequestContext context = new RequestContext(request);\n        User user =  context.getLoggedInUser();\n\n        long cid = context.getRequiredParam(\"cid\");\n        Channel chan = ChannelFactory.lookupByIdAndUser(cid, user);\n        request.setAttribute(\"channel_name\", chan.getName());\n        request.setAttribute(\"cid\",  chan.getId());\n\n\n        Map params = new HashMap();\n        params.put(RequestContext.CID, chan.getId().toString());\n\n        ListHelper helper = new ListHelper(this, request, params);\n        helper.execute();\n\n\n        TaskomaticApi taskomatic = new TaskomaticApi();\n        String oldCronExpr;\n        try {\n            oldCronExpr = taskomatic.getRepoSyncSchedule(chan, user);\n        }\n        catch (TaskomaticApiException except) {\n            params.put(\"inactive\", true);\n            request.setAttribute(\"inactive\", true);\n            createErrorMessage(request,\n                    \"repos.jsp.message.taskomaticdown\", null);\n            return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n\n        }\n\n\n\n\n\n        RecurringEventPicker picker = RecurringEventPicker.prepopulatePicker(\n                request, \"date\", oldCronExpr);\n\n\n        if (context.isSubmitted()) {\n            StrutsDelegate strutsDelegate = getStrutsDelegate();\n\n            // check user permissions first\n            if (!UserManager.verifyChannelAdmin(user, chan)) {\n                createErrorMessage(request,\n                        \"frontend.actions.channels.manager.add.permsfailure\", null);\n                return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n            }\n\n            if (chan.getSources().isEmpty()) {\n                createErrorMessage(request,\n                        \"repos.jsp.channel.norepos\", null);\n                return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n            }\n\n            try {\n                if (context.wasDispatched(\"repos.jsp.button-sync\")) {\n                    // schedule one time repo sync\n                    taskomatic.scheduleSingleRepoSync(chan, user);\n                    createSuccessMessage(request, \"message.syncscheduled\",\n                            chan.getName());\n\n                }\n                else if (context.wasDispatched(\"schedule.button\")) {\n                    if ((picker.isDisabled() || StringUtils.isEmpty(picker.getCronEntry())) &&\n                            oldCronExpr != null) {\n                        taskomatic.unscheduleRepoSync(chan, user);\n                        createSuccessMessage(request, \"message.syncschedule.disabled\",\n                                chan.getName());\n                    }\n                    else if (!StringUtils.isEmpty(picker.getCronEntry())) {\n                        Date date = taskomatic.scheduleRepoSync(chan, user,\n                                picker.getCronEntry());\n                        createSuccessMessage(request, \"message.syncscheduled\",\n                                chan.getName());\n                    }\n                }\n            }\n            catch (TaskomaticApiException e) {\n                if (e.getMessage().contains(\"InvalidParamException\")) {\n                    createErrorMessage(request,\n                            \"repos.jsp.message.invalidcron\", picker.getCronEntry());\n                }\n                else {\n                    createErrorMessage(request,\n                            \"repos.jsp.message.schedulefailed\", null);\n                }\n                return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n            }\n\n            Map forwardParams = new HashMap();\n            forwardParams.put(\"cid\", chan.getId());\n            return getStrutsDelegate().forwardParams(mapping.findForward(\"success\"),\n                    forwardParams);\n        }\n\n        return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n    }","commit_id":"24e8a9dd5dab5913c82565ddd2c66deda51716ad","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n        ActionForm form, HttpServletRequest request,\n        HttpServletResponse response) {\n\n        String rpmSchemaVersion = getRpmSchemaVersion(\"satellite-schema\");\n        if (rpmSchemaVersion == null) {\n            rpmSchemaVersion = getRpmSchemaVersion(\"spacewalk-schema\");\n        }\n\n        SelectMode m = ModeFactory.getMode(\"General_queries\", \"installed_schema_version\");\n        DataResult<HashMap> dr = m.execute();\n        String installedSchemaVersion = null;\n        if (dr.size() > 0) {\n            installedSchemaVersion = (String) dr.get(0).get(\"version\");\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"RPM version of schema: \" +\n                (rpmSchemaVersion == null ? \"null\" : rpmSchemaVersion));\n            log.debug(\"Version of installed database schema: \" +\n                (installedSchemaVersion == null ? \"null\" : installedSchemaVersion));\n        }\n\n        if (rpmSchemaVersion != null && installedSchemaVersion != null &&\n            !rpmSchemaVersion.equals(installedSchemaVersion)) {\n            request.setAttribute(\"schemaUpgradeRequired\", \"true\");\n        }\n        else {\n            request.setAttribute(\"schemaUpgradeRequired\", \"false\");\n        }\n\n        CertificateManager man = CertificateManager.getInstance();\n        if (man.isSatelliteCertInRestrictedPeriod()) {\n            createErrorMessageWithMultipleArgs(request, \"satellite.expired.restricted\",\n                    man.getDayProgressInRestrictedPeriod());\n        }\n        else if (man.isSatelliteCertExpired()) {\n            addMessage(request, \"satellite.expired\");\n            request.setAttribute(HAS_EXPIRED, Boolean.TRUE);\n            return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n        }\n        else if (man.isSatelliteCertInGracePeriod()) {\n            long daysUntilExpiration = man.getDaysLeftBeforeCertExpiration();\n            createSuccessMessage(request,\n                \"satellite.graceperiod\",\n                String.valueOf(daysUntilExpiration));\n        }\n        else if (!UserManager.satelliteHasUsers()) {\n            return mapping.findForward(\"needuser\");\n        }\n\n        if (AclManager.hasAcl(\"user_authenticated()\", request, null)) {\n            return mapping.findForward(\"loggedin\");\n        }\n\n        String remoteUserString = request.getRemoteUser();\n        if (remoteUserString != null) {\n\n            String firstname = decodeFromIso88591(\n                    (String) request.getAttribute(\"REMOTE_USER_FIRSTNAME\"), \"\");\n            String lastname = decodeFromIso88591(\n                    (String) request.getAttribute(\"REMOTE_USER_LASTNAME\"), \"\");\n            String email = decodeFromIso88591(\n                    (String) request.getAttribute(\"REMOTE_USER_EMAIL\"), null);\n\n            User remoteUser = null;\n            try {\n                log.info(\"REMOTE_USER_CUSTOM_N: \" +\n                        request.getAttribute(\"REMOTE_USER_CUSTOM_N\"));\n                log.info(\"REMOTE_USER_GECOS: \" +\n                        request.getAttribute(\"REMOTE_USER_GECOS\"));\n                log.info(\"REMOTE_USER_GROUPS: \" +\n                        request.getAttribute(\"REMOTE_USER_GROUPS\"));\n\n                remoteUser = UserFactory.lookupByLogin(remoteUserString);\n\n                if (remoteUser.isDisabled()) {\n                    createErrorMessage(request, \"account.user.disabled\", remoteUserString);\n                    remoteUser = null;\n                }\n                else {\n                    UpdateUserCommand updateCmd = new UpdateUserCommand(remoteUser);\n                    updateCmd.setFirstNames(firstname);\n                    updateCmd.setLastName(lastname);\n                    updateCmd.setEmail(email);\n                    updateCmd.updateUser();\n                    log.warn(\"Kerberos login \" + remoteUserString + \" (\" + firstname + \" \" +\n                            lastname + \")\");\n                }\n            }\n            catch (LookupException le) {\n                Long defaultOrgId = ConfigDefaults.get().getIpaDefaultUserOrgId();\n                Org defaultOrg = OrgFactory.lookupById(defaultOrgId);\n                if (defaultOrg == null) {\n                    log.warn(\"Cannot find organization with id: \" + defaultOrgId);\n                }\n                else {\n                    CreateUserCommand createCmd = new CreateUserCommand();\n                    createCmd.setLogin(remoteUserString);\n                    // set a password, that cannot really be used\n                    createCmd.setRawPassword(DEFAULT_KERB_USER_PASSWORD);\n                    createCmd.setFirstNames(firstname);\n                    createCmd.setLastName(lastname);\n                    createCmd.setEmail(email);\n                    createCmd.setOrg(defaultOrg);\n                    createCmd.validate();\n                    createCmd.storeNewUser();\n                    remoteUser = createCmd.getUser();\n                    log.warn(\"Kerberos login \" + remoteUserString + \" (\" + firstname + \" \" +\n                            lastname + \") created.\");\n                }\n            }\n            if (remoteUser != null) {\n                if (remoteUser.getPassword().equals(DEFAULT_KERB_USER_PASSWORD)) {\n                    createMessage(request, \"message.kerbuserlogged\",\n                            new String [] {remoteUserString});\n                }\n                if (LoginAction.successfulLogin(request, response, remoteUser)) {\n                    return null;\n                }\n                return mapping.findForward(\"loggedin\");\n            }\n        }\n\n        // store url_bounce set by pxt pages\n        String urlBounce = request.getParameter(\"url_bounce\");\n        if (!StringUtils.isBlank(urlBounce)) {\n            HttpSession hs = request.getSession();\n            if (hs != null) {\n                hs.setAttribute(\"url_bounce\", urlBounce);\n            }\n        }\n        return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n    }","id":26575,"modified_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n        ActionForm form, HttpServletRequest request,\n        HttpServletResponse response) {\n\n        String rpmSchemaVersion = getRpmSchemaVersion(\"satellite-schema\");\n        if (rpmSchemaVersion == null) {\n            rpmSchemaVersion = getRpmSchemaVersion(\"spacewalk-schema\");\n        }\n\n        SelectMode m = ModeFactory.getMode(\"General_queries\", \"installed_schema_version\");\n        DataResult<HashMap> dr = m.execute();\n        String installedSchemaVersion = null;\n        if (dr.size() > 0) {\n            installedSchemaVersion = (String) dr.get(0).get(\"version\");\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"RPM version of schema: \" +\n                (rpmSchemaVersion == null ? \"null\" : rpmSchemaVersion));\n            log.debug(\"Version of installed database schema: \" +\n                (installedSchemaVersion == null ? \"null\" : installedSchemaVersion));\n        }\n\n        if (rpmSchemaVersion != null && installedSchemaVersion != null &&\n            !rpmSchemaVersion.equals(installedSchemaVersion)) {\n            request.setAttribute(\"schemaUpgradeRequired\", \"true\");\n        }\n        else {\n            request.setAttribute(\"schemaUpgradeRequired\", \"false\");\n        }\n\n        CertificateManager man = CertificateManager.getInstance();\n        if (man.isSatelliteCertInRestrictedPeriod()) {\n            createErrorMessageWithMultipleArgs(request, \"satellite.expired.restricted\",\n                    man.getDayProgressInRestrictedPeriod());\n        }\n        else if (man.isSatelliteCertExpired()) {\n            addMessage(request, \"satellite.expired\");\n            request.setAttribute(HAS_EXPIRED, Boolean.TRUE);\n            return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n        }\n        else if (man.isSatelliteCertInGracePeriod()) {\n            long daysUntilExpiration = man.getDaysLeftBeforeCertExpiration();\n            createSuccessMessage(request,\n                \"satellite.graceperiod\",\n                String.valueOf(daysUntilExpiration));\n        }\n        else if (!UserManager.satelliteHasUsers()) {\n            return mapping.findForward(\"needuser\");\n        }\n\n        if (AclManager.hasAcl(\"user_authenticated()\", request, null)) {\n            return mapping.findForward(\"loggedin\");\n        }\n\n        String remoteUserString = request.getRemoteUser();\n        if (remoteUserString != null) {\n\n            String firstname = decodeFromIso88591(\n                    (String) request.getAttribute(\"REMOTE_USER_FIRSTNAME\"), \"\");\n            String lastname = decodeFromIso88591(\n                    (String) request.getAttribute(\"REMOTE_USER_LASTNAME\"), \"\");\n            String email = decodeFromIso88591(\n                    (String) request.getAttribute(\"REMOTE_USER_EMAIL\"), null);\n\n            Long defaultOrgId = SatConfigFactory.getSatConfigLongValue(\n                    SatConfigFactory.ORG_ID_FOR_EXT_AUTH);\n\n            User remoteUser = null;\n            try {\n                log.info(\"REMOTE_USER_CUSTOM_N: \" +\n                        request.getAttribute(\"REMOTE_USER_CUSTOM_N\"));\n                log.info(\"REMOTE_USER_GECOS: \" +\n                        request.getAttribute(\"REMOTE_USER_GECOS\"));\n                log.info(\"REMOTE_USER_GROUPS: \" +\n                        request.getAttribute(\"REMOTE_USER_GROUPS\"));\n\n                remoteUser = UserFactory.lookupByLogin(remoteUserString);\n\n                if (remoteUser.isDisabled()) {\n                    createErrorMessage(request, \"account.user.disabled\", remoteUserString);\n                    remoteUser = null;\n                }\n                else if (!remoteUser.getOrg().getId().equals(defaultOrgId)) {\n                    createErrorMessage(request, \"account.user.wrong_org\", remoteUserString);\n                    remoteUser = null;\n                }\n                if (remoteUser != null) {\n                    UpdateUserCommand updateCmd = new UpdateUserCommand(remoteUser);\n                    updateCmd.setFirstNames(firstname);\n                    updateCmd.setLastName(lastname);\n                    updateCmd.setEmail(email);\n                    updateCmd.updateUser();\n                    log.warn(\"Externally authenticated login \" + remoteUserString + \" (\" + firstname + \" \" +\n                            lastname + \")\");\n                }\n            }\n            catch (LookupException le) {\n                Org defaultOrg = null;\n                if (defaultOrgId != null) {\n                    defaultOrg = OrgFactory.lookupById(defaultOrgId);\n                }\n                if (defaultOrg == null) {\n                    log.error(\"Cannot find organization with id: \" + defaultOrgId);\n                }\n                else {\n                    CreateUserCommand createCmd = new CreateUserCommand();\n                    createCmd.setLogin(remoteUserString);\n                    // set a password, that cannot really be used\n                    createCmd.setRawPassword(DEFAULT_KERB_USER_PASSWORD);\n                    createCmd.setFirstNames(firstname);\n                    createCmd.setLastName(lastname);\n                    createCmd.setEmail(email);\n                    createCmd.setOrg(defaultOrg);\n                    createCmd.validate();\n                    createCmd.storeNewUser();\n                    remoteUser = createCmd.getUser();\n                    log.warn(\"Externally authenticated login \" + remoteUserString + \" (\" + firstname + \" \" +\n                            lastname + \") created.\");\n                }\n            }\n            if (remoteUser != null) {\n                if (remoteUser.getPassword().equals(DEFAULT_KERB_USER_PASSWORD)) {\n                    createMessage(request, \"message.kerbuserlogged\",\n                            new String [] {remoteUserString});\n                }\n                if (LoginAction.successfulLogin(request, response, remoteUser)) {\n                    return null;\n                }\n                return mapping.findForward(\"loggedin\");\n            }\n        }\n\n        // store url_bounce set by pxt pages\n        String urlBounce = request.getParameter(\"url_bounce\");\n        if (!StringUtils.isBlank(urlBounce)) {\n            HttpSession hs = request.getSession();\n            if (hs != null) {\n                hs.setAttribute(\"url_bounce\", urlBounce);\n            }\n        }\n        return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n    }","commit_id":"0aac65672a8436cc7091cabf5e7ccf4373b11dec","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private void processSheet(Sheet sheet,\n                              List< ? extends DataListener> listeners) {\n        int maxRows = sheet.getLastRowNum();\n\n        CellRangeAddress[] mergedRanges = getMergedCells(sheet);\n        DataFormatter formatter = new DataFormatter();\n\n        for ( int i = 0; i <= maxRows; i++ ) {\n            Row row = sheet.getRow( i );\n            int lastCellNum = row != null ? row.getLastCellNum() : 0;\n            newRow( listeners, i, lastCellNum );\n\n            for ( int cellNum = 0; cellNum < lastCellNum; cellNum++ ) {\n                Cell cell = row.getCell(cellNum);\n                if (cell == null)\n                    continue;\n                double num = 0;\n\n                CellRangeAddress merged = getRangeIfMerged( cell,\n                        mergedRanges );\n\n                if ( merged != null ) {\n\n                    Cell topLeft = sheet.getRow(merged.getFirstRow()).getCell(merged.getFirstColumn());\n                    newCell( listeners,\n                            i,\n                            cellNum,\n                            formatter.formatCellValue(topLeft),\n                            topLeft.getColumnIndex() );\n                } else {\n                    if (cell.getCellType() == Cell.CELL_TYPE_NUMERIC) {\n                        num = cell.getNumericCellValue();\n                    }\n                    if ( Math.abs(num) - Math.ceil(num) != 0 ) {\n                        newCell(listeners, i, cellNum, String.valueOf(num), DataListener.NON_MERGED );\n                    } else {\n                        newCell( listeners,\n                                i,\n                                cellNum,\n                                formatter.formatCellValue(cell),\n                                DataListener.NON_MERGED );\n                    }\n                }\n            }\n        }\n        finishSheet( listeners );\n    }","id":26576,"modified_method":"private void processSheet(Sheet sheet,\n                              List< ? extends DataListener> listeners) {\n        int maxRows = sheet.getLastRowNum();\n\n        CellRangeAddress[] mergedRanges = getMergedCells(sheet);\n        DataFormatter formatter = new DataFormatter();\n\n        for ( int i = 0; i <= maxRows; i++ ) {\n            Row row = sheet.getRow( i );\n            int lastCellNum = row != null ? row.getLastCellNum() : 0;\n            newRow( listeners, i, lastCellNum );\n\n            for ( int cellNum = 0; cellNum < lastCellNum; cellNum++ ) {\n                Cell cell = row.getCell(cellNum);\n                if (cell == null)\n                    continue;\n                double num = 0;\n\n                CellRangeAddress merged = getRangeIfMerged( cell,\n                        mergedRanges );\n\n                if ( merged != null ) {\n\n                    Cell topLeft = sheet.getRow(merged.getFirstRow()).getCell(merged.getFirstColumn());\n                    newCell( listeners,\n                            i,\n                            cellNum,\n                            formatter.formatCellValue(topLeft),\n                            topLeft.getColumnIndex() );\n                } else {\n                    if (cell.getCellType() == Cell.CELL_TYPE_NUMERIC) {\n                        num = cell.getNumericCellValue();\n                    }\n                    if ( num - Math.round(num) != 0 ) {\n                        newCell(listeners, i, cellNum, String.valueOf(num), DataListener.NON_MERGED );\n                    } else {\n                        newCell( listeners,\n                                i,\n                                cellNum,\n                                formatter.formatCellValue(cell),\n                                DataListener.NON_MERGED );\n                    }\n                }\n            }\n        }\n        finishSheet( listeners );\n    }","commit_id":"612752c36c606a76e0b3ed3f93ec3efc0c8aa1d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public FieldValue getFieldValue(Object value,\n                                           ValueType valueType,\n                                           DateFormats dateFormats) {\n        FieldValue field = null;\n        if ( value == null ) {\n            valueType = ValueType.NULL_TYPE;\n        }\n\n        if ( valueType == ValueType.NULL_TYPE ) {\n            field = new ObjectFieldImpl( null );\n        } else if ( valueType == ValueType.PCHAR_TYPE || valueType == ValueType.CHAR_TYPE) {\n            if( value instanceof String && ((String)value).length() == 1 ) {\n                field = new LongFieldImpl( ((String) value).charAt(0) );\n            } else {\n                field = new LongFieldImpl( ((Character) value).charValue() );\n            }\n        } else if ( valueType == ValueType.PBYTE_TYPE ||   valueType == ValueType.BYTE_TYPE ) {\n            if( value instanceof String ) {\n                field = new LongFieldImpl( Byte.parseByte( (String) value) );\n            } else {\n                field = new LongFieldImpl( ((Number) value).byteValue() );\n            }\n        } else if ( valueType == ValueType.PSHORT_TYPE ||  valueType == ValueType.SHORT_TYPE ) {\n            if( value instanceof String ) {\n                field = new LongFieldImpl( Short.parseShort( (String) value) );\n            } else {\n                field = new LongFieldImpl( ((Number) value).shortValue() );\n            }\n        } else if ( valueType == ValueType.PINTEGER_TYPE || valueType == ValueType.INTEGER_TYPE ) {\n            if( value instanceof String ) {\n                field = new LongFieldImpl( Integer.parseInt( stripNumericType( (String) value ) ) );\n            } else {\n                field = new LongFieldImpl( ((Number) value).intValue() );\n            }\n        } else if ( valueType == ValueType.PLONG_TYPE || valueType == ValueType.LONG_TYPE ) {\n            if( value instanceof String ) {\n                field = new LongFieldImpl( Long.parseLong( stripNumericType( (String) value ) ) );\n            } else {\n                field = new LongFieldImpl( ((Number) value).longValue() );\n            }\n        } else if ( valueType == ValueType.PFLOAT_TYPE || valueType == ValueType.FLOAT_TYPE ) {\n            if( value instanceof String ) {\n                field = new DoubleFieldImpl( Float.parseFloat( stripNumericType( (String) value ) ) );\n            } else {\n                field = new DoubleFieldImpl( ((Number) value).floatValue() );\n            }\n        } else if ( valueType == ValueType.PDOUBLE_TYPE || valueType == ValueType.DOUBLE_TYPE ) {\n            if( value instanceof String ) {\n                field = new DoubleFieldImpl( Double.parseDouble( stripNumericType( (String) value ) ) );\n            } else {\n                field = new DoubleFieldImpl( ((Number) value).doubleValue() );\n            }\n        } else if ( valueType == ValueType.PBOOLEAN_TYPE || valueType == ValueType.BOOLEAN_TYPE ) {\n            if( value instanceof String ) {\n                field = new BooleanFieldImpl( Boolean.valueOf( (String) value).booleanValue() );\n            } else {\n                field = new BooleanFieldImpl( ((Boolean) value).booleanValue() );\n            }\n        }  else if ( valueType == ValueType.STRING_TYPE ) {\n            field = new ObjectFieldImpl( value );\n        } else if ( valueType == ValueType.DATE_TYPE ) {\n            //MN: I think its fine like this, seems to work !\n            if( value instanceof String ) {\n                Date date = DateUtils.parseDate( (String) value, dateFormats );\n                field = new ObjectFieldImpl( date );\n            } else {\n                field = new ObjectFieldImpl( value );\n            }\n        } else if ( valueType == ValueType.ARRAY_TYPE ) {\n            //MN: I think its fine like this.\n            field = new ObjectFieldImpl( value );\n        } else if ( valueType == ValueType.OBJECT_TYPE ) {\n            field = new ObjectFieldImpl( value );\n        } else if ( valueType == ValueType.BIG_DECIMAL_TYPE ) {\n            field = new ObjectFieldImpl( MathUtils.getBigDecimal( value ) );\n        } else if ( valueType == ValueType.BIG_INTEGER_TYPE ) {\n            field = new ObjectFieldImpl( MathUtils.getBigInteger( value ) );\n        } else if ( valueType == ValueType.CLASS_TYPE ) {\n            field = new ClassFieldImpl( (Class) value );\n        }\n\n        return field;\n    }","id":26577,"modified_method":"public FieldValue getFieldValue(Object value,\n                                           ValueType valueType,\n                                           DateFormats dateFormats) {\n        FieldValue field = null;\n        if ( value == null ) {\n            valueType = ValueType.NULL_TYPE;\n        }\n\n        if ( valueType == ValueType.NULL_TYPE ) {\n            field = new ObjectFieldImpl( null );\n        } else if ( valueType == ValueType.PCHAR_TYPE || valueType == ValueType.CHAR_TYPE) {\n            if( value instanceof String && ((String)value).length() == 1 ) {\n                field = new LongFieldImpl( ((String) value).charAt(0) );\n            } else {\n                field = new LongFieldImpl( ((Character) value).charValue() );\n            }\n        } else if ( valueType == ValueType.PBYTE_TYPE ||   valueType == ValueType.BYTE_TYPE ) {\n            if( value instanceof String ) {\n                field = new LongFieldImpl( Byte.parseByte( (String) value) );\n            } else {\n                field = new LongFieldImpl( ((Number) value).byteValue() );\n            }\n        } else if ( valueType == ValueType.PSHORT_TYPE ||  valueType == ValueType.SHORT_TYPE ) {\n            if( value instanceof String ) {\n                try {\n                    field = new LongFieldImpl( NumberFormat.getInstance().parse( (String) value ).shortValue() );\n                } catch ( ParseException e ) {\n                    throw new NumberFormatException( \"Error parsing number '\"+value+\"'\" );\n                }\n            } else {\n                field = new LongFieldImpl( ((Number) value).shortValue() );\n            }\n        } else if ( valueType == ValueType.PINTEGER_TYPE || valueType == ValueType.INTEGER_TYPE ) {\n            if( value instanceof String ) {\n                try {\n                    field = new LongFieldImpl( NumberFormat.getInstance().parse( (String) value ).intValue() );\n                } catch ( ParseException e ) {\n                    throw new NumberFormatException( \"Error parsing number '\"+value+\"'\" );\n                }\n            } else {\n                field = new LongFieldImpl( ((Number) value).intValue() );\n            }\n        } else if ( valueType == ValueType.PLONG_TYPE || valueType == ValueType.LONG_TYPE ) {\n            if( value instanceof String ) {\n                try {\n                    field = new LongFieldImpl( NumberFormat.getInstance().parse( (String) value ).longValue() );\n                } catch ( ParseException e ) {\n                    throw new NumberFormatException( \"Error parsing number '\"+value+\"'\" );\n                }\n            } else {\n                field = new LongFieldImpl( ((Number) value).longValue() );\n            }\n        } else if ( valueType == ValueType.PFLOAT_TYPE || valueType == ValueType.FLOAT_TYPE ) {\n            if( value instanceof String ) {\n                try {\n                    field = new DoubleFieldImpl( NumberFormat.getInstance().parse( (String) value ).floatValue() );\n                } catch ( ParseException e ) {\n                    throw new NumberFormatException( \"Error parsing number '\"+value+\"'\" );\n                }\n            } else {\n                field = new DoubleFieldImpl( ((Number) value).floatValue() );\n            }\n        } else if ( valueType == ValueType.PDOUBLE_TYPE || valueType == ValueType.DOUBLE_TYPE ) {\n            if( value instanceof String ) {\n                try {\n                    field = new DoubleFieldImpl( NumberFormat.getInstance().parse( (String) value ).doubleValue() );\n                } catch ( ParseException e ) {\n                    throw new NumberFormatException( \"Error parsing number '\"+value+\"'\" );\n                }\n            } else {\n                field = new DoubleFieldImpl( ((Number) value).doubleValue() );\n            }\n        } else if ( valueType == ValueType.PBOOLEAN_TYPE || valueType == ValueType.BOOLEAN_TYPE ) {\n            if( value instanceof String ) {\n                field = new BooleanFieldImpl( Boolean.valueOf( (String) value).booleanValue() );\n            } else {\n                field = new BooleanFieldImpl( ((Boolean) value).booleanValue() );\n            }\n        }  else if ( valueType == ValueType.STRING_TYPE ) {\n            field = new ObjectFieldImpl( value );\n        } else if ( valueType == ValueType.DATE_TYPE ) {\n            //MN: I think its fine like this, seems to work !\n            if( value instanceof String ) {\n                Date date = DateUtils.parseDate( (String) value, dateFormats );\n                field = new ObjectFieldImpl( date );\n            } else {\n                field = new ObjectFieldImpl( value );\n            }\n        } else if ( valueType == ValueType.ARRAY_TYPE ) {\n            //MN: I think its fine like this.\n            field = new ObjectFieldImpl( value );\n        } else if ( valueType == ValueType.OBJECT_TYPE ) {\n            field = new ObjectFieldImpl( value );\n        } else if ( valueType == ValueType.BIG_DECIMAL_TYPE ) {\n            field = new ObjectFieldImpl( MathUtils.getBigDecimal( value ) );\n        } else if ( valueType == ValueType.BIG_INTEGER_TYPE ) {\n            field = new ObjectFieldImpl( MathUtils.getBigInteger( value ) );\n        } else if ( valueType == ValueType.CLASS_TYPE ) {\n            field = new ClassFieldImpl( (Class) value );\n        }\n\n        return field;\n    }","commit_id":"612752c36c606a76e0b3ed3f93ec3efc0c8aa1d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Override\r\n    public void scrapeTag0(Tag tag) {\r\n        if (tag.name.equalsIgnoreCase(\"img\")) {\r\n            final String src = tag.opts.getProperty(\"src\", EMPTY_STRING);\r\n            try {\r\n                if (src.length() > 0) {\r\n                    final AnchorURL url = absolutePath(src);\r\n                    if (url != null) {\r\n                        final int width = Integer.parseInt(tag.opts.getProperty(\"width\", \"-1\"));\r\n                        final int height = Integer.parseInt(tag.opts.getProperty(\"height\", \"-1\"));\r\n                        final ImageEntry ie = new ImageEntry(url, tag.opts.getProperty(\"alt\", EMPTY_STRING), width, height, -1);\r\n                        this.images.add(ie);\r\n                    }\r\n                }\r\n            } catch (final NumberFormatException e) {}\r\n            this.evaluationScores.match(Element.imgpath, src);\r\n        } else if(tag.name.equalsIgnoreCase(\"base\")) {\r\n            try {\r\n                this.root = new DigestURL(tag.opts.getProperty(\"href\", EMPTY_STRING));\r\n            } catch (final MalformedURLException e) {}\r\n        } else if (tag.name.equalsIgnoreCase(\"frame\")) {\r\n            final AnchorURL src = absolutePath(tag.opts.getProperty(\"src\", EMPTY_STRING));\r\n            tag.opts.put(\"src\", src.toNormalform(true));\r\n            src.setAll(tag.opts);\r\n            this.anchors.add(src);\r\n            this.frames.add(src);\r\n            this.evaluationScores.match(Element.framepath, src.toNormalform(true));\r\n        } else if (tag.name.equalsIgnoreCase(\"body\")) {\r\n            final String c = tag.opts.getProperty(\"class\", EMPTY_STRING);\r\n            this.evaluationScores.match(Element.bodyclass, c);\r\n        } else if (tag.name.equalsIgnoreCase(\"div\")) {\r\n            final String id = tag.opts.getProperty(\"id\", EMPTY_STRING);\r\n            this.evaluationScores.match(Element.divid, id);\r\n            final String itemtype = tag.opts.getProperty(\"itemtype\", EMPTY_STRING);\r\n            if (itemtype.equals(\"http://data-vocabulary.org/Breadcrumb\")) {\r\n                breadcrumbs++;\r\n            }\r\n        } else if (tag.name.equalsIgnoreCase(\"meta\")) {\r\n            final String content = tag.opts.getProperty(\"content\", EMPTY_STRING);\r\n            String name = tag.opts.getProperty(\"name\", EMPTY_STRING);\r\n            if (name.length() > 0) {\r\n                this.metas.put(name.toLowerCase(), CharacterCoding.html2unicode(content));\r\n                if (name.toLowerCase().equals(\"generator\")) {\r\n                    this.evaluationScores.match(Element.metagenerator, content);\r\n                }\r\n            }\r\n            name = tag.opts.getProperty(\"http-equiv\", EMPTY_STRING);\r\n            if (name.length() > 0) {\r\n                this.metas.put(name.toLowerCase(), CharacterCoding.html2unicode(content));\r\n            }\r\n            name = tag.opts.getProperty(\"property\", EMPTY_STRING);\r\n            if (name.length() > 0) {\r\n                this.metas.put(name.toLowerCase(), CharacterCoding.html2unicode(content));\r\n            }\r\n        } else if (tag.name.equalsIgnoreCase(\"area\")) {\r\n            final String areatitle = cleanLine(tag.opts.getProperty(\"title\", EMPTY_STRING));\r\n            //String alt   = tag.opts.getProperty(\"alt\",EMPTY_STRING);\r\n            final String href  = tag.opts.getProperty(\"href\", EMPTY_STRING);\r\n            if (href.length() > 0) {\r\n                tag.opts.put(\"name\", areatitle);\r\n                AnchorURL url = absolutePath(href);\r\n                tag.opts.put(\"href\", url.toNormalform(true));\r\n                url.setAll(tag.opts);\r\n                this.anchors.add(url);\r\n            }\r\n        } else if (tag.name.equalsIgnoreCase(\"link\")) {\r\n            final String href = tag.opts.getProperty(\"href\", EMPTY_STRING);\r\n            final AnchorURL newLink = absolutePath(href);\r\n\r\n            if (newLink != null) {\r\n                tag.opts.put(\"href\", newLink.toNormalform(true));\r\n                String rel = tag.opts.getProperty(\"rel\", EMPTY_STRING);\r\n                final String linktitle = tag.opts.getProperty(\"title\", EMPTY_STRING);\r\n                final String type = tag.opts.getProperty(\"type\", EMPTY_STRING);\r\n                final String hreflang = tag.opts.getProperty(\"hreflang\", EMPTY_STRING);\r\n\r\n                if (rel.equalsIgnoreCase(\"shortcut icon\")) {\r\n                    final ImageEntry ie = new ImageEntry(newLink, linktitle, -1, -1, -1);\r\n                    this.images.add(ie);\r\n                    this.favicon = newLink;\r\n                } else if (rel.equalsIgnoreCase(\"canonical\")) {\r\n                    tag.opts.put(\"name\", this.titles.size() == 0 ? \"\" : this.titles.iterator().next());\r\n                    newLink.setAll(tag.opts);\r\n                    this.anchors.add(newLink);\r\n                    this.canonical = newLink;\r\n                } else if (rel.equalsIgnoreCase(\"publisher\")) {\r\n                    this.publisher = newLink;\r\n                } else if (rel.equalsIgnoreCase(\"top\") || rel.equalsIgnoreCase(\"up\") || rel.equalsIgnoreCase(\"next\") || rel.equalsIgnoreCase(\"prev\") || rel.equalsIgnoreCase(\"first\") || rel.equalsIgnoreCase(\"last\")) {\r\n                    this.navigation.put(rel, newLink);\r\n                } else if (rel.equalsIgnoreCase(\"alternate\") && type.equalsIgnoreCase(\"application/rss+xml\")) {\r\n                    this.rss.put(newLink, linktitle);\r\n                } else if (rel.equalsIgnoreCase(\"alternate\") && hreflang.length() > 0) {\r\n                    this.hreflang.put(hreflang, newLink);\r\n                } else if (rel.equalsIgnoreCase(\"stylesheet\") && type.equalsIgnoreCase(\"text/css\")) {\r\n                    this.css.put(newLink, rel);\r\n                    this.evaluationScores.match(Element.csspath, href);\r\n                } else if (!rel.equalsIgnoreCase(\"stylesheet\") && !rel.equalsIgnoreCase(\"alternate stylesheet\")) {\r\n                    tag.opts.put(\"name\", linktitle);\r\n                    newLink.setAll(tag.opts);\r\n                    this.anchors.add(newLink);\r\n                }\r\n            }\r\n        } else if(tag.name.equalsIgnoreCase(\"embed\")) {\r\n            final String src = tag.opts.getProperty(\"src\", EMPTY_STRING);\r\n            try {\r\n                if (src.length() > 0) {\r\n                    final AnchorURL url = absolutePath(src);\r\n                    if (url != null) {\r\n                        final int width = Integer.parseInt(tag.opts.getProperty(\"width\", \"-1\"));\r\n                        final int height = Integer.parseInt(tag.opts.getProperty(\"height\", \"-1\"));\r\n                        tag.opts.put(\"src\", url.toNormalform(true));\r\n                        final EmbedEntry ie = new EmbedEntry(url, width, height, tag.opts.getProperty(\"type\", EMPTY_STRING), tag.opts.getProperty(\"pluginspage\", EMPTY_STRING));\r\n                        this.embeds.put(url, ie);\r\n                        url.setAll(tag.opts);\r\n                        this.anchors.add(url);\r\n                    }\r\n                }\r\n            } catch (final NumberFormatException e) {}\r\n        } else if(tag.name.equalsIgnoreCase(\"param\")) {\r\n            final String name = tag.opts.getProperty(\"name\", EMPTY_STRING);\r\n            if (name.equalsIgnoreCase(\"movie\")) {\r\n                AnchorURL url = absolutePath(tag.opts.getProperty(\"value\", EMPTY_STRING));\r\n                tag.opts.put(\"value\", url.toNormalform(true));\r\n                url.setAll(tag.opts);\r\n                this.anchors.add(url);\r\n            }\r\n        } else if (tag.name.equalsIgnoreCase(\"iframe\")) {\r\n            final AnchorURL src = absolutePath(tag.opts.getProperty(\"src\", EMPTY_STRING));\r\n            tag.opts.put(\"src\", src.toNormalform(true));\r\n            src.setAll(tag.opts);\r\n            this.anchors.add(src);\r\n            this.iframes.add(src);\r\n            this.evaluationScores.match(Element.iframepath, src.toNormalform(true));\r\n        } else if (tag.name.equalsIgnoreCase(\"html\")) {\r\n            final String lang = tag.opts.getProperty(\"lang\", EMPTY_STRING);\r\n            if (!lang.isEmpty()) // fake a language meta to preserv detection from <html lang=\"xx\" />\r\n                this.metas.put(\"dc.language\",lang.substring(0,2)); // fix found entries like \"hu-hu\"\r\n        }\r\n\r\n        // fire event\r\n        fireScrapeTag0(tag.name, tag.opts);\r\n    }","id":26578,"modified_method":"@Override\r\n    public void scrapeTag0(Tag tag) {\r\n        if (tag.name.equalsIgnoreCase(\"img\")) {\r\n            final String src = tag.opts.getProperty(\"src\", EMPTY_STRING);\r\n            try {\r\n                if (src.length() > 0) {\r\n                    final AnchorURL url = absolutePath(src);\r\n                    if (url != null) {\r\n                        // use Numberformat.parse to allow parse of \"550px\"\r\n                        NumberFormat intnum = NumberFormat.getIntegerInstance ();\r\n                        final int width = intnum.parse(tag.opts.getProperty(\"width\", \"-1\")).intValue(); // Integer.parseInt fails on \"200px\"\r\n                        final int height = intnum.parse(tag.opts.getProperty(\"height\", \"-1\")).intValue();\r\n                        final ImageEntry ie = new ImageEntry(url, tag.opts.getProperty(\"alt\", EMPTY_STRING), width, height, -1);\r\n                        this.images.add(ie);\r\n                    }\r\n                }\r\n            } catch (final ParseException e) {}\r\n            this.evaluationScores.match(Element.imgpath, src);\r\n        } else if(tag.name.equalsIgnoreCase(\"base\")) {\r\n            try {\r\n                this.root = new DigestURL(tag.opts.getProperty(\"href\", EMPTY_STRING));\r\n            } catch (final MalformedURLException e) {}\r\n        } else if (tag.name.equalsIgnoreCase(\"frame\")) {\r\n            final AnchorURL src = absolutePath(tag.opts.getProperty(\"src\", EMPTY_STRING));\r\n            tag.opts.put(\"src\", src.toNormalform(true));\r\n            src.setAll(tag.opts);\r\n            this.anchors.add(src);\r\n            this.frames.add(src);\r\n            this.evaluationScores.match(Element.framepath, src.toNormalform(true));\r\n        } else if (tag.name.equalsIgnoreCase(\"body\")) {\r\n            final String c = tag.opts.getProperty(\"class\", EMPTY_STRING);\r\n            this.evaluationScores.match(Element.bodyclass, c);\r\n        } else if (tag.name.equalsIgnoreCase(\"div\")) {\r\n            final String id = tag.opts.getProperty(\"id\", EMPTY_STRING);\r\n            this.evaluationScores.match(Element.divid, id);\r\n            final String itemtype = tag.opts.getProperty(\"itemtype\", EMPTY_STRING);\r\n            if (itemtype.equals(\"http://data-vocabulary.org/Breadcrumb\")) {\r\n                breadcrumbs++;\r\n            }\r\n        } else if (tag.name.equalsIgnoreCase(\"meta\")) {\r\n            final String content = tag.opts.getProperty(\"content\", EMPTY_STRING);\r\n            String name = tag.opts.getProperty(\"name\", EMPTY_STRING);\r\n            if (name.length() > 0) {\r\n                this.metas.put(name.toLowerCase(), CharacterCoding.html2unicode(content));\r\n                if (name.toLowerCase().equals(\"generator\")) {\r\n                    this.evaluationScores.match(Element.metagenerator, content);\r\n                }\r\n            }\r\n            name = tag.opts.getProperty(\"http-equiv\", EMPTY_STRING);\r\n            if (name.length() > 0) {\r\n                this.metas.put(name.toLowerCase(), CharacterCoding.html2unicode(content));\r\n            }\r\n            name = tag.opts.getProperty(\"property\", EMPTY_STRING);\r\n            if (name.length() > 0) {\r\n                this.metas.put(name.toLowerCase(), CharacterCoding.html2unicode(content));\r\n            }\r\n        } else if (tag.name.equalsIgnoreCase(\"area\")) {\r\n            final String areatitle = cleanLine(tag.opts.getProperty(\"title\", EMPTY_STRING));\r\n            //String alt   = tag.opts.getProperty(\"alt\",EMPTY_STRING);\r\n            final String href  = tag.opts.getProperty(\"href\", EMPTY_STRING);\r\n            if (href.length() > 0) {\r\n                tag.opts.put(\"name\", areatitle);\r\n                AnchorURL url = absolutePath(href);\r\n                tag.opts.put(\"href\", url.toNormalform(true));\r\n                url.setAll(tag.opts);\r\n                this.anchors.add(url);\r\n            }\r\n        } else if (tag.name.equalsIgnoreCase(\"link\")) {\r\n            final String href = tag.opts.getProperty(\"href\", EMPTY_STRING);\r\n            final AnchorURL newLink = absolutePath(href);\r\n\r\n            if (newLink != null) {\r\n                tag.opts.put(\"href\", newLink.toNormalform(true));\r\n                String rel = tag.opts.getProperty(\"rel\", EMPTY_STRING);\r\n                final String linktitle = tag.opts.getProperty(\"title\", EMPTY_STRING);\r\n                final String type = tag.opts.getProperty(\"type\", EMPTY_STRING);\r\n                final String hreflang = tag.opts.getProperty(\"hreflang\", EMPTY_STRING);\r\n\r\n                if (rel.equalsIgnoreCase(\"shortcut icon\")) {\r\n                    final ImageEntry ie = new ImageEntry(newLink, linktitle, -1, -1, -1);\r\n                    this.images.add(ie);\r\n                    this.favicon = newLink;\r\n                } else if (rel.equalsIgnoreCase(\"canonical\")) {\r\n                    tag.opts.put(\"name\", this.titles.size() == 0 ? \"\" : this.titles.iterator().next());\r\n                    newLink.setAll(tag.opts);\r\n                    this.anchors.add(newLink);\r\n                    this.canonical = newLink;\r\n                } else if (rel.equalsIgnoreCase(\"publisher\")) {\r\n                    this.publisher = newLink;\r\n                } else if (rel.equalsIgnoreCase(\"top\") || rel.equalsIgnoreCase(\"up\") || rel.equalsIgnoreCase(\"next\") || rel.equalsIgnoreCase(\"prev\") || rel.equalsIgnoreCase(\"first\") || rel.equalsIgnoreCase(\"last\")) {\r\n                    this.navigation.put(rel, newLink);\r\n                } else if (rel.equalsIgnoreCase(\"alternate\") && type.equalsIgnoreCase(\"application/rss+xml\")) {\r\n                    this.rss.put(newLink, linktitle);\r\n                } else if (rel.equalsIgnoreCase(\"alternate\") && hreflang.length() > 0) {\r\n                    this.hreflang.put(hreflang, newLink);\r\n                } else if (rel.equalsIgnoreCase(\"stylesheet\") && type.equalsIgnoreCase(\"text/css\")) {\r\n                    this.css.put(newLink, rel);\r\n                    this.evaluationScores.match(Element.csspath, href);\r\n                } else if (!rel.equalsIgnoreCase(\"stylesheet\") && !rel.equalsIgnoreCase(\"alternate stylesheet\")) {\r\n                    tag.opts.put(\"name\", linktitle);\r\n                    newLink.setAll(tag.opts);\r\n                    this.anchors.add(newLink);\r\n                }\r\n            }\r\n        } else if(tag.name.equalsIgnoreCase(\"embed\")) {\r\n            final String src = tag.opts.getProperty(\"src\", EMPTY_STRING);\r\n            try {\r\n                if (src.length() > 0) {\r\n                    final AnchorURL url = absolutePath(src);\r\n                    if (url != null) {\r\n                        final int width = Integer.parseInt(tag.opts.getProperty(\"width\", \"-1\"));\r\n                        final int height = Integer.parseInt(tag.opts.getProperty(\"height\", \"-1\"));\r\n                        tag.opts.put(\"src\", url.toNormalform(true));\r\n                        final EmbedEntry ie = new EmbedEntry(url, width, height, tag.opts.getProperty(\"type\", EMPTY_STRING), tag.opts.getProperty(\"pluginspage\", EMPTY_STRING));\r\n                        this.embeds.put(url, ie);\r\n                        url.setAll(tag.opts);\r\n                        this.anchors.add(url);\r\n                    }\r\n                }\r\n            } catch (final NumberFormatException e) {}\r\n        } else if(tag.name.equalsIgnoreCase(\"param\")) {\r\n            final String name = tag.opts.getProperty(\"name\", EMPTY_STRING);\r\n            if (name.equalsIgnoreCase(\"movie\")) {\r\n                AnchorURL url = absolutePath(tag.opts.getProperty(\"value\", EMPTY_STRING));\r\n                tag.opts.put(\"value\", url.toNormalform(true));\r\n                url.setAll(tag.opts);\r\n                this.anchors.add(url);\r\n            }\r\n        } else if (tag.name.equalsIgnoreCase(\"iframe\")) {\r\n            final AnchorURL src = absolutePath(tag.opts.getProperty(\"src\", EMPTY_STRING));\r\n            tag.opts.put(\"src\", src.toNormalform(true));\r\n            src.setAll(tag.opts);\r\n            this.anchors.add(src);\r\n            this.iframes.add(src);\r\n            this.evaluationScores.match(Element.iframepath, src.toNormalform(true));\r\n        } else if (tag.name.equalsIgnoreCase(\"html\")) {\r\n            final String lang = tag.opts.getProperty(\"lang\", EMPTY_STRING);\r\n            if (!lang.isEmpty()) // fake a language meta to preserv detection from <html lang=\"xx\" />\r\n                this.metas.put(\"dc.language\",lang.substring(0,2)); // fix found entries like \"hu-hu\"\r\n        }\r\n\r\n        // fire event\r\n        fireScrapeTag0(tag.name, tag.opts);\r\n    }","commit_id":"0b6db04e4024f137a8316ceec9e7ca8bef636d0a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Test\n    public void testIdentPort() throws MalformedURLException {\n        String[][] testStrings = new String[][]{\n            new String[]{\"http://www.yacy.net:\", \"http://www.yacy.net/\"},\n            new String[]{\"http://www.yacy.net:-1\", \"http://www.yacy.net/\"},\n            new String[]{\"http://www.yacy.net:/\", \"http://www.yacy.net/\"},\n            new String[]{\"http://www.yacy.net: /\", \"http://www.yacy.net/\"}\n        };\n\n        for (int i = 0; i < testStrings.length; i++) {\n            // desired conversion result\n            System.out.print(\"testIdentPort: \" + testStrings[i][0]);\n            String shouldBe = testStrings[i][1];\n\n            // conversion result\n            String resolvedURL = (new DigestURL(testStrings[i][0])).toString();\n\n            // test if equal\n            assertEquals(shouldBe, resolvedURL);\n            System.out.println(\" -> \" + resolvedURL);\n\n        }\n    }","id":26579,"modified_method":"@Test\n    public void testIdentPort() throws MalformedURLException {\n        String[][] testStrings = new String[][]{\n            new String[]{\"http://www.yacy.net:\", \"http://www.yacy.net/\"},\n            new String[]{\"http://www.yacy.net:80\", \"http://www.yacy.net/\"},\n            new String[]{\"http://www.yacy.net:/\", \"http://www.yacy.net/\"},\n            new String[]{\"http://www.yacy.net: /\", \"http://www.yacy.net/\"}\n        };\n\n        for (int i = 0; i < testStrings.length; i++) {\n            // desired conversion result\n            System.out.print(\"testIdentPort: \" + testStrings[i][0]);\n            String shouldBe = testStrings[i][1];\n\n            // conversion result\n            String resolvedURL = (new DigestURL(testStrings[i][0])).toString();\n\n            // test if equal\n            assertEquals(shouldBe, resolvedURL);\n            System.out.println(\" -> \" + resolvedURL);\n\n        }\n    }","commit_id":"0b6db04e4024f137a8316ceec9e7ca8bef636d0a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * Test of parseToScraper method, of class htmlParser.\n     */\n    @Test\n    public void testParseToScraper_4args() throws Exception {\n        // test link with inline html in text\n        // expectation to deliver pure text as it is possibly indexed in outboundlinks_anchortext_txt/inboundlinks_anchortext_txt\n        final AnchorURL url = new AnchorURL(\"http://localhost/\");\n        final String mimetype = \"text/html\";\n        final String testhtml = \"<html><bod>\"\n                + \"<a href='x1.html'><span>testtext<\/span><\/a>\" // \"testtext\"\n                + \"<a href=\\\"http://localhost/x2.html\\\">   <i id=\\\"home-icon\\\" class=\\\"img-sprite\\\"><\/i>Start<\/a>\" // \"Start\"\n                + \"<a href='x1.html'><span class='button'><img src='pic.gif'/><\/span><\/a>\" // \"\"  + image\n                + \"<\/body><\/html>\";\n\n        ContentScraper scraper = parseToScraper(url, mimetype, testhtml, 10);\n        List<AnchorURL> anchorlist = scraper.getAnchors();\n\n        String linktxt = anchorlist.get(0).getTextProperty();\n        assertEquals(\"testtext\", linktxt);\n\n        linktxt = anchorlist.get(1).getTextProperty();\n        assertEquals(\"Start\", linktxt);\n\n        linktxt = anchorlist.get(2).getTextProperty();\n        assertEquals(\"\", linktxt);\n\n        int cnt = scraper.getImages().size();\n        assertEquals(1,cnt);\n    }","id":26580,"modified_method":"/**\n     * Test of parseToScraper method, of class htmlParser.\n     */\n    @Test\n    public void testParseToScraper_4args() throws Exception {\n        // test link with inline html in text\n        // expectation to deliver pure text as it is possibly indexed in outboundlinks_anchortext_txt/inboundlinks_anchortext_txt\n        final AnchorURL url = new AnchorURL(\"http://localhost/\");\n        final String mimetype = \"text/html\";\n        final String testhtml = \"<html><body>\"\n                + \"<a href='x1.html'><span>testtext<\/span><\/a>\" // \"testtext\"\n                + \"<a href=\\\"http://localhost/x2.html\\\">   <i id=\\\"home-icon\\\" class=\\\"img-sprite\\\"><\/i>Start<\/a>\" // \"Start\"\n                + \"<a href='x1.html'><span class='button'><img src='pic.gif'/><\/span><\/a>\" // \"\"  + image\n                + \"<figure><img width=\\\"550px\\\" title=\\\"image as exemple\\\" alt=\\\"image as exemple\\\" src=\\\"./img/my_image.png\\\"><\/figrue>\" // + img width 550 (+html5 figure)\n                + \"<\/body><\/html>\";\n\n        ContentScraper scraper = parseToScraper(url, mimetype, testhtml, 10);\n        List<AnchorURL> anchorlist = scraper.getAnchors();\n\n        String linktxt = anchorlist.get(0).getTextProperty();\n        assertEquals(\"testtext\", linktxt);\n\n        linktxt = anchorlist.get(1).getTextProperty();\n        assertEquals(\"Start\", linktxt);\n\n        linktxt = anchorlist.get(2).getTextProperty();\n        assertEquals(\"\", linktxt);\n\n        int cnt = scraper.getImages().size();\n        assertEquals(2,cnt);\n        ImageEntry img = scraper.getImages().get(1);\n        assertEquals(550,img.width());\n    }","commit_id":"0b6db04e4024f137a8316ceec9e7ca8bef636d0a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void main(String[] args) {\n    String INPUT = new String(\"<doc> <a><b><findme/><\/b><c><\/c><\/a> <\/doc>\");\n    try {\n      InputStream is = new ByteArrayInputStream(INPUT.getBytes());\n      Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is);\n      for(Node n : TreeTraversalFactory.Traverse(TreeTraversalFactory.Traverse(TreeTraversalFactory.Filter(TreeTraversalFactory.Traverse(new DomNode_TreePath().from(doc), TreeTraversalFactory.Axis(\"DESCENDANTS\")), new WhereFilter_1169051087510(null, null)), TreeTraversalFactory.Axis(\"PRECEDING_SIBLINGS\")), TreeTraversalFactory.Axis(\"DESCENDANTS\"))) {\n        System.out.println(n);\n      }\n    } catch (Exception ignored) {\n    }\n  }","id":26581,"modified_method":"public static void main(String[] args) {\n    String INPUT = new String(\"<doc> <a><b><findme/><\/b><c><\/c><\/a> <\/doc>\");\n    try {\n      InputStream is = new ByteArrayInputStream(INPUT.getBytes());\n      Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is);\n      for(Node node : TreeTraversalFactory.Filter(TreeTraversalFactory.Traverse(new DOM().from(doc), TreeTraversalFactory.Axis(\"DESCENDANTS\")), new WhereFilter_1175129771556(null, null))) {\n        System.out.println(node);\n      }\n    } catch (Exception ignored) {\n    }\n  }","commit_id":"89921c015494586d35a8a983b56fa1cc41ef03f8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void main(String[] args) {\n    SNode foo = null;\n    TreeTraversalFactory.Traverse(TreeTraversalFactory.Traverse(new SNODE().startTraversal(foo), TreeTraversalFactory.Axis(\"CHILDREN\"), \"child\"), TreeTraversalFactory.Axis(\"CHILDREN\"), \"link\");\n    TreeTraversalFactory.Traverse(TreeTraversalFactory.Traverse(new SNODE().startTraversal(foo), TreeTraversalFactory.Axis(\"CHILDREN\"), \"link\"), TreeTraversalFactory.Axis(\"CHILDREN\"), \"child\");\n  }","id":26582,"modified_method":"public static void main(String[] args) {\n    SNode foo = null;\n    TreeTraversalFactory.Traverse(\n            TreeTraversalFactory.Traverse(\n                    TreeTraversalFactory.Traverse(\n                            new SNODE().startTraversal(foo), \n                            TreeTraversalFactory.Axis(\"CHILDREN\"), \n                            \"child\"), \n                    TreeTraversalFactory.Axis(\"CHILDREN\"), \n            \"link\"), \n            TreeTraversalFactory.Axis(\"CHILDREN\"), \n            \"child\");\n  }","commit_id":"2ba1641a62f7600cdbd07120cb2e3cf91395fa77","url":"https://github.com/JetBrains/MPS"},{"original_method":"public BoostAllEffect(DynamicValue power, DynamicValue toughness, Duration duration, FilterCreaturePermanent filter, boolean excludeSource, String rule, boolean lockedInPT) {\n        super(duration, Layer.PTChangingEffects_7, SubLayer.ModifyPT_7c, isCanKill(toughness) ? Outcome.UnboostCreature : Outcome.BoostCreature);\n        this.power = power;\n        this.toughness = toughness;\n        this.filter = filter;\n        this.excludeSource = excludeSource;\n        \n        this.lockedInPT = lockedInPT;\n        if (rule == null) {\n            setText();\n        } else {\n            this.staticText = rule;\n        }\n    }","id":26583,"modified_method":"public BoostAllEffect(DynamicValue power, DynamicValue toughness, Duration duration, FilterCreaturePermanent filter, boolean excludeSource, String rule, boolean lockedInPT) {\n        super(duration, Layer.PTChangingEffects_7, SubLayer.ModifyPT_7c, isCanKill(toughness) ? Outcome.UnboostCreature : Outcome.BoostCreature);\n        this.power = power;\n        this.toughness = toughness;\n        this.filter = filter;\n        this.excludeSource = excludeSource;\n\n        this.lockedInPT = lockedInPT;\n        if (rule == null || rule.isEmpty()) {\n            setText();\n        } else {\n            this.staticText = rule;\n        }\n    }","commit_id":"4b7270672caf3edcacefa277b4df7c2f065cbf65","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public DynamicValue copy() {\r\n        return new ManacostVariableValue();\r\n    }","id":26584,"modified_method":"@Override\r\n    public ManacostVariableValue copy() {\r\n        return new ManacostVariableValue();\r\n    }","commit_id":"4b7270672caf3edcacefa277b4df7c2f065cbf65","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Card card = game.getCard(source.getSourceId());\r\n        if (controller != null && card !=null) {\r\n            Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n            if (sourcePermanent != null) {\r\n                if (sourcePermanent.turnFaceUp(game, source.getControllerId())) {\r\n                    if (megamorph) {\r\n                        sourcePermanent.addCounters(CounterType.P1P1.createInstance(), game);\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":26585,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Card card = game.getCard(source.getSourceId());\r\n        if (controller != null && card != null) {\r\n            Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n            if (sourcePermanent != null) {\r\n                if (sourcePermanent.turnFaceUp(game, source.getControllerId())) {\r\n                    if (megamorph) {\r\n                        sourcePermanent.addCounters(CounterType.P1P1.createInstance(), game);\r\n                    }\r\n                    game.getState().setValue(source.getSourceId().toString() + \"TurnFaceUpX\", source.getManaCostsToPay().getX());\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"4b7270672caf3edcacefa277b4df7c2f065cbf65","url":"https://github.com/magefree/mage"},{"original_method":"public TurnFaceUpAbility(Costs<Cost> costs, boolean megamorph) {\r\n        super(Zone.BATTLEFIELD);\r\n        this.addEffect(new TurnFaceUpEffect(megamorph));\r\n        this.addCost(costs);\r\n        this.usesStack = false;\r\n        this.abilityType = AbilityType.SPECIAL_ACTION;\r\n        this.setRuleVisible(false); // will be made visible only to controller in CardView\r\n    }","id":26586,"modified_method":"public TurnFaceUpAbility(Costs<Cost> costs, boolean megamorph) {\r\n        super(Zone.BATTLEFIELD);\r\n        this.addEffect(new TurnFaceUpEffect(megamorph));\r\n        for (Cost cost : costs) {\r\n            if (cost instanceof ManaCost) {\r\n                this.addManaCost((ManaCost) cost);\r\n            } else {\r\n                this.addCost(cost);\r\n            }\r\n        }\r\n\r\n        this.usesStack = false;\r\n        this.abilityType = AbilityType.SPECIAL_ACTION;\r\n        this.setRuleVisible(false); // will be made visible only to controller in CardView\r\n    }","commit_id":"4b7270672caf3edcacefa277b4df7c2f065cbf65","url":"https://github.com/magefree/mage"},{"original_method":"public AngelsHerald(UUID ownerId) {\r\n        super(ownerId, 2, \"Angel's Herald\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{W}\");\r\n        this.expansionSetCode = \"ALA\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Cleric\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // {2}{W}, {tap}, Sacrifice a green creature, a white creature, and a blue creature: Search your library for a card named Empyrial Archangel and put it onto the battlefield. Then shuffle your library.\r\n        TargetCardInLibrary target = new TargetCardInLibrary(1, 1, new FilterCard(filter));\r\n        Ability ability = new SimpleActivatedAbility(Constants.Zone.BATTLEFIELD, new SearchLibraryPutInPlayEffect(target), new ManaCostsImpl(\"{2}{W}\"));\r\n        ability.addCost(new TapSourceCost());\r\n        ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, filterWhite, false)));\r\n        ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, filterGreen, false)));\r\n        ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, filterBlue, false)));\r\n        this.addAbility(ability);\r\n    }","id":26587,"modified_method":"public AngelsHerald(UUID ownerId) {\r\n        super(ownerId, 2, \"Angel's Herald\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{W}\");\r\n        this.expansionSetCode = \"ALA\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Cleric\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // {2}{W}, {tap}, Sacrifice a green creature, a white creature, and a blue creature:\r\n        // Search your library for a card named Empyrial Archangel and put it onto the battlefield. Then shuffle your library.\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,\r\n                new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(1, 1, new FilterCard(filter))),\r\n                new ManaCostsImpl(\"{2}{W}\"));\r\n        ability.addCost(new TapSourceCost());\r\n        ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, filterGreen, false)));\r\n        ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, filterWhite, false)));\r\n        ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, filterBlue, false)));\r\n        this.addAbility(ability);\r\n    }","commit_id":"9c779595b3a5fd2f10e4fd042c4149ddb3a1a32c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE,\r\n                source.getControllerId(), source.getId(), source.getControllerId(), event.getAmount(), false);\r\n        if (!game.replaceEvent(preventEvent)) {\r\n            int damage = event.getAmount();\r\n            if (damage > 0) {\r\n                event.setAmount(damage - 1);\r\n                this.used = true;\r\n            }\r\n            game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE,\r\n                    source.getControllerId(), source.getId(), source.getControllerId(), damage));\r\n        }\r\n        return false;\r\n    }","id":26588,"modified_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE,\r\n                source.getControllerId(), source.getId(), source.getControllerId(), event.getAmount(), false);\r\n        if (!game.replaceEvent(preventEvent)) {\r\n            int damage = event.getAmount();\r\n            if (damage > 0) {\r\n                event.setAmount(damage - 1);\r\n                this.used = true;\r\n                game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE,\r\n                        source.getControllerId(), source.getId(), source.getControllerId(), 1));\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"9c779595b3a5fd2f10e4fd042c4149ddb3a1a32c","url":"https://github.com/magefree/mage"},{"original_method":"BatToken() {\r\n        super(\"Bat\", \"1/1 black Bat creature tokens with flying\");\r\n        cardType.add(CardType.CREATURE);\r\n        color = ObjectColor.BLACK;\r\n        subtype.add(\"Bat\");\r\n        power = new MageInt(1);\r\n        toughness = new MageInt(1);\r\n        this.addAbility(FlyingAbility.getInstance());\r\n    }","id":26589,"modified_method":"BatToken() {\r\n        super(\"Bat\", \"1/1 black Bat creature token with flying\");\r\n        cardType.add(CardType.CREATURE);\r\n        color = ObjectColor.BLACK;\r\n        subtype.add(\"Bat\");\r\n        power = new MageInt(1);\r\n        toughness = new MageInt(1);\r\n        this.addAbility(FlyingAbility.getInstance());\r\n    }","commit_id":"9c779595b3a5fd2f10e4fd042c4149ddb3a1a32c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n        Permanent permanent = game.getPermanent(source.getFirstTarget());\r\n        if (sourcePermanent == null) {\r\n            sourcePermanent = (Permanent) game.getLastKnownInformation(source.getSourceId(), Constants.Zone.BATTLEFIELD);\r\n        }\r\n        if (sourcePermanent != null && permanent != null) {\r\n            permanent.damage(sourcePermanent.getPower().getValue(), source.getId(), game, true, false);\r\n            return true;\r\n        }\r\n        Player player = game.getPlayer(source.getFirstTarget());\r\n        if (sourcePermanent != null && player != null) {\r\n            player.damage(sourcePermanent.getPower().getValue(), source.getSourceId(), game, false, true);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":26590,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n        if (sourcePermanent == null) {\r\n            sourcePermanent = (Permanent) game.getLastKnownInformation(source.getSourceId(), Constants.Zone.BATTLEFIELD);\r\n        }\r\n        if (sourcePermanent == null) {\r\n            return false;\r\n        }\r\n\r\n        int damage = sourcePermanent.getPower().getValue();\r\n\r\n        Permanent permanent = game.getPermanent(source.getFirstTarget());\r\n        if (permanent != null) {\r\n            permanent.damage(damage, sourcePermanent.getId(), game, true, false);\r\n            return true;\r\n        }\r\n        Player player = game.getPlayer(source.getFirstTarget());\r\n        if (player != null) {\r\n            player.damage(damage, sourcePermanent.getId(), game, false, true);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"9c779595b3a5fd2f10e4fd042c4149ddb3a1a32c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n        Permanent permanent = game.getPermanent(source.getFirstTarget());\r\n        if (sourcePermanent == null) {\r\n            sourcePermanent = (Permanent) game.getLastKnownInformation(source.getSourceId(), Constants.Zone.BATTLEFIELD);\r\n        }\r\n        if (sourcePermanent != null && permanent != null) {\r\n            permanent.damage(sourcePermanent.getPower().getValue(), source.getId(), game, true, false);\r\n            return true;\r\n        }\r\n        Player player = game.getPlayer(source.getFirstTarget());\r\n        if (sourcePermanent != null && player != null) {\r\n            player.damage(sourcePermanent.getPower().getValue(), source.getSourceId(), game, false, true);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":26591,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n        if (sourcePermanent == null) {\r\n            sourcePermanent = (Permanent) game.getLastKnownInformation(source.getSourceId(), Constants.Zone.BATTLEFIELD);\r\n        }\r\n        if (sourcePermanent == null) {\r\n            return false;\r\n        }\r\n\r\n        int damage = sourcePermanent.getPower().getValue();\r\n\r\n        Permanent permanent = game.getPermanent(source.getFirstTarget());\r\n        if (permanent != null) {\r\n            permanent.damage(damage, sourcePermanent.getId(), game, true, false);\r\n            return true;\r\n        }\r\n        Player player = game.getPlayer(source.getFirstTarget());\r\n        if (player != null) {\r\n            player.damage(damage, sourcePermanent.getId(), game, false, true);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"9c779595b3a5fd2f10e4fd042c4149ddb3a1a32c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\n        GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, source.getControllerId(), source.getId(), source.getControllerId(), event.getAmount(), false);\n        if (!game.replaceEvent(preventEvent)) {\n            Player player = game.getPlayer(source.getFirstTarget());\n            if (player != null) {\n                if (event.getAmount() >= this.amount) {\n                    int damage = event.getAmount();\n                    event.setAmount(event.getAmount() - amount);\n                    player.damage(amount, source.getSourceId(), game, false, true);\n                    this.used = true;\n                    game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, source.getControllerId(), source.getId(), source.getControllerId(), damage));\n                } else {\n                    int damage = event.getAmount();\n                    event.setAmount(0);\n                    amount -= damage;\n                    player.damage(damage, source.getSourceId(), game, false, true);\n                    game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, source.getControllerId(), source.getId(), source.getControllerId(), damage));\n                }\n            }\n        }\n        return false;\n    }","id":26592,"modified_method":"@Override\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\n        GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, source.getControllerId(), source.getId(), source.getControllerId(), event.getAmount(), false);\n        if (!game.replaceEvent(preventEvent)) {\n            Player player = game.getPlayer(source.getFirstTarget());\n            if (player != null) {\n                int damage = event.getAmount();\n                if (event.getAmount() >= this.amount) {\n                    event.setAmount(damage - this.amount);\n                    damage = this.amount;\n                    this.used = true;\n                } else {\n                    event.setAmount(0);\n                    this.amount -= damage;\n                }\n\n                player.damage(damage, source.getSourceId(), game, false, true);\n                game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE,\n                        source.getControllerId(), source.getId(), source.getControllerId(), damage));\n            }\n        }\n        return false;\n    }","commit_id":"9c779595b3a5fd2f10e4fd042c4149ddb3a1a32c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent sourceDamage = (Permanent) game.getPermanent(source.getFirstTarget());\r\n        Permanent target = (Permanent) game.getPermanent(source.getTargets().get(1).getFirstTarget());\r\n\r\n        if (sourceDamage != null && target != null) {\r\n            target.damage(sourceDamage.getPower().getValue(), sourceDamage.getId(), game, true, false);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":26593,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent sourcePermanent = game.getPermanent(source.getFirstTarget());\r\n        if (sourcePermanent == null) {\r\n            game.getLastKnownInformation(source.getFirstTarget(), Zone.BATTLEFIELD);\r\n        }\r\n\r\n        Permanent targetPermanent = (Permanent) game.getPermanent(source.getTargets().get(1).getFirstTarget());\r\n        if (sourcePermanent != null && targetPermanent != null) {\r\n            targetPermanent.damage(sourcePermanent.getPower().getValue(), sourcePermanent.getId(), game, true, false);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"9c779595b3a5fd2f10e4fd042c4149ddb3a1a32c","url":"https://github.com/magefree/mage"},{"original_method":"public ActivatedAbilityImpl(Zone zone, Effect effect, Cost cost) {\n\t\tsuper(AbilityType.ACTIVATED, zone);\n\t\tif (effect != null) {\n\t\t\tthis.addEffect(effect);\n\t\t}\n\t\tif (cost != null)\n\t\t\tthis.addCost(cost);\n\t}","id":26594,"modified_method":"public ActivatedAbilityImpl(Zone zone, Effect effect, Cost cost) {\n\t\tsuper(AbilityType.ACTIVATED, zone);\n\t\tif (effect != null) {\n\t\t\tthis.addEffect(effect);\n\t\t}\n\t\tif (cost != null) {\n\t\t\tif (cost instanceof PhyrexianManaCost) {\n\t\t\t\tthis.addManaCost((PhyrexianManaCost)cost);\n\t\t\t} else {\n\t\t\t\tthis.addCost(cost);\n\t\t\t}\n\t\t}\n\t}","commit_id":"cd34310fe6bbfa03ce28d6e66b3b303cbf04fafa","url":"https://github.com/magefree/mage"},{"original_method":"public AddManaOfAnyColorEffect(final AddManaOfAnyColorEffect effect) {\n\t\tsuper(effect);\n\t\tthis.amount = effect.amount;\n\t}","id":26595,"modified_method":"public AddManaOfAnyColorEffect(final AddManaOfAnyColorEffect effect) {\n\t\tsuper(effect);\n\t}","commit_id":"d195e6a749e54c3d0a33a12be3c00ce02b2fd547","url":"https://github.com/magefree/mage"},{"original_method":"public AddManaOfAnyColorEffect(int amount) {\n\t\tsuper(Outcome.PutManaInPool);\n\t\tthis.amount = amount;\n\t}","id":26596,"modified_method":"public AddManaOfAnyColorEffect() {\n\t\tsuper(Outcome.PutManaInPool);\n\t}","commit_id":"d195e6a749e54c3d0a33a12be3c00ce02b2fd547","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic String getText(Ability source) {\n\t\tif (amount > 1)\n\t\t\treturn \"add \" + Integer.toString(amount) + \" mana of any color to your mana pool\";\n\t\telse\n\t\t\treturn \"add one mana of any color to your mana pool\";\n\t}","id":26597,"modified_method":"@Override\n\tpublic String getText(Ability source) {\n        return \"add one mana of any color to your mana pool\";\n\t}","commit_id":"d195e6a749e54c3d0a33a12be3c00ce02b2fd547","url":"https://github.com/magefree/mage"},{"original_method":"public AlloyMyr(UUID ownerId) {\r\n        super(ownerId, 129, \"Alloy Myr\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, \"{3}\");\r\n        this.expansionSetCode = \"NPH\";\r\n        this.subtype.add(\"Myr\");\r\n\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        this.addAbility(new BlackManaAbility());\r\n        this.addAbility(new BlueManaAbility());\r\n        this.addAbility(new GreenManaAbility());\r\n        this.addAbility(new RedManaAbility());\r\n        this.addAbility(new WhiteManaAbility());\r\n    }","id":26598,"modified_method":"public AlloyMyr(UUID ownerId) {\r\n        super(ownerId, 129, \"Alloy Myr\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, \"{3}\");\r\n        this.expansionSetCode = \"NPH\";\r\n        this.subtype.add(\"Myr\");\r\n\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddManaOfAnyColorEffect(), new TapSourceCost());\r\n\t\tability.addChoice(new ChoiceColor());\r\n        this.addAbility(ability);\r\n    }","commit_id":"d195e6a749e54c3d0a33a12be3c00ce02b2fd547","url":"https://github.com/magefree/mage"},{"original_method":"public BirdsOfParadise(UUID ownerId) {\n\t\tsuper(ownerId, 252, \"Birds of Paradise\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{G}\");\n\t\tthis.expansionSetCode = \"10E\";\n\t\tthis.subtype.add(\"Bird\");\n\t\tthis.color.setGreen(true);\n\t\tthis.power = new MageInt(0);\n\t\tthis.toughness = new MageInt(1);\n\t\tthis.addAbility(FlyingAbility.getInstance());\n\t\tthis.addAbility(new BlackManaAbility());\n\t\tthis.addAbility(new BlueManaAbility());\n\t\tthis.addAbility(new GreenManaAbility());\n\t\tthis.addAbility(new RedManaAbility());\n\t\tthis.addAbility(new WhiteManaAbility());\n\t}","id":26599,"modified_method":"public BirdsOfParadise(UUID ownerId) {\n\t\tsuper(ownerId, 252, \"Birds of Paradise\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{G}\");\n\t\tthis.expansionSetCode = \"10E\";\n\t\tthis.subtype.add(\"Bird\");\n\n\t\tthis.color.setGreen(true);\n\t\tthis.power = new MageInt(0);\n\t\tthis.toughness = new MageInt(1);\n\n\t\tthis.addAbility(FlyingAbility.getInstance());\n        SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddManaOfAnyColorEffect(), new TapSourceCost());\n\t\tability.addChoice(new ChoiceColor());\n        this.addAbility(ability);\n\t}","commit_id":"d195e6a749e54c3d0a33a12be3c00ce02b2fd547","url":"https://github.com/magefree/mage"},{"original_method":"public LotusCobra(UUID ownerId) {\n\t\tsuper(ownerId, 168, \"Lotus Cobra\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{1}{G}\");\n\t\tthis.expansionSetCode = \"ZEN\";\n\t\tthis.subtype.add(\"Snake\");\n\t\tthis.color.setGreen(true);\n\t\tthis.power = new MageInt(2);\n\t\tthis.toughness = new MageInt(1);\n\n\t\tLandfallAbility ability = new LandfallAbility(new AddManaOfAnyColorEffect(1), false);\n\t\tability.addChoice(new ChoiceColor());\n\t\tthis.addAbility(ability);\n\t}","id":26600,"modified_method":"public LotusCobra(UUID ownerId) {\n\t\tsuper(ownerId, 168, \"Lotus Cobra\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{1}{G}\");\n\t\tthis.expansionSetCode = \"ZEN\";\n\t\tthis.subtype.add(\"Snake\");\n        \n\t\tthis.color.setGreen(true);\n\t\tthis.power = new MageInt(2);\n\t\tthis.toughness = new MageInt(1);\n\n\t\tLandfallAbility ability = new LandfallAbility(new AddManaOfAnyColorEffect(), false);\n\t\tability.addChoice(new ChoiceColor());\n\t\tthis.addAbility(ability);\n\t}","commit_id":"d195e6a749e54c3d0a33a12be3c00ce02b2fd547","url":"https://github.com/magefree/mage"},{"original_method":"public MoxOpal(UUID ownerId) {\n\t\tsuper(ownerId, 179, \"Mox Opal\", Rarity.MYTHIC, new CardType[]{CardType.ARTIFACT}, \"{0}\");\n\t\tthis.supertype.add(\"Legendary\");\n\t\tthis.expansionSetCode = \"SOM\";\n\t\tAbility ability1 = new WhiteManaAbility();\n\t\tability1.addCost(new MetalcraftCost());\n\t\tthis.addAbility(ability1);\n\t\tAbility ability2 = new RedManaAbility();\n\t\tability2.addCost(new MetalcraftCost());\n\t\tthis.addAbility(ability2);\n\t\tAbility ability3 = new BlueManaAbility();\n\t\tability3.addCost(new MetalcraftCost());\n\t\tthis.addAbility(ability3);\n\t\tAbility ability4 = new BlackManaAbility();\n\t\tability4.addCost(new MetalcraftCost());\n\t\tthis.addAbility(ability4);\n\t\tAbility ability5 = new GreenManaAbility();\n\t\tability5.addCost(new MetalcraftCost());\n\t\tthis.addAbility(ability5);\n\t}","id":26601,"modified_method":"public MoxOpal(UUID ownerId) {\n\t\tsuper(ownerId, 179, \"Mox Opal\", Rarity.MYTHIC, new CardType[]{CardType.ARTIFACT}, \"{0}\");\n\t\tthis.supertype.add(\"Legendary\");\n\t\tthis.expansionSetCode = \"SOM\";\n\n\t\tSimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddManaOfAnyColorEffect(), new TapSourceCost());\n\t\tability.addChoice(new ChoiceColor());\n\t\tability.addCost(new MetalcraftCost());\n\t\tthis.addAbility(ability);\n\t}","commit_id":"d195e6a749e54c3d0a33a12be3c00ce02b2fd547","url":"https://github.com/magefree/mage"},{"original_method":"public PropheticPrism(UUID ownerId) {\r\n        super(ownerId, 222, \"Prophetic Prism\", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, \"{2}\");\r\n        this.expansionSetCode = \"ROE\";\r\n\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardControllerEffect(1)));\r\n        Ability ability = new BlackManaAbility();\r\n        ability.addCost(new GenericManaCost(1));\r\n        this.addAbility(ability);\r\n        ability = new RedManaAbility();\r\n        ability.addCost(new GenericManaCost(1));\r\n        this.addAbility(ability);\r\n        ability = new BlueManaAbility();\r\n        ability.addCost(new GenericManaCost(1));\r\n        this.addAbility(ability);\r\n        ability = new GreenManaAbility();\r\n        ability.addCost(new GenericManaCost(1));\r\n        this.addAbility(ability);\r\n        ability = new WhiteManaAbility();\r\n        ability.addCost(new GenericManaCost(1));\r\n        this.addAbility(ability);\r\n\r\n    }","id":26602,"modified_method":"public PropheticPrism(UUID ownerId) {\r\n        super(ownerId, 222, \"Prophetic Prism\", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, \"{2}\");\r\n        this.expansionSetCode = \"ROE\";\r\n\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardControllerEffect(1)));\r\n        SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddManaOfAnyColorEffect(), new GenericManaCost(1));\r\n        ability.addChoice(new ChoiceColor());\r\n        ability.addCost(new TapSourceCost());\r\n        this.addAbility(ability);\r\n    }","commit_id":"d195e6a749e54c3d0a33a12be3c00ce02b2fd547","url":"https://github.com/magefree/mage"},{"original_method":"public RuptureSpire (UUID ownerId) {\r\n        super(ownerId, 144, \"Rupture Spire\", Rarity.COMMON, new CardType[]{CardType.LAND}, null);\r\n        this.expansionSetCode = \"CON\";\r\n        this.addAbility(new EntersBattlefieldTappedAbility());\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ManaCostsImpl(\"{1}\")), false));\r\n        this.addAbility(new BlackManaAbility());\r\n        this.addAbility(new BlueManaAbility());\r\n        this.addAbility(new GreenManaAbility());\r\n        this.addAbility(new RedManaAbility());\r\n        this.addAbility(new WhiteManaAbility());\r\n    }","id":26603,"modified_method":"public RuptureSpire (UUID ownerId) {\r\n        super(ownerId, 144, \"Rupture Spire\", Rarity.COMMON, new CardType[]{CardType.LAND}, null);\r\n        this.expansionSetCode = \"CON\";\r\n\r\n        this.addAbility(new EntersBattlefieldTappedAbility());\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ManaCostsImpl(\"{1}\")), false));\r\n        SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddManaOfAnyColorEffect(), new TapSourceCost());\r\n\t\tability.addChoice(new ChoiceColor());\r\n        this.addAbility(ability);\r\n    }","commit_id":"d195e6a749e54c3d0a33a12be3c00ce02b2fd547","url":"https://github.com/magefree/mage"},{"original_method":"public SphereOfTheSuns(UUID ownerId) {\r\n        super(ownerId, 134, \"Sphere of the Suns\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, \"{2}\");\r\n        this.expansionSetCode = \"MBS\";\r\n        \r\n        Ability ability = new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.CHARGE.createInstance(3)),\r\n                \"Sphere of the Suns enters the battlefield tapped and with three charge counters on it.\");\r\n        ability.addEffect(new TapSourceEffect());\r\n        this.addAbility(ability);\r\n\r\n        RemoveCountersSourceCost removeCounterCost = new RemoveCountersSourceCost(CounterType.CHARGE.getName(), 1);\r\n        ability = new BlackManaAbility();\r\n        ability.addCost(removeCounterCost);\r\n        this.addAbility(ability);\r\n        ability = new BlueManaAbility();\r\n        ability.addCost(removeCounterCost);\r\n        this.addAbility(ability);\r\n        ability = new RedManaAbility();\r\n        ability.addCost(removeCounterCost);\r\n        this.addAbility(ability);\r\n        ability = new GreenManaAbility();\r\n        ability.addCost(removeCounterCost);\r\n        this.addAbility(ability);\r\n        ability = new WhiteManaAbility();\r\n        ability.addCost(removeCounterCost);\r\n        this.addAbility(ability);\r\n    }","id":26604,"modified_method":"public SphereOfTheSuns(UUID ownerId) {\r\n        super(ownerId, 134, \"Sphere of the Suns\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, \"{2}\");\r\n        this.expansionSetCode = \"MBS\";\r\n\r\n        Ability ability = new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.CHARGE.createInstance(3)),\r\n                \"Sphere of the Suns enters the battlefield tapped and with three charge counters on it.\");\r\n        ability.addEffect(new TapSourceEffect());\r\n        this.addAbility(ability);\r\n\r\n        RemoveCountersSourceCost removeCounterCost = new RemoveCountersSourceCost(CounterType.CHARGE.getName(), 1);\r\n        ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddManaOfAnyColorEffect(), new TapSourceCost());\r\n        ability.addChoice(new ChoiceColor());\r\n        ability.addCost(removeCounterCost);\r\n        this.addAbility(ability);\r\n    }","commit_id":"d195e6a749e54c3d0a33a12be3c00ce02b2fd547","url":"https://github.com/magefree/mage"},{"original_method":"public void renderLastElement(Writer writer, Map context, ModelTree.ModelNode node) throws IOException {\n        if (!node.isRootNode()) {\n            Boolean processChildren = (Boolean) context.get(\"processChildren\");\n            if (processChildren.booleanValue()) {\n                appendWhitespace(writer);\n                writer.write(\"<ul class=\\\"basic-tree\\\">\");\n            }\n        }\n    }","id":26605,"modified_method":"public void renderLastElement(Writer writer, Map context, ModelTree.ModelNode node) throws IOException {\n        Boolean processChildren = (Boolean) context.get(\"processChildren\");\n        if (processChildren.booleanValue()) {\n            appendWhitespace(writer);\n            writer.write(\"<ul class=\\\"basic-tree\\\">\");\n        }\n    }","commit_id":"09791a94c542cad10179ed70a590e7d99b656223","url":"https://github.com/apache/ofbiz"},{"original_method":"public void renderNodeBegin(Writer writer, Map context, ModelTree.ModelNode node, int depth, boolean isLast) throws IOException {\n\n        String pathString = buildPathString(node.getModelTree(), depth);\n        String currentNodeTrailPiped = null;\n        List currentNodeTrail = node.getModelTree().getCurrentNodeTrail();\n        String staticNodeTrailPiped = StringUtil.join(currentNodeTrail, \"|\");\n        context.put(\"staticNodeTrailPiped\", staticNodeTrailPiped);\n        context.put(\"nodePathString\", pathString);\n        context.put(\"depth\", Integer.toString(depth));\n        if (node.isRootNode()) {\n            appendWhitespace(writer);\n            writer.write(\"<!-- begin tree widget -->\");\n            appendWhitespace(writer);\n            writer.write(\"<ul class=\\\"basic-tree\\\">\");\n        } else {\n            appendWhitespace(writer);\n            writer.write(\" <li>\");\n        }\n\n        String pkName = node.getPkName();\n        String entityId = null;\n        String entryName = node.getEntryName();\n        if (UtilValidate.isNotEmpty(entryName)) {\n            Map map = (Map)context.get(entryName);\n            entityId = (String)map.get(pkName);\n        } else {\n            entityId = (String) context.get(pkName);\n        }\n        boolean hasChildren = node.hasChildren(context);\n            //Debug.logInfo(\"HtmlTreeExpandCollapseRenderer, hasChildren(1):\" + hasChildren, module);\n\n        // check to see if this node needs to be expanded.\n        if (hasChildren && node.isExpandCollapse()) {\n            String targetEntityId = null;\n            List targetNodeTrail = node.getModelTree().getTrailList();\n            if (depth < targetNodeTrail.size()) {\n                targetEntityId = (String)targetNodeTrail.get(depth);\n            }\n            //Debug.logInfo(\"HtmlTreeExpandCollapseRenderer, targetEntityId(1):\" + targetEntityId, module);\n            //Debug.logInfo(\"HtmlTreeExpandCollapseRenderer, depth(1):\" + depth, module);\n    \n            ModelTree.ModelNode.Image expandCollapseImage = new ModelTree.ModelNode.Image();\n            expandCollapseImage.setBorder(\"0\");\n            ModelTree.ModelNode.Link expandCollapseLink = new ModelTree.ModelNode.Link();\n            //String currentNodeTrailCsv = (String)context.get(\"currentNodeTrailCsv\");\n    \n            int openDepth = node.getModelTree().getOpenDepth();\n            if (depth >= openDepth && (targetEntityId == null || !targetEntityId.equals(entityId))) {\n                // Not on the trail\n                if( node.showPeers(depth)) {\n                    context.put(\"processChildren\", Boolean.FALSE);\n                    //expandCollapseLink.setText(\"&nbsp;+&nbsp;\");\n                    currentNodeTrailPiped = StringUtil.join(currentNodeTrail, \"|\");\n                    context.put(\"currentNodeTrailPiped\", currentNodeTrailPiped);\n                    //context.put(\"currentNodeTrailCsv\", currentNodeTrailCsv);\n                    expandCollapseLink.setStyle(\"collapsed\");\n                    expandCollapseLink.setText(\"&nbsp;\");\n                    String target = node.getModelTree().getExpandCollapseRequest(context);\n                    String trailName = node.getModelTree().getTrailName(context);\n                    if (target.indexOf(\"?\") < 0) {\n                        target += \"?\";\n                    } else {\n                        target += \"&\";\n                    }\n                    target += trailName + \"=\" + currentNodeTrailPiped;\n                    target += \"#\" + staticNodeTrailPiped;\n                    //expandCollapseLink.setTarget(\"/ViewOutline?docRootContentId=${docRootContentId}&targetNodeTrailCsv=${currentNodeTrailCsv}\");\n                    expandCollapseLink.setTarget(target);\n                }\n            } else {\n                context.put(\"processChildren\", Boolean.TRUE);\n                //expandCollapseLink.setText(\"&nbsp;-&nbsp;\");\n                String lastContentId = (String)currentNodeTrail.remove(currentNodeTrail.size() - 1);\n                currentNodeTrailPiped = StringUtil.join(currentNodeTrail, \"|\");\n                if (currentNodeTrailPiped == null) {\n                    currentNodeTrailPiped = \"\";\n                }\n                context.put(\"currentNodeTrailPiped\", currentNodeTrailPiped);\n                //context.put(\"currentNodeTrailCsv\", currentNodeTrailCsv);\n                expandCollapseLink.setStyle(\"expanded\");\n                expandCollapseLink.setText(\"&nbsp;\");\n                String target = node.getModelTree().getExpandCollapseRequest(context);\n                String trailName = node.getModelTree().getTrailName(context);\n                if (target.indexOf(\"?\") < 0)  target += \"?\";\n                else target += \"&\";\n                target += trailName + \"=\" + currentNodeTrailPiped;\n                target += \"#\" + staticNodeTrailPiped;\n                expandCollapseLink.setTarget(target);\n                // add it so it can be remove in renderNodeEnd\n                currentNodeTrail.add(lastContentId);\n                currentNodeTrailPiped = StringUtil.join(currentNodeTrail, \"|\");\n                if (currentNodeTrailPiped == null) {\n                    currentNodeTrailPiped = \"\";\n                }\n                context.put(\"currentNodeTrailPiped\", currentNodeTrailPiped);\n            }\n            renderLink( writer, context, expandCollapseLink);\n        } else if (!hasChildren){\n                //writer.write(\" \");\n                context.put(\"processChildren\", Boolean.FALSE);\n                //currentNodeTrail.add(contentId);\n        }\n    }","id":26606,"modified_method":"public void renderNodeBegin(Writer writer, Map context, ModelTree.ModelNode node, int depth, boolean isLast) throws IOException {\n\n        String pathString = buildPathString(node.getModelTree(), depth);\n        String currentNodeTrailPiped = null;\n        List currentNodeTrail = node.getModelTree().getCurrentNodeTrail();\n        String staticNodeTrailPiped = StringUtil.join(currentNodeTrail, \"|\");\n        context.put(\"staticNodeTrailPiped\", staticNodeTrailPiped);\n        context.put(\"nodePathString\", pathString);\n        context.put(\"depth\", Integer.toString(depth));\n        if (node.isRootNode()) {\n            appendWhitespace(writer);\n            writer.write(\"<ul class=\\\"basic-tree\\\">\");\n        }\n        appendWhitespace(writer);\n        writer.write(\"<li>\");\n\n        String pkName = node.getPkName();\n        String entityId = null;\n        String entryName = node.getEntryName();\n        if (UtilValidate.isNotEmpty(entryName)) {\n            Map map = (Map)context.get(entryName);\n            entityId = (String)map.get(pkName);\n        } else {\n            entityId = (String) context.get(pkName);\n        }\n        boolean hasChildren = node.hasChildren(context);\n            //Debug.logInfo(\"HtmlTreeExpandCollapseRenderer, hasChildren(1):\" + hasChildren, module);\n\n        // check to see if this node needs to be expanded.\n        if (hasChildren && node.isExpandCollapse()) {\n            String targetEntityId = null;\n            List targetNodeTrail = node.getModelTree().getTrailList();\n            if (depth < targetNodeTrail.size()) {\n                targetEntityId = (String)targetNodeTrail.get(depth);\n            }\n            //Debug.logInfo(\"HtmlTreeExpandCollapseRenderer, targetEntityId(1):\" + targetEntityId, module);\n            //Debug.logInfo(\"HtmlTreeExpandCollapseRenderer, depth(1):\" + depth, module);\n    \n            ModelTree.ModelNode.Image expandCollapseImage = new ModelTree.ModelNode.Image();\n            expandCollapseImage.setBorder(\"0\");\n            ModelTree.ModelNode.Link expandCollapseLink = new ModelTree.ModelNode.Link();\n            //String currentNodeTrailCsv = (String)context.get(\"currentNodeTrailCsv\");\n    \n            int openDepth = node.getModelTree().getOpenDepth();\n            if (depth >= openDepth && (targetEntityId == null || !targetEntityId.equals(entityId))) {\n                // Not on the trail\n                if( node.showPeers(depth)) {\n                    context.put(\"processChildren\", Boolean.FALSE);\n                    //expandCollapseLink.setText(\"&nbsp;+&nbsp;\");\n                    currentNodeTrailPiped = StringUtil.join(currentNodeTrail, \"|\");\n                    context.put(\"currentNodeTrailPiped\", currentNodeTrailPiped);\n                    //context.put(\"currentNodeTrailCsv\", currentNodeTrailCsv);\n                    expandCollapseLink.setStyle(\"collapsed\");\n                    expandCollapseLink.setText(\"&nbsp;\");\n                    String target = node.getModelTree().getExpandCollapseRequest(context);\n                    String trailName = node.getModelTree().getTrailName(context);\n                    if (target.indexOf(\"?\") < 0) {\n                        target += \"?\";\n                    } else {\n                        target += \"&\";\n                    }\n                    target += trailName + \"=\" + currentNodeTrailPiped;\n                    target += \"#\" + staticNodeTrailPiped;\n                    //expandCollapseLink.setTarget(\"/ViewOutline?docRootContentId=${docRootContentId}&targetNodeTrailCsv=${currentNodeTrailCsv}\");\n                    expandCollapseLink.setTarget(target);\n                }\n            } else {\n                context.put(\"processChildren\", Boolean.TRUE);\n                //expandCollapseLink.setText(\"&nbsp;-&nbsp;\");\n                String lastContentId = (String)currentNodeTrail.remove(currentNodeTrail.size() - 1);\n                currentNodeTrailPiped = StringUtil.join(currentNodeTrail, \"|\");\n                if (currentNodeTrailPiped == null) {\n                    currentNodeTrailPiped = \"\";\n                }\n                context.put(\"currentNodeTrailPiped\", currentNodeTrailPiped);\n                //context.put(\"currentNodeTrailCsv\", currentNodeTrailCsv);\n                expandCollapseLink.setStyle(\"expanded\");\n                expandCollapseLink.setText(\"&nbsp;\");\n                String target = node.getModelTree().getExpandCollapseRequest(context);\n                String trailName = node.getModelTree().getTrailName(context);\n                if (target.indexOf(\"?\") < 0)  target += \"?\";\n                else target += \"&\";\n                target += trailName + \"=\" + currentNodeTrailPiped;\n                target += \"#\" + staticNodeTrailPiped;\n                expandCollapseLink.setTarget(target);\n                // add it so it can be remove in renderNodeEnd\n                currentNodeTrail.add(lastContentId);\n                currentNodeTrailPiped = StringUtil.join(currentNodeTrail, \"|\");\n                if (currentNodeTrailPiped == null) {\n                    currentNodeTrailPiped = \"\";\n                }\n                context.put(\"currentNodeTrailPiped\", currentNodeTrailPiped);\n            }\n            renderLink( writer, context, expandCollapseLink);\n        } else if (!hasChildren){\n                //writer.write(\" \");\n                context.put(\"processChildren\", Boolean.FALSE);\n                //currentNodeTrail.add(contentId);\n        }\n    }","commit_id":"09791a94c542cad10179ed70a590e7d99b656223","url":"https://github.com/apache/ofbiz"},{"original_method":"public void renderNodeEnd(Writer writer, Map context, ModelTree.ModelNode node) throws IOException {\n        if (node.isRootNode()) {\n            appendWhitespace(writer);\n            writer.write(\"<\/ul>\");\n            appendWhitespace(writer);\n            writer.write(\"<!-- end tree widget -->\");\n            appendWhitespace(writer);\n        }\n        else {\n            Boolean processChildren = (Boolean) context.get(\"processChildren\");\n            if (processChildren.booleanValue()) {\n                appendWhitespace(writer);\n                writer.write(\"<\/ul>\");\n            }\n            writer.write(\"<\/li>\");\n        }\n    }","id":26607,"modified_method":"public void renderNodeEnd(Writer writer, Map context, ModelTree.ModelNode node) throws IOException {\n        Boolean processChildren = (Boolean) context.get(\"processChildren\");\n        if (processChildren.booleanValue()) {\n            appendWhitespace(writer);\n            writer.write(\"<\/ul>\");\n        }\n        appendWhitespace(writer);\n        writer.write(\"<\/li>\");\n        if (node.isRootNode()){\n            appendWhitespace(writer);\n            writer.write(\"<\/ul>\");\n            appendWhitespace(writer);\n        }\n    }","commit_id":"09791a94c542cad10179ed70a590e7d99b656223","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Executes multiple commands inside a Single Session.\n     * Commands have a default timeout of 10 seconds.\n     * @param commands\n     * @return\n     */\n    protected String executeCommands(final String ...commands) {\n        String response;\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        final PrintStream printStream = new PrintStream(byteArrayOutputStream);\n        final CommandProcessor commandProcessor = getOsgiService(CommandProcessor.class);\n        final CommandSession commandSession = commandProcessor.createSession(System.in, printStream, printStream);\n        commandSession.put(\"APPLICATION\", System.getProperty(\"karaf.name\", \"root\"));\n        commandSession.put(\"USER\", \"karaf\");\n        FutureTask<String> commandFuture = new FutureTask<String>(\n                new Callable<String>() {\n                    public String call() {\n                        try {\n                            for(String command:commands) {\n                             System.err.println(command);\n                             commandSession.execute(command);\n                            }\n                        } catch (Exception e) {\n                            e.printStackTrace(System.err);\n                        }\n                        return byteArrayOutputStream.toString();\n                    }\n                });\n\n        try {\n            executor.submit(commandFuture);\n            response =  commandFuture.get(COMMAND_TIMEOUT, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            response = \"SHELL COMMAND TIMED OUT: \";\n        }\n\n        return response;\n    }","id":26608,"modified_method":"/**\n     * Executes multiple commands inside a Single Session.\n     * Commands have a default timeout of 10 seconds.\n     * @param commands\n     * @return\n     */\n    protected String executeCommands(final String ...commands) {\n        String response;\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        final PrintStream printStream = new PrintStream(byteArrayOutputStream);\n        final CommandProcessor commandProcessor = getOsgiService(CommandProcessor.class);\n        final CommandSession commandSession = commandProcessor.createSession(System.in, printStream, printStream);\n        commandSession.put(\"APPLICATION\", System.getProperty(\"karaf.name\", \"root\"));\n        commandSession.put(\"USER\", \"karaf\");\n        FutureTask<String> commandFuture = new FutureTask<String>(\n                new Callable<String>() {\n                    public String call() {\n                        try {\n                            for(String command:commands) {\n                             System.out.println(command);\n                             commandSession.execute(command);\n                            }\n                        } catch (Exception e) {\n                            e.printStackTrace(System.err);\n                        }\n                        return byteArrayOutputStream.toString();\n                    }\n                });\n\n        try {\n            executor.submit(commandFuture);\n            response =  commandFuture.get(COMMAND_TIMEOUT, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            response = \"SHELL COMMAND TIMED OUT: \";\n        }\n\n        return response;\n    }","commit_id":"5689e882b78d901df396dd62060ee76933cea3a4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Executes a shell command and returns output as a String.\n     * Commands have a default timeout of 10 seconds.\n     * @param command The command to execute.\n     * @param timeout The amount of time in millis to wait for the command to execute.\n     * @param silent  Specifies if the command should be displayed in the screen.\n     * @return\n     */\n    protected String executeCommand(final String command, final Long timeout, final Boolean silent) {\n        String response;\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        final PrintStream printStream = new PrintStream(byteArrayOutputStream);\n        final CommandProcessor commandProcessor = getOsgiService(CommandProcessor.class);\n        final CommandSession commandSession = commandProcessor.createSession(System.in, printStream, printStream);\n        commandSession.put(\"APPLICATION\", System.getProperty(\"karaf.name\", \"root\"));\n        commandSession.put(\"USER\", \"karaf\");\n        FutureTask<String> commandFuture = new FutureTask<String>(\n                new Callable<String>() {\n                    public String call() {\n                        try {\n                            if (!silent) {\n                                System.err.println(command);\n                            }\n                            commandSession.execute(command);\n                        } catch (Exception e) {\n                            e.printStackTrace(System.err);\n                        }\n                        printStream.flush();\n                        return byteArrayOutputStream.toString();\n                    }\n                });\n\n        try {\n            executor.submit(commandFuture);\n            response =  commandFuture.get(timeout, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            response = \"SHELL COMMAND TIMED OUT: \";\n        }\n\n        return response;\n    }","id":26609,"modified_method":"/**\n     * Executes a shell command and returns output as a String.\n     * Commands have a default timeout of 10 seconds.\n     * @param command The command to execute.\n     * @param timeout The amount of time in millis to wait for the command to execute.\n     * @param silent  Specifies if the command should be displayed in the screen.\n     * @return\n     */\n    protected String executeCommand(final String command, final Long timeout, final Boolean silent) {\n        String response;\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        final PrintStream printStream = new PrintStream(byteArrayOutputStream);\n        final CommandProcessor commandProcessor = getOsgiService(CommandProcessor.class);\n        final CommandSession commandSession = commandProcessor.createSession(System.in, printStream, printStream);\n        commandSession.put(\"APPLICATION\", System.getProperty(\"karaf.name\", \"root\"));\n        commandSession.put(\"USER\", \"karaf\");\n        FutureTask<String> commandFuture = new FutureTask<String>(\n                new Callable<String>() {\n                    public String call() {\n                        try {\n                            if (!silent) {\n                                System.out.println(command);\n                                System.out.flush();\n                            }\n                            commandSession.execute(command);\n                        } catch (Exception e) {\n                            e.printStackTrace(System.err);\n                        }\n                        printStream.flush();\n                        return byteArrayOutputStream.toString();\n                    }\n                });\n\n        try {\n            executor.submit(commandFuture);\n            response =  commandFuture.get(timeout, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            response = \"SHELL COMMAND TIMED OUT: \";\n        }\n\n        return response;\n    }","commit_id":"5689e882b78d901df396dd62060ee76933cea3a4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Configuration\n    public Option[] config() {\n        return new Option[]{\n                fabricDistributionConfiguration(), keepRuntimeFolder(),\n                editConfigurationFileExtend(\"etc/system.properties\", \"fabric.version\", MavenUtils.asInProject().getVersion(GROUP_ID,ARTIFACT_ID)),\n                logLevel(LogLevelOption.LogLevel.ERROR)};\n    }","id":26610,"modified_method":"@Configuration\n    public Option[] config() {\n        return new Option[]{\n                fabricDistributionConfiguration(), keepRuntimeFolder(),\n                //debugConfiguration(\"5005\",true),\n                editConfigurationFilePut(\"etc/system.properties\", \"fabric.version\", MavenUtils.asInProject().getVersion(GROUP_ID,ARTIFACT_ID)),\n                logLevel(LogLevelOption.LogLevel.ERROR)};\n    }","commit_id":"5689e882b78d901df396dd62060ee76933cea3a4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Configuration\n    public Option[] config() {\n        return new Option[]{\n                fabricDistributionConfiguration(), keepRuntimeFolder(),\n                editConfigurationFileExtend(\"etc/system.properties\", \"fabric.version\", MavenUtils.asInProject().getVersion(\"org.fusesource.fabric\",\"fuse-fabric\")),\n                logLevel(LogLevelOption.LogLevel.ERROR)};\n    }","id":26611,"modified_method":"@Configuration\n    public Option[] config() {\n        return new Option[]{\n                fabricDistributionConfiguration(), keepRuntimeFolder(),\n                editConfigurationFilePut(\"etc/system.properties\", \"fabric.version\", MavenUtils.asInProject().getVersion(\"org.fusesource.fabric\",\"fuse-fabric\")),\n                logLevel(LogLevelOption.LogLevel.ERROR)};\n    }","commit_id":"5689e882b78d901df396dd62060ee76933cea3a4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Create an {@link Option} for using a Fabric distribution.\n     *\n     * @return\n     */\n    protected Option fabricDistributionConfiguration() {\n        return new DefaultCompositeOption(\n                new Option[]{karafDistributionConfiguration().frameworkUrl(\n                        maven().groupId(GROUP_ID).artifactId(ARTIFACT_ID).versionAsInProject().type(\"tar.gz\"))\n                        .karafVersion(getKarafVersion()).name(\"Fabric Karaf Distro\").unpackDirectory(new File(\"target/paxexam/unpack/\")),\n                      useOwnExamBundlesStartLevel(0)\n                });\n    }","id":26612,"modified_method":"/**\n     * Create an {@link Option} for using a Fabric distribution.\n     *\n     * @return\n     */\n    protected Option fabricDistributionConfiguration() {\n        return new DefaultCompositeOption(\n                new Option[]{karafDistributionConfiguration().frameworkUrl(\n                        maven().groupId(GROUP_ID).artifactId(ARTIFACT_ID).versionAsInProject().type(\"tar.gz\"))\n                        .karafVersion(getKarafVersion()).name(\"Fabric Karaf Distro\").unpackDirectory(new File(\"target/paxexam/unpack/\")),\n                        useOwnExamBundlesStartLevel(40),\n                      editConfigurationFilePut(\"etc/config.properties\", \"karaf.startlevel.bundle\", \"35\")\n                });\n    }","commit_id":"5689e882b78d901df396dd62060ee76933cea3a4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Make available system properties that are configured for the test, to the test container.\n     * <p>Note:<\/p> If not obvious the container runs in in forked mode and thus system properties passed\n     * form command line or surefire plugin are not available to the container without an approach like this.\n     * @param propertyName\n     * @return\n     */\n    public static Option copySystemProperty(String propertyName) {\n        return editConfigurationFileExtend(\"etc/system.properties\", propertyName, System.getProperty(propertyName) != null ? System.getProperty(propertyName) : \"\");\n    }","id":26613,"modified_method":"/**\n     * Make available system properties that are configured for the test, to the test container.\n     * <p>Note:<\/p> If not obvious the container runs in in forked mode and thus system properties passed\n     * form command line or surefire plugin are not available to the container without an approach like this.\n     * @param propertyName\n     * @return\n     */\n    public static Option copySystemProperty(String propertyName) {\n        return editConfigurationFilePut(\"etc/system.properties\", propertyName, System.getProperty(propertyName) != null ? System.getProperty(propertyName) : \"\");\n    }","commit_id":"5689e882b78d901df396dd62060ee76933cea3a4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected Option mqDistributionConfiguration() {\n        return karafDistributionConfiguration().frameworkUrl(\n                maven().groupId(MQ_GROUP_ID).artifactId(MQ_ARTIFACT_ID).versionAsInProject().type(\"tar.gz\"))\n                .karafVersion(\"2.2.2\").name(\"Fabric MQ Distro\").unpackDirectory(new File(\"target/paxexam/unpack/\"));\n    }","id":26614,"modified_method":"protected Option mqDistributionConfiguration() {\n        return new DefaultCompositeOption(\n                new Option[]{karafDistributionConfiguration().frameworkUrl(\n                maven().groupId(MQ_GROUP_ID).artifactId(MQ_ARTIFACT_ID).versionAsInProject().type(\"tar.gz\"))\n                .karafVersion(\"2.2.2\").name(\"Fabric MQ Distro\").unpackDirectory(new File(\"target/paxexam/unpack/\")),\n                      useOwnExamBundlesStartLevel(60),\n                      editConfigurationFilePut(\"etc/config.properties\", \"karaf.startlevel.bundle\", \"35\")});\n    }","commit_id":"5689e882b78d901df396dd62060ee76933cea3a4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Configuration\n    @Override\n    public Option[] config() {\n\n        return combine(\n               ///super.config(),\n               /*\n               new Option[] {\n                   karafDistributionConfiguration().frameworkUrl(\n                           maven().groupId(\"org.apache.karaf\").artifactId(\"apache-karaf\").versionAsInProject().type(\"tar.gz\")\n                       ).karafVersion(\n                           MavenUtils.getArtifactVersion(\"org.apache.karaf\", \"apache-karaf\")\n                       ).name(\"Apache Karaf\").unpackDirectory(new File(\"target/exam\")),\n                   keepRuntimeFolder()//,\n                   //logLevel(LogLevelOption.LogLevel.ERROR)\n               },\n               */\n               new Option[] {\n                   karafDistributionConfiguration().frameworkUrl(\n                           // Use mvn:org.opennms.container:karaf:tar.gz as the Karaf distribution so that it has the same\n                           // settings as a running OpenNMS system\n                           maven().groupId(\"org.opennms.container\").artifactId(\"karaf\").versionAsInProject().type(\"tar.gz\")\n                       ).karafVersion(\n                           MavenUtils.getArtifactVersion(\"org.apache.karaf\", \"apache-karaf\")\n                       ).name(\"Apache Karaf\").unpackDirectory(new File(\"target/exam\"))\n                   //keepRuntimeFolder()\n               },\n               options(\n                   logLevel(LogLevelOption.LogLevel.DEBUG),\n\n                   // Change the RMI/JMX ports that Karaf management runs on so that it doesn't conflict\n                   // with a running OpenNMS instance.\n                   //\n                   // Note: The next time we upgrade Karaf, this should be unnecessary because the configs in\n                   // KarafTestSupport have been changed in an identical manner.\n                   editConfigurationFilePut(\"etc/org.apache.karaf.management.cfg\", \"rmiRegistryPort\", \"1101\"),\n                   editConfigurationFilePut(\"etc/org.apache.karaf.management.cfg\", \"rmiServerPort\", \"44445\"),\n\n                   // Change the SSH port so that it doesn't conflict with a running OpenNMS instance\n                   editConfigurationFilePut(\"etc/org.apache.karaf.shell.cfg\", \"sshPort\", \"8201\"),\n\n                   systemPackage(\"org.apache.commons.logging\"),\n\n                   //mavenBundle(\"org.apache.felix\", \"org.apache.felix.configadmin\").versionAsInProject(),\n                   //mavenBundle(\"org.ops4j.pax.logging\", \"pax-logging-api\").versionAsInProject(), \n                   //mavenBundle(\"org.ops4j.pax.logging\", \"pax-logging-service\").versionAsInProject(), \n                   ///mavenBundle(\"org.apache.aries\", \"org.apache.aries.util\").versionAsInProject(),\n                   ///mavenBundle(\"org.apache.aries.blueprint\", \"org.apache.aries.blueprint\").versionAsInProject(),\n                   //mavenBundle(\"org.apache.aries.blueprint\", \"org.apache.aries.blueprint.sample\").versionAsInProject(),\n                   //mavenBundle(\"org.apache.aries.jmx\", \"org.apache.aries.jmx.blueprint\").versionAsInProject(),\n                   ///mavenBundle(\"org.apache.aries.proxy\", \"org.apache.aries.proxy\").versionAsInProject(),\n                   //mavenBundle(\"org.osgi\", \"org.osgi.compendium\").versionAsInProject(),\n                   \n                   //systemPackage(\"org.ops4j.pax.exam.options\"),\n                   /****\n                   mavenBundle(\"org.ops4j.base\", \"ops4j-base-util-property\").versionAsInProject(),\n                   mavenBundle(\"org.ops4j.base\", \"ops4j-base-monitors\").versionAsInProject(),\n                   mavenBundle(\"org.ops4j.base\", \"ops4j-base-io\").versionAsInProject(),\n                   mavenBundle(\"org.ops4j.base\", \"ops4j-base-lang\").versionAsInProject(),\n                   mavenBundle(\"org.ops4j.base\", \"ops4j-base-store\").versionAsInProject(),\n                   mavenBundle(\"org.ops4j.pax.exam\", \"pax-exam\").versionAsInProject(),\n                   mavenBundle(\"org.apache.felix\", \"org.apache.felix.gogo.runtime\").versionAsInProject(),\n                   mavenBundle(\"org.apache.karaf.shell\", \"org.apache.karaf.shell.console\").versionAsInProject(),\n                   wrappedBundle(mavenBundle(\"org.apache.karaf.itests\", \"itests\").versionAsInProject().classifier(\"tests\")),\n                   ****/\n                   //mavenBundle(\"org.opennms.features.topology\", \"api\").versionAsInProject(),\n                   //mavenBundle(\"org.opennms.features.topology.plugins.topo\", \"linkd\").versionAsInProject(),\n                   //mavenBundle(\"com.vaadin\", \"vaadin\").versionAsInProject(),\n                   junitBundles()\n            )\n        );\n    }","id":26615,"modified_method":"@Configuration\n    @Override\n    public Option[] config() {\n        return new Option[] {\n            karafDistributionConfiguration().frameworkUrl(\n                    // Use mvn:org.opennms.container:karaf:tar.gz as the Karaf distribution so that it has the same\n                    // settings as a running OpenNMS system\n                    maven().groupId(\"org.opennms.container\").artifactId(\"karaf\").versionAsInProject().type(\"tar.gz\")\n                ).karafVersion(\n                    //MavenUtils.getArtifactVersion(\"org.apache.karaf\", \"apache-karaf\")\n                    \"2.3.1\"\n                ).name(\"OpenNMS Apache Karaf\").unpackDirectory(new File(\"target/exam\")\n            ),\n\n            keepRuntimeFolder(),\n\n            // Crank the logging\n            logLevel(LogLevelOption.LogLevel.DEBUG),\n\n            // Change the RMI/JMX ports that Karaf management runs on so that it doesn't conflict\n            // with a running OpenNMS instance.\n            //\n            // Note: The next time we upgrade Karaf, this should be unnecessary because the configs in\n            // KarafTestSupport have been changed in an identical manner.\n            editConfigurationFilePut(\"etc/org.apache.karaf.management.cfg\", \"rmiRegistryPort\", \"1101\"),\n            editConfigurationFilePut(\"etc/org.apache.karaf.management.cfg\", \"rmiServerPort\", \"44445\"),\n\n            editConfigurationFilePut(\"etc/org.apache.karaf.features.cfg\", \"featuresBoot\", \"config,ssh,http,http-whiteboard,exam\"),\n\n            // Change the SSH port so that it doesn't conflict with a running OpenNMS instance\n            editConfigurationFilePut(\"etc/org.apache.karaf.shell.cfg\", \"sshPort\", \"8201\"),\n\n            /**\n             * I think that we need to install org.apache.karaf.itests:itests:tests and all of its dependencies\n             * into the container so that the unit test will execute properly. This doesn't seem to work with\n             * Karaf 2.3.1... I get inconsistent behavior, almost like there is a race condition when registering\n             * services or something. *sigh*\n             */\n            //wrappedBundle(mavenBundle(\"org.apache.karaf.itests\", \"itests\").versionAsInProject().classifier(\"tests\")),\n            /*\n            mavenBundle(\"org.ops4j.base\", \"ops4j-base-util-property\").versionAsInProject(),\n            mavenBundle(\"org.ops4j.base\", \"ops4j-base-monitors\").versionAsInProject(),\n            mavenBundle(\"org.ops4j.base\", \"ops4j-base-io\").versionAsInProject(),\n            mavenBundle(\"org.ops4j.base\", \"ops4j-base-lang\").versionAsInProject(),\n            mavenBundle(\"org.ops4j.base\", \"ops4j-base-store\").versionAsInProject(),\n            mavenBundle(\"org.apache.felix\", \"org.apache.felix.gogo.runtime\").versionAsInProject(),\n            */\n            mavenBundle(\"org.apache.karaf.shell\", \"org.apache.karaf.shell.console\").versionAsInProject().noStart(),\n            mavenBundle(\"org.ops4j.pax.exam\", \"pax-exam\").versionAsInProject().noStart(),\n            mavenBundle(\"org.apache.karaf.itests\", \"itests\").versionAsInProject().classifier(\"tests\").noStart(),\n\n            junitBundles()\n        };\n    }","commit_id":"b72346ced6919d71d2e97063e8119fd089939889","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Create an {@link Option} for using a Fabric distribution.\n     *\n     * @return\n     */\n    protected Option fabricDistributionConfiguration() {\n        return karafDistributionConfiguration().frameworkUrl(\n                maven().groupId(GROUP_ID).artifactId(ARTIFACT_ID).versionAsInProject().type(\"tar.gz\"))\n                .karafVersion(getKarafVersion()).name(\"Fabric Karaf Distro\").unpackDirectory(new File(\"target/paxexam/unpack/\"));\n    }","id":26616,"modified_method":"/**\n     * Create an {@link Option} for using a Fabric distribution.\n     *\n     * @return\n     */\n    protected Option fabricDistributionConfiguration() {\n        return new DefaultCompositeOption(\n                new Option[]{karafDistributionConfiguration().frameworkUrl(\n                        maven().groupId(GROUP_ID).artifactId(ARTIFACT_ID).versionAsInProject().type(\"tar.gz\"))\n                        .karafVersion(getKarafVersion()).name(\"Fabric Karaf Distro\").unpackDirectory(new File(\"target/paxexam/unpack/\")),\n                      useOwnExamBundlesStartLevel(1)\n                });\n    }","commit_id":"2f6c639b0b182a1d54660bd7dfc07663d0698b39","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void importWordsDB() {\r\n        this.log.logInfo(\"STARTING DB-IMPORT\");  \r\n        \r\n        try {                                                \r\n            this.log.logInfo(\"Importing DB from '\" + this.importPath.getAbsolutePath() + \"' to '\" + this.homeWordIndex.getRoot().getAbsolutePath() + \"'.\");\r\n            this.log.logInfo(\"Home word index contains \" + this.homeWordIndex.size() + \" words and \" + this.homeUrlDB.size() + \" URLs.\");\r\n            this.log.logInfo(\"Import word index contains \" + this.importWordIndex.size() + \" words and \" + this.importUrlDB.size() + \" URLs.\");                        \r\n            \r\n            HashSet unknownUrlBuffer = new HashSet();\r\n            HashSet importedUrlBuffer = new HashSet();\r\n\t\t\t\r\n            // iterate over all words from import db\r\n            Iterator importWordHashIterator = this.importWordIndex.wordHashes(this.wordChunkStartHash, plasmaWordIndex.RL_WORDFILES, false);\r\n            while (!isAborted() && importWordHashIterator.hasNext()) {\r\n                \r\n                TreeSet entityUrls = new TreeSet(new kelondroNaturalOrder(true));\r\n                plasmaWordIndexEntryContainer newContainer = null;\r\n                try {\r\n                    this.wordCounter++;\r\n                    this.wordHash = (String) importWordHashIterator.next();\r\n                    newContainer = this.importWordIndex.getContainer(this.wordHash, true, -1);\r\n                    \r\n                    if (newContainer.size() == 0) continue;\r\n                    \r\n                    // loop throug the entities of the container and get the\r\n                    // urlhash\r\n                    Iterator importWordIdxEntries = newContainer.entries();\r\n                    plasmaWordIndexEntry importWordIdxEntry;\r\n                    while (importWordIdxEntries.hasNext()) {\r\n                        // testing if import process was aborted\r\n                        if (isAborted()) break;\r\n\r\n                        // getting next word index entry\r\n                        importWordIdxEntry = (plasmaWordIndexEntry) importWordIdxEntries.next();\r\n                        String urlHash = importWordIdxEntry.getUrlHash();\r\n                        entityUrls.add(urlHash);\r\n                    }\r\n\r\n                    Iterator urlIter = entityUrls.iterator();\r\n                    while (urlIter.hasNext()) {\t\r\n                        if (isAborted()) break;\r\n                        String urlHash = (String) urlIter.next();\r\n\r\n                        if (importedUrlBuffer.contains(urlHash)) {\r\n                            // already known url\r\n                        } else if (unknownUrlBuffer.contains(urlHash)) {\r\n                            // url known as unknown\r\n                            unknownUrlBuffer.add(urlHash);\r\n                            notBoundEntryCounter++;\r\n                            newContainer.remove(urlHash);\r\n                            continue;\r\n                        } else {\r\n                            // we need to import the url\r\n                            try {\t\r\n                                // getting the url entry\r\n                                plasmaCrawlLURL.Entry urlEntry = this.importUrlDB.getEntry(urlHash, null);\r\n\r\n                                /* write it into the home url db */\r\n                                plasmaCrawlLURL.Entry homeEntry = this.homeUrlDB.newEntry(urlEntry);\r\n                                homeEntry.store();\r\n                                importedUrlBuffer.add(urlHash);\r\n                                this.urlCounter++;\r\n\r\n                                if (this.urlCounter % 500 == 0) {\r\n                                    this.log.logFine(this.urlCounter + \" URLs processed so far.\");\r\n                                }\r\n                            } catch (IOException e) {\r\n                                unknownUrlBuffer.add(urlHash);\r\n                                notBoundEntryCounter++;\r\n                                newContainer.remove(urlHash);\r\n                                continue;\r\n                            }\r\n                        }\r\n                    this.entryCounter++;\r\n                    }\r\n\t\t\t\t\t\r\n                    // testing if import process was aborted\r\n                    if (isAborted()) break;\r\n                    \r\n                    // importing entity container to home db\r\n                    if (newContainer.size() > 0) { this.homeWordIndex.addEntries(newContainer, System.currentTimeMillis(), false); }\r\n                    \r\n                    // delete complete index entity file\r\n                    this.importWordIndex.deleteIndex(this.wordHash);                 \r\n                    \r\n                    // print out some statistical information\r\n                    if (this.entryCounter % 500 == 0) {\r\n                        this.log.logFine(this.entryCounter + \" word entries and \" + this.wordCounter + \" word entities processed so far.\");\r\n                    }\r\n\r\n                    if (this.wordCounter%500 == 0) {\r\n                        this.wordChunkEndHash = this.wordHash;\r\n                        this.wordChunkEnd = System.currentTimeMillis();\r\n                        long duration = this.wordChunkEnd - this.wordChunkStart;\r\n                        this.log.logInfo(this.wordCounter + \" word entities imported \" +\r\n                                \"[\" + this.wordChunkStartHash + \" .. \" + this.wordChunkEndHash + \"] \" +\r\n                                this.getProcessingStatusPercent() + \"%\\n\" + \r\n                                \"Speed: \"+ 500*1000/duration + \" word entities/s\" +\r\n                                \" | Elapsed time: \" + serverDate.intervalToString(getElapsedTime()) +\r\n                                \" | Estimated time: \" + serverDate.intervalToString(getEstimatedTime()) + \"\\n\" + \r\n                                \"Home Words = \" + this.homeWordIndex.size() + \r\n                                \" | Import Words = \" + this.importWordIndex.size());\r\n                        this.wordChunkStart = this.wordChunkEnd;\r\n                        this.wordChunkStartHash = this.wordChunkEndHash;\r\n                    }                    \r\n                    \r\n                } catch (Exception e) {\r\n                    this.log.logSevere(\"Import of word entity '\" + this.wordHash + \"' failed.\",e);\r\n                } finally {\r\n                    if (newContainer != null) newContainer.clear();\r\n                }\r\n            }\r\n            \r\n            this.log.logInfo(\"Home word index contains \" + this.homeWordIndex.size() + \" words and \" + this.homeUrlDB.size() + \" URLs.\");\r\n            this.log.logInfo(\"Import word index contains \" + this.importWordIndex.size() + \" words and \" + this.importUrlDB.size() + \" URLs.\");\r\n        } catch (Exception e) {\r\n            this.log.logSevere(\"Database import failed.\",e);\r\n            e.printStackTrace();\r\n            this.error = e.toString();\r\n        } finally {\r\n            this.log.logInfo(\"Import process finished.\");\r\n            if (this.importUrlDB != null) try { this.importUrlDB.close(); } catch (Exception e){}\r\n            if (this.importWordIndex != null) try { this.importWordIndex.close(5000); } catch (Exception e){}\r\n        }\r\n    }","id":26617,"modified_method":"public void importWordsDB() {\r\n        this.log.logInfo(\"STARTING DB-IMPORT\");  \r\n        \r\n        try {                                                \r\n            this.log.logInfo(\"Importing DB from '\" + this.importPath.getAbsolutePath() + \"' to '\" + this.homeWordIndex.getRoot().getAbsolutePath() + \"'.\");\r\n            this.log.logInfo(\"Home word index contains \" + this.homeWordIndex.size() + \" words and \" + this.homeUrlDB.size() + \" URLs.\");\r\n            this.log.logInfo(\"Import word index contains \" + this.importWordIndex.size() + \" words and \" + this.importUrlDB.size() + \" URLs.\");                        \r\n            \r\n            HashSet unknownUrlBuffer = new HashSet();\r\n            HashSet importedUrlBuffer = new HashSet();\r\n\t\t\t\r\n            // iterate over all words from import db\r\n            //Iterator importWordHashIterator = this.importWordIndex.wordHashes(this.wordChunkStartHash, plasmaWordIndex.RL_WORDFILES, false);\r\n            Iterator importWordHashIterator = this.importWordIndex.wordHashes(this.wordChunkStartHash, plasmaWordIndex.RL_WORDFILES, false, 100).iterator();\r\n            while (!isAborted() && importWordHashIterator.hasNext()) {\r\n                \r\n                TreeSet entityUrls = new TreeSet(new kelondroNaturalOrder(true));\r\n                plasmaWordIndexEntryContainer newContainer = null;\r\n                try {\r\n                    this.wordCounter++;\r\n                    this.wordHash = (String) importWordHashIterator.next();\r\n                    newContainer = this.importWordIndex.getContainer(this.wordHash, true, -1);\r\n                    \r\n                    // loop throug the entities of the container and get the\r\n                    // urlhash\r\n                    Iterator importWordIdxEntries = newContainer.entries();\r\n                    plasmaWordIndexEntry importWordIdxEntry;\r\n                    while (importWordIdxEntries.hasNext()) {\r\n                        // testing if import process was aborted\r\n                        if (isAborted()) break;\r\n\r\n                        // getting next word index entry\r\n                        importWordIdxEntry = (plasmaWordIndexEntry) importWordIdxEntries.next();\r\n                        String urlHash = importWordIdxEntry.getUrlHash();\r\n                        entityUrls.add(urlHash);\r\n                    }\r\n\r\n                    Iterator urlIter = entityUrls.iterator();\r\n                    while (urlIter.hasNext()) {\t\r\n                        if (isAborted()) break;\r\n                        String urlHash = (String) urlIter.next();\r\n\r\n                        if (importedUrlBuffer.contains(urlHash)) {\r\n                            // already known url\r\n                        } else if (unknownUrlBuffer.contains(urlHash)) {\r\n                            // url known as unknown\r\n                            unknownUrlBuffer.add(urlHash);\r\n                            notBoundEntryCounter++;\r\n                            newContainer.remove(urlHash);\r\n                            continue;\r\n                        } else {\r\n                            // we need to import the url\r\n                            try {\t\r\n                                // getting the url entry\r\n                                plasmaCrawlLURL.Entry urlEntry = this.importUrlDB.getEntry(urlHash, null);\r\n\r\n                                /* write it into the home url db */\r\n                                plasmaCrawlLURL.Entry homeEntry = this.homeUrlDB.newEntry(urlEntry);\r\n                                homeEntry.store();\r\n                                importedUrlBuffer.add(urlHash);\r\n                                this.urlCounter++;\r\n\r\n                                if (this.urlCounter % 500 == 0) {\r\n                                    this.log.logFine(this.urlCounter + \" URLs processed so far.\");\r\n                                }\r\n                            } catch (IOException e) {\r\n                                unknownUrlBuffer.add(urlHash);\r\n                                notBoundEntryCounter++;\r\n                                newContainer.remove(urlHash);\r\n                                continue;\r\n                            }\r\n                        }\r\n                        this.entryCounter++;\r\n                    }\r\n\t\t\t\t\t\r\n                    // testing if import process was aborted\r\n                    if (isAborted()) break;\r\n                    \r\n                    // importing entity container to home db\r\n                    if (newContainer.size() > 0) { this.homeWordIndex.addEntries(newContainer, System.currentTimeMillis(), false); }\r\n                    \r\n                    // delete complete index entity file\r\n                    this.importWordIndex.deleteIndex(this.wordHash);                 \r\n                    \r\n                    // print out some statistical information\r\n                    if (this.entryCounter % 500 == 0) {\r\n                        this.log.logFine(this.entryCounter + \" word entries and \" + this.wordCounter + \" word entities processed so far.\");\r\n                    }\r\n\r\n                    if (this.wordCounter%500 == 0) {\r\n                        this.wordChunkEndHash = this.wordHash;\r\n                        this.wordChunkEnd = System.currentTimeMillis();\r\n                        long duration = this.wordChunkEnd - this.wordChunkStart;\r\n                        this.log.logInfo(this.wordCounter + \" word entities imported \" +\r\n                                \"[\" + this.wordChunkStartHash + \" .. \" + this.wordChunkEndHash + \"] \" +\r\n                                this.getProcessingStatusPercent() + \"%\\n\" + \r\n                                \"Speed: \"+ 500*1000/duration + \" word entities/s\" +\r\n                                \" | Elapsed time: \" + serverDate.intervalToString(getElapsedTime()) +\r\n                                \" | Estimated time: \" + serverDate.intervalToString(getEstimatedTime()) + \"\\n\" + \r\n                                \"Home Words = \" + this.homeWordIndex.size() + \r\n                                \" | Import Words = \" + this.importWordIndex.size());\r\n                        this.wordChunkStart = this.wordChunkEnd;\r\n                        this.wordChunkStartHash = this.wordChunkEndHash;\r\n                    }                    \r\n                    \r\n                } catch (Exception e) {\r\n                    this.log.logSevere(\"Import of word entity '\" + this.wordHash + \"' failed.\",e);\r\n                } finally {\r\n                    if (newContainer != null) newContainer.clear();\r\n                }\r\n\r\n                if (!importWordHashIterator.hasNext()) {\r\n                    // We may not be finished yet, try to get the next chunk of wordHashes\r\n                    TreeSet wordHashes = this.importWordIndex.wordHashes(this.wordHash, plasmaWordIndex.RL_WORDFILES, false, 100);\r\n                    importWordHashIterator = wordHashes.iterator();\r\n                    // Make sure we don't get the same wordhash twice, but don't skip a word\r\n                    if ((importWordHashIterator.hasNext())&&(!this.wordHash.equals(importWordHashIterator.next()))) {\r\n                        importWordHashIterator = wordHashes.iterator();\r\n                    }\r\n                }\r\n            }\r\n            \r\n            this.log.logInfo(\"Home word index contains \" + this.homeWordIndex.size() + \" words and \" + this.homeUrlDB.size() + \" URLs.\");\r\n            this.log.logInfo(\"Import word index contains \" + this.importWordIndex.size() + \" words and \" + this.importUrlDB.size() + \" URLs.\");\r\n        } catch (Exception e) {\r\n            this.log.logSevere(\"Database import failed.\",e);\r\n            e.printStackTrace();\r\n            this.error = e.toString();\r\n        } finally {\r\n            this.log.logInfo(\"Import process finished.\");\r\n            if (this.importUrlDB != null) try { this.importUrlDB.close(); } catch (Exception e){}\r\n            if (this.importWordIndex != null) try { this.importWordIndex.close(5000); } catch (Exception e){}\r\n        }\r\n    }","commit_id":"4e9a8f41fdcd7e3b5fa06ece8b4d897d05c5de33","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void run() {\r\n            serverLog.logInfo(\"INDEXCLEANER\", \"IndexCleaner-Thread started\");\r\n            String wordHash = \"\";\r\n            plasmaWordIndexEntryContainer wordContainer = null;\r\n            plasmaWordIndexEntry entry = null;\r\n            URL url = null;\r\n            HashSet urlHashs = new HashSet();\r\n            try {\r\n                Iterator wordHashIterator = wordHashes(startHash, plasmaWordIndex.RL_WORDFILES, false);\r\n                while (wordHashIterator.hasNext() && run) {\r\n                    waiter();\r\n                    wordHash = (String) wordHashIterator.next();\r\n                    wordContainer = getContainer(wordHash, true, -1);\r\n                    Iterator containerIterator = wordContainer.entries();\r\n                    wordHashNow = wordHash;\r\n                    while (containerIterator.hasNext() && run) {\r\n                        waiter();\r\n                        entry = (plasmaWordIndexEntry) containerIterator.next();\r\n                        // System.out.println(\"Wordhash: \"+wordHash+\" UrlHash:\r\n                        // \"+entry.getUrlHash());\r\n                        try {\r\n                            url = lurl.getEntry(entry.getUrlHash(), null).url();\r\n                            if ((url == null) || (plasmaSwitchboard.urlBlacklist.isListed(url.getHost().toLowerCase(), url.getPath()) == true)) {\r\n                                urlHashs.add(entry.getUrlHash());\r\n                            }\r\n                        } catch (IOException e) {\r\n                            urlHashs.add(entry.getUrlHash());\r\n                        }\r\n                    }\r\n                    if (urlHashs.size() > 0) {\r\n                        String[] urlArray;\r\n                        urlArray = (String[]) urlHashs.toArray(new String[0]);\r\n                        int removed = removeEntries(wordHash, urlArray, true);\r\n                        serverLog.logFine(\"INDEXCLEANER\", wordHash + \": \" + removed + \" of \" + wordContainer.size() + \" URL-entries deleted\");\r\n                        lastWordHash = wordHash;\r\n                        lastDeletionCounter = urlHashs.size();\r\n                        urlHashs.clear();\r\n                    }\r\n                }\r\n            } catch (IOException e) {\r\n                serverLog.logSevere(\"INDEXCLEANER\",\r\n                        \"IndexCleaner-Thread: unable to start: \"\r\n                                + e.getMessage());\r\n            }\r\n            serverLog.logInfo(\"INDEXCLEANER\", \"IndexCleaner-Thread stopped\");\r\n        }","id":26618,"modified_method":"public void run() {\r\n            serverLog.logInfo(\"INDEXCLEANER\", \"IndexCleaner-Thread started\");\r\n            String wordHash = \"\";\r\n            plasmaWordIndexEntryContainer wordContainer = null;\r\n            plasmaWordIndexEntry entry = null;\r\n            URL url = null;\r\n            HashSet urlHashs = new HashSet();\r\n            try {\r\n                Iterator wordHashIterator = wordHashes(startHash, plasmaWordIndex.RL_WORDFILES, false, 100).iterator();\r\n                while (wordHashIterator.hasNext() && run) {\r\n                    waiter();\r\n                    wordHash = (String) wordHashIterator.next();\r\n                    wordContainer = getContainer(wordHash, true, -1);\r\n                    Iterator containerIterator = wordContainer.entries();\r\n                    wordHashNow = wordHash;\r\n                    while (containerIterator.hasNext() && run) {\r\n                        waiter();\r\n                        entry = (plasmaWordIndexEntry) containerIterator.next();\r\n                        // System.out.println(\"Wordhash: \"+wordHash+\" UrlHash:\r\n                        // \"+entry.getUrlHash());\r\n                        try {\r\n                            url = lurl.getEntry(entry.getUrlHash(), null).url();\r\n                            if ((url == null) || (plasmaSwitchboard.urlBlacklist.isListed(url.getHost().toLowerCase(), url.getPath()) == true)) {\r\n                                urlHashs.add(entry.getUrlHash());\r\n                            }\r\n                        } catch (IOException e) {\r\n                            urlHashs.add(entry.getUrlHash());\r\n                        }\r\n                    }\r\n                    if (urlHashs.size() > 0) {\r\n                        String[] urlArray;\r\n                        urlArray = (String[]) urlHashs.toArray(new String[0]);\r\n                        int removed = removeEntries(wordHash, urlArray, true);\r\n                        serverLog.logFine(\"INDEXCLEANER\", wordHash + \": \" + removed + \" of \" + wordContainer.size() + \" URL-entries deleted\");\r\n                        lastWordHash = wordHash;\r\n                        lastDeletionCounter = urlHashs.size();\r\n                        urlHashs.clear();\r\n                    }\r\n                    if (!wordHashIterator.hasNext()) {\r\n                        // We may not be finished yet, try to get the next chunk of wordHashes\r\n                        TreeSet wordHashes = wordHashes(wordHash, plasmaWordIndex.RL_WORDFILES, false, 100);\r\n                        wordHashIterator = wordHashes.iterator();\r\n                        // Make sure we don't get the same wordhash twice, but don't skip a word\r\n                        if ((wordHashIterator.hasNext())&&(!wordHash.equals(wordHashIterator.next()))) {\r\n                            wordHashIterator = wordHashes.iterator();\r\n                        }\r\n                    }\r\n                }\r\n            } catch (IOException e) {\r\n                serverLog.logSevere(\"INDEXCLEANER\",\r\n                        \"IndexCleaner-Thread: unable to start: \"\r\n                                + e.getMessage());\r\n            }\r\n            serverLog.logInfo(\"INDEXCLEANER\", \"IndexCleaner-Thread stopped\");\r\n        }","commit_id":"4e9a8f41fdcd7e3b5fa06ece8b4d897d05c5de33","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static void RWIHashList(String homePath, String targetName) {\r\n        serverLog log = new serverLog(\"HASHLIST\");\r\n        File homeDBroot = new File(new File(homePath), \"DATA/PLASMADB\");\r\n        String wordChunkStartHash = \"------------\";\r\n        try {serverLog.configureLogging(new File(homePath, \"yacy.logging\"));} catch (Exception e) {}\r\n        log.logInfo(\"STARTING CREATION OF RWI-HASHLIST\");\r\n        File root = new File(homePath);\r\n        File file = new File(root, targetName + \".txt\");\r\n        try {\r\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));\r\n            plasmaWordIndex WordIndex = new plasmaWordIndex(homeDBroot, 8*1024*1024, log);\r\n            Iterator WordHashIterator = WordIndex.wordHashes(wordChunkStartHash, true, true);\r\n            int counter = 0;\r\n            while (WordHashIterator.hasNext()) {\r\n                counter++;\r\n                String wordHash = (String) WordHashIterator.next();\r\n                bos.write((wordHash).getBytes());\r\n                bos.write(serverCore.crlf);\r\n                if (counter % 500 == 0) {\r\n                    log.logInfo(\"Found \" + counter + \" Hashs until now. Last found Hash: \" + wordHash);\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    }","id":26619,"modified_method":"private static void RWIHashList(String homePath, String targetName, String resource) {\r\n        serverLog log = new serverLog(\"HASHLIST\");\r\n        File homeDBroot = new File(new File(homePath), \"DATA/PLASMADB\");\r\n        String wordChunkStartHash = \"------------\";\r\n        try {serverLog.configureLogging(new File(homePath, \"yacy.logging\"));} catch (Exception e) {}\r\n        log.logInfo(\"STARTING CREATION OF RWI-HASHLIST\");\r\n        File root = new File(homePath);\r\n        File file = new File(root, targetName + \".txt\");\r\n        try {\r\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));\r\n            Iterator WordHashIterator = null;\r\n            if (resource.equals(\"all\")) {\r\n                plasmaWordIndex WordIndex = new plasmaWordIndex(homeDBroot, 8*1024*1024, log);\r\n                WordHashIterator = WordIndex.wordHashes(wordChunkStartHash, true, false);\r\n            }\r\n            if (resource.equals(\"assortments\")) {\r\n                plasmaWordIndexAssortmentCluster assortmentCluster = new plasmaWordIndexAssortmentCluster(new File(homeDBroot, \"ACLUSTER\"), 64, 16*1024*1024, log);\r\n                WordHashIterator = assortmentCluster.hashConjunction(wordChunkStartHash, true);\r\n            }\r\n            if (resource.equals(\"words\")) {\r\n                plasmaWordIndexClassicDB fileDB = new plasmaWordIndexClassicDB(homeDBroot, log);\r\n                WordHashIterator = fileDB.wordHashes(wordChunkStartHash, true);\r\n            }\r\n            int counter = 0;\r\n            while (WordHashIterator.hasNext()) {\r\n                counter++;\r\n                String wordHash = (String) WordHashIterator.next();\r\n                bos.write((wordHash).getBytes());\r\n                bos.write(serverCore.crlf);\r\n                if (counter % 500 == 0) {\r\n                    log.logInfo(\"Found \" + counter + \" Hashs until now. Last found Hash: \" + wordHash);\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }","commit_id":"537a819824265c369e5bd0398d995dcfd4d62e62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * Main-method which is started by java. Checks for special arguments or\r\n     * starts up the application.\r\n     * \r\n     * @param args\r\n     *            Given arguments from the command line.\r\n     */\r\n    public static void main(String args[]) {\r\n\r\n        // check memory amount\r\n        System.gc();\r\n        long startupMemFree  = Runtime.getRuntime().freeMemory(); // the\r\n                                                                    // amount of\r\n                                                                    // free\r\n                                                                    // memory in\r\n                                                                    // the Java\r\n                                                                    // Virtual\r\n                                                                    // Machine\r\n        long startupMemTotal = Runtime.getRuntime().totalMemory(); // the total amount of memory in the Java virtual machine; may vary over time\r\n\r\n        // go into headless awt mode\r\n        System.setProperty(\"java.awt.headless\", \"true\");\r\n        \r\n        String applicationRoot = System.getProperty(\"user.dir\").replace('\\\\', '/');\r\n        //System.out.println(\"args.length=\" + args.length);\r\n        //System.out.print(\"args=[\"); for (int i = 0; i < args.length; i++) System.out.print(args[i] + \", \"); System.out.println(\"]\");\r\n        if ((args.length >= 1) && ((args[0].equals(\"-startup\")) || (args[0].equals(\"-start\")))) {\r\n            // normal start-up of yacy\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            startup(applicationRoot, startupMemFree, startupMemTotal);\r\n        } else if ((args.length >= 1) && ((args[0].equals(\"-shutdown\")) || (args[0].equals(\"-stop\")))) {\r\n            // normal shutdown of yacy\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            shutdown(applicationRoot);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-migratewords\"))) {\r\n            // migrate words from DATA/PLASMADB/WORDS path to assortment cache, if possible\r\n            // attention: this may run long and should not be interrupted!\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            migrateWords(applicationRoot);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-minimizeUrlDB\"))) {\r\n            // migrate words from DATA/PLASMADB/WORDS path to assortment cache, if possible\r\n            // attention: this may run long and should not be interrupted!\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            minimizeUrlDB(applicationRoot);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-importDB\"))) {\r\n            // attention: this may run long and should not be interrupted!\r\n            String importRoot = null;\r\n            if (args.length == 3) {\r\n                applicationRoot= args[1];\r\n                importRoot = args[2];\r\n            } else if (args.length == 2) {\r\n                importRoot = args[1];\r\n            } else {\r\n                System.err.println(\"Usage: -importDB [homeDbRoot] importDbRoot\");\r\n            }\r\n            importDB(applicationRoot, importRoot);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-deletestopwords\"))) {\r\n            // delete those words in the index that are listed in the stopwords file\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            deleteStopwords(applicationRoot);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-genwordstat\"))) {\r\n            // this can help to create a stop-word list\r\n            // to use this, you need a 'yacy.words' file in the root path\r\n            // start this with \"java -classpath classes yacy -genwordstat [<rootdir>]\"\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            genWordstat(applicationRoot);\r\n        } else if ((args.length == 4) && (args[0].equals(\"-cleanwordlist\"))) {\r\n            // this can be used to organize and clean a word-list\r\n            // start this with \"java -classpath classes yacy -cleanwordlist <word-file> <minlength> <maxlength>\"\r\n            int minlength = Integer.parseInt(args[2]);\r\n            int maxlength = Integer.parseInt(args[3]);\r\n            cleanwordlist(args[1], minlength, maxlength);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-transfercr\"))) {\r\n            // transfer a single cr file to a remote peer\r\n            String targetaddress = args[1];\r\n            String crfile = args[2];\r\n            transferCR(targetaddress, crfile);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-domlist\"))) {\r\n            // generate a url list and save it in a file\r\n            String format = \"txt\";\r\n            if (args.length >= 3 && args[1].equals(\"-format\")) {\r\n                if (args[2].equals(\"html\")) format = args[2];\r\n                if (args[2].equals(\"zip\")) format = args[2];\r\n                args = shift(args, 1, 2);\r\n            }\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            String outfile = \"domlist_\" + System.currentTimeMillis();\r\n            domlist(applicationRoot, format, outfile);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-urllist\"))) {\r\n            // generate a url list and save it in a file\r\n            boolean html = false;\r\n            if (args.length >= 3 && args[1].equals(\"-format\")) {\r\n                if (args[2].equals(\"html\")) html = true;\r\n                args = shift(args, 1, 2);\r\n            }\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            String outfile = \"urllist_\" + System.currentTimeMillis() + ((html) ? \".html\" : \".txt\");\r\n            urllist(applicationRoot, html, outfile);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-urldbcleanup\"))) {\r\n            // generate a url list and save it in a file\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            urldbcleanup(applicationRoot);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-rwihashlist\"))) {\r\n            // generate a url list and save it in a file\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            String outfile = \"rwihashlist_\" + System.currentTimeMillis();\r\n            RWIHashList(applicationRoot, outfile);\r\n        } else {\r\n            if (args.length == 1) applicationRoot= args[0];\r\n            startup(applicationRoot, startupMemFree, startupMemTotal);\r\n        }\r\n    }","id":26620,"modified_method":"/**\r\n     * Main-method which is started by java. Checks for special arguments or\r\n     * starts up the application.\r\n     * \r\n     * @param args\r\n     *            Given arguments from the command line.\r\n     */\r\n    public static void main(String args[]) {\r\n\r\n        // check memory amount\r\n        System.gc();\r\n        long startupMemFree  = Runtime.getRuntime().freeMemory(); // the\r\n                                                                    // amount of\r\n                                                                    // free\r\n                                                                    // memory in\r\n                                                                    // the Java\r\n                                                                    // Virtual\r\n                                                                    // Machine\r\n        long startupMemTotal = Runtime.getRuntime().totalMemory(); // the total amount of memory in the Java virtual machine; may vary over time\r\n\r\n        // go into headless awt mode\r\n        System.setProperty(\"java.awt.headless\", \"true\");\r\n        \r\n        String applicationRoot = System.getProperty(\"user.dir\").replace('\\\\', '/');\r\n        //System.out.println(\"args.length=\" + args.length);\r\n        //System.out.print(\"args=[\"); for (int i = 0; i < args.length; i++) System.out.print(args[i] + \", \"); System.out.println(\"]\");\r\n        if ((args.length >= 1) && ((args[0].equals(\"-startup\")) || (args[0].equals(\"-start\")))) {\r\n            // normal start-up of yacy\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            startup(applicationRoot, startupMemFree, startupMemTotal);\r\n        } else if ((args.length >= 1) && ((args[0].equals(\"-shutdown\")) || (args[0].equals(\"-stop\")))) {\r\n            // normal shutdown of yacy\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            shutdown(applicationRoot);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-migratewords\"))) {\r\n            // migrate words from DATA/PLASMADB/WORDS path to assortment cache, if possible\r\n            // attention: this may run long and should not be interrupted!\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            migrateWords(applicationRoot);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-minimizeUrlDB\"))) {\r\n            // migrate words from DATA/PLASMADB/WORDS path to assortment cache, if possible\r\n            // attention: this may run long and should not be interrupted!\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            minimizeUrlDB(applicationRoot);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-importDB\"))) {\r\n            // attention: this may run long and should not be interrupted!\r\n            String importRoot = null;\r\n            if (args.length == 3) {\r\n                applicationRoot= args[1];\r\n                importRoot = args[2];\r\n            } else if (args.length == 2) {\r\n                importRoot = args[1];\r\n            } else {\r\n                System.err.println(\"Usage: -importDB [homeDbRoot] importDbRoot\");\r\n            }\r\n            importDB(applicationRoot, importRoot);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-deletestopwords\"))) {\r\n            // delete those words in the index that are listed in the stopwords file\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            deleteStopwords(applicationRoot);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-genwordstat\"))) {\r\n            // this can help to create a stop-word list\r\n            // to use this, you need a 'yacy.words' file in the root path\r\n            // start this with \"java -classpath classes yacy -genwordstat [<rootdir>]\"\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            genWordstat(applicationRoot);\r\n        } else if ((args.length == 4) && (args[0].equals(\"-cleanwordlist\"))) {\r\n            // this can be used to organize and clean a word-list\r\n            // start this with \"java -classpath classes yacy -cleanwordlist <word-file> <minlength> <maxlength>\"\r\n            int minlength = Integer.parseInt(args[2]);\r\n            int maxlength = Integer.parseInt(args[3]);\r\n            cleanwordlist(args[1], minlength, maxlength);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-transfercr\"))) {\r\n            // transfer a single cr file to a remote peer\r\n            String targetaddress = args[1];\r\n            String crfile = args[2];\r\n            transferCR(targetaddress, crfile);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-domlist\"))) {\r\n            // generate a url list and save it in a file\r\n            String format = \"txt\";\r\n            if (args.length >= 3 && args[1].equals(\"-format\")) {\r\n                if (args[2].equals(\"html\")) format = args[2];\r\n                if (args[2].equals(\"zip\")) format = args[2];\r\n                args = shift(args, 1, 2);\r\n            }\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            String outfile = \"domlist_\" + System.currentTimeMillis();\r\n            domlist(applicationRoot, format, outfile);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-urllist\"))) {\r\n            // generate a url list and save it in a file\r\n            boolean html = false;\r\n            if (args.length >= 3 && args[1].equals(\"-format\")) {\r\n                if (args[2].equals(\"html\")) html = true;\r\n                args = shift(args, 1, 2);\r\n            }\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            String outfile = \"urllist_\" + System.currentTimeMillis() + ((html) ? \".html\" : \".txt\");\r\n            urllist(applicationRoot, html, outfile);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-urldbcleanup\"))) {\r\n            // generate a url list and save it in a file\r\n            if (args.length == 2) applicationRoot= args[1];\r\n            urldbcleanup(applicationRoot);\r\n        } else if ((args.length >= 1) && (args[0].equals(\"-rwihashlist\"))) {\r\n            // generate a url list and save it in a file\r\n            String domain = \"all\";\r\n            if (args.length >= 2) domain= args[1];\r\n            if (args.length == 3) applicationRoot= args[2];\r\n            String outfile = \"rwihashlist_\" + System.currentTimeMillis();\r\n            RWIHashList(applicationRoot, outfile, domain);\r\n        } else {\r\n            if (args.length == 1) applicationRoot= args[0];\r\n            startup(applicationRoot, startupMemFree, startupMemTotal);\r\n        }\r\n    }","commit_id":"537a819824265c369e5bd0398d995dcfd4d62e62","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void calculateExtendedTypes(Class<?> actingClass, Method method, OperationDescriptor operation)\n    {\n        ExtensionOf extensionOf = method.getAnnotation(ExtensionOf.class);\n        if (extensionOf == null)\n        {\n            extensionOf = actingClass.getAnnotation(ExtensionOf.class);\n        }\n\n        if (extensionOf != null)\n        {\n            operation.withCapability(new ExtendingOperationCapability(extensionOf.value()));\n        }\n    }","id":26621,"modified_method":"private void calculateExtendedTypes(Class<?> actingClass, Method method, OperationDescriptor operation)\n    {\n        ExtensionOf extensionOf = method.getAnnotation(ExtensionOf.class);\n        if (extensionOf == null)\n        {\n            extensionOf = actingClass.getAnnotation(ExtensionOf.class);\n        }\n\n        if (extensionOf != null)\n        {\n            operation.withCapability(new ExtendingOperationCapability(extensionOf.value()));\n        }\n        else if (isExtensible())\n        {\n            operation.withCapability(new ExtendingOperationCapability(extensionType));\n        }\n    }","commit_id":"d3d5843350b1de818281172e9b2c5ccf1eeced1b","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void heisengergPointerPlusExternalConfig() throws Exception\n    {\n        describer = describerFor(HeisengergPointerPlusExternalConfig.class);\n        Declaration declaration = describer.describe().getRootDeclaration().getDeclaration();\n\n        assertExtensionProperties(declaration);\n        assertThat(declaration.getConfigurations().size(), equalTo(2));\n\n        ConfigurationDeclaration configuration = declaration.getConfigurations().get(1);\n        assertThat(configuration, is(notNullValue()));\n        assertThat(configuration.getName(), equalTo(EXTENDED_CONFIG_NAME));\n        assertThat(configuration.getParameters(), hasSize(1));\n        assertParameter(configuration.getParameters(), \"extendedProperty\", \"\", DataType.of(String.class), true, true, null);\n    }","id":26622,"modified_method":"@Test\n    public void heisenbergPointerPlusExternalConfig() throws Exception\n    {\n        setDescriber(describerFor(HeisengergPointerPlusExternalConfig.class));\n        Declaration declaration = getDescriber().describe().getRootDeclaration().getDeclaration();\n\n        assertExtensionProperties(declaration);\n        assertThat(declaration.getConfigurations().size(), equalTo(2));\n\n        ConfigurationDeclaration configuration = declaration.getConfigurations().get(1);\n        assertThat(configuration, is(notNullValue()));\n        assertThat(configuration.getName(), equalTo(EXTENDED_CONFIG_NAME));\n        assertThat(configuration.getParameters(), hasSize(1));\n        assertParameter(configuration.getParameters(), \"extendedProperty\", \"\", DataType.of(String.class), true, true, null);\n    }","commit_id":"d3d5843350b1de818281172e9b2c5ccf1eeced1b","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void describeTestModule() throws Exception\n    {\n        Descriptor descriptor = describer.describe();\n\n        Declaration declaration = descriptor.getRootDeclaration().getDeclaration();\n        assertExtensionProperties(declaration);\n\n        assertTestModuleConfiguration(declaration);\n        assertTestModuleOperations(declaration);\n\n        assertCapabilities(declaration);\n    }","id":26623,"modified_method":"@Test\n    public void describeTestModule() throws Exception\n    {\n        Descriptor descriptor = getDescriber().describe();\n\n        Declaration declaration = descriptor.getRootDeclaration().getDeclaration();\n        assertExtensionProperties(declaration);\n\n        assertTestModuleConfiguration(declaration);\n        assertTestModuleOperations(declaration);\n\n        assertCapabilities(declaration);\n    }","commit_id":"d3d5843350b1de818281172e9b2c5ccf1eeced1b","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void heisengergPointer() throws Exception\n    {\n        describer = describerFor(HeisenbergPointer.class);\n        describeTestModule();\n    }","id":26624,"modified_method":"@Test\n    public void heisenbergPointer() throws Exception\n    {\n        setDescriber(describerFor(HeisenbergPointer.class));\n        describeTestModule();\n    }","commit_id":"d3d5843350b1de818281172e9b2c5ccf1eeced1b","url":"https://github.com/mulesoft/mule"},{"original_method":"@Before\n    public void setUp()\n    {\n        describer = describerFor(HeisenbergExtension.class);\n    }","id":26625,"modified_method":"@Before\n    public void setUp()\n    {\n        setDescriber(describerFor(HeisenbergExtension.class));\n    }","commit_id":"d3d5843350b1de818281172e9b2c5ccf1eeced1b","url":"https://github.com/mulesoft/mule"},{"original_method":"public List<IssueResolution> getResolutions(IssueContext issueContext) {\n\t\tList<Method> fixMethods = getFixMethods(issueContext);\n\t\treturn getResolutions(issueContext, fixMethods);\n\t}","id":26626,"modified_method":"public List<IssueResolution> getResolutions(final IssueContext issueContext) {\n\t\tfinal IssueContextProvider provider = new IssueContextProvider() {\n\t\t\tpublic IssueContext getIssueContext() {\n\t\t\t\treturn issueContext;\n\t\t\t}\n\t\t};\n\n\t\tList<Method> fixMethods = getFixMethods(issueContext);\n\t\treturn getResolutions(provider, fixMethods);\n\t}","commit_id":"46ca7831204b83c4ae5a25525b647af022abcbd9","url":"https://github.com/eclipse/xtext"},{"original_method":"protected List<IssueResolution> getResolutions(final IssueContext issueContext, List<Method> fixMethods) {\n\t\treturn Lists.transform(fixMethods, new Function<Method, IssueResolution>() {\n\t\t\tpublic IssueResolution apply(final Method from) {\n\t\t\t\treturn new IssueResolution() {\n\t\t\t\t\tprivate final Fix annotation = from.getAnnotation(Fix.class);\n\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\texecuteFixMethod(from, issueContext);\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic String getLabel() {\n\t\t\t\t\t\treturn annotation.label();\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic String getDescription() {\n\t\t\t\t\t\treturn annotation.description();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpublic String getImage() {\n\t\t\t\t\t\treturn annotation.image();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}","id":26627,"modified_method":"protected List<IssueResolution> getResolutions(final IssueContextProvider provider, List<Method> fixMethods) {\n\t\treturn Lists.transform(fixMethods, new Function<Method, IssueResolution>() {\n\t\t\tpublic IssueResolution apply(final Method from) {\n\t\t\t\treturn new IssueResolution() {\n\t\t\t\t\tprivate final Fix annotation = from.getAnnotation(Fix.class);\n\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\texecuteFixMethod(from, provider.getIssueContext());\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic String getLabel() {\n\t\t\t\t\t\treturn annotation.label();\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic String getDescription() {\n\t\t\t\t\t\treturn annotation.description();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpublic String getImage() {\n\t\t\t\t\t\treturn annotation.image();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}","commit_id":"46ca7831204b83c4ae5a25525b647af022abcbd9","url":"https://github.com/eclipse/xtext"},{"original_method":"private Issue getIssueFromAnnotation(Annotation annotation, IAnnotationModel amodel, IXtextDocument document) {\n\t\t\tif (annotation instanceof XtextAnnotation) {\n\t\t\t\tXtextAnnotation xtextAnnotation = (XtextAnnotation) annotation;\n\t\t\t\treturn xtextAnnotation.getIssue();\n\t\t\t} else if(annotation instanceof MarkerAnnotation) {\n\t\t\t\tMarkerAnnotation markerAnnotation = (MarkerAnnotation)annotation;\n\t\t\t\tIssue.IssueImpl issue = new Issue.IssueImpl();\n\t\t\t\tissue.setMessage(annotation.getText());\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tissue.setLineNumber(document.getLineOfOffset(pos.getOffset()));\n\t\t\t\t\tissue.setOffset(pos.getOffset());\n\t\t\t\t\tissue.setLength(pos.getLength());\n\t\t\t\t} catch (BadLocationException e) {\n\t\t\t\t}\n\n\t\t\t\tissue.setCode(MarkerTypes.getCode(markerAnnotation));\n\t\t\t\tissue.setUriToProblem(getUriToProblem(markerAnnotation));\n\t\t\t\tissue.setSeverity(getSeverityFromMarker(markerAnnotation.getMarker()));\n\t\t\t\t\n\t\t\t\t// Note, isSyntaxError is unset, but currently the api does not allow fixing\n\t\t\t\t// syntax errors anyway.\n\t\t\t\treturn issue;\n\t\t\t} else\n\t\t\t\treturn null;\n\t\t}","id":26628,"modified_method":"private Issue getIssueFromAnnotation(Annotation annotation, IAnnotationModel amodel, IXtextDocument document) {\n\t\t\tif (annotation instanceof XtextAnnotation) {\n\t\t\t\tXtextAnnotation xtextAnnotation = (XtextAnnotation) annotation;\n\t\t\t\treturn xtextAnnotation.getIssue();\n\t\t\t} else if(annotation instanceof MarkerAnnotation) {\n\t\t\t\tMarkerAnnotation markerAnnotation = (MarkerAnnotation)annotation;\n\t\t\t\tIssue.IssueImpl issue = (IssueImpl) IssueUtil.createIssue(markerAnnotation.getMarker());\n\t\t\t\treturn issue;\n\t\t\t} else\n\t\t\t\treturn null;\n\t\t}","commit_id":"46ca7831204b83c4ae5a25525b647af022abcbd9","url":"https://github.com/eclipse/xtext"},{"original_method":"public Image getImage() {\n\t\t\tif(Strings.isEmpty(resolution.getImage()))\n\t\t\t\treturn XtextPluginImages.get(XtextPluginImages.OBJ_CORRECTION_CHANGE);\n\t\t\telse\n\t\t\t\treturn imageHelper.getImage(resolution.getImage());\n\t\t}","id":26629,"modified_method":"public Image getImage() {\n\t\t\treturn IssueUtil.getImage(resolution, imageHelper);\n\t\t}","commit_id":"46ca7831204b83c4ae5a25525b647af022abcbd9","url":"https://github.com/eclipse/xtext"},{"original_method":"@Inject\n\tpublic XtextQuickAssistAssistant(IssueResolutionProvider issueResolutionProvider, IDocumentEditor documentEditor, IImageHelper imageHelper) {\n\t\tsetQuickAssistProcessor(new XtextQuickAssistProcessor(issueResolutionProvider, documentEditor, imageHelper));\n\t\tsetInformationControlCreator(new AbstractReusableInformationControlCreator() {\n\t\t\t@Override\n\t\t\tpublic IInformationControl doCreateInformationControl(Shell parent) {\n\t\t\t\treturn new DefaultInformationControl(parent, (IInformationPresenter) null);\n\t\t\t}\n\t\t});\n\t}","id":26630,"modified_method":"@Inject\n\tpublic XtextQuickAssistAssistant(IssueResolutionProvider issueResolutionProvider, IDocumentEditor documentEditor, IImageHelper imageHelper) {\n\t\tXtextQuickAssistProcessor processor = new XtextQuickAssistProcessor();\n\t\tprocessor.setDocumentEditor(documentEditor);\n\t\tprocessor.setImageHelper(imageHelper);\n\t\tprocessor.setResolutionProvider(issueResolutionProvider);\n\t\tsetQuickAssistProcessor(processor);\n\t\t\n\t\tsetInformationControlCreator(new AbstractReusableInformationControlCreator() {\n\t\t\t@Override\n\t\t\tpublic IInformationControl doCreateInformationControl(Shell parent) {\n\t\t\t\treturn new DefaultInformationControl(parent, (IInformationPresenter) null);\n\t\t\t}\n\t\t});\n\t}","commit_id":"46ca7831204b83c4ae5a25525b647af022abcbd9","url":"https://github.com/eclipse/xtext"},{"original_method":"public ICompletionProposal[] computeQuickAssistProposals(IQuickAssistInvocationContext invocationContext) {\n\t\t\tfinal IDocument d = invocationContext.getSourceViewer().getDocument();\n\t\t\tif(!(d instanceof IXtextDocument))\n\t\t\t\treturn new ICompletionProposal[0];\n\t\t\tfinal IXtextDocument document = (IXtextDocument)d;\n\t\t\t\n\t\t\tfinal IAnnotationModel amodel = invocationContext.getSourceViewer().getAnnotationModel();\n\t\t\t\n\t\t\tList<ICompletionProposal> result = new ArrayList<ICompletionProposal>();\n\t\t\tfinal int offset = invocationContext.getOffset();\n\t\t\tfor (Iterator<?> it = amodel.getAnnotationIterator(); it.hasNext();) {\n\t\t\t\tObject key = it.next();\n\t\t\t\tif(!(key instanceof Annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tAnnotation annotation = (Annotation) key;\n\t\t\t\tif(!canFix(annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tfinal Issue issue = getIssueFromAnnotation(annotation, amodel, document);\n\t\t\t\tif(issue == null)\n\t\t\t\t\tcontinue;\n\t\t\n\t\t\t\tIterable<IssueResolution> resolutions = getResolutions(issue, document);\n\t\t\t\tif(!resolutions.iterator().hasNext())\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tint line = document.getLineOfOffset(pos.getOffset());\n\t\t\t\t\tint start = pos.getOffset();\n\t\t\t\t\tString delim = document.getLineDelimiter(line);\n\t\t\t\t\tint delimLength = delim != null ? delim.length() : 0;\n\t\t\t\t\tint end = document.getLineLength(line) + start - delimLength;\n\t\t\t\t\tif (offset >= start && offset <= end) {\n\t\t\t\t\t\tfor(IssueResolution resolution : resolutions)\n\t\t\t\t\t\t\tresult.add(new XtextCompletionProposal(pos, resolution, imageHelper));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (BadLocationException e) {\n\t\t\t\t\terrorMessage = e.getMessage();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.toArray(new ICompletionProposal[result.size()]);\n\t\t}","id":26631,"modified_method":"public ICompletionProposal[] computeQuickAssistProposals(IQuickAssistInvocationContext invocationContext) {\n\t\t\tfinal IDocument d = invocationContext.getSourceViewer().getDocument();\n\t\t\tif(!(d instanceof IXtextDocument))\n\t\t\t\treturn new ICompletionProposal[0];\n\t\t\tfinal IXtextDocument document = (IXtextDocument)d;\n\t\t\t\n\t\t\tfinal IAnnotationModel amodel = invocationContext.getSourceViewer().getAnnotationModel();\n\t\t\t\n\t\t\tList<ICompletionProposal> result = new ArrayList<ICompletionProposal>();\n\t\t\tfinal int offset = invocationContext.getOffset();\n\t\t\tfor (Iterator<?> it = amodel.getAnnotationIterator(); it.hasNext();) {\n\t\t\t\tObject key = it.next();\n\t\t\t\tif(!(key instanceof Annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tAnnotation annotation = (Annotation) key;\n\t\t\t\tif(!canFix(annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tfinal Issue issue = getIssueFromAnnotation(annotation, amodel, document);\n\t\t\t\tif(issue == null)\n\t\t\t\t\tcontinue;\n\t\t\n\t\t\t\tIterable<IssueResolution> resolutions = getResolutions(issue, document);\n\t\t\t\tif(!resolutions.iterator().hasNext())\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tint line = document.getLineOfOffset(pos.getOffset());\n\t\t\t\t\tint start = pos.getOffset();\n\t\t\t\t\tString delim = document.getLineDelimiter(line);\n\t\t\t\t\tint delimLength = delim != null ? delim.length() : 0;\n\t\t\t\t\tint end = document.getLineLength(line) + start - delimLength;\n\t\t\t\t\tif (offset >= start && offset <= end) {\n\t\t\t\t\t\tfor(IssueResolution resolution : resolutions)\n\t\t\t\t\t\t\tresult.add(new XtextCompletionProposal(pos, resolution, getImageHelper()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (BadLocationException e) {\n\t\t\t\t\terrorMessage = e.getMessage();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.toArray(new ICompletionProposal[result.size()]);\n\t\t}","commit_id":"46ca7831204b83c4ae5a25525b647af022abcbd9","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean canFix(Annotation annotation) {\n\t\t\tif (annotation.isMarkedDeleted())\n\t\t\t\treturn false;\n\t\t\t\n\t\t\t// non-persisted annotation\n\t\t\tif (annotation instanceof XtextAnnotation) {\n\t\t\t\tXtextAnnotation a = (XtextAnnotation) annotation;\n\t\t\t\treturn issueResolutionProvider.hasResolutionFor(a.getIssueCode());\n\t\t\t}\n\t\t\t\n\t\t\t// persisted markerAnnotation\n\t\t\tif (annotation instanceof MarkerAnnotation) {\n\t\t\t\tMarkerAnnotation markerAnnotation = (MarkerAnnotation) annotation;\n\t\t\t\tif (markerAnnotation.isQuickFixableStateSet())\n\t\t\t\t\treturn markerAnnotation.isQuickFixable();\n\t\t\t\t\n\t\t\t\t\n//\t\t\t\t// TODO: register helper at org.eclipse.ui.markerhelp and org.eclipse.ui.markerresolution\n//\t\t\t\t// that scans for IssueCode-Attribute, see MarkerHelpRegistry\n\t\t\t\t// BUT: has to produce proper Resolutions as well\n//\t\t\t\tfinal IMarker marker = markerAnnotation.getMarker();\n//\t\t\t\tboolean canFix = IDE.getMarkerHelpRegistry().hasResolutions(marker);\n//\t\t\t\t\n//\t\t\t\tif (canFix) {\n//\t\t\t\t\tfinal IMarkerResolution[] contributedResolutions = IDE.getMarkerHelpRegistry().getResolutions(marker);\n//\t\t\t\t\tcanFix = contributedResolutions.length > 0;\n//\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean canFix = issueResolutionProvider.hasResolutionFor(MarkerTypes.getCode(markerAnnotation));\n\t\t\t\t\n\t\t\t\tif (!markerAnnotation.isQuickFixableStateSet())\n\t\t\t\t\tmarkerAnnotation.setQuickFixable(canFix);\n\t\n\t\t\t\treturn canFix;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}","id":26632,"modified_method":"public boolean canFix(Annotation annotation) {\n\t\t\tif (annotation.isMarkedDeleted())\n\t\t\t\treturn false;\n\t\t\t\n\t\t\t// non-persisted annotation\n\t\t\tif (annotation instanceof XtextAnnotation) {\n\t\t\t\tXtextAnnotation a = (XtextAnnotation) annotation;\n\t\t\t\treturn getResolutionProvider().hasResolutionFor(a.getIssueCode());\n\t\t\t}\n\t\t\t\n\t\t\t// persisted markerAnnotation\n\t\t\tif (annotation instanceof MarkerAnnotation) {\n\t\t\t\tMarkerAnnotation markerAnnotation = (MarkerAnnotation) annotation;\n\t\t\t\tif (!markerAnnotation.isQuickFixableStateSet())\n\t\t\t\t\tmarkerAnnotation.setQuickFixable(getResolutionProvider().hasResolutionFor(MarkerUtil.getCode(markerAnnotation)));\n\t\t\t\t\n\t\t\t\treturn markerAnnotation.isQuickFixable();\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}","commit_id":"46ca7831204b83c4ae5a25525b647af022abcbd9","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected MarkerAnnotation createMarkerAnnotation(IMarker marker) {\n\t\tMarkerAnnotation annotation = super.createMarkerAnnotation(marker);\n\t\tString issueCode = MarkerTypes.getCode(annotation);\n\t\tannotation.setQuickFixable(issueResolutionProvider.hasResolutionFor(issueCode));\n\t\treturn annotation;\n\t}","id":26633,"modified_method":"@Override\n\tprotected MarkerAnnotation createMarkerAnnotation(IMarker marker) {\n\t\tMarkerAnnotation annotation = super.createMarkerAnnotation(marker);\n\t\tString issueCode = MarkerUtil.getCode(annotation);\n\t\tannotation.setQuickFixable(issueResolutionProvider.hasResolutionFor(issueCode));\n\t\treturn annotation;\n\t}","commit_id":"46ca7831204b83c4ae5a25525b647af022abcbd9","url":"https://github.com/eclipse/xtext"},{"original_method":"protected List<IssueResolution> getResolutions(final IssueContext issueContext, List<Method> fixMethods) {\n\t\treturn Lists.transform(fixMethods, new Function<Method, IssueResolution>() {\n\t\t\tpublic IssueResolution apply(final Method from) {\n\t\t\t\treturn new IssueResolution() {\n\t\t\t\t\tprivate final Fix annotation = from.getAnnotation(Fix.class);\n\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\texecuteFixMethod(from, issueContext);\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic String getLabel() {\n\t\t\t\t\t\treturn annotation.label();\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic String getDescription() {\n\t\t\t\t\t\treturn annotation.description();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpublic String getImage() {\n\t\t\t\t\t\treturn annotation.image();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}","id":26634,"modified_method":"protected List<IssueResolution> getResolutions(final IssueContextProvider provider, List<Method> fixMethods) {\n\t\treturn Lists.transform(fixMethods, new Function<Method, IssueResolution>() {\n\t\t\tpublic IssueResolution apply(final Method from) {\n\t\t\t\treturn new IssueResolution() {\n\t\t\t\t\tprivate final Fix annotation = from.getAnnotation(Fix.class);\n\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\texecuteFixMethod(from, provider.getIssueContext());\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic String getLabel() {\n\t\t\t\t\t\treturn annotation.label();\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic String getDescription() {\n\t\t\t\t\t\treturn annotation.description();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpublic String getImage() {\n\t\t\t\t\t\treturn annotation.image();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}","commit_id":"bb1f3f619f22c88b5f41da1fe41e1d6f6301e41e","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<IssueResolution> getResolutions(IssueContext issueContext) {\n\t\tList<Method> fixMethods = getFixMethods(issueContext);\n\t\treturn getResolutions(issueContext, fixMethods);\n\t}","id":26635,"modified_method":"public List<IssueResolution> getResolutions(final IssueContext issueContext) {\n\t\tfinal IssueContextProvider provider = new IssueContextProvider() {\n\t\t\tpublic IssueContext getIssueContext() {\n\t\t\t\treturn issueContext;\n\t\t\t}\n\t\t};\n\n\t\tList<Method> fixMethods = getFixMethods(issueContext);\n\t\treturn getResolutions(provider, fixMethods);\n\t}","commit_id":"bb1f3f619f22c88b5f41da1fe41e1d6f6301e41e","url":"https://github.com/eclipse/xtext"},{"original_method":"private Issue getIssueFromAnnotation(Annotation annotation, IAnnotationModel amodel, IXtextDocument document) {\n\t\t\tif (annotation instanceof XtextAnnotation) {\n\t\t\t\tXtextAnnotation xtextAnnotation = (XtextAnnotation) annotation;\n\t\t\t\treturn xtextAnnotation.getIssue();\n\t\t\t} else if(annotation instanceof MarkerAnnotation) {\n\t\t\t\tMarkerAnnotation markerAnnotation = (MarkerAnnotation)annotation;\n\t\t\t\tIssue.IssueImpl issue = new Issue.IssueImpl();\n\t\t\t\tissue.setMessage(annotation.getText());\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tissue.setLineNumber(document.getLineOfOffset(pos.getOffset()));\n\t\t\t\t\tissue.setOffset(pos.getOffset());\n\t\t\t\t\tissue.setLength(pos.getLength());\n\t\t\t\t} catch (BadLocationException e) {\n\t\t\t\t}\n\n\t\t\t\tissue.setCode(MarkerTypes.getCode(markerAnnotation));\n\t\t\t\tissue.setUriToProblem(getUriToProblem(markerAnnotation));\n\t\t\t\tissue.setSeverity(getSeverityFromMarker(markerAnnotation.getMarker()));\n\t\t\t\t\n\t\t\t\t// Note, isSyntaxError is unset, but currently the api does not allow fixing\n\t\t\t\t// syntax errors anyway.\n\t\t\t\treturn issue;\n\t\t\t} else\n\t\t\t\treturn null;\n\t\t}","id":26636,"modified_method":"private Issue getIssueFromAnnotation(Annotation annotation, IAnnotationModel amodel, IXtextDocument document) {\n\t\t\tif (annotation instanceof XtextAnnotation) {\n\t\t\t\tXtextAnnotation xtextAnnotation = (XtextAnnotation) annotation;\n\t\t\t\treturn xtextAnnotation.getIssue();\n\t\t\t} else if(annotation instanceof MarkerAnnotation) {\n\t\t\t\tMarkerAnnotation markerAnnotation = (MarkerAnnotation)annotation;\n\t\t\t\tIssue.IssueImpl issue = (IssueImpl) IssueUtil.createIssue(markerAnnotation.getMarker());\n\t\t\t\treturn issue;\n\t\t\t} else\n\t\t\t\treturn null;\n\t\t}","commit_id":"bb1f3f619f22c88b5f41da1fe41e1d6f6301e41e","url":"https://github.com/eclipse/xtext"},{"original_method":"public ICompletionProposal[] computeQuickAssistProposals(IQuickAssistInvocationContext invocationContext) {\n\t\t\tfinal IDocument d = invocationContext.getSourceViewer().getDocument();\n\t\t\tif(!(d instanceof IXtextDocument))\n\t\t\t\treturn new ICompletionProposal[0];\n\t\t\tfinal IXtextDocument document = (IXtextDocument)d;\n\t\t\t\n\t\t\tfinal IAnnotationModel amodel = invocationContext.getSourceViewer().getAnnotationModel();\n\t\t\t\n\t\t\tList<ICompletionProposal> result = new ArrayList<ICompletionProposal>();\n\t\t\tfinal int offset = invocationContext.getOffset();\n\t\t\tfor (Iterator<?> it = amodel.getAnnotationIterator(); it.hasNext();) {\n\t\t\t\tObject key = it.next();\n\t\t\t\tif(!(key instanceof Annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tAnnotation annotation = (Annotation) key;\n\t\t\t\tif(!canFix(annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tfinal Issue issue = getIssueFromAnnotation(annotation, amodel, document);\n\t\t\t\tif(issue == null)\n\t\t\t\t\tcontinue;\n\t\t\n\t\t\t\tIterable<IssueResolution> resolutions = getResolutions(issue, document);\n\t\t\t\tif(!resolutions.iterator().hasNext())\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tint line = document.getLineOfOffset(pos.getOffset());\n\t\t\t\t\tint start = pos.getOffset();\n\t\t\t\t\tString delim = document.getLineDelimiter(line);\n\t\t\t\t\tint delimLength = delim != null ? delim.length() : 0;\n\t\t\t\t\tint end = document.getLineLength(line) + start - delimLength;\n\t\t\t\t\tif (offset >= start && offset <= end) {\n\t\t\t\t\t\tfor(IssueResolution resolution : resolutions)\n\t\t\t\t\t\t\tresult.add(new XtextCompletionProposal(pos, resolution, imageHelper));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (BadLocationException e) {\n\t\t\t\t\terrorMessage = e.getMessage();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.toArray(new ICompletionProposal[result.size()]);\n\t\t}","id":26637,"modified_method":"public ICompletionProposal[] computeQuickAssistProposals(IQuickAssistInvocationContext invocationContext) {\n\t\t\tfinal IDocument d = invocationContext.getSourceViewer().getDocument();\n\t\t\tif(!(d instanceof IXtextDocument))\n\t\t\t\treturn new ICompletionProposal[0];\n\t\t\tfinal IXtextDocument document = (IXtextDocument)d;\n\t\t\t\n\t\t\tfinal IAnnotationModel amodel = invocationContext.getSourceViewer().getAnnotationModel();\n\t\t\t\n\t\t\tList<ICompletionProposal> result = new ArrayList<ICompletionProposal>();\n\t\t\tfinal int offset = invocationContext.getOffset();\n\t\t\tfor (Iterator<?> it = amodel.getAnnotationIterator(); it.hasNext();) {\n\t\t\t\tObject key = it.next();\n\t\t\t\tif(!(key instanceof Annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tAnnotation annotation = (Annotation) key;\n\t\t\t\tif(!canFix(annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tfinal Issue issue = getIssueFromAnnotation(annotation, amodel, document);\n\t\t\t\tif(issue == null)\n\t\t\t\t\tcontinue;\n\t\t\n\t\t\t\tIterable<IssueResolution> resolutions = getResolutions(issue, document);\n\t\t\t\tif(!resolutions.iterator().hasNext())\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tint line = document.getLineOfOffset(pos.getOffset());\n\t\t\t\t\tint start = pos.getOffset();\n\t\t\t\t\tString delim = document.getLineDelimiter(line);\n\t\t\t\t\tint delimLength = delim != null ? delim.length() : 0;\n\t\t\t\t\tint end = document.getLineLength(line) + start - delimLength;\n\t\t\t\t\tif (offset >= start && offset <= end) {\n\t\t\t\t\t\tfor(IssueResolution resolution : resolutions)\n\t\t\t\t\t\t\tresult.add(new XtextCompletionProposal(pos, resolution, getImageHelper()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (BadLocationException e) {\n\t\t\t\t\terrorMessage = e.getMessage();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.toArray(new ICompletionProposal[result.size()]);\n\t\t}","commit_id":"bb1f3f619f22c88b5f41da1fe41e1d6f6301e41e","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean canFix(Annotation annotation) {\n\t\t\tif (annotation.isMarkedDeleted())\n\t\t\t\treturn false;\n\t\t\t\n\t\t\t// non-persisted annotation\n\t\t\tif (annotation instanceof XtextAnnotation) {\n\t\t\t\tXtextAnnotation a = (XtextAnnotation) annotation;\n\t\t\t\treturn issueResolutionProvider.hasResolutionFor(a.getIssueCode());\n\t\t\t}\n\t\t\t\n\t\t\t// persisted markerAnnotation\n\t\t\tif (annotation instanceof MarkerAnnotation) {\n\t\t\t\tMarkerAnnotation markerAnnotation = (MarkerAnnotation) annotation;\n\t\t\t\tif (markerAnnotation.isQuickFixableStateSet())\n\t\t\t\t\treturn markerAnnotation.isQuickFixable();\n\t\t\t\t\n\t\t\t\t\n//\t\t\t\t// TODO: register helper at org.eclipse.ui.markerhelp and org.eclipse.ui.markerresolution\n//\t\t\t\t// that scans for IssueCode-Attribute, see MarkerHelpRegistry\n\t\t\t\t// BUT: has to produce proper Resolutions as well\n//\t\t\t\tfinal IMarker marker = markerAnnotation.getMarker();\n//\t\t\t\tboolean canFix = IDE.getMarkerHelpRegistry().hasResolutions(marker);\n//\t\t\t\t\n//\t\t\t\tif (canFix) {\n//\t\t\t\t\tfinal IMarkerResolution[] contributedResolutions = IDE.getMarkerHelpRegistry().getResolutions(marker);\n//\t\t\t\t\tcanFix = contributedResolutions.length > 0;\n//\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean canFix = issueResolutionProvider.hasResolutionFor(MarkerTypes.getCode(markerAnnotation));\n\t\t\t\t\n\t\t\t\tif (!markerAnnotation.isQuickFixableStateSet())\n\t\t\t\t\tmarkerAnnotation.setQuickFixable(canFix);\n\t\n\t\t\t\treturn canFix;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}","id":26638,"modified_method":"public boolean canFix(Annotation annotation) {\n\t\t\tif (annotation.isMarkedDeleted())\n\t\t\t\treturn false;\n\t\t\t\n\t\t\t// non-persisted annotation\n\t\t\tif (annotation instanceof XtextAnnotation) {\n\t\t\t\tXtextAnnotation a = (XtextAnnotation) annotation;\n\t\t\t\treturn getResolutionProvider().hasResolutionFor(a.getIssueCode());\n\t\t\t}\n\t\t\t\n\t\t\t// persisted markerAnnotation\n\t\t\tif (annotation instanceof MarkerAnnotation) {\n\t\t\t\tMarkerAnnotation markerAnnotation = (MarkerAnnotation) annotation;\n\t\t\t\tif (!markerAnnotation.isQuickFixableStateSet())\n\t\t\t\t\tmarkerAnnotation.setQuickFixable(getResolutionProvider().hasResolutionFor(MarkerUtil.getCode(markerAnnotation)));\n\t\t\t\t\n\t\t\t\treturn markerAnnotation.isQuickFixable();\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}","commit_id":"bb1f3f619f22c88b5f41da1fe41e1d6f6301e41e","url":"https://github.com/eclipse/xtext"},{"original_method":"@Inject\n\tpublic XtextQuickAssistAssistant(IssueResolutionProvider issueResolutionProvider, IDocumentEditor documentEditor, IImageHelper imageHelper) {\n\t\tsetQuickAssistProcessor(new XtextQuickAssistProcessor(issueResolutionProvider, documentEditor, imageHelper));\n\t\tsetInformationControlCreator(new AbstractReusableInformationControlCreator() {\n\t\t\t@Override\n\t\t\tpublic IInformationControl doCreateInformationControl(Shell parent) {\n\t\t\t\treturn new DefaultInformationControl(parent, (IInformationPresenter) null);\n\t\t\t}\n\t\t});\n\t}","id":26639,"modified_method":"@Inject\n\tpublic XtextQuickAssistAssistant(IssueResolutionProvider issueResolutionProvider, IDocumentEditor documentEditor, IImageHelper imageHelper) {\n\t\tXtextQuickAssistProcessor processor = new XtextQuickAssistProcessor();\n\t\tprocessor.setDocumentEditor(documentEditor);\n\t\tprocessor.setImageHelper(imageHelper);\n\t\tprocessor.setResolutionProvider(issueResolutionProvider);\n\t\tsetQuickAssistProcessor(processor);\n\t\t\n\t\tsetInformationControlCreator(new AbstractReusableInformationControlCreator() {\n\t\t\t@Override\n\t\t\tpublic IInformationControl doCreateInformationControl(Shell parent) {\n\t\t\t\treturn new DefaultInformationControl(parent, (IInformationPresenter) null);\n\t\t\t}\n\t\t});\n\t}","commit_id":"bb1f3f619f22c88b5f41da1fe41e1d6f6301e41e","url":"https://github.com/eclipse/xtext"},{"original_method":"public Image getImage() {\n\t\t\tif(Strings.isEmpty(resolution.getImage()))\n\t\t\t\treturn XtextPluginImages.get(XtextPluginImages.OBJ_CORRECTION_CHANGE);\n\t\t\telse\n\t\t\t\treturn imageHelper.getImage(resolution.getImage());\n\t\t}","id":26640,"modified_method":"public Image getImage() {\n\t\t\treturn IssueUtil.getImage(resolution, imageHelper);\n\t\t}","commit_id":"bb1f3f619f22c88b5f41da1fe41e1d6f6301e41e","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected MarkerAnnotation createMarkerAnnotation(IMarker marker) {\n\t\tMarkerAnnotation annotation = super.createMarkerAnnotation(marker);\n\t\tString issueCode = MarkerTypes.getCode(annotation);\n\t\tannotation.setQuickFixable(issueResolutionProvider.hasResolutionFor(issueCode));\n\t\treturn annotation;\n\t}","id":26641,"modified_method":"@Override\n\tprotected MarkerAnnotation createMarkerAnnotation(IMarker marker) {\n\t\tMarkerAnnotation annotation = super.createMarkerAnnotation(marker);\n\t\tString issueCode = MarkerUtil.getCode(annotation);\n\t\tannotation.setQuickFixable(issueResolutionProvider.hasResolutionFor(issueCode));\n\t\treturn annotation;\n\t}","commit_id":"bb1f3f619f22c88b5f41da1fe41e1d6f6301e41e","url":"https://github.com/eclipse/xtext"},{"original_method":"private int getJavaLineNumber(final IJavaStratumLineBreakpoint breakpoint) throws CoreException {\n\t\tIResource storage = breakpoint.getMarker().getResource();\n\t\tITrace javaTrace = traceForStorageProvider.getTraceToTarget((IStorage) storage);\n\t\tif (javaTrace == null)\n\t\t\treturn -1;\n\t\tTextRegion textRegion = new TextRegion(breakpoint.getCharStart(), 0);\n\t\tILocationInResource javaLocation = javaTrace.getBestAssociatedLocation(textRegion);\n\t\tif (javaLocation == null)\n\t\t\treturn -1;\n\t\tAbstractTrace sourceTrace = (AbstractTrace) traceForStorageProvider.getTraceToSource(javaLocation.getStorage());\n\t\tif (sourceTrace == null)\n\t\t\treturn -1;\n\t\tAbstractTraceRegion rootTraceRegion = sourceTrace.getRootTraceRegion();\n\t\tif (rootTraceRegion == null)\n\t\t\treturn -1;\n\t\tList<LineMapping> lineMappings = lineMappingProvider.getLineMapping(rootTraceRegion);\n\t\tfor (LineMapping lineMapping : lineMappings) {\n\t\t\tif (lineMapping.sourceStartLine == breakpoint.getLineNumber()) {\n\t\t\t\treturn lineMapping.targetEndLine + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}","id":26642,"modified_method":"private int getJavaLineNumber(final IJavaStratumLineBreakpoint breakpoint) throws CoreException {\n\t\tURI uri = URI.createURI((String) breakpoint.getMarker().getAttribute(StratumBreakpointAdapterFactory.ORG_ECLIPSE_XTEXT_XBASE_SOURCE_URI));\n\t\tPair<IStorage, IProject> storage = Iterables.getFirst(storage2UriMapper.getStorages(uri), null);\n\t\tif (storage == null)\n\t\t\treturn -1;\n\t\tITrace javaTrace = traceForStorageProvider.getTraceToTarget(storage.getFirst());\n\t\tif (javaTrace == null)\n\t\t\treturn -1;\n\t\tTextRegion textRegion = new TextRegion(breakpoint.getCharStart(), 0);\n\t\tILocationInResource javaLocation = javaTrace.getBestAssociatedLocation(textRegion);\n\t\tif (javaLocation == null)\n\t\t\treturn -1;\n\t\tAbstractTrace sourceTrace = (AbstractTrace) traceForStorageProvider.getTraceToSource(javaLocation.getStorage());\n\t\tif (sourceTrace == null)\n\t\t\treturn -1;\n\t\tAbstractTraceRegion rootTraceRegion = sourceTrace.getRootTraceRegion();\n\t\tif (rootTraceRegion == null)\n\t\t\treturn -1;\n\t\tList<LineMapping> lineMappings = lineMappingProvider.getLineMapping(rootTraceRegion);\n\t\tfor (LineMapping lineMapping : lineMappings) {\n\t\t\tif (lineMapping.sourceStartLine == breakpoint.getLineNumber()) {\n\t\t\t\treturn lineMapping.targetEndLine + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}","commit_id":"4616b0d237d92ec0037496e91e8d80da0f94a5fb","url":"https://github.com/eclipse/xtext"},{"original_method":"private String getHandleId(final IJavaStratumLineBreakpoint breakpoint) throws CoreException {\n\t\tIResource storage = breakpoint.getMarker().getResource();\n\t\tResourceSet resourceSet = resourceSetProvider.get(storage.getProject());\n\t\tURI uri = storage2UriMapper.getUri((IStorage) storage);\n\t\tResource resource = resourceSet.getResource(uri, true);\n\t\tresource.getContents();\n\t\tEObject sourceObject = eObjectAtOffsetHelper.resolveContainedElementAt((XtextResource) resource, breakpoint.getCharStart());\n\t\tEObject primaryJvmElement = null;\n\t\twhile (primaryJvmElement == null && sourceObject != null) {\n\t\t\tprimaryJvmElement = jvmModelAssociations.getPrimaryJvmElement(sourceObject);\n\t\t\tsourceObject = sourceObject.eContainer();\n\t\t}\n\t\tJvmType jvmType = EcoreUtil2.getContainerOfType(primaryJvmElement, JvmType.class);\n\t\tIJavaElement javaElement = javaElementFinder.findElementFor(jvmType);\n\t\treturn javaElement == null? null : javaElement.getHandleIdentifier();\n\t}","id":26643,"modified_method":"private String getHandleId(final IJavaStratumLineBreakpoint breakpoint) throws CoreException {\n\t\tIMarker marker = breakpoint.getMarker();\n\t\tIResource storage = marker.getResource();\n\t\tResourceSet resourceSet = resourceSetProvider.get(storage.getProject());\n\t\tURI uri = URI.createURI((String) marker.getAttribute(StratumBreakpointAdapterFactory.ORG_ECLIPSE_XTEXT_XBASE_SOURCE_URI));\n\t\tResource resource = resourceSet.getResource(uri, true);\n\t\tresource.getContents();\n\t\tEObject sourceObject = eObjectAtOffsetHelper.resolveContainedElementAt((XtextResource) resource, breakpoint.getCharStart());\n\t\tEObject primaryJvmElement = null;\n\t\twhile (primaryJvmElement == null && sourceObject != null) {\n\t\t\tprimaryJvmElement = jvmModelAssociations.getPrimaryJvmElement(sourceObject);\n\t\t\tsourceObject = sourceObject.eContainer();\n\t\t}\n\t\tJvmType jvmType = EcoreUtil2.getContainerOfType(primaryJvmElement, JvmType.class);\n\t\tIJavaElement javaElement = javaElementFinder.findElementFor(jvmType);\n\t\treturn javaElement == null? null : javaElement.getHandleIdentifier();\n\t}","commit_id":"4616b0d237d92ec0037496e91e8d80da0f94a5fb","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n    public void testRequestWithRawClose() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"GET / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        TLSRecord record = proxy.readFromClient();\n        proxy.flushToServer(record);\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n\n        // Close the raw socket\n        // This generates a truncation attack, and we cannot respond\n        // because we won't know if the request was legitimate\n        proxy.flushToServer((TLSRecord)null);\n\n        // Expect raw close from server\n        record = proxy.readFromServer();\n        Assert.assertNull(record);\n        proxy.flushToClient(record);\n\n        client.close();\n    }","id":26644,"modified_method":"@Test\n    public void testRequestWithRawClose() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"GET / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        TLSRecord record = proxy.readFromClient();\n        proxy.flushToServer(record);\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n\n        // Close the raw socket\n        // This generates a truncation attack, and we cannot respond\n        // because we won't know if the request was legitimate\n        proxy.flushToServer((TLSRecord)null);\n\n        // Expect raw close from server\n        record = proxy.readFromServer();\n        Assert.assertNull(\"\" + record, record);\n        proxy.flushToClient(record);\n\n        client.close();\n    }","commit_id":"9c804921de475f55f71aaf7ac870e49ccc7dbef0","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testHandshakeAndRequestOneByteAtATime() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        Future<Object> handshake = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                client.startHandshake();\n                return null;\n            }\n        });\n\n        // Client Hello\n        TLSRecord record = proxy.readFromClient();\n        for (byte b : record.getBytes())\n        {\n            proxy.flushToServer(b);\n            TimeUnit.MILLISECONDS.sleep(50);\n        }\n\n        // Server Hello + Certificate + Server Done\n        record = proxy.readFromServer();\n        proxy.flushToClient(record);\n\n        // Client Key Exchange\n        record = proxy.readFromClient();\n        for (byte b : record.getBytes())\n        {\n            proxy.flushToServer(b);\n            TimeUnit.MILLISECONDS.sleep(50);\n        }\n\n        // Change Cipher Spec\n        record = proxy.readFromClient();\n        for (byte b : record.getBytes())\n        {\n            proxy.flushToServer(b);\n            TimeUnit.MILLISECONDS.sleep(50);\n        }\n\n        // Client Done\n        record = proxy.readFromClient();\n        for (byte b : record.getBytes())\n        {\n            proxy.flushToServer(b);\n            TimeUnit.MILLISECONDS.sleep(50);\n        }\n\n        // Change Cipher Spec\n        record = proxy.readFromServer();\n        proxy.flushToClient(record);\n\n        // Server Done\n        record = proxy.readFromServer();\n        proxy.flushToClient(record);\n\n        Assert.assertNull(handshake.get(5, TimeUnit.SECONDS));\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"GET / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        record = proxy.readFromClient();\n        for (byte b : record.getBytes())\n        {\n            proxy.flushToServer(b);\n            TimeUnit.MILLISECONDS.sleep(50);\n        }\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n\n        // Application data\n        record = proxy.readFromServer();\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream(), \"UTF-8\"));\n        String line = reader.readLine();\n        Assert.assertNotNull(line);\n        Assert.assertTrue(line.contains(\" 200 \"));\n        while ((line = reader.readLine()) != null)\n        {\n            if (line.trim().length() == 0)\n                break;\n        }\n\n        client.close();\n\n        // Close Alert\n        record = proxy.readFromClient();\n        for (byte b : record.getBytes())\n        {\n            proxy.flushToServer(b);\n            TimeUnit.MILLISECONDS.sleep(50);\n        }\n        // Socket close\n        record = proxy.readFromClient();\n        Assert.assertNull(record);\n        proxy.flushToServer(record);\n\n        // Close Alert\n        record = proxy.readFromServer();\n        proxy.flushToClient(record);\n        // Socket close\n        record = proxy.readFromServer();\n        Assert.assertNull(record);\n        proxy.flushToClient(record);\n    }","id":26645,"modified_method":"@Test\n    public void testHandshakeAndRequestOneByteAtATime() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        Future<Object> handshake = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                client.startHandshake();\n                return null;\n            }\n        });\n\n        // Client Hello\n        TLSRecord record = proxy.readFromClient();\n        for (byte b : record.getBytes())\n        {\n            proxy.flushToServer(b);\n            TimeUnit.MILLISECONDS.sleep(50);\n        }\n\n        // Server Hello + Certificate + Server Done\n        record = proxy.readFromServer();\n        proxy.flushToClient(record);\n\n        // Client Key Exchange\n        record = proxy.readFromClient();\n        for (byte b : record.getBytes())\n        {\n            proxy.flushToServer(b);\n            TimeUnit.MILLISECONDS.sleep(50);\n        }\n\n        // Change Cipher Spec\n        record = proxy.readFromClient();\n        for (byte b : record.getBytes())\n        {\n            proxy.flushToServer(b);\n            TimeUnit.MILLISECONDS.sleep(50);\n        }\n\n        // Client Done\n        record = proxy.readFromClient();\n        for (byte b : record.getBytes())\n        {\n            proxy.flushToServer(b);\n            TimeUnit.MILLISECONDS.sleep(50);\n        }\n\n        // Change Cipher Spec\n        record = proxy.readFromServer();\n        proxy.flushToClient(record);\n\n        // Server Done\n        record = proxy.readFromServer();\n        proxy.flushToClient(record);\n\n        Assert.assertNull(handshake.get(5, TimeUnit.SECONDS));\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"GET / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        record = proxy.readFromClient();\n        for (byte b : record.getBytes())\n        {\n            proxy.flushToServer(b);\n            TimeUnit.MILLISECONDS.sleep(50);\n        }\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n\n        // Application data\n        record = proxy.readFromServer();\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream(), \"UTF-8\"));\n        String line = reader.readLine();\n        Assert.assertNotNull(line);\n        Assert.assertTrue(line.startsWith(\"HTTP/1.1 200 \"));\n        while ((line = reader.readLine()) != null)\n        {\n            if (line.trim().length() == 0)\n                break;\n        }\n\n        // Check that we did not spin\n        Assert.assertThat(sslHandles.get(), lessThan(500));\n        Assert.assertThat(httpParses.get(), lessThan(150));\n\n        client.close();\n\n        // Close Alert\n        record = proxy.readFromClient();\n        for (byte b : record.getBytes())\n        {\n            proxy.flushToServer(b);\n            TimeUnit.MILLISECONDS.sleep(50);\n        }\n        // Socket close\n        record = proxy.readFromClient();\n        Assert.assertNull(\"\" + record, record);\n        proxy.flushToServer(record);\n\n        // Close Alert\n        record = proxy.readFromServer();\n        proxy.flushToClient(record);\n        // Socket close\n        record = proxy.readFromServer();\n        Assert.assertNull(\"\" + record, record);\n        proxy.flushToClient(record);\n    }","commit_id":"9c804921de475f55f71aaf7ac870e49ccc7dbef0","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testRequestWithCloseAlertWithSplitBoundary() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"GET / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        TLSRecord dataRecord = proxy.readFromClient();\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n\n        client.close();\n\n        // Close Alert\n        TLSRecord closeRecord = proxy.readFromClient();\n\n        // Send request and half of the close alert bytes\n        byte[] dataBytes = dataRecord.getBytes();\n        byte[] closeBytes = closeRecord.getBytes();\n        byte[] bytes = new byte[dataBytes.length + closeBytes.length / 2];\n        System.arraycopy(dataBytes, 0, bytes, 0, dataBytes.length);\n        System.arraycopy(closeBytes, 0, bytes, dataBytes.length, closeBytes.length / 2);\n        proxy.flushToServer(bytes);\n\n        TimeUnit.MILLISECONDS.sleep(100);\n\n        bytes = new byte[closeBytes.length - closeBytes.length / 2];\n        System.arraycopy(closeBytes, closeBytes.length / 2, bytes, 0, bytes.length);\n        proxy.flushToServer(bytes);\n\n        // Do not close the raw socket yet\n\n        // Expect response from server\n        // SSLSocket is limited and we cannot read the response, but we make sure\n        // it is application data and not a close alert\n        TLSRecord record = proxy.readFromServer();\n        Assert.assertNotNull(record);\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        // Close Alert\n        record = proxy.readFromServer();\n        Assert.assertNotNull(record);\n        Assert.assertEquals(TLSRecord.Type.ALERT, record.getType());\n        // We can't forward to the client, its socket is already closed\n\n        // Socket close\n        record = proxy.readFromClient();\n        Assert.assertNull(record);\n        proxy.flushToServer(record);\n\n        // Socket close\n        record = proxy.readFromServer();\n        Assert.assertNull(record);\n        proxy.flushToClient(record);\n    }","id":26646,"modified_method":"@Test\n    public void testRequestWithCloseAlertWithSplitBoundary() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"GET / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        TLSRecord dataRecord = proxy.readFromClient();\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n\n        client.close();\n\n        // Close Alert\n        TLSRecord closeRecord = proxy.readFromClient();\n\n        // Send request and half of the close alert bytes\n        byte[] dataBytes = dataRecord.getBytes();\n        byte[] closeBytes = closeRecord.getBytes();\n        byte[] bytes = new byte[dataBytes.length + closeBytes.length / 2];\n        System.arraycopy(dataBytes, 0, bytes, 0, dataBytes.length);\n        System.arraycopy(closeBytes, 0, bytes, dataBytes.length, closeBytes.length / 2);\n        proxy.flushToServer(bytes);\n\n        TimeUnit.MILLISECONDS.sleep(100);\n\n        bytes = new byte[closeBytes.length - closeBytes.length / 2];\n        System.arraycopy(closeBytes, closeBytes.length / 2, bytes, 0, bytes.length);\n        proxy.flushToServer(bytes);\n\n        // Do not close the raw socket yet\n\n        // Expect response from server\n        // SSLSocket is limited and we cannot read the response, but we make sure\n        // it is application data and not a close alert\n        TLSRecord record = proxy.readFromServer();\n        Assert.assertNotNull(record);\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        // Close Alert\n        record = proxy.readFromServer();\n        Assert.assertNotNull(record);\n        Assert.assertEquals(TLSRecord.Type.ALERT, record.getType());\n        // We can't forward to the client, its socket is already closed\n\n        // Socket close\n        record = proxy.readFromClient();\n        Assert.assertNull(\"\" + record, record);\n        proxy.flushToServer(record);\n\n        // Socket close\n        record = proxy.readFromServer();\n        Assert.assertNull(\"\" + record, record);\n        proxy.flushToClient(record);\n    }","commit_id":"9c804921de475f55f71aaf7ac870e49ccc7dbef0","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void flushToServer(byte... datum) throws IOException\n        {\n            flush(server, datum);\n        }","id":26647,"modified_method":"public void flushToServer(byte... bytes) throws IOException\n        {\n            flush(server, bytes);\n        }","commit_id":"9c804921de475f55f71aaf7ac870e49ccc7dbef0","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testRequestWithCloseAlert() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"GET / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        TLSRecord record = proxy.readFromClient();\n        proxy.flushToServer(record);\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n\n        client.close();\n\n        // Close Alert\n        record = proxy.readFromClient();\n        proxy.flushToServer(record);\n\n        // Do not close the raw socket yet\n\n        // Expect response from server\n        // SSLSocket is limited and we cannot read the response, but we make sure\n        // it is application data and not a close alert\n        record = proxy.readFromServer();\n        Assert.assertNotNull(record);\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        // Close Alert\n        record = proxy.readFromServer();\n        Assert.assertNotNull(record);\n        Assert.assertEquals(TLSRecord.Type.ALERT, record.getType());\n        // We can't forward to the client, its socket is already closed\n\n        // Socket close\n        record = proxy.readFromClient();\n        Assert.assertNull(record);\n        proxy.flushToServer(record);\n\n        // Socket close\n        record = proxy.readFromServer();\n        Assert.assertNull(record);\n        proxy.flushToClient(record);\n    }","id":26648,"modified_method":"@Test\n    public void testRequestWithCloseAlert() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"GET / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        TLSRecord record = proxy.readFromClient();\n        proxy.flushToServer(record);\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n\n        client.close();\n\n        // Close Alert\n        record = proxy.readFromClient();\n        proxy.flushToServer(record);\n\n        // Do not close the raw socket yet\n\n        // Expect response from server\n        // SSLSocket is limited and we cannot read the response, but we make sure\n        // it is application data and not a close alert\n        record = proxy.readFromServer();\n        Assert.assertNotNull(record);\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        // Close Alert\n        record = proxy.readFromServer();\n        Assert.assertNotNull(record);\n        Assert.assertEquals(TLSRecord.Type.ALERT, record.getType());\n        // We can't forward to the client, its socket is already closed\n\n        // Socket close\n        record = proxy.readFromClient();\n        Assert.assertNull(\"\" + record, record);\n        proxy.flushToServer(record);\n\n        // Socket close\n        record = proxy.readFromServer();\n        Assert.assertNull(\"\" + record, record);\n        proxy.flushToClient(record);\n    }","commit_id":"9c804921de475f55f71aaf7ac870e49ccc7dbef0","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testRequestWithContentWithSplitBoundary() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        final String content = \"0123456789ABCDEF\";\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"POST / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"Content-Type: text/plain\\r\\n\" +\n                        \"Content-Length: \" + content.length() + \"\\r\\n\" +\n                        \"\\r\\n\" +\n                        content).getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        TLSRecord record = proxy.readFromClient();\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n        byte[] chunk1 = new byte[2 * record.getBytes().length / 3];\n        System.arraycopy(record.getBytes(), 0, chunk1, 0, chunk1.length);\n        proxy.flushToServer(chunk1);\n\n        TimeUnit.MILLISECONDS.sleep(100);\n\n        byte[] chunk2 = new byte[record.getBytes().length - chunk1.length];\n        System.arraycopy(record.getBytes(), chunk1.length, chunk2, 0, chunk2.length);\n        proxy.flushToServer(chunk2);\n\n        record = proxy.readFromServer();\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream(), \"UTF-8\"));\n        String line = reader.readLine();\n        Assert.assertNotNull(line);\n        Assert.assertTrue(line.contains(\" 200 \"));\n        while ((line = reader.readLine()) != null)\n        {\n            if (line.trim().length() == 0)\n                break;\n        }\n\n        closeClient(client);\n    }","id":26649,"modified_method":"@Test\n    public void testRequestWithContentWithSplitBoundary() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        final String content = \"0123456789ABCDEF\";\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"POST / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"Content-Type: text/plain\\r\\n\" +\n                        \"Content-Length: \" + content.length() + \"\\r\\n\" +\n                        \"\\r\\n\" +\n                        content).getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        TLSRecord record = proxy.readFromClient();\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n        byte[] chunk1 = new byte[2 * record.getBytes().length / 3];\n        System.arraycopy(record.getBytes(), 0, chunk1, 0, chunk1.length);\n        proxy.flushToServer(chunk1);\n\n        TimeUnit.MILLISECONDS.sleep(100);\n\n        byte[] chunk2 = new byte[record.getBytes().length - chunk1.length];\n        System.arraycopy(record.getBytes(), chunk1.length, chunk2, 0, chunk2.length);\n        proxy.flushToServer(chunk2);\n\n        record = proxy.readFromServer();\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream(), \"UTF-8\"));\n        String line = reader.readLine();\n        Assert.assertNotNull(line);\n        Assert.assertTrue(line.startsWith(\"HTTP/1.1 200 \"));\n        while ((line = reader.readLine()) != null)\n        {\n            if (line.trim().length() == 0)\n                break;\n        }\n\n        closeClient(client);\n    }","commit_id":"9c804921de475f55f71aaf7ac870e49ccc7dbef0","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private TLSRecord read(Socket socket) throws IOException\n        {\n            InputStream input = socket.getInputStream();\n            int first = -2;\n            while (!Thread.currentThread().isInterrupted())\n            {\n                try\n                {\n                    socket.setSoTimeout(500);\n                    first = input.read();\n                    break;\n                }\n                catch (SocketTimeoutException x)\n                {\n                    // Ignore\n                }\n            }\n            if (first == -2)\n                throw new InterruptedIOException();\n            else if (first == -1)\n                return null;\n\n            if (first >= 0x80)\n            {\n                // SSLv2 Record\n                int hiLength = first & 0x3F;\n                int loLength = input.read();\n                int length = (hiLength << 8) + loLength;\n                byte[] bytes = new byte[2 + length];\n                bytes[0] = (byte)first;\n                bytes[1] = (byte)loLength;\n                return read(TLSRecord.Type.HANDSHAKE, input, bytes, 2, length);\n            }\n            else\n            {\n                // TLS Record\n                int major = input.read();\n                int minor = input.read();\n                int hiLength = input.read();\n                int loLength = input.read();\n                int length = (hiLength << 8) + loLength;\n                byte[] bytes = new byte[1 + 2 + 2 + length];\n                bytes[0] = (byte)first;\n                bytes[1] = (byte)major;\n                bytes[2] = (byte)minor;\n                bytes[3] = (byte)hiLength;\n                bytes[4] = (byte)loLength;\n                return read(TLSRecord.Type.from(first), input, bytes, 5, length);\n            }\n        }","id":26650,"modified_method":"private TLSRecord read(Socket socket) throws IOException\n        {\n            InputStream input = socket.getInputStream();\n            int first = -2;\n            while (true)\n            {\n                try\n                {\n                    socket.setSoTimeout(500);\n                    first = input.read();\n                    break;\n                }\n                catch (SocketTimeoutException x)\n                {\n                    if (Thread.currentThread().isInterrupted())\n                        break;\n                }\n            }\n            if (first == -2)\n                throw new InterruptedIOException();\n            else if (first == -1)\n                return null;\n\n            if (first >= 0x80)\n            {\n                // SSLv2 Record\n                int hiLength = first & 0x3F;\n                int loLength = input.read();\n                int length = (hiLength << 8) + loLength;\n                byte[] bytes = new byte[2 + length];\n                bytes[0] = (byte)first;\n                bytes[1] = (byte)loLength;\n                return read(TLSRecord.Type.HANDSHAKE, input, bytes, 2, length);\n            }\n            else\n            {\n                // TLS Record\n                int major = input.read();\n                int minor = input.read();\n                int hiLength = input.read();\n                int loLength = input.read();\n                int length = (hiLength << 8) + loLength;\n                byte[] bytes = new byte[1 + 2 + 2 + length];\n                bytes[0] = (byte)first;\n                bytes[1] = (byte)major;\n                bytes[2] = (byte)minor;\n                bytes[3] = (byte)hiLength;\n                bytes[4] = (byte)loLength;\n                return read(TLSRecord.Type.from(first), input, bytes, 5, length);\n            }\n        }","commit_id":"9c804921de475f55f71aaf7ac870e49ccc7dbef0","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void closeClient(SSLSocket client) throws IOException\n    {\n        client.close();\n\n        // Close Alert\n        TLSRecord record = proxy.readFromClient();\n        proxy.flushToServer(record);\n        // Socket close\n        record = proxy.readFromClient();\n        Assert.assertNull(record);\n        proxy.flushToServer(record);\n\n        // Close Alert\n        record = proxy.readFromServer();\n        proxy.flushToClient(record);\n        // Socket close\n        record = proxy.readFromServer();\n        Assert.assertNull(record);\n        proxy.flushToClient(record);\n    }","id":26651,"modified_method":"private void closeClient(SSLSocket client) throws IOException\n    {\n        client.close();\n\n        // Close Alert\n        TLSRecord record = proxy.readFromClient();\n        proxy.flushToServer(record);\n        // Socket close\n        record = proxy.readFromClient();\n        Assert.assertNull(\"\" + record, record);\n        proxy.flushToServer(record);\n\n        // Close Alert\n        record = proxy.readFromServer();\n        proxy.flushToClient(record);\n        // Socket close\n        record = proxy.readFromServer();\n        Assert.assertNull(\"\" + record, record);\n        proxy.flushToClient(record);\n    }","commit_id":"9c804921de475f55f71aaf7ac870e49ccc7dbef0","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * TODO\n     * Currently this test does not pass.\n     * The problem is a mix of Java not being able to perform SSL half closes\n     * (but SSL supporting it), and the current implementation in Jetty.\n     * See the test below, that passes and whose only difference is that we\n     * delay the output shutdown from the client.\n     *\n     * @throws Exception if the test fails\n     */\n    @Ignore\n    @Test\n    public void testRequestWithCloseAlertAndShutdown() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"GET / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        TLSRecord record = proxy.readFromClient();\n        proxy.flushToServer(record);\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n\n        client.close();\n\n        // Close Alert\n        record = proxy.readFromClient();\n        proxy.flushToServer(record);\n        // Socket close\n        record = proxy.readFromClient();\n        Assert.assertNull(record);\n        proxy.flushToServer(record);\n\n        // Expect response from server\n        // SSLSocket is limited and we cannot read the response, but we make sure\n        // it is application data and not a close alert\n        record = proxy.readFromServer();\n        Assert.assertNotNull(record);\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        // Close Alert\n        record = proxy.readFromServer();\n        Assert.assertNotNull(record);\n        Assert.assertEquals(TLSRecord.Type.ALERT, record.getType());\n        // We can't forward to the client, its socket is already closed\n\n        // Socket close\n        record = proxy.readFromClient();\n        Assert.assertNull(record);\n        proxy.flushToServer(record);\n\n        // Socket close\n        record = proxy.readFromServer();\n        Assert.assertNull(record);\n        proxy.flushToClient(record);\n    }","id":26652,"modified_method":"/**\n     * TODO\n     * Currently this test does not pass.\n     * The problem is a mix of Java not being able to perform SSL half closes\n     * (but SSL supporting it), and the current implementation in Jetty.\n     * See the test below, that passes and whose only difference is that we\n     * delay the output shutdown from the client.\n     *\n     * @throws Exception if the test fails\n     */\n    @Ignore\n    @Test\n    public void testRequestWithCloseAlertAndShutdown() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"GET / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        TLSRecord record = proxy.readFromClient();\n        proxy.flushToServer(record);\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n\n        client.close();\n\n        // Close Alert\n        record = proxy.readFromClient();\n        proxy.flushToServer(record);\n        // Socket close\n        record = proxy.readFromClient();\n        Assert.assertNull(\"\" + record, record);\n        proxy.flushToServer(record);\n\n        // Expect response from server\n        // SSLSocket is limited and we cannot read the response, but we make sure\n        // it is application data and not a close alert\n        record = proxy.readFromServer();\n        Assert.assertNotNull(record);\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        // Close Alert\n        record = proxy.readFromServer();\n        Assert.assertNotNull(record);\n        Assert.assertEquals(TLSRecord.Type.ALERT, record.getType());\n        // We can't forward to the client, its socket is already closed\n\n        // Socket close\n        record = proxy.readFromClient();\n        Assert.assertNull(\"\" + record, record);\n        proxy.flushToServer(record);\n\n        // Socket close\n        record = proxy.readFromServer();\n        Assert.assertNull(\"\" + record, record);\n        proxy.flushToClient(record);\n    }","commit_id":"9c804921de475f55f71aaf7ac870e49ccc7dbef0","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testRequestResponse() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"GET / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        TLSRecord record = proxy.readFromClient();\n        proxy.flushToServer(record);\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n\n        // Application data\n        record = proxy.readFromServer();\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream(), \"UTF-8\"));\n        String line = reader.readLine();\n        Assert.assertNotNull(line);\n        Assert.assertTrue(line.contains(\" 200 \"));\n        while ((line = reader.readLine()) != null)\n        {\n            if (line.trim().length() == 0)\n                break;\n        }\n\n        closeClient(client);\n    }","id":26653,"modified_method":"@Test\n    public void testRequestResponse() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"GET / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"\\r\\n\").getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Application data\n        TLSRecord record = proxy.readFromClient();\n        proxy.flushToServer(record);\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n\n        // Application data\n        record = proxy.readFromServer();\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream(), \"UTF-8\"));\n        String line = reader.readLine();\n        Assert.assertNotNull(line);\n        Assert.assertTrue(line.startsWith(\"HTTP/1.1 200 \"));\n        while ((line = reader.readLine()) != null)\n        {\n            if (line.trim().length() == 0)\n                break;\n        }\n\n        closeClient(client);\n    }","commit_id":"9c804921de475f55f71aaf7ac870e49ccc7dbef0","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testRequestWithBigContentWithSplitBoundary() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        // Use a content that is larger than the TLS record which is 2^14 (around 16k)\n        byte[] data = new byte[128 * 1024];\n        Arrays.fill(data, (byte)'X');\n        final String content = new String(data, \"UTF-8\");\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"POST / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"Content-Type: text/plain\\r\\n\" +\n                        \"Content-Length: \" + content.length() + \"\\r\\n\" +\n                        \"\\r\\n\" +\n                        content).getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // The data is 8 times bigger than the TLS record max length,\n        // therefore there will be generated 9 TLSRecord\n        for (int i = 0; i < 9; ++i)\n        {\n            // Application data\n            TLSRecord record = proxy.readFromClient();\n            byte[] bytes = record.getBytes();\n            byte[] chunk1 = new byte[2 * bytes.length / 3];\n            System.arraycopy(bytes, 0, chunk1, 0, chunk1.length);\n            proxy.flushToServer(chunk1);\n\n            TimeUnit.MILLISECONDS.sleep(100);\n\n            byte[] chunk2 = new byte[bytes.length - chunk1.length];\n            System.arraycopy(bytes, chunk1.length, chunk2, 0, chunk2.length);\n            proxy.flushToServer(chunk2);\n\n            TimeUnit.MILLISECONDS.sleep(100);\n        }\n\n        // Check that we did not spin\n        Assert.assertThat(sslHandles.get(), lessThan(10));\n        Assert.assertThat(httpParses.get(), lessThan(50));\n\n        TLSRecord record = proxy.readFromServer();\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream(), \"UTF-8\"));\n        String line = reader.readLine();\n        Assert.assertNotNull(line);\n        Assert.assertTrue(line.contains(\" 200 \"));\n        while ((line = reader.readLine()) != null)\n        {\n            if (line.trim().length() == 0)\n                break;\n        }\n\n        closeClient(client);\n    }","id":26654,"modified_method":"@Test\n    public void testRequestWithBigContentWithSplitBoundary() throws Exception\n    {\n        final SSLSocket client = newClient();\n\n        SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n        client.startHandshake();\n        Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n        // Use a content that is larger than the TLS record which is 2^14 (around 16k)\n        byte[] data = new byte[128 * 1024];\n        Arrays.fill(data, (byte)'X');\n        final String content = new String(data, \"UTF-8\");\n\n        Future<Object> request = threadPool.submit(new Callable<Object>()\n        {\n            public Object call() throws Exception\n            {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write((\"\" +\n                        \"POST / HTTP/1.1\\r\\n\" +\n                        \"Host: localhost\\r\\n\" +\n                        \"Content-Type: text/plain\\r\\n\" +\n                        \"Content-Length: \" + content.length() + \"\\r\\n\" +\n                        \"\\r\\n\" +\n                        content).getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n            }\n        });\n\n        // Nine TLSRecords will be generated for the request\n        for (int i = 0; i < 9; ++i)\n        {\n            // Application data\n            TLSRecord record = proxy.readFromClient();\n            byte[] bytes = record.getBytes();\n            byte[] chunk1 = new byte[2 * bytes.length / 3];\n            System.arraycopy(bytes, 0, chunk1, 0, chunk1.length);\n            byte[] chunk2 = new byte[bytes.length - chunk1.length];\n            System.arraycopy(bytes, chunk1.length, chunk2, 0, chunk2.length);\n            proxy.flushToServer(chunk1);\n            TimeUnit.MILLISECONDS.sleep(100);\n            proxy.flushToServer(chunk2);\n            TimeUnit.MILLISECONDS.sleep(100);\n        }\n\n        // Check that we did not spin\n        Assert.assertThat(sslHandles.get(), lessThan(20));\n        Assert.assertThat(httpParses.get(), lessThan(50));\n\n        Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n\n        TLSRecord record = proxy.readFromServer();\n        Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n        proxy.flushToClient(record);\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream(), \"UTF-8\"));\n        String line = reader.readLine();\n        Assert.assertNotNull(line);\n        Assert.assertTrue(line.startsWith(\"HTTP/1.1 200 \"));\n        while ((line = reader.readLine()) != null)\n        {\n            if (line.trim().length() == 0)\n                break;\n        }\n\n        closeClient(client);\n    }","commit_id":"9c804921de475f55f71aaf7ac870e49ccc7dbef0","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @param recon Reconnect flag.\n     * @return Whether joined successfully.\n     * @throws IgniteSpiException In case of error.\n     */\n    private boolean joinTopology(boolean recon) throws IgniteSpiException {\n        if (!recon)\n            stats.onJoinStarted();\n\n        Collection<InetSocketAddress> addrs = null;\n\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                while (addrs == null || addrs.isEmpty()) {\n                    addrs = resolvedAddresses();\n\n                    if (!F.isEmpty(addrs)) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Resolved addresses from IP finder: \" + addrs);\n                    }\n                    else {\n                        U.warn(log, \"No addresses registered in the IP finder (will retry in 2000ms): \" + ipFinder);\n\n                        U.sleep(2000);\n                    }\n                }\n\n                Collection<InetSocketAddress> addrs0 = new ArrayList<>(addrs);\n\n                Iterator<InetSocketAddress> it = addrs.iterator();\n\n                while (it.hasNext() && !Thread.currentThread().isInterrupted()) {\n                    InetSocketAddress addr = it.next();\n\n                    Socket sock = null;\n\n                    try {\n                        long ts = U.currentTimeMillis();\n\n                        IgniteBiTuple<Socket, UUID> t = initConnection(addr);\n\n                        sock = t.get1();\n\n                        UUID rmtNodeId = t.get2();\n\n                        stats.onClientSocketInitialized(U.currentTimeMillis() - ts);\n\n                        locNode.clientRouterNodeId(rmtNodeId);\n\n                        TcpDiscoveryAbstractMessage msg = recon ?\n                            new TcpDiscoveryClientReconnectMessage(getLocalNodeId(), rmtNodeId,\n                                lastMsgId) :\n                            new TcpDiscoveryJoinRequestMessage(locNode, null);\n\n                        msg.client(true);\n\n                        writeToSocket(sock, msg);\n\n                        int res = readReceipt(sock, ackTimeout);\n\n                        switch (res) {\n                            case RES_OK:\n                                this.sock = sock;\n\n                                sockRdr = new SocketReader(rmtNodeId, new MessageWorker(recon));\n                                sockRdr.start();\n\n                                if (U.await(joinLatch, netTimeout, MILLISECONDS)) {\n                                    IgniteSpiException joinErr0 = joinErr;\n\n                                    if (joinErr0 != null)\n                                        throw joinErr0;\n\n                                    if (reconFailed) {\n                                        if (log.isDebugEnabled())\n                                            log.debug(\"Failed to reconnect, will try to rejoin [locNode=\" +\n                                                locNode + ']');\n\n                                        U.closeQuiet(sock);\n\n                                        U.interrupt(sockRdr);\n                                        U.join(sockRdr, log);\n\n                                        this.sock = null;\n\n                                        return false;\n                                    }\n\n                                    if (log.isDebugEnabled())\n                                        log.debug(\"Successfully connected to topology [sock=\" + sock + ']');\n\n                                    hbSender = new HeartbeatSender();\n                                    hbSender.start();\n\n                                    stats.onJoinFinished();\n\n                                    return true;\n                                }\n                                else {\n                                    U.warn(log, \"Join process timed out (will try other address) [sock=\" + sock +\n                                        \", timeout=\" + netTimeout + ']');\n\n                                    U.closeQuiet(sock);\n\n                                    U.interrupt(sockRdr);\n                                    U.join(sockRdr, log);\n\n                                    it.remove();\n\n                                    break;\n                                }\n\n                            case RES_CONTINUE_JOIN:\n                            case RES_WAIT:\n                                U.closeQuiet(sock);\n\n                                break;\n\n                            default:\n                                if (log.isDebugEnabled())\n                                    log.debug(\"Received unexpected response to join request: \" + res);\n\n                                U.closeQuiet(sock);\n                        }\n                    }\n                    catch (IgniteInterruptedCheckedException ignored) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"Joining thread was interrupted.\");\n\n                        return false;\n                    }\n                    catch (IOException | IgniteCheckedException e) {\n                        if (log.isDebugEnabled())\n                            U.error(log, \"Failed to establish connection with address: \" + addr, e);\n\n                        U.closeQuiet(sock);\n\n                        it.remove();\n                    }\n                }\n\n                if (addrs.isEmpty()) {\n                    U.warn(log, \"Failed to connect to any address from IP finder (will retry to join topology \" +\n                        \"in 2000ms): \" + addrs0);\n\n                    U.sleep(2000);\n                }\n            }\n            catch (IgniteInterruptedCheckedException ignored) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Joining thread was interrupted.\");\n            }\n        }\n\n        return false;\n    }","id":26655,"modified_method":"/**\n     *\n     */\n    @NotNull\n    private Socket joinTopology(boolean recon) throws IgniteSpiException, InterruptedException {\n        Collection<InetSocketAddress> addrs = null;\n\n        while (true) {\n            if (Thread.currentThread().isInterrupted())\n                throw new InterruptedException();\n\n            while (addrs == null || addrs.isEmpty()) {\n                addrs = resolvedAddresses();\n\n                if (!F.isEmpty(addrs)) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Resolved addresses from IP finder: \" + addrs);\n                }\n                else {\n                    U.warn(log, \"No addresses registered in the IP finder (will retry in 2000ms): \" + ipFinder);\n\n                    Thread.sleep(2000);\n                }\n            }\n\n            Collection<InetSocketAddress> addrs0 = new ArrayList<>(addrs);\n\n            Iterator<InetSocketAddress> it = addrs.iterator();\n\n            while (it.hasNext()) {\n                if (Thread.currentThread().isInterrupted())\n                    throw new InterruptedException();\n\n                InetSocketAddress addr = it.next();\n\n                Socket sock = null;\n\n                try {\n                    long ts = U.currentTimeMillis();\n\n                    IgniteBiTuple<Socket, UUID> t = initConnection(addr);\n\n                    sock = t.get1();\n\n                    UUID rmtNodeId = t.get2();\n\n                    stats.onClientSocketInitialized(U.currentTimeMillis() - ts);\n\n                    locNode.clientRouterNodeId(rmtNodeId);\n\n                    TcpDiscoveryAbstractMessage msg = recon ?\n                        new TcpDiscoveryClientReconnectMessage(getLocalNodeId(), rmtNodeId,\n                            lastMsgId) :\n                        new TcpDiscoveryJoinRequestMessage(locNode, null);\n\n                    msg.client(true);\n\n                    writeToSocket(sock, msg);\n\n                    int res = readReceipt(sock, ackTimeout);\n\n                    switch (res) {\n                        case RES_OK:\n                            return sock;\n\n                        case RES_CONTINUE_JOIN:\n                        case RES_WAIT:\n                            U.closeQuiet(sock);\n\n                            break;\n\n                        default:\n                            if (log.isDebugEnabled())\n                                log.debug(\"Received unexpected response to join request: \" + res);\n\n                            U.closeQuiet(sock);\n                    }\n                }\n                catch (IOException | IgniteCheckedException e) {\n                    if (log.isDebugEnabled())\n                        U.error(log, \"Failed to establish connection with address: \" + addr, e);\n\n                    U.closeQuiet(sock);\n\n                    it.remove();\n                }\n            }\n\n            if (addrs.isEmpty()) {\n                U.warn(log, \"Failed to connect to any address from IP finder (will retry to join topology \" +\n                    \"in 2000ms): \" + addrs0);\n\n                Thread.sleep(2000);\n            }\n        }\n    }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void failNode(UUID nodeId) {\n        ClusterNode node = rmtNodes.get(nodeId);\n\n        if (node != null) {\n            TcpDiscoveryNodeFailedMessage msg = new TcpDiscoveryNodeFailedMessage(getLocalNodeId(),\n                node.id(), node.order());\n\n            sockRdr.addMessage(msg);\n        }\n    }","id":26656,"modified_method":"/** {@inheritDoc} */\n    @Override public void failNode(UUID nodeId) {\n        ClusterNode node = rmtNodes.get(nodeId);\n\n        if (node != null) {\n            TcpDiscoveryNodeFailedMessage msg = new TcpDiscoveryNodeFailedMessage(getLocalNodeId(),\n                node.id(), node.order());\n\n            msgWorker.addMessage(msg);\n        }\n    }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void spiStart(@Nullable String gridName) throws IgniteSpiException {\n        startStopwatch();\n\n        assertParameter(ipFinder != null, \"ipFinder != null\");\n        assertParameter(netTimeout > 0, \"networkTimeout > 0\");\n        assertParameter(sockTimeout > 0, \"sockTimeout > 0\");\n        assertParameter(ackTimeout > 0, \"ackTimeout > 0\");\n        assertParameter(hbFreq > 0, \"heartbeatFreq > 0\");\n        assertParameter(threadPri > 0, \"threadPri > 0\");\n\n        try {\n            locHost = U.resolveLocalHost(locAddr);\n        }\n        catch (IOException e) {\n            throw new IgniteSpiException(\"Unknown local address: \" + locAddr, e);\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(configInfo(\"localHost\", locHost.getHostAddress()));\n            log.debug(configInfo(\"threadPri\", threadPri));\n            log.debug(configInfo(\"networkTimeout\", netTimeout));\n            log.debug(configInfo(\"sockTimeout\", sockTimeout));\n            log.debug(configInfo(\"ackTimeout\", ackTimeout));\n            log.debug(configInfo(\"ipFinder\", ipFinder));\n            log.debug(configInfo(\"heartbeatFreq\", hbFreq));\n        }\n\n        // Warn on odd network timeout.\n        if (netTimeout < 3000)\n            U.warn(log, \"Network timeout is too low (at least 3000 ms recommended): \" + netTimeout);\n\n        // Warn on odd heartbeat frequency.\n        if (hbFreq < 2000)\n            U.warn(log, \"Heartbeat frequency is too high (at least 2000 ms recommended): \" + hbFreq);\n\n        registerMBean(gridName, this, TcpClientDiscoverySpiMBean.class);\n\n        try {\n            locHost = U.resolveLocalHost(locAddr);\n        }\n        catch (IOException e) {\n            throw new IgniteSpiException(\"Unknown local address: \" + locAddr, e);\n        }\n\n        if (ipFinder instanceof TcpDiscoveryMulticastIpFinder) {\n            TcpDiscoveryMulticastIpFinder mcastIpFinder = ((TcpDiscoveryMulticastIpFinder)ipFinder);\n\n            if (mcastIpFinder.getLocalAddress() == null)\n                mcastIpFinder.setLocalAddress(locAddr);\n        }\n\n        IgniteBiTuple<Collection<String>, Collection<String>> addrs;\n\n        try {\n            addrs = U.resolveLocalAddresses(locHost);\n        }\n        catch (IOException | IgniteCheckedException e) {\n            throw new IgniteSpiException(\"Failed to resolve local host to set of external addresses: \" + locHost, e);\n        }\n\n        locNode = new TcpDiscoveryNode(\n            getLocalNodeId(),\n            addrs.get1(),\n            addrs.get2(),\n            0,\n            metricsProvider,\n            locNodeVer);\n\n        locNode.setAttributes(locNodeAttrs);\n        locNode.local(true);\n\n        sockTimeoutWorker = new SocketTimeoutWorker();\n        sockTimeoutWorker.start();\n\n        joinTopology(false);\n\n        disconnectHnd = new DisconnectHandler();\n        disconnectHnd.start();\n\n        if (log.isDebugEnabled())\n            log.debug(startInfo());\n    }","id":26657,"modified_method":"/** {@inheritDoc} */\n    @Override public void spiStart(@Nullable String gridName) throws IgniteSpiException {\n        startStopwatch();\n\n        assertParameter(ipFinder != null, \"ipFinder != null\");\n        assertParameter(netTimeout > 0, \"networkTimeout > 0\");\n        assertParameter(sockTimeout > 0, \"sockTimeout > 0\");\n        assertParameter(ackTimeout > 0, \"ackTimeout > 0\");\n        assertParameter(hbFreq > 0, \"heartbeatFreq > 0\");\n        assertParameter(threadPri > 0, \"threadPri > 0\");\n\n        try {\n            locHost = U.resolveLocalHost(locAddr);\n        }\n        catch (IOException e) {\n            throw new IgniteSpiException(\"Unknown local address: \" + locAddr, e);\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(configInfo(\"localHost\", locHost.getHostAddress()));\n            log.debug(configInfo(\"threadPri\", threadPri));\n            log.debug(configInfo(\"networkTimeout\", netTimeout));\n            log.debug(configInfo(\"sockTimeout\", sockTimeout));\n            log.debug(configInfo(\"ackTimeout\", ackTimeout));\n            log.debug(configInfo(\"ipFinder\", ipFinder));\n            log.debug(configInfo(\"heartbeatFreq\", hbFreq));\n        }\n\n        // Warn on odd network timeout.\n        if (netTimeout < 3000)\n            U.warn(log, \"Network timeout is too low (at least 3000 ms recommended): \" + netTimeout);\n\n        // Warn on odd heartbeat frequency.\n        if (hbFreq < 2000)\n            U.warn(log, \"Heartbeat frequency is too high (at least 2000 ms recommended): \" + hbFreq);\n\n        registerMBean(gridName, this, TcpClientDiscoverySpiMBean.class);\n\n        try {\n            locHost = U.resolveLocalHost(locAddr);\n        }\n        catch (IOException e) {\n            throw new IgniteSpiException(\"Unknown local address: \" + locAddr, e);\n        }\n\n        if (ipFinder instanceof TcpDiscoveryMulticastIpFinder) {\n            TcpDiscoveryMulticastIpFinder mcastIpFinder = ((TcpDiscoveryMulticastIpFinder)ipFinder);\n\n            if (mcastIpFinder.getLocalAddress() == null)\n                mcastIpFinder.setLocalAddress(locAddr);\n        }\n\n        IgniteBiTuple<Collection<String>, Collection<String>> addrs;\n\n        try {\n            addrs = U.resolveLocalAddresses(locHost);\n        }\n        catch (IOException | IgniteCheckedException e) {\n            throw new IgniteSpiException(\"Failed to resolve local host to set of external addresses: \" + locHost, e);\n        }\n\n        locNode = new TcpDiscoveryNode(\n            getLocalNodeId(),\n            addrs.get1(),\n            addrs.get2(),\n            0,\n            metricsProvider,\n            locNodeVer);\n\n        locNode.setAttributes(locNodeAttrs);\n        locNode.local(true);\n\n        sockWriter = new SocketWriter();\n        sockWriter.start();\n\n        sockReader = new SocketReader();\n        sockReader.start();\n\n        sockTimeoutWorker = new SocketTimeoutWorker();\n        sockTimeoutWorker.start();\n\n        msgWorker = new MessageWorker();\n        msgWorker.start();\n\n        try {\n            joinLatch.await();\n\n            if (joinErr != null)\n                throw joinErr;\n        }\n        catch (InterruptedException e) {\n            throw new IgniteSpiException(\"Thread has been interrupted.\", e);\n        }\n\n        timer.schedule(new HeartbeatSender(), hbFreq, hbFreq);\n\n        if (log.isDebugEnabled())\n            log.debug(startInfo());\n    }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/**\n         * @param msg Message.\n         */\n        private void processCustomMessage(TcpDiscoveryCustomEventMessage msg) {\n            if (msg.verified()) {\n                DiscoverySpiListener lsnr = TcpClientDiscoverySpi.this.lsnr;\n\n                if (lsnr != null) {\n                    UUID nodeId = msg.creatorNodeId();\n\n                    TcpDiscoveryNode node = nodeId.equals(getLocalNodeId()) ? locNode : rmtNodes.get(nodeId);\n\n                    if (node != null && node.visible()) {\n                        try {\n                            Serializable msgObj = marsh.unmarshal(msg.messageBytes(), U.gridClassLoader());\n\n                            notifyDiscovery(EVT_DISCOVERY_CUSTOM_EVT, topVer, node, allNodes(), msgObj);\n                        }\n                        catch (IgniteCheckedException e) {\n                            U.error(log, \"Failed to unmarshal discovery custom message.\", e);\n                        }\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Received metrics from unknown node: \" + nodeId);\n                }\n            }\n            else {\n                if (getLocalNodeId().equals(msg.creatorNodeId())) {\n                    Socket sock0 = sock;\n\n                    if (sock0 != null) {\n                        try {\n                            writeToSocket(sock0, msg);\n\n                            if (log.isDebugEnabled())\n                                log.debug(\"Heartbeat message sent [sock=\" + sock0 + \", msg=\" + msg + ']');\n                        }\n                        catch (IOException | IgniteCheckedException e) {\n                            if (log.isDebugEnabled())\n                                U.error(log, \"Failed to send custom message [sock=\" + sock0 +\n                                    \", msg=\" + msg + ']', e);\n\n                            U.closeQuiet(sock0);\n\n                            sock = null;\n\n                            interrupt();\n                        }\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Failed to send custom message (node is disconnected): \" + msg);\n                }\n            }\n        }","id":26658,"modified_method":"/**\n         * @param msg Message.\n         */\n        private void processCustomMessage(TcpDiscoveryCustomEventMessage msg) {\n            if (msg.verified()) {\n                DiscoverySpiListener lsnr = TcpClientDiscoverySpi.this.lsnr;\n\n                if (lsnr != null) {\n                    UUID nodeId = msg.creatorNodeId();\n\n                    TcpDiscoveryNode node = nodeId.equals(getLocalNodeId()) ? locNode : rmtNodes.get(nodeId);\n\n                    if (node != null && node.visible()) {\n                        try {\n                            Serializable msgObj = marsh.unmarshal(msg.messageBytes(), U.gridClassLoader());\n\n                            notifyDiscovery(EVT_DISCOVERY_CUSTOM_EVT, topVer, node, allNodes(), msgObj);\n                        }\n                        catch (IgniteCheckedException e) {\n                            U.error(log, \"Failed to unmarshal discovery custom message.\", e);\n                        }\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Received metrics from unknown node: \" + nodeId);\n                }\n            }\n        }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void sendCustomEvent(Serializable evt) {\n        try {\n            sockRdr.addMessage(new TcpDiscoveryCustomEventMessage(getLocalNodeId(), marsh.marshal(evt)));\n        }\n        catch (IgniteCheckedException e) {\n            throw new IgniteSpiException(\"Failed to marshal custom event: \" + evt, e);\n        }\n    }","id":26659,"modified_method":"/** {@inheritDoc} */\n    @Override public void sendCustomEvent(Serializable evt) {\n        try {\n            sockWriter.sendMessage(new TcpDiscoveryCustomEventMessage(getLocalNodeId(), marsh.marshal(evt)));\n        }\n        catch (IgniteCheckedException e) {\n            throw new IgniteSpiException(\"Failed to marshal custom event: \" + evt, e);\n        }\n    }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n        @Override protected void body() throws InterruptedException {\n            Socket sock0 = sock;\n\n            if (sock0 == null) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Failed to start socket reader, node is already disconnected.\");\n\n                return;\n            }\n\n            try {\n                InputStream in = new BufferedInputStream(sock0.getInputStream());\n\n                sock0.setKeepAlive(true);\n                sock0.setTcpNoDelay(true);\n\n                while (!isInterrupted()) {\n                    try {\n                        TcpDiscoveryAbstractMessage msg = marsh.unmarshal(in, U.gridClassLoader());\n\n                        msg.senderNodeId(nodeId);\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"Message has been received: \" + msg);\n\n                        stats.onMessageReceived(msg);\n\n                        if (joinLatch.getCount() > 0) {\n                            IgniteSpiException err = null;\n\n                            if (msg instanceof TcpDiscoveryDuplicateIdMessage)\n                                err = duplicateIdError((TcpDiscoveryDuplicateIdMessage)msg);\n                            else if (msg instanceof TcpDiscoveryAuthFailedMessage)\n                                err = authenticationFailedError((TcpDiscoveryAuthFailedMessage)msg);\n                            else if (msg instanceof TcpDiscoveryCheckFailedMessage)\n                                err = checkFailedError((TcpDiscoveryCheckFailedMessage)msg);\n\n                            if (err != null) {\n                                joinErr = err;\n\n                                joinLatch.countDown();\n\n                                return;\n                            }\n                        }\n\n                        msgWrk.addMessage(msg);\n                    }\n                    catch (IgniteCheckedException e) {\n                        if (log.isDebugEnabled())\n                            U.error(log, \"Failed to read message [sock=\" + sock0 + \", \" +\n                                \"locNodeId=\" + getLocalNodeId() + \", rmtNodeId=\" + nodeId + ']', e);\n\n                        IOException ioEx = X.cause(e, IOException.class);\n\n                        if (ioEx != null)\n                            throw ioEx;\n\n                        ClassNotFoundException clsNotFoundEx = X.cause(e, ClassNotFoundException.class);\n\n                        if (clsNotFoundEx != null)\n                            LT.warn(log, null, \"Failed to read message due to ClassNotFoundException \" +\n                                \"(make sure same versions of all classes are available on all nodes) \" +\n                                \"[rmtNodeId=\" + nodeId + \", err=\" + clsNotFoundEx.getMessage() + ']');\n                        else\n                            LT.error(log, e, \"Failed to read message [sock=\" + sock0 + \", locNodeId=\" +\n                                getLocalNodeId() + \", rmtNodeId=\" + nodeId + ']');\n                    }\n                }\n            }\n            catch (IOException e) {\n                if (log.isDebugEnabled())\n                    U.error(log, \"Connection failed [sock=\" + sock0 + \", locNodeId=\" +\n                        getLocalNodeId() + \", rmtNodeId=\" + nodeId + ']', e);\n            }\n            finally {\n                U.closeQuiet(sock0);\n\n                U.interrupt(msgWrk);\n\n                try {\n                    U.join(msgWrk);\n                }\n                catch (IgniteInterruptedCheckedException ignored) {\n                    // No-op.\n                }\n\n                sock = null;\n            }\n        }","id":26660,"modified_method":"/** {@inheritDoc} */\n        @Override protected void body() throws InterruptedException {\n            while (!isInterrupted()) {\n                Socket sock;\n                UUID rmtNodeId;\n\n                synchronized (mux) {\n                    if (this.sock == null) {\n                        mux.wait();\n\n                        continue;\n                    }\n\n                    sock = this.sock;\n                    rmtNodeId = this.rmtNodeId;\n                }\n\n                try {\n                    try {\n                        InputStream in = new BufferedInputStream(sock.getInputStream());\n\n                        sock.setKeepAlive(true);\n                        sock.setTcpNoDelay(true);\n\n                        while (!isInterrupted()) {\n                            TcpDiscoveryAbstractMessage msg;\n\n                            try {\n                                msg = marsh.unmarshal(in, U.gridClassLoader());\n\n                                System.out.println(\"TcpClientDiscoverySpi.SocketReader: read: \" + msg);\n                            }\n                            catch (IgniteCheckedException e) {\n                                if (log.isDebugEnabled())\n                                    U.error(log, \"Failed to read message [sock=\" + sock + \", \" +\n                                        \"locNodeId=\" + getLocalNodeId() + \", rmtNodeId=\" + rmtNodeId + ']', e);\n\n                                IOException ioEx = X.cause(e, IOException.class);\n\n                                if (ioEx != null)\n                                    throw ioEx;\n\n                                ClassNotFoundException clsNotFoundEx = X.cause(e, ClassNotFoundException.class);\n\n                                if (clsNotFoundEx != null)\n                                    LT.warn(log, null, \"Failed to read message due to ClassNotFoundException \" +\n                                        \"(make sure same versions of all classes are available on all nodes) \" +\n                                        \"[rmtNodeId=\" + rmtNodeId + \", err=\" + clsNotFoundEx.getMessage() + ']');\n                                else\n                                    LT.error(log, e, \"Failed to read message [sock=\" + sock + \", locNodeId=\" +\n                                        getLocalNodeId() + \", rmtNodeId=\" + rmtNodeId + ']');\n\n                                continue;\n                            }\n\n                            msg.senderNodeId(rmtNodeId);\n\n                            if (log.isDebugEnabled())\n                                log.debug(\"Message has been received: \" + msg);\n\n                            stats.onMessageReceived(msg);\n\n                            if (ensured(msg))\n                                lastMsgId = msg.id();\n\n                            msgWorker.addMessage(msg);\n                        }\n                    }\n                    catch (IOException e) {\n                        System.out.println(\"TcpClientDiscoverySpi.SocketReader: IOException: \" + e);\n\n                        msgWorker.addMessage(new SocketClosedMessage(sock));\n\n                        if (log.isDebugEnabled())\n                            U.error(log, \"Connection failed [sock=\" + sock + \", locNodeId=\" + getLocalNodeId() + ']', e);\n                    }\n                }\n                finally {\n                    System.out.println(\"TcpClientDiscoverySpi.SocketReader: Closed\");\n\n                    U.closeQuiet(sock);\n\n                    synchronized (mux) {\n                        if (this.sock == sock) {\n                            this.sock = null;\n                            this.rmtNodeId = null;\n                        }\n                    }\n                }\n            }\n        }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n        @Override protected void processMessage(TcpDiscoveryAbstractMessage msg) {\n            assert msg != null;\n            assert msg.verified() || msg.senderNodeId() == null;\n\n            stats.onMessageProcessingStarted(msg);\n\n            if (msg instanceof TcpDiscoveryClientReconnectMessage)\n                processClientReconnectMessage((TcpDiscoveryClientReconnectMessage)msg);\n            else {\n                if (recon && !pending) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Discarding message received during reconnection: \" + msg);\n                }\n                else {\n                    if (msg instanceof TcpDiscoveryNodeAddedMessage)\n                        processNodeAddedMessage((TcpDiscoveryNodeAddedMessage)msg);\n                    else if (msg instanceof TcpDiscoveryNodeAddFinishedMessage)\n                        processNodeAddFinishedMessage((TcpDiscoveryNodeAddFinishedMessage)msg);\n                    else if (msg instanceof TcpDiscoveryNodeLeftMessage)\n                        processNodeLeftMessage((TcpDiscoveryNodeLeftMessage)msg);\n                    else if (msg instanceof TcpDiscoveryNodeFailedMessage)\n                        processNodeFailedMessage((TcpDiscoveryNodeFailedMessage)msg);\n                    else if (msg instanceof TcpDiscoveryHeartbeatMessage)\n                        processHeartbeatMessage((TcpDiscoveryHeartbeatMessage)msg);\n                    else if (msg instanceof TcpDiscoveryCustomEventMessage)\n                        processCustomMessage((TcpDiscoveryCustomEventMessage)msg);\n\n                    if (ensured(msg))\n                        lastMsgId = msg.id();\n                }\n            }\n\n            stats.onMessageProcessingFinished(msg);\n        }","id":26661,"modified_method":"/** {@inheritDoc} */\n        protected void processDiscoveryMessage(TcpDiscoveryAbstractMessage msg) {\n            assert msg != null;\n            assert msg.verified() || msg.senderNodeId() == null;\n\n            stats.onMessageProcessingStarted(msg);\n\n            if (msg instanceof TcpDiscoveryNodeAddedMessage)\n                processNodeAddedMessage((TcpDiscoveryNodeAddedMessage)msg);\n            else if (msg instanceof TcpDiscoveryNodeAddFinishedMessage)\n                processNodeAddFinishedMessage((TcpDiscoveryNodeAddFinishedMessage)msg);\n            else if (msg instanceof TcpDiscoveryNodeLeftMessage)\n                processNodeLeftMessage((TcpDiscoveryNodeLeftMessage)msg);\n            else if (msg instanceof TcpDiscoveryNodeFailedMessage)\n                processNodeFailedMessage((TcpDiscoveryNodeFailedMessage)msg);\n            else if (msg instanceof TcpDiscoveryHeartbeatMessage)\n                processHeartbeatMessage((TcpDiscoveryHeartbeatMessage)msg);\n            else if (msg instanceof TcpDiscoveryCustomEventMessage)\n                processCustomMessage((TcpDiscoveryCustomEventMessage)msg);\n\n            stats.onMessageProcessingFinished(msg);\n        }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public int getMessageWorkerQueueSize() {\n        SocketReader sockRdr0 = sockRdr;\n\n        return sockRdr0 != null ? sockRdr0.msgWrk.queueSize() : 0;\n    }","id":26662,"modified_method":"/** {@inheritDoc} */\n    @Override public int getMessageWorkerQueueSize() {\n        return msgWorker.queueSize();\n    }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/**\n         * @param msg Message.\n         */\n        private void processNodeLeftMessage(TcpDiscoveryNodeLeftMessage msg) {\n            if (getLocalNodeId().equals(msg.creatorNodeId())) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Received node left message for local node: \" + msg);\n\n                CountDownLatch leaveLatch0 = leaveLatch;\n\n                assert leaveLatch0 != null;\n\n                leaveLatch0.countDown();\n            }\n            else {\n                if (leaveLatch != null)\n                    return;\n\n                TcpDiscoveryNode node = rmtNodes.remove(msg.creatorNodeId());\n\n                if (node == null) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Discarding node left message since node is not found [msg=\" + msg + ']');\n\n                    return;\n                }\n\n                Collection<ClusterNode> top = updateTopologyHistory(msg.topologyVersion());\n\n                if (!pending && joinLatch.getCount() > 0) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Discarding node left message (join process is not finished): \" + msg);\n\n                    return;\n                }\n\n                notifyDiscovery(EVT_NODE_LEFT, msg.topologyVersion(), node, top);\n\n                stats.onNodeLeft();\n            }\n        }","id":26663,"modified_method":"/**\n         * @param msg Message.\n         */\n        private void processNodeLeftMessage(TcpDiscoveryNodeLeftMessage msg) {\n            if (getLocalNodeId().equals(msg.creatorNodeId())) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Received node left message for local node: \" + msg);\n\n                leaveLatch.countDown();\n            }\n            else {\n                if (getSpiContext().isStopping())\n                    return;\n\n                TcpDiscoveryNode node = rmtNodes.remove(msg.creatorNodeId());\n\n                if (node == null) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Discarding node left message since node is not found [msg=\" + msg + ']');\n\n                    return;\n                }\n\n                Collection<ClusterNode> top = updateTopologyHistory(msg.topologyVersion());\n\n                if (!pending && joinLatch.getCount() > 0) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Discarding node left message (join process is not finished): \" + msg);\n\n                    return;\n                }\n\n                notifyDiscovery(EVT_NODE_LEFT, msg.topologyVersion(), node, top);\n\n                stats.onNodeLeft();\n            }\n        }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param addr Address.\n     * @return Remote node ID.\n     * @throws IOException In case of I/O error.\n     * @throws IgniteCheckedException In case of other error.\n     */\n    private IgniteBiTuple<Socket, UUID> initConnection(InetSocketAddress addr) throws IOException, IgniteCheckedException {\n        assert addr != null;\n\n        joinLatch = new CountDownLatch(1);\n\n        Socket sock = openSocket(addr);\n\n        TcpDiscoveryHandshakeRequest req = new TcpDiscoveryHandshakeRequest(getLocalNodeId());\n\n        req.client(true);\n\n        writeToSocket(sock, req);\n\n        TcpDiscoveryHandshakeResponse res = readMessage(sock, null, ackTimeout);\n\n        UUID nodeId = res.creatorNodeId();\n\n        assert nodeId != null;\n        assert !getLocalNodeId().equals(nodeId);\n\n        return F.t(sock, nodeId);\n    }","id":26664,"modified_method":"/**\n     * @param addr Address.\n     * @return Remote node ID.\n     * @throws IOException In case of I/O error.\n     * @throws IgniteCheckedException In case of other error.\n     */\n    private IgniteBiTuple<Socket, UUID> initConnection(InetSocketAddress addr) throws IOException, IgniteCheckedException {\n        assert addr != null;\n\n        Socket sock = openSocket(addr);\n\n        TcpDiscoveryHandshakeRequest req = new TcpDiscoveryHandshakeRequest(getLocalNodeId());\n\n        req.client(true);\n\n        writeToSocket(sock, req);\n\n        TcpDiscoveryHandshakeResponse res = readMessage(sock, null, ackTimeout);\n\n        UUID nodeId = res.creatorNodeId();\n\n        assert nodeId != null;\n        assert !getLocalNodeId().equals(nodeId);\n\n        return F.t(sock, nodeId);\n    }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/**\n         * @param msg Message.\n         */\n        private void processHeartbeatMessage(TcpDiscoveryHeartbeatMessage msg) {\n            if (leaveLatch != null)\n                return;\n\n            if (getLocalNodeId().equals(msg.creatorNodeId())) {\n                if (msg.senderNodeId() == null) {\n                    Socket sock0 = sock;\n\n                    if (sock0 != null) {\n                        UUID nodeId = ignite.configuration().getNodeId();\n\n                        msg.setMetrics(nodeId, metricsProvider.metrics());\n\n                        msg.setCacheMetrics(nodeId, metricsProvider.cacheMetrics());\n\n                        try {\n                            writeToSocket(sock0, msg);\n\n                            if (log.isDebugEnabled())\n                                log.debug(\"Heartbeat message sent [sock=\" + sock0 + \", msg=\" + msg + ']');\n                        }\n                        catch (IOException | IgniteCheckedException e) {\n                            if (log.isDebugEnabled())\n                                U.error(log, \"Failed to send heartbeat message [sock=\" + sock0 +\n                                    \", msg=\" + msg + ']', e);\n\n                            U.closeQuiet(sock0);\n\n                            sock = null;\n\n                            interrupt();\n                        }\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Failed to send heartbeat message (node is disconnected): \" + msg);\n                }\n                else if (log.isDebugEnabled())\n                    log.debug(\"Received heartbeat response: \" + msg);\n            }\n            else {\n                long tstamp = U.currentTimeMillis();\n\n                if (msg.hasMetrics()) {\n                    for (Map.Entry<UUID, MetricsSet> e : msg.metrics().entrySet()) {\n                        UUID nodeId = e.getKey();\n\n                        MetricsSet metricsSet = e.getValue();\n\n                        Map<Integer, CacheMetrics> cacheMetrics = msg.hasCacheMetrics() ?\n                                msg.cacheMetrics().get(nodeId) : Collections.<Integer, CacheMetrics>emptyMap();\n\n                        updateMetrics(nodeId, metricsSet.metrics(), cacheMetrics, tstamp);\n\n                        for (T2<UUID, ClusterMetrics> t : metricsSet.clientMetrics())\n                            updateMetrics(t.get1(), t.get2(), cacheMetrics, tstamp);\n                    }\n                }\n            }\n        }","id":26665,"modified_method":"/**\n         * @param msg Message.\n         */\n        private void processHeartbeatMessage(TcpDiscoveryHeartbeatMessage msg) {\n            if (getSpiContext().isStopping())\n                return;\n\n            if (getLocalNodeId().equals(msg.creatorNodeId())) {\n                assert msg.senderNodeId() != null;\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Received heartbeat response: \" + msg);\n            }\n            else {\n                long tstamp = U.currentTimeMillis();\n\n                if (msg.hasMetrics()) {\n                    for (Map.Entry<UUID, MetricsSet> e : msg.metrics().entrySet()) {\n                        UUID nodeId = e.getKey();\n\n                        MetricsSet metricsSet = e.getValue();\n\n                        Map<Integer, CacheMetrics> cacheMetrics = msg.hasCacheMetrics() ?\n                                msg.cacheMetrics().get(nodeId) : Collections.<Integer, CacheMetrics>emptyMap();\n\n                        updateMetrics(nodeId, metricsSet.metrics(), cacheMetrics, tstamp);\n\n                        for (T2<UUID, ClusterMetrics> t : metricsSet.clientMetrics())\n                            updateMetrics(t.get1(), t.get2(), cacheMetrics, tstamp);\n                    }\n                }\n            }\n        }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * FOR TEST PURPOSE ONLY!\n     */\n    void simulateNodeFailure() {\n        U.warn(log, \"Simulating client node failure: \" + getLocalNodeId());\n\n        U.closeQuiet(sock);\n\n        U.interrupt(disconnectHnd);\n        U.join(disconnectHnd, log);\n\n        U.interrupt(hbSender);\n        U.join(hbSender, log);\n\n        U.interrupt(sockRdr);\n        U.join(sockRdr, log);\n\n        U.interrupt(sockTimeoutWorker);\n        U.join(sockTimeoutWorker, log);\n    }","id":26666,"modified_method":"/**\n     * FOR TEST PURPOSE ONLY!\n     */\n    void simulateNodeFailure() {\n        U.warn(log, \"Simulating client node failure: \" + getLocalNodeId());\n\n        U.interrupt(sockWriter);\n        U.interrupt(msgWorker);\n        U.interrupt(sockTimeoutWorker);\n\n        U.join(sockWriter, log);\n        U.join(msgWorker, log);\n        U.join(sockTimeoutWorker, log);\n\n        timer.cancel();\n    }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/**\n         * @param msg Message.\n         */\n        private void processClientReconnectMessage(TcpDiscoveryClientReconnectMessage msg) {\n            if (leaveLatch != null)\n                return;\n\n            if (getLocalNodeId().equals(msg.creatorNodeId())) {\n                if (msg.success()) {\n                    pending = true;\n\n                    try {\n                        for (TcpDiscoveryAbstractMessage pendingMsg : msg.pendingMessages())\n                            processMessage(pendingMsg);\n                    }\n                    finally {\n                        pending = false;\n                    }\n\n                    joinErr = null;\n                    reconFailed = false;\n\n                    joinLatch.countDown();\n                }\n                else {\n                    joinErr = null;\n                    reconFailed = true;\n\n                    getSpiContext().recordEvent(new DiscoveryEvent(locNode,\n                        \"Client node disconnected: \" + locNode,\n                        EVT_CLIENT_NODE_DISCONNECTED, locNode));\n\n                    joinLatch.countDown();\n                }\n            }\n            else if (log.isDebugEnabled())\n                log.debug(\"Discarding reconnect message for another client: \" + msg);\n        }","id":26667,"modified_method":"/**\n         * @param msg Message.\n         */\n        private void processClientReconnectMessage(TcpDiscoveryClientReconnectMessage msg) {\n            if (getSpiContext().isStopping())\n                return;\n\n            if (getLocalNodeId().equals(msg.creatorNodeId())) {\n\n            }\n\n            if (getLocalNodeId().equals(msg.creatorNodeId())) {\n                if (msg.success()) {\n                    pending = true;\n\n                    try {\n                        for (TcpDiscoveryAbstractMessage pendingMsg : msg.pendingMessages())\n                            processDiscoveryMessage(pendingMsg);\n                    }\n                    finally {\n                        pending = false;\n                    }\n                }\n                else {\n                    getSpiContext().recordEvent(new DiscoveryEvent(locNode,\n                        \"Client node disconnected: \" + locNode,\n                        EVT_NODE_SEGMENTED, locNode));\n\n                }\n            }\n            else if (log.isDebugEnabled())\n                log.debug(\"Discarding reconnect message for another client: \" + msg);\n        }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/**\n         * @param recon Whether reconnection is in progress.\n         */\n        protected MessageWorker(boolean recon) {\n            super(\"tcp-client-disco-msg-worker\");\n\n            this.recon = recon;\n        }","id":26668,"modified_method":"/**\n         *\n         */\n        private MessageWorker() {\n            super(gridName, \"tcp-client-disco-msg-worker\", log);\n        }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/**\n         * @param msg Message.\n         */\n        private void processNodeFailedMessage(TcpDiscoveryNodeFailedMessage msg) {\n            if (leaveLatch != null)\n                return;\n\n            if (!getLocalNodeId().equals(msg.creatorNodeId())) {\n                TcpDiscoveryNode node = rmtNodes.remove(msg.failedNodeId());\n\n                if (node == null) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Discarding node failed message since node is not found [msg=\" + msg + ']');\n\n                    return;\n                }\n\n                Collection<ClusterNode> top = updateTopologyHistory(msg.topologyVersion());\n\n                if (!pending && joinLatch.getCount() > 0) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Discarding node failed message (join process is not finished): \" + msg);\n\n                    return;\n                }\n\n                notifyDiscovery(EVT_NODE_FAILED, msg.topologyVersion(), node, top);\n\n                stats.onNodeFailed();\n            }\n        }","id":26669,"modified_method":"/**\n         * @param msg Message.\n         */\n        private void processNodeFailedMessage(TcpDiscoveryNodeFailedMessage msg) {\n            if (getSpiContext().isStopping()) {\n                if (!getLocalNodeId().equals(msg.creatorNodeId()) && getLocalNodeId().equals(msg.failedNodeId())) {\n                    if (leaveLatch.getCount() > 0) {\n                        log.debug(\"Remote node fail this node while node is stopping [locNode=\" + getLocalNodeId()\n                            + \", rmtNode=\" + msg.creatorNodeId() + ']');\n\n                        leaveLatch.countDown();\n                    }\n                }\n                return;\n            }\n\n            if (!getLocalNodeId().equals(msg.creatorNodeId())) {\n                TcpDiscoveryNode node = rmtNodes.remove(msg.failedNodeId());\n\n                if (node == null) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Discarding node failed message since node is not found [msg=\" + msg + ']');\n\n                    return;\n                }\n\n                Collection<ClusterNode> top = updateTopologyHistory(msg.topologyVersion());\n\n                if (!pending && joinLatch.getCount() > 0) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Discarding node failed message (join process is not finished): \" + msg);\n\n                    return;\n                }\n\n                notifyDiscovery(EVT_NODE_FAILED, msg.topologyVersion(), node, top);\n\n                stats.onNodeFailed();\n            }\n        }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/**\n         * @param msg Message.\n         */\n        private void processNodeAddedMessage(TcpDiscoveryNodeAddedMessage msg) {\n            if (leaveLatch != null)\n                return;\n\n            TcpDiscoveryNode node = msg.node();\n\n            UUID newNodeId = node.id();\n\n            if (getLocalNodeId().equals(newNodeId)) {\n                if (joinLatch.getCount() > 0) {\n                    Collection<TcpDiscoveryNode> top = msg.topology();\n\n                    if (top != null) {\n                        gridStartTime = msg.gridStartTime();\n\n                        for (TcpDiscoveryNode n : top) {\n                            if (n.order() > 0)\n                                n.visible(true);\n\n                            rmtNodes.put(n.id(), n);\n                        }\n\n                        topHist.clear();\n\n                        if (msg.topologyHistory() != null)\n                            topHist.putAll(msg.topologyHistory());\n\n                        Map<UUID, Map<Integer, byte[]>> dataMap = msg.oldNodesDiscoveryData();\n\n                        if (dataMap != null) {\n                            for (Map.Entry<UUID, Map<Integer, byte[]>> entry : dataMap.entrySet())\n                                onExchange(newNodeId, entry.getKey(), entry.getValue(), null);\n                        }\n\n                        locNode.setAttributes(node.attributes());\n                        locNode.visible(true);\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Discarding node added message with empty topology: \" + msg);\n                }\n                else if (log.isDebugEnabled())\n                    log.debug(\"Discarding node added message (this message has already been processed) \" +\n                        \"[msg=\" + msg + \", locNode=\" + locNode + ']');\n            }\n            else {\n                boolean topChanged = rmtNodes.putIfAbsent(newNodeId, node) == null;\n\n                if (topChanged) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Added new node to topology: \" + node);\n\n                    Map<Integer, byte[]> data = msg.newNodeDiscoveryData();\n\n                    if (data != null)\n                        onExchange(newNodeId, newNodeId, data, null);\n                }\n            }\n        }","id":26670,"modified_method":"/**\n         * @param msg Message.\n         */\n        private void processNodeAddedMessage(TcpDiscoveryNodeAddedMessage msg) {\n            if (getSpiContext().isStopping())\n                return;\n\n            TcpDiscoveryNode node = msg.node();\n\n            UUID newNodeId = node.id();\n\n            if (getLocalNodeId().equals(newNodeId)) {\n                if (joinLatch.getCount() > 0) {\n                    Collection<TcpDiscoveryNode> top = msg.topology();\n\n                    if (top != null) {\n                        gridStartTime = msg.gridStartTime();\n\n                        for (TcpDiscoveryNode n : top) {\n                            if (n.order() > 0)\n                                n.visible(true);\n\n                            rmtNodes.put(n.id(), n);\n                        }\n\n                        topHist.clear();\n\n                        if (msg.topologyHistory() != null)\n                            topHist.putAll(msg.topologyHistory());\n\n                        Map<UUID, Map<Integer, byte[]>> dataMap = msg.oldNodesDiscoveryData();\n\n                        if (dataMap != null) {\n                            for (Map.Entry<UUID, Map<Integer, byte[]>> entry : dataMap.entrySet())\n                                onExchange(newNodeId, entry.getKey(), entry.getValue(), null);\n                        }\n\n                        locNode.setAttributes(node.attributes());\n                        locNode.visible(true);\n                    }\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Discarding node added message with empty topology: \" + msg);\n                }\n                else if (log.isDebugEnabled())\n                    log.debug(\"Discarding node added message (this message has already been processed) \" +\n                        \"[msg=\" + msg + \", locNode=\" + locNode + ']');\n            }\n            else {\n                boolean topChanged = rmtNodes.putIfAbsent(newNodeId, node) == null;\n\n                if (topChanged) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Added new node to topology: \" + node);\n\n                    Map<Integer, byte[]> data = msg.newNodeDiscoveryData();\n\n                    if (data != null)\n                        onExchange(newNodeId, newNodeId, data, null);\n                }\n            }\n        }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void spiStop() throws IgniteSpiException {\n        rmtNodes.clear();\n\n        U.interrupt(disconnectHnd);\n        U.join(disconnectHnd, log);\n\n        U.interrupt(hbSender);\n        U.join(hbSender, log);\n\n        Socket sock0 = sock;\n\n        sock = null;\n\n        if (sock0 != null) {\n            leaveLatch = new CountDownLatch(1);\n\n            try {\n                TcpDiscoveryNodeLeftMessage msg = new TcpDiscoveryNodeLeftMessage(getLocalNodeId());\n\n                msg.client(true);\n\n                writeToSocket(sock0, msg);\n\n                if (!U.await(leaveLatch, netTimeout, MILLISECONDS)) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Did not receive node left message for local node (will stop anyway) [sock=\" +\n                            sock0 + ']');\n                }\n            }\n            catch (IOException | IgniteCheckedException e) {\n                if (log.isDebugEnabled())\n                    U.error(log, \"Failed to send node left message (will stop anyway) [sock=\" + sock0 + ']', e);\n            }\n            finally {\n                U.closeQuiet(sock0);\n            }\n        }\n\n        U.interrupt(sockRdr);\n        U.join(sockRdr, log);\n\n        U.interrupt(sockTimeoutWorker);\n        U.join(sockTimeoutWorker, log);\n\n        unregisterMBean();\n\n        if (log.isDebugEnabled())\n            log.debug(stopInfo());\n    }","id":26671,"modified_method":"/** {@inheritDoc} */\n    @Override public void spiStop() throws IgniteSpiException {\n        timer.cancel();\n\n        if (msgWorker.isAlive()) { // Should always be alive\n            msgWorker.addMessage(SPI_STOP);\n\n            try {\n                if (!leaveLatch.await(10000, MILLISECONDS)) {\n                    System.out.println(\"leaveLatch Timeout!!!!\");\n\n                    if (log.isDebugEnabled())\n                        U.error(log, \"Failed to left node: timeout [nodeId=\" + locNode + ']');\n                }\n            }\n            catch (InterruptedException ignored) {\n\n            }\n        }\n\n        rmtNodes.clear();\n\n        U.interrupt(sockTimeoutWorker);\n        U.interrupt(msgWorker);\n        U.interrupt(sockWriter);\n        U.interrupt(sockReader);\n\n        U.join(msgWorker, log);\n        U.join(sockTimeoutWorker, log);\n        U.join(sockWriter, log);\n        U.join(sockReader, log);\n\n        unregisterMBean();\n\n        if (log.isDebugEnabled())\n            log.debug(stopInfo());\n    }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"/**\n         * @param msg Message.\n         */\n        private void processNodeAddFinishedMessage(TcpDiscoveryNodeAddFinishedMessage msg) {\n            if (leaveLatch != null)\n                return;\n\n            if (getLocalNodeId().equals(msg.nodeId())) {\n                if (joinLatch.getCount() > 0) {\n                    long topVer = msg.topologyVersion();\n\n                    locNode.order(topVer);\n\n                    notifyDiscovery(EVT_NODE_JOINED, topVer, locNode, updateTopologyHistory(topVer));\n\n                    joinErr = null;\n\n                    joinLatch.countDown();\n                }\n                else if (log.isDebugEnabled())\n                    log.debug(\"Discarding node add finished message (this message has already been processed) \" +\n                        \"[msg=\" + msg + \", locNode=\" + locNode + ']');\n            }\n            else {\n                TcpDiscoveryNode node = rmtNodes.get(msg.nodeId());\n\n                if (node == null) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Discarding node add finished message since node is not found [msg=\" + msg + ']');\n\n                    return;\n                }\n\n                long topVer = msg.topologyVersion();\n\n                node.order(topVer);\n                node.visible(true);\n\n                if (locNodeVer.equals(node.version()))\n                    node.version(locNodeVer);\n\n                Collection<ClusterNode> top = updateTopologyHistory(topVer);\n\n                if (!pending && joinLatch.getCount() > 0) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Discarding node add finished message (join process is not finished): \" + msg);\n\n                    return;\n                }\n\n                notifyDiscovery(EVT_NODE_JOINED, topVer, node, top);\n\n                stats.onNodeJoined();\n            }\n        }","id":26672,"modified_method":"/**\n         * @param msg Message.\n         */\n        private void processNodeAddFinishedMessage(TcpDiscoveryNodeAddFinishedMessage msg) {\n            if (getSpiContext().isStopping())\n                return;\n\n            if (getLocalNodeId().equals(msg.nodeId())) {\n                if (joinLatch.getCount() > 0) {\n                    long topVer = msg.topologyVersion();\n\n                    locNode.order(topVer);\n\n                    notifyDiscovery(EVT_NODE_JOINED, topVer, locNode, updateTopologyHistory(topVer));\n\n                    joinErr = null;\n\n                    joinLatch.countDown();\n\n                    stats.onJoinFinished();\n                }\n                else if (log.isDebugEnabled())\n                    log.debug(\"Discarding node add finished message (this message has already been processed) \" +\n                        \"[msg=\" + msg + \", locNode=\" + locNode + ']');\n            }\n            else {\n                TcpDiscoveryNode node = rmtNodes.get(msg.nodeId());\n\n                if (node == null) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Discarding node add finished message since node is not found [msg=\" + msg + ']');\n\n                    return;\n                }\n\n                long topVer = msg.topologyVersion();\n\n                node.order(topVer);\n                node.visible(true);\n\n                if (locNodeVer.equals(node.version()))\n                    node.version(locNodeVer);\n\n                Collection<ClusterNode> top = updateTopologyHistory(topVer);\n\n                if (!pending && joinLatch.getCount() > 0) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Discarding node add finished message (join process is not finished): \" + msg);\n\n                    return;\n                }\n\n                notifyDiscovery(EVT_NODE_JOINED, topVer, node, top);\n\n                stats.onNodeJoined();\n            }\n        }","commit_id":"fd778e617f7835b51f8879a86761ee8036e0a915","url":"https://github.com/apache/ignite"},{"original_method":"private static String getVariableRelatedPath(String var, String path) {\n    return var == null ? null : (\"file://$\" + var + \"$\" + (path == null ? \"\" : (\"/\" + path)));\n  }","id":26673,"modified_method":"private static String getVariableRelatedPath(String var, String path) {\n    return var == null ? null : (\"$\" + var + \"$\" + (path == null ? \"\" : (\"/\" + path)));\n  }","commit_id":"a996d24ec0ccc2e42aa34eeca8674cd1569b8870","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void readClasspathEntry(ModifiableRootModel rootModel,\n                                  final Collection<String> unknownLibraries, Collection<String> unknownJdks, final Set<String> usedVariables,\n                                  Set<String> refsToModules, final String testPattern,\n                                  Element element)\n    throws ConversionException {\n    String kind = element.getAttributeValue(EclipseXml.KIND_ATTR);\n    if (kind == null) {\n      throw new ConversionException(\"Missing classpathentry/@kind\");\n    }\n\n\n    String path = element.getAttributeValue(EclipseXml.PATH_ATTR);\n    if (path == null) {\n      throw new ConversionException(\"Missing classpathentry/@path\");\n    }\n\n    final boolean exported = EclipseXml.TRUE_VALUE.equals(element.getAttributeValue(EclipseXml.EXPORTED_ATTR));\n\n    if (kind.equals(EclipseXml.SRC_KIND)) {\n      if (path.startsWith(\"/\")) {\n        final String moduleName = path.substring(1);\n        refsToModules.add(moduleName);\n        rootModel.addInvalidModuleEntry(moduleName).setExported(exported);\n      }\n      else {\n        getContentEntry().addSourceFolder(VfsUtil.pathToUrl(myRootPath + \"/\" + path), testPattern != null && path.matches(testPattern));\n      }\n    }\n\n    else if (kind.equals(EclipseXml.OUTPUT_KIND)) {\n      final CompilerModuleExtension compilerModuleExtension = rootModel.getModuleExtension(CompilerModuleExtension.class);\n      compilerModuleExtension.setCompilerOutputPath(VfsUtil.pathToUrl(myRootPath + \"/\" + path));\n      compilerModuleExtension.inheritCompilerOutputPath(false);\n    }\n\n    else if (kind.equals(EclipseXml.LIB_KIND)) {\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n      modifiableModel.addRoot(getUrl(path), OrderRootType.CLASSES);\n\n      final String sourcePath = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (sourcePath != null) {\n        modifiableModel.addRoot(getUrl(sourcePath), OrderRootType.SOURCES);\n      }\n\n      final List<String> docPaths = getClasspathEntryAttribute(element);\n      if (docPaths != null) {\n        for (String docPath : docPaths) {\n          modifiableModel.addRoot(docPath, JavadocOrderRootType.getInstance());\n        }\n      }\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.VAR_KIND)) {\n      int slash = path.indexOf(\"/\");\n      if (slash == 0) {\n        throw new ConversionException(\"Incorrect 'classpathentry/var@path' format\");\n      }\n\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n\n      final String clsVar;\n      final String clsPath;\n      if (slash > 0) {\n        clsVar = path.substring(0, slash);\n        clsPath = path.substring(slash + 1);\n      }\n      else {\n        clsVar = path;\n        clsPath = null;\n      }\n      usedVariables.add(clsVar);\n      modifiableModel.addRoot(PathMacroManager.getInstance(rootModel.getModule()).expandPath(getVariableRelatedPath(clsVar, clsPath)), OrderRootType.CLASSES);\n\n      final String srcPathAttr = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (srcPathAttr != null) {\n        final String srcVar;\n        final String srcPath;\n        final int varStart = srcPathAttr.startsWith(\"/\") ? 1 : 0;\n\n        int slash2 = srcPathAttr.indexOf(\"/\", varStart);\n        if (slash2 > 0) {\n          srcVar = srcPathAttr.substring(varStart, slash2);\n          srcPath = srcPathAttr.substring(slash2 + 1);\n        }\n        else {\n          srcVar = srcPathAttr.substring(varStart);\n          srcPath = null;\n        }\n        usedVariables.add(srcVar);\n        modifiableModel.addRoot(PathMacroManager.getInstance(rootModel.getModule()).expandPath(getVariableRelatedPath(srcVar, srcPath)), OrderRootType.SOURCES);\n      }\n\n      final List<String> docPaths = getClasspathEntryAttribute(element);\n      if (docPaths != null) {\n        for (String docPath : docPaths) {\n          modifiableModel.addRoot(docPath, JavadocOrderRootType.getInstance());\n        }\n      }\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.CON_KIND)) {\n      if (path.equals(EclipseXml.ECLIPSE_PLATFORM)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, IdeaXml.ECLIPSE_LIBRARY);\n      }\n      else if (path.startsWith(EclipseXml.JRE_CONTAINER)) {\n\n        final String jdkName = getLastPathComponent(path);\n        if (jdkName == null) {\n          rootModel.inheritSdk();\n        }\n        else {\n          final Sdk moduleJdk = ProjectJdkTable.getInstance().findJdk(jdkName);\n          if (moduleJdk != null) {\n            rootModel.setSdk(moduleJdk);\n          }\n          else {\n            rootModel.setInvalidSdk(jdkName, IdeaXml.JAVA_SDK_TYPE);\n            unknownJdks.add(jdkName);\n          }\n        }\n        OrderEntry[] orderEntries = rootModel.getOrderEntries();\n        orderEntries = ArrayUtil.append(orderEntries, orderEntries[0]);\n        rootModel.rearrangeOrderEntries(ArrayUtil.remove(orderEntries, 0));\n      }\n      else if (path.startsWith(EclipseXml.USER_LIBRARY)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, getPresentableName(path));\n      }\n      else if (path.startsWith(EclipseXml.JUNIT_CONTAINER)) {\n        final String junitName = IdeaXml.JUNIT + getPresentableName(path);\n        final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(junitName);\n        final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n        modifiableModel.addRoot(getJunitClsUrl(junitName.contains(\"4\")), OrderRootType.CLASSES);\n        modifiableModel.commit();\n      }\n    }\n    else {\n      throw new ConversionException(\"Unknown classpathentry/@kind: \" + kind);\n    }\n  }","id":26674,"modified_method":"private void readClasspathEntry(ModifiableRootModel rootModel,\n                                  final Collection<String> unknownLibraries, Collection<String> unknownJdks, final Set<String> usedVariables,\n                                  Set<String> refsToModules, final String testPattern,\n                                  Element element)\n    throws ConversionException {\n    String kind = element.getAttributeValue(EclipseXml.KIND_ATTR);\n    if (kind == null) {\n      throw new ConversionException(\"Missing classpathentry/@kind\");\n    }\n\n\n    String path = element.getAttributeValue(EclipseXml.PATH_ATTR);\n    if (path == null) {\n      throw new ConversionException(\"Missing classpathentry/@path\");\n    }\n\n    final boolean exported = EclipseXml.TRUE_VALUE.equals(element.getAttributeValue(EclipseXml.EXPORTED_ATTR));\n\n    if (kind.equals(EclipseXml.SRC_KIND)) {\n      if (path.startsWith(\"/\")) {\n        final String moduleName = path.substring(1);\n        refsToModules.add(moduleName);\n        rootModel.addInvalidModuleEntry(moduleName).setExported(exported);\n      }\n      else {\n        getContentEntry().addSourceFolder(VfsUtil.pathToUrl(myRootPath + \"/\" + path), testPattern != null && path.matches(testPattern));\n      }\n    }\n\n    else if (kind.equals(EclipseXml.OUTPUT_KIND)) {\n      final CompilerModuleExtension compilerModuleExtension = rootModel.getModuleExtension(CompilerModuleExtension.class);\n      compilerModuleExtension.setCompilerOutputPath(VfsUtil.pathToUrl(myRootPath + \"/\" + path));\n      compilerModuleExtension.inheritCompilerOutputPath(false);\n    }\n\n    else if (kind.equals(EclipseXml.LIB_KIND)) {\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n      modifiableModel.addRoot(getUrl(path), OrderRootType.CLASSES);\n\n      final String sourcePath = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (sourcePath != null) {\n        modifiableModel.addRoot(getUrl(sourcePath), OrderRootType.SOURCES);\n      }\n\n      final List<String> docPaths = getClasspathEntryAttribute(element);\n      if (docPaths != null) {\n        for (String docPath : docPaths) {\n          modifiableModel.addRoot(docPath, JavadocOrderRootType.getInstance());\n        }\n      }\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.VAR_KIND)) {\n      int slash = path.indexOf(\"/\");\n      if (slash == 0) {\n        throw new ConversionException(\"Incorrect 'classpathentry/var@path' format\");\n      }\n\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n\n      final String clsVar;\n      final String clsPath;\n      if (slash > 0) {\n        clsVar = path.substring(0, slash);\n        clsPath = path.substring(slash + 1);\n      }\n      else {\n        clsVar = path;\n        clsPath = null;\n      }\n      usedVariables.add(clsVar);\n      final String url = PathMacroManager.getInstance(rootModel.getModule()).expandPath(getVariableRelatedPath(clsVar, clsPath));\n      modifiableModel.addRoot(getUrl(url), OrderRootType.CLASSES);\n\n      final String srcPathAttr = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (srcPathAttr != null) {\n        final String srcVar;\n        final String srcPath;\n        final int varStart = srcPathAttr.startsWith(\"/\") ? 1 : 0;\n\n        int slash2 = srcPathAttr.indexOf(\"/\", varStart);\n        if (slash2 > 0) {\n          srcVar = srcPathAttr.substring(varStart, slash2);\n          srcPath = srcPathAttr.substring(slash2 + 1);\n        }\n        else {\n          srcVar = srcPathAttr.substring(varStart);\n          srcPath = null;\n        }\n        usedVariables.add(srcVar);\n        final String srcUrl = PathMacroManager.getInstance(rootModel.getModule()).expandPath(getVariableRelatedPath(srcVar, srcPath));\n        modifiableModel.addRoot(getUrl(srcUrl), OrderRootType.SOURCES);\n      }\n\n      final List<String> docPaths = getClasspathEntryAttribute(element);\n      if (docPaths != null) {\n        for (String docPath : docPaths) {\n          modifiableModel.addRoot(docPath, JavadocOrderRootType.getInstance());\n        }\n      }\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.CON_KIND)) {\n      if (path.equals(EclipseXml.ECLIPSE_PLATFORM)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, IdeaXml.ECLIPSE_LIBRARY);\n      }\n      else if (path.startsWith(EclipseXml.JRE_CONTAINER)) {\n\n        final String jdkName = getLastPathComponent(path);\n        if (jdkName == null) {\n          rootModel.inheritSdk();\n        }\n        else {\n          final Sdk moduleJdk = ProjectJdkTable.getInstance().findJdk(jdkName);\n          if (moduleJdk != null) {\n            rootModel.setSdk(moduleJdk);\n          }\n          else {\n            rootModel.setInvalidSdk(jdkName, IdeaXml.JAVA_SDK_TYPE);\n            unknownJdks.add(jdkName);\n          }\n        }\n        OrderEntry[] orderEntries = rootModel.getOrderEntries();\n        orderEntries = ArrayUtil.append(orderEntries, orderEntries[0]);\n        rootModel.rearrangeOrderEntries(ArrayUtil.remove(orderEntries, 0));\n      }\n      else if (path.startsWith(EclipseXml.USER_LIBRARY)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, getPresentableName(path));\n      }\n      else if (path.startsWith(EclipseXml.JUNIT_CONTAINER)) {\n        final String junitName = IdeaXml.JUNIT + getPresentableName(path);\n        final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(junitName);\n        final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n        modifiableModel.addRoot(getJunitClsUrl(junitName.contains(\"4\")), OrderRootType.CLASSES);\n        modifiableModel.commit();\n      }\n    }\n    else {\n      throw new ConversionException(\"Unknown classpathentry/@kind: \" + kind);\n    }\n  }","commit_id":"a996d24ec0ccc2e42aa34eeca8674cd1569b8870","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void readClasspathEntry(ModifiableRootModel rootModel,\n                                  final Collection<String> unknownLibraries,\n                                  Collection<String> unknownJdks,\n                                  final Set<String> usedVariables,\n                                  Set<String> refsToModules,\n                                  final String testPattern,\n                                  Element element) throws ConversionException {\n    String kind = element.getAttributeValue(EclipseXml.KIND_ATTR);\n    if (kind == null) {\n      throw new ConversionException(\"Missing classpathentry/@kind\");\n    }\n\n\n    String path = element.getAttributeValue(EclipseXml.PATH_ATTR);\n    if (path == null) {\n      throw new ConversionException(\"Missing classpathentry/@path\");\n    }\n\n    final boolean exported = EclipseXml.TRUE_VALUE.equals(element.getAttributeValue(EclipseXml.EXPORTED_ATTR));\n\n    if (kind.equals(EclipseXml.SRC_KIND)) {\n      if (path.startsWith(\"/\")) {\n        final String moduleName = path.substring(1);\n        refsToModules.add(moduleName);\n        rootModel.addInvalidModuleEntry(moduleName).setExported(exported);\n      }\n      else {\n        getContentEntry().addSourceFolder(VfsUtil.pathToUrl(myRootPath + \"/\" + path), testPattern != null && testPattern.length() > 0 && path.matches(testPattern));\n      }\n    }\n\n    else if (kind.equals(EclipseXml.OUTPUT_KIND)) {\n      setupOutput(rootModel, myRootPath + \"/\" + path);\n    }\n\n    else if (kind.equals(EclipseXml.LIB_KIND)) {\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n      modifiableModel.addRoot(getUrl(path), OrderRootType.CLASSES);\n\n      final String sourcePath = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (sourcePath != null) {\n        modifiableModel.addRoot(getUrl(sourcePath), OrderRootType.SOURCES);\n      }\n\n      final List<String> docPaths = getJavadocAttribute(element);\n      if (docPaths != null) {\n        for (String docPath : docPaths) {\n          modifiableModel.addRoot(docPath, JavadocOrderRootType.getInstance());\n        }\n      }\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.VAR_KIND)) {\n      int slash = path.indexOf(\"/\");\n      if (slash == 0) {\n        throw new ConversionException(\"Incorrect 'classpathentry/var@path' format\");\n      }\n\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n\n      final String clsVar;\n      final String clsPath;\n      if (slash > 0) {\n        clsVar = path.substring(0, slash);\n        clsPath = path.substring(slash + 1);\n      }\n      else {\n        clsVar = path;\n        clsPath = null;\n      }\n      usedVariables.add(clsVar);\n      final String url = PathMacroManager.getInstance(rootModel.getModule()).expandPath(getVariableRelatedPath(clsVar, clsPath));\n      modifiableModel.addRoot(getUrl(url), OrderRootType.CLASSES);\n\n      final String srcPathAttr = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (srcPathAttr != null) {\n        final String srcVar;\n        final String srcPath;\n        final int varStart = srcPathAttr.startsWith(\"/\") ? 1 : 0;\n\n        int slash2 = srcPathAttr.indexOf(\"/\", varStart);\n        if (slash2 > 0) {\n          srcVar = srcPathAttr.substring(varStart, slash2);\n          srcPath = srcPathAttr.substring(slash2 + 1);\n        }\n        else {\n          srcVar = srcPathAttr.substring(varStart);\n          srcPath = null;\n        }\n        usedVariables.add(srcVar);\n        final String srcUrl = PathMacroManager.getInstance(rootModel.getModule()).expandPath(getVariableRelatedPath(srcVar, srcPath));\n        modifiableModel.addRoot(getUrl(srcUrl), OrderRootType.SOURCES);\n      }\n\n      final List<String> docPaths = getJavadocAttribute(element);\n      if (docPaths != null) {\n        for (String docPath : docPaths) {\n          modifiableModel.addRoot(docPath, JavadocOrderRootType.getInstance());\n        }\n      }\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.CON_KIND)) {\n      if (path.equals(EclipseXml.ECLIPSE_PLATFORM)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, IdeaXml.ECLIPSE_LIBRARY, LibraryTablesRegistrar.APPLICATION_LEVEL);\n      }\n      else if (path.startsWith(EclipseXml.JRE_CONTAINER)) {\n\n        final String jdkName = getLastPathComponent(path);\n        if (jdkName == null) {\n          rootModel.inheritSdk();\n        }\n        else {\n          final Sdk moduleJdk = ProjectJdkTable.getInstance().findJdk(jdkName);\n          if (moduleJdk != null) {\n            rootModel.setSdk(moduleJdk);\n          }\n          else {\n            rootModel.setInvalidSdk(jdkName, IdeaXml.JAVA_SDK_TYPE);\n            unknownJdks.add(jdkName);\n          }\n        }\n        OrderEntry[] orderEntries = rootModel.getOrderEntries();\n        orderEntries = ArrayUtil.append(orderEntries, orderEntries[0]);\n        rootModel.rearrangeOrderEntries(ArrayUtil.remove(orderEntries, 0));\n      }\n      else if (path.startsWith(EclipseXml.USER_LIBRARY)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, getPresentableName(path), LibraryTablesRegistrar.PROJECT_LEVEL);\n      }\n      else if (path.startsWith(EclipseXml.JUNIT_CONTAINER)) {\n        final String junitName = IdeaXml.JUNIT + getPresentableName(path);\n        final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(junitName);\n        final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n        modifiableModel.addRoot(getJunitClsUrl(junitName.contains(\"4\")), OrderRootType.CLASSES);\n        modifiableModel.commit();\n      }\n    }\n    else {\n      throw new ConversionException(\"Unknown classpathentry/@kind: \" + kind);\n    }\n  }","id":26675,"modified_method":"private void readClasspathEntry(ModifiableRootModel rootModel,\n                                  final Collection<String> unknownLibraries,\n                                  Collection<String> unknownJdks,\n                                  final Set<String> usedVariables,\n                                  Set<String> refsToModules,\n                                  final String testPattern,\n                                  Element element) throws ConversionException {\n    String kind = element.getAttributeValue(EclipseXml.KIND_ATTR);\n    if (kind == null) {\n      throw new ConversionException(\"Missing classpathentry/@kind\");\n    }\n\n\n    String path = element.getAttributeValue(EclipseXml.PATH_ATTR);\n    if (path == null) {\n      throw new ConversionException(\"Missing classpathentry/@path\");\n    }\n\n    final boolean exported = EclipseXml.TRUE_VALUE.equals(element.getAttributeValue(EclipseXml.EXPORTED_ATTR));\n\n    if (kind.equals(EclipseXml.SRC_KIND)) {\n      if (path.startsWith(\"/\")) {\n        final String moduleName = path.substring(1);\n        refsToModules.add(moduleName);\n        rootModel.addInvalidModuleEntry(moduleName).setExported(exported);\n      }\n      else {\n        getContentEntry().addSourceFolder(VfsUtil.pathToUrl(myRootPath + \"/\" + path), testPattern != null && testPattern.length() > 0 && path.matches(testPattern));\n      }\n    }\n\n    else if (kind.equals(EclipseXml.OUTPUT_KIND)) {\n      setupOutput(rootModel, myRootPath + \"/\" + path);\n    }\n\n    else if (kind.equals(EclipseXml.LIB_KIND)) {\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n      modifiableModel.addRoot(getUrl(path), OrderRootType.CLASSES);\n\n      final String sourcePath = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (sourcePath != null) {\n        modifiableModel.addRoot(getUrl(sourcePath), OrderRootType.SOURCES);\n      }\n\n      final List<String> docPaths = getJavadocAttribute(element);\n      if (docPaths != null) {\n        for (String docPath : docPaths) {\n          modifiableModel.addRoot(docPath, JavadocOrderRootType.getInstance());\n        }\n      }\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.VAR_KIND)) {\n      int slash = path.indexOf(\"/\");\n      if (slash == 0) {\n        throw new ConversionException(\"Incorrect 'classpathentry/var@path' format\");\n      }\n\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n\n      final String clsVar;\n      final String clsPath;\n      if (slash > 0) {\n        clsVar = path.substring(0, slash);\n        clsPath = path.substring(slash + 1);\n      }\n      else {\n        clsVar = path;\n        clsPath = null;\n      }\n      usedVariables.add(clsVar);\n\n      final String url = getUrl(PathMacroManager.getInstance(rootModel.getModule()).expandPath(getVariableRelatedPath(clsVar, clsPath)));\n      EclipseModuleManager.getInstance(rootModel.getModule()).registerEclipseVariablePath(url, path);\n      modifiableModel.addRoot(url, OrderRootType.CLASSES);\n\n      final String srcPathAttr = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (srcPathAttr != null) {\n        final String srcVar;\n        final String srcPath;\n        final int varStart = srcPathAttr.startsWith(\"/\") ? 1 : 0;\n\n        int slash2 = srcPathAttr.indexOf(\"/\", varStart);\n        if (slash2 > 0) {\n          srcVar = srcPathAttr.substring(varStart, slash2);\n          srcPath = srcPathAttr.substring(slash2 + 1);\n        }\n        else {\n          srcVar = srcPathAttr.substring(varStart);\n          srcPath = null;\n        }\n        usedVariables.add(srcVar);\n        final String srcUrl = getUrl(PathMacroManager.getInstance(rootModel.getModule()).expandPath(getVariableRelatedPath(srcVar, srcPath)));\n        EclipseModuleManager.getInstance(rootModel.getModule()).registerEclipseSrcVariablePath(srcUrl, srcPathAttr);\n        modifiableModel.addRoot(srcUrl, OrderRootType.SOURCES);\n      }\n\n      final List<String> docPaths = getJavadocAttribute(element);\n      if (docPaths != null) {\n        for (String docPath : docPaths) {\n          modifiableModel.addRoot(docPath, JavadocOrderRootType.getInstance());\n        }\n      }\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.CON_KIND)) {\n      if (path.equals(EclipseXml.ECLIPSE_PLATFORM)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, IdeaXml.ECLIPSE_LIBRARY, LibraryTablesRegistrar.APPLICATION_LEVEL);\n      }\n      else if (path.startsWith(EclipseXml.JRE_CONTAINER)) {\n\n        final String jdkName = getLastPathComponent(path);\n        if (jdkName == null) {\n          rootModel.inheritSdk();\n        }\n        else {\n          final Sdk moduleJdk = ProjectJdkTable.getInstance().findJdk(jdkName);\n          if (moduleJdk != null) {\n            rootModel.setSdk(moduleJdk);\n          }\n          else {\n            rootModel.setInvalidSdk(jdkName, IdeaXml.JAVA_SDK_TYPE);\n            unknownJdks.add(jdkName);\n          }\n        }\n        OrderEntry[] orderEntries = rootModel.getOrderEntries();\n        orderEntries = ArrayUtil.append(orderEntries, orderEntries[0]);\n        rootModel.rearrangeOrderEntries(ArrayUtil.remove(orderEntries, 0));\n      }\n      else if (path.startsWith(EclipseXml.USER_LIBRARY)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, getPresentableName(path), LibraryTablesRegistrar.PROJECT_LEVEL);\n      }\n      else if (path.startsWith(EclipseXml.JUNIT_CONTAINER)) {\n        final String junitName = IdeaXml.JUNIT + getPresentableName(path);\n        final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(junitName);\n        final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n        modifiableModel.addRoot(getJunitClsUrl(junitName.contains(\"4\")), OrderRootType.CLASSES);\n        modifiableModel.commit();\n      }\n    }\n    else {\n      throw new ConversionException(\"Unknown classpathentry/@kind: \" + kind);\n    }\n  }","commit_id":"00a6e8b8372990fb4c26acebeaaf5088c8435292","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createClasspathEntry(OrderEntry entry, Element classpathRoot, Element oldRoot) throws ConversionException {\n    if (entry instanceof ModuleSourceOrderEntry) {\n      final ContentEntry[] entries = ((ModuleSourceOrderEntry)entry).getRootModel().getContentEntries();\n      if (entries.length > 0) {\n        final ContentEntry contentEntry = entries[0];\n        for (SourceFolder sourceFolder : contentEntry.getSourceFolders()) {\n          addOrderEntry(EclipseXml.SRC_KIND, getRelativePath(sourceFolder.getUrl()), classpathRoot, oldRoot);\n        }\n      }\n    }\n    else if (entry instanceof ModuleOrderEntry) {\n      Element orderEntry = addOrderEntry(EclipseXml.SRC_KIND, \"/\" + ((ModuleOrderEntry)entry).getModuleName(), classpathRoot, oldRoot);\n      setAttributeIfAbsent(orderEntry, EclipseXml.COMBINEACCESSRULES_ATTR, EclipseXml.FALSE_VALUE);\n      setExported(orderEntry, ((ExportableOrderEntry)entry));\n    }\n    else if (entry instanceof LibraryOrderEntry) {\n      final LibraryOrderEntry libraryOrderEntry = (LibraryOrderEntry)entry;\n      final String libraryName = libraryOrderEntry.getLibraryName();\n      if (libraryOrderEntry.isModuleLevel()) {\n        final String[] files = libraryOrderEntry.getUrls(OrderRootType.CLASSES);\n        if (files.length > 0) {\n          if (libraryName != null &&\n              libraryName.contains(IdeaXml.JUNIT) &&\n              Comparing.strEqual(files[0], EclipseClasspathReader.getJunitClsUrl(libraryName.contains(\"4\")))) {\n            final Element orderEntry =\n              addOrderEntry(EclipseXml.CON_KIND, EclipseXml.JUNIT_CONTAINER + \"/\" + libraryName.substring(IdeaXml.JUNIT.length()),\n                            classpathRoot, oldRoot);\n            setExported(orderEntry, libraryOrderEntry);\n          }\n          else {\n            final Project project = myModel.getModule().getProject();\n            final String[] kind = new String[]{EclipseXml.LIB_KIND};\n            String relativeClassPath = getRelativePath(files[0], kind);\n\n            final String[] srcFiles = libraryOrderEntry.getUrls(OrderRootType.SOURCES);\n            final String relativePath;\n            if (srcFiles.length == 0) {\n              relativePath = null;\n            }\n            else {\n              final String[] srcKind = new String[1];\n              final boolean replaceVarsInSrc = Comparing.strEqual(kind[0], EclipseXml.VAR_KIND);\n              relativePath = getRelativePath(srcFiles[srcFiles.length - 1], srcKind, replaceVarsInSrc, project, getContentRoot());\n              if (replaceVarsInSrc && srcKind[0] == null) {\n                kind[0] = EclipseXml.LIB_KIND;\n                relativeClassPath = getRelativePath(files[0], kind, false, project, getContentRoot());\n              }\n            }\n\n            final Element orderEntry = addOrderEntry(kind[0], relativeClassPath, classpathRoot, oldRoot);\n            setOrRemoveAttribute(orderEntry, EclipseXml.SOURCEPATH_ATTR, relativePath);\n\n            //clear javadocs before write new\n            final List children = new ArrayList(orderEntry.getChildren(EclipseXml.ATTRIBUTES_TAG));\n            for (Object o : children) {\n              ((Element)o).detach();\n            }\n            final String[] docUrls = libraryOrderEntry.getUrls(JavadocOrderRootType.getInstance());\n            for (final String docUrl : docUrls) {\n              setJavadocPath(orderEntry, docUrl);\n            }\n\n            setExported(orderEntry, libraryOrderEntry);\n          }\n        }\n      }\n      else {\n        final Element orderEntry;\n        if (Comparing.strEqual(libraryName, IdeaXml.ECLIPSE_LIBRARY)) {\n          orderEntry = addOrderEntry(EclipseXml.CON_KIND, EclipseXml.ECLIPSE_PLATFORM, classpathRoot, oldRoot);\n        }\n        else {\n          orderEntry = addOrderEntry(EclipseXml.CON_KIND, EclipseXml.USER_LIBRARY + \"/\" + libraryName, classpathRoot, oldRoot);\n        }\n        setExported(orderEntry, libraryOrderEntry);\n      }\n    }\n    else if (entry instanceof JdkOrderEntry) {\n      if (entry instanceof InheritedJdkOrderEntry) {\n        addOrderEntry(EclipseXml.CON_KIND, EclipseXml.JRE_CONTAINER, classpathRoot, oldRoot);\n      }\n      else {\n        final Sdk jdk = ((JdkOrderEntry)entry).getJdk();\n        String jdkLink;\n        if (jdk == null) {\n          jdkLink = EclipseXml.JRE_CONTAINER;\n        }\n        else {\n          jdkLink = EclipseXml.JRE_CONTAINER;\n          if (jdk.getSdkType() instanceof JavaSdkType) {\n            jdkLink += EclipseXml.JAVA_SDK_TYPE;\n          }\n          jdkLink += \"/\" + jdk.getName();\n        }\n        addOrderEntry(EclipseXml.CON_KIND, jdkLink, classpathRoot, oldRoot);\n      }\n    }\n    else {\n      throw new ConversionException(\"Unknown EclipseProjectModel.ClasspathEntry: \" + entry.getClass());\n    }\n  }","id":26676,"modified_method":"private void createClasspathEntry(OrderEntry entry, Element classpathRoot, Element oldRoot) throws ConversionException {\n    if (entry instanceof ModuleSourceOrderEntry) {\n      final ContentEntry[] entries = ((ModuleSourceOrderEntry)entry).getRootModel().getContentEntries();\n      if (entries.length > 0) {\n        final ContentEntry contentEntry = entries[0];\n        for (SourceFolder sourceFolder : contentEntry.getSourceFolders()) {\n          addOrderEntry(EclipseXml.SRC_KIND, getRelativePath(sourceFolder.getUrl()), classpathRoot, oldRoot);\n        }\n      }\n    }\n    else if (entry instanceof ModuleOrderEntry) {\n      Element orderEntry = addOrderEntry(EclipseXml.SRC_KIND, \"/\" + ((ModuleOrderEntry)entry).getModuleName(), classpathRoot, oldRoot);\n      setAttributeIfAbsent(orderEntry, EclipseXml.COMBINEACCESSRULES_ATTR, EclipseXml.FALSE_VALUE);\n      setExported(orderEntry, ((ExportableOrderEntry)entry));\n    }\n    else if (entry instanceof LibraryOrderEntry) {\n      final LibraryOrderEntry libraryOrderEntry = (LibraryOrderEntry)entry;\n      final String libraryName = libraryOrderEntry.getLibraryName();\n      if (libraryOrderEntry.isModuleLevel()) {\n        final String[] files = libraryOrderEntry.getUrls(OrderRootType.CLASSES);\n        if (files.length > 0) {\n          if (libraryName != null &&\n              libraryName.contains(IdeaXml.JUNIT) &&\n              Comparing.strEqual(files[0], EclipseClasspathReader.getJunitClsUrl(libraryName.contains(\"4\")))) {\n            final Element orderEntry =\n              addOrderEntry(EclipseXml.CON_KIND, EclipseXml.JUNIT_CONTAINER + \"/\" + libraryName.substring(IdeaXml.JUNIT.length()),\n                            classpathRoot, oldRoot);\n            setExported(orderEntry, libraryOrderEntry);\n          }\n          else {\n            final String eclipseVariablePath = EclipseModuleManager.getInstance(libraryOrderEntry.getOwnerModule()).getEclipseVariablePath(files[0]);\n            final Element orderEntry;\n            if (eclipseVariablePath != null) {\n              orderEntry = addOrderEntry(EclipseXml.VAR_KIND, eclipseVariablePath, classpathRoot, oldRoot);\n            }\n            else {\n              orderEntry = addOrderEntry(EclipseXml.LIB_KIND, getRelativePath(files[0]), classpathRoot, oldRoot);\n            }\n\n            final String srcRelativePath;\n            final String eclipseSrcVariablePath;\n\n            final String[] srcFiles = libraryOrderEntry.getUrls(OrderRootType.SOURCES);\n            if (srcFiles.length == 0) {\n              srcRelativePath = null;\n              eclipseSrcVariablePath = null;\n            }\n            else {\n              final String lastSourceRoot = srcFiles[srcFiles.length - 1];\n              srcRelativePath = getRelativePath(lastSourceRoot);\n              eclipseSrcVariablePath = EclipseModuleManager.getInstance(libraryOrderEntry.getOwnerModule()).getEclipseSrcVariablePath(lastSourceRoot);\n            }\n            setOrRemoveAttribute(orderEntry, EclipseXml.SOURCEPATH_ATTR, eclipseSrcVariablePath != null ? eclipseSrcVariablePath : srcRelativePath);\n\n            //clear javadocs before write new\n            final List children = new ArrayList(orderEntry.getChildren(EclipseXml.ATTRIBUTES_TAG));\n            for (Object o : children) {\n              ((Element)o).detach();\n            }\n            final String[] docUrls = libraryOrderEntry.getUrls(JavadocOrderRootType.getInstance());\n            for (final String docUrl : docUrls) {\n              setJavadocPath(orderEntry, docUrl);\n            }\n\n            setExported(orderEntry, libraryOrderEntry);\n          }\n        }\n      }\n      else {\n        final Element orderEntry;\n        if (Comparing.strEqual(libraryName, IdeaXml.ECLIPSE_LIBRARY)) {\n          orderEntry = addOrderEntry(EclipseXml.CON_KIND, EclipseXml.ECLIPSE_PLATFORM, classpathRoot, oldRoot);\n        }\n        else {\n          orderEntry = addOrderEntry(EclipseXml.CON_KIND, EclipseXml.USER_LIBRARY + \"/\" + libraryName, classpathRoot, oldRoot);\n        }\n        setExported(orderEntry, libraryOrderEntry);\n      }\n    }\n    else if (entry instanceof JdkOrderEntry) {\n      if (entry instanceof InheritedJdkOrderEntry) {\n        addOrderEntry(EclipseXml.CON_KIND, EclipseXml.JRE_CONTAINER, classpathRoot, oldRoot);\n      }\n      else {\n        final Sdk jdk = ((JdkOrderEntry)entry).getJdk();\n        String jdkLink;\n        if (jdk == null) {\n          jdkLink = EclipseXml.JRE_CONTAINER;\n        }\n        else {\n          jdkLink = EclipseXml.JRE_CONTAINER;\n          if (jdk.getSdkType() instanceof JavaSdkType) {\n            jdkLink += EclipseXml.JAVA_SDK_TYPE;\n          }\n          jdkLink += \"/\" + jdk.getName();\n        }\n        addOrderEntry(EclipseXml.CON_KIND, jdkLink, classpathRoot, oldRoot);\n      }\n    }\n    else {\n      throw new ConversionException(\"Unknown EclipseProjectModel.ClasspathEntry: \" + entry.getClass());\n    }\n  }","commit_id":"00a6e8b8372990fb4c26acebeaaf5088c8435292","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getRelativePath(String url) {\n    return getRelativePath(url, new String[1]);\n  }","id":26677,"modified_method":"private String getRelativePath(String url) {\n    final Project project = myModel.getModule().getProject();\n    final VirtualFile contentRoot = getContentRoot();\n    final VirtualFile projectBaseDir = contentRoot != null ? contentRoot.getParent() : project.getBaseDir();\n    assert projectBaseDir != null;\n    VirtualFile file = VirtualFileManager.getInstance().findFileByUrl(url);\n    if (file != null) {\n      if (file.getFileSystem() instanceof JarFileSystem) {\n        file = JarFileSystem.getInstance().getVirtualFileForJar(file);\n      }\n      assert file != null;\n      if (contentRoot != null) {\n        if (VfsUtil.isAncestor(contentRoot, file, false)) {\n          return VfsUtil.getRelativePath(file, contentRoot, '/');\n        } else {\n          final Module module = ModuleUtil.findModuleForFile(file, project);\n          if (module != null) {\n            final VirtualFile[] contentRoots = ModuleRootManager.getInstance(module).getContentRoots();\n            for (VirtualFile otherRoot : contentRoots) {\n              if (VfsUtil.isAncestor(otherRoot, file, false)) {\n                return \"/\" + module.getName() + \"/\" + VfsUtil.getRelativePath(file, otherRoot, '/');\n              }\n            }\n          }\n        }\n      }\n      if (VfsUtil.isAncestor(projectBaseDir, file, false)) {\n        return \"/\" + VfsUtil.getRelativePath(file, projectBaseDir, '/');\n      }\n      else {\n        return ProjectRootManagerImpl.extractLocalPath(url);\n      }\n    }\n    else {\n      if (contentRoot != null) {\n        final String rootUrl = contentRoot.getUrl();\n        if (url.startsWith(rootUrl) && url.length() > rootUrl.length()) {\n          return url.substring(rootUrl.length() + 1); //without leading /\n        }\n      }\n      final String projectUrl = projectBaseDir.getUrl();\n      if (url.startsWith(projectUrl)) {\n        return url.substring(projectUrl.length()); //leading /\n      }\n\n      return ProjectRootManagerImpl.extractLocalPath(url);\n    }\n  }","commit_id":"00a6e8b8372990fb4c26acebeaaf5088c8435292","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static ManagedObject getMOFromPropString(String oidStr, String valStr) {\n\t\tOID moOID = new OID(oidStr);\n\t\tString moTypeStr = valStr.substring(0, valStr.indexOf(\":\"));\n\t\tString moValStr = valStr.substring(valStr.indexOf(\":\") + 2);\n\t\tManagedObject newMO;\n\t\tif (moTypeStr.equals(\"STRING\")) {\n\t\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, new OctetString(moValStr));\n\t\t} else if (moTypeStr.equals(\"Hex-STRING\")) {\n\t\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, OctetString.fromHexString(moValStr));\n\t\t} else if (moTypeStr.equals(\"INTEGER\") || moTypeStr.equals(\"Gauge32\") || moTypeStr.equals(\"Counter32\")) {\n\t\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, new Integer32(Integer.parseInt(moValStr)));\t\t\t\n\t\t} else if (moTypeStr.equals(\"TimeTicks\")) {\n\t\t\tInteger ticksInt = Integer.parseInt( moValStr.substring( moValStr.indexOf(\"(\") + 1, moValStr.indexOf(\")\") ) );\n\t\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, new Integer32(ticksInt));\n\t\t} else if (moTypeStr.equals(\"OID\")) {\n\t\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, new OID(moValStr));\n\t\t} else {\n\t\t\t// Punt, assume it's a String\n\t\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, new OctetString(moValStr)); \n\t\t}\n\t\treturn newMO;\n\t}","id":26678,"modified_method":"protected static ManagedObject getMOFromPropString(String oidStr, String valStr) {\n\t\tOID moOID = new OID(oidStr);\n\t\tString moTypeStr = valStr.substring(0, valStr.indexOf(\":\"));\n\t\tString moValStr = valStr.substring(valStr.indexOf(\":\") + 2);\n\t\tManagedObject newMO;\n\t\tVariable newVar;\n\t\tif (moTypeStr.equals(\"STRING\")) {\n\t\t\tnewVar = new OctetString(moValStr);\n\t\t} else if (moTypeStr.equals(\"Hex-STRING\")) {\n\t\t\tnewVar = OctetString.fromHexString(moValStr);\n\t\t} else if (moTypeStr.equals(\"INTEGER\")) {\n\t\t\tnewVar = new Integer32(Integer.parseInt(moValStr));\n\t\t} else if (moTypeStr.equals(\"Gauge32\")) {\n\t\t\tnewVar = new Gauge32(Integer.parseInt(moValStr));\n\t\t} else if (moTypeStr.equals(\"Counter32\")) {\n\t\t\tnewVar = new Counter32(Integer.parseInt(moValStr));\n\t\t} else if (moTypeStr.equals(\"Counter64\")) {\n\t\t\tnewVar = new Counter64(Long.parseLong(moValStr));\n\t\t} else if (moTypeStr.equals(\"TimeTicks\")) {\n\t\t\tInteger ticksInt = Integer.parseInt( moValStr.substring( moValStr.indexOf(\"(\") + 1, moValStr.indexOf(\")\") ) );\n\t\t\tnewVar = new TimeTicks(ticksInt);\n\t\t} else if (moTypeStr.equals(\"OID\")) {\n\t\t\tnewVar = new OID(moValStr);\n\t\t} else {\n\t\t\t// Punt, assume it's a String\n\t\t\tnewVar = new OctetString(moValStr);\n\t\t}\n\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, newVar);\n\t\treturn newMO;\n\t}","commit_id":"7321b0c3ab4a953fdcb7b7b29cbcef4e4a078883","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected static ManagedObject getMOFromPropString(String oidStr, String valStr) {\n\t\tOID moOID = new OID(oidStr);\n\t\tString moTypeStr = valStr.substring(0, valStr.indexOf(\":\"));\n\t\tString moValStr = valStr.substring(valStr.indexOf(\":\") + 2);\n\t\tManagedObject newMO;\n\t\tif (moTypeStr.equals(\"STRING\")) {\n\t\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, new OctetString(moValStr));\n\t\t} else if (moTypeStr.equals(\"Hex-STRING\")) {\n\t\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, OctetString.fromHexString(moValStr));\n\t\t} else if (moTypeStr.equals(\"INTEGER\") || moTypeStr.equals(\"Gauge32\") || moTypeStr.equals(\"Counter32\")) {\n\t\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, new Integer32(Integer.parseInt(moValStr)));\t\t\t\n\t\t} else if (moTypeStr.equals(\"TimeTicks\")) {\n\t\t\tInteger ticksInt = Integer.parseInt( moValStr.substring( moValStr.indexOf(\"(\") + 1, moValStr.indexOf(\")\") ) );\n\t\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, new Integer32(ticksInt));\n\t\t} else if (moTypeStr.equals(\"OID\")) {\n\t\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, new OID(moValStr));\n\t\t} else {\n\t\t\t// Punt, assume it's a String\n\t\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, new OctetString(moValStr)); \n\t\t}\n\t\treturn newMO;\n\t}","id":26679,"modified_method":"protected static ManagedObject getMOFromPropString(String oidStr, String valStr) {\n\t\tOID moOID = new OID(oidStr);\n\t\tString moTypeStr = valStr.substring(0, valStr.indexOf(\":\"));\n\t\tString moValStr = valStr.substring(valStr.indexOf(\":\") + 2);\n\t\tManagedObject newMO;\n\t\tVariable newVar;\n\t\tif (moTypeStr.equals(\"STRING\")) {\n\t\t\tnewVar = new OctetString(moValStr);\n\t\t} else if (moTypeStr.equals(\"Hex-STRING\")) {\n\t\t\tnewVar = OctetString.fromHexString(moValStr);\n\t\t} else if (moTypeStr.equals(\"INTEGER\")) {\n\t\t\tnewVar = new Integer32(Integer.parseInt(moValStr));\n\t\t} else if (moTypeStr.equals(\"Gauge32\")) {\n\t\t\tnewVar = new Gauge32(Integer.parseInt(moValStr));\n\t\t} else if (moTypeStr.equals(\"Counter32\")) {\n\t\t\tnewVar = new Counter32(Integer.parseInt(moValStr));\n\t\t} else if (moTypeStr.equals(\"Counter64\")) {\n\t\t\tnewVar = new Counter64(Long.parseLong(moValStr));\n\t\t} else if (moTypeStr.equals(\"TimeTicks\")) {\n\t\t\tInteger ticksInt = Integer.parseInt( moValStr.substring( moValStr.indexOf(\"(\") + 1, moValStr.indexOf(\")\") ) );\n\t\t\tnewVar = new TimeTicks(ticksInt);\n\t\t} else if (moTypeStr.equals(\"OID\")) {\n\t\t\tnewVar = new OID(moValStr);\n\t\t} else {\n\t\t\t// Punt, assume it's a String\n\t\t\tnewVar = new OctetString(moValStr);\n\t\t}\n\t\tnewMO = new MOScalar(moOID, MOAccessImpl.ACCESS_READ_ONLY, newVar);\n\t\treturn newMO;\n\t}","commit_id":"f7ea20afaacb3f192fd7559bae2b54486bd985c0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<JCTree> transform(AttributeGetterDefinition decl) {\n        String name = decl.getIdentifier().getText();\n        JCBlock body = statementGen().transform(decl.getBlock());\n        return AttributeDefinitionBuilder\n            .getter(this, name, decl.getDeclarationModel())\n            .modifiers(transformAttributeGetSetDeclFlags(decl.getDeclarationModel()))\n            .isActual(Decl.isActual(decl))\n            .getterBlock(body)\n            .build();\n    }","id":26680,"modified_method":"public List<JCTree> transform(AttributeGetterDefinition decl) {\n        String name = decl.getIdentifier().getText();\n        JCBlock body = statementGen().transform(decl.getBlock());\n        return AttributeDefinitionBuilder\n            .getter(this, name, decl.getDeclarationModel())\n            .modifiers(transformAttributeGetSetDeclFlags(decl))\n            .isActual(Decl.isActual(decl))\n            .getterBlock(body)\n            .build();\n    }","commit_id":"8c53af7907f34861cbd18f75d384e5344139d11b","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private List<JCTree> makeGetter(Tree.AttributeDeclaration decl) {\n        at(decl);\n        String atrrName = decl.getIdentifier().getText();\n        return AttributeDefinitionBuilder\n            .getter(this, atrrName, decl.getDeclarationModel())\n            .modifiers(transformAttributeGetSetDeclFlags(decl.getDeclarationModel()))\n            .isActual(Decl.isActual(decl))\n            .isFormal(Decl.isFormal(decl))\n            .build();\n    }","id":26681,"modified_method":"private List<JCTree> makeGetter(Tree.AttributeDeclaration decl) {\n        at(decl);\n        String atrrName = decl.getIdentifier().getText();\n        return AttributeDefinitionBuilder\n            .getter(this, atrrName, decl.getDeclarationModel())\n            .modifiers(transformAttributeGetSetDeclFlags(decl))\n            .isActual(Decl.isActual(decl))\n            .isFormal(Decl.isFormal(decl))\n            .build();\n    }","commit_id":"8c53af7907f34861cbd18f75d384e5344139d11b","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private int transformAttributeGetSetDeclFlags(TypedDeclaration cdecl) {\n        if (cdecl instanceof Setter) {\n            // Spec says: A setter may not be annotated shared, default or \n            // actual. The visibility and refinement modifiers of an attribute \n            // with a setter are specified by annotating the matching getter.\n            cdecl = ((Setter)cdecl).getGetter();\n        }\n        \n        int result = 0;\n\n        result |= cdecl.isShared() ? PUBLIC : PRIVATE;\n        result |= (cdecl.isFormal() && !cdecl.isDefault()) ? ABSTRACT : 0;\n        result |= !(cdecl.isFormal() || cdecl.isDefault()) ? FINAL : 0;\n\n        return result;\n    }","id":26682,"modified_method":"private int transformAttributeGetSetDeclFlags(Tree.TypedDeclaration cdecl) {\n        TypedDeclaration tdecl = cdecl.getDeclarationModel();\n        if (tdecl instanceof Setter) {\n            // Spec says: A setter may not be annotated shared, default or \n            // actual. The visibility and refinement modifiers of an attribute \n            // with a setter are specified by annotating the matching getter.\n            tdecl = ((Setter)tdecl).getGetter();\n        }\n        \n        int result = 0;\n\n        result |= tdecl.isShared() ? PUBLIC : PRIVATE;\n        result |= (tdecl.isFormal() && !tdecl.isDefault()) ? ABSTRACT : 0;\n        result |= !(tdecl.isFormal() || tdecl.isDefault()) ? FINAL : 0;\n\n        return result;\n    }","commit_id":"8c53af7907f34861cbd18f75d384e5344139d11b","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transform(AttributeSetterDefinition decl) {\n        JCBlock body = statementGen().transform(decl.getBlock());\n        String name = decl.getIdentifier().getText();\n        return AttributeDefinitionBuilder\n            .setter(this, name, decl.getDeclarationModel().getParameter())\n            .modifiers(transformAttributeGetSetDeclFlags(decl.getDeclarationModel()))\n            .isActual(isActual(decl))\n            .setterBlock(body)\n            .build();\n    }","id":26683,"modified_method":"public List<JCTree> transform(AttributeSetterDefinition decl) {\n        JCBlock body = statementGen().transform(decl.getBlock());\n        String name = decl.getIdentifier().getText();\n        return AttributeDefinitionBuilder\n            .setter(this, name, decl.getDeclarationModel().getParameter())\n            .modifiers(transformAttributeGetSetDeclFlags(decl))\n            .isActual(isActual(decl))\n            .setterBlock(body)\n            .build();\n    }","commit_id":"8c53af7907f34861cbd18f75d384e5344139d11b","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private List<JCTree> makeSetter(Tree.AttributeDeclaration decl) {\n        at(decl);\n        String attrName = decl.getIdentifier().getText();\n        Value declModel = decl.getDeclarationModel();\n        return AttributeDefinitionBuilder\n            .setter(this, attrName, declModel)\n            .modifiers(transformAttributeGetSetDeclFlags(declModel))\n            .isActual(isActual(decl))\n            .isFormal(Decl.isFormal(decl))\n            .build();\n    }","id":26684,"modified_method":"private List<JCTree> makeSetter(Tree.AttributeDeclaration decl) {\n        at(decl);\n        String attrName = decl.getIdentifier().getText();\n        return AttributeDefinitionBuilder\n            .setter(this, attrName, decl.getDeclarationModel())\n            .modifiers(transformAttributeGetSetDeclFlags(decl))\n            .isActual(isActual(decl))\n            .isFormal(Decl.isFormal(decl))\n            .build();\n    }","commit_id":"8c53af7907f34861cbd18f75d384e5344139d11b","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transformObject(Tree.ObjectDefinition def, ClassDefinitionBuilder containingClassBuilder) {\n        String name = def.getIdentifier().getText();\n        ClassDefinitionBuilder objectClassBuilder = ClassDefinitionBuilder.klass(this, name);\n        \n        CeylonVisitor visitor = new CeylonVisitor(gen(), objectClassBuilder);\n        def.visitChildren(visitor);\n\n        TypeDeclaration decl = def.getDeclarationModel().getType().getDeclaration();\n\n        if (Decl.isToplevel(def)) {\n            objectClassBuilder.body(makeObjectGlobal(def, name).toList());\n        }\n\n        List<JCTree> result = objectClassBuilder\n            .annotations(makeAtObject())\n            .modifiers(transformObjectDeclFlags(def))\n            .constructorModifiers(PRIVATE)\n            .satisfies(decl.getSatisfiedTypes())\n            .init((List<JCStatement>)visitor.getResult().toList())\n            .build();\n        \n        if (Decl.withinMethod(def)) {\n            result = result.append(makeLocalIdentityInstance(name, false));\n        } else if (Decl.withinClassOrInterface(def)) {\n            boolean visible = Decl.isCaptured(def);\n            int modifiers = FINAL | ((visible) ? PRIVATE : 0);\n            JCTree.JCIdent type = make().Ident(names().fromString(name));\n            JCExpression initialValue = makeNewClass(name);\n            containingClassBuilder.field(modifiers, name, type, initialValue, !visible);\n            \n            if (visible) {\n                result = result.appendList(AttributeDefinitionBuilder\n                    .getter(this, name, def.getDeclarationModel())\n                    .modifiers(transformAttributeGetSetDeclFlags(def.getDeclarationModel()))\n                    .isActual(Decl.isActual(def))\n                    .build());\n            }\n        }\n        \n        return result;\n    }","id":26685,"modified_method":"public List<JCTree> transformObject(Tree.ObjectDefinition def, ClassDefinitionBuilder containingClassBuilder) {\n        String name = def.getIdentifier().getText();\n        ClassDefinitionBuilder objectClassBuilder = ClassDefinitionBuilder.klass(this, name);\n        \n        CeylonVisitor visitor = new CeylonVisitor(gen(), objectClassBuilder);\n        def.visitChildren(visitor);\n\n        TypeDeclaration decl = def.getDeclarationModel().getType().getDeclaration();\n\n        if (Decl.isToplevel(def)) {\n            objectClassBuilder.body(makeObjectGlobal(def, name).toList());\n        }\n\n        List<JCTree> result = objectClassBuilder\n            .annotations(makeAtObject())\n            .modifiers(transformObjectDeclFlags(def))\n            .constructorModifiers(PRIVATE)\n            .satisfies(decl.getSatisfiedTypes())\n            .init((List<JCStatement>)visitor.getResult().toList())\n            .build();\n        \n        if (Decl.withinMethod(def)) {\n            result = result.append(makeLocalIdentityInstance(name, false));\n        } else if (Decl.withinClassOrInterface(def)) {\n            boolean visible = Decl.isCaptured(def);\n            int modifiers = FINAL | ((visible) ? PRIVATE : 0);\n            JCTree.JCIdent type = make().Ident(names().fromString(name));\n            JCExpression initialValue = makeNewClass(name);\n            containingClassBuilder.field(modifiers, name, type, initialValue, !visible);\n            \n            if (visible) {\n                result = result.appendList(AttributeDefinitionBuilder\n                    .getter(this, name, def.getDeclarationModel())\n                    .modifiers(transformAttributeGetSetDeclFlags(def))\n                    .isActual(Decl.isActual(def))\n                    .build());\n            }\n        }\n        \n        return result;\n    }","commit_id":"8c53af7907f34861cbd18f75d384e5344139d11b","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private int transformClassDeclFlags(ClassOrInterface cdecl) {\n        int result = 0;\n\n        result |= Decl.isShared(cdecl) ? PUBLIC : 0;\n        result |= cdecl.isAbstract() && (cdecl instanceof Class) ? ABSTRACT : 0;\n        result |= (cdecl instanceof Interface) ? INTERFACE : 0;\n        result |= cdecl.isAlias() && (cdecl instanceof Class) ? FINAL : 0;\n\n        return result;\n    }","id":26686,"modified_method":"private int transformClassDeclFlags(ClassOrInterface cdecl) {\n        int result = 0;\n\n        result |= Decl.isShared(cdecl) ? PUBLIC : 0;\n        result |= (cdecl.isAbstract() || cdecl.isFormal()) && (cdecl instanceof Class) ? ABSTRACT : 0;\n        result |= (cdecl instanceof Interface) ? INTERFACE : 0;\n        result |= cdecl.isAlias() && (cdecl instanceof Class) ? FINAL : 0;\n\n        return result;\n    }","commit_id":"166eb881c23a25571e510031e3743a8b997bf56a","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        final ClassOrInterface model = def.getDeclarationModel();\n        \n        // we only create types for aliases so they can be imported with the model loader\n        // and since we can't import local declarations let's just not create those types\n        // in that case\n        if(model.isAlias()\n                && Decl.isAncestorLocal(def))\n            return List.nil();\n        \n        naming.noteDecl(model);\n        final String javaClassName;\n        String ceylonClassName = def.getIdentifier().getText();\n        if (def instanceof Tree.AnyInterface) {\n            javaClassName = naming.declName(model, QUALIFIED).replaceFirst(\".*\\\\.\", \"\");\n        } else {\n            javaClassName = def.getIdentifier().getText();\n        }\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder\n                .klass(this, javaClassName, ceylonClassName);\n\n        if (def instanceof Tree.AnyClass) {\n            if(def instanceof Tree.ClassDefinition){\n                Tree.ParameterList paramList = ((Tree.AnyClass)def).getParameterList();\n                for (Tree.Parameter param : paramList.getParameters()) {\n                    at(param);\n                    classBuilder.parameter(param.getDeclarationModel());\n                    DefaultArgument defaultArgument = param.getDefaultArgument();\n                    if (defaultArgument != null\n                            || param.getDeclarationModel().isSequenced()) {\n                        MethodDefinitionBuilder m = makeParamDefaultValueMethod(false, def.getDeclarationModel(), paramList, param);\n                        if (Strategy.defaultParameterMethodStatic(model)) {\n                            classBuilder.method(m);\n                        } else {\n                            classBuilder.getCompanionBuilder(model).method(m);\n                        }\n                        \n                        // Add overloaded constructors for defaulted parameter\n                        MethodDefinitionBuilder overloadBuilder = classBuilder.addConstructor();\n                        makeOverloadsForDefaultedParameter(OL_BODY,\n                                overloadBuilder,\n                                model, paramList, param);\n                    }\n                }\n                satisfaction((Class)model, classBuilder);\n                at(def);\n            }else{\n                // class alias\n                classBuilder.constructorModifiers(PRIVATE);\n                classBuilder.annotations(makeAtAlias(model.getExtendedType()));\n                classBuilder.isAlias(true);\n            }\n        }\n        \n        if (def instanceof Tree.AnyInterface) {\n            if(def instanceof Tree.InterfaceDefinition){\n                //  Copy all the qualifying type's type parameters into the interface\n                ProducedType type = model.getType().getQualifyingType();\n                while (type != null) {\n                    java.util.List<TypeParameter> typeArguments = type.getDeclaration().getTypeParameters();\n                    if (typeArguments == null) {\n                        continue;\n                    }\n                    for (TypeParameter typeArgument : typeArguments) {\n                        classBuilder.typeParameter(typeArgument);\n                    }\n                    type = type.getQualifyingType();\n                }\n                \n                classBuilder.method(makeCompanionAccessor((Interface)model, model.getType(), false));\n                // Build the companion class\n                buildCompanion(def, (Interface)model, classBuilder);\n            }else{\n                // interface alias\n                classBuilder.annotations(makeAtAlias(model.getExtendedType()));\n                classBuilder.isAlias(true);\n            }\n        }\n        \n        // Transform the class/interface members\n        CeylonVisitor visitor = gen().visitor;\n        final ListBuffer<JCTree> prevDefs = visitor.defs;\n        final boolean prevInInitializer = visitor.inInitializer;\n        final ClassDefinitionBuilder prevClassBuilder = visitor.classBuilder;\n        List<JCStatement> childDefs;\n        try {\n            visitor.defs = new ListBuffer<JCTree>();\n            visitor.inInitializer = true;\n            visitor.classBuilder = classBuilder;\n            \n            def.visitChildren(visitor);\n            childDefs = (List<JCStatement>)visitor.getResult().toList();\n        } finally {\n            visitor.classBuilder = prevClassBuilder;\n            visitor.inInitializer = prevInInitializer;\n            visitor.defs = prevDefs;\n        }\n\n        // If it's a Class without initializer parameters...\n        if (Strategy.generateMain(def)) {\n            // ... then add a main() method\n            classBuilder.method(makeMainForClass(model));\n        }\n        \n        return classBuilder\n            .modelAnnotations(model.getAnnotations())\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(model.getSatisfiedTypes())\n            .caseTypes(model.getCaseTypes())\n            .of(model.getSelfType())\n            .init(childDefs)\n            .build();\n    }","id":26687,"modified_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        final ClassOrInterface model = def.getDeclarationModel();\n        \n        // we only create types for aliases so they can be imported with the model loader\n        // and since we can't import local declarations let's just not create those types\n        // in that case\n        if(model.isAlias()\n                && Decl.isAncestorLocal(def))\n            return List.nil();\n        \n        naming.noteDecl(model);\n        final String javaClassName;\n        String ceylonClassName = def.getIdentifier().getText();\n        if (def instanceof Tree.AnyInterface) {\n            javaClassName = naming.declName(model, QUALIFIED).replaceFirst(\".*\\\\.\", \"\");\n        } else {\n            javaClassName = def.getIdentifier().getText();\n        }\n        ClassDefinitionBuilder instantiatorImplCb;\n        ClassDefinitionBuilder instantiatorDeclCb;\n        if (Decl.withinInterface(model)) {\n            instantiatorImplCb = gen().current().getCompanionBuilder((Interface)model.getContainer());\n            instantiatorDeclCb = gen().current();\n        } else {\n            instantiatorImplCb = gen().current();\n            instantiatorDeclCb = null;\n        }\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder\n                .klass(this, javaClassName, ceylonClassName);\n\n        if (def instanceof Tree.AnyClass) {\n            if(def instanceof Tree.ClassDefinition){\n            Tree.ParameterList paramList = ((Tree.AnyClass)def).getParameterList();\n            Class cls = ((Tree.AnyClass)def).getDeclarationModel();\n            // Member classes need a instantiator method\n            boolean generateInstantiator = Strategy.generateInstantiator(cls);\n            // TODO Instantiators on companion classes\n            if (generateInstantiator) {\n                classBuilder.constructorModifiers(PROTECTED);\n                if (Decl.withinInterface(cls)) {\n                    MethodDefinitionBuilder instBuilder = MethodDefinitionBuilder.systemMethod(this, naming.getInstantiatorMethodName(cls));\n                    makeOverloadsForDefaultedParameter(0,\n                            instBuilder,\n                            model, paramList, null);\n                    instantiatorDeclCb.method(instBuilder);\n                }\n                if (!Decl.withinInterface(cls)\n                        || !model.isFormal()) {\n                    MethodDefinitionBuilder instBuilder = MethodDefinitionBuilder.systemMethod(this, naming.getInstantiatorMethodName(cls));\n                    makeOverloadsForDefaultedParameter(!cls.isFormal() ? OL_BODY : 0,\n                            instBuilder,\n                            model, paramList, null);\n                    instantiatorImplCb.method(instBuilder);\n                }\n                \n            }\n            for (Tree.Parameter param : paramList.getParameters()) {\n                Parameter paramModel = param.getDeclarationModel();\n                Parameter refinedParam = (Parameter)CodegenUtil.getTopmostRefinedDeclaration(param.getDeclarationModel());\n                at(param);\n                classBuilder.parameter(paramModel);\n                if (paramModel.isDefaulted()\n                        || paramModel.isSequenced()\n                        || (generateInstantiator\n                                && (refinedParam.isDefaulted()\n                                    || refinedParam.isSequenced()))) {\n                    ClassDefinitionBuilder cbForDevaultValues;\n                    if (Strategy.defaultParameterMethodStatic(model)) {\n                        cbForDevaultValues = classBuilder;\n                    } else {\n                        cbForDevaultValues = classBuilder.getCompanionBuilder(model);\n                    }\n                    if (generateInstantiator && refinedParam != paramModel) {}\n                    else {\n                        cbForDevaultValues.method(makeParamDefaultValueMethod(false, def.getDeclarationModel(), paramList, param));\n                    }\n                    if (generateInstantiator) {\n                        MethodDefinitionBuilder instBuilder = MethodDefinitionBuilder.systemMethod(this, naming.getInstantiatorMethodName(cls));\n                        makeOverloadsForDefaultedParameter(OL_BODY,\n                                instBuilder,\n                                model, paramList, param);\n                        instantiatorImplCb.method(instBuilder);\n                    } else {\n                        // Add overloaded constructors for defaulted parameter\n                        MethodDefinitionBuilder overloadBuilder = classBuilder.addConstructor();\n                        makeOverloadsForDefaultedParameter(OL_BODY,\n                                overloadBuilder,\n                                model, paramList, param);\n                    }\n                }\n            }\n            satisfaction((Class)model, classBuilder);\n            at(def);\n            }else{\n                // class alias\n                classBuilder.constructorModifiers(PRIVATE);\n                classBuilder.annotations(makeAtAlias(model.getExtendedType()));\n                classBuilder.isAlias(true);\n            }\n        }\n        \n        if (def instanceof Tree.AnyInterface) {\n            if(def instanceof Tree.InterfaceDefinition){\n                //  Copy all the qualifying type's type parameters into the interface\n                ProducedType type = model.getType().getQualifyingType();\n                while (type != null) {\n                    java.util.List<TypeParameter> typeArguments = type.getDeclaration().getTypeParameters();\n                    if (typeArguments == null) {\n                        continue;\n                    }\n                    for (TypeParameter typeArgument : typeArguments) {\n                        classBuilder.typeParameter(typeArgument);\n                    }\n                    type = type.getQualifyingType();\n                }\n                \n                classBuilder.method(makeCompanionAccessor((Interface)model, model.getType(), false));\n                // Build the companion class\n                buildCompanion(def, (Interface)model, classBuilder);\n            }else{\n                // interface alias\n                classBuilder.annotations(makeAtAlias(model.getExtendedType()));\n                classBuilder.isAlias(true);\n            }\n        }\n        \n        // Transform the class/interface members\n        CeylonVisitor visitor = gen().visitor;\n        final ListBuffer<JCTree> prevDefs = visitor.defs;\n        final boolean prevInInitializer = visitor.inInitializer;\n        final ClassDefinitionBuilder prevClassBuilder = visitor.classBuilder;\n        List<JCStatement> childDefs;\n        try {\n            visitor.defs = new ListBuffer<JCTree>();\n            visitor.inInitializer = true;\n            visitor.classBuilder = classBuilder;\n            \n            def.visitChildren(visitor);\n            childDefs = (List<JCStatement>)visitor.getResult().toList();\n        } finally {\n            visitor.classBuilder = prevClassBuilder;\n            visitor.inInitializer = prevInInitializer;\n            visitor.defs = prevDefs;\n        }\n\n        // If it's a Class without initializer parameters...\n        if (Strategy.generateMain(def)) {\n            // ... then add a main() method\n            classBuilder.method(makeMainForClass(model));\n        }\n        \n        return classBuilder\n            .modelAnnotations(model.getAnnotations())\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(model.getSatisfiedTypes())\n            .caseTypes(model.getCaseTypes())\n            .of(model.getSelfType())\n            .init(childDefs)\n            .build();\n    }","commit_id":"166eb881c23a25571e510031e3743a8b997bf56a","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Generates an overloaded method where all the defaulted parameters after \n     * and including the given {@code currentParam} are given their default \n     * values. Using Java-side overloading ensures positional invocations \n     * are binary compatible when new defaulted parameters are appended to a\n     * parameter list.\n     */\n    private MethodDefinitionBuilder makeOverloadsForDefaultedParameter(\n            int flags, MethodDefinitionBuilder overloadBuilder,\n            final Declaration model, java.util.List<Parameter> parameters,\n            final Parameter currentParam) {\n        // need annotations for BC, but the method isn't really there\n        overloadBuilder.ignoreAnnotations();\n        \n        final JCExpression methName;\n        if (model instanceof Method) {\n            long mods = transformOverloadMethodDeclFlags((Method)model);\n            if ((flags & OL_BODY) != 0) {\n                mods &= ~ABSTRACT;\n            }\n            if ((flags & OL_IMPLEMENTOR) != 0 || (flags & OL_DELEGATOR) != 0) {\n                mods |= FINAL;\n            }\n            overloadBuilder.modifiers(mods);\n            JCExpression qualifier;\n            if ((flags & OL_DELEGATOR) != 0) {\n                qualifier = naming.makeQuotedThis();\n            } else {\n                qualifier = null;\n            }\n            methName = naming.makeQualifiedName(qualifier, (Method)model, Naming.NA_MEMBER);\n            overloadBuilder.resultType((Method)model, 0);\n        } else if (model instanceof Class) {\n            overloadBuilder.modifiers(transformOverloadCtorFlags((Class)model));\n            methName = naming.makeThis();\n        } else {\n            throw new RuntimeException();\n        }\n        \n        // TODO MPL\n        if (model instanceof Method) {\n            copyTypeParameters((Method)model, overloadBuilder);\n        }\n\n        // TODO Some simple default expressions (e.g. literals, null and \n        // base expressions it might be worth inlining the expression rather \n        // than calling the default value method.\n        // TODO This really belongs in the invocation builder\n        \n        ListBuffer<JCExpression> args = ListBuffer.<JCExpression>lb();\n        ListBuffer<JCStatement> vars = ListBuffer.<JCStatement>lb();\n        \n        final Naming.SyntheticName companionInstanceName = naming.temp(\"$impl$\");\n        if (model instanceof Class\n                && !Strategy.defaultParameterMethodStatic(model)) {\n            Class classModel = (Class)model;\n            vars.append(makeVar(companionInstanceName, \n                    makeJavaType(classModel.getType(), AbstractTransformer.JT_COMPANION),\n                    make().NewClass(null, \n                            null,\n                            makeJavaType(classModel.getType(), AbstractTransformer.JT_COMPANION),\n                            List.<JCExpression>nil(), null)));\n        }\n        \n        boolean useDefault = false;\n        for (Parameter param2 : parameters) {\n            \n            if (param2 == currentParam) {\n                useDefault = true;\n            }\n            if (useDefault) {\n                List<JCExpression> typeArguments = List.<JCExpression>nil();\n                JCIdent dpmQualifier;\n                if (Strategy.defaultParameterMethodOnSelf(model) \n                        || (flags & OL_IMPLEMENTOR) != 0) {\n                    dpmQualifier = null;\n                } else if (Strategy.defaultParameterMethodStatic(model)){\n                    dpmQualifier = null;\n                    if (model instanceof Class) {\n                        typeArguments = typeArguments((Class)model);\n                    } else if (model instanceof Method) {\n                        typeArguments = typeArguments((Method)model);\n                    }\n                } else {\n                    dpmQualifier = companionInstanceName.makeIdent();\n                }\n                JCExpression defaultValueMethodName = naming.makeDefaultedParamMethod(dpmQualifier, param2);\n                \n                Naming.SyntheticName varName = naming.temp(\"$\"+param2.getName()+\"$\");\n                final ProducedType paramType;\n                if (param2 instanceof FunctionalParameter) {\n                    paramType = typeFact().getCallableType(param2.getType());\n                } else {\n                    paramType = param2.getType();\n                }\n                vars.append(makeVar(varName, \n                        makeJavaType(paramType), \n                        make().Apply(typeArguments, \n                                defaultValueMethodName, \n                                ListBuffer.<JCExpression>lb().appendList(args).toList())));\n                args.add(varName.makeIdent());\n            } else {\n                overloadBuilder.parameter(param2, 0);\n                args.add(naming.makeName(param2, Naming.NA_MEMBER | Naming.NA_ALIASED));\n            }\n        }\n        \n        // TODO Type args on method call\n        if ((flags & OL_BODY) != 0) {\n            JCExpression invocation = make().Apply(List.<JCExpression>nil(),\n                    methName, args.toList());\n               \n            if (isVoid(model)) {\n                vars.append(make().Exec(invocation));\n                invocation = make().LetExpr(vars.toList(), makeNull());\n                overloadBuilder.body(make().Exec(invocation));\n            } else {\n                invocation = make().LetExpr(vars.toList(), invocation);\n                overloadBuilder.body(make().Return(invocation));\n            }\n        } else {\n            overloadBuilder.noBody();\n        }\n        \n        return overloadBuilder;\n    }","id":26688,"modified_method":"/**\n     * Generates an overloaded method where all the defaulted parameters after \n     * and including the given {@code currentParam} are given their default \n     * values. Using Java-side overloading ensures positional invocations \n     * are binary compatible when new defaulted parameters are appended to a\n     * parameter list.\n     */\n    private MethodDefinitionBuilder makeOverloadsForDefaultedParameter(\n            int flags, MethodDefinitionBuilder overloadBuilder,\n            final Declaration model, java.util.List<Parameter> parameters,\n            final Parameter currentParam) {\n        // need annotations for BC, but the method isn't really there\n        overloadBuilder.ignoreAnnotations();\n        \n        final JCExpression methName;\n        if (model instanceof Method) {\n            long mods = transformOverloadMethodDeclFlags((Method)model);\n            if ((flags & OL_BODY) != 0) {\n                mods &= ~ABSTRACT;\n            }\n            if ((flags & OL_IMPLEMENTOR) != 0 || (flags & OL_DELEGATOR) != 0) {\n                mods |= FINAL;\n            }\n            overloadBuilder.modifiers(mods);\n            JCExpression qualifier;\n            if ((flags & OL_DELEGATOR) != 0) {\n                qualifier = naming.makeQuotedThis();\n            } else {\n                qualifier = null;\n            }\n            methName = naming.makeQualifiedName(qualifier, (Method)model, Naming.NA_MEMBER);\n            overloadBuilder.resultType((Method)model, 0);\n        } else if (model instanceof Class) {\n            if (Strategy.generateInstantiator(model)) {\n                overloadBuilder.ignoreAnnotations();\n                if (Strategy.generateInstantiator(((Class)model).getExtendedTypeDeclaration())){\n                        //&& ((Class)model).getExtendedTypeDeclaration().getContainer() instanceof Class) {\n                    overloadBuilder.isOverride(true);\n                }\n                overloadBuilder.modifiers(transformClassDeclFlags((Class)model));\n                methName = naming.makeInstantiatorMethodName(null, (Class)model);\n                overloadBuilder.resultType(null, makeJavaType(((Class)model).getType()));\n            } else {   \n                overloadBuilder.modifiers(transformOverloadCtorFlags((Class)model));\n                methName = naming.makeThis();\n            }\n        } else {\n            throw new RuntimeException();\n        }\n        \n        // TODO MPL\n        if (model instanceof Method\n                || Strategy.generateInstantiator(model)) {\n            copyTypeParameters((Functional)model, overloadBuilder);\n        }\n\n        // TODO Some simple default expressions (e.g. literals, null and \n        // base expressions it might be worth inlining the expression rather \n        // than calling the default value method.\n        // TODO This really belongs in the invocation builder\n        \n        ListBuffer<JCExpression> args = ListBuffer.<JCExpression>lb();\n        ListBuffer<JCStatement> vars = ListBuffer.<JCStatement>lb();\n        \n        final Naming.SyntheticName companionInstanceName = naming.temp(\"$impl$\");\n        if (model instanceof Class\n                && !Strategy.defaultParameterMethodStatic(model)\n                && currentParam != null) {\n            Class classModel = (Class)model;\n            vars.append(makeVar(companionInstanceName, \n                    makeJavaType(classModel.getType(), AbstractTransformer.JT_COMPANION),\n                    make().NewClass(null, \n                            null,\n                            makeJavaType(classModel.getType(), AbstractTransformer.JT_COMPANION),\n                            List.<JCExpression>nil(), null)));\n        }\n        \n        boolean useDefault = false;\n        for (Parameter param2 : parameters) {\n            \n            if (param2 == currentParam) {\n                useDefault = true;\n            }\n            if (useDefault) {\n                List<JCExpression> typeArguments = List.<JCExpression>nil();\n                JCIdent dpmQualifier;\n                if (Strategy.defaultParameterMethodOnSelf(model) \n                        || (flags & OL_IMPLEMENTOR) != 0) {\n                    dpmQualifier = null;\n                } else if (Strategy.defaultParameterMethodStatic(model)){\n                    dpmQualifier = null;\n                    if (model instanceof Class) {\n                        typeArguments = typeArguments((Class)model);\n                    } else if (model instanceof Method) {\n                        typeArguments = typeArguments((Method)model);\n                    }\n                } else {\n                    dpmQualifier = companionInstanceName.makeIdent();\n                }\n                JCExpression defaultValueMethodName = naming.makeDefaultedParamMethod(dpmQualifier, param2);\n                \n                Naming.SyntheticName varName = naming.temp(\"$\"+param2.getName()+\"$\");\n                final ProducedType paramType;\n                if (param2 instanceof FunctionalParameter) {\n                    paramType = typeFact().getCallableType(param2.getType());\n                } else {\n                    paramType = param2.getType();\n                }\n                vars.append(makeVar(varName, \n                        makeJavaType(paramType), \n                        make().Apply(typeArguments, \n                                defaultValueMethodName, \n                                ListBuffer.<JCExpression>lb().appendList(args).toList())));\n                args.add(varName.makeIdent());\n            } else {\n                overloadBuilder.parameter(param2, 0);\n                args.add(naming.makeName(param2, Naming.NA_MEMBER | Naming.NA_ALIASED));\n            }\n        }\n        \n        // TODO Type args on method call\n        if ((flags & OL_BODY) != 0) {\n            JCExpression invocation;\n            if (Strategy.generateInstantiator(model)) {\n                invocation = make().NewClass(null, \n                        null, \n                        makeJavaType(((Class)model).getType(), JT_CLASS_NEW | JT_NON_QUALIFIED),\n                        args.toList(),\n                        null);\n            } else {\n                invocation = make().Apply(List.<JCExpression>nil(),\n                    methName, args.toList());\n            }\n               \n            if (isVoid(model) && !Strategy.generateInstantiator(model)) {\n                vars.append(make().Exec(invocation));\n                invocation = make().LetExpr(vars.toList(), makeNull());\n                overloadBuilder.body(make().Exec(invocation));\n            } else {\n                if (!vars.isEmpty()) {\n                    invocation = make().LetExpr(vars.toList(), invocation);\n                }\n                overloadBuilder.body(make().Return(invocation));\n            }\n        } else {\n            overloadBuilder.noBody();\n        }\n        \n        return overloadBuilder;\n    }","commit_id":"166eb881c23a25571e510031e3743a8b997bf56a","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Generates an overloaded method where all the defaulted parameters after \n     * and including the given {@code currentParam} are given their default \n     * values. Using Java-side overloading ensures positional invocations \n     * are binary compatible when new defaulted parameters are appended to a\n     * parameter list.\n     */\n    private MethodDefinitionBuilder makeOverloadsForDefaultedParameter(\n            int flags,\n            MethodDefinitionBuilder overloadBuilder,\n            Declaration model,\n            Tree.ParameterList paramList,\n            Tree.Parameter currentParam) {\n        at(currentParam);\n        java.util.List<Parameter> parameters = new java.util.ArrayList<Parameter>(paramList.getParameters().size());\n        for (Tree.Parameter param : paramList.getParameters()) {\n            parameters.add(param.getDeclarationModel());\n        }\n        return makeOverloadsForDefaultedParameter(flags,\n                overloadBuilder, model,\n                parameters, currentParam.getDeclarationModel());\n    }","id":26689,"modified_method":"/**\n     * Generates an overloaded method where all the defaulted parameters after \n     * and including the given {@code currentParam} are given their default \n     * values. Using Java-side overloading ensures positional invocations \n     * are binary compatible when new defaulted parameters are appended to a\n     * parameter list.\n     */\n    private MethodDefinitionBuilder makeOverloadsForDefaultedParameter(\n            int flags,\n            MethodDefinitionBuilder overloadBuilder,\n            Declaration model,\n            Tree.ParameterList paramList,\n            Tree.Parameter currentParam) {\n        at(currentParam);\n        java.util.List<Parameter> parameters = new java.util.ArrayList<Parameter>(paramList.getParameters().size());\n        for (Tree.Parameter param : paramList.getParameters()) {\n            parameters.add(param.getDeclarationModel());\n        }\n        return makeOverloadsForDefaultedParameter(flags,\n                overloadBuilder, model,\n                parameters, currentParam != null ? currentParam.getDeclarationModel() : null);\n    }","commit_id":"166eb881c23a25571e510031e3743a8b997bf56a","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        String className = def.getIdentifier().getText();\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder\n                .klass(this, Decl.isAncestorLocal(def), className);\n\n        if (def instanceof Tree.AnyClass) {\n            ParameterList paramList = ((Tree.AnyClass)def).getParameterList();\n            for (Tree.Parameter param : paramList.getParameters()) {\n                classBuilder.parameter(param);\n                // Does the parameter have a default value?\n                if (param.getDefaultArgument() != null &&  param.getDefaultArgument().getSpecifierExpression() != null) {\n                    classBuilder.getCompanionBuilder().defs(transformDefaultedParameter(false, param, def, paramList));\n                }\n            }\n            \n            // Add overloaded constructors for defaulted parameter\n            for (Tree.Parameter param : paramList.getParameters()) {\n                DefaultArgument defaultArgument = param.getDefaultArgument();\n                if (defaultArgument != null) {\n                    MethodDefinitionBuilder overloadBuilder = classBuilder.addConstructor();\n                    transformForDefaultedParameter(\n                            overloadBuilder,\n                            def, def.getDeclarationModel(), true, paramList, param);\n                    \n                }\n            }\n            \n            // For each satisfied interface, instantiate an instance of the \n            // companion class in the constructor and assign it to a\n            // $Interface$impl field\n            for (TypeDeclaration decl : def.getDeclarationModel().getSatisfiedTypeDeclarations()) {\n                if (!(decl instanceof Interface)) {\n                    continue;\n                }\n                Interface iface = (Interface)decl;\n                ListBuffer<JCExpression> state = ListBuffer.<JCExpression>of(makeUnquotedIdent(\"this\"));\n                if (!iface.isToplevel()) {\n                    state.append(makeQuotedQualIdent(makeJavaType(iface.getType().getQualifyingType()), \"this\"));\n                }\n                final String fieldName = \"$\" + iface.getName() + \"$impl\";\n                final String companionClassName = Util.getCompanionClassName(iface.getName());\n                classBuilder.init(make().Exec(make().Assign(\n                        makeSelect(\"this\", fieldName),// TODO Use qualified name for quoting? \n                        make().NewClass(null, \n                                null, // TODO Type args \n                                make().TypeApply(makeQuotedIdent(companionClassName), typeParams(def.getDeclarationModel())), \n                                state.toList(), // TODO Add outer if necessary \n                                null))));\n                \n                classBuilder.field(PRIVATE | FINAL, fieldName, \n                        make().TypeApply(makeQuotedIdent(companionClassName), typeParams(def.getDeclarationModel())), null, false);\n            }\n        }\n        \n        if (def instanceof Tree.AnyInterface) {\n            // Give the $impl companion a constructor...\n            ClassDefinitionBuilder companionBuilder = classBuilder.getCompanionBuilder();\n            MethodDefinitionBuilder ctor = companionBuilder.addConstructor();\n            \n            // ...with a $this ctor parameter and field...\n            ProducedType thisType = def.getDeclarationModel().getType();\n            ctor.parameter(0, \"$this\", makeJavaType(thisType), null);\n            ListBuffer<JCStatement> bodyStatements = ListBuffer.<JCStatement>of(\n                    make().Exec(\n                            make().Assign(\n                                    makeSelect(\"this\", \"$this\"), \n                                    makeUnquotedIdent(\"$this\"))));\n            companionBuilder.field(PRIVATE | FINAL, \n                    \"$this\", \n                    makeJavaType(thisType), \n                    null, false);\n            if (!def.getDeclarationModel().isToplevel()) {\n                // ...and an $outer ctor parameter and field\n                ProducedType outerType = thisType.getQualifyingType();\n                ctor.parameter(0, \"$outer\", makeJavaType(outerType), null);\n                bodyStatements.append(\n                        make().Exec(\n                                make().Assign(\n                                        makeSelect(\"this\", \"$outer\"), \n                                        makeUnquotedIdent(\"$outer\"))));\n                companionBuilder.field(PRIVATE | FINAL, \n                        \"$outer\", \n                        makeJavaType(outerType), \n                        null, false);\n                \n                // Add an $outer() method to the interface\n                MethodDefinitionBuilder outerBuilder = MethodDefinitionBuilder.method(gen(), false, true, \"$outer\");// TODO ancestorLocal\n                outerBuilder.modifiers(PUBLIC | ABSTRACT);\n                outerBuilder.resultType(null, makeJavaType(outerType));\n                classBuilder.defs(outerBuilder.build());\n            }\n            ctor.body(bodyStatements.toList());\n        }\n        \n        if (def instanceof Tree.AnyClass) {\n            for (TypeDeclaration decl : def.getDeclarationModel().getSatisfiedTypeDeclarations()) {\n                if (!(decl instanceof Interface)\n                        || decl.isToplevel()) {\n                    // TODO What about local interfaces?\n                    continue;\n                }\n                Interface iface = (Interface)decl;\n                \n                // Generate $outer() impl if implementing an inner interface\n                MethodDefinitionBuilder outerBuilder = MethodDefinitionBuilder.method(gen(), true, true, \"$outer\");// TODO ancestorLocal\n                outerBuilder.annotations(makeAtOverride());\n                outerBuilder.modifiers(FINAL | PUBLIC);\n                outerBuilder.resultType(null, makeJavaType(iface.getType().getQualifyingType()));\n                outerBuilder.body(make().Return(makeQuotedIdent(\"$outer\")));\n                classBuilder.defs(outerBuilder.build());\n            }\n        }\n        \n        CeylonVisitor visitor = new CeylonVisitor(gen(), classBuilder);\n        def.visitChildren(visitor);\n\n        // Check if it's a Class without initializer parameters\n        if (def instanceof Tree.AnyClass && Decl.isToplevel(def) && !Decl.isAbstract(def)) {\n            com.redhat.ceylon.compiler.typechecker.model.Class c = (com.redhat.ceylon.compiler.typechecker.model.Class) def.getDeclarationModel();\n            if (c.getParameterList().getParameters().isEmpty()) {\n                // Add a main() method\n                at(null);\n                JCExpression nameId = makeQuotedFQIdent(c.getQualifiedNameString());\n                JCNewClass expr = make().NewClass(null, null, nameId, List.<JCTree.JCExpression>nil(), null);\n                classBuilder.body(makeMainMethod(def.getDeclarationModel(), expr));\n            }\n        }\n        \n        return classBuilder\n            .modelAnnotations(def.getDeclarationModel().getAnnotations())\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(def.getDeclarationModel().getSatisfiedTypes())\n            .caseTypes(def.getDeclarationModel().getCaseTypes())\n            .init((List<JCStatement>)visitor.getResult().toList())\n            .build();\n    }","id":26690,"modified_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        String className = def.getIdentifier().getText();\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder\n                .klass(this, Decl.isAncestorLocal(def), className);\n\n        if (def instanceof Tree.AnyClass) {\n            ParameterList paramList = ((Tree.AnyClass)def).getParameterList();\n            for (Tree.Parameter param : paramList.getParameters()) {\n                classBuilder.parameter(param);\n                // Does the parameter have a default value?\n                if (param.getDefaultArgument() != null &&  param.getDefaultArgument().getSpecifierExpression() != null) {\n                    classBuilder.getCompanionBuilder().defs(transformDefaultedParameter(false, param, def, paramList));\n                }\n            }\n            \n            // Add overloaded constructors for defaulted parameter\n            for (Tree.Parameter param : paramList.getParameters()) {\n                DefaultArgument defaultArgument = param.getDefaultArgument();\n                if (defaultArgument != null) {\n                    MethodDefinitionBuilder overloadBuilder = classBuilder.addConstructor();\n                    transformForDefaultedParameter(\n                            overloadBuilder,\n                            def, def.getDeclarationModel(), true, paramList, param);\n                    \n                }\n            }\n            \n            // For each satisfied interface, instantiate an instance of the \n            // companion class in the constructor and assign it to a\n            // $Interface$impl field\n            for (TypeDeclaration decl : def.getDeclarationModel().getSatisfiedTypeDeclarations()) {\n                if (!(decl instanceof Interface)) {\n                    continue;\n                }\n                Interface iface = (Interface)decl;\n                ListBuffer<JCExpression> state = ListBuffer.<JCExpression>of(makeUnquotedIdent(\"this\"));\n                if (!iface.isToplevel()) {\n                    state.append(makeQuotedQualIdent(makeJavaType(iface.getType().getQualifyingType()), \"this\"));\n                }\n                final String fieldName = getCompanionFieldName(iface);\n                classBuilder.init(make().Exec(make().Assign(\n                        makeSelect(\"this\", fieldName),// TODO Use qualified name for quoting? \n                        make().NewClass(null, \n                                null, // TODO Type args \n                                makeCompanionType(iface), \n                                state.toList(),  \n                                null))));\n                \n                classBuilder.field(PRIVATE | FINAL, fieldName, \n                        makeCompanionType(iface), null, false);\n            }\n        }\n        \n        if (def instanceof Tree.AnyInterface) {\n            // Give the $impl companion a constructor...\n            ClassDefinitionBuilder companionBuilder = classBuilder.getCompanionBuilder();\n            MethodDefinitionBuilder ctor = companionBuilder.addConstructor();\n            \n            // ...with a $this ctor parameter and field...\n            ProducedType thisType = def.getDeclarationModel().getType();\n            ctor.parameter(0, \"$this\", makeJavaType(thisType), null);\n            ListBuffer<JCStatement> bodyStatements = ListBuffer.<JCStatement>of(\n                    make().Exec(\n                            make().Assign(\n                                    makeSelect(\"this\", \"$this\"), \n                                    makeUnquotedIdent(\"$this\"))));\n            companionBuilder.field(PRIVATE | FINAL, \n                    \"$this\", \n                    makeJavaType(thisType), \n                    null, false);\n            if (!def.getDeclarationModel().isToplevel()) {\n                // ...and an $outer ctor parameter and field\n                ProducedType outerType = thisType.getQualifyingType();\n                ctor.parameter(0, \"$outer\", makeJavaType(outerType), null);\n                bodyStatements.append(\n                        make().Exec(\n                                make().Assign(\n                                        makeSelect(\"this\", \"$outer\"), \n                                        makeUnquotedIdent(\"$outer\"))));\n                companionBuilder.field(PRIVATE | FINAL, \n                        \"$outer\", \n                        makeJavaType(outerType), \n                        null, false);\n                \n                // Add an $outer() method to the interface\n                MethodDefinitionBuilder outerBuilder = MethodDefinitionBuilder.method(gen(), false, true, \"$outer\");// TODO ancestorLocal\n                outerBuilder.modifiers(PUBLIC | ABSTRACT);\n                outerBuilder.resultType(null, makeJavaType(outerType));\n                classBuilder.defs(outerBuilder.build());\n            }\n            ctor.body(bodyStatements.toList());\n        }\n        \n        if (def instanceof Tree.AnyClass) {\n            for (TypeDeclaration decl : def.getDeclarationModel().getSatisfiedTypeDeclarations()) {\n                if (!(decl instanceof Interface)\n                        || decl.isToplevel()) {\n                    // TODO What about local interfaces?\n                    continue;\n                }\n                Interface iface = (Interface)decl;\n                \n                // Generate $outer() impl if implementing an inner interface\n                MethodDefinitionBuilder outerBuilder = MethodDefinitionBuilder.method(gen(), true, true, \"$outer\");// TODO ancestorLocal\n                outerBuilder.annotations(makeAtOverride());\n                outerBuilder.modifiers(FINAL | PUBLIC);\n                outerBuilder.resultType(null, makeJavaType(iface.getType().getQualifyingType()));\n                outerBuilder.body(make().Return(makeQuotedIdent(\"$outer\")));\n                classBuilder.defs(outerBuilder.build());\n            }\n        }\n        \n        CeylonVisitor visitor = new CeylonVisitor(gen(), classBuilder);\n        def.visitChildren(visitor);\n\n        // Check if it's a Class without initializer parameters\n        if (def instanceof Tree.AnyClass && Decl.isToplevel(def) && !Decl.isAbstract(def)) {\n            com.redhat.ceylon.compiler.typechecker.model.Class c = (com.redhat.ceylon.compiler.typechecker.model.Class) def.getDeclarationModel();\n            if (c.getParameterList().getParameters().isEmpty()) {\n                // Add a main() method\n                at(null);\n                JCExpression nameId = makeQuotedFQIdent(c.getQualifiedNameString());\n                JCNewClass expr = make().NewClass(null, null, nameId, List.<JCTree.JCExpression>nil(), null);\n                classBuilder.body(makeMainMethod(def.getDeclarationModel(), expr));\n            }\n        }\n        \n        return classBuilder\n            .modelAnnotations(def.getDeclarationModel().getAnnotations())\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(def.getDeclarationModel().getSatisfiedTypes())\n            .caseTypes(def.getDeclarationModel().getCaseTypes())\n            .init((List<JCStatement>)visitor.getResult().toList())\n            .build();\n    }","commit_id":"b4371b82d28322d075f5b34b3738563f28116e1d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCMethodDecl transformDefaultValueMethodImpl(Method method,\n            java.util.List<Parameter> parameters, Parameter p) {\n        String name = Util.getDefaultedParamMethodName(method, p);\n        MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(gen(), false, true, name);// TODO ancestorLocal\n        overloadBuilder.annotations(makeAtOverride());\n        overloadBuilder.modifiers((transformMethodDeclFlags(method) & (PUBLIC | PRIVATE | Flags.PROTECTED)) | FINAL);\n        for (TypeParameter tp : method.getTypeParameters()) {\n            overloadBuilder.typeParameter(tp);\n        }\n        overloadBuilder.resultType(null, makeJavaType(p.getType()));\n        ListBuffer<JCExpression> args = ListBuffer.<JCExpression>lb(); \n        for (Parameter p2 : parameters.subList(0, parameters.indexOf(p))) {\n            overloadBuilder.parameter(p2);\n            args.append(makeQuotedIdent(p2.getName()));\n        }\n        String ifaceName = ((Interface)method.getRefinedDeclaration().getContainer()).getName();\n        overloadBuilder.body(make().Return(\n                make().Apply(typeParams(method), // TODO type args\n                        makeQuotedQualIdent(makeQuotedIdent(\"$\" + Util.getCompanionClassName(ifaceName)), name), \n                        args.toList())));\n        return overloadBuilder.build();\n    }","id":26691,"modified_method":"private JCMethodDecl transformDefaultValueMethodImpl(Method method,\n            java.util.List<Parameter> parameters, Parameter p) {\n        String name = Util.getDefaultedParamMethodName(method, p);\n        MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(gen(), false, true, name);// TODO ancestorLocal\n        overloadBuilder.annotations(makeAtOverride());\n        overloadBuilder.modifiers((transformMethodDeclFlags(method) & (PUBLIC | PRIVATE | PROTECTED)) | FINAL);\n        for (TypeParameter tp : method.getTypeParameters()) {\n            overloadBuilder.typeParameter(tp);\n        }\n        overloadBuilder.resultType(null, makeJavaType(p.getType()));\n        ListBuffer<JCExpression> args = ListBuffer.<JCExpression>lb(); \n        for (Parameter p2 : parameters.subList(0, parameters.indexOf(p))) {\n            overloadBuilder.parameter(p2);\n            args.append(makeQuotedIdent(p2.getName()));\n        }\n        Interface iface = (Interface)method.getRefinedDeclaration().getContainer();\n        overloadBuilder.body(make().Return(\n                make().Apply(typeParams(method), \n                        makeQuotedQualIdent(makeQuotedIdent(getCompanionFieldName(iface)), name), \n                        args.toList())));\n        return overloadBuilder.build();\n    }","commit_id":"b4371b82d28322d075f5b34b3738563f28116e1d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCMethodDecl overloadMethodImpl(\n            Method method, java.util.List<Parameter> parameters, Parameter p) {\n        MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(gen(), false, true, method.getName());// TODO ancestorLocal\n        overloadBuilder.modifiers((transformMethodDeclFlags(method) & (PUBLIC | PRIVATE | Flags.PROTECTED)) | FINAL);\n        overloadBuilder.annotations(makeAtOverride());\n        overloadBuilder.annotations(makeAtIgnore());\n        for (TypeParameter tp : method.getTypeParameters()) {\n            overloadBuilder.typeParameter(tp);\n        }\n        overloadBuilder.resultType(method);\n        final ListBuffer<JCExpression> args = ListBuffer.<JCExpression>lb();\n        final ListBuffer<JCVariableDecl> vars = ListBuffer.<JCVariableDecl>lb();        \n        boolean seen = false;\n        // TODO This code is very similar to transformForDefaultedParameter() but\n        // operates on model.Parameter not Tree.Parameter\n        \n        for (Parameter p2 : parameters) {\n            if (p2 == p) {\n                seen = true;\n            }\n            if (!seen) {\n                args.append(makeQuotedIdent(p2.getName()));\n                overloadBuilder.parameter(p2);\n            } else {\n                String tempName = tempName(p2.getName());\n                String ifaceName = ((Interface)method.getRefinedDeclaration().getContainer()).getName();\n                \n                vars.append(makeVar(\n                        tempName, \n                        makeJavaType(p2.getType()), \n                        make().Apply(typeParams(method),// TODO Type args \n                            makeQuotedQualIdent(makeUnquotedIdent(\"$\" + Util.getCompanionClassName(ifaceName)), Util.getDefaultedParamMethodName(method, p2)), \n                            args.toList())));\n                args.append(makeQuotedIdent(tempName));\n            }\n        }\n        \n        JCExpression invocation = make().Apply(\n                typeParams(method), // TODO type args\n                makeQuotedIdent(method.getName()),\n                args.toList());\n        \n        if (isVoid(method.getType())) {\n            invocation = make().LetExpr(vars.toList(), List.<JCStatement>of(make().Exec(invocation)), makeNull());\n            overloadBuilder.body(make().Exec(invocation));\n        } else {\n            invocation = make().LetExpr(vars.toList(), invocation);\n            overloadBuilder.body(make().Return(invocation));\n        }\n        \n        return overloadBuilder.build();\n    }","id":26692,"modified_method":"private JCMethodDecl overloadMethodImpl(\n            Method method, java.util.List<Parameter> parameters, Parameter p) {\n        MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(gen(), false, true, method.getName());// TODO ancestorLocal\n        overloadBuilder.modifiers((transformMethodDeclFlags(method) & (PUBLIC | PRIVATE | PROTECTED)) | FINAL);\n        overloadBuilder.annotations(makeAtOverride());\n        overloadBuilder.annotations(makeAtIgnore());\n        for (TypeParameter tp : method.getTypeParameters()) {\n            overloadBuilder.typeParameter(tp);\n        }\n        overloadBuilder.resultType(method);\n        final ListBuffer<JCExpression> args = ListBuffer.<JCExpression>lb();\n        final ListBuffer<JCVariableDecl> vars = ListBuffer.<JCVariableDecl>lb();        \n        boolean seen = false;\n        // TODO This code is very similar to transformForDefaultedParameter() but\n        // operates on model.Parameter not Tree.Parameter\n        \n        for (Parameter p2 : parameters) {\n            if (p2 == p) {\n                seen = true;\n            }\n            if (!seen) {\n                args.append(makeQuotedIdent(p2.getName()));\n                overloadBuilder.parameter(p2);\n            } else {\n                String tempName = tempName(p2.getName());\n                String ifaceName = ((Interface)method.getRefinedDeclaration().getContainer()).getName();\n                \n                vars.append(makeVar(\n                        tempName, \n                        makeJavaType(p2.getType()), \n                        make().Apply(typeParams(method),\n                            makeQuotedQualIdent(makeUnquotedIdent(\"$\" + Util.getCompanionClassName(ifaceName)), Util.getDefaultedParamMethodName(method, p2)), \n                            args.toList())));\n                args.append(makeQuotedIdent(tempName));\n            }\n        }\n        \n        JCExpression invocation = make().Apply(\n                typeParams(method),\n                makeQuotedIdent(method.getName()),\n                args.toList());\n        \n        if (isVoid(method.getType())) {\n            invocation = make().LetExpr(vars.toList(), List.<JCStatement>of(make().Exec(invocation)), makeNull());\n            overloadBuilder.body(make().Exec(invocation));\n        } else {\n            invocation = make().LetExpr(vars.toList(), invocation);\n            overloadBuilder.body(make().Return(invocation));\n        }\n        \n        return overloadBuilder.build();\n    }","commit_id":"b4371b82d28322d075f5b34b3738563f28116e1d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private MethodDefinitionBuilder transformForDefaultedParameter(\n            MethodDefinitionBuilder overloadBuilder,\n            Tree.Declaration def,\n            Declaration model, boolean isVoid, ParameterList paramList,\n            Tree.Parameter param) {\n        \n        final TypeParameterList typeParameterList;\n        final JCExpression methName;\n        if (def instanceof Tree.AnyMethod) {\n            Tree.AnyMethod meth = (Tree.AnyMethod)def;\n            long mods = transformMethodDeclFlags(meth);\n            if (!Decl.withinInterface((model))) {\n                mods |= FINAL;\n            }\n            overloadBuilder.modifiers(mods);\n            typeParameterList = meth.getTypeParameterList();\n            methName = makeQuotedIdent(Util.quoteMethodNameIfProperty((Method)model, gen()));\n        } else if (def instanceof Tree.ClassOrInterface) {\n            Tree.ClassOrInterface typeDecl = (Tree.ClassOrInterface)def;\n            overloadBuilder.modifiers(transformClassDeclFlags(typeDecl) & (PUBLIC | PRIVATE | Flags.PROTECTED));\n            typeParameterList = typeDecl.getTypeParameterList();\n            methName = makeUnquotedIdent(\"this\");\n        } else {\n            throw new RuntimeException();\n        }\n        \n        overloadBuilder.annotations(makeAtIgnore());\n        if (model instanceof Method) {\n            overloadBuilder.resultType((Method)model);\n        }\n        // TODO MPL\n        ListBuffer<JCExpression> typeArguments = ListBuffer.<JCExpression>lb();\n        if (typeParameterList != null) {\n            for (Tree.TypeParameterDeclaration t : typeParameterList.getTypeParameterDeclarations()) {\n                if (def instanceof Tree.AnyMethod) {\n                    overloadBuilder.typeParameter(t);\n                } else {\n                    // Ceylon doesn't have type params on constructors so no \n                    // need to parameterise the overloadBuilder\n                    typeArguments.add(gen().makeQuotedIdent(t.getIdentifier().getText()));\n                }\n                \n            }\n        }\n\n        // TODO Some simple default expressions (e.g. literals, null and \n        // base expressions it might be worth inlining the expression rather \n        // than calling the default value method.\n        // TODO We should call the no-defaults method directly using a Let\n        // rather than having the overloaded call each other in sequence\n        // (imagine a recursive method with many defaulted parameters -- we're \n        // wasting stack space)\n        // TODO This really belongs in the invocation builder\n        Declaration container = param.getDeclarationModel().getDeclaration().getRefinedDeclaration();\n        if (!container.isToplevel()) {\n            container = (Declaration)container.getContainer();\n        }\n        String className = Util.getCompanionClassName(container.getName());\n        \n        ListBuffer<JCExpression> args = ListBuffer.<JCExpression>lb();\n        ListBuffer<JCVariableDecl> vars = ListBuffer.<JCVariableDecl>lb();\n        \n        final String companionInstanceName = tempName(\"$impl$\");\n        if (def instanceof Tree.AnyClass) {\n            \n            JCExpression clazz = makeQuotedFQIdent(Util.getCompanionClassName(def.getDeclarationModel().getQualifiedNameString()));\n            if (!typeArguments.isEmpty()) {\n                clazz = make().TypeApply(clazz, typeArguments.toList());\n            }\n            vars.append(makeVar(companionInstanceName, \n                    clazz,// TODO FQ \n                    make().NewClass(null, // TODO encl == null ???\n                            null,\n                            clazz, \n                                    List.<JCExpression>nil(), null)));\n        }\n        \n        boolean useDefault = false;\n        for (Tree.Parameter param2 : paramList.getParameters()) {\n            if (param2 == param) {\n                useDefault = true;\n            }\n            if (useDefault) {\n                String methodName = Util.getDefaultedParamMethodName(def.getDeclarationModel(), param2.getDeclarationModel());\n                JCExpression defaultValueMethodName;\n                if (Decl.defaultParameterMethodOnSelf(def)) {\n                    defaultValueMethodName = gen().makeQuotedIdent(methodName);\n                } else {\n                    defaultValueMethodName = gen().makeQuotedQualIdent(makeQuotedIdent(companionInstanceName), methodName);\n                }\n                String varName = tempName(\"$\"+param2.getIdentifier().getText()+\"$\");\n                vars.append(makeVar(varName, \n                        makeJavaType(param2.getDeclarationModel().getType()), \n                        make().Apply(List.<JCExpression>nil(), defaultValueMethodName, \n                                ListBuffer.<JCExpression>lb().appendList(args).toList())));\n                args.add(makeUnquotedIdent(varName));\n            } else {\n                overloadBuilder.parameter(param2);\n                args.add(makeQuotedIdent(param2.getIdentifier().getText()));\n            }\n        }\n        \n        // TODO Type args on method call\n        JCExpression invocation;\n        /*if (def instanceof Tree.AnyMethod) {\n            invocation = make().Apply(List.<JCExpression>nil(),\n                    methName, args.toList());\n        } else {*/\n            invocation = make().Apply(List.<JCExpression>nil(),\n                    methName, args.toList());\n            \n        //}\n        if (isVoid) {\n            invocation = make().LetExpr(vars.toList(), List.<JCStatement>of(make().Exec(invocation)), makeNull());\n            overloadBuilder.body(make().Exec(invocation));\n        } else {\n            invocation = make().LetExpr(vars.toList(), invocation);\n            overloadBuilder.body(make().Return(invocation));\n        }\n        \n        return overloadBuilder;\n    }","id":26693,"modified_method":"private MethodDefinitionBuilder transformForDefaultedParameter(\n            MethodDefinitionBuilder overloadBuilder,\n            Tree.Declaration def,\n            Declaration model, boolean isVoid, ParameterList paramList,\n            Tree.Parameter param) {\n        \n        final TypeParameterList typeParameterList;\n        final JCExpression methName;\n        if (def instanceof Tree.AnyMethod) {\n            Tree.AnyMethod meth = (Tree.AnyMethod)def;\n            long mods = transformMethodDeclFlags(meth);\n            if (!Decl.withinInterface((model))) {\n                mods |= FINAL;\n            }\n            overloadBuilder.modifiers(mods);\n            typeParameterList = meth.getTypeParameterList();\n            methName = makeQuotedIdent(Util.quoteMethodNameIfProperty((Method)model, gen()));\n        } else if (def instanceof Tree.ClassOrInterface) {\n            Tree.ClassOrInterface typeDecl = (Tree.ClassOrInterface)def;\n            overloadBuilder.modifiers(transformClassDeclFlags(typeDecl) & (PUBLIC | PRIVATE | PROTECTED));\n            typeParameterList = typeDecl.getTypeParameterList();\n            methName = makeUnquotedIdent(\"this\");\n        } else {\n            throw new RuntimeException();\n        }\n        \n        overloadBuilder.annotations(makeAtIgnore());\n        if (model instanceof Method) {\n            overloadBuilder.resultType((Method)model);\n        }\n        // TODO MPL\n        if (typeParameterList != null) {\n            for (Tree.TypeParameterDeclaration t : typeParameterList.getTypeParameterDeclarations()) {\n                if (def instanceof Tree.AnyMethod) {\n                    // Ceylon doesn't have type params on constructors so only \n                    // need to parameterise the overloadBuilder if a method\n                    overloadBuilder.typeParameter(t);\n                }\n                \n            }\n        }\n\n        // TODO Some simple default expressions (e.g. literals, null and \n        // base expressions it might be worth inlining the expression rather \n        // than calling the default value method.\n        // TODO This really belongs in the invocation builder\n        Declaration container = param.getDeclarationModel().getDeclaration().getRefinedDeclaration();\n        if (!container.isToplevel()) {\n            container = (Declaration)container.getContainer();\n        }\n        \n        ListBuffer<JCExpression> args = ListBuffer.<JCExpression>lb();\n        ListBuffer<JCVariableDecl> vars = ListBuffer.<JCVariableDecl>lb();\n        \n        final String companionInstanceName = tempName(\"$impl$\");\n        if (def instanceof Tree.AnyClass) {\n            \n            vars.append(makeVar(companionInstanceName, \n                    makeCompanionType((Class)def.getDeclarationModel()),\n                    make().NewClass(null, // TODO encl == null ???\n                            null,\n                            makeCompanionType((Class)def.getDeclarationModel()),\n                            List.<JCExpression>nil(), null)));\n        }\n        \n        boolean useDefault = false;\n        for (Tree.Parameter param2 : paramList.getParameters()) {\n            if (param2 == param) {\n                useDefault = true;\n            }\n            if (useDefault) {\n                String methodName = Util.getDefaultedParamMethodName(def.getDeclarationModel(), param2.getDeclarationModel());\n                JCExpression defaultValueMethodName;\n                if (Decl.defaultParameterMethodOnSelf(def)) {\n                    defaultValueMethodName = gen().makeQuotedIdent(methodName);\n                } else {\n                    defaultValueMethodName = gen().makeQuotedQualIdent(makeQuotedIdent(companionInstanceName), methodName);\n                }\n                String varName = tempName(\"$\"+param2.getIdentifier().getText()+\"$\");\n                vars.append(makeVar(varName, \n                        makeJavaType(param2.getDeclarationModel().getType()), \n                        make().Apply(List.<JCExpression>nil(), defaultValueMethodName, \n                                ListBuffer.<JCExpression>lb().appendList(args).toList())));\n                args.add(makeUnquotedIdent(varName));\n            } else {\n                overloadBuilder.parameter(param2);\n                args.add(makeQuotedIdent(param2.getIdentifier().getText()));\n            }\n        }\n        \n        // TODO Type args on method call\n        JCExpression invocation = make().Apply(List.<JCExpression>nil(),\n                methName, args.toList());\n           \n        if (isVoid) {\n            invocation = make().LetExpr(vars.toList(), List.<JCStatement>of(make().Exec(invocation)), makeNull());\n            overloadBuilder.body(make().Exec(invocation));\n        } else {\n            invocation = make().LetExpr(vars.toList(), invocation);\n            overloadBuilder.body(make().Return(invocation));\n        }\n        \n        return overloadBuilder;\n    }","commit_id":"b4371b82d28322d075f5b34b3738563f28116e1d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private List<JCTree> makeSetter(Tree.AttributeDeclaration decl) {\n        at(decl);\n        String atrrName = decl.getIdentifier().getText();\n        return AttributeDefinitionBuilder\n            .setter(this, atrrName, decl.getDeclarationModel())\n            .modifiers(transformAttributeGetSetDeclFlags(decl))\n            .isActual(Decl.isActual(decl))\n            .isFormal(Decl.isFormal(decl))\n            .build();\n    }","id":26694,"modified_method":"private List<JCTree> makeSetter(Tree.AttributeDeclaration decl) {\n        at(decl);\n        String attrName = decl.getIdentifier().getText();\n        Value declModel = decl.getDeclarationModel();\n        Declaration parentDecl = declModel.getRefinedDeclaration();\n        boolean actual;\n        // If a variable attr is refining a non-variable one then the\n        // setter is not overriding anything\n        if (parentDecl != null && \n                parentDecl instanceof Value) {\n            Value parentValue = (Value)parentDecl;\n            actual = parentValue.isVariable() && Decl.isActual(decl);\n        } else {\n            actual = Decl.isActual(decl);\n        }\n        return AttributeDefinitionBuilder\n            .setter(this, attrName, declModel)\n            .modifiers(transformAttributeGetSetDeclFlags(decl))\n            .isActual(actual)\n            .isFormal(Decl.isFormal(decl))\n            .build();\n    }","commit_id":"e86f3c01faac2577481f022e96015b696465198b","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void onTraversalDone(Integer result) {\n        if ( readsToClean.size() > 0 || readsNotToClean.size() > 0 ) {\n            clean(readsToClean);\n            knownIndelsToTry.clear();\n\n            // merge the two sets for emission\n            readsNotToClean.addAll(readsToClean.getReads());\n            emit(readsNotToClean);\n        }\n\n        if ( writer != null )\n            writer.close();\n\n        if ( OUT_INDELS != null ) {\n            try {\n                indelOutput.close();\n            } catch (Exception e) {\n                logger.error(\"Failed to close \"+OUT_INDELS+\" gracefully. Data may be corrupt.\");\n            }\n        }\n        if ( OUT_STATS != null ) {\n            try {\n                statsOutput.close();\n            } catch (Exception e) {\n                logger.error(\"Failed to close \"+OUT_STATS+\" gracefully. Data may be corrupt.\");\n            }\n        }\n        if ( OUT_SNPS != null ) {\n            try {\n                snpsOutput.close();\n            } catch (Exception e) {\n                logger.error(\"Failed to close \"+OUT_SNPS+\" gracefully. Data may be corrupt.\");\n            }\n        }\n    }","id":26695,"modified_method":"public void onTraversalDone(Integer result) {\n        if ( readsToClean.size() > 0 || readsNotToClean.size() > 0 ) {\n            clean(readsToClean);\n            knownIndelsToTry.clear();\n\n            // merge the two sets for emission\n            readsNotToClean.addAll(readsToClean.getReads());\n            emit(readsNotToClean);\n        }\n\n        if ( OUT_INDELS != null ) {\n            try {\n                indelOutput.close();\n            } catch (Exception e) {\n                logger.error(\"Failed to close \"+OUT_INDELS+\" gracefully. Data may be corrupt.\");\n            }\n        }\n        if ( OUT_STATS != null ) {\n            try {\n                statsOutput.close();\n            } catch (Exception e) {\n                logger.error(\"Failed to close \"+OUT_STATS+\" gracefully. Data may be corrupt.\");\n            }\n        }\n        if ( OUT_SNPS != null ) {\n            try {\n                snpsOutput.close();\n            } catch (Exception e) {\n                logger.error(\"Failed to close \"+OUT_SNPS+\" gracefully. Data may be corrupt.\");\n            }\n        }\n    }","commit_id":"427a2f85e9d0ca0fc3baa25a145a85a7be39ef8a","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() {\n\n        if ( LOD_THRESHOLD < 0.0 )\n            throw new RuntimeException(\"LOD threshold cannot be a negative number\");\n        if ( MISMATCH_THRESHOLD <= 0.0 || MISMATCH_THRESHOLD > 1.0 )\n            throw new RuntimeException(\"Entropy threshold must be a fraction between 0 and 1\");\n\n        referenceReader = new IndexedFastaSequenceFile(getToolkit().getArguments().referenceFile);\n\n        if ( !TARGET_NOT_SORTED && IntervalUtils.isIntervalFile(intervalsFile)) {\n            // prepare to read intervals one-by-one, as needed (assuming they are sorted). \n            intervals = new IntervalFileMergingIterator( new java.io.File(intervalsFile), IntervalMergingRule.OVERLAPPING_ONLY );\n        } else {\n            // read in the whole list of intervals for cleaning\n            GenomeLocSortedSet locs = IntervalUtils.sortAndMergeIntervals(IntervalUtils.parseIntervalArguments(Arrays.asList(intervalsFile)), IntervalMergingRule.OVERLAPPING_ONLY);\n            intervals = locs.iterator();\n        }\n        currentInterval = intervals.hasNext() ? intervals.next() : null;\n\n        // set up the output writer(s)\n        if ( writerFilename != null ) {\n            SAMFileWriterFactory factory = new SAMFileWriterFactory();\n            factory.setMaxRecordsInRam(MAX_RECORDS_IN_RAM);\n\n            SAMFileHeader header = getToolkit().getSAMFileHeader();\n            File file = new File(writerFilename);\n            writer = makeWriter(factory, header, file);\n        }\n\n        if ( OUT_INDELS != null ) {\n            try {\n                indelOutput = new FileWriter(new File(OUT_INDELS));\n            } catch (Exception e) {\n                logger.error(\"Failed to create output file \"+ OUT_INDELS+\". Indel output will be suppressed\");\n                logger.error(e.getMessage());\n                indelOutput = null;\n            }\n        }\n        if ( OUT_STATS != null ) {\n            try {\n                statsOutput = new FileWriter(new File(OUT_STATS));\n            } catch (Exception e) {\n                logger.error(\"Failed to create output file \"+ OUT_STATS+\". Cleaning stats output will be suppressed\");\n                logger.error(e.getMessage());\n                statsOutput = null;\n            }\n        }\n        if ( OUT_SNPS != null ) {\n            try {\n                snpsOutput = new FileWriter(new File(OUT_SNPS));\n            } catch (Exception e) {\n                logger.error(\"Failed to create output file \"+ OUT_SNPS+\". Cleaning snps output will be suppressed\");\n                logger.error(e.getMessage());\n                snpsOutput = null;\n            }\n        }\n    }","id":26696,"modified_method":"public void initialize() {\n\n        if ( LOD_THRESHOLD < 0.0 )\n            throw new RuntimeException(\"LOD threshold cannot be a negative number\");\n        if ( MISMATCH_THRESHOLD <= 0.0 || MISMATCH_THRESHOLD > 1.0 )\n            throw new RuntimeException(\"Entropy threshold must be a fraction between 0 and 1\");\n\n        referenceReader = new IndexedFastaSequenceFile(getToolkit().getArguments().referenceFile);\n\n        if ( !TARGET_NOT_SORTED && IntervalUtils.isIntervalFile(intervalsFile)) {\n            // prepare to read intervals one-by-one, as needed (assuming they are sorted). \n            intervals = new IntervalFileMergingIterator( new java.io.File(intervalsFile), IntervalMergingRule.OVERLAPPING_ONLY );\n        } else {\n            // read in the whole list of intervals for cleaning\n            GenomeLocSortedSet locs = IntervalUtils.sortAndMergeIntervals(IntervalUtils.parseIntervalArguments(Arrays.asList(intervalsFile)), IntervalMergingRule.OVERLAPPING_ONLY);\n            intervals = locs.iterator();\n        }\n        currentInterval = intervals.hasNext() ? intervals.next() : null;\n\n        // set up the output writer(s)\n        if ( writer != null )\n            setupWriter(getToolkit().getSAMFileHeader());\n\n        if ( OUT_INDELS != null ) {\n            try {\n                indelOutput = new FileWriter(new File(OUT_INDELS));\n            } catch (Exception e) {\n                logger.error(\"Failed to create output file \"+ OUT_INDELS+\". Indel output will be suppressed\");\n                logger.error(e.getMessage());\n                indelOutput = null;\n            }\n        }\n        if ( OUT_STATS != null ) {\n            try {\n                statsOutput = new FileWriter(new File(OUT_STATS));\n            } catch (Exception e) {\n                logger.error(\"Failed to create output file \"+ OUT_STATS+\". Cleaning stats output will be suppressed\");\n                logger.error(e.getMessage());\n                statsOutput = null;\n            }\n        }\n        if ( OUT_SNPS != null ) {\n            try {\n                snpsOutput = new FileWriter(new File(OUT_SNPS));\n            } catch (Exception e) {\n                logger.error(\"Failed to create output file \"+ OUT_SNPS+\". Cleaning snps output will be suppressed\");\n                logger.error(e.getMessage());\n                snpsOutput = null;\n            }\n        }\n    }","commit_id":"427a2f85e9d0ca0fc3baa25a145a85a7be39ef8a","url":"https://github.com/broadgsa/gatk"},{"original_method":"private SAMFileWriter makeWriter(SAMFileWriterFactory factory, SAMFileHeader header, File file) {\n        if ( SORT_IN_COORDINATE_ORDER )\n            header.setSortOrder(SAMFileHeader.SortOrder.coordinate);\n        else\n            header.setSortOrder(SAMFileHeader.SortOrder.queryname);\n\n        if ( !NO_PG_TAG ) {\n            final SAMProgramRecord programRecord = new SAMProgramRecord(PROGRAM_RECORD_NAME);\n            final ResourceBundle headerInfo = TextFormattingUtils.loadResourceBundle(\"StingText\");\n            programRecord.setProgramVersion(headerInfo.getString(\"org.broadinstitute.sting.gatk.version\"));\n            HashSet<Object> args = new HashSet<Object>();\n            args.add(this);\n            programRecord.setCommandLine(CommandLineUtils.createApproximateCommandLineArgumentString(getToolkit(), args, getClass()));\n\n            List<SAMProgramRecord> oldRecords = header.getProgramRecords();\n            List<SAMProgramRecord> newRecords = new ArrayList<SAMProgramRecord>(oldRecords.size()+1);\n            for ( SAMProgramRecord record : oldRecords ) {\n                if ( !record.getId().startsWith(PROGRAM_RECORD_NAME) )\n                    newRecords.add(record);\n            }\n            newRecords.add(programRecord);\n            header.setProgramRecords(newRecords);\n        }\n\n        SAMFileWriter writer = factory.makeBAMWriter(header, false, file, compressionLevel);\n\n        return writer;\n    }","id":26697,"modified_method":"private void setupWriter(SAMFileHeader header) {\n        if ( SORT_IN_COORDINATE_ORDER )\n            header.setSortOrder(SAMFileHeader.SortOrder.coordinate);\n        else\n            header.setSortOrder(SAMFileHeader.SortOrder.queryname);\n\n        if ( !NO_PG_TAG ) {\n            final SAMProgramRecord programRecord = new SAMProgramRecord(PROGRAM_RECORD_NAME);\n            final ResourceBundle headerInfo = TextFormattingUtils.loadResourceBundle(\"StingText\");\n            programRecord.setProgramVersion(headerInfo.getString(\"org.broadinstitute.sting.gatk.version\"));\n            HashSet<Object> args = new HashSet<Object>();\n            args.add(this);\n            programRecord.setCommandLine(CommandLineUtils.createApproximateCommandLineArgumentString(getToolkit(), args, getClass()));\n\n            List<SAMProgramRecord> oldRecords = header.getProgramRecords();\n            List<SAMProgramRecord> newRecords = new ArrayList<SAMProgramRecord>(oldRecords.size()+1);\n            for ( SAMProgramRecord record : oldRecords ) {\n                if ( !record.getId().startsWith(PROGRAM_RECORD_NAME) )\n                    newRecords.add(record);\n            }\n            newRecords.add(programRecord);\n            header.setProgramRecords(newRecords);\n        }\n\n        writer.writeHeader(header);\n        writer.setPresorted(false);\n    }","commit_id":"427a2f85e9d0ca0fc3baa25a145a85a7be39ef8a","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void addWriter(SAMReaderID id , String outName, SAMFileHeader.SortOrder order, boolean presorted,\n                           boolean indexOnTheFly, boolean generateMD5, SAMProgramRecord programRecord) {\n        File f = new File(outName);\n        SAMFileHeader header = toolkit.getSAMFileHeader(id).clone();\n        header.setSortOrder(order);\n\n        if ( programRecord != null )  {\n            // --->> add program record\n            List<SAMProgramRecord> oldRecords = header.getProgramRecords();\n            List<SAMProgramRecord> newRecords = new ArrayList<SAMProgramRecord>(oldRecords.size()+1);\n            for ( SAMProgramRecord record : oldRecords ) {\n                if ( !record.getId().startsWith(programRecord.getId()) || KEEP_ALL_PG_RECORDS )\n                    newRecords.add(record);\n            }\n            newRecords.add(programRecord);\n            header.setProgramRecords(newRecords);\n            // <-- add program record ends here\n        }\n        SAMFileWriterFactory factory = new SAMFileWriterFactory();\n        factory.setCreateIndex(indexOnTheFly);\n        factory.setCreateMd5File(generateMD5);\n        SAMFileWriter sw = factory.makeSAMOrBAMWriter(header, presorted, f);\n        writerMap.put(id,sw);\n    }","id":26698,"modified_method":"private void addWriter(SAMReaderID id , String outName, SAMFileHeader.SortOrder order, boolean presorted,\n                           boolean indexOnTheFly, boolean generateMD5, SAMProgramRecord programRecord) {\n        File f = new File(outName);\n        SAMFileHeader header = Utils.setupWriter(toolkit, toolkit.getSAMFileHeader(id), KEEP_ALL_PG_RECORDS, programRecord);\n        SAMFileWriterFactory factory = new SAMFileWriterFactory();\n        factory.setCreateIndex(indexOnTheFly);\n        factory.setCreateMd5File(generateMD5);\n        SAMFileWriter sw = factory.makeSAMOrBAMWriter(header, presorted, f);\n        writerMap.put(id,sw);\n    }","commit_id":"42d399e02d94f85cd97707413fe4ee76a49731e1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static SAMProgramRecord createProgramRecord(GenomeAnalysisEngine toolkit, Object walker, String PROGRAM_RECORD_NAME) {\n        final SAMProgramRecord programRecord = new SAMProgramRecord(PROGRAM_RECORD_NAME);\n        final ResourceBundle headerInfo = TextFormattingUtils.loadResourceBundle(\"StingText\");\n        try {\n            final String version = headerInfo.getString(\"org.broadinstitute.sting.gatk.version\");\n            programRecord.setProgramVersion(version);\n        } catch (MissingResourceException e) {\n            // couldn't care less if the resource is missing...\n        }\n        programRecord.setCommandLine(toolkit.createApproximateCommandLineArgumentString(toolkit, walker));\n        return programRecord;\n    }","id":26699,"modified_method":"/**\n     * Creates a program record (@PG) tag\n     *\n     * @param toolkit             the engine\n     * @param walker              the walker object (so we can extract the command line)\n     * @param PROGRAM_RECORD_NAME the name for the PG tag\n     * @return a program record for the tool\n     */\n    public static SAMProgramRecord createProgramRecord(GenomeAnalysisEngine toolkit, Object walker, String PROGRAM_RECORD_NAME) {\n        final SAMProgramRecord programRecord = new SAMProgramRecord(PROGRAM_RECORD_NAME);\n        final ResourceBundle headerInfo = TextFormattingUtils.loadResourceBundle(\"StingText\");\n        try {\n            final String version = headerInfo.getString(\"org.broadinstitute.sting.gatk.version\");\n            programRecord.setProgramVersion(version);\n        } catch (MissingResourceException e) {\n            // couldn't care less if the resource is missing...\n        }\n        programRecord.setCommandLine(toolkit.createApproximateCommandLineArgumentString(toolkit, walker));\n        return programRecord;\n    }","commit_id":"42d399e02d94f85cd97707413fe4ee76a49731e1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static void setupWriter(StingSAMFileWriter writer, GenomeAnalysisEngine toolkit, boolean preSorted, boolean KEEP_ALL_PG_RECORDS, Object walker, String PROGRAM_RECORD_NAME) {\n        final SAMProgramRecord programRecord = createProgramRecord(toolkit, walker, PROGRAM_RECORD_NAME);\n\n        SAMFileHeader header = toolkit.getSAMFileHeader();\n        List<SAMProgramRecord> oldRecords = header.getProgramRecords();\n        List<SAMProgramRecord> newRecords = new ArrayList<SAMProgramRecord>(oldRecords.size()+1);\n        for ( SAMProgramRecord record : oldRecords )\n            if ( !record.getId().startsWith(PROGRAM_RECORD_NAME) || KEEP_ALL_PG_RECORDS )\n                newRecords.add(record);\n\n        newRecords.add(programRecord);\n        header.setProgramRecords(newRecords);\n\n        writer.writeHeader(header);\n        writer.setPresorted(preSorted);\n    }","id":26700,"modified_method":"/**\n     * Creates a program record for the program, adds it to the list of program records (@PG tags) in the bam file and sets\n     * up the writer with the header and presorted status.\n     *\n     * @param writer              BAM file writer\n     * @param toolkit             the engine\n     * @param preSorted           whether or not the writer can assume reads are going to be added are already sorted\n     * @param KEEP_ALL_PG_RECORDS whether or not to keep all the other program records already existing in this BAM file\n     * @param walker              the walker object (so we can extract the command line)\n     * @param PROGRAM_RECORD_NAME the name for the PG tag\n     */\n    public static void setupWriter(StingSAMFileWriter writer, GenomeAnalysisEngine toolkit, SAMFileHeader originalHeader, boolean preSorted, boolean KEEP_ALL_PG_RECORDS, Object walker, String PROGRAM_RECORD_NAME) {\n        SAMFileHeader header = setupWriter(toolkit, originalHeader, KEEP_ALL_PG_RECORDS, walker, PROGRAM_RECORD_NAME);\n        writer.writeHeader(header);\n        writer.setPresorted(preSorted);\n    }","commit_id":"42d399e02d94f85cd97707413fe4ee76a49731e1","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void addWriter(SAMReaderID id , String outName, SAMFileHeader.SortOrder order, boolean presorted,\n                           boolean indexOnTheFly, boolean generateMD5, SAMProgramRecord programRecord) {\n        File f = new File(outName);\n        SAMFileHeader header = toolkit.getSAMFileHeader(id).clone();\n        header.setSortOrder(order);\n\n        if ( programRecord != null )  {\n            // --->> add program record\n            List<SAMProgramRecord> oldRecords = header.getProgramRecords();\n            List<SAMProgramRecord> newRecords = new ArrayList<SAMProgramRecord>(oldRecords.size()+1);\n            for ( SAMProgramRecord record : oldRecords ) {\n                if ( !record.getId().startsWith(programRecord.getId()) || KEEP_ALL_PG_RECORDS )\n                    newRecords.add(record);\n            }\n            newRecords.add(programRecord);\n            header.setProgramRecords(newRecords);\n            // <-- add program record ends here\n        }\n        SAMFileWriterFactory factory = new SAMFileWriterFactory();\n        factory.setCreateIndex(indexOnTheFly);\n        factory.setCreateMd5File(generateMD5);\n        SAMFileWriter sw = factory.makeSAMOrBAMWriter(header, presorted, f);\n        writerMap.put(id,sw);\n    }","id":26701,"modified_method":"private void addWriter(SAMReaderID id , String outName, SAMFileHeader.SortOrder order, boolean presorted,\n                           boolean indexOnTheFly, boolean generateMD5, SAMProgramRecord programRecord) {\n        File f = new File(outName);\n        SAMFileHeader header = Utils.setupWriter(toolkit, toolkit.getSAMFileHeader(id), KEEP_ALL_PG_RECORDS, programRecord);\n        SAMFileWriterFactory factory = new SAMFileWriterFactory();\n        factory.setCreateIndex(indexOnTheFly);\n        factory.setCreateMd5File(generateMD5);\n        SAMFileWriter sw = factory.makeSAMOrBAMWriter(header, presorted, f);\n        writerMap.put(id,sw);\n    }","commit_id":"995d2d2c682b26c07907090cc269a975811ce15b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static SAMProgramRecord createProgramRecord(GenomeAnalysisEngine toolkit, Object walker, String PROGRAM_RECORD_NAME) {\n        final SAMProgramRecord programRecord = new SAMProgramRecord(PROGRAM_RECORD_NAME);\n        final ResourceBundle headerInfo = TextFormattingUtils.loadResourceBundle(\"StingText\");\n        try {\n            final String version = headerInfo.getString(\"org.broadinstitute.sting.gatk.version\");\n            programRecord.setProgramVersion(version);\n        } catch (MissingResourceException e) {\n            // couldn't care less if the resource is missing...\n        }\n        programRecord.setCommandLine(toolkit.createApproximateCommandLineArgumentString(toolkit, walker));\n        return programRecord;\n    }","id":26702,"modified_method":"/**\n     * Creates a program record (@PG) tag\n     *\n     * @param toolkit             the engine\n     * @param walker              the walker object (so we can extract the command line)\n     * @param PROGRAM_RECORD_NAME the name for the PG tag\n     * @return a program record for the tool\n     */\n    public static SAMProgramRecord createProgramRecord(GenomeAnalysisEngine toolkit, Object walker, String PROGRAM_RECORD_NAME) {\n        final SAMProgramRecord programRecord = new SAMProgramRecord(PROGRAM_RECORD_NAME);\n        final ResourceBundle headerInfo = TextFormattingUtils.loadResourceBundle(\"StingText\");\n        try {\n            final String version = headerInfo.getString(\"org.broadinstitute.sting.gatk.version\");\n            programRecord.setProgramVersion(version);\n        } catch (MissingResourceException e) {\n            // couldn't care less if the resource is missing...\n        }\n        programRecord.setCommandLine(toolkit.createApproximateCommandLineArgumentString(toolkit, walker));\n        return programRecord;\n    }","commit_id":"995d2d2c682b26c07907090cc269a975811ce15b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static void setupWriter(StingSAMFileWriter writer, GenomeAnalysisEngine toolkit, boolean preSorted, boolean KEEP_ALL_PG_RECORDS, Object walker, String PROGRAM_RECORD_NAME) {\n        final SAMProgramRecord programRecord = createProgramRecord(toolkit, walker, PROGRAM_RECORD_NAME);\n\n        SAMFileHeader header = toolkit.getSAMFileHeader();\n        List<SAMProgramRecord> oldRecords = header.getProgramRecords();\n        List<SAMProgramRecord> newRecords = new ArrayList<SAMProgramRecord>(oldRecords.size()+1);\n        for ( SAMProgramRecord record : oldRecords )\n            if ( !record.getId().startsWith(PROGRAM_RECORD_NAME) || KEEP_ALL_PG_RECORDS )\n                newRecords.add(record);\n\n        newRecords.add(programRecord);\n        header.setProgramRecords(newRecords);\n\n        writer.writeHeader(header);\n        writer.setPresorted(preSorted);\n    }","id":26703,"modified_method":"/**\n     * Creates a program record for the program, adds it to the list of program records (@PG tags) in the bam file and sets\n     * up the writer with the header and presorted status.\n     *\n     * @param writer              BAM file writer\n     * @param toolkit             the engine\n     * @param preSorted           whether or not the writer can assume reads are going to be added are already sorted\n     * @param KEEP_ALL_PG_RECORDS whether or not to keep all the other program records already existing in this BAM file\n     * @param walker              the walker object (so we can extract the command line)\n     * @param PROGRAM_RECORD_NAME the name for the PG tag\n     */\n    public static void setupWriter(StingSAMFileWriter writer, GenomeAnalysisEngine toolkit, SAMFileHeader originalHeader, boolean preSorted, boolean KEEP_ALL_PG_RECORDS, Object walker, String PROGRAM_RECORD_NAME) {\n        SAMFileHeader header = setupWriter(toolkit, originalHeader, KEEP_ALL_PG_RECORDS, walker, PROGRAM_RECORD_NAME);\n        writer.writeHeader(header);\n        writer.setPresorted(preSorted);\n    }","commit_id":"995d2d2c682b26c07907090cc269a975811ce15b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public boolean swapOut(SModelData model) {\n      if (mySpaceDir == null || !mySpaceDir.exists()) throw new IllegalStateException(\"no swap dir\");\n\n      String modelId = model.getReference().getModelId().toString();\n      if (modelId == null || modelId.isEmpty()) {\n        LOG.error(\"Bad model id <\" + modelId + \">\");\n        return false;\n      }\n      modelId = modelId.replaceAll(\":\", \"-\");\n\n      File swapFile = new File(mySpaceDir, modelId);\n      if (swapFile.exists() && !swapFile.delete()) {\n        LOG.error(\"Couldn't delete swap file\");\n        return false;\n      }\n\n      ArrayList<SNode> roots = new ArrayList<SNode>();\n      for (Iterator<SNode> it = model.getRootNodes().iterator(); it.hasNext(); ) {\n        roots.add(it.next());\n      }\n      ModelOutputStream mos = null;\n      IOException ioex = null;\n      try {\n        mos = new ModelOutputStream(new FileOutputStream(swapFile));\n        saveModel(model.getReference(), roots, mos);\n      } catch (IOException e) {\n        ioex = e;\n        LOG.error(null, e);\n      } finally {\n        if (mos != null) {\n          try {\n            mos.close();\n          } catch (IOException ignore) {\n          }\n        }\n      }\n\n      return ioex == null;\n    }","id":26704,"modified_method":"@Override\n    public boolean swapOut(SModelData model) {\n      if (mySpaceDir == null || !mySpaceDir.exists()) throw new IllegalStateException(\"no swap dir\");\n\n      String modelId = model.getReference().getModelId().toString();\n      if (modelId == null || modelId.isEmpty()) {\n        LOG.error(\"Bad model id <\" + modelId + \">\");\n        return false;\n      }\n      modelId = modelId.replaceAll(\":\", \"-\");\n\n      File swapFile = new File(mySpaceDir, modelId);\n      if (swapFile.exists() && !swapFile.delete()) {\n        LOG.error(\"Couldn't delete swap file\");\n        return false;\n      }\n\n      ArrayList<SNode> roots = new ArrayList<SNode>();\n      for (SNode next : model.getRootNodes()) {\n        roots.add(next);\n      }\n      ModelOutputStream mos = null;\n      IOException ioex = null;\n      try {\n        mos = new ModelOutputStream(new FileOutputStream(swapFile));\n        saveModel(model.getReference(), roots, mos);\n      } catch (IOException e) {\n        ioex = e;\n        LOG.error(null, e);\n      } finally {\n        if (mos != null) {\n          try {\n            mos.close();\n          } catch (IOException ignore) {\n          }\n        }\n      }\n\n      return ioex == null;\n    }","commit_id":"dafae5f55eb39f9bf0e05d460cac87b6bf4f28dd","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SModel writeAndReadModel(jetbrains.mps.smodel.SModel model) throws IOException {\n    // write\n    ByteArrayOutputStream os = new ByteArrayOutputStream();\n    ModelOutputStream mos = new ModelOutputStream(os);\n\n    ArrayList<SNode> roots = new ArrayList<SNode>();\n    for (Iterator<SNode> it = model.getRootNodes().iterator(); it.hasNext(); ) {\n      roots.add(it.next());\n    }\n    mos.writeInt(44);\n    new NodesWriter(model.getReference(), null).writeNodes(roots, mos);\n    mos.close();\n\n    final jetbrains.mps.smodel.SModel resultModel = new jetbrains.mps.smodel.SModel(\n        PersistenceFacade.getInstance().createModelReference(\"smodel.long.name.for.testing\"));\n    ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());\n    ModelInputStream mis = new ModelInputStream(is);\n\n    // read\n    int version = mis.readInt();\n    if (version != 44) {\n      return null;\n    }\n    List<Pair<String, SNode>> resultRoots = new NodesReader(resultModel.getReference(), false).readNodes(mis);\n    for (Pair<String, SNode> root : resultRoots) {\n      resultModel.addRootNode(root.o2);\n    }\n\n    SModelOperations.validateLanguagesAndImports(resultModel, false, false);\n\n    SModelBase result = new SModelBase(resultModel.getReference(), new NullDataSource()) {\n      @Override\n      public jetbrains.mps.smodel.SModel getSModelInternal() {\n        return resultModel;\n      }\n\n      @Override\n      public boolean isLoaded() {\n        return true;\n      }\n\n      @Override\n      public void unload() {\n\n      }\n    };\n\n    resultModel.setModelDescriptor(result);\n    return result;\n  }","id":26705,"modified_method":"public static SModel writeAndReadModel(jetbrains.mps.smodel.SModel model) throws IOException {\n    // write\n    ByteArrayOutputStream os = new ByteArrayOutputStream();\n    ModelOutputStream mos = new ModelOutputStream(os);\n\n    ArrayList<SNode> roots = new ArrayList<SNode>();\n    for (SNode next : model.getRootNodes()) {\n      roots.add(next);\n    }\n    mos.writeInt(44);\n    new NodesWriter(model.getReference(), null).writeNodes(roots, mos);\n    mos.close();\n\n    final jetbrains.mps.smodel.SModel resultModel = new jetbrains.mps.smodel.SModel(\n        PersistenceFacade.getInstance().createModelReference(\"smodel.long.name.for.testing\"));\n    ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());\n    ModelInputStream mis = new ModelInputStream(is);\n\n    // read\n    int version = mis.readInt();\n    if (version != 44) {\n      return null;\n    }\n    List<Pair<String, SNode>> resultRoots = new NodesReader(resultModel.getReference(), false).readNodes(mis);\n    for (Pair<String, SNode> root : resultRoots) {\n      resultModel.addRootNode(root.o2);\n    }\n\n    SModelBase result = new SModelBase(resultModel.getReference(), new NullDataSource()) {\n      @Override\n      public jetbrains.mps.smodel.SModel getSModelInternal() {\n        return resultModel;\n      }\n\n      @Override\n      public boolean isLoaded() {\n        return true;\n      }\n\n      @Override\n      public void unload() {\n\n      }\n    };\n\n    resultModel.setModelDescriptor(result);\n\n    SModelOperations.validateLanguagesAndImports(result, false, false);\n\n    return result;\n  }","commit_id":"dafae5f55eb39f9bf0e05d460cac87b6bf4f28dd","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public final jetbrains.mps.smodel.SModel getSModelInternal() {\n      if (mySModel != null) {\n        return mySModel;\n      }\n      synchronized (this) {\n        if (mySModel == null) {\n          mySModel = createModel();\n          mySModel.setModelDescriptor(this);\n          fireModelStateChanged(ModelLoadingState.FULLY_LOADED);\n        }\n      }\n      return mySModel;\n    }","id":26706,"modified_method":"@Override\n    public final jetbrains.mps.smodel.SModel getSModelInternal() {\n      if (mySModel != null) {\n        return mySModel;\n      }\n      synchronized (this) {\n        if (mySModel == null) {\n          mySModel = createModel();\n          mySModel.setModelDescriptor(this);\n          if (wasUnloaded) {\n            // ensure imports are back\n            SModelOperations.validateLanguagesAndImports(this, false, false);\n          }\n          fireModelStateChanged(ModelLoadingState.FULLY_LOADED);\n        }\n      }\n      return mySModel;\n    }","commit_id":"dafae5f55eb39f9bf0e05d460cac87b6bf4f28dd","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected jetbrains.mps.smodel.SModel createModel() {\n      if (wasUnloaded) {\n        LOG.debug(\"Re-loading \" + getReference());\n\n        TransientSwapSpace swap = myComponent.getTransientSwapSpace();\n        if (swap == null) throw new IllegalStateException(\"no swap space\");\n\n        TransientSModel m = swap.restoreFromSwap(getReference(), new TransientSModel(getReference()));\n        if (m != null) {\n          // ensure imports are back\n          SModelOperations.validateLanguagesAndImports(m, false, false);\n          return m;\n        }\n\n        throw new IllegalStateException(\"lost swapped out model\");\n      } else {\n        return new TransientSModel(getReference());\n      }\n    }","id":26707,"modified_method":"private jetbrains.mps.smodel.SModel createModel() {\n      if (wasUnloaded) {\n        LOG.debug(\"Re-loading \" + getReference());\n\n        TransientSwapSpace swap = myComponent.getTransientSwapSpace();\n        if (swap == null) throw new IllegalStateException(\"no swap space\");\n\n        TransientSModel m = swap.restoreFromSwap(getReference(), new TransientSModel(getReference()));\n        if (m != null) {\n          return m;\n        }\n\n        throw new IllegalStateException(\"lost swapped out model\");\n      } else {\n        return new TransientSModel(getReference());\n      }\n    }","commit_id":"dafae5f55eb39f9bf0e05d460cac87b6bf4f28dd","url":"https://github.com/JetBrains/MPS"},{"original_method":"private SModel executeMajorStepInternal(SModel inputModel, RuleManager ruleManager) throws GenerationFailureException, GenerationCanceledException {\n    SModel currentInputModel = inputModel;\n    IGenerationTracer tracer = mySessionContext.getGenerationTracer();\n\n    // -----------------------\n    // run pre-processing scripts\n    // -----------------------\n    ttrace.push(\"pre-processing\", false);\n    currentInputModel = preProcessModel(ruleManager, currentInputModel);\n    ttrace.pop();\n\n    SModel currentOutputModel = createTransientModel();\n\n    if (myLogger.needsInfo()) {\n      myLogger.info(\n          \"generating model '\" + currentInputModel.getReference().getModelName() + \"' --> '\" + currentOutputModel.getReference().getModelName() + \"'\");\n    }\n    boolean isPrimary = true;\n    // exit condition for secondary mapping\n    int secondaryMappingRepeatCount = 0;\n    while (true) {\n      if (myLogger.needsInfo() && !isPrimary /*only for 1+ minor steps*/) {\n        myLogger.info(\"next minor step '\" + SModelStereotype.getStereotype(\n            currentInputModel.getReference().getModelName()) + \"' --> '\" + SModelStereotype.getStereotype(currentOutputModel.getReference().getModelName()) + \"'\");\n      }\n      tracer.startTracing(currentInputModel, currentOutputModel);\n      final Pair<Boolean, SModel> applied = applyRules(currentInputModel, currentOutputModel, isPrimary, ruleManager);\n      boolean somethingHasBeenGenerated = applied.o1;\n      SModel realOutputModel = applied.o2;\n      if (!somethingHasBeenGenerated) {\n        // nothing has been generated\n        myDependenciesBuilder.dropModel();\n        tracer.discardTracing(currentInputModel, currentOutputModel);\n        recycleWasteModel(currentOutputModel, true);\n        myMinorStep--; // what for?!\n        if (myLogger.needsInfo()) {\n          myLogger.info(\"unchanged, empty model '\" + SModelStereotype.getStereotype(currentOutputModel.getReference().getModelName()) + \"' removed\");\n        }\n        currentOutputModel = currentInputModel;\n        break;\n      }\n\n      if (++secondaryMappingRepeatCount > 10) {\n        logTenMinorStepsCountReached(realOutputModel);\n        throw new GenerationFailureException();\n      }\n\n      // next iteration ...\n      mySessionContext.clearTransientObjects();\n      isPrimary = false;\n      if (realOutputModel == currentOutputModel) { // 'honest' transformation, not in-place\n        SModelOperations.validateLanguagesAndImports(currentOutputModel, false, false);\n        myDependenciesBuilder.updateModel(currentOutputModel);\n        recycleWasteModel(currentInputModel, false); // we can forget about former input model here\n        currentInputModel = currentOutputModel;\n        ((jetbrains.mps.smodel.SModelInternal) currentInputModel).disposeFastNodeFinder(); // why?!\n        currentOutputModel = createTransientModel();\n      } else {\n        assert currentInputModel == realOutputModel;\n        // in fact, can reuse output model here, but it's task to solve together with tracer (and how it would live with startTracing(same models)\n        recycleWasteModel(currentOutputModel, true);\n        currentOutputModel = createTransientModel();\n      }\n    }\n\n    // -----------------------\n    // run post-processing scripts\n    // -----------------------\n    ttrace.push(\"post-processing\", false);\n    currentOutputModel = postProcessModel(ruleManager, currentOutputModel);\n    ttrace.pop();\n\n    return currentOutputModel;\n  }","id":26708,"modified_method":"private SModel executeMajorStepInternal(SModel inputModel, RuleManager ruleManager) throws GenerationFailureException, GenerationCanceledException {\n    SModel currentInputModel = inputModel;\n    IGenerationTracer tracer = mySessionContext.getGenerationTracer();\n\n    // -----------------------\n    // run pre-processing scripts\n    // -----------------------\n    ttrace.push(\"pre-processing\", false);\n    currentInputModel = preProcessModel(ruleManager, currentInputModel);\n    ttrace.pop();\n\n    SModel currentOutputModel = createTransientModel();\n\n    if (myLogger.needsInfo()) {\n      myLogger.info(\n          \"generating model '\" + currentInputModel.getReference().getModelName() + \"' --> '\" + currentOutputModel.getReference().getModelName() + \"'\");\n    }\n    boolean isPrimary = true;\n    // exit condition for secondary mapping\n    int secondaryMappingRepeatCount = 0;\n    while (true) {\n      if (myLogger.needsInfo() && !isPrimary /*only for 1+ minor steps*/) {\n        myLogger.info(\"next minor step '\" + SModelStereotype.getStereotype(\n            currentInputModel.getReference().getModelName()) + \"' --> '\" + SModelStereotype.getStereotype(currentOutputModel.getReference().getModelName()) + \"'\");\n      }\n      tracer.startTracing(currentInputModel, currentOutputModel);\n      final Pair<Boolean, SModel> applied = applyRules(currentInputModel, currentOutputModel, isPrimary, ruleManager);\n      boolean somethingHasBeenGenerated = applied.o1;\n      SModel realOutputModel = applied.o2;\n      if (!somethingHasBeenGenerated) {\n        // nothing has been generated\n        myDependenciesBuilder.dropModel();\n        tracer.discardTracing(currentInputModel, currentOutputModel);\n        recycleWasteModel(currentOutputModel, true);\n        myMinorStep--; // what for?!\n        if (myLogger.needsInfo()) {\n          myLogger.info(\"unchanged, empty model '\" + SModelStereotype.getStereotype(currentOutputModel.getReference().getModelName()) + \"' removed\");\n        }\n        currentOutputModel = currentInputModel;\n        break;\n      }\n\n      if (++secondaryMappingRepeatCount > 10) {\n        logTenMinorStepsCountReached(realOutputModel);\n        throw new GenerationFailureException();\n      }\n\n      // next iteration ...\n      mySessionContext.clearTransientObjects();\n      isPrimary = false;\n      if (realOutputModel == currentOutputModel) { // 'honest' transformation, not in-place\n        SModelOperations.validateLanguagesAndImports(currentOutputModel, false, false);\n        myDependenciesBuilder.updateModel(currentOutputModel);\n        recycleWasteModel(currentInputModel, false); // we can forget about former input model here\n        currentInputModel = currentOutputModel;\n        ((jetbrains.mps.smodel.SModelInternal) currentInputModel).disposeFastNodeFinder(); // why?!\n        currentOutputModel = createTransientModel();\n      } else {\n        assert currentInputModel == realOutputModel;\n        myDependenciesBuilder.dropModel();\n        // in fact, can reuse output model here, but it's task to solve together with tracer (and how it would live with startTracing(same models)\n        recycleWasteModel(currentOutputModel, true);\n        currentOutputModel = createTransientModel();\n      }\n    }\n\n    // -----------------------\n    // run post-processing scripts\n    // -----------------------\n    ttrace.push(\"post-processing\", false);\n    currentOutputModel = postProcessModel(ruleManager, currentOutputModel);\n    ttrace.pop();\n\n    return currentOutputModel;\n  }","commit_id":"8dcbdca11b9df8000e8bee684a1971bb2f91ecb7","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void applyReductions(boolean isPrimary) throws GenerationCanceledException, GenerationFailureException {\n    // create all roots\n    if (isPrimary) {\n      ttrace.push(\"create roots\", false);\n\n      final QueryExecutionContext executionContext = getExecutionContext(null);\n      if (executionContext != null) {\n        TemplateExecutionEnvironment environment = new TemplateExecutionEnvironmentImpl(this, executionContext, new ReductionContext());\n        for (TemplateCreateRootRule rule : myRuleManager.getCreateRootRules()) {\n          checkMonitorCanceled();\n          applyCreateRoot(rule, environment);\n        }\n      }\n      ttrace.pop();\n    }\n\n    // root mapping rules\n    ttrace.push(\"root mappings\", false);\n    ArrayList<SNode> rootsConsumed = new ArrayList<SNode>();\n    for (TemplateRootMappingRule rule : myRuleManager.getRoot_MappingRules()) {\n      checkMonitorCanceled();\n      applyRootRule(rule, rootsConsumed);\n    }\n    ArrayList<SNode> rootsToCopy = new ArrayList<SNode>();\n    for (SNode root : myInputModel.getRootNodes()) {\n      rootsToCopy.add(root);\n    }\n    rootsToCopy.removeAll(rootsConsumed);\n    ttrace.pop();\n\n    if (myInplaceChangeEnabled && !isPrimary && !myChanged && rootsConsumed.isEmpty()) {\n      if (myWeavingProcessor.hasWeavingRulesToApply()) {\n        myLogger.info(\"Could have had delta builder here, but can't due to active weavings\");\n      } else {\n        myDeltaBuilder = createDeltaBuilder();\n      }\n    }\n    // copy roots\n    checkMonitorCanceled();\n    getGeneratorSessionContext().clearCopiedRootsSet();\n    for (SNode rootToCopy : rootsToCopy) {\n      QueryExecutionContext context = getExecutionContext(rootToCopy);\n      if (context != null) {\n        TemplateExecutionEnvironmentImpl rootenv = new TemplateExecutionEnvironmentImpl(this, context, new ReductionContext());\n        copyRootInputNode(rootToCopy, rootenv);\n      }\n    }\n  }","id":26709,"modified_method":"protected void applyReductions(boolean isPrimary) throws GenerationCanceledException, GenerationFailureException {\n    // create all roots\n    if (isPrimary) {\n      ttrace.push(\"create roots\", false);\n\n      final QueryExecutionContext executionContext = getExecutionContext(null);\n      if (executionContext != null) {\n        TemplateExecutionEnvironment environment = new TemplateExecutionEnvironmentImpl(this, executionContext, new ReductionContext());\n        for (TemplateCreateRootRule rule : myRuleManager.getCreateRootRules()) {\n          checkMonitorCanceled();\n          applyCreateRoot(rule, environment);\n        }\n      }\n      ttrace.pop();\n    }\n\n    // root mapping rules\n    ttrace.push(\"root mappings\", false);\n    ArrayList<SNode> rootsConsumed = new ArrayList<SNode>();\n    for (TemplateRootMappingRule rule : myRuleManager.getRoot_MappingRules()) {\n      checkMonitorCanceled();\n      applyRootRule(rule, rootsConsumed);\n    }\n    ttrace.pop();\n\n    if (myInplaceChangeEnabled && !myNewRootsAreAdded && rootsConsumed.isEmpty()) {\n      if (myWeavingProcessor.hasWeavingRulesToApply()) {\n        myLogger.info(\"Could have had delta builder here, but can't due to active weavings\");\n      } else {\n        myLogger.info(\"Active in-place model transformation\");\n        myDeltaBuilder = createDeltaBuilder();\n      }\n    }\n    // copy roots\n    checkMonitorCanceled();\n    getGeneratorSessionContext().clearCopiedRootsSet();\n    for (SNode rootToCopy : myInputModel.getRootNodes()) {\n      if (rootsConsumed.contains(rootToCopy)) {\n        continue;\n      }\n      QueryExecutionContext context = getExecutionContext(rootToCopy);\n      if (context != null) {\n        TemplateExecutionEnvironmentImpl rootenv = new TemplateExecutionEnvironmentImpl(this, context, new ReductionContext());\n        copyRootInputNode(rootToCopy, rootenv);\n      }\n    }\n  }","commit_id":"8dcbdca11b9df8000e8bee684a1971bb2f91ecb7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void applyCreateRoot(TemplateCreateRootRule rule, TemplateExecutionEnvironment environment) throws GenerationFailureException, GenerationCanceledException {\n    try {\n      if (environment.getQueryExecutor().isApplicable(rule, environment, null)) {\n        myGenerationTracer.pushRule(rule.getRuleNode());\n        try {\n          createRootNodeByRule(rule, environment);\n        } finally {\n          myGenerationTracer.closeRule(rule.getRuleNode());\n        }\n      }\n    } catch (GenerationException e) {\n      if (e instanceof GenerationCanceledException) throw (GenerationCanceledException) e;\n      if (e instanceof GenerationFailureException) throw (GenerationFailureException) e;\n      showErrorMessage(null, rule.getRuleNode().resolve(MPSModuleRepository.getInstance()), \"internal error: \" + e.toString());\n    }\n  }","id":26710,"modified_method":"private void applyCreateRoot(TemplateCreateRootRule rule, TemplateExecutionEnvironment environment) throws GenerationFailureException, GenerationCanceledException {\n    try {\n      if (environment.getQueryExecutor().isApplicable(rule, environment, null)) {\n        myNewRootsAreAdded = true;\n        myGenerationTracer.pushRule(rule.getRuleNode());\n        try {\n          createRootNodeByRule(rule, environment);\n        } finally {\n          myGenerationTracer.closeRule(rule.getRuleNode());\n        }\n      }\n    } catch (GenerationException e) {\n      if (e instanceof GenerationCanceledException) throw (GenerationCanceledException) e;\n      if (e instanceof GenerationFailureException) throw (GenerationFailureException) e;\n      showErrorMessage(null, rule.getRuleNode().resolve(MPSModuleRepository.getInstance()), \"internal error: \" + e.toString());\n    }\n  }","commit_id":"8dcbdca11b9df8000e8bee684a1971bb2f91ecb7","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Summarize fields which are specific to hex.gbm.GBM.GBMModel.\n   */\n  private static void summarizeGBMModel(ModelSummary summary, hex.gbm.GBM.GBMModel model) {\n    // add generic fields such as column names\n    summarizeModelCommonFields(summary, model);\n\n    summary.model_algorithm = \"GBM\";\n\n    JsonObject all_params = ((GBM)model.get_params()).toJSON();\n    summary.critical_parameters = whitelistJsonObject(all_params, GBM_critical_params);\n    summary.secondary_parameters = whitelistJsonObject(all_params, GBM_secondary_params);\n    summary.expert_parameters = whitelistJsonObject(all_params, GBM_expert_params);\n  }","id":26711,"modified_method":"/**\n   * Summarize fields which are specific to hex.gbm.GBM.GBMModel.\n   */\n  private static void summarizeGBMModel(ModelSummary summary, hex.gbm.GBM.GBMModel model) {\n    // add generic fields such as column names\n    summarizeModelCommonFields(summary, model);\n\n    summary.model_algorithm = \"GBM\";\n\n    JsonObject all_params = (model.get_params()).toJSON();\n    summary.critical_parameters = whitelistJsonObject(all_params, GBM_critical_params);\n    summary.secondary_parameters = whitelistJsonObject(all_params, GBM_secondary_params);\n    summary.expert_parameters = whitelistJsonObject(all_params, GBM_expert_params);\n  }","commit_id":"cbf7307fecb9cf84b82b60673c904938eb332f80","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Summarize subclasses of water.Model.\n   */\n  protected static void summarizeAndEnhanceModel(ModelSummary summary, Model model, boolean find_compatible_frames, Map<String, Frame> all_frames, Map<String, Set<String>> all_frames_cols) {\n    if (model instanceof GLMModel) {\n      summarizeGLMModel(summary, (GLMModel) model);\n    } else if (model instanceof DRF.DRFModel) {\n      summarizeDRFModel(summary, (DRF.DRFModel) model);\n    } else if (model instanceof hex.deeplearning.DeepLearningModel) {\n      summarizeDeepLearningModel(summary, (hex.deeplearning.DeepLearningModel) model);\n    } else if (model instanceof hex.gbm.GBM.GBMModel) {\n      summarizeGBMModel(summary, (hex.gbm.GBM.GBMModel) model);\n    } else {\n      // catch-all\n      summarizeModelCommonFields(summary, (Model) model);\n    }\n\n    if (find_compatible_frames) {\n      Map<String, Frame> compatible_frames = findCompatibleFrames(model, all_frames, all_frames_cols);\n      summary.compatible_frames = compatible_frames.keySet();\n    }\n  }","id":26712,"modified_method":"/**\n   * Summarize subclasses of water.Model.\n   */\n  protected static void summarizeAndEnhanceModel(ModelSummary summary, Model model, boolean find_compatible_frames, Map<String, Frame> all_frames, Map<String, Set<String>> all_frames_cols) {\n    if (model instanceof GLMModel) {\n      summarizeGLMModel(summary, (GLMModel) model);\n    } else if (model instanceof DRF.DRFModel) {\n      summarizeDRFModel(summary, (DRF.DRFModel) model);\n    } else if (model instanceof hex.deeplearning.DeepLearningModel) {\n      summarizeDeepLearningModel(summary, (hex.deeplearning.DeepLearningModel) model);\n    } else if (model instanceof hex.gbm.GBM.GBMModel) {\n      summarizeGBMModel(summary, (hex.gbm.GBM.GBMModel) model);\n    } else {\n      // catch-all\n      summarizeModelCommonFields(summary, model);\n    }\n\n    if (find_compatible_frames) {\n      Map<String, Frame> compatible_frames = findCompatibleFrames(model, all_frames, all_frames_cols);\n      summary.compatible_frames = compatible_frames.keySet();\n    }\n  }","commit_id":"cbf7307fecb9cf84b82b60673c904938eb332f80","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Summarize fields which are specific to hex.drf.DRF.DRFModel.\n   */\n  private static void summarizeDRFModel(ModelSummary summary, hex.drf.DRF.DRFModel model) {\n    // add generic fields such as column names\n    summarizeModelCommonFields(summary, model);\n\n    summary.model_algorithm = \"DRF\";\n\n    JsonObject all_params = ((DRF)model.get_params()).toJSON();\n    summary.critical_parameters = whitelistJsonObject(all_params, DRF_critical_params);\n    summary.secondary_parameters = whitelistJsonObject(all_params, DRF_secondary_params);\n    summary.expert_parameters = whitelistJsonObject(all_params, DRF_expert_params);\n  }","id":26713,"modified_method":"/**\n   * Summarize fields which are specific to hex.drf.DRF.DRFModel.\n   */\n  private static void summarizeDRFModel(ModelSummary summary, hex.drf.DRF.DRFModel model) {\n    // add generic fields such as column names\n    summarizeModelCommonFields(summary, model);\n\n    summary.model_algorithm = \"DRF\";\n\n    JsonObject all_params = (model.get_params()).toJSON();\n    summary.critical_parameters = whitelistJsonObject(all_params, DRF_critical_params);\n    summary.secondary_parameters = whitelistJsonObject(all_params, DRF_secondary_params);\n    summary.expert_parameters = whitelistJsonObject(all_params, DRF_expert_params);\n  }","commit_id":"cbf7307fecb9cf84b82b60673c904938eb332f80","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Summarize fields which are specific to hex.deeplearning.DeepLearningModel.\n   */\n  private static void summarizeDeepLearningModel(ModelSummary summary, hex.deeplearning.DeepLearningModel model) {\n    // add generic fields such as column names\n    summarizeModelCommonFields(summary, model);\n\n    summary.model_algorithm = \"DeepLearning\";\n\n    JsonObject all_params = ((DeepLearning)model.get_params()).toJSON();\n    summary.critical_parameters = whitelistJsonObject(all_params, DL_critical_params);\n    summary.secondary_parameters = whitelistJsonObject(all_params, DL_secondary_params);\n    summary.expert_parameters = whitelistJsonObject(all_params, DL_expert_params);\n  }","id":26714,"modified_method":"/**\n   * Summarize fields which are specific to hex.deeplearning.DeepLearningModel.\n   */\n  private static void summarizeDeepLearningModel(ModelSummary summary, hex.deeplearning.DeepLearningModel model) {\n    // add generic fields such as column names\n    summarizeModelCommonFields(summary, model);\n\n    summary.model_algorithm = \"DeepLearning\";\n\n    JsonObject all_params = (model.get_params()).toJSON();\n    summary.critical_parameters = whitelistJsonObject(all_params, DL_critical_params);\n    summary.secondary_parameters = whitelistJsonObject(all_params, DL_secondary_params);\n    summary.expert_parameters = whitelistJsonObject(all_params, DL_expert_params);\n  }","commit_id":"cbf7307fecb9cf84b82b60673c904938eb332f80","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Summarize fields which are specific to hex.glm.GLMModel.\n   */\n  private static void summarizeGLMModel(ModelSummary summary, hex.glm.GLMModel model) {\n    // add generic fields such as column names\n    summarizeModelCommonFields(summary, model);\n\n    summary.model_algorithm = \"GLM\";\n\n    JsonObject all_params = ((GLM2)model.get_params()).toJSON();\n    summary.critical_parameters = whitelistJsonObject(all_params, GLM_critical_params);\n    summary.secondary_parameters = whitelistJsonObject(all_params, GLM_secondary_params);\n    summary.expert_parameters = whitelistJsonObject(all_params, GLM_expert_params);\n  }","id":26715,"modified_method":"/**\n   * Summarize fields which are specific to hex.glm.GLMModel.\n   */\n  private static void summarizeGLMModel(ModelSummary summary, hex.glm.GLMModel model) {\n    // add generic fields such as column names\n    summarizeModelCommonFields(summary, model);\n\n    summary.model_algorithm = \"GLM\";\n\n    JsonObject all_params = (model.get_params()).toJSON();\n    summary.critical_parameters = whitelistJsonObject(all_params, GLM_critical_params);\n    summary.secondary_parameters = whitelistJsonObject(all_params, GLM_secondary_params);\n    summary.expert_parameters = whitelistJsonObject(all_params, GLM_expert_params);\n  }","commit_id":"cbf7307fecb9cf84b82b60673c904938eb332f80","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Test getting a long lasting Access Token.\n   * @throws Exception\n   */\n  @Test\n  public void testExtendedToken() throws Exception {\n    HttpClient client = getHTTPClient();\n    String uri = String.format(\"%s://%s:%d/%s\", getProtocol(), server.getSocketAddress().getHostString(),\n                               server.getSocketAddress().getPort(), GrantAccessToken.Paths.GET_EXTENDED_TOKEN);\n    HttpGet request = new HttpGet(uri);\n    request.addHeader(\"Authorization\", \"Basic YWRtaW46cmVhbHRpbWU=\");\n    HttpResponse response = client.execute(request);\n\n    assertEquals(200, response.getStatusLine().getStatusCode());\n\n    // Test correct response body\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    ByteStreams.copy(response.getEntity().getContent(), bos);\n    String responseBody = bos.toString(\"UTF-8\");\n    bos.close();\n\n    JsonParser parser = new JsonParser();\n    JsonObject responseJson = (JsonObject) parser.parse(responseBody);\n    long expiration = responseJson.get(ExternalAuthenticationServer.ResponseFields.EXPIRES_IN).getAsLong();\n\n    long expectedExpiration =  configuration.getInt(Constants.Security.EXTENDED_TOKEN_EXPIRATION);\n    // Test expiration time in seconds\n    assertEquals(expectedExpiration / 1000, expiration);\n\n    // Test that the server passes back an AccessToken object which can be decoded correctly.\n    String encodedToken = responseJson.get(ExternalAuthenticationServer.ResponseFields.ACCESS_TOKEN).getAsString();\n    AccessToken token = tokenCodec.decode(Base64.decodeBase64(encodedToken));\n    assertEquals(\"admin\", token.getIdentifier().getUsername());\n    LOG.info(\"AccessToken got from ExternalAuthenticationServer is: \" + encodedToken);\n  }","id":26716,"modified_method":"/**\n   * Test getting a long lasting Access Token.\n   * @throws Exception\n   */\n  @Test\n  public void testExtendedToken() throws Exception {\n    HttpClient client = getHTTPClient();\n    String uri = String.format(\"%s://%s:%d/%s\", getProtocol(), server.getSocketAddress().getAddress().getHostAddress(),\n                               server.getSocketAddress().getPort(), GrantAccessToken.Paths.GET_EXTENDED_TOKEN);\n    HttpGet request = new HttpGet(uri);\n    request.addHeader(\"Authorization\", \"Basic YWRtaW46cmVhbHRpbWU=\");\n    HttpResponse response = client.execute(request);\n\n    assertEquals(200, response.getStatusLine().getStatusCode());\n\n    // Test correct response body\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    ByteStreams.copy(response.getEntity().getContent(), bos);\n    String responseBody = bos.toString(\"UTF-8\");\n    bos.close();\n\n    JsonParser parser = new JsonParser();\n    JsonObject responseJson = (JsonObject) parser.parse(responseBody);\n    long expiration = responseJson.get(ExternalAuthenticationServer.ResponseFields.EXPIRES_IN).getAsLong();\n\n    long expectedExpiration =  configuration.getInt(Constants.Security.EXTENDED_TOKEN_EXPIRATION);\n    // Test expiration time in seconds\n    assertEquals(expectedExpiration / 1000, expiration);\n\n    // Test that the server passes back an AccessToken object which can be decoded correctly.\n    String encodedToken = responseJson.get(ExternalAuthenticationServer.ResponseFields.ACCESS_TOKEN).getAsString();\n    AccessToken token = tokenCodec.decode(Base64.decodeBase64(encodedToken));\n    assertEquals(\"admin\", token.getIdentifier().getUsername());\n    LOG.info(\"AccessToken got from ExternalAuthenticationServer is: \" + encodedToken);\n  }","commit_id":"5e7a9465d3f311b3455f0a724f0d8720faa0371d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Test an unauthorized status request to server.\n   * @throws Exception\n   */\n  @Test\n  public void testStatusResponse() throws Exception {\n    HttpClient client = getHTTPClient();\n    String uri = String.format(\"%s://%s:%d/%s\", getProtocol(), server.getSocketAddress().getHostString(),\n                               server.getSocketAddress().getPort(), Constants.EndPoints.STATUS);\n    HttpGet request = new HttpGet(uri);\n\n    HttpResponse response = client.execute(request);\n\n    // Status request is authorized without any extra headers\n    assertEquals(200, response.getStatusLine().getStatusCode());\n\n  }","id":26717,"modified_method":"/**\n   * Test an unauthorized status request to server.\n   * @throws Exception\n   */\n  @Test\n  public void testStatusResponse() throws Exception {\n    HttpClient client = getHTTPClient();\n    String uri = String.format(\"%s://%s:%d/%s\", getProtocol(), server.getSocketAddress().getAddress().getHostAddress(),\n                               server.getSocketAddress().getPort(), Constants.EndPoints.STATUS);\n    HttpGet request = new HttpGet(uri);\n\n    HttpResponse response = client.execute(request);\n\n    // Status request is authorized without any extra headers\n    assertEquals(200, response.getStatusLine().getStatusCode());\n\n  }","commit_id":"5e7a9465d3f311b3455f0a724f0d8720faa0371d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Test that invalid paths return a 404 Not Found.\n   * @throws Exception\n   */\n  @Test\n  public void testInvalidPath() throws Exception {\n    HttpClient client = getHTTPClient();\n    String uri = String.format(\"%s://%s:%d/%s\", getProtocol(), server.getSocketAddress().getHostString(),\n                               server.getSocketAddress().getPort(), \"invalid\");\n    HttpGet request = new HttpGet(uri);\n    request.addHeader(\"Authorization\", \"Basic YWRtaW46cmVhbHRpbWU=\");\n    HttpResponse response = client.execute(request);\n\n    assertEquals(404, response.getStatusLine().getStatusCode());\n\n  }","id":26718,"modified_method":"/**\n   * Test that invalid paths return a 404 Not Found.\n   * @throws Exception\n   */\n  @Test\n  public void testInvalidPath() throws Exception {\n    HttpClient client = getHTTPClient();\n    String uri = String.format(\"%s://%s:%d/%s\", getProtocol(), server.getSocketAddress().getAddress().getHostAddress(),\n                               server.getSocketAddress().getPort(), \"invalid\");\n    HttpGet request = new HttpGet(uri);\n    request.addHeader(\"Authorization\", \"Basic YWRtaW46cmVhbHRpbWU=\");\n    HttpResponse response = client.execute(request);\n\n    assertEquals(404, response.getStatusLine().getStatusCode());\n\n  }","commit_id":"5e7a9465d3f311b3455f0a724f0d8720faa0371d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Test an unauthorized request to server.\n   * @throws Exception\n   */\n  @Test\n  public void testInvalidAuthentication() throws Exception {\n    HttpClient client = getHTTPClient();\n    String uri = String.format(\"%s://%s:%d/%s\", getProtocol(), server.getSocketAddress().getHostString(),\n                               server.getSocketAddress().getPort(), GrantAccessToken.Paths.GET_TOKEN);\n    HttpGet request = new HttpGet(uri);\n    request.addHeader(\"Authorization\", \"xxxxx\");\n\n    HttpResponse response = client.execute(request);\n\n    // Request is Unauthorized\n    assertEquals(401, response.getStatusLine().getStatusCode());\n    verify(TEST_AUDIT_LOGGER, timeout(10000).atLeastOnce()).trace(contains(\"401\"));\n  }","id":26719,"modified_method":"/**\n   * Test an unauthorized request to server.\n   * @throws Exception\n   */\n  @Test\n  public void testInvalidAuthentication() throws Exception {\n    HttpClient client = getHTTPClient();\n    String uri = String.format(\"%s://%s:%d/%s\", getProtocol(), server.getSocketAddress().getAddress().getHostAddress(),\n                               server.getSocketAddress().getPort(), GrantAccessToken.Paths.GET_TOKEN);\n    HttpGet request = new HttpGet(uri);\n    request.addHeader(\"Authorization\", \"xxxxx\");\n\n    HttpResponse response = client.execute(request);\n\n    // Request is Unauthorized\n    assertEquals(401, response.getStatusLine().getStatusCode());\n    verify(TEST_AUDIT_LOGGER, timeout(10000).atLeastOnce()).trace(contains(\"401\"));\n  }","commit_id":"5e7a9465d3f311b3455f0a724f0d8720faa0371d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Test an authorized request to server.\n   * @throws Exception\n   */\n  @Test\n  public void testValidAuthentication() throws Exception {\n    HttpClient client = getHTTPClient();\n    String uri = String.format(\"%s://%s:%d/%s\", getProtocol(), server.getSocketAddress().getHostString(),\n                               server.getSocketAddress().getPort(), GrantAccessToken.Paths.GET_TOKEN);\n\n    HttpGet request = new HttpGet(uri);\n    request.addHeader(\"Authorization\", \"Basic YWRtaW46cmVhbHRpbWU=\");\n    HttpResponse response = client.execute(request);\n\n    assertEquals(response.getStatusLine().getStatusCode(), 200);\n    verify(TEST_AUDIT_LOGGER, timeout(10000).atLeastOnce()).trace(contains(\"admin\"));\n\n    // Test correct headers being returned\n    String cacheControlHeader = response.getFirstHeader(\"Cache-Control\").getValue();\n    String pragmaHeader = response.getFirstHeader(\"Pragma\").getValue();\n    String contentType = response.getFirstHeader(\"Content-Type\").getValue();\n\n    assertEquals(\"no-store\", cacheControlHeader);\n    assertEquals(\"no-cache\", pragmaHeader);\n    assertEquals(\"application/json;charset=UTF-8\", contentType);\n\n    // Test correct response body\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    ByteStreams.copy(response.getEntity().getContent(), bos);\n    String responseBody = bos.toString(\"UTF-8\");\n    bos.close();\n\n    JsonParser parser = new JsonParser();\n    JsonObject responseJson = (JsonObject) parser.parse(responseBody);\n    String tokenType = responseJson.get(ExternalAuthenticationServer.ResponseFields.TOKEN_TYPE).toString();\n    long expiration = responseJson.get(ExternalAuthenticationServer.ResponseFields.EXPIRES_IN).getAsLong();\n\n    assertEquals(String.format(\"\\\"%s\\\"\", ExternalAuthenticationServer.ResponseFields.TOKEN_TYPE_BODY), tokenType);\n\n    long expectedExpiration =  configuration.getInt(Constants.Security.TOKEN_EXPIRATION);\n    // Test expiration time in seconds\n    assertEquals(expectedExpiration / 1000, expiration);\n\n    // Test that the server passes back an AccessToken object which can be decoded correctly.\n    String encodedToken = responseJson.get(ExternalAuthenticationServer.ResponseFields.ACCESS_TOKEN).getAsString();\n    AccessToken token = tokenCodec.decode(Base64.decodeBase64(encodedToken));\n    assertEquals(\"admin\", token.getIdentifier().getUsername());\n    LOG.info(\"AccessToken got from ExternalAuthenticationServer is: \" + encodedToken);\n  }","id":26720,"modified_method":"/**\n   * Test an authorized request to server.\n   * @throws Exception\n   */\n  @Test\n  public void testValidAuthentication() throws Exception {\n    HttpClient client = getHTTPClient();\n    String uri = String.format(\"%s://%s:%d/%s\", getProtocol(), server.getSocketAddress().getAddress().getHostAddress(),\n                               server.getSocketAddress().getPort(), GrantAccessToken.Paths.GET_TOKEN);\n\n    HttpGet request = new HttpGet(uri);\n    request.addHeader(\"Authorization\", \"Basic YWRtaW46cmVhbHRpbWU=\");\n    HttpResponse response = client.execute(request);\n\n    assertEquals(response.getStatusLine().getStatusCode(), 200);\n    verify(TEST_AUDIT_LOGGER, timeout(10000).atLeastOnce()).trace(contains(\"admin\"));\n\n    // Test correct headers being returned\n    String cacheControlHeader = response.getFirstHeader(\"Cache-Control\").getValue();\n    String pragmaHeader = response.getFirstHeader(\"Pragma\").getValue();\n    String contentType = response.getFirstHeader(\"Content-Type\").getValue();\n\n    assertEquals(\"no-store\", cacheControlHeader);\n    assertEquals(\"no-cache\", pragmaHeader);\n    assertEquals(\"application/json;charset=UTF-8\", contentType);\n\n    // Test correct response body\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    ByteStreams.copy(response.getEntity().getContent(), bos);\n    String responseBody = bos.toString(\"UTF-8\");\n    bos.close();\n\n    JsonParser parser = new JsonParser();\n    JsonObject responseJson = (JsonObject) parser.parse(responseBody);\n    String tokenType = responseJson.get(ExternalAuthenticationServer.ResponseFields.TOKEN_TYPE).toString();\n    long expiration = responseJson.get(ExternalAuthenticationServer.ResponseFields.EXPIRES_IN).getAsLong();\n\n    assertEquals(String.format(\"\\\"%s\\\"\", ExternalAuthenticationServer.ResponseFields.TOKEN_TYPE_BODY), tokenType);\n\n    long expectedExpiration =  configuration.getInt(Constants.Security.TOKEN_EXPIRATION);\n    // Test expiration time in seconds\n    assertEquals(expectedExpiration / 1000, expiration);\n\n    // Test that the server passes back an AccessToken object which can be decoded correctly.\n    String encodedToken = responseJson.get(ExternalAuthenticationServer.ResponseFields.ACCESS_TOKEN).getAsString();\n    AccessToken token = tokenCodec.decode(Base64.decodeBase64(encodedToken));\n    assertEquals(\"admin\", token.getIdentifier().getUsername());\n    LOG.info(\"AccessToken got from ExternalAuthenticationServer is: \" + encodedToken);\n  }","commit_id":"5e7a9465d3f311b3455f0a724f0d8720faa0371d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        final boolean verbose = request.paramAsBoolean(\"verbose\", false);\n        final StringBuilder out = new StringBuilder();\n\n        final ClusterStateRequest clusterStateRequest = new ClusterStateRequest();                                                                                                     clusterStateRequest.listenerThreaded(false);\n        clusterStateRequest.filterMetaData(true);\n        clusterStateRequest.local(false);\n\n        client.admin().cluster().state(clusterStateRequest, new ActionListener<ClusterStateResponse>() {\n            @Override\n            public void onResponse(final ClusterStateResponse clusterStateResponse) {\n                try {\n                    RestStatus status = RestStatus.OK;\n                    Table tab = new Table();\n                    tab.addRow(new Row()\n                            .addCell(\"id\")\n                            .addCell(\"transport addr\")\n                            .addCell(\"name\"), true);\n                    tab.addRow(new Row()\n                            .addCell(clusterStateResponse.getState().nodes().masterNode().id())\n                            .addCell(((InetSocketTransportAddress)clusterStateResponse.getState().nodes()\n                                     .masterNode().address()).address().getHostString())\n                            .addCell(clusterStateResponse.getState().nodes().masterNode().name()));\n\n                    channel.sendResponse(new StringRestResponse(status, tab.render(verbose)));\n                } catch (Throwable e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":26721,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        final boolean verbose = request.paramAsBoolean(\"verbose\", false);\n        final StringBuilder out = new StringBuilder();\n\n        final ClusterStateRequest clusterStateRequest = new ClusterStateRequest();                                                                                                     clusterStateRequest.listenerThreaded(false);\n        clusterStateRequest.filterMetaData(true);\n        clusterStateRequest.local(false);\n\n        client.admin().cluster().state(clusterStateRequest, new ActionListener<ClusterStateResponse>() {\n            @Override\n            public void onResponse(final ClusterStateResponse clusterStateResponse) {\n                try {\n                    RestStatus status = RestStatus.OK;\n                    Table tab = new Table();\n                    tab.addRow(new Row()\n                            .addCell(\"id\")\n                            .addCell(\"transport addr\")\n                            .addCell(\"name\"), true);\n                    tab.addRow(new Row()\n                            .addCell(clusterStateResponse.getState().nodes().masterNode().id())\n                            .addCell(((InetSocketTransportAddress)clusterStateResponse.getState().nodes()\n                                     .masterNode().address()).address().getAddress().getHostAddress())\n                            .addCell(clusterStateResponse.getState().nodes().masterNode().name()));\n\n                    channel.sendResponse(new StringRestResponse(status, tab.render(verbose)));\n                } catch (Throwable e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"0d57c4eafd56ae0c733bc30c5f81adb36496fe5b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private String process(ClusterStateResponse state, IndicesStatsResponse stats, boolean headers) {\n        Table tab = new Table();\n        if (headers) {\n            tab.addRow(new Row()\n                    .addCell(\"index\")\n                    .addCell(\"shard\")\n                    .addCell(\"replica\")\n                    .addCell(\"state\")\n                    .addCell(\"docs\")\n                    .addCell(\"size\")\n                    .addCell(\"bytes\")\n                    .addCell(\"host\")\n                    .addCell(\"node\"), true);\n        }\n\n        for (ShardRouting shard : state.getState().routingTable().allShards()) {\n            Row row = new Row();\n            String pri = \"r\";\n            StringBuilder host = new StringBuilder();\n            String docs = \"\";\n            String size = \"\";\n            String bytes = \"\";\n            String nodeName = \"\";\n\n            if (shard.assignedToNode()) {\n                host.append(((InetSocketTransportAddress) state.getState().nodes().get(shard.currentNodeId()).address()).address().getHostString());\n                nodeName = state.getState().nodes().get(shard.currentNodeId()).name();\n            }\n\n            if (shard.relocating()) {\n                host.append(\" -> \");\n                host.append(((InetSocketTransportAddress) state.getState().nodes().get(shard.relocatingNodeId()).address()).address().getHostString());\n                host.append(state.getState().nodes().get(shard.relocatingNodeId()).name());\n            }\n\n            if (null != stats.asMap().get(shard.globalId())) {\n                size = stats.asMap().get(shard.globalId()).getStore().size().toString();\n                bytes = new Long(stats.asMap().get(shard.globalId()).getStore().getSizeInBytes()).toString();\n                docs = new Long(stats.asMap().get(shard.globalId()).getDocs().getCount()).toString();\n            }\n\n            if (shard.primary()) {\n                pri = \"p\";\n            }\n\n            row.addCell(shard.index())\n                    .addCell(new Integer(shard.shardId().id()).toString())\n                    .addCell(pri)\n                    .addCell(shard.state().toString())\n                    .addCell(docs)\n                    .addCell(size)\n                    .addCell(bytes)\n                    .addCell(host.toString())\n                    .addCell(nodeName);\n            tab.addRow(row);\n        }\n\n        return tab.render(headers);\n    }","id":26722,"modified_method":"private String process(ClusterStateResponse state, IndicesStatsResponse stats, boolean headers) {\n        Table tab = new Table();\n        if (headers) {\n            tab.addRow(new Row()\n                    .addCell(\"index\")\n                    .addCell(\"shard\")\n                    .addCell(\"replica\")\n                    .addCell(\"state\")\n                    .addCell(\"docs\")\n                    .addCell(\"size\")\n                    .addCell(\"bytes\")\n                    .addCell(\"host\")\n                    .addCell(\"node\"), true);\n        }\n\n        for (ShardRouting shard : state.getState().routingTable().allShards()) {\n            Row row = new Row();\n            String pri = \"r\";\n            StringBuilder host = new StringBuilder();\n            String docs = \"\";\n            String size = \"\";\n            String bytes = \"\";\n            String nodeName = \"\";\n\n            if (shard.assignedToNode()) {\n                host.append(((InetSocketTransportAddress) state.getState().nodes().get(shard.currentNodeId()).address()).address().getAddress().getHostAddress());\n                nodeName = state.getState().nodes().get(shard.currentNodeId()).name();\n            }\n\n            if (shard.relocating()) {\n                host.append(\" -> \");\n                host.append(((InetSocketTransportAddress) state.getState().nodes().get(shard.relocatingNodeId()).address()).address().getAddress().getHostAddress());\n                host.append(state.getState().nodes().get(shard.relocatingNodeId()).name());\n            }\n\n            if (null != stats.asMap().get(shard.globalId())) {\n                size = stats.asMap().get(shard.globalId()).getStore().size().toString();\n                bytes = new Long(stats.asMap().get(shard.globalId()).getStore().getSizeInBytes()).toString();\n                docs = new Long(stats.asMap().get(shard.globalId()).getDocs().getCount()).toString();\n            }\n\n            if (shard.primary()) {\n                pri = \"p\";\n            }\n\n            row.addCell(shard.index())\n                    .addCell(new Integer(shard.shardId().id()).toString())\n                    .addCell(pri)\n                    .addCell(shard.state().toString())\n                    .addCell(docs)\n                    .addCell(size)\n                    .addCell(bytes)\n                    .addCell(host.toString())\n                    .addCell(nodeName);\n            tab.addRow(row);\n        }\n\n        return tab.render(headers);\n    }","commit_id":"0d57c4eafd56ae0c733bc30c5f81adb36496fe5b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n  public Expr inline(final QueryContext ctx, final VarScope scp, final Var v, final Expr e)\n      throws QueryException {\n\n    boolean change = false;\n    try {\n      final Expr sub = expr.inline(ctx, scp, v, e);\n      if(sub != null) {\n        if(sub.isValue()) return optPre(sub, ctx);\n        expr = sub;\n        change = true;\n      }\n    } catch(final QueryException qe) {\n      if(!qe.isCatchable()) throw qe;\n      for(final Catch c : ctch) {\n        if(c.matches(qe)) {\n          // found a matching clause, inline variable and error message\n          return optPre(c.inline(ctx, scp, v, e).asExpr(qe, ctx, scp), ctx);\n        }\n      }\n      throw qe;\n    }\n\n    for(final Catch c : ctch) change |= c.inline(ctx, scp, v, e) != null;\n    return change ? this : null;\n  }","id":26723,"modified_method":"@Override\n  public Expr inline(final QueryContext ctx, final VarScope scp, final Var v, final Expr e)\n      throws QueryException {\n\n    boolean change = false;\n    try {\n      final Expr sub = expr.inline(ctx, scp, v, e);\n      if(sub != null) {\n        if(sub.isValue()) return optPre(sub, ctx);\n        expr = sub;\n        change = true;\n      }\n    } catch(final QueryException qe) {\n      if(!qe.isCatchable()) throw qe;\n      for(final Catch c : ctch) {\n        if(c.matches(qe)) {\n          // found a matching clause, inline variable and error message\n          final Catch ca = c.inline(ctx, scp, v, e);\n          if(ca != null) return optPre(ca.asExpr(qe, ctx, scp), ctx);\n        }\n      }\n      throw qe;\n    }\n\n    for(final Catch c : ctch) change |= c.inline(ctx, scp, v, e) != null;\n    return change ? this : null;\n  }","commit_id":"3914b6978c0310a14eaa4263c1edda9a1605e7fc","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Expr inline(final QueryContext ctx, final VarScope scp, final Var v, final Expr e)\n      throws QueryException {\n\n    boolean change = false;\n    try {\n      final Expr sub = expr.inline(ctx, scp, v, e);\n      if(sub != null) {\n        if(sub.isValue()) return optPre(sub, ctx);\n        expr = sub;\n        change = true;\n      }\n    } catch(final QueryException qe) {\n      if(!qe.isCatchable()) throw qe;\n      for(final Catch c : ctch) {\n        if(c.matches(qe)) {\n          // found a matching clause, inline variable and error message\n          return optPre(c.inline(ctx, scp, v, e).asExpr(qe, ctx, scp), ctx);\n        }\n      }\n      throw qe;\n    }\n\n    for(final Catch c : ctch) change |= c.inline(ctx, scp, v, e) != null;\n    return change ? this : null;\n  }","id":26724,"modified_method":"@Override\n  public Expr inline(final QueryContext ctx, final VarScope scp, final Var v, final Expr e)\n      throws QueryException {\n\n    boolean change = false;\n    try {\n      final Expr sub = expr.inline(ctx, scp, v, e);\n      if(sub != null) {\n        if(sub.isValue()) return optPre(sub, ctx);\n        expr = sub;\n        change = true;\n      }\n    } catch(final QueryException qe) {\n      if(!qe.isCatchable()) throw qe;\n      for(final Catch c : ctch) {\n        if(c.matches(qe)) {\n          // found a matching clause, inline variable and error message\n          final Catch ca = c.inline(ctx, scp, v, e);\n          if(ca != null) return optPre(ca.asExpr(qe, ctx, scp), ctx);\n        }\n      }\n      throw qe;\n    }\n\n    for(final Catch c : ctch) change |= c.inline(ctx, scp, v, e) != null;\n    return change ? this : null;\n  }","commit_id":"988be2f617ea68e289440dbc9fcd07ef354af231","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n    public void endVisit(JsFunction function, JsContext context) {\n        super.endVisit(function, context);\n        removeUnusedLocalFunctionInstances(function);\n        inliningContexts.pop();\n    }","id":26725,"modified_method":"@Override\n    public void endVisit(JsFunction function, JsContext context) {\n        super.endVisit(function, context);\n        removeUnusedLocalFunctionInstances(function);\n        processedFunctions.add(function);\n\n        assert inProcessFunctions.contains(function);\n        inProcessFunctions.remove(function);\n\n        inliningContexts.pop();\n    }","commit_id":"da817e7ed2f40a6eacde2bfafd2d57abff3eaf2e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public boolean visit(JsInvocation call, JsContext context) {\n        if (call == null) {\n            return false;\n        }\n\n        if (shouldInline(call) && canInline(call)) {\n            inline(call, context);\n        }\n\n        return !lastStatementWasShifted;\n    }","id":26726,"modified_method":"@Override\n    public boolean visit(JsInvocation call, JsContext context) {\n        if (call == null) {\n            return false;\n        }\n\n        if (shouldInline(call) && canInline(call)) {\n            JsFunction definition = getFunctionContext().getFunctionDefinition(call);\n            if (!processedFunctions.contains(definition)) {\n                accept(definition);\n            }\n\n            inline(call, context);\n        }\n\n        return !lastStatementWasShifted;\n    }","commit_id":"da817e7ed2f40a6eacde2bfafd2d57abff3eaf2e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public boolean visit(JsFunction function, JsContext context) {\n        inliningContexts.push(new JsInliningContext(function));\n        return super.visit(function, context);\n    }","id":26727,"modified_method":"@Override\n    public boolean visit(JsFunction function, JsContext context) {\n        inliningContexts.push(new JsInliningContext(function));\n\n        if (inProcessFunctions.contains(function)) throw new InlineRecursionException();\n        inProcessFunctions.add(function);\n\n        return super.visit(function, context);\n    }","commit_id":"da817e7ed2f40a6eacde2bfafd2d57abff3eaf2e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void dump(Object object) throws Exception {\n        JAXBContext jaxbContext = XmlTestSupport.createJaxbContext();\n        Marshaller marshaller = jaxbContext.createMarshaller();\n        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n        StringWriter buffer = new StringWriter();\n        marshaller.marshal(object, buffer);\n        log.info(\"Created: \" + buffer);\n        assertNotNull(buffer);\n        String out = buffer.toString();\n        assertTrue(\"Should contain the description\", out.indexOf(\"This is a description of the route\") > 0);\n    }","id":26728,"modified_method":"protected void dump(Object object) throws Exception {\n        JAXBContext jaxbContext = XmlTestSupport.createJaxbContext();\n        Marshaller marshaller = jaxbContext.createMarshaller();\n        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n        StringWriter buffer = new StringWriter();\n        marshaller.marshal(object, buffer);\n        log.info(\"Created: \" + buffer);\n        assertNotNull(buffer);\n        String out = buffer.toString();\n        assertTrue(\"Should contain the description\", out.indexOf(\"<from uri=\\\"direct:start\\\"/>\") > 0);\n    }","commit_id":"2e468dcea2c451c07e2b37e12bccf42be23abffe","url":"https://github.com/apache/camel"},{"original_method":"public InterceptType createProxy() {\n        InterceptType answer = new InterceptType();\n        answer.getOutputs().addAll(this.getOutputs());\n        \n        answer.setStopIntercept(getStopIntercept());\n\n        // hack: now we need to replace the proceed of the proxy with its own\n        // a bit ugly, operating based on the assumption that the proceed is\n        // in its outputs (if proceed() was called) and/or in the\n        // outputs of the otherwise or last when clause for the predicated version.\n        if (answer.getOutputs().size() > 0) {\n            // this is for the predicate version or if a choice() is present\n            ChoiceType choice = null;\n            for (ProcessorType processor : answer.getOutputs()) {\n                if (processor instanceof ChoiceType) {\n                    // special cases for predicates (choices)\n                    choice = (ChoiceType) processor;\n\n                    // for the predicated version we add the proceed() to otherwise()\n                    // before knowing if stop() will follow, so let's make a small adjustment\n                    if (usePredicate.booleanValue() && getStopIntercept().booleanValue()) {\n                        WhenType when = choice.getWhenClauses().get(0);\n                        when.getOutputs().remove(this.getProceed());\n                    }\n\n                    // add proceed to the when clause\n                    addProceedProxy(this.getProceed(), answer.getProceed(),\n                        choice.getWhenClauses().get(choice.getWhenClauses().size() - 1), usePredicate.booleanValue() && !getStopIntercept().booleanValue());\n\n                    // force adding a proceed at the end (otherwise) if its not a stop type\n                    addProceedProxy(this.getProceed(), answer.getProceed(), choice.getOtherwise(), !getStopIntercept().booleanValue());\n\n                    if (getStopIntercept().booleanValue()) {\n                        // must add proceed to when clause if stop is explictiy declared, otherwise when the\n                        // predicate test fails then there is no proceed\n                        // See example: InterceptorSimpleRouteTest (City Paris is never proceeded)  \n                        addProceedProxy(this.getProceed(), answer.getProceed(),\n                            choice.getWhenClauses().get(choice.getWhenClauses().size() - 1), usePredicate.booleanValue());\n                    }\n\n                    break;\n                }\n            }\n            if (choice == null) {\n                // force adding a proceed at the end if its not a stop type\n                addProceedProxy(this.getProceed(), answer.getProceed(), answer, !getStopIntercept().booleanValue());\n            }\n        }\n\n        return answer;\n    }","id":26729,"modified_method":"public InterceptType createProxy() {\n        InterceptType answer = new InterceptType();\n        answer.getOutputs().addAll(this.getOutputs());\n        \n        answer.setStopIntercept(getStopIntercept());\n\n        // hack: now we need to replace the proceed of the proxy with its own\n        // a bit ugly, operating based on the assumption that the proceed is\n        // in its outputs (if proceed() was called) and/or in the\n        // outputs of the otherwise or last when clause for the predicated version.\n        if (answer.getOutputs().size() > 0) {\n            // this is for the predicate version or if a choice() is present\n            ChoiceType choice = null;\n            for (ProcessorType processor : answer.getOutputs()) {\n                if (processor instanceof ChoiceType) {\n                    // special cases for predicates (choices)\n                    choice = (ChoiceType) processor;\n\n                    // for the predicated version we add the proceed() to otherwise()\n                    // before knowing if stop() will follow, so let's make a small adjustment\n                    if (usePredicate && getStopIntercept()) {\n                        WhenType when = choice.getWhenClauses().get(0);\n                        when.getOutputs().remove(this.getProceed());\n                    }\n\n                    // add proceed to the when clause\n                    addProceedProxy(this.getProceed(), answer.getProceed(),\n                        choice.getWhenClauses().get(choice.getWhenClauses().size() - 1), usePredicate && !getStopIntercept());\n\n                    // force adding a proceed at the end (otherwise) if its not a stop type\n                    addProceedProxy(this.getProceed(), answer.getProceed(), choice.getOtherwise(), !getStopIntercept());\n\n                    if (getStopIntercept()) {\n                        // must add proceed to when clause if stop is explictiy declared, otherwise when the\n                        // predicate test fails then there is no proceed\n                        // See example: InterceptorSimpleRouteTest (City Paris is never proceeded)  \n                        addProceedProxy(this.getProceed(), answer.getProceed(),\n                            choice.getWhenClauses().get(choice.getWhenClauses().size() - 1), usePredicate);\n                    }\n\n                    break;\n                }\n            }\n            if (choice == null) {\n                // force adding a proceed at the end if its not a stop type\n                addProceedProxy(this.getProceed(), answer.getProceed(), answer, !getStopIntercept());\n            }\n        }\n\n        return answer;\n    }","commit_id":"2e468dcea2c451c07e2b37e12bccf42be23abffe","url":"https://github.com/apache/camel"},{"original_method":"private long calcDataOffset() {\n    try {\n      long offset = getHeaderOffset();\n      myFile.archive.seek(offset + JBZipFile.LFH_OFFSET_FOR_FILENAME_LENGTH);\n      byte[] b = new byte[JBZipFile.WORD];\n      myFile.archive.readFully(b);\n      int fileNameLen = ZipShort.getValue(b, 0);\n      int extraFieldLen = ZipShort.getValue(b, JBZipFile.SHORT);\n      return offset + JBZipFile.LFH_OFFSET_FOR_FILENAME_LENGTH + JBZipFile.WORD + fileNameLen + extraFieldLen;\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","id":26730,"modified_method":"private long calcDataOffset() throws IOException {\n    long offset = getHeaderOffset();\n    myFile.archive.seek(offset + JBZipFile.LFH_OFFSET_FOR_FILENAME_LENGTH);\n    byte[] b = new byte[JBZipFile.WORD];\n    myFile.archive.readFully(b);\n    int fileNameLen = ZipShort.getValue(b, 0);\n    int extraFieldLen = ZipShort.getValue(b, JBZipFile.SHORT);\n    return offset + JBZipFile.LFH_OFFSET_FOR_FILENAME_LENGTH + JBZipFile.WORD + fileNameLen + extraFieldLen;\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Returns an InputStream for reading the contents of the given entry.\n   *\n   * @return a stream to read the entry from.\n   * @throws java.io.IOException        if unable to create an input stream from the zipenty\n   * @throws java.util.zip.ZipException if the zipentry has an unsupported compression method\n   */\n  public InputStream getInputStream() throws IOException {\n    long start = calcDataOffset();\n\n    BoundedInputStream bis = new BoundedInputStream(start, getCompressedSize());\n    switch (getMethod()) {\n      case STORED:\n        return bis;\n      case DEFLATED:\n        bis.addDummy();\n        return new InflaterInputStream(bis, new Inflater(true));\n      default:\n        throw new ZipException(\"Found unsupported compression method \" + getMethod());\n    }\n  }","id":26731,"modified_method":"private InputStream getInputStream() throws IOException {\n    long start = calcDataOffset();\n\n    BoundedInputStream bis = new BoundedInputStream(start, getCompressedSize());\n    switch (getMethod()) {\n      case STORED:\n        return bis;\n      case DEFLATED:\n        bis.addDummy();\n        return new InflaterInputStream(bis, new Inflater(true));\n      default:\n        throw new ZipException(\"Found unsupported compression method \" + getMethod());\n    }\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setData(byte[] bytes) throws IOException {\n    JBZipOutputStream stream = myFile.getOutputStream();\n    stream.putNextEntry(this);\n    stream.write(bytes);\n    stream.closeEntry();\n  }","id":26732,"modified_method":"public void setData(byte[] bytes) throws IOException {\n    setData(bytes, time);\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Returns the modification time of the entry, or -1 if not specified.\n   *\n   * @return the modification time of the entry, or -1 if not specified\n   * @see #setTime(long)\n   */\n  public long getTime() {\n    return time != -1 ? dosToJavaTime(time) : -1;\n  }","id":26733,"modified_method":"/**\n   * Returns the modification time of the entry, or -1 if not specified.\n   *\n   * @return the modification time of the entry, or -1 if not specified\n   * @see #setTime(long)\n   */\n  public long getTime() {\n    return time;\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Sets the modification time of the entry.\n   *\n   * @param time the entry modification time in number of milliseconds\n   *             since the epoch\n   * @see #getTime()\n   */\n  public void setTime(long time) {\n    this.time = javaToDosTime(time);\n  }","id":26734,"modified_method":"/**\n   * Sets the modification time of the entry.\n   *\n   * @param time the entry modification time in number of milliseconds\n   *             since the epoch\n   * @see #getTime()\n   */\n  public void setTime(long time) {\n    this.time = time;\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Creates a new zip entry with the specified name.\n   *\n   * @param name the name of the entry\n   * @param file\n   * @since 1.1\n   */\n  public JBZipEntry(String name, JBZipFile file) {\n    this.name = name;\n    myFile = file;\n  }","id":26735,"modified_method":"/**\n   * Creates a new zip entry with the specified name.\n   *\n   * @param name the name of the entry\n   * @param file\n   * @since 1.1\n   */\n  protected JBZipEntry(String name, JBZipFile file) {\n    this.name = name;\n    myFile = file;\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void eraseEntry(JBZipEntry entry) {\n    getOutputStream(); // Ensure OutputStream created, so we'll print out central directory at the end;\n    entries.remove(entry);\n    nameMap.remove(entry.getName());\n  }","id":26736,"modified_method":"void eraseEntry(JBZipEntry entry) {\n    getOutputStream(); // Ensure OutputStream created, so we'll print out central directory at the end;\n    entries.remove(entry);\n    nameMap.remove(entry.getName());\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JBZipOutputStream getOutputStream() {\n    if (myOutputStream == null) {\n      myOutputStream = new JBZipOutputStream(this, currentcfdfoffset);\n    }\n    return myOutputStream;\n  }","id":26737,"modified_method":"JBZipOutputStream getOutputStream() {\n    if (myOutputStream == null) {\n      myOutputStream = new JBZipOutputStream(this, currentcfdfoffset);\n    }\n    return myOutputStream;\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Reads the central directory of the given archive and populates\n   * the internal tables with ZipEntry instances.\n   * <p/>\n   * <p>The ZipEntrys will know all data that can be obtained from\n   * the central directory alone, but not the data that requires the\n   * local file header or additional data to be read.<\/p>\n   */\n  private void populateFromCentralDirectory() throws IOException {\n    positionAtCentralDirectory();\n\n    byte[] cfh = new byte[CFH_LEN];\n\n    byte[] signatureBytes = new byte[WORD];\n    archive.readFully(signatureBytes);\n    long sig = ZipLong.getValue(signatureBytes);\n    final long cfhSig = ZipLong.getValue(JBZipOutputStream.CFH_SIG);\n    while (sig == cfhSig) {\n      archive.readFully(cfh);\n      int off = 0;\n      JBZipEntry ze = new JBZipEntry(this);\n\n      int versionMadeBy = ZipShort.getValue(cfh, off);\n      off += SHORT;\n      ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n      off += WORD; // skip version info and general purpose byte\n\n      ze.setMethod(ZipShort.getValue(cfh, off));\n      off += SHORT;\n\n      // FIXME this is actually not very cpu cycles friendly as we are converting from\n      // dos to java while the underlying Sun implementation will convert\n      // from java to dos time for internal storage...\n      long time = dosToJavaTime(ZipLong.getValue(cfh, off));\n      ze.setTime(time);\n      off += WORD;\n\n      ze.setCrc(ZipLong.getValue(cfh, off));\n      off += WORD;\n\n      ze.setCompressedSize(ZipLong.getValue(cfh, off));\n      off += WORD;\n\n      ze.setSize(ZipLong.getValue(cfh, off));\n      off += WORD;\n\n      int fileNameLen = ZipShort.getValue(cfh, off);\n      off += SHORT;\n\n      int extraLen = ZipShort.getValue(cfh, off);\n      off += SHORT;\n\n      int commentLen = ZipShort.getValue(cfh, off);\n      off += SHORT;\n\n      off += SHORT; // disk number\n\n      ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n      off += SHORT;\n\n      ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n      off += WORD;\n\n      byte[] fileName = new byte[fileNameLen];\n      archive.readFully(fileName);\n      ze.setName(getString(fileName));\n\n      // LFH offset,\n      // data offset will be filled later\n      ze.setHeaderOffset(ZipLong.getValue(cfh, off));\n\n      nameMap.put(ze.getName(), ze);\n      entries.add(ze);\n\n      if (extraLen > 0) {\n        byte[] extra = new byte[extraLen];\n        archive.readFully(extra);\n        ze.setExtra(extra);\n      }\n\n      byte[] comment = new byte[commentLen];\n      archive.readFully(comment);\n      ze.setComment(getString(comment));\n\n      archive.readFully(signatureBytes);\n      sig = ZipLong.getValue(signatureBytes);\n    }\n  }","id":26738,"modified_method":"/**\n   * Reads the central directory of the given archive and populates\n   * the internal tables with ZipEntry instances.\n   * <p/>\n   * <p>The ZipEntrys will know all data that can be obtained from\n   * the central directory alone, but not the data that requires the\n   * local file header or additional data to be read.<\/p>\n   */\n  private void populateFromCentralDirectory() throws IOException {\n    positionAtCentralDirectory();\n\n    byte[] cfh = new byte[CFH_LEN];\n\n    byte[] signatureBytes = new byte[WORD];\n    archive.readFully(signatureBytes);\n    long sig = ZipLong.getValue(signatureBytes);\n    final long cfhSig = ZipLong.getValue(JBZipOutputStream.CFH_SIG);\n    while (sig == cfhSig) {\n      archive.readFully(cfh);\n      int off = 0;\n\n      int versionMadeBy = ZipShort.getValue(cfh, off);\n      off += SHORT;\n      final int platform = (versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK;\n\n      off += WORD; // skip version info and general purpose byte\n\n      final int method = ZipShort.getValue(cfh, off);\n      off += SHORT;\n\n      long time = DosTime.dosToJavaTime(ZipLong.getValue(cfh, off));\n      off += WORD;\n\n      final long crc = ZipLong.getValue(cfh, off);\n      off += WORD;\n\n      final long compressedSize = ZipLong.getValue(cfh, off);\n      off += WORD;\n\n      final long uncompressedSize = ZipLong.getValue(cfh, off);\n      off += WORD;\n\n      int fileNameLen = ZipShort.getValue(cfh, off);\n      off += SHORT;\n\n      int extraLen = ZipShort.getValue(cfh, off);\n      off += SHORT;\n\n      int commentLen = ZipShort.getValue(cfh, off);\n      off += SHORT;\n\n      off += SHORT; // disk number\n\n      final int internalAttributes = ZipShort.getValue(cfh, off);\n      off += SHORT;\n\n      final long externalAttributes = ZipLong.getValue(cfh, off);\n      off += WORD;\n\n      long localHeaderOffset = ZipLong.getValue(cfh, off);\n\n      String name = getString(readBytes(fileNameLen));\n      byte[] extra = readBytes(extraLen);\n      String comment = getString(readBytes(commentLen));\n\n      JBZipEntry ze = new JBZipEntry(this);\n      ze.setName(name);\n      ze.setHeaderOffset(localHeaderOffset);\n      ze.setPlatform(platform);\n      ze.setMethod(method);\n      ze.setTime(time);\n      ze.setCrc(crc);\n      ze.setCompressedSize(compressedSize);\n      ze.setSize(uncompressedSize);\n      ze.setInternalAttributes(internalAttributes);\n      ze.setExternalAttributes(externalAttributes);\n      ze.setExtra(extra);\n      ze.setComment(comment);\n\n      nameMap.put(ze.getName(), ze);\n      entries.add(ze);\n\n      archive.readFully(signatureBytes);\n      sig = ZipLong.getValue(signatureBytes);\n    }\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Opens the given file for reading, assuming the platform's\n   * native encoding for file names.\n   *\n   * @param name name of the archive.\n   * @throws IOException if an error occurs while reading the file.\n   */\n  public JBZipFile(String name) throws IOException {\n    this(new File(name), null);\n  }","id":26739,"modified_method":"/**\n   * Opens the given file for reading, assuming the platform's\n   * native encoding for file names.\n   *\n   * @param name name of the archive.\n   * @throws IOException if an error occurs while reading the file.\n   */\n  public JBZipFile(String name) throws IOException {\n    this(new File(name), \"UTF-8\");\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Retrieve a String from the given bytes using the encoding set\n   * for this ZipFile.\n   *\n   * @param bytes the byte array to transform\n   * @return String obtained by using the given encoding\n   * @throws ZipException if the encoding cannot be recognized.\n   */\n  protected String getString(byte[] bytes) throws ZipException {\n    if (encoding == null) {\n      return new String(bytes);\n    }\n    else {\n      try {\n        return new String(bytes, encoding);\n      }\n      catch (UnsupportedEncodingException uee) {\n        throw new ZipException(uee.getMessage());\n      }\n    }\n  }","id":26740,"modified_method":"/**\n   * Retrieve a String from the given bytes using the encoding set\n   * for this ZipFile.\n   *\n   * @param bytes the byte array to transform\n   * @return String obtained by using the given encoding\n   * @throws ZipException if the encoding cannot be recognized.\n   */\n  String getString(byte[] bytes) throws ZipException {\n    if (encoding == null) {\n      return new String(bytes);\n    }\n    else {\n      try {\n        return new String(bytes, encoding);\n      }\n      catch (UnsupportedEncodingException uee) {\n        throw new ZipException(uee.getMessage());\n      }\n    }\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Opens the given file for reading, assuming the platform's\n   * native encoding for file names.\n   *\n   * @param f the archive.\n   * @throws IOException if an error occurs while reading the file.\n   */\n  public JBZipFile(File f) throws IOException {\n    this(f, null);\n  }","id":26741,"modified_method":"/**\n   * Opens the given file for reading, assuming the platform's\n   * native encoding for file names.\n   *\n   * @param f the archive.\n   * @throws IOException if an error occurs while reading the file.\n   */\n  public JBZipFile(File f) throws IOException {\n    this(f, \"UTF-8\");\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Writes all necessary data for this entry.\n   *\n   * @throws IOException on error\n   * @since 1.1\n   */\n  public void closeEntry() throws IOException {\n    if (entry == null) {\n      return;\n    }\n\n    long realCrc = crc.getValue();\n    crc.reset();\n\n    if (entry.getMethod() == DEFLATED) {\n      def.finish();\n      while (!def.finished()) {\n        deflate();\n      }\n\n      entry.setSize(adjustToLong(def.getTotalIn()));\n      entry.setCompressedSize(adjustToLong(def.getTotalOut()));\n      entry.setCrc(realCrc);\n\n      def.reset();\n\n      written += entry.getCompressedSize();\n    }\n    else { /* method is STORED and we used RandomAccessFile */\n      long size = written - dataStart;\n\n      entry.setSize(size);\n      entry.setCompressedSize(size);\n      entry.setCrc(realCrc);\n    }\n\n    // If random access output, write the local file header containing\n    // the correct CRC and compressed/uncompressed sizes\n    long save = raf.getFilePointer();\n\n    raf.seek(localDataStart);\n    writeOut(ZipLong.getBytes(entry.getCrc()));\n    writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n    writeOut(ZipLong.getBytes(entry.getSize()));\n    raf.seek(save);\n\n    entry = null;\n  }","id":26742,"modified_method":"/**\n   * Writes all necessary data for this entry.\n   *\n   * @throws IOException on error\n   * @since 1.1\n   */\n  public void closeEntry() throws IOException {\n    if (entry == null) {\n      return;\n    }\n\n    long realCrc = crc.getValue();\n    crc.reset();\n\n    if (entry.getMethod() == ZipEntry.DEFLATED) {\n      def.finish();\n      while (!def.finished()) {\n        deflate();\n      }\n\n      entry.setSize(adjustToLong(def.getTotalIn()));\n      entry.setCompressedSize(adjustToLong(def.getTotalOut()));\n      entry.setCrc(realCrc);\n\n      def.reset();\n\n      written += entry.getCompressedSize();\n    }\n    else { /* method is STORED and we used RandomAccessFile */\n      long size = written - dataStart;\n\n      entry.setSize(size);\n      entry.setCompressedSize(size);\n      entry.setCrc(realCrc);\n    }\n\n    // If random access output, write the local file header containing\n    // the correct CRC and compressed/uncompressed sizes\n    long save = raf.getFilePointer();\n\n    raf.seek(localDataStart);\n    writeOut(ZipLong.getBytes(entry.getCrc()));\n    writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n    writeOut(ZipLong.getBytes(entry.getSize()));\n    raf.seek(save);\n\n    entry = null;\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Writes the local file header entry\n   *\n   * @param ze the entry to write\n   * @throws IOException on error\n   * @since 1.1\n   */\n  protected void writeLocalFileHeader(JBZipEntry ze) throws IOException {\n    ze.setHeaderOffset(written);\n    raf.seek(written);\n\n    writeOut(LFH_SIG);\n    written += WORD;\n\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n\n    // version needed to extract\n    // general purpose bit flag\n    // CheckStyle:MagicNumber OFF\n    writeOut(ZipShort.getBytes(10));\n    writeOut(ZERO);\n    // CheckStyle:MagicNumber ON\n    written += WORD;\n\n    // compression method\n    writeOut(ZipShort.getBytes(zipMethod));\n    written += SHORT;\n\n    // last mod. time and date\n    writeOut(toDosTime(ze.getTime()));\n    written += WORD;\n\n    // CRC\n    // compressed length\n    // uncompressed length\n    localDataStart = written;\n    writeOut(LZERO);\n    writeOut(LZERO);\n    writeOut(LZERO);\n    // CheckStyle:MagicNumber OFF\n    written += 12;\n    // CheckStyle:MagicNumber ON\n\n    // file name length\n    byte[] name = getBytes(ze.getName());\n    writeOut(ZipShort.getBytes(name.length));\n    written += SHORT;\n\n    // extra field length\n    byte[] extra = ze.getLocalFileDataExtra();\n    writeOut(ZipShort.getBytes(extra.length));\n    written += SHORT;\n\n    // file name\n    writeOut(name);\n    written += name.length;\n\n    // extra field\n    writeOut(extra);\n    written += extra.length;\n\n    dataStart = written;\n  }","id":26743,"modified_method":"/**\n   * Writes the local file header entry\n   *\n   * @param ze the entry to write\n   * @throws IOException on error\n   * @since 1.1\n   */\n  protected void writeLocalFileHeader(JBZipEntry ze) throws IOException {\n    ze.setHeaderOffset(written);\n    raf.seek(written);\n\n    writeOut(LFH_SIG);\n    written += WORD;\n\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n\n    // version needed to extract\n    // general purpose bit flag\n    // CheckStyle:MagicNumber OFF\n    writeOut(ZipShort.getBytes(10));\n    writeOut(ZERO);\n    // CheckStyle:MagicNumber ON\n    written += WORD;\n\n    // compression method\n    writeOut(ZipShort.getBytes(zipMethod));\n    written += SHORT;\n\n    // last mod. time and date\n    writeOut(ZipLong.getBytes(DosTime.javaToDosTime(ze.getTime())));\n    written += WORD;\n\n    // CRC\n    // compressed length\n    // uncompressed length\n    localDataStart = written;\n    writeOut(LZERO);\n    writeOut(LZERO);\n    writeOut(LZERO);\n    // CheckStyle:MagicNumber OFF\n    written += 12;\n    // CheckStyle:MagicNumber ON\n\n    // file name length\n    byte[] name = getBytes(ze.getName());\n    writeOut(ZipShort.getBytes(name.length));\n    written += SHORT;\n\n    // extra field length\n    byte[] extra = ze.getLocalFileDataExtra();\n    writeOut(ZipShort.getBytes(extra.length));\n    written += SHORT;\n\n    // file name\n    writeOut(name);\n    written += name.length;\n\n    // extra field\n    writeOut(extra);\n    written += extra.length;\n\n    dataStart = written;\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Begin writing next entry.\n   *\n   * @param ze the entry to write\n   * @throws IOException on error\n   * @since 1.1\n   */\n  public void putNextEntry(JBZipEntry ze) throws IOException {\n    closeEntry();\n\n    entry = ze;\n\n    if (entry.getMethod() == -1) { // not specified\n      entry.setMethod(method);\n    }\n\n    if (entry.getTime() == -1) { // not specified\n      entry.setTime(System.currentTimeMillis());\n    }\n\n    if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n      def.setLevel(level);\n      hasCompressionLevelChanged = false;\n    }\n    writeLocalFileHeader(entry);\n  }","id":26744,"modified_method":"/**\n   * Begin writing next entry.\n   *\n   * @param ze the entry to write\n   * @throws IOException on error\n   * @since 1.1\n   */\n  public void putNextEntry(JBZipEntry ze) throws IOException {\n    closeEntry();\n\n    entry = ze;\n\n    if (entry.getMethod() == -1) { // not specified\n      entry.setMethod(method);\n    }\n\n    if (entry.getTime() == -1) { // not specified\n      entry.setTime(System.currentTimeMillis());\n    }\n\n    if (entry.getMethod() == ZipEntry.DEFLATED && hasCompressionLevelChanged) {\n      def.setLevel(level);\n      hasCompressionLevelChanged = false;\n    }\n    writeLocalFileHeader(entry);\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Writes the central file header entry.\n   *\n   * @param ze the entry to write\n   * @throws IOException on error\n   * @since 1.1\n   */\n  protected void writeCentralFileHeader(JBZipEntry ze) throws IOException {\n    raf.seek(written);\n    writeOut(CFH_SIG);\n    written += WORD;\n\n    // version made by\n    // CheckStyle:MagicNumber OFF\n    writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\n    written += SHORT;\n\n    // version needed to extract\n    // general purpose bit flag\n    writeOut(ZipShort.getBytes(10));\n    writeOut(ZERO);\n    // CheckStyle:MagicNumber ON\n    written += WORD;\n\n    // compression method\n    writeOut(ZipShort.getBytes(ze.getMethod()));\n    written += SHORT;\n\n    // last mod. time and date\n    writeOut(toDosTime(ze.getTime()));\n    written += WORD;\n\n    // CRC\n    // compressed length\n    // uncompressed length\n    writeOut(ZipLong.getBytes(ze.getCrc()));\n    writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n    writeOut(ZipLong.getBytes(ze.getSize()));\n    // CheckStyle:MagicNumber OFF\n    written += 12;\n    // CheckStyle:MagicNumber ON\n\n    // file name length\n    byte[] name = getBytes(ze.getName());\n    writeOut(ZipShort.getBytes(name.length));\n    written += SHORT;\n\n    // extra field length\n    byte[] extra = ze.getExtra();\n    writeOut(ZipShort.getBytes(extra.length));\n    written += SHORT;\n\n    // file comment length\n    String comm = ze.getComment();\n    if (comm == null) {\n      comm = \"\";\n    }\n    byte[] commentB = getBytes(comm);\n    writeOut(ZipShort.getBytes(commentB.length));\n    written += SHORT;\n\n    // disk number start\n    writeOut(ZERO);\n    written += SHORT;\n\n    // internal file attributes\n    writeOut(ZipShort.getBytes(ze.getInternalAttributes()));\n    written += SHORT;\n\n    // external file attributes\n    writeOut(ZipLong.getBytes(ze.getExternalAttributes()));\n    written += WORD;\n\n    // relative offset of LFH\n    writeOut(ZipLong.getBytes(ze.getHeaderOffset()));\n    written += WORD;\n\n    // file name\n    writeOut(name);\n    written += name.length;\n\n    // extra field\n    writeOut(extra);\n    written += extra.length;\n\n    // file comment\n    writeOut(commentB);\n    written += commentB.length;\n  }","id":26745,"modified_method":"/**\n   * Writes the central file header entry.\n   *\n   * @param ze the entry to write\n   * @throws IOException on error\n   * @since 1.1\n   */\n  protected void writeCentralFileHeader(JBZipEntry ze) throws IOException {\n    raf.seek(written);\n    writeOut(CFH_SIG);\n    written += WORD;\n\n    // version made by\n    // CheckStyle:MagicNumber OFF\n    writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\n    written += SHORT;\n\n    // version needed to extract\n    // general purpose bit flag\n    writeOut(ZipShort.getBytes(10));\n    writeOut(ZERO);\n    // CheckStyle:MagicNumber ON\n    written += WORD;\n\n    // compression method\n    writeOut(ZipShort.getBytes(ze.getMethod()));\n    written += SHORT;\n\n    // last mod. time and date\n    writeOut(ZipLong.getBytes(DosTime.javaToDosTime(ze.getTime())));\n    written += WORD;\n\n    // CRC\n    // compressed length\n    // uncompressed length\n    writeOut(ZipLong.getBytes(ze.getCrc()));\n    writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n    writeOut(ZipLong.getBytes(ze.getSize()));\n    // CheckStyle:MagicNumber OFF\n    written += 12;\n    // CheckStyle:MagicNumber ON\n\n    // file name length\n    byte[] name = getBytes(ze.getName());\n    writeOut(ZipShort.getBytes(name.length));\n    written += SHORT;\n\n    // extra field length\n    byte[] extra = ze.getExtra();\n    writeOut(ZipShort.getBytes(extra.length));\n    written += SHORT;\n\n    // file comment length\n    String comm = ze.getComment();\n    if (comm == null) {\n      comm = \"\";\n    }\n    byte[] commentB = getBytes(comm);\n    writeOut(ZipShort.getBytes(commentB.length));\n    written += SHORT;\n\n    // disk number start\n    writeOut(ZERO);\n    written += SHORT;\n\n    // internal file attributes\n    writeOut(ZipShort.getBytes(ze.getInternalAttributes()));\n    written += SHORT;\n\n    // external file attributes\n    writeOut(ZipLong.getBytes(ze.getExternalAttributes()));\n    written += WORD;\n\n    // relative offset of LFH\n    writeOut(ZipLong.getBytes(ze.getHeaderOffset()));\n    written += WORD;\n\n    // file name\n    writeOut(name);\n    written += name.length;\n\n    // extra field\n    writeOut(extra);\n    written += extra.length;\n\n    // file comment\n    writeOut(commentB);\n    written += commentB.length;\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Writes bytes to ZIP entry.\n   *\n   * @param b      the byte array to write\n   * @param offset the start position to write from\n   * @param length the number of bytes to write\n   * @throws IOException on error\n   */\n  public void write(byte[] b, int offset, int length) throws IOException {\n    if (entry.getMethod() == DEFLATED) {\n      if (length > 0) {\n        if (!def.finished()) {\n          def.setInput(b, offset, length);\n          while (!def.needsInput()) {\n            deflate();\n          }\n        }\n      }\n    }\n    else {\n      writeOut(b, offset, length);\n      written += length;\n    }\n    crc.update(b, offset, length);\n  }","id":26746,"modified_method":"/**\n   * Writes bytes to ZIP entry.\n   *\n   * @param b      the byte array to write\n   * @param offset the start position to write from\n   * @param length the number of bytes to write\n   * @throws IOException on error\n   */\n  public void write(byte[] b, int offset, int length) throws IOException {\n    if (entry.getMethod() == ZipEntry.DEFLATED) {\n      if (length > 0) {\n        if (!def.finished()) {\n          def.setInput(b, offset, length);\n          while (!def.needsInput()) {\n            deflate();\n          }\n        }\n      }\n    }\n    else {\n      writeOut(b, offset, length);\n      written += length;\n    }\n    crc.update(b, offset, length);\n  }","commit_id":"860b12c014daa861d112df70d7f03cc074d8dfe8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected MockHttpServletRequest createInvokerHttpServletRequest(\n\t\tString content) {\n\n\t\tMockHttpServletRequest mockHttpServletRequest = createHttpRequest(\n\t\t\t\"/invoke\");\n\n\t\tmockHttpServletRequest.setContent(content.getBytes());\n\n\t\tmockHttpServletRequest.setRemoteUser(\"root\");\n\n\t\tmockHttpServletRequest.setMethod(\"POST\");\n\n\t\treturn mockHttpServletRequest;\n\t}","id":26747,"modified_method":"protected MockHttpServletRequest createInvokerHttpServletRequest(\n\t\tString content) {\n\n\t\tMockHttpServletRequest mockHttpServletRequest = createHttpRequest(\n\t\t\t\"/invoke\");\n\n\t\tmockHttpServletRequest.setContent(content.getBytes());\n\t\tmockHttpServletRequest.setMethod(HttpMethods.POST);\n\t\tmockHttpServletRequest.setRemoteUser(\"root\");\n\n\t\treturn mockHttpServletRequest;\n\t}","commit_id":"57f46a18306ca0a63434c04c2e97a99ba743204d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n            final DeploymentUnit deploymentUnit = context.getDeploymentUnit();\n            final DeploymentReflectionIndex deploymentReflectionIndex = deploymentUnit.getAttachment(REFLECTION_INDEX);\n            final Object instanceKey = BasicComponentInstance.INSTANCE_KEY;\n            final Module module = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);\n            final EEApplicationDescription applicationDescription = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_DESCRIPTION);\n            final ProxyMetadataSource proxyReflectionIndex = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.PROXY_REFLECTION_INDEX);\n\n            // Module stuff\n            final EEModuleClassConfiguration componentClassConfiguration = configuration.getModuleClassConfiguration();\n\n            final Deque<InterceptorFactory> instantiators = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> injectors = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> uninjectors = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> destructors = new ArrayDeque<InterceptorFactory>();\n\n            final ClassReflectionIndex<?> componentClassIndex = deploymentReflectionIndex.getClassIndex(componentClassConfiguration.getModuleClass());\n            final List<InterceptorFactory> componentUserAroundInvoke = new ArrayList<InterceptorFactory>();\n            final List<InterceptorFactory> componentUserAroundTimeout;\n\n            final Map<String, List<InterceptorFactory>> userAroundInvokesByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n            final Map<String, List<InterceptorFactory>> userAroundTimeoutsByInterceptorClass;\n\n            final Map<String, List<InterceptorFactory>> userPostConstructByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n            final Map<String, List<InterceptorFactory>> userPreDestroyByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n\n            if (description.isTimerServiceApplicable()) {\n                componentUserAroundTimeout = new ArrayList<InterceptorFactory>();\n                userAroundTimeoutsByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n            } else {\n                componentUserAroundTimeout = null;\n                userAroundTimeoutsByInterceptorClass = null;\n            }\n\n\n            // Primary instance\n            final ManagedReferenceFactory instanceFactory = configuration.getInstanceFactory();\n            if (instanceFactory != null) {\n                instantiators.addFirst(new ManagedReferenceInterceptorFactory(instanceFactory, instanceKey));\n            } else {\n                //use the default constructor if no instanceFactory has been set\n                final Constructor<Object> constructor = (Constructor<Object>) componentClassIndex.getConstructor(EMPTY_CLASS_ARRAY);\n                if (constructor == null) {\n                    throw new DeploymentUnitProcessingException(\"Could not find default constructor for \" + componentClassConfiguration.getModuleClass());\n                }\n                ValueManagedReferenceFactory factory = new ValueManagedReferenceFactory(new ConstructedValue<Object>(constructor, Collections.<Value<?>>emptyList()));\n                instantiators.addFirst(new ManagedReferenceInterceptorFactory(factory, instanceKey));\n            }\n            destructors.addLast(new ManagedReferenceReleaseInterceptorFactory(instanceKey));\n\n            new ClassDescriptionTraversal(componentClassConfiguration, applicationDescription) {\n\n                @Override\n                public void handle(EEModuleClassConfiguration classConfiguration, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                    for (final ResourceInjectionConfiguration injectionConfiguration : classConfiguration.getInjectionConfigurations()) {\n                        final Object valueContextKey = new Object();\n                        final InjectedValue<ManagedReferenceFactory> managedReferenceFactoryValue = new InjectedValue<ManagedReferenceFactory>();\n                        configuration.getStartDependencies().add(new InjectedConfigurator(injectionConfiguration, configuration, context, managedReferenceFactoryValue));\n                        injectors.addFirst(injectionConfiguration.getTarget().createInjectionInterceptorFactory(instanceKey, valueContextKey, managedReferenceFactoryValue, deploymentUnit));\n                        uninjectors.addLast(new ManagedReferenceReleaseInterceptorFactory(valueContextKey));\n                    }\n                }\n            }.run();\n\n\n            //all interceptors with lifecycle callbacks, in the correct order\n            final List<InterceptorDescription> interceptorWithLifecycleCallbacks = new ArrayList<InterceptorDescription>();\n            if (!description.isExcludeDefaultInterceptors()) {\n                interceptorWithLifecycleCallbacks.addAll(description.getDefaultInterceptors());\n            }\n            interceptorWithLifecycleCallbacks.addAll(description.getClassInterceptors());\n\n            for (final InterceptorDescription interceptorDescription : description.getAllInterceptors()) {\n                final String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                final EEModuleClassConfiguration interceptorConfiguration = applicationDescription.getClassConfiguration(interceptorClassName);\n\n                //we store the interceptor instance under the class key\n                final Object contextKey = interceptorConfiguration.getModuleClass();\n                if (interceptorConfiguration.getInstantiator() == null) {\n                    throw new DeploymentUnitProcessingException(\"No default constructor for interceptor class \" + interceptorClassName + \" on component \" + componentClassConfiguration.getModuleClass());\n                }\n                instantiators.addFirst(new ManagedReferenceInterceptorFactory(interceptorConfiguration.getInstantiator(), contextKey));\n                destructors.addLast(new ManagedReferenceReleaseInterceptorFactory(contextKey));\n\n                final boolean interceptorHasLifecycleCallbacks = interceptorWithLifecycleCallbacks.contains(interceptorDescription);\n                final ClassReflectionIndex<?> interceptorIndex = deploymentReflectionIndex.getClassIndex(interceptorConfiguration.getModuleClass());\n\n                new ClassDescriptionTraversal(interceptorConfiguration, applicationDescription) {\n                    @Override\n                    public void handle(EEModuleClassConfiguration interceptorClassConfiguration, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                        final ClassReflectionIndex<?> interceptorClassIndex = deploymentReflectionIndex.getClassIndex(interceptorClassConfiguration.getModuleClass());\n\n                        for (final ResourceInjectionConfiguration injectionConfiguration : interceptorClassConfiguration.getInjectionConfigurations()) {\n                            final Object valueContextKey = new Object();\n                            final InjectedValue<ManagedReferenceFactory> managedReferenceFactoryValue = new InjectedValue<ManagedReferenceFactory>();\n                            configuration.getStartDependencies().add(new InjectedConfigurator(injectionConfiguration, configuration, context, managedReferenceFactoryValue));\n                            injectors.addFirst(injectionConfiguration.getTarget().createInjectionInterceptorFactory(contextKey, valueContextKey, managedReferenceFactoryValue, deploymentUnit));\n                            uninjectors.addLast(new ManagedReferenceReleaseInterceptorFactory(valueContextKey));\n                        }\n                        // Only class level interceptors are processed for postconstruct/predestroy methods.\n                        // Method level interceptors aren't supposed to be processed for postconstruct/predestroy lifecycle\n                        // methods, as per interceptors spec\n                        if (interceptorHasLifecycleCallbacks) {\n                            final MethodIdentifier postConstructMethodIdentifier = classDescription.getPostConstructMethod();\n                            if (postConstructMethodIdentifier != null) {\n                                final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, interceptorClassIndex, postConstructMethodIdentifier);\n\n                                if (isNotOverriden(interceptorClassConfiguration, method, interceptorIndex, deploymentReflectionIndex)) {\n                                    InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, true);\n                                    List<InterceptorFactory> userPostConstruct = userPostConstructByInterceptorClass.get(interceptorClassName);\n                                    if (userPostConstruct == null) {\n                                        userPostConstructByInterceptorClass.put(interceptorClassName, userPostConstruct = new ArrayList<InterceptorFactory>());\n                                    }\n                                    userPostConstruct.add(interceptorFactory);\n                                }\n                            }\n                            final MethodIdentifier preDestroyMethodIdentifier = classDescription.getPreDestroyMethod();\n                            if (preDestroyMethodIdentifier != null) {\n                                final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, interceptorClassIndex, preDestroyMethodIdentifier);\n                                if (isNotOverriden(interceptorClassConfiguration, method, interceptorIndex, deploymentReflectionIndex)) {\n                                    InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, true);\n                                    List<InterceptorFactory> userPreDestroy = userPreDestroyByInterceptorClass.get(interceptorClassName);\n                                    if (userPreDestroy == null) {\n                                        userPreDestroyByInterceptorClass.put(interceptorClassName, userPreDestroy = new ArrayList<InterceptorFactory>());\n                                    }\n                                    userPreDestroy.add(interceptorFactory);\n                                }\n                            }\n                        }\n                        final MethodIdentifier aroundInvokeMethodIdentifier = classDescription.getAroundInvokeMethod();\n                        if (aroundInvokeMethodIdentifier != null) {\n                            final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, interceptorClassIndex, aroundInvokeMethodIdentifier);\n                            if (isNotOverriden(interceptorClassConfiguration, method, interceptorIndex, deploymentReflectionIndex)) {\n                                List<InterceptorFactory> interceptors;\n                                if ((interceptors = userAroundInvokesByInterceptorClass.get(interceptorClassName)) == null) {\n                                    userAroundInvokesByInterceptorClass.put(interceptorClassName, interceptors = new ArrayList<InterceptorFactory>());\n                                }\n                                interceptors.add(new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, false));\n                            }\n                        }\n                        if (description.isTimerServiceApplicable()) {\n                            final MethodIdentifier aroundTimeoutMethodIdentifier = classDescription.getAroundTimeoutMethod();\n                            if (aroundTimeoutMethodIdentifier != null) {\n                                final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, interceptorClassIndex, aroundTimeoutMethodIdentifier);\n                                if (isNotOverriden(interceptorClassConfiguration, method, interceptorIndex, deploymentReflectionIndex)) {\n                                    List<InterceptorFactory> interceptors;\n                                    if ((interceptors = userAroundTimeoutsByInterceptorClass.get(interceptorClassName)) == null) {\n                                        userAroundTimeoutsByInterceptorClass.put(interceptorClassName, interceptors = new ArrayList<InterceptorFactory>());\n                                    }\n                                    interceptors.add(new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, false));\n                                }\n                            }\n                        }\n                    }\n                }.run();\n            }\n\n            final Deque<InterceptorFactory> userPostConstruct = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> userPreDestroy = new ArrayDeque<InterceptorFactory>();\n\n            //now add the lifecycle interceptors in the correct order\n\n\n            for (final InterceptorDescription interceptorClass : interceptorWithLifecycleCallbacks) {\n                if (userPostConstructByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                    userPostConstruct.addAll(userPostConstructByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n                }\n                if (userPreDestroyByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                    userPreDestroy.addAll(userPreDestroyByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n                }\n            }\n\n\n            new ClassDescriptionTraversal(componentClassConfiguration, applicationDescription) {\n                @Override\n                public void handle(EEModuleClassConfiguration configuration, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                    final ClassReflectionIndex classReflectionIndex = deploymentReflectionIndex.getClassIndex(configuration.getModuleClass());\n                    final MethodIdentifier componentPostConstructMethodIdentifier = classDescription.getPostConstructMethod();\n                    if (componentPostConstructMethodIdentifier != null) {\n                        final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, classReflectionIndex, componentPostConstructMethodIdentifier);\n                        if (isNotOverriden(configuration, method, componentClassIndex, deploymentReflectionIndex)) {\n                            InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, true);\n                            userPostConstruct.addLast(interceptorFactory);\n                        }\n                    }\n                    final MethodIdentifier componentPreDestroyMethodIdentifier = classDescription.getPreDestroyMethod();\n                    if (componentPreDestroyMethodIdentifier != null) {\n                        final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, classReflectionIndex, componentPreDestroyMethodIdentifier);\n                        if (isNotOverriden(configuration, method, componentClassIndex, deploymentReflectionIndex)) {\n                            InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, true);\n                            userPreDestroy.addLast(interceptorFactory);\n                        }\n                    }\n                    final MethodIdentifier componentAroundInvokeMethodIdentifier = classDescription.getAroundInvokeMethod();\n                    if (componentAroundInvokeMethodIdentifier != null) {\n                        final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, classReflectionIndex, componentAroundInvokeMethodIdentifier);\n\n                        if (isNotOverriden(configuration, method, componentClassIndex, deploymentReflectionIndex)) {\n                            componentUserAroundInvoke.add(new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, false));\n                        }\n                    }\n                    if (description.isTimerServiceApplicable()) {\n                        final MethodIdentifier componentAroundTimeoutMethodIdentifier = classDescription.getAroundTimeoutMethod();\n                        if (componentAroundTimeoutMethodIdentifier != null) {\n                            final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, classReflectionIndex, componentAroundTimeoutMethodIdentifier);\n                            if (isNotOverriden(configuration, method, componentClassIndex, deploymentReflectionIndex)) {\n                                componentUserAroundTimeout.add(new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, false));\n                            }\n                        }\n                    }\n                }\n            }.run();\n\n            final InterceptorFactory tcclInterceptor = new ImmediateInterceptorFactory(new TCCLInterceptor(module.getClassLoader()));\n\n            // Apply post-construct\n            if (!injectors.isEmpty()) {\n                configuration.addPostConstructInterceptor(weaved(injectors), InterceptorOrder.ComponentPostConstruct.RESOURCE_INJECTION_INTERCEPTORS);\n            }\n\n            if (!instantiators.isEmpty()) {\n                configuration.addPostConstructInterceptor(weaved(instantiators), InterceptorOrder.ComponentPostConstruct.INSTANTIATION_INTERCEPTORS);\n            }\n            if (!userPostConstruct.isEmpty()) {\n                configuration.addPostConstructInterceptor(weaved(userPostConstruct), InterceptorOrder.ComponentPostConstruct.USER_INTERCEPTORS);\n            }\n            configuration.addPostConstructInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ComponentPostConstruct.TERMINAL_INTERCEPTOR);\n            configuration.addPostConstructInterceptor(tcclInterceptor, InterceptorOrder.ComponentPostConstruct.TCCL_INTERCEPTOR);\n\n            // Apply pre-destroy\n            if (!uninjectors.isEmpty()) {\n                configuration.addPreDestroyInterceptor(weaved(uninjectors), InterceptorOrder.ComponentPreDestroy.UNINJECTION_INTERCEPTORS);\n            }\n            if (!destructors.isEmpty()) {\n                configuration.addPreDestroyInterceptor(weaved(destructors), InterceptorOrder.ComponentPreDestroy.DESTRUCTION_INTERCEPTORS);\n            }\n            if (!userPreDestroy.isEmpty()) {\n                configuration.addPreDestroyInterceptor(weaved(userPreDestroy), InterceptorOrder.ComponentPreDestroy.USER_INTERCEPTORS);\n            }\n\n            configuration.addPreDestroyInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ComponentPreDestroy.TERMINAL_INTERCEPTOR);\n            configuration.addPreDestroyInterceptor(tcclInterceptor, InterceptorOrder.ComponentPreDestroy.TCCL_INTERCEPTOR);\n\n            // @AroundInvoke interceptors\n            final List<InterceptorDescription> classInterceptors = description.getClassInterceptors();\n            final Map<MethodIdentifier, List<InterceptorDescription>> methodInterceptors = description.getMethodInterceptors();\n\n            if (description.isIntercepted()) {\n\n                for (final Method method : componentClassConfiguration.getClassMethods()) {\n\n                    //now add the interceptor that initializes and the interceptor that actually invokes to the end of the interceptor chain\n\n                    configuration.addComponentInterceptor(method, Interceptors.getInitialInterceptorFactory(), InterceptorOrder.Component.INITIAL_INTERCEPTOR);\n                    configuration.addComponentInterceptor(method, new ManagedReferenceMethodInterceptorFactory(instanceKey, method), InterceptorOrder.Component.TERMINAL_INTERCEPTOR);\n                    if (description.isTimerServiceApplicable()) {\n                        configuration.addTimeoutInterceptor(method, new ManagedReferenceMethodInterceptorFactory(instanceKey, method), InterceptorOrder.Component.TERMINAL_INTERCEPTOR);\n                    }\n                    // and also add the tccl interceptor\n                    configuration.addComponentInterceptor(method, tcclInterceptor, InterceptorOrder.Component.TCCL_INTERCEPTOR);\n                    if (description.isTimerServiceApplicable()) {\n                        configuration.addTimeoutInterceptor(method, tcclInterceptor, InterceptorOrder.Component.TCCL_INTERCEPTOR);\n                    }\n\n\n                    final MethodIdentifier identifier = MethodIdentifier.getIdentifier(method.getReturnType(), method.getName(), method.getParameterTypes());\n\n                    final List<InterceptorFactory> userAroundInvokes = new ArrayList<InterceptorFactory>();\n                    final List<InterceptorFactory> userAroundTimeouts = new ArrayList<InterceptorFactory>();\n                    // first add the default interceptors (if not excluded) to the deque\n                    if (!description.isExcludeDefaultInterceptors() && !description.isExcludeDefaultInterceptors(identifier)) {\n                        for (InterceptorDescription interceptorDescription : description.getDefaultInterceptors()) {\n                            String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                            List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                            if (aroundInvokes != null) {\n                                userAroundInvokes.addAll(aroundInvokes);\n                            }\n                            if (description.isTimerServiceApplicable()) {\n                                List<InterceptorFactory> aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);\n                                if (aroundTimeouts != null) {\n                                    userAroundTimeouts.addAll(aroundTimeouts);\n                                }\n                            }\n                        }\n                    }\n\n                    // now add class level interceptors (if not excluded) to the deque\n                    if (!description.isExcludeClassInterceptors(identifier)) {\n                        for (InterceptorDescription interceptorDescription : classInterceptors) {\n                            String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                            List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                            if (aroundInvokes != null) {\n                                userAroundInvokes.addAll(aroundInvokes);\n                            }\n                            if (description.isTimerServiceApplicable()) {\n                                List<InterceptorFactory> aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);\n                                if (aroundTimeouts != null) {\n                                    userAroundTimeouts.addAll(aroundTimeouts);\n                                }\n                            }\n                        }\n                    }\n\n                    // now add method level interceptors for to the deque so that they are triggered after the class interceptors\n                    List<InterceptorDescription> methodLevelInterceptors = methodInterceptors.get(identifier);\n                    if (methodLevelInterceptors != null) {\n                        for (InterceptorDescription methodLevelInterceptor : methodLevelInterceptors) {\n                            String interceptorClassName = methodLevelInterceptor.getInterceptorClassName();\n                            List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                            if (aroundInvokes != null) {\n                                userAroundInvokes.addAll(aroundInvokes);\n                            }\n                            if (description.isTimerServiceApplicable()) {\n                                List<InterceptorFactory> aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);\n                                if (aroundTimeouts != null) {\n                                    userAroundTimeouts.addAll(aroundTimeouts);\n                                }\n                            }\n                        }\n                    }\n\n                    // finally add the component level around invoke to the deque so that it's triggered last\n                    userAroundInvokes.addAll(componentUserAroundInvoke);\n\n                    configuration.addComponentInterceptor(method, weaved(userAroundInvokes), InterceptorOrder.Component.USER_INTERCEPTORS);\n                    if (description.isTimerServiceApplicable()) {\n                        userAroundTimeouts.addAll(componentUserAroundTimeout);\n                        configuration.addTimeoutInterceptor(method, weaved(userAroundTimeouts), InterceptorOrder.Component.USER_INTERCEPTORS);\n                    }\n                }\n            }\n\n\n            //views\n            for (ViewDescription view : description.getViews()) {\n                Class<?> viewClass;\n                try {\n                    viewClass = module.getClassLoader().loadClass(view.getViewClassName());\n                } catch (ClassNotFoundException e) {\n                    throw new DeploymentUnitProcessingException(\"Could not load view class \" + view.getViewClassName() + \" for component \" + configuration, e);\n                }\n                final ViewConfiguration viewConfiguration;\n\n                final ProxyConfiguration proxyConfiguration = new ProxyConfiguration();\n                proxyConfiguration.setProxyName(viewClass.getName() + \"$$$view\" + PROXY_ID.incrementAndGet());\n                proxyConfiguration.setClassLoader(module.getClassLoader());\n                proxyConfiguration.setProtectionDomain(viewClass.getProtectionDomain());\n                proxyConfiguration.setMetadataSource(proxyReflectionIndex);\n                if (view.isSerializable()) {\n                    proxyConfiguration.addAdditionalInterface(Serializable.class);\n                    if (view.isUseWriteReplace()) {\n                        proxyConfiguration.addAdditionalInterface(WriteReplaceInterface.class);\n                    }\n                }\n\n                //we define it in the modules class loader to prevent permgen leaks\n                if (viewClass.isInterface()) {\n                    proxyConfiguration.setSuperClass(Object.class);\n                    proxyConfiguration.addAdditionalInterface(viewClass);\n                    viewConfiguration = view.createViewConfiguration(viewClass, configuration, new ProxyFactory(proxyConfiguration));\n                } else {\n                    proxyConfiguration.setSuperClass(viewClass);\n                    viewConfiguration = view.createViewConfiguration(viewClass, configuration, new ProxyFactory(proxyConfiguration));\n                }\n                for (final ViewConfigurator configurator : view.getConfigurators()) {\n                    configurator.configure(context, configuration, view, viewConfiguration);\n                }\n                configuration.getViews().add(viewConfiguration);\n            }\n\n            configuration.getStartDependencies().add(new DependencyConfigurator<ComponentStartService>() {\n                @Override\n                public void configureDependency(final ServiceBuilder<?> serviceBuilder, ComponentStartService service) throws DeploymentUnitProcessingException {\n                    for (final Map.Entry<ServiceName, ServiceBuilder.DependencyType> entry : description.getDependencies().entrySet()) {\n                        serviceBuilder.addDependency(entry.getValue(), entry.getKey());\n                    }\n\n                }\n            });\n        }","id":26748,"modified_method":"public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n            final DeploymentUnit deploymentUnit = context.getDeploymentUnit();\n            final DeploymentReflectionIndex deploymentReflectionIndex = deploymentUnit.getAttachment(REFLECTION_INDEX);\n            final Object instanceKey = BasicComponentInstance.INSTANCE_KEY;\n            final Module module = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);\n            final EEApplicationDescription applicationDescription = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_DESCRIPTION);\n            final ProxyMetadataSource proxyReflectionIndex = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.PROXY_REFLECTION_INDEX);\n\n            // Module stuff\n            final EEModuleClassConfiguration componentClassConfiguration = configuration.getModuleClassConfiguration();\n\n            final Deque<InterceptorFactory> instantiators = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> injectors = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> uninjectors = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> destructors = new ArrayDeque<InterceptorFactory>();\n\n            final ClassReflectionIndex<?> componentClassIndex = deploymentReflectionIndex.getClassIndex(componentClassConfiguration.getModuleClass());\n            final List<InterceptorFactory> componentUserAroundInvoke = new ArrayList<InterceptorFactory>();\n            final List<InterceptorFactory> componentUserAroundTimeout;\n\n            final Map<String, List<InterceptorFactory>> userAroundInvokesByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n            final Map<String, List<InterceptorFactory>> userAroundTimeoutsByInterceptorClass;\n\n            final Map<String, List<InterceptorFactory>> userPostConstructByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n            final Map<String, List<InterceptorFactory>> userPreDestroyByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n\n            if (description.isTimerServiceApplicable()) {\n                componentUserAroundTimeout = new ArrayList<InterceptorFactory>();\n                userAroundTimeoutsByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n            } else {\n                componentUserAroundTimeout = null;\n                userAroundTimeoutsByInterceptorClass = null;\n            }\n\n\n            // Primary instance\n            final ManagedReferenceFactory instanceFactory = configuration.getInstanceFactory();\n            if (instanceFactory != null) {\n                instantiators.addFirst(new ManagedReferenceInterceptorFactory(instanceFactory, instanceKey));\n            } else {\n                //use the default constructor if no instanceFactory has been set\n                final Constructor<Object> constructor = (Constructor<Object>) componentClassIndex.getConstructor(EMPTY_CLASS_ARRAY);\n                if (constructor == null) {\n                    throw new DeploymentUnitProcessingException(\"Could not find default constructor for \" + componentClassConfiguration.getModuleClass());\n                }\n                ValueManagedReferenceFactory factory = new ValueManagedReferenceFactory(new ConstructedValue<Object>(constructor, Collections.<Value<?>>emptyList()));\n                instantiators.addFirst(new ManagedReferenceInterceptorFactory(factory, instanceKey));\n            }\n            destructors.addLast(new ManagedReferenceReleaseInterceptorFactory(instanceKey));\n\n            new ClassDescriptionTraversal(componentClassConfiguration, applicationDescription) {\n\n                @Override\n                public void handle(EEModuleClassConfiguration classConfiguration, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                    for (final ResourceInjectionConfiguration injectionConfiguration : classConfiguration.getInjectionConfigurations()) {\n                        final Object valueContextKey = new Object();\n                        final InjectedValue<ManagedReferenceFactory> managedReferenceFactoryValue = new InjectedValue<ManagedReferenceFactory>();\n                        configuration.getStartDependencies().add(new InjectedConfigurator(injectionConfiguration, configuration, context, managedReferenceFactoryValue));\n                        injectors.addFirst(injectionConfiguration.getTarget().createInjectionInterceptorFactory(instanceKey, valueContextKey, managedReferenceFactoryValue, deploymentUnit));\n                        uninjectors.addLast(new ManagedReferenceReleaseInterceptorFactory(valueContextKey));\n                    }\n                }\n            }.run();\n\n\n            //all interceptors with lifecycle callbacks, in the correct order\n            final List<InterceptorDescription> interceptorWithLifecycleCallbacks = new ArrayList<InterceptorDescription>();\n            if (!description.isExcludeDefaultInterceptors()) {\n                interceptorWithLifecycleCallbacks.addAll(description.getDefaultInterceptors());\n            }\n            interceptorWithLifecycleCallbacks.addAll(description.getClassInterceptors());\n\n            for (final InterceptorDescription interceptorDescription : description.getAllInterceptors()) {\n                final String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                final EEModuleClassConfiguration interceptorConfiguration = applicationDescription.getClassConfiguration(interceptorClassName);\n\n                //we store the interceptor instance under the class key\n                final Object contextKey = interceptorConfiguration.getModuleClass();\n                if (interceptorConfiguration.getInstantiator() == null) {\n                    throw new DeploymentUnitProcessingException(\"No default constructor for interceptor class \" + interceptorClassName + \" on component \" + componentClassConfiguration.getModuleClass());\n                }\n                instantiators.addFirst(new ManagedReferenceInterceptorFactory(interceptorConfiguration.getInstantiator(), contextKey));\n                destructors.addLast(new ManagedReferenceReleaseInterceptorFactory(contextKey));\n\n                final boolean interceptorHasLifecycleCallbacks = interceptorWithLifecycleCallbacks.contains(interceptorDescription);\n                final ClassReflectionIndex<?> interceptorIndex = deploymentReflectionIndex.getClassIndex(interceptorConfiguration.getModuleClass());\n\n                new ClassDescriptionTraversal(interceptorConfiguration, applicationDescription) {\n                    @Override\n                    public void handle(EEModuleClassConfiguration interceptorClassConfiguration, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                        final ClassReflectionIndex<?> interceptorClassIndex = deploymentReflectionIndex.getClassIndex(interceptorClassConfiguration.getModuleClass());\n\n                        for (final ResourceInjectionConfiguration injectionConfiguration : interceptorClassConfiguration.getInjectionConfigurations()) {\n                            final Object valueContextKey = new Object();\n                            final InjectedValue<ManagedReferenceFactory> managedReferenceFactoryValue = new InjectedValue<ManagedReferenceFactory>();\n                            configuration.getStartDependencies().add(new InjectedConfigurator(injectionConfiguration, configuration, context, managedReferenceFactoryValue));\n                            injectors.addFirst(injectionConfiguration.getTarget().createInjectionInterceptorFactory(contextKey, valueContextKey, managedReferenceFactoryValue, deploymentUnit));\n                            uninjectors.addLast(new ManagedReferenceReleaseInterceptorFactory(valueContextKey));\n                        }\n                        // Only class level interceptors are processed for postconstruct/predestroy methods.\n                        // Method level interceptors aren't supposed to be processed for postconstruct/predestroy lifecycle\n                        // methods, as per interceptors spec\n                        if (interceptorHasLifecycleCallbacks) {\n                            final MethodIdentifier postConstructMethodIdentifier = classDescription.getPostConstructMethod();\n                            if (postConstructMethodIdentifier != null) {\n                                final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, interceptorClassIndex, postConstructMethodIdentifier);\n\n                                if (isNotOverriden(interceptorClassConfiguration, method, interceptorIndex, deploymentReflectionIndex)) {\n                                    InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, true, true);\n                                    List<InterceptorFactory> userPostConstruct = userPostConstructByInterceptorClass.get(interceptorClassName);\n                                    if (userPostConstruct == null) {\n                                        userPostConstructByInterceptorClass.put(interceptorClassName, userPostConstruct = new ArrayList<InterceptorFactory>());\n                                    }\n                                    userPostConstruct.add(interceptorFactory);\n                                }\n                            }\n                            final MethodIdentifier preDestroyMethodIdentifier = classDescription.getPreDestroyMethod();\n                            if (preDestroyMethodIdentifier != null) {\n                                final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, interceptorClassIndex, preDestroyMethodIdentifier);\n                                if (isNotOverriden(interceptorClassConfiguration, method, interceptorIndex, deploymentReflectionIndex)) {\n                                    InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, true, true);\n                                    List<InterceptorFactory> userPreDestroy = userPreDestroyByInterceptorClass.get(interceptorClassName);\n                                    if (userPreDestroy == null) {\n                                        userPreDestroyByInterceptorClass.put(interceptorClassName, userPreDestroy = new ArrayList<InterceptorFactory>());\n                                    }\n                                    userPreDestroy.add(interceptorFactory);\n                                }\n                            }\n                        }\n                        final MethodIdentifier aroundInvokeMethodIdentifier = classDescription.getAroundInvokeMethod();\n                        if (aroundInvokeMethodIdentifier != null) {\n                            final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, interceptorClassIndex, aroundInvokeMethodIdentifier);\n                            if (isNotOverriden(interceptorClassConfiguration, method, interceptorIndex, deploymentReflectionIndex)) {\n                                List<InterceptorFactory> interceptors;\n                                if ((interceptors = userAroundInvokesByInterceptorClass.get(interceptorClassName)) == null) {\n                                    userAroundInvokesByInterceptorClass.put(interceptorClassName, interceptors = new ArrayList<InterceptorFactory>());\n                                }\n                                interceptors.add(new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, false));\n                            }\n                        }\n                        if (description.isTimerServiceApplicable()) {\n                            final MethodIdentifier aroundTimeoutMethodIdentifier = classDescription.getAroundTimeoutMethod();\n                            if (aroundTimeoutMethodIdentifier != null) {\n                                final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, interceptorClassIndex, aroundTimeoutMethodIdentifier);\n                                if (isNotOverriden(interceptorClassConfiguration, method, interceptorIndex, deploymentReflectionIndex)) {\n                                    List<InterceptorFactory> interceptors;\n                                    if ((interceptors = userAroundTimeoutsByInterceptorClass.get(interceptorClassName)) == null) {\n                                        userAroundTimeoutsByInterceptorClass.put(interceptorClassName, interceptors = new ArrayList<InterceptorFactory>());\n                                    }\n                                    interceptors.add(new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, false));\n                                }\n                            }\n                        }\n                    }\n                }.run();\n            }\n\n            final Deque<InterceptorFactory> userPostConstruct = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> userPreDestroy = new ArrayDeque<InterceptorFactory>();\n\n            //now add the lifecycle interceptors in the correct order\n\n\n            for (final InterceptorDescription interceptorClass : interceptorWithLifecycleCallbacks) {\n                if (userPostConstructByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                    userPostConstruct.addAll(userPostConstructByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n                }\n                if (userPreDestroyByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                    userPreDestroy.addAll(userPreDestroyByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n                }\n            }\n\n\n            new ClassDescriptionTraversal(componentClassConfiguration, applicationDescription) {\n                @Override\n                public void handle(EEModuleClassConfiguration configuration, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                    final ClassReflectionIndex classReflectionIndex = deploymentReflectionIndex.getClassIndex(configuration.getModuleClass());\n                    final MethodIdentifier componentPostConstructMethodIdentifier = classDescription.getPostConstructMethod();\n                    if (componentPostConstructMethodIdentifier != null) {\n                        final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, classReflectionIndex, componentPostConstructMethodIdentifier);\n                        if (isNotOverriden(configuration, method, componentClassIndex, deploymentReflectionIndex)) {\n                            InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, true, true);\n                            userPostConstruct.addLast(interceptorFactory);\n                        }\n                    }\n                    final MethodIdentifier componentPreDestroyMethodIdentifier = classDescription.getPreDestroyMethod();\n                    if (componentPreDestroyMethodIdentifier != null) {\n                        final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, classReflectionIndex, componentPreDestroyMethodIdentifier);\n                        if (isNotOverriden(configuration, method, componentClassIndex, deploymentReflectionIndex)) {\n                            InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, true, true);\n                            userPreDestroy.addLast(interceptorFactory);\n                        }\n                    }\n                    final MethodIdentifier componentAroundInvokeMethodIdentifier = classDescription.getAroundInvokeMethod();\n                    if (componentAroundInvokeMethodIdentifier != null) {\n                        final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, classReflectionIndex, componentAroundInvokeMethodIdentifier);\n\n                        if (isNotOverriden(configuration, method, componentClassIndex, deploymentReflectionIndex)) {\n                            componentUserAroundInvoke.add(new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, false));\n                        }\n                    }\n                    if (description.isTimerServiceApplicable()) {\n                        final MethodIdentifier componentAroundTimeoutMethodIdentifier = classDescription.getAroundTimeoutMethod();\n                        if (componentAroundTimeoutMethodIdentifier != null) {\n                            final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, classReflectionIndex, componentAroundTimeoutMethodIdentifier);\n                            if (isNotOverriden(configuration, method, componentClassIndex, deploymentReflectionIndex)) {\n                                componentUserAroundTimeout.add(new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, false));\n                            }\n                        }\n                    }\n                }\n            }.run();\n\n            final InterceptorFactory tcclInterceptor = new ImmediateInterceptorFactory(new TCCLInterceptor(module.getClassLoader()));\n\n            // Apply post-construct\n            if (!injectors.isEmpty()) {\n                configuration.addPostConstructInterceptor(weaved(injectors), InterceptorOrder.ComponentPostConstruct.RESOURCE_INJECTION_INTERCEPTORS);\n            }\n\n            if (!instantiators.isEmpty()) {\n                configuration.addPostConstructInterceptor(weaved(instantiators), InterceptorOrder.ComponentPostConstruct.INSTANTIATION_INTERCEPTORS);\n            }\n            if (!userPostConstruct.isEmpty()) {\n                configuration.addPostConstructInterceptor(weaved(userPostConstruct), InterceptorOrder.ComponentPostConstruct.USER_INTERCEPTORS);\n            }\n            configuration.addPostConstructInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ComponentPostConstruct.TERMINAL_INTERCEPTOR);\n            configuration.addPostConstructInterceptor(tcclInterceptor, InterceptorOrder.ComponentPostConstruct.TCCL_INTERCEPTOR);\n\n            // Apply pre-destroy\n            if (!uninjectors.isEmpty()) {\n                configuration.addPreDestroyInterceptor(weaved(uninjectors), InterceptorOrder.ComponentPreDestroy.UNINJECTION_INTERCEPTORS);\n            }\n            if (!destructors.isEmpty()) {\n                configuration.addPreDestroyInterceptor(weaved(destructors), InterceptorOrder.ComponentPreDestroy.DESTRUCTION_INTERCEPTORS);\n            }\n            if (!userPreDestroy.isEmpty()) {\n                configuration.addPreDestroyInterceptor(weaved(userPreDestroy), InterceptorOrder.ComponentPreDestroy.USER_INTERCEPTORS);\n            }\n\n            configuration.addPreDestroyInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ComponentPreDestroy.TERMINAL_INTERCEPTOR);\n            configuration.addPreDestroyInterceptor(tcclInterceptor, InterceptorOrder.ComponentPreDestroy.TCCL_INTERCEPTOR);\n\n            // @AroundInvoke interceptors\n            final List<InterceptorDescription> classInterceptors = description.getClassInterceptors();\n            final Map<MethodIdentifier, List<InterceptorDescription>> methodInterceptors = description.getMethodInterceptors();\n\n            if (description.isIntercepted()) {\n\n                for (final Method method : componentClassConfiguration.getClassMethods()) {\n\n                    //now add the interceptor that initializes and the interceptor that actually invokes to the end of the interceptor chain\n\n                    configuration.addComponentInterceptor(method, Interceptors.getInitialInterceptorFactory(), InterceptorOrder.Component.INITIAL_INTERCEPTOR);\n                    configuration.addComponentInterceptor(method, new ManagedReferenceMethodInterceptorFactory(instanceKey, method), InterceptorOrder.Component.TERMINAL_INTERCEPTOR);\n                    if (description.isTimerServiceApplicable()) {\n                        configuration.addTimeoutInterceptor(method, new ManagedReferenceMethodInterceptorFactory(instanceKey, method), InterceptorOrder.Component.TERMINAL_INTERCEPTOR);\n                    }\n                    // and also add the tccl interceptor\n                    configuration.addComponentInterceptor(method, tcclInterceptor, InterceptorOrder.Component.TCCL_INTERCEPTOR);\n                    if (description.isTimerServiceApplicable()) {\n                        configuration.addTimeoutInterceptor(method, tcclInterceptor, InterceptorOrder.Component.TCCL_INTERCEPTOR);\n                    }\n\n\n                    final MethodIdentifier identifier = MethodIdentifier.getIdentifier(method.getReturnType(), method.getName(), method.getParameterTypes());\n\n                    final List<InterceptorFactory> userAroundInvokes = new ArrayList<InterceptorFactory>();\n                    final List<InterceptorFactory> userAroundTimeouts = new ArrayList<InterceptorFactory>();\n                    // first add the default interceptors (if not excluded) to the deque\n                    if (!description.isExcludeDefaultInterceptors() && !description.isExcludeDefaultInterceptors(identifier)) {\n                        for (InterceptorDescription interceptorDescription : description.getDefaultInterceptors()) {\n                            String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                            List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                            if (aroundInvokes != null) {\n                                userAroundInvokes.addAll(aroundInvokes);\n                            }\n                            if (description.isTimerServiceApplicable()) {\n                                List<InterceptorFactory> aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);\n                                if (aroundTimeouts != null) {\n                                    userAroundTimeouts.addAll(aroundTimeouts);\n                                }\n                            }\n                        }\n                    }\n\n                    // now add class level interceptors (if not excluded) to the deque\n                    if (!description.isExcludeClassInterceptors(identifier)) {\n                        for (InterceptorDescription interceptorDescription : classInterceptors) {\n                            String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                            List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                            if (aroundInvokes != null) {\n                                userAroundInvokes.addAll(aroundInvokes);\n                            }\n                            if (description.isTimerServiceApplicable()) {\n                                List<InterceptorFactory> aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);\n                                if (aroundTimeouts != null) {\n                                    userAroundTimeouts.addAll(aroundTimeouts);\n                                }\n                            }\n                        }\n                    }\n\n                    // now add method level interceptors for to the deque so that they are triggered after the class interceptors\n                    List<InterceptorDescription> methodLevelInterceptors = methodInterceptors.get(identifier);\n                    if (methodLevelInterceptors != null) {\n                        for (InterceptorDescription methodLevelInterceptor : methodLevelInterceptors) {\n                            String interceptorClassName = methodLevelInterceptor.getInterceptorClassName();\n                            List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                            if (aroundInvokes != null) {\n                                userAroundInvokes.addAll(aroundInvokes);\n                            }\n                            if (description.isTimerServiceApplicable()) {\n                                List<InterceptorFactory> aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);\n                                if (aroundTimeouts != null) {\n                                    userAroundTimeouts.addAll(aroundTimeouts);\n                                }\n                            }\n                        }\n                    }\n\n                    // finally add the component level around invoke to the deque so that it's triggered last\n                    userAroundInvokes.addAll(componentUserAroundInvoke);\n\n                    configuration.addComponentInterceptor(method, weaved(userAroundInvokes), InterceptorOrder.Component.USER_INTERCEPTORS);\n                    if (description.isTimerServiceApplicable()) {\n                        userAroundTimeouts.addAll(componentUserAroundTimeout);\n                        configuration.addTimeoutInterceptor(method, weaved(userAroundTimeouts), InterceptorOrder.Component.USER_INTERCEPTORS);\n                    }\n                }\n            }\n\n\n            //views\n            for (ViewDescription view : description.getViews()) {\n                Class<?> viewClass;\n                try {\n                    viewClass = module.getClassLoader().loadClass(view.getViewClassName());\n                } catch (ClassNotFoundException e) {\n                    throw new DeploymentUnitProcessingException(\"Could not load view class \" + view.getViewClassName() + \" for component \" + configuration, e);\n                }\n                final ViewConfiguration viewConfiguration;\n\n                final ProxyConfiguration proxyConfiguration = new ProxyConfiguration();\n                proxyConfiguration.setProxyName(viewClass.getName() + \"$$$view\" + PROXY_ID.incrementAndGet());\n                proxyConfiguration.setClassLoader(module.getClassLoader());\n                proxyConfiguration.setProtectionDomain(viewClass.getProtectionDomain());\n                proxyConfiguration.setMetadataSource(proxyReflectionIndex);\n                if (view.isSerializable()) {\n                    proxyConfiguration.addAdditionalInterface(Serializable.class);\n                    if (view.isUseWriteReplace()) {\n                        proxyConfiguration.addAdditionalInterface(WriteReplaceInterface.class);\n                    }\n                }\n\n                //we define it in the modules class loader to prevent permgen leaks\n                if (viewClass.isInterface()) {\n                    proxyConfiguration.setSuperClass(Object.class);\n                    proxyConfiguration.addAdditionalInterface(viewClass);\n                    viewConfiguration = view.createViewConfiguration(viewClass, configuration, new ProxyFactory(proxyConfiguration));\n                } else {\n                    proxyConfiguration.setSuperClass(viewClass);\n                    viewConfiguration = view.createViewConfiguration(viewClass, configuration, new ProxyFactory(proxyConfiguration));\n                }\n                for (final ViewConfigurator configurator : view.getConfigurators()) {\n                    configurator.configure(context, configuration, view, viewConfiguration);\n                }\n                configuration.getViews().add(viewConfiguration);\n            }\n\n            configuration.getStartDependencies().add(new DependencyConfigurator<ComponentStartService>() {\n                @Override\n                public void configureDependency(final ServiceBuilder<?> serviceBuilder, ComponentStartService service) throws DeploymentUnitProcessingException {\n                    for (final Map.Entry<ServiceName, ServiceBuilder.DependencyType> entry : description.getDependencies().entrySet()) {\n                        serviceBuilder.addDependency(entry.getValue(), entry.getKey());\n                    }\n\n                }\n            });\n        }","commit_id":"07ee31bd0bcaa88000d4f334f198ecad3290e8e2","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public Object processInvocation(final InterceptorContext context) throws Exception {\n        final ManagedReference reference = instanceRef.get();\n        final Object instance = reference.getInstance();\n        try {\n            Method method = this.method;\n            if (withContext) {\n                if (changeMethod) {\n                    final Method oldMethod = context.getMethod();\n                    context.setMethod(method);\n                    try {\n                        return method.invoke(instance, context.getInvocationContext());\n                    } finally {\n                        context.setMethod(oldMethod);\n                    }\n                } else {\n                    return method.invoke(instance, context.getInvocationContext());\n                }\n            } else {\n                method.invoke(instance, null);\n                return context.proceed();\n            }\n        } catch (IllegalAccessException e) {\n            final IllegalAccessError n = new IllegalAccessError(e.getMessage());\n            n.setStackTrace(e.getStackTrace());\n            throw n;\n        } catch (InvocationTargetException e) {\n            throw Interceptors.rethrow(e.getCause());\n        }\n    }","id":26749,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public Object processInvocation(final InterceptorContext context) throws Exception {\n        final ManagedReference reference = instanceRef.get();\n        final Object instance = reference.getInstance();\n        try {\n            final Method method = this.method;\n            if (withContext) {\n                final Method oldMethod = context.getMethod();\n                try {\n                    if (this.lifecycleMethod) {\n                        // because InvocationContext#getMethod() is expected to return null for lifecycle methods\n                        context.setMethod(null);\n                        return method.invoke(instance, context.getInvocationContext());\n                    } else if (this.changeMethod) {\n                        context.setMethod(method);\n                        return method.invoke(instance, context.getInvocationContext());\n                    } else {\n                        return method.invoke(instance, context.getInvocationContext());\n                    }\n                } finally {\n                    // reset any changed method on the interceptor context\n                    context.setMethod(oldMethod);\n                }\n            } else {\n                method.invoke(instance, null);\n                return context.proceed();\n            }\n        } catch (IllegalAccessException e) {\n            final IllegalAccessError n = new IllegalAccessError(e.getMessage());\n            n.setStackTrace(e.getStackTrace());\n            throw n;\n        } catch (InvocationTargetException e) {\n            throw Interceptors.rethrow(e.getCause());\n        }\n    }","commit_id":"07ee31bd0bcaa88000d4f334f198ecad3290e8e2","url":"https://github.com/wildfly/wildfly"},{"original_method":"ManagedReferenceLifecycleMethodInterceptor(final AtomicReference<ManagedReference> instanceRef, final Method method, final boolean changeMethod) {\n        this.changeMethod = changeMethod;\n        this.method = method;\n        this.instanceRef = instanceRef;\n        withContext = method.getParameterTypes().length == 1;\n    }","id":26750,"modified_method":"/**\n     * @param instanceRef\n     * @param method          The method on which the interceptor applies\n     * @param changeMethod    True if during the interceptor processing, the {@link org.jboss.invocation.InterceptorContext#getMethod()}\n     *                        is expected to return the passed <code>method<\/code>\n     * @param lifecycleMethod If the passed <code>method<\/code> is a lifecycle callback method. False otherwise\n     */\n    ManagedReferenceLifecycleMethodInterceptor(final AtomicReference<ManagedReference> instanceRef, final Method method, final boolean changeMethod, final boolean lifecycleMethod) {\n        this.changeMethod = changeMethod;\n        this.method = method;\n        this.lifecycleMethod = lifecycleMethod;\n        this.instanceRef = instanceRef;\n        withContext = method.getParameterTypes().length == 1;\n    }","commit_id":"07ee31bd0bcaa88000d4f334f198ecad3290e8e2","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Interceptor create(final InterceptorFactoryContext context) {\n        @SuppressWarnings(\"unchecked\")\n        final AtomicReference<ManagedReference> ref = (AtomicReference<ManagedReference>) context.getContextData().get(contextKey);\n        return new ManagedReferenceLifecycleMethodInterceptor(ref, method, changeMethod);\n    }","id":26751,"modified_method":"public Interceptor create(final InterceptorFactoryContext context) {\n        @SuppressWarnings(\"unchecked\")\n        final AtomicReference<ManagedReference> ref = (AtomicReference<ManagedReference>) context.getContextData().get(contextKey);\n        return new ManagedReferenceLifecycleMethodInterceptor(ref, method, changeMethod, this.lifecycleMethod);\n    }","commit_id":"07ee31bd0bcaa88000d4f334f198ecad3290e8e2","url":"https://github.com/wildfly/wildfly"},{"original_method":"ManagedReferenceLifecycleMethodInterceptorFactory(final Object contextKey, final Method method, final boolean changeMethod) {\n        this.contextKey = contextKey;\n        this.method = method;\n        this.changeMethod = changeMethod;\n    }","id":26752,"modified_method":"/**\n     * This is equivalent to calling <code>ManagedReferenceLifecycleMethodInterceptorFactory(Object, java.lang.reflect.Method, boolean, false)<\/code>\n     *\n     * @param contextKey\n     * @param method       The method for which the interceptor has to be created\n     * @param changeMethod True if during the interceptor processing, the {@link org.jboss.invocation.InterceptorContext#getMethod()}\n     *                     is expected to return the passed <code>method<\/code>\n     */\n    ManagedReferenceLifecycleMethodInterceptorFactory(final Object contextKey, final Method method, final boolean changeMethod) {\n        this(contextKey, method, changeMethod, false);\n    }","commit_id":"07ee31bd0bcaa88000d4f334f198ecad3290e8e2","url":"https://github.com/wildfly/wildfly"},{"original_method":"public MetricsHelper(Class<?> caller, CMetrics metrics,\n                       String qualifier, String method) {\n    this.classe = caller;\n    this.metrics = metrics;\n    this.startTime = System.currentTimeMillis();\n    this.setQualifier(qualifier);\n\n    this.scope = null;\n    this.setMethod(method);\n  }","id":26753,"modified_method":"public MetricsHelper(Class<?> caller, CMetrics metrics,\n                       String qualifier, String method) {\n    this.classe = caller;\n    this.metrics = metrics;\n    this.startTime = System.currentTimeMillis();\n    this.setQualifier(qualifier);\n\n    this.scope = null;\n    if (method != null) {\n      this.setMethod(method);\n    }\n  }","commit_id":"5f60a6c933fda9507bfb0efb68026bd1ea72d966","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n    public void test() throws Exception {\n        if (isJava16() && isJavaVendor(\"ibm\")) {\n            // does not test well on java6 with ibm\n            return;\n        }\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setNamespaceAware(true);\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        Document doc = db.parse(getClass().getClassLoader().getResourceAsStream(\"test-rest.xml\"));\n        Element elem = null;\n        NodeList nl = doc.getDocumentElement().getChildNodes();\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            if (node instanceof Element) {\n                elem = (Element) node;\n                break;\n            }\n        }\n        CamelNamespaceHandler.renameNamespaceRecursive(elem, CamelNamespaceHandler.BLUEPRINT_NS, CamelNamespaceHandler.SPRING_NS);\n\n        JAXBContext context = JAXBContext.newInstance(\"org.apache.camel.blueprint:\"\n                                                        + \"org.apache.camel:org.apache.camel.model:\"\n                                                        + \"org.apache.camel.model.config:\"\n                                                        + \"org.apache.camel.model.dataformat:\"\n                                                        + \"org.apache.camel.model.language:\"\n                                                        + \"org.apache.camel.model.loadbalancer:\"\n                                                        + \"org.apache.camel.model.rest\");\n        Unmarshaller unmarshaller = context.createUnmarshaller();\n        Object object = unmarshaller.unmarshal(elem);\n        assertNotNull(object);\n        assertTrue(object instanceof CamelContextFactoryBean);\n        assertNotNull(((CamelContextFactoryBean) object).getRoutes());\n        assertEquals(0, ((CamelContextFactoryBean) object).getRoutes().size());\n\n        CamelContextFactoryBean cfb = (CamelContextFactoryBean) object;\n        assertEquals(1, cfb.getRests().size());\n        assertEquals(2, cfb.getRests().get(0).getPaths().size());\n        assertEquals(\"/say/hello\", cfb.getRests().get(0).getPaths().get(0).getUri());\n        assertEquals(\"/say/bye\", cfb.getRests().get(0).getPaths().get(1).getUri());\n\n        assertEquals(1, cfb.getRests().get(0).getPaths().get(0).getVerbs().size());\n        assertEquals(2, cfb.getRests().get(0).getPaths().get(1).getVerbs().size());\n        assertEquals(\"get\", cfb.getRests().get(0).getPaths().get(0).getVerbs().get(0).getMethod());\n        assertEquals(\"get\", cfb.getRests().get(0).getPaths().get(1).getVerbs().get(0).getMethod());\n        assertEquals(\"post\", cfb.getRests().get(0).getPaths().get(1).getVerbs().get(1).getMethod());\n    }","id":26754,"modified_method":"@Test\n    public void test() throws Exception {\n        if (isJava16() && isJavaVendor(\"ibm\")) {\n            // does not test well on java6 with ibm\n            return;\n        }\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setNamespaceAware(true);\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        Document doc = db.parse(getClass().getClassLoader().getResourceAsStream(\"test-rest.xml\"));\n        Element elem = null;\n        NodeList nl = doc.getDocumentElement().getChildNodes();\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            if (node instanceof Element) {\n                elem = (Element) node;\n                break;\n            }\n        }\n        CamelNamespaceHandler.renameNamespaceRecursive(elem, CamelNamespaceHandler.BLUEPRINT_NS, CamelNamespaceHandler.SPRING_NS);\n\n        JAXBContext context = JAXBContext.newInstance(\"org.apache.camel.blueprint:\"\n                                                        + \"org.apache.camel:org.apache.camel.model:\"\n                                                        + \"org.apache.camel.model.config:\"\n                                                        + \"org.apache.camel.model.dataformat:\"\n                                                        + \"org.apache.camel.model.language:\"\n                                                        + \"org.apache.camel.model.loadbalancer:\"\n                                                        + \"org.apache.camel.model.rest\");\n        Unmarshaller unmarshaller = context.createUnmarshaller();\n        Object object = unmarshaller.unmarshal(elem);\n        assertNotNull(object);\n        assertTrue(object instanceof CamelContextFactoryBean);\n        assertNotNull(((CamelContextFactoryBean) object).getRoutes());\n        assertEquals(0, ((CamelContextFactoryBean) object).getRoutes().size());\n\n        CamelContextFactoryBean cfb = (CamelContextFactoryBean) object;\n        assertEquals(1, cfb.getRests().size());\n        assertEquals(2, cfb.getRests().get(0).getPaths().size());\n        assertEquals(\"/say/hello\", cfb.getRests().get(0).getPaths().get(0).getUri());\n        assertEquals(\"/say/bye\", cfb.getRests().get(0).getPaths().get(1).getUri());\n\n        assertEquals(1, cfb.getRests().get(0).getPaths().get(0).getVerbs().size());\n        assertEquals(2, cfb.getRests().get(0).getPaths().get(1).getVerbs().size());\n        assertEquals(\"get\", cfb.getRests().get(0).getPaths().get(0).getVerbs().get(0).asVerb());\n        assertEquals(\"get\", cfb.getRests().get(0).getPaths().get(1).getVerbs().get(0).asVerb());\n        assertEquals(\"post\", cfb.getRests().get(0).getPaths().get(1).getVerbs().get(1).asVerb());\n    }","commit_id":"571b1345c2bf3612eb9f96c8ee29b75bf02b752a","url":"https://github.com/apache/camel"},{"original_method":"public void testFromRestModel() throws Exception {\n        assertEquals(getExpectedNumberOfRoutes(), context.getRoutes().size());\n\n        RestDefinition rest = context.getRestDefinitions().get(0);\n        assertNotNull(rest);\n\n        assertEquals(2, rest.getPaths().size());\n        PathDefinition path = rest.getPaths().get(0);\n        assertEquals(\"/say/hello\", path.getUri());\n        ToDefinition to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(0).getOutputs().get(0));\n        assertEquals(\"mock:hello\", to.getUri());\n\n        path = rest.getPaths().get(1);\n        assertEquals(\"/say/bye\", path.getUri());\n        assertEquals(\"application/json\", path.getVerbs().get(1).getAccept());\n        to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(1).getOutputs().get(0));\n        assertEquals(\"mock:bye\", to.getUri());\n\n        // the rest becomes routes and the input is a seda endpoint created by the DummyRestConsumerFactory\n        getMockEndpoint(\"mock:update\").expectedMessageCount(1);\n        template.sendBody(\"seda:post-say\", \"I was here\");\n        assertMockEndpointsSatisfied();\n\n        String out = template.requestBody(\"seda:get-say-hello\", \"Me\", String.class);\n        assertEquals(\"Hello World\", out);\n        String out2 = template.requestBody(\"seda:get-say-bye\", \"Me\", String.class);\n        assertEquals(\"Bye World\", out2);\n    }","id":26755,"modified_method":"public void testFromRestModel() throws Exception {\n        assertEquals(getExpectedNumberOfRoutes(), context.getRoutes().size());\n\n        RestDefinition rest = context.getRestDefinitions().get(0);\n        assertNotNull(rest);\n\n        assertEquals(2, rest.getPaths().size());\n        PathDefinition path = rest.getPaths().get(0);\n        assertEquals(\"/say/hello\", path.getUri());\n        ToDefinition to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(0).getOutputs().get(0));\n        assertEquals(\"mock:hello\", to.getUri());\n\n        path = rest.getPaths().get(1);\n        assertEquals(\"/say/bye\", path.getUri());\n        assertEquals(\"application/json\", path.getVerbs().get(0).getAccept());\n        to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(0).getOutputs().get(0));\n        assertEquals(\"mock:bye\", to.getUri());\n\n        // the rest becomes routes and the input is a seda endpoint created by the DummyRestConsumerFactory\n        getMockEndpoint(\"mock:update\").expectedMessageCount(1);\n        template.sendBody(\"seda:post-say-bye\", \"I was here\");\n        assertMockEndpointsSatisfied();\n\n        String out = template.requestBody(\"seda:get-say-hello\", \"Me\", String.class);\n        assertEquals(\"Hello World\", out);\n        String out2 = template.requestBody(\"seda:get-say-bye\", \"Me\", String.class);\n        assertEquals(\"Bye World\", out2);\n    }","commit_id":"571b1345c2bf3612eb9f96c8ee29b75bf02b752a","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testFromRestModel() throws Exception {\n        assertEquals(getExpectedNumberOfRoutes(), context.getRoutes().size());\n\n        RestDefinition rest = context.getRestDefinitions().get(0);\n        assertNotNull(rest);\n\n        assertEquals(2, rest.getPaths().size());\n        PathDefinition path = rest.getPaths().get(0);\n        assertEquals(\"/say/hello\", path.getUri());\n        ToDefinition to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(0).getOutputs().get(0));\n        assertEquals(\"mock:hello\", to.getUri());\n\n        path = rest.getPaths().get(1);\n        assertEquals(\"/say/bye\", path.getUri());\n        assertEquals(\"application/json\", path.getVerbs().get(1).getAccept());\n        to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(1).getOutputs().get(0));\n        assertEquals(\"mock:bye\", to.getUri());\n\n        // the rest becomes routes and the input is a seda endpoint created by the DummyRestConsumerFactory\n        getMockEndpoint(\"mock:update\").expectedMessageCount(1);\n        template.sendBody(\"seda:post-say\", \"I was here\");\n        assertMockEndpointsSatisfied();\n\n        String out = template.requestBody(\"seda:get-say-hello\", \"Me\", String.class);\n        assertEquals(\"Hello World\", out);\n        String out2 = template.requestBody(\"seda:get-say-bye\", \"Me\", String.class);\n        assertEquals(\"Bye World\", out2);\n    }","id":26756,"modified_method":"@Test\n    public void testFromRestModel() throws Exception {\n        assertEquals(getExpectedNumberOfRoutes(), context.getRoutes().size());\n\n        RestDefinition rest = context.getRestDefinitions().get(0);\n        assertNotNull(rest);\n\n        assertEquals(2, rest.getPaths().size());\n        PathDefinition path = rest.getPaths().get(0);\n        assertEquals(\"/say/hello\", path.getUri());\n        ToDefinition to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(0).getOutputs().get(0));\n        assertEquals(\"mock:hello\", to.getUri());\n\n        path = rest.getPaths().get(1);\n        assertEquals(\"/say/bye\", path.getUri());\n        assertEquals(\"application/json\", path.getVerbs().get(0).getAccept());\n        to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(0).getOutputs().get(0));\n        assertEquals(\"mock:bye\", to.getUri());\n\n        // the rest becomes routes and the input is a seda endpoint created by the DummyRestConsumerFactory\n        getMockEndpoint(\"mock:update\").expectedMessageCount(1);\n        template.sendBody(\"seda:post-say-bye\", \"I was here\");\n        assertMockEndpointsSatisfied();\n\n        String out = template.requestBody(\"seda:get-say-hello\", \"Me\", String.class);\n        assertEquals(\"Hello World\", out);\n        String out2 = template.requestBody(\"seda:get-say-bye\", \"Me\", String.class);\n        assertEquals(\"Bye World\", out2);\n    }","commit_id":"571b1345c2bf3612eb9f96c8ee29b75bf02b752a","url":"https://github.com/apache/camel"},{"original_method":"public void testFromRestModel() throws Exception {\n        assertEquals(getExpectedNumberOfRoutes(), context.getRoutes().size());\n\n        RestDefinition rest = context.getRestDefinitions().get(0);\n        assertNotNull(rest);\n\n        assertEquals(2, rest.getPaths().size());\n        PathDefinition path = rest.getPaths().get(0);\n        assertEquals(\"/say/hello\", path.getUri());\n        ToDefinition to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(0).getOutputs().get(0));\n        assertEquals(\"mock:hello\", to.getUri());\n\n        path = rest.getPaths().get(1);\n        assertEquals(\"/say/bye\", path.getUri());\n        assertEquals(\"application/json\", path.getVerbs().get(1).getAccept());\n        to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(1).getOutputs().get(0));\n        assertEquals(\"mock:bye\", to.getUri());\n\n        // the rest becomes routes and the input is a seda endpoint created by the DummyRestConsumerFactory\n        getMockEndpoint(\"mock:update\").expectedMessageCount(1);\n        template.sendBody(\"seda:post-say\", \"I was here\");\n        assertMockEndpointsSatisfied();\n\n        String out = template.requestBody(\"seda:get-say-hello\", \"Me\", String.class);\n        assertEquals(\"Hello World\", out);\n        String out2 = template.requestBody(\"seda:get-say-bye\", \"Me\", String.class);\n        assertEquals(\"Bye World\", out2);\n    }","id":26757,"modified_method":"public void testFromRestModel() throws Exception {\n        assertEquals(getExpectedNumberOfRoutes(), context.getRoutes().size());\n\n        RestDefinition rest = context.getRestDefinitions().get(0);\n        assertNotNull(rest);\n\n        assertEquals(2, rest.getPaths().size());\n        PathDefinition path = rest.getPaths().get(0);\n        assertEquals(\"/say/hello\", path.getUri());\n        ToDefinition to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(0).getOutputs().get(0));\n        assertEquals(\"direct:hello\", to.getUri());\n\n        path = rest.getPaths().get(1);\n        assertEquals(\"/say/bye\", path.getUri());\n        assertEquals(\"application/json\", path.getVerbs().get(0).getAccept());\n        to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(0).getOutputs().get(0));\n        assertEquals(\"direct:bye\", to.getUri());\n\n        // the rest becomes routes and the input is a seda endpoint created by the DummyRestConsumerFactory\n        getMockEndpoint(\"mock:update\").expectedMessageCount(1);\n        template.sendBody(\"seda:post-say-bye\", \"I was here\");\n        assertMockEndpointsSatisfied();\n\n        String out = template.requestBody(\"seda:get-say-hello\", \"Me\", String.class);\n        assertEquals(\"Hello World\", out);\n        String out2 = template.requestBody(\"seda:get-say-bye\", \"Me\", String.class);\n        assertEquals(\"Bye World\", out2);\n    }","commit_id":"571b1345c2bf3612eb9f96c8ee29b75bf02b752a","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testFromRestModel() throws Exception {\n        assertEquals(getExpectedNumberOfRoutes(), context.getRoutes().size());\n\n        RestDefinition rest = context.getRestDefinitions().get(0);\n        assertNotNull(rest);\n\n        assertEquals(2, rest.getPaths().size());\n        PathDefinition path = rest.getPaths().get(0);\n        assertEquals(\"/say/hello\", path.getUri());\n        ToDefinition to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(0).getOutputs().get(0));\n        assertEquals(\"mock:hello\", to.getUri());\n\n        path = rest.getPaths().get(1);\n        assertEquals(\"/say/bye\", path.getUri());\n        assertEquals(\"application/json\", path.getVerbs().get(1).getAccept());\n        to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(1).getOutputs().get(0));\n        assertEquals(\"mock:bye\", to.getUri());\n\n        // the rest becomes routes and the input is a seda endpoint created by the DummyRestConsumerFactory\n        getMockEndpoint(\"mock:update\").expectedMessageCount(1);\n        template.sendBody(\"seda:post-say\", \"I was here\");\n        assertMockEndpointsSatisfied();\n\n        String out = template.requestBody(\"seda:get-say-hello\", \"Me\", String.class);\n        assertEquals(\"Hello World\", out);\n        String out2 = template.requestBody(\"seda:get-say-bye\", \"Me\", String.class);\n        assertEquals(\"Bye World\", out2);\n    }","id":26758,"modified_method":"@Test\n    public void testFromRestModel() throws Exception {\n        assertEquals(getExpectedNumberOfRoutes(), context.getRoutes().size());\n\n        RestDefinition rest = context.getRestDefinitions().get(0);\n        assertNotNull(rest);\n\n        assertEquals(2, rest.getPaths().size());\n        PathDefinition path = rest.getPaths().get(0);\n        assertEquals(\"/say/hello\", path.getUri());\n        ToDefinition to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(0).getOutputs().get(0));\n        assertEquals(\"direct:hello\", to.getUri());\n\n        path = rest.getPaths().get(1);\n        assertEquals(\"/say/bye\", path.getUri());\n        assertEquals(\"application/json\", path.getVerbs().get(0).getAccept());\n        to = assertIsInstanceOf(ToDefinition.class, path.getVerbs().get(0).getOutputs().get(0));\n        assertEquals(\"direct:bye\", to.getUri());\n\n        // the rest becomes routes and the input is a seda endpoint created by the DummyRestConsumerFactory\n        getMockEndpoint(\"mock:update\").expectedMessageCount(1);\n        template.sendBody(\"seda:post-say-bye\", \"I was here\");\n        assertMockEndpointsSatisfied();\n\n        String out = template.requestBody(\"seda:get-say-hello\", \"Me\", String.class);\n        assertEquals(\"Hello World\", out);\n        String out2 = template.requestBody(\"seda:get-say-bye\", \"Me\", String.class);\n        assertEquals(\"Bye World\", out2);\n    }","commit_id":"571b1345c2bf3612eb9f96c8ee29b75bf02b752a","url":"https://github.com/apache/camel"},{"original_method":"public void testFindComponentsInClasspath() throws Exception {\n        // JMX tests dont work well on AIX CI servers (hangs them)\n        if (isPlatform(\"aix\")) {\n            return;\n        }\n\n        MBeanServer mbeanServer = getMBeanServer();\n\n        ObjectName on = ObjectName.getInstance(\"org.apache.camel:context=19-camel-1,type=context,name=\\\"camel-1\\\"\");\n\n        assertTrue(\"Should be registered\", mbeanServer.isRegistered(on));\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Properties> info = (Map<String, Properties>) mbeanServer.invoke(on, \"findComponents\", null, null);\n        assertNotNull(info);\n\n        assertEquals(22, info.size());\n        Properties prop = info.get(\"seda\");\n        assertNotNull(prop);\n        assertEquals(\"seda\", prop.get(\"name\"));\n        assertEquals(\"org.apache.camel\", prop.get(\"groupId\"));\n        assertEquals(\"camel-core\", prop.get(\"artifactId\"));\n    }","id":26759,"modified_method":"public void testFindComponentsInClasspath() throws Exception {\n        // JMX tests dont work well on AIX CI servers (hangs them)\n        if (isPlatform(\"aix\")) {\n            return;\n        }\n\n        MBeanServer mbeanServer = getMBeanServer();\n\n        ObjectName on = ObjectName.getInstance(\"org.apache.camel:context=19-camel-1,type=context,name=\\\"camel-1\\\"\");\n\n        assertTrue(\"Should be registered\", mbeanServer.isRegistered(on));\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Properties> info = (Map<String, Properties>) mbeanServer.invoke(on, \"findComponents\", null, null);\n        assertNotNull(info);\n\n        assertEquals(23, info.size());\n        Properties prop = info.get(\"seda\");\n        assertNotNull(prop);\n        assertEquals(\"seda\", prop.get(\"name\"));\n        assertEquals(\"org.apache.camel\", prop.get(\"groupId\"));\n        assertEquals(\"camel-core\", prop.get(\"artifactId\"));\n    }","commit_id":"571b1345c2bf3612eb9f96c8ee29b75bf02b752a","url":"https://github.com/apache/camel"},{"original_method":"public void testFromRestModel() throws Exception {\n        // JMX tests dont work well on AIX CI servers (hangs them)\n        if (isPlatform(\"aix\")) {\n            return;\n        }\n\n        MBeanServer mbeanServer = getMBeanServer();\n\n        ObjectName on = ObjectName.getInstance(\"org.apache.camel:context=camel-1,type=context,name=\\\"camel-1\\\"\");\n\n        String xml = (String) mbeanServer.invoke(on, \"dumpRestsAsXml\", null, null);\n        assertNotNull(xml);\n        log.info(xml);\n\n        assertTrue(xml.contains(\"rests\"));\n        assertTrue(xml.contains(\"rest\"));\n        assertTrue(xml.contains(\"<path uri=\\\"/say\\\">\"));\n        assertTrue(xml.contains(\"<get method=\\\"get\\\" uri=\\\"/hello\\\">\"));\n        assertTrue(xml.contains(\"<get method=\\\"get\\\" uri=\\\"/bye\\\">\"));\n        assertTrue(xml.contains(\"<post method=\\\"post\\\">\"));\n\n        String xml2 = (String) mbeanServer.invoke(on, \"dumpRoutesAsXml\", null, null);\n        log.info(xml2);\n        // and we should have rest in the routes that indicate its from a rest dsl\n        assertTrue(xml2.contains(\"rest=\\\"true\\\"\"));\n    }","id":26760,"modified_method":"public void testFromRestModel() throws Exception {\n        // JMX tests dont work well on AIX CI servers (hangs them)\n        if (isPlatform(\"aix\")) {\n            return;\n        }\n\n        MBeanServer mbeanServer = getMBeanServer();\n\n        ObjectName on = ObjectName.getInstance(\"org.apache.camel:context=camel-1,type=context,name=\\\"camel-1\\\"\");\n\n        String xml = (String) mbeanServer.invoke(on, \"dumpRestsAsXml\", null, null);\n        assertNotNull(xml);\n        log.info(xml);\n\n        assertTrue(xml.contains(\"rests\"));\n        assertTrue(xml.contains(\"rest\"));\n        assertTrue(xml.contains(\"<path uri=\\\"/say/hello\\\">\"));\n        assertTrue(xml.contains(\"<path uri=\\\"/say/bye\\\">\"));\n        assertTrue(xml.contains(\"<get>\"));\n        assertTrue(xml.contains(\"<post>\"));\n\n        String xml2 = (String) mbeanServer.invoke(on, \"dumpRoutesAsXml\", null, null);\n        log.info(xml2);\n        // and we should have rest in the routes that indicate its from a rest dsl\n        assertTrue(xml2.contains(\"rest=\\\"true\\\"\"));\n    }","commit_id":"571b1345c2bf3612eb9f96c8ee29b75bf02b752a","url":"https://github.com/apache/camel"},{"original_method":"private PathDefinition addVerb(String verb, String url) {\n        VerbDefinition answer = new VerbDefinition();\n        answer.setMethod(verb);\n        answer.setPath(this);\n        getVerbs().add(answer);\n        return this;\n    }","id":26761,"modified_method":"private PathDefinition addVerb(String verb, String url) {\n        VerbDefinition answer;\n\n        if (\"get\".equals(verb)) {\n            answer = new GetVerbDefinition();\n        } else if (\"post\".equals(verb)) {\n            answer = new PostVerbDefinition();\n        } else if (\"delete\".equals(verb)) {\n            answer = new DeleteVerbDefinition();\n        } else if (\"head\".equals(verb)) {\n            answer = new HeadVerbDefinition();\n        } else if (\"put\".equals(verb)) {\n            answer = new PutVerbDefinition();\n        } else {\n            answer = new VerbDefinition();\n            answer.setMethod(verb);\n        }\n\n        answer.setPath(this);\n        getVerbs().add(answer);\n        return this;\n    }","commit_id":"571b1345c2bf3612eb9f96c8ee29b75bf02b752a","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Transforms this REST definition into a list of {@link org.apache.camel.model.RouteDefinition} which\n     * Camel routing engine can add and run. This allows us to define REST services using this\n     * REST DSL and turn those into regular Camel routes.\n     */\n    public List<RouteDefinition> asRouteDefinition(ModelCamelContext camelContext) throws Exception {\n        List<RouteDefinition> answer = new ArrayList<RouteDefinition>();\n\n        for (PathDefinition path : getPaths()) {\n            String uri = path.getUri();\n            for (VerbDefinition verb : path.getVerbs()) {\n                String from = \"rest:\" + verb.getMethod() + \":\" + uri + (getComponent() != null ? \"?componentName=\" + getComponent() : \"\");\n                RouteDefinition route = new RouteDefinition();\n                route.fromRest(from);\n                answer.add(route);\n                route.getOutputs().addAll(verb.getOutputs());\n            }\n        }\n\n        return answer;\n    }","id":26762,"modified_method":"/**\n     * Transforms this REST definition into a list of {@link org.apache.camel.model.RouteDefinition} which\n     * Camel routing engine can add and run. This allows us to define REST services using this\n     * REST DSL and turn those into regular Camel routes.\n     */\n    public List<RouteDefinition> asRouteDefinition(ModelCamelContext camelContext) throws Exception {\n        List<RouteDefinition> answer = new ArrayList<RouteDefinition>();\n\n        for (PathDefinition path : getPaths()) {\n            String uri = path.getUri();\n            for (VerbDefinition verb : path.getVerbs()) {\n                String from = \"rest:\" + verb.asVerb() + \":\" + uri + (getComponent() != null ? \"?componentName=\" + getComponent() : \"\");\n                RouteDefinition route = new RouteDefinition();\n                route.fromRest(from);\n                answer.add(route);\n                route.getOutputs().addAll(verb.getOutputs());\n            }\n        }\n\n        return answer;\n    }","commit_id":"571b1345c2bf3612eb9f96c8ee29b75bf02b752a","url":"https://github.com/apache/camel"},{"original_method":"public ASMAnnotation(AnnotationNode node) {\n    myType = TypeUtil.fromDescriptor(node.desc);\n    if (node.values != null) {\n      for (int i = 0; i < node.values.size() / 2; i += 2) {\n        Object key = node.values.get(i * 2);\n        Object value = processValue(node.values.get(i * 2 + 1));\n\n\n        myValues.put(key.toString(), value);\n      }\n    }\n  }","id":26763,"modified_method":"public ASMAnnotation(AnnotationNode node) {\n    myType = TypeUtil.fromDescriptor(node.desc);\n\n    if (node.values != null) {\n      myValues = new LinkedHashMap<String, Object>(node.values.size() / 2);\n      for (int i = 0; i < node.values.size() / 2; i += 2) {\n        Object key = node.values.get(i * 2);\n        Object value = processValue(node.values.get(i * 2 + 1));\n\n        myValues.put(key.toString(), value);\n      }\n    }\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Map<String, Object> getValues() {\n    return Collections.unmodifiableMap(myValues);\n  }","id":26764,"modified_method":"public Map<String, Object> getValues() {\n    return myValues == null ? Collections.<String,Object>emptyMap() : Collections.unmodifiableMap(myValues);\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public Set<String> getSubpackages(String namespace) {\n    Set<String> result = new HashSet<String>(0);\n\n    for (IClassPathItem item : myChildren) {\n      result.addAll(item.getSubpackages(namespace));\n    }\n\n    return result;\n  }","id":26765,"modified_method":"public void collectSubpackages(Set<String> subpackages, String namespace) {\n    for (IClassPathItem item : myChildren) {\n      if(item instanceof AbstractClassPathItem) {\n        ((AbstractClassPathItem)item).collectSubpackages(subpackages, namespace);\n      } else {\n        subpackages.addAll(item.getSubpackages(namespace));\n      }\n    }\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public Set<String> getAvailableClasses(String namespace) {\n    Set<String> result = new HashSet<String>(0);\n    for (IClassPathItem item : myChildren) {\n      result.addAll(item.getAvailableClasses(namespace));\n    }\n    return result;\n  }","id":26766,"modified_method":"public void collectAvailableClasses(Set<String> classes, String namespace) {\n    for (IClassPathItem item : myChildren) {\n      if(item instanceof AbstractClassPathItem) {\n        ((AbstractClassPathItem)item).collectAvailableClasses(classes, namespace);\n      } else {\n        classes.addAll(item.getAvailableClasses(namespace));\n      }\n    }\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public Set<String> getSubpackages(String namespace) {\n    if (!mySubpackagesCache.containsKey(namespace)) {\n      buildCacheFor(namespace);\n    }\n\n    Set<String> result = mySubpackagesCache.get(namespace);\n    if (result == null) {\n      return Collections.emptySet();\n    }\n\n    return Collections.unmodifiableSet(result);\n  }","id":26767,"modified_method":"public void collectSubpackages(Set<String> subpackages, String namespace) {\n    if (!mySubpackagesCache.containsKey(namespace)) {\n      buildCacheFor(namespace);\n    }\n\n    Set<String> result = mySubpackagesCache.get(namespace);\n    if (result != null) {\n      subpackages.addAll(result);\n    }\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public byte[] getClass(String name) {\n    String namespace = NameUtil.namespaceFromLongName(name);\n    String shortname = NameUtil.shortNameFromLongName(name);\n\n    if (!myAvailableClassesCache.containsKey(namespace)) {\n      buildCacheFor(namespace);\n    }\n\n    Set<String> classes = myAvailableClassesCache.get(namespace);\n    if (classes == null\n      || !classes.contains(shortname)) {\n      return null;\n    }\n\n    String path = myClassPath + File.separatorChar + name.replace('.', File.separatorChar) + \".class\";\n    IFile file = FileSystem.getFile(path);\n    try {\n      byte[] result = new byte[(int) file.length()];\n      InputStream inp = null;\n      try {\n        inp = file.openInputStream();\n        ReadUtil.read(result, inp);\n      } finally {\n        if (inp != null) {\n          inp.close();\n        }\n      }\n\n      return result;\n    } catch (IOException e) {\n      return null;\n    }\n  }","id":26768,"modified_method":"public byte[] getClass(String name) {\n    String namespace = NameUtil.namespaceFromLongName(name);\n    String shortname = NameUtil.shortNameFromLongName(name);\n\n    if (!myAvailableClassesCache.containsKey(namespace)) {\n      buildCacheFor(namespace);\n    }\n\n    Set<String> classes = myAvailableClassesCache.get(namespace);\n    if (classes == null\n      || !classes.contains(shortname)) {\n      return null;\n    }\n\n    String path = myClassPath + File.separatorChar + name.replace('.', File.separatorChar) + MPSExtentions.DOT_CLASSFILE;\n    IFile file = FileSystem.getFile(path);\n    try {\n      byte[] result = new byte[(int) file.length()];\n      InputStream inp = null;\n      try {\n        inp = file.openInputStream();\n        ReadUtil.read(result, inp);\n      } finally {\n        if (inp != null) {\n          inp.close();\n        }\n      }\n\n      return result;\n    } catch (IOException e) {\n      return null;\n    }\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public long getClassesTimestamp(String namespace) {\n    IFile dir = getModelDir(namespace);\n    long result = dir.lastModified();\n    if (dir.exists()) {\n      for (IFile file : dir.list()) {\n        if (file.getName().endsWith(\".class\")) {\n          result = Math.max(result, file.lastModified());\n        }\n      }\n    }\n    return result;\n  }","id":26769,"modified_method":"public long getClassesTimestamp(String namespace) {\n    IFile dir = getModelDir(namespace);\n    long result = dir.lastModified();\n    if (dir.exists()) {\n      for (IFile file : dir.list()) {\n        if (file.getName().endsWith(MPSExtentions.DOT_CLASSFILE)) {\n          result = Math.max(result, file.lastModified());\n        }\n      }\n    }\n    return result;\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public Set<String> getAvailableClasses(String namespace) {\n    if (!myAvailableClassesCache.containsKey(namespace)) {\n      buildCacheFor(namespace);\n    }\n\n    Set<String> result = myAvailableClassesCache.get(namespace);\n    if (result == null) {\n      return Collections.emptySet();\n    }\n\n    return Collections.unmodifiableSet(result);\n  }","id":26770,"modified_method":"public void collectAvailableClasses(Set<String> classes, String namespace) {\n    if (!myAvailableClassesCache.containsKey(namespace)) {\n      buildCacheFor(namespace);\n    }\n\n    Set<String> result = myAvailableClassesCache.get(namespace);\n    if (result != null) {\n      classes.addAll(result);\n    }\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void buildCacheFor(String namespace) {\n    Set<String> subpacks = new HashSet<String>(0);\n    Set<String> classes = new HashSet<String>(0);\n    IFile dir = getModelDir(namespace);\n\n    List<IFile> files = dir.list();\n    if (files != null) {\n      for (IFile file : files) {\n        String name = file.getName();\n        if (!name.endsWith(MPSExtentions.DOT_CLASSFILE)) { //isDirectory is quite expensive operation\n          if (file.isDirectory()) {\n            if (namespace.length() > 0) {\n              subpacks.add(namespace + \".\" + name);\n            } else {\n              subpacks.add(namespace + name);\n            }\n          } \n        }\n\n        if (name.endsWith(\".class\")) {\n          classes.add(name.substring(0, name.length() - \".class\".length()));\n        }\n      }\n    }\n\n    mySubpackagesCache.put(namespace, subpacks.isEmpty() ? null : subpacks);\n    myAvailableClassesCache.put(namespace, classes.isEmpty() ? null : classes);\n  }","id":26771,"modified_method":"private void buildCacheFor(String namespace) {\n    Set<String> subpacks = null;\n    Set<String> classes = null;\n    IFile dir = getModelDir(namespace);\n\n    List<IFile> files = dir.list();\n    if (files != null) {\n      for (IFile file : files) {\n        String name = file.getName();\n        if (name.endsWith(MPSExtentions.DOT_CLASSFILE)) { //isDirectory is quite expensive operation\n          if(classes == null) {\n            classes = new HashSet<String>(files.size());\n          }\n          classes.add(name.substring(0, name.length() - MPSExtentions.DOT_CLASSFILE.length()));\n        } else {\n          if (file.isDirectory()) {\n            if(subpacks == null) {\n              subpacks = new HashSet<String>();\n            }\n            subpacks.add(namespace.length() > 0 ? namespace + \".\" + name : name);\n          }\n        }\n      }\n    }\n\n    mySubpackagesCache.put(namespace, subpacks);\n    myAvailableClassesCache.put(namespace, classes);\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void buildCaches() {\n    Iterable<? extends ZipEntry> entries = CollectionUtil.asIterable(myZipFile.entries());\n\n    for (ZipEntry entry : entries) {\n      if (entry.isDirectory()) {\n        String name = entry.getName();\n        if (name.endsWith(\"/\")) {\n          name = name.substring(0, name.length() - 1);\n        }\n\n        String pack = name.replace('/', '.');\n        buildPackageCaches(pack);\n      } else {\n        String name = entry.getName();\n\n        if (!name.endsWith(\".class\")) continue;\n\n        int packEnd = name.lastIndexOf('/');\n        String pack;\n        String className;\n        if (packEnd == -1) {\n          pack = \"\";\n          className = name.substring(0, name.length() - \".class\".length());\n        } else {\n          pack = packEnd > 0 ? name.substring(0, packEnd).replace('/', '.') : name;\n          className = name.substring(packEnd + 1, name.length() - \".class\".length());\n        }\n\n        buildPackageCaches(pack);\n        getClassesSetFor(pack).add(className);\n\n        if (pack.length() > 0) {\n          myEntries.put(pack + \".\" + className, entry);\n        } else {\n          myEntries.put(className, entry);\n        }\n      }\n    }\n  }","id":26772,"modified_method":"private void buildCaches() {\n    Iterable<? extends ZipEntry> entries = CollectionUtil.asIterable(myZipFile.entries());\n\n    for (ZipEntry entry : entries) {\n      if (entry.isDirectory()) {\n        String name = entry.getName();\n        if (name.endsWith(\"/\")) {\n          name = name.substring(0, name.length() - 1);\n        }\n\n        String pack = name.replace('/', '.');\n        buildPackageCaches(pack);\n      } else {\n        String name = entry.getName();\n\n        if (!name.endsWith(MPSExtentions.DOT_CLASSFILE)) continue;\n\n        int packEnd = name.lastIndexOf('/');\n        String pack;\n        String className;\n        if (packEnd == -1) {\n          pack = \"\";\n          className = name.substring(0, name.length() - MPSExtentions.DOT_CLASSFILE.length());\n        } else {\n          pack = packEnd > 0 ? name.substring(0, packEnd).replace('/', '.') : name;\n          className = name.substring(packEnd + 1, name.length() - \".class\".length());\n        }\n\n        buildPackageCaches(pack);\n        getClassesSetFor(pack).add(className);\n\n        if (pack.length() > 0) {\n          myEntries.put(pack + \".\" + className, entry);\n        } else {\n          myEntries.put(className, entry);\n        }\n      }\n    }\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public Set<String> getSubpackages(String namespace) {\n    return Collections.unmodifiableSet(getSubpackagesSetFor(namespace));\n  }","id":26773,"modified_method":"public void collectSubpackages(Set<String> subpackages, String namespace) {\n    subpackages.addAll(getSubpackagesSetFor(namespace));\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Set<String> getClassesSetFor(String pack) {\n    if (!myClasses.containsKey(pack)) {\n      myClasses.put(pack, new HashSet<String>(0));\n    }\n    return myClasses.get(pack);\n  }","id":26774,"modified_method":"private Set<String> getClassesSetFor(String pack) {\n    if (!myClasses.containsKey(pack)) {\n      myClasses.put(pack, new HashSet<String>());\n    }\n    return myClasses.get(pack);\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public Set<String> getAvailableClasses(String namespace) {\n    return Collections.unmodifiableSet(getClassesSetFor(namespace));\n  }","id":26775,"modified_method":"public void collectAvailableClasses(Set<String> classes, String namespace) {\n    classes.addAll(getClassesSetFor(namespace));\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Set<String> getSubpackagesSetFor(String pack) {\n    if (!mySubpackages.containsKey(pack)) {\n      mySubpackages.put(pack, new HashSet<String>(0));\n    }\n    return mySubpackages.get(pack);\n  }","id":26776,"modified_method":"private Set<String> getSubpackagesSetFor(String pack) {\n    if (!mySubpackages.containsKey(pack)) {\n      mySubpackages.put(pack, new HashSet<String>());\n    }\n    return mySubpackages.get(pack);\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Map<IModule, List<SModel>> getLanguageModels(MPSProject project, Language language) {\n    Map<IModule, List<SModel>> result = new HashMap<IModule, List<SModel>>();\n    result.put(language, getLanguageModelsList(project, language));\n    return result;\n  }","id":26777,"modified_method":"public static Map<IModule, List<SModel>> getLanguageModels(MPSProject project, Language language) {\n    return Collections.<IModule, List<SModel>>singletonMap(language, getLanguageModelsList(project, language));\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Map<IModule, List<SModel>> getLanguageAndItsExtendingLanguageModels(MPSProject project, Language language) {\n    Map<IModule, List<SModel>> result = new LinkedHashMap<IModule, List<SModel>>();\n\n    final Set<Language> langs = new LinkedHashSet<Language>();\n    langs.add(language);\n    langs.addAll(MPSModuleRepository.getInstance().getAllExtendingLanguages(language));\n\n    for (Language l : langs) {\n      result.put(l, getLanguageModelsList(project, l));\n    }\n\n    return result;\n  }","id":26778,"modified_method":"public static Map<IModule, List<SModel>> getLanguageAndItsExtendingLanguageModels(MPSProject project, Language language) {\n    Set<Language> extendingLangs =  MPSModuleRepository.getInstance().getAllExtendingLanguages(language);\n    Map<IModule, List<SModel>> result = new LinkedHashMap<IModule, List<SModel>>(extendingLangs.size() + 1);\n    result.put(language, getLanguageModelsList(project, language));\n    for (Language l : extendingLangs) {\n      if(!l.equals(language)) {\n        result.put(l, getLanguageModelsList(project, l));\n      }\n    }\n    return result;\n  }","commit_id":"a227de3a3be292d63ceea355fa1a2026e9b4ba1a","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Initializes all additional resource types stored in the modules.<p>\n     * \n     * @param cms an initialized OpenCms user context with \"module manager\" role permissions\n     * \n     * @throws CmsRoleViolationException in case the provided OpenCms user context did not have \"module manager\" role permissions\n     * @throws CmsConfigurationException in case of duplicate resource types in the configuration\n     */\n    public synchronized void initialize(CmsObject cms) throws CmsRoleViolationException, CmsConfigurationException {\n\n        if (OpenCms.getRunLevel() > OpenCms.RUNLEVEL_1_CORE_OBJECT) {\n            // some simple test cases don't require this check       \n            OpenCms.getRoleManager().checkRole(cms, CmsRole.DATABASE_MANAGER);\n        }\n\n        // initalize the resource types\n        initResourceTypes();\n\n        // call initialize method on all resource types\n        Iterator i = m_configuration.getResourceTypeList().iterator();\n        while (i.hasNext()) {\n            I_CmsResourceType type = (I_CmsResourceType)i.next();\n            type.initialize(cms);\n        }\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_LOADER_CONFIG_FINISHED_0));\n        }\n    }","id":26779,"modified_method":"/**\n     * Initializes all additional resource types stored in the modules.<p>\n     * \n     * @param cms an initialized OpenCms user context with \"module manager\" role permissions\n     * \n     * @throws CmsRoleViolationException in case the provided OpenCms user context did not have \"module manager\" role permissions\n     * @throws CmsConfigurationException in case of duplicate resource types in the configuration\n     */\n    public synchronized void initialize(CmsObject cms) throws CmsRoleViolationException, CmsConfigurationException {\n\n        if (OpenCms.getRunLevel() > OpenCms.RUNLEVEL_1_CORE_OBJECT) {\n            // some simple test cases don't require this check       \n            OpenCms.getRoleManager().checkRole(cms, CmsRole.DATABASE_MANAGER);\n        }\n\n        // initialize the resource types\n        initResourceTypes();\n\n        // call initialize method on all resource types\n        Iterator i = m_configuration.m_resourceTypeList.iterator();\n        while (i.hasNext()) {\n            I_CmsResourceType type = (I_CmsResourceType)i.next();\n            type.initialize(cms);\n        }\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_LOADER_CONFIG_FINISHED_0));\n        }\n    }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the (unmodifyable array) list with all initialized resource types.<p>\n     * \n     * @return the (unmodifyable array) list with all initialized resource types\n     */\n    public List getResourceTypes() {\n\n        // return the list of resource types\n        return m_configuration.getResourceTypeList();\n    }","id":26780,"modified_method":"/**\n     * Returns the (unmodifiable) list with all initialized resource types.<p>\n     * \n     * @return the (unmodifiable) list with all initialized resource types\n     */\n    public List getResourceTypes() {\n\n        return m_configuration.m_resourceTypeList;\n    }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n         * Creates a new resource manager data storage.<p>\n         */\n        protected CmsResourceManagerConfiguration() {\n\n            m_resourceTypes = new I_CmsResourceType[100];\n            m_resourceTypeMap = new HashMap();\n            m_mappings = new HashMap();\n            m_resourceTypeList = new ArrayList();\n        }","id":26781,"modified_method":"/**\n         * Creates a new resource manager data storage.<p>\n         */\n        protected CmsResourceManagerConfiguration() {\n\n            m_resourceTypeIdMap = new HashMap(128);\n            m_resourceTypeNameMap = new HashMap(128);\n            m_extensionMappings = new HashMap(128);\n            m_resourceTypeList = new ArrayList(32);\n        }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n         * Returns the map that contains all initialized resource types mapped to their type name.<p>\n         *\n         * @return the map that contains all initialized resource types mapped to their type name\n         */\n        protected Map getResourceTypeMap() {\n\n            return m_resourceTypeMap;\n        }","id":26782,"modified_method":"/**\n         * Returns the configured resource type with the matching type id, or <code>null<\/code>\n         * if a resource type with that id is not configured.<p> \n         * \n         * @param typeId the type id to get the resource type for\n         * \n         * @return the configured resource type with the matching type id, or <code>null<\/code>\n         */\n        protected I_CmsResourceType getResourceTypeById(int typeId) {\n\n            return (I_CmsResourceType)m_resourceTypeIdMap.get(Integer.valueOf(typeId));\n        }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Checks if an initialized resource type instance for the given resource type name is available.<p>\n     * \n     * @param typeName the name of the resource type to check\n     * @return <code>true<\/code> if such a resource type has been configured, <code>false<\/code> otherwise\n     * \n     * @see #getResourceType(String)\n     */\n    public boolean hasResourceType(String typeName) {\n\n        I_CmsResourceType result = (I_CmsResourceType)m_configuration.getResourceTypeMap().get(typeName);\n        return result != null;\n    }","id":26783,"modified_method":"/**\n     * Checks if an initialized resource type instance for the given resource type name is available.<p>\n     * \n     * @param typeName the name of the resource type to check\n     * @return <code>true<\/code> if such a resource type has been configured, <code>false<\/code> otherwise\n     * \n     * @see #getResourceType(String)\n     */\n    public boolean hasResourceType(String typeName) {\n\n        return m_configuration.getResourceTypeByName(typeName) != null;\n    }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the initialized resource type instance for the given resource type name.<p>\n     * \n     * @param typeName the name of the resource type to get\n     * @return the initialized resource type instance for the given name\n     * @throws CmsLoaderException if no resource type is available for the given name\n     */\n    public I_CmsResourceType getResourceType(String typeName) throws CmsLoaderException {\n\n        I_CmsResourceType result = (I_CmsResourceType)m_configuration.getResourceTypeMap().get(typeName);\n        if (result != null) {\n            return result;\n        }\n        throw new CmsLoaderException(Messages.get().container(Messages.ERR_UNKNOWN_RESTYPE_NAME_REQ_1, typeName));\n    }","id":26784,"modified_method":"/**\n     * Returns the initialized resource type instance for the given resource type name.<p>\n     * \n     * @param typeName the name of the resource type to get\n     * \n     * @return the initialized resource type instance for the given name\n     * \n     * @throws CmsLoaderException if no resource type is available for the given name\n     */\n    public I_CmsResourceType getResourceType(String typeName) throws CmsLoaderException {\n\n        I_CmsResourceType result = m_configuration.getResourceTypeByName(typeName);\n        if (result != null) {\n            return result;\n        }\n        throw new CmsLoaderException(Messages.get().container(Messages.ERR_UNKNOWN_RESTYPE_NAME_REQ_1, typeName));\n    }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Checks if an initialized resource type instance equal to the given resource type is available.<p>\n     * \n     * @param type the resource type to check\n     * @return <code>true<\/code> if such a resource type has been configured, <code>false<\/code> otherwise\n     * \n     * @see #getResourceType(String)\n     * @see #getResourceType(int)\n     */\n    public boolean hasResourceType(I_CmsResourceType type) {\n\n        int result = m_configuration.getResourceTypeList().indexOf(type);\n        return result >= 0;\n    }","id":26785,"modified_method":"/**\n     * Checks if an initialized resource type instance equal to the given resource type is available.<p>\n     * \n     * @param type the resource type to check\n     * @return <code>true<\/code> if such a resource type has been configured, <code>false<\/code> otherwise\n     * \n     * @see #getResourceType(String)\n     * @see #getResourceType(int)\n     */\n    public boolean hasResourceType(I_CmsResourceType type) {\n\n        return hasResourceType(type.getTypeId());\n    }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes member variables required for storing the resource types.<p>\n     *\n     * @throws CmsConfigurationException in case of duplicate resource types in the configuration\n     */\n    private synchronized void initResourceTypes() throws CmsConfigurationException {\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_STARTING_LOADER_CONFIG_0));\n        }\n\n        CmsResourceManagerConfiguration newConfiguration = new CmsResourceManagerConfiguration();\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(\n                Messages.INIT_ADD_RESTYPE_FROM_FILE_2,\n                new Integer(m_resourceTypesFromXml.size()),\n                CmsVfsConfiguration.DEFAULT_XML_FILE_NAME));\n        }\n\n        // build a new resource type list from the resource types of the XML configuration\n        Iterator i;\n        i = m_resourceTypesFromXml.iterator();\n        while (i.hasNext()) {\n            I_CmsResourceType resourceType = (I_CmsResourceType)i.next();\n            initResourceType(resourceType, newConfiguration);\n        }\n\n        // add all resource types declared in the modules\n        CmsModuleManager moduleManager = OpenCms.getModuleManager();\n        if (moduleManager != null) {\n            i = moduleManager.getModuleNames().iterator();\n            while (i.hasNext()) {\n                CmsModule module = moduleManager.getModule((String)i.next());\n                if ((module != null) && (module.getResourceTypes().size() > 0)) {\n                    // module contains resource types                \n                    if (CmsLog.INIT.isInfoEnabled()) {\n                        CmsLog.INIT.info(Messages.get().getBundle().key(\n                            Messages.INIT_ADD_NUM_RESTYPES_FROM_MOD_2,\n                            new Integer(module.getResourceTypes().size()),\n                            module.getName()));\n                    }\n\n                    Iterator j = module.getResourceTypes().iterator();\n                    while (j.hasNext()) {\n                        I_CmsResourceType resourceType = (I_CmsResourceType)j.next();\n                        I_CmsResourceType conflictingType = null;\n                        if (resourceType.getTypeId() == CmsResourceTypeUnknownFile.RESOURCE_TYPE_ID) {\n                            // default unknown file resource type\n                            if (m_restypeUnknownFile != null) {\n                                // error: already set\n                                conflictingType = m_restypeUnknownFile;\n                            } else {\n                                m_restypeUnknownFile = resourceType;\n                                continue;\n                            }\n                        } else if (resourceType.getTypeId() == CmsResourceTypeUnknownFolder.RESOURCE_TYPE_ID) {\n                            // default unknown folder resource type\n                            if (m_restypeUnknownFolder != null) {\n                                // error: already set\n                                conflictingType = m_restypeUnknownFolder;\n                            } else {\n                                m_restypeUnknownFolder = resourceType;\n                                continue;\n                            }\n                        } else {\n                            // normal resource types\n                            int conflictIndex = newConfiguration.getResourceTypeList().indexOf(resourceType);\n                            if (conflictIndex >= 0) {\n                                conflictingType = (I_CmsResourceType)newConfiguration.getResourceTypeList().get(\n                                    conflictIndex);\n                            }\n                        }\n                        if (conflictingType != null) {\n                            throw new CmsConfigurationException(Messages.get().container(\n                                Messages.ERR_CONFLICTING_MODULE_RESOURCE_TYPES_5,\n                                new Object[] {\n                                    resourceType.getTypeName(),\n                                    new Integer(resourceType.getTypeId()),\n                                    module.getName(),\n                                    conflictingType.getTypeName(),\n                                    new Integer(conflictingType.getTypeId())}));\n                        }\n                        initResourceType(resourceType, newConfiguration);\n                    }\n                }\n            }\n        }\n\n        // freeze the current configuration\n        newConfiguration.freeze();\n        m_configuration = newConfiguration;\n        m_frozen = true;\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_RESOURCE_TYPE_INITIALIZED_0));\n        }\n    }","id":26786,"modified_method":"/**\n     * Initializes member variables required for storing the resource types.<p>\n     *\n     * @throws CmsConfigurationException in case of duplicate resource types in the configuration\n     */\n    private synchronized void initResourceTypes() throws CmsConfigurationException {\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_STARTING_LOADER_CONFIG_0));\n        }\n\n        CmsResourceManagerConfiguration newConfiguration = new CmsResourceManagerConfiguration();\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(\n                Messages.INIT_ADD_RESTYPE_FROM_FILE_2,\n                new Integer(m_resourceTypesFromXml.size()),\n                CmsVfsConfiguration.DEFAULT_XML_FILE_NAME));\n        }\n\n        // build a new resource type list from the resource types of the XML configuration\n        Iterator i;\n        i = m_resourceTypesFromXml.iterator();\n        while (i.hasNext()) {\n            I_CmsResourceType resourceType = (I_CmsResourceType)i.next();\n            initResourceType(resourceType, newConfiguration);\n        }\n\n        // add all resource types declared in the modules\n        CmsModuleManager moduleManager = OpenCms.getModuleManager();\n        if (moduleManager != null) {\n            i = moduleManager.getModuleNames().iterator();\n            while (i.hasNext()) {\n                CmsModule module = moduleManager.getModule((String)i.next());\n                if ((module != null) && (module.getResourceTypes().size() > 0)) {\n                    // module contains resource types                \n                    if (CmsLog.INIT.isInfoEnabled()) {\n                        CmsLog.INIT.info(Messages.get().getBundle().key(\n                            Messages.INIT_ADD_NUM_RESTYPES_FROM_MOD_2,\n                            new Integer(module.getResourceTypes().size()),\n                            module.getName()));\n                    }\n\n                    Iterator j = module.getResourceTypes().iterator();\n                    while (j.hasNext()) {\n                        I_CmsResourceType resourceType = (I_CmsResourceType)j.next();\n                        I_CmsResourceType conflictingType = null;\n                        if (resourceType.getTypeId() == CmsResourceTypeUnknownFile.RESOURCE_TYPE_ID) {\n                            // default unknown file resource type\n                            if (m_restypeUnknownFile != null) {\n                                // error: already set\n                                conflictingType = m_restypeUnknownFile;\n                            } else {\n                                m_restypeUnknownFile = resourceType;\n                                continue;\n                            }\n                        } else if (resourceType.getTypeId() == CmsResourceTypeUnknownFolder.RESOURCE_TYPE_ID) {\n                            // default unknown folder resource type\n                            if (m_restypeUnknownFolder != null) {\n                                // error: already set\n                                conflictingType = m_restypeUnknownFolder;\n                            } else {\n                                m_restypeUnknownFile = resourceType;\n                                continue;\n                            }\n                        } else {\n                            // normal resource types\n                            conflictingType = newConfiguration.getResourceTypeById(resourceType.getTypeId());\n                        }\n                        if (conflictingType != null) {\n                            throw new CmsConfigurationException(Messages.get().container(\n                                Messages.ERR_CONFLICTING_MODULE_RESOURCE_TYPES_5,\n                                new Object[] {\n                                    resourceType.getTypeName(),\n                                    new Integer(resourceType.getTypeId()),\n                                    module.getName(),\n                                    conflictingType.getTypeName(),\n                                    new Integer(conflictingType.getTypeId())}));\n                        }\n                        initResourceType(resourceType, newConfiguration);\n                    }\n                }\n            }\n        }\n\n        // freeze the current configuration\n        newConfiguration.freeze(m_restypeUnknownFile, m_restypeUnknownFile);\n        m_configuration = newConfiguration;\n        m_frozen = true;\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_RESOURCE_TYPE_INITIALIZED_0));\n        }\n    }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the default resource type for the given resource name, using the \n     * configured resource type file extensions.<p>\n     * \n     * In case the given name does not map to a configured resource type,\n     * {@link CmsResourceTypePlain} is returned.<p>\n     * \n     * This is only required (and should <i>not<\/i> be used otherwise) when \n     * creating a new resource automatically during file upload or synchronization.\n     * Only in this case, the file type for the new resource is determined using this method.\n     * Otherwise the resource type is <i>always<\/i> stored as part of the resource, \n     * and is <i>not<\/i> related to the file name.<p>\n     * \n     * @param resourcename the resource name to look up the resource type for\n     * \n     * @return the default resource type for the given resource name\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public I_CmsResourceType getDefaultTypeForName(String resourcename) throws CmsException {\n\n        String typeName = null;\n        String suffix = null;\n        if (CmsStringUtil.isNotEmpty(resourcename)) {\n            int pos = resourcename.lastIndexOf('.');\n            if (pos >= 0) {\n                suffix = resourcename.substring(pos);\n                if (CmsStringUtil.isNotEmpty(suffix)) {\n                    suffix = suffix.toLowerCase();\n                    typeName = (String)m_configuration.getMappings().get(suffix);\n\n                }\n            }\n        }\n\n        if (typeName == null) {\n            // use default type \"plain\"\n            typeName = CmsResourceTypePlain.getStaticTypeName();\n        }\n\n        if (CmsLog.INIT.isDebugEnabled()) {\n            CmsLog.INIT.debug(Messages.get().getBundle().key(Messages.INIT_GET_RESTYPE_2, typeName, suffix));\n        }\n        // look up and return the resource type\n        return getResourceType(typeName);\n    }","id":26787,"modified_method":"/**\n     * Returns the default resource type for the given resource name, using the \n     * configured resource type file extensions.<p>\n     * \n     * In case the given name does not map to a configured resource type,\n     * {@link CmsResourceTypePlain} is returned.<p>\n     * \n     * This is only required (and should <i>not<\/i> be used otherwise) when \n     * creating a new resource automatically during file upload or synchronization.\n     * Only in this case, the file type for the new resource is determined using this method.\n     * Otherwise the resource type is <i>always<\/i> stored as part of the resource, \n     * and is <i>not<\/i> related to the file name.<p>\n     * \n     * @param resourcename the resource name to look up the resource type for\n     * \n     * @return the default resource type for the given resource name\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public I_CmsResourceType getDefaultTypeForName(String resourcename) throws CmsException {\n\n        String typeName = null;\n        String suffix = null;\n        if (CmsStringUtil.isNotEmpty(resourcename)) {\n            int pos = resourcename.lastIndexOf('.');\n            if (pos >= 0) {\n                suffix = resourcename.substring(pos);\n                if (CmsStringUtil.isNotEmpty(suffix)) {\n                    suffix = suffix.toLowerCase();\n                    typeName = (String)m_configuration.m_extensionMappings.get(suffix);\n\n                }\n            }\n        }\n\n        if (typeName == null) {\n            // use default type \"plain\"\n            typeName = CmsResourceTypePlain.getStaticTypeName();\n        }\n\n        if (CmsLog.INIT.isDebugEnabled()) {\n            CmsLog.INIT.debug(Messages.get().getBundle().key(Messages.INIT_GET_RESTYPE_2, typeName, suffix));\n        }\n        // look up and return the resource type\n        return getResourceType(typeName);\n    }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds a new resource type to the internal list of loaded resource types and initializes \n     * options for the resource type.<p>\n     *\n     * @param resourceType the resource type to add\n     * @param configuration the resource configuration\n     */\n    private synchronized void initResourceType(\n        I_CmsResourceType resourceType,\n        CmsResourceManagerConfiguration configuration) {\n\n        // add the loader to the internal list of loaders\n        int pos = resourceType.getTypeId();\n        if (pos > configuration.m_resourceTypes.length) {\n            I_CmsResourceType[] types = new I_CmsResourceType[pos * 2];\n            System.arraycopy(configuration.m_resourceTypes, 0, types, 0, configuration.m_resourceTypes.length);\n            configuration.m_resourceTypes = types;\n        }\n        configuration.m_resourceTypes[pos] = resourceType;\n        configuration.getResourceTypeList().add(resourceType);\n        configuration.getResourceTypeMap().put(resourceType.getTypeName(), resourceType);\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(\n                Messages.INIT_ADD_RESTYPE_3,\n                resourceType.getTypeName(),\n                new Integer(resourceType.getTypeId()),\n                resourceType.getClass().getName()));\n        }\n\n        // add the mappings\n        List mappings = resourceType.getConfiguredMappings();\n        Iterator i = mappings.iterator();\n        while (i.hasNext()) {\n            String mapping = (String)i.next();\n            // only add this mapping if a mapping with this file extension does not\n            // exist already\n            if (!configuration.getMappings().containsKey(mapping)) {\n                configuration.getMappings().put(mapping, resourceType.getTypeName());\n                if (CmsLog.INIT.isInfoEnabled()) {\n                    CmsLog.INIT.info(Messages.get().getBundle().key(\n                        Messages.INIT_MAP_RESTYPE_2,\n                        mapping,\n                        resourceType.getTypeName()));\n                }\n            }\n        }\n    }","id":26788,"modified_method":"/**\n     * Adds a new resource type to the internal list of loaded resource types and initializes \n     * options for the resource type.<p>\n     *\n     * @param resourceType the resource type to add\n     * @param configuration the resource configuration\n     */\n    private synchronized void initResourceType(\n        I_CmsResourceType resourceType,\n        CmsResourceManagerConfiguration configuration) {\n\n        // add the loader to the internal list of loaders\n        configuration.addResourceType(resourceType);\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(\n                Messages.INIT_ADD_RESTYPE_3,\n                resourceType.getTypeName(),\n                new Integer(resourceType.getTypeId()),\n                resourceType.getClass().getName()));\n        }\n\n        // add the mappings\n        List mappings = resourceType.getConfiguredMappings();\n        Iterator i = mappings.iterator();\n        while (i.hasNext()) {\n            String mapping = (String)i.next();\n            // only add this mapping if a mapping with this file extension does not\n            // exist already\n            if (!configuration.m_extensionMappings.containsKey(mapping)) {\n                configuration.m_extensionMappings.put(mapping, resourceType.getTypeName());\n                if (CmsLog.INIT.isInfoEnabled()) {\n                    CmsLog.INIT.info(Messages.get().getBundle().key(\n                        Messages.INIT_MAP_RESTYPE_2,\n                        mapping,\n                        resourceType.getTypeName()));\n                }\n            }\n        }\n    }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Checks if an initialized resource type instance for the given resource type is is available.<p>\n     * \n     * @param typeId the id of the resource type to check\n     * @return <code>true<\/code> if such a resource type has been configured, <code>false<\/code> otherwise\n     * \n     * @see #getResourceType(int)\n     */\n    public boolean hasResourceType(int typeId) {\n\n        I_CmsResourceType result = null;\n        if ((typeId >= 0) && (typeId < m_configuration.m_resourceTypes.length)) {\n            result = m_configuration.m_resourceTypes[typeId];\n        }\n        return result != null;\n    }","id":26789,"modified_method":"/**\n     * Checks if an initialized resource type instance for the given resource type is is available.<p>\n     * \n     * @param typeId the id of the resource type to check\n     * @return <code>true<\/code> if such a resource type has been configured, <code>false<\/code> otherwise\n     * \n     * @see #getResourceType(int)\n     */\n    public boolean hasResourceType(int typeId) {\n\n        return m_configuration.getResourceTypeById(typeId) != null;\n    }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the list with all initialized resource types including unknown types.<p>\n     * \n     * @return the list with all initialized resource types including unknown types\n     */\n    public List getResourceTypesWithUnknown() {\n\n        // return the list of resource types\n        List result = new ArrayList(m_configuration.getResourceTypeList().size() + 2);\n        if (m_restypeUnknownFolder != null) {\n            result.add(m_restypeUnknownFolder);\n        }\n        if (m_restypeUnknownFile != null) {\n            result.add(m_restypeUnknownFile);\n        }\n        result.addAll(m_configuration.getResourceTypeList());\n        return result;\n    }","id":26790,"modified_method":"/**\n     * Returns the (unmodifiable) list with all initialized resource types including unknown types.<p>\n     * \n     * @return the (unmodifiable) list with all initialized resource types including unknown types\n     */\n    public List getResourceTypesWithUnknown() {\n\n        return m_configuration.m_resourceTypeListWithUnknown;\n    }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the file extensions (suffixes) mappings to resource types.<p>\n     *\n     * @return a Map with all known file extensions as keys and their resource types as values.\n     */\n    public Map getExtensionMapping() {\n\n        return m_configuration.getMappings();\n    }","id":26791,"modified_method":"/**\n     * Returns the file extensions (suffixes) mappings to resource types.<p>\n     *\n     * @return a Map with all known file extensions as keys and their resource types as values.\n     */\n    public Map getExtensionMapping() {\n\n        return m_configuration.m_extensionMappings;\n    }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the initialized resource type instance for the given id.<p>\n     * \n     * @param typeId the id of the resource type to get\n     * \n     * @return the initialized resource type instance for the given id\n     * \n     * @throws CmsLoaderException if no resource type is available for the given id\n     */\n    public I_CmsResourceType getResourceType(int typeId) throws CmsLoaderException {\n\n        I_CmsResourceType result = null;\n        if ((typeId >= 0) && (typeId < m_configuration.m_resourceTypes.length)) {\n            result = m_configuration.m_resourceTypes[typeId];\n        }\n        if (result == null) {\n            throw new CmsLoaderException(Messages.get().container(\n                Messages.ERR_UNKNOWN_RESTYPE_ID_REQ_1,\n                new Integer(typeId)));\n        }\n        return result;\n    }","id":26792,"modified_method":"/**\n     * Returns the initialized resource type instance for the given id.<p>\n     * \n     * @param typeId the id of the resource type to get\n     * \n     * @return the initialized resource type instance for the given id\n     * \n     * @throws CmsLoaderException if no resource type is available for the given id\n     */\n    public I_CmsResourceType getResourceType(int typeId) throws CmsLoaderException {\n\n        I_CmsResourceType result = m_configuration.getResourceTypeById(typeId);\n        if (result == null) {\n            throw new CmsLoaderException(Messages.get().container(\n                Messages.ERR_UNKNOWN_RESTYPE_ID_REQ_1,\n                new Integer(typeId)));\n        }\n        return result;\n    }","commit_id":"0dd3882dacd0058a7ac17bff3d2cfdfe0a0e7e34","url":"https://github.com/alkacon/opencms-core"},{"original_method":"protected void loadFragmentInfo() {\n        final InputStream inputStream;\n        try {\n            inputStream = this.configurationFile.getInputStream();\n        }\n        catch (IOException e) {\n            throw new IllegalArgumentException(\"Could not open InputStream to dlm configuration resource \"+ this.configurationFile, e);\n        }\n        \n        final String configUrl;\n        try {\n            configUrl = this.configurationFile.getURL().toExternalForm();\n        }\n        catch (IOException e) {\n            throw new IllegalArgumentException(\"Could not convert dlm configuration resource to URL \"+ this.configurationFile, e);\n        }\n        \n        final Document doc;\n        try {\n            doc = DocumentFactory.getDocumentFromStream(inputStream, configUrl);\n        }\n        catch (IOException e) {\n            throw new IllegalArgumentException(\"Could load dlm configuration resource \"+ this.configurationFile, e);\n        }\n        catch (SAXException e) {\n            throw new IllegalArgumentException(\"Could parse dlm configuration resource \"+ this.configurationFile, e);\n        }\n        \n        final NodeList fragmentNodes = doc.getElementsByTagName( \"dlm:fragment\" );\n        final List<FragmentDefinition> localFragments = this.getFragments(fragmentNodes);\n        if (localFragments != null) {\n            // lastly sort according to precedence followed by index\n            Collections.sort(localFragments, new FragmentComparator() );\n            // show sort order in log file if debug is on. (Could check and\n            // only build of on but do later.)\n            if (logger.isDebugEnabled()) {\n                StringBuilder bfr = new StringBuilder();\n                for (final FragmentDefinition fragmentDefinition : localFragments) {\n                    bfr.append( fragmentDefinition.getName() );\n                    bfr.append( \"[\" );\n                    bfr.append( fragmentDefinition.getPrecedence() );\n                    bfr.append( \"],\\n\" );\n                }\n                logger.debug(\"Fragments Sorted by Precedence and then index {\\n\" +\n                    bfr.toString() + \" }\" );\n            }\n            \n            //Store the fragments in a map by name & owner for easy access\n            final Map<String, FragmentDefinition> fragmentsByName = new LinkedHashMap<String, FragmentDefinition>();\n            for (final FragmentDefinition fragmentDefinition : localFragments) {\n                fragmentsByName.put(fragmentDefinition.getName(), fragmentDefinition);\n            }\n            final Map<String, FragmentDefinition> fragmentsByOwnerId = new LinkedHashMap<String, FragmentDefinition>();\n            for (final FragmentDefinition fragmentDefinition : localFragments) {\n                fragmentsByOwnerId.put(fragmentDefinition.getOwnerId(), fragmentDefinition);\n            }\n            \n            this.fragments = Collections.unmodifiableList(localFragments);\n            this.fragmentsByName = Collections.unmodifiableMap(fragmentsByOwnerId);\n        }\n    }","id":26793,"modified_method":"protected void loadFragmentInfo() {\n        final InputStream inputStream;\n        try {\n            inputStream = this.configurationFile.getInputStream();\n        }\n        catch (IOException e) {\n            throw new IllegalArgumentException(\"Could not open InputStream to dlm configuration resource \"+ this.configurationFile, e);\n        }\n        \n        final String configUrl;\n        try {\n            configUrl = this.configurationFile.getURL().toExternalForm();\n        }\n        catch (IOException e) {\n            throw new IllegalArgumentException(\"Could not convert dlm configuration resource to URL \"+ this.configurationFile, e);\n        }\n        \n        final Document doc;\n        try {\n            doc = DocumentFactory.getDocumentFromStream(inputStream, configUrl);\n        }\n        catch (IOException e) {\n            throw new IllegalArgumentException(\"Could load dlm configuration resource \"+ this.configurationFile, e);\n        }\n        catch (SAXException e) {\n            throw new IllegalArgumentException(\"Could parse dlm configuration resource \"+ this.configurationFile, e);\n        }\n        \n        final NodeList fragmentNodes = doc.getElementsByTagName( \"dlm:fragment\" );\n        final List<FragmentDefinition> localFragments = this.getFragments(fragmentNodes);\n        if (localFragments != null) {\n            // lastly sort according to precedence followed by index\n            Collections.sort(localFragments, new FragmentComparator() );\n            // show sort order in log file if debug is on. (Could check and\n            // only build of on but do later.)\n            if (logger.isDebugEnabled()) {\n                StringBuilder bfr = new StringBuilder();\n                for (final FragmentDefinition fragmentDefinition : localFragments) {\n                    bfr.append( fragmentDefinition.getName() );\n                    bfr.append( \"[\" );\n                    bfr.append( fragmentDefinition.getPrecedence() );\n                    bfr.append( \"],\\n\" );\n                }\n                logger.debug(\"Fragments Sorted by Precedence and then index {\\n\" +\n                    bfr.toString() + \" }\" );\n            }\n            \n            //Store the fragments in a map by name & owner for easy access\n            final Map<String, FragmentDefinition> fragmentsByName = new LinkedHashMap<String, FragmentDefinition>();\n            for (final FragmentDefinition fragmentDefinition : localFragments) {\n                fragmentsByName.put(fragmentDefinition.getName(), fragmentDefinition);\n            }\n            final Map<String, FragmentDefinition> fragmentsByOwnerId = new LinkedHashMap<String, FragmentDefinition>();\n            for (final FragmentDefinition fragmentDefinition : localFragments) {\n                fragmentsByOwnerId.put(fragmentDefinition.getOwnerId(), fragmentDefinition);\n            }\n            \n            this.fragments = Collections.unmodifiableList(localFragments);\n            this.fragmentsByName = Collections.unmodifiableMap(fragmentsByName);\n            this.fragmentsByOwnerId = Collections.unmodifiableMap(fragmentsByOwnerId);\n        }\n    }","commit_id":"9e1b0972e4b0dbed8279f2e27c1c8d39892b1bb5","url":"https://github.com/Jasig/uPortal"},{"original_method":"public Map<String, DiskUsage> getNodeDiskUsages() {\n        return this.usages;\n    }","id":26794,"modified_method":"/**\n     * Returns a node id to disk usage mapping for the path that has the most available space on the node.\n     */\n    public Map<String, DiskUsage> getNodeMostAvailableDiskUsages() {\n        return this.mostAvailabeSpaceUsage;\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public long getShardSize(ShardRouting shardRouting, long defaultValue) {\n        Long shardSize = getShardSize(shardRouting);\n        return shardSize == null ? defaultValue : shardSize;\n    }","id":26795,"modified_method":"/**\n     * Returns the shard size for the given shard routing or <code>defaultValue<\/code> it that metric is not available.\n     */\n    public long getShardSize(ShardRouting shardRouting, long defaultValue) {\n        Long shardSize = getShardSize(shardRouting);\n        return shardSize == null ? defaultValue : shardSize;\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ClusterInfo(Map<String, DiskUsage> usages, Map<String, Long> shardSizes) {\n        this.usages = usages;\n        this.shardSizes = shardSizes;\n    }","id":26796,"modified_method":"/**\n     * Creates a new ClusterInfo instance.\n     *\n     * @param leastAvailableSpaceUsage a node id to disk usage mapping for the path that has the least available space on the node.\n     * @param mostAvailableSpaceUsage  a node id to disk usage mapping for the path that has the most available space on the node.\n     * @param shardSizes a shardkey to size in bytes mapping per shard.\n     * @see #shardIdentifierFromRouting\n     */\n    public ClusterInfo(final Map<String, DiskUsage> leastAvailableSpaceUsage, final Map<String, DiskUsage> mostAvailableSpaceUsage, final Map<String, Long> shardSizes) {\n        this.leastAvailableSpaceUsage = leastAvailableSpaceUsage;\n        this.shardSizes = shardSizes;\n        this.mostAvailabeSpaceUsage = mostAvailableSpaceUsage;\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private ClusterInfo() {\n        this.usages = Collections.emptyMap();\n        this.shardSizes = Collections.emptyMap();\n    }","id":26797,"modified_method":"protected ClusterInfo() {\n       this(Collections.EMPTY_MAP, Collections.EMPTY_MAP, Collections.EMPTY_MAP);\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Long getShardSize(ShardRouting shardRouting) {\n        return shardSizes.get(shardIdentifierFromRouting(shardRouting));\n    }","id":26798,"modified_method":"/**\n     * Returns the shard size for the given shard routing or <code>null<\/code> it that metric is not available.\n     */\n    public Long getShardSize(ShardRouting shardRouting) {\n        return shardSizes.get(shardIdentifierFromRouting(shardRouting));\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testClusterInfoServiceInformationClearOnError() throws InterruptedException, ExecutionException {\n        internalCluster().startNodesAsync(2,\n                // manually control publishing\n                Settings.builder().put(InternalClusterInfoService.INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL, \"60m\").build())\n                .get();\n        prepareCreate(\"test\").setSettings(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).get();\n        ensureGreen(\"test\");\n        InternalTestCluster internalTestCluster = internalCluster();\n        InternalClusterInfoService infoService = (InternalClusterInfoService) internalTestCluster.getInstance(ClusterInfoService.class, internalTestCluster.getMasterName());\n        InfoListener listener = new InfoListener();\n        infoService.addListener(listener);\n\n        // get one healthy sample\n        infoService.updateOnce();\n        ClusterInfo info = listener.get();\n        assertNotNull(\"failed to collect info\", info);\n        assertThat(\"some usages are populated\", info.getNodeDiskUsages().size(), Matchers.equalTo(2));\n        assertThat(\"some shard sizes are populated\", info.shardSizes.size(), greaterThan(0));\n\n\n        MockTransportService mockTransportService = (MockTransportService) internalCluster().getInstance(TransportService.class, internalTestCluster.getMasterName());\n\n        final AtomicBoolean timeout = new AtomicBoolean(false);\n        final Set<String> blockedActions = ImmutableSet.of(NodesStatsAction.NAME, NodesStatsAction.NAME + \"[n]\", IndicesStatsAction.NAME, IndicesStatsAction.NAME + \"[s]\");\n        // drop all outgoing stats requests to force a timeout.\n        for (DiscoveryNode node : internalTestCluster.clusterService().state().getNodes()) {\n            mockTransportService.addDelegate(node, new MockTransportService.DelegateTransport(mockTransportService.original()) {\n                @Override\n                public void sendRequest(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                        TransportRequestOptions options) throws IOException, TransportException {\n                    if (blockedActions.contains(action)) {\n                        if (timeout.get()) {\n                            logger.info(\"dropping [{}] to [{}]\", action, node);\n                            return;\n                        }\n                    }\n                    super.sendRequest(node, requestId, action, request, options);\n                }\n            });\n        }\n\n        // timeouts shouldn't clear the info\n        timeout.set(true);\n        listener.reset();\n        infoService.updateOnce();\n        info = listener.get();\n        assertNotNull(\"info should not be null\", info);\n        // node info will time out both on the request level on the count down latch. this means\n        // it is likely to update the node disk usage based on the one response that came be from local\n        // node.\n        assertThat(info.getNodeDiskUsages().size(), greaterThanOrEqualTo(1));\n        // indices is guaranteed to time out on the latch, not updating anything.\n        assertThat(info.shardSizes.size(), greaterThan(1));\n\n        // now we cause an exception\n        timeout.set(false);\n        ActionFilters actionFilters = internalTestCluster.getInstance(ActionFilters.class, internalTestCluster.getMasterName());\n        BlockingActionFilter blockingActionFilter = null;\n        for (ActionFilter filter : actionFilters.filters()) {\n            if (filter instanceof BlockingActionFilter) {\n                blockingActionFilter = (BlockingActionFilter) filter;\n                break;\n            }\n        }\n\n        assertNotNull(\"failed to find BlockingActionFilter\", blockingActionFilter);\n        blockingActionFilter.blockActions(blockedActions.toArray(Strings.EMPTY_ARRAY));\n        listener.reset();\n        infoService.updateOnce();\n        info = listener.get();\n        assertNotNull(\"info should not be null\", info);\n        assertThat(info.getNodeDiskUsages().size(), equalTo(0));\n        assertThat(info.shardSizes.size(), equalTo(0));\n\n        // check we recover\n        blockingActionFilter.blockActions();\n        listener.reset();\n        infoService.updateOnce();\n        info = listener.get();\n        assertNotNull(\"info should not be null\", info);\n        assertThat(info.getNodeDiskUsages().size(), equalTo(2));\n        assertThat(info.shardSizes.size(), greaterThan(0));\n\n    }","id":26799,"modified_method":"@Test\n    public void testClusterInfoServiceInformationClearOnError() throws InterruptedException, ExecutionException {\n        internalCluster().startNodesAsync(2,\n                // manually control publishing\n                Settings.builder().put(InternalClusterInfoService.INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL, \"60m\").build())\n                .get();\n        prepareCreate(\"test\").setSettings(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).get();\n        ensureGreen(\"test\");\n        InternalTestCluster internalTestCluster = internalCluster();\n        InternalClusterInfoService infoService = (InternalClusterInfoService) internalTestCluster.getInstance(ClusterInfoService.class, internalTestCluster.getMasterName());\n        InfoListener listener = new InfoListener();\n        infoService.addListener(listener);\n\n        // get one healthy sample\n        infoService.updateOnce();\n        ClusterInfo info = listener.get();\n        assertNotNull(\"failed to collect info\", info);\n        assertThat(\"some usages are populated\", info.getNodeLeastAvailableDiskUsages().size(), Matchers.equalTo(2));\n        assertThat(\"some shard sizes are populated\", info.shardSizes.size(), greaterThan(0));\n\n\n        MockTransportService mockTransportService = (MockTransportService) internalCluster().getInstance(TransportService.class, internalTestCluster.getMasterName());\n\n        final AtomicBoolean timeout = new AtomicBoolean(false);\n        final Set<String> blockedActions = ImmutableSet.of(NodesStatsAction.NAME, NodesStatsAction.NAME + \"[n]\", IndicesStatsAction.NAME, IndicesStatsAction.NAME + \"[s]\");\n        // drop all outgoing stats requests to force a timeout.\n        for (DiscoveryNode node : internalTestCluster.clusterService().state().getNodes()) {\n            mockTransportService.addDelegate(node, new MockTransportService.DelegateTransport(mockTransportService.original()) {\n                @Override\n                public void sendRequest(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                        TransportRequestOptions options) throws IOException, TransportException {\n                    if (blockedActions.contains(action)) {\n                        if (timeout.get()) {\n                            logger.info(\"dropping [{}] to [{}]\", action, node);\n                            return;\n                        }\n                    }\n                    super.sendRequest(node, requestId, action, request, options);\n                }\n            });\n        }\n\n        // timeouts shouldn't clear the info\n        timeout.set(true);\n        listener.reset();\n        infoService.updateOnce();\n        info = listener.get();\n        assertNotNull(\"info should not be null\", info);\n        // node info will time out both on the request level on the count down latch. this means\n        // it is likely to update the node disk usage based on the one response that came be from local\n        // node.\n        assertThat(info.getNodeLeastAvailableDiskUsages().size(), greaterThanOrEqualTo(1));\n        // indices is guaranteed to time out on the latch, not updating anything.\n        assertThat(info.shardSizes.size(), greaterThan(1));\n\n        // now we cause an exception\n        timeout.set(false);\n        ActionFilters actionFilters = internalTestCluster.getInstance(ActionFilters.class, internalTestCluster.getMasterName());\n        BlockingActionFilter blockingActionFilter = null;\n        for (ActionFilter filter : actionFilters.filters()) {\n            if (filter instanceof BlockingActionFilter) {\n                blockingActionFilter = (BlockingActionFilter) filter;\n                break;\n            }\n        }\n\n        assertNotNull(\"failed to find BlockingActionFilter\", blockingActionFilter);\n        blockingActionFilter.blockActions(blockedActions.toArray(Strings.EMPTY_ARRAY));\n        listener.reset();\n        infoService.updateOnce();\n        info = listener.get();\n        assertNotNull(\"info should not be null\", info);\n        assertThat(info.getNodeLeastAvailableDiskUsages().size(), equalTo(0));\n        assertThat(info.shardSizes.size(), equalTo(0));\n\n        // check we recover\n        blockingActionFilter.blockActions();\n        listener.reset();\n        infoService.updateOnce();\n        info = listener.get();\n        assertNotNull(\"info should not be null\", info);\n        assertThat(info.getNodeLeastAvailableDiskUsages().size(), equalTo(2));\n        assertThat(info.shardSizes.size(), greaterThan(0));\n\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testClusterInfoServiceCollectsInformation() throws Exception {\n        internalCluster().startNodesAsync(2,\n                Settings.builder().put(InternalClusterInfoService.INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL, \"200ms\").build())\n                .get();\n        assertAcked(prepareCreate(\"test\").setSettings(settingsBuilder().put(Store.INDEX_STORE_STATS_REFRESH_INTERVAL, 0).build()));\n        ensureGreen(\"test\");\n        InternalTestCluster internalTestCluster = internalCluster();\n        // Get the cluster info service on the master node\n        final InternalClusterInfoService infoService = (InternalClusterInfoService) internalTestCluster.getInstance(ClusterInfoService.class, internalTestCluster.getMasterName());\n        InfoListener listener = new InfoListener();\n        infoService.addListener(listener);\n        ClusterInfo info = listener.get();\n        assertNotNull(\"info should not be null\", info);\n        Map<String, DiskUsage> usages = info.getNodeDiskUsages();\n        Map<String, Long> shardSizes = info.shardSizes;\n        assertNotNull(usages);\n        assertNotNull(shardSizes);\n        assertThat(\"some usages are populated\", usages.values().size(), Matchers.equalTo(2));\n        assertThat(\"some shard sizes are populated\", shardSizes.values().size(), greaterThan(0));\n        for (DiskUsage usage : usages.values()) {\n            logger.info(\"--> usage: {}\", usage);\n            assertThat(\"usage has be retrieved\", usage.getFreeBytes(), greaterThan(0L));\n        }\n        for (Long size : shardSizes.values()) {\n            logger.info(\"--> shard size: {}\", size);\n            assertThat(\"shard size is greater than 0\", size, greaterThan(0L));\n        }\n    }","id":26800,"modified_method":"@Test\n    public void testClusterInfoServiceCollectsInformation() throws Exception {\n        internalCluster().startNodesAsync(2,\n                Settings.builder().put(InternalClusterInfoService.INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL, \"200ms\").build())\n                .get();\n        assertAcked(prepareCreate(\"test\").setSettings(settingsBuilder().put(Store.INDEX_STORE_STATS_REFRESH_INTERVAL, 0).build()));\n        ensureGreen(\"test\");\n        InternalTestCluster internalTestCluster = internalCluster();\n        // Get the cluster info service on the master node\n        final InternalClusterInfoService infoService = (InternalClusterInfoService) internalTestCluster.getInstance(ClusterInfoService.class, internalTestCluster.getMasterName());\n        InfoListener listener = new InfoListener();\n        infoService.addListener(listener);\n        ClusterInfo info = listener.get();\n        assertNotNull(\"info should not be null\", info);\n        Map<String, DiskUsage> usages = info.getNodeLeastAvailableDiskUsages();\n        Map<String, Long> shardSizes = info.shardSizes;\n        assertNotNull(usages);\n        assertNotNull(shardSizes);\n        assertThat(\"some usages are populated\", usages.values().size(), Matchers.equalTo(2));\n        assertThat(\"some shard sizes are populated\", shardSizes.values().size(), greaterThan(0));\n        for (DiskUsage usage : usages.values()) {\n            logger.info(\"--> usage: {}\", usage);\n            assertThat(\"usage has be retrieved\", usage.getFreeBytes(), greaterThan(0L));\n        }\n        for (Long size : shardSizes.values()) {\n            logger.info(\"--> shard size: {}\", size);\n            assertThat(\"shard size is greater than 0\", size, greaterThan(0L));\n        }\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Returns a {@link DiskUsage} for the {@link RoutingNode} using the\n     * average usage of other nodes in the disk usage map.\n     * @param node Node to return an averaged DiskUsage object for\n     * @param usages Map of nodeId to DiskUsage for all known nodes\n     * @return DiskUsage representing given node using the average disk usage\n     */\n    public DiskUsage averageUsage(RoutingNode node, Map<String, DiskUsage> usages) {\n        if (usages.size() == 0) {\n            return new DiskUsage(node.nodeId(), node.node().name(), 0, 0);\n        }\n        long totalBytes = 0;\n        long freeBytes = 0;\n        for (DiskUsage du : usages.values()) {\n            totalBytes += du.getTotalBytes();\n            freeBytes += du.getFreeBytes();\n        }\n        return new DiskUsage(node.nodeId(), node.node().name(), totalBytes / usages.size(), freeBytes / usages.size());\n    }","id":26801,"modified_method":"/**\n     * Returns a {@link DiskUsage} for the {@link RoutingNode} using the\n     * average usage of other nodes in the disk usage map.\n     * @param node Node to return an averaged DiskUsage object for\n     * @param usages Map of nodeId to DiskUsage for all known nodes\n     * @return DiskUsage representing given node using the average disk usage\n     */\n    public DiskUsage averageUsage(RoutingNode node, Map<String, DiskUsage> usages) {\n        if (usages.size() == 0) {\n            return new DiskUsage(node.nodeId(), node.node().name(), \"_na_\", 0, 0);\n        }\n        long totalBytes = 0;\n        long freeBytes = 0;\n        for (DiskUsage du : usages.values()) {\n            totalBytes += du.getTotalBytes();\n            freeBytes += du.getFreeBytes();\n        }\n        return new DiskUsage(node.nodeId(), node.node().name(), \"_na_\", totalBytes / usages.size(), freeBytes / usages.size());\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private Decision earlyTerminate(RoutingAllocation allocation) {\n        // Always allow allocation if the decider is disabled\n        if (!enabled) {\n            return allocation.decision(Decision.YES, NAME, \"disk threshold decider disabled\");\n        }\n\n        // Allow allocation regardless if only a single node is available\n        if (allocation.nodes().size() <= 1) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"only a single node is present, allowing allocation\");\n            }\n            return allocation.decision(Decision.YES, NAME, \"only a single node is present\");\n        }\n\n        // Fail open there is no info available\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        if (clusterInfo == null) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"cluster info unavailable for disk threshold decider, allowing allocation.\");\n            }\n            return allocation.decision(Decision.YES, NAME, \"cluster info unavailable\");\n        }\n\n        final Map<String, DiskUsage> usages = clusterInfo.getNodeDiskUsages();\n        // Fail open if there are no disk usages available\n        if (usages.isEmpty()) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"unable to determine disk usages for disk-aware allocation, allowing allocation\");\n            }\n            return allocation.decision(Decision.YES, NAME, \"disk usages unavailable\");\n        }\n        return null;\n    }","id":26802,"modified_method":"private Decision earlyTerminate(RoutingAllocation allocation) {\n        // Always allow allocation if the decider is disabled\n        if (!enabled) {\n            return allocation.decision(Decision.YES, NAME, \"disk threshold decider disabled\");\n        }\n\n        // Allow allocation regardless if only a single node is available\n        if (allocation.nodes().size() <= 1) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"only a single node is present, allowing allocation\");\n            }\n            return allocation.decision(Decision.YES, NAME, \"only a single node is present\");\n        }\n\n        // Fail open there is no info available\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        if (clusterInfo == null) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"cluster info unavailable for disk threshold decider, allowing allocation.\");\n            }\n            return allocation.decision(Decision.YES, NAME, \"cluster info unavailable\");\n        }\n\n        final Map<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        // Fail open if there are no disk usages available\n        if (usages.isEmpty()) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"unable to determine disk usages for disk-aware allocation, allowing allocation\");\n            }\n            return allocation.decision(Decision.YES, NAME, \"disk usages unavailable\");\n        }\n        return null;\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Given the DiskUsage for a node and the size of the shard, return the\n     * percentage of free disk if the shard were to be allocated to the node.\n     * @param usage A DiskUsage for the node to have space computed for\n     * @param shardSize Size in bytes of the shard\n     * @return Percentage of free space after the shard is assigned to the node\n     */\n    public double freeDiskPercentageAfterShardAssigned(DiskUsage usage, Long shardSize) {\n        shardSize = (shardSize == null) ? 0 : shardSize;\n        DiskUsage newUsage = new DiskUsage(usage.getNodeId(), usage.getNodeName(),\n                usage.getTotalBytes(), usage.getFreeBytes() - shardSize);\n        return newUsage.getFreeDiskAsPercentage();\n    }","id":26803,"modified_method":"/**\n     * Given the DiskUsage for a node and the size of the shard, return the\n     * percentage of free disk if the shard were to be allocated to the node.\n     * @param usage A DiskUsage for the node to have space computed for\n     * @param shardSize Size in bytes of the shard\n     * @return Percentage of free space after the shard is assigned to the node\n     */\n    public double freeDiskPercentageAfterShardAssigned(DiskUsage usage, Long shardSize) {\n        shardSize = (shardSize == null) ? 0 : shardSize;\n        DiskUsage newUsage = new DiskUsage(usage.getNodeId(), usage.getNodeName(), usage.getPath(),\n                usage.getTotalBytes(),  usage.getFreeBytes() - shardSize);\n        return newUsage.getFreeDiskAsPercentage();\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        final Decision decision = earlyTerminate(allocation);\n        if (decision != null) {\n            return decision;\n        }\n        DiskUsage usage = getDiskUsage(node, allocation);\n        // If this node is already above the high threshold, the shard cannot remain (get it off!)\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (freeBytes < freeBytesThresholdHigh.bytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        freeBytesThresholdHigh, freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME, \"after allocation less than required [%s] free on node, free: [%s]\",\n                    freeBytesThresholdHigh, new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < freeDiskThresholdHigh) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        freeDiskThresholdHigh, freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME, \"after allocation less than required [%s%%] free disk on node, free: [%s%%]\",\n                    freeDiskThresholdHigh, freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME, \"enough disk for shard to remain on node, free: [%s]\", new ByteSizeValue(freeBytes));\n    }","id":26804,"modified_method":"@Override\n    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final Decision decision = earlyTerminate(allocation);\n        if (decision != null) {\n            return decision;\n        }\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        Map<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        DiskUsage usage = getDiskUsage(node, allocation, usages);\n        // If this node is already above the high threshold, the shard cannot remain (get it off!)\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (freeBytes < freeBytesThresholdHigh.bytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        freeBytesThresholdHigh, freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME, \"after allocation less than required [%s] free on node, free: [%s]\",\n                    freeBytesThresholdHigh, new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < freeDiskThresholdHigh) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        freeDiskThresholdHigh, freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME, \"after allocation less than required [%s%%] free disk on node, free: [%s%%]\",\n                    freeDiskThresholdHigh, freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME, \"enough disk for shard to remain on node, free: [%s]\", new ByteSizeValue(freeBytes));\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        final Decision decision = earlyTerminate(allocation);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - DiskThresholdDecider.this.freeDiskThresholdLow;\n        final double usedDiskThresholdHigh = 100.0 - DiskThresholdDecider.this.freeDiskThresholdHigh;\n        DiskUsage usage = getDiskUsage(node, allocation);\n        // First, check that the node currently over the low watermark\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        // Cache the used disk percentage for displaying disk percentages consistent with documentation\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        // a flag for whether the primary shard has been previously allocated\n        boolean primaryHasBeenAllocated = shardRouting.primary() && shardRouting.allocatedPostIndexCreate();\n\n        // checks for exact byte comparisons\n        if (freeBytes < freeBytesThresholdLow.bytes()) {\n            // If the shard is a replica or has a primary that has already been allocated before, check the low threshold\n            if (!shardRouting.primary() || (shardRouting.primary() && primaryHasBeenAllocated)) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, preventing allocation\",\n                            freeBytesThresholdLow, freeBytes, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME, \"less than required [%s] free on node, free: [%s]\",\n                        freeBytesThresholdLow, new ByteSizeValue(freeBytes));\n            } else if (freeBytes > freeBytesThresholdHigh.bytes()) {\n                // Allow the shard to be allocated because it is primary that\n                // has never been allocated if it's under the high watermark\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            freeBytesThresholdLow, freeBytes, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME, \"primary has never been allocated before\");\n            } else {\n                // Even though the primary has never been allocated, the node is\n                // above the high watermark, so don't allow allocating the shard\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            freeBytesThresholdHigh, freeBytes, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME, \"less than required [%s] free on node, free: [%s]\",\n                        freeBytesThresholdHigh, new ByteSizeValue(freeBytes));\n            }\n        }\n\n        // checks for percentage comparisons\n        if (freeDiskPercentage < freeDiskThresholdLow) {\n            // If the shard is a replica or has a primary that has already been allocated before, check the low threshold\n            if (!shardRouting.primary() || (shardRouting.primary() && primaryHasBeenAllocated)) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME, \"more than allowed [%s%%] used disk on node, free: [%s%%]\",\n                        usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > freeDiskThresholdHigh) {\n                // Allow the shard to be allocated because it is primary that\n                // has never been allocated if it's under the high watermark\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME, \"primary has never been allocated before\");\n            } else {\n                // Even though the primary has never been allocated, the node is\n                // above the high watermark, so don't allow allocating the shard\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(freeDiskThresholdHigh, \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME, \"more than allowed [%s%%] used disk on node, free: [%s%%]\",\n                        usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        // Secondly, check that allocating the shard to this node doesn't put it above the high watermark\n        final long shardSize = getShardSize(shardRouting, allocation.clusterInfo());\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < freeBytesThresholdHigh.bytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required {} free bytes threshold ({} bytes free), preventing allocation\",\n                    node.nodeId(), freeBytesThresholdHigh, freeBytesAfterShard);\n            return allocation.decision(Decision.NO, NAME, \"after allocation less than required [%s] free on node, free: [%s]\",\n                    freeBytesThresholdLow, new ByteSizeValue(freeBytesAfterShard));\n        }\n        if (freeSpaceAfterShard < freeDiskThresholdHigh) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed {} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(freeDiskThresholdHigh, \"%\"), Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME, \"after allocation more than allowed [%s%%] used disk on node, free: [%s%%]\",\n                    usedDiskThresholdLow, freeSpaceAfterShard);\n        }\n\n        return allocation.decision(Decision.YES, NAME, \"enough disk for shard on node, free: [%s]\", new ByteSizeValue(freeBytes));\n    }","id":26805,"modified_method":"@Override\n    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        final Decision decision = earlyTerminate(allocation);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - DiskThresholdDecider.this.freeDiskThresholdLow;\n        final double usedDiskThresholdHigh = 100.0 - DiskThresholdDecider.this.freeDiskThresholdHigh;\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        Map<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        DiskUsage usage = getDiskUsage(node, allocation, usages);\n        // First, check that the node currently over the low watermark\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        // Cache the used disk percentage for displaying disk percentages consistent with documentation\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        // a flag for whether the primary shard has been previously allocated\n        boolean primaryHasBeenAllocated = shardRouting.primary() && shardRouting.allocatedPostIndexCreate();\n\n        // checks for exact byte comparisons\n        if (freeBytes < freeBytesThresholdLow.bytes()) {\n            // If the shard is a replica or has a primary that has already been allocated before, check the low threshold\n            if (!shardRouting.primary() || (shardRouting.primary() && primaryHasBeenAllocated)) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, preventing allocation\",\n                            freeBytesThresholdLow, freeBytes, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME, \"less than required [%s] free on node, free: [%s]\",\n                        freeBytesThresholdLow, new ByteSizeValue(freeBytes));\n            } else if (freeBytes > freeBytesThresholdHigh.bytes()) {\n                // Allow the shard to be allocated because it is primary that\n                // has never been allocated if it's under the high watermark\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            freeBytesThresholdLow, freeBytes, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME, \"primary has never been allocated before\");\n            } else {\n                // Even though the primary has never been allocated, the node is\n                // above the high watermark, so don't allow allocating the shard\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            freeBytesThresholdHigh, freeBytes, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME, \"less than required [%s] free on node, free: [%s]\",\n                        freeBytesThresholdHigh, new ByteSizeValue(freeBytes));\n            }\n        }\n\n        // checks for percentage comparisons\n        if (freeDiskPercentage < freeDiskThresholdLow) {\n            // If the shard is a replica or has a primary that has already been allocated before, check the low threshold\n            if (!shardRouting.primary() || (shardRouting.primary() && primaryHasBeenAllocated)) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME, \"more than allowed [%s%%] used disk on node, free: [%s%%]\",\n                        usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > freeDiskThresholdHigh) {\n                // Allow the shard to be allocated because it is primary that\n                // has never been allocated if it's under the high watermark\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME, \"primary has never been allocated before\");\n            } else {\n                // Even though the primary has never been allocated, the node is\n                // above the high watermark, so don't allow allocating the shard\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(freeDiskThresholdHigh, \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME, \"more than allowed [%s%%] used disk on node, free: [%s%%]\",\n                        usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        // Secondly, check that allocating the shard to this node doesn't put it above the high watermark\n        final long shardSize = getShardSize(shardRouting, allocation.clusterInfo());\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < freeBytesThresholdHigh.bytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required {} free bytes threshold ({} bytes free), preventing allocation\",\n                    node.nodeId(), freeBytesThresholdHigh, freeBytesAfterShard);\n            return allocation.decision(Decision.NO, NAME, \"after allocation less than required [%s] free on node, free: [%s]\",\n                    freeBytesThresholdLow, new ByteSizeValue(freeBytesAfterShard));\n        }\n        if (freeSpaceAfterShard < freeDiskThresholdHigh) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed {} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(freeDiskThresholdHigh, \"%\"), Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME, \"after allocation more than allowed [%s%%] used disk on node, free: [%s%%]\",\n                    usedDiskThresholdLow, freeSpaceAfterShard);\n        }\n\n        return allocation.decision(Decision.YES, NAME, \"enough disk for shard on node, free: [%s]\", new ByteSizeValue(freeBytes));\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void onNewInfo(ClusterInfo info) {\n            Map<String, DiskUsage> usages = info.getNodeDiskUsages();\n            if (usages != null) {\n                boolean reroute = false;\n                String explanation = \"\";\n\n                // Garbage collect nodes that have been removed from the cluster\n                // from the map that tracks watermark crossing\n                Set<String> nodes = usages.keySet();\n                for (String node : nodeHasPassedWatermark) {\n                    if (nodes.contains(node) == false) {\n                        nodeHasPassedWatermark.remove(node);\n                    }\n                }\n\n                for (Map.Entry<String, DiskUsage> entry : usages.entrySet()) {\n                    String node = entry.getKey();\n                    DiskUsage usage = entry.getValue();\n                    warnAboutDiskIfNeeded(usage);\n                    if (usage.getFreeBytes() < DiskThresholdDecider.this.freeBytesThresholdHigh.bytes() ||\n                            usage.getFreeDiskAsPercentage() < DiskThresholdDecider.this.freeDiskThresholdHigh) {\n                        if ((System.nanoTime() - lastRunNS) > DiskThresholdDecider.this.rerouteInterval.nanos()) {\n                            lastRunNS = System.nanoTime();\n                            reroute = true;\n                            explanation = \"high disk watermark exceeded on one or more nodes\";\n                        } else {\n                            logger.debug(\"high disk watermark exceeded on {} but an automatic reroute has occurred in the last [{}], skipping reroute\",\n                                    node, DiskThresholdDecider.this.rerouteInterval);\n                        }\n                        nodeHasPassedWatermark.add(node);\n                    } else if (usage.getFreeBytes() < DiskThresholdDecider.this.freeBytesThresholdLow.bytes() ||\n                            usage.getFreeDiskAsPercentage() < DiskThresholdDecider.this.freeDiskThresholdLow) {\n                        nodeHasPassedWatermark.add(node);\n                    } else {\n                        if (nodeHasPassedWatermark.contains(node)) {\n                            // The node has previously been over the high or\n                            // low watermark, but is no longer, so we should\n                            // reroute so any unassigned shards can be allocated\n                            // if they are able to be\n                            if ((System.nanoTime() - lastRunNS) > DiskThresholdDecider.this.rerouteInterval.nanos()) {\n                                lastRunNS = System.nanoTime();\n                                reroute = true;\n                                explanation = \"one or more nodes has gone under the high or low watermark\";\n                                nodeHasPassedWatermark.remove(node);\n                            } else {\n                                logger.debug(\"{} has gone below a disk threshold, but an automatic reroute has occurred in the last [{}], skipping reroute\",\n                                        node, DiskThresholdDecider.this.rerouteInterval);\n                            }\n                        }\n                    }\n                }\n                if (reroute) {\n                    logger.info(\"rerouting shards: [{}]\", explanation);\n                    // Execute an empty reroute, but don't block on the response\n                    client.admin().cluster().prepareReroute().execute();\n                }\n            }\n        }","id":26806,"modified_method":"@Override\n        public void onNewInfo(ClusterInfo info) {\n            Map<String, DiskUsage> usages = info.getNodeLeastAvailableDiskUsages();\n            if (usages != null) {\n                boolean reroute = false;\n                String explanation = \"\";\n\n                // Garbage collect nodes that have been removed from the cluster\n                // from the map that tracks watermark crossing\n                Set<String> nodes = usages.keySet();\n                for (String node : nodeHasPassedWatermark) {\n                    if (nodes.contains(node) == false) {\n                        nodeHasPassedWatermark.remove(node);\n                    }\n                }\n\n                for (Map.Entry<String, DiskUsage> entry : usages.entrySet()) {\n                    String node = entry.getKey();\n                    DiskUsage usage = entry.getValue();\n                    warnAboutDiskIfNeeded(usage);\n                    if (usage.getFreeBytes() < DiskThresholdDecider.this.freeBytesThresholdHigh.bytes() ||\n                            usage.getFreeDiskAsPercentage() < DiskThresholdDecider.this.freeDiskThresholdHigh) {\n                        if ((System.nanoTime() - lastRunNS) > DiskThresholdDecider.this.rerouteInterval.nanos()) {\n                            lastRunNS = System.nanoTime();\n                            reroute = true;\n                            explanation = \"high disk watermark exceeded on one or more nodes\";\n                        } else {\n                            logger.debug(\"high disk watermark exceeded on {} but an automatic reroute has occurred in the last [{}], skipping reroute\",\n                                    node, DiskThresholdDecider.this.rerouteInterval);\n                        }\n                        nodeHasPassedWatermark.add(node);\n                    } else if (usage.getFreeBytes() < DiskThresholdDecider.this.freeBytesThresholdLow.bytes() ||\n                            usage.getFreeDiskAsPercentage() < DiskThresholdDecider.this.freeDiskThresholdLow) {\n                        nodeHasPassedWatermark.add(node);\n                    } else {\n                        if (nodeHasPassedWatermark.contains(node)) {\n                            // The node has previously been over the high or\n                            // low watermark, but is no longer, so we should\n                            // reroute so any unassigned shards can be allocated\n                            // if they are able to be\n                            if ((System.nanoTime() - lastRunNS) > DiskThresholdDecider.this.rerouteInterval.nanos()) {\n                                lastRunNS = System.nanoTime();\n                                reroute = true;\n                                explanation = \"one or more nodes has gone under the high or low watermark\";\n                                nodeHasPassedWatermark.remove(node);\n                            } else {\n                                logger.debug(\"{} has gone below a disk threshold, but an automatic reroute has occurred in the last [{}], skipping reroute\",\n                                        node, DiskThresholdDecider.this.rerouteInterval);\n                            }\n                        }\n                    }\n                }\n                if (reroute) {\n                    logger.info(\"rerouting shards: [{}]\", explanation);\n                    // Execute an empty reroute, but don't block on the response\n                    client.admin().cluster().prepareReroute().execute();\n                }\n            }\n        }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private DiskUsage getDiskUsage(RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        Map<String, DiskUsage> usages = clusterInfo.getNodeDiskUsages();\n        DiskUsage usage = usages.get(node.nodeId());\n        if (usage == null) {\n            // If there is no usage, and we have other nodes in the cluster,\n            // use the average usage for all nodes as the usage for this node\n            usage = averageUsage(node, usages);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"unable to determine disk usage for {}, defaulting to average across nodes [{} total] [{} free] [{}% free]\",\n                        node.nodeId(), usage.getTotalBytes(), usage.getFreeBytes(), usage.getFreeDiskAsPercentage());\n            }\n        }\n\n        if (includeRelocations) {\n            long relocatingShardsSize = sizeOfRelocatingShards(node, clusterInfo, true);\n            DiskUsage usageIncludingRelocations = new DiskUsage(node.nodeId(), node.node().name(),\n                    usage.getTotalBytes(), usage.getFreeBytes() - relocatingShardsSize);\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"usage without relocations: {}\", usage);\n                logger.trace(\"usage with relocations: [{} bytes] {}\", relocatingShardsSize, usageIncludingRelocations);\n            }\n            usage = usageIncludingRelocations;\n        }\n        return usage;\n    }","id":26807,"modified_method":"private DiskUsage getDiskUsage(RoutingNode node, RoutingAllocation allocation,  Map<String, DiskUsage> usages) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        DiskUsage usage = usages.get(node.nodeId());\n        if (usage == null) {\n            // If there is no usage, and we have other nodes in the cluster,\n            // use the average usage for all nodes as the usage for this node\n            usage = averageUsage(node, usages);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"unable to determine disk usage for {}, defaulting to average across nodes [{} total] [{} free] [{}% free]\",\n                        node.nodeId(), usage.getTotalBytes(), usage.getFreeBytes(), usage.getFreeDiskAsPercentage());\n            }\n        }\n\n        if (includeRelocations) {\n            long relocatingShardsSize = sizeOfRelocatingShards(node, clusterInfo, true);\n            DiskUsage usageIncludingRelocations = new DiskUsage(node.nodeId(), node.node().name(), \"_na_\",\n                    usage.getTotalBytes(), usage.getFreeBytes() - relocatingShardsSize);\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"usage without relocations: {}\", usage);\n                logger.trace(\"usage with relocations: [{} bytes] {}\", relocatingShardsSize, usageIncludingRelocations);\n            }\n            usage = usageIncludingRelocations;\n        }\n        return usage;\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testShardRelocationsTakenIntoAccount() {\n        Settings diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, 0.7)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, 0.8).build();\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node1\", new DiskUsage(\"node1\", \"n1\", 100, 40)); // 60% used\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"n2\", 100, 40)); // 60% used\n        usages.put(\"node2\", new DiskUsage(\"node3\", \"n3\", 100, 40)); // 60% used\n\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][p]\", 14L); // 14 bytes\n        shardSizes.put(\"[test][0][r]\", 14L);\n        shardSizes.put(\"[test2][0][p]\", 1L); // 1 bytes\n        shardSizes.put(\"[test2][0][r]\", 1L);\n        final ClusterInfo clusterInfo = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n\n        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        ClusterInfoService cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n\n        AllocationService strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .put(IndexMetaData.builder(\"test2\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test2\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n\n        logger.info(\"--> adding two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .put(newNode(\"node1\"))\n                        .put(newNode(\"node2\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // shards should be initializing\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n\n        logger.info(\"--> start the shards\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that we're able to start the primary and replicas\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(4));\n\n        logger.info(\"--> adding node3\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                        .put(newNode(\"node3\"))\n        ).build();\n\n        AllocationCommand relocate1 = new MoveAllocationCommand(new ShardId(\"test\", 0), \"node2\", \"node3\");\n        AllocationCommands cmds = new AllocationCommands(relocate1);\n\n        routingTable = strategy.reroute(clusterState, cmds).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        AllocationCommand relocate2 = new MoveAllocationCommand(new ShardId(\"test2\", 0), \"node2\", \"node3\");\n        cmds = new AllocationCommands(relocate2);\n\n        try {\n            // The shard for the \"test\" index is already being relocated to\n            // node3, which will put it over the low watermark when it\n            // completes, with shard relocations taken into account this should\n            // throw an exception about not being able to complete\n            strategy.reroute(clusterState, cmds).routingTable();\n            fail(\"should not have been able to reroute the shard\");\n        } catch (IllegalArgumentException e) {\n            assertThat(\"can't allocated because there isn't enough room: \" + e.getMessage(),\n                    e.getMessage().contains(\"more than allowed [70.0%] used disk on node, free: [26.0%]\"), equalTo(true));\n        }\n\n    }","id":26808,"modified_method":"@Test\n    public void testShardRelocationsTakenIntoAccount() {\n        Settings diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, 0.7)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, 0.8).build();\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node1\", new DiskUsage(\"node1\", \"n1\", \"_na_\", 100, 40)); // 60% used\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"n2\", \"_na_\", 100, 40)); // 60% used\n        usages.put(\"node2\", new DiskUsage(\"node3\", \"n3\", \"_na_\", 100, 40)); // 60% used\n\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][p]\", 14L); // 14 bytes\n        shardSizes.put(\"[test][0][r]\", 14L);\n        shardSizes.put(\"[test2][0][p]\", 1L); // 1 bytes\n        shardSizes.put(\"[test2][0][r]\", 1L);\n        final ClusterInfo clusterInfo = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n\n        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        ClusterInfoService cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n\n        AllocationService strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .put(IndexMetaData.builder(\"test2\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test2\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n\n        logger.info(\"--> adding two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .put(newNode(\"node1\"))\n                        .put(newNode(\"node2\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // shards should be initializing\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(4));\n\n        logger.info(\"--> start the shards\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that we're able to start the primary and replicas\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(4));\n\n        logger.info(\"--> adding node3\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                        .put(newNode(\"node3\"))\n        ).build();\n\n        AllocationCommand relocate1 = new MoveAllocationCommand(new ShardId(\"test\", 0), \"node2\", \"node3\");\n        AllocationCommands cmds = new AllocationCommands(relocate1);\n\n        routingTable = strategy.reroute(clusterState, cmds).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        AllocationCommand relocate2 = new MoveAllocationCommand(new ShardId(\"test2\", 0), \"node2\", \"node3\");\n        cmds = new AllocationCommands(relocate2);\n\n        try {\n            // The shard for the \"test\" index is already being relocated to\n            // node3, which will put it over the low watermark when it\n            // completes, with shard relocations taken into account this should\n            // throw an exception about not being able to complete\n            strategy.reroute(clusterState, cmds).routingTable();\n            fail(\"should not have been able to reroute the shard\");\n        } catch (IllegalArgumentException e) {\n            assertThat(\"can't allocated because there isn't enough room: \" + e.getMessage(),\n                    e.getMessage().contains(\"more than allowed [70.0%] used disk on node, free: [26.0%]\"), equalTo(true));\n        }\n\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void diskThresholdWithAbsoluteSizesTest() {\n        Settings diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, \"30b\")\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, \"9b\").build();\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node1\", new DiskUsage(\"node1\", \"n1\", 100, 10)); // 90% used\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"n2\", 100, 10)); // 90% used\n        usages.put(\"node3\", new DiskUsage(\"node3\", \"n3\", 100, 60)); // 40% used\n        usages.put(\"node4\", new DiskUsage(\"node4\", \"n4\", 100, 80)); // 20% used\n        usages.put(\"node5\", new DiskUsage(\"node5\", \"n5\", 100, 85)); // 15% used\n\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][p]\", 10L); // 10 bytes\n        shardSizes.put(\"[test][0][r]\", 10L);\n        final ClusterInfo clusterInfo = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n\n        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        ClusterInfoService cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n\n        AllocationService strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(2))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n\n        logger.info(\"--> adding node1 and node2 node\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .put(newNode(\"node1\"))\n                        .put(newNode(\"node2\"))\n        ).build();\n\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // Primary should initialize, even though both nodes are over the limit initialize\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(1));\n\n        String nodeWithPrimary, nodeWithoutPrimary;\n        if (clusterState.getRoutingNodes().node(\"node1\").size() == 1) {\n            nodeWithPrimary = \"node1\";\n            nodeWithoutPrimary = \"node2\";\n        } else {\n            nodeWithPrimary = \"node2\";\n            nodeWithoutPrimary = \"node1\";\n        }\n        logger.info(\"--> nodeWithPrimary: {}\", nodeWithPrimary);\n        logger.info(\"--> nodeWithoutPrimary: {}\", nodeWithoutPrimary);\n\n        // Make node without the primary now habitable to replicas\n        usages.put(nodeWithoutPrimary, new DiskUsage(nodeWithoutPrimary, \"\", 100, 35)); // 65% used\n        final ClusterInfo clusterInfo2 = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n        cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo2;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n        strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // Now the replica should be able to initialize\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(2));\n\n        logger.info(\"--> start the shards (primaries)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that we're able to start the primary and replica, since they were both initializing\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(2));\n        // Assert that node1 got a single shard (the primary), even though its disk usage is too high\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(1));\n        // Assert that node2 got a single shard (a replica)\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n\n        // Assert that one replica is still unassigned\n        //assertThat(clusterState.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1));\n\n        logger.info(\"--> adding node3\");\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .put(newNode(\"node3\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that the replica is initialized now that node3 is available with enough space\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(2));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> start the shards (replicas)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that all replicas could be started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(3));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n\n        logger.info(\"--> changing decider settings\");\n\n        // Set the low threshold to 60 instead of 70\n        // Set the high threshold to 70 instead of 80\n        // node2 now should not have new shards allocated to it, but shards can remain\n        diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, \"40b\")\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, \"30b\").build();\n\n        deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // Shards remain started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(3));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n\n        logger.info(\"--> changing settings again\");\n\n        // Set the low threshold to 50 instead of 60\n        // Set the high threshold to 60 instead of 70\n        // node2 now should not have new shards allocated to it, and shards cannot remain\n        diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, \"50b\")\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, \"40b\").build();\n\n        deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Shards remain started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(3));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(1));\n        // Shard hasn't been moved off of node2 yet because there's nowhere for it to go\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n\n        logger.info(\"--> adding node4\");\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .put(newNode(\"node4\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Shards remain started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(2));\n        // One shard is relocating off of node1\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> apply INITIALIZING shards\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // primary shard already has been relocated away\n        assertThat(clusterState.getRoutingNodes().node(nodeWithPrimary).size(), equalTo(0));\n        // node with increased space still has its shard\n        assertThat(clusterState.getRoutingNodes().node(nodeWithoutPrimary).size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node4\").size(), equalTo(1));\n\n        logger.info(\"--> adding node5\");\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                        .put(newNode(\"node5\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Shards remain started on node3 and node4\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(2));\n        // One shard is relocating off of node2 now\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(1));\n        // Initializing on node5\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> apply INITIALIZING shards\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logger.info(\"--> final cluster state:\");\n        logShardStates(clusterState);\n        // Node1 still has no shards because it has no space for them\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(0));\n        // Node5 is available now, so the shard is moved off of node2\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(0));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node4\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node5\").size(), equalTo(1));\n    }","id":26809,"modified_method":"@Test\n    public void diskThresholdWithAbsoluteSizesTest() {\n        Settings diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, \"30b\")\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, \"9b\").build();\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node1\", new DiskUsage(\"node1\", \"n1\", \"_na_\", 100, 10)); // 90% used\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"n2\", \"_na_\", 100, 10)); // 90% used\n        usages.put(\"node3\", new DiskUsage(\"node3\", \"n3\", \"_na_\", 100, 60)); // 40% used\n        usages.put(\"node4\", new DiskUsage(\"node4\", \"n4\", \"_na_\", 100, 80)); // 20% used\n        usages.put(\"node5\", new DiskUsage(\"node5\", \"n5\", \"_na_\", 100, 85)); // 15% used\n\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][p]\", 10L); // 10 bytes\n        shardSizes.put(\"[test][0][r]\", 10L);\n        final ClusterInfo clusterInfo = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n\n        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        ClusterInfoService cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n\n        AllocationService strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(2))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n\n        logger.info(\"--> adding node1 and node2 node\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                        .put(newNode(\"node1\"))\n                        .put(newNode(\"node2\"))\n        ).build();\n\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // Primary should initialize, even though both nodes are over the limit initialize\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(1));\n\n        String nodeWithPrimary, nodeWithoutPrimary;\n        if (clusterState.getRoutingNodes().node(\"node1\").size() == 1) {\n            nodeWithPrimary = \"node1\";\n            nodeWithoutPrimary = \"node2\";\n        } else {\n            nodeWithPrimary = \"node2\";\n            nodeWithoutPrimary = \"node1\";\n        }\n        logger.info(\"--> nodeWithPrimary: {}\", nodeWithPrimary);\n        logger.info(\"--> nodeWithoutPrimary: {}\", nodeWithoutPrimary);\n\n        // Make node without the primary now habitable to replicas\n        usages.put(nodeWithoutPrimary, new DiskUsage(nodeWithoutPrimary, \"\", \"_na_\", 100, 35)); // 65% used\n        final ClusterInfo clusterInfo2 = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n        cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo2;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n        strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // Now the replica should be able to initialize\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(2));\n\n        logger.info(\"--> start the shards (primaries)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that we're able to start the primary and replica, since they were both initializing\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(2));\n        // Assert that node1 got a single shard (the primary), even though its disk usage is too high\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(1));\n        // Assert that node2 got a single shard (a replica)\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n\n        // Assert that one replica is still unassigned\n        //assertThat(clusterState.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1));\n\n        logger.info(\"--> adding node3\");\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .put(newNode(\"node3\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that the replica is initialized now that node3 is available with enough space\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(2));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> start the shards (replicas)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that all replicas could be started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(3));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n\n        logger.info(\"--> changing decider settings\");\n\n        // Set the low threshold to 60 instead of 70\n        // Set the high threshold to 70 instead of 80\n        // node2 now should not have new shards allocated to it, but shards can remain\n        diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, \"40b\")\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, \"30b\").build();\n\n        deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // Shards remain started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(3));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n\n        logger.info(\"--> changing settings again\");\n\n        // Set the low threshold to 50 instead of 60\n        // Set the high threshold to 60 instead of 70\n        // node2 now should not have new shards allocated to it, and shards cannot remain\n        diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, \"50b\")\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, \"40b\").build();\n\n        deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Shards remain started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(3));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(1));\n        // Shard hasn't been moved off of node2 yet because there's nowhere for it to go\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n\n        logger.info(\"--> adding node4\");\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .put(newNode(\"node4\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Shards remain started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(2));\n        // One shard is relocating off of node1\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> apply INITIALIZING shards\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // primary shard already has been relocated away\n        assertThat(clusterState.getRoutingNodes().node(nodeWithPrimary).size(), equalTo(0));\n        // node with increased space still has its shard\n        assertThat(clusterState.getRoutingNodes().node(nodeWithoutPrimary).size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node4\").size(), equalTo(1));\n\n        logger.info(\"--> adding node5\");\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                        .put(newNode(\"node5\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Shards remain started on node3 and node4\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(2));\n        // One shard is relocating off of node2 now\n        assertThat(clusterState.getRoutingNodes().shardsWithState(RELOCATING).size(), equalTo(1));\n        // Initializing on node5\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> apply INITIALIZING shards\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logger.info(\"--> final cluster state:\");\n        logShardStates(clusterState);\n        // Node1 still has no shards because it has no space for them\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(0));\n        // Node5 is available now, so the shard is moved off of node2\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(0));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node4\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node5\").size(), equalTo(1));\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void averageUsageUnitTest() {\n        RoutingNode rn = new RoutingNode(\"node1\", newNode(\"node1\"));\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY);\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"n2\", 100, 50)); // 50% used\n        usages.put(\"node3\", new DiskUsage(\"node3\", \"n3\", 100, 0));  // 100% used\n\n        DiskUsage node1Usage = decider.averageUsage(rn, usages);\n        assertThat(node1Usage.getTotalBytes(), equalTo(100L));\n        assertThat(node1Usage.getFreeBytes(), equalTo(25L));\n    }","id":26810,"modified_method":"@Test\n    public void averageUsageUnitTest() {\n        RoutingNode rn = new RoutingNode(\"node1\", newNode(\"node1\"));\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY);\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"n2\", \"_na_\", 100, 50)); // 50% used\n        usages.put(\"node3\", new DiskUsage(\"node3\", \"n3\", \"_na_\", 100, 0));  // 100% used\n\n        DiskUsage node1Usage = decider.averageUsage(rn, usages);\n        assertThat(node1Usage.getTotalBytes(), equalTo(100L));\n        assertThat(node1Usage.getFreeBytes(), equalTo(25L));\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void freeDiskPercentageAfterShardAssignedUnitTest() {\n        RoutingNode rn = new RoutingNode(\"node1\", newNode(\"node1\"));\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY);\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"n2\", 100, 50)); // 50% used\n        usages.put(\"node3\", new DiskUsage(\"node3\", \"n3\", 100, 0));  // 100% used\n\n        Double after = decider.freeDiskPercentageAfterShardAssigned(new DiskUsage(\"node2\", \"n2\", 100, 30), 11L);\n        assertThat(after, equalTo(19.0));\n    }","id":26811,"modified_method":"@Test\n    public void freeDiskPercentageAfterShardAssignedUnitTest() {\n        RoutingNode rn = new RoutingNode(\"node1\", newNode(\"node1\"));\n        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY);\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"n2\", \"_na_\", 100, 50)); // 50% used\n        usages.put(\"node3\", new DiskUsage(\"node3\", \"n3\", \"_na_\", 100, 0));  // 100% used\n\n        Double after = decider.freeDiskPercentageAfterShardAssigned(new DiskUsage(\"node2\", \"n2\", \"_na_\", 100, 30), 11L);\n        assertThat(after, equalTo(19.0));\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void diskThresholdWithShardSizes() {\n        Settings diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, 0.7)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, \"71%\").build();\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node1\", new DiskUsage(\"node1\", \"n1\", 100, 31)); // 69% used\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"n2\", 100, 1));  // 99% used\n\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][p]\", 10L); // 10 bytes\n        final ClusterInfo clusterInfo = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n\n        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        ClusterInfoService cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n\n        AllocationService strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(0))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n        logger.info(\"--> adding node1\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .put(newNode(\"node1\"))\n                .put(newNode(\"node2\")) // node2 is added because DiskThresholdDecider automatically ignore single-node clusters\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logger.info(\"--> start the shards (primaries)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // Shard can't be allocated to node1 (or node2) because it would cause too much usage\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n        // No shards are started, no nodes have enough disk for allocation\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(0));\n    }","id":26812,"modified_method":"@Test\n    public void diskThresholdWithShardSizes() {\n        Settings diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, 0.7)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, \"71%\").build();\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node1\", new DiskUsage(\"node1\", \"n1\", \"_na_\", 100, 31)); // 69% used\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"n2\", \"_na_\", 100, 1));  // 99% used\n\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][p]\", 10L); // 10 bytes\n        final ClusterInfo clusterInfo = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n\n        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        ClusterInfoService cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n\n        AllocationService strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(0))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n        logger.info(\"--> adding node1\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .put(newNode(\"node1\"))\n                .put(newNode(\"node2\")) // node2 is added because DiskThresholdDecider automatically ignore single-node clusters\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logger.info(\"--> start the shards (primaries)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // Shard can't be allocated to node1 (or node2) because it would cause too much usage\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n        // No shards are started, no nodes have enough disk for allocation\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(0));\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void unknownDiskUsageTest() {\n        Settings diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, 0.7)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, 0.85).build();\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"node2\", 100, 50)); // 50% used\n        usages.put(\"node3\", new DiskUsage(\"node3\", \"node3\", 100, 0));  // 100% used\n\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][p]\", 10L); // 10 bytes\n        shardSizes.put(\"[test][0][r]\", 10L); // 10 bytes\n        final ClusterInfo clusterInfo = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n\n        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        ClusterInfoService cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n\n        AllocationService strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(0))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n        logger.info(\"--> adding node1\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .put(newNode(\"node1\"))\n                .put(newNode(\"node3\")) // node3 is added because DiskThresholdDecider automatically ignore single-node clusters\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        // Shard can be allocated to node1, even though it only has 25% free,\n        // because it's a primary that's never been allocated before\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> start the shards (primaries)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // A single shard is started on node1, even though it normally would not\n        // be allowed, because it's a primary that hasn't been allocated, and node1\n        // is still below the high watermark (unlike node3)\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(1));\n    }","id":26813,"modified_method":"@Test\n    public void unknownDiskUsageTest() {\n        Settings diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, 0.7)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, 0.85).build();\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"node2\", \"_na_\", 100, 50)); // 50% used\n        usages.put(\"node3\", new DiskUsage(\"node3\", \"node3\", \"_na_\", 100, 0));  // 100% used\n\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][p]\", 10L); // 10 bytes\n        shardSizes.put(\"[test][0][r]\", 10L); // 10 bytes\n        final ClusterInfo clusterInfo = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n\n        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        ClusterInfoService cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n\n        AllocationService strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(0))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n        logger.info(\"--> adding node1\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .put(newNode(\"node1\"))\n                .put(newNode(\"node3\")) // node3 is added because DiskThresholdDecider automatically ignore single-node clusters\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        // Shard can be allocated to node1, even though it only has 25% free,\n        // because it's a primary that's never been allocated before\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> start the shards (primaries)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // A single shard is started on node1, even though it normally would not\n        // be allowed, because it's a primary that hasn't been allocated, and node1\n        // is still below the high watermark (unlike node3)\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(1));\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testCanRemainWithShardRelocatingAway() {\n        Settings diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, \"60%\")\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, \"70%\").build();\n\n        // We have an index with 2 primary shards each taking 40 bytes. Each node has 100 bytes available\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node1\", new DiskUsage(\"node1\", \"n1\", 100, 20)); // 80% used\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"n2\", 100, 100)); // 0% used\n\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][p]\", 40L);\n        shardSizes.put(\"[test][1][p]\", 40L);\n        final ClusterInfo clusterInfo = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n\n        DiskThresholdDecider diskThresholdDecider = new DiskThresholdDecider(diskSettings);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        DiscoveryNode discoveryNode1 = new DiscoveryNode(\"node1\", new LocalTransportAddress(\"1\"), Version.CURRENT);\n        DiscoveryNode discoveryNode2 = new DiscoveryNode(\"node2\", new LocalTransportAddress(\"2\"), Version.CURRENT);\n        DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().put(discoveryNode1).put(discoveryNode2).build();\n\n        ClusterState baseClusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(discoveryNodes)\n                .build();\n\n        // Two shards consuming each 80% of disk space while 70% is allowed, so shard 0 isn't allowed here\n        ShardRouting firstRouting = TestShardRouting.newShardRouting(\"test\", 0, \"node1\", null, null, true, ShardRoutingState.STARTED, 1);\n        ShardRouting secondRouting = TestShardRouting.newShardRouting(\"test\", 1, \"node1\", null, null, true, ShardRoutingState.STARTED, 1);\n        RoutingNode firstRoutingNode = new RoutingNode(\"node1\", discoveryNode1, Arrays.asList(firstRouting, secondRouting));\n        RoutingTable.Builder builder = RoutingTable.builder().add(\n                IndexRoutingTable.builder(\"test\")\n                        .addIndexShard(new IndexShardRoutingTable.Builder(new ShardId(\"test\", 0))\n                                        .addShard(firstRouting)\n                                        .build()\n                        )\n                        .addIndexShard(new IndexShardRoutingTable.Builder(new ShardId(\"test\", 1))\n                                        .addShard(secondRouting)\n                                        .build()\n                        )\n        );\n        ClusterState clusterState = ClusterState.builder(baseClusterState).routingTable(builder).build();\n        RoutingAllocation routingAllocation = new RoutingAllocation(null, new RoutingNodes(clusterState), discoveryNodes, clusterInfo);\n        Decision decision = diskThresholdDecider.canRemain(firstRouting, firstRoutingNode, routingAllocation);\n        assertThat(decision.type(), equalTo(Decision.Type.NO));\n\n        // Two shards consuming each 80% of disk space while 70% is allowed, but one is relocating, so shard 0 can stay\n        firstRouting = TestShardRouting.newShardRouting(\"test\", 0, \"node1\", null, null, true, ShardRoutingState.STARTED, 1);\n        secondRouting = TestShardRouting.newShardRouting(\"test\", 1, \"node1\", \"node2\", null, true, ShardRoutingState.RELOCATING, 1);\n        firstRoutingNode = new RoutingNode(\"node1\", discoveryNode1, Arrays.asList(firstRouting, secondRouting));\n        builder = RoutingTable.builder().add(\n                IndexRoutingTable.builder(\"test\")\n                        .addIndexShard(new IndexShardRoutingTable.Builder(new ShardId(\"test\", 0))\n                                        .addShard(firstRouting)\n                                        .build()\n                        )\n                        .addIndexShard(new IndexShardRoutingTable.Builder(new ShardId(\"test\", 1))\n                                        .addShard(secondRouting)\n                                        .build()\n                        )\n        );\n        clusterState = ClusterState.builder(baseClusterState).routingTable(builder).build();\n        routingAllocation = new RoutingAllocation(null, new RoutingNodes(clusterState), discoveryNodes, clusterInfo);\n        decision = diskThresholdDecider.canRemain(firstRouting, firstRoutingNode, routingAllocation);\n        assertThat(decision.type(), equalTo(Decision.Type.YES));\n\n        // Creating AllocationService instance and the services it depends on...\n        ClusterInfoService cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY, new HashSet<>(Arrays.asList(\n            new SameShardAllocationDecider(Settings.EMPTY), diskThresholdDecider\n        )));\n        AllocationService strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n        // Ensure that the reroute call doesn't alter the routing table, since the first primary is relocating away\n        // and therefor we will have sufficient disk space on node1.\n        RoutingAllocation.Result result = strategy.reroute(clusterState);\n        assertThat(result.changed(), is(false));\n        assertThat(result.routingTable().index(\"test\").getShards().get(0).primaryShard().state(), equalTo(STARTED));\n        assertThat(result.routingTable().index(\"test\").getShards().get(0).primaryShard().currentNodeId(), equalTo(\"node1\"));\n        assertThat(result.routingTable().index(\"test\").getShards().get(0).primaryShard().relocatingNodeId(), nullValue());\n        assertThat(result.routingTable().index(\"test\").getShards().get(1).primaryShard().state(), equalTo(RELOCATING));\n        assertThat(result.routingTable().index(\"test\").getShards().get(1).primaryShard().currentNodeId(), equalTo(\"node1\"));\n        assertThat(result.routingTable().index(\"test\").getShards().get(1).primaryShard().relocatingNodeId(), equalTo(\"node2\"));\n    }","id":26814,"modified_method":"@Test\n    public void testCanRemainWithShardRelocatingAway() {\n        Settings diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, \"60%\")\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, \"70%\").build();\n\n        // We have an index with 2 primary shards each taking 40 bytes. Each node has 100 bytes available\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node1\", new DiskUsage(\"node1\", \"n1\", \"_na_\", 100, 20)); // 80% used\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"n2\", \"_na_\", 100, 100)); // 0% used\n\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][p]\", 40L);\n        shardSizes.put(\"[test][1][p]\", 40L);\n        final ClusterInfo clusterInfo = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n\n        DiskThresholdDecider diskThresholdDecider = new DiskThresholdDecider(diskSettings);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        DiscoveryNode discoveryNode1 = new DiscoveryNode(\"node1\", new LocalTransportAddress(\"1\"), Version.CURRENT);\n        DiscoveryNode discoveryNode2 = new DiscoveryNode(\"node2\", new LocalTransportAddress(\"2\"), Version.CURRENT);\n        DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().put(discoveryNode1).put(discoveryNode2).build();\n\n        ClusterState baseClusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(discoveryNodes)\n                .build();\n\n        // Two shards consuming each 80% of disk space while 70% is allowed, so shard 0 isn't allowed here\n        ShardRouting firstRouting = TestShardRouting.newShardRouting(\"test\", 0, \"node1\", null, null, true, ShardRoutingState.STARTED, 1);\n        ShardRouting secondRouting = TestShardRouting.newShardRouting(\"test\", 1, \"node1\", null, null, true, ShardRoutingState.STARTED, 1);\n        RoutingNode firstRoutingNode = new RoutingNode(\"node1\", discoveryNode1, Arrays.asList(firstRouting, secondRouting));\n        RoutingTable.Builder builder = RoutingTable.builder().add(\n                IndexRoutingTable.builder(\"test\")\n                        .addIndexShard(new IndexShardRoutingTable.Builder(new ShardId(\"test\", 0))\n                                        .addShard(firstRouting)\n                                        .build()\n                        )\n                        .addIndexShard(new IndexShardRoutingTable.Builder(new ShardId(\"test\", 1))\n                                        .addShard(secondRouting)\n                                        .build()\n                        )\n        );\n        ClusterState clusterState = ClusterState.builder(baseClusterState).routingTable(builder).build();\n        RoutingAllocation routingAllocation = new RoutingAllocation(null, new RoutingNodes(clusterState), discoveryNodes, clusterInfo);\n        Decision decision = diskThresholdDecider.canRemain(firstRouting, firstRoutingNode, routingAllocation);\n        assertThat(decision.type(), equalTo(Decision.Type.NO));\n\n        // Two shards consuming each 80% of disk space while 70% is allowed, but one is relocating, so shard 0 can stay\n        firstRouting = TestShardRouting.newShardRouting(\"test\", 0, \"node1\", null, null, true, ShardRoutingState.STARTED, 1);\n        secondRouting = TestShardRouting.newShardRouting(\"test\", 1, \"node1\", \"node2\", null, true, ShardRoutingState.RELOCATING, 1);\n        firstRoutingNode = new RoutingNode(\"node1\", discoveryNode1, Arrays.asList(firstRouting, secondRouting));\n        builder = RoutingTable.builder().add(\n                IndexRoutingTable.builder(\"test\")\n                        .addIndexShard(new IndexShardRoutingTable.Builder(new ShardId(\"test\", 0))\n                                        .addShard(firstRouting)\n                                        .build()\n                        )\n                        .addIndexShard(new IndexShardRoutingTable.Builder(new ShardId(\"test\", 1))\n                                        .addShard(secondRouting)\n                                        .build()\n                        )\n        );\n        clusterState = ClusterState.builder(baseClusterState).routingTable(builder).build();\n        routingAllocation = new RoutingAllocation(null, new RoutingNodes(clusterState), discoveryNodes, clusterInfo);\n        decision = diskThresholdDecider.canRemain(firstRouting, firstRoutingNode, routingAllocation);\n        assertThat(decision.type(), equalTo(Decision.Type.YES));\n\n        // Creating AllocationService instance and the services it depends on...\n        ClusterInfoService cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY, new HashSet<>(Arrays.asList(\n            new SameShardAllocationDecider(Settings.EMPTY), diskThresholdDecider\n        )));\n        AllocationService strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n        // Ensure that the reroute call doesn't alter the routing table, since the first primary is relocating away\n        // and therefor we will have sufficient disk space on node1.\n        RoutingAllocation.Result result = strategy.reroute(clusterState);\n        assertThat(result.changed(), is(false));\n        assertThat(result.routingTable().index(\"test\").getShards().get(0).primaryShard().state(), equalTo(STARTED));\n        assertThat(result.routingTable().index(\"test\").getShards().get(0).primaryShard().currentNodeId(), equalTo(\"node1\"));\n        assertThat(result.routingTable().index(\"test\").getShards().get(0).primaryShard().relocatingNodeId(), nullValue());\n        assertThat(result.routingTable().index(\"test\").getShards().get(1).primaryShard().state(), equalTo(RELOCATING));\n        assertThat(result.routingTable().index(\"test\").getShards().get(1).primaryShard().currentNodeId(), equalTo(\"node1\"));\n        assertThat(result.routingTable().index(\"test\").getShards().get(1).primaryShard().relocatingNodeId(), equalTo(\"node2\"));\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void diskThresholdTest() {\n        Settings diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, 0.7)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, 0.8).build();\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node1\", new DiskUsage(\"node1\", \"node1\", 100, 10)); // 90% used\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"node2\", 100, 35)); // 65% used\n        usages.put(\"node3\", new DiskUsage(\"node3\", \"node3\", 100, 60)); // 40% used\n        usages.put(\"node4\", new DiskUsage(\"node4\", \"node4\", 100, 80)); // 20% used\n\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][p]\", 10L); // 10 bytes\n        shardSizes.put(\"[test][0][r]\", 10L);\n        final ClusterInfo clusterInfo = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n\n        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        ClusterInfoService cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n\n        AllocationService strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n\n        logger.info(\"--> adding two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .put(newNode(\"node1\"))\n                .put(newNode(\"node2\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // Primary shard should be initializing, replica should not\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> start the shards (primaries)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that we're able to start the primary\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(1));\n        // Assert that node1 didn't get any shards because its disk usage is too high\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(0));\n\n        logger.info(\"--> start the shards (replicas)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that the replica couldn't be started since node1 doesn't have enough space\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(1));\n\n        logger.info(\"--> adding node3\");\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .put(newNode(\"node3\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that the replica is initialized now that node3 is available with enough space\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> start the shards (replicas)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that the replica couldn't be started since node1 doesn't have enough space\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(2));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(0));\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n\n        logger.info(\"--> changing decider settings\");\n\n        // Set the low threshold to 60 instead of 70\n        // Set the high threshold to 70 instead of 80\n        // node2 now should not have new shards allocated to it, but shards can remain\n        diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, \"60%\")\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, 0.7).build();\n\n        deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // Shards remain started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(2));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(0));\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n\n        logger.info(\"--> changing settings again\");\n\n        // Set the low threshold to 50 instead of 60\n        // Set the high threshold to 60 instead of 70\n        // node2 now should not have new shards allocated to it, and shards cannot remain\n        diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, 0.5)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, 0.6).build();\n\n        deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Shards remain started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(2));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(0));\n        // Shard hasn't been moved off of node2 yet because there's nowhere for it to go\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n\n        logger.info(\"--> adding node4\");\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .put(newNode(\"node4\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Shards remain started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> apply INITIALIZING shards\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(0));\n        // Node4 is available now, so the shard is moved off of node2\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(0));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node4\").size(), equalTo(1));\n    }","id":26815,"modified_method":"@Test\n    public void diskThresholdTest() {\n        Settings diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, 0.7)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, 0.8).build();\n\n        Map<String, DiskUsage> usages = new HashMap<>();\n        usages.put(\"node1\", new DiskUsage(\"node1\", \"node1\", \"_na_\", 100, 10)); // 90% used\n        usages.put(\"node2\", new DiskUsage(\"node2\", \"node2\", \"_na_\", 100, 35)); // 65% used\n        usages.put(\"node3\", new DiskUsage(\"node3\", \"node3\", \"_na_\", 100, 60)); // 40% used\n        usages.put(\"node4\", new DiskUsage(\"node4\", \"node4\", \"_na_\", 100, 80)); // 20% used\n\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][p]\", 10L); // 10 bytes\n        shardSizes.put(\"[test][0][r]\", 10L);\n        final ClusterInfo clusterInfo = new ClusterInfo(Collections.unmodifiableMap(usages), Collections.unmodifiableMap(usages), Collections.unmodifiableMap(shardSizes));\n\n        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        ClusterInfoService cis = new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                logger.info(\"--> calling fake getClusterInfo\");\n                return clusterInfo;\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n                // noop\n            }\n        };\n        AllocationService strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n\n        logger.info(\"--> adding two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n                .put(newNode(\"node1\"))\n                .put(newNode(\"node2\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // Primary shard should be initializing, replica should not\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> start the shards (primaries)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that we're able to start the primary\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(1));\n        // Assert that node1 didn't get any shards because its disk usage is too high\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(0));\n\n        logger.info(\"--> start the shards (replicas)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that the replica couldn't be started since node1 doesn't have enough space\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(1));\n\n        logger.info(\"--> adding node3\");\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .put(newNode(\"node3\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that the replica is initialized now that node3 is available with enough space\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> start the shards (replicas)\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Assert that the replica couldn't be started since node1 doesn't have enough space\n        assertThat(clusterState.getRoutingNodes().shardsWithState(ShardRoutingState.STARTED).size(), equalTo(2));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(0));\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n\n        logger.info(\"--> changing decider settings\");\n\n        // Set the low threshold to 60 instead of 70\n        // Set the high threshold to 70 instead of 80\n        // node2 now should not have new shards allocated to it, but shards can remain\n        diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, \"60%\")\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, 0.7).build();\n\n        deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        logShardStates(clusterState);\n\n        // Shards remain started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(2));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(0));\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n\n        logger.info(\"--> changing settings again\");\n\n        // Set the low threshold to 50 instead of 60\n        // Set the high threshold to 60 instead of 70\n        // node2 now should not have new shards allocated to it, and shards cannot remain\n        diskSettings = settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, 0.5)\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, 0.6).build();\n\n        deciders = new AllocationDeciders(Settings.EMPTY,\n                new HashSet<>(Arrays.asList(\n                        new SameShardAllocationDecider(Settings.EMPTY),\n                        new DiskThresholdDecider(diskSettings))));\n\n        strategy = new AllocationService(settingsBuilder()\n                .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                .build(), deciders, makeShardsAllocators(), cis);\n\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Shards remain started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(2));\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(0));\n        // Shard hasn't been moved off of node2 yet because there's nowhere for it to go\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n\n        logger.info(\"--> adding node4\");\n\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .put(newNode(\"node4\"))\n        ).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        // Shards remain started\n        assertThat(clusterState.getRoutingNodes().shardsWithState(STARTED).size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().shardsWithState(INITIALIZING).size(), equalTo(1));\n\n        logger.info(\"--> apply INITIALIZING shards\");\n        routingTable = strategy.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        logShardStates(clusterState);\n        assertThat(clusterState.getRoutingNodes().node(\"node1\").size(), equalTo(0));\n        // Node4 is available now, so the shard is moved off of node2\n        assertThat(clusterState.getRoutingNodes().node(\"node2\").size(), equalTo(0));\n        assertThat(clusterState.getRoutingNodes().node(\"node3\").size(), equalTo(1));\n        assertThat(clusterState.getRoutingNodes().node(\"node4\").size(), equalTo(1));\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testShardSizeAndRelocatingSize() {\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][r]\", 10L);\n        shardSizes.put(\"[test][1][r]\", 100L);\n        shardSizes.put(\"[test][2][r]\", 1000L);\n        shardSizes.put(\"[other][0][p]\", 10000L);\n        ClusterInfo info = new ClusterInfo(Collections.EMPTY_MAP, shardSizes);\n        ShardRouting test_0 = ShardRouting.newUnassigned(\"test\", 0, null, false, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        ShardRoutingHelper.initialize(test_0, \"node1\");\n        ShardRoutingHelper.moveToStarted(test_0);\n        ShardRoutingHelper.relocate(test_0, \"node2\");\n\n        ShardRouting test_1 = ShardRouting.newUnassigned(\"test\", 1, null, false, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        ShardRoutingHelper.initialize(test_1, \"node2\");\n        ShardRoutingHelper.moveToStarted(test_1);\n        ShardRoutingHelper.relocate(test_1, \"node1\");\n\n        ShardRouting test_2 = ShardRouting.newUnassigned(\"test\", 2, null, false, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        ShardRoutingHelper.initialize(test_2, \"node1\");\n        ShardRoutingHelper.moveToStarted(test_2);\n\n        assertEquals(1000l, DiskThresholdDecider.getShardSize(test_2, info));\n        assertEquals(100l, DiskThresholdDecider.getShardSize(test_1, info));\n        assertEquals(10l, DiskThresholdDecider.getShardSize(test_0, info));\n\n        RoutingNode node = new RoutingNode(\"node1\", new DiscoveryNode(\"node1\", LocalTransportAddress.PROTO, Version.CURRENT), Arrays.asList(test_0, test_1.buildTargetRelocatingShard(), test_2));\n        assertEquals(100l, DiskThresholdDecider.sizeOfRelocatingShards(node, info, false));\n        assertEquals(90l, DiskThresholdDecider.sizeOfRelocatingShards(node, info, true));\n\n        ShardRouting test_3 = ShardRouting.newUnassigned(\"test\", 3, null, false, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        ShardRoutingHelper.initialize(test_3, \"node1\");\n        ShardRoutingHelper.moveToStarted(test_3);\n        assertEquals(0l, DiskThresholdDecider.getShardSize(test_3, info));\n\n\n        ShardRouting other_0 = ShardRouting.newUnassigned(\"other\", 0, null, randomBoolean(), new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        ShardRoutingHelper.initialize(other_0, \"node2\");\n        ShardRoutingHelper.moveToStarted(other_0);\n        ShardRoutingHelper.relocate(other_0, \"node1\");\n\n\n        node = new RoutingNode(\"node1\", new DiscoveryNode(\"node1\", LocalTransportAddress.PROTO, Version.CURRENT), Arrays.asList(test_0, test_1.buildTargetRelocatingShard(), test_2, other_0.buildTargetRelocatingShard()));\n        if (other_0.primary()) {\n            assertEquals(10100l, DiskThresholdDecider.sizeOfRelocatingShards(node, info, false));\n            assertEquals(10090l, DiskThresholdDecider.sizeOfRelocatingShards(node, info, true));\n        } else {\n            assertEquals(100l, DiskThresholdDecider.sizeOfRelocatingShards(node, info, false));\n            assertEquals(90l, DiskThresholdDecider.sizeOfRelocatingShards(node, info, true));\n        }\n\n    }","id":26816,"modified_method":"public void testShardSizeAndRelocatingSize() {\n        Map<String, Long> shardSizes = new HashMap<>();\n        shardSizes.put(\"[test][0][r]\", 10L);\n        shardSizes.put(\"[test][1][r]\", 100L);\n        shardSizes.put(\"[test][2][r]\", 1000L);\n        shardSizes.put(\"[other][0][p]\", 10000L);\n        ClusterInfo info = new ClusterInfo(Collections.EMPTY_MAP, Collections.EMPTY_MAP, shardSizes);\n        ShardRouting test_0 = ShardRouting.newUnassigned(\"test\", 0, null, false, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        ShardRoutingHelper.initialize(test_0, \"node1\");\n        ShardRoutingHelper.moveToStarted(test_0);\n        ShardRoutingHelper.relocate(test_0, \"node2\");\n\n        ShardRouting test_1 = ShardRouting.newUnassigned(\"test\", 1, null, false, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        ShardRoutingHelper.initialize(test_1, \"node2\");\n        ShardRoutingHelper.moveToStarted(test_1);\n        ShardRoutingHelper.relocate(test_1, \"node1\");\n\n        ShardRouting test_2 = ShardRouting.newUnassigned(\"test\", 2, null, false, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        ShardRoutingHelper.initialize(test_2, \"node1\");\n        ShardRoutingHelper.moveToStarted(test_2);\n\n        assertEquals(1000l, DiskThresholdDecider.getShardSize(test_2, info));\n        assertEquals(100l, DiskThresholdDecider.getShardSize(test_1, info));\n        assertEquals(10l, DiskThresholdDecider.getShardSize(test_0, info));\n\n        RoutingNode node = new RoutingNode(\"node1\", new DiscoveryNode(\"node1\", LocalTransportAddress.PROTO, Version.CURRENT), Arrays.asList(test_0, test_1.buildTargetRelocatingShard(), test_2));\n        assertEquals(100l, DiskThresholdDecider.sizeOfRelocatingShards(node, info, false));\n        assertEquals(90l, DiskThresholdDecider.sizeOfRelocatingShards(node, info, true));\n\n        ShardRouting test_3 = ShardRouting.newUnassigned(\"test\", 3, null, false, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        ShardRoutingHelper.initialize(test_3, \"node1\");\n        ShardRoutingHelper.moveToStarted(test_3);\n        assertEquals(0l, DiskThresholdDecider.getShardSize(test_3, info));\n\n\n        ShardRouting other_0 = ShardRouting.newUnassigned(\"other\", 0, null, randomBoolean(), new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"foo\"));\n        ShardRoutingHelper.initialize(other_0, \"node2\");\n        ShardRoutingHelper.moveToStarted(other_0);\n        ShardRoutingHelper.relocate(other_0, \"node1\");\n\n\n        node = new RoutingNode(\"node1\", new DiscoveryNode(\"node1\", LocalTransportAddress.PROTO, Version.CURRENT), Arrays.asList(test_0, test_1.buildTargetRelocatingShard(), test_2, other_0.buildTargetRelocatingShard()));\n        if (other_0.primary()) {\n            assertEquals(10100l, DiskThresholdDecider.sizeOfRelocatingShards(node, info, false));\n            assertEquals(10090l, DiskThresholdDecider.sizeOfRelocatingShards(node, info, true));\n        } else {\n            assertEquals(100l, DiskThresholdDecider.sizeOfRelocatingShards(node, info, false));\n            assertEquals(90l, DiskThresholdDecider.sizeOfRelocatingShards(node, info, true));\n        }\n\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public String toString() {\n        return \"[\" + nodeId + \"][\" + nodeName + \"] free: \" + new ByteSizeValue(getFreeBytes()) +\n                \"[\" + Strings.format1Decimals(getFreeDiskAsPercentage(), \"%\") + \"]\";\n    }","id":26817,"modified_method":"@Override\n    public String toString() {\n        return \"[\" + nodeId + \"][\" + nodeName + \"][\" + path + \"] free: \" + new ByteSizeValue(getFreeBytes()) +\n                \"[\" + Strings.format1Decimals(getFreeDiskAsPercentage(), \"%\") + \"]\";\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Create a new DiskUsage, if {@code totalBytes} is 0, {@get getFreeDiskAsPercentage}\n     * will always return 100.0% free\n     */\n    public DiskUsage(String nodeId, String nodeName, long totalBytes, long freeBytes) {\n        this.nodeId = nodeId;\n        this.nodeName = nodeName;\n        this.freeBytes = freeBytes;\n        this.totalBytes = totalBytes;\n    }","id":26818,"modified_method":"/**\n     * Create a new DiskUsage, if {@code totalBytes} is 0, {@get getFreeDiskAsPercentage}\n     * will always return 100.0% free\n     */\n    public DiskUsage(String nodeId, String nodeName, String path, long totalBytes, long freeBytes) {\n        this.nodeId = nodeId;\n        this.nodeName = nodeName;\n        this.freeBytes = freeBytes;\n        this.totalBytes = totalBytes;\n        this.path = path;\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void randomDiskUsageTest() {\n        int iters = scaledRandomIntBetween(1000, 10000);\n        for (int i = 1; i < iters; i++) {\n            long total = between(Integer.MIN_VALUE, Integer.MAX_VALUE);\n            long free = between(Integer.MIN_VALUE, Integer.MAX_VALUE);\n            DiskUsage du = new DiskUsage(\"random\", \"random\", total, free);\n            if (total == 0) {\n                assertThat(du.getFreeBytes(), equalTo(free));\n                assertThat(du.getTotalBytes(), equalTo(0L));\n                assertThat(du.getUsedBytes(), equalTo(-free));\n                assertThat(du.getFreeDiskAsPercentage(), equalTo(100.0));\n                assertThat(du.getUsedDiskAsPercentage(), equalTo(0.0));\n            } else {\n                assertThat(du.getFreeBytes(), equalTo(free));\n                assertThat(du.getTotalBytes(), equalTo(total));\n                assertThat(du.getUsedBytes(), equalTo(total - free));\n                assertThat(du.getFreeDiskAsPercentage(), equalTo(100.0 * ((double) free / total)));\n                assertThat(du.getUsedDiskAsPercentage(), equalTo(100.0 - (100.0 * ((double) free / total))));\n            }\n        }\n    }","id":26819,"modified_method":"@Test\n    public void randomDiskUsageTest() {\n        int iters = scaledRandomIntBetween(1000, 10000);\n        for (int i = 1; i < iters; i++) {\n            long total = between(Integer.MIN_VALUE, Integer.MAX_VALUE);\n            long free = between(Integer.MIN_VALUE, Integer.MAX_VALUE);\n            DiskUsage du = new DiskUsage(\"random\", \"random\", \"random\", total, free);\n            if (total == 0) {\n                assertThat(du.getFreeBytes(), equalTo(free));\n                assertThat(du.getTotalBytes(), equalTo(0L));\n                assertThat(du.getUsedBytes(), equalTo(-free));\n                assertThat(du.getFreeDiskAsPercentage(), equalTo(100.0));\n                assertThat(du.getUsedDiskAsPercentage(), equalTo(0.0));\n            } else {\n                assertThat(du.getFreeBytes(), equalTo(free));\n                assertThat(du.getTotalBytes(), equalTo(total));\n                assertThat(du.getUsedBytes(), equalTo(total - free));\n                assertThat(du.getFreeDiskAsPercentage(), equalTo(100.0 * ((double) free / total)));\n                assertThat(du.getUsedDiskAsPercentage(), equalTo(100.0 - (100.0 * ((double) free / total))));\n            }\n        }\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void diskUsageCalcTest() {\n        DiskUsage du = new DiskUsage(\"node1\", \"n1\", 100, 40);\n        assertThat(du.getFreeDiskAsPercentage(), equalTo(40.0));\n        assertThat(du.getUsedDiskAsPercentage(), equalTo(100.0 - 40.0));\n        assertThat(du.getFreeBytes(), equalTo(40L));\n        assertThat(du.getUsedBytes(), equalTo(60L));\n        assertThat(du.getTotalBytes(), equalTo(100L));\n\n        // Test that DiskUsage handles invalid numbers, as reported by some\n        // filesystems (ZFS & NTFS)\n        DiskUsage du2 = new DiskUsage(\"node1\", \"n1\", 100, 101);\n        assertThat(du2.getFreeDiskAsPercentage(), equalTo(101.0));\n        assertThat(du2.getFreeBytes(), equalTo(101L));\n        assertThat(du2.getUsedBytes(), equalTo(-1L));\n        assertThat(du2.getTotalBytes(), equalTo(100L));\n\n        DiskUsage du3 = new DiskUsage(\"node1\", \"n1\", -1, -1);\n        assertThat(du3.getFreeDiskAsPercentage(), equalTo(100.0));\n        assertThat(du3.getFreeBytes(), equalTo(-1L));\n        assertThat(du3.getUsedBytes(), equalTo(0L));\n        assertThat(du3.getTotalBytes(), equalTo(-1L));\n\n        DiskUsage du4 = new DiskUsage(\"node1\", \"n1\", 0, 0);\n        assertThat(du4.getFreeDiskAsPercentage(), equalTo(100.0));\n        assertThat(du4.getFreeBytes(), equalTo(0L));\n        assertThat(du4.getUsedBytes(), equalTo(0L));\n        assertThat(du4.getTotalBytes(), equalTo(0L));\n    }","id":26820,"modified_method":"@Test\n    public void diskUsageCalcTest() {\n        DiskUsage du = new DiskUsage(\"node1\", \"n1\", \"random\", 100, 40);\n        assertThat(du.getFreeDiskAsPercentage(), equalTo(40.0));\n        assertThat(du.getUsedDiskAsPercentage(), equalTo(100.0 - 40.0));\n        assertThat(du.getFreeBytes(), equalTo(40L));\n        assertThat(du.getUsedBytes(), equalTo(60L));\n        assertThat(du.getTotalBytes(), equalTo(100L));\n\n        // Test that DiskUsage handles invalid numbers, as reported by some\n        // filesystems (ZFS & NTFS)\n        DiskUsage du2 = new DiskUsage(\"node1\", \"n1\",\"random\", 100, 101);\n        assertThat(du2.getFreeDiskAsPercentage(), equalTo(101.0));\n        assertThat(du2.getFreeBytes(), equalTo(101L));\n        assertThat(du2.getUsedBytes(), equalTo(-1L));\n        assertThat(du2.getTotalBytes(), equalTo(100L));\n\n        DiskUsage du3 = new DiskUsage(\"node1\", \"n1\", \"random\",-1, -1);\n        assertThat(du3.getFreeDiskAsPercentage(), equalTo(100.0));\n        assertThat(du3.getFreeBytes(), equalTo(-1L));\n        assertThat(du3.getUsedBytes(), equalTo(0L));\n        assertThat(du3.getTotalBytes(), equalTo(-1L));\n\n        DiskUsage du4 = new DiskUsage(\"node1\", \"n1\",\"random\", 0, 0);\n        assertThat(du4.getFreeDiskAsPercentage(), equalTo(100.0));\n        assertThat(du4.getFreeBytes(), equalTo(0L));\n        assertThat(du4.getUsedBytes(), equalTo(0L));\n        assertThat(du4.getTotalBytes(), equalTo(0L));\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testInitializingHasExpectedSize() {\n        final long byteSize = randomIntBetween(0, Integer.MAX_VALUE);\n        AllocationService strategy = createAllocationService(Settings.EMPTY, new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                return new ClusterInfo(Collections.EMPTY_MAP, Collections.EMPTY_MAP) {\n                    @Override\n                    public Long getShardSize(ShardRouting shardRouting) {\n                        if (shardRouting.index().equals(\"test\") && shardRouting.shardId().getId() == 0) {\n                            return byteSize;\n                        }\n                        return null;\n                    }\n                };\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n            }\n        });\n\n        logger.info(\"Building initial routing table\");\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)\n                        .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n                        .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1)))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n        logger.info(\"Adding one node and performing rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().put(newNode(\"node1\"))).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        assertEquals(1, clusterState.getRoutingNodes().node(\"node1\").numberOfShardsWithState(ShardRoutingState.INITIALIZING));\n        assertEquals(byteSize, clusterState.getRoutingNodes().getRoutingTable().shardsWithState(ShardRoutingState.INITIALIZING).get(0).getExpectedShardSize());\n        logger.info(\"Start the primary shard\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        routingTable = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        assertEquals(1, clusterState.getRoutingNodes().node(\"node1\").numberOfShardsWithState(ShardRoutingState.STARTED));\n        assertEquals(1, clusterState.getRoutingNodes().unassigned().size());\n\n        logger.info(\"Add another one node and reroute\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes()).put(newNode(\"node2\"))).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        assertEquals(1, clusterState.getRoutingNodes().node(\"node2\").numberOfShardsWithState(ShardRoutingState.INITIALIZING));\n        assertEquals(byteSize, clusterState.getRoutingNodes().getRoutingTable().shardsWithState(ShardRoutingState.INITIALIZING).get(0).getExpectedShardSize());\n    }","id":26821,"modified_method":"@Test\n    public void testInitializingHasExpectedSize() {\n        final long byteSize = randomIntBetween(0, Integer.MAX_VALUE);\n        AllocationService strategy = createAllocationService(Settings.EMPTY, new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                return new ClusterInfo() {\n                    @Override\n                    public Long getShardSize(ShardRouting shardRouting) {\n                        if (shardRouting.index().equals(\"test\") && shardRouting.shardId().getId() == 0) {\n                            return byteSize;\n                        }\n                        return null;\n                    }\n                };\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n            }\n        });\n\n        logger.info(\"Building initial routing table\");\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)\n                        .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n                        .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1)))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n        logger.info(\"Adding one node and performing rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().put(newNode(\"node1\"))).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        assertEquals(1, clusterState.getRoutingNodes().node(\"node1\").numberOfShardsWithState(ShardRoutingState.INITIALIZING));\n        assertEquals(byteSize, clusterState.getRoutingNodes().getRoutingTable().shardsWithState(ShardRoutingState.INITIALIZING).get(0).getExpectedShardSize());\n        logger.info(\"Start the primary shard\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        routingTable = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        assertEquals(1, clusterState.getRoutingNodes().node(\"node1\").numberOfShardsWithState(ShardRoutingState.STARTED));\n        assertEquals(1, clusterState.getRoutingNodes().unassigned().size());\n\n        logger.info(\"Add another one node and reroute\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes()).put(newNode(\"node2\"))).build();\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        assertEquals(1, clusterState.getRoutingNodes().node(\"node2\").numberOfShardsWithState(ShardRoutingState.INITIALIZING));\n        assertEquals(byteSize, clusterState.getRoutingNodes().getRoutingTable().shardsWithState(ShardRoutingState.INITIALIZING).get(0).getExpectedShardSize());\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testExpectedSizeOnMove() {\n        final long byteSize = randomIntBetween(0, Integer.MAX_VALUE);\n        final AllocationService allocation = createAllocationService(Settings.EMPTY, new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                return new ClusterInfo(Collections.EMPTY_MAP, Collections.EMPTY_MAP) {\n                    @Override\n                    public Long getShardSize(ShardRouting shardRouting) {\n                        if (shardRouting.index().equals(\"test\") && shardRouting.shardId().getId() == 0) {\n                            return byteSize;\n                        }\n                        return null;\n                    }\n                };\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n            }\n        });\n        logger.info(\"creating an index with 1 shard, no replica\");\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(0))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n\n        logger.info(\"adding two nodes and performing rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().put(newNode(\"node1\")).put(newNode(\"node2\"))).build();\n        RoutingAllocation.Result rerouteResult = allocation.reroute(clusterState);\n        clusterState = ClusterState.builder(clusterState).routingTable(rerouteResult.routingTable()).build();\n\n        logger.info(\"start primary shard\");\n        rerouteResult = allocation.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        clusterState = ClusterState.builder(clusterState).routingTable(rerouteResult.routingTable()).build();\n\n        logger.info(\"move the shard\");\n        String existingNodeId = clusterState.routingTable().index(\"test\").shard(0).primaryShard().currentNodeId();\n        String toNodeId;\n        if (\"node1\".equals(existingNodeId)) {\n            toNodeId = \"node2\";\n        } else {\n            toNodeId = \"node1\";\n        }\n        rerouteResult = allocation.reroute(clusterState, new AllocationCommands(new MoveAllocationCommand(new ShardId(\"test\", 0), existingNodeId, toNodeId)));\n        assertThat(rerouteResult.changed(), equalTo(true));\n        clusterState = ClusterState.builder(clusterState).routingTable(rerouteResult.routingTable()).build();\n        assertEquals(clusterState.getRoutingNodes().node(existingNodeId).get(0).state(), ShardRoutingState.RELOCATING);\n        assertEquals(clusterState.getRoutingNodes().node(toNodeId).get(0).state(),ShardRoutingState.INITIALIZING);\n\n        assertEquals(clusterState.getRoutingNodes().node(existingNodeId).get(0).getExpectedShardSize(), byteSize);\n        assertEquals(clusterState.getRoutingNodes().node(toNodeId).get(0).getExpectedShardSize(), byteSize);\n\n        logger.info(\"finish moving the shard\");\n        rerouteResult = allocation.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        clusterState = ClusterState.builder(clusterState).routingTable(rerouteResult.routingTable()).build();\n\n        assertThat(clusterState.getRoutingNodes().node(existingNodeId).isEmpty(), equalTo(true));\n        assertThat(clusterState.getRoutingNodes().node(toNodeId).get(0).state(), equalTo(ShardRoutingState.STARTED));\n        assertEquals(clusterState.getRoutingNodes().node(toNodeId).get(0).getExpectedShardSize(), -1);\n    }","id":26822,"modified_method":"@Test\n    public void testExpectedSizeOnMove() {\n        final long byteSize = randomIntBetween(0, Integer.MAX_VALUE);\n        final AllocationService allocation = createAllocationService(Settings.EMPTY, new ClusterInfoService() {\n            @Override\n            public ClusterInfo getClusterInfo() {\n                return new ClusterInfo() {\n                    @Override\n                    public Long getShardSize(ShardRouting shardRouting) {\n                        if (shardRouting.index().equals(\"test\") && shardRouting.shardId().getId() == 0) {\n                            return byteSize;\n                        }\n                        return null;\n                    }\n                };\n            }\n\n            @Override\n            public void addListener(Listener listener) {\n            }\n        });\n        logger.info(\"creating an index with 1 shard, no replica\");\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(0))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n\n        logger.info(\"adding two nodes and performing rerouting\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().put(newNode(\"node1\")).put(newNode(\"node2\"))).build();\n        RoutingAllocation.Result rerouteResult = allocation.reroute(clusterState);\n        clusterState = ClusterState.builder(clusterState).routingTable(rerouteResult.routingTable()).build();\n\n        logger.info(\"start primary shard\");\n        rerouteResult = allocation.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        clusterState = ClusterState.builder(clusterState).routingTable(rerouteResult.routingTable()).build();\n\n        logger.info(\"move the shard\");\n        String existingNodeId = clusterState.routingTable().index(\"test\").shard(0).primaryShard().currentNodeId();\n        String toNodeId;\n        if (\"node1\".equals(existingNodeId)) {\n            toNodeId = \"node2\";\n        } else {\n            toNodeId = \"node1\";\n        }\n        rerouteResult = allocation.reroute(clusterState, new AllocationCommands(new MoveAllocationCommand(new ShardId(\"test\", 0), existingNodeId, toNodeId)));\n        assertThat(rerouteResult.changed(), equalTo(true));\n        clusterState = ClusterState.builder(clusterState).routingTable(rerouteResult.routingTable()).build();\n        assertEquals(clusterState.getRoutingNodes().node(existingNodeId).get(0).state(), ShardRoutingState.RELOCATING);\n        assertEquals(clusterState.getRoutingNodes().node(toNodeId).get(0).state(),ShardRoutingState.INITIALIZING);\n\n        assertEquals(clusterState.getRoutingNodes().node(existingNodeId).get(0).getExpectedShardSize(), byteSize);\n        assertEquals(clusterState.getRoutingNodes().node(toNodeId).get(0).getExpectedShardSize(), byteSize);\n\n        logger.info(\"finish moving the shard\");\n        rerouteResult = allocation.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));\n        clusterState = ClusterState.builder(clusterState).routingTable(rerouteResult.routingTable()).build();\n\n        assertThat(clusterState.getRoutingNodes().node(existingNodeId).isEmpty(), equalTo(true));\n        assertThat(clusterState.getRoutingNodes().node(toNodeId).get(0).state(), equalTo(ShardRoutingState.STARTED));\n        assertEquals(clusterState.getRoutingNodes().node(toNodeId).get(0).getExpectedShardSize(), -1);\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public InternalClusterInfoService(Settings settings, NodeSettingsService nodeSettingsService,\n                                      TransportNodesStatsAction transportNodesStatsAction,\n                                      TransportIndicesStatsAction transportIndicesStatsAction, ClusterService clusterService,\n                                      ThreadPool threadPool) {\n        super(settings);\n        this.usages = Collections.emptyMap();\n        this.shardSizes = Collections.emptyMap();\n        this.transportNodesStatsAction = transportNodesStatsAction;\n        this.transportIndicesStatsAction = transportIndicesStatsAction;\n        this.clusterService = clusterService;\n        this.threadPool = threadPool;\n        this.updateFrequency = settings.getAsTime(INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL, TimeValue.timeValueSeconds(30));\n        this.fetchTimeout = settings.getAsTime(INTERNAL_CLUSTER_INFO_TIMEOUT, TimeValue.timeValueSeconds(15));\n        this.enabled = settings.getAsBoolean(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true);\n        nodeSettingsService.addListener(new ApplySettings());\n\n        // Add InternalClusterInfoService to listen for Master changes\n        this.clusterService.add((LocalNodeMasterListener)this);\n        // Add to listen for state changes (when nodes are added)\n        this.clusterService.add((ClusterStateListener)this);\n    }","id":26823,"modified_method":"@Inject\n    public InternalClusterInfoService(Settings settings, NodeSettingsService nodeSettingsService,\n                                      TransportNodesStatsAction transportNodesStatsAction,\n                                      TransportIndicesStatsAction transportIndicesStatsAction, ClusterService clusterService,\n                                      ThreadPool threadPool) {\n        super(settings);\n        this.leastAvailableSpaceUsages = Collections.emptyMap();\n        this.mostAvailableSpaceUsages = Collections.emptyMap();\n        this.shardSizes = Collections.emptyMap();\n        this.transportNodesStatsAction = transportNodesStatsAction;\n        this.transportIndicesStatsAction = transportIndicesStatsAction;\n        this.clusterService = clusterService;\n        this.threadPool = threadPool;\n        this.updateFrequency = settings.getAsTime(INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL, TimeValue.timeValueSeconds(30));\n        this.fetchTimeout = settings.getAsTime(INTERNAL_CLUSTER_INFO_TIMEOUT, TimeValue.timeValueSeconds(15));\n        this.enabled = settings.getAsBoolean(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED, true);\n        nodeSettingsService.addListener(new ApplySettings());\n\n        // Add InternalClusterInfoService to listen for Master changes\n        this.clusterService.add((LocalNodeMasterListener)this);\n        // Add to listen for state changes (when nodes are added)\n        this.clusterService.add((ClusterStateListener)this);\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void clusterChanged(ClusterChangedEvent event) {\n        if (!this.enabled) {\n            return;\n        }\n\n        // Check whether it was a data node that was added\n        boolean dataNodeAdded = false;\n        for (DiscoveryNode addedNode : event.nodesDelta().addedNodes()) {\n            if (addedNode.dataNode()) {\n                dataNodeAdded = true;\n                break;\n            }\n        }\n\n        if (this.isMaster && dataNodeAdded && clusterService.state().getNodes().getDataNodes().size() > 1) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"data node was added, retrieving new cluster info\");\n            }\n            updateOnce();\n        }\n\n        if (this.isMaster && event.nodesRemoved()) {\n            for (DiscoveryNode removedNode : event.nodesDelta().removedNodes()) {\n                if (removedNode.dataNode()) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Removing node from cluster info: {}\", removedNode.getId());\n                    }\n                    Map<String, DiskUsage> newUsages = new HashMap<>(usages);\n                    newUsages.remove(removedNode.getId());\n                    usages = Collections.unmodifiableMap(newUsages);\n                }\n            }\n        }\n    }","id":26824,"modified_method":"@Override\n    public void clusterChanged(ClusterChangedEvent event) {\n        if (!this.enabled) {\n            return;\n        }\n\n        // Check whether it was a data node that was added\n        boolean dataNodeAdded = false;\n        for (DiscoveryNode addedNode : event.nodesDelta().addedNodes()) {\n            if (addedNode.dataNode()) {\n                dataNodeAdded = true;\n                break;\n            }\n        }\n\n        if (this.isMaster && dataNodeAdded && clusterService.state().getNodes().getDataNodes().size() > 1) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"data node was added, retrieving new cluster info\");\n            }\n            updateOnce();\n        }\n\n        if (this.isMaster && event.nodesRemoved()) {\n            for (DiscoveryNode removedNode : event.nodesDelta().removedNodes()) {\n                if (removedNode.dataNode()) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Removing node from cluster info: {}\", removedNode.getId());\n                    }\n                    if (leastAvailableSpaceUsages.containsKey(removedNode.getId())) {\n                        Map<String, DiskUsage> newMaxUsages = new HashMap<>(leastAvailableSpaceUsages);\n                        newMaxUsages.remove(removedNode.getId());\n                        leastAvailableSpaceUsages = Collections.unmodifiableMap(newMaxUsages);\n                    }\n                    if (mostAvailableSpaceUsages.containsKey(removedNode.getId())) {\n                        Map<String, DiskUsage> newMinUsages = new HashMap<>(mostAvailableSpaceUsages);\n                        newMinUsages.remove(removedNode.getId());\n                        mostAvailableSpaceUsages = Collections.unmodifiableMap(newMinUsages);\n                    }\n                }\n            }\n        }\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public ClusterInfo getClusterInfo() {\n        return new ClusterInfo(usages, shardSizes);\n    }","id":26825,"modified_method":"@Override\n    public ClusterInfo getClusterInfo() {\n        return new ClusterInfo(leastAvailableSpaceUsages, mostAvailableSpaceUsages, shardSizes);\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void run() {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Performing ClusterInfoUpdateJob\");\n            }\n\n            if (isMaster && this.reschedule) {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Scheduling next run for updating cluster info in: {}\", updateFrequency.toString());\n                }\n                try {\n                    threadPool.schedule(updateFrequency, executorName(), new SubmitReschedulingClusterInfoUpdatedJob());\n                } catch (EsRejectedExecutionException ex) {\n                    logger.debug(\"Reschedule cluster info service was rejected\", ex);\n                }\n            }\n            if (!enabled) {\n                // Short-circuit if not enabled\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Skipping ClusterInfoUpdatedJob since it is disabled\");\n                }\n                return;\n            }\n\n            CountDownLatch nodeLatch = updateNodeStats(new ActionListener<NodesStatsResponse>() {\n                @Override\n                public void onResponse(NodesStatsResponse nodeStatses) {\n                    Map<String, DiskUsage> newUsages = new HashMap<>();\n                    for (NodeStats nodeStats : nodeStatses.getNodes()) {\n                        if (nodeStats.getFs() == null) {\n                            logger.warn(\"Unable to retrieve node FS stats for {}\", nodeStats.getNode().name());\n                        } else {\n                            long available = 0;\n                            long total = 0;\n\n                            for (FsInfo.Path info : nodeStats.getFs()) {\n                                available += info.getAvailable().bytes();\n                                total += info.getTotal().bytes();\n                            }\n                            String nodeId = nodeStats.getNode().id();\n                            String nodeName = nodeStats.getNode().getName();\n                            if (logger.isTraceEnabled()) {\n                                logger.trace(\"node: [{}], total disk: {}, available disk: {}\", nodeId, total, available);\n                            }\n                            newUsages.put(nodeId, new DiskUsage(nodeId, nodeName, total, available));\n                        }\n                    }\n                    usages = Collections.unmodifiableMap(newUsages);\n                }\n\n                @Override\n                public void onFailure(Throwable e) {\n                    if (e instanceof ReceiveTimeoutTransportException) {\n                        logger.error(\"NodeStatsAction timed out for ClusterInfoUpdateJob (reason [{}])\", e.getMessage());\n                    } else {\n                        if (e instanceof ClusterBlockException) {\n                            if (logger.isTraceEnabled()) {\n                                logger.trace(\"Failed to execute NodeStatsAction for ClusterInfoUpdateJob\", e);\n                            }\n                        } else {\n                            logger.warn(\"Failed to execute NodeStatsAction for ClusterInfoUpdateJob\", e);\n                        }\n                        // we empty the usages list, to be safe - we don't know what's going on.\n                        usages = Collections.emptyMap();\n                    }\n                }\n            });\n\n            CountDownLatch indicesLatch = updateIndicesStats(new ActionListener<IndicesStatsResponse>() {\n                @Override\n                public void onResponse(IndicesStatsResponse indicesStatsResponse) {\n                    ShardStats[] stats = indicesStatsResponse.getShards();\n                    HashMap<String, Long> newShardSizes = new HashMap<>();\n                    for (ShardStats s : stats) {\n                        long size = s.getStats().getStore().sizeInBytes();\n                        String sid = ClusterInfo.shardIdentifierFromRouting(s.getShardRouting());\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"shard: {} size: {}\", sid, size);\n                        }\n                        newShardSizes.put(sid, size);\n                    }\n                    shardSizes = Collections.unmodifiableMap(newShardSizes);\n                }\n\n                @Override\n                public void onFailure(Throwable e) {\n                    if (e instanceof ReceiveTimeoutTransportException) {\n                        logger.error(\"IndicesStatsAction timed out for ClusterInfoUpdateJob (reason [{}])\", e.getMessage());\n                    } else {\n                        if (e instanceof ClusterBlockException) {\n                            if (logger.isTraceEnabled()) {\n                                logger.trace(\"Failed to execute IndicesStatsAction for ClusterInfoUpdateJob\", e);\n                            }\n                        } else {\n                            logger.warn(\"Failed to execute IndicesStatsAction for ClusterInfoUpdateJob\", e);\n                        }\n                        // we empty the usages list, to be safe - we don't know what's going on.\n                        shardSizes = Collections.emptyMap();\n                    }\n                }\n            });\n\n            try {\n                nodeLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt(); // restore interrupt status\n                logger.warn(\"Failed to update node information for ClusterInfoUpdateJob within 15s timeout\");\n            }\n\n            try {\n                indicesLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt(); // restore interrupt status\n                logger.warn(\"Failed to update shard information for ClusterInfoUpdateJob within 15s timeout\");\n            }\n\n            for (Listener l : listeners) {\n                try {\n                    l.onNewInfo(getClusterInfo());\n                } catch (Exception e) {\n                    logger.info(\"Failed executing ClusterInfoService listener\", e);\n                }\n            }\n        }","id":26826,"modified_method":"@Override\n        public void run() {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Performing ClusterInfoUpdateJob\");\n            }\n\n            if (isMaster && this.reschedule) {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Scheduling next run for updating cluster info in: {}\", updateFrequency.toString());\n                }\n                try {\n                    threadPool.schedule(updateFrequency, executorName(), new SubmitReschedulingClusterInfoUpdatedJob());\n                } catch (EsRejectedExecutionException ex) {\n                    logger.debug(\"Reschedule cluster info service was rejected\", ex);\n                }\n            }\n            if (!enabled) {\n                // Short-circuit if not enabled\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Skipping ClusterInfoUpdatedJob since it is disabled\");\n                }\n                return;\n            }\n\n            CountDownLatch nodeLatch = updateNodeStats(new ActionListener<NodesStatsResponse>() {\n                @Override\n                public void onResponse(NodesStatsResponse nodeStatses) {\n                    Map<String, DiskUsage> newLeastAvaiableUsages = new HashMap<>();\n                    Map<String, DiskUsage> newMostAvaiableUsages = new HashMap<>();\n                    fillDiskUsagePerNode(logger, nodeStatses.getNodes(), newLeastAvaiableUsages, newMostAvaiableUsages);\n                    leastAvailableSpaceUsages = Collections.unmodifiableMap(newLeastAvaiableUsages);\n                    mostAvailableSpaceUsages = Collections.unmodifiableMap(newMostAvaiableUsages);\n                }\n\n                @Override\n                public void onFailure(Throwable e) {\n                    if (e instanceof ReceiveTimeoutTransportException) {\n                        logger.error(\"NodeStatsAction timed out for ClusterInfoUpdateJob (reason [{}])\", e.getMessage());\n                    } else {\n                        if (e instanceof ClusterBlockException) {\n                            if (logger.isTraceEnabled()) {\n                                logger.trace(\"Failed to execute NodeStatsAction for ClusterInfoUpdateJob\", e);\n                            }\n                        } else {\n                            logger.warn(\"Failed to execute NodeStatsAction for ClusterInfoUpdateJob\", e);\n                        }\n                        // we empty the usages list, to be safe - we don't know what's going on.\n                        leastAvailableSpaceUsages = Collections.emptyMap();\n                        mostAvailableSpaceUsages = Collections.emptyMap();\n                    }\n                }\n            });\n\n            CountDownLatch indicesLatch = updateIndicesStats(new ActionListener<IndicesStatsResponse>() {\n                @Override\n                public void onResponse(IndicesStatsResponse indicesStatsResponse) {\n                    ShardStats[] stats = indicesStatsResponse.getShards();\n                    HashMap<String, Long> newShardSizes = new HashMap<>();\n                    for (ShardStats s : stats) {\n                        long size = s.getStats().getStore().sizeInBytes();\n                        String sid = ClusterInfo.shardIdentifierFromRouting(s.getShardRouting());\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"shard: {} size: {}\", sid, size);\n                        }\n                        newShardSizes.put(sid, size);\n                    }\n                    shardSizes = Collections.unmodifiableMap(newShardSizes);\n                }\n\n                @Override\n                public void onFailure(Throwable e) {\n                    if (e instanceof ReceiveTimeoutTransportException) {\n                        logger.error(\"IndicesStatsAction timed out for ClusterInfoUpdateJob (reason [{}])\", e.getMessage());\n                    } else {\n                        if (e instanceof ClusterBlockException) {\n                            if (logger.isTraceEnabled()) {\n                                logger.trace(\"Failed to execute IndicesStatsAction for ClusterInfoUpdateJob\", e);\n                            }\n                        } else {\n                            logger.warn(\"Failed to execute IndicesStatsAction for ClusterInfoUpdateJob\", e);\n                        }\n                        // we empty the usages list, to be safe - we don't know what's going on.\n                        shardSizes = Collections.emptyMap();\n                    }\n                }\n            });\n\n            try {\n                nodeLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt(); // restore interrupt status\n                logger.warn(\"Failed to update node information for ClusterInfoUpdateJob within 15s timeout\");\n            }\n\n            try {\n                indicesLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt(); // restore interrupt status\n                logger.warn(\"Failed to update shard information for ClusterInfoUpdateJob within 15s timeout\");\n            }\n\n            for (Listener l : listeners) {\n                try {\n                    l.onNewInfo(getClusterInfo());\n                } catch (Exception e) {\n                    logger.info(\"Failed executing ClusterInfoService listener\", e);\n                }\n            }\n        }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    //@TestLogging(\"org.elasticsearch.cluster:TRACE,org.elasticsearch.cluster.routing.allocation.decider:TRACE\")\n    public void testRerouteOccursOnDiskPassingHighWatermark() throws Exception {\n        List<String> nodes = internalCluster().startNodesAsync(3).get();\n\n        // Wait for all 3 nodes to be up\n        assertBusy(new Runnable() {\n            @Override\n            public void run() {\n                NodesStatsResponse resp = client().admin().cluster().prepareNodesStats().get();\n                assertThat(resp.getNodes().length, equalTo(3));\n            }\n        });\n\n        // Start with all nodes at 50% usage\n        final MockInternalClusterInfoService cis = (MockInternalClusterInfoService)\n                internalCluster().getInstance(ClusterInfoService.class, internalCluster().getMasterName());\n        cis.setN1Usage(nodes.get(0), new DiskUsage(nodes.get(0), \"n1\", 100, 50));\n        cis.setN2Usage(nodes.get(1), new DiskUsage(nodes.get(1), \"n2\", 100, 50));\n        cis.setN3Usage(nodes.get(2), new DiskUsage(nodes.get(2), \"n3\", 100, 50));\n\n        client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, randomFrom(\"20b\", \"80%\"))\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, randomFrom(\"10b\", \"90%\"))\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL, \"1ms\")).get();\n\n        // Create an index with 10 shards so we can check allocation for it\n        prepareCreate(\"test\").setSettings(settingsBuilder()\n                .put(\"number_of_shards\", 10)\n                .put(\"number_of_replicas\", 0)\n                .put(\"index.routing.allocation.exclude._name\", \"\")).get();\n        ensureGreen(\"test\");\n\n        // Block until the \"fake\" cluster info is retrieved at least once\n        assertBusy(new Runnable() {\n            @Override\n            public void run() {\n                ClusterInfo info = cis.getClusterInfo();\n                logger.info(\"--> got: {} nodes\", info.getNodeDiskUsages().size());\n                assertThat(info.getNodeDiskUsages().size(), greaterThan(0));\n            }\n        });\n\n        final List<String> realNodeNames = new ArrayList<>();\n        ClusterStateResponse resp = client().admin().cluster().prepareState().get();\n        Iterator<RoutingNode> iter = resp.getState().getRoutingNodes().iterator();\n        while (iter.hasNext()) {\n            RoutingNode node = iter.next();\n            realNodeNames.add(node.nodeId());\n            logger.info(\"--> node {} has {} shards\",\n                    node.nodeId(), resp.getState().getRoutingNodes().node(node.nodeId()).numberOfOwningShards());\n        }\n\n        // Update the disk usages so one node has now passed the high watermark\n        cis.setN1Usage(realNodeNames.get(0), new DiskUsage(nodes.get(0), \"n1\", 100, 50));\n        cis.setN2Usage(realNodeNames.get(1), new DiskUsage(nodes.get(1), \"n2\", 100, 50));\n        cis.setN3Usage(realNodeNames.get(2), new DiskUsage(nodes.get(2), \"n3\", 100, 0)); // nothing free on node3\n\n        // Retrieve the count of shards on each node\n        final Map<String, Integer> nodesToShardCount = newHashMap();\n\n        assertBusy(new Runnable() {\n            @Override\n            public void run() {\n                ClusterStateResponse resp = client().admin().cluster().prepareState().get();\n                Iterator<RoutingNode> iter = resp.getState().getRoutingNodes().iterator();\n                while (iter.hasNext()) {\n                    RoutingNode node = iter.next();\n                    logger.info(\"--> node {} has {} shards\",\n                            node.nodeId(), resp.getState().getRoutingNodes().node(node.nodeId()).numberOfOwningShards());\n                    nodesToShardCount.put(node.nodeId(), resp.getState().getRoutingNodes().node(node.nodeId()).numberOfOwningShards());\n                }\n                assertThat(\"node1 has 5 shards\", nodesToShardCount.get(realNodeNames.get(0)), equalTo(5));\n                assertThat(\"node2 has 5 shards\", nodesToShardCount.get(realNodeNames.get(1)), equalTo(5));\n                assertThat(\"node3 has 0 shards\", nodesToShardCount.get(realNodeNames.get(2)), equalTo(0));\n            }\n        });\n\n        // Update the disk usages so one node is now back under the high watermark\n        cis.setN1Usage(realNodeNames.get(0), new DiskUsage(nodes.get(0), \"n1\", 100, 50));\n        cis.setN2Usage(realNodeNames.get(1), new DiskUsage(nodes.get(1), \"n2\", 100, 50));\n        cis.setN3Usage(realNodeNames.get(2), new DiskUsage(nodes.get(2), \"n3\", 100, 50)); // node3 has free space now\n\n        // Retrieve the count of shards on each node\n        nodesToShardCount.clear();\n\n        assertBusy(new Runnable() {\n            @Override\n            public void run() {\n                ClusterStateResponse resp = client().admin().cluster().prepareState().get();\n                Iterator<RoutingNode> iter = resp.getState().getRoutingNodes().iterator();\n                while (iter.hasNext()) {\n                    RoutingNode node = iter.next();\n                    logger.info(\"--> node {} has {} shards\",\n                            node.nodeId(), resp.getState().getRoutingNodes().node(node.nodeId()).numberOfOwningShards());\n                    nodesToShardCount.put(node.nodeId(), resp.getState().getRoutingNodes().node(node.nodeId()).numberOfOwningShards());\n                }\n                assertThat(\"node1 has at least 3 shards\", nodesToShardCount.get(realNodeNames.get(0)), greaterThanOrEqualTo(3));\n                assertThat(\"node2 has at least 3 shards\", nodesToShardCount.get(realNodeNames.get(1)), greaterThanOrEqualTo(3));\n                assertThat(\"node3 has at least 3 shards\", nodesToShardCount.get(realNodeNames.get(2)), greaterThanOrEqualTo(3));\n            }\n        });\n    }","id":26827,"modified_method":"@Test\n    //@TestLogging(\"org.elasticsearch.cluster:TRACE,org.elasticsearch.cluster.routing.allocation.decider:TRACE\")\n    public void testRerouteOccursOnDiskPassingHighWatermark() throws Exception {\n        List<String> nodes = internalCluster().startNodesAsync(3).get();\n\n        // Wait for all 3 nodes to be up\n        assertBusy(new Runnable() {\n            @Override\n            public void run() {\n                NodesStatsResponse resp = client().admin().cluster().prepareNodesStats().get();\n                assertThat(resp.getNodes().length, equalTo(3));\n            }\n        });\n\n        // Start with all nodes at 50% usage\n        final MockInternalClusterInfoService cis = (MockInternalClusterInfoService)\n                internalCluster().getInstance(ClusterInfoService.class, internalCluster().getMasterName());\n        cis.setN1Usage(nodes.get(0), new DiskUsage(nodes.get(0), \"n1\", \"_na_\", 100, 50));\n        cis.setN2Usage(nodes.get(1), new DiskUsage(nodes.get(1), \"n2\", \"_na_\", 100, 50));\n        cis.setN3Usage(nodes.get(2), new DiskUsage(nodes.get(2), \"n3\", \"_na_\", 100, 50));\n\n        client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder()\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, randomFrom(\"20b\", \"80%\"))\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, randomFrom(\"10b\", \"90%\"))\n                .put(DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL, \"1ms\")).get();\n\n        // Create an index with 10 shards so we can check allocation for it\n        prepareCreate(\"test\").setSettings(settingsBuilder()\n                .put(\"number_of_shards\", 10)\n                .put(\"number_of_replicas\", 0)\n                .put(\"index.routing.allocation.exclude._name\", \"\")).get();\n        ensureGreen(\"test\");\n\n        // Block until the \"fake\" cluster info is retrieved at least once\n        assertBusy(new Runnable() {\n            @Override\n            public void run() {\n                ClusterInfo info = cis.getClusterInfo();\n                logger.info(\"--> got: {} nodes\", info.getNodeLeastAvailableDiskUsages().size());\n                assertThat(info.getNodeLeastAvailableDiskUsages().size(), greaterThan(0));\n            }\n        });\n\n        final List<String> realNodeNames = new ArrayList<>();\n        ClusterStateResponse resp = client().admin().cluster().prepareState().get();\n        Iterator<RoutingNode> iter = resp.getState().getRoutingNodes().iterator();\n        while (iter.hasNext()) {\n            RoutingNode node = iter.next();\n            realNodeNames.add(node.nodeId());\n            logger.info(\"--> node {} has {} shards\",\n                    node.nodeId(), resp.getState().getRoutingNodes().node(node.nodeId()).numberOfOwningShards());\n        }\n\n        // Update the disk usages so one node has now passed the high watermark\n        cis.setN1Usage(realNodeNames.get(0), new DiskUsage(nodes.get(0), \"n1\", \"_na_\", 100, 50));\n        cis.setN2Usage(realNodeNames.get(1), new DiskUsage(nodes.get(1), \"n2\", \"_na_\", 100, 50));\n        cis.setN3Usage(realNodeNames.get(2), new DiskUsage(nodes.get(2), \"n3\", \"_na_\", 100, 0)); // nothing free on node3\n\n        // Retrieve the count of shards on each node\n        final Map<String, Integer> nodesToShardCount = newHashMap();\n\n        assertBusy(new Runnable() {\n            @Override\n            public void run() {\n                ClusterStateResponse resp = client().admin().cluster().prepareState().get();\n                Iterator<RoutingNode> iter = resp.getState().getRoutingNodes().iterator();\n                while (iter.hasNext()) {\n                    RoutingNode node = iter.next();\n                    logger.info(\"--> node {} has {} shards\",\n                            node.nodeId(), resp.getState().getRoutingNodes().node(node.nodeId()).numberOfOwningShards());\n                    nodesToShardCount.put(node.nodeId(), resp.getState().getRoutingNodes().node(node.nodeId()).numberOfOwningShards());\n                }\n                assertThat(\"node1 has 5 shards\", nodesToShardCount.get(realNodeNames.get(0)), equalTo(5));\n                assertThat(\"node2 has 5 shards\", nodesToShardCount.get(realNodeNames.get(1)), equalTo(5));\n                assertThat(\"node3 has 0 shards\", nodesToShardCount.get(realNodeNames.get(2)), equalTo(0));\n            }\n        });\n\n        // Update the disk usages so one node is now back under the high watermark\n        cis.setN1Usage(realNodeNames.get(0), new DiskUsage(nodes.get(0), \"n1\", \"_na_\", 100, 50));\n        cis.setN2Usage(realNodeNames.get(1), new DiskUsage(nodes.get(1), \"n2\", \"_na_\", 100, 50));\n        cis.setN3Usage(realNodeNames.get(2), new DiskUsage(nodes.get(2), \"n3\", \"_na_\", 100, 50)); // node3 has free space now\n\n        // Retrieve the count of shards on each node\n        nodesToShardCount.clear();\n\n        assertBusy(new Runnable() {\n            @Override\n            public void run() {\n                ClusterStateResponse resp = client().admin().cluster().prepareState().get();\n                Iterator<RoutingNode> iter = resp.getState().getRoutingNodes().iterator();\n                while (iter.hasNext()) {\n                    RoutingNode node = iter.next();\n                    logger.info(\"--> node {} has {} shards\",\n                            node.nodeId(), resp.getState().getRoutingNodes().node(node.nodeId()).numberOfOwningShards());\n                    nodesToShardCount.put(node.nodeId(), resp.getState().getRoutingNodes().node(node.nodeId()).numberOfOwningShards());\n                }\n                assertThat(\"node1 has at least 3 shards\", nodesToShardCount.get(realNodeNames.get(0)), greaterThanOrEqualTo(3));\n                assertThat(\"node2 has at least 3 shards\", nodesToShardCount.get(realNodeNames.get(1)), greaterThanOrEqualTo(3));\n                assertThat(\"node3 has at least 3 shards\", nodesToShardCount.get(realNodeNames.get(2)), greaterThanOrEqualTo(3));\n            }\n        });\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public MockInternalClusterInfoService(Settings settings, NodeSettingsService nodeSettingsService,\n                                          TransportNodesStatsAction transportNodesStatsAction,\n                                          TransportIndicesStatsAction transportIndicesStatsAction,\n                                          ClusterService clusterService, ThreadPool threadPool) {\n        super(settings, nodeSettingsService, transportNodesStatsAction, transportIndicesStatsAction, clusterService, threadPool);\n        this.clusterName = ClusterName.clusterNameFromSettings(settings);\n        stats[0] = MockDiskUsagesIT.makeStats(\"node_t1\", new DiskUsage(\"node_t1\", \"n1\", 100, 100));\n        stats[1] = MockDiskUsagesIT.makeStats(\"node_t2\", new DiskUsage(\"node_t2\", \"n2\", 100, 100));\n        stats[2] = MockDiskUsagesIT.makeStats(\"node_t3\", new DiskUsage(\"node_t3\", \"n3\", 100, 100));\n    }","id":26828,"modified_method":"@Inject\n    public MockInternalClusterInfoService(Settings settings, NodeSettingsService nodeSettingsService,\n                                          TransportNodesStatsAction transportNodesStatsAction,\n                                          TransportIndicesStatsAction transportIndicesStatsAction,\n                                          ClusterService clusterService, ThreadPool threadPool) {\n        super(settings, nodeSettingsService, transportNodesStatsAction, transportIndicesStatsAction, clusterService, threadPool);\n        this.clusterName = ClusterName.clusterNameFromSettings(settings);\n        stats[0] = MockDiskUsagesIT.makeStats(\"node_t1\", new DiskUsage(\"node_t1\", \"n1\", \"_na_\", 100, 100));\n        stats[1] = MockDiskUsagesIT.makeStats(\"node_t2\", new DiskUsage(\"node_t2\", \"n2\", \"_na_\", 100, 100));\n        stats[2] = MockDiskUsagesIT.makeStats(\"node_t3\", new DiskUsage(\"node_t3\", \"n3\", \"_na_\", 100, 100));\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testRebalanceOnlyAfterAllShardsAreActive() {\n        final long[] sizes = new long[5];\n        for (int i =0; i < sizes.length; i++) {\n            sizes[i] = randomIntBetween(0, Integer.MAX_VALUE);\n        }\n\n        AllocationService strategy = createAllocationService(settingsBuilder()\n                        .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                        .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                        .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                        .build(),\n                new ClusterInfoService() {\n                    @Override\n                    public ClusterInfo getClusterInfo() {\n                        return new ClusterInfo(Collections.EMPTY_MAP, Collections.EMPTY_MAP) {\n                            @Override\n                            public Long getShardSize(ShardRouting shardRouting) {\n                                if (shardRouting.index().equals(\"test\")) {\n                                    return sizes[shardRouting.getId()];\n                                }\n                                return null;                    }\n                        };\n                    }\n\n                    @Override\n                    public void addListener(Listener listener) {\n                    }\n                });\n        logger.info(\"Building initial routing table\");\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(5).numberOfReplicas(1))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n\n        assertThat(routingTable.index(\"test\").shards().size(), equalTo(5));\n        for (int i = 0; i < routingTable.index(\"test\").shards().size(); i++) {\n            assertThat(routingTable.index(\"test\").shard(i).shards().size(), equalTo(2));\n            assertThat(routingTable.index(\"test\").shard(i).shards().get(0).state(), equalTo(UNASSIGNED));\n            assertThat(routingTable.index(\"test\").shard(i).shards().get(1).state(), equalTo(UNASSIGNED));\n            assertThat(routingTable.index(\"test\").shard(i).shards().get(0).currentNodeId(), nullValue());\n            assertThat(routingTable.index(\"test\").shard(i).shards().get(1).currentNodeId(), nullValue());\n        }\n\n        logger.info(\"start two nodes and fully start the shards\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().put(newNode(\"node1\")).put(newNode(\"node2\"))).build();\n        RoutingTable prevRoutingTable = routingTable;\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        for (int i = 0; i < routingTable.index(\"test\").shards().size(); i++) {\n            assertThat(routingTable.index(\"test\").shard(i).shards().size(), equalTo(2));\n            assertThat(routingTable.index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n            assertThat(routingTable.index(\"test\").shard(i).replicaShards().get(0).state(), equalTo(UNASSIGNED));\n        }\n\n        logger.info(\"start all the primary shards, replicas will start initializing\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        prevRoutingTable = routingTable;\n        routingTable = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        routingNodes = clusterState.getRoutingNodes();\n\n        for (int i = 0; i < routingTable.index(\"test\").shards().size(); i++) {\n            assertThat(routingTable.index(\"test\").shard(i).shards().size(), equalTo(2));\n            assertThat(routingTable.index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n            assertThat(routingTable.index(\"test\").shard(i).replicaShards().get(0).state(), equalTo(INITIALIZING));\n            assertEquals(routingTable.index(\"test\").shard(i).replicaShards().get(0).getExpectedShardSize(), sizes[i]);\n        }\n\n        logger.info(\"now, start 8 more nodes, and check that no rebalancing/relocation have happened\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .put(newNode(\"node3\")).put(newNode(\"node4\")).put(newNode(\"node5\")).put(newNode(\"node6\")).put(newNode(\"node7\")).put(newNode(\"node8\")).put(newNode(\"node9\")).put(newNode(\"node10\")))\n                .build();\n        prevRoutingTable = routingTable;\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        routingNodes = clusterState.getRoutingNodes();\n\n        for (int i = 0; i < routingTable.index(\"test\").shards().size(); i++) {\n            assertThat(routingTable.index(\"test\").shard(i).shards().size(), equalTo(2));\n            assertThat(routingTable.index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n            assertThat(routingTable.index(\"test\").shard(i).replicaShards().get(0).state(), equalTo(INITIALIZING));\n            assertEquals(routingTable.index(\"test\").shard(i).replicaShards().get(0).getExpectedShardSize(), sizes[i]);\n\n        }\n\n        logger.info(\"start the replica shards, rebalancing should start\");\n        routingNodes = clusterState.getRoutingNodes();\n        prevRoutingTable = routingTable;\n        routingTable = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        routingNodes = clusterState.getRoutingNodes();\n\n        // we only allow one relocation at a time\n        assertThat(routingTable.shardsWithState(STARTED).size(), equalTo(5));\n        assertThat(routingTable.shardsWithState(RELOCATING).size(), equalTo(5));\n        for (int i = 0; i < routingTable.index(\"test\").shards().size(); i++) {\n            int num = 0;\n            for (ShardRouting routing : routingTable.index(\"test\").shard(i).shards()) {\n                if (routing.state() == RELOCATING || routing.state() == INITIALIZING) {\n                    assertEquals(routing.getExpectedShardSize(), sizes[i]);\n                    num++;\n                }\n            }\n            assertTrue(num > 0);\n        }\n\n        logger.info(\"complete relocation, other half of relocation should happen\");\n        routingNodes = clusterState.getRoutingNodes();\n        prevRoutingTable = routingTable;\n        routingTable = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        routingNodes = clusterState.getRoutingNodes();\n\n        // we now only relocate 3, since 2 remain where they are!\n        assertThat(routingTable.shardsWithState(STARTED).size(), equalTo(7));\n        assertThat(routingTable.shardsWithState(RELOCATING).size(), equalTo(3));\n        for (int i = 0; i < routingTable.index(\"test\").shards().size(); i++) {\n            for (ShardRouting routing : routingTable.index(\"test\").shard(i).shards()) {\n                if (routing.state() == RELOCATING || routing.state() == INITIALIZING) {\n                    assertEquals(routing.getExpectedShardSize(), sizes[i]);\n                }\n            }\n        }\n\n\n        logger.info(\"complete relocation, thats it!\");\n        routingNodes = clusterState.getRoutingNodes();\n        prevRoutingTable = routingTable;\n        routingTable = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        routingNodes = clusterState.getRoutingNodes();\n\n        assertThat(routingTable.shardsWithState(STARTED).size(), equalTo(10));\n        // make sure we have an even relocation\n        for (RoutingNode routingNode : routingNodes) {\n            assertThat(routingNode.size(), equalTo(1));\n        }\n    }","id":26829,"modified_method":"@Test\n    public void testRebalanceOnlyAfterAllShardsAreActive() {\n        final long[] sizes = new long[5];\n        for (int i =0; i < sizes.length; i++) {\n            sizes[i] = randomIntBetween(0, Integer.MAX_VALUE);\n        }\n\n        AllocationService strategy = createAllocationService(settingsBuilder()\n                        .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                        .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, \"always\")\n                        .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n                        .build(),\n                new ClusterInfoService() {\n                    @Override\n                    public ClusterInfo getClusterInfo() {\n                        return new ClusterInfo() {\n                            @Override\n                            public Long getShardSize(ShardRouting shardRouting) {\n                                if (shardRouting.index().equals(\"test\")) {\n                                    return sizes[shardRouting.getId()];\n                                }\n                                return null;                    }\n                        };\n                    }\n\n                    @Override\n                    public void addListener(Listener listener) {\n                    }\n                });\n        logger.info(\"Building initial routing table\");\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(5).numberOfReplicas(1))\n                .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();\n\n        assertThat(routingTable.index(\"test\").shards().size(), equalTo(5));\n        for (int i = 0; i < routingTable.index(\"test\").shards().size(); i++) {\n            assertThat(routingTable.index(\"test\").shard(i).shards().size(), equalTo(2));\n            assertThat(routingTable.index(\"test\").shard(i).shards().get(0).state(), equalTo(UNASSIGNED));\n            assertThat(routingTable.index(\"test\").shard(i).shards().get(1).state(), equalTo(UNASSIGNED));\n            assertThat(routingTable.index(\"test\").shard(i).shards().get(0).currentNodeId(), nullValue());\n            assertThat(routingTable.index(\"test\").shard(i).shards().get(1).currentNodeId(), nullValue());\n        }\n\n        logger.info(\"start two nodes and fully start the shards\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().put(newNode(\"node1\")).put(newNode(\"node2\"))).build();\n        RoutingTable prevRoutingTable = routingTable;\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        for (int i = 0; i < routingTable.index(\"test\").shards().size(); i++) {\n            assertThat(routingTable.index(\"test\").shard(i).shards().size(), equalTo(2));\n            assertThat(routingTable.index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n            assertThat(routingTable.index(\"test\").shard(i).replicaShards().get(0).state(), equalTo(UNASSIGNED));\n        }\n\n        logger.info(\"start all the primary shards, replicas will start initializing\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        prevRoutingTable = routingTable;\n        routingTable = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        routingNodes = clusterState.getRoutingNodes();\n\n        for (int i = 0; i < routingTable.index(\"test\").shards().size(); i++) {\n            assertThat(routingTable.index(\"test\").shard(i).shards().size(), equalTo(2));\n            assertThat(routingTable.index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n            assertThat(routingTable.index(\"test\").shard(i).replicaShards().get(0).state(), equalTo(INITIALIZING));\n            assertEquals(routingTable.index(\"test\").shard(i).replicaShards().get(0).getExpectedShardSize(), sizes[i]);\n        }\n\n        logger.info(\"now, start 8 more nodes, and check that no rebalancing/relocation have happened\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .put(newNode(\"node3\")).put(newNode(\"node4\")).put(newNode(\"node5\")).put(newNode(\"node6\")).put(newNode(\"node7\")).put(newNode(\"node8\")).put(newNode(\"node9\")).put(newNode(\"node10\")))\n                .build();\n        prevRoutingTable = routingTable;\n        routingTable = strategy.reroute(clusterState).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        routingNodes = clusterState.getRoutingNodes();\n\n        for (int i = 0; i < routingTable.index(\"test\").shards().size(); i++) {\n            assertThat(routingTable.index(\"test\").shard(i).shards().size(), equalTo(2));\n            assertThat(routingTable.index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n            assertThat(routingTable.index(\"test\").shard(i).replicaShards().get(0).state(), equalTo(INITIALIZING));\n            assertEquals(routingTable.index(\"test\").shard(i).replicaShards().get(0).getExpectedShardSize(), sizes[i]);\n\n        }\n\n        logger.info(\"start the replica shards, rebalancing should start\");\n        routingNodes = clusterState.getRoutingNodes();\n        prevRoutingTable = routingTable;\n        routingTable = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        routingNodes = clusterState.getRoutingNodes();\n\n        // we only allow one relocation at a time\n        assertThat(routingTable.shardsWithState(STARTED).size(), equalTo(5));\n        assertThat(routingTable.shardsWithState(RELOCATING).size(), equalTo(5));\n        for (int i = 0; i < routingTable.index(\"test\").shards().size(); i++) {\n            int num = 0;\n            for (ShardRouting routing : routingTable.index(\"test\").shard(i).shards()) {\n                if (routing.state() == RELOCATING || routing.state() == INITIALIZING) {\n                    assertEquals(routing.getExpectedShardSize(), sizes[i]);\n                    num++;\n                }\n            }\n            assertTrue(num > 0);\n        }\n\n        logger.info(\"complete relocation, other half of relocation should happen\");\n        routingNodes = clusterState.getRoutingNodes();\n        prevRoutingTable = routingTable;\n        routingTable = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        routingNodes = clusterState.getRoutingNodes();\n\n        // we now only relocate 3, since 2 remain where they are!\n        assertThat(routingTable.shardsWithState(STARTED).size(), equalTo(7));\n        assertThat(routingTable.shardsWithState(RELOCATING).size(), equalTo(3));\n        for (int i = 0; i < routingTable.index(\"test\").shards().size(); i++) {\n            for (ShardRouting routing : routingTable.index(\"test\").shard(i).shards()) {\n                if (routing.state() == RELOCATING || routing.state() == INITIALIZING) {\n                    assertEquals(routing.getExpectedShardSize(), sizes[i]);\n                }\n            }\n        }\n\n\n        logger.info(\"complete relocation, thats it!\");\n        routingNodes = clusterState.getRoutingNodes();\n        prevRoutingTable = routingTable;\n        routingTable = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        routingNodes = clusterState.getRoutingNodes();\n\n        assertThat(routingTable.shardsWithState(STARTED).size(), equalTo(10));\n        // make sure we have an even relocation\n        for (RoutingNode routingNode : routingNodes) {\n            assertThat(routingNode.size(), equalTo(1));\n        }\n    }","commit_id":"0c71328186d69d35b698eaae485a51cb3151cdc5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n   * Adds a fork to the {@link Workflow}\n   * @param branches the list of branches to be added to the {@link Workflow}\n   */\n  protected final void addFork(List<String> branches) {\n    configurer.addFork(branches);\n  }","id":26830,"modified_method":"/**\n   * Adds a fork to the {@link Workflow}\n   * @param fork the name of the fork to be added to the {@link Workflow}\n   * @param branches the list of branches to be added to the {@link Workflow}\n   */\n  protected final void addFork(String fork, List<String> branches) {\n    configurer.addFork(fork, branches);\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"public WorkflowSpecification createSpecification() {\n    return new WorkflowSpecification(className, name, description, properties, nodes, forks, customActionMap);\n  }","id":26831,"modified_method":"public WorkflowSpecification createSpecification() {\n    return new WorkflowSpecification(className, name, description, properties, nodes, forks, mapreduces, sparks,\n                                     customActionMap);\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void addAction(WorkflowAction action) {\n    Preconditions.checkArgument(action != null, \"WorkflowAction is null.\");\n    WorkflowActionSpecification spec = new DefaultWorkflowActionSpecification(action);\n    customActionMap.put(spec.getName(), spec);\n    nodes.add(new WorkflowNode(WorkflowNodeType.ACTION, new ScheduleProgramInfo(SchedulableProgramType.CUSTOM_ACTION,\n                                                                                spec.getName())));\n  }","id":26832,"modified_method":"@Override\n  public void addAction(WorkflowAction action) {\n    Preconditions.checkArgument(action != null, \"WorkflowAction is null.\");\n    WorkflowActionSpecification spec = new DefaultWorkflowActionSpecification(action);\n    customActionMap.put(spec.getName(), spec);\n    nodes.add(new WorkflowNode(spec.getName(), WorkflowNodeType.ACTION));\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void addFork(List<String> branchList) {\n    Preconditions.checkArgument(branchList != null, \"List of branches for the fork is null.\");\n    Preconditions.checkArgument(branchList.size() > 1, \"Atleast two branches needed for fork.\");\n\n    List<WorkflowForkBranch> forkBranches = Lists.newArrayList();\n\n    for (String branch : branchList) {\n      Preconditions.checkArgument(branches.containsKey(branch), \"Fork branch '\" + branch + \"' is not found.\");\n      WorkflowForkBranch forkBranch = new WorkflowForkBranch(branch, branches.get(branch));\n      forkBranches.add(forkBranch);\n    }\n\n    int forkSize = forks.size();\n    // Generate the id for the fork based on its occurrence in the Workflow\n    String forkId = \"fork_\" + forkSize;\n    forks.put(forkId, new WorkflowFork(forkBranches));\n\n    WorkflowNode node = new WorkflowNode(WorkflowNodeType.FORK,\n                                         new ScheduleProgramInfo(SchedulableProgramType.NONE, forkId));\n    nodes.add(node);\n  }","id":26833,"modified_method":"@Override\n  public void addFork(String fork, List<String> branchList) {\n    Preconditions.checkArgument(branchList != null, \"List of branches for the fork is null.\");\n    Preconditions.checkArgument(branchList.size() > 1, \"Atleast two branches needed for fork.\");\n\n    List<WorkflowForkBranch> forkBranches = Lists.newArrayList();\n\n    for (String branch : branchList) {\n      Preconditions.checkArgument(branches.containsKey(branch), \"Fork branch '\" + branch + \"' is not found.\");\n      WorkflowForkBranch forkBranch = new WorkflowForkBranch(branch, branches.get(branch));\n      forkBranches.add(forkBranch);\n    }\n\n    forks.put(fork, new WorkflowFork(forkBranches));\n\n    WorkflowNode node = new WorkflowNode(fork, WorkflowNodeType.FORK);\n    nodes.add(node);\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void addMapReduceToBranch(String mapReduce, String branch) {\n    Preconditions.checkNotNull(mapReduce, \"MapReduce name is null.\");\n    Preconditions.checkArgument(!mapReduce.isEmpty(), \"MapReduce name is empty.\");\n    Preconditions.checkNotNull(branch, \"Branch name is null.\");\n    Preconditions.checkArgument(!branch.isEmpty(), \"Branch name is empty.\");\n\n    if (!branches.containsKey(branch)) {\n      branches.put(branch, new ArrayList<WorkflowNode>());\n    }\n    WorkflowNode node = new WorkflowNode(WorkflowNodeType.ACTION,\n                                         new ScheduleProgramInfo(SchedulableProgramType.MAPREDUCE, mapReduce));\n    branches.get(branch).add(node);\n  }","id":26834,"modified_method":"@Override\n  public void addMapReduceToBranch(String mapReduce, String branch) {\n    Preconditions.checkNotNull(mapReduce, \"MapReduce name is null.\");\n    Preconditions.checkArgument(!mapReduce.isEmpty(), \"MapReduce name is empty.\");\n    Preconditions.checkNotNull(branch, \"Branch name is null.\");\n    Preconditions.checkArgument(!branch.isEmpty(), \"Branch name is empty.\");\n\n    mapreduces.add(mapReduce);\n    if (!branches.containsKey(branch)) {\n      branches.put(branch, new ArrayList<WorkflowNode>());\n    }\n    WorkflowNode node = new WorkflowNode(mapReduce, WorkflowNodeType.ACTION);\n    branches.get(branch).add(node);\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void addActionToBranch(WorkflowAction action, String branch) {\n    Preconditions.checkArgument(action != null, \"WorkflowAction is null.\");\n    Preconditions.checkNotNull(branch, \"Branch name is null.\");\n    Preconditions.checkArgument(!branch.isEmpty(), \"Branch name is empty.\");\n\n    WorkflowActionSpecification spec = new DefaultWorkflowActionSpecification(action);\n    customActionMap.put(spec.getName(), spec);\n\n    if (!branches.containsKey(branch)) {\n      branches.put(branch, new ArrayList<WorkflowNode>());\n    }\n    WorkflowNode node = new WorkflowNode(WorkflowNodeType.ACTION,\n                                         new ScheduleProgramInfo(SchedulableProgramType.CUSTOM_ACTION, spec.getName()));\n    branches.get(branch).add(node);\n  }","id":26835,"modified_method":"@Override\n  public void addActionToBranch(WorkflowAction action, String branch) {\n    Preconditions.checkArgument(action != null, \"WorkflowAction is null.\");\n    Preconditions.checkNotNull(branch, \"Branch name is null.\");\n    Preconditions.checkArgument(!branch.isEmpty(), \"Branch name is empty.\");\n\n    WorkflowActionSpecification spec = new DefaultWorkflowActionSpecification(action);\n    customActionMap.put(spec.getName(), spec);\n\n    if (!branches.containsKey(branch)) {\n      branches.put(branch, new ArrayList<WorkflowNode>());\n    }\n    WorkflowNode node = new WorkflowNode(spec.getName(), WorkflowNodeType.ACTION);\n    branches.get(branch).add(node);\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void addSparkToBranch(String spark, String branch) {\n    Preconditions.checkNotNull(spark, \"Spark program name is null.\");\n    Preconditions.checkArgument(!spark.isEmpty(), \"Spark program name is empty.\");\n    Preconditions.checkNotNull(branch, \"Branch name is null.\");\n    Preconditions.checkArgument(!branch.isEmpty(), \"Branch name is empty.\");\n\n    if (!branches.containsKey(branch)) {\n      branches.put(branch, new ArrayList<WorkflowNode>());\n    }\n    WorkflowNode node = new WorkflowNode(WorkflowNodeType.ACTION,\n                                         new ScheduleProgramInfo(SchedulableProgramType.SPARK, spark));\n    branches.get(branch).add(node);\n  }","id":26836,"modified_method":"@Override\n  public void addSparkToBranch(String spark, String branch) {\n    Preconditions.checkNotNull(spark, \"Spark program name is null.\");\n    Preconditions.checkArgument(!spark.isEmpty(), \"Spark program name is empty.\");\n    Preconditions.checkNotNull(branch, \"Branch name is null.\");\n    Preconditions.checkArgument(!branch.isEmpty(), \"Branch name is empty.\");\n\n    sparks.add(spark);\n    if (!branches.containsKey(branch)) {\n      branches.put(branch, new ArrayList<WorkflowNode>());\n    }\n    WorkflowNode node = new WorkflowNode(spark, WorkflowNodeType.ACTION);\n    branches.get(branch).add(node);\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void addMapReduce(String mapReduce) {\n    Preconditions.checkNotNull(mapReduce, \"MapReduce name is null.\");\n    Preconditions.checkArgument(!mapReduce.isEmpty(), \"MapReduce name is empty.\");\n    nodes.add(new WorkflowNode(WorkflowNodeType.ACTION, new ScheduleProgramInfo(SchedulableProgramType.MAPREDUCE,\n                                                                                mapReduce)));\n  }","id":26837,"modified_method":"@Override\n  public void addMapReduce(String mapReduce) {\n    Preconditions.checkNotNull(mapReduce, \"MapReduce name is null.\");\n    Preconditions.checkArgument(!mapReduce.isEmpty(), \"MapReduce name is empty.\");\n    mapreduces.add(mapReduce);\n    nodes.add(new WorkflowNode(mapReduce, WorkflowNodeType.ACTION));\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void addSpark(String spark) {\n    Preconditions.checkNotNull(spark, \"Spark program name is null.\");\n    Preconditions.checkArgument(!spark.isEmpty(), \"Spark program name is empty.\");\n    nodes.add(new WorkflowNode(WorkflowNodeType.ACTION, new ScheduleProgramInfo(SchedulableProgramType.SPARK, spark)));\n  }","id":26838,"modified_method":"@Override\n  public void addSpark(String spark) {\n    Preconditions.checkNotNull(spark, \"Spark program name is null.\");\n    Preconditions.checkArgument(!spark.isEmpty(), \"Spark program name is empty.\");\n    sparks.add(spark);\n    nodes.add(new WorkflowNode(spark, WorkflowNodeType.ACTION));\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"private void verifyWorkflowNode(ApplicationSpecification appSpec, WorkflowSpecification workflowSpec,\n                                  WorkflowNode node) {\n    WorkflowNodeType nodeType = node.getType();\n    switch (nodeType) {\n      case ACTION:\n        verifyWorkflowAction(appSpec, node.getProgramInfo());\n        break;\n      case FORK:\n        for (Map.Entry<String, WorkflowFork> entry : workflowSpec.getForks().entrySet()) {\n          List<WorkflowForkBranch> forkBranches = entry.getValue().getBranches();\n          if (forkBranches == null) {\n            throw new RuntimeException(String.format(\"Fork is added in the Workflow '%s' without any branches\",\n                                                     workflowSpec.getName()));\n          }\n\n          for (WorkflowForkBranch branch : forkBranches) {\n            for (WorkflowNode n : branch.getNodes()) {\n              verifyWorkflowNode(appSpec, workflowSpec, n);\n            }\n          }\n        }\n        break;\n      case CONDITION:\n        // no-op\n        break;\n      default:\n        break;\n    }\n  }","id":26839,"modified_method":"private void verifyWorkflowNode(ApplicationSpecification appSpec, WorkflowSpecification workflowSpec,\n                                  WorkflowNode node) {\n    WorkflowNodeType nodeType = node.getType();\n    switch (nodeType) {\n      case ACTION:\n        verifyWorkflowAction(appSpec, workflowSpec.getProgramInfo(node.getName()));\n        break;\n      case FORK:\n        for (Map.Entry<String, WorkflowFork> entry : workflowSpec.getForks().entrySet()) {\n          List<WorkflowForkBranch> forkBranches = entry.getValue().getBranches();\n          if (forkBranches == null) {\n            throw new RuntimeException(String.format(\"Fork is added in the Workflow '%s' without any branches\",\n                                                     workflowSpec.getName()));\n          }\n\n          for (WorkflowForkBranch branch : forkBranches) {\n            for (WorkflowNode n : branch.getNodes()) {\n              verifyWorkflowNode(appSpec, workflowSpec, n);\n            }\n          }\n        }\n        break;\n      case CONDITION:\n        // no-op\n        break;\n      default:\n        break;\n    }\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void run() throws Exception {\n    LOG.info(\"Start workflow execution for {}\", workflowSpec);\n    InstantiatorFactory instantiator = new InstantiatorFactory(false);\n    ClassLoader classLoader = program.getClassLoader();\n\n    // Executes actions step by step. Individually invoke the init()->run()->destroy() sequence.\n\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n\n    Iterator<WorkflowNode> iterator = workflowSpec.getNodes().iterator();\n    int step = 0;\n    while (running && iterator.hasNext()) {\n      WorkflowActionSpecification actionSpec;\n      WorkflowNode node = iterator.next();\n      switch (node.getType()) {\n        case ACTION:\n          ScheduleProgramInfo actionInfo = node.getProgramInfo();\n          switch (actionInfo.getProgramType()) {\n            case MAPREDUCE:\n              MapReduceSpecification mapReduceSpec = appSpec.getMapReduce().get(actionInfo.getProgramName());\n              String mapReduce = mapReduceSpec.getName();\n              actionSpec = new DefaultWorkflowActionSpecification(new ProgramWorkflowAction(\n                mapReduce, mapReduce, SchedulableProgramType.MAPREDUCE));\n              break;\n            case SPARK:\n              SparkSpecification sparkSpec = appSpec.getSpark().get(actionInfo.getProgramName());\n              String spark = sparkSpec.getName();\n              actionSpec = new DefaultWorkflowActionSpecification(new ProgramWorkflowAction(\n                spark, spark, SchedulableProgramType.SPARK));\n              break;\n            case CUSTOM_ACTION:\n              actionSpec = workflowSpec.getCustomActionMap().get(actionInfo.getProgramName());\n              break;\n            default:\n              LOG.error(\"Unknown Program Type '{}', Program '{}' in the Workflow.\", actionInfo.getProgramType(),\n                        actionInfo.getProgramName());\n              throw new IllegalStateException(\"Workflow stopped without executing all tasks\");\n          }\n          workflowStatus = new WorkflowStatus(state(), actionSpec, step++);\n\n          WorkflowAction action = initialize(actionSpec, classLoader, instantiator);\n          try {\n            ClassLoader oldClassLoader = ClassLoaders.setContextClassLoader(action.getClass().getClassLoader());\n            try {\n              action.run();\n            } finally {\n              ClassLoaders.setContextClassLoader(oldClassLoader);\n            }\n          } catch (Throwable t) {\n            LOG.warn(\"Exception on WorkflowAction.run(), aborting Workflow. {}\", actionSpec);\n            // this will always rethrow\n            Throwables.propagateIfPossible(t, Exception.class);\n          } finally {\n            // Destroy the action.\n            destroy(actionSpec, action);\n          }\n          break;\n        case FORK:\n          // not-implemented yet\n          break;\n        case CONDITION:\n          break;\n        default:\n      }\n    }\n\n    // If there is some task left when the loop exited, it must be called by explicit stop of this driver.\n    if (iterator.hasNext()) {\n      LOG.warn(\"Workflow explicitly stopped. Treated as abort on error. {} {}\", workflowSpec);\n      throw new IllegalStateException(\"Workflow stopped without executing all tasks: \" + workflowSpec);\n    }\n\n    LOG.info(\"Workflow execution succeeded for {}\", workflowSpec);\n\n    running = false;\n  }","id":26840,"modified_method":"@Override\n  protected void run() throws Exception {\n    LOG.info(\"Start workflow execution for {}\", workflowSpec);\n    InstantiatorFactory instantiator = new InstantiatorFactory(false);\n    ClassLoader classLoader = program.getClassLoader();\n\n    // Executes actions step by step. Individually invoke the init()->run()->destroy() sequence.\n\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n\n    Iterator<WorkflowNode> iterator = workflowSpec.getNodes().iterator();\n    int step = 0;\n    while (running && iterator.hasNext()) {\n      WorkflowActionSpecification actionSpec;\n      WorkflowNode node = iterator.next();\n      switch (node.getType()) {\n        case ACTION:\n          ScheduleProgramInfo actionInfo = workflowSpec.getProgramInfo(node.getName());\n          switch (actionInfo.getProgramType()) {\n            case MAPREDUCE:\n              MapReduceSpecification mapReduceSpec = appSpec.getMapReduce().get(actionInfo.getProgramName());\n              String mapReduce = mapReduceSpec.getName();\n              actionSpec = new DefaultWorkflowActionSpecification(new ProgramWorkflowAction(\n                mapReduce, mapReduce, SchedulableProgramType.MAPREDUCE));\n              break;\n            case SPARK:\n              SparkSpecification sparkSpec = appSpec.getSpark().get(actionInfo.getProgramName());\n              String spark = sparkSpec.getName();\n              actionSpec = new DefaultWorkflowActionSpecification(new ProgramWorkflowAction(\n                spark, spark, SchedulableProgramType.SPARK));\n              break;\n            case CUSTOM_ACTION:\n              actionSpec = workflowSpec.getCustomActionMap().get(actionInfo.getProgramName());\n              break;\n            default:\n              LOG.error(\"Unknown Program Type '{}', Program '{}' in the Workflow.\", actionInfo.getProgramType(),\n                        actionInfo.getProgramName());\n              throw new IllegalStateException(\"Workflow stopped without executing all tasks\");\n          }\n          workflowStatus = new WorkflowStatus(state(), actionSpec, step++);\n\n          WorkflowAction action = initialize(actionSpec, classLoader, instantiator);\n          try {\n            ClassLoader oldClassLoader = ClassLoaders.setContextClassLoader(action.getClass().getClassLoader());\n            try {\n              action.run();\n            } finally {\n              ClassLoaders.setContextClassLoader(oldClassLoader);\n            }\n          } catch (Throwable t) {\n            LOG.warn(\"Exception on WorkflowAction.run(), aborting Workflow. {}\", actionSpec);\n            // this will always rethrow\n            Throwables.propagateIfPossible(t, Exception.class);\n          } finally {\n            // Destroy the action.\n            destroy(actionSpec, action);\n          }\n          break;\n        case FORK:\n          // not-implemented yet\n          break;\n        case CONDITION:\n          break;\n        default:\n      }\n    }\n\n    // If there is some task left when the loop exited, it must be called by explicit stop of this driver.\n    if (iterator.hasNext()) {\n      LOG.warn(\"Workflow explicitly stopped. Treated as abort on error. {} {}\", workflowSpec);\n      throw new IllegalStateException(\"Workflow stopped without executing all tasks: \" + workflowSpec);\n    }\n\n    LOG.info(\"Workflow execution succeeded for {}\", workflowSpec);\n\n    running = false;\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    WorkflowNode that = (WorkflowNode) o;\n\n    return programInfo.equals(that.programInfo) && nodeType == that.nodeType;\n  }","id":26841,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    WorkflowNode that = (WorkflowNode) o;\n\n    return nodeName.equals(that.nodeName) && nodeType == that.nodeType;\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public int hashCode() {\n    int result = programInfo.hashCode();\n    result = 31 * result + nodeType.hashCode();\n    return result;\n  }","id":26842,"modified_method":"@Override\n  public int hashCode() {\n    int result = nodeName.hashCode();\n    result = 31 * result + nodeType.hashCode();\n    return result;\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Return the name of the {@link WorkflowNode} which is same as the name of the encapsulated program.\n   * In the case of Fork node, returns the fork identifier.\n   * @return the name of the {@link WorkflowNode}\n   */\n  public String getName() {\n    return programInfo.getProgramName();\n  }","id":26843,"modified_method":"/**\n   * If the {@link WorkflowNodeType} of the {@link WorkflowNode} is {@link WorkflowNodeType.ACTION},\n   * the name of the node is same as the name of the program or custom action represented by the node\n   * @return the name of the {@link WorkflowNode}\n   */\n  public String getName() {\n    return nodeName;\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"public WorkflowSpecification(String className, String name, String description,\n                                      Map<String, String> properties, List<WorkflowNode> nodes,\n                                      Map<String, WorkflowFork> forks,\n                                      Map<String, WorkflowActionSpecification> customActionMap) {\n    this.className = className;\n    this.name = name;\n    this.description = description;\n    this.properties = properties == null ? Collections.<String, String>emptyMap() :\n                                           Collections.unmodifiableMap(new HashMap<String, String>(properties));\n    this.nodes = Collections.unmodifiableList(new ArrayList<WorkflowNode>(nodes));\n    this.forks = forks == null ? Collections.<String, WorkflowFork>emptyMap() :\n      Collections.unmodifiableMap(new HashMap<String, WorkflowFork>(forks));\n    this.customActionMap = Collections.unmodifiableMap(new HashMap(customActionMap));\n  }","id":26844,"modified_method":"public WorkflowSpecification(String className, String name, String description,\n                                      Map<String, String> properties, List<WorkflowNode> nodes,\n                                      Map<String, WorkflowFork> forks, Set<String> mapreduces, Set<String> sparks,\n                                      Map<String, WorkflowActionSpecification> customActionMap) {\n    this.className = className;\n    this.name = name;\n    this.description = description;\n    this.properties = properties == null ? Collections.<String, String>emptyMap() :\n                                           Collections.unmodifiableMap(new HashMap<String, String>(properties));\n    this.nodes = Collections.unmodifiableList(new ArrayList<WorkflowNode>(nodes));\n    this.forks = Collections.unmodifiableMap(new HashMap<String, WorkflowFork>(forks));\n    this.mapreduces = Collections.unmodifiableSet(new HashSet<String>(mapreduces));\n    this.sparks = Collections.unmodifiableSet(new HashSet<String>(sparks));\n    this.customActionMap = Collections.unmodifiableMap(new HashMap(customActionMap));\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public WorkflowSpecification deserialize(JsonElement json, Type typeOfT,\n                                           JsonDeserializationContext context) throws JsonParseException {\n    JsonObject jsonObj = json.getAsJsonObject();\n\n    String className = jsonObj.get(\"className\").getAsString();\n    String name = jsonObj.get(\"name\").getAsString();\n    String description = jsonObj.get(\"description\").getAsString();\n    Map<String, String> properties = deserializeMap(jsonObj.get(\"properties\"), context, String.class);\n    List<WorkflowNode> nodes = deserializeList(jsonObj.get(\"nodes\"), context, WorkflowNode.class);\n    Map<String, WorkflowFork> forks = deserializeMap(jsonObj.get(\"forks\"), context, WorkflowFork.class);\n    Map<String, WorkflowActionSpecification> customActionMap = deserializeMap(jsonObj.get(\"customActionMap\"), context,\n                                                                    WorkflowActionSpecification.class);\n\n\n    return new WorkflowSpecification(className, name, description, properties, nodes, forks, customActionMap);\n  }","id":26845,"modified_method":"@Override\n  public WorkflowSpecification deserialize(JsonElement json, Type typeOfT,\n                                           JsonDeserializationContext context) throws JsonParseException {\n    JsonObject jsonObj = json.getAsJsonObject();\n\n    String className = jsonObj.get(\"className\").getAsString();\n    String name = jsonObj.get(\"name\").getAsString();\n    String description = jsonObj.get(\"description\").getAsString();\n    Map<String, String> properties = deserializeMap(jsonObj.get(\"properties\"), context, String.class);\n    List<WorkflowNode> nodes = deserializeList(jsonObj.get(\"nodes\"), context, WorkflowNode.class);\n    Map<String, WorkflowFork> forks = deserializeMap(jsonObj.get(\"forks\"), context, WorkflowFork.class);\n    Set<String> mapreduces = deserializeSet(jsonObj.get(\"mapreduces\"), context, String.class);\n    Set<String> sparks = deserializeSet(jsonObj.get(\"sparks\"), context, String.class);\n    Map<String, WorkflowActionSpecification> customActionMap = deserializeMap(jsonObj.get(\"customActionMap\"), context,\n                                                                    WorkflowActionSpecification.class);\n\n    return new WorkflowSpecification(className, name, description, properties, nodes, forks, mapreduces, sparks,\n                                     customActionMap);\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public JsonElement serialize(WorkflowSpecification src, Type typeOfSrc, JsonSerializationContext context) {\n    JsonObject jsonObj = new JsonObject();\n\n    jsonObj.add(\"className\", new JsonPrimitive(src.getClassName()));\n    jsonObj.add(\"name\", new JsonPrimitive(src.getName()));\n    jsonObj.add(\"description\", new JsonPrimitive(src.getDescription()));\n    jsonObj.add(\"properties\", serializeMap(src.getProperties(), context, String.class));\n    // TODO:SAGAR how to handle upgrades\n    jsonObj.add(\"nodes\", serializeList(src.getNodes(), context, WorkflowNode.class));\n    jsonObj.add(\"forks\", serializeMap(src.getForks(), context, WorkflowFork.class));\n\n    jsonObj.add(\"customActionMap\", serializeMap(src.getCustomActionMap(), context, WorkflowActionSpecification.class));\n\n\n    return jsonObj;\n  }","id":26846,"modified_method":"@Override\n  public JsonElement serialize(WorkflowSpecification src, Type typeOfSrc, JsonSerializationContext context) {\n    JsonObject jsonObj = new JsonObject();\n\n    jsonObj.add(\"className\", new JsonPrimitive(src.getClassName()));\n    jsonObj.add(\"name\", new JsonPrimitive(src.getName()));\n    jsonObj.add(\"description\", new JsonPrimitive(src.getDescription()));\n    jsonObj.add(\"properties\", serializeMap(src.getProperties(), context, String.class));\n    // TODO:SAGAR how to handle upgrades\n    jsonObj.add(\"nodes\", serializeList(src.getNodes(), context, WorkflowNode.class));\n    jsonObj.add(\"forks\", serializeMap(src.getForks(), context, WorkflowFork.class));\n    jsonObj.add(\"mapreduces\", serializeSet(src.getMapreduces(), context, String.class));\n    jsonObj.add(\"sparks\", serializeSet(src.getSparks(), context, String.class));\n    jsonObj.add(\"customActionMap\", serializeMap(src.getCustomActionMap(), context, WorkflowActionSpecification.class));\n\n    return jsonObj;\n  }","commit_id":"00556e976f1fa0fd7f504dd12b1d16b4b56b1e20","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tLong parentFolderId = (Long)getParameterValue(\"parentFolderId\");\n\n\t\tif (parentFolderId != null) {\n\t\t\tsuper.processRequest();\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncSite syncSite = (SyncSite)getParameterValue(\"syncSite\");\n\n\t\t// Refetch for updated last remote sync time\n\n\t\tsyncSite = SyncSiteService.fetchSyncSite(\n\t\t\tsyncSite.getGroupId(), syncSite.getSyncAccountId());\n\n\t\tif (syncSite.getRemoteSyncTime() == 0) {\n\t\t\tString filePathName = syncSite.getFilePathName();\n\n\t\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(filePathName);\n\n\t\t\tif (syncFile == null) {\n\t\t\t\tFiles.createDirectories(Paths.get(filePathName));\n\n\t\t\t\tSyncFileService.addSyncFile(\n\t\t\t\t\tnull, null, null, filePathName, null, filePathName, 0,\n\t\t\t\t\tsyncSite.getGroupId(), SyncFile.STATE_SYNCED,\n\t\t\t\t\tsyncSite.getSyncAccountId(), SyncFile.TYPE_SYSTEM);\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\tparameters.put(\"companyId\", syncSite.getCompanyId());\n\t\tparameters.put(\"lastAccessTime\", syncSite.getRemoteSyncTime());\n\t\tparameters.put(\"repositoryId\", syncSite.getGroupId());\n\n\t\texecutePost(_URL_PATH, parameters);\n\t}","id":26847,"modified_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tLong parentFolderId = (Long)getParameterValue(\"parentFolderId\");\n\n\t\tif (parentFolderId != null) {\n\t\t\tsuper.processRequest();\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncSite syncSite = (SyncSite)getParameterValue(\"syncSite\");\n\n\t\t// Refetch for updated last remote sync time\n\n\t\tsyncSite = SyncSiteService.fetchSyncSite(\n\t\t\tsyncSite.getGroupId(), syncSite.getSyncAccountId());\n\n\t\tif (syncSite.getRemoteSyncTime() == 0) {\n\t\t\tString filePathName = syncSite.getFilePathName();\n\n\t\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(filePathName);\n\n\t\t\tif (syncFile == null) {\n\t\t\t\tFiles.createDirectories(Paths.get(filePathName));\n\n\t\t\t\tSyncFileService.addSyncFile(\n\t\t\t\t\tnull, null, null, filePathName, null, syncSite.getName(), 0,\n\t\t\t\t\tsyncSite.getGroupId(), SyncFile.STATE_SYNCED,\n\t\t\t\t\tsyncSite.getSyncAccountId(), SyncFile.TYPE_SYSTEM);\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\tparameters.put(\"companyId\", syncSite.getCompanyId());\n\t\tparameters.put(\"lastAccessTime\", syncSite.getRemoteSyncTime());\n\t\tparameters.put(\"repositoryId\", syncSite.getGroupId());\n\n\t\texecutePost(_URL_PATH, parameters);\n\t}","commit_id":"4379fa30d3cdbb3335c325c3ec446f619a0ee15d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateFile(\n\t\t\tSyncFile sourceSyncFile, SyncFile targetSyncFile,\n\t\t\tString filePathName)\n\t\tthrows Exception {\n\n\t\tif (sourceSyncFile == null) {\n\t\t\taddFile(targetSyncFile, filePathName);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString sourceVersion = sourceSyncFile.getVersion();\n\n\t\tPath sourceFilePath = Paths.get(sourceSyncFile.getFilePathName());\n\n\t\tboolean filePathChanged = processFilePathChange(\n\t\t\tsourceSyncFile, targetSyncFile);\n\n\t\tsourceSyncFile.setChangeLog(targetSyncFile.getChangeLog());\n\t\tsourceSyncFile.setChecksum(targetSyncFile.getChecksum());\n\t\tsourceSyncFile.setDescription(targetSyncFile.getDescription());\n\t\tsourceSyncFile.setExtension(targetSyncFile.getExtension());\n\t\tsourceSyncFile.setExtraSettings(targetSyncFile.getExtraSettings());\n\t\tsourceSyncFile.setLockExpirationDate(\n\t\t\ttargetSyncFile.getLockExpirationDate());\n\t\tsourceSyncFile.setLockUserId(targetSyncFile.getLockUserId());\n\t\tsourceSyncFile.setLockUserName(targetSyncFile.getLockUserName());\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\t\tsourceSyncFile.setSize(targetSyncFile.getSize());\n\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_UPDATED_REMOTE);\n\t\tsourceSyncFile.setVersion(targetSyncFile.getVersion());\n\n\t\tSyncFileService.update(sourceSyncFile);\n\n\t\tif (filePathChanged && !Files.exists(sourceFilePath)) {\n\t\t\tif (targetSyncFile.isFolder()) {\n\t\t\t\tPath targetFilePath = Paths.get(filePathName);\n\n\t\t\t\tFiles.createDirectories(targetFilePath);\n\n\t\t\t\tSyncFileService.update(sourceSyncFile);\n\n\t\t\t\tSyncFileService.updateFileKeySyncFile(sourceSyncFile);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdownloadFile(sourceSyncFile, null, false);\n\t\t\t}\n\t\t}\n\t\telse if (targetSyncFile.isFile() &&\n\t\t\t\t FileUtil.hasFileChanged(targetSyncFile, sourceFilePath)) {\n\n\t\t\tdownloadFile(\n\t\t\t\tsourceSyncFile, sourceVersion,\n\t\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(targetSyncFile));\n\t\t}\n\t}","id":26848,"modified_method":"protected void updateFile(\n\t\t\tSyncFile sourceSyncFile, SyncFile targetSyncFile,\n\t\t\tString filePathName)\n\t\tthrows Exception {\n\n\t\tString sourceVersion = sourceSyncFile.getVersion();\n\n\t\tPath sourceFilePath = Paths.get(sourceSyncFile.getFilePathName());\n\n\t\tboolean filePathChanged = processFilePathChange(\n\t\t\tsourceSyncFile, targetSyncFile);\n\n\t\tsourceSyncFile.setChangeLog(targetSyncFile.getChangeLog());\n\t\tsourceSyncFile.setChecksum(targetSyncFile.getChecksum());\n\t\tsourceSyncFile.setDescription(targetSyncFile.getDescription());\n\t\tsourceSyncFile.setExtension(targetSyncFile.getExtension());\n\t\tsourceSyncFile.setExtraSettings(targetSyncFile.getExtraSettings());\n\t\tsourceSyncFile.setLockExpirationDate(\n\t\t\ttargetSyncFile.getLockExpirationDate());\n\t\tsourceSyncFile.setLockUserId(targetSyncFile.getLockUserId());\n\t\tsourceSyncFile.setLockUserName(targetSyncFile.getLockUserName());\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\t\tsourceSyncFile.setSize(targetSyncFile.getSize());\n\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_UPDATED_REMOTE);\n\t\tsourceSyncFile.setVersion(targetSyncFile.getVersion());\n\n\t\tSyncFileService.update(sourceSyncFile);\n\n\t\tif (filePathChanged && !Files.exists(sourceFilePath)) {\n\t\t\tif (targetSyncFile.isFolder()) {\n\t\t\t\tPath targetFilePath = Paths.get(filePathName);\n\n\t\t\t\tFiles.createDirectories(targetFilePath);\n\n\t\t\t\tSyncFileService.update(sourceSyncFile);\n\n\t\t\t\tSyncFileService.updateFileKeySyncFile(sourceSyncFile);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdownloadFile(sourceSyncFile, null, false);\n\t\t\t}\n\t\t}\n\t\telse if (targetSyncFile.isFile() &&\n\t\t\t\t hasFileChanged(\n\t\t\t\t\t sourceSyncFile, targetSyncFile, sourceFilePath)) {\n\n\t\t\tdownloadFile(\n\t\t\t\tsourceSyncFile, sourceVersion,\n\t\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(targetSyncFile));\n\t\t}\n\t}","commit_id":"4379fa30d3cdbb3335c325c3ec446f619a0ee15d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void processResponse(String response) throws Exception {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\n\t\tSyncDLObjectUpdate syncDLObjectUpdate = objectMapper.readValue(\n\t\t\tresponse, new TypeReference<SyncDLObjectUpdate>() {});\n\n\t\tfor (SyncFile targetSyncFile : syncDLObjectUpdate.getSyncDLObjects()) {\n\t\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\t\ttargetSyncFile.getParentFolderId());\n\n\t\t\tif (parentSyncFile == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString filePathName = \"\";\n\n\t\t\ttry {\n\t\t\t\tfilePathName = FileUtil.getFilePathName(\n\t\t\t\t\tparentSyncFile.getFilePathName(),\n\t\t\t\t\tFileUtil.getSanitizedFileName(\n\t\t\t\t\t\ttargetSyncFile.getName(),\n\t\t\t\t\t\ttargetSyncFile.getExtension()));\n\n\t\t\t\tSyncFile sourceSyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\t\t\ttargetSyncFile.getTypePK());\n\n\t\t\t\tif (isIgnoredFilePath(sourceSyncFile, filePathName)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString event = targetSyncFile.getEvent();\n\n\t\t\t\tif (event.equals(SyncFile.EVENT_ADD) ||\n\t\t\t\t\tevent.equals(SyncFile.EVENT_GET) ||\n\t\t\t\t\tevent.equals(SyncFile.EVENT_RESTORE)) {\n\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse if (event.equals(SyncFile.EVENT_DELETE)) {\n\t\t\t\t\tdeleteFile(sourceSyncFile, false);\n\t\t\t\t}\n\t\t\t\telse if (event.equals(SyncFile.EVENT_MOVE)) {\n\t\t\t\t\tmoveFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse if (event.equals(SyncFile.EVENT_TRASH)) {\n\t\t\t\t\tdeleteFile(sourceSyncFile, true);\n\t\t\t\t}\n\t\t\t\telse if (event.equals(SyncFile.EVENT_UPDATE)) {\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_logger.error(e.getMessage(), e);\n\n\t\t\t\tif (e instanceof FileSystemException) {\n\t\t\t\t\tString message = e.getMessage();\n\n\t\t\t\t\tif (message.contains(\"File name too long\")) {\n\t\t\t\t\t\ttargetSyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\t\t\t\ttargetSyncFile.setUiEvent(\n\t\t\t\t\t\t\tSyncFile.UI_EVENT_FILE_NAME_TOO_LONG);\n\n\t\t\t\t\t\tSyncFileService.update(targetSyncFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (getParameterValue(\"parentFolderId\") == null) {\n\t\t\tSyncSite syncSite = SyncSiteService.fetchSyncSite(\n\t\t\t\t(Long)getParameterValue(\"repositoryId\"), getSyncAccountId());\n\n\t\t\tsyncSite.setRemoteSyncTime(syncDLObjectUpdate.getLastAccessTime());\n\n\t\t\tSyncSiteService.update(syncSite);\n\t\t}\n\t}","id":26849,"modified_method":"@Override\n\tprotected void processResponse(String response) throws Exception {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\n\t\tSyncDLObjectUpdate syncDLObjectUpdate = objectMapper.readValue(\n\t\t\tresponse, new TypeReference<SyncDLObjectUpdate>() {});\n\n\t\tfor (SyncFile targetSyncFile : syncDLObjectUpdate.getSyncDLObjects()) {\n\t\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\t\ttargetSyncFile.getParentFolderId());\n\n\t\t\tif (parentSyncFile == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString filePathName = \"\";\n\n\t\t\ttry {\n\t\t\t\tfilePathName = FileUtil.getFilePathName(\n\t\t\t\t\tparentSyncFile.getFilePathName(),\n\t\t\t\t\tFileUtil.getSanitizedFileName(\n\t\t\t\t\t\ttargetSyncFile.getName(),\n\t\t\t\t\t\ttargetSyncFile.getExtension()));\n\n\t\t\t\tSyncFile sourceSyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\t\t\ttargetSyncFile.getTypePK());\n\n\t\t\t\tif (isIgnoredFilePath(sourceSyncFile, filePathName) ||\n\t\t\t\t\t((sourceSyncFile != null) &&\n\t\t\t\t\t (sourceSyncFile.getModifiedTime() ==\n\t\t\t\t\t\ttargetSyncFile.getModifiedTime()))) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString event = targetSyncFile.getEvent();\n\n\t\t\t\tif (event.equals(SyncFile.EVENT_ADD) ||\n\t\t\t\t\tevent.equals(SyncFile.EVENT_GET) ||\n\t\t\t\t\tevent.equals(SyncFile.EVENT_RESTORE)) {\n\n\t\t\t\t\tif (sourceSyncFile != null) {\n\t\t\t\t\t\tupdateFile(\n\t\t\t\t\t\t\tsourceSyncFile, targetSyncFile, filePathName);\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse if (event.equals(SyncFile.EVENT_DELETE)) {\n\t\t\t\t\tdeleteFile(sourceSyncFile, false);\n\t\t\t\t}\n\t\t\t\telse if (event.equals(SyncFile.EVENT_MOVE)) {\n\t\t\t\t\tmoveFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse if (event.equals(SyncFile.EVENT_TRASH)) {\n\t\t\t\t\tdeleteFile(sourceSyncFile, true);\n\t\t\t\t}\n\t\t\t\telse if (event.equals(SyncFile.EVENT_UPDATE)) {\n\t\t\t\t\tif (sourceSyncFile == null) {\n\t\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_logger.error(e.getMessage(), e);\n\n\t\t\t\tif (e instanceof FileSystemException) {\n\t\t\t\t\tString message = e.getMessage();\n\n\t\t\t\t\tif (message.contains(\"File name too long\")) {\n\t\t\t\t\t\ttargetSyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\t\t\t\ttargetSyncFile.setUiEvent(\n\t\t\t\t\t\t\tSyncFile.UI_EVENT_FILE_NAME_TOO_LONG);\n\n\t\t\t\t\t\tSyncFileService.update(targetSyncFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (getParameterValue(\"parentFolderId\") == null) {\n\t\t\tSyncSite syncSite = SyncSiteService.fetchSyncSite(\n\t\t\t\t(Long)getParameterValue(\"repositoryId\"), getSyncAccountId());\n\n\t\t\tsyncSite.setRemoteSyncTime(syncDLObjectUpdate.getLastAccessTime());\n\n\t\t\tSyncSiteService.update(syncSite);\n\t\t}\n\t}","commit_id":"4379fa30d3cdbb3335c325c3ec446f619a0ee15d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private StringBody _getStringBody(Object value) {\n\t\treturn new StringBody(\n\t\t\tString.valueOf(value),\n\t\t\tContentType.create(\n\t\t\t\tContentType.TEXT_PLAIN.getMimeType(),\n\t\t\t\tCharset.defaultCharset()));\n\t}","id":26850,"modified_method":"private StringBody _getStringBody(Object value) {\n\t\treturn new StringBody(\n\t\t\tString.valueOf(value),\n\t\t\tContentType.create(\n\t\t\t\tContentType.TEXT_PLAIN.getMimeType(),\n\t\t\t\tCharset.forName(\"UTF-8\")));\n\t}","commit_id":"4379fa30d3cdbb3335c325c3ec446f619a0ee15d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SyncAccount addSyncAccount(\n\t\t\tString filePathName, String login, int maxConnections,\n\t\t\tString password, int pollInterval, SyncSite[] syncSites,\n\t\t\tSyncUser syncUser, boolean trustSelfSigned, String url)\n\t\tthrows Exception {\n\n\t\t// Sync account\n\n\t\tSyncAccount syncAccount = new SyncAccount();\n\n\t\tsyncAccount.setFilePathName(filePathName);\n\t\tsyncAccount.setLogin(login);\n\t\tsyncAccount.setMaxConnections(maxConnections);\n\t\tsyncAccount.setPassword(Encryptor.encrypt(password));\n\t\tsyncAccount.setPollInterval(pollInterval);\n\t\tsyncAccount.setTrustSelfSigned(trustSelfSigned);\n\t\tsyncAccount.setUrl(url);\n\n\t\t_syncAccountPersistence.create(syncAccount);\n\n\t\t// Sync file\n\n\t\tPath dataFilePath = Files.createDirectories(\n\t\t\tFileUtil.getFilePath(filePathName, \".data\"));\n\n\t\tif (OSDetector.isWindows()) {\n\t\t\tFiles.setAttribute(dataFilePath, \"dos:hidden\", true);\n\t\t}\n\n\t\tSyncFileService.addSyncFile(\n\t\t\tnull, null, null, filePathName, null, filePathName, 0, 0,\n\t\t\tSyncFile.STATE_SYNCED, syncAccount.getSyncAccountId(),\n\t\t\tSyncFile.TYPE_SYSTEM);\n\n\t\t// Sync sites\n\n\t\tif (syncSites != null) {\n\t\t\tfor (SyncSite syncSite : syncSites) {\n\t\t\t\tString syncSiteName = syncSite.getName();\n\n\t\t\t\tif (!FileUtil.isValidFileName(syncSiteName)) {\n\t\t\t\t\tsyncSiteName = String.valueOf(syncSite.getGroupId());\n\t\t\t\t}\n\n\t\t\t\tsyncSite.setFilePathName(\n\t\t\t\t\tFileUtil.getFilePathName(\n\t\t\t\t\t\tsyncAccount.getFilePathName(), syncSiteName));\n\n\t\t\t\tsyncSite.setSyncAccountId(syncAccount.getSyncAccountId());\n\n\t\t\t\tSyncSiteService.update(syncSite);\n\t\t\t}\n\t\t}\n\n\t\t// Sync user\n\n\t\tsyncUser.setSyncAccountId(syncAccount.getSyncAccountId());\n\n\t\tSyncUserService.update(syncUser);\n\n\t\treturn syncAccount;\n\t}","id":26851,"modified_method":"public static SyncAccount addSyncAccount(\n\t\t\tString filePathName, String login, int maxConnections,\n\t\t\tString password, int pollInterval, SyncSite[] syncSites,\n\t\t\tSyncUser syncUser, boolean trustSelfSigned, String url)\n\t\tthrows Exception {\n\n\t\t// Sync account\n\n\t\tSyncAccount syncAccount = new SyncAccount();\n\n\t\tsyncAccount.setFilePathName(filePathName);\n\t\tsyncAccount.setLogin(login);\n\t\tsyncAccount.setMaxConnections(maxConnections);\n\t\tsyncAccount.setPassword(Encryptor.encrypt(password));\n\t\tsyncAccount.setPollInterval(pollInterval);\n\t\tsyncAccount.setTrustSelfSigned(trustSelfSigned);\n\t\tsyncAccount.setUrl(url);\n\n\t\t_syncAccountPersistence.create(syncAccount);\n\n\t\t// Sync file\n\n\t\tPath filePath = Paths.get(filePathName);\n\n\t\tPath dataFilePath = Files.createDirectories(filePath.resolve(\".data\"));\n\n\t\tif (OSDetector.isWindows()) {\n\t\t\tFiles.setAttribute(dataFilePath, \"dos:hidden\", true);\n\t\t}\n\n\t\tSyncFileService.addSyncFile(\n\t\t\tnull, null, null, filePathName, null,\n\t\t\tString.valueOf(filePath.getFileName()), 0, 0, SyncFile.STATE_SYNCED,\n\t\t\tsyncAccount.getSyncAccountId(), SyncFile.TYPE_SYSTEM);\n\n\t\t// Sync sites\n\n\t\tif (syncSites != null) {\n\t\t\tfor (SyncSite syncSite : syncSites) {\n\t\t\t\tString syncSiteName = syncSite.getName();\n\n\t\t\t\tif (!FileUtil.isValidFileName(syncSiteName)) {\n\t\t\t\t\tsyncSiteName = String.valueOf(syncSite.getGroupId());\n\t\t\t\t}\n\n\t\t\t\tsyncSite.setFilePathName(\n\t\t\t\t\tFileUtil.getFilePathName(\n\t\t\t\t\t\tsyncAccount.getFilePathName(), syncSiteName));\n\n\t\t\t\tsyncSite.setSyncAccountId(syncAccount.getSyncAccountId());\n\n\t\t\t\tSyncSiteService.update(syncSite);\n\t\t\t}\n\t\t}\n\n\t\t// Sync user\n\n\t\tsyncUser.setSyncAccountId(syncAccount.getSyncAccountId());\n\n\t\tSyncUserService.update(syncUser);\n\n\t\treturn syncAccount;\n\t}","commit_id":"4379fa30d3cdbb3335c325c3ec446f619a0ee15d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SyncFile addFileSyncFile(\n\t\t\tPath filePath, long folderId, long repositoryId, long syncAccountId)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tif (Files.notExists(filePath)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString checksum = FileUtil.getChecksum(filePath);\n\t\tString name = String.valueOf(filePath.getFileName());\n\t\tString mimeType = Files.probeContentType(filePath);\n\n\t\tSyncFile syncFile = addSyncFile(\n\t\t\tnull, checksum, null, filePath.toString(), mimeType, name, folderId,\n\t\t\trepositoryId, SyncFile.STATE_SYNCED, syncAccountId,\n\t\t\tSyncFile.TYPE_FILE);\n\n\t\tIODeltaUtil.checksums(syncFile);\n\n\t\t// Remote sync file\n\n\t\tFileEventUtil.addFile(\n\t\t\tfilePath, folderId, repositoryId, syncAccountId, checksum, name,\n\t\t\tmimeType, syncFile);\n\n\t\treturn syncFile;\n\t}","id":26852,"modified_method":"public static SyncFile addFileSyncFile(\n\t\t\tPath filePath, long folderId, long repositoryId, long syncAccountId)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tif (Files.notExists(filePath)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString checksum = FileUtil.getChecksum(filePath);\n\t\tString name = String.valueOf(filePath.getFileName());\n\t\tString mimeType = Files.probeContentType(filePath);\n\n\t\tSyncFile syncFile = addSyncFile(\n\t\t\tnull, checksum, null, filePath.toString(), mimeType, name, folderId,\n\t\t\trepositoryId, SyncFile.STATE_SYNCED, syncAccountId,\n\t\t\tSyncFile.TYPE_FILE);\n\n\t\t// Remote sync file\n\n\t\tFileEventUtil.addFile(\n\t\t\tfilePath, folderId, repositoryId, syncAccountId, checksum, name,\n\t\t\tmimeType, syncFile);\n\n\t\treturn syncFile;\n\t}","commit_id":"4379fa30d3cdbb3335c325c3ec446f619a0ee15d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SyncFile addSyncFile(\n\t\t\tString changeLog, String checksum, String description,\n\t\t\tString filePathName, String mimeType, String name,\n\t\t\tlong parentFolderId, long repositoryId, int state,\n\t\t\tlong syncAccountId, String type)\n\t\tthrows Exception {\n\n\t\tSyncFile syncFile = new SyncFile();\n\n\t\tsyncFile.setChangeLog(changeLog);\n\t\tsyncFile.setChecksum(checksum);\n\t\tsyncFile.setDescription(description);\n\t\tsyncFile.setFilePathName(filePathName);\n\t\tsyncFile.setLocalSyncTime(System.currentTimeMillis());\n\t\tsyncFile.setMimeType(mimeType);\n\t\tsyncFile.setName(name);\n\t\tsyncFile.setParentFolderId(parentFolderId);\n\t\tsyncFile.setRepositoryId(repositoryId);\n\t\tsyncFile.setState(state);\n\t\tsyncFile.setSyncAccountId(syncAccountId);\n\t\tsyncFile.setType(type);\n\n\t\t_syncFilePersistence.create(syncFile);\n\n\t\tupdateFileKeySyncFile(syncFile);\n\n\t\treturn syncFile;\n\t}","id":26853,"modified_method":"public static SyncFile addSyncFile(\n\t\t\tString changeLog, String checksum, String description,\n\t\t\tString filePathName, String mimeType, String name,\n\t\t\tlong parentFolderId, long repositoryId, int state,\n\t\t\tlong syncAccountId, String type)\n\t\tthrows Exception {\n\n\t\tSyncFile syncFile = new SyncFile();\n\n\t\tsyncFile.setChangeLog(changeLog);\n\t\tsyncFile.setChecksum(checksum);\n\t\tsyncFile.setDescription(description);\n\t\tsyncFile.setFilePathName(filePathName);\n\t\tsyncFile.setLocalSyncTime(System.currentTimeMillis());\n\t\tsyncFile.setMimeType(mimeType);\n\t\tsyncFile.setName(name);\n\t\tsyncFile.setParentFolderId(parentFolderId);\n\t\tsyncFile.setRepositoryId(repositoryId);\n\t\tsyncFile.setState(state);\n\t\tsyncFile.setSyncAccountId(syncAccountId);\n\t\tsyncFile.setType(type);\n\n\t\t_syncFilePersistence.create(syncFile);\n\n\t\tupdateFileKeySyncFile(syncFile);\n\n\t\tIODeltaUtil.checksums(syncFile);\n\n\t\treturn syncFile;\n\t}","commit_id":"4379fa30d3cdbb3335c325c3ec446f619a0ee15d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void run() {\n\t\tSyncWatchEvent lastSyncWatchEvent =\n\t\t\tSyncWatchEventService.fetchLastSyncWatchEvent(_syncAccountId);\n\n\t\tif (lastSyncWatchEvent == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tlong delta =\n\t\t\tSystem.currentTimeMillis() - lastSyncWatchEvent.getTimestamp();\n\n\t\tif (delta <= 500) {\n\t\t\t_inProgress = true;\n\n\t\t\treturn;\n\t\t}\n\n\t\tWatcher watcher = WatcherRegistry.getWatcher(_syncAccountId);\n\n\t\tList<String> createdFilePathNames = watcher.getCreatedFilePathNames();\n\n\t\tcreatedFilePathNames.clear();\n\n\t\tif (_logger.isTraceEnabled()) {\n\t\t\t_logger.trace(\"Processing sync watch events\");\n\t\t}\n\n\t\tList<SyncWatchEvent> syncWatchEvents =\n\t\t\tSyncWatchEventService.findBySyncAccountId(\n\t\t\t\t_syncAccountId, \"eventType\", true);\n\n\t\tfor (SyncWatchEvent syncWatchEvent : syncWatchEvents) {\n\t\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t\t_syncAccountId);\n\n\t\t\tif (syncAccount.getState() != SyncAccount.STATE_CONNECTED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (_processedSyncWatchEventIds.contains(\n\t\t\t\t\tsyncWatchEvent.getSyncWatchEventId())) {\n\n\t\t\t\tSyncWatchEventService.deleteSyncWatchEvent(\n\t\t\t\t\tsyncWatchEvent.getSyncWatchEventId());\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(\n\t\t\t\t\t\"Event type {} file path {} file type {} timestamp {}\",\n\t\t\t\t\tsyncWatchEvent.getEventType(),\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getFileType(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\t\t\t}\n\n\t\t\tboolean syncWatchEventProcessed = true;\n\n\t\t\tString fileType = syncWatchEvent.getFileType();\n\n\t\t\tString eventType = syncWatchEvent.getEventType();\n\n\t\t\ttry {\n\t\t\t\tif (eventType.equals(SyncWatchEvent.EVENT_TYPE_CREATE)) {\n\t\t\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\t\t\tsyncWatchEventProcessed = addFile(syncWatchEvent);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsyncWatchEventProcessed = addFolder(syncWatchEvent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_DELETE)) {\n\t\t\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\t\t\tdeleteFile(syncWatchEvent);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdeleteFolder(syncWatchEvent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_MODIFY)) {\n\t\t\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\t\t\tmodifyFile(syncWatchEvent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t}\n\n\t\t\tsyncAccount = SyncAccountService.fetchSyncAccount(_syncAccountId);\n\n\t\t\tif (syncWatchEventProcessed &&\n\t\t\t\t(syncAccount.getState() == SyncAccount.STATE_CONNECTED)) {\n\n\t\t\t\tSyncWatchEventService.deleteSyncWatchEvent(\n\t\t\t\t\tsyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\n\t\t_inProgress = false;\n\n\t\t_processedSyncWatchEventIds.clear();\n\t}","id":26854,"modified_method":"@Override\n\tpublic void run() {\n\t\tSyncWatchEvent lastSyncWatchEvent =\n\t\t\tSyncWatchEventService.fetchLastSyncWatchEvent(_syncAccountId);\n\n\t\tif (lastSyncWatchEvent == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tlong delta =\n\t\t\tSystem.currentTimeMillis() - lastSyncWatchEvent.getTimestamp();\n\n\t\tif (delta <= 500) {\n\t\t\t_inProgress = true;\n\n\t\t\treturn;\n\t\t}\n\n\t\tWatcher watcher = WatcherRegistry.getWatcher(_syncAccountId);\n\n\t\tif (watcher != null) {\n\t\t\tList<String> createdFilePathNames =\n\t\t\t\twatcher.getCreatedFilePathNames();\n\n\t\t\tcreatedFilePathNames.clear();\n\t\t}\n\n\t\tif (_logger.isTraceEnabled()) {\n\t\t\t_logger.trace(\"Processing sync watch events\");\n\t\t}\n\n\t\tList<SyncWatchEvent> syncWatchEvents =\n\t\t\tSyncWatchEventService.findBySyncAccountId(\n\t\t\t\t_syncAccountId, \"eventType\", true);\n\n\t\tfor (SyncWatchEvent syncWatchEvent : syncWatchEvents) {\n\t\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t\t_syncAccountId);\n\n\t\t\tif (syncAccount.getState() != SyncAccount.STATE_CONNECTED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (_processedSyncWatchEventIds.contains(\n\t\t\t\t\tsyncWatchEvent.getSyncWatchEventId())) {\n\n\t\t\t\tSyncWatchEventService.deleteSyncWatchEvent(\n\t\t\t\t\tsyncWatchEvent.getSyncWatchEventId());\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(\n\t\t\t\t\t\"Event type {} file path {} file type {} timestamp {}\",\n\t\t\t\t\tsyncWatchEvent.getEventType(),\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getFileType(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\t\t\t}\n\n\t\t\tboolean syncWatchEventProcessed = true;\n\n\t\t\tString fileType = syncWatchEvent.getFileType();\n\n\t\t\tString eventType = syncWatchEvent.getEventType();\n\n\t\t\ttry {\n\t\t\t\tif (eventType.equals(SyncWatchEvent.EVENT_TYPE_CREATE)) {\n\t\t\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\t\t\tsyncWatchEventProcessed = addFile(syncWatchEvent);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsyncWatchEventProcessed = addFolder(syncWatchEvent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_DELETE)) {\n\t\t\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\t\t\tdeleteFile(syncWatchEvent);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdeleteFolder(syncWatchEvent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_MODIFY)) {\n\t\t\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\t\t\tmodifyFile(syncWatchEvent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t}\n\n\t\t\tsyncAccount = SyncAccountService.fetchSyncAccount(_syncAccountId);\n\n\t\t\tif (syncWatchEventProcessed &&\n\t\t\t\t(syncAccount.getState() == SyncAccount.STATE_CONNECTED)) {\n\n\t\t\t\tSyncWatchEventService.deleteSyncWatchEvent(\n\t\t\t\t\tsyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\n\t\t_inProgress = false;\n\n\t\t_processedSyncWatchEventIds.clear();\n\t}","commit_id":"4379fa30d3cdbb3335c325c3ec446f619a0ee15d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean checksumsEqual(String checksum1, String checksum2) {\n\t\tif ((checksum1 == null) || (checksum2 == null) ||\n\t\t\tchecksum1.isEmpty() || checksum2.isEmpty()) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn checksum1.equals(checksum2);\n\t}","id":26855,"modified_method":"public static boolean checksumsEqual(String checksum1, String checksum2) {\n\t\tif (Validator.isBlank(checksum1) || Validator.isBlank(checksum2)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn checksum1.equals(checksum2);\n\t}","commit_id":"51e16d86a0d8753d58d8eb6d169d8c7b2cbdee51","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean isModified(SyncFile syncFile, Path filePath) {\n\t\tif ((filePath == null) || Files.notExists(filePath)) {\n\t\t\treturn true;\n\t\t}\n\n\t\ttry {\n\t\t\tif (MSOfficeFileUtil.isLegacyExcelFile(filePath)) {\n\t\t\t\tDate lastSavedDate = MSOfficeFileUtil.getLastSavedDate(\n\t\t\t\t\tfilePath);\n\n\t\t\t\tif ((lastSavedDate != null) && (lastSavedDate.getTime() ==\n\t\t\t\t\t\tGetterUtil.getLong(\n\t\t\t\t\t\t\tsyncFile.getLocalExtraSettingValue(\n\t\t\t\t\t\t\t\t\"lastSavedDate\")))) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (syncFile.getSize() > 0) {\n\t\t\t\tlong lastModifiedTime = getLastModifiedTime(filePath);\n\n\t\t\t\tlong modifiedTime = syncFile.getModifiedTime();\n\n\t\t\t\tif (OSDetector.isUnix()) {\n\t\t\t\t\tmodifiedTime = modifiedTime / 1000 * 1000;\n\t\t\t\t}\n\n\t\t\t\tif (((lastModifiedTime == modifiedTime) ||\n\t\t\t\t\t (lastModifiedTime ==\n\t\t\t\t\t\t syncFile.getPreviousModifiedTime())) &&\n\t\t\t\t\tFileKeyUtil.hasFileKey(\n\t\t\t\t\t\tfilePath, syncFile.getSyncFileId())) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(ioe.getMessage(), ioe);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif ((syncFile.getSize() > 0) &&\n\t\t\t\t(syncFile.getSize() != Files.size(filePath))) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(ioe.getMessage(), ioe);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tString checksum = getChecksum(filePath);\n\n\t\t\treturn !checksumsEqual(checksum, syncFile.getChecksum());\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(ioe.getMessage(), ioe);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}","id":26856,"modified_method":"public static boolean isModified(SyncFile syncFile, Path filePath) {\n\t\tif ((filePath == null) || Files.notExists(filePath)) {\n\t\t\treturn true;\n\t\t}\n\n\t\ttry {\n\t\t\tif (MSOfficeFileUtil.isLegacyExcelFile(filePath)) {\n\t\t\t\tDate lastSavedDate = MSOfficeFileUtil.getLastSavedDate(\n\t\t\t\t\tfilePath);\n\n\t\t\t\tif ((lastSavedDate != null) && (lastSavedDate.getTime() ==\n\t\t\t\t\t\tGetterUtil.getLong(\n\t\t\t\t\t\t\tsyncFile.getLocalExtraSettingValue(\n\t\t\t\t\t\t\t\t\"lastSavedDate\")))) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (syncFile.getSize() > 0) {\n\t\t\t\tlong lastModifiedTime = getLastModifiedTime(filePath);\n\n\t\t\t\tlong modifiedTime = syncFile.getModifiedTime();\n\n\t\t\t\tif (OSDetector.isUnix()) {\n\t\t\t\t\tmodifiedTime = modifiedTime / 1000 * 1000;\n\t\t\t\t}\n\n\t\t\t\tif (((lastModifiedTime == modifiedTime) ||\n\t\t\t\t\t (lastModifiedTime ==\n\t\t\t\t\t\t syncFile.getPreviousModifiedTime())) &&\n\t\t\t\t\tFileKeyUtil.hasFileKey(\n\t\t\t\t\t\tfilePath, syncFile.getSyncFileId())) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(ioe.getMessage(), ioe);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif ((syncFile.getSize() > 0) &&\n\t\t\t\t(syncFile.getSize() != Files.size(filePath))) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(ioe.getMessage(), ioe);\n\t\t\t}\n\t\t}\n\n\t\treturn !checksumsEqual(getChecksum(filePath), syncFile.getChecksum());\n\t}","commit_id":"51e16d86a0d8753d58d8eb6d169d8c7b2cbdee51","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getChecksum(Path filePath) throws IOException {\n\t\tif (!isValidChecksum(filePath)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tInputStream fileInputStream = null;\n\n\t\ttry {\n\t\t\tfileInputStream = Files.newInputStream(filePath);\n\n\t\t\tbyte[] bytes = DigestUtils.sha1(fileInputStream);\n\n\t\t\treturn Base64.encodeBase64String(bytes);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(fileInputStream);\n\t\t}\n\t}","id":26857,"modified_method":"public static String getChecksum(Path filePath) {\n\t\tInputStream fileInputStream = null;\n\n\t\ttry {\n\t\t\tif (!isValidChecksum(filePath)) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\tfileInputStream = Files.newInputStream(filePath);\n\n\t\t\tbyte[] bytes = DigestUtils.sha1(fileInputStream);\n\n\t\t\treturn Base64.encodeBase64String(bytes);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(ioe.getMessage(), ioe);\n\t\t\t}\n\n\t\t\treturn \"\";\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(fileInputStream);\n\t\t}\n\t}","commit_id":"51e16d86a0d8753d58d8eb6d169d8c7b2cbdee51","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getSanitizedFileName(\n\t\tString fileName, String extension) {\n\n\t\tfor (String blacklistChar : PropsValues.SYNC_FILE_BLACKLIST_CHARS) {\n\t\t\tfileName = fileName.replace(blacklistChar, \"_\");\n\t\t}\n\n\t\tfor (String blacklistCharLast :\n\t\t\t\tPropsValues.SYNC_FILE_BLACKLIST_CHARS_LAST) {\n\n\t\t\tif (blacklistCharLast.startsWith(\"\\\\u\")) {\n\t\t\t\tblacklistCharLast = StringEscapeUtils.unescapeJava(\n\t\t\t\t\tblacklistCharLast);\n\t\t\t}\n\n\t\t\tif (fileName.endsWith(blacklistCharLast)) {\n\t\t\t\tfileName = fileName.substring(0, fileName.length() - 1);\n\t\t\t}\n\t\t}\n\n\t\tif ((extension != null) && !extension.isEmpty()) {\n\t\t\tint x = fileName.lastIndexOf(\".\");\n\n\t\t\tif ((x == -1) ||\n\t\t\t\t!extension.equalsIgnoreCase(fileName.substring(x + 1))) {\n\n\t\t\t\tfileName += \".\" + extension;\n\t\t\t}\n\t\t}\n\n\t\tif (fileName.length() > 255) {\n\t\t\tint x = fileName.length() - 1;\n\n\t\t\tif ((extension != null) && !extension.isEmpty()) {\n\t\t\t\tx = fileName.lastIndexOf(\".\");\n\t\t\t}\n\n\t\t\tint y = x - (fileName.length() - 255);\n\n\t\t\tfileName = fileName.substring(0, y) + fileName.substring(x);\n\t\t}\n\n\t\treturn fileName;\n\t}","id":26858,"modified_method":"public static String getSanitizedFileName(\n\t\tString fileName, String extension) {\n\n\t\tfor (String blacklistChar : PropsValues.SYNC_FILE_BLACKLIST_CHARS) {\n\t\t\tfileName = fileName.replace(blacklistChar, \"_\");\n\t\t}\n\n\t\tfor (String blacklistCharLast :\n\t\t\t\tPropsValues.SYNC_FILE_BLACKLIST_CHARS_LAST) {\n\n\t\t\tif (blacklistCharLast.startsWith(\"\\\\u\")) {\n\t\t\t\tblacklistCharLast = StringEscapeUtils.unescapeJava(\n\t\t\t\t\tblacklistCharLast);\n\t\t\t}\n\n\t\t\tif (fileName.endsWith(blacklistCharLast)) {\n\t\t\t\tfileName = fileName.substring(0, fileName.length() - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (!Validator.isBlank(extension)) {\n\t\t\tint x = fileName.lastIndexOf(\".\");\n\n\t\t\tif ((x == -1) ||\n\t\t\t\t!extension.equalsIgnoreCase(fileName.substring(x + 1))) {\n\n\t\t\t\tfileName += \".\" + extension;\n\t\t\t}\n\t\t}\n\n\t\tif (fileName.length() > 255) {\n\t\t\tint x = fileName.length() - 1;\n\n\t\t\tif (!Validator.isBlank(extension)) {\n\t\t\t\tx = fileName.lastIndexOf(\".\");\n\t\t\t}\n\n\t\t\tint y = x - (fileName.length() - 255);\n\n\t\t\tfileName = fileName.substring(0, y) + fileName.substring(x);\n\t\t}\n\n\t\treturn fileName;\n\t}","commit_id":"51e16d86a0d8753d58d8eb6d169d8c7b2cbdee51","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processSyncFile(SyncFile targetSyncFile) {\n\t\tString event = targetSyncFile.getEvent();\n\n\t\tSyncFile sourceSyncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\ttargetSyncFile.getTypePK());\n\n\t\tif (event.equals(SyncFile.EVENT_DELETE) ||\n\t\t\tevent.equals(SyncFile.EVENT_TRASH)) {\n\n\t\t\tif (sourceSyncFile != null) {\n\t\t\t\ttry {\n\t\t\t\t\tdeleteFile(sourceSyncFile, targetSyncFile);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\ttargetSyncFile.getParentFolderId());\n\n\t\tif (parentSyncFile == null) {\n\t\t\tqueueSyncFile(targetSyncFile.getParentFolderId(), targetSyncFile);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString filePathName = \"\";\n\n\t\ttry {\n\t\t\tfilePathName = FileUtil.getFilePathName(\n\t\t\t\tparentSyncFile.getFilePathName(),\n\t\t\t\tFileUtil.getSanitizedFileName(\n\t\t\t\t\ttargetSyncFile.getName(), targetSyncFile.getExtension()));\n\n\t\t\tif (isIgnoredFilePath(sourceSyncFile, filePathName) ||\n\t\t\t\t((sourceSyncFile != null) &&\n\t\t\t\t (sourceSyncFile.getModifiedTime() ==\n\t\t\t\t\t targetSyncFile.getModifiedTime()))) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((sourceSyncFile != null) && !sourceSyncFile.isUnsynced()) {\n\t\t\t\tsourceSyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\t\t}\n\n\t\t\ttargetSyncFile.setFilePathName(filePathName);\n\t\t\ttargetSyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\n\t\t\tif (event.equals(SyncFile.EVENT_ADD) ||\n\t\t\t\tevent.equals(SyncFile.EVENT_GET)) {\n\n\t\t\t\tif (sourceSyncFile != null) {\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_MOVE)) {\n\t\t\t\tif (sourceSyncFile == null) {\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse if (sourceSyncFile.getParentFolderId() ==\n\t\t\t\t\t\t\ttargetSyncFile.getParentFolderId()) {\n\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmoveFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_RESTORE)) {\n\t\t\t\tif (sourceSyncFile != null) {\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse if (isParentUnsynced(targetSyncFile)) {\n\t\t\t\t\tif (targetSyncFile.isFolder()) {\n\t\t\t\t\t\ttargetSyncFile.setModifiedTime(0);\n\t\t\t\t\t\ttargetSyncFile.setState(SyncFile.STATE_UNSYNCED);\n\t\t\t\t\t\ttargetSyncFile.setSyncAccountId(getSyncAccountId());\n\t\t\t\t\t\ttargetSyncFile.setUiEvent(SyncFile.UI_EVENT_NONE);\n\n\t\t\t\t\t\tSyncFileService.update(targetSyncFile);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttargetSyncFile.setLocalExtraSetting(\"restoreEvent\", true);\n\n\t\t\t\t\tSyncFileService.update(targetSyncFile);\n\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_UPDATE)) {\n\t\t\t\tif (sourceSyncFile == null) {\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprocessDependentSyncFiles(targetSyncFile);\n\n\t\t\tif (getParameterValue(\"parentFolderId\") != null) {\n\t\t\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\t\t\t(Long)getParameterValue(\"repositoryId\"), getSyncAccountId(),\n\t\t\t\t\t(Long)getParameterValue(\"parentFolderId\"));\n\n\t\t\t\tif (syncFile != null) {\n\t\t\t\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\t\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_RESYNCING);\n\n\t\t\t\t\tSyncFileService.update(syncFile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (FileSystemException fse) {\n\t\t\tString message = fse.getMessage();\n\n\t\t\tif (message.contains(\"File name too long\")) {\n\t\t\t\ttargetSyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\t\ttargetSyncFile.setUiEvent(SyncFile.UI_EVENT_FILE_NAME_TOO_LONG);\n\n\t\t\t\tSyncFileService.update(targetSyncFile);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_logger.error(e.getMessage(), e);\n\t\t}\n\t}","id":26859,"modified_method":"protected void processSyncFile(SyncFile targetSyncFile) {\n\t\tString event = targetSyncFile.getEvent();\n\n\t\tSyncFile sourceSyncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\ttargetSyncFile.getTypePK());\n\n\t\tif (event.equals(SyncFile.EVENT_DELETE) ||\n\t\t\tevent.equals(SyncFile.EVENT_TRASH)) {\n\n\t\t\tif (sourceSyncFile != null) {\n\t\t\t\ttry {\n\t\t\t\t\tdeleteFile(sourceSyncFile, targetSyncFile);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\ttargetSyncFile.getParentFolderId());\n\n\t\tif (parentSyncFile == null) {\n\t\t\tqueueSyncFile(targetSyncFile.getParentFolderId(), targetSyncFile);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString filePathName = \"\";\n\n\t\ttry {\n\t\t\tfilePathName = FileUtil.getFilePathName(\n\t\t\t\tparentSyncFile.getFilePathName(),\n\t\t\t\tFileUtil.getSanitizedFileName(\n\t\t\t\t\ttargetSyncFile.getName(), targetSyncFile.getExtension()));\n\n\t\t\tif (isIgnoredFilePath(sourceSyncFile, filePathName)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((sourceSyncFile != null) &&\n\t\t\t\t(sourceSyncFile.getModifiedTime() ==\n\t\t\t\t\ttargetSyncFile.getModifiedTime()) &&\n\t\t\t\t!Validator.isBlank(targetSyncFile.getChecksum())) {\n\n\t\t\t\tsourceSyncFile.setChecksum(targetSyncFile.getChecksum());\n\n\t\t\t\tSyncFileService.update(sourceSyncFile);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((sourceSyncFile != null) && !sourceSyncFile.isUnsynced()) {\n\t\t\t\tsourceSyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\t\t}\n\n\t\t\ttargetSyncFile.setFilePathName(filePathName);\n\t\t\ttargetSyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\n\t\t\tif (event.equals(SyncFile.EVENT_ADD) ||\n\t\t\t\tevent.equals(SyncFile.EVENT_GET)) {\n\n\t\t\t\tif (sourceSyncFile != null) {\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_MOVE)) {\n\t\t\t\tif (sourceSyncFile == null) {\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse if (sourceSyncFile.getParentFolderId() ==\n\t\t\t\t\t\t\ttargetSyncFile.getParentFolderId()) {\n\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmoveFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_RESTORE)) {\n\t\t\t\tif (sourceSyncFile != null) {\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse if (isParentUnsynced(targetSyncFile)) {\n\t\t\t\t\tif (targetSyncFile.isFolder()) {\n\t\t\t\t\t\ttargetSyncFile.setModifiedTime(0);\n\t\t\t\t\t\ttargetSyncFile.setState(SyncFile.STATE_UNSYNCED);\n\t\t\t\t\t\ttargetSyncFile.setSyncAccountId(getSyncAccountId());\n\t\t\t\t\t\ttargetSyncFile.setUiEvent(SyncFile.UI_EVENT_NONE);\n\n\t\t\t\t\t\tSyncFileService.update(targetSyncFile);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttargetSyncFile.setLocalExtraSetting(\"restoreEvent\", true);\n\n\t\t\t\t\tSyncFileService.update(targetSyncFile);\n\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_UPDATE)) {\n\t\t\t\tif (sourceSyncFile == null) {\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprocessDependentSyncFiles(targetSyncFile);\n\n\t\t\tif (getParameterValue(\"parentFolderId\") != null) {\n\t\t\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\t\t\t(Long)getParameterValue(\"repositoryId\"), getSyncAccountId(),\n\t\t\t\t\t(Long)getParameterValue(\"parentFolderId\"));\n\n\t\t\t\tif (syncFile != null) {\n\t\t\t\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\t\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_RESYNCING);\n\n\t\t\t\t\tSyncFileService.update(syncFile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (FileSystemException fse) {\n\t\t\tString message = fse.getMessage();\n\n\t\t\tif (message.contains(\"File name too long\")) {\n\t\t\t\ttargetSyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\t\ttargetSyncFile.setUiEvent(SyncFile.UI_EVENT_FILE_NAME_TOO_LONG);\n\n\t\t\t\tSyncFileService.update(targetSyncFile);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_logger.error(e.getMessage(), e);\n\t\t}\n\t}","commit_id":"51e16d86a0d8753d58d8eb6d169d8c7b2cbdee51","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tif (_watchService == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tWatchKey watchKey = null;\n\n\t\t\ttry {\n\t\t\t\twatchKey = _watchService.take();\n\t\t\t}\n\t\t\tcatch (ConcurrentModificationException cme) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPath parentFilePath = _filePaths.get(watchKey);\n\n\t\t\tif (parentFilePath == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tList<WatchEvent<?>> watchEvents = watchKey.pollEvents();\n\n\t\t\tfor (int i = 0; i < watchEvents.size(); i++) {\n\t\t\t\tWatchEvent<Path> watchEvent = (WatchEvent<Path>)watchEvents.get(\n\t\t\t\t\ti);\n\n\t\t\t\tPathImpl pathImpl = (PathImpl)watchEvent.context();\n\n\t\t\t\tif (pathImpl == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tWatchEvent.Kind<?> kind = watchEvent.kind();\n\n\t\t\t\tPath childFilePath = parentFilePath.resolve(\n\t\t\t\t\tpathImpl.toString());\n\n\t\t\t\tif (((kind == StandardWatchEventKind.ENTRY_CREATE) &&\n\t\t\t\t\t isIgnoredFilePath(childFilePath)) ||\n\t\t\t\t\t((kind == StandardWatchEventKind.ENTRY_MODIFY) &&\n\t\t\t\t\t Files.isDirectory(childFilePath))) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (kind == StandardWatchEventKind.ENTRY_DELETE) {\n\t\t\t\t\tprocessMissingFilePath(childFilePath);\n\t\t\t\t}\n\n\t\t\t\tfireWatchEventListener(childFilePath, watchEvent);\n\n\t\t\t\tif (_recursive &&\n\t\t\t\t\t(kind == StandardWatchEventKind.ENTRY_CREATE)) {\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (Files.isDirectory(\n\t\t\t\t\t\t\t\tchildFilePath, LinkOption.NOFOLLOW_LINKS)) {\n\n\t\t\t\t\t\t\tregisterFilePath(childFilePath, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!watchKey.reset()) {\n\t\t\t\tPath filePath = _filePaths.remove(watchKey);\n\n\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t_logger.trace(\"Unregistered file path {}\", filePath);\n\t\t\t\t}\n\n\t\t\t\tprocessMissingFilePath(filePath);\n\n\t\t\t\tif (_filePaths.isEmpty()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":26860,"modified_method":"@Override\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tif (_watchService == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tWatchKey watchKey = null;\n\n\t\t\ttry {\n\t\t\t\twatchKey = _watchService.take();\n\t\t\t}\n\t\t\tcatch (ConcurrentModificationException cme) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPath parentFilePath = _filePaths.get(watchKey);\n\n\t\t\tif (parentFilePath == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tList<WatchEvent<?>> watchEvents = watchKey.pollEvents();\n\n\t\t\tfor (int i = 0; i < watchEvents.size(); i++) {\n\t\t\t\tWatchEvent<Path> watchEvent = (WatchEvent<Path>)watchEvents.get(\n\t\t\t\t\ti);\n\n\t\t\t\tPathImpl pathImpl = (PathImpl)watchEvent.context();\n\n\t\t\t\tif (pathImpl == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tWatchEvent.Kind<?> kind = watchEvent.kind();\n\n\t\t\t\tPath childFilePath = parentFilePath.resolve(\n\t\t\t\t\tpathImpl.toString());\n\n\t\t\t\tif (kind == StandardWatchEventKind.ENTRY_CREATE) {\n\t\t\t\t\tif (isIgnoredFilePath(childFilePath)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfireWatchEventListener(childFilePath, watchEvent);\n\n\t\t\t\t\tif (_recursive) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (Files.isDirectory(\n\t\t\t\t\t\t\t\t\tchildFilePath, LinkOption.NOFOLLOW_LINKS)) {\n\n\t\t\t\t\t\t\t\tregisterFilePath(childFilePath, true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (kind == StandardWatchEventKind.ENTRY_DELETE) {\n\t\t\t\t\tprocessMissingFilePath(childFilePath);\n\n\t\t\t\t\tfireWatchEventListener(childFilePath, watchEvent);\n\t\t\t\t}\n\t\t\t\telse if (kind == StandardWatchEventKind.ENTRY_MODIFY) {\n\t\t\t\t\tif (Files.isDirectory(childFilePath)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfireWatchEventListener(childFilePath, watchEvent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!watchKey.reset()) {\n\t\t\t\tPath filePath = _filePaths.remove(watchKey);\n\n\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t_logger.trace(\"Unregistered file path {}\", filePath);\n\t\t\t\t}\n\n\t\t\t\tprocessMissingFilePath(filePath);\n\n\t\t\t\tif (_filePaths.isEmpty()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"20a397933fe3add904e51f0e94368fb7e076cf71","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteFile(long syncAccountId, SyncFile syncFile) {\n\t\tMap<String, Object> parameters = new HashMap<>();\n\n\t\tparameters.put(\"fileEntryId\", syncFile.getTypePK());\n\t\tparameters.put(\"syncFile\", syncFile);\n\n\t\tMoveFileEntryToTrashEvent moveFileEntryToTrashEvent =\n\t\t\tnew MoveFileEntryToTrashEvent(syncAccountId, parameters);\n\n\t\tmoveFileEntryToTrashEvent.run();\n\t}","id":26861,"modified_method":"public static void deleteFile(long syncAccountId, SyncFile syncFile) {\n\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tsyncFile.getRepositoryId(), syncAccountId,\n\t\t\tsyncFile.getParentFolderId());\n\n\t\tif ((parentSyncFile == null) ||\n\t\t\t(parentSyncFile.getUiEvent() == SyncFile.UI_EVENT_DELETED_LOCAL)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tMap<String, Object> parameters = new HashMap<>();\n\n\t\tparameters.put(\"fileEntryId\", syncFile.getTypePK());\n\t\tparameters.put(\"syncFile\", syncFile);\n\n\t\tMoveFileEntryToTrashEvent moveFileEntryToTrashEvent =\n\t\t\tnew MoveFileEntryToTrashEvent(syncAccountId, parameters);\n\n\t\tmoveFileEntryToTrashEvent.run();\n\t}","commit_id":"4b1258aebc1bf08d785744d98ec22852cdbebd02","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteFolder(long syncAccountId, SyncFile syncFile) {\n\t\tMap<String, Object> parameters = new HashMap<>();\n\n\t\tparameters.put(\"folderId\", syncFile.getTypePK());\n\t\tparameters.put(\"syncFile\", syncFile);\n\n\t\tMoveFolderToTrashEvent moveFolderToTrashEvent =\n\t\t\tnew MoveFolderToTrashEvent(syncAccountId, parameters);\n\n\t\tmoveFolderToTrashEvent.run();\n\t}","id":26862,"modified_method":"public static void deleteFolder(long syncAccountId, SyncFile syncFile) {\n\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tsyncFile.getRepositoryId(), syncAccountId,\n\t\t\tsyncFile.getParentFolderId());\n\n\t\tif ((parentSyncFile == null) ||\n\t\t\t(parentSyncFile.getUiEvent() == SyncFile.UI_EVENT_DELETED_LOCAL)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tMap<String, Object> parameters = new HashMap<>();\n\n\t\tparameters.put(\"folderId\", syncFile.getTypePK());\n\t\tparameters.put(\"syncFile\", syncFile);\n\n\t\tMoveFolderToTrashEvent moveFolderToTrashEvent =\n\t\t\tnew MoveFolderToTrashEvent(syncAccountId, parameters);\n\n\t\tmoveFolderToTrashEvent.run();\n\t}","commit_id":"4b1258aebc1bf08d785744d98ec22852cdbebd02","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<SyncFile> findByF_L(String filePathName, long localSyncTime)\n\t\tthrows SQLException {\n\n\t\tQueryBuilder<SyncFile, Long> queryBuilder = queryBuilder();\n\n\t\tWhere<SyncFile, Long> where = queryBuilder.where();\n\n\t\tfilePathName = StringUtils.replace(filePathName, \"\\\\\", \"\\\\\\\\\");\n\n\t\tFileSystem fileSystem = FileSystems.getDefault();\n\n\t\twhere.like(\n\t\t\t\"filePathName\",\n\t\t\tnew SelectArg(filePathName + fileSystem.getSeparator() + \"%\"));\n\t\twhere.lt(\"localSyncTime\", localSyncTime);\n\t\twhere.or(\n\t\t\twhere.eq(\"state\", SyncFile.STATE_SYNCED),\n\t\t\twhere.eq(\"uiEvent\", SyncFile.UI_EVENT_UPLOADING));\n\t\twhere.ne(\"type\", SyncFile.TYPE_SYSTEM);\n\n\t\twhere.and(4);\n\n\t\treturn query(queryBuilder.prepare());\n\t}","id":26863,"modified_method":"public List<SyncFile> findByF_L(String filePathName, long localSyncTime)\n\t\tthrows SQLException {\n\n\t\tQueryBuilder<SyncFile, Long> queryBuilder = queryBuilder();\n\n\t\tWhere<SyncFile, Long> where = queryBuilder.where();\n\n\t\tfilePathName = StringUtils.replace(filePathName, \"\\\\\", \"\\\\\\\\\");\n\n\t\tFileSystem fileSystem = FileSystems.getDefault();\n\n\t\twhere.like(\n\t\t\t\"filePathName\",\n\t\t\tnew SelectArg(filePathName + fileSystem.getSeparator() + \"%\"));\n\t\twhere.lt(\"localSyncTime\", localSyncTime);\n\t\twhere.or(\n\t\t\twhere.eq(\"state\", SyncFile.STATE_SYNCED),\n\t\t\twhere.eq(\"uiEvent\", SyncFile.UI_EVENT_DELETED_LOCAL),\n\t\t\twhere.eq(\"uiEvent\", SyncFile.UI_EVENT_UPLOADING));\n\t\twhere.ne(\"type\", SyncFile.TYPE_SYSTEM);\n\n\t\twhere.and(4);\n\n\t\treturn query(queryBuilder.prepare());\n\t}","commit_id":"4b1258aebc1bf08d785744d98ec22852cdbebd02","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processWatchEvent(String eventType, Path filePath)\n\t\tthrows IOException {\n\n\t\tif (!OSDetector.isLinux() &&\n\t\t\tfilePath.startsWith(_baseFilePath.resolve(\".data\"))) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (eventType.equals(SyncWatchEvent.EVENT_TYPE_CREATE)) {\n\t\t\tif (isIgnoredFilePath(filePath)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taddCreatedFilePathName(filePath.toString());\n\n\t\t\tif (_downloadedFilePathNames.remove(filePath.toString())) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfireWatchEventListener(eventType, filePath);\n\n\t\t\tif (Files.isDirectory(filePath)) {\n\t\t\t\twalkFileTree(filePath);\n\t\t\t}\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_DELETE)) {\n\t\t\tif (Files.exists(filePath)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprocessMissingFilePath(filePath);\n\n\t\t\tif (Files.notExists(filePath.getParent())) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfireWatchEventListener(SyncWatchEvent.EVENT_TYPE_DELETE, filePath);\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_MODIFY)) {\n\t\t\tif (_downloadedFilePathNames.remove(filePath.toString()) ||\n\t\t\t\t(removeCreatedFilePathName(filePath.toString()) &&\n\t\t\t\t !FileUtil.isValidChecksum(filePath)) ||\n\t\t\t\tFiles.notExists(filePath) || Files.isDirectory(filePath)) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfireWatchEventListener(SyncWatchEvent.EVENT_TYPE_MODIFY, filePath);\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_RENAME_FROM)) {\n\t\t\tfireWatchEventListener(\n\t\t\t\tSyncWatchEvent.EVENT_TYPE_RENAME_FROM, filePath);\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_RENAME_TO)) {\n\t\t\tif (isIgnoredFilePath(filePath)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfireWatchEventListener(\n\t\t\t\tSyncWatchEvent.EVENT_TYPE_RENAME_TO, filePath);\n\t\t}\n\t}","id":26864,"modified_method":"protected void processWatchEvent(String eventType, Path filePath)\n\t\tthrows IOException {\n\n\t\tif (!OSDetector.isLinux() &&\n\t\t\tfilePath.startsWith(_baseFilePath.resolve(\".data\"))) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (eventType.equals(SyncWatchEvent.EVENT_TYPE_CREATE)) {\n\t\t\tif (isIgnoredFilePath(filePath)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taddCreatedFilePathName(filePath.toString());\n\n\t\t\tif (_downloadedFilePathNames.remove(filePath.toString())) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfireWatchEventListener(eventType, filePath);\n\n\t\t\tif (Files.isDirectory(filePath)) {\n\t\t\t\twalkFileTree(filePath);\n\t\t\t}\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_DELETE)) {\n\t\t\tif (Files.exists(filePath)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprocessMissingFilePath(filePath);\n\n\t\t\tif (Files.notExists(filePath.getParent())) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfireWatchEventListener(SyncWatchEvent.EVENT_TYPE_DELETE, filePath);\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_MODIFY)) {\n\t\t\tif (_downloadedFilePathNames.remove(filePath.toString()) ||\n\t\t\t\t(removeCreatedFilePathName(filePath.toString()) &&\n\t\t\t\t !FileUtil.isValidChecksum(filePath)) ||\n\t\t\t\tFiles.notExists(filePath) || Files.isDirectory(filePath)) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfireWatchEventListener(SyncWatchEvent.EVENT_TYPE_MODIFY, filePath);\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_RENAME_FROM)) {\n\t\t\tfireWatchEventListener(\n\t\t\t\tSyncWatchEvent.EVENT_TYPE_RENAME_FROM, filePath);\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_RENAME_TO)) {\n\t\t\tif (_downloadedFilePathNames.remove(filePath.toString()) ||\n\t\t\t\tisIgnoredFilePath(filePath)) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfireWatchEventListener(\n\t\t\t\tSyncWatchEvent.EVENT_TYPE_RENAME_TO, filePath);\n\t\t}\n\t}","commit_id":"4b1258aebc1bf08d785744d98ec22852cdbebd02","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * Make a multi-region table.  Presumption is that table already exists and\n   * that there is only one regionserver. Makes it multi-region by filling with\n   * data and provoking splits. Asserts parent region is cleaned up after its\n   * daughter splits release all references.\n   * @param conf\n   * @param cluster\n   * @param fs\n   * @param tableName\n   * @param columnName\n   * @throws IOException\n   */\n  @SuppressWarnings(\"null\")\n  public static void makeMultiRegionTable(HBaseConfiguration conf,\n      MiniHBaseCluster cluster, FileSystem fs, String tableName,\n      String columnName) throws IOException {  \n    final int retries = 10; \n    final long waitTime = 20L * 1000L;\n    \n    // This size should make it so we always split using the addContent\n    // below.  After adding all data, the first region is 1.3M. Should\n    // set max filesize to be <= 1M.\n    assertTrue(conf.getLong(\"hbase.hregion.max.filesize\",\n      HConstants.DEFAULT_MAX_FILE_SIZE) <= 1024 * 1024);\n\n    assertNotNull(fs);\n    Path d = fs.makeQualified(new Path(conf.get(HConstants.HBASE_DIR)));\n\n    // Get connection on the meta table and get count of rows.\n    HTable meta = new HTable(conf, HConstants.META_TABLE_NAME);\n    int count = count(meta, tableName);\n    HTable t = new HTable(conf, new Text(tableName));\n    // Get the parent region here now.\n    HRegionInfo parent =\n      t.getRegionLocation(HConstants.EMPTY_START_ROW).getRegionInfo();\n    LOG.info(\"Parent region \" + parent.toString());\n    Path parentDir = HRegion.getRegionDir(new Path(d, tableName),\n      parent.getEncodedName());\n    assertTrue(fs.exists(parentDir));\n    // Now add content.\n    addContent(new HTableIncommon(t), columnName);\n    LOG.info(\"Finished content loading\");\n    \n    // All is running in the one JVM so I should be able to get the single\n    // region instance and bring on a split. Presumption is that there is only\n    // one regionserver.   Of not, the split may already have happened by the\n    // time we got here.  If so, then the region found when we go searching\n    // with EMPTY_START_ROW will be one of the unsplittable daughters.\n    HRegionInfo hri = null;\n    HRegion r = null;\n    for (int i = 0; i < 30; i++) {\n      hri = t.getRegionLocation(HConstants.EMPTY_START_ROW).getRegionInfo();\n      LOG.info(\"Region location: \" + hri);\n      r = cluster.getRegionThreads().get(0).getRegionServer().\n        onlineRegions.get(hri.getRegionName());\n      if (r != null) {\n        break;\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.warn(\"Waiting on region to come online\", e);\n      }\n    }\n\n    // Flush the cache\n    cluster.getRegionThreads().get(0).getRegionServer().getCacheFlushListener().\n      flushRequested(r);\n\n    // Now, wait until split makes it into the meta table.\n    int oldCount = count;\n    for (int i = 0; i < retries;  i++) {\n      count = count(meta, tableName);\n      if (count > oldCount) {\n        break;\n      }\n      try {\n        Thread.sleep(waitTime);\n      } catch (InterruptedException e) {\n        // continue\n      }\n    }\n    if (count <= oldCount) {\n      throw new IOException(\"Failed waiting on splits to show up\");\n    }\n    \n    // Get info on the parent from the meta table.  Pass in 'hri'. Its the\n    // region we have been dealing with up to this. Its the parent of the\n    // region split.\n    Map<Text, byte []> data = getSplitParentInfo(meta, parent);\n    if (data == null) {\n      // We changed stuff so daughters get cleaned up much faster now.  Can\n      // run so fast, parent has been deleted by time we get to here.\n    } else {\n      parent  = Writables.getHRegionInfoOrNull(data.get(HConstants.COL_REGIONINFO));\n      LOG.info(\"Found parent region: \" + parent);\n      assertTrue(parent.isOffline());\n      assertTrue(parent.isSplit());\n      HRegionInfo splitA =\n        Writables.getHRegionInfoOrNull(data.get(HConstants.COL_SPLITA));\n      HRegionInfo splitB =\n        Writables.getHRegionInfoOrNull(data.get(HConstants.COL_SPLITB));\n      assertTrue(fs.exists(parentDir));\n      LOG.info(\"Split happened. Parent is \" + parent.getRegionName());\n\n      // Recalibrate will cause us to wait on new regions' deployment\n      recalibrate(t, new Text(columnName), retries, waitTime);\n\n      if (splitA == null) {\n        LOG.info(\"splitA was already null. Assuming it was previously compacted.\");\n      } else {\n        LOG.info(\"Daughter splitA: \" + splitA.getRegionName());\n        // Compact a region at a time so we can test case where one region has\n        // no references but the other still has some\n        compact(cluster, splitA);\n        \n        // Wait till the parent only has reference to remaining split, one that\n        // still has references.\n        while (true) {\n          data = getSplitParentInfo(meta, parent);\n          if (data == null || data.size() == 3) {\n            try {\n              Thread.sleep(waitTime);\n            } catch (InterruptedException e) {\n              // continue\n            }\n            continue;\n          }\n          break;\n        }\n        LOG.info(\"Parent split info returned \" + data.keySet().toString());\n      }\n\n      if (splitB == null) {\n        LOG.info(\"splitB was already null. Assuming it was previously compacted.\");\n      } else {\n        LOG.info(\"Daughter splitB: \" + splitA.getRegionName());\n\n        // Call second split.\n        compact(cluster, splitB);\n      }\n      // Now wait until parent disappears.    \n      LOG.info(\"Waiting on parent \" + parent.getRegionName() + \" to disappear\");\n      for (int i = 0; i < retries; i++) {\n        if (getSplitParentInfo(meta, parent) == null) {\n          break;\n        }\n        \n        try {\n          Thread.sleep(waitTime);\n        } catch (InterruptedException e) {\n          // continue\n        }\n      }\n      assertNull(getSplitParentInfo(meta, parent));\n    }\n\n    // Assert cleaned up.\n    \n    for (int i = 0; i < retries; i++) {\n      if (!fs.exists(parentDir)) {\n        break;\n      }\n      try {\n        Thread.sleep(waitTime);\n      } catch (InterruptedException e) {\n        // continue\n      }\n    }\n    assertFalse(fs.exists(parentDir));\n  }","id":26865,"modified_method":"/**\n   * Make a multi-region table.  Presumption is that table already exists and\n   * that there is only one regionserver. Makes it multi-region by filling with\n   * data and provoking splits. Asserts parent region is cleaned up after its\n   * daughter splits release all references.\n   * @param conf\n   * @param cluster\n   * @param fs\n   * @param tableName\n   * @param columnName\n   * @throws IOException\n   */\n  @SuppressWarnings(\"null\")\n  public static void makeMultiRegionTable(HBaseConfiguration conf,\n      MiniHBaseCluster cluster, FileSystem fs, String tableName,\n      String columnName) throws IOException {  \n    final int retries = 10; \n    final long waitTime = 20L * 1000L;\n    \n    // This size should make it so we always split using the addContent\n    // below.  After adding all data, the first region is 1.3M. Should\n    // set max filesize to be <= 1M.\n    assertTrue(conf.getLong(\"hbase.hregion.max.filesize\",\n      HConstants.DEFAULT_MAX_FILE_SIZE) <= 1024 * 1024);\n\n    assertNotNull(fs);\n    Path d = fs.makeQualified(new Path(conf.get(HConstants.HBASE_DIR)));\n\n    // Get connection on the meta table and get count of rows.\n    HTable meta = new HTable(conf, HConstants.META_TABLE_NAME);\n    int count = count(meta, tableName);\n    HTable t = new HTable(conf, new Text(tableName));\n    // Get the parent region here now.\n    HRegionInfo parent =\n      t.getRegionLocation(HConstants.EMPTY_START_ROW).getRegionInfo();\n    LOG.info(\"Parent region \" + parent.toString());\n    Path parentDir = HRegion.getRegionDir(new Path(d, tableName),\n      parent.getEncodedName());\n    assertTrue(fs.exists(parentDir));\n    // Now add content.\n    addContent(new HTableIncommon(t), columnName);\n    LOG.info(\"Finished content loading\");\n    \n    // All is running in the one JVM so I should be able to get the single\n    // region instance and bring on a split. Presumption is that there is only\n    // one regionserver.   Of not, the split may already have happened by the\n    // time we got here.  If so, then the region found when we go searching\n    // with EMPTY_START_ROW will be one of the unsplittable daughters.\n    HRegionInfo hri = null;\n    HRegion r = null;\n    HRegionServer server = cluster.getRegionThreads().get(0).getRegionServer(); \n    for (int i = 0; i < 30; i++) {\n      try {\n        hri = t.getRegionLocation(HConstants.EMPTY_START_ROW).getRegionInfo();\n      } catch (IOException e) {\n        e = RemoteExceptionHandler.checkIOException(e);\n        e.printStackTrace();\n        continue;\n      }\n      LOG.info(\"Region location: \" + hri);\n      r = server.onlineRegions.get(hri.getRegionName());\n      if (r != null) {\n        break;\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.warn(\"Waiting on region to come online\", e);\n      }\n    }\n    assertNotNull(r);\n\n    // Flush the cache\n    server.getCacheFlushListener().flushRequested(r);\n\n    // Now, wait until split makes it into the meta table.\n    int oldCount = count;\n    for (int i = 0; i < retries;  i++) {\n      count = count(meta, tableName);\n      if (count > oldCount) {\n        break;\n      }\n      try {\n        Thread.sleep(waitTime);\n      } catch (InterruptedException e) {\n        // continue\n      }\n    }\n    if (count <= oldCount) {\n      throw new IOException(\"Failed waiting on splits to show up\");\n    }\n    \n    // Get info on the parent from the meta table.  Pass in 'hri'. Its the\n    // region we have been dealing with up to this. Its the parent of the\n    // region split.\n    Map<Text, byte []> data = getSplitParentInfo(meta, parent);\n    if (data == null) {\n      // We changed stuff so daughters get cleaned up much faster now.  Can\n      // run so fast, parent has been deleted by time we get to here.\n    } else {\n      parent  = Writables.getHRegionInfoOrNull(data.get(HConstants.COL_REGIONINFO));\n      LOG.info(\"Found parent region: \" + parent);\n      assertTrue(parent.isOffline());\n      assertTrue(parent.isSplit());\n      HRegionInfo splitA =\n        Writables.getHRegionInfoOrNull(data.get(HConstants.COL_SPLITA));\n      HRegionInfo splitB =\n        Writables.getHRegionInfoOrNull(data.get(HConstants.COL_SPLITB));\n      assertTrue(fs.exists(parentDir));\n      LOG.info(\"Split happened. Parent is \" + parent.getRegionName());\n\n      // Recalibrate will cause us to wait on new regions' deployment\n      recalibrate(t, new Text(columnName), retries, waitTime);\n\n      if (splitA == null) {\n        LOG.info(\"splitA was already null. Assuming it was previously compacted.\");\n      } else {\n        LOG.info(\"Daughter splitA: \" + splitA.getRegionName());\n        // Compact a region at a time so we can test case where one region has\n        // no references but the other still has some\n        compact(cluster, splitA);\n        \n        // Wait till the parent only has reference to remaining split, one that\n        // still has references.\n        while (true) {\n          data = getSplitParentInfo(meta, parent);\n          if (data != null && data.size() == 3) {\n            LOG.info(\"Waiting for splitA to release reference to parent\");\n            try {\n              Thread.sleep(waitTime);\n            } catch (InterruptedException e) {\n              // continue\n            }\n            continue;\n          }\n          break;\n        }\n        if (data != null) {\n          LOG.info(\"Parent split info returned \" + data.keySet().toString());\n        }\n      }\n\n      if (splitB == null) {\n        LOG.info(\"splitB was already null. Assuming it was previously compacted.\");\n      } else {\n        LOG.info(\"Daughter splitB: \" + splitA.getRegionName());\n\n        // Call second split.\n        compact(cluster, splitB);\n      }\n      // Now wait until parent disappears.    \n      LOG.info(\"Waiting on parent \" + parent.getRegionName() + \" to disappear\");\n      for (int i = 0; i < retries; i++) {\n        if (getSplitParentInfo(meta, parent) == null) {\n          break;\n        }\n        \n        try {\n          Thread.sleep(waitTime);\n        } catch (InterruptedException e) {\n          // continue\n        }\n      }\n      assertNull(getSplitParentInfo(meta, parent));\n    }\n\n    // Assert cleaned up.\n    \n    for (int i = 0; i < retries; i++) {\n      if (!fs.exists(parentDir)) {\n        LOG.info(\"Parent directory was deleted. tries=\" + i);\n        break;\n      }\n      LOG.info(\"Waiting for parent directory to be deleted. tries=\" + i);\n      try {\n        Thread.sleep(waitTime);\n      } catch (InterruptedException e) {\n        // continue\n      }\n    }\n    assertFalse(fs.exists(parentDir));\n  }","commit_id":"e6c687d1593377a8b66b0a2ba4284ebdc8658978","url":"https://github.com/apache/hbase"},{"original_method":"private static Map<Text, byte []> getSplitParentInfo(final HTable t,\n      final HRegionInfo parent)\n  throws IOException {  \n    HScannerInterface s = t.obtainScanner(HConstants.COLUMN_FAMILY_ARRAY,\n        HConstants.EMPTY_START_ROW, System.currentTimeMillis(), null);\n    try {\n      HStoreKey curKey = new HStoreKey();\n      TreeMap<Text, byte []> curVals = new TreeMap<Text, byte []>();\n      while(s.next(curKey, curVals)) {\n        HRegionInfo hri = Writables.\n          getHRegionInfoOrNull(curVals.get(HConstants.COL_REGIONINFO));\n        if (hri == null) {\n          continue;\n        }\n        // Make sure I get the parent.\n        if (hri.getRegionName().toString().\n            equals(parent.getRegionName().toString()) &&\n              hri.getRegionId() == parent.getRegionId()) {\n          return curVals;\n        }\n      }\n      return null;\n    } finally {\n      s.close();\n    }   \n  }","id":26866,"modified_method":"private static Map<Text, byte []> getSplitParentInfo(final HTable t,\n      final HRegionInfo parent)\n  throws IOException {  \n    HScannerInterface s = t.obtainScanner(HConstants.COLUMN_FAMILY_ARRAY,\n        HConstants.EMPTY_START_ROW, System.currentTimeMillis(), null);\n    try {\n      HStoreKey curKey = new HStoreKey();\n      TreeMap<Text, byte []> curVals = new TreeMap<Text, byte []>();\n      while(s.next(curKey, curVals)) {\n        HRegionInfo hri = Writables.\n          getHRegionInfoOrNull(curVals.get(HConstants.COL_REGIONINFO));\n        if (hri == null) {\n          continue;\n        }\n        // Make sure I get the parent.\n        if (hri.getRegionName().equals(parent.getRegionName()) &&\n              hri.getRegionId() == parent.getRegionId()) {\n          return curVals;\n        }\n      }\n      return null;\n    } finally {\n      s.close();\n    }   \n  }","commit_id":"e6c687d1593377a8b66b0a2ba4284ebdc8658978","url":"https://github.com/apache/hbase"},{"original_method":"protected static void compact(final MiniHBaseCluster cluster,\n      final HRegionInfo r)\n  throws IOException {\n    if (r == null) {\n      LOG.debug(\"Passed region is null\");\n      return;\n    }\n    LOG.info(\"Starting compaction\");\n    for (LocalHBaseCluster.RegionServerThread thread:\n        cluster.getRegionThreads()) {\n      SortedMap<Text, HRegion> regions = thread.getRegionServer().onlineRegions;\n      \n      // Retry if ConcurrentModification... alternative of sync'ing is not\n      // worth it for sake of unit test.\n      for (int i = 0; i < 10; i++) {\n        try {\n          for (HRegion online: regions.values()) {\n            if (online.getRegionName().toString().\n                equals(r.getRegionName().toString())) {\n              online.compactStores();\n            }\n          }\n          break;\n        } catch (ConcurrentModificationException e) {\n          LOG.warn(\"Retrying because ...\" + e.toString() + \" -- one or \" +\n          \"two should be fine\");\n          continue;\n        }\n      }\n    }\n  }","id":26867,"modified_method":"protected static void compact(final MiniHBaseCluster cluster,\n      final HRegionInfo r) throws IOException {\n    if (r == null) {\n      LOG.debug(\"Passed region is null\");\n      return;\n    }\n    LOG.info(\"Starting compaction\");\n    for (LocalHBaseCluster.RegionServerThread thread:\n        cluster.getRegionThreads()) {\n      SortedMap<Text, HRegion> regions = thread.getRegionServer().onlineRegions;\n      \n      // Retry if ConcurrentModification... alternative of sync'ing is not\n      // worth it for sake of unit test.\n      for (int i = 0; i < 10; i++) {\n        try {\n          for (HRegion online: regions.values()) {\n            if (online.getRegionName().equals(r.getRegionName())) {\n              online.compactStores();\n            }\n          }\n          break;\n        } catch (ConcurrentModificationException e) {\n          LOG.warn(\"Retrying because ...\" + e.toString() + \" -- one or \" +\n          \"two should be fine\");\n          continue;\n        }\n      }\n    }\n  }","commit_id":"e6c687d1593377a8b66b0a2ba4284ebdc8658978","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Test HBase map/reduce\n   * \n   * @throws IOException\n   */\n  @SuppressWarnings(\"static-access\")\n  public void testTableIndex() throws IOException {\n    boolean printResults = false;\n    if (printResults) {\n      LOG.info(\"Print table contents before map/reduce\");\n    }\n    scanTable(printResults);\n\n    @SuppressWarnings(\"deprecation\")\n    MiniMRCluster mrCluster = new MiniMRCluster(2, fs.getUri().toString(), 1);\n\n    // set configuration parameter for index build\n    conf.set(\"hbase.index.conf\", createIndexConfContent());\n\n    try {\n      JobConf jobConf = new JobConf(conf, TestTableIndex.class);\n      jobConf.setJobName(\"index column contents\");\n      jobConf.setNumMapTasks(2);\n      // number of indexes to partition into\n      jobConf.setNumReduceTasks(1);\n\n      // use identity map (a waste, but just as an example)\n      IdentityTableMap.initJob(TABLE_NAME, INPUT_COLUMN,\n          IdentityTableMap.class, jobConf);\n\n      // use IndexTableReduce to build a Lucene index\n      jobConf.setReducerClass(IndexTableReduce.class);\n      jobConf.setOutputPath(new Path(INDEX_DIR));\n      jobConf.setOutputFormat(IndexOutputFormat.class);\n\n      JobClient.runJob(jobConf);\n\n    } finally {\n      mrCluster.shutdown();\n    }\n\n    if (printResults) {\n      LOG.info(\"Print table contents after map/reduce\");\n    }\n    scanTable(printResults);\n\n    // verify index results\n    verify();\n  }","id":26868,"modified_method":"/**\n   * Test HBase map/reduce\n   * \n   * @throws IOException\n   */\n  @SuppressWarnings(\"static-access\")\n  public void testTableIndex() throws IOException {\n    boolean printResults = false;\n    if (printResults) {\n      LOG.info(\"Print table contents before map/reduce\");\n    }\n    scanTable(printResults);\n\n    MiniMRCluster mrCluster = new MiniMRCluster(2, fs.getUri().toString(), 1);\n\n    // set configuration parameter for index build\n    conf.set(\"hbase.index.conf\", createIndexConfContent());\n\n    try {\n      JobConf jobConf = new JobConf(conf, TestTableIndex.class);\n      jobConf.setJobName(\"index column contents\");\n      jobConf.setNumMapTasks(2);\n      // number of indexes to partition into\n      jobConf.setNumReduceTasks(1);\n\n      // use identity map (a waste, but just as an example)\n      IdentityTableMap.initJob(TABLE_NAME, INPUT_COLUMN,\n          IdentityTableMap.class, jobConf);\n\n      // use IndexTableReduce to build a Lucene index\n      jobConf.setReducerClass(IndexTableReduce.class);\n      jobConf.setOutputPath(new Path(INDEX_DIR));\n      jobConf.setOutputFormat(IndexOutputFormat.class);\n\n      JobClient.runJob(jobConf);\n\n    } finally {\n      mrCluster.shutdown();\n    }\n\n    if (printResults) {\n      LOG.info(\"Print table contents after map/reduce\");\n    }\n    scanTable(printResults);\n\n    // verify index results\n    verify();\n  }","commit_id":"e6c687d1593377a8b66b0a2ba4284ebdc8658978","url":"https://github.com/apache/hbase"},{"original_method":"private void verify() throws IOException {\n    // Force a cache flush for every online region to ensure that when the\n    // scanner takes its snapshot, all the updates have made it into the cache.\n    for (HRegion r : hCluster.getRegionThreads().get(0).getRegionServer().\n        getOnlineRegions().values()) {\n      HRegionIncommon region = new HRegionIncommon(r);\n      region.flushcache();\n    }\n\n    Path localDir = new Path(getUnitTestdir(getName()), \"index_\" +\n      Integer.toString(new Random().nextInt()));\n    this.fs.copyToLocalFile(new Path(INDEX_DIR), localDir);\n    FileSystem localfs = FileSystem.getLocal(conf);\n    Path [] indexDirs = localfs.listPaths(new Path [] {localDir});\n    Searcher searcher = null;\n    HScannerInterface scanner = null;\n    try {\n      if (indexDirs.length == 1) {\n        searcher = new IndexSearcher((new File(indexDirs[0].\n          toUri())).getAbsolutePath());\n      } else if (indexDirs.length > 1) {\n        Searchable[] searchers = new Searchable[indexDirs.length];\n        for (int i = 0; i < indexDirs.length; i++) {\n          searchers[i] = new IndexSearcher((new File(indexDirs[i].\n            toUri()).getAbsolutePath()));\n        }\n        searcher = new MultiSearcher(searchers);\n      } else {\n        throw new IOException(\"no index directory found\");\n      }\n\n      HTable table = new HTable(conf, new Text(TABLE_NAME));\n      scanner = table.obtainScanner(columns, HConstants.EMPTY_START_ROW);\n\n      HStoreKey key = new HStoreKey();\n      TreeMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n\n      IndexConfiguration indexConf = new IndexConfiguration();\n      String content = conf.get(\"hbase.index.conf\");\n      if (content != null) {\n        indexConf.addFromXML(content);\n      }\n      String rowkeyName = indexConf.getRowkeyName();\n\n      int count = 0;\n      while (scanner.next(key, results)) {\n        String value = key.getRow().toString();\n        LOG.debug(\"Scanned over \" + key.getRow());\n        Term term = new Term(rowkeyName, value);\n        int hitCount = searcher.search(new TermQuery(term)).length();\n        assertEquals(\"check row \" + value, 1, hitCount);\n        count++;\n      }\n      LOG.debug(\"Searcher.maxDoc: \" + searcher.maxDoc());\n      LOG.debug(\"IndexReader.numDocs: \" + ((IndexSearcher)searcher).getIndexReader().numDocs());      \n      int maxDoc = ((IndexSearcher)searcher).getIndexReader().numDocs();\n      assertEquals(\"check number of rows\", maxDoc, count);\n    } finally {\n      if (null != searcher)\n        searcher.close();\n      if (null != scanner)\n        scanner.close();\n    }\n  }","id":26869,"modified_method":"private void verify() throws IOException {\n    // Force a cache flush for every online region to ensure that when the\n    // scanner takes its snapshot, all the updates have made it into the cache.\n    for (HRegion r : hCluster.getRegionThreads().get(0).getRegionServer().\n        getOnlineRegions().values()) {\n      HRegionIncommon region = new HRegionIncommon(r);\n      region.flushcache();\n    }\n\n    Path localDir = new Path(getUnitTestdir(getName()), \"index_\" +\n      Integer.toString(new Random().nextInt()));\n    this.fs.copyToLocalFile(new Path(INDEX_DIR), localDir);\n    FileSystem localfs = FileSystem.getLocal(conf);\n    FileStatus [] indexDirs = localfs.listStatus(localDir);\n    Searcher searcher = null;\n    HScannerInterface scanner = null;\n    try {\n      if (indexDirs.length == 1) {\n        searcher = new IndexSearcher((new File(indexDirs[0].getPath().\n          toUri())).getAbsolutePath());\n      } else if (indexDirs.length > 1) {\n        Searchable[] searchers = new Searchable[indexDirs.length];\n        for (int i = 0; i < indexDirs.length; i++) {\n          searchers[i] = new IndexSearcher((new File(indexDirs[i].getPath().\n            toUri()).getAbsolutePath()));\n        }\n        searcher = new MultiSearcher(searchers);\n      } else {\n        throw new IOException(\"no index directory found\");\n      }\n\n      HTable table = new HTable(conf, new Text(TABLE_NAME));\n      scanner = table.obtainScanner(columns, HConstants.EMPTY_START_ROW);\n\n      HStoreKey key = new HStoreKey();\n      TreeMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n\n      IndexConfiguration indexConf = new IndexConfiguration();\n      String content = conf.get(\"hbase.index.conf\");\n      if (content != null) {\n        indexConf.addFromXML(content);\n      }\n      String rowkeyName = indexConf.getRowkeyName();\n\n      int count = 0;\n      while (scanner.next(key, results)) {\n        String value = key.getRow().toString();\n        Term term = new Term(rowkeyName, value);\n        int hitCount = searcher.search(new TermQuery(term)).length();\n        assertEquals(\"check row \" + value, 1, hitCount);\n        count++;\n      }\n      LOG.debug(\"Searcher.maxDoc: \" + searcher.maxDoc());\n      LOG.debug(\"IndexReader.numDocs: \" + ((IndexSearcher)searcher).getIndexReader().numDocs());      \n      int maxDoc = ((IndexSearcher)searcher).getIndexReader().numDocs();\n      assertEquals(\"check number of rows\", maxDoc, count);\n    } finally {\n      if (null != searcher)\n        searcher.close();\n      if (null != scanner)\n        scanner.close();\n    }\n  }","commit_id":"e6c687d1593377a8b66b0a2ba4284ebdc8658978","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\n  @Override\n  public void setUp() throws Exception {\n    // Enable DEBUG-level MR logging.\n    Logger.getLogger(\"org.apache.hadoop.mapred\").setLevel(Level.DEBUG);\n    \n    // Make sure the cache gets flushed so we trigger a compaction(s) and\n    // hence splits.\n    conf.setInt(\"hbase.hregion.memcache.flush.size\", 1024 * 1024);\n    \n    // This size should make it so we always split using the addContent\n    // below. After adding all data, the first region is 1.3M\n    conf.setLong(\"hbase.hregion.max.filesize\", 1024 * 1024);\n\n    desc = new HTableDescriptor(TABLE_NAME);\n    desc.addFamily(new HColumnDescriptor(INPUT_COLUMN));\n    desc.addFamily(new HColumnDescriptor(OUTPUT_COLUMN));\n\n    dfsCluster = new MiniDFSCluster(conf, 1, true, (String[]) null);\n    // Set the hbase.rootdir to be the home directory in mini dfs.\n    this.conf.set(HConstants.HBASE_DIR,\n      this.dfsCluster.getFileSystem().getHomeDirectory().toString());\n\n    // Must call super.setUp after mini dfs cluster is started or else\n    // filesystem ends up being local\n    \n    super.setUp();\n\n    try {\n      dir = new Path(\"/hbase\");\n      fs.mkdirs(dir);\n\n      // Start up HBase cluster\n      hCluster = new MiniHBaseCluster(conf, 1, dfsCluster, true);\n\n      // Create a table.\n      HBaseAdmin admin = new HBaseAdmin(conf);\n      admin.createTable(desc);\n\n      // Populate a table into multiple regions\n      makeMultiRegionTable(conf, hCluster, this.fs, TABLE_NAME, INPUT_COLUMN);\n\n      // Verify table indeed has multiple regions\n      HTable table = new HTable(conf, new Text(TABLE_NAME));\n      Text[] startKeys = table.getStartKeys();\n      assertTrue(startKeys.length > 1);\n    } catch (Exception e) {\n      StaticTestEnvironment.shutdownDfs(dfsCluster);\n      throw e;\n    }\n    LOG.debug(\"\\n\\n\\n\\n\\t\\t\\tSetup Complete\\n\\n\\n\\n\");\n  }","id":26870,"modified_method":"/** {@inheritDoc} */\n  @Override\n  public void setUp() throws Exception {\n    // Enable DEBUG-level MR logging.\n    Logger.getLogger(\"org.apache.hadoop.mapred\").setLevel(Level.DEBUG);\n    \n    // Make sure the cache gets flushed so we trigger a compaction(s) and\n    // hence splits.\n    conf.setInt(\"hbase.hregion.memcache.flush.size\", 1024 * 1024);\n    \n    // This size should make it so we always split using the addContent\n    // below. After adding all data, the first region is 1.3M\n    conf.setLong(\"hbase.hregion.max.filesize\", 1024 * 1024);\n\n    // Always compact if there is more than one store file.\n    conf.setInt(\"hbase.hstore.compactionThreshold\", 2);\n\n    desc = new HTableDescriptor(TABLE_NAME);\n    desc.addFamily(new HColumnDescriptor(INPUT_COLUMN));\n    desc.addFamily(new HColumnDescriptor(OUTPUT_COLUMN));\n\n    dfsCluster = new MiniDFSCluster(conf, 1, true, (String[]) null);\n    // Set the hbase.rootdir to be the home directory in mini dfs.\n    this.conf.set(HConstants.HBASE_DIR,\n      this.dfsCluster.getFileSystem().getHomeDirectory().toString());\n\n    // Must call super.setUp after mini dfs cluster is started or else\n    // filesystem ends up being local\n    \n    super.setUp();\n\n    try {\n      dir = new Path(\"/hbase\");\n      fs.mkdirs(dir);\n\n      // Start up HBase cluster\n      hCluster = new MiniHBaseCluster(conf, 1, dfsCluster, true);\n\n      // Create a table.\n      HBaseAdmin admin = new HBaseAdmin(conf);\n      admin.createTable(desc);\n\n      // Populate a table into multiple regions\n      makeMultiRegionTable(conf, hCluster, this.fs, TABLE_NAME, INPUT_COLUMN);\n\n      // Verify table indeed has multiple regions\n      HTable table = new HTable(conf, new Text(TABLE_NAME));\n      Text[] startKeys = table.getStartKeys();\n      assertTrue(startKeys.length > 1);\n    } catch (Exception e) {\n      StaticTestEnvironment.shutdownDfs(dfsCluster);\n      throw e;\n    }\n    LOG.debug(\"\\n\\n\\n\\n\\t\\t\\tSetup Complete\\n\\n\\n\\n\");\n  }","commit_id":"e6c687d1593377a8b66b0a2ba4284ebdc8658978","url":"https://github.com/apache/hbase"},{"original_method":"private void localTestSingleRegionTable() throws IOException {\n    HTableDescriptor desc = new HTableDescriptor(SINGLE_REGION_TABLE_NAME);\n    desc.addFamily(new HColumnDescriptor(INPUT_COLUMN));\n    desc.addFamily(new HColumnDescriptor(OUTPUT_COLUMN));\n    \n    // Create a table.\n    HBaseAdmin admin = new HBaseAdmin(this.conf);\n    admin.createTable(desc);\n\n    // insert some data into the test table\n    HTable table = new HTable(conf, new Text(SINGLE_REGION_TABLE_NAME));\n\n    for(int i = 0; i < values.length; i++) {\n      long lockid = table.startUpdate(new Text(\"row_\"\n          + String.format(\"%1$05d\", i)));\n\n      try {\n        table.put(lockid, TEXT_INPUT_COLUMN, values[i]);\n        table.commit(lockid, System.currentTimeMillis());\n        lockid = -1;\n      } finally {\n        if (lockid != -1)\n          table.abort(lockid);\n      }\n    }\n\n    LOG.info(\"Print table contents before map/reduce for \" +\n      SINGLE_REGION_TABLE_NAME);\n    scanTable(SINGLE_REGION_TABLE_NAME, true);\n\n    @SuppressWarnings(\"deprecation\")\n    MiniMRCluster mrCluster = new MiniMRCluster(2, fs.getUri().toString(), 1);\n\n    try {\n      JobConf jobConf = new JobConf(conf, TestTableMapReduce.class);\n      jobConf.setJobName(\"process column contents\");\n      jobConf.setNumMapTasks(1);\n      jobConf.setNumReduceTasks(1);\n\n      TableMap.initJob(SINGLE_REGION_TABLE_NAME, INPUT_COLUMN, \n          ProcessContentsMapper.class, jobConf);\n\n      TableReduce.initJob(SINGLE_REGION_TABLE_NAME,\n          IdentityTableReduce.class, jobConf);\n      LOG.info(\"Started \" + SINGLE_REGION_TABLE_NAME);\n      JobClient.runJob(jobConf);\n\n      LOG.info(\"Print table contents after map/reduce for \" +\n        SINGLE_REGION_TABLE_NAME);\n    scanTable(SINGLE_REGION_TABLE_NAME, true);\n\n    // verify map-reduce results\n    verify(SINGLE_REGION_TABLE_NAME);\n    } finally {\n      mrCluster.shutdown();\n    }\n  }","id":26871,"modified_method":"private void localTestSingleRegionTable() throws IOException {\n    HTableDescriptor desc = new HTableDescriptor(SINGLE_REGION_TABLE_NAME);\n    desc.addFamily(new HColumnDescriptor(INPUT_COLUMN));\n    desc.addFamily(new HColumnDescriptor(OUTPUT_COLUMN));\n    \n    // Create a table.\n    HBaseAdmin admin = new HBaseAdmin(this.conf);\n    admin.createTable(desc);\n\n    // insert some data into the test table\n    HTable table = new HTable(conf, new Text(SINGLE_REGION_TABLE_NAME));\n\n    for(int i = 0; i < values.length; i++) {\n      BatchUpdate b = new BatchUpdate(new Text(\"row_\" +\n          String.format(\"%1$05d\", i)));\n\n      b.put(TEXT_INPUT_COLUMN, values[i]);\n      table.commit(b);\n    }\n\n    LOG.info(\"Print table contents before map/reduce for \" +\n      SINGLE_REGION_TABLE_NAME);\n    scanTable(SINGLE_REGION_TABLE_NAME, true);\n\n    @SuppressWarnings(\"deprecation\")\n    MiniMRCluster mrCluster = new MiniMRCluster(2, fs.getUri().toString(), 1);\n\n    try {\n      JobConf jobConf = new JobConf(conf, TestTableMapReduce.class);\n      jobConf.setJobName(\"process column contents\");\n      jobConf.setNumMapTasks(1);\n      jobConf.setNumReduceTasks(1);\n\n      TableMap.initJob(SINGLE_REGION_TABLE_NAME, INPUT_COLUMN, \n          ProcessContentsMapper.class, jobConf);\n\n      TableReduce.initJob(SINGLE_REGION_TABLE_NAME,\n          IdentityTableReduce.class, jobConf);\n      LOG.info(\"Started \" + SINGLE_REGION_TABLE_NAME);\n      JobClient.runJob(jobConf);\n\n      LOG.info(\"Print table contents after map/reduce for \" +\n        SINGLE_REGION_TABLE_NAME);\n    scanTable(SINGLE_REGION_TABLE_NAME, true);\n\n    // verify map-reduce results\n    verify(SINGLE_REGION_TABLE_NAME);\n    } finally {\n      mrCluster.shutdown();\n    }\n  }","commit_id":"e6c687d1593377a8b66b0a2ba4284ebdc8658978","url":"https://github.com/apache/hbase"},{"original_method":"/** constructor */\n  public TestTableMapReduce() {\n    super();\n    \n    // Make sure the cache gets flushed so we trigger a compaction(s) and\n    // hence splits.\n    conf.setInt(\"hbase.hregion.memcache.flush.size\", 1024 * 1024);\n\n    // Always compact if there is more than one store file.\n    conf.setInt(\"hbase.hstore.compactionThreshold\", 2);\n\n    // This size should make it so we always split using the addContent\n    // below. After adding all data, the first region is 1.3M\n    conf.setLong(\"hbase.hregion.max.filesize\", 256 * 1024);\n\n    // Make lease timeout longer, lease checks less frequent\n    conf.setInt(\"hbase.master.lease.period\", 10 * 1000);\n    conf.setInt(\"hbase.master.lease.thread.wakefrequency\", 5 * 1000);\n    \n    // Set client pause to the original default\n    conf.setInt(\"hbase.client.pause\", 10 * 1000);\n  }","id":26872,"modified_method":"/** constructor */\n  public TestTableMapReduce() {\n    super();\n    \n    // Make sure the cache gets flushed so we trigger a compaction(s) and\n    // hence splits.\n    conf.setInt(\"hbase.hregion.memcache.flush.size\", 1024 * 1024);\n\n    // Always compact if there is more than one store file.\n    conf.setInt(\"hbase.hstore.compactionThreshold\", 2);\n\n    // This size should make it so we always split using the addContent\n    // below. After adding all data, the first region is 1.3M\n    conf.setLong(\"hbase.hregion.max.filesize\", 1024 * 1024);\n\n    // Make lease timeout longer, lease checks less frequent\n    conf.setInt(\"hbase.master.lease.period\", 10 * 1000);\n    conf.setInt(\"hbase.master.lease.thread.wakefrequency\", 5 * 1000);\n    \n    // Set client pause to the original default\n    conf.setInt(\"hbase.client.pause\", 10 * 1000);\n  }","commit_id":"e6c687d1593377a8b66b0a2ba4284ebdc8658978","url":"https://github.com/apache/hbase"},{"original_method":"public String getValue(String key, String def) {\n\t\tif (key == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tPreference preference = _preferences.get(key);\n\n\t\tString[] values = null;\n\n\t\tif (preference != null) {\n\t\t\tvalues = preference.getValues();\n\t\t}\n\n\t\tString value = null;\n\n\t\tif (Validator.isNotNull(values)) {\n\t\t\tvalue = _getActualValue(values[0]);\n\t\t}\n\n\t\tif (Validator.isNull(value)) {\n\t\t\tvalue = _getActualValue(def);\n\t\t}\n\n\t\treturn value;\n\t}","id":26873,"modified_method":"public String getValue(String key, String def) {\n\t\tif (key == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tPreference preference = _preferences.get(key);\n\n\t\tString[] values = null;\n\n\t\tif (preference != null) {\n\t\t\tvalues = preference.getValues();\n\t\t}\n\n\t\tif ((values != null) && (values.length > 0)) {\n\t\t\treturn _getActualValue(values[0]);\n\t\t}\n\t\telse {\n\t\t\treturn _getActualValue(def);\n\t\t}\n\t}","commit_id":"e377c703753744e37a2d9ff3e4ba7595bfcce321","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String[] getValues(String key, String[] def) {\n\t\tif (key == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tPreference preference = _preferences.get(key);\n\n\t\tString[] values = null;\n\t\tif (preference != null) {\n\t\t\tvalues = preference.getValues();\n\t\t}\n\n\t\tif (Validator.isNotNull(values)) {\n\t\t\treturn _getActualValues(values);\n\t\t}\n\t\telse {\n\t\t\treturn _getActualValues(def);\n\t\t}\n\t}","id":26874,"modified_method":"public String[] getValues(String key, String[] def) {\n\t\tif (key == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tPreference preference = _preferences.get(key);\n\n\t\tString[] values = null;\n\t\tif (preference != null) {\n\t\t\tvalues = preference.getValues();\n\t\t}\n\n\t\tif ((values != null) && (values.length > 0)) {\n\t\t\treturn _getActualValues(values);\n\t\t}\n\t\telse {\n\t\t\treturn _getActualValues(def);\n\t\t}\n\t}","commit_id":"e377c703753744e37a2d9ff3e4ba7595bfcce321","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String[] getValues(String key, String[] def) {\n\t\tif (key == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tPreference preference = _preferences.get(key);\n\n\t\tString[] values = null;\n\t\tif (preference != null) {\n\t\t\tvalues = preference.getValues();\n\t\t}\n\n\t\tif (values != null && values.length > 0) {\n\t\t\treturn _getActualValues(values);\n\t\t}\n\t\telse {\n\t\t\treturn _getActualValues(def);\n\t\t}\n\t}","id":26875,"modified_method":"public String[] getValues(String key, String[] def) {\n\t\tif (key == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tPreference preference = _preferences.get(key);\n\n\t\tString[] values = null;\n\t\tif (preference != null) {\n\t\t\tvalues = preference.getValues();\n\t\t}\n\n\t\tif (Validator.isNotNull(values)) {\n\t\t\treturn _getActualValues(values);\n\t\t}\n\t\telse {\n\t\t\treturn _getActualValues(def);\n\t\t}\n\t}","commit_id":"976d6a6bbace975d1e771a0e61f0fe21aea9394f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getValue(String key, String def) {\n\t\tif (key == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tPreference preference = _preferences.get(key);\n\n\t\tString[] values = null;\n\n\t\tif (preference != null) {\n\t\t\tvalues = preference.getValues();\n\t\t}\n\n\t\tif (values != null && values.length > 0) {\n\t\t\treturn _getActualValue(values[0]);\n\t\t}\n\t\telse {\n\t\t\treturn _getActualValue(def);\n\t\t}\n\t}","id":26876,"modified_method":"public String getValue(String key, String def) {\n\t\tif (key == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tPreference preference = _preferences.get(key);\n\n\t\tString[] values = null;\n\n\t\tif (preference != null) {\n\t\t\tvalues = preference.getValues();\n\t\t}\n\n\t\tString value = null;\n\n\t\tif (Validator.isNotNull(values)) {\n\t\t\tvalue = _getActualValue(values[0]);\n\t\t}\n\n\t\tif (Validator.isNull(value)) {\n\t\t\tvalue = _getActualValue(def);\n\t\t}\n\n\t\treturn value;\n\t}","commit_id":"976d6a6bbace975d1e771a0e61f0fe21aea9394f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private boolean isValidText_internal(String text) {\n    if (text != null && text.length() == 0) {\n      text = null;\n    }\n\n    if (myReadOnly) {\n      String propertyValue = getText();\n      return (text == null && (propertyValue == null || propertyValue.isEmpty())) || (text != null && text.equals(propertyValue));\n    }\n\n    if (myPropertyDeclaration != null) {\n      PropertySupport propertySupport = PropertySupport.getPropertySupport(myPropertyDeclaration);\n      return propertySupport.canSetValue(myNode, myPropertyName, text, myScope);\n    }\n    return true;\n  }","id":26877,"modified_method":"private boolean isValidText_internal(String text) {\n    if (text != null && text.length() == 0) {\n      text = null;\n    }\n\n    if (myReadOnly) {\n      String propertyValue = getText();\n      return (text == null && (propertyValue == null || propertyValue.isEmpty())) || (text != null && text.equals(propertyValue));\n    }\n\n    if (isValidPropertyDeclaration()) {\n      PropertySupport propertySupport = PropertySupport.getPropertySupport(myPropertyDeclaration.getNode());\n      return propertySupport.canSetValue(myNode, myPropertyName, text, myScope);\n    }\n    return true;\n  }","commit_id":"907d0c691bedb88ea4157a2398850183d9c2df74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PropertyAccessor(SNode node, String propertyName, boolean readOnly, boolean allowEmptyText, EditorContext editorContext) {\n    myNode = node;\n    myPropertyName = propertyName;\n    myReadOnly = readOnly || node.getModel().isNotEditable() || editorContext.getNodeEditorComponent().isReadOnly();\n    myAllowEmptyText = allowEmptyText;\n    myPropertyDeclaration = node.getPropertyDeclaration(propertyName);\n    myScope = editorContext.getScope();\n  }","id":26878,"modified_method":"public PropertyAccessor(SNode node, String propertyName, boolean readOnly, boolean allowEmptyText, EditorContext editorContext) {\n    myNode = node;\n    myPropertyName = propertyName;\n    myReadOnly = readOnly || node.getModel().isNotEditable() || editorContext.getNodeEditorComponent().isReadOnly();\n    myAllowEmptyText = allowEmptyText;\n    myPropertyDeclaration = new SNodePointer(node.getPropertyDeclaration(propertyName));\n    myScope = editorContext.getScope();\n  }","commit_id":"907d0c691bedb88ea4157a2398850183d9c2df74","url":"https://github.com/JetBrains/MPS"},{"original_method":"private String toInternal(String value) {\n    if (myPropertyDeclaration != null) {\n      PropertySupport propertySupport = PropertySupport.getPropertySupport(myPropertyDeclaration);\n      return propertySupport.toInternalValue(value);\n    }\n    return value;\n  }","id":26879,"modified_method":"private String toInternal(String value) {\n    if (isValidPropertyDeclaration()) {\n      PropertySupport propertySupport = PropertySupport.getPropertySupport(myPropertyDeclaration.getNode());\n      return propertySupport.toInternalValue(value);\n    }\n    return value;\n  }","commit_id":"907d0c691bedb88ea4157a2398850183d9c2df74","url":"https://github.com/JetBrains/MPS"},{"original_method":"private String fromInternal(String value) {\n    if (myPropertyDeclaration != null) {\n      PropertySupport propertySupport = PropertySupport.getPropertySupport(myPropertyDeclaration);\n      return propertySupport.fromInternalValue(value);\n    }\n    return value;\n  }","id":26880,"modified_method":"private String fromInternal(String value) {\n    if (isValidPropertyDeclaration()) {\n      PropertySupport propertySupport = PropertySupport.getPropertySupport(myPropertyDeclaration.getNode());\n      return propertySupport.fromInternalValue(value);\n    }\n    return value;\n  }","commit_id":"907d0c691bedb88ea4157a2398850183d9c2df74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PropertyAccessor(SNode node, String propertyName, boolean readOnly, boolean allowEmptyText, IOperationContext context) {\n    myNode = node;\n    myPropertyName = propertyName;\n    myReadOnly = readOnly || node.getModel().isNotEditable();\n    myAllowEmptyText = allowEmptyText;\n    myPropertyDeclaration = node.getPropertyDeclaration(propertyName);\n    myScope = context.getScope();\n  }","id":26881,"modified_method":"public PropertyAccessor(SNode node, String propertyName, boolean readOnly, boolean allowEmptyText, IOperationContext context) {\n    myNode = node;\n    myPropertyName = propertyName;\n    myReadOnly = readOnly || node.getModel().isNotEditable();\n    myAllowEmptyText = allowEmptyText;\n    myPropertyDeclaration = new SNodePointer(node.getPropertyDeclaration(propertyName));\n    myScope = context.getScope();\n  }","commit_id":"907d0c691bedb88ea4157a2398850183d9c2df74","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean isValidText_internal(String text) {\n    if (text != null && text.length() == 0) {\n      text = null;\n    }\n\n    if (myReadOnly) {\n      String propertyValue = getText();\n      return (text == null && (propertyValue == null || propertyValue.isEmpty())) || (text != null && text.equals(propertyValue));\n    }\n\n    if (myPropertyDeclaration != null) {\n      PropertySupport propertySupport = PropertySupport.getPropertySupport(myPropertyDeclaration);\n      return propertySupport.canSetValue(myNode, myPropertyName, text, myScope);\n    }\n    return true;\n  }","id":26882,"modified_method":"private boolean isValidText_internal(String text) {\n    if (text != null && text.length() == 0) {\n      text = null;\n    }\n\n    if (myReadOnly) {\n      String propertyValue = getText();\n      return (text == null && (propertyValue == null || propertyValue.isEmpty())) || (text != null && text.equals(propertyValue));\n    }\n\n    SNode node = myPropertyDeclaration.getNode();\n    if (node != null) {\n      PropertySupport propertySupport = PropertySupport.getPropertySupport(node);\n      return propertySupport.canSetValue(myNode, myPropertyName, text, myScope);\n    }\n    return true;\n  }","commit_id":"0412a878b693d6ff10759c8ebbf51a8d1e2c8525","url":"https://github.com/JetBrains/MPS"},{"original_method":"private String fromInternal(String value) {\n    if (myPropertyDeclaration != null) {\n      PropertySupport propertySupport = PropertySupport.getPropertySupport(myPropertyDeclaration);\n      return propertySupport.fromInternalValue(value);\n    }\n    return value;\n  }","id":26883,"modified_method":"private String fromInternal(String value) {\n    SNode node = myPropertyDeclaration.getNode();\n    if (node != null) {\n      PropertySupport propertySupport = PropertySupport.getPropertySupport(node);\n      return propertySupport.fromInternalValue(value);\n    }\n    return value;\n  }","commit_id":"0412a878b693d6ff10759c8ebbf51a8d1e2c8525","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PropertyAccessor(SNode node, String propertyName, boolean readOnly, boolean allowEmptyText, IOperationContext context) {\n    myNode = node;\n    myPropertyName = propertyName;\n    myReadOnly = readOnly || node.getModel().isNotEditable();\n    myAllowEmptyText = allowEmptyText;\n    myPropertyDeclaration = node.getPropertyDeclaration(propertyName);\n    myScope = context.getScope();\n  }","id":26884,"modified_method":"public PropertyAccessor(SNode node, String propertyName, boolean readOnly, boolean allowEmptyText, IOperationContext context) {\n    myNode = node;\n    myPropertyName = propertyName;\n    myReadOnly = readOnly || node.getModel().isNotEditable();\n    myAllowEmptyText = allowEmptyText;\n    myPropertyDeclaration = new SNodePointer(node.getPropertyDeclaration(propertyName));\n    myScope = context.getScope();\n  }","commit_id":"0412a878b693d6ff10759c8ebbf51a8d1e2c8525","url":"https://github.com/JetBrains/MPS"},{"original_method":"private String toInternal(String value) {\n    if (myPropertyDeclaration != null) {\n      PropertySupport propertySupport = PropertySupport.getPropertySupport(myPropertyDeclaration);\n      return propertySupport.toInternalValue(value);\n    }\n    return value;\n  }","id":26885,"modified_method":"private String toInternal(String value) {\n    SNode node = myPropertyDeclaration.getNode();\n    if (node != null) {\n      PropertySupport propertySupport = PropertySupport.getPropertySupport(node);\n      return propertySupport.toInternalValue(value);\n    }\n    return value;\n  }","commit_id":"0412a878b693d6ff10759c8ebbf51a8d1e2c8525","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PropertyAccessor(SNode node, String propertyName, boolean readOnly, boolean allowEmptyText, EditorContext editorContext) {\n    myNode = node;\n    myPropertyName = propertyName;\n    myReadOnly = readOnly || node.getModel().isNotEditable() || editorContext.getNodeEditorComponent().isReadOnly();\n    myAllowEmptyText = allowEmptyText;\n    myPropertyDeclaration = node.getPropertyDeclaration(propertyName);\n    myScope = editorContext.getScope();\n  }","id":26886,"modified_method":"public PropertyAccessor(SNode node, String propertyName, boolean readOnly, boolean allowEmptyText, EditorContext editorContext) {\n    myNode = node;\n    myPropertyName = propertyName;\n    myReadOnly = readOnly || node.getModel().isNotEditable() || editorContext.getNodeEditorComponent().isReadOnly();\n    myAllowEmptyText = allowEmptyText;\n    myPropertyDeclaration = new SNodePointer(node.getPropertyDeclaration(propertyName));\n    myScope = editorContext.getScope();\n  }","commit_id":"0412a878b693d6ff10759c8ebbf51a8d1e2c8525","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * <b>Callback<\/b> (called by RequestCorrelator or Transport).\n     * Adds a response to the response table. When all responses have been received,\n     * <code>execute()<\/code> returns.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void receiveResponse(Object response_value, Address sender, boolean is_exception) {\n        if(done)\n            return;\n        Rsp<T> rsp=requests.get(sender);\n        if(rsp == null)\n            return;\n\n        RspFilter rsp_filter=options.getRspFilter();\n        boolean responseReceived=false;\n\n        lock.lock();\n        try {\n            if(!rsp.wasReceived()) {\n                num_received++;\n                if((responseReceived=(rsp_filter == null) || rsp_filter.isAcceptable(response_value, sender))) {\n                    if(is_exception && response_value instanceof Throwable)\n                        rsp.setException((Throwable)response_value);\n                    else\n                        rsp.setValue((T)response_value);\n                }\n                rsp.setReceived(responseReceived);\n            }\n\n            if(responseReceived)\n                num_valid++;\n            done=responsesComplete() || (rsp_filter != null && !rsp_filter.needMoreResponses());\n            if(responseReceived || done)\n                completed.signalAll(); // wakes up execute()\n            if(done && corr != null)\n                corr.done(req_id);\n        }\n        finally {\n            lock.unlock();\n        }\n        if(responseReceived || done)\n            checkCompletion(this);\n    }","id":26887,"modified_method":"/**\n     * <b>Callback<\/b> (called by RequestCorrelator or Transport).\n     * Adds a response to the response table. When all responses have been received,\n     * <code>execute()<\/code> returns.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void receiveResponse(Object response_value, Address sender, boolean is_exception) {\n        if(done)\n            return;\n        Rsp<T> rsp=requests.get(sender);\n        if(rsp == null)\n            return;\n\n        RspFilter rsp_filter=options.getRspFilter();\n        boolean responseReceived=false;\n\n        lock.lock();\n        try {\n            if(!rsp.wasReceived()) {\n                num_received++;\n                if((responseReceived=(rsp_filter == null) || rsp_filter.isAcceptable(response_value, sender))) {\n                    if(is_exception && response_value instanceof Throwable)\n                        rsp.setException((Throwable)response_value);\n                    else\n                        rsp.setValue((T)response_value);\n                    rsp.setReceived(true);\n                    num_valid++;\n                }\n            }\n\n            done=responsesComplete() || (rsp_filter != null && !rsp_filter.needMoreResponses());\n            if(responseReceived || done)\n                completed.signalAll(); // wakes up execute()\n            if(done && corr != null)\n                corr.done(req_id);\n        }\n        finally {\n            lock.unlock();\n        }\n        if(responseReceived || done)\n            checkCompletion(this);\n    }","commit_id":"b12d4209b522f410293b83f2b789ae6f4173c2b4","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends a unicast message and - depending on the options - returns a result\n     * @param msg the message to be sent. The destination needs to be non-null\n     * @param opts the options to be used\n     * @return T the result\n     * @throws Exception If there was problem sending the request, processing it at the receiver, or processing\n     *                   it at the sender.\n     * @throws TimeoutException If the call didn't succeed within the timeout defined in options (if set)\n     */\n    public <T> T sendMessage(Message msg, RequestOptions opts) throws Exception {\n        Address dest=msg.getDest();\n        if(dest == null) {\n            if(log.isErrorEnabled())\n                log.error(\"the message's destination is null, cannot send message\");\n            return null;\n        }\n\n        if(opts != null) {\n            msg.setFlag(opts.getFlags());\n            if(opts.getScope() > 0)\n                msg.setScope(opts.getScope());\n        }\n\n        UnicastRequest<T> req=new UnicastRequest<T>(msg, corr, dest, opts);\n        req.execute();\n\n        if(opts != null && opts.getMode() == ResponseMode.GET_NONE)\n            return null;\n\n        Rsp<T> rsp=req.getResult();\n        if(rsp.wasSuspected())\n            throw new SuspectedException(dest);\n\n        Throwable exception=rsp.getException();\n        if(exception != null) {\n            if(exception instanceof Error) throw (Error)exception;\n            else if(exception instanceof RuntimeException) throw (RuntimeException)exception;\n            else if(exception instanceof Exception) throw (Exception)exception;\n            else throw new RuntimeException(exception);\n        }\n\n        if(!rsp.wasReceived())\n            throw new TimeoutException(\"timeout sending message to \" + dest);\n        return rsp.getValue();\n    }","id":26888,"modified_method":"/**\n     * Sends a unicast message and - depending on the options - returns a result\n     * @param msg the message to be sent. The destination needs to be non-null\n     * @param opts the options to be used\n     * @return T the result\n     * @throws Exception If there was problem sending the request, processing it at the receiver, or processing\n     *                   it at the sender.\n     * @throws TimeoutException If the call didn't succeed within the timeout defined in options (if set)\n     */\n    public <T> T sendMessage(Message msg, RequestOptions opts) throws Exception {\n        Address dest=msg.getDest();\n        if(dest == null) {\n            if(log.isErrorEnabled())\n                log.error(\"the message's destination is null, cannot send message\");\n            return null;\n        }\n\n        if(opts != null) {\n            msg.setFlag(opts.getFlags());\n            if(opts.getScope() > 0)\n                msg.setScope(opts.getScope());\n        }\n\n        UnicastRequest<T> req=new UnicastRequest<T>(msg, corr, dest, opts);\n        req.execute();\n\n        if(opts != null && opts.getMode() == ResponseMode.GET_NONE)\n            return null;\n\n        Rsp<T> rsp=req.getResult();\n        if(rsp.wasSuspected())\n            throw new SuspectedException(dest);\n\n        Throwable exception=rsp.getException();\n        if(exception != null) {\n            if(exception instanceof Error) throw (Error)exception;\n            else if(exception instanceof RuntimeException) throw (RuntimeException)exception;\n            else if(exception instanceof Exception) throw (Exception)exception;\n            else throw new RuntimeException(exception);\n        }\n\n        if(!rsp.wasReceived() && !req.responseReceived())\n            throw new TimeoutException(\"timeout sending message to \" + dest);\n        return rsp.getValue();\n    }","commit_id":"b12d4209b522f410293b83f2b789ae6f4173c2b4","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testUnicastRPCs() throws Exception {\n\n        MethodCall method = new MethodCall(\"getName\", new Object[0], new Class[0]);\n\n        final Address address = channels[1].getAddress();\n        \n        // Validate normal dispatchers\n        Object response = dispatchers[0].callRemoteMethod(address, method, RequestOptions.SYNC());\n\n        Assert.assertEquals(response, \"dispatcher[1]\");\n\n        // Validate muxed dispatchers\n        for (int j = 0; j < muxDispatchers[0].length; ++j) {\n            \n            response = muxDispatchers[0][j].callRemoteMethod(address, method, RequestOptions.SYNC());\n\n            Assert.assertEquals(response, \"muxDispatcher[1][\" + j + \"]\");\n        }\n        \n        // Filter testing is disabled for now pending filter improvements in JGroups 3\n        \n//        // Validate muxed rpc dispatchers w/filter\n//        \n//        RspFilter filter = new RspFilter() {\n//\n//            @Override\n//            public boolean isAcceptable(Object response, Address sender) {\n//                return !sender.equals(address);\n//            }\n//\n//            @Override\n//            public boolean needMoreResponses() {\n//                return true;\n//            }\n//        };\n//        \n//        response = muxDispatchers[0][0].callRemoteMethod(address, method, RequestOptions.SYNC.setRspFilter(filter));\n//\n//        Assert.assertNull(address);\n//        \n//        // Validate stopped mux dispatcher response is auto-filtered\n//        muxDispatchers[1][0].stop();\n//        \n//        response = muxDispatchers[0][0].callRemoteMethod(address, method, RequestOptions.SYNC.setRspFilter(null));\n//\n//        Assert.assertNull(address);\n//        \n//        // Validate restarted mux dispatcher functions normally\n//        muxDispatchers[1][0].start();\n//        \n//        response = muxDispatchers[0][0].callRemoteMethod(address, method, RequestOptions.SYNC.setRspFilter(null));\n//\n//        Assert.assertEquals(response, \"muxDispatcher[1][0]\");\n    }","id":26889,"modified_method":"public void testUnicastRPCs() throws Exception {\n        RequestOptions options=RequestOptions.SYNC().setTimeout(30000);\n        MethodCall method = new MethodCall(\"getName\", new Object[0], new Class[0]);\n\n        final Address address = channels[1].getAddress();\n        \n        // Validate normal dispatchers\n        Object response = dispatchers[0].callRemoteMethod(address, method, options);\n        Assert.assertEquals(response, \"dispatcher[1]\");\n\n        // Validate muxed dispatchers\n        for (int j = 0; j < muxDispatchers[0].length; ++j) {\n            response = muxDispatchers[0][j].callRemoteMethod(address, method, options);\n            Assert.assertEquals(response, \"muxDispatcher[1][\" + j + \"]\");\n        }\n        \n        // Filter testing is disabled for now pending filter improvements in JGroups 3\n        \n        // Validate muxed rpc dispatchers w/filter\n\n        RspFilter filter = new RspFilter() {\n            @Override public boolean isAcceptable(Object response, Address sender) {return !sender.equals(address);}\n            @Override public boolean needMoreResponses() {return true;}\n        };\n\n        response = muxDispatchers[0][0].callRemoteMethod(address, method, RequestOptions.SYNC().setRspFilter(filter));\n        assert response == null;\n\n        // Validate stopped mux dispatcher response is auto-filtered\n        muxDispatchers[1][0].stop();\n\n        try {\n            response = muxDispatchers[0][0].callRemoteMethod(address, method, RequestOptions.SYNC().setTimeout(2000).setRspFilter(null));\n            assert false : \"should have run into a TimeoutException\";\n        }\n        catch(TimeoutException timeout) {\n            System.out.println(\"received \" + timeout + \" - as expected\");\n        }\n\n        Assert.assertNull(response);\n\n        // Validate restarted mux dispatcher functions normally\n        muxDispatchers[1][0].start();\n\n        response = muxDispatchers[0][0].callRemoteMethod(address, method, RequestOptions.SYNC().setRspFilter(null));\n\n        Assert.assertEquals(response, \"muxDispatcher[1][0]\");\n    }","commit_id":"b12d4209b522f410293b83f2b789ae6f4173c2b4","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testMulticastRPCs() throws Exception {\n\n        MethodCall method = new MethodCall(\"getName\", new Object[0], new Class[0]);\n        \n        // Validate normal dispatchers\n        Map<Address, Rsp<String>> responses = dispatchers[0].callRemoteMethods(null, method, RequestOptions.SYNC());\n\n        Assert.assertEquals(responses.size(), 2);\n        \n        for (int i = 0; i < dispatchers.length; ++i) {\n            \n            verifyResponse(responses, channels[i], \"dispatcher[\" + i + \"]\");\n        }\n\n        // Validate muxed dispatchers\n        for (int j = 0; j < muxDispatchers[0].length; ++j) {\n            \n            responses = muxDispatchers[0][j].callRemoteMethods(null, method, RequestOptions.SYNC());\n\n            Assert.assertEquals(responses.size(), 2);\n            \n            for (int i = 0; i < dispatchers.length; ++i) {\n                \n                verifyResponse(responses, channels[i], \"muxDispatcher[\" + i + \"][\" + j + \"]\");\n            }\n        }\n        \n        // Validate muxed rpc dispatchers w/filter\n        final Address address = channels[0].getAddress();\n        \n        RspFilter filter = new RspFilter() {\n\n            public boolean isAcceptable(Object response, Address sender) {\n                return !sender.equals(address);\n            }\n\n            public boolean needMoreResponses() {\n                return true;\n            }\n        };\n        \n        responses = muxDispatchers[0][0].callRemoteMethods(null, method, RequestOptions.SYNC().setRspFilter(filter));\n\n        Assert.assertEquals(responses.size(), 2);\n        verifyResponse(responses, channels[0], null);\n        verifyResponse(responses, channels[1], \"muxDispatcher[1][0]\");\n        \n        // Validate stopped mux dispatcher response is auto-filtered\n        muxDispatchers[1][0].stop();\n        \n        responses = muxDispatchers[0][0].callRemoteMethods(null, method, RequestOptions.SYNC().setRspFilter(null));\n\n        Assert.assertEquals(responses.size(), 2);\n        verifyResponse(responses, channels[0], \"muxDispatcher[0][0]\");\n        verifyResponse(responses, channels[1], null);\n        \n        // Validate stopped mux dispatcher response is auto-filtered and custom filter is applied\n        responses = muxDispatchers[0][0].callRemoteMethods(null, method, RequestOptions.SYNC().setRspFilter(filter));\n\n        Assert.assertEquals(responses.size(), 2);\n        verifyResponse(responses, channels[0], null);\n        verifyResponse(responses, channels[1], null);\n        \n        // Validate restarted mux dispatcher functions normally\n        muxDispatchers[1][0].start();\n        \n        responses = muxDispatchers[0][0].callRemoteMethods(null, method, RequestOptions.SYNC().setRspFilter(null));\n\n        Assert.assertEquals(responses.size(), 2);\n        verifyResponse(responses, channels[0], \"muxDispatcher[0][0]\");\n        verifyResponse(responses, channels[1], \"muxDispatcher[1][0]\");\n    }","id":26890,"modified_method":"public void testMulticastRPCs() throws Exception {\n        MethodCall method = new MethodCall(\"getName\", new Object[0], new Class[0]);\n        RequestOptions options=RequestOptions.SYNC().setTimeout(30000);\n        \n        // Validate normal dispatchers\n        Map<Address, Rsp<String>> responses = dispatchers[0].callRemoteMethods(null, method, options);\n        Assert.assertEquals(responses.size(), 2);\n        \n        for (int i = 0; i < dispatchers.length; ++i)\n            verifyResponse(responses, channels[i], \"dispatcher[\" + i + \"]\");\n\n        // Validate muxed dispatchers\n        for (int j = 0; j < muxDispatchers[0].length; ++j) {\n            responses = muxDispatchers[0][j].callRemoteMethods(null, method, options);\n            Assert.assertEquals(responses.size(), 2);\n            for (int i = 0; i < dispatchers.length; ++i)\n                verifyResponse(responses, channels[i], \"muxDispatcher[\" + i + \"][\" + j + \"]\");\n        }\n        \n        // Validate muxed rpc dispatchers w/filter\n        final Address address = channels[0].getAddress();\n        \n        RspFilter filter = new RspFilter() {\n            public boolean isAcceptable(Object response, Address sender) {\n                return !sender.equals(address);\n            }\n            public boolean needMoreResponses() {\n                return true;\n            }\n        };\n        \n        responses = muxDispatchers[0][0].callRemoteMethods(null,method,RequestOptions.SYNC().setTimeout(30000).setRspFilter(filter));\n\n        Assert.assertEquals(responses.size(), 2);\n        verifyResponse(responses, channels[0], null);\n        verifyResponse(responses, channels[1], \"muxDispatcher[1][0]\");\n        \n        // Validate stopped mux dispatcher response is auto-filtered\n        muxDispatchers[1][0].stop();\n        \n        responses = muxDispatchers[0][0].callRemoteMethods(null, method, options.setTimeout(2000));\n        Assert.assertEquals(responses.size(), 2);\n        verifyResponse(responses, channels[0], \"muxDispatcher[0][0]\");\n        verifyResponse(responses, channels[1], null);\n        \n        // Validate stopped mux dispatcher response is auto-filtered and custom filter is applied\n        responses = muxDispatchers[0][0].callRemoteMethods(null,method,RequestOptions.SYNC().setTimeout(2000).setRspFilter(filter));\n\n        Assert.assertEquals(responses.size(), 2);\n        verifyResponse(responses, channels[0], null);\n        verifyResponse(responses, channels[1], null);\n        \n        // Validate restarted mux dispatcher functions normally\n        muxDispatchers[1][0].start();\n        \n        responses = muxDispatchers[0][0].callRemoteMethods(null, method, options.setTimeout(30000));\n\n        Assert.assertEquals(responses.size(), 2);\n        verifyResponse(responses, channels[0], \"muxDispatcher[0][0]\");\n        verifyResponse(responses, channels[1], \"muxDispatcher[1][0]\");\n    }","commit_id":"b12d4209b522f410293b83f2b789ae6f4173c2b4","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Multiple threads (NUM_THREADS) send messages (NUM_MSGS)\n     * @throws Exception\n     */\n    @Test(dataProvider=\"provider\")\n    public void testMessageReceptionUnderHighLoad(String props) throws Exception {\n        CountDownLatch latch=new CountDownLatch(1);\n        c1=new JChannel(props);\n        c2=new JChannel(props);\n        MyReceiver r1=new MyReceiver(\"c1\"), r2=new MyReceiver(\"c2\");\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c1.connect(\"testSimpleMessageReception\");\n        c2.connect(\"testSimpleMessageReception\");\n\n        Address c1_addr=c1.getAddress(), c2_addr=c2.getAddress();\n        MySender[] c1_senders=new MySender[NUM_THREADS];\n        for(int i=0; i < c1_senders.length; i++) {\n            c1_senders[i]=new MySender(c1, c2_addr, latch);\n            c1_senders[i].start();\n        }\n        MySender[] c2_senders=new MySender[NUM_THREADS];\n        for(int i=0; i < c2_senders.length; i++) {\n            c2_senders[i]=new MySender(c2, c1_addr, latch);\n            c2_senders[i].start();\n        }\n\n        Util.sleep(500);\n        latch.countDown(); // starts all threads\n\n        long NUM_EXPECTED_MSGS=NUM_THREADS * NUM_MSGS;\n\n        for(int i=0; i < 100; i++) {\n            if(r1.getNum() == NUM_EXPECTED_MSGS && r2.getNum() == NUM_EXPECTED_MSGS)\n                break;\n            Util.sleep(500);\n            UNICAST2 unicast2=(UNICAST2)c1.getProtocolStack().findProtocol(UNICAST2.class);\n            if(unicast2 != null)\n                unicast2.sendStableMessages();\n            unicast2=(UNICAST2)c2.getProtocolStack().findProtocol(UNICAST2.class);\n            if(unicast2 != null)\n                unicast2.sendStableMessages();\n        }\n\n        System.out.println(\"c1 received \" + r1.getNum() + \" msgs, \" + getNumberOfRetransmissions(c1) + \" retransmissions\");\n        System.out.println(\"c2 received \" + r2.getNum() + \" msgs, \" + getNumberOfRetransmissions(c2) + \" retransmissions\");\n\n        assert r1.getNum() == NUM_EXPECTED_MSGS : \"expected \" + NUM_EXPECTED_MSGS + \", but got \" + r1.getNum();\n        assert r2.getNum() == NUM_EXPECTED_MSGS : \"expected \" + NUM_EXPECTED_MSGS + \", but got \" + r2.getNum();\n    }","id":26891,"modified_method":"/**\n     * Multiple threads (NUM_THREADS) send messages (NUM_MSGS)\n     * @throws Exception\n     */\n    @Test(dataProvider=\"provider\")\n    public void testMessageReceptionUnderHighLoad(String props) throws Exception {\n        CountDownLatch latch=new CountDownLatch(1);\n        c1=new JChannel(props);\n        c2=new JChannel(props);\n        MyReceiver r1=new MyReceiver(\"c1\"), r2=new MyReceiver(\"c2\");\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c1.connect(\"testSimpleMessageReception\");\n        c2.connect(\"testSimpleMessageReception\");\n\n        Address c1_addr=c1.getAddress(), c2_addr=c2.getAddress();\n        MySender[] c1_senders=new MySender[NUM_THREADS];\n        for(int i=0; i < c1_senders.length; i++) {\n            c1_senders[i]=new MySender(c1, c2_addr, latch);\n            c1_senders[i].start();\n        }\n        MySender[] c2_senders=new MySender[NUM_THREADS];\n        for(int i=0; i < c2_senders.length; i++) {\n            c2_senders[i]=new MySender(c2, c1_addr, latch);\n            c2_senders[i].start();\n        }\n\n        Util.sleep(500);\n        latch.countDown(); // starts all threads\n\n        long NUM_EXPECTED_MSGS=NUM_THREADS * NUM_MSGS;\n\n        for(int i=0; i < 20; i++) {\n            if(r1.getNum() == NUM_EXPECTED_MSGS && r2.getNum() == NUM_EXPECTED_MSGS)\n                break;\n            Util.sleep(2000);\n            UNICAST2 unicast2=(UNICAST2)c1.getProtocolStack().findProtocol(UNICAST2.class);\n            if(unicast2 != null)\n                unicast2.sendStableMessages();\n            unicast2=(UNICAST2)c2.getProtocolStack().findProtocol(UNICAST2.class);\n            if(unicast2 != null)\n                unicast2.sendStableMessages();\n        }\n\n        System.out.println(\"c1 received \" + r1.getNum() + \" msgs, \" + getNumberOfRetransmissions(c1) + \" retransmissions\");\n        System.out.println(\"c2 received \" + r2.getNum() + \" msgs, \" + getNumberOfRetransmissions(c2) + \" retransmissions\");\n\n        assert r1.getNum() == NUM_EXPECTED_MSGS : \"expected \" + NUM_EXPECTED_MSGS + \", but got \" + r1.getNum();\n        assert r2.getNum() == NUM_EXPECTED_MSGS : \"expected \" + NUM_EXPECTED_MSGS + \", but got \" + r2.getNum();\n    }","commit_id":"b12d4209b522f410293b83f2b789ae6f4173c2b4","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * <b>Callback<\/b> (called by RequestCorrelator or Transport).\n     * Adds a response to the response table. When all responses have been received,\n     * <code>execute()<\/code> returns.\n     */\n    public void receiveResponse(Object response_value, Address sender, boolean is_exception) {\n        RspFilter rsp_filter=options.getRspFilter();\n\n        lock.lock();\n        try {\n            if(done)\n                return;\n            if(!result.wasReceived()) {\n                num_received++;\n                boolean responseReceived=(rsp_filter == null) || rsp_filter.isAcceptable(response_value, sender);\n                if(is_exception && response_value instanceof Throwable)\n                    result.setException((Throwable)response_value);\n                else\n                    result.setValue((T)response_value);\n                result.setReceived(responseReceived);\n                if(log.isTraceEnabled()) {\n                    StringBuilder sb=new StringBuilder(\"received response for request \");\n                    sb.append(req_id).append(\", sender=\").append(sender);\n                    if(is_exception && response_value instanceof Throwable)\n                        sb.append(\", exception=\");\n                    else\n                        sb.append(\", val=\");\n                    sb.append(response_value);\n                    log.trace(sb.toString());\n                }\n            }\n            done=responsesComplete() || (rsp_filter != null && !rsp_filter.needMoreResponses());\n            if(done && corr != null)\n                corr.done(req_id);\n        }\n        finally {\n            completed.signalAll(); // wakes up execute()\n            lock.unlock();\n        }\n        checkCompletion(this);\n    }","id":26892,"modified_method":"/**\n     * <b>Callback<\/b> (called by RequestCorrelator or Transport).\n     * Adds a response to the response table. When all responses have been received,\n     * <code>execute()<\/code> returns.\n     */\n    public void receiveResponse(Object response_value, Address sender, boolean is_exception) {\n        RspFilter rsp_filter=options.getRspFilter();\n\n        lock.lock();\n        try {\n            if(done)\n                return;\n            if(!result.wasReceived()) {\n                num_received++;\n                if(rsp_filter == null || rsp_filter.isAcceptable(response_value, sender)) {\n                    if(is_exception && response_value instanceof Throwable)\n                        result.setException((Throwable)response_value);\n                    else\n                        result.setValue((T)response_value);\n                    result.setReceived(true);\n                    if(log.isTraceEnabled()) {\n                        StringBuilder sb=new StringBuilder(\"received response for request \");\n                        sb.append(req_id).append(\", sender=\").append(sender);\n                        if(is_exception && response_value instanceof Throwable)\n                            sb.append(\", exception=\");\n                        else\n                            sb.append(\", val=\");\n                        sb.append(response_value);\n                        log.trace(sb.toString());\n                    }\n                }\n            }\n            done=responsesComplete() || (rsp_filter != null && !rsp_filter.needMoreResponses());\n            if(done && corr != null)\n                corr.done(req_id);\n        }\n        finally {\n            completed.signalAll(); // wakes up execute()\n            lock.unlock();\n        }\n        checkCompletion(this);\n    }","commit_id":"b12d4209b522f410293b83f2b789ae6f4173c2b4","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     @param timeout Time to wait for responses (ms). A value of <= 0 means wait indefinitely\n     (e.g. if a suspicion service is available; timeouts are not needed).\n     */\n    public GroupRequest(Message m, RequestCorrelator corr, Collection<Address> mbrs, int rsp_mode,\n                        long timeout, int expected_mbrs) {\n        super(m, corr, null, null, rsp_mode, timeout);\n        this.expected_mbrs=expected_mbrs;\n        setTargets(mbrs);\n    }","id":26893,"modified_method":"/**\n     @param timeout Time to wait for responses (ms). A value of <= 0 means wait indefinitely\n     (e.g. if a suspicion service is available; timeouts are not needed).\n     */\n    public GroupRequest(Message m, RequestCorrelator corr, Collection<Address> mbrs, int rsp_mode,\n                        long timeout, int expected_mbrs) {\n        super(m, corr, null, null, rsp_mode, timeout);\n        this.expected_mbrs=expected_mbrs;\n        int size=mbrs.size();\n        requests=new HashMap<Address,Rsp>(size);\n        setTargets(mbrs);\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * <b>Callback<\/b> (called by RequestCorrelator or Transport).\n     * Adds a response to the response table. When all responses have been received,\n     * <code>execute()<\/code> returns.\n     */\n    public void receiveResponse(Object response_value, Address sender) {\n        if(done)\n            return;\n\n        lock.lock();\n        try {\n            Rsp rsp=requests.get(sender);\n            if(rsp == null)\n                return;\n            if(!rsp.wasReceived()) {\n                boolean responseReceived =(rsp_filter == null) || rsp_filter.isAcceptable(response_value, sender);\n                rsp.setValue(response_value);\n                rsp.setReceived(responseReceived);\n                if(log.isTraceEnabled())\n                    log.trace(new StringBuilder(\"received response for request \").append(req_id)\n                            .append(\", sender=\").append(sender).append(\", val=\").append(response_value));\n            }\n            // done=rsp_filter != null && !rsp_filter.needMoreResponses();\n            done=rsp_filter == null? responsesComplete() : !rsp_filter.needMoreResponses();\n            if(done && corr != null)\n                corr.done(req_id);\n        }\n        finally {\n            completed.signalAll(); // wakes up execute()\n            lock.unlock();\n        }\n        checkCompletion(this);\n    }","id":26894,"modified_method":"/**\n     * <b>Callback<\/b> (called by RequestCorrelator or Transport).\n     * Adds a response to the response table. When all responses have been received,\n     * <code>execute()<\/code> returns.\n     */\n    public void receiveResponse(Object response_value, Address sender) {\n        if(done)\n            return;\n        Rsp rsp=requests.get(sender);\n        if(rsp == null)\n            return;\n\n        boolean responseReceived=false;\n        if(!rsp.wasReceived()) {\n            if((responseReceived=(rsp_filter == null) || rsp_filter.isAcceptable(response_value, sender)))\n                rsp.setValue(response_value);\n            rsp.setReceived(responseReceived);\n        }\n\n        lock.lock();\n        try {\n            if(responseReceived)\n                num_received++;\n            done=rsp_filter == null? responsesComplete() : !rsp_filter.needMoreResponses();\n            if(responseReceived || done)\n                completed.signalAll(); // wakes up execute()\n            if(done && corr != null)\n                corr.done(req_id);\n        }\n        finally {\n            lock.unlock();\n        }\n        if(responseReceived || done)\n            checkCompletion(this);\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"@GuardedBy(\"lock\")\n    protected boolean responsesComplete() {\n        if(done)\n            return true;\n\n        int num_received=0, num_not_received=0, num_suspected=0;\n        final int num_total=requests.size();\n\n        for(Rsp rsp: requests.values()) {\n            if(rsp.wasReceived()) {\n                num_received++;\n            }\n            else {\n                if(rsp.wasSuspected()) {\n                    num_suspected++;\n                }\n                else {\n                    num_not_received++;\n                }\n            }\n        }\n\n        switch(rsp_mode) {\n            case GET_FIRST:\n                if(num_received > 0)\n                    return true;\n                if(num_suspected >= num_total)\n                // e.g. 2 members, and both suspected\n                    return true;\n                break;\n            case GET_ALL:\n                return num_received + num_suspected >= num_total;\n            case GET_MAJORITY:\n                int majority=determineMajority(num_total);\n                if(num_received + num_suspected >= majority)\n                    return true;\n                break;\n            case GET_ABS_MAJORITY:\n                majority=determineMajority(num_total);\n                if(num_received >= majority)\n                    return true;\n                break;\n            case GET_N:\n                if(expected_mbrs >= num_total) {                    \n                    return responsesComplete();\n                }\n                return num_received >= expected_mbrs || num_received + num_not_received < expected_mbrs && num_received + num_suspected >= expected_mbrs;\n            case GET_NONE:\n                return true;\n            default :\n                if(log.isErrorEnabled()) log.error(\"rsp_mode \" + rsp_mode + \" unknown !\");\n                break;\n        }\n        return false;\n    }","id":26895,"modified_method":"@GuardedBy(\"lock\")\n    protected boolean responsesComplete() {\n        if(done)\n            return true;\n\n        final int num_total=requests.size();\n\n        switch(rsp_mode) {\n            case GET_FIRST:\n                if(num_received > 0)\n                    return true;\n                if(num_suspected >= num_total)\n                // e.g. 2 members, and both suspected\n                    return true;\n                break;\n            case GET_ALL:\n                return num_received + num_suspected >= num_total;\n            case GET_MAJORITY:\n                int majority=determineMajority(num_total);\n                if(num_received + num_suspected >= majority)\n                    return true;\n                break;\n            case GET_ABS_MAJORITY:\n                majority=determineMajority(num_total);\n                if(num_received >= majority)\n                    return true;\n                break;\n            case GET_N:\n                return num_received >= expected_mbrs || num_received + num_not_received < expected_mbrs && num_received + num_suspected >= expected_mbrs;\n            case GET_NONE:\n                return true;\n            default :\n                if(log.isErrorEnabled()) log.error(\"rsp_mode \" + rsp_mode + \" unknown !\");\n                break;\n        }\n        return false;\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Returns the results as a RspList */\n    public RspList getResults() {\n        lock.lock();\n        try {\n            Collection<Rsp> rsps=requests.values();\n            return new RspList(rsps);\n        }\n        finally {\n            lock.unlock();\n        }\n    }","id":26896,"modified_method":"/** Returns the results as a RspList */\n    public RspList getResults() {\n        Collection<Rsp> rsps=requests.values();\n        return new RspList(rsps);\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"public GroupRequest(Message m, RequestCorrelator corr, Address target, int rsp_mode,\n                        long timeout, int expected_mbrs) {\n        super(m, corr, null, null, rsp_mode, timeout);\n        this.expected_mbrs=expected_mbrs;\n        setTarget(target);\n    }","id":26897,"modified_method":"public GroupRequest(Message m, RequestCorrelator corr, Address target, int rsp_mode,\n                        long timeout, int expected_mbrs) {\n        super(m, corr, null, null, rsp_mode, timeout);\n        this.expected_mbrs=expected_mbrs;\n        requests=new HashMap<Address,Rsp>(1);\n        setTarget(target);\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Any member of 'membership' that is not in the new view is flagged as\n     * SUSPECTED. Any member in the new view that is <em>not<\/em> in the\n     * membership (ie, the set of responses expected for the current RPC) will\n     * <em>not<\/em> be added to it. If we did this we might run into the\n     * following problem:\n     * <ul>\n     * <li>Membership is {A,B}\n     * <li>A sends a synchronous group RPC (which sleeps for 60 secs in the\n     * invocation handler)\n     * <li>C joins while A waits for responses from A and B\n     * <li>If this would generate a new view {A,B,C} and if this expanded the\n     * response set to {A,B,C}, A would wait forever on C's response because C\n     * never received the request in the first place, therefore won't send a\n     * response.\n     * <\/ul>\n     */\n    public void viewChange(View new_view) {\n        Address mbr;\n        Vector<Address> mbrs=new_view != null? new_view.getMembers() : null;\n\n        if(mbrs == null)\n            return;\n\n        lock.lock();\n        try {\n            if(requests == null || requests.isEmpty())\n                return;\n\n            this.members.clear();\n            this.members.addAll(mbrs);\n\n            Rsp rsp;\n            Set<Address> tmp=null;\n            for(Map.Entry<Address,Rsp> entry: requests.entrySet()) {\n                mbr=entry.getKey();\n                if(!mbrs.contains(mbr)) {\n                    if(tmp == null)\n                        tmp=new HashSet<Address>();\n                    tmp.add(mbr);\n                    addSuspect(mbr);\n                    rsp=entry.getValue();\n                    rsp.setValue(null);\n                    rsp.setSuspected(true);\n                }\n            }\n\n            if(tmp != null) {\n                for(Address suspect: tmp) {\n                    addSuspect(suspect);\n                }\n                completed.signalAll();\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n        checkCompletion(this);\n    }","id":26898,"modified_method":"/**\n     * Any member of 'membership' that is not in the new view is flagged as\n     * SUSPECTED. Any member in the new view that is <em>not<\/em> in the\n     * membership (ie, the set of responses expected for the current RPC) will\n     * <em>not<\/em> be added to it. If we did this we might run into the\n     * following problem:\n     * <ul>\n     * <li>Membership is {A,B}\n     * <li>A sends a synchronous group RPC (which sleeps for 60 secs in the\n     * invocation handler)\n     * <li>C joins while A waits for responses from A and B\n     * <li>If this would generate a new view {A,B,C} and if this expanded the\n     * response set to {A,B,C}, A would wait forever on C's response because C\n     * never received the request in the first place, therefore won't send a\n     * response.\n     * <\/ul>\n     */\n    public void viewChange(View new_view) {\n        Vector<Address> mbrs=new_view != null? new_view.getMembers() : null;\n        if(mbrs == null)\n            return;\n\n        boolean changed=false;\n        if(requests == null || requests.isEmpty())\n                return;\n\n        lock.lock();\n        try {\n            for(Map.Entry<Address,Rsp> entry: requests.entrySet()) {\n                Address mbr=entry.getKey();\n                if(!mbrs.contains(mbr)) {\n                    Rsp rsp=entry.getValue();\n                    rsp.setValue(null);\n                    if(rsp.setSuspected(true)) {\n                        num_suspected++;\n                        changed=true;\n                    }\n                }\n            }\n            if(changed)\n                completed.signalAll();\n        }\n        finally {\n            lock.unlock();\n        }\n        if(changed)\n            checkCompletion(this);\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * <b>Callback<\/b> (called by RequestCorrelator or Transport).\n     * Report to <code>GroupRequest<\/code> that a member is reported as faulty (suspected).\n     * This method would probably be called when getting a suspect message from a failure detector\n     * (where available). It is used to exclude faulty members from the response list.\n     */\n    public void suspect(Address suspected_member) {\n        if(suspected_member == null)\n            return;\n\n        lock.lock();\n        try {\n            addSuspect(suspected_member);\n            Rsp rsp=requests.get(suspected_member);\n            if(rsp != null) {\n                rsp.setSuspected(true);\n                rsp.setValue(null);\n                completed.signalAll();\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n        checkCompletion(this);\n    }","id":26899,"modified_method":"/**\n     * <b>Callback<\/b> (called by RequestCorrelator or Transport).\n     * Report to <code>GroupRequest<\/code> that a member is reported as faulty (suspected).\n     * This method would probably be called when getting a suspect message from a failure detector\n     * (where available). It is used to exclude faulty members from the response list.\n     */\n    public void suspect(Address suspected_member) {\n        if(suspected_member == null)\n            return;\n\n        boolean changed=false;\n        Rsp rsp=requests.get(suspected_member);\n        if(rsp !=  null) {\n            if(rsp.setSuspected(true)) {\n                rsp.setValue(null);\n                changed=true;\n                lock.lock();\n                try {\n                    num_suspected++;\n                    completed.signalAll();\n                }\n                finally {\n                    lock.unlock();\n                }\n            }\n        }\n\n        if(changed)\n            checkCompletion(this);\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendRequest() throws Exception {\n        Vector<Address> targets=null;\n        lock.lock();\n        try {\n            targets=new Vector<Address>(members);\n            for(Address suspect: suspects) { // mark all suspects in 'received' array\n                Rsp rsp=requests.get(suspect);\n                if(rsp != null) {\n                    rsp.setSuspected(true);\n                    break; // we can break here because we ensure there are no duplicate members\n                }\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n\n        sendRequest(targets, req_id, use_anycasting);\n    }","id":26900,"modified_method":"public void sendRequest() throws Exception {\n        sendRequest(requests.keySet(), req_id, use_anycasting);\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"void setTargets(Collection<Address> mbrs) {\n        if(mbrs != null) {\n            for(Address mbr: mbrs) {\n                requests.put(mbr, new Rsp(mbr));\n            }\n            this.members.clear();\n            this.members.addAll(mbrs);\n        }\n    }","id":26901,"modified_method":"private void setTargets(Collection<Address> mbrs) {\n        for(Address mbr: mbrs)\n            requests.put(mbr, new Rsp(mbr));\n        num_not_received=requests.size();\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n        StringBuilder ret=new StringBuilder(128);\n        ret.append(super.toString());\n\n        lock.lock();\n        try {\n            if(!requests.isEmpty()) {\n                ret.append(\", entries:\\n\");\n                for(Map.Entry<Address,Rsp> entry: requests.entrySet()) {\n                    Address mbr=entry.getKey();\n                    Rsp rsp=entry.getValue();\n                    ret.append(mbr).append(\": \").append(rsp).append(\"\\n\");\n                }\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n        return ret.toString();\n    }","id":26902,"modified_method":"public String toString() {\n        StringBuilder ret=new StringBuilder(128);\n        ret.append(super.toString());\n\n        if(!requests.isEmpty()) {\n            ret.append(\", entries:\\n\");\n            for(Map.Entry<Address,Rsp> entry: requests.entrySet()) {\n                Address mbr=entry.getKey();\n                Rsp rsp=entry.getValue();\n                ret.append(mbr).append(\": \").append(rsp).append(\"\\n\");\n            }\n        }\n        return ret.toString();\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendRequest(Vector<Address> targetMembers, long requestId,boolean use_anycasting) throws Exception {\n        try {\n            if(log.isTraceEnabled()) log.trace(new StringBuilder(\"sending request (id=\").append(req_id).append(')'));\n            if(corr != null) {                \n                corr.sendRequest(requestId, targetMembers, request_msg, rsp_mode == GET_NONE? null : this, use_anycasting);\n            }\n            else {\n                if(use_anycasting) {                                                          \n                    for(Address mbr: targetMembers) {\n                        Message copy=request_msg.copy(true);\n                        copy.setDest(mbr);\n                        transport.send(copy);\n                    }\n                }\n                else {\n                    transport.send(request_msg);\n                }\n            }\n        }\n        catch(Exception ex) {\n            if(corr != null)\n                corr.done(requestId);\n            throw ex;\n        }\n    }","id":26903,"modified_method":"private void sendRequest(final Collection<Address> targetMembers, long requestId,boolean use_anycasting) throws Exception {\n        try {\n            if(corr != null) {\n                corr.sendRequest(requestId, targetMembers, request_msg, rsp_mode == GET_NONE? null : this, use_anycasting);\n            }\n            else {\n                if(use_anycasting) {                                                          \n                    for(Address mbr: targetMembers) {\n                        Message copy=request_msg.copy(true);\n                        copy.setDest(mbr);\n                        transport.send(copy);\n                    }\n                }\n                else {\n                    transport.send(request_msg);\n                }\n            }\n        }\n        catch(Exception ex) {\n            if(corr != null)\n                corr.done(requestId);\n            throw ex;\n        }\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * @param timeout Time to wait for responses (ms). A value of <= 0 means wait indefinitely\n     *                       (e.g. if a suspicion service is available; timeouts are not needed).\n     */\n    public GroupRequest(Message m, Transport transport, Collection<Address> mbrs, int rsp_mode,\n                        long timeout, int expected_mbrs) {\n        super(m, null, transport, null, rsp_mode, timeout);\n        this.expected_mbrs=expected_mbrs;\n        setTargets(mbrs);\n    }","id":26904,"modified_method":"/**\n     * @param timeout Time to wait for responses (ms). A value of <= 0 means wait indefinitely\n     *                       (e.g. if a suspicion service is available; timeouts are not needed).\n     */\n    public GroupRequest(Message m, Transport transport, Collection<Address> mbrs, int rsp_mode,\n                        long timeout, int expected_mbrs) {\n        super(m, null, transport, null, rsp_mode, timeout);\n        this.expected_mbrs=expected_mbrs;\n        int size=mbrs.size();\n        requests=new HashMap<Address,Rsp>(size);\n        setTargets(mbrs);\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"void setTarget(Address mbr) {\n        if(mbr != null) {\n            requests.put(mbr, new Rsp(mbr));\n            this.members.clear();\n            this.members.add(mbr);\n        }\n    }","id":26905,"modified_method":"private void setTarget(Address mbr) {\n        requests.put(mbr, new Rsp(mbr));\n        num_not_received=1;\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * @param m\n     *                The message to be sent\n     * @param corr\n     *                The request correlator to be used. A request correlator\n     *                sends requests tagged with a unique ID and notifies the\n     *                sender when matching responses are received. The reason\n     *                <code>GroupRequest<\/code> uses it instead of a\n     *                <code>Transport<\/code> is that multiple\n     *                requests/responses might be sent/received concurrently.\n     * @param members\n     *                The initial membership. This value reflects the membership\n     *                to which the request is sent (and from which potential\n     *                responses are expected). Is reset by reset().\n     * @param rsp_mode\n     *                How many responses are expected. Can be\n     *                <ol>\n     *                <li><code>GET_ALL<\/code>: wait for all responses from\n     *                non-suspected members. A suspicion service might warn us\n     *                when a member from which a response is outstanding has\n     *                crashed, so it can be excluded from the responses. If no\n     *                suspicion service is available, a timeout can be used (a\n     *                value of 0 means wait forever). <em>If a timeout of\n     *                0 is used, no suspicion service is available and a member from which we\n     *                expect a response has crashed, this methods blocks forever !<\/em>.\n     *                <li><code>GET_FIRST<\/code>: wait for the first\n     *                available response.\n     *                <li><code>GET_MAJORITY<\/code>: wait for the majority\n     *                of all responses. The majority is re-computed when a\n     *                member is suspected.\n     *                <li><code>GET_ABS_MAJORITY<\/code>: wait for the\n     *                majority of <em>all<\/em> members. This includes failed\n     *                members, so it may block if no timeout is specified.\n     *                <li><code>GET_N<\/CODE>: wait for N members. Return if\n     *                n is >= membership+suspects.\n     *                <li><code>GET_NONE<\/code>: don't wait for any\n     *                response. Essentially send an asynchronous message to the\n     *                group members.\n     *                <\/ol>\n     */\n    public GroupRequest(Message m, RequestCorrelator corr, Vector<Address> members, int rsp_mode) {\n        this(m,corr,members,rsp_mode,0,0);\n    }","id":26906,"modified_method":"/**\n     * @param msg The message to be sent\n     * @param corr The request correlator to be used. A request correlator sends requests tagged with a unique ID and\n     *             notifies the sender when matching responses are received. The reason <code>GroupRequest<\/code> uses\n     *             it instead of a <code>Transport<\/code> is that multiple requests/responses might be sent/received concurrently\n     * @param targets The targets, which are supposed to receive the message. Any receiver not in this set will\n     *                discard the message. Targets are always a subset of the current membership\n     * @param rsp_mode How many responses are expected. Can be\n     *                <ol>\n     *                <li><code>GET_ALL<\/code>: wait for all responses from non-suspected members. A suspicion service\n     *                might warn us when a member from which a response is pending has crashed, so it can be excluded\n     *                from the responses. If no suspicion service is available, a timeout can be used (a value of 0\n     *                means wait forever). <em>If a timeout of 0 is used, no suspicion service is available and a member\n     *                from which we expect a response has crashed, this methods blocks forever !<\/em>.\n     *                <li><code>GET_FIRST<\/code>: wait for the first available response.\n     *                <li><code>GET_MAJORITY<\/code>: wait for the majority of all responses. The majority is\n     *                re-computed when a member is suspected.\n     *                <li><code>GET_ABS_MAJORITY<\/code>: wait for the majority of <em>all<\/em> members. This includes\n     *                failed members, so it may block if no timeout is specified.\n     *                <li><code>GET_N<\/CODE>: wait for N members. Return if n is >= membership+suspects.\n     *                <li><code>GET_NONE<\/code>: don't wait for any response. Essentially send an asynchronous\n     *                message to the group members.\n     *                <\/ol>\n     */\n    public GroupRequest(Message msg, RequestCorrelator corr, Vector<Address> targets, int rsp_mode) {\n        this(msg, corr, targets, rsp_mode, 0, 0);\n    }","commit_id":"04b40ab4e6278f649ab6576f3d798bf722c118a1","url":"https://github.com/belaban/JGroups"},{"original_method":"void setTargets(Collection<Address> mbrs) {\n        if(mbrs != null) {\n            for(Address mbr: mbrs) {\n                requests.put(mbr, new Rsp(mbr));\n            }\n            this.members.clear();\n            this.members.addAll(mbrs);\n        }\n    }","id":26907,"modified_method":"private void setTargets(Collection<Address> mbrs) {\n        for(Address mbr: mbrs)\n            requests.put(mbr, new Rsp(mbr));\n        num_not_received=requests.size();\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Any member of 'membership' that is not in the new view is flagged as\n     * SUSPECTED. Any member in the new view that is <em>not<\/em> in the\n     * membership (ie, the set of responses expected for the current RPC) will\n     * <em>not<\/em> be added to it. If we did this we might run into the\n     * following problem:\n     * <ul>\n     * <li>Membership is {A,B}\n     * <li>A sends a synchronous group RPC (which sleeps for 60 secs in the\n     * invocation handler)\n     * <li>C joins while A waits for responses from A and B\n     * <li>If this would generate a new view {A,B,C} and if this expanded the\n     * response set to {A,B,C}, A would wait forever on C's response because C\n     * never received the request in the first place, therefore won't send a\n     * response.\n     * <\/ul>\n     */\n    public void viewChange(View new_view) {\n        Address mbr;\n        Vector<Address> mbrs=new_view != null? new_view.getMembers() : null;\n\n        if(mbrs == null)\n            return;\n\n        lock.lock();\n        try {\n            if(requests == null || requests.isEmpty())\n                return;\n\n            this.members.clear();\n            this.members.addAll(mbrs);\n\n            Rsp rsp;\n            Set<Address> tmp=null;\n            for(Map.Entry<Address,Rsp> entry: requests.entrySet()) {\n                mbr=entry.getKey();\n                if(!mbrs.contains(mbr)) {\n                    if(tmp == null)\n                        tmp=new HashSet<Address>();\n                    tmp.add(mbr);\n                    addSuspect(mbr);\n                    rsp=entry.getValue();\n                    rsp.setValue(null);\n                    rsp.setSuspected(true);\n                }\n            }\n\n            if(tmp != null) {\n                for(Address suspect: tmp) {\n                    addSuspect(suspect);\n                }\n                completed.signalAll();\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n        checkCompletion(this);\n    }","id":26908,"modified_method":"/**\n     * Any member of 'membership' that is not in the new view is flagged as\n     * SUSPECTED. Any member in the new view that is <em>not<\/em> in the\n     * membership (ie, the set of responses expected for the current RPC) will\n     * <em>not<\/em> be added to it. If we did this we might run into the\n     * following problem:\n     * <ul>\n     * <li>Membership is {A,B}\n     * <li>A sends a synchronous group RPC (which sleeps for 60 secs in the\n     * invocation handler)\n     * <li>C joins while A waits for responses from A and B\n     * <li>If this would generate a new view {A,B,C} and if this expanded the\n     * response set to {A,B,C}, A would wait forever on C's response because C\n     * never received the request in the first place, therefore won't send a\n     * response.\n     * <\/ul>\n     */\n    public void viewChange(View new_view) {\n        Vector<Address> mbrs=new_view != null? new_view.getMembers() : null;\n        if(mbrs == null)\n            return;\n\n        boolean changed=false;\n        if(requests == null || requests.isEmpty())\n                return;\n\n        lock.lock();\n        try {\n            for(Map.Entry<Address,Rsp> entry: requests.entrySet()) {\n                Address mbr=entry.getKey();\n                if(!mbrs.contains(mbr)) {\n                    Rsp rsp=entry.getValue();\n                    rsp.setValue(null);\n                    if(rsp.setSuspected(true)) {\n                        num_suspected++;\n                        changed=true;\n                    }\n                }\n            }\n            if(changed)\n                completed.signalAll();\n        }\n        finally {\n            lock.unlock();\n        }\n        if(changed)\n            checkCompletion(this);\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * @param timeout Time to wait for responses (ms). A value of <= 0 means wait indefinitely\n     *                       (e.g. if a suspicion service is available; timeouts are not needed).\n     */\n    public GroupRequest(Message m, Transport transport, Collection<Address> mbrs, int rsp_mode,\n                        long timeout, int expected_mbrs) {\n        super(m, null, transport, null, rsp_mode, timeout);\n        this.expected_mbrs=expected_mbrs;\n        setTargets(mbrs);\n    }","id":26909,"modified_method":"/**\n     * @param timeout Time to wait for responses (ms). A value of <= 0 means wait indefinitely\n     *                       (e.g. if a suspicion service is available; timeouts are not needed).\n     */\n    public GroupRequest(Message m, Transport transport, Collection<Address> mbrs, int rsp_mode,\n                        long timeout, int expected_mbrs) {\n        super(m, null, transport, null, rsp_mode, timeout);\n        this.expected_mbrs=expected_mbrs;\n        int size=mbrs.size();\n        requests=new HashMap<Address,Rsp>(size);\n        setTargets(mbrs);\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * @param m\n     *                The message to be sent\n     * @param corr\n     *                The request correlator to be used. A request correlator\n     *                sends requests tagged with a unique ID and notifies the\n     *                sender when matching responses are received. The reason\n     *                <code>GroupRequest<\/code> uses it instead of a\n     *                <code>Transport<\/code> is that multiple\n     *                requests/responses might be sent/received concurrently.\n     * @param members\n     *                The initial membership. This value reflects the membership\n     *                to which the request is sent (and from which potential\n     *                responses are expected). Is reset by reset().\n     * @param rsp_mode\n     *                How many responses are expected. Can be\n     *                <ol>\n     *                <li><code>GET_ALL<\/code>: wait for all responses from\n     *                non-suspected members. A suspicion service might warn us\n     *                when a member from which a response is outstanding has\n     *                crashed, so it can be excluded from the responses. If no\n     *                suspicion service is available, a timeout can be used (a\n     *                value of 0 means wait forever). <em>If a timeout of\n     *                0 is used, no suspicion service is available and a member from which we\n     *                expect a response has crashed, this methods blocks forever !<\/em>.\n     *                <li><code>GET_FIRST<\/code>: wait for the first\n     *                available response.\n     *                <li><code>GET_MAJORITY<\/code>: wait for the majority\n     *                of all responses. The majority is re-computed when a\n     *                member is suspected.\n     *                <li><code>GET_ABS_MAJORITY<\/code>: wait for the\n     *                majority of <em>all<\/em> members. This includes failed\n     *                members, so it may block if no timeout is specified.\n     *                <li><code>GET_N<\/CODE>: wait for N members. Return if\n     *                n is >= membership+suspects.\n     *                <li><code>GET_NONE<\/code>: don't wait for any\n     *                response. Essentially send an asynchronous message to the\n     *                group members.\n     *                <\/ol>\n     */\n    public GroupRequest(Message m, RequestCorrelator corr, Vector<Address> members, int rsp_mode) {\n        this(m,corr,members,rsp_mode,0,0);\n    }","id":26910,"modified_method":"/**\n     * @param msg The message to be sent\n     * @param corr The request correlator to be used. A request correlator sends requests tagged with a unique ID and\n     *             notifies the sender when matching responses are received. The reason <code>GroupRequest<\/code> uses\n     *             it instead of a <code>Transport<\/code> is that multiple requests/responses might be sent/received concurrently\n     * @param targets The targets, which are supposed to receive the message. Any receiver not in this set will\n     *                discard the message. Targets are always a subset of the current membership\n     * @param rsp_mode How many responses are expected. Can be\n     *                <ol>\n     *                <li><code>GET_ALL<\/code>: wait for all responses from non-suspected members. A suspicion service\n     *                might warn us when a member from which a response is pending has crashed, so it can be excluded\n     *                from the responses. If no suspicion service is available, a timeout can be used (a value of 0\n     *                means wait forever). <em>If a timeout of 0 is used, no suspicion service is available and a member\n     *                from which we expect a response has crashed, this methods blocks forever !<\/em>.\n     *                <li><code>GET_FIRST<\/code>: wait for the first available response.\n     *                <li><code>GET_MAJORITY<\/code>: wait for the majority of all responses. The majority is\n     *                re-computed when a member is suspected.\n     *                <li><code>GET_ABS_MAJORITY<\/code>: wait for the majority of <em>all<\/em> members. This includes\n     *                failed members, so it may block if no timeout is specified.\n     *                <li><code>GET_N<\/CODE>: wait for N members. Return if n is >= membership+suspects.\n     *                <li><code>GET_NONE<\/code>: don't wait for any response. Essentially send an asynchronous\n     *                message to the group members.\n     *                <\/ol>\n     */\n    public GroupRequest(Message msg, RequestCorrelator corr, Vector<Address> targets, int rsp_mode) {\n        this(msg, corr, targets, rsp_mode, 0, 0);\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n        StringBuilder ret=new StringBuilder(128);\n        ret.append(super.toString());\n\n        lock.lock();\n        try {\n            if(!requests.isEmpty()) {\n                ret.append(\", entries:\\n\");\n                for(Map.Entry<Address,Rsp> entry: requests.entrySet()) {\n                    Address mbr=entry.getKey();\n                    Rsp rsp=entry.getValue();\n                    ret.append(mbr).append(\": \").append(rsp).append(\"\\n\");\n                }\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n        return ret.toString();\n    }","id":26911,"modified_method":"public String toString() {\n        StringBuilder ret=new StringBuilder(128);\n        ret.append(super.toString());\n\n        if(!requests.isEmpty()) {\n            ret.append(\", entries:\\n\");\n            for(Map.Entry<Address,Rsp> entry: requests.entrySet()) {\n                Address mbr=entry.getKey();\n                Rsp rsp=entry.getValue();\n                ret.append(mbr).append(\": \").append(rsp).append(\"\\n\");\n            }\n        }\n        return ret.toString();\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Returns the results as a RspList */\n    public RspList getResults() {\n        lock.lock();\n        try {\n            Collection<Rsp> rsps=requests.values();\n            return new RspList(rsps);\n        }\n        finally {\n            lock.unlock();\n        }\n    }","id":26912,"modified_method":"/** Returns the results as a RspList */\n    public RspList getResults() {\n        Collection<Rsp> rsps=requests.values();\n        return new RspList(rsps);\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"public GroupRequest(Message m, RequestCorrelator corr, Address target, int rsp_mode,\n                        long timeout, int expected_mbrs) {\n        super(m, corr, null, null, rsp_mode, timeout);\n        this.expected_mbrs=expected_mbrs;\n        setTarget(target);\n    }","id":26913,"modified_method":"public GroupRequest(Message m, RequestCorrelator corr, Address target, int rsp_mode,\n                        long timeout, int expected_mbrs) {\n        super(m, corr, null, null, rsp_mode, timeout);\n        this.expected_mbrs=expected_mbrs;\n        requests=new HashMap<Address,Rsp>(1);\n        setTarget(target);\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendRequest() throws Exception {\n        Vector<Address> targets=null;\n        lock.lock();\n        try {\n            targets=new Vector<Address>(members);\n            for(Address suspect: suspects) { // mark all suspects in 'received' array\n                Rsp rsp=requests.get(suspect);\n                if(rsp != null) {\n                    rsp.setSuspected(true);\n                    break; // we can break here because we ensure there are no duplicate members\n                }\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n\n        sendRequest(targets, req_id, use_anycasting);\n    }","id":26914,"modified_method":"public void sendRequest() throws Exception {\n        sendRequest(requests.keySet(), req_id, use_anycasting);\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"@GuardedBy(\"lock\")\n    protected boolean responsesComplete() {\n        if(done)\n            return true;\n\n        int num_received=0, num_not_received=0, num_suspected=0;\n        final int num_total=requests.size();\n\n        for(Rsp rsp: requests.values()) {\n            if(rsp.wasReceived()) {\n                num_received++;\n            }\n            else {\n                if(rsp.wasSuspected()) {\n                    num_suspected++;\n                }\n                else {\n                    num_not_received++;\n                }\n            }\n        }\n\n        switch(rsp_mode) {\n            case GET_FIRST:\n                if(num_received > 0)\n                    return true;\n                if(num_suspected >= num_total)\n                // e.g. 2 members, and both suspected\n                    return true;\n                break;\n            case GET_ALL:\n                return num_received + num_suspected >= num_total;\n            case GET_MAJORITY:\n                int majority=determineMajority(num_total);\n                if(num_received + num_suspected >= majority)\n                    return true;\n                break;\n            case GET_ABS_MAJORITY:\n                majority=determineMajority(num_total);\n                if(num_received >= majority)\n                    return true;\n                break;\n            case GET_N:\n                if(expected_mbrs >= num_total) {                    \n                    return responsesComplete();\n                }\n                return num_received >= expected_mbrs || num_received + num_not_received < expected_mbrs && num_received + num_suspected >= expected_mbrs;\n            case GET_NONE:\n                return true;\n            default :\n                if(log.isErrorEnabled()) log.error(\"rsp_mode \" + rsp_mode + \" unknown !\");\n                break;\n        }\n        return false;\n    }","id":26915,"modified_method":"@GuardedBy(\"lock\")\n    protected boolean responsesComplete() {\n        if(done)\n            return true;\n\n        final int num_total=requests.size();\n\n        switch(rsp_mode) {\n            case GET_FIRST:\n                if(num_received > 0)\n                    return true;\n                if(num_suspected >= num_total)\n                // e.g. 2 members, and both suspected\n                    return true;\n                break;\n            case GET_ALL:\n                return num_received + num_suspected >= num_total;\n            case GET_MAJORITY:\n                int majority=determineMajority(num_total);\n                if(num_received + num_suspected >= majority)\n                    return true;\n                break;\n            case GET_ABS_MAJORITY:\n                majority=determineMajority(num_total);\n                if(num_received >= majority)\n                    return true;\n                break;\n            case GET_N:\n                return num_received >= expected_mbrs || num_received + num_not_received < expected_mbrs && num_received + num_suspected >= expected_mbrs;\n            case GET_NONE:\n                return true;\n            default :\n                if(log.isErrorEnabled()) log.error(\"rsp_mode \" + rsp_mode + \" unknown !\");\n                break;\n        }\n        return false;\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     @param timeout Time to wait for responses (ms). A value of <= 0 means wait indefinitely\n     (e.g. if a suspicion service is available; timeouts are not needed).\n     */\n    public GroupRequest(Message m, RequestCorrelator corr, Collection<Address> mbrs, int rsp_mode,\n                        long timeout, int expected_mbrs) {\n        super(m, corr, null, null, rsp_mode, timeout);\n        this.expected_mbrs=expected_mbrs;\n        setTargets(mbrs);\n    }","id":26916,"modified_method":"/**\n     @param timeout Time to wait for responses (ms). A value of <= 0 means wait indefinitely\n     (e.g. if a suspicion service is available; timeouts are not needed).\n     */\n    public GroupRequest(Message m, RequestCorrelator corr, Collection<Address> mbrs, int rsp_mode,\n                        long timeout, int expected_mbrs) {\n        super(m, corr, null, null, rsp_mode, timeout);\n        this.expected_mbrs=expected_mbrs;\n        int size=mbrs.size();\n        requests=new HashMap<Address,Rsp>(size);\n        setTargets(mbrs);\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendRequest(Vector<Address> targetMembers, long requestId,boolean use_anycasting) throws Exception {\n        try {\n            if(log.isTraceEnabled()) log.trace(new StringBuilder(\"sending request (id=\").append(req_id).append(')'));\n            if(corr != null) {                \n                corr.sendRequest(requestId, targetMembers, request_msg, rsp_mode == GET_NONE? null : this, use_anycasting);\n            }\n            else {\n                if(use_anycasting) {                                                          \n                    for(Address mbr: targetMembers) {\n                        Message copy=request_msg.copy(true);\n                        copy.setDest(mbr);\n                        transport.send(copy);\n                    }\n                }\n                else {\n                    transport.send(request_msg);\n                }\n            }\n        }\n        catch(Exception ex) {\n            if(corr != null)\n                corr.done(requestId);\n            throw ex;\n        }\n    }","id":26917,"modified_method":"private void sendRequest(final Collection<Address> targetMembers, long requestId,boolean use_anycasting) throws Exception {\n        try {\n            if(corr != null) {\n                corr.sendRequest(requestId, targetMembers, request_msg, rsp_mode == GET_NONE? null : this, use_anycasting);\n            }\n            else {\n                if(use_anycasting) {                                                          \n                    for(Address mbr: targetMembers) {\n                        Message copy=request_msg.copy(true);\n                        copy.setDest(mbr);\n                        transport.send(copy);\n                    }\n                }\n                else {\n                    transport.send(request_msg);\n                }\n            }\n        }\n        catch(Exception ex) {\n            if(corr != null)\n                corr.done(requestId);\n            throw ex;\n        }\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"void setTarget(Address mbr) {\n        if(mbr != null) {\n            requests.put(mbr, new Rsp(mbr));\n            this.members.clear();\n            this.members.add(mbr);\n        }\n    }","id":26918,"modified_method":"private void setTarget(Address mbr) {\n        requests.put(mbr, new Rsp(mbr));\n        num_not_received=1;\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * <b>Callback<\/b> (called by RequestCorrelator or Transport).\n     * Adds a response to the response table. When all responses have been received,\n     * <code>execute()<\/code> returns.\n     */\n    public void receiveResponse(Object response_value, Address sender) {\n        if(done)\n            return;\n\n        lock.lock();\n        try {\n            Rsp rsp=requests.get(sender);\n            if(rsp == null)\n                return;\n            if(!rsp.wasReceived()) {\n                boolean responseReceived =(rsp_filter == null) || rsp_filter.isAcceptable(response_value, sender);\n                rsp.setValue(response_value);\n                rsp.setReceived(responseReceived);\n                if(log.isTraceEnabled())\n                    log.trace(new StringBuilder(\"received response for request \").append(req_id)\n                            .append(\", sender=\").append(sender).append(\", val=\").append(response_value));\n            }\n            // done=rsp_filter != null && !rsp_filter.needMoreResponses();\n            done=rsp_filter == null? responsesComplete() : !rsp_filter.needMoreResponses();\n            if(done && corr != null)\n                corr.done(req_id);\n        }\n        finally {\n            completed.signalAll(); // wakes up execute()\n            lock.unlock();\n        }\n        checkCompletion(this);\n    }","id":26919,"modified_method":"/**\n     * <b>Callback<\/b> (called by RequestCorrelator or Transport).\n     * Adds a response to the response table. When all responses have been received,\n     * <code>execute()<\/code> returns.\n     */\n    public void receiveResponse(Object response_value, Address sender) {\n        if(done)\n            return;\n        Rsp rsp=requests.get(sender);\n        if(rsp == null)\n            return;\n\n        boolean responseReceived=false;\n        if(!rsp.wasReceived()) {\n            if((responseReceived=(rsp_filter == null) || rsp_filter.isAcceptable(response_value, sender)))\n                rsp.setValue(response_value);\n            rsp.setReceived(responseReceived);\n        }\n\n        lock.lock();\n        try {\n            if(responseReceived)\n                num_received++;\n            done=rsp_filter == null? responsesComplete() : !rsp_filter.needMoreResponses();\n            if(responseReceived || done)\n                completed.signalAll(); // wakes up execute()\n            if(done && corr != null)\n                corr.done(req_id);\n        }\n        finally {\n            lock.unlock();\n        }\n        if(responseReceived || done)\n            checkCompletion(this);\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * <b>Callback<\/b> (called by RequestCorrelator or Transport).\n     * Report to <code>GroupRequest<\/code> that a member is reported as faulty (suspected).\n     * This method would probably be called when getting a suspect message from a failure detector\n     * (where available). It is used to exclude faulty members from the response list.\n     */\n    public void suspect(Address suspected_member) {\n        if(suspected_member == null)\n            return;\n\n        lock.lock();\n        try {\n            addSuspect(suspected_member);\n            Rsp rsp=requests.get(suspected_member);\n            if(rsp != null) {\n                rsp.setSuspected(true);\n                rsp.setValue(null);\n                completed.signalAll();\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n        checkCompletion(this);\n    }","id":26920,"modified_method":"/**\n     * <b>Callback<\/b> (called by RequestCorrelator or Transport).\n     * Report to <code>GroupRequest<\/code> that a member is reported as faulty (suspected).\n     * This method would probably be called when getting a suspect message from a failure detector\n     * (where available). It is used to exclude faulty members from the response list.\n     */\n    public void suspect(Address suspected_member) {\n        if(suspected_member == null)\n            return;\n\n        boolean changed=false;\n        Rsp rsp=requests.get(suspected_member);\n        if(rsp !=  null) {\n            if(rsp.setSuspected(true)) {\n                rsp.setValue(null);\n                changed=true;\n                lock.lock();\n                try {\n                    num_suspected++;\n                    completed.signalAll();\n                }\n                finally {\n                    lock.unlock();\n                }\n            }\n        }\n\n        if(changed)\n            checkCompletion(this);\n    }","commit_id":"3b39bad6cee5880eda292cf769e5233ef3b41631","url":"https://github.com/belaban/JGroups"},{"original_method":"private Folder GetNextFolderItem() throws IOException {\n        int numCoders = this.inStream.ReadNum();\n        \n        Folder folder = new Folder();\n        folder.Coders.clear();\n        folder.Coders.ensureCapacity(numCoders);\n        int numInStreams = 0;\n        int numOutStreams = 0;\n        for (int i=0; i<numCoders; i++) {\n            folder.Coders.add(new CoderInfo());\n            CoderInfo coder = (CoderInfo)folder.Coders.lastElement();\n            int mainByte;\n            do {\n                AltCoderInfo altCoder = new AltCoderInfo();\n                coder.AltCoders.add(altCoder);\n                mainByte = this.inStream.ReadByte();\n                altCoder.MethodID.IDSize = (byte)(mainByte & 0xF);\n                if (!this.inStream.ReadBytes(altCoder.MethodID.ID, altCoder.MethodID.IDSize))\n                \tthrow new IOException(\"error reading properties for alternative decoder\");\n                \n                if ((mainByte & 0x10) != 0) {\n                    coder.NumInStreams = this.inStream.ReadNum();\n                    coder.NumOutStreams = this.inStream.ReadNum();\n                } else {\n                    coder.NumInStreams = 1;\n                    coder.NumOutStreams = 1;\n                }\n                if ((mainByte & 0x20) != 0) {\n                    int propertiesSize = this.inStream.ReadNum();\n                    if (!this.inStream.ReadBytes(altCoder.Properties, propertiesSize))\n                    \tthrow new IOException(\"error reading properties for alternative decoder\");\n                }\n            } while ((mainByte & 0x80) != 0);\n            numInStreams += coder.NumInStreams;\n            numOutStreams += coder.NumOutStreams;\n        }\n        \n        // RINOK(ReadNumber(numBindPairs));\n        int numBindPairs = numOutStreams - 1;\n        folder.BindPairs.clear();\n        folder.BindPairs.ensureCapacity(numBindPairs);\n        for (int i=0; i<numBindPairs; i++) {\n            BindPair bindPair = new BindPair();\n            bindPair.InIndex = this.inStream.ReadNum();\n            bindPair.OutIndex = this.inStream.ReadNum();\n            folder.BindPairs.add(bindPair);\n        }\n        \n        int numPackedStreams = numInStreams - numBindPairs;\n        folder.PackStreams.Reserve(numPackedStreams);\n        if (numPackedStreams == 1) {\n            for (int j=0; j<numInStreams; j++)\n                if (folder.FindBindPairForInStream(j) < 0) {\n                folder.PackStreams.add(j);\n                break;\n                }\n        } else {\n            for (int i=0; i<numPackedStreams; i++) {\n\t            int packStreamInfo = this.inStream.ReadNum();\n\t            folder.PackStreams.add(packStreamInfo);\n            }\n        }\n        \n        return folder;\n    }","id":26921,"modified_method":"private Folder GetNextFolderItem() throws IOException {\n        int numCoders = this.inStream.ReadNum();\n        \n        Folder folder = new Folder();\n        folder.Coders.clear();\n        folder.Coders.ensureCapacity(numCoders);\n        int numInStreams = 0;\n        int numOutStreams = 0;\n        for (int i=0; i<numCoders; i++) {\n            folder.Coders.add(new CoderInfo());\n            CoderInfo coder = folder.Coders.lastElement();\n            int mainByte;\n            do {\n                AltCoderInfo altCoder = new AltCoderInfo();\n                coder.AltCoders.add(altCoder);\n                mainByte = this.inStream.ReadByte();\n                altCoder.MethodID.IDSize = (byte)(mainByte & 0xF);\n                if (!this.inStream.ReadBytes(altCoder.MethodID.ID, altCoder.MethodID.IDSize))\n                \tthrow new IOException(\"error reading properties for alternative decoder\");\n                \n                if ((mainByte & 0x10) != 0) {\n                    coder.NumInStreams = this.inStream.ReadNum();\n                    coder.NumOutStreams = this.inStream.ReadNum();\n                } else {\n                    coder.NumInStreams = 1;\n                    coder.NumOutStreams = 1;\n                }\n                if ((mainByte & 0x20) != 0) {\n                    int propertiesSize = this.inStream.ReadNum();\n                    if (!this.inStream.ReadBytes(altCoder.Properties, propertiesSize))\n                    \tthrow new IOException(\"error reading properties for alternative decoder\");\n                }\n            } while ((mainByte & 0x80) != 0);\n            numInStreams += coder.NumInStreams;\n            numOutStreams += coder.NumOutStreams;\n        }\n        \n        // RINOK(ReadNumber(numBindPairs));\n        int numBindPairs = numOutStreams - 1;\n        folder.BindPairs.clear();\n        folder.BindPairs.ensureCapacity(numBindPairs);\n        for (int i=0; i<numBindPairs; i++) {\n            BindPair bindPair = new BindPair();\n            bindPair.InIndex = this.inStream.ReadNum();\n            bindPair.OutIndex = this.inStream.ReadNum();\n            folder.BindPairs.add(bindPair);\n        }\n        \n        int numPackedStreams = numInStreams - numBindPairs;\n        folder.PackStreams.Reserve(numPackedStreams);\n        if (numPackedStreams == 1) {\n            for (int j=0; j<numInStreams; j++)\n                if (folder.FindBindPairForInStream(j) < 0) {\n                folder.PackStreams.add(j);\n                break;\n                }\n        } else {\n            for (int i=0; i<numPackedStreams; i++) {\n\t            int packStreamInfo = this.inStream.ReadNum();\n\t            folder.PackStreams.add(packStreamInfo);\n            }\n        }\n        \n        return folder;\n    }","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private Vector ReadUnPackInfo(Vector dataVector) throws IOException {\n        this.inStream.skipToAttribute(Header.NID.kFolder);\n        \n        int numFolders = this.inStream.ReadNum();\n        \n        StreamSwitch streamSwitch = new StreamSwitch();\n        streamSwitch.Set(this.inStream, dataVector);\n        Vector folders = new Vector(numFolders);\n        for (int i=0; i<numFolders; i++)\n            folders.add(GetNextFolderItem());\n        streamSwitch.close();\n        \n        this.inStream.skipToAttribute(Header.NID.kCodersUnPackSize);\n        \n        for (int i=0; i<numFolders; i++) {\n            Folder folder = (Folder)folders.get(i);\n            int numOutStreams = folder.GetNumOutStreams();\n            folder.UnPackSizes.Reserve(numOutStreams);\n            for (int j=0; j<numOutStreams; j++) {\n                long unPackSize = this.inStream.ReadNumber();\n                folder.UnPackSizes.add(unPackSize);\n            }\n        }\n        \n        long type;\n        while ((type = this.inStream.ReadID()) != Header.NID.kEnd) {\n            if (type == Header.NID.kCRC) {\n                BoolVector crcsDefined = new BoolVector();\n                IntVector crcs = new IntVector();\n                crcs = this.inStream.ReadHashDigests(numFolders, crcsDefined);\n                for (int i=0; i<numFolders; i++) {\n                    Folder folder = (Folder)folders.get(i);\n                    folder.UnPackCRCDefined = crcsDefined.get(i);\n                    folder.UnPackCRC = crcs.get(i);\n                }\n                continue;\n            }\n            this.inStream.SkeepData();\n        }\n        return folders;\n    }","id":26922,"modified_method":"private Vector<Folder> ReadUnPackInfo(Vector dataVector) throws IOException {\n        this.inStream.skipToAttribute(Header.NID.kFolder);\n        \n        int numFolders = this.inStream.ReadNum();\n        \n        StreamSwitch streamSwitch = new StreamSwitch();\n        streamSwitch.Set(this.inStream, dataVector);\n        Vector<Folder> folders = new Vector(numFolders);\n        for (int i=0; i<numFolders; i++)\n            folders.add(GetNextFolderItem());\n        streamSwitch.close();\n        \n        this.inStream.skipToAttribute(Header.NID.kCodersUnPackSize);\n        \n        for (int i=0; i<numFolders; i++) {\n            Folder folder = folders.get(i);\n            int numOutStreams = folder.GetNumOutStreams();\n            folder.UnPackSizes.Reserve(numOutStreams);\n            for (int j=0; j<numOutStreams; j++) {\n                long unPackSize = this.inStream.ReadNumber();\n                folder.UnPackSizes.add(unPackSize);\n            }\n        }\n        \n        long type;\n        while ((type = this.inStream.ReadID()) != Header.NID.kEnd) {\n            if (type == Header.NID.kCRC) {\n                BoolVector crcsDefined = new BoolVector();\n                IntVector crcs = new IntVector();\n                crcs = this.inStream.ReadHashDigests(numFolders, crcsDefined);\n                for (int i=0; i<numFolders; i++) {\n                    Folder folder = folders.get(i);\n                    folder.UnPackCRCDefined = crcsDefined.get(i);\n                    folder.UnPackCRC = crcs.get(i);\n                }\n                continue;\n            }\n            this.inStream.SkeepData();\n        }\n        return folders;\n    }","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private Vector ReadAndDecodePackedStreams(long baseOffset, int dataStartPosIndex) throws IOException {\n        LongVector packSizes = new LongVector();\n        \n        BoolVector packCRCsDefined = new BoolVector();\n        IntVector packCRCs = new IntVector();\n        \n        long type = this.inStream.ReadID();\n        assert (type == Header.NID.kPackInfo);\n        this.ReadPackInfo(packSizes, packCRCsDefined, packCRCs, dataStartPosIndex);\n        \n        type = this.inStream.ReadID();\n        assert (type == Header.NID.kUnPackInfo);\n        Vector folders = ReadUnPackInfo(null);\n        \n        type = this.inStream.ReadID();\n        assert (type == Header.NID.kEnd);\n        \n        int packIndex = 0;\n        Decoder decoder = new Decoder(false); // _ST_MODE\n        \n        Vector dataVector = new Vector();\n        long dataStartPos = baseOffset + ((dataStartPosIndex == 0) ?\n        \t\tthis.ArchiveInfo.DataStartPosition : this.ArchiveInfo.DataStartPosition2);\n        for(int i=0; i<folders.size(); i++) {\n            Folder folder = (Folder)folders.get(i);\n            long unPackSize = folder.GetUnPackSize();\n            if (unPackSize > InStream.kNumMax || unPackSize > 0xFFFFFFFFL)\n                throw new IOException(\"unPackSize too great: \" + unPackSize);\n            \n            ByteArrayOutputStream baos = new ByteArrayOutputStream((int)unPackSize);\n            decoder.Decode(\n            \t\tthis.inStream.stream, dataStartPos,\n                    packSizes, packIndex,\n                    folder, baos, null);\n            byte[] data; // TODO: stream belassen!\n            dataVector.add(data = baos.toByteArray());\n            \n            if (folder.UnPackCRCDefined)\n                if (!CRC.VerifyDigest(folder.UnPackCRC, data, (int)unPackSize))\n                    throw new IOException(\"Incorrect Header, CRCs of packed folder don't match: archive: \" +\n                    \t\tInteger.toHexString(folder.UnPackCRC) + \", calculated: \" +\n                    \t\tInteger.toHexString(CRC.CalculateDigest(data, (int)unPackSize)) +\n                    \t\t\". Either is the archive corrupted or an internal error occured\");\n            \n            for (int j = 0; j < folder.PackStreams.size(); j++)\n                dataStartPos += packSizes.get(packIndex++);\n        }\n        \n        return dataVector;\n    }","id":26923,"modified_method":"private Vector ReadAndDecodePackedStreams(long baseOffset, int dataStartPosIndex) throws IOException {\n        LongVector packSizes = new LongVector();\n        \n        BoolVector packCRCsDefined = new BoolVector();\n        IntVector packCRCs = new IntVector();\n        \n        long type = this.inStream.ReadID();\n        assert (type == Header.NID.kPackInfo);\n        this.ReadPackInfo(packSizes, packCRCsDefined, packCRCs, dataStartPosIndex);\n        \n        type = this.inStream.ReadID();\n        assert (type == Header.NID.kUnPackInfo);\n        Vector<Folder> folders = ReadUnPackInfo(null);\n        \n        type = this.inStream.ReadID();\n        assert (type == Header.NID.kEnd);\n        \n        int packIndex = 0;\n        Decoder decoder = new Decoder(false); // _ST_MODE\n        \n        Vector dataVector = new Vector();\n        long dataStartPos = baseOffset + ((dataStartPosIndex == 0) ?\n        \t\tthis.ArchiveInfo.DataStartPosition : this.ArchiveInfo.DataStartPosition2);\n        for(int i=0; i<folders.size(); i++) {\n            Folder folder = (Folder)folders.get(i);\n            long unPackSize = folder.GetUnPackSize();\n            if (unPackSize > InStream.kNumMax || unPackSize > 0xFFFFFFFFL)\n                throw new IOException(\"unPackSize too great: \" + unPackSize);\n            \n            ByteArrayOutputStream baos = new ByteArrayOutputStream((int)unPackSize);\n            decoder.Decode(\n            \t\tthis.inStream.stream, dataStartPos,\n                    packSizes, packIndex,\n                    folder, baos, null);\n            byte[] data; // TODO: stream belassen!\n            dataVector.add(data = baos.toByteArray());\n            \n            if (folder.UnPackCRCDefined)\n                if (!CRC.VerifyDigest(folder.UnPackCRC, data, (int)unPackSize))\n                    throw new IOException(\"Incorrect Header, CRCs of packed folder don't match: archive: \" +\n                    \t\tInteger.toHexString(folder.UnPackCRC) + \", calculated: \" +\n                    \t\tInteger.toHexString(CRC.CalculateDigest(data, (int)unPackSize)) +\n                    \t\t\". Either is the archive corrupted or an internal error occured\");\n            \n            for (int j = 0; j < folder.PackStreams.size(); j++)\n                dataStartPos += packSizes.get(packIndex++);\n        }\n        \n        return dataVector;\n    }","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void ReadSubStreamsInfo(\n            Vector folders,\n            IntVector numUnPackStreamsInFolders,\n            LongVector unPackSizes,\n            BoolVector digestsDefined,\n            IntVector digests)  throws IOException {\n        numUnPackStreamsInFolders.clear();\n        numUnPackStreamsInFolders.Reserve(folders.size());\n        long type;\n        \n        while ((type = this.inStream.ReadID()) != Header.NID.kCRC &&\n        \t\ttype != Header.NID.kSize &&\n        \t\ttype != Header.NID.kEnd) {\n            if (type == Header.NID.kNumUnPackStream) {\n                for(int i = 0; i < folders.size(); i++) {\n                    int value = this.inStream.ReadNum();\n                    numUnPackStreamsInFolders.add(value);\n                }\n                continue;\n            }\n            this.inStream.SkeepData();\n        }\n        \n        if (numUnPackStreamsInFolders.isEmpty())\n            for (int i=0; i<folders.size(); i++)\n                numUnPackStreamsInFolders.add(1);\n        \n        final ArrayList sizes = new ArrayList();\n        int numSubstreams;\n        long sum, size;\n        for (int i=0; i<numUnPackStreamsInFolders.size(); i++) {\n        \tnumSubstreams = numUnPackStreamsInFolders.get(i);\n        \tif (numSubstreams < 1) continue;\n        \tsum = 0;\n        \tif (type == Header.NID.kSize)\n        \t\tfor (int j=1; j<numSubstreams; j++) {\n\t        \t\tsum += size = this.inStream.ReadNumber();\n\t        \t\tsizes.add(new Long(size));\n        \t\t}\n        \tsizes.add(new Long((((Folder)folders.get(i)).GetUnPackSize() - sum)));\n        }\n        unPackSizes.addAll(sizes);\n        sizes.clear();\n        \n        if (type == Header.NID.kSize)\n            type = this.inStream.ReadID();\n        \n        int numDigests = 0;\n        int numDigestsTotal = 0;\n        for(int i = 0; i < folders.size(); i++) {\n            numSubstreams = numUnPackStreamsInFolders.get(i);\n            if (numSubstreams != 1 || !((Folder)folders.get(i)).UnPackCRCDefined)\n                numDigests += numSubstreams;\n            numDigestsTotal += numSubstreams;\n        }\n        \n        final ArrayList bsizes = new ArrayList();\n        do {\n            if (type == Header.NID.kCRC) {\n                BoolVector digestsDefined2 = new BoolVector();\n                IntVector digests2 = new IntVector();\n                digests2 = this.inStream.ReadHashDigests(numDigests, digestsDefined2);\n                int digestIndex = 0;\n                \n                for (int i=0; i<folders.size(); i++) {\n                \tnumSubstreams = numUnPackStreamsInFolders.get(i);\n                \tFolder folder = (Folder)folders.get(i);\n                \tif (numSubstreams == 1 && folder.UnPackCRCDefined) {\n                \t\tbsizes.add(Boolean.TRUE);\n                \t\tsizes.add(new Integer(folder.UnPackCRC));\n                \t} else {\n                \t\tfor (int j=0; j<numSubstreams; j++, digestIndex++) {\n                \t\t\tbsizes.add(new Boolean(digestsDefined2.get(digestIndex)));\n                \t\t\tsizes.add(new Integer(digests2.get(digestIndex)));\n                \t\t}\n                \t}\n                }\n                digestsDefined.addAll(bsizes);\n                bsizes.clear();\n                digests.addAll(sizes);\n                sizes.clear();\n            } else {\n            \tthis.inStream.SkeepData();\n            }\n        } while ((type = this.inStream.ReadID()) != Header.NID.kEnd);\n        \n        if (digestsDefined.isEmpty()) {\n            digests.clear();\n            for (int i=0; i<numDigestsTotal; i++) {\n                digestsDefined.add(false);\n                digests.add(0);\n            }\n        }\n    }","id":26924,"modified_method":"private void ReadSubStreamsInfo(\n            Vector<Folder> folders,\n            IntVector numUnPackStreamsInFolders,\n            LongVector unPackSizes,\n            BoolVector digestsDefined,\n            IntVector digests)  throws IOException {\n        numUnPackStreamsInFolders.clear();\n        numUnPackStreamsInFolders.Reserve(folders.size());\n        long type;\n        \n        while ((type = this.inStream.ReadID()) != Header.NID.kCRC &&\n        \t\ttype != Header.NID.kSize &&\n        \t\ttype != Header.NID.kEnd) {\n            if (type == Header.NID.kNumUnPackStream) {\n                for(int i = 0; i < folders.size(); i++) {\n                    int value = this.inStream.ReadNum();\n                    numUnPackStreamsInFolders.add(value);\n                }\n                continue;\n            }\n            this.inStream.SkeepData();\n        }\n        \n        if (numUnPackStreamsInFolders.isEmpty())\n            for (int i=0; i<folders.size(); i++)\n                numUnPackStreamsInFolders.add(1);\n        \n        final ArrayList sizes = new ArrayList();\n        int numSubstreams;\n        long sum, size;\n        for (int i=0; i<numUnPackStreamsInFolders.size(); i++) {\n        \tnumSubstreams = numUnPackStreamsInFolders.get(i);\n        \tif (numSubstreams < 1) continue;\n        \tsum = 0;\n        \tif (type == Header.NID.kSize)\n        \t\tfor (int j=1; j<numSubstreams; j++) {\n\t        \t\tsum += size = this.inStream.ReadNumber();\n\t        \t\tsizes.add(new Long(size));\n        \t\t}\n        \tsizes.add(new Long((((Folder)folders.get(i)).GetUnPackSize() - sum)));\n        }\n        unPackSizes.addAll(sizes);\n        sizes.clear();\n        \n        if (type == Header.NID.kSize)\n            type = this.inStream.ReadID();\n        \n        int numDigests = 0;\n        int numDigestsTotal = 0;\n        for(int i = 0; i < folders.size(); i++) {\n            numSubstreams = numUnPackStreamsInFolders.get(i);\n            if (numSubstreams != 1 || !((Folder)folders.get(i)).UnPackCRCDefined)\n                numDigests += numSubstreams;\n            numDigestsTotal += numSubstreams;\n        }\n        \n        final ArrayList bsizes = new ArrayList();\n        do {\n            if (type == Header.NID.kCRC) {\n                BoolVector digestsDefined2 = new BoolVector();\n                IntVector digests2 = new IntVector();\n                digests2 = this.inStream.ReadHashDigests(numDigests, digestsDefined2);\n                int digestIndex = 0;\n                \n                for (int i=0; i<folders.size(); i++) {\n                \tnumSubstreams = numUnPackStreamsInFolders.get(i);\n                \tFolder folder = (Folder)folders.get(i);\n                \tif (numSubstreams == 1 && folder.UnPackCRCDefined) {\n                \t\tbsizes.add(Boolean.TRUE);\n                \t\tsizes.add(new Integer(folder.UnPackCRC));\n                \t} else {\n                \t\tfor (int j=0; j<numSubstreams; j++, digestIndex++) {\n                \t\t\tbsizes.add(new Boolean(digestsDefined2.get(digestIndex)));\n                \t\t\tsizes.add(new Integer(digests2.get(digestIndex)));\n                \t\t}\n                \t}\n                }\n                digestsDefined.addAll(bsizes);\n                bsizes.clear();\n                digests.addAll(sizes);\n                sizes.clear();\n            } else {\n            \tthis.inStream.SkeepData();\n            }\n        } while ((type = this.inStream.ReadID()) != Header.NID.kEnd);\n        \n        if (digestsDefined.isEmpty()) {\n            digests.clear();\n            for (int i=0; i<numDigestsTotal; i++) {\n                digestsDefined.add(false);\n                digests.add(0);\n            }\n        }\n    }","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"void CodeReal(\r\n            Vector inStreams,\r\n            Object useless1, // const UInt64 ** /* inSizes */,\r\n            int numInStreams,\r\n            Vector outStreams,\r\n            Object useless2, // const UInt64 ** /* outSizes */,\r\n            int numOutStreams,\r\n            ICompressProgressInfo progress) throws java.io.IOException {\r\n        \r\n        if (numInStreams != 4 || numOutStreams != 1)\r\n            throw new IllegalArgumentException(\"numInStreams != 4 || numOutStreams != 1\");\r\n        \r\n        _mainInStream.Create(1 << 16);\r\n        _callStream.Create(1 << 20);\r\n        _jumpStream.Create(1 << 16);\r\n        _rangeDecoder.Create(1 << 20);\r\n        _outStream.Create(1 << 16);\r\n        \r\n        _mainInStream.SetStream((InputStream)inStreams.get(0));\r\n        _callStream.SetStream((InputStream)inStreams.get(1));\r\n        _jumpStream.SetStream((InputStream)inStreams.get(2));\r\n        _rangeDecoder.SetStream((InputStream)inStreams.get(3));\r\n        _outStream.SetStream((OutputStream)outStreams.get(0));\r\n        \r\n        _mainInStream.Init();\r\n        _callStream.Init();\r\n        _jumpStream.Init();\r\n        _rangeDecoder.Init();\r\n        _outStream.Init();\r\n        \r\n        for (int i = 0; i < 256; i++) {\r\n            _statusE8Decoder[i] = new SevenZip.Compression.RangeCoder.BitDecoder(kNumMoveBits);\r\n            _statusE8Decoder[i].Init();\r\n        }\r\n        _statusE9Decoder.Init();\r\n        _statusJccDecoder.Init();\r\n        \r\n        int prevByte = 0;\r\n        int processedBytes = 0;\r\n        for (;;) {\r\n            \r\n            if (processedBytes > (1 << 20) && progress != null) {\r\n                long nowPos64 = _outStream.GetProcessedSize();\r\n                progress.SetRatioInfo(ICompressProgressInfo.INVALID, nowPos64);\r\n                processedBytes = 0;\r\n            }\r\n            \r\n            processedBytes++;\r\n            int b = _mainInStream.read();\r\n            if (b == -1) {\r\n                Flush();\r\n                return;\r\n            }\r\n            _outStream.WriteByte(b); // System.out.println(\"0:\"+b);\r\n            // if ((b != 0xE8) && (b != 0xE9) && (!IsJcc(prevByte, b))) {\r\n            if ((b != 0xE8) && (b != 0xE9) && (!((prevByte == 0x0F) && ((b & 0xF0) == 0x80)))) {\r\n                prevByte = b;\r\n                continue;\r\n            }\r\n            \r\n            boolean status;\r\n            if (b == 0xE8)\r\n                status = (_statusE8Decoder[prevByte].Decode(_rangeDecoder) == 1);\r\n            else if (b == 0xE9)\r\n                status = (_statusE9Decoder.Decode(_rangeDecoder) == 1);\r\n            else\r\n                status = (_statusJccDecoder.Decode(_rangeDecoder) == 1);\r\n            \r\n            if (status) {\r\n                int src;\r\n                if (b == 0xE8) {\r\n                    int b0 = _callStream.read();\r\n                    // if(b0 == -1) return HRESULT.S_FALSE;\r\n                    src = ((int)b0) << 24;\r\n                    \r\n                    b0 = _callStream.read();\r\n                    // if(b0 == -1) return HRESULT.S_FALSE;\r\n                    src |= ((int)b0) << 16;\r\n                    \r\n                    b0 = _callStream.read();\r\n                    // if(b0 == -1) return HRESULT.S_FALSE;\r\n                    src |= ((int)b0) << 8;\r\n                    \r\n                    b0 = _callStream.read();\r\n                    if (b0 == -1) return; // TODO: HRESULT.S_FALSE;\r\n                    src |= ((int)b0);\r\n                    \r\n                } else {\r\n                    int b0 = _jumpStream.read();\r\n                    // if(b0 == -1) return HRESULT.S_FALSE;\r\n                    src = ((int)b0) << 24;\r\n                    \r\n                    b0 = _jumpStream.read();\r\n                    // if(b0 == -1) return HRESULT.S_FALSE;\r\n                    src |= ((int)b0) << 16;\r\n                    \r\n                    b0 = _jumpStream.read();\r\n                    // if(b0 == -1) return HRESULT.S_FALSE;\r\n                    src |= ((int)b0) << 8;\r\n                    \r\n                    b0 = _jumpStream.read();\r\n                    if(b0 == -1) return; // TODO: HRESULT.S_FALSE;\r\n                    src |= ((int)b0);\r\n                    \r\n                }\r\n                int dest = src - ((int)_outStream.GetProcessedSize() + 4) ;\r\n                _outStream.WriteByte(dest);\r\n                _outStream.WriteByte((dest >> 8));\r\n                _outStream.WriteByte((dest >> 16));\r\n                _outStream.WriteByte((dest >> 24));\r\n                prevByte = (int)(dest >> 24) & 0xFF;\r\n                processedBytes += 4;\r\n            } else\r\n                prevByte = b;\r\n        }\r\n    }","id":26925,"modified_method":"void CodeReal(\r\n            Vector<InputStream> inStreams,\r\n            //Object useless1, // const UInt64 ** /* inSizes */,\r\n            int numInStreams,\r\n            Vector<OutputStream> outStreams,\r\n            //Object useless2, // const UInt64 ** /* outSizes */,\r\n            int numOutStreams,\r\n            ICompressProgressInfo progress) throws java.io.IOException {\r\n        \r\n        if (numInStreams != 4 || numOutStreams != 1)\r\n            throw new IllegalArgumentException(\"numInStreams != 4 || numOutStreams != 1\");\r\n        \r\n        _mainInStream.Create(1 << 16);\r\n        _callStream.Create(1 << 20);\r\n        _jumpStream.Create(1 << 16);\r\n        _rangeDecoder.Create(1 << 20);\r\n        _outStream.Create(1 << 16);\r\n        \r\n        _mainInStream.SetStream(inStreams.get(0));\r\n        _callStream.SetStream(inStreams.get(1));\r\n        _jumpStream.SetStream(inStreams.get(2));\r\n        _rangeDecoder.SetStream(inStreams.get(3));\r\n        _outStream.SetStream(outStreams.get(0));\r\n        \r\n        _mainInStream.Init();\r\n        _callStream.Init();\r\n        _jumpStream.Init();\r\n        _rangeDecoder.Init();\r\n        _outStream.Init();\r\n        \r\n        for (int i = 0; i < 256; i++) {\r\n            _statusE8Decoder[i] = new SevenZip.Compression.RangeCoder.BitDecoder(kNumMoveBits);\r\n            _statusE8Decoder[i].Init();\r\n        }\r\n        _statusE9Decoder.Init();\r\n        _statusJccDecoder.Init();\r\n        \r\n        int prevByte = 0;\r\n        int processedBytes = 0;\r\n        for (;;) {\r\n            \r\n            if (processedBytes > (1 << 20) && progress != null) {\r\n                long nowPos64 = _outStream.GetProcessedSize();\r\n                progress.SetRatioInfo(ICompressProgressInfo.INVALID, nowPos64);\r\n                processedBytes = 0;\r\n            }\r\n            \r\n            processedBytes++;\r\n            int b = _mainInStream.read();\r\n            if (b == -1) {\r\n                Flush();\r\n                return;\r\n            }\r\n            _outStream.WriteByte(b); // System.out.println(\"0:\"+b);\r\n            // if ((b != 0xE8) && (b != 0xE9) && (!IsJcc(prevByte, b))) {\r\n            if ((b != 0xE8) && (b != 0xE9) && (!((prevByte == 0x0F) && ((b & 0xF0) == 0x80)))) {\r\n                prevByte = b;\r\n                continue;\r\n            }\r\n            \r\n            boolean status;\r\n            if (b == 0xE8)\r\n                status = (_statusE8Decoder[prevByte].Decode(_rangeDecoder) == 1);\r\n            else if (b == 0xE9)\r\n                status = (_statusE9Decoder.Decode(_rangeDecoder) == 1);\r\n            else\r\n                status = (_statusJccDecoder.Decode(_rangeDecoder) == 1);\r\n            \r\n            if (status) {\r\n                int src;\r\n                if (b == 0xE8) {\r\n                    int b0 = _callStream.read();\r\n                    // if(b0 == -1) return HRESULT.S_FALSE;\r\n                    src = ((int)b0) << 24;\r\n                    \r\n                    b0 = _callStream.read();\r\n                    // if(b0 == -1) return HRESULT.S_FALSE;\r\n                    src |= ((int)b0) << 16;\r\n                    \r\n                    b0 = _callStream.read();\r\n                    // if(b0 == -1) return HRESULT.S_FALSE;\r\n                    src |= ((int)b0) << 8;\r\n                    \r\n                    b0 = _callStream.read();\r\n                    if (b0 == -1) return; // TODO: HRESULT.S_FALSE;\r\n                    src |= ((int)b0);\r\n                    \r\n                } else {\r\n                    int b0 = _jumpStream.read();\r\n                    // if(b0 == -1) return HRESULT.S_FALSE;\r\n                    src = ((int)b0) << 24;\r\n                    \r\n                    b0 = _jumpStream.read();\r\n                    // if(b0 == -1) return HRESULT.S_FALSE;\r\n                    src |= ((int)b0) << 16;\r\n                    \r\n                    b0 = _jumpStream.read();\r\n                    // if(b0 == -1) return HRESULT.S_FALSE;\r\n                    src |= ((int)b0) << 8;\r\n                    \r\n                    b0 = _jumpStream.read();\r\n                    if(b0 == -1) return; // TODO: HRESULT.S_FALSE;\r\n                    src |= ((int)b0);\r\n                    \r\n                }\r\n                int dest = src - ((int)_outStream.GetProcessedSize() + 4) ;\r\n                _outStream.WriteByte(dest);\r\n                _outStream.WriteByte((dest >> 8));\r\n                _outStream.WriteByte((dest >> 16));\r\n                _outStream.WriteByte((dest >> 24));\r\n                prevByte = (int)(dest >> 24) & 0xFF;\r\n                processedBytes += 4;\r\n            } else\r\n                prevByte = b;\r\n        }\r\n    }","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void Code(\r\n            Vector inStreams, // ISequentialInStream **inStreams,\r\n            Object useless_inSizes, // const UInt64 ** /* inSizes */,\r\n            int numInStreams,\r\n            Vector outStreams, // ISequentialOutStream **outStreams\r\n            Object useless_outSizes, // const UInt64 ** /* outSizes */,\r\n            int numOutStreams,\r\n            ICompressProgressInfo progress) throws java.io.IOException {\r\n        \r\n        try {\r\n            CodeReal(inStreams, useless_inSizes, numInStreams,\r\n                    outStreams, useless_outSizes,numOutStreams, progress);\r\n        } catch(java.io.IOException e) {\r\n            throw e;\r\n        } finally {\r\n            ReleaseStreams();\r\n        }\r\n    }","id":26926,"modified_method":"public void Code(\r\n            Vector<InputStream> inStreams, // ISequentialInStream **inStreams,\r\n            //Object useless_inSizes, // const UInt64 ** /* inSizes */,\r\n            int numInStreams,\r\n            Vector<OutputStream> outStreams, // ISequentialOutStream **outStreams\r\n            //Object useless_outSizes, // const UInt64 ** /* outSizes */,\r\n            int numOutStreams,\r\n            ICompressProgressInfo progress) throws java.io.IOException {\r\n        \r\n        try {\r\n            CodeReal(inStreams, /*useless_inSizes,*/ numInStreams,\r\n                    outStreams, /*useless_outSizes,*/ numOutStreams, progress);\r\n        } catch(java.io.IOException e) {\r\n            throw e;\r\n        } finally {\r\n            ReleaseStreams();\r\n        }\r\n    }","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void Code(\r\n\t\t\tVector inStreams,\r\n\t\t\tObject useless_inSizes, // const UInt64 ** inSizes ,\r\n\t\t\tint numInStreams,\r\n\t\t\tVector outStreams,\r\n\t\t\tObject useless_outSizes, // const UInt64 ** /* outSizes */,\r\n\t\t\tint numOutStreams,\r\n\t\t\tICompressProgressInfo progress) throws IOException {\r\n\t\tif (numInStreams != bindInfo.InStreams.size() || numOutStreams != bindInfo.OutStreams.size())\r\n\t\t\tthrow new IllegalArgumentException(\"internal error: numInStreams != _bindInfo.InStreams.size() || numOutStreams != _bindInfo.OutStreams.size()\");\r\n\t\t\r\n\t\t// Find main coder\r\n\t\tint mainCoderIndex = -1;\r\n\t\tfor (int i=0; i<coders.size(); i++)\r\n\t\t\tif (((STCoderInfo)coders.get(i)).IsMain) {\r\n\t\t\t\tmainCoderIndex = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\r\n\t\tif (mainCoderIndex < 0)\r\n\t\t\tfor (int i=0; i<coders.size(); i++)\r\n\t\t\t\tif (((STCoderInfo)coders.get(i)).NumInStreams > 1) {\r\n\t\t\t\t\tif (mainCoderIndex >= 0) // TODO: description, what exactly is not implemented\r\n\t\t\t\t\t\tthrow new IOException(\"not implemented\");\r\n\t\t\t\t\tmainCoderIndex = i;\r\n\t\t\t\t}\r\n\t\t\r\n\t\tif (mainCoderIndex < 0)\r\n\t\t\tmainCoderIndex = 0;\r\n\t\t\r\n\t\t// _mainCoderIndex = 0;\r\n\t\t// _mainCoderIndex = _coders.Size() - 1;\r\n\t\tCoderInfo mainCoder = (STCoderInfo)coders.get(mainCoderIndex);\r\n\t\t\r\n\t\tVector seqInStreams = new Vector(); // CObjectVector< CMyComPtr<ISequentialInStream> >\r\n\t\tint startInIndex = bindInfo.GetCoderInStreamIndex(mainCoderIndex);\r\n\t\tfor (int i=0; i<mainCoder.NumInStreams; i++)\r\n\t\t\tfor (int j=0; j<bindInfo.InStreams.size(); j++)\r\n\t\t\t\tif (bindInfo.InStreams.get(j) == startInIndex + i)\r\n\t\t\t\t\tseqInStreams.add(inStreams.get(j));\r\n\t\t\r\n\t\tVector seqOutStreams = new Vector(); // CObjectVector< CMyComPtr<ISequentialOutStream> >\r\n\t\tint startOutIndex = bindInfo.GetCoderOutStreamIndex(mainCoderIndex);\r\n\t\tfor (int i=0; i<mainCoder.NumOutStreams; i++)\r\n\t\t\tfor (int j=0; j<bindInfo.OutStreams.size(); j++)\r\n\t\t\t\tif (bindInfo.OutStreams.get(j) == startOutIndex + i)\r\n\t\t\t\t\tseqOutStreams.add(outStreams.get(j));\r\n\t\t\r\n\t\tfor (int i=0; i<coders.size(); i++) {\r\n\t\t\tif (i == mainCoderIndex) continue;\r\n\t\t\tCoderInfo coder = (STCoderInfo)coders.get(i);\r\n\t\t\t((ICompressSetOutStreamSize)coder.Coder).SetOutStreamSize(coder.OutSizePointers.Front());\r\n\t\t}\r\n\t\t\r\n\t\tif (mainCoder.Coder != null) {\r\n\t\t\tmainCoder.Coder.Code(\r\n\t\t\t\t\t(InputStream)seqInStreams.firstElement(),\r\n\t\t\t\t\t(OutputStream)seqOutStreams.firstElement(),\r\n\t\t\t\t\tmainCoder.OutSizePointers.Front(),\r\n\t\t\t\t\tprogress);\r\n\t\t} else {\r\n\t\t\tmainCoder.Coder2.Code(\r\n\t\t\t\t\tseqInStreams,\r\n\t\t\t\t\tnew Long(mainCoder.InSizePointers.Front()),\r\n\t\t\t\t\tmainCoder.NumInStreams,\r\n\t\t\t\t\tseqOutStreams,\r\n\t\t\t\t\tnew Long(mainCoder.OutSizePointers.Front()),\r\n\t\t\t\t\tmainCoder.NumOutStreams,\r\n\t\t\t\t\tprogress);\r\n\t\t}\r\n\t\t\r\n\t\tOutputStream stream = (OutputStream)seqOutStreams.firstElement();\r\n\t\tif (stream != null) stream.flush();\r\n\t}","id":26927,"modified_method":"public void Code(\r\n\t\t\tVector<InputStream> inStreams,\r\n\t\t\t//Object useless_inSizes, // const UInt64 ** inSizes ,\r\n\t\t\tint numInStreams,\r\n\t\t\tVector<OutputStream> outStreams,\r\n\t\t\t//Object useless_outSizes, // const UInt64 ** /* outSizes */,\r\n\t\t\tint numOutStreams,\r\n\t\t\tICompressProgressInfo progress) throws IOException {\r\n\t\tif (numInStreams != bindInfo.InStreams.size() || numOutStreams != bindInfo.OutStreams.size())\r\n\t\t\tthrow new IllegalArgumentException(\"internal error: numInStreams != _bindInfo.InStreams.size() || numOutStreams != _bindInfo.OutStreams.size()\");\r\n\t\t\r\n\t\t// Find main coder\r\n\t\tint mainCoderIndex = -1;\r\n\t\tfor (int i=0; i<coders.size(); i++)\r\n\t\t\tif ((coders.get(i)).IsMain) {\r\n\t\t\t\tmainCoderIndex = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\r\n\t\tif (mainCoderIndex < 0)\r\n\t\t\tfor (int i=0; i<coders.size(); i++)\r\n\t\t\t\tif ((coders.get(i)).NumInStreams > 1) {\r\n\t\t\t\t\tif (mainCoderIndex >= 0) // TODO: description, what exactly is not implemented\r\n\t\t\t\t\t\tthrow new IOException(\"not implemented\");\r\n\t\t\t\t\tmainCoderIndex = i;\r\n\t\t\t\t}\r\n\t\t\r\n\t\tif (mainCoderIndex < 0)\r\n\t\t\tmainCoderIndex = 0;\r\n\t\t\r\n\t\t// _mainCoderIndex = 0;\r\n\t\t// _mainCoderIndex = _coders.Size() - 1;\r\n\t\tCoderInfo mainCoder = coders.get(mainCoderIndex);\r\n\r\n\t\tVector<InputStream> seqInStreams = new Vector(); // CObjectVector< CMyComPtr<ISequentialInStream> >\r\n\t\tint startInIndex = bindInfo.GetCoderInStreamIndex(mainCoderIndex);\r\n\r\n        // this original (from J7Zip 4.43a) replaces blows loop, as with LZMA BCJ2 format seqInStreams.size() is incorrect (array out of index) with modified code\r\n        for (int i = 0; i < (int)mainCoder.NumInStreams; i++) {\r\n            java.io.InputStream tmp [] = new  java.io.InputStream[1];\r\n            int res = GetInStream(inStreams, /*useless_inSizes,*/ startInIndex + i, tmp /* &seqInStream */ );\r\n            if (res != HRESULT.S_OK) return;\r\n            java.io.InputStream seqInStream = tmp[0];\r\n            seqInStreams.add(seqInStream);\r\n        }\r\n        /* --- replaced by above ---\r\n\t\tfor (int i=0; i<mainCoder.NumInStreams; i++)\r\n\t\t\tfor (int j=0; j<bindInfo.InStreams.size(); j++)\r\n\t\t\t\tif (bindInfo.InStreams.get(j) == startInIndex + i)\r\n\t\t\t\t\tseqInStreams.add(inStreams.get(j));\r\n\t*/\r\n\t\tVector<OutputStream> seqOutStreams = new Vector(); // CObjectVector< CMyComPtr<ISequentialOutStream> >\r\n\t\tint startOutIndex = bindInfo.GetCoderOutStreamIndex(mainCoderIndex);\r\n\t\tfor (int i=0; i<mainCoder.NumOutStreams; i++)\r\n\t\t\tfor (int j=0; j<bindInfo.OutStreams.size(); j++)\r\n\t\t\t\tif (bindInfo.OutStreams.get(j) == startOutIndex + i)\r\n\t\t\t\t\tseqOutStreams.add(outStreams.get(j));\r\n\t\t\r\n\t\tfor (int i=0; i<coders.size(); i++) {\r\n\t\t\tif (i == mainCoderIndex) continue;\r\n\t\t\tCoderInfo coder = coders.get(i);\r\n\t\t\t((ICompressSetOutStreamSize)coder.Coder).SetOutStreamSize(coder.OutSizePointers.Front());\r\n\t\t}\r\n\t\t\r\n\t\tif (mainCoder.Coder != null) {\r\n\t\t\tmainCoder.Coder.Code(\r\n\t\t\t\t\tseqInStreams.firstElement(),\r\n\t\t\t\t\tseqOutStreams.firstElement(),\r\n\t\t\t\t\tmainCoder.OutSizePointers.Front(),\r\n\t\t\t\t\tprogress);\r\n\t\t} else {\r\n\t\t\tmainCoder.Coder2.Code(\r\n\t\t\t\t\tseqInStreams,\r\n\t\t\t\t\t//new Long(mainCoder.InSizePointers.Front()),\r\n\t\t\t\t\tmainCoder.NumInStreams,\r\n\t\t\t\t\tseqOutStreams,\r\n\t\t\t\t\t//new Long(mainCoder.OutSizePointers.Front()),\r\n\t\t\t\t\tmainCoder.NumOutStreams,\r\n\t\t\t\t\tprogress);\r\n\t\t}\r\n\t\t\r\n\t\tOutputStream stream = seqOutStreams.firstElement();\r\n\t\tif (stream != null) stream.flush();\r\n\t}","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public OutputStream GetOutStream(\r\n\t\t\tVector outStreams,\r\n\t\t\t// Object useless_outSizes, //  const UInt64 **outSizes,\r\n\t\t\tint streamIndex) {\r\n\t\treturn null;\r\n\t}","id":26928,"modified_method":"public int GetInStream(\r\n            Vector<InputStream> inStreams,\r\n            //Object useless_inSizes, // const UInt64 **inSizes,\r\n            int streamIndex,\r\n            InputStream [] inStreamRes) {\r\n        java.io.InputStream seqInStream;\r\n        int i;\r\n        for(i = 0; i < bindInfo.InStreams.size(); i++)\r\n            if (bindInfo.InStreams.get(i) == streamIndex) {\r\n            seqInStream = inStreams.get(i);\r\n            inStreamRes[0] = seqInStream; // seqInStream.Detach();\r\n            return  HRESULT.S_OK;\r\n            }\r\n        int binderIndex = bindInfo.FindBinderForInStream(streamIndex);\r\n        if (binderIndex < 0)\r\n            return HRESULT.E_INVALIDARG;\r\n\r\n\r\n        int tmp1[] = new int[2]; // TBD\r\n        //int tmp2 [] = new int[1]; // TBD\r\n        tmp1 = bindInfo.FindOutStream(bindInfo.BindPairs.get(binderIndex).OutIndex);\r\n               // , tmp1 /* coderIndex */ , tmp2 /* coderStreamIndex */ );\r\n        int coderIndex = tmp1[0], coderStreamIndex = tmp1[0];\r\n\r\n        CoderInfo coder = coders.get(coderIndex);\r\n        if (coder.Coder == null)\r\n            return HRESULT.E_NOTIMPL;\r\n\r\n        seqInStream = (java.io.InputStream)coder.Coder; // coder.Coder.QueryInterface(IID_ISequentialInStream, &seqInStream);\r\n        if (seqInStream == null)\r\n            return HRESULT.E_NOTIMPL;\r\n\r\n        int startIndex = bindInfo.GetCoderInStreamIndex(coderIndex);\r\n\r\n        if (coder.Coder == null)\r\n            return HRESULT.E_NOTIMPL;\r\n\r\n        ICompressSetInStream setInStream = (ICompressSetInStream)coder.Coder; //  coder.Coder.QueryInterface(IID_ICompressSetInStream, &setInStream);\r\n        if (setInStream == null)\r\n            return HRESULT.E_NOTIMPL;\r\n\r\n        if (coder.NumInStreams > 1)\r\n            return HRESULT.E_NOTIMPL;\r\n        for (i = 0; i < (int)coder.NumInStreams; i++) {\r\n            InputStream [] tmp = new java.io.InputStream[1];\r\n            int res = GetInStream(inStreams, /*useless_inSizes,*/ startIndex + i, tmp /* &seqInStream2 */ );\r\n            if (res != HRESULT.S_OK) return res;\r\n            InputStream seqInStream2 = tmp[0];\r\n            setInStream.SetInStream(seqInStream2);\r\n            //if (res != HRESULT.S_OK) return res;\r\n        }\r\n        inStreamRes[0] = seqInStream; // seqInStream.Detach();\r\n        return HRESULT.S_OK;\r\n    }","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void AddCoder(ICompressCoder coder, boolean isMain) {\r\n\t\tAddCoderCommon(isMain);\r\n\t\t((STCoderInfo)coders.lastElement()).Coder = coder;\r\n\t}","id":26929,"modified_method":"public void AddCoder(ICompressCoder coder, boolean isMain) {\r\n\t\tAddCoderCommon(isMain);\r\n\t\tcoders.lastElement().Coder = coder;\r\n\t}","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void SetCoderInfo(int coderIndex, LongVector inSizes, LongVector outSizes) {\r\n\t\t// _coders[coderIndex].SetCoderInfo(inSizes, outSizes);\r\n\t\t((STCoderInfo)coders.get(coderIndex)).SetCoderInfo(inSizes, outSizes);\r\n\t}","id":26930,"modified_method":"public void SetCoderInfo(int coderIndex, LongVector inSizes, LongVector outSizes) {\r\n\t\t// _coders[coderIndex].SetCoderInfo(inSizes, outSizes);\r\n\t\tcoders.get(coderIndex).SetCoderInfo(inSizes, outSizes);\r\n\t}","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void AddCoder2(ICompressCoder2 coder, boolean isMain) {\r\n\t\tAddCoderCommon(isMain);\r\n\t\t((STCoderInfo)coders.lastElement()).Coder2 = coder;\r\n\t}","id":26931,"modified_method":"public void AddCoder2(ICompressCoder2 coder, boolean isMain) {\r\n\t\tAddCoderCommon(isMain);\r\n\t\tcoders.lastElement().Coder2 = coder;\r\n\t}","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void Decode(\r\n\t\t\tIInStream inStream, long startPos,\r\n\t\t\tLongVector packSizes, int packSizesOffset,\r\n\t\t\tFolder folderInfo,\r\n\t\t\tOutputStream outStream,\r\n\t\t\tICompressProgressInfo compressProgress\r\n\t) throws IOException {\r\n\t\t\r\n\t\tfinal Vector inStreams = folderInfo.getInStreams(\r\n\t\t\t\tinStream,\r\n\t\t\t\tstartPos,\r\n\t\t\t\tpackSizes,\r\n\t\t\t\tpackSizesOffset);\r\n\t\t\r\n\t\tfinal BindInfoEx bindInfo = folderInfo.toBindInfoEx();\r\n\t\t\r\n\t\tif (!(this._bindInfoExPrevIsDefined && bindInfo.equals(this._bindInfoExPrev))) {\r\n\t\t\tcreateNewCoders(bindInfo, folderInfo);\r\n\t\t} else { /* should not happen, as far as I understood... */ }\r\n\t\t\r\n\t\tthis._mixerCoderSTSpec.ReInit();\r\n\t\t// this._mixerCoderCommon.setCoderInfos(this._decoders, folderInfo, packSizes);\r\n\t\tsetCoderMixerCommonInfos(folderInfo, packSizes);\r\n\t\t\r\n        // int mainCoder = bindInfo.FindOutStream(bindInfo.OutStreams.get(0))[0];\r\n        \r\n\t\tif (this._multiThread) {\r\n\t\t\t// _mixerCoderMTSpec.SetProgressCoderIndex(mainCoder);\r\n\t\t\tthrow new IOException(\"Multithreaded decoder is not implemented\");\r\n\t\t}\r\n\t\t\r\n\t\tif (folderInfo.Coders.size() == 0)\r\n\t\t\tthrow new IOException(\"no decoders available\");\r\n\t\t\r\n\t\tfinal Vector outStreams = new Vector(1);\r\n\t\toutStreams.add(outStream);\r\n\t\t\r\n\t\tthis._mixerCoderSTSpec.Code(\r\n\t\t\t\tinStreams,\r\n\t\t\t\tnull,\r\n\t\t\t\tinStreams.size(),\r\n\t\t\t\toutStreams,\r\n\t\t\t\tnull,\r\n\t\t\t\t1,\r\n\t\t\t\tcompressProgress);\r\n\t}","id":26932,"modified_method":"public void Decode(\r\n\t\t\tIInStream inStream, long startPos,\r\n\t\t\tLongVector packSizes, int packSizesOffset,\r\n\t\t\tFolder folderInfo,\r\n\t\t\tOutputStream outStream,\r\n\t\t\tICompressProgressInfo compressProgress\r\n\t) throws IOException {\r\n\t\t\r\n\t\tfinal Vector<InputStream> inStreams = folderInfo.getInStreams(\r\n\t\t\t\tinStream,\r\n\t\t\t\tstartPos,\r\n\t\t\t\tpackSizes,\r\n\t\t\t\tpackSizesOffset);\r\n\t\t\r\n\t\tfinal BindInfoEx bindInfo = folderInfo.toBindInfoEx();\r\n\t\t\r\n\t\tif (!(this._bindInfoExPrevIsDefined && bindInfo.equals(this._bindInfoExPrev))) {\r\n\t\t\tcreateNewCoders(bindInfo, folderInfo);\r\n\t\t} else { /* should not happen, as far as I understood... */ }\r\n\t\t\r\n\t\tthis._mixerCoderSTSpec.ReInit();\r\n\t\t// this._mixerCoderCommon.setCoderInfos(this._decoders, folderInfo, packSizes);\r\n\t\tsetCoderMixerCommonInfos(folderInfo, packSizes);\r\n\t\t\r\n        // int mainCoder = bindInfo.FindOutStream(bindInfo.OutStreams.get(0))[0];\r\n        \r\n\t\tif (this._multiThread) {\r\n\t\t\t// _mixerCoderMTSpec.SetProgressCoderIndex(mainCoder);\r\n\t\t\tthrow new IOException(\"Multithreaded decoder is not implemented\");\r\n\t\t}\r\n\t\t\r\n\t\tif (folderInfo.Coders.size() == 0)\r\n\t\t\tthrow new IOException(\"no decoders available\");\r\n\t\t\r\n\t\tfinal Vector outStreams = new Vector(1);\r\n\t\toutStreams.add(outStream);\r\n\t\t\r\n\t\tthis._mixerCoderSTSpec.Code(\r\n\t\t\t\tinStreams,\r\n\t\t\t\t//null,\r\n\t\t\t\tinStreams.size(),\r\n\t\t\t\toutStreams,\r\n\t\t\t\t//null,\r\n\t\t\t\t1,\r\n\t\t\t\tcompressProgress);\r\n\t}","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void setCoderMixerCommonInfos(Folder folderInfo, LongVector packSizes) {\r\n\t\tint packStreamIndex = 0, unPackStreamIndex = 0;\r\n\t\tfor (int i=0; i<folderInfo.Coders.size(); i++) {\r\n\t\t\tCoderInfo coderInfo = (CoderInfo)folderInfo.Coders.get(i);\r\n\t\t\tint numInStreams = coderInfo.NumInStreams;\r\n\t\t\tint numOutStreams = coderInfo.NumOutStreams;\r\n\t\t\tLongVector packSizesPointers = new LongVector(); // CRecordVector<const UInt64 *>\r\n\t\t\tLongVector unPackSizesPointers = new LongVector(); // CRecordVector<const UInt64 *>\r\n\t\t\tpackSizesPointers.Reserve(numInStreams);\r\n\t\t\tunPackSizesPointers.Reserve(numOutStreams);\r\n\t\t\tint j;\r\n\t\t\t\r\n\t\t\tfor (j=0; j<numOutStreams; j++, unPackStreamIndex++)\r\n\t\t\t\tunPackSizesPointers.add(folderInfo.UnPackSizes.get(unPackStreamIndex));\r\n\t\t\t \r\n\t\t\tfor (j=0; j<numInStreams; j++, packStreamIndex++) {\r\n\t\t\t\tfinal long packSizesPointer;\r\n\t\t\t\tfinal int bindPairIndex = folderInfo.FindBindPairForInStream(packStreamIndex);\r\n\t\t\t\tfinal int index;\r\n\t\t\t\tif (bindPairIndex >= 0) {\r\n\t\t\t\t\tindex = ((BindPair)folderInfo.BindPairs.get(bindPairIndex)).OutIndex;\r\n\t\t\t\t\tpackSizesPointer = folderInfo.UnPackSizes.get(index);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tindex = folderInfo.FindPackStreamArrayIndex(packStreamIndex);\r\n\t\t\t\t\tif (index < 0)\r\n\t\t\t\t\t\tthrow new IndexOutOfBoundsException(\"PackStreamArrayIndex: \" + index);\r\n\t\t\t\t\tpackSizesPointer = packSizes.get(index);\r\n\t\t\t\t}\r\n\t\t\t\tpackSizesPointers.add(packSizesPointer);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis._mixerCoderSTSpec.SetCoderInfo(\r\n\t\t\t\t\ti,\r\n\t\t\t\t\tpackSizesPointers, // &packSizesPointers.Front(),\r\n\t\t\t\t\tunPackSizesPointers // &unPackSizesPointers.Front()\r\n\t\t\t);\r\n\t\t}\r\n\t}","id":26933,"modified_method":"private void setCoderMixerCommonInfos(Folder folderInfo, LongVector packSizes) {\r\n\t\tint packStreamIndex = 0, unPackStreamIndex = 0;\r\n\t\tfor (int i=0; i<folderInfo.Coders.size(); i++) {\r\n\t\t\tCoderInfo coderInfo = folderInfo.Coders.get(i);\r\n\t\t\tint numInStreams = coderInfo.NumInStreams;\r\n\t\t\tint numOutStreams = coderInfo.NumOutStreams;\r\n\t\t\tLongVector packSizesPointers = new LongVector(); // CRecordVector<const UInt64 *>\r\n\t\t\tLongVector unPackSizesPointers = new LongVector(); // CRecordVector<const UInt64 *>\r\n\t\t\tpackSizesPointers.Reserve(numInStreams);\r\n\t\t\tunPackSizesPointers.Reserve(numOutStreams);\r\n\t\t\tint j;\r\n\t\t\t\r\n\t\t\tfor (j=0; j<numOutStreams; j++, unPackStreamIndex++)\r\n\t\t\t\tunPackSizesPointers.add(folderInfo.UnPackSizes.get(unPackStreamIndex));\r\n\t\t\t \r\n\t\t\tfor (j=0; j<numInStreams; j++, packStreamIndex++) {\r\n\t\t\t\tfinal long packSizesPointer;\r\n\t\t\t\tfinal int bindPairIndex = folderInfo.FindBindPairForInStream(packStreamIndex);\r\n\t\t\t\tfinal int index;\r\n\t\t\t\tif (bindPairIndex >= 0) {\r\n\t\t\t\t\tindex = (folderInfo.BindPairs.get(bindPairIndex)).OutIndex;\r\n\t\t\t\t\tpackSizesPointer = folderInfo.UnPackSizes.get(index);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tindex = folderInfo.FindPackStreamArrayIndex(packStreamIndex);\r\n\t\t\t\t\tif (index < 0)\r\n\t\t\t\t\t\tthrow new IndexOutOfBoundsException(\"PackStreamArrayIndex: \" + index);\r\n\t\t\t\t\tpackSizesPointer = packSizes.get(index);\r\n\t\t\t\t}\r\n\t\t\t\tpackSizesPointers.add(packSizesPointer);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis._mixerCoderSTSpec.SetCoderInfo(\r\n\t\t\t\t\ti,\r\n\t\t\t\t\tpackSizesPointers, // &packSizesPointers.Front(),\r\n\t\t\t\t\tunPackSizesPointers // &unPackSizesPointers.Front()\r\n\t\t\t);\r\n\t\t}\r\n\t}","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void createNewCoders(\r\n\t\t\tBindInfoEx bindInfo,\r\n\t\t\tFolder folderInfo) throws IOException {\r\n\t\tint i;\r\n\t\tthis._decoders.clear();\r\n\t\tif (this._mixerCoderSTSpec != null) this._mixerCoderSTSpec.close(); // _mixerCoder.Release();\r\n\t\tif (this._multiThread) {\r\n\t\t\t/*\r\n            _mixerCoderMTSpec = new CoderMixer2MT();\r\n            _mixerCoder = _mixerCoderMTSpec;\r\n            _mixerCoderCommon = _mixerCoderMTSpec;\r\n\t\t\t */\r\n\t\t\tthrow new IOException(\"multithreaded decoder not implemented\");\r\n\t\t} else {\r\n\t\t\tthis._mixerCoderSTSpec = new CoderMixer2ST(bindInfo);\r\n\t\t}\r\n\t\t\r\n\t\tfor (i=0; i<folderInfo.Coders.size(); i++) {\r\n\t\t\tCoderInfo coderInfo = (CoderInfo)folderInfo.Coders.get(i);\r\n\t\t\tAltCoderInfo altCoderInfo = (AltCoderInfo)coderInfo.AltCoders.firstElement();\r\n\t\t\t\r\n\t\t\tif (coderInfo.IsSimpleCoder()) {\r\n\t\t\t\tICompressCoder decoder = getSimpleCoder(altCoderInfo);\r\n\t\t\t\tthis._decoders.add(decoder);\r\n\t\t\t\t\r\n\t\t\t\tif (this._multiThread) {\r\n\t\t\t\t\t// _mixerCoderMTSpec.AddCoder(decoder);\r\n\t\t\t\t\t// has already ben checked above\r\n\t\t\t\t\t// throw new IOException(\"Multithreaded decoder is not implemented\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._mixerCoderSTSpec.AddCoder(decoder, false);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tICompressCoder2 decoder = getComplexCoder(altCoderInfo);\r\n\t\t\t\tthis._decoders.add(decoder);\r\n\t\t\t\t\r\n\t\t\t\tif (this._multiThread) {\r\n\t\t\t\t\t// _mixerCoderMTSpec.AddCoder2(decoder);\r\n\t\t\t\t\t// has already ben checked above\r\n\t\t\t\t\t// throw new IOException(\"Multithreaded decoder is not implemented\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._mixerCoderSTSpec.AddCoder2(decoder, false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._bindInfoExPrev = bindInfo;\r\n\t\tthis._bindInfoExPrevIsDefined = true;\r\n\t}","id":26934,"modified_method":"private void createNewCoders(\r\n\t\t\tBindInfoEx bindInfo,\r\n\t\t\tFolder folderInfo) throws IOException {\r\n\t\tint i;\r\n\t\tthis._decoders.clear();\r\n\t\tif (this._mixerCoderSTSpec != null) this._mixerCoderSTSpec.close(); // _mixerCoder.Release();\r\n\t\tif (this._multiThread) {\r\n\t\t\t/*\r\n            _mixerCoderMTSpec = new CoderMixer2MT();\r\n            _mixerCoder = _mixerCoderMTSpec;\r\n            _mixerCoderCommon = _mixerCoderMTSpec;\r\n\t\t\t */\r\n\t\t\tthrow new IOException(\"multithreaded decoder not implemented\");\r\n\t\t} else {\r\n\t\t\tthis._mixerCoderSTSpec = new CoderMixer2ST(bindInfo);\r\n\t\t}\r\n\t\t\r\n\t\tfor (i=0; i<folderInfo.Coders.size(); i++) {\r\n\t\t\tCoderInfo coderInfo = folderInfo.Coders.get(i);\r\n\t\t\tAltCoderInfo altCoderInfo = (AltCoderInfo)coderInfo.AltCoders.firstElement();\r\n\t\t\t\r\n\t\t\tif (coderInfo.IsSimpleCoder()) {\r\n\t\t\t\tICompressCoder decoder = getSimpleCoder(altCoderInfo);\r\n\t\t\t\tthis._decoders.add(decoder);\r\n\t\t\t\t\r\n\t\t\t\tif (this._multiThread) {\r\n\t\t\t\t\t// _mixerCoderMTSpec.AddCoder(decoder);\r\n\t\t\t\t\t// has already ben checked above\r\n\t\t\t\t\t// throw new IOException(\"Multithreaded decoder is not implemented\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._mixerCoderSTSpec.AddCoder(decoder, false);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tICompressCoder2 decoder = getComplexCoder(altCoderInfo);\r\n\t\t\t\tthis._decoders.add(decoder);\r\n\t\t\t\t\r\n\t\t\t\tif (this._multiThread) {\r\n\t\t\t\t\t// _mixerCoderMTSpec.AddCoder2(decoder);\r\n\t\t\t\t\t// has already ben checked above\r\n\t\t\t\t\t// throw new IOException(\"Multithreaded decoder is not implemented\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._mixerCoderSTSpec.AddCoder2(decoder, false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._bindInfoExPrev = bindInfo;\r\n\t\tthis._bindInfoExPrevIsDefined = true;\r\n\t}","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public int FindBindPairForOutStream(int outStreamIndex) {\r\n        for(int i = 0; i < BindPairs.size(); i++)\r\n            if (((BindPair)BindPairs.get(i)).OutIndex == outStreamIndex)\r\n                return i;\r\n        return -1;\r\n    }","id":26935,"modified_method":"public int FindBindPairForOutStream(int outStreamIndex) {\r\n        for(int i = 0; i < BindPairs.size(); i++)\r\n            if ((BindPairs.get(i)).OutIndex == outStreamIndex)\r\n                return i;\r\n        return -1;\r\n    }","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public int FindBindPairForInStream(int inStreamIndex) {\r\n        for(int i = 0; i < BindPairs.size(); i++)\r\n            if (((BindPair)BindPairs.get(i)).InIndex == inStreamIndex)\r\n                return i;\r\n        return -1;\r\n    }","id":26936,"modified_method":"public int FindBindPairForInStream(int inStreamIndex) {\r\n        for(int i = 0; i < BindPairs.size(); i++)\r\n            if ((BindPairs.get(i)).InIndex == inStreamIndex)\r\n                return i;\r\n        return -1;\r\n    }","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public int GetNumOutStreams() {\r\n        int result = 0;\r\n        for (int i = 0; i < Coders.size(); i++)\r\n            result += ((CoderInfo)Coders.get(i)).NumOutStreams;\r\n        return result;\r\n    }","id":26937,"modified_method":"public int GetNumOutStreams() {\r\n        int result = 0;\r\n        for (int i = 0; i < Coders.size(); i++)\r\n            result += (Coders.get(i)).NumOutStreams;\r\n        return result;\r\n    }","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public BindInfoEx toBindInfoEx() {\r\n\t\tBindInfoEx bindInfo = new BindInfoEx();\r\n\t\t\r\n\t\tfor (int i = 0; i < this.BindPairs.size(); i++) {\r\n\t\t\tBindPair bindPair = new BindPair();\r\n\t\t\tbindPair.InIndex = ((BindPair)this.BindPairs.get(i)).InIndex;\r\n\t\t\tbindPair.OutIndex = ((BindPair)this.BindPairs.get(i)).OutIndex;\r\n\t\t\tbindInfo.BindPairs.add(bindPair);\r\n\t\t}\r\n\t\tint outStreamIndex = 0;\r\n\t\tfor (int i = 0; i < this.Coders.size(); i++) {\r\n\t\t\tCoderStreamsInfo coderStreamsInfo = new CoderStreamsInfo();\r\n\t\t\tCoderInfo coderInfo = (CoderInfo)this.Coders.get(i);\r\n\t\t\tcoderStreamsInfo.NumInStreams = coderInfo.NumInStreams;\r\n\t\t\tcoderStreamsInfo.NumOutStreams = coderInfo.NumOutStreams;\r\n\t\t\tbindInfo.Coders.add(coderStreamsInfo);\r\n\t\t\tAltCoderInfo altCoderInfo = (AltCoderInfo)coderInfo.AltCoders.firstElement();\r\n\t\t\tbindInfo.CoderMethodIDs.add(altCoderInfo.MethodID);\r\n\t\t\tfor (int j = 0; j < coderStreamsInfo.NumOutStreams; j++, outStreamIndex++)\r\n\t\t\t\tif (this.FindBindPairForOutStream(outStreamIndex) < 0)\r\n\t\t\t\t\tbindInfo.OutStreams.add(outStreamIndex);\r\n\t\t}\r\n\t\tfor (int i = 0; i < this.PackStreams.size(); i++)\r\n\t\t\tbindInfo.InStreams.add(this.PackStreams.get(i));\r\n\t\treturn bindInfo;\r\n    }","id":26938,"modified_method":"public BindInfoEx toBindInfoEx() {\r\n\t\tBindInfoEx bindInfo = new BindInfoEx();\r\n\t\t\r\n\t\tfor (int i = 0; i < this.BindPairs.size(); i++) {\r\n\t\t\tBindPair bindPair = new BindPair();\r\n\t\t\tbindPair.InIndex = (this.BindPairs.get(i)).InIndex;\r\n\t\t\tbindPair.OutIndex = (this.BindPairs.get(i)).OutIndex;\r\n\t\t\tbindInfo.BindPairs.add(bindPair);\r\n\t\t}\r\n\t\tint outStreamIndex = 0;\r\n\t\tfor (int i = 0; i < this.Coders.size(); i++) {\r\n\t\t\tCoderStreamsInfo coderStreamsInfo = new CoderStreamsInfo();\r\n\t\t\tCoderInfo coderInfo = this.Coders.get(i);\r\n\t\t\tcoderStreamsInfo.NumInStreams = coderInfo.NumInStreams;\r\n\t\t\tcoderStreamsInfo.NumOutStreams = coderInfo.NumOutStreams;\r\n\t\t\tbindInfo.Coders.add(coderStreamsInfo);\r\n\t\t\tAltCoderInfo altCoderInfo = (AltCoderInfo)coderInfo.AltCoders.firstElement();\r\n\t\t\tbindInfo.CoderMethodIDs.add(altCoderInfo.MethodID);\r\n\t\t\tfor (int j = 0; j < coderStreamsInfo.NumOutStreams; j++, outStreamIndex++)\r\n\t\t\t\tif (this.FindBindPairForOutStream(outStreamIndex) < 0)\r\n\t\t\t\t\tbindInfo.OutStreams.add(outStreamIndex);\r\n\t\t}\r\n\t\tfor (int i = 0; i < this.PackStreams.size(); i++)\r\n\t\t\tbindInfo.InStreams.add(this.PackStreams.get(i));\r\n\t\treturn bindInfo;\r\n    }","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void Extract(int [] indices, int numItems,\r\n            int testModeSpec, IArchiveExtractCallback extractCallback) throws IOException {\r\n        \r\n        boolean testMode = (testModeSpec != 0);\r\n        long importantTotalUnPacked = 0;\r\n        \r\n        boolean allFilesMode = (numItems == -1);\r\n        if (allFilesMode)\r\n            numItems = this._database.Files.size();\r\n        \r\n        if (numItems == 0)\r\n            return;\r\n        \r\n        Vector extractFolderInfoVector = new Vector();\r\n        for (int ii = 0; ii < numItems; ii++) {\r\n            int ref2Index = allFilesMode ? ii : indices[ii];\r\n            \r\n            ArchiveDB database = _database;\r\n            int fileIndex = ref2Index;\r\n            \r\n            int folderIndex = database.FileIndexToFolderIndexMap.get(fileIndex);\r\n            if (folderIndex == ArchiveDB.kNumNoIndex) {\r\n                extractFolderInfoVector.add( new ExtractFolderInfo(fileIndex, ArchiveDB.kNumNoIndex));\r\n                continue;\r\n            }\r\n            if (extractFolderInfoVector.isEmpty() ||\r\n                    folderIndex != ((ExtractFolderInfo)extractFolderInfoVector.lastElement()).FolderIndex) {\r\n                extractFolderInfoVector.add(new ExtractFolderInfo(ArchiveDB.kNumNoIndex, folderIndex));\r\n                Folder folderInfo = (Folder)database.Folders.get(folderIndex);\r\n                long unPackSize = folderInfo.GetUnPackSize();\r\n                importantTotalUnPacked += unPackSize;\r\n                ((ExtractFolderInfo)extractFolderInfoVector.lastElement()).UnPackSize = unPackSize;\r\n            }\r\n            \r\n            ExtractFolderInfo efi = (ExtractFolderInfo)extractFolderInfoVector.lastElement();\r\n            \r\n            int startIndex = database.FolderStartFileIndex.get(folderIndex); // CNum\r\n            for (int index = efi.ExtractStatuses.size(); index <= fileIndex - startIndex; index++)\r\n                efi.ExtractStatuses.add(index == fileIndex - startIndex);\r\n        }\r\n        \r\n        extractCallback.SetTotal(importantTotalUnPacked);\r\n        \r\n        Decoder decoder = new Decoder(false);\r\n        \r\n        long currentImportantTotalUnPacked = 0;\r\n        long totalFolderUnPacked;\r\n        \r\n        for (int i = 0; i < extractFolderInfoVector.size(); i++, currentImportantTotalUnPacked += totalFolderUnPacked) {\r\n            ExtractFolderInfo efi = (ExtractFolderInfo)extractFolderInfoVector.get(i);\r\n            totalFolderUnPacked = efi.UnPackSize;\r\n            \r\n            extractCallback.SetCompleted(currentImportantTotalUnPacked);\r\n            \r\n            int startIndex; // CNum\r\n            if (efi.FileIndex != ArchiveDB.kNumNoIndex)\r\n                startIndex = efi.FileIndex;\r\n            else\r\n                startIndex = this._database.FolderStartFileIndex.get(efi.FolderIndex);\r\n            \r\n            \r\n            FolderOutStream folderOutStream = new FolderOutStream(this._database, 0, startIndex, efi.ExtractStatuses, extractCallback, testMode);\r\n            int result = HRESULT.S_OK;\r\n            \r\n            if (efi.FileIndex != ArchiveDB.kNumNoIndex)\r\n                continue;\r\n            \r\n            int folderIndex = efi.FolderIndex; // CNum\r\n            Folder folderInfo = (Folder)this._database.Folders.get(folderIndex);\r\n            \r\n            LocalProgress localProgressSpec = new LocalProgress(extractCallback, false);\r\n            \r\n            ICompressProgressInfo compressProgress = new LocalCompressProgressInfo(\r\n            \t\tlocalProgressSpec,\r\n            \t\tICompressProgressInfo.INVALID,\r\n            \t\tcurrentImportantTotalUnPacked);\r\n            \r\n            int packStreamIndex = this._database.FolderStartPackStreamIndex.get(folderIndex); // CNum\r\n            long folderStartPackPos = this._database.GetFolderStreamPos(folderIndex, 0);\r\n            \r\n            try {\r\n                /* TODO: result = */ decoder.Decode(\r\n                \t\tthis._inStream,\r\n                        folderStartPackPos,\r\n                        this._database.PackSizes,\r\n                        packStreamIndex,\r\n                        folderInfo,\r\n                        folderOutStream,\r\n                        compressProgress);\r\n                \r\n                if (result == HRESULT.S_FALSE) {\r\n                    folderOutStream.FlushCorrupted(IInArchive.NExtract_NOperationResult_kDataError);\r\n                    // if (result != HRESULT.S_OK) return result;\r\n                    continue;\r\n                }\r\n                if (result == HRESULT.E_NOTIMPL) {\r\n                    folderOutStream.FlushCorrupted(IInArchive.NExtract_NOperationResult_kUnSupportedMethod);\r\n                    // if (result != HRESULT.S_OK) return result;\r\n                    continue;\r\n                }\r\n                if (folderOutStream.IsWritingFinished()) {\r\n                    folderOutStream.FlushCorrupted(IInArchive.NExtract_NOperationResult_kDataError);\r\n                    // if (result != HRESULT.S_OK) return result;\r\n                    continue;\r\n                }\r\n            } catch(Exception e) {\r\n                System.out.println(\"IOException : \" + e);\r\n                e.printStackTrace();\r\n                folderOutStream.FlushCorrupted(IInArchive.NExtract_NOperationResult_kDataError);\r\n                // if (result != HRESULT.S_OK) return result;\r\n                continue;\r\n            }\r\n        }\r\n    }","id":26939,"modified_method":"public void Extract(int [] indices, int numItems,\r\n            int testModeSpec, IArchiveExtractCallback extractCallback) throws IOException {\r\n        \r\n        boolean testMode = (testModeSpec != 0);\r\n        long importantTotalUnPacked = 0;\r\n        \r\n        boolean allFilesMode = (numItems == -1);\r\n        if (allFilesMode)\r\n            numItems = this._database.Files.size();\r\n        \r\n        if (numItems == 0)\r\n            return;\r\n        \r\n        Vector<ExtractFolderInfo> extractFolderInfoVector = new Vector();\r\n        for (int ii = 0; ii < numItems; ii++) {\r\n            int ref2Index = allFilesMode ? ii : indices[ii];\r\n            \r\n            ArchiveDB database = _database;\r\n            int fileIndex = ref2Index;\r\n            \r\n            int folderIndex = database.FileIndexToFolderIndexMap.get(fileIndex);\r\n            if (folderIndex == ArchiveDB.kNumNoIndex) {\r\n                extractFolderInfoVector.add( new ExtractFolderInfo(fileIndex, ArchiveDB.kNumNoIndex));\r\n                continue;\r\n            }\r\n            if (extractFolderInfoVector.isEmpty() ||\r\n                    folderIndex != (extractFolderInfoVector.lastElement()).FolderIndex) {\r\n                extractFolderInfoVector.add(new ExtractFolderInfo(ArchiveDB.kNumNoIndex, folderIndex));\r\n                Folder folderInfo = database.Folders.get(folderIndex);\r\n                long unPackSize = folderInfo.GetUnPackSize();\r\n                importantTotalUnPacked += unPackSize;\r\n                extractFolderInfoVector.lastElement().UnPackSize = unPackSize;\r\n            }\r\n            \r\n            ExtractFolderInfo efi = extractFolderInfoVector.lastElement();\r\n            \r\n            int startIndex = database.FolderStartFileIndex.get(folderIndex); // CNum\r\n            for (int index = efi.ExtractStatuses.size(); index <= fileIndex - startIndex; index++)\r\n                efi.ExtractStatuses.add(index == fileIndex - startIndex);\r\n        }\r\n        \r\n        extractCallback.SetTotal(importantTotalUnPacked);\r\n        \r\n        Decoder decoder = new Decoder(false);\r\n        \r\n        long currentImportantTotalUnPacked = 0;\r\n        long totalFolderUnPacked;\r\n        \r\n        for (int i = 0; i < extractFolderInfoVector.size(); i++, currentImportantTotalUnPacked += totalFolderUnPacked) {\r\n            ExtractFolderInfo efi = extractFolderInfoVector.get(i);\r\n            totalFolderUnPacked = efi.UnPackSize;\r\n            \r\n            extractCallback.SetCompleted(currentImportantTotalUnPacked);\r\n            \r\n            int startIndex; // CNum\r\n            if (efi.FileIndex != ArchiveDB.kNumNoIndex)\r\n                startIndex = efi.FileIndex;\r\n            else\r\n                startIndex = this._database.FolderStartFileIndex.get(efi.FolderIndex);\r\n            \r\n            \r\n            FolderOutStream folderOutStream = new FolderOutStream(this._database, 0, startIndex, efi.ExtractStatuses, extractCallback, testMode);\r\n            int result = HRESULT.S_OK;\r\n            \r\n            if (efi.FileIndex != ArchiveDB.kNumNoIndex)\r\n                continue;\r\n            \r\n            int folderIndex = efi.FolderIndex; // CNum\r\n            Folder folderInfo = this._database.Folders.get(folderIndex);\r\n            \r\n            LocalProgress localProgressSpec = new LocalProgress(extractCallback, false);\r\n            \r\n            ICompressProgressInfo compressProgress = new LocalCompressProgressInfo(\r\n            \t\tlocalProgressSpec,\r\n            \t\tICompressProgressInfo.INVALID,\r\n            \t\tcurrentImportantTotalUnPacked);\r\n            \r\n            int packStreamIndex = this._database.FolderStartPackStreamIndex.get(folderIndex); // CNum\r\n            long folderStartPackPos = this._database.GetFolderStreamPos(folderIndex, 0);\r\n            \r\n            try {\r\n                /* TODO: result = */ decoder.Decode(\r\n                \t\tthis._inStream,\r\n                        folderStartPackPos,\r\n                        this._database.PackSizes,\r\n                        packStreamIndex,\r\n                        folderInfo,\r\n                        folderOutStream,\r\n                        compressProgress);\r\n                \r\n                if (result == HRESULT.S_FALSE) {\r\n                    folderOutStream.FlushCorrupted(IInArchive.NExtract_NOperationResult_kDataError);\r\n                    // if (result != HRESULT.S_OK) return result;\r\n                    continue;\r\n                }\r\n                if (result == HRESULT.E_NOTIMPL) {\r\n                    folderOutStream.FlushCorrupted(IInArchive.NExtract_NOperationResult_kUnSupportedMethod);\r\n                    // if (result != HRESULT.S_OK) return result;\r\n                    continue;\r\n                }\r\n                if (folderOutStream.IsWritingFinished()) {\r\n                    folderOutStream.FlushCorrupted(IInArchive.NExtract_NOperationResult_kDataError);\r\n                    // if (result != HRESULT.S_OK) return result;\r\n                    continue;\r\n                }\r\n            } catch(Exception e) {\r\n                System.out.println(\"IOException : \" + e);\r\n                e.printStackTrace();\r\n                folderOutStream.FlushCorrupted(IInArchive.NExtract_NOperationResult_kDataError);\r\n                // if (result != HRESULT.S_OK) return result;\r\n                continue;\r\n            }\r\n        }\r\n    }","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private String getMethods(int index2) {\r\n        int folderIndex = _database.FileIndexToFolderIndexMap.get(index2);\r\n        if (folderIndex != ArchiveDB.kNumNoIndex) {\r\n            Folder folderInfo = (Folder)_database.Folders.get(folderIndex);\r\n            StringBuffer methodsString = new StringBuffer();\r\n            for (int i = folderInfo.Coders.size() - 1; i >= 0; i--) {\r\n                CoderInfo coderInfo = (CoderInfo)folderInfo.Coders.get(i);\r\n                if (methodsString.length() > 0)\r\n                    methodsString.append(' ');\r\n                \r\n                // MethodInfo methodInfo;\r\n                \r\n                for (int j = 0; j < coderInfo.AltCoders.size(); j++) {\r\n                    if (j > 0) methodsString.append('|');\r\n                    AltCoderInfo altCoderInfo = (AltCoderInfo)coderInfo.AltCoders.get(j);\r\n                    \r\n                    if (altCoderInfo.MethodID.getName() == null) {\r\n                        // TBD methodsString += altCoderInfo.MethodID.ConvertToString();\r\n                    } else {\r\n                        methodsString.append(altCoderInfo.MethodID.getName());\r\n                        \r\n                        if (altCoderInfo.MethodID.equals(MethodID.k_LZMA)) {\r\n                            if (altCoderInfo.Properties.size() >= 5) {\r\n                                methodsString.append(':');\r\n                                int dicSize = GetUInt32FromMemLE(altCoderInfo.Properties.toByteArray(), 1);\r\n                                methodsString.append(GetStringForSizeValue(dicSize));\r\n                            }\r\n                        }\r\n                        /* else if (altCoderInfo.MethodID == k_PPMD) {\r\n                            if (altCoderInfo.Properties.GetCapacity() >= 5) {\r\n                                Byte order = *(const Byte *)altCoderInfo.Properties;\r\n                                methodsString += \":o\";\r\n                                methodsString += ConvertUInt32ToString(order);\r\n                                methodsString += \":mem\";\r\n                                UInt32 dicSize = GetUInt32FromMemLE(\r\n                                        ((const Byte *)altCoderInfo.Properties + 1));\r\n                                methodsString += GetStringForSizeValue(dicSize);\r\n                            }\r\n                        } else if (altCoderInfo.MethodID == k_AES) {\r\n                            if (altCoderInfo.Properties.GetCapacity() >= 1) {\r\n                                methodsString += \":\";\r\n                                const Byte *data = (const Byte *)altCoderInfo.Properties;\r\n                                Byte firstByte = *data++;\r\n                                UInt32 numCyclesPower = firstByte & 0x3F;\r\n                                methodsString += ConvertUInt32ToString(numCyclesPower);\r\n                            }\r\n                        } else {\r\n                            if (altCoderInfo.Properties.GetCapacity() > 0) {\r\n                                methodsString += \":[\";\r\n                                for (size_t bi = 0; bi < altCoderInfo.Properties.GetCapacity(); bi++) {\r\n                                    if (bi > 5 && bi + 1 < altCoderInfo.Properties.GetCapacity()) {\r\n                                        methodsString += \"..\";\r\n                                        break;\r\n                                    } else\r\n                                        methodsString += GetHex2(altCoderInfo.Properties[bi]);\r\n                                }\r\n                                methodsString += \"]\";\r\n                            }\r\n                        }\r\n                         */\r\n                    }\r\n                }\r\n            }\r\n            return methodsString.toString();\r\n        }\r\n        \r\n        return new String();\r\n    }","id":26940,"modified_method":"private String getMethods(int index2) {\r\n        int folderIndex = _database.FileIndexToFolderIndexMap.get(index2);\r\n        if (folderIndex != ArchiveDB.kNumNoIndex) {\r\n            Folder folderInfo = _database.Folders.get(folderIndex);\r\n            StringBuffer methodsString = new StringBuffer();\r\n            for (int i = folderInfo.Coders.size() - 1; i >= 0; i--) {\r\n                CoderInfo coderInfo = folderInfo.Coders.get(i);\r\n                if (methodsString.length() > 0)\r\n                    methodsString.append(' ');\r\n                \r\n                // MethodInfo methodInfo;\r\n                \r\n                for (int j = 0; j < coderInfo.AltCoders.size(); j++) {\r\n                    if (j > 0) methodsString.append('|');\r\n                    AltCoderInfo altCoderInfo = (AltCoderInfo)coderInfo.AltCoders.get(j);\r\n                    \r\n                    if (altCoderInfo.MethodID.getName() == null) {\r\n                        // TBD methodsString += altCoderInfo.MethodID.ConvertToString();\r\n                    } else {\r\n                        methodsString.append(altCoderInfo.MethodID.getName());\r\n                        \r\n                        if (altCoderInfo.MethodID.equals(MethodID.k_LZMA)) {\r\n                            if (altCoderInfo.Properties.size() >= 5) {\r\n                                methodsString.append(':');\r\n                                int dicSize = GetUInt32FromMemLE(altCoderInfo.Properties.toByteArray(), 1);\r\n                                methodsString.append(GetStringForSizeValue(dicSize));\r\n                            }\r\n                        }\r\n                        /* else if (altCoderInfo.MethodID == k_PPMD) {\r\n                            if (altCoderInfo.Properties.GetCapacity() >= 5) {\r\n                                Byte order = *(const Byte *)altCoderInfo.Properties;\r\n                                methodsString += \":o\";\r\n                                methodsString += ConvertUInt32ToString(order);\r\n                                methodsString += \":mem\";\r\n                                UInt32 dicSize = GetUInt32FromMemLE(\r\n                                        ((const Byte *)altCoderInfo.Properties + 1));\r\n                                methodsString += GetStringForSizeValue(dicSize);\r\n                            }\r\n                        } else if (altCoderInfo.MethodID == k_AES) {\r\n                            if (altCoderInfo.Properties.GetCapacity() >= 1) {\r\n                                methodsString += \":\";\r\n                                const Byte *data = (const Byte *)altCoderInfo.Properties;\r\n                                Byte firstByte = *data++;\r\n                                UInt32 numCyclesPower = firstByte & 0x3F;\r\n                                methodsString += ConvertUInt32ToString(numCyclesPower);\r\n                            }\r\n                        } else {\r\n                            if (altCoderInfo.Properties.GetCapacity() > 0) {\r\n                                methodsString += \":[\";\r\n                                for (size_t bi = 0; bi < altCoderInfo.Properties.GetCapacity(); bi++) {\r\n                                    if (bi > 5 && bi + 1 < altCoderInfo.Properties.GetCapacity()) {\r\n                                        methodsString += \"..\";\r\n                                        break;\r\n                                    } else\r\n                                        methodsString += GetHex2(altCoderInfo.Properties[bi]);\r\n                                }\r\n                                methodsString += \"]\";\r\n                            }\r\n                        }\r\n                         */\r\n                    }\r\n                }\r\n            }\r\n            return methodsString.toString();\r\n        }\r\n        \r\n        return new String();\r\n    }","commit_id":"5b07f3473ef7e155ccaed383ce97f65b76f6a860","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void schedule() {\n\t\tUSKAttempt[] attempts;\n\t\tlong lookedUp = uskManager.lookup(origUSK);\n\t\tsynchronized(this) {\n\t\t\tvalueAtSchedule = Math.max(lookedUp, valueAtSchedule);\n\t\t\tif(cancelled) return;\n\t\t\tlong startPoint = Math.max(origUSK.suggestedEdition, valueAtSchedule);\n\t\t\tfor(long i=startPoint;i<startPoint+minFailures;i++)\n\t\t\t\tadd(i);\n\t\t\tattempts = (USKAttempt[]) runningAttempts.toArray(new USKAttempt[runningAttempts.size()]);\n\t\t\tstarted = true;\n\t\t}\n\t\tif(!cancelled) {\n\t\t\tfor(int i=0;i<attempts.length;i++) {\n\t\t\t\t// Race conditions happen here and waste a lot more time than this simple check.\n\t\t\t\tlong lastEd = uskManager.lookup(origUSK);\n\t\t\t\tif(keepLastData && lastEd == lookedUp)\n\t\t\t\t\tlastEd--; // If we want the data, then get it for the known edition, so we always get the data, so USKInserter can compare it and return the old edition if it is identical.\n\t\t\t\tif(attempts[i].number > lastEd)\n\t\t\t\t\tattempts[i].schedule();\n\t\t\t\telse {\n\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\trunningAttempts.remove(attempts[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":26941,"modified_method":"public void schedule() {\n\t\tUSKAttempt[] attempts;\n\t\tlong lookedUp = uskManager.lookup(origUSK);\n\t\tsynchronized(this) {\n\t\t\tvalueAtSchedule = Math.max(lookedUp, valueAtSchedule);\n\t\t\tif(cancelled) return;\n\t\t\tlong startPoint = Math.max(origUSK.suggestedEdition, valueAtSchedule);\n\t\t\tfor(long i=startPoint;i<startPoint+minFailures;i++)\n\t\t\t\tadd(i);\n\t\t\tattempts = runningAttempts.toArray(new USKAttempt[runningAttempts.size()]);\n\t\t\tstarted = true;\n\t\t}\n\t\tif(!cancelled) {\n\t\t\tfor(int i=0;i<attempts.length;i++) {\n\t\t\t\t// Race conditions happen here and waste a lot more time than this simple check.\n\t\t\t\tlong lastEd = uskManager.lookup(origUSK);\n\t\t\t\tif(keepLastData && lastEd == lookedUp)\n\t\t\t\t\tlastEd--; // If we want the data, then get it for the known edition, so we always get the data, so USKInserter can compare it and return the old edition if it is identical.\n\t\t\t\tif(attempts[i].number > lastEd)\n\t\t\t\t\tattempts[i].schedule();\n\t\t\t\telse {\n\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\trunningAttempts.remove(attempts[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"188ed3eec874dc478574e6046ab5b2d6100acba8","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Add a USKAttempt for another edition number.\n\t * Caller is responsible for calling .schedule().\n\t */\n\tprivate synchronized USKAttempt add(long i) {\n\t\tif(cancelled) return null;\n\t\tif(logMINOR) Logger.minor(this, \"Adding USKAttempt for \"+i+\" for \"+origUSK.getURI());\n\t\tif(!runningAttempts.isEmpty()) {\n\t\t\tUSKAttempt last = (USKAttempt) runningAttempts.lastElement();\n\t\t\tif(last.number >= i) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Returning because last.number=\"+i+\" for \"+origUSK.getURI());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tUSKAttempt a = new USKAttempt(i);\n\t\trunningAttempts.add(a);\n\t\tlastAddedEdition = i;\n\t\tif(logMINOR) Logger.minor(this, \"Added \"+a+\" for \"+origUSK);\n\t\treturn a;\n\t}","id":26942,"modified_method":"/**\n\t * Add a USKAttempt for another edition number.\n\t * Caller is responsible for calling .schedule().\n\t */\n\tprivate synchronized USKAttempt add(long i) {\n\t\tif(cancelled) return null;\n\t\tif(logMINOR) Logger.minor(this, \"Adding USKAttempt for \"+i+\" for \"+origUSK.getURI());\n\t\tif(!runningAttempts.isEmpty()) {\n\t\t\tUSKAttempt last = runningAttempts.lastElement();\n\t\t\tif(last.number >= i) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Returning because last.number=\"+i+\" for \"+origUSK.getURI());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tUSKAttempt a = new USKAttempt(i);\n\t\trunningAttempts.add(a);\n\t\tlastAddedEdition = i;\n\t\tif(logMINOR) Logger.minor(this, \"Added \"+a+\" for \"+origUSK);\n\t\treturn a;\n\t}","commit_id":"188ed3eec874dc478574e6046ab5b2d6100acba8","url":"https://github.com/freenet/fred"},{"original_method":"public void cancel() {\n\t\tUSKAttempt[] attempts;\n\t\tsynchronized(this) {\n\t\t\tcancelled = true;\n\t\t\tattempts = (USKAttempt[]) runningAttempts.toArray(new USKAttempt[runningAttempts.size()]);\n\t\t}\n\t\tfor(int i=0;i<attempts.length;i++)\n\t\t\tattempts[i].cancel();\n\t\tuskManager.onCancelled(this);\n\t}","id":26943,"modified_method":"public void cancel() {\n\t\tUSKAttempt[] attempts;\n\t\tsynchronized(this) {\n\t\t\tcancelled = true;\n\t\t\tattempts = runningAttempts.toArray(new USKAttempt[runningAttempts.size()]);\n\t\t}\n\t\tfor(int i=0;i<attempts.length;i++)\n\t\t\tattempts[i].cancel();\n\t\tuskManager.onCancelled(this);\n\t}","commit_id":"188ed3eec874dc478574e6046ab5b2d6100acba8","url":"https://github.com/freenet/fred"},{"original_method":"void onSuccess(USKAttempt att, boolean dontUpdate, ClientSSKBlock block) {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tLinkedList l = null;\n\t\tfinal long lastEd = uskManager.lookup(origUSK);\n\t\tlong curLatest;\n\t\tboolean decode = false;\n\t\tsynchronized(this) {\n\t\t\trunningAttempts.remove(att);\n\t\t\tcurLatest = att.number;\n\t\t\tif(completed || cancelled) return;\n\t\t\tdecode = curLatest >= lastEd && !(dontUpdate && block == null);\n\t\t\tcurLatest = Math.max(lastEd, curLatest);\n\t\t\tif(logMINOR) Logger.minor(this, \"Latest: \"+curLatest);\n\t\t\tlong addTo = curLatest + minFailures;\n\t\t\tlong addFrom = Math.max(lastAddedEdition + 1, curLatest + 1);\n\t\t\tif(logMINOR) Logger.minor(this, \"Adding from \"+addFrom+\" to \"+addTo+\" for \"+origUSK);\n\t\t\tif(addTo >= addFrom) {\n\t\t\t\tl = new LinkedList();\n\t\t\t\tfor(long i=addFrom;i<=addTo;i++) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Adding checker for edition \"+i+\" for \"+origUSK);\n\t\t\t\t\tl.add(add(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcancelBefore(curLatest);\n\t\t}\n\t\tBucket data = null;\n\t\tif(decode) {\n\t\t\ttry {\n\t\t\t\tdata = lastRequestData = block.decode(ctx.bucketFactory, 1025 /* it's an SSK */, true);\n\t\t\t} catch (KeyDecodeException e) {\n\t\t\t\tdata = null;\n\t\t\t} catch (IOException e) {\n\t\t\t\tdata = null;\n\t\t\t}\n\t\t}\n\t\tsynchronized(this) {\n\t\t\tif (decode) {\n\t\t\t\t\tlastCompressionCodec = block.getCompressionCodec();\n\t\t\t\t\tlastWasMetadata = block.isMetadata();\n\t\t\t\t\tif(keepLastData)\n\t\t\t\t\t\tlastRequestData = data;\n\t\t\t\t\telse\n\t\t\t\t\t\tdata.free();\n\t\t\t}\n\t\t}\n\t\tif(!dontUpdate)\n\t\t\tuskManager.update(origUSK, curLatest);\n\t\tif(l == null) return;\n\t\tfinal LinkedList toSched = l;\n\t\t// If we schedule them here, we don't get icky recursion problems.\n\t\tif(!cancelled) {\n\t\t\tctx.executor.execute(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tlong last = lastEd;\n\t\t\t\t\tfor(Iterator i=toSched.iterator();i.hasNext();) {\n\t\t\t\t\t\t// We may be called recursively through onSuccess().\n\t\t\t\t\t\t// So don't start obsolete requests.\n\t\t\t\t\t\tUSKAttempt a = (USKAttempt) i.next();\n\t\t\t\t\t\tlast = uskManager.lookup(origUSK);\n\t\t\t\t\t\tif((last <= a.number) && !a.cancelled)\n\t\t\t\t\t\t\ta.schedule();\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\t\t\trunningAttempts.remove(a);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, \"USK scheduler\"); // Run on separate thread because otherwise can get loooong recursions\n\t\t}\n\t}","id":26944,"modified_method":"void onSuccess(USKAttempt att, boolean dontUpdate, ClientSSKBlock block) {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tLinkedList<USKAttempt> l = null;\n\t\tfinal long lastEd = uskManager.lookup(origUSK);\n\t\tlong curLatest;\n\t\tboolean decode = false;\n\t\tsynchronized(this) {\n\t\t\trunningAttempts.remove(att);\n\t\t\tcurLatest = att.number;\n\t\t\tif(completed || cancelled) return;\n\t\t\tdecode = curLatest >= lastEd && !(dontUpdate && block == null);\n\t\t\tcurLatest = Math.max(lastEd, curLatest);\n\t\t\tif(logMINOR) Logger.minor(this, \"Latest: \"+curLatest);\n\t\t\tlong addTo = curLatest + minFailures;\n\t\t\tlong addFrom = Math.max(lastAddedEdition + 1, curLatest + 1);\n\t\t\tif(logMINOR) Logger.minor(this, \"Adding from \"+addFrom+\" to \"+addTo+\" for \"+origUSK);\n\t\t\tif(addTo >= addFrom) {\n\t\t\t\tl = new LinkedList<USKAttempt>();\n\t\t\t\tfor(long i=addFrom;i<=addTo;i++) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Adding checker for edition \"+i+\" for \"+origUSK);\n\t\t\t\t\tl.add(add(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcancelBefore(curLatest);\n\t\t}\n\t\tBucket data = null;\n\t\tif(decode) {\n\t\t\ttry {\n\t\t\t\tdata = lastRequestData = block.decode(ctx.bucketFactory, 1025 /* it's an SSK */, true);\n\t\t\t} catch (KeyDecodeException e) {\n\t\t\t\tdata = null;\n\t\t\t} catch (IOException e) {\n\t\t\t\tdata = null;\n\t\t\t}\n\t\t}\n\t\tsynchronized(this) {\n\t\t\tif (decode) {\n\t\t\t\t\tlastCompressionCodec = block.getCompressionCodec();\n\t\t\t\t\tlastWasMetadata = block.isMetadata();\n\t\t\t\t\tif(keepLastData)\n\t\t\t\t\t\tlastRequestData = data;\n\t\t\t\t\telse\n\t\t\t\t\t\tdata.free();\n\t\t\t}\n\t\t}\n\t\tif(!dontUpdate)\n\t\t\tuskManager.update(origUSK, curLatest);\n\t\tif(l == null) return;\n\t\tfinal LinkedList<USKAttempt> toSched = l;\n\t\t// If we schedule them here, we don't get icky recursion problems.\n\t\tif(!cancelled) {\n\t\t\tctx.executor.execute(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tlong last = lastEd;\n\t\t\t\t\tfor(Iterator<USKAttempt> i=toSched.iterator();i.hasNext();) {\n\t\t\t\t\t\t// We may be called recursively through onSuccess().\n\t\t\t\t\t\t// So don't start obsolete requests.\n\t\t\t\t\t\tUSKAttempt a = i.next();\n\t\t\t\t\t\tlast = uskManager.lookup(origUSK);\n\t\t\t\t\t\tif((last <= a.number) && !a.cancelled)\n\t\t\t\t\t\t\ta.schedule();\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\t\t\trunningAttempts.remove(a);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, \"USK scheduler\"); // Run on separate thread because otherwise can get loooong recursions\n\t\t}\n\t}","commit_id":"188ed3eec874dc478574e6046ab5b2d6100acba8","url":"https://github.com/freenet/fred"},{"original_method":"private void updatePriorities() {\n\t\t// FIXME should this be synchronized? IMHO it doesn't matter that much if we get the priority\n\t\t// wrong for a few requests... also, we avoid any possible deadlock this way if the callbacks\n\t\t// take locks...\n\t\tshort normalPrio = RequestStarter.MINIMUM_PRIORITY_CLASS;\n\t\tshort progressPrio = RequestStarter.MINIMUM_PRIORITY_CLASS;\n\t\tUSKCallback[] callbacks;\n\t\tsynchronized(this) {\n\t\t\tcallbacks = (USKCallback[]) subscribers.toArray(new USKCallback[subscribers.size()]);\n\t\t}\n\t\tif(callbacks.length == 0) {\n\t\t\tnormalPollPriority = DEFAULT_NORMAL_POLL_PRIORITY;\n\t\t\tprogressPollPriority = DEFAULT_PROGRESS_POLL_PRIORITY;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<callbacks.length;i++) {\n\t\t\tUSKCallback cb = callbacks[i];\n\t\t\tshort prio = cb.getPollingPriorityNormal();\n\t\t\tif(prio < normalPrio) normalPrio = prio;\n\t\t\tprio = cb.getPollingPriorityProgress();\n\t\t\tif(prio < progressPrio) progressPrio = prio;\n\t\t}\n\t\tnormalPollPriority = normalPrio;\n\t\tprogressPollPriority = progressPrio;\n\t}","id":26945,"modified_method":"private void updatePriorities() {\n\t\t// FIXME should this be synchronized? IMHO it doesn't matter that much if we get the priority\n\t\t// wrong for a few requests... also, we avoid any possible deadlock this way if the callbacks\n\t\t// take locks...\n\t\tshort normalPrio = RequestStarter.MINIMUM_PRIORITY_CLASS;\n\t\tshort progressPrio = RequestStarter.MINIMUM_PRIORITY_CLASS;\n\t\tUSKCallback[] callbacks;\n\t\tsynchronized(this) {\n\t\t\tcallbacks = subscribers.toArray(new USKCallback[subscribers.size()]);\n\t\t}\n\t\tif(callbacks.length == 0) {\n\t\t\tnormalPollPriority = DEFAULT_NORMAL_POLL_PRIORITY;\n\t\t\tprogressPollPriority = DEFAULT_PROGRESS_POLL_PRIORITY;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<callbacks.length;i++) {\n\t\t\tUSKCallback cb = callbacks[i];\n\t\t\tshort prio = cb.getPollingPriorityNormal();\n\t\t\tif(prio < normalPrio) normalPrio = prio;\n\t\t\tprio = cb.getPollingPriorityProgress();\n\t\t\tif(prio < progressPrio) progressPrio = prio;\n\t\t}\n\t\tnormalPollPriority = normalPrio;\n\t\tprogressPollPriority = progressPrio;\n\t}","commit_id":"188ed3eec874dc478574e6046ab5b2d6100acba8","url":"https://github.com/freenet/fred"},{"original_method":"USKFetcher(USK origUSK, USKManager manager, FetchContext ctx, ClientRequester requester, int minFailures, boolean pollForever, long maxProbeEditions, boolean keepLastData) {\n\t\tthis.parent = requester;\n\t\tthis.maxMinFailures = maxProbeEditions;\n\t\tthis.origUSK = origUSK;\n\t\tthis.uskManager = manager;\n\t\tthis.minFailures = this.origMinFailures = minFailures;\n\t\trunningAttempts = new Vector();\n\t\tcallbacks = new LinkedList();\n\t\tsubscribers = new HashSet();\n\t\tlastFetchedEdition = -1;\n\t\tlastAddedEdition = -1;\n\t\tthis.ctx = ctx;\n\t\tthis.backgroundPoll = pollForever;\n\t\tthis.keepLastData = keepLastData;\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t}","id":26946,"modified_method":"USKFetcher(USK origUSK, USKManager manager, FetchContext ctx, ClientRequester requester, int minFailures, boolean pollForever, long maxProbeEditions, boolean keepLastData) {\n\t\tthis.parent = requester;\n\t\tthis.maxMinFailures = maxProbeEditions;\n\t\tthis.origUSK = origUSK;\n\t\tthis.uskManager = manager;\n\t\tthis.minFailures = this.origMinFailures = minFailures;\n\t\trunningAttempts = new Vector<USKAttempt>();\n\t\tcallbacks = new LinkedList<USKFetcherCallback>();\n\t\tsubscribers = new HashSet<USKCallback>();\n\t\tlastFetchedEdition = -1;\n\t\tlastAddedEdition = -1;\n\t\tthis.ctx = ctx;\n\t\tthis.backgroundPoll = pollForever;\n\t\tthis.keepLastData = keepLastData;\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t}","commit_id":"188ed3eec874dc478574e6046ab5b2d6100acba8","url":"https://github.com/freenet/fred"},{"original_method":"private void finishCancelled() {\n\t\tUSKFetcherCallback[] cb;\n\t\tsynchronized(this) {\n\t\t\tcompleted = true;\n\t\t\tcb = (USKFetcherCallback[]) callbacks.toArray(new USKFetcherCallback[callbacks.size()]);\n\t\t}\n\t\tfor(int i=0;i<cb.length;i++)\n\t\t\tcb[i].onCancelled();\n\t}","id":26947,"modified_method":"private void finishCancelled() {\n\t\tUSKFetcherCallback[] cb;\n\t\tsynchronized(this) {\n\t\t\tcompleted = true;\n\t\t\tcb = callbacks.toArray(new USKFetcherCallback[callbacks.size()]);\n\t\t}\n\t\tfor(int i=0;i<cb.length;i++)\n\t\t\tcb[i].onCancelled();\n\t}","commit_id":"188ed3eec874dc478574e6046ab5b2d6100acba8","url":"https://github.com/freenet/fred"},{"original_method":"private void cancelBefore(long curLatest) {\n\t\tVector v = null;\n\t\tint count = 0;\n\t\tsynchronized(this) {\n\t\t\tfor(Iterator i=runningAttempts.iterator();i.hasNext();) {\n\t\t\t\tUSKAttempt att = (USKAttempt) (i.next());\n\t\t\t\tif(att.number < curLatest) {\n\t\t\t\t\tif(v == null) v = new Vector(runningAttempts.size()-count);\n\t\t\t\t\tv.add(att);\n\t\t\t\t\ti.remove();\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(v != null) {\n\t\t\tfor(int i=0;i<v.size();i++) {\n\t\t\t\tUSKAttempt att = (USKAttempt) v.get(i);\n\t\t\t\tatt.cancel();\n\t\t\t}\n\t\t}\n\t}","id":26948,"modified_method":"private void cancelBefore(long curLatest) {\n\t\tVector<USKAttempt> v = null;\n\t\tint count = 0;\n\t\tsynchronized(this) {\n\t\t\tfor(Iterator<USKAttempt> i=runningAttempts.iterator();i.hasNext();) {\n\t\t\t\tUSKAttempt att = i.next();\n\t\t\t\tif(att.number < curLatest) {\n\t\t\t\t\tif(v == null) v = new Vector<USKAttempt>(runningAttempts.size()-count);\n\t\t\t\t\tv.add(att);\n\t\t\t\t\ti.remove();\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(v != null) {\n\t\t\tfor(int i=0;i<v.size();i++) {\n\t\t\t\tUSKAttempt att = v.get(i);\n\t\t\t\tatt.cancel();\n\t\t\t}\n\t\t}\n\t}","commit_id":"188ed3eec874dc478574e6046ab5b2d6100acba8","url":"https://github.com/freenet/fred"},{"original_method":"private void finishSuccess() {\n\t\tif(backgroundPoll) {\n\t\t\tlong valAtEnd = uskManager.lookup(origUSK);\n\t\t\tlong end;\n\t\t\tlong now = System.currentTimeMillis();\n\t\t\tsynchronized(this) {\n\t\t\t\tstarted = false; // don't finish before have rescheduled\n                \n                //Find out when we should check next ('end'), in an increasing delay (unless we make progress).\n                int newSleepTime = sleepTime * 2;\n\t\t\t\tif(newSleepTime > maxSleepTime) newSleepTime = maxSleepTime;\n\t\t\t\tsleepTime = newSleepTime;\n\t\t\t\tend = now + ctx.random.nextInt(sleepTime);\n                \n\t\t\t\tif(valAtEnd > valueAtSchedule) {\n\t\t\t\t\t// We have advanced; keep trying as if we just started.\n\t\t\t\t\tminFailures = origMinFailures;\n\t\t\t\t\tsleepTime = origSleepTime;\n\t\t\t\t\tend = now;\n\t\t\t\t} else {\n\t\t\t\t\t// We have not found any new version; Increase exponentially but relatively slowly\n\t\t\t\t\tlong newMinFailures = Math.max(((int)(minFailures * 1.25)), minFailures+1);\n\t\t\t\t\tif(newMinFailures > maxMinFailures)\n\t\t\t\t\t\tnewMinFailures = maxMinFailures;\n\t\t\t\t\tminFailures = newMinFailures;\n\t\t\t\t}\n\t\t\t}\n\t\t\tschedule(end-now);\n\t\t} else {\n\t\t\tlong ed = uskManager.lookup(origUSK);\n\t\t\tUSKFetcherCallback[] cb;\n\t\t\tsynchronized(this) {\n\t\t\t\tcompleted = true;\n\t\t\t\tcb = (USKFetcherCallback[]) callbacks.toArray(new USKFetcherCallback[callbacks.size()]);\n\t\t\t}\n\t\t\tfor(int i=0;i<cb.length;i++)\n\t\t\t\tcb[i].onFoundEdition(ed, origUSK.copy(ed));\n\t\t}\n\t}","id":26949,"modified_method":"private void finishSuccess() {\n\t\tif(backgroundPoll) {\n\t\t\tlong valAtEnd = uskManager.lookup(origUSK);\n\t\t\tlong end;\n\t\t\tlong now = System.currentTimeMillis();\n\t\t\tsynchronized(this) {\n\t\t\t\tstarted = false; // don't finish before have rescheduled\n                \n                //Find out when we should check next ('end'), in an increasing delay (unless we make progress).\n                int newSleepTime = sleepTime * 2;\n\t\t\t\tif(newSleepTime > maxSleepTime) newSleepTime = maxSleepTime;\n\t\t\t\tsleepTime = newSleepTime;\n\t\t\t\tend = now + ctx.random.nextInt(sleepTime);\n                \n\t\t\t\tif(valAtEnd > valueAtSchedule) {\n\t\t\t\t\t// We have advanced; keep trying as if we just started.\n\t\t\t\t\tminFailures = origMinFailures;\n\t\t\t\t\tsleepTime = origSleepTime;\n\t\t\t\t\tend = now;\n\t\t\t\t} else {\n\t\t\t\t\t// We have not found any new version; Increase exponentially but relatively slowly\n\t\t\t\t\tlong newMinFailures = Math.max(((int)(minFailures * 1.25)), minFailures+1);\n\t\t\t\t\tif(newMinFailures > maxMinFailures)\n\t\t\t\t\t\tnewMinFailures = maxMinFailures;\n\t\t\t\t\tminFailures = newMinFailures;\n\t\t\t\t}\n\t\t\t}\n\t\t\tschedule(end-now);\n\t\t} else {\n\t\t\tlong ed = uskManager.lookup(origUSK);\n\t\t\tUSKFetcherCallback[] cb;\n\t\t\tsynchronized(this) {\n\t\t\t\tcompleted = true;\n\t\t\t\tcb = callbacks.toArray(new USKFetcherCallback[callbacks.size()]);\n\t\t\t}\n\t\t\tfor(int i=0;i<cb.length;i++)\n\t\t\t\tcb[i].onFoundEdition(ed, origUSK.copy(ed));\n\t\t}\n\t}","commit_id":"188ed3eec874dc478574e6046ab5b2d6100acba8","url":"https://github.com/freenet/fred"},{"original_method":"protected Object createNode(final Object name, final Map attributes) {\n\n        final Attributes attrs = buildAttributes(attributes);\n        String tagName = name.toString();\n        String ns = \"\";\n\n        if (name instanceof QName) {\n            QName q = (QName) name;\n            tagName = q.getLocalPart();\n            ns = q.getNamespaceURI();\n        }\n\n        // import can be used only as top level element\n        if (\"import\".equals(name)) {\n            antXmlContext.setCurrentTarget(implicitTarget);\n        } else if (\"target\".equals(name) && !insideTask) {\n            return onStartTarget(attrs, tagName, ns);\n        }\n\n        try {\n            antElementHandler.onStartElement(ns, tagName, tagName, attrs, antXmlContext);\n        }\n        catch (final SAXParseException e) {\n            log.log(Level.SEVERE, \"Caught: \" + e, e);\n        }\n\n        insideTask = true;\n        final RuntimeConfigurable wrapper = (RuntimeConfigurable) antXmlContext.getWrapperStack().lastElement();\n        return wrapper.getProxy();\n    }","id":26950,"modified_method":"protected Object createNode(final Object name, final Map attributes) {\n\n        final Attributes attrs = buildAttributes(attributes);\n        String tagName = name.toString();\n        String ns = \"\";\n\n        if (name instanceof QName) {\n            QName q = (QName) name;\n            tagName = q.getLocalPart();\n            ns = q.getNamespaceURI();\n        }\n\n        // import can be used only as top level element\n        if (\"import\".equals(name)) {\n            antXmlContext.setCurrentTarget(implicitTarget);\n        } else if (\"target\".equals(name) && !insideTask) {\n            return onStartTarget(attrs, tagName, ns);\n        } else if (\"defineTarget\".equals(name) && !insideTask) {\n            return onDefineTarget(attrs, \"target\", ns);\n        }\n\n        try {\n            antElementHandler.onStartElement(ns, tagName, tagName, attrs, antXmlContext);\n        }\n        catch (final SAXParseException e) {\n            log.log(Level.SEVERE, \"Caught: \" + e, e);\n        }\n\n        insideTask = true;\n        final RuntimeConfigurable wrapper = antXmlContext.getWrapperStack().lastElement();\n        return wrapper.getProxy();\n    }","commit_id":"bdd807f00c29dca4c22a8c07e088f424be818282","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Determines, when the ANT Task that is represented by the \"node\" should perform.\n     * Node must be an ANT Task or no \"perform\" is called.\n     * If node is an ANT Task, it performs right after complete construction.\n     * If node is nested in a TaskContainer, calling \"perform\" is delegated to that\n     * TaskContainer.\n     *\n     * @param parent note: null when node is root\n     * @param node   the node that now has all its children applied\n     */\n    protected void nodeCompleted(final Object parent, final Object node) {\n        if (parent == null) insideTask = false;\n        antElementHandler.onEndElement(null, null, antXmlContext);\n\n        lastCompletedNode = node;\n        if (parent != null && !(parent instanceof Target)) {\n            log.finest(\"parent is not null: no perform on nodeCompleted\");\n            return; // parent will care about when children perform\n        }\n\n        // as in Target.execute()\n        if (node instanceof Task) {\n            Task task = (Task) node;\n            final String taskName = task.getTaskName();\n\n            if (\"antcall\".equals(taskName) && parent == null) {\n                throw new BuildException(\"antcall not supported within AntBuilder, consider using 'ant.project.executeTarget('targetName')' instead.\");\n            }\n\n            if (saveStreams) {\n                // save original streams\n                synchronized (AntBuilder.class) {\n                    int currentStreamCount = streamCount++;\n                    if (currentStreamCount == 0) {\n                        // we are first, save the streams\n                        savedProjectInputStream = project.getDefaultInputStream();\n                        savedIn = System.in;\n                        savedErr = System.err;\n                        savedOut = System.out;\n\n                        if (!(savedIn instanceof DemuxInputStream)) {\n                            project.setDefaultInputStream(savedIn);\n                            demuxInputStream = new DemuxInputStream(project);\n                            System.setIn(demuxInputStream);\n                        }\n                        demuxOutputStream = new DemuxOutputStream(project, false);\n                        System.setOut(new PrintStream(demuxOutputStream));\n                        demuxErrorStream = new DemuxOutputStream(project, true);\n                        System.setErr(new PrintStream(demuxErrorStream));\n                    }\n                }\n            }\n\n            try {\n                lastCompletedNode = performTask(task);\n            } finally {\n                if (saveStreams) {\n                    synchronized (AntBuilder.class) {\n                        int currentStreamCount = --streamCount;\n                        if (currentStreamCount == 0) {\n                            // last to leave, turn out the lights: restore original streams\n                            project.setDefaultInputStream(savedProjectInputStream);\n                            System.setOut(savedOut);\n                            System.setErr(savedErr);\n                            if (demuxInputStream != null) {\n                                System.setIn(savedIn);\n                                DefaultGroovyMethodsSupport.closeQuietly(demuxInputStream);\n                                demuxInputStream = null;\n                            }\n                            DefaultGroovyMethodsSupport.closeQuietly(demuxOutputStream);\n                            DefaultGroovyMethodsSupport.closeQuietly(demuxErrorStream);\n                            demuxOutputStream = null;\n                            demuxErrorStream = null;\n                        }\n                    }\n                }\n            }\n\n            // restore dummy collector target\n            if (\"import\".equals(taskName)) {\n                antXmlContext.setCurrentTarget(collectorTarget);\n            }\n        } else if (node instanceof Target) {\n            // restore dummy collector target\n            antXmlContext.setCurrentTarget(collectorTarget);\n        } else {\n            final RuntimeConfigurable r = (RuntimeConfigurable) node;\n            r.maybeConfigure(project);\n        }\n    }","id":26951,"modified_method":"/**\n     * Determines, when the ANT Task that is represented by the \"node\" should perform.\n     * Node must be an ANT Task or no \"perform\" is called.\n     * If node is an ANT Task, it performs right after complete construction.\n     * If node is nested in a TaskContainer, calling \"perform\" is delegated to that\n     * TaskContainer.\n     *\n     * @param parent note: null when node is root\n     * @param node   the node that now has all its children applied\n     */\n    protected void nodeCompleted(final Object parent, final Object node) {\n        if (parent == null) insideTask = false;\n        antElementHandler.onEndElement(null, null, antXmlContext);\n\n        lastCompletedNode = node;\n        if (parent != null && !(parent instanceof Target)) {\n            log.finest(\"parent is not null: no perform on nodeCompleted\");\n            return; // parent will care about when children perform\n        }\n        if (definingTarget != null && definingTarget == parent && node instanceof Task) return; // inside defineTarget\n        if (definingTarget == node) {\n            definingTarget = null;\n        }\n\n        // as in Target.execute()\n        if (node instanceof Task) {\n            Task task = (Task) node;\n            final String taskName = task.getTaskName();\n\n            if (\"antcall\".equals(taskName) && parent == null) {\n                throw new BuildException(\"antcall not supported within AntBuilder, consider using 'ant.project.executeTarget('targetName')' instead.\");\n            }\n\n            if (saveStreams) {\n                // save original streams\n                synchronized (AntBuilder.class) {\n                    int currentStreamCount = streamCount++;\n                    if (currentStreamCount == 0) {\n                        // we are first, save the streams\n                        savedProjectInputStream = project.getDefaultInputStream();\n                        savedIn = System.in;\n                        savedErr = System.err;\n                        savedOut = System.out;\n\n                        if (!(savedIn instanceof DemuxInputStream)) {\n                            project.setDefaultInputStream(savedIn);\n                            demuxInputStream = new DemuxInputStream(project);\n                            System.setIn(demuxInputStream);\n                        }\n                        demuxOutputStream = new DemuxOutputStream(project, false);\n                        System.setOut(new PrintStream(demuxOutputStream));\n                        demuxErrorStream = new DemuxOutputStream(project, true);\n                        System.setErr(new PrintStream(demuxErrorStream));\n                    }\n                }\n            }\n\n            try {\n                lastCompletedNode = performTask(task);\n            } finally {\n                if (saveStreams) {\n                    synchronized (AntBuilder.class) {\n                        int currentStreamCount = --streamCount;\n                        if (currentStreamCount == 0) {\n                            // last to leave, turn out the lights: restore original streams\n                            project.setDefaultInputStream(savedProjectInputStream);\n                            System.setOut(savedOut);\n                            System.setErr(savedErr);\n                            if (demuxInputStream != null) {\n                                System.setIn(savedIn);\n                                DefaultGroovyMethodsSupport.closeQuietly(demuxInputStream);\n                                demuxInputStream = null;\n                            }\n                            DefaultGroovyMethodsSupport.closeQuietly(demuxOutputStream);\n                            DefaultGroovyMethodsSupport.closeQuietly(demuxErrorStream);\n                            demuxOutputStream = null;\n                            demuxErrorStream = null;\n                        }\n                    }\n                }\n            }\n\n            // restore dummy collector target\n            if (\"import\".equals(taskName)) {\n                antXmlContext.setCurrentTarget(collectorTarget);\n            }\n        } else if (node instanceof Target) {\n            // restore dummy collector target\n            antXmlContext.setCurrentTarget(collectorTarget);\n        } else {\n            final RuntimeConfigurable r = (RuntimeConfigurable) node;\n            r.maybeConfigure(project);\n        }\n    }","commit_id":"bdd807f00c29dca4c22a8c07e088f424be818282","url":"https://github.com/apache/groovy"},{"original_method":"private Target onStartTarget(final Attributes attrs, String tagName, String ns) {\n        final Target target = new Target();\n        target.setProject(project);\n        target.setLocation(new Location(antXmlContext.getLocator()));\n        try {\n            antTargetHandler.onStartElement(ns, tagName, tagName, attrs, antXmlContext);\n            final Target newTarget = (Target) getProject().getTargets().get(attrs.getValue(\"name\"));\n\n            // execute dependencies (if any)\n            final Vector targets = new Vector();\n            for (final Enumeration deps = newTarget.getDependencies(); deps.hasMoreElements();) {\n                final String targetName = (String) deps.nextElement();\n                targets.add(project.getTargets().get(targetName));\n            }\n            getProject().executeSortedTargets(targets);\n\n            antXmlContext.setCurrentTarget(newTarget);\n            return newTarget;\n        }\n        catch (final SAXParseException e) {\n            log.log(Level.SEVERE, \"Caught: \" + e, e);\n        }\n        return null;\n    }","id":26952,"modified_method":"private Target onStartTarget(final Attributes attrs, String tagName, String ns) {\n        final Target target = new Target();\n        target.setProject(project);\n        target.setLocation(new Location(antXmlContext.getLocator()));\n        try {\n            antTargetHandler.onStartElement(ns, tagName, tagName, attrs, antXmlContext);\n            final Target newTarget = getProject().getTargets().get(attrs.getValue(\"name\"));\n\n            // execute dependencies (if any)\n            final Vector targets = new Vector();\n            for (final Enumeration deps = newTarget.getDependencies(); deps.hasMoreElements();) {\n                final String targetName = (String) deps.nextElement();\n                targets.add(project.getTargets().get(targetName));\n            }\n            getProject().executeSortedTargets(targets);\n\n            antXmlContext.setCurrentTarget(newTarget);\n            return newTarget;\n        }\n        catch (final SAXParseException e) {\n            log.log(Level.SEVERE, \"Caught: \" + e, e);\n        }\n        return null;\n    }","commit_id":"bdd807f00c29dca4c22a8c07e088f424be818282","url":"https://github.com/apache/groovy"},{"original_method":"protected ICompletionProposal createOverrideMethodProposal(XtendClass model, JvmExecutable overridden,\n\t\t\tfinal ContentAssistContext context, IProposalConflictHelper conflictHelper) {\n\t\tReplacingAppendable appendable = appendableFactory.get(context.getDocument(), model, context.getReplaceRegion()\n\t\t\t\t.getOffset(), context.getReplaceRegion().getLength(), 1, true);\n\t\tfinal String simpleName;\n\t\tif (overridden instanceof JvmOperation) {\n\t\t\timplementor.appendOverrideFunction(model, (JvmOperation) overridden, appendable);\n\t\t\tsimpleName = overridden.getSimpleName();\n\t\t} else {\n\t\t\timplementor.appendConstructorFromSuper(model, (JvmConstructor) overridden, appendable);\n\t\t\tsimpleName = \"new\";\n\t\t}\n\t\tString code = appendable.toString();\n\t\tif (!isValidProposal(code.trim(), context, conflictHelper)\n\t\t\t\t&& !isValidProposal(overridden.getSimpleName(), context, conflictHelper))\n\t\t\treturn null;\n\t\tImportOrganizingProposal completionProposal = createCompletionProposal(appendable, context.getReplaceRegion(),\n\t\t\t\tgetLabel(overridden), images.forFunction(overridden.getVisibility(), false));\n\t\tMatcher matcher = bodyExpressionPattern.matcher(code.trim());\n\t\tif (matcher.find()) {\n\t\t\tint bodyExpressionLength = matcher.end(1) - matcher.start(1);\n\t\t\tif (bodyExpressionLength == 0) {\n\t\t\t\tcompletionProposal.setCursorPosition(matcher.start(1));\n\t\t\t} else {\n\t\t\t\tcompletionProposal.setSelectionStart(completionProposal.getReplacementOffset() + matcher.start(1));\n\t\t\t\tcompletionProposal.setSelectionLength(bodyExpressionLength);\n\t\t\t\tcompletionProposal.setAutoInsertable(false);\n\t\t\t\tcompletionProposal.setCursorPosition(matcher.start(1) + bodyExpressionLength);\n\t\t\t\tcompletionProposal.setSimpleLinkedMode(context.getViewer(), '\\t');\n\t\t\t}\n\t\t}\n\t\tcompletionProposal.setPriority(getPriority(model, overridden, context));\n\t\tcompletionProposal.setMatcher(new PrefixMatcher() {\n\n\t\t\t@Override\n\t\t\tpublic boolean isCandidateMatchingPrefix(String name, String prefix) {\n\t\t\t\tPrefixMatcher delegate = context.getMatcher();\n\t\t\t\tboolean result = delegate.isCandidateMatchingPrefix(simpleName, prefix);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\treturn completionProposal;\n\t}","id":26953,"modified_method":"protected ICompletionProposal createOverrideMethodProposal(XtendClass model, JvmExecutable overridden,\n\t\t\tfinal ContentAssistContext context, IProposalConflictHelper conflictHelper) {\n\t\tReplacingAppendable appendable = appendableFactory.get(context.getDocument(), model, context.getReplaceRegion()\n\t\t\t\t.getOffset(), context.getReplaceRegion().getLength(), 1, true);\n\t\tfinal String simpleName;\n\t\tif (overridden instanceof JvmOperation) {\n\t\t\timplementor.appendOverrideFunction(model, (JvmOperation) overridden, appendable);\n\t\t\tsimpleName = overridden.getSimpleName();\n\t\t} else {\n\t\t\timplementor.appendConstructorFromSuper(model, (JvmConstructor) overridden, appendable);\n\t\t\tsimpleName = \"new\";\n\t\t}\n\t\tString code = appendable.getCode();\n\t\tif (!isValidProposal(code.trim(), context, conflictHelper) && !isValidProposal(simpleName, context, conflictHelper))\n\t\t\treturn null;\n\t\tImportOrganizingProposal completionProposal = createCompletionProposal(appendable, context.getReplaceRegion(),\n\t\t\t\tgetLabel(overridden), images.forFunction(overridden.getVisibility(), false));\n\t\tMatcher matcher = bodyExpressionPattern.matcher(code);\n\t\tif (matcher.find()) {\n\t\t\tint bodyExpressionLength = matcher.end(1) - matcher.start(1);\n\t\t\tint bodyExpressionStart = matcher.start(1) + appendable.getTotalOffset() - completionProposal.getReplacementOffset();\n\t\t\tif (bodyExpressionLength == 0) {\n\t\t\t\tcompletionProposal.setCursorPosition(bodyExpressionStart);\n\t\t\t} else {\n\t\t\t\tcompletionProposal.setSelectionStart(completionProposal.getReplacementOffset() + bodyExpressionStart);\n\t\t\t\tcompletionProposal.setSelectionLength(bodyExpressionLength);\n\t\t\t\tcompletionProposal.setAutoInsertable(false);\n\t\t\t\tcompletionProposal.setCursorPosition(bodyExpressionStart + bodyExpressionLength);\n\t\t\t\tcompletionProposal.setSimpleLinkedMode(context.getViewer(), '\\t');\n\t\t\t}\n\t\t}\n\t\tcompletionProposal.setPriority(getPriority(model, overridden, context));\n\t\tcompletionProposal.setMatcher(new PrefixMatcher() {\n\n\t\t\t@Override\n\t\t\tpublic boolean isCandidateMatchingPrefix(String name, String prefix) {\n\t\t\t\tPrefixMatcher delegate = context.getMatcher();\n\t\t\t\tboolean result = delegate.isCandidateMatchingPrefix(simpleName, prefix);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\treturn completionProposal;\n\t}","commit_id":"af3463da8e5753b1b554cc4ee75bc67e8271994a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void apply(IDocument document) {\n\t\ttry {\n\t\t\tappendable.commitChanges(getReplacementOffset(), getReplacementLength());\n\t\t\tif (isLinkedMode())\n\t\t\t\tsetUpLinkedMode(document);\n\t\t} catch (BadLocationException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","id":26954,"modified_method":"@Override\n\tpublic void apply(IDocument document) {\n\t\ttry {\n\t\t\tint shiftOffsetBy = appendable.commitChanges(getReplacementOffset(), getReplacementLength());\n\t\t\tsetSelectionStart(getSelectionStart() + shiftOffsetBy);\n\t\t\tsetCursorPosition(getCursorPosition() + shiftOffsetBy);\n\t\t\tif (isLinkedMode()) {\n\t\t\t\tsetUpLinkedMode(document);\n\t\t\t}\n\t\t} catch (BadLocationException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"af3463da8e5753b1b554cc4ee75bc67e8271994a","url":"https://github.com/eclipse/xtext"},{"original_method":"public ImportOrganizingProposal(ReplacingAppendable appendable, int replacementOffset, int replacementLength,\n\t\t\tint cursorPosition, Image image, StyledString displayString) {\n\t\tsuper(appendable.toString(), replacementOffset, replacementLength, cursorPosition, image, displayString, null, null);\n\t\tthis.appendable = appendable;\n\t}","id":26955,"modified_method":"public ImportOrganizingProposal(ReplacingAppendable appendable, int replacementOffset, int replacementLength,\n\t\t\tint cursorPosition, Image image, StyledString displayString) {\n\t\tsuper(appendable.getCode(), replacementOffset, replacementLength, cursorPosition, image, displayString, null, null);\n\t\tthis.appendable = appendable;\n\t}","commit_id":"af3463da8e5753b1b554cc4ee75bc67e8271994a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\t\tpublic void apply(IDocument document, ConfigurableCompletionProposal proposal) throws BadLocationException {\n\t\t\tString proposalReplacementString = proposal.getReplacementString();\n\t\t\tString typeName = proposalReplacementString;\n\t\t\tif (valueConverter != null)\n\t\t\t\ttypeName = valueConverter.toValue(proposalReplacementString, null);\n\t\t\tString replacementString = getActualReplacementString(proposal);\n\t\t\t// there is an import statement - apply computed replacementString\n\t\t\tif (!proposalReplacementString.equals(replacementString)) {\n\t\t\t\tString shortTypeName = replacementString;\n\t\t\t\tif (valueConverter != null)\n\t\t\t\t\tshortTypeName = valueConverter.toValue(replacementString, null);\n\t\t\t\tQualifiedName shortQualifiedName = qualifiedNameConverter.toQualifiedName(shortTypeName);\n\t\t\t\tif (shortQualifiedName.getSegmentCount() == 1) {\n\t\t\t\t\tproposal.setCursorPosition(replacementString.length());\n\t\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), replacementString);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// we could create an import statement if there is no conflict\n\t\t\tXtendFile file = (XtendFile) context.getContents().get(0);\n\t\t\tXtendClass clazz = file.getXtendClass();\n\t\t\t\n\t\t\tQualifiedName qualifiedName = qualifiedNameConverter.toQualifiedName(typeName);\t\t\t\n\t\t\tif (qualifiedName.getSegmentCount() == 1) {\n\t\t\t\t// type resides in default package - no need to hassle with imports\n\t\t\t\tproposal.setCursorPosition(proposalReplacementString.length());\n\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), proposalReplacementString);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tIEObjectDescription description = scope.getSingleElement(qualifiedName.skipFirst(qualifiedName.getSegmentCount() - 1));\n\t\t\tif (description != null) {\n\t\t\t\t// there exists a conflict - insert fully qualified name\n\t\t\t\tproposal.setCursorPosition(proposalReplacementString.length());\n\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), proposalReplacementString);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Import does not introduce ambiguities - add import and insert short name\n\t\t\tString shortName = qualifiedName.getLastSegment();\n\t\t\tint topPixel = -1;\n\t\t\t// store the pixel coordinates to prevent the ui from flickering\n\t\t\tStyledText widget = viewer.getTextWidget();\n\t\t\tif (widget != null)\n\t\t\t\ttopPixel = widget.getTopPixel();\n\t\t\tITextViewerExtension viewerExtension = null;\n\t\t\tif (viewer instanceof ITextViewerExtension) {\n\t\t\t\tviewerExtension = (ITextViewerExtension) viewer;\n\t\t\t\tviewerExtension.setRedraw(false);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\t// compute import statement's offset\n\t\t\t\tint offset = 0;\n\t\t\t\tboolean startWithLineBreak = true;\n\t\t\t\tboolean endWithLineBreak = false;\n\t\t\t\tif (file.getImports().isEmpty()) {\n\t\t\t\t\tstartWithLineBreak = false;\n\t\t\t\t\tif (clazz == null) {\n\t\t\t\t\t\toffset = document.getLength();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tICompositeNode node = NodeModelUtils.getNode(clazz);\n\t\t\t\t\t\toffset = node.getOffset();\n\t\t\t\t\t\tendWithLineBreak = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tICompositeNode node = NodeModelUtils.getNode(file.getImports().get(file.getImports().size() - 1));\n\t\t\t\t\toffset = node.getOffset() + node.getLength();\n\t\t\t\t}\n\t\t\t\toffset = Math.min(proposal.getReplacementOffset(), offset);\n\t\t\t\n\t\t\t\t// apply short proposal\n\t\t\t\tString escapedShortname = shortName;\n\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\tescapedShortname = valueConverter.toString(shortName);\n\t\t\t\t}\n\t\t\t\tproposal.setCursorPosition(escapedShortname.length());\n\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), escapedShortname);\n\t\t\t\n\t\t\t\t// add import statement\n\t\t\t\tString importStatement = (startWithLineBreak ? \"\\nimport \" : \"import \") + importConverter.toString(typeName);\n\t\t\t\tif (endWithLineBreak)\n\t\t\t\t\timportStatement += \"\\n\\n\";\n\t\t\t\tdocument.replace(offset, 0, importStatement.toString());\n\t\t\t\tproposal.setCursorPosition(proposal.getCursorPosition() + importStatement.length());\n\t\t\t\t\n\t\t\t\t// set the pixel coordinates\n\t\t\t\tif (widget != null) {\n\t\t\t\t\tint additionalTopPixel = 0;\n\t\t\t\t\tif (startWithLineBreak)\n\t\t\t\t\t\tadditionalTopPixel += widget.getLineHeight();\n\t\t\t\t\tif (endWithLineBreak)\n\t\t\t\t\t\tadditionalTopPixel += 2 * widget.getLineHeight();\n\t\t\t\t\twidget.setTopPixel(topPixel + additionalTopPixel);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (viewerExtension != null)\n\t\t\t\t\tviewerExtension.setRedraw(true);\n\t\t\t}\n\t\t}","id":26956,"modified_method":"@Override\n\t\tpublic void apply(IDocument document, ConfigurableCompletionProposal proposal) throws BadLocationException {\n\t\t\tString proposalReplacementString = proposal.getReplacementString();\n\t\t\tString typeName = proposalReplacementString;\n\t\t\tif (valueConverter != null)\n\t\t\t\ttypeName = valueConverter.toValue(proposalReplacementString, null);\n\t\t\tString replacementString = getActualReplacementString(proposal);\n\t\t\t// there is an import statement - apply computed replacementString\n\t\t\tif (!proposalReplacementString.equals(replacementString)) {\n\t\t\t\tString shortTypeName = replacementString;\n\t\t\t\tif (valueConverter != null)\n\t\t\t\t\tshortTypeName = valueConverter.toValue(replacementString, null);\n\t\t\t\tQualifiedName shortQualifiedName = qualifiedNameConverter.toQualifiedName(shortTypeName);\n\t\t\t\tif (shortQualifiedName.getSegmentCount() == 1) {\n\t\t\t\t\tproposal.setCursorPosition(replacementString.length());\n\t\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), replacementString);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// we could create an import statement if there is no conflict\n\t\t\tXtendFile file = (XtendFile) context.getContents().get(0);\n\t\t\tXtendClass clazz = file.getXtendClass();\n\t\t\t\n\t\t\tQualifiedName qualifiedName = qualifiedNameConverter.toQualifiedName(typeName);\t\t\t\n\t\t\tif (qualifiedName.getSegmentCount() == 1) {\n\t\t\t\t// type resides in default package - no need to hassle with imports\n\t\t\t\tproposal.setCursorPosition(proposalReplacementString.length());\n\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), proposalReplacementString);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tIEObjectDescription description = scope.getSingleElement(qualifiedName.skipFirst(qualifiedName.getSegmentCount() - 1));\n\t\t\tif (description != null) {\n\t\t\t\t// there exists a conflict - insert fully qualified name\n\t\t\t\tproposal.setCursorPosition(proposalReplacementString.length());\n\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), proposalReplacementString);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Import does not introduce ambiguities - add import and insert short name\n\t\t\tString shortName = qualifiedName.getLastSegment();\n\t\t\tint topPixel = -1;\n\t\t\t// store the pixel coordinates to prevent the ui from flickering\n\t\t\tStyledText widget = viewer.getTextWidget();\n\t\t\tif (widget != null)\n\t\t\t\ttopPixel = widget.getTopPixel();\n\t\t\tITextViewerExtension viewerExtension = null;\n\t\t\tif (viewer instanceof ITextViewerExtension) {\n\t\t\t\tviewerExtension = (ITextViewerExtension) viewer;\n\t\t\t\tviewerExtension.setRedraw(false);\n\t\t\t}\n\t\t\tDocumentRewriteSession rewriteSession = null;\n\t\t\ttry {\n\t\t\t\tif (document instanceof IDocumentExtension4) {\n\t\t\t\t\trewriteSession = ((IDocumentExtension4) document).startRewriteSession(DocumentRewriteSessionType.UNRESTRICTED_SMALL);\n\t\t\t\t}\n\t\t\t\t// compute import statement's offset\n\t\t\t\tint offset = 0;\n\t\t\t\tboolean startWithLineBreak = true;\n\t\t\t\tboolean endWithLineBreak = false;\n\t\t\t\tif (file.getImports().isEmpty()) {\n\t\t\t\t\tstartWithLineBreak = false;\n\t\t\t\t\tif (clazz == null) {\n\t\t\t\t\t\toffset = document.getLength();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tICompositeNode node = NodeModelUtils.getNode(clazz);\n\t\t\t\t\t\toffset = node.getOffset();\n\t\t\t\t\t\tendWithLineBreak = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tICompositeNode node = NodeModelUtils.getNode(file.getImports().get(file.getImports().size() - 1));\n\t\t\t\t\toffset = node.getOffset() + node.getLength();\n\t\t\t\t}\n\t\t\t\toffset = Math.min(proposal.getReplacementOffset(), offset);\n\t\t\t\n\t\t\t\t// apply short proposal\n\t\t\t\tString escapedShortname = shortName;\n\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\tescapedShortname = valueConverter.toString(shortName);\n\t\t\t\t}\n\t\t\t\tproposal.setCursorPosition(escapedShortname.length());\n\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), escapedShortname);\n\t\t\t\n\t\t\t\t// add import statement\n\t\t\t\tString importStatement = (startWithLineBreak ? \"\\nimport \" : \"import \") + importConverter.toString(typeName);\n\t\t\t\tif (endWithLineBreak)\n\t\t\t\t\timportStatement += \"\\n\\n\";\n\t\t\t\tdocument.replace(offset, 0, importStatement.toString());\n\t\t\t\tproposal.setCursorPosition(proposal.getCursorPosition() + importStatement.length());\n\t\t\t\t\n\t\t\t\t// set the pixel coordinates\n\t\t\t\tif (widget != null) {\n\t\t\t\t\tint additionalTopPixel = 0;\n\t\t\t\t\tif (startWithLineBreak)\n\t\t\t\t\t\tadditionalTopPixel += widget.getLineHeight();\n\t\t\t\t\tif (endWithLineBreak)\n\t\t\t\t\t\tadditionalTopPixel += 2 * widget.getLineHeight();\n\t\t\t\t\twidget.setTopPixel(topPixel + additionalTopPixel);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (rewriteSession != null) {\n\t\t\t\t\t((IDocumentExtension4) document).stopRewriteSession(rewriteSession);\n\t\t\t\t}\n\t\t\t\tif (viewerExtension != null)\n\t\t\t\t\tviewerExtension.setRedraw(true);\n\t\t\t}\n\t\t}","commit_id":"af3463da8e5753b1b554cc4ee75bc67e8271994a","url":"https://github.com/eclipse/xtext"},{"original_method":"public void insertNewImports() throws BadLocationException {\n\t\tList<String> newImports = getNewImports();\n\t\tif (!newImports.isEmpty()) {\n\t\t\tStringBuilder importSection = new StringBuilder();\n\t\t\tfor (String newImport : newImports) {\n\t\t\t\timportSection.append(\"import \");\n\t\t\t\timportSection.append(newImport);\n\t\t\t\timportSection.append(\"\\n\");\n\t\t\t}\n\t\t\tint offset;\n\t\t\tif (xtendFile.getImports().isEmpty()) {\n\t\t\t\toffset = NodeModelUtils.findActualNodeFor(xtendFile.getXtendClass()).getOffset();\n\t\t\t\timportSection.append(\"\\n\");\n\t\t\t} else {\n\t\t\t\tICompositeNode lastImportNode = NodeModelUtils.findActualNodeFor(xtendFile.getImports().get(\n\t\t\t\t\t\txtendFile.getImports().size() - 1));\n\t\t\t\timportSection.insert(0, \"\\n\");\n\t\t\t\timportSection.replace(importSection.length() - 1, importSection.length(), \"\");\n\t\t\t\toffset = lastImportNode.getOffset() + lastImportNode.getLength();\n\t\t\t}\n\t\t\tdocument.replace(offset, 0, importSection.toString());\n\t\t}\n\t}","id":26957,"modified_method":"public int insertNewImports() throws BadLocationException {\n\t\tList<String> newImports = getNewImports();\n\t\tif (!newImports.isEmpty()) {\n\t\t\tStringBuilder importSection = new StringBuilder();\n\t\t\tfor (String newImport : newImports) {\n\t\t\t\timportSection.append(\"import \");\n\t\t\t\timportSection.append(newImport);\n\t\t\t\timportSection.append(\"\\n\");\n\t\t\t}\n\t\t\tint offset;\n\t\t\tif (xtendFile.getImports().isEmpty()) {\n\t\t\t\toffset = NodeModelUtils.findActualNodeFor(xtendFile.getXtendClass()).getOffset();\n\t\t\t\timportSection.append(\"\\n\");\n\t\t\t} else {\n\t\t\t\tICompositeNode lastImportNode = NodeModelUtils.findActualNodeFor(xtendFile.getImports().get(\n\t\t\t\t\t\txtendFile.getImports().size() - 1));\n\t\t\t\timportSection.insert(0, \"\\n\");\n\t\t\t\timportSection.replace(importSection.length() - 1, importSection.length(), \"\");\n\t\t\t\toffset = lastImportNode.getOffset() + lastImportNode.getLength();\n\t\t\t}\n\t\t\tdocument.replace(offset, 0, importSection.toString());\n\t\t\treturn importSection.length();\n\t\t}\n\t\treturn 0;\n\t}","commit_id":"af3463da8e5753b1b554cc4ee75bc67e8271994a","url":"https://github.com/eclipse/xtext"},{"original_method":"public void commitChanges(int from, int length) throws BadLocationException {\n\t\tint actualOffset = Math.min(whitespaceHelper.getTotalOffset(), from);\n\t\tint endOffset = Math.max(whitespaceHelper.getTotalOffset() + whitespaceHelper.getTotalLength(), from + length);\n\t\tint actualLength = endOffset - actualOffset;\n\t\tdocument.replace(actualOffset, actualLength, toString());\n\t\tinsertNewImports();\n\t}","id":26958,"modified_method":"public int commitChanges(int offset, int length) throws BadLocationException {\n\t\tint actualOffset = Math.min(whitespaceHelper.getTotalOffset(), offset);\n\t\tint endOffset = Math.max(whitespaceHelper.getTotalOffset() + whitespaceHelper.getTotalLength(), offset + length);\n\t\tint actualLength = endOffset - actualOffset;\n\t\tdocument.replace(actualOffset, actualLength, toString());\n\t\tint shiftCursorBy = insertNewImports();\n\t\treturn shiftCursorBy;\n\t}","commit_id":"af3463da8e5753b1b554cc4ee75bc67e8271994a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic String toString() {\n\t\tStringBuilder b = new StringBuilder();\n\t\tif (whitespaceHelper.getPrefix() != null)\n\t\t\tb.append(whitespaceHelper.getPrefix().replace(\"\\n\", getIndentationString()));\n\t\tb.append(super.toString());\n\t\tif (whitespaceHelper.getSuffix() != null)\n\t\t\tb.append(whitespaceHelper.getSuffix().replace(\"\\n\", getIndentationString()));\n\t\treturn b.toString();\n\t}","id":26959,"modified_method":"@Override\n\tpublic String toString() {\n\t\treturn getCode();\n\t}","commit_id":"af3463da8e5753b1b554cc4ee75bc67e8271994a","url":"https://github.com/eclipse/xtext"},{"original_method":"protected IModification getXtendModification(final Xtend builder) {\n    final IModification _function = new IModification() {\n        public void apply(final IModificationContext it) throws Exception {\n          final XtendTypeDeclaration xtendClass = builder.getXtendType();\n          URI _uRI = EcoreUtil.getURI(xtendClass);\n          final IEditorPart editor = CodeBuilderQuickfix.this.editorOpener.open(_uRI, false);\n          boolean _not = (!(editor instanceof XtextEditor));\n          if (_not) {\n            return;\n          }\n          final XtextEditor xtextEditor = ((XtextEditor) editor);\n          final IXtextDocument document = xtextEditor.getDocument();\n          int offset = builder.getInsertOffset();\n          int _indentationLevel = builder.getIndentationLevel();\n          final ReplacingAppendable appendable = CodeBuilderQuickfix.this.appendableFactory.get(document, xtendClass, offset, 0, _indentationLevel, true);\n          builder.build(appendable);\n          appendable.commitChanges();\n          int _plus = (offset + 1);\n          int _length = appendable.length();\n          xtextEditor.setHighlightRange(_plus, _length, true);\n        }\n      };\n    return _function;\n  }","id":26960,"modified_method":"protected IModification getXtendModification(final Xtend builder) {\n    final IModification _function = new IModification() {\n        public void apply(final IModificationContext it) throws Exception {\n          final XtendTypeDeclaration xtendClass = builder.getXtendType();\n          URI _uRI = EcoreUtil.getURI(xtendClass);\n          final IEditorPart editor = CodeBuilderQuickfix.this.editorOpener.open(_uRI, false);\n          boolean _not = (!(editor instanceof XtextEditor));\n          if (_not) {\n            return;\n          }\n          final XtextEditor xtextEditor = ((XtextEditor) editor);\n          final IXtextDocument document = xtextEditor.getDocument();\n          int offset = builder.getInsertOffset();\n          Resource _eResource = xtendClass.eResource();\n          OptionalParameters _optionalParameters = new OptionalParameters();\n          final Procedure1<OptionalParameters> _function = new Procedure1<OptionalParameters>() {\n              public void apply(final OptionalParameters it) {\n                int _indentationLevel = builder.getIndentationLevel();\n                it.baseIndentationLevel = _indentationLevel;\n                it.ensureEmptyLinesAround = true;\n              }\n            };\n          OptionalParameters _doubleArrow = ObjectExtensions.<OptionalParameters>operator_doubleArrow(_optionalParameters, _function);\n          final ReplacingAppendable appendable = CodeBuilderQuickfix.this.appendableFactory.create(document, ((XtextResource) _eResource), offset, 0, _doubleArrow);\n          builder.build(appendable);\n          appendable.commitChanges();\n          int _plus = (offset + 1);\n          int _length = appendable.length();\n          xtextEditor.setHighlightRange(_plus, _length, true);\n        }\n      };\n    return _function;\n  }","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void newLocalVariableQuickfix(final String variableName, XAbstractFeatureCall call, Issue issue,\n\t\t\tIssueResolutionAcceptor issueResolutionAcceptor) {\n\t\tLightweightTypeReference variableType = getNewMemberType(call);\n\t\tfinal StringBuilderBasedAppendable localVarDescriptionBuilder = new StringBuilderBasedAppendable();\n\t\tlocalVarDescriptionBuilder.append(\"...\").newLine();\n\t\tfinal String defaultValueLiteral = getDefaultValueLiteral(variableType);\n\t\tlocalVarDescriptionBuilder.append(\"val \").append(variableName).append(\" = \").append(defaultValueLiteral);\n\t\tlocalVarDescriptionBuilder.newLine().append(\"...\");\n\t\tissueResolutionAcceptor.accept(issue, \"Create local variable '\" + variableName + \"'\",\n\t\t\t\tlocalVarDescriptionBuilder.toString(), \"fix_local_var.png\",\n\t\t\t\tnew SemanticModificationWrapper(issue.getUriToProblem(), new ISemanticModification() {\n\t\t\t\t\tpublic void apply(@Nullable final EObject element, @Nullable final IModificationContext context) throws Exception {\n\t\t\t\t\t\tif (element != null) {\n\t\t\t\t\t\t\tXtendMember xtendMember = EcoreUtil2.getContainerOfType(element, XtendMember.class);\n\t\t\t\t\t\t\tif (xtendMember != null) {\n\t\t\t\t\t\t\t\tint offset = getFirstOffsetOfKeyword(xtendMember, \"{\");\n\t\t\t\t\t\t\t\tIXtextDocument xtextDocument = context.getXtextDocument();\n\t\t\t\t\t\t\t\tif (offset != -1 && xtextDocument != null) {\n\t\t\t\t\t\t\t\t\tfinal ReplacingAppendable appendable = appendableFactory.get(xtextDocument,\n\t\t\t\t\t\t\t\t\t\t\telement, offset, 0, 1, false);\n\t\t\t\t\t\t\t\t\tappendable.increaseIndentation().newLine().append(\"val \").append(variableName).append(\" = \")\n\t\t\t\t\t\t\t\t\t\t\t.append(defaultValueLiteral);\n\t\t\t\t\t\t\t\t\tappendable.commitChanges();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}));\n\t}","id":26961,"modified_method":"protected void newLocalVariableQuickfix(final String variableName, XAbstractFeatureCall call, Issue issue,\n\t\t\tIssueResolutionAcceptor issueResolutionAcceptor) {\n\t\tLightweightTypeReference variableType = getNewMemberType(call);\n\t\tfinal StringBuilderBasedAppendable localVarDescriptionBuilder = new StringBuilderBasedAppendable();\n\t\tlocalVarDescriptionBuilder.append(\"...\").newLine();\n\t\tfinal String defaultValueLiteral = getDefaultValueLiteral(variableType);\n\t\tlocalVarDescriptionBuilder.append(\"val \").append(variableName).append(\" = \").append(defaultValueLiteral);\n\t\tlocalVarDescriptionBuilder.newLine().append(\"...\");\n\t\tissueResolutionAcceptor.accept(issue, \"Create local variable '\" + variableName + \"'\",\n\t\t\t\tlocalVarDescriptionBuilder.toString(), \"fix_local_var.png\",\n\t\t\t\tnew SemanticModificationWrapper(issue.getUriToProblem(), new ISemanticModification() {\n\t\t\t\t\tpublic void apply(@Nullable final EObject element, @Nullable final IModificationContext context) throws Exception {\n\t\t\t\t\t\tif (element != null) {\n\t\t\t\t\t\t\tXtendMember xtendMember = EcoreUtil2.getContainerOfType(element, XtendMember.class);\n\t\t\t\t\t\t\tif (xtendMember != null) {\n\t\t\t\t\t\t\t\tint offset = getFirstOffsetOfKeyword(xtendMember, \"{\");\n\t\t\t\t\t\t\t\tIXtextDocument xtextDocument = context.getXtextDocument();\n\t\t\t\t\t\t\t\tif (offset != -1 && xtextDocument != null) {\n\t\t\t\t\t\t\t\t\tfinal ReplacingAppendable appendable = appendableFactory.create(xtextDocument,\n\t\t\t\t\t\t\t\t\t\t\t(XtextResource) element.eResource(), offset, 0, new OptionalParameters() {{ \n\t\t\t\t\t\t\t\t\t\t\t\tbaseIndentationLevel = 1;\t\n\t\t\t\t\t\t\t\t\t\t\t}});\n\t\t\t\t\t\t\t\t\tappendable.increaseIndentation().newLine().append(\"val \").append(variableName).append(\" = \")\n\t\t\t\t\t\t\t\t\t\t\t.append(defaultValueLiteral);\n\t\t\t\t\t\t\t\t\tappendable.commitChanges();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}));\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"public Section newSection(int offset, int length, boolean ensureEmptyLinesAround) {\n\t\treturn newSection(offset, length, getIndentationLevelAtOffset(offset, document), ensureEmptyLinesAround);\n\t}","id":26962,"modified_method":"public Section newSection(int offset, int length, boolean ensureEmptyLinesAround) {\n\t\tOptionalParameters parameters = createOptionalParameters();\n\t\tparameters.ensureEmptyLinesAround = ensureEmptyLinesAround;\n\t\tSection section = factory.sectionFactory.create(document, resource, offset, length, parameters);\n\t\taddSection(section);\n\t\treturn section;\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<ReplaceRegion> getChanges() {\n\t\tList<ReplaceRegion> changes = newArrayList();\n\t\tfor (Section section : sections) {\n\t\t\tReplaceRegion change = section.getChange();\n\t\t\tchanges.add(change);\n\t\t}\n\t\tfor (ReplaceRegion change : importManager.getChanges()) {\n\t\t\tchanges.add(change);\n\t\t}\n\t\treturn changes;\n\t}","id":26963,"modified_method":"public List<ReplaceRegion> getChanges() {\n\t\tList<ReplaceRegion> changes = newArrayList();\n\t\tfor (Section section : sections) {\n\t\t\tReplaceRegion change = section.getChange();\n\t\t\tchanges.add(change);\n\t\t}\n\t\tfor (ReplaceRegion change : importSection.rewrite()) {\n\t\t\tchanges.add(change);\n\t\t}\n\t\treturn changes;\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"public IDocument getDocument() {\n\t\treturn document;\n\t}","id":26964,"modified_method":"public IXtextDocument getDocument() {\n\t\treturn document;\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"public Section newSection(int offset, int length, int indentationLevel, boolean ensureEmptyLinesAround) {\n\t\tWhitespaceHelper whitespaceHelper = factory.whitespaceHelperProvider.get();\n\t\twhitespaceHelper.initialize(document, offset, length, ensureEmptyLinesAround);\n\t\tSection section = new Section(this, indentationLevel, indentString, lineSeparator, whitespaceHelper);\n\t\tfor (Section otherSection : sections)\n\t\t\tif (section.isOverlap(otherSection))\n\t\t\t\tthrow new IllegalArgumentException(\"Section overlaps with exisiting section\");\n\t\tfor (int i = 0; i < indentationLevel; ++i)\n\t\t\tsection.increaseIndentation();\n\t\tsections.add(section);\n\t\treturn section;\n\t}","id":26965,"modified_method":"public Section newSection(int offset, int length, int baseIndentationLevel, boolean ensureEmptyLinesAround) {\n\t\tOptionalParameters parameters = createOptionalParameters();\n\t\tparameters.ensureEmptyLinesAround = ensureEmptyLinesAround;\n\t\tparameters.baseIndentationLevel = baseIndentationLevel;\n\t\tSection section = factory.sectionFactory.create(document, resource, offset, length, parameters);\n\t\taddSection(section);\n\t\treturn section;\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"public Section newSection(int offset, int length) {\n\t\treturn newSection(offset, length, getIndentationLevelAtOffset(offset, document), false);\n\t}","id":26966,"modified_method":"public Section newSection(int offset, int length) {\n\t\tOptionalParameters parameters = createOptionalParameters();\n\t\tSection section = factory.sectionFactory.create(document, resource, offset, length, parameters);\n\t\taddSection(section);\n\t\treturn section;\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"public DocumentRewriter create(IDocument document, XtextResource resource) {\n\t\t\tRewritableImportSection importSection = rewritableImportSectionFactory.parse(resource);\n\t\t\tImportManager importManager = new ImportManager(importSection);\n\t\t\tString indentString = indentInformation.getIndentString();\n\t\t\tString lineSeparator = whitespaceInformationProvider.getLineSeparatorInformation(resource.getURI())\n\t\t\t\t\t.getLineSeparator();\n\t\t\treturn new DocumentRewriter(document, importManager, indentString, lineSeparator, this);\n\t\t}","id":26967,"modified_method":"public DocumentRewriter create(IXtextDocument document, XtextResource resource) {\n\t\t\treturn new DocumentRewriter(document, resource, this);\n\t\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Section(DocumentRewriter documentEditor, int initialIndentationLevel, String indentString,\n\t\t\t\tString lineSeparator, WhitespaceHelper whitespaceHelper) {\n\t\t\tsuper(indentString, lineSeparator, false);\n\t\t\tthis.documentRewriter = documentEditor;\n\t\t\tthis.baseIndentationLevel = initialIndentationLevel;\n\t\t\tthis.whitespaceHelper = whitespaceHelper;\n\t\t\tthis.indentString = indentString;\n\t\t}","id":26968,"modified_method":"public Section(IXtextDocument document, RewritableImportSection importSection, WhitespaceHelper whitespaceHelper, String indentString,\n\t\t\t\tString lineSeparator, int baseIndentationLevel) {\n\t\t\tsuper(document, importSection, whitespaceHelper, indentString, lineSeparator, baseIndentationLevel);\n\t\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"protected DocumentRewriter(IDocument document, ImportManager importManager, String indentString,\n\t\t\tString lineSeparator, Factory factory) {\n\t\tthis.document = document;\n\t\tthis.importManager = importManager;\n\t\tthis.indentString = indentString;\n\t\tthis.lineSeparator = lineSeparator;\n\t\tthis.factory = factory;\n\t\tsections = newArrayList();\n\t}","id":26969,"modified_method":"protected DocumentRewriter(IXtextDocument document, XtextResource resource, Factory factory) {\n\t\tthis.document = document;\n\t\tthis.resource = resource;\n\t\tthis.importSection = factory.rewritableImportSectionFactory.parse(resource);\n\t\timportSection.setSort(true);\n\t\tthis.indentString = factory.whitespaceInformationProvider.getIndentationInformation(resource.getURI()).getIndentString();\n\t\tthis.lineSeparator = factory.whitespaceInformationProvider.getLineSeparatorInformation(resource.getURI())\n\t\t\t\t.getLineSeparator();\n\t\tthis.factory = factory;\n\t\tsections = newArrayList();\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"protected ICompletionProposal createOverrideMethodProposal(XtendClass model, JvmExecutable overridden,\n\t\t\tfinal ContentAssistContext context, IProposalConflictHelper conflictHelper) {\n\t\tReplacingAppendable appendable = appendableFactory.get(context.getDocument(), model, context.getReplaceRegion()\n\t\t\t\t.getOffset(), context.getReplaceRegion().getLength(), 1, true);\n\t\tfinal String simpleName;\n\t\tif (overridden instanceof JvmOperation) {\n\t\t\timplementor.appendOverrideFunction(model, (JvmOperation) overridden, appendable);\n\t\t\tsimpleName = overridden.getSimpleName();\n\t\t} else {\n\t\t\timplementor.appendConstructorFromSuper(model, (JvmConstructor) overridden, appendable);\n\t\t\tsimpleName = \"new\";\n\t\t}\n\t\tString code = appendable.getCode();\n\t\tif (!isValidProposal(code.trim(), context, conflictHelper) && !isValidProposal(simpleName, context, conflictHelper))\n\t\t\treturn null;\n\t\tImageDescriptor imageDescriptor = images.forOperation(overridden.getVisibility(), adornments.getOverrideAdornment(overridden));\n\t\tImportOrganizingProposal completionProposal = createCompletionProposal(appendable, context.getReplaceRegion(),\n\t\t\t\tgetLabel(overridden), imageHelper.getImage(imageDescriptor));\n\t\tMatcher matcher = bodyExpressionPattern.matcher(code);\n\t\tif (matcher.find()) {\n\t\t\tint bodyExpressionLength = matcher.end(1) - matcher.start(1);\n\t\t\tint bodyExpressionStart = matcher.start(1) + appendable.getTotalOffset() - completionProposal.getReplacementOffset();\n\t\t\tif (bodyExpressionLength == 0) {\n\t\t\t\tcompletionProposal.setCursorPosition(bodyExpressionStart);\n\t\t\t} else {\n\t\t\t\tcompletionProposal.setSelectionStart(completionProposal.getReplacementOffset() + bodyExpressionStart);\n\t\t\t\tcompletionProposal.setSelectionLength(bodyExpressionLength);\n\t\t\t\tcompletionProposal.setAutoInsertable(false);\n\t\t\t\tcompletionProposal.setCursorPosition(bodyExpressionStart + bodyExpressionLength);\n\t\t\t\tcompletionProposal.setSimpleLinkedMode(context.getViewer(), '\\t');\n\t\t\t}\n\t\t}\n\t\tcompletionProposal.setPriority(getPriority(model, overridden, context));\n\t\tcompletionProposal.setMatcher(new PrefixMatcher() {\n\n\t\t\t@Override\n\t\t\tpublic boolean isCandidateMatchingPrefix(String name, String prefix) {\n\t\t\t\tPrefixMatcher delegate = context.getMatcher();\n\t\t\t\tboolean result = delegate.isCandidateMatchingPrefix(simpleName, prefix);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\treturn completionProposal;\n\t}","id":26970,"modified_method":"protected ICompletionProposal createOverrideMethodProposal(XtendClass model, JvmExecutable overridden,\n\t\t\tfinal ContentAssistContext context, IProposalConflictHelper conflictHelper) {\n\t\tReplacingAppendable appendable = appendableFactory.create(context.getDocument(), (XtextResource) model.eResource(), context.getReplaceRegion()\n\t\t\t\t.getOffset(), context.getReplaceRegion().getLength(), new OptionalParameters() {{ \n\t\t\t\t\tensureEmptyLinesAround = true;\n\t\t\t\t\tbaseIndentationLevel = 1;\t\n\t\t\t\t}});\n\t\tfinal String simpleName;\n\t\tif (overridden instanceof JvmOperation) {\n\t\t\timplementor.appendOverrideFunction(model, (JvmOperation) overridden, appendable);\n\t\t\tsimpleName = overridden.getSimpleName();\n\t\t} else {\n\t\t\timplementor.appendConstructorFromSuper(model, (JvmConstructor) overridden, appendable);\n\t\t\tsimpleName = \"new\";\n\t\t}\n\t\tString code = appendable.getCode();\n\t\tif (!isValidProposal(code.trim(), context, conflictHelper) && !isValidProposal(simpleName, context, conflictHelper))\n\t\t\treturn null;\n\t\tImageDescriptor imageDescriptor = images.forOperation(overridden.getVisibility(), adornments.getOverrideAdornment(overridden));\n\t\tImportOrganizingProposal completionProposal = createCompletionProposal(appendable, context.getReplaceRegion(),\n\t\t\t\tgetLabel(overridden), imageHelper.getImage(imageDescriptor));\n\t\tMatcher matcher = bodyExpressionPattern.matcher(code);\n\t\tif (matcher.find()) {\n\t\t\tint bodyExpressionLength = matcher.end(1) - matcher.start(1);\n\t\t\tint bodyExpressionStart = matcher.start(1) + appendable.getTotalOffset() - completionProposal.getReplacementOffset();\n\t\t\tif (bodyExpressionLength == 0) {\n\t\t\t\tcompletionProposal.setCursorPosition(bodyExpressionStart);\n\t\t\t} else {\n\t\t\t\tcompletionProposal.setSelectionStart(completionProposal.getReplacementOffset() + bodyExpressionStart);\n\t\t\t\tcompletionProposal.setSelectionLength(bodyExpressionLength);\n\t\t\t\tcompletionProposal.setAutoInsertable(false);\n\t\t\t\tcompletionProposal.setCursorPosition(bodyExpressionStart + bodyExpressionLength);\n\t\t\t\tcompletionProposal.setSimpleLinkedMode(context.getViewer(), '\\t');\n\t\t\t}\n\t\t}\n\t\tcompletionProposal.setPriority(getPriority(model, overridden, context));\n\t\tcompletionProposal.setMatcher(new PrefixMatcher() {\n\n\t\t\t@Override\n\t\t\tpublic boolean isCandidateMatchingPrefix(String name, String prefix) {\n\t\t\t\tPrefixMatcher delegate = context.getMatcher();\n\t\t\t\tboolean result = delegate.isCandidateMatchingPrefix(simpleName, prefix);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\treturn completionProposal;\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void apply(IDocument document) {\n\t\ttry {\n\t\t\tint shiftOffsetBy = appendable.commitChanges(getReplacementOffset(), getReplacementLength());\n\t\t\tsetSelectionStart(getSelectionStart() + shiftOffsetBy);\n\t\t\tsetCursorPosition(getCursorPosition() + shiftOffsetBy);\n\t\t\tif (isLinkedMode()) {\n\t\t\t\tsetUpLinkedMode(document);\n\t\t\t}\n\t\t} catch (BadLocationException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","id":26971,"modified_method":"@Override\n\tpublic void apply(IDocument document) {\n\t\ttry {\n\t\t\tint shiftOffsetBy = appendable.commitChanges();\n\t\t\tsetSelectionStart(getSelectionStart() + shiftOffsetBy);\n\t\t\tsetCursorPosition(getCursorPosition() + shiftOffsetBy);\n\t\t\tif (isLinkedMode()) {\n\t\t\t\tsetUpLinkedMode(document);\n\t\t\t}\n\t\t} catch (BadLocationException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void createImportProposals(final JvmDeclaredType contextType, final Issue issue, String typeSimpleName, IJavaSearchScope searchScope,\n\t\t\tfinal IssueResolutionAcceptor acceptor) throws JavaModelException {\n\t\tif(contextType != null) {\n\t\t\tfinal String wantedTypeName = typeSimpleName.contains(\"::\") \n\t\t\t\t? typeSimpleName.substring(0, typeSimpleName.indexOf(\"::\")) \n\t\t\t\t: typeSimpleName;\n\t\t\tBasicSearchEngine searchEngine = new BasicSearchEngine();\n\t\t\tsearchEngine.searchAllTypeNames(null, SearchPattern.R_EXACT_MATCH, wantedTypeName.toCharArray(),\n\t\t\t\t\tSearchPattern.R_EXACT_MATCH, IJavaSearchConstants.TYPE, searchScope, new IRestrictedAccessTypeRequestor() {\n\t\t\t\t\t\t\n\t\t\t\t\t\tpublic void acceptType(int modifiers, char[] packageName, char[] simpleTypeName, char[][] enclosingTypeNames,\n\t\t\t\t\t\t\t\tString path, AccessRestriction access) {\n\t\t\t\t\t\t\tfinal String qualifiedTypeName = getQualifiedTypeName(packageName, enclosingTypeNames,\n\t\t\t\t\t\t\t\t\tsimpleTypeName);\n\t\t\t\t\t\t\tif(access == null || (access.getProblemId() != IProblem.ForbiddenReference && !access.ignoreIfBetter())){\n\t\t\t\t\t\t\t\tJvmType importType = typeRefs.findDeclaredType(qualifiedTypeName, contextType);\n\t\t\t\t\t\t\t\tif(importType instanceof JvmDeclaredType\n\t\t\t\t\t\t\t\t\t\t&& visibilityService.isVisible((JvmDeclaredType)importType, contextType)) {\n\t\t\t\t\t\t\t\t\tStringBuilder label = new StringBuilder(\"Import '\");\n\t\t\t\t\t\t\t\t\tlabel.append(simpleTypeName);\n\t\t\t\t\t\t\t\t\tlabel.append(\"' (\");\n\t\t\t\t\t\t\t\t\tlabel.append(packageName);\n\t\t\t\t\t\t\t\t\tif(enclosingTypeNames != null && enclosingTypeNames.length > 0) {\n\t\t\t\t\t\t\t\t\t\tfor(char[] enclosingTypeName: enclosingTypeNames) {\n\t\t\t\t\t\t\t\t\t\t\tlabel.append(\".\");\n\t\t\t\t\t\t\t\t\t\t\tlabel.append(enclosingTypeName);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlabel.append(\")\");\n\t\t\t\t\t\t\t\t\tacceptor.accept(issue, label.toString(), label.toString(), \"impc_obj.gif\", new ISemanticModification() {\n\t\t\t\t\t\t\t\t\t\t@SuppressWarnings(\"null\")\n\t\t\t\t\t\t\t\t\t\tpublic void apply(EObject element, IModificationContext context) throws Exception {\n\t\t\t\t\t\t\t\t\t\t\tReplacingAppendable appendable = appendableFactory.get(context.getXtextDocument(),\n\t\t\t\t\t\t\t\t\t\t\t\t\telement, 0, 0);\n\t\t\t\t\t\t\t\t\t\t\tappendable.append(typeRefs.findDeclaredType(qualifiedTypeName, element));\n\t\t\t\t\t\t\t\t\t\t\tappendable.insertNewImports();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, jdtTypeRelevance.getRelevance(qualifiedTypeName, wantedTypeName) + 100);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, new NullProgressMonitor());\n\t\t}\n\t}","id":26972,"modified_method":"protected void createImportProposals(final JvmDeclaredType contextType, final Issue issue, String typeSimpleName, IJavaSearchScope searchScope,\n\t\t\tfinal IssueResolutionAcceptor acceptor) throws JavaModelException {\n\t\tif(contextType != null) {\n\t\t\tfinal String wantedTypeName = typeSimpleName.contains(\"::\") \n\t\t\t\t? typeSimpleName.substring(0, typeSimpleName.indexOf(\"::\")) \n\t\t\t\t: typeSimpleName;\n\t\t\tBasicSearchEngine searchEngine = new BasicSearchEngine();\n\t\t\tsearchEngine.searchAllTypeNames(null, SearchPattern.R_EXACT_MATCH, wantedTypeName.toCharArray(),\n\t\t\t\t\tSearchPattern.R_EXACT_MATCH, IJavaSearchConstants.TYPE, searchScope, new IRestrictedAccessTypeRequestor() {\n\t\t\t\t\t\t\n\t\t\t\t\t\tpublic void acceptType(int modifiers, char[] packageName, char[] simpleTypeName, char[][] enclosingTypeNames,\n\t\t\t\t\t\t\t\tString path, AccessRestriction access) {\n\t\t\t\t\t\t\tfinal String qualifiedTypeName = getQualifiedTypeName(packageName, enclosingTypeNames,\n\t\t\t\t\t\t\t\t\tsimpleTypeName);\n\t\t\t\t\t\t\tif(access == null || (access.getProblemId() != IProblem.ForbiddenReference && !access.ignoreIfBetter())){\n\t\t\t\t\t\t\t\tJvmType importType = typeRefs.findDeclaredType(qualifiedTypeName, contextType);\n\t\t\t\t\t\t\t\tif(importType instanceof JvmDeclaredType\n\t\t\t\t\t\t\t\t\t\t&& visibilityService.isVisible((JvmDeclaredType)importType, contextType)) {\n\t\t\t\t\t\t\t\t\tStringBuilder label = new StringBuilder(\"Import '\");\n\t\t\t\t\t\t\t\t\tlabel.append(simpleTypeName);\n\t\t\t\t\t\t\t\t\tlabel.append(\"' (\");\n\t\t\t\t\t\t\t\t\tlabel.append(packageName);\n\t\t\t\t\t\t\t\t\tif(enclosingTypeNames != null && enclosingTypeNames.length > 0) {\n\t\t\t\t\t\t\t\t\t\tfor(char[] enclosingTypeName: enclosingTypeNames) {\n\t\t\t\t\t\t\t\t\t\t\tlabel.append(\".\");\n\t\t\t\t\t\t\t\t\t\t\tlabel.append(enclosingTypeName);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlabel.append(\")\");\n\t\t\t\t\t\t\t\t\tacceptor.accept(issue, label.toString(), label.toString(), \"impc_obj.gif\", new ISemanticModification() {\n\t\t\t\t\t\t\t\t\t\tpublic void apply(EObject element, IModificationContext context) throws Exception {\n\t\t\t\t\t\t\t\t\t\t\tReplacingAppendable appendable = appendableFactory.create(context.getXtextDocument(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t(XtextResource) element.eResource(), 0, 0);\n\t\t\t\t\t\t\t\t\t\t\tappendable.append(typeRefs.findDeclaredType(qualifiedTypeName, element));\n\t\t\t\t\t\t\t\t\t\t\tappendable.insertNewImports();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, jdtTypeRelevance.getRelevance(qualifiedTypeName, wantedTypeName) + 100);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, new NullProgressMonitor());\n\t\t}\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"public int insertNewImports() throws BadLocationException {\n\t\tList<ReplaceRegion> importChanges = importSection.rewrite();\n\t\tint lengthDelta = 0;\n\t\tif(!importChanges.isEmpty()) {\n\t\t\tfor(ReplaceRegion change: importChanges) {\n\t\t\t\tlengthDelta = lengthDelta - change.getLength() + change.getText().length(); \n\t\t\t}\n\t\t\treplaceConverter.convertToTextEdit(importChanges).apply(document);\n\t\t}\n\t\treturn lengthDelta;\n\t}","id":26973,"modified_method":"public int insertNewImports() throws BadLocationException {\n\t\tList<ReplaceRegion> importChanges = getImportSection().rewrite();\n\t\tint lengthDelta = 0;\n\t\tif(!importChanges.isEmpty()) {\n\t\t\tfor(ReplaceRegion change: importChanges) {\n\t\t\t\tlengthDelta = lengthDelta - change.getLength() + change.getText().length(); \n\t\t\t}\n\t\t\treplaceConverter.convertToTextEdit(importChanges).apply(getDocument());\n\t\t}\n\t\treturn lengthDelta;\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"public void commitChanges() throws BadLocationException {\n\t\tdocument.replace(whitespaceHelper.getTotalOffset(), whitespaceHelper.getTotalLength(), toString());\n\t\tinsertNewImports();\n\t}","id":26974,"modified_method":"public int commitChanges() throws BadLocationException {\n\t\tReplaceRegion change = getChange();\n\t\tgetDocument().replace(change.getOffset(), change.getLength(), change.getText());\n\t\treturn insertNewImports();\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"public ReplacingAppendable(RewritableImportSection importSection, String lineSeparator, String indentString, IXtextDocument document,\n\t\t\tWhitespaceHelper whitespaceHelper, ReplaceConverter replaceConverter) {\n\t\tsuper(indentString, lineSeparator, false);\n\t\tthis.importSection = importSection;\n\t\tthis.document = document;\n\t\tthis.whitespaceHelper = whitespaceHelper;\n\t\tthis.replaceConverter = replaceConverter;\n\t}","id":26975,"modified_method":"protected ReplacingAppendable(IXtextDocument document, RewritableImportSection importSection, WhitespaceHelper whitespaceHelper,\n\t\t\tString indentString, String lineSeparator, int baseIndentationLevel, ReplaceConverter replaceConverter) {\n\t\tsuper(document, importSection, whitespaceHelper, indentString, lineSeparator, baseIndentationLevel);\n\t\tthis.replaceConverter = replaceConverter;\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"protected XtextDocument insertListField(final String model, final String fieldName)\n\t\t\tthrows Exception {\n\t\tfinal int cursorPosition = model.indexOf('|');\n\t\tString actualModel = model.replace(\"|\", \" \");\n\t\tfinal XtendFile file = testHelper.xtendFile(\"Foo\", actualModel);\n\t\tfinal XtextDocument document = documentProvider.get();\n\t\tdocument.set(actualModel);\n\t\tXtextResource xtextResource = (XtextResource) file.eResource();\n\t\tdocument.setInput(xtextResource);\n\t\tfinal EObject context = eObjectAtOffsetHelper.resolveElementAt(xtextResource, cursorPosition);\n\t\tdocument.modify(new IUnitOfWork.Void<XtextResource>() {\n\t\t\t@Override\n\t\t\tpublic void process(XtextResource state) throws Exception {\n\t\t\t\tReplacingAppendable a = appendableFactory.get(document, context, cursorPosition, 1, 0, false);\n\t\t\t\tITypeReferenceOwner owner = new StandardTypeReferenceOwner(services, context);\n\t\t\t\tOwnedConverter converter = new OwnedConverter(owner);\n\t\t\t\tLightweightTypeReference typeRef = converter.apply(services.getTypeReferences().getTypeForName(List.class, context, typesFactory.createJvmWildcardTypeReference()));\n\t\t\t\ta.append(typeRef);\n\t\t\t\ta.append(\" \").append(fieldName);\n\t\t\t\ta.commitChanges();\n\t\t\t}\n\t\t});\n\t\treturn document;\n\t}","id":26976,"modified_method":"protected XtextDocument insertListField(final String model, final String fieldName)\n\t\t\tthrows Exception {\n\t\tfinal int cursorPosition = model.indexOf('|');\n\t\tString actualModel = model.replace(\"|\", \" \");\n\t\tfinal XtendFile file = testHelper.xtendFile(\"Foo\", actualModel);\n\t\tfinal XtextDocument document = documentProvider.get();\n\t\tdocument.set(actualModel);\n\t\tXtextResource xtextResource = (XtextResource) file.eResource();\n\t\tdocument.setInput(xtextResource);\n\t\tfinal EObject context = eObjectAtOffsetHelper.resolveElementAt(xtextResource, cursorPosition);\n\t\tdocument.modify(new IUnitOfWork.Void<XtextResource>() {\n\t\t\t@Override\n\t\t\tpublic void process(XtextResource state) throws Exception {\n\t\t\t\tReplacingAppendable a = appendableFactory.create(document, state, cursorPosition, 1);\n\t\t\t\tITypeReferenceOwner owner = new StandardTypeReferenceOwner(services, context);\n\t\t\t\tOwnedConverter converter = new OwnedConverter(owner);\n\t\t\t\tLightweightTypeReference typeRef = converter.apply(services.getTypeReferences().getTypeForName(List.class, context, typesFactory.createJvmWildcardTypeReference()));\n\t\t\t\ta.append(typeRef);\n\t\t\t\ta.append(\" \").append(fieldName);\n\t\t\t\ta.commitChanges();\n\t\t\t}\n\t\t});\n\t\treturn document;\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"@Fix(IssueCodes.CLASS_MUST_BE_ABSTRACT)\n\tpublic void implementAbstractMethods(final Issue issue, IssueResolutionAcceptor acceptor) {\n\t\tif (issue.getData() != null && issue.getData().length > 0) {\n\t\t\tacceptor.accept(issue, \"Add unimplemented methods\", \"Add unimplemented methods\", \"fix_indent.gif\",\n\t\t\t\t\tnew ISemanticModification() {\n\t\t\t\t\t\tpublic void apply(EObject element, IModificationContext context) throws Exception {\n\t\t\t\t\t\t\tXtendClass clazz = (XtendClass) element;\n\t\t\t\t\t\t\tIXtextDocument document = context.getXtextDocument();\n\t\t\t\t\t\t\tReplacingAppendable appendable = appendableFactory.get(document, clazz,\n\t\t\t\t\t\t\t\t\tinsertionOffsets.getNewMethodInsertOffset(null, clazz), 0, 1, true);\n\t\t\t\t\t\t\tboolean isFirst = true;\n\t\t\t\t\t\t\tfor (String operationUriAsString : issue.getData()) {\n\t\t\t\t\t\t\t\tURI operationURI = URI.createURI(operationUriAsString);\n\t\t\t\t\t\t\t\tEObject overridden = clazz.eResource().getResourceSet().getEObject(operationURI, true);\n\t\t\t\t\t\t\t\tif (overridden instanceof JvmOperation) {\n\t\t\t\t\t\t\t\t\tif(!isFirst) \n\t\t\t\t\t\t\t\t\t\tappendable.newLine().newLine();\n\t\t\t\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t\t\t\t\tsuperMemberImplementor.appendOverrideFunction(clazz, (JvmOperation) overridden,\n\t\t\t\t\t\t\t\t\t\t\tappendable);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tappendable.commitChanges();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\t\tacceptor.accept(issue, \"Make class abstract\", \"Make class abstract\", \"fix_indent.gif\",\n\t\t\t\tnew ISemanticModification() {\n\t\t\tpublic void apply(EObject element, IModificationContext context) throws Exception {\n\t\t\t\tinternalDoAddAbstractKeyword(element, context);\n\t\t\t}\n\t\t});\n\t}","id":26977,"modified_method":"@Fix(IssueCodes.CLASS_MUST_BE_ABSTRACT)\n\tpublic void implementAbstractMethods(final Issue issue, IssueResolutionAcceptor acceptor) {\n\t\tif (issue.getData() != null && issue.getData().length > 0) {\n\t\t\tacceptor.accept(issue, \"Add unimplemented methods\", \"Add unimplemented methods\", \"fix_indent.gif\",\n\t\t\t\t\tnew ISemanticModification() {\n\t\t\t\t\t\tpublic void apply(EObject element, IModificationContext context) throws Exception {\n\t\t\t\t\t\t\tXtendClass clazz = (XtendClass) element;\n\t\t\t\t\t\t\tIXtextDocument document = context.getXtextDocument();\n\t\t\t\t\t\t\tReplacingAppendable appendable = appendableFactory.create(document, (XtextResource) clazz.eResource(),\n\t\t\t\t\t\t\t\t\tinsertionOffsets.getNewMethodInsertOffset(null, clazz), 0, new OptionalParameters() {{ \n\t\t\t\t\t\t\t\t\t\tensureEmptyLinesAround = true;\n\t\t\t\t\t\t\t\t\t\tbaseIndentationLevel = 1;\t\n\t\t\t\t\t\t\t\t\t}});\n\t\t\t\t\t\t\tboolean isFirst = true;\n\t\t\t\t\t\t\tfor (String operationUriAsString : issue.getData()) {\n\t\t\t\t\t\t\t\tURI operationURI = URI.createURI(operationUriAsString);\n\t\t\t\t\t\t\t\tEObject overridden = clazz.eResource().getResourceSet().getEObject(operationURI, true);\n\t\t\t\t\t\t\t\tif (overridden instanceof JvmOperation) {\n\t\t\t\t\t\t\t\t\tif(!isFirst) \n\t\t\t\t\t\t\t\t\t\tappendable.newLine().newLine();\n\t\t\t\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t\t\t\t\tsuperMemberImplementor.appendOverrideFunction(clazz, (JvmOperation) overridden,\n\t\t\t\t\t\t\t\t\t\t\tappendable);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tappendable.commitChanges();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\t\tacceptor.accept(issue, \"Make class abstract\", \"Make class abstract\", \"fix_indent.gif\",\n\t\t\t\tnew ISemanticModification() {\n\t\t\tpublic void apply(EObject element, IModificationContext context) throws Exception {\n\t\t\t\tinternalDoAddAbstractKeyword(element, context);\n\t\t\t}\n\t\t});\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"@Fix(org.eclipse.xtext.xbase.validation.IssueCodes.UNHANDLED_EXCEPTION)\n\tpublic void surroundWithTryCatch(final Issue issue, IssueResolutionAcceptor acceptor) {\n\t\tif (issue.getData() != null && issue.getData().length > 1)\n\t\t\tacceptor.accept(issue, \"Surround with try/catch block\", \"Surround with try/catch block\", \"fix_indent.gif\",\n\t\t\t\t\tnew ISemanticModification() {\n\t\t\t\t\t\tpublic void apply(EObject element, IModificationContext context) throws Exception {\n\t\t\t\t\t\t\tString[] issueData = issue.getData();\n\t\t\t\t\t\t\tURI childURI = URI.createURI(issueData[issueData.length - 1]);\n\t\t\t\t\t\t\tXtextResource xtextResource = (XtextResource) element.eResource();\n\t\t\t\t\t\t\tList<JvmType> exceptions = getExceptions(issueData, xtextResource);\n\t\t\t\t\t\t\tif (exceptions.size() > 0) {\n\t\t\t\t\t\t\t\tEObject childThrowingException = xtextResource.getResourceSet().getEObject(childURI, true);\n\t\t\t\t\t\t\t\tXExpression toBeSurrounded = findContainerExpressionInBlockExpression(childThrowingException);\n\t\t\t\t\t\t\t\tIXtextDocument xtextDocument = context.getXtextDocument();\n\t\t\t\t\t\t\t\tif (toBeSurrounded != null) {\n\t\t\t\t\t\t\t\t\tICompositeNode toBeSurroundedNode = NodeModelUtils.findActualNodeFor(toBeSurrounded);\n\t\t\t\t\t\t\t\t\tif (toBeSurroundedNode == null)\n\t\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"toBeSurroundedNode may not be null\");\n\t\t\t\t\t\t\t\t\tReplacingAppendable appendable = appendableFactory.get(\n\t\t\t\t\t\t\t\t\t\t\tcontext.getXtextDocument(),\n\t\t\t\t\t\t\t\t\t\t\tchildThrowingException, \n\t\t\t\t\t\t\t\t\t\t\ttoBeSurroundedNode.getOffset(),\n\t\t\t\t\t\t\t\t\t\t\ttoBeSurroundedNode.getLength());\n\t\t\t\t\t\t\t\t\tappendable\n\t\t\t\t\t\t\t\t\t\t\t.append(\"try {\")\n\t\t\t\t\t\t\t\t\t\t\t.increaseIndentation()\n\t\t\t\t\t\t\t\t\t\t\t\t.newLine()\n\t\t\t\t\t\t\t\t\t\t\t\t.append(xtextDocument.get(toBeSurroundedNode.getOffset(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttoBeSurroundedNode.getLength()))\n\t\t\t\t\t\t\t\t\t\t\t.decreaseIndentation()\n\t\t\t\t\t\t\t\t\t\t\t.newLine();\n\t\t\t\t\t\t\t\t\tfor(JvmType exceptionType: exceptions) {\n\t\t\t\t\t\t\t\t\t\tappendable\n\t\t\t\t\t\t\t\t\t\t\t.append(\"} catch (\")\n\t\t\t\t\t\t\t\t\t\t// TODO type ref?\n\t\t\t\t\t\t\t\t\t\t\t.append(exceptionType).append(\" exc) {\").increaseIndentation()\n\t\t\t\t\t\t\t\t\t\t\t\t.newLine()\n\t\t\t\t\t\t\t\t\t\t\t\t.append(\"throw new RuntimeException(\\\"auto-generated try/catch\\\", exc)\").decreaseIndentation()\n\t\t\t\t\t\t\t\t\t\t\t.newLine();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tappendable.append(\"}\");\n\t\t\t\t\t\t\t\t\tappendable.commitChanges();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t}","id":26978,"modified_method":"@Fix(org.eclipse.xtext.xbase.validation.IssueCodes.UNHANDLED_EXCEPTION)\n\tpublic void surroundWithTryCatch(final Issue issue, IssueResolutionAcceptor acceptor) {\n\t\tif (issue.getData() != null && issue.getData().length > 1)\n\t\t\tacceptor.accept(issue, \"Surround with try/catch block\", \"Surround with try/catch block\", \"fix_indent.gif\",\n\t\t\t\t\tnew ISemanticModification() {\n\t\t\t\t\t\tpublic void apply(EObject element, IModificationContext context) throws Exception {\n\t\t\t\t\t\t\tString[] issueData = issue.getData();\n\t\t\t\t\t\t\tURI childURI = URI.createURI(issueData[issueData.length - 1]);\n\t\t\t\t\t\t\tXtextResource xtextResource = (XtextResource) element.eResource();\n\t\t\t\t\t\t\tList<JvmType> exceptions = getExceptions(issueData, xtextResource);\n\t\t\t\t\t\t\tif (exceptions.size() > 0) {\n\t\t\t\t\t\t\t\tEObject childThrowingException = xtextResource.getResourceSet().getEObject(childURI, true);\n\t\t\t\t\t\t\t\tXExpression toBeSurrounded = findContainerExpressionInBlockExpression(childThrowingException);\n\t\t\t\t\t\t\t\tIXtextDocument xtextDocument = context.getXtextDocument();\n\t\t\t\t\t\t\t\tif (toBeSurrounded != null) {\n\t\t\t\t\t\t\t\t\tICompositeNode toBeSurroundedNode = NodeModelUtils.findActualNodeFor(toBeSurrounded);\n\t\t\t\t\t\t\t\t\tif (toBeSurroundedNode == null)\n\t\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"toBeSurroundedNode may not be null\");\n\t\t\t\t\t\t\t\t\tReplacingAppendable appendable = appendableFactory.create(\n\t\t\t\t\t\t\t\t\t\t\tcontext.getXtextDocument(),\n\t\t\t\t\t\t\t\t\t\t\t(XtextResource) childThrowingException.eResource(), \n\t\t\t\t\t\t\t\t\t\t\ttoBeSurroundedNode.getOffset(),\n\t\t\t\t\t\t\t\t\t\t\ttoBeSurroundedNode.getLength());\n\t\t\t\t\t\t\t\t\tappendable\n\t\t\t\t\t\t\t\t\t\t\t.append(\"try {\")\n\t\t\t\t\t\t\t\t\t\t\t.increaseIndentation()\n\t\t\t\t\t\t\t\t\t\t\t\t.newLine()\n\t\t\t\t\t\t\t\t\t\t\t\t.append(xtextDocument.get(toBeSurroundedNode.getOffset(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttoBeSurroundedNode.getLength()))\n\t\t\t\t\t\t\t\t\t\t\t.decreaseIndentation()\n\t\t\t\t\t\t\t\t\t\t\t.newLine();\n\t\t\t\t\t\t\t\t\tfor(JvmType exceptionType: exceptions) {\n\t\t\t\t\t\t\t\t\t\tappendable\n\t\t\t\t\t\t\t\t\t\t\t.append(\"} catch (\")\n\t\t\t\t\t\t\t\t\t\t// TODO type ref?\n\t\t\t\t\t\t\t\t\t\t\t.append(exceptionType).append(\" exc) {\").increaseIndentation()\n\t\t\t\t\t\t\t\t\t\t\t\t.newLine()\n\t\t\t\t\t\t\t\t\t\t\t\t.append(\"throw new RuntimeException(\\\"auto-generated try/catch\\\", exc)\").decreaseIndentation()\n\t\t\t\t\t\t\t\t\t\t\t.newLine();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tappendable.append(\"}\");\n\t\t\t\t\t\t\t\t\tappendable.commitChanges();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"@Fix(IssueCodes.MISSING_CONSTRUCTOR)\n\tpublic void addConstuctorFromSuper(final Issue issue, IssueResolutionAcceptor acceptor) {\n\t\tif (issue.getData() != null) {\n\t\t\tfor(int i=0; i<issue.getData().length; i+=2) {\n\t\t\t\tfinal URI constructorURI = URI.createURI(issue.getData()[i]);\n\t\t\t\tString javaSignature = issue.getData()[i+1];\n\t\t\t\tString xtendSignature = \"new\" + javaSignature.substring(javaSignature.indexOf('('));\n\t\t\t\tacceptor.accept(issue, \"Add constructor \" + xtendSignature, \"Add constructor \" + xtendSignature, \"fix_indent.gif\",\n\t\t\t\t\tnew ISemanticModification() {\n\t\t\t\t\t\tpublic void apply(EObject element, IModificationContext context) throws Exception {\n\t\t\t\t\t\t\tXtendClass clazz = (XtendClass) element;\n\t\t\t\t\t\t\tReplacingAppendable appendable = appendableFactory.get(context.getXtextDocument(), clazz,\n\t\t\t\t\t\t\t\t\tinsertionOffsets.getNewConstructorInsertOffset(null, clazz), 0, 1, true);\n\t\t\t\t\t\t\tEObject constructor = clazz.eResource().getResourceSet().getEObject(constructorURI, true);\n\t\t\t\t\t\t\tif (constructor instanceof JvmConstructor) {\n\t\t\t\t\t\t\t\tsuperMemberImplementor.appendConstructorFromSuper(clazz, (JvmConstructor) constructor,\n\t\t\t\t\t\t\t\t\t\tappendable);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tappendable.commitChanges();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}","id":26979,"modified_method":"@Fix(IssueCodes.MISSING_CONSTRUCTOR)\n\tpublic void addConstuctorFromSuper(final Issue issue, IssueResolutionAcceptor acceptor) {\n\t\tif (issue.getData() != null) {\n\t\t\tfor(int i=0; i<issue.getData().length; i+=2) {\n\t\t\t\tfinal URI constructorURI = URI.createURI(issue.getData()[i]);\n\t\t\t\tString javaSignature = issue.getData()[i+1];\n\t\t\t\tString xtendSignature = \"new\" + javaSignature.substring(javaSignature.indexOf('('));\n\t\t\t\tacceptor.accept(issue, \"Add constructor \" + xtendSignature, \"Add constructor \" + xtendSignature, \"fix_indent.gif\",\n\t\t\t\t\tnew ISemanticModification() {\n\t\t\t\t\t\tpublic void apply(EObject element, IModificationContext context) throws Exception {\n\t\t\t\t\t\t\tXtendClass clazz = (XtendClass) element;\n\t\t\t\t\t\t\tReplacingAppendable appendable = appendableFactory.create(context.getXtextDocument(), (XtextResource) clazz.eResource(),\n\t\t\t\t\t\t\t\t\tinsertionOffsets.getNewConstructorInsertOffset(null, clazz), 0, new OptionalParameters() {{ \n\t\t\t\t\t\t\t\t\t\tensureEmptyLinesAround = true;\n\t\t\t\t\t\t\t\t\t\tbaseIndentationLevel = 1;\t\n\t\t\t\t\t\t\t\t\t}});\n\t\t\t\t\t\t\tEObject constructor = clazz.eResource().getResourceSet().getEObject(constructorURI, true);\n\t\t\t\t\t\t\tif (constructor instanceof JvmConstructor) {\n\t\t\t\t\t\t\t\tsuperMemberImplementor.appendConstructorFromSuper(clazz, (JvmConstructor) constructor,\n\t\t\t\t\t\t\t\t\t\tappendable);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tappendable.commitChanges();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void internalDoAddAbstractKeyword(EObject element, IModificationContext context)\n\t\t\tthrows BadLocationException {\n\t\tif (element instanceof XtendFunction) {\n\t\t\telement = element.eContainer();\n\t\t}\n\t\tif (element instanceof XtendClass) {\n\t\t\tXtendClass clazz = (XtendClass) element;\n\t\t\tIXtextDocument document = context.getXtextDocument();\n\t\t\tICompositeNode clazzNode = NodeModelUtils.findActualNodeFor(clazz);\n\t\t\tif (clazzNode == null)\n\t\t\t\tthrow new IllegalStateException(\"Cannot determine node for clazz \" + clazz.getName());\n\t\t\tint offset = -1;\n\t\t\tfor (ILeafNode leafNode : clazzNode.getLeafNodes()) {\n\t\t\t\tif (leafNode.getText().equals(\"class\")) {\n\t\t\t\t\toffset = leafNode.getOffset();\n\t\t\t\t}\n\t\t\t}\n\t\t\tReplacingAppendable appendable = appendableFactory.get(document, clazz,\n\t\t\t\t\toffset, 0);\n\t\t\tappendable.append(\"abstract \");\n\t\t\tappendable.commitChanges();\n\t\t}\n\t}","id":26980,"modified_method":"protected void internalDoAddAbstractKeyword(EObject element, IModificationContext context)\n\t\t\tthrows BadLocationException {\n\t\tif (element instanceof XtendFunction) {\n\t\t\telement = element.eContainer();\n\t\t}\n\t\tif (element instanceof XtendClass) {\n\t\t\tXtendClass clazz = (XtendClass) element;\n\t\t\tIXtextDocument document = context.getXtextDocument();\n\t\t\tICompositeNode clazzNode = NodeModelUtils.findActualNodeFor(clazz);\n\t\t\tif (clazzNode == null)\n\t\t\t\tthrow new IllegalStateException(\"Cannot determine node for clazz \" + clazz.getName());\n\t\t\tint offset = -1;\n\t\t\tfor (ILeafNode leafNode : clazzNode.getLeafNodes()) {\n\t\t\t\tif (leafNode.getText().equals(\"class\")) {\n\t\t\t\t\toffset = leafNode.getOffset();\n\t\t\t\t}\n\t\t\t}\n\t\t\tReplacingAppendable appendable = appendableFactory.create(document, (XtextResource) clazz.eResource(),\n\t\t\t\t\toffset, 0);\n\t\t\tappendable.append(\"abstract \");\n\t\t\tappendable.commitChanges();\n\t\t}\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"@Fix(org.eclipse.xtext.xbase.validation.IssueCodes.UNHANDLED_EXCEPTION)\n\tpublic void addThrowsDeclaration(final Issue issue, IssueResolutionAcceptor acceptor) {\n\t\tif (issue.getData() != null && issue.getData().length > 0)\n\t\t\tacceptor.accept(issue, \"Add throws declaration\", \"Add throws declaration\", \"fix_indent.gif\",\n\t\t\t\t\tnew ISemanticModification() {\n\t\t\t\t\t\tpublic void apply(EObject element, IModificationContext context) throws Exception {\n\t\t\t\t\t\t\tString[] issueData = issue.getData(); \n\t\t\t\t\t\t\tXtendFunction xtendFunction = EcoreUtil2.getContainerOfType(element, XtendFunction.class);\n\t\t\t\t\t\t\tXtextResource xtextResource = (XtextResource) xtendFunction.eResource();\n\t\t\t\t\t\t\tList<JvmType> exceptions = getExceptions(issueData, xtextResource);\n\t\t\t\t\t\t\tif (exceptions.size() > 0) {\n\t\t\t\t\t\t\t\tint insertPosition;\n\t\t\t\t\t\t\t\tif (xtendFunction.getExpression() == null) {\n\t\t\t\t\t\t\t\t\tICompositeNode functionNode = NodeModelUtils.findActualNodeFor(xtendFunction);\n\t\t\t\t\t\t\t\t\tif (functionNode == null)\n\t\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"functionNode may not be null\");\n\t\t\t\t\t\t\t\t\tinsertPosition = functionNode.getOffset() + functionNode.getLength();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tICompositeNode expressionNode = NodeModelUtils.findActualNodeFor(xtendFunction.getExpression());\n\t\t\t\t\t\t\t\t\tif (expressionNode == null)\n\t\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"expressionNode may not be null\");\n\t\t\t\t\t\t\t\t\tinsertPosition = expressionNode.getOffset();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tReplacingAppendable appendable = appendableFactory.get(context.getXtextDocument(),\n\t\t\t\t\t\t\t\t\t\txtendFunction, insertPosition, 0);\n\t\t\t\t\t\t\t\tif (xtendFunction.getExpression() == null) \n\t\t\t\t\t\t\t\t\tappendable.append(\" \");\n\t\t\t\t\t\t\t\tEList<JvmTypeReference> thrownExceptions = xtendFunction.getExceptions();\n\t\t\t\t\t\t\t\tif (thrownExceptions.isEmpty())\n\t\t\t\t\t\t\t\t\tappendable.append(\"throws \");\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tappendable.append(\", \");\n\t\t\t\t\t\t\t\tfor(int i = 0; i < exceptions.size(); i++) {\n\t\t\t\t\t\t\t\t\t// TODO type ref?\n\t\t\t\t\t\t\t\t\tappendable.append(exceptions.get(i));\n\t\t\t\t\t\t\t\t\tif (i != exceptions.size() - 1) {\n\t\t\t\t\t\t\t\t\t\tappendable.append(\", \");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (xtendFunction.getExpression() != null) \n\t\t\t\t\t\t\t\t\tappendable.append(\" \");\n\t\t\t\t\t\t\t\tappendable.commitChanges();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t}","id":26981,"modified_method":"@Fix(org.eclipse.xtext.xbase.validation.IssueCodes.UNHANDLED_EXCEPTION)\n\tpublic void addThrowsDeclaration(final Issue issue, IssueResolutionAcceptor acceptor) {\n\t\tif (issue.getData() != null && issue.getData().length > 0)\n\t\t\tacceptor.accept(issue, \"Add throws declaration\", \"Add throws declaration\", \"fix_indent.gif\",\n\t\t\t\t\tnew ISemanticModification() {\n\t\t\t\t\t\tpublic void apply(EObject element, IModificationContext context) throws Exception {\n\t\t\t\t\t\t\tString[] issueData = issue.getData(); \n\t\t\t\t\t\t\tXtendFunction xtendFunction = EcoreUtil2.getContainerOfType(element, XtendFunction.class);\n\t\t\t\t\t\t\tXtextResource xtextResource = (XtextResource) xtendFunction.eResource();\n\t\t\t\t\t\t\tList<JvmType> exceptions = getExceptions(issueData, xtextResource);\n\t\t\t\t\t\t\tif (exceptions.size() > 0) {\n\t\t\t\t\t\t\t\tint insertPosition;\n\t\t\t\t\t\t\t\tif (xtendFunction.getExpression() == null) {\n\t\t\t\t\t\t\t\t\tICompositeNode functionNode = NodeModelUtils.findActualNodeFor(xtendFunction);\n\t\t\t\t\t\t\t\t\tif (functionNode == null)\n\t\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"functionNode may not be null\");\n\t\t\t\t\t\t\t\t\tinsertPosition = functionNode.getOffset() + functionNode.getLength();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tICompositeNode expressionNode = NodeModelUtils.findActualNodeFor(xtendFunction.getExpression());\n\t\t\t\t\t\t\t\t\tif (expressionNode == null)\n\t\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"expressionNode may not be null\");\n\t\t\t\t\t\t\t\t\tinsertPosition = expressionNode.getOffset();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tReplacingAppendable appendable = appendableFactory.create(context.getXtextDocument(),\n\t\t\t\t\t\t\t\t\t\t(XtextResource) xtendFunction.eResource(), insertPosition, 0);\n\t\t\t\t\t\t\t\tif (xtendFunction.getExpression() == null) \n\t\t\t\t\t\t\t\t\tappendable.append(\" \");\n\t\t\t\t\t\t\t\tEList<JvmTypeReference> thrownExceptions = xtendFunction.getExceptions();\n\t\t\t\t\t\t\t\tif (thrownExceptions.isEmpty())\n\t\t\t\t\t\t\t\t\tappendable.append(\"throws \");\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tappendable.append(\", \");\n\t\t\t\t\t\t\t\tfor(int i = 0; i < exceptions.size(); i++) {\n\t\t\t\t\t\t\t\t\t// TODO type ref?\n\t\t\t\t\t\t\t\t\tappendable.append(exceptions.get(i));\n\t\t\t\t\t\t\t\t\tif (i != exceptions.size() - 1) {\n\t\t\t\t\t\t\t\t\t\tappendable.append(\", \");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (xtendFunction.getExpression() != null) \n\t\t\t\t\t\t\t\t\tappendable.append(\" \");\n\t\t\t\t\t\t\t\tappendable.commitChanges();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t}","commit_id":"3d30154dbbeb4224a74e932f65ed0e35f48f0e6b","url":"https://github.com/eclipse/xtext"},{"original_method":"protected ICompletionProposal createOverrideMethodProposal(XtendClass model, JvmExecutable overridden,\n\t\t\tfinal ContentAssistContext context, IProposalConflictHelper conflictHelper) {\n\t\tReplacingAppendable appendable = appendableFactory.get(context.getDocument(), model, context.getReplaceRegion()\n\t\t\t\t.getOffset(), context.getReplaceRegion().getLength(), 1, true);\n\t\tfinal String simpleName;\n\t\tif (overridden instanceof JvmOperation) {\n\t\t\timplementor.appendOverrideFunction(model, (JvmOperation) overridden, appendable);\n\t\t\tsimpleName = overridden.getSimpleName();\n\t\t} else {\n\t\t\timplementor.appendConstructorFromSuper(model, (JvmConstructor) overridden, appendable);\n\t\t\tsimpleName = \"new\";\n\t\t}\n\t\tString code = appendable.toString();\n\t\tif (!isValidProposal(code.trim(), context, conflictHelper)\n\t\t\t\t&& !isValidProposal(overridden.getSimpleName(), context, conflictHelper))\n\t\t\treturn null;\n\t\tImportOrganizingProposal completionProposal = createCompletionProposal(appendable, context.getReplaceRegion(),\n\t\t\t\tgetLabel(overridden), images.forFunction(overridden.getVisibility(), false));\n\t\tMatcher matcher = bodyExpressionPattern.matcher(code.trim());\n\t\tif (matcher.find()) {\n\t\t\tint bodyExpressionLength = matcher.end(1) - matcher.start(1);\n\t\t\tif (bodyExpressionLength == 0) {\n\t\t\t\tcompletionProposal.setCursorPosition(matcher.start(1));\n\t\t\t} else {\n\t\t\t\tcompletionProposal.setSelectionStart(completionProposal.getReplacementOffset() + matcher.start(1));\n\t\t\t\tcompletionProposal.setSelectionLength(bodyExpressionLength);\n\t\t\t\tcompletionProposal.setAutoInsertable(false);\n\t\t\t\tcompletionProposal.setCursorPosition(matcher.start(1) + bodyExpressionLength);\n\t\t\t\tcompletionProposal.setSimpleLinkedMode(context.getViewer(), '\\t');\n\t\t\t}\n\t\t}\n\t\tcompletionProposal.setPriority(getPriority(model, overridden, context));\n\t\tcompletionProposal.setMatcher(new PrefixMatcher() {\n\n\t\t\t@Override\n\t\t\tpublic boolean isCandidateMatchingPrefix(String name, String prefix) {\n\t\t\t\tPrefixMatcher delegate = context.getMatcher();\n\t\t\t\tboolean result = delegate.isCandidateMatchingPrefix(simpleName, prefix);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\treturn completionProposal;\n\t}","id":26982,"modified_method":"protected ICompletionProposal createOverrideMethodProposal(XtendClass model, JvmExecutable overridden,\n\t\t\tfinal ContentAssistContext context, IProposalConflictHelper conflictHelper) {\n\t\tReplacingAppendable appendable = appendableFactory.get(context.getDocument(), model, context.getReplaceRegion()\n\t\t\t\t.getOffset(), context.getReplaceRegion().getLength(), 1, true);\n\t\tfinal String simpleName;\n\t\tif (overridden instanceof JvmOperation) {\n\t\t\timplementor.appendOverrideFunction(model, (JvmOperation) overridden, appendable);\n\t\t\tsimpleName = overridden.getSimpleName();\n\t\t} else {\n\t\t\timplementor.appendConstructorFromSuper(model, (JvmConstructor) overridden, appendable);\n\t\t\tsimpleName = \"new\";\n\t\t}\n\t\tString code = appendable.getCode();\n\t\tif (!isValidProposal(code.trim(), context, conflictHelper) && !isValidProposal(simpleName, context, conflictHelper))\n\t\t\treturn null;\n\t\tImportOrganizingProposal completionProposal = createCompletionProposal(appendable, context.getReplaceRegion(),\n\t\t\t\tgetLabel(overridden), images.forFunction(overridden.getVisibility(), false));\n\t\tMatcher matcher = bodyExpressionPattern.matcher(code);\n\t\tif (matcher.find()) {\n\t\t\tint bodyExpressionLength = matcher.end(1) - matcher.start(1);\n\t\t\tint bodyExpressionStart = matcher.start(1) + appendable.getTotalOffset() - completionProposal.getReplacementOffset();\n\t\t\tif (bodyExpressionLength == 0) {\n\t\t\t\tcompletionProposal.setCursorPosition(bodyExpressionStart);\n\t\t\t} else {\n\t\t\t\tcompletionProposal.setSelectionStart(completionProposal.getReplacementOffset() + bodyExpressionStart);\n\t\t\t\tcompletionProposal.setSelectionLength(bodyExpressionLength);\n\t\t\t\tcompletionProposal.setAutoInsertable(false);\n\t\t\t\tcompletionProposal.setCursorPosition(bodyExpressionStart + bodyExpressionLength);\n\t\t\t\tcompletionProposal.setSimpleLinkedMode(context.getViewer(), '\\t');\n\t\t\t}\n\t\t}\n\t\tcompletionProposal.setPriority(getPriority(model, overridden, context));\n\t\tcompletionProposal.setMatcher(new PrefixMatcher() {\n\n\t\t\t@Override\n\t\t\tpublic boolean isCandidateMatchingPrefix(String name, String prefix) {\n\t\t\t\tPrefixMatcher delegate = context.getMatcher();\n\t\t\t\tboolean result = delegate.isCandidateMatchingPrefix(simpleName, prefix);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\treturn completionProposal;\n\t}","commit_id":"168f05084ff82085f549e4b134aaef175156c21e","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void apply(IDocument document) {\n\t\ttry {\n\t\t\tappendable.commitChanges(getReplacementOffset(), getReplacementLength());\n\t\t\tif (isLinkedMode())\n\t\t\t\tsetUpLinkedMode(document);\n\t\t} catch (BadLocationException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","id":26983,"modified_method":"@Override\n\tpublic void apply(IDocument document) {\n\t\ttry {\n\t\t\tint shiftOffsetBy = appendable.commitChanges(getReplacementOffset(), getReplacementLength());\n\t\t\tsetSelectionStart(getSelectionStart() + shiftOffsetBy);\n\t\t\tsetCursorPosition(getCursorPosition() + shiftOffsetBy);\n\t\t\tif (isLinkedMode()) {\n\t\t\t\tsetUpLinkedMode(document);\n\t\t\t}\n\t\t} catch (BadLocationException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"168f05084ff82085f549e4b134aaef175156c21e","url":"https://github.com/eclipse/xtext"},{"original_method":"public ImportOrganizingProposal(ReplacingAppendable appendable, int replacementOffset, int replacementLength,\n\t\t\tint cursorPosition, Image image, StyledString displayString) {\n\t\tsuper(appendable.toString(), replacementOffset, replacementLength, cursorPosition, image, displayString, null, null);\n\t\tthis.appendable = appendable;\n\t}","id":26984,"modified_method":"public ImportOrganizingProposal(ReplacingAppendable appendable, int replacementOffset, int replacementLength,\n\t\t\tint cursorPosition, Image image, StyledString displayString) {\n\t\tsuper(appendable.getCode(), replacementOffset, replacementLength, cursorPosition, image, displayString, null, null);\n\t\tthis.appendable = appendable;\n\t}","commit_id":"168f05084ff82085f549e4b134aaef175156c21e","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\t\tpublic void apply(IDocument document, ConfigurableCompletionProposal proposal) throws BadLocationException {\n\t\t\tString proposalReplacementString = proposal.getReplacementString();\n\t\t\tString typeName = proposalReplacementString;\n\t\t\tif (valueConverter != null)\n\t\t\t\ttypeName = valueConverter.toValue(proposalReplacementString, null);\n\t\t\tString replacementString = getActualReplacementString(proposal);\n\t\t\t// there is an import statement - apply computed replacementString\n\t\t\tif (!proposalReplacementString.equals(replacementString)) {\n\t\t\t\tString shortTypeName = replacementString;\n\t\t\t\tif (valueConverter != null)\n\t\t\t\t\tshortTypeName = valueConverter.toValue(replacementString, null);\n\t\t\t\tQualifiedName shortQualifiedName = qualifiedNameConverter.toQualifiedName(shortTypeName);\n\t\t\t\tif (shortQualifiedName.getSegmentCount() == 1) {\n\t\t\t\t\tproposal.setCursorPosition(replacementString.length());\n\t\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), replacementString);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// we could create an import statement if there is no conflict\n\t\t\tXtendFile file = (XtendFile) context.getContents().get(0);\n\t\t\tXtendClass clazz = file.getXtendClass();\n\t\t\t\n\t\t\tQualifiedName qualifiedName = qualifiedNameConverter.toQualifiedName(typeName);\t\t\t\n\t\t\tif (qualifiedName.getSegmentCount() == 1) {\n\t\t\t\t// type resides in default package - no need to hassle with imports\n\t\t\t\tproposal.setCursorPosition(proposalReplacementString.length());\n\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), proposalReplacementString);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tIEObjectDescription description = scope.getSingleElement(qualifiedName.skipFirst(qualifiedName.getSegmentCount() - 1));\n\t\t\tif (description != null) {\n\t\t\t\t// there exists a conflict - insert fully qualified name\n\t\t\t\tproposal.setCursorPosition(proposalReplacementString.length());\n\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), proposalReplacementString);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Import does not introduce ambiguities - add import and insert short name\n\t\t\tString shortName = qualifiedName.getLastSegment();\n\t\t\tint topPixel = -1;\n\t\t\t// store the pixel coordinates to prevent the ui from flickering\n\t\t\tStyledText widget = viewer.getTextWidget();\n\t\t\tif (widget != null)\n\t\t\t\ttopPixel = widget.getTopPixel();\n\t\t\tITextViewerExtension viewerExtension = null;\n\t\t\tif (viewer instanceof ITextViewerExtension) {\n\t\t\t\tviewerExtension = (ITextViewerExtension) viewer;\n\t\t\t\tviewerExtension.setRedraw(false);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\t// compute import statement's offset\n\t\t\t\tint offset = 0;\n\t\t\t\tboolean startWithLineBreak = true;\n\t\t\t\tboolean endWithLineBreak = false;\n\t\t\t\tif (file.getImports().isEmpty()) {\n\t\t\t\t\tstartWithLineBreak = false;\n\t\t\t\t\tif (clazz == null) {\n\t\t\t\t\t\toffset = document.getLength();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tICompositeNode node = NodeModelUtils.getNode(clazz);\n\t\t\t\t\t\toffset = node.getOffset();\n\t\t\t\t\t\tendWithLineBreak = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tICompositeNode node = NodeModelUtils.getNode(file.getImports().get(file.getImports().size() - 1));\n\t\t\t\t\toffset = node.getOffset() + node.getLength();\n\t\t\t\t}\n\t\t\t\toffset = Math.min(proposal.getReplacementOffset(), offset);\n\t\t\t\n\t\t\t\t// apply short proposal\n\t\t\t\tString escapedShortname = shortName;\n\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\tescapedShortname = valueConverter.toString(shortName);\n\t\t\t\t}\n\t\t\t\tproposal.setCursorPosition(escapedShortname.length());\n\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), escapedShortname);\n\t\t\t\n\t\t\t\t// add import statement\n\t\t\t\tString importStatement = (startWithLineBreak ? \"\\nimport \" : \"import \") + importConverter.toString(typeName);\n\t\t\t\tif (endWithLineBreak)\n\t\t\t\t\timportStatement += \"\\n\\n\";\n\t\t\t\tdocument.replace(offset, 0, importStatement.toString());\n\t\t\t\tproposal.setCursorPosition(proposal.getCursorPosition() + importStatement.length());\n\t\t\t\t\n\t\t\t\t// set the pixel coordinates\n\t\t\t\tif (widget != null) {\n\t\t\t\t\tint additionalTopPixel = 0;\n\t\t\t\t\tif (startWithLineBreak)\n\t\t\t\t\t\tadditionalTopPixel += widget.getLineHeight();\n\t\t\t\t\tif (endWithLineBreak)\n\t\t\t\t\t\tadditionalTopPixel += 2 * widget.getLineHeight();\n\t\t\t\t\twidget.setTopPixel(topPixel + additionalTopPixel);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (viewerExtension != null)\n\t\t\t\t\tviewerExtension.setRedraw(true);\n\t\t\t}\n\t\t}","id":26985,"modified_method":"@Override\n\t\tpublic void apply(IDocument document, ConfigurableCompletionProposal proposal) throws BadLocationException {\n\t\t\tString proposalReplacementString = proposal.getReplacementString();\n\t\t\tString typeName = proposalReplacementString;\n\t\t\tif (valueConverter != null)\n\t\t\t\ttypeName = valueConverter.toValue(proposalReplacementString, null);\n\t\t\tString replacementString = getActualReplacementString(proposal);\n\t\t\t// there is an import statement - apply computed replacementString\n\t\t\tif (!proposalReplacementString.equals(replacementString)) {\n\t\t\t\tString shortTypeName = replacementString;\n\t\t\t\tif (valueConverter != null)\n\t\t\t\t\tshortTypeName = valueConverter.toValue(replacementString, null);\n\t\t\t\tQualifiedName shortQualifiedName = qualifiedNameConverter.toQualifiedName(shortTypeName);\n\t\t\t\tif (shortQualifiedName.getSegmentCount() == 1) {\n\t\t\t\t\tproposal.setCursorPosition(replacementString.length());\n\t\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), replacementString);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// we could create an import statement if there is no conflict\n\t\t\tXtendFile file = (XtendFile) context.getContents().get(0);\n\t\t\tXtendClass clazz = file.getXtendClass();\n\t\t\t\n\t\t\tQualifiedName qualifiedName = qualifiedNameConverter.toQualifiedName(typeName);\t\t\t\n\t\t\tif (qualifiedName.getSegmentCount() == 1) {\n\t\t\t\t// type resides in default package - no need to hassle with imports\n\t\t\t\tproposal.setCursorPosition(proposalReplacementString.length());\n\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), proposalReplacementString);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tIEObjectDescription description = scope.getSingleElement(qualifiedName.skipFirst(qualifiedName.getSegmentCount() - 1));\n\t\t\tif (description != null) {\n\t\t\t\t// there exists a conflict - insert fully qualified name\n\t\t\t\tproposal.setCursorPosition(proposalReplacementString.length());\n\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), proposalReplacementString);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Import does not introduce ambiguities - add import and insert short name\n\t\t\tString shortName = qualifiedName.getLastSegment();\n\t\t\tint topPixel = -1;\n\t\t\t// store the pixel coordinates to prevent the ui from flickering\n\t\t\tStyledText widget = viewer.getTextWidget();\n\t\t\tif (widget != null)\n\t\t\t\ttopPixel = widget.getTopPixel();\n\t\t\tITextViewerExtension viewerExtension = null;\n\t\t\tif (viewer instanceof ITextViewerExtension) {\n\t\t\t\tviewerExtension = (ITextViewerExtension) viewer;\n\t\t\t\tviewerExtension.setRedraw(false);\n\t\t\t}\n\t\t\tDocumentRewriteSession rewriteSession = null;\n\t\t\ttry {\n\t\t\t\tif (document instanceof IDocumentExtension4) {\n\t\t\t\t\trewriteSession = ((IDocumentExtension4) document).startRewriteSession(DocumentRewriteSessionType.UNRESTRICTED_SMALL);\n\t\t\t\t}\n\t\t\t\t// compute import statement's offset\n\t\t\t\tint offset = 0;\n\t\t\t\tboolean startWithLineBreak = true;\n\t\t\t\tboolean endWithLineBreak = false;\n\t\t\t\tif (file.getImports().isEmpty()) {\n\t\t\t\t\tstartWithLineBreak = false;\n\t\t\t\t\tif (clazz == null) {\n\t\t\t\t\t\toffset = document.getLength();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tICompositeNode node = NodeModelUtils.getNode(clazz);\n\t\t\t\t\t\toffset = node.getOffset();\n\t\t\t\t\t\tendWithLineBreak = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tICompositeNode node = NodeModelUtils.getNode(file.getImports().get(file.getImports().size() - 1));\n\t\t\t\t\toffset = node.getOffset() + node.getLength();\n\t\t\t\t}\n\t\t\t\toffset = Math.min(proposal.getReplacementOffset(), offset);\n\t\t\t\n\t\t\t\t// apply short proposal\n\t\t\t\tString escapedShortname = shortName;\n\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\tescapedShortname = valueConverter.toString(shortName);\n\t\t\t\t}\n\t\t\t\tproposal.setCursorPosition(escapedShortname.length());\n\t\t\t\tdocument.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), escapedShortname);\n\t\t\t\n\t\t\t\t// add import statement\n\t\t\t\tString importStatement = (startWithLineBreak ? \"\\nimport \" : \"import \") + importConverter.toString(typeName);\n\t\t\t\tif (endWithLineBreak)\n\t\t\t\t\timportStatement += \"\\n\\n\";\n\t\t\t\tdocument.replace(offset, 0, importStatement.toString());\n\t\t\t\tproposal.setCursorPosition(proposal.getCursorPosition() + importStatement.length());\n\t\t\t\t\n\t\t\t\t// set the pixel coordinates\n\t\t\t\tif (widget != null) {\n\t\t\t\t\tint additionalTopPixel = 0;\n\t\t\t\t\tif (startWithLineBreak)\n\t\t\t\t\t\tadditionalTopPixel += widget.getLineHeight();\n\t\t\t\t\tif (endWithLineBreak)\n\t\t\t\t\t\tadditionalTopPixel += 2 * widget.getLineHeight();\n\t\t\t\t\twidget.setTopPixel(topPixel + additionalTopPixel);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (rewriteSession != null) {\n\t\t\t\t\t((IDocumentExtension4) document).stopRewriteSession(rewriteSession);\n\t\t\t\t}\n\t\t\t\tif (viewerExtension != null)\n\t\t\t\t\tviewerExtension.setRedraw(true);\n\t\t\t}\n\t\t}","commit_id":"168f05084ff82085f549e4b134aaef175156c21e","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic String toString() {\n\t\tStringBuilder b = new StringBuilder();\n\t\tif (whitespaceHelper.getPrefix() != null)\n\t\t\tb.append(whitespaceHelper.getPrefix().replace(\"\\n\", getIndentationString()));\n\t\tb.append(super.toString());\n\t\tif (whitespaceHelper.getSuffix() != null)\n\t\t\tb.append(whitespaceHelper.getSuffix().replace(\"\\n\", getIndentationString()));\n\t\treturn b.toString();\n\t}","id":26986,"modified_method":"@Override\n\tpublic String toString() {\n\t\treturn getCode();\n\t}","commit_id":"168f05084ff82085f549e4b134aaef175156c21e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void commitChanges(int from, int length) throws BadLocationException {\n\t\tint actualOffset = Math.min(whitespaceHelper.getTotalOffset(), from);\n\t\tint endOffset = Math.max(whitespaceHelper.getTotalOffset() + whitespaceHelper.getTotalLength(), from + length);\n\t\tint actualLength = endOffset - actualOffset;\n\t\tdocument.replace(actualOffset, actualLength, toString());\n\t\tinsertNewImports();\n\t}","id":26987,"modified_method":"public int commitChanges(int offset, int length) throws BadLocationException {\n\t\tint actualOffset = Math.min(whitespaceHelper.getTotalOffset(), offset);\n\t\tint endOffset = Math.max(whitespaceHelper.getTotalOffset() + whitespaceHelper.getTotalLength(), offset + length);\n\t\tint actualLength = endOffset - actualOffset;\n\t\tdocument.replace(actualOffset, actualLength, toString());\n\t\tint shiftCursorBy = insertNewImports();\n\t\treturn shiftCursorBy;\n\t}","commit_id":"168f05084ff82085f549e4b134aaef175156c21e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void insertNewImports() throws BadLocationException {\n\t\tList<String> newImports = getNewImports();\n\t\tif (!newImports.isEmpty()) {\n\t\t\tStringBuilder importSection = new StringBuilder();\n\t\t\tfor (String newImport : newImports) {\n\t\t\t\timportSection.append(\"import \");\n\t\t\t\timportSection.append(newImport);\n\t\t\t\timportSection.append(\"\\n\");\n\t\t\t}\n\t\t\tint offset;\n\t\t\tif (xtendFile.getImports().isEmpty()) {\n\t\t\t\toffset = NodeModelUtils.findActualNodeFor(xtendFile.getXtendClass()).getOffset();\n\t\t\t\timportSection.append(\"\\n\");\n\t\t\t} else {\n\t\t\t\tICompositeNode lastImportNode = NodeModelUtils.findActualNodeFor(xtendFile.getImports().get(\n\t\t\t\t\t\txtendFile.getImports().size() - 1));\n\t\t\t\timportSection.insert(0, \"\\n\");\n\t\t\t\timportSection.replace(importSection.length() - 1, importSection.length(), \"\");\n\t\t\t\toffset = lastImportNode.getOffset() + lastImportNode.getLength();\n\t\t\t}\n\t\t\tdocument.replace(offset, 0, importSection.toString());\n\t\t}\n\t}","id":26988,"modified_method":"public int insertNewImports() throws BadLocationException {\n\t\tList<String> newImports = getNewImports();\n\t\tif (!newImports.isEmpty()) {\n\t\t\tStringBuilder importSection = new StringBuilder();\n\t\t\tfor (String newImport : newImports) {\n\t\t\t\timportSection.append(\"import \");\n\t\t\t\timportSection.append(newImport);\n\t\t\t\timportSection.append(\"\\n\");\n\t\t\t}\n\t\t\tint offset;\n\t\t\tif (xtendFile.getImports().isEmpty()) {\n\t\t\t\toffset = NodeModelUtils.findActualNodeFor(xtendFile.getXtendClass()).getOffset();\n\t\t\t\timportSection.append(\"\\n\");\n\t\t\t} else {\n\t\t\t\tICompositeNode lastImportNode = NodeModelUtils.findActualNodeFor(xtendFile.getImports().get(\n\t\t\t\t\t\txtendFile.getImports().size() - 1));\n\t\t\t\timportSection.insert(0, \"\\n\");\n\t\t\t\timportSection.replace(importSection.length() - 1, importSection.length(), \"\");\n\t\t\t\toffset = lastImportNode.getOffset() + lastImportNode.getLength();\n\t\t\t}\n\t\t\tdocument.replace(offset, 0, importSection.toString());\n\t\t\treturn importSection.length();\n\t\t}\n\t\treturn 0;\n\t}","commit_id":"168f05084ff82085f549e4b134aaef175156c21e","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n        super.init(servletConfig);        \n        \n        final BeanManager beanManager = CDI.current().getBeanManager();\n        final JAXRSCdiResourceExtension extension = beanManager.getExtension(JAXRSCdiResourceExtension.class);\n        if (extension != null) {    \n            for (final JAXRSServerFactoryBean factory: extension.getFactories()) {\n                factory.setBus(getBus());    \n                factory.init();\n            }        \n        }\n    }","id":26989,"modified_method":"@Override\n    protected void loadBus(ServletConfig servletConfig) {\n        final BeanManager beanManager = CDI.current().getBeanManager();        \n        if (beanManager != null) {\n            final JAXRSCdiResourceExtension extension = beanManager.getExtension(JAXRSCdiResourceExtension.class);\n            if (extension != null) {\n                setBus(extension.getBus());\n            }\n        } else {\n            busCreated = true;\n            setBus(BusFactory.newInstance().createBus());\n        }\n    }","commit_id":"675c9b2f77541f7e36d97e8887ceb04ef24dcf3b","url":"https://github.com/apache/cxf"},{"original_method":"public void load(@Observes final AfterDeploymentValidation event, final BeanManager beanManager) {\n        for (final Bean< ? > bean: serviceBeans) {\n            services.add(\n                beanManager.getReference(\n                    bean, \n                    bean.getBeanClass(), \n                    beanManager.createCreationalContext(bean) \n                )\n            );    \n        }\n        \n        for (final Bean< ? > bean: providerBeans) {\n            providers.add(\n                beanManager.getReference(\n                    bean, \n                    bean.getBeanClass(), \n                    beanManager.createCreationalContext(bean)\n                ) \n            );    \n        }\n        \n        for (final Map.Entry< Bean< ? >, Bean< JAXRSServerFactoryBean > > entry: factoryBeans.entrySet()) {\n            final Application instance = (Application)beanManager.getReference(\n                entry.getKey(), \n                entry.getKey().getBeanClass(), \n                beanManager.createCreationalContext(entry.getKey()) \n            );\n            \n            // Create the JAXRSServerFactoryBean for each application we have discovered\n            factories.add(createFactoryInstance(instance, entry.getValue(), beanManager));\n        }\n    }","id":26990,"modified_method":"public void load(@Observes final AfterDeploymentValidation event, final BeanManager beanManager) {\n        for (final Bean< ? > bean: serviceBeans) {\n            services.add(\n                beanManager.getReference(\n                    bean, \n                    bean.getBeanClass(), \n                    beanManager.createCreationalContext(bean) \n                )\n            );    \n        }\n        \n        for (final Bean< ? > bean: providerBeans) {\n            providers.add(\n                beanManager.getReference(\n                    bean, \n                    bean.getBeanClass(), \n                    beanManager.createCreationalContext(bean)\n                ) \n            );    \n        }\n        \n        bus = (Bus)beanManager.getReference(\n            busBean, \n            busBean.getBeanClass(), \n            beanManager.createCreationalContext(busBean)\n        );\n        \n        for (final Bean< ? > application: applicationBeans) {\n            final Application instance = (Application)beanManager.getReference(\n                application, \n                application.getBeanClass(), \n                beanManager.createCreationalContext(application) \n            );\n            \n            // Create the JAXRSServerFactoryBean for each application we have discovered\n            final JAXRSServerFactoryBean factory = createFactoryInstance(instance);\n            factory.init();\n        }\n    }","commit_id":"675c9b2f77541f7e36d97e8887ceb04ef24dcf3b","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"rawtypes\")\n    private JAXRSServerFactoryBean createFactoryInstance(final Application application, \n            final Bean< ? > factoryBean, final BeanManager beanManager) {\n        \n        final JAXRSServerFactoryBean instance = (JAXRSServerFactoryBean)beanManager.getReference(\n            factoryBean, \n            factoryBean.getBeanClass(), \n            beanManager.createCreationalContext(factoryBean)\n        );\n                        \n        ResourceUtils.initializeApplication(instance, application, false, false);          \n        instance.setServiceBeans(new ArrayList< Object >(services));\n        instance.setProviders(providers);\n              \n        final ServiceLoader< MessageBodyWriter > writers = ServiceLoader.load(MessageBodyWriter.class);\n        for (final MessageBodyWriter< ? > writer: writers) {\n            instance.setProvider(writer);\n        }\n        \n        final ServiceLoader< MessageBodyReader > readers = ServiceLoader.load(MessageBodyReader.class);\n        for (final MessageBodyReader< ? > reader: readers) {\n            instance.setProvider(reader);\n        }\n        \n        return instance; \n    }","id":26991,"modified_method":"@SuppressWarnings(\"rawtypes\")\n    private JAXRSServerFactoryBean createFactoryInstance(final Application application) {\n                        \n        JAXRSServerFactoryBean instance = ResourceUtils.createApplication(application, false, false);          \n        instance.setServiceBeans(new ArrayList< Object >(services));\n        instance.setProviders(providers);\n        instance.setBus(bus);\n              \n        final ServiceLoader< MessageBodyWriter > writers = ServiceLoader.load(MessageBodyWriter.class);\n        for (final MessageBodyWriter< ? > writer: writers) {\n            instance.setProvider(writer);\n        }\n        \n        final ServiceLoader< MessageBodyReader > readers = ServiceLoader.load(MessageBodyReader.class);\n        for (final MessageBodyReader< ? > reader: readers) {\n            instance.setProvider(reader);\n        }\n        \n        return instance; \n    }","commit_id":"675c9b2f77541f7e36d97e8887ceb04ef24dcf3b","url":"https://github.com/apache/cxf"},{"original_method":"public <T> void collect(@Observes final ProcessBean< T > event) {\n        if (event.getAnnotated().isAnnotationPresent(ApplicationPath.class)) {\n            applicationBeans.add(event.getBean());\n        } else if (event.getAnnotated().isAnnotationPresent(Path.class)) {\n            serviceBeans.add(event.getBean());\n        } else if (event.getAnnotated().isAnnotationPresent(Provider.class)) {\n            providerBeans.add(event.getBean());\n        }\n    }","id":26992,"modified_method":"public <T> void collect(@Observes final ProcessBean< T > event) {\n        if (event.getAnnotated().isAnnotationPresent(ApplicationPath.class)) {\n            applicationBeans.add(event.getBean());\n        } else if (event.getAnnotated().isAnnotationPresent(Path.class)) {\n            serviceBeans.add(event.getBean());\n        } else if (event.getAnnotated().isAnnotationPresent(Provider.class)) {\n            providerBeans.add(event.getBean());\n        } else if (CdiBusBean.CXF.equals(event.getBean().getName()) \n                && Bus.class.isAssignableFrom(event.getBean().getBeanClass())) {\n            busBean = event.getBean();  \n        }\n    }","commit_id":"675c9b2f77541f7e36d97e8887ceb04ef24dcf3b","url":"https://github.com/apache/cxf"},{"original_method":"public void injectFactories(@Observes final AfterBeanDiscovery event, final BeanManager beanManager) {\n        final AnnotatedType< JAXRSServerFactoryBean > factoryAnnotatedType = \n             beanManager.createAnnotatedType(JAXRSServerFactoryBean.class);\n        \n        final InjectionTarget<JAXRSServerFactoryBean> injectionTarget = \n             beanManager.createInjectionTarget(factoryAnnotatedType);\n        \n        for (final Bean< ? > applicationBean: applicationBeans) {\n            final Bean< JAXRSServerFactoryBean > factoryBean =\n                new JAXRSCdiServerFactoryBean(applicationBean, injectionTarget);   \n            \n            event.addBean(factoryBean);\n            factoryBeans.put(applicationBean, factoryBean);\n        }\n    }","id":26993,"modified_method":"public void injectFactories(@Observes final AfterBeanDiscovery event, final BeanManager beanManager) {\n        if (busBean == null) {\n            final AnnotatedType< ExtensionManagerBus > busAnnotatedType = \n                beanManager.createAnnotatedType(ExtensionManagerBus.class);\n               \n            final InjectionTarget<ExtensionManagerBus> busInjectionTarget = \n                beanManager.createInjectionTarget(busAnnotatedType);\n               \n            busBean = new CdiBusBean(busInjectionTarget);\n            event.addBean(busBean);\n        } \n    }","commit_id":"675c9b2f77541f7e36d97e8887ceb04ef24dcf3b","url":"https://github.com/apache/cxf"},{"original_method":"public static JAXRSServerFactoryBean createApplication(Application app, boolean ignoreAppPath,\n                                                           boolean staticSubresourceResolution) {\n        return initializeApplication(new JAXRSServerFactoryBean(), app, \n                ignoreAppPath, staticSubresourceResolution);\n    }","id":26994,"modified_method":"public static JAXRSServerFactoryBean createApplication(Application app, boolean ignoreAppPath,\n                                                           boolean staticSubresourceResolution) {\n        \n        Set<Object> singletons = app.getSingletons();\n        verifySingletons(singletons);\n        \n        List<Class<?>> resourceClasses = new ArrayList<Class<?>>();\n        List<Object> providers = new ArrayList<Object>();\n        Map<Class<?>, ResourceProvider> map = new HashMap<Class<?>, ResourceProvider>();\n        \n        // Note, app.getClasses() returns a list of per-request classes\n        // or singleton provider classes\n        for (Class<?> cls : app.getClasses()) {\n            if (isValidApplicationClass(cls, singletons)) {\n                if (isValidProvider(cls)) {\n                    try {\n                        Constructor<?> c = ResourceUtils.findResourceConstructor(cls, false);\n                        if (c.getParameterTypes().length == 0) {\n                            providers.add(c.newInstance());\n                        } else {\n                            providers.add(c);\n                        }\n                    } catch (Throwable ex) {\n                        throw new RuntimeException(\"Provider \" + cls.getName() + \" can not be created\", ex); \n                    }\n                } else {\n                    resourceClasses.add(cls);\n                    map.put(cls, new PerRequestResourceProvider(cls));\n                }\n            }\n        }\n        \n        // we can get either a provider or resource class here        \n        for (Object o : singletons) {\n            if (isValidProvider(o.getClass())) {\n                providers.add(o);\n            } else {\n                resourceClasses.add(o.getClass());\n                map.put(o.getClass(), new SingletonResourceProvider(o));\n            }\n        }\n        \n        JAXRSServerFactoryBean bean = new JAXRSServerFactoryBean();\n        String address = \"/\";\n        if (!ignoreAppPath) {\n            ApplicationPath appPath = app.getClass().getAnnotation(ApplicationPath.class);\n            if (appPath != null) {\n                address = appPath.value();\n            }\n        }\n        if (!address.startsWith(\"/\")) {\n            address = \"/\" + address;\n        }\n        bean.setAddress(address);\n        bean.setStaticSubresourceResolution(staticSubresourceResolution);\n        bean.setResourceClasses(resourceClasses);\n        bean.setProviders(providers);\n        for (Map.Entry<Class<?>, ResourceProvider> entry : map.entrySet()) {\n            bean.setResourceProvider(entry.getKey(), entry.getValue());\n        }\n        Map<String, Object> appProps = app.getProperties();\n        if (appProps != null) {\n            bean.getProperties(true).putAll(appProps);\n        }\n        bean.setApplication(app);\n        \n        return bean;\n    }","commit_id":"675c9b2f77541f7e36d97e8887ceb04ef24dcf3b","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected void doStart() throws MuleException\n    {\n        try\n        {\n            if (deployer != null)\n            {\n                deployer.start();\n            }\n\n            httpServer.start();\n\n            for (ConnectorHolder<?, ?> contextHolder : holders.values())\n            {\n                contextHolder.start();\n            }\n        }\n        catch (Exception e)\n        {\n            throw new LifecycleException(CoreMessages.failedToStart(\"Jetty Http Receiver\"), e, this);\n        }\n    }","id":26995,"modified_method":"@Override\n    protected void doStart() throws MuleException\n    {\n        try\n        {\n            httpServer.start();\n\n            for (ConnectorHolder<?, ?> contextHolder : holders.values())\n            {\n                contextHolder.start();\n            }\n        }\n        catch (Exception e)\n        {\n            throw new LifecycleException(CoreMessages.failedToStart(\"Jetty Http Receiver\"), e, this);\n        }\n    }","commit_id":"2e88fdda37bf43cfc49853b57712427147e34310","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Servlet createServlet(Connector connector, ImmutableEndpoint endpoint)\n    {\n        HttpServlet servlet;\n        if (getReceiverServlet() == null)\n        {\n            if(isUseContinuations())\n            {\n                servlet = new JettyContinuationsReceiverServlet();\n            }\n            else\n            {\n                servlet = new JettyReceiverServlet();\n            }\n        }\n        else\n        {\n            servlet = getReceiverServlet();\n        }\n\n        String path = endpoint.getEndpointURI().getPath();\n        if(StringUtils.isBlank(path))\n        {\n            path = ROOT;\n        }\n\n        ContextHandlerCollection handlerCollection = new ContextHandlerCollection();\n\n        if (resourceBase != null)\n        {\n            ResourceHandler resourceHandler = new ResourceHandler();\n            ContextHandler resourceContextHandler = new ContextHandler(handlerCollection, path);\n            resourceHandler.setResourceBase(resourceBase);\n            resourceContextHandler.setHandler(resourceHandler);\n        }\n\n        ServletContextHandler servletContext = new ServletContextHandler(handlerCollection, ROOT, ServletContextHandler.NO_SECURITY);\n        servletContext.addEventListener(new MuleServletContextListener(muleContext, getName()));\n\n        ServletHolder holder = new ServletHolder();\n        holder.setServlet(servlet);\n        servletContext.addServlet(holder, \"/*\");\n        servletContext.addServlet(JarResourceServlet.class, JarResourceServlet.DEFAULT_PATH_SPEC);\n        handlerCollection.addHandler(servletContext);\n\n        addHandler(handlerCollection);\n        return servlet;\n    }","id":26996,"modified_method":"protected Servlet createServlet(Connector connector, ImmutableEndpoint endpoint)\n    {\n        HttpServlet servlet;\n        if (getReceiverServlet() == null)\n        {\n            if(isUseContinuations())\n            {\n                servlet = new JettyContinuationsReceiverServlet();\n            }\n            else\n            {\n                servlet = new JettyReceiverServlet();\n            }\n        }\n        else\n        {\n            servlet = getReceiverServlet();\n        }\n\n        String path = endpoint.getEndpointURI().getPath();\n        if(StringUtils.isBlank(path))\n        {\n            path = ROOT;\n        }\n\n        if (resourceBase != null)\n        {\n            ResourceHandler resourceHandler = new ResourceHandler();\n            ContextHandler resourceContextHandler = new ContextHandler(contexts, path);\n            resourceHandler.setResourceBase(resourceBase);\n            resourceContextHandler.setHandler(resourceHandler);\n        }\n\n        ServletContextHandler servletContext = new ServletContextHandler(contexts, ROOT, ServletContextHandler.NO_SECURITY);\n        servletContext.addEventListener(new MuleServletContextListener(muleContext, getName()));\n        servletContext.setConnectorNames(new String[] {connector.getName()});\n\n        ServletHolder holder = new ServletHolder();\n        holder.setServlet(servlet);\n        servletContext.addServlet(holder, \"/*\");\n        servletContext.addServlet(JarResourceServlet.class, JarResourceServlet.DEFAULT_PATH_SPEC);\n        addHandler(servletContext);\n\n        return servlet;\n    }","commit_id":"2e88fdda37bf43cfc49853b57712427147e34310","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    protected void doInitialise() throws InitialisationException\n    {\n        httpServer = new Server();\n\n        if (webappsConfiguration != null)\n        {\n            deployer = new WebAppDeployer();\n            String webAppDir = webappsConfiguration.getDirectory();\n            if (StringUtils.isBlank(webAppDir))\n            {\n                // if none specified, resolve defaults dynamically\n                final String appDir = muleContext.getRegistry().get(MuleProperties.APP_HOME_DIRECTORY_PROPERTY);\n                webAppDir = appDir + \"/webapps\";\n            }\n\n            if (configFile == null)\n            {\n                // override only if user hasn't specified one (turn off file-mapped buffer for\n                // static files to avoid resource locking, makes webapp resources editable on the fly)\n                final URL muleDefaults = ClassUtils.getResource(\"org/mule/transport/jetty/webdefault.xml\", getClass());\n                deployer.setDefaultsDescriptor(muleDefaults.toExternalForm());\n            }\n            deployer.setConnector(this);\n            deployer.setWebAppDir(webAppDir);\n            deployer.setExtract(true);\n            deployer.setParentLoaderPriority(false);\n            deployer.setServerClasses(webappsConfiguration.getServerClasses());\n            deployer.setSystemClasses(webappsConfiguration.getSystemClasses());\n\n            Connector jettyConnector = createJettyConnector();\n            jettyConnector.setHost(webappsConfiguration.getHost());\n            jettyConnector.setPort(webappsConfiguration.getPort());\n            deployer.setContexts(httpServer);\n            String[] confClasses = new String[]\n            {\n                // configures webapp's classloader as a child of a Mule app classloader\n                WebInfConfiguration.class.getName(),\n                WebXmlConfiguration.class.getName(),\n                // just to get jetty going, we don't need java ee bindings. inherits annotation processing\n                DummyJndiConfiguration.class.getName()\n            };\n            deployer.setConfigurationClasses(confClasses);\n\n            httpServer.addConnector(jettyConnector);\n            httpServer.addBean(deployer);\n        }\n\n        initialiseFromConfigFile();\n\n        try\n        {\n            muleContext.registerListener(new MuleContextNotificationListener<MuleContextNotification>(){\n                @Override\n                public void onNotification(MuleContextNotification notification)\n                {\n                    if (notification.getAction() == MuleContextNotification.CONTEXT_STARTED)\n                    {\n                        //We delay starting until the context has been started since we need the MuleAjaxServlet to initialise first\n                        setInitialStateStopped(false);\n                        try\n                        {\n                            start();\n                            // update the agent displaying webapp urls to the user\n                            final JettyWebappServerAgent agent = (JettyWebappServerAgent) muleContext.getRegistry().lookupAgent(JettyWebappServerAgent.NAME);\n                            if (agent != null)\n                            {\n                                agent.onJettyConnectorStarted(JettyHttpConnector.this);\n                            }\n                        }\n                        catch (MuleException e)\n                        {\n                            throw new MuleRuntimeException(CoreMessages.failedToStart(getName()), e);\n                        }\n                    }\n                }\n            });\n        }\n        catch (NotificationException e)\n        {\n            throw new InitialisationException(e, this);\n        }\n    }","id":26997,"modified_method":"@Override\n    protected void doInitialise() throws InitialisationException\n    {\n        httpServer = new Server();\n        contexts = new ContextHandlerCollection();\n\n        httpServer.setHandler(contexts);\n\n        if (webappsConfiguration != null)\n        {\n            DeploymentManager deploymentManager = new DeploymentManager();\n            WebAppProvider webAppProvider = new WebAppProvider()\n            {\n                @Override\n                public ContextHandler createContextHandler(App app) throws Exception\n                {\n                    WebAppContext webAppContext = (WebAppContext) super.createContextHandler(app);\n                    if (webappsConfiguration.getServerClasses() != null)\n                    {\n                        webAppContext.setServerClasses(webappsConfiguration.getServerClasses());\n                    }\n                    if (webappsConfiguration.getSystemClasses() != null)\n                    {\n                        webAppContext.setSystemClasses(webappsConfiguration.getSystemClasses());\n                    }\n                    return webAppContext;\n                }\n            };\n\n            final Connector jettyConnector = createJettyConnector();\n            jettyConnector.setHost(webappsConfiguration.getHost());\n            jettyConnector.setPort(webappsConfiguration.getPort());\n\n            deploymentManager.setContexts(contexts);\n            deploymentManager.addAppProvider(webAppProvider);\n            deploymentManager.addLifeCycleBinding(new AppLifeCycle.Binding()\n            {\n                @Override\n                public String[] getBindingTargets()\n                {\n                    return new String[] {AppLifeCycle.DEPLOYING};\n                }\n\n                @Override\n                public void processBinding(Node node, App app) throws Exception\n                {\n                    ContextHandler contextHandler = app.getContextHandler();\n\n                    if (contextHandler instanceof WebAppContext)\n                    {\n                        WebAppContext webapp = (WebAppContext) contextHandler;\n                        File workDir = new File(muleContext.getConfiguration().getWorkingDirectory(),\n                                                \"_exploded_wars\" + webapp.getContextPath());\n                        workDir.mkdirs();\n                        webapp.setTempDirectory(workDir);\n                        webapp.setAttribute(MULE_CONTEXT_ATTRIBUTE, muleContext);\n                        webapp.setConnectorNames(new String[] {jettyConnector.getName()});\n\n                        if (logger.isInfoEnabled())\n                        {\n                            String msg = String.format(\"Will deploy a web app at %s://%s%s%s\",\n                                                       \"http\", jettyConnector.getHost(),\n                                                       jettyConnector.getPort() == 80 ? StringUtils.EMPTY : \":\" + jettyConnector.getPort(),\n                                                       webapp.getContextPath());\n\n                            logger.info(StringMessageUtils.getBoilerPlate(msg, '*', 70));\n                        }\n                        return;\n                    }\n                }\n            });\n            String webAppDir = webappsConfiguration.getDirectory();\n            if (StringUtils.isBlank(webAppDir))\n            {\n                // if none specified, resolve defaults dynamically\n                final String appDir = muleContext.getRegistry().get(MuleProperties.APP_HOME_DIRECTORY_PROPERTY);\n                webAppDir = appDir + \"/webapps\";\n            }\n\n            if (configFile == null)\n            {\n                // override only if user hasn't specified one (turn off file-mapped buffer for\n                // static files to avoid resource locking, makes webapp resources editable on the fly)\n                final URL muleDefaults = ClassUtils.getResource(\"org/mule/transport/jetty/webdefault.xml\", getClass());\n                webAppProvider.setDefaultsDescriptor(muleDefaults.toExternalForm());\n            }\n\n            webAppProvider.setMonitoredDirName(webAppDir);\n            webAppProvider.setExtractWars(true);\n            webAppProvider.setParentLoaderPriority(false);\n\n            String[] confClasses = new String[]\n            {\n                // configures webapp's classloader as a child of a Mule app classloader\n                WebInfConfiguration.class.getName(),\n                WebXmlConfiguration.class.getName()\n            };\n            webAppProvider.setConfigurationClasses(confClasses);\n            webAppProvider.setDeploymentManager(deploymentManager);\n\n            httpServer.addBean(deploymentManager);\n            httpServer.addConnector(jettyConnector);\n        }\n\n        initialiseFromConfigFile();\n\n        try\n        {\n            muleContext.registerListener(new MuleContextNotificationListener<MuleContextNotification>(){\n                @Override\n                public void onNotification(MuleContextNotification notification)\n                {\n                    if (notification.getAction() == MuleContextNotification.CONTEXT_STARTED)\n                    {\n                        //We delay starting until the context has been started since we need the MuleAjaxServlet to initialise first\n                        setInitialStateStopped(false);\n                        try\n                        {\n                            start();\n                            // update the agent displaying webapp urls to the user\n                            final JettyWebappServerAgent agent = (JettyWebappServerAgent) muleContext.getRegistry().lookupAgent(JettyWebappServerAgent.NAME);\n                            if (agent != null)\n                            {\n                                agent.onJettyConnectorStarted(JettyHttpConnector.this);\n                            }\n                        }\n                        catch (MuleException e)\n                        {\n                            throw new MuleRuntimeException(CoreMessages.failedToStart(getName()), e);\n                        }\n                    }\n                }\n            });\n        }\n        catch (NotificationException e)\n        {\n            throw new InitialisationException(e, this);\n        }\n    }","commit_id":"2e88fdda37bf43cfc49853b57712427147e34310","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void addHandler(Handler handler)\n    {\n\n        final Connector c = httpServer.getConnectors()[0];\n        if (handler instanceof WebAppContext)\n        {\n            final WebAppContext webapp = (WebAppContext) handler;\n            final File workDir = new File(muleContext.getConfiguration().getWorkingDirectory(),\n                                          \"_exploded_wars\" + webapp.getContextPath());\n            workDir.mkdirs();\n            webapp.setTempDirectory(workDir);\n            webapp.setAttribute(MULE_CONTEXT_ATTRIBUTE, muleContext);\n\n            if (logger.isInfoEnabled())\n            {\n                final String msg = String.format(\"Will deploy a web app at %s:/%s%s%s\",\n                                                 \"http\", c.getHost(),\n                                                 c.getPort() == 80 ? StringUtils.EMPTY : \":\" + c.getPort(),\n                                                 webapp.getContextPath());\n\n                logger.info(StringMessageUtils.getBoilerPlate(msg, '*', 70));\n            }\n        }\n\n        ContextHandlerCollection contextHandlers = (ContextHandlerCollection) httpServer.getHandler();\n\n        if (contextHandlers == null)\n        {\n            contextHandlers = new ContextHandlerCollection();\n        }\n        contextHandlers.addHandler(handler);\n\n        httpServer.setHandler(contextHandlers);\n    }","id":26998,"modified_method":"protected void addHandler(Handler handler)\n    {\n        contexts.addHandler(handler);\n    }","commit_id":"2e88fdda37bf43cfc49853b57712427147e34310","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    protected void doStop() throws MuleException\n    {\n        try\n        {\n            httpServer.stop();\n\n            if (deployer != null)\n            {\n                deployer.stop();\n            }\n\n            for (ConnectorHolder<?, ?> connectorRef : holders.values())\n            {\n                connectorRef.stop();\n            }\n        }\n        catch (Exception e)\n        {\n            throw new LifecycleException(CoreMessages.failedToStop(\"Jetty Http Receiver\"), e, this);\n        }\n    }","id":26999,"modified_method":"@Override\n    protected void doStop() throws MuleException\n    {\n        try\n        {\n            httpServer.stop();\n\n            for (ConnectorHolder<?, ?> connectorRef : holders.values())\n            {\n                connectorRef.stop();\n            }\n        }\n        catch (Exception e)\n        {\n            throw new LifecycleException(CoreMessages.failedToStop(\"Jetty Http Receiver\"), e, this);\n        }\n    }","commit_id":"2e88fdda37bf43cfc49853b57712427147e34310","url":"https://github.com/mulesoft/mule"}]