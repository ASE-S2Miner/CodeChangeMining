[{"original_method":"public void configure(FlowSpecifier specifier) {\n    specifier.name(\"CountTokens\");\n    specifier.email(\"me@continuuity.com\");\n    specifier.application(\"End2End\");\n    specifier.stream(\"text\");\n    specifier.flowlet(\"source\", StreamSource.class, 1);\n    specifier.flowlet(\"split\", Tokenizer.class, 1);\n    specifier.flowlet(\"upper\", UpperCaser.class, 1);\n    specifier.flowlet(\"count1\", CountByField.class, 1);\n    specifier.flowlet(\"count2\", CountByField.class, 1);\n    specifier.input(\"text\", \"source\");\n    specifier.connection(\"source\", \"split\");\n    specifier.connection(\"split\", \"count1\");\n    specifier.connection(\"split\", \"upper\");\n    specifier.connection(\"upper\", \"count2\");\n  }","id":92000,"modified_method":"public void configure(FlowSpecifier specifier) {\n    specifier.name(\"CountTokens\");\n    specifier.email(\"me@continuuity.com\");\n    specifier.application(\"End2End\");\n    specifier.stream(\"text\");\n    specifier.dataset(Common.tableName);\n    specifier.flowlet(\"source\", StreamSource.class, 1);\n    specifier.flowlet(\"split\", Tokenizer.class, 1);\n    specifier.flowlet(\"upper\", UpperCaser.class, 1);\n    specifier.flowlet(\"count1\", CountByField.class, 1);\n    specifier.flowlet(\"count2\", CountByField.class, 1);\n    specifier.input(\"text\", \"source\");\n    specifier.connection(\"source\", \"split\");\n    specifier.connection(\"split\", \"count1\");\n    specifier.connection(\"split\", \"upper\");\n    specifier.connection(\"upper\", \"count2\");\n  }","commit_id":"dcdf5a8ead645a78313126535eaf6fa35d5c42ea","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .setApplicationName(\"CountTokensDemo\")\n      .addFlow(CountTokens.class)\n      .addStream(new Stream(\"text\"))\n      .create();\n  }","id":92001,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .setApplicationName(\"CountTokensDemo\")\n      .addFlow(CountTokens.class)\n      .addStream(new Stream(\"text\"))\n      .addDataSet(new KeyValueTable(Common.tableName))\n      .create();\n  }","commit_id":"dcdf5a8ead645a78313126535eaf6fa35d5c42ea","url":"https://github.com/caskdata/cdap"},{"original_method":"protected String importPortletData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences portletPreferences, Element portletDataRefEl)\n\t\tthrows SystemException {\n\n\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\tcontext.getCompanyId(), portletId);\n\n\t\tif (portlet == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Do not import portlet data for \" + portletId +\n\t\t\t\t\t\t\" because the portlet does not exist\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tPortletDataHandler portletDataHandler =\n\t\t\tportlet.getPortletDataHandlerInstance();\n\n\t\tif (portletDataHandler == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Do not import portlet data for \" + portletId +\n\t\t\t\t\t\t\" because the portlet does not have a \" +\n\t\t\t\t\t\t\t\"PortletDataHandler\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Importing data for \" + portletId);\n\t\t}\n\n\t\t// Layout scope\n\n\t\tlong groupId = context.getGroupId();\n\n\t\tString scopeLayoutUuid = context.getScopeLayoutUuid();\n\n\t\tif (Validator.isNull(scopeLayoutUuid)) {\n\t\t\tscopeLayoutUuid = GetterUtil.getString(\n\t\t\t\tportletDataRefEl.getParent().attributeValue(\n\t\t\t\t\t\"scope-layout-uuid\"));\n\t\t}\n\n\t\tif (Validator.isNotNull(scopeLayoutUuid)) {\n\t\t\ttry {\n\t\t\t\tLayout scopeLayout =\n\t\t\t\t\tLayoutLocalServiceUtil.getLayoutByUuidAndGroupId(\n\t\t\t\t\t\tscopeLayoutUuid, groupId);\n\n\t\t\t\tGroup scopeGroup = null;\n\n\t\t\t\tif (scopeLayout.hasScopeGroup()) {\n\t\t\t\t\tscopeGroup = scopeLayout.getScopeGroup();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString name = String.valueOf(scopeLayout.getPlid());\n\n\t\t\t\t\tscopeGroup = GroupLocalServiceUtil.addGroup(\n\t\t\t\t\t\tcontext.getUserId(null), Layout.class.getName(),\n\t\t\t\t\t\tscopeLayout.getPlid(), name, null, 0, null, true, null);\n\t\t\t\t}\n\n\t\t\t\tcontext.setScopeGroupId(scopeGroup.getGroupId());\n\t\t\t}\n\t\t\tcatch (PortalException pe) {\n\t\t\t}\n\t\t}\n\n\t\tPortletPreferencesImpl preferencesImpl = null;\n\n\t\tif (portletPreferences != null) {\n\t\t\tpreferencesImpl = (PortletPreferencesImpl)\n\t\t\t\tPortletPreferencesSerializer.fromDefaultXML(\n\t\t\t\t\tportletPreferences.getPreferences());\n\t\t}\n\n\t\tString portletData = context.getZipEntryAsString(\n\t\t\tportletDataRefEl.attributeValue(\"path\"));\n\n\t\ttry {\n\t\t\tSocialActivityThreadLocal.setEnabled(false);\n\t\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\t\tpreferencesImpl =\n\t\t\t\t(PortletPreferencesImpl)portletDataHandler.importData(\n\t\t\t\t\tcontext, portletId, preferencesImpl, portletData);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcontext.setScopeGroupId(groupId);\n\n\t\t\tSocialActivityThreadLocal.setEnabled(true);\n\t\t\tWorkflowThreadLocal.setEnabled(true);\n\t\t}\n\n\t\tif (preferencesImpl == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn PortletPreferencesSerializer.toXML(preferencesImpl);\n\t}","id":92002,"modified_method":"protected String importPortletData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences portletPreferences, Element portletDataRefEl)\n\t\tthrows SystemException {\n\n\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\tcontext.getCompanyId(), portletId);\n\n\t\tif (portlet == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Do not import portlet data for \" + portletId +\n\t\t\t\t\t\t\" because the portlet does not exist\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tPortletDataHandler portletDataHandler =\n\t\t\tportlet.getPortletDataHandlerInstance();\n\n\t\tif (portletDataHandler == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Do not import portlet data for \" + portletId +\n\t\t\t\t\t\t\" because the portlet does not have a \" +\n\t\t\t\t\t\t\t\"PortletDataHandler\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Importing data for \" + portletId);\n\t\t}\n\n\t\t// Layout scope\n\n\t\tlong groupId = context.getGroupId();\n\n\t\tString scopeLayoutUuid = context.getScopeLayoutUuid();\n\n\t\tif (Validator.isNull(scopeLayoutUuid)) {\n\t\t\tscopeLayoutUuid = GetterUtil.getString(\n\t\t\t\tportletDataRefEl.getParent().attributeValue(\n\t\t\t\t\t\"scope-layout-uuid\"));\n\t\t}\n\n\t\tif (Validator.isNotNull(scopeLayoutUuid)) {\n\t\t\ttry {\n\t\t\t\tLayout scopeLayout =\n\t\t\t\t\tLayoutLocalServiceUtil.getLayoutByUuidAndGroupId(\n\t\t\t\t\t\tscopeLayoutUuid, groupId);\n\n\t\t\t\tGroup scopeGroup = null;\n\n\t\t\t\tif (scopeLayout.hasScopeGroup()) {\n\t\t\t\t\tscopeGroup = scopeLayout.getScopeGroup();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString name = String.valueOf(scopeLayout.getPlid());\n\n\t\t\t\t\tscopeGroup = GroupLocalServiceUtil.addGroup(\n\t\t\t\t\t\tcontext.getUserId(null), Layout.class.getName(),\n\t\t\t\t\t\tscopeLayout.getPlid(), name, null, 0, null, true, null);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tlong oldPlid = context.getOldPlid();\n\n\t\t\t\t\tif (oldPlid == 0) {\n\t\t\t\t\t\toldPlid = GetterUtil.getLong(\n\t\t\t\t\t\t\tportletDataRefEl.getParent().attributeValue(\n\t\t\t\t\t\t\t\t\"old-plid\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tLayout oldLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\t\toldPlid);\n\n\t\t\t\t\tGroup oldScopeGroup = oldLayout.getScopeGroup();\n\n\t\t\t\t\toldScopeGroup.setLiveGroupId(scopeGroup.getGroupId());\n\n\t\t\t\t\tGroupLocalServiceUtil.updateGroup(oldScopeGroup, true);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(nsle);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontext.setScopeGroupId(scopeGroup.getGroupId());\n\t\t\t}\n\t\t\tcatch (PortalException pe) {\n\t\t\t}\n\t\t}\n\n\t\tPortletPreferencesImpl preferencesImpl = null;\n\n\t\tif (portletPreferences != null) {\n\t\t\tpreferencesImpl = (PortletPreferencesImpl)\n\t\t\t\tPortletPreferencesSerializer.fromDefaultXML(\n\t\t\t\t\tportletPreferences.getPreferences());\n\t\t}\n\n\t\tString portletData = context.getZipEntryAsString(\n\t\t\tportletDataRefEl.attributeValue(\"path\"));\n\n\t\ttry {\n\t\t\tSocialActivityThreadLocal.setEnabled(false);\n\t\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\t\tpreferencesImpl =\n\t\t\t\t(PortletPreferencesImpl)portletDataHandler.importData(\n\t\t\t\t\tcontext, portletId, preferencesImpl, portletData);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcontext.setScopeGroupId(groupId);\n\n\t\t\tSocialActivityThreadLocal.setEnabled(true);\n\t\t\tWorkflowThreadLocal.setEnabled(true);\n\t\t}\n\n\t\tif (preferencesImpl == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn PortletPreferencesSerializer.toXML(preferencesImpl);\n\t}","commit_id":"cca53713026cf33f21aea992d0811a657cb70fdd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void publishToLive(PortletRequest portletRequest, Portlet portlet)\n\t\tthrows Exception {\n\n\t\tlong plid = ParamUtil.getLong(portletRequest, \"plid\");\n\n\t\tLayout sourceLayout = LayoutLocalServiceUtil.getLayout(plid);\n\n\t\tGroup stagingGroup = sourceLayout.getGroup();\n\t\tGroup liveGroup = stagingGroup.getLiveGroup();\n\n\t\tLayout targetLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\tliveGroup.getGroupId(), sourceLayout.isPrivateLayout(),\n\t\t\tsourceLayout.getLayoutId());\n\n\t\tcopyPortlet(\n\t\t\tportletRequest, stagingGroup.getGroupId(), liveGroup.getGroupId(),\n\t\t\tsourceLayout.getPlid(), targetLayout.getPlid(),\n\t\t\tportlet.getPortletId());\n\t}","id":92003,"modified_method":"public void publishToLive(PortletRequest portletRequest, Portlet portlet)\n\t\tthrows Exception {\n\n\t\tlong plid = ParamUtil.getLong(portletRequest, \"plid\");\n\n\t\tLayout sourceLayout = LayoutLocalServiceUtil.getLayout(plid);\n\n\t\tGroup stagingGroup = null;\n\t\tGroup liveGroup = null;\n\n\t\tLayout targetLayout = null;\n\n\t\tlong scopeGroupId = PortalUtil.getScopeGroupId(portletRequest);\n\n\t\tif (sourceLayout.hasScopeGroup() &&\n\t\t\t(sourceLayout.getScopeGroup().getGroupId() == scopeGroupId)) {\n\n\t\t\tstagingGroup = sourceLayout.getScopeGroup();\n\t\t\tliveGroup = stagingGroup.getLiveGroup();\n\n\t\t\ttargetLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\tliveGroup.getClassPK());\n\t\t}\n\t\telse {\n\t\t\tstagingGroup = sourceLayout.getGroup();\n\t\t\tliveGroup = stagingGroup.getLiveGroup();\n\n\t\t\ttargetLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\tliveGroup.getGroupId(), sourceLayout.isPrivateLayout(),\n\t\t\t\tsourceLayout.getLayoutId());\n\t\t}\n\n\t\tcopyPortlet(\n\t\t\tportletRequest, stagingGroup.getGroupId(), liveGroup.getGroupId(),\n\t\t\tsourceLayout.getPlid(), targetLayout.getPlid(),\n\t\t\tportlet.getPortletId());\n\t}","commit_id":"cca53713026cf33f21aea992d0811a657cb70fdd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.rendering.macro.Macro#execute(java.lang.Object, java.lang.String,\n     *      org.xwiki.rendering.transformation.MacroTransformationContext)\n     */\n    public List<Block> execute(DashboardMacroParameters parameters, String content, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        Map<String, Object> fxParams = new HashMap<String, Object>();\n        fxParams.put(\"forceSkinAction\", true);\n\n        ssfx.use(\"uicomponents/dashboard/dashboard.css\", fxParams);\n\n        // do the layouting with the container macro\n        ContainerMacroParameters containerParameters = new ContainerMacroParameters();\n        containerParameters.setJustify(true);\n        containerParameters.setLayoutStyle(parameters.getLayout());\n        List<Block> layoutedResult = containerMacro.execute(containerParameters, content, context);\n\n        // get all the macro blocks inside and wrap them in a gadget macro, which will generate a title for it and a box\n        // around it to be able to have decoration and drag it\n        // TODO: expand container macros and descend into them. Container macro is a special case, used for layouting\n        // dashboards and not as a gadget\n        for (Block layoutedTopLevelBlock : layoutedResult) {\n            for (MacroBlock macroBlock : layoutedTopLevelBlock.getChildrenByType(MacroBlock.class, true)) {\n                // clone the macro block here, because otherwise we will not have it in the parent anymore\n                GadgetMacro gadgetBoxMacro = new GadgetMacro((MacroBlock) macroBlock.clone(), this.componentManager);\n                // execute with null params and null content since they will be generated anyway, from the set macro\n                // block\n                List<Block> boxMacroBlocks = gadgetBoxMacro.execute(null, null, context);\n                // replace the macro block in its parent with the blocks returned by the box macro\n                macroBlock.getParent().replaceChild(boxMacroBlocks, macroBlock);\n            }\n        }\n\n        // put everything in a nice toplevel group for this dashboard, to be able to add classes to it\n        GroupBlock topLevel = new GroupBlock();\n        topLevel.addChildren(layoutedResult);\n        // add the style attribute of the dashboard macro as a class to the toplevel container\n        topLevel.setParameter(\"class\", MACRO_NAME\n            + (StringUtils.isEmpty(parameters.getStyle()) ? \"\" : \" \" + parameters.getStyle()));\n\n        return Collections.<Block> singletonList(topLevel);\n    }","id":92004,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.rendering.macro.Macro#execute(java.lang.Object, java.lang.String,\n     *      org.xwiki.rendering.transformation.MacroTransformationContext)\n     */\n    public List<Block> execute(DashboardMacroParameters parameters, String content, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        Map<String, Object> fxParams = new HashMap<String, Object>();\n        fxParams.put(\"forceSkinAction\", true);\n\n        ssfx.use(\"uicomponents/dashboard/dashboard.css\", fxParams);\n\n        // get the gadgets from the objects\n        List<Gadget> gadgets;\n        try {\n            gadgets = gadgetReader.getGadgets(context);\n        } catch (Exception e) {\n            String message = \"Could not get the gadgets.\";\n            // log and throw further\n            getLogger().error(message, e);\n            throw new MacroExecutionException(message, e);\n        }\n        DashboardRenderer renderer =\n            getDashboardRenderer(StringUtils.isEmpty(parameters.getLayout()) ? \"columns\" : parameters.getLayout());\n        if (renderer == null) {\n            String message = \"Could not find dashboard renderer \" + parameters.getLayout();\n            // log and throw further\n            getLogger().error(message);\n            throw new MacroExecutionException(message);\n        }\n        // else, layout\n        List<Block> layoutedResult;\n        try {\n            layoutedResult = renderer.renderGadgets(gadgets, context);\n        } catch (Exception e) {\n            String message = \"Could not render the gadgets for layout \" + parameters.getLayout();\n            // log and throw further\n            getLogger().error(message, e);\n            throw new MacroExecutionException(message, e);\n        }\n\n        // put everything in a nice toplevel group for this dashboard, to be able to add classes to it\n        GroupBlock topLevel = new GroupBlock();\n        topLevel.addChildren(layoutedResult);\n        // add the style attribute of the dashboard macro as a class to the toplevel container\n        topLevel.setParameter(\"class\", MACRO_NAME\n            + (StringUtils.isEmpty(parameters.getStyle()) ? \"\" : \" \" + parameters.getStyle()));\n\n        return Collections.<Block> singletonList(topLevel);\n    }","commit_id":"b311d8c481fa16ef31906827513c95b5664d2e51","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void updatePortletPreferences() throws Exception {\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select portletPreferencesId, ownerId, ownerType, plid, \" +\n\t\t\t\t\t\"portletId, preferences from PortletPreferences where \" +\n\t\t\t\t\t\tgetUpdatePortletPreferencesWhereClause());\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tlong portletPreferencesId = rs.getLong(\"portletPreferencesId\");\n\t\t\t\tlong ownerId = rs.getLong(\"ownerId\");\n\t\t\t\tint ownerType = rs.getInt(\"ownerType\");\n\t\t\t\tlong plid = rs.getLong(\"plid\");\n\t\t\t\tString portletId = rs.getString(\"portletId\");\n\t\t\t\tString preferences = rs.getString(\"preferences\");\n\n\t\t\t\tObject[] layout = getLayout(plid);\n\n\t\t\t\tif (layout != null) {\n\t\t\t\t\tlong companyId = (Long)layout[1];\n\n\t\t\t\t\tString newPreferences = upgradePreferences(\n\t\t\t\t\t\tcompanyId, ownerId, ownerType, plid, portletId,\n\t\t\t\t\t\tpreferences);\n\n\t\t\t\t\tupdatePortletPreferences(\n\t\t\t\t\t\tportletPreferencesId, newPreferences);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdeletePortletPreferences(portletPreferencesId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\t}","id":92005,"modified_method":"protected void updatePortletPreferences() throws Exception {\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select portletPreferencesId, ownerId, ownerType, plid, \" +\n\t\t\t\t\t\"portletId, preferences from PortletPreferences where \" +\n\t\t\t\t\t\tgetUpdatePortletPreferencesWhereClause());\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tlong portletPreferencesId = rs.getLong(\"portletPreferencesId\");\n\t\t\t\tlong ownerId = rs.getLong(\"ownerId\");\n\t\t\t\tint ownerType = rs.getInt(\"ownerType\");\n\t\t\t\tlong plid = rs.getLong(\"plid\");\n\t\t\t\tString portletId = rs.getString(\"portletId\");\n\t\t\t\tString preferences = rs.getString(\"preferences\");\n\n\t\t\t\tObject[] context = null;\n\n\t\t\t\tif (ownerType == PortletKeys.PREFS_OWNER_TYPE_GROUP) {\n\t\t\t\t\tcontext = getGroup(ownerId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontext = getLayout(plid);\n\t\t\t\t}\n\n\n\t\t\t\tif (context != null) {\n\t\t\t\t\tlong companyId = (Long)context[1];\n\n\t\t\t\t\tString newPreferences = upgradePreferences(\n\t\t\t\t\t\tcompanyId, ownerId, ownerType, plid, portletId,\n\t\t\t\t\t\tpreferences);\n\n\t\t\t\t\tupdatePortletPreferences(\n\t\t\t\t\t\tportletPreferencesId, newPreferences);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdeletePortletPreferences(portletPreferencesId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\t}","commit_id":"80460799b0abc22085ff10782f935ff6152dc602","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long getGroupId(HttpServletRequest request) {\n\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\n\t\tif (groupId > 0) {\n\t\t\treturn groupId;\n\t\t}\n\n\t\tlong plid = ParamUtil.getLong(request, \"p_l_id\");\n\n\t\tif ((plid > 0) && (_layoutLocalService != null)) {\n\t\t\ttry {\n\t\t\t\tLayout layout = _layoutLocalService.getLayout(plid);\n\n\t\t\t\tgroupId = layout.getGroupId();\n\t\t\t}\n\t\t\tcatch (PortalException pe) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Unable to retrieve layout \" + plid, pe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn groupId;\n\t}","id":92006,"modified_method":"protected long getGroupId(HttpServletRequest request) {\n\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\n\t\tif (groupId > 0) {\n\t\t\treturn groupId;\n\t\t}\n\n\t\tLayout layout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tif (layout != null) {\n\t\t\treturn layout.getGroupId();\n\t\t}\n\n\t\tlong plid = ParamUtil.getLong(request, \"p_l_id\");\n\n\t\tif ((plid > 0) && (_layoutLocalService != null)) {\n\t\t\ttry {\n\t\t\t\tlayout = _layoutLocalService.getLayout(plid);\n\n\t\t\t\tgroupId = layout.getGroupId();\n\t\t\t}\n\t\t\tcatch (PortalException pe) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Unable to retrieve layout \" + plid, pe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn groupId;\n\t}","commit_id":"ce809766bb93fc1fe40cd9b057a1131411c97e21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows IOException, ServletException {\n\n\t\tlong companyId = PortalUtil.getCompanyId(request);\n\t\tlong groupId = getGroupId(request);\n\n\t\tDataSample dataSample = null;\n\n\t\tif (_monitorPortalRequest) {\n\t\t\tdataSample = _dataSampleFactory.createPortalRequestDataSample(\n\t\t\t\tcompanyId, groupId, request.getRemoteUser(),\n\t\t\t\trequest.getRequestURI(),\n\t\t\t\tGetterUtil.getString(request.getRequestURL()));\n\n\t\t\tDataSampleThreadLocal.initialize();\n\t\t}\n\n\t\ttry {\n\t\t\tif (dataSample != null) {\n\t\t\t\tdataSample.prepare();\n\t\t\t}\n\n\t\t\tprocessFilter(\n\t\t\t\tMonitoringFilter.class, request, response, filterChain);\n\n\t\t\tif (dataSample != null) {\n\t\t\t\tdataSample.capture(RequestStatus.SUCCESS);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (dataSample != null) {\n\t\t\t\tdataSample.capture(RequestStatus.ERROR);\n\t\t\t}\n\n\t\t\tif (e instanceof IOException) {\n\t\t\t\tthrow (IOException)e;\n\t\t\t}\n\t\t\telse if (e instanceof ServletException) {\n\t\t\t\tthrow (ServletException)e;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new ServletException(\"Unable to execute request\", e);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (dataSample != null) {\n\t\t\t\tDataSampleThreadLocal.addDataSample(dataSample);\n\t\t\t}\n\n\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\tDestinationNames.MONITORING,\n\t\t\t\tDataSampleThreadLocal.getDataSamples());\n\t\t}\n\t}","id":92007,"modified_method":"@Override\n\tprotected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows IOException, ServletException {\n\n\t\tlong companyId = PortalUtil.getCompanyId(request);\n\t\tlong groupId = getGroupId(request);\n\n\t\tDataSample dataSample = null;\n\n\t\tif (_monitorPortalRequest) {\n\t\t\tdataSample = _dataSampleFactory.createPortalRequestDataSample(\n\t\t\t\tcompanyId, groupId, request.getRemoteUser(),\n\t\t\t\trequest.getRequestURI(),\n\t\t\t\tGetterUtil.getString(request.getRequestURL()));\n\n\t\t\tDataSampleThreadLocal.initialize();\n\t\t}\n\n\t\ttry {\n\t\t\tif (dataSample != null) {\n\t\t\t\tdataSample.prepare();\n\t\t\t}\n\n\t\t\tprocessFilter(\n\t\t\t\tMonitoringFilter.class, request, response, filterChain);\n\n\t\t\tif (dataSample != null) {\n\t\t\t\tdataSample.capture(RequestStatus.SUCCESS);\n\t\t\t\tdataSample.setGroupId(getGroupId(request));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (dataSample != null) {\n\t\t\t\tdataSample.capture(RequestStatus.ERROR);\n\t\t\t}\n\n\t\t\tif (e instanceof IOException) {\n\t\t\t\tthrow (IOException)e;\n\t\t\t}\n\t\t\telse if (e instanceof ServletException) {\n\t\t\t\tthrow (ServletException)e;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new ServletException(\"Unable to execute request\", e);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (dataSample != null) {\n\t\t\t\tDataSampleThreadLocal.addDataSample(dataSample);\n\t\t\t}\n\n\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\tDestinationNames.MONITORING,\n\t\t\t\tDataSampleThreadLocal.getDataSamples());\n\t\t}\n\t}","commit_id":"ce809766bb93fc1fe40cd9b057a1131411c97e21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateListenersConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"   <listeners>\" +\n                \"        <listener>foo<\/listener>\\n\\n\" +\n                \"   <\/listeners>\\n\" +\n                \"   <listeners>\" +\n                \"        <listener>bar<\/listener>\\n\\n\" +\n                \"   <\/listeners>\\n\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92008,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateListenersConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"   <listeners>\" +\n                \"        <listener>foo<\/listener>\\n\\n\" +\n                \"   <\/listeners>\\n\" +\n                \"   <listeners>\" +\n                \"        <listener>bar<\/listener>\\n\\n\" +\n                \"   <\/listeners>\\n\" +\n                \"<\/hazelcast>\";\n\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testImportEmptyResourceContent() throws Exception {\n        File config1 = createConfigFile(\"hz1\", \"xml\");\n        FileOutputStream os1 = new FileOutputStream(config1);\n        String config1Xml = \"<hazelcast>\" +\n                \"    <import resource=\\\"file://\" + config1.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os1, \"\");\n        ByteArrayInputStream bis = new ByteArrayInputStream(config1Xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92009,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testImportEmptyResourceContent() throws Exception {\n        File config1 = createConfigFile(\"hz1\", \"xml\");\n        FileOutputStream os1 = new FileOutputStream(config1);\n        String config1Xml = \"<hazelcast>\" +\n                \"    <import resource=\\\"file://\" + config1.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os1, \"\");\n        buildConfig(config1Xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateSerializationConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"       <serialization>\\n\" +\n                \"        <portable-version>0<\/portable-version>\\n\" +\n                \"        <data-serializable-factories>\\n\" +\n                \"            <data-serializable-factory factory-id=\\\"1\\\">com.hazelcast.examples.DataSerializableFactory\\n\" +\n                \"            <\/data-serializable-factory>\\n\" +\n                \"        <\/data-serializable-factories>\\n\" +\n                \"        <portable-factories>\\n\" +\n                \"            <portable-factory factory-id=\\\"1\\\">com.hazelcast.examples.PortableFactory<\/portable-factory>\\n\" +\n                \"        <\/portable-factories>\\n\" +\n                \"        <serializers>\\n\" +\n                \"            <global-serializer>com.hazelcast.examples.GlobalSerializerFactory<\/global-serializer>\\n\" +\n                \"            <serializer type-class=\\\"com.hazelcast.examples.DummyType\\\" class-name=\\\"com.hazelcast.examples.SerializerFactory\\\"/>\\n\" +\n                \"        <\/serializers>\\n\" +\n                \"        <check-class-def-errors>true<\/check-class-def-errors>\\n\" +\n                \"    <\/serialization>\\n <serialization>\\n\" +\n                \"        <portable-version>0<\/portable-version>\\n\" +\n                \"        <data-serializable-factories>\\n\" +\n                \"            <data-serializable-factory factory-id=\\\"1\\\">com.hazelcast.examples.DataSerializableFactory\\n\" +\n                \"            <\/data-serializable-factory>\\n\" +\n                \"        <\/data-serializable-factories>\\n\" +\n                \"        <portable-factories>\\n\" +\n                \"            <portable-factory factory-id=\\\"1\\\">com.hazelcast.examples.PortableFactory<\/portable-factory>\\n\" +\n                \"        <\/portable-factories>\\n\" +\n                \"        <serializers>\\n\" +\n                \"            <global-serializer>com.hazelcast.examples.GlobalSerializerFactory<\/global-serializer>\\n\" +\n                \"            <serializer type-class=\\\"com.hazelcast.examples.DummyType\\\" class-name=\\\"com.hazelcast.examples.SerializerFactory\\\"/>\\n\" +\n                \"        <\/serializers>\\n\" +\n                \"        <check-class-def-errors>true<\/check-class-def-errors>\\n\" +\n                \"    <\/serialization>\\n\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92010,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateSerializationConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"       <serialization>\\n\" +\n                \"        <portable-version>0<\/portable-version>\\n\" +\n                \"        <data-serializable-factories>\\n\" +\n                \"            <data-serializable-factory factory-id=\\\"1\\\">com.hazelcast.examples.DataSerializableFactory\\n\" +\n                \"            <\/data-serializable-factory>\\n\" +\n                \"        <\/data-serializable-factories>\\n\" +\n                \"        <portable-factories>\\n\" +\n                \"            <portable-factory factory-id=\\\"1\\\">com.hazelcast.examples.PortableFactory<\/portable-factory>\\n\" +\n                \"        <\/portable-factories>\\n\" +\n                \"        <serializers>\\n\" +\n                \"            <global-serializer>com.hazelcast.examples.GlobalSerializerFactory<\/global-serializer>\\n\" +\n                \"            <serializer type-class=\\\"com.hazelcast.examples.DummyType\\\" class-name=\\\"com.hazelcast.examples.SerializerFactory\\\"/>\\n\" +\n                \"        <\/serializers>\\n\" +\n                \"        <check-class-def-errors>true<\/check-class-def-errors>\\n\" +\n                \"    <\/serialization>\\n <serialization>\\n\" +\n                \"        <portable-version>0<\/portable-version>\\n\" +\n                \"        <data-serializable-factories>\\n\" +\n                \"            <data-serializable-factory factory-id=\\\"1\\\">com.hazelcast.examples.DataSerializableFactory\\n\" +\n                \"            <\/data-serializable-factory>\\n\" +\n                \"        <\/data-serializable-factories>\\n\" +\n                \"        <portable-factories>\\n\" +\n                \"            <portable-factory factory-id=\\\"1\\\">com.hazelcast.examples.PortableFactory<\/portable-factory>\\n\" +\n                \"        <\/portable-factories>\\n\" +\n                \"        <serializers>\\n\" +\n                \"            <global-serializer>com.hazelcast.examples.GlobalSerializerFactory<\/global-serializer>\\n\" +\n                \"            <serializer type-class=\\\"com.hazelcast.examples.DummyType\\\" class-name=\\\"com.hazelcast.examples.SerializerFactory\\\"/>\\n\" +\n                \"        <\/serializers>\\n\" +\n                \"        <check-class-def-errors>true<\/check-class-def-errors>\\n\" +\n                \"    <\/serialization>\\n\" +\n                \"<\/hazelcast>\";\n\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateGroupConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <group>\\n\" +\n                \"        <name>foobar<\/name>\\n\" +\n                \"        <password>dev-pass<\/password>\\n\" +\n                \"    <\/group>\" +\n                \"    <group>\\n\" +\n                \"        <name>foobar<\/name>\\n\" +\n                \"        <password>dev-pass<\/password>\\n\" +\n                \"    <\/group>\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92011,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateGroupConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <group>\\n\" +\n                \"        <name>foobar<\/name>\\n\" +\n                \"        <password>dev-pass<\/password>\\n\" +\n                \"    <\/group>\" +\n                \"    <group>\\n\" +\n                \"        <name>foobar<\/name>\\n\" +\n                \"        <password>dev-pass<\/password>\\n\" +\n                \"    <\/group>\" +\n                \"<\/hazelcast>\";\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicatePropertiesConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <properties>\\n\" +\n                \"        <property>foo<\/property>\\n\" +\n                \"    <\/properties>\" +\n                \"    <properties>\\n\" +\n                \"        <property>bar<\/property>\\n\" +\n                \"    <\/properties>\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92012,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicatePropertiesConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <properties>\\n\" +\n                \"        <property>foo<\/property>\\n\" +\n                \"    <\/properties>\" +\n                \"    <properties>\\n\" +\n                \"        <property>bar<\/property>\\n\" +\n                \"    <\/properties>\" +\n                \"<\/hazelcast>\";\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testHazelcastElementOnlyAppersOnce() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"   <hazelcast>\" +\n                \"   <\/hazelcast>\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        Config config = configBuilder.build();\n    }","id":92013,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testHazelcastElementOnlyAppersOnce() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"   <hazelcast>\" +\n                \"   <\/hazelcast>\" +\n                \"<\/hazelcast>\";\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void readVariables() {\n        String xml =\n                \"<hazelcast>\\n\" +\n                        \"    <semaphore name=\\\"${name}\\\">\\n\" +\n                        \"        <initial-permits>${initial.permits}<\/initial-permits>\\n\" +\n                        \"        <backup-count>${backupcount.part1}${backupcount.part2}<\/backup-count>\\n\" +\n                        \"        <async-backup-count>${notreplaced}<\/async-backup-count>\\n\" +\n                        \"    <\/semaphore>\" +\n                        \"<\/hazelcast>\";\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n\n        Properties properties = new Properties();\n        properties.setProperty(\"name\", \"s\");\n        properties.setProperty(\"initial.permits\", \"25\");\n        properties.setProperty(\"backupcount.part1\", \"1\");\n        properties.setProperty(\"backupcount.part2\", \"0\");\n        configBuilder.setProperties(properties);\n\n        Config config = configBuilder.build();\n        SemaphoreConfig semaphoreConfig = config.getSemaphoreConfig(\"s\");\n        assertEquals(25, semaphoreConfig.getInitialPermits());\n        assertEquals(10, semaphoreConfig.getBackupCount());\n        assertEquals(0, semaphoreConfig.getAsyncBackupCount());\n    }","id":92014,"modified_method":"@Test\n    public void readVariables() {\n        String xml =\n                \"<hazelcast>\\n\" +\n                        \"    <semaphore name=\\\"${name}\\\">\\n\" +\n                        \"        <initial-permits>${initial.permits}<\/initial-permits>\\n\" +\n                        \"        <backup-count>${backupcount.part1}${backupcount.part2}<\/backup-count>\\n\" +\n                        \"        <async-backup-count>${notreplaced}<\/async-backup-count>\\n\" +\n                        \"    <\/semaphore>\" +\n                        \"<\/hazelcast>\";\n\n        Properties properties = new Properties();\n        properties.setProperty(\"name\", \"s\");\n        properties.setProperty(\"initial.permits\", \"25\");\n        properties.setProperty(\"backupcount.part1\", \"1\");\n        properties.setProperty(\"backupcount.part2\", \"0\");\n        Config config = buildConfig(xml, properties);\n        SemaphoreConfig semaphoreConfig = config.getSemaphoreConfig(\"s\");\n        assertEquals(25, semaphoreConfig.getInitialPermits());\n        assertEquals(10, semaphoreConfig.getBackupCount());\n        assertEquals(0, semaphoreConfig.getAsyncBackupCount());\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testImportElementOnlyAppersInTopLevel() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"   <network>\" +\n                \"        <import resource=\\\"\\\"/>\\n\" +\n                \"   <\/network>\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        Config config = configBuilder.build();\n    }","id":92015,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testImportElementOnlyAppersInTopLevel() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"   <network>\" +\n                \"        <import resource=\\\"\\\"/>\\n\" +\n                \"   <\/network>\" +\n                \"<\/hazelcast>\";\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateNetworkConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <network>\\n\" +\n                \"        <join>\\n\" +\n                \"            <tcp-ip enabled=\\\"true\\\"/>\\n\" +\n                \"        <\/join>\\n\" +\n                \"    <\/network>\\n\" +\n                \"    <network>\\n\" +\n                \"        <join>\\n\" +\n                \"            <tcp-ip enabled=\\\"false\\\"/>\\n\" +\n                \"        <\/join>\\n\" +\n                \"    <\/network>\\n\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92016,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateNetworkConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <network>\\n\" +\n                \"        <join>\\n\" +\n                \"            <tcp-ip enabled=\\\"true\\\"/>\\n\" +\n                \"        <\/join>\\n\" +\n                \"    <\/network>\\n\" +\n                \"    <network>\\n\" +\n                \"        <join>\\n\" +\n                \"            <tcp-ip enabled=\\\"false\\\"/>\\n\" +\n                \"        <\/join>\\n\" +\n                \"    <\/network>\\n\" +\n                \"<\/hazelcast>\";\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testImportNotExistingResourceThrowsException() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"notexisting.xml\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92017,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testImportNotExistingResourceThrowsException() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"notexisting.xml\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testImportedConfigVariableReplacement() throws IOException {\n        File file = createConfigFile(\"foo\", \"bar\");\n        FileOutputStream os = new FileOutputStream(file);\n        String networkConfig = \"<hazelcast>\" +\n                \"    <network>\\n\" +\n                \"        <join>\\n\" +\n                \"            <multicast enabled=\\\"false\\\"/>\\n\" +\n                \"            <tcp-ip enabled=\\\"${tcp.ip.enabled}\\\"/>\\n\" +\n                \"        <\/join>\\n\" +\n                \"    <\/network>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os, networkConfig);\n\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"${config.location}\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n\n        Properties properties = new Properties();\n        properties.setProperty(\"config.location\", file.getAbsolutePath());\n        properties.setProperty(\"tcp.ip.enabled\", \"true\");\n        configBuilder.setProperties(properties);\n        Config config = configBuilder.build();\n        JoinConfig join = config.getNetworkConfig().getJoin();\n        assertFalse(join.getMulticastConfig().isEnabled());\n        assertTrue(join.getTcpIpConfig().isEnabled());\n    }","id":92018,"modified_method":"@Test\n    public void testImportedConfigVariableReplacement() throws IOException {\n        File file = createConfigFile(\"foo\", \"bar\");\n        FileOutputStream os = new FileOutputStream(file);\n        String networkConfig = \"<hazelcast>\" +\n                \"    <network>\\n\" +\n                \"        <join>\\n\" +\n                \"            <multicast enabled=\\\"false\\\"/>\\n\" +\n                \"            <tcp-ip enabled=\\\"${tcp.ip.enabled}\\\"/>\\n\" +\n                \"        <\/join>\\n\" +\n                \"    <\/network>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os, networkConfig);\n\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"${config.location}\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n\n        Properties properties = new Properties();\n        properties.setProperty(\"config.location\", file.getAbsolutePath());\n        properties.setProperty(\"tcp.ip.enabled\", \"true\");\n        Config config = buildConfig(xml, properties);\n        JoinConfig join = config.getNetworkConfig().getJoin();\n        assertFalse(join.getMulticastConfig().isEnabled());\n        assertTrue(join.getTcpIpConfig().isEnabled());\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testThreeResourceCyclicImportThrowsException() throws Exception {\n        File config1 = createConfigFile(\"hz1\", \"xml\");\n        File config2 = createConfigFile(\"hz2\", \"xml\");\n        File config3 = createConfigFile(\"hz3\", \"xml\");\n        FileOutputStream os1 = new FileOutputStream(config1);\n        FileOutputStream os2 = new FileOutputStream(config2);\n        FileOutputStream os3 = new FileOutputStream(config2);\n        String config1Xml = \"<hazelcast>\" +\n                \"    <import resource=\\\"file://\" + config2.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        String config2Xml = \"<hazelcast>\" +\n                \"    <import resource=\\\"file://\" + config3.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        String config3Xml = \"<hazelcast>\" +\n                \"    <import resource=\\\"file://\" + config1.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os1, config1Xml);\n        writeStringToStreamAndClose(os2, config2Xml);\n        writeStringToStreamAndClose(os3, config3Xml);\n        ByteArrayInputStream bis = new ByteArrayInputStream(config1Xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92019,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testThreeResourceCyclicImportThrowsException() throws Exception {\n        File config1 = createConfigFile(\"hz1\", \"xml\");\n        File config2 = createConfigFile(\"hz2\", \"xml\");\n        File config3 = createConfigFile(\"hz3\", \"xml\");\n        FileOutputStream os1 = new FileOutputStream(config1);\n        FileOutputStream os2 = new FileOutputStream(config2);\n        FileOutputStream os3 = new FileOutputStream(config2);\n        String config1Xml = \"<hazelcast>\" +\n                \"    <import resource=\\\"file://\" + config2.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        String config2Xml = \"<hazelcast>\" +\n                \"    <import resource=\\\"file://\" + config3.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        String config3Xml = \"<hazelcast>\" +\n                \"    <import resource=\\\"file://\" + config1.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os1, config1Xml);\n        writeStringToStreamAndClose(os2, config2Xml);\n        writeStringToStreamAndClose(os3, config3Xml);\n        buildConfig(config1Xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateServicesConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"   <services>       \" +\n                \"       <service enabled=\\\"true\\\">\\n\" +\n                \"            <name>custom-service<\/name>\\n\" +\n                \"            <class-name>com.hazelcast.examples.MyService<\/class-name>\\n\" +\n                \"        <\/service>\\n\" +\n                \"   <\/services>\" +\n                \"   <services>   \" +\n                \"        <service enabled=\\\"true\\\">\\n\" +\n                \"            <name>custom-service<\/name>\\n\" +\n                \"            <class-name>com.hazelcast.examples.MyService<\/class-name>\\n\" +\n                \"        <\/service>\\n\" +\n                \"   <\/services>\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92020,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateServicesConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"   <services>       \" +\n                \"       <service enabled=\\\"true\\\">\\n\" +\n                \"            <name>custom-service<\/name>\\n\" +\n                \"            <class-name>com.hazelcast.examples.MyService<\/class-name>\\n\" +\n                \"        <\/service>\\n\" +\n                \"   <\/services>\" +\n                \"   <services>   \" +\n                \"        <service enabled=\\\"true\\\">\\n\" +\n                \"            <name>custom-service<\/name>\\n\" +\n                \"            <class-name>com.hazelcast.examples.MyService<\/class-name>\\n\" +\n                \"        <\/service>\\n\" +\n                \"   <\/services>\" +\n                \"<\/hazelcast>\";\n\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testImportMapConfigFromFile() throws Exception {\n        File file = createConfigFile(\"mymap\", \"config\");\n        FileOutputStream os = new FileOutputStream(file);\n        String mapConfig = \"<hazelcast>\" +\n                \"    <map name=\\\"mymap\\\">\\n\" +\n                \"       <backup-count>6<\/backup-count>\" +\n                \"       <time-to-live-seconds>10<\/time-to-live-seconds>\" +\n                \"       <map-store enabled=\\\"true\\\" initial-mode=\\\"LAZY\\\">\\n\" +\n                \"            <class-name>com.hazelcast.examples.MyMapStore<\/class-name>\\n\" +\n                \"            <write-delay-seconds>10<\/write-delay-seconds>\\n\" +\n                \"            <write-batch-size>100<\/write-batch-size>\\n\" +\n                \"        <\/map-store>\" +\n                \"<\/map>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os, mapConfig);\n\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"file://\" + file.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        Config config = configBuilder.build();\n        MapConfig myMapConfig = config.getMapConfig(\"mymap\");\n        assertEquals(\"mymap\", myMapConfig.getName());\n        assertEquals(6, myMapConfig.getBackupCount());\n        assertEquals(10, myMapConfig.getTimeToLiveSeconds());\n        MapStoreConfig myMapStoreConfig = myMapConfig.getMapStoreConfig();\n        assertEquals(10, myMapStoreConfig.getWriteDelaySeconds());\n        assertEquals(100, myMapStoreConfig.getWriteBatchSize());\n        assertEquals(\"com.hazelcast.examples.MyMapStore\", myMapStoreConfig.getClassName());\n    }","id":92021,"modified_method":"@Test\n    public void testImportMapConfigFromFile() throws Exception {\n        File file = createConfigFile(\"mymap\", \"config\");\n        FileOutputStream os = new FileOutputStream(file);\n        String mapConfig = \"<hazelcast>\" +\n                \"    <map name=\\\"mymap\\\">\\n\" +\n                \"       <backup-count>6<\/backup-count>\" +\n                \"       <time-to-live-seconds>10<\/time-to-live-seconds>\" +\n                \"       <map-store enabled=\\\"true\\\" initial-mode=\\\"LAZY\\\">\\n\" +\n                \"            <class-name>com.hazelcast.examples.MyMapStore<\/class-name>\\n\" +\n                \"            <write-delay-seconds>10<\/write-delay-seconds>\\n\" +\n                \"            <write-batch-size>100<\/write-batch-size>\\n\" +\n                \"        <\/map-store>\" +\n                \"<\/map>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os, mapConfig);\n\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"file://\" + file.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n\n        Config config = buildConfig(xml, null);\n        MapConfig myMapConfig = config.getMapConfig(\"mymap\");\n        assertEquals(\"mymap\", myMapConfig.getName());\n        assertEquals(6, myMapConfig.getBackupCount());\n        assertEquals(10, myMapConfig.getTimeToLiveSeconds());\n        MapStoreConfig myMapStoreConfig = myMapConfig.getMapStoreConfig();\n        assertEquals(10, myMapStoreConfig.getWriteDelaySeconds());\n        assertEquals(100, myMapStoreConfig.getWriteBatchSize());\n        assertEquals(\"com.hazelcast.examples.MyMapStore\", myMapStoreConfig.getClassName());\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateMemberAttributesConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <member-attributes>\\n\" +\n                \"        <attribute name=\\\"attribute.float\\\" type=\\\"float\\\">1234.5678<\/attribute>\\n\" +\n                \"    <\/member-attributes>\\n\" +\n                \"    <member-attributes>\\n\" +\n                \"        <attribute name=\\\"attribute.float\\\" type=\\\"float\\\">1234.5678<\/attribute>\\n\" +\n                \"    <\/member-attributes>\\n\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92022,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateMemberAttributesConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <member-attributes>\\n\" +\n                \"        <attribute name=\\\"attribute.float\\\" type=\\\"float\\\">1234.5678<\/attribute>\\n\" +\n                \"    <\/member-attributes>\\n\" +\n                \"    <member-attributes>\\n\" +\n                \"        <attribute name=\\\"attribute.float\\\" type=\\\"float\\\">1234.5678<\/attribute>\\n\" +\n                \"    <\/member-attributes>\\n\" +\n                \"<\/hazelcast>\";\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testImportGroupConfigFromClassPath() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"classpath:test-hazelcast.xml\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        Config config = configBuilder.build();\n        GroupConfig groupConfig = config.getGroupConfig();\n        assertEquals(\"foobar\", groupConfig.getName());\n        assertEquals(\"dev-pass\", groupConfig.getPassword());\n    }","id":92023,"modified_method":"@Test\n    public void testImportGroupConfigFromClassPath() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"classpath:test-hazelcast.xml\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n\n        Config config = buildConfig(xml, null);\n        GroupConfig groupConfig = config.getGroupConfig();\n        assertEquals(\"foobar\", groupConfig.getName());\n        assertEquals(\"dev-pass\", groupConfig.getPassword());\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateSecurityConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"   <security>       \" +\n                \"   <\/security>\" +\n                \"   <security>   \" +\n                \"   <\/security>\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92024,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateSecurityConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"   <security>       \" +\n                \"   <\/security>\" +\n                \"   <security>   \" +\n                \"   <\/security>\" +\n                \"<\/hazelcast>\";\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testImportNetworkConfigFromFile() throws Exception {\n        File file = createConfigFile(\"foo\", \"bar\");\n        FileOutputStream os = new FileOutputStream(file);\n        String networkConfig = \"<hazelcast>\" +\n                \"    <network>\\n\" +\n                \"        <join>\\n\" +\n                \"            <multicast enabled=\\\"false\\\"/>\\n\" +\n                \"            <tcp-ip enabled=\\\"true\\\"/>\\n\" +\n                \"        <\/join>\\n\" +\n                \"    <\/network>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os, networkConfig);\n\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"file://\" + file.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        Config config = configBuilder.build();\n        JoinConfig join = config.getNetworkConfig().getJoin();\n        assertFalse(join.getMulticastConfig().isEnabled());\n        assertTrue(join.getTcpIpConfig().isEnabled());\n    }","id":92025,"modified_method":"@Test\n    public void testImportNetworkConfigFromFile() throws Exception {\n        File file = createConfigFile(\"foo\", \"bar\");\n        FileOutputStream os = new FileOutputStream(file);\n        String networkConfig = \"<hazelcast>\" +\n                \"    <network>\\n\" +\n                \"        <join>\\n\" +\n                \"            <multicast enabled=\\\"false\\\"/>\\n\" +\n                \"            <tcp-ip enabled=\\\"true\\\"/>\\n\" +\n                \"        <\/join>\\n\" +\n                \"    <\/network>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os, networkConfig);\n\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"file://\" + file.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n\n        Config config = buildConfig(xml, null);\n        JoinConfig join = config.getNetworkConfig().getJoin();\n        assertFalse(join.getMulticastConfig().isEnabled());\n        assertTrue(join.getTcpIpConfig().isEnabled());\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicatePartitionGroupConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"   <partition-group>\\n\" +\n                \"      <member-group>\\n\" +\n                \"          <interface>foo<\/interface>\\n\" +\n                \"      <\/member-group>\\n\" +\n                \"   <\/partition-group>\\n\" +\n                \"   <partition-group>\\n\" +\n                \"      <member-group>\\n\" +\n                \"          <interface>bar<\/interface>\\n\" +\n                \"      <\/member-group>\\n\" +\n                \"   <\/partition-group>\\n\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92026,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicatePartitionGroupConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"   <partition-group>\\n\" +\n                \"      <member-group>\\n\" +\n                \"          <interface>foo<\/interface>\\n\" +\n                \"      <\/member-group>\\n\" +\n                \"   <\/partition-group>\\n\" +\n                \"   <partition-group>\\n\" +\n                \"      <member-group>\\n\" +\n                \"          <interface>bar<\/interface>\\n\" +\n                \"      <\/member-group>\\n\" +\n                \"   <\/partition-group>\\n\" +\n                \"<\/hazelcast>\";\n\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateLicenseKeyConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <license-key>foo<\/license-key>\" +\n                \"    <license-key>bar<\/license-key>\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92027,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testXmlDeniesDuplicateLicenseKeyConfig() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <license-key>foo<\/license-key>\" +\n                \"    <license-key>bar<\/license-key>\" +\n                \"<\/hazelcast>\";\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testTwoResourceCyclicImportThrowsException() throws Exception {\n        File config1 = createConfigFile(\"hz1\", \"xml\");\n        File config2 = createConfigFile(\"hz2\", \"xml\");\n        FileOutputStream os1 = new FileOutputStream(config1);\n        FileOutputStream os2 = new FileOutputStream(config2);\n        String config1Xml = \"<hazelcast>\" +\n                \"    <import resource=\\\"file://\" + config2.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        String config2Xml = \"<hazelcast>\" +\n                \"    <import resource=\\\"file://\" + config1.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os1, config1Xml);\n        writeStringToStreamAndClose(os2, config2Xml);\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(config1Xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92028,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testTwoResourceCyclicImportThrowsException() throws Exception {\n        File config1 = createConfigFile(\"hz1\", \"xml\");\n        File config2 = createConfigFile(\"hz2\", \"xml\");\n        FileOutputStream os1 = new FileOutputStream(config1);\n        FileOutputStream os2 = new FileOutputStream(config2);\n        String config1Xml = \"<hazelcast>\" +\n                \"    <import resource=\\\"file://\" + config2.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        String config2Xml = \"<hazelcast>\" +\n                \"    <import resource=\\\"file://\" + config1.getAbsolutePath() + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os1, config1Xml);\n        writeStringToStreamAndClose(os2, config2Xml);\n        buildConfig(config1Xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = HazelcastException.class)\n    public void testImportEmptyResourceThrowsException() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n        configBuilder.build();\n    }","id":92029,"modified_method":"@Test(expected = HazelcastException.class)\n    public void testImportEmptyResourceThrowsException() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        buildConfig(xml, null);\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testImportConfigFromResourceVariables() throws IOException {\n        File file = createConfigFile(\"foo\", \"bar\");\n        FileOutputStream os = new FileOutputStream(file);\n        String networkConfig = \"<hazelcast>\" +\n                \"    <network>\\n\" +\n                \"        <join>\\n\" +\n                \"            <multicast enabled=\\\"false\\\"/>\\n\" +\n                \"            <tcp-ip enabled=\\\"true\\\"/>\\n\" +\n                \"        <\/join>\\n\" +\n                \"    <\/network>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os, networkConfig);\n\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"${config.location}\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(xml.getBytes());\n        XmlConfigBuilder configBuilder = new XmlConfigBuilder(bis);\n\n        Properties properties = new Properties();\n        properties.setProperty(\"config.location\", file.getAbsolutePath());\n        configBuilder.setProperties(properties);\n        Config config = configBuilder.build();\n        JoinConfig join = config.getNetworkConfig().getJoin();\n        assertFalse(join.getMulticastConfig().isEnabled());\n        assertTrue(join.getTcpIpConfig().isEnabled());\n    }","id":92030,"modified_method":"@Test\n    public void testImportConfigFromResourceVariables() throws IOException {\n        File file = createConfigFile(\"foo\", \"bar\");\n        FileOutputStream os = new FileOutputStream(file);\n        String networkConfig = \"<hazelcast>\" +\n                \"    <network>\\n\" +\n                \"        <join>\\n\" +\n                \"            <multicast enabled=\\\"false\\\"/>\\n\" +\n                \"            <tcp-ip enabled=\\\"true\\\"/>\\n\" +\n                \"        <\/join>\\n\" +\n                \"    <\/network>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os, networkConfig);\n\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"${config.location}\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        Config config = buildConfig(xml, \"config.location\", file.getAbsolutePath());\n        JoinConfig join = config.getNetworkConfig().getJoin();\n        assertFalse(join.getMulticastConfig().isEnabled());\n        assertTrue(join.getTcpIpConfig().isEnabled());\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void replaceVariables(Node node) {\n        String value = node.getNodeValue();\n        StringBuilder sb = new StringBuilder();\n        int endIndex = -1;\n        int startIndex = value.indexOf(\"${\");\n        while (startIndex > -1) {\n            endIndex = value.indexOf('}', startIndex);\n            if (endIndex == -1) {\n                LOGGER.warning(\"Bad variable syntax. Could not find a closing curly bracket '}' on node: \"\n                        + node.getLocalName());\n                break;\n            }\n            String variable = value.substring(startIndex + 2, endIndex);\n            String variableReplacement = xmlConfigBuilder.getProperties().getProperty(variable);\n            if (variableReplacement != null) {\n                sb.append(variableReplacement);\n            } else {\n                sb.append(value.substring(startIndex, endIndex + 1));\n                LOGGER.warning(\"Could not find a value for property  '\" + variable + \"' on node: \"\n                        + node.getLocalName());\n            }\n            startIndex = value.indexOf(\"${\", endIndex);\n        }\n        sb.append(value.substring(endIndex + 1));\n        node.setNodeValue(sb.toString());\n    }","id":92031,"modified_method":"private void replaceVariables(Node node) {\n        String value = node.getNodeValue();\n        StringBuilder sb = new StringBuilder(value);\n        int endIndex = -1;\n        int startIndex = sb.indexOf(\"${\");\n        while (startIndex > -1) {\n            endIndex = sb.indexOf(\"}\", startIndex);\n            if (endIndex == -1) {\n                LOGGER.warning(\"Bad variable syntax. Could not find a closing curly bracket '}' on node: \"\n                        + node.getLocalName());\n                break;\n            }\n            String variable = sb.substring(startIndex + 2, endIndex);\n            String variableReplacement = xmlConfigBuilder.getProperties().getProperty(variable);\n            if (variableReplacement != null) {\n                sb.replace(startIndex, endIndex + 1, variableReplacement);\n                endIndex = startIndex + variableReplacement.length();\n            } else {\n                LOGGER.warning(\"Could not find a value for property  '\" + variable + \"' on node: \"\n                        + node.getLocalName());\n            }\n            startIndex = sb.indexOf(\"${\", endIndex);\n        }\n        node.setNodeValue(sb.toString());\n    }","commit_id":"9502e75ad3b0a8a57adff781bab5d1e85294142b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testImportConfigFromResourceVariables() throws IOException {\n        File file = createConfigFile(\"foo\", \"bar\");\n        FileOutputStream os = new FileOutputStream(file);\n        String networkConfig = \"<hazelcast>\" +\n                \"    <network>\\n\" +\n                \"        <join>\\n\" +\n                \"            <multicast enabled=\\\"false\\\"/>\\n\" +\n                \"            <tcp-ip enabled=\\\"true\\\"/>\\n\" +\n                \"        <\/join>\\n\" +\n                \"    <\/network>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os, networkConfig);\n\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"${config.location}\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n\n        Properties properties = new Properties();\n        properties.setProperty(\"config.location\", file.getAbsolutePath());\n        Config config = buildConfig(xml, properties);\n        JoinConfig join = config.getNetworkConfig().getJoin();\n        assertFalse(join.getMulticastConfig().isEnabled());\n        assertTrue(join.getTcpIpConfig().isEnabled());\n    }","id":92032,"modified_method":"@Test\n    public void testImportConfigFromResourceVariables() throws IOException {\n        File file = createConfigFile(\"foo\", \"bar\");\n        FileOutputStream os = new FileOutputStream(file);\n        String networkConfig = \"<hazelcast>\" +\n                \"    <network>\\n\" +\n                \"        <join>\\n\" +\n                \"            <multicast enabled=\\\"false\\\"/>\\n\" +\n                \"            <tcp-ip enabled=\\\"true\\\"/>\\n\" +\n                \"        <\/join>\\n\" +\n                \"    <\/network>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os, networkConfig);\n\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"${config.location}\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        Config config = buildConfig(xml, \"config.location\", file.getAbsolutePath());\n        JoinConfig join = config.getNetworkConfig().getJoin();\n        assertFalse(join.getMulticastConfig().isEnabled());\n        assertTrue(join.getTcpIpConfig().isEnabled());\n    }","commit_id":"b62b679699df46bf3aee009c42b189cf6c9ddd23","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testXmlVariableReplacementAsSubstring() throws Exception {\n        Properties properties = new Properties();\n        String xml = \"<hazelcast>\\n\" +\n                \"    <properties>\\n\" +\n                \"        <property name=\\\"${env}-with-suffix\\\">local-with-suffix<\/property>\\n\" +\n                \"        <property name=\\\"with-prefix-${env}\\\">with-prefix-local<\/property>\\n\" +\n                \"    <\/properties>\\n\" +\n                \"<\/hazelcast>\";\n\n        properties.setProperty(\"env\", \"local\");\n        Config config = buildConfig(xml, properties);\n        assertEquals(config.getProperty(\"local-with-suffix\"), \"local-with-suffix\");\n        assertEquals(config.getProperty(\"with-prefix-local\"), \"with-prefix-local\");\n    }","id":92033,"modified_method":"@Test\n    public void testXmlVariableReplacementAsSubstring() throws Exception {\n        String xml = \"<hazelcast>\\n\" +\n                \"    <properties>\\n\" +\n                \"        <property name=\\\"${env}-with-suffix\\\">local-with-suffix<\/property>\\n\" +\n                \"        <property name=\\\"with-prefix-${env}\\\">with-prefix-local<\/property>\\n\" +\n                \"    <\/properties>\\n\" +\n                \"<\/hazelcast>\";\n\n        Config config = buildConfig(xml, \"env\", \"local\");\n        assertEquals(config.getProperty(\"local-with-suffix\"), \"local-with-suffix\");\n        assertEquals(config.getProperty(\"with-prefix-local\"), \"with-prefix-local\");\n    }","commit_id":"b62b679699df46bf3aee009c42b189cf6c9ddd23","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testXmlImportWithVariableReplacementAsSubstring() throws Exception {\n        Properties properties = new Properties();\n        File file = createConfigFile(\"foo\", \"bar\");\n        FileOutputStream os = new FileOutputStream(file);\n        String networkConfig = \"<hazelcast>\" +\n                \"    <properties>\\n\" +\n                \"        <property name=\\\"prop1\\\">value1<\/property>\\n\" +\n                \"        <property name=\\\"prop2\\\">value2<\/property>\\n\" +\n                \"    <\/properties>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os, networkConfig);\n\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"file://\" + \"${file}\" + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        properties.setProperty(\"file\", file.getAbsolutePath());\n        Config config = buildConfig(xml, properties);\n        assertEquals(config.getProperty(\"prop1\"), \"value1\");\n        assertEquals(config.getProperty(\"prop2\"), \"value2\");\n    }","id":92034,"modified_method":"@Test\n    public void testXmlImportWithVariableReplacementAsSubstring() throws Exception {\n        File file = createConfigFile(\"foo\", \"bar\");\n        FileOutputStream os = new FileOutputStream(file);\n        String networkConfig = \"<hazelcast>\" +\n                \"    <properties>\\n\" +\n                \"        <property name=\\\"prop1\\\">value1<\/property>\\n\" +\n                \"        <property name=\\\"prop2\\\">value2<\/property>\\n\" +\n                \"    <\/properties>\\n\" +\n                \"<\/hazelcast>\";\n        writeStringToStreamAndClose(os, networkConfig);\n\n        String xml = \"<hazelcast>\\n\" +\n                \"    <import resource=\\\"file://\" + \"${file}\" + \"\\\"/>\\n\" +\n                \"<\/hazelcast>\";\n        Config config = buildConfig(xml, \"file\", file.getAbsolutePath());\n        assertEquals(config.getProperty(\"prop1\"), \"value1\");\n        assertEquals(config.getProperty(\"prop2\"), \"value2\");\n    }","commit_id":"b62b679699df46bf3aee009c42b189cf6c9ddd23","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            int actualYear = Calendar.getInstance().get( Calendar.YEAR );\n            String year = String.valueOf( actualYear );\n\n            Model model = getProject().getModel();\n            if ( model.getInceptionYear() != null )\n            {\n                if ( StringUtils.isNumeric( model.getInceptionYear() ) )\n                {\n                    if ( Integer.valueOf( model.getInceptionYear() ).intValue() != actualYear )\n                    {\n                        year = model.getInceptionYear() + \"-\" + String.valueOf( actualYear );\n                    }\n                }\n                else\n                {\n                    getLog().warn( \"The inception year is not a valid year.\" );\n                }\n            }\n\n            StringBuffer classpath = new StringBuffer();\n            for ( Iterator i = getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\n            {\n                classpath.append( (String) i.next() );\n\n                if ( i.hasNext() )\n                {\n                    classpath.append( PATH_SEPARATOR );\n                }\n            }\n            if ( classpath.length() > 0 )\n            {\n                classpath.insert( 0, \"-classpath \" );\n            }\n\n            StringBuffer sourcePath = new StringBuffer();\n            StringBuffer files = new StringBuffer();\n            for ( Iterator i = getProject().getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String sourceDirectory = (String) i.next();\n                String[] fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[]{\"java\"} );\n                if ( fileList != null && fileList.length != 0 )\n                {\n                    for ( int j = 0; j < fileList.length; j++ )\n                    {\n                        files.append( fileList[j] );\n                        files.append( \"\\n\" );\n                    }\n                }\n\n                sourcePath.append( sourceDirectory );\n\n                if ( i.hasNext() )\n                {\n                    sourcePath.append( PATH_SEPARATOR );\n                }\n            }\n\n            if ( files.length() == 0 )\n            {\n                return;\n            }\n\n            File javadocDirectory = getReportOutputDirectory();\n\n            if ( !javadocDirectory.equals( getOutputDirectory() ) )\n            {\n                // we're in site-embedded report mode, so Doxia has set the\n                // reportOutputDirectory to the basedir of the site.\n                // Append 'apidocs'.\n                javadocDirectory = new File( javadocDirectory, \"apidocs\" );\n            }\n            javadocDirectory.mkdirs();\n\n            File file = new File( javadocDirectory, \"files\" );\n            file.deleteOnExit();\n            FileUtils.fileWrite( file.getAbsolutePath(), files.toString() );\n\n            // Copy default style sheet\n            copyDefaultStylesheet( javadocDirectory );\n\n            Commandline cmd = new Commandline();\n\n            List arguments = new ArrayList();\n\n            cmd.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\n            cmd.setExecutable( getJavadocPath() );\n\n            // General javadoc arguments\n            addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n            if ( !StringUtils.isEmpty( doclet ) )\n            {\n                addArgIfNotEmpty( arguments, \"-doclet\", doclet );\n                addArgIfNotEmpty( arguments, \"-docletPath\", docletPath );\n            }\n            addArgIfNotEmpty( arguments, \"-encoding\", encoding );\n            addArgIfNotEmpty( arguments, \"-extdirs\", extdirs );\n            addArgIfNotEmpty( arguments, \"-exclude\", excludePackageNames, 1.4f );\n            addArgIfNotEmpty( arguments, \"-locale\", this.locale );\n            if ( !StringUtils.isEmpty( maxmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( maxmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xmx\" + maxmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( maxmemory.substring( 0, maxmemory.length() - 1 ) ) ) &&\n                        ( maxmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xmx\" + maxmemory );\n                    }\n                    else\n                    {\n                        getLog().error(\n                            \"The maxmemory '\" + maxmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( !StringUtils.isEmpty( minmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( minmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xms\" + minmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( minmemory.substring( 0, minmemory.length() - 1 ) ) ) &&\n                        ( minmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xms\" + minmemory );\n                    }\n                    else\n                    {\n                        getLog().error(\n                            \"The minmemory '\" + minmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( old && SystemUtils.isJavaVersionAtLeast( 1.4f ) )\n            {\n                getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n            }\n            else\n            {\n                addArgIf( arguments, old, \"-1.1\" );\n            }\n\n            addArgIfNotEmpty( arguments, \"-overview\", overview );\n            addArgIf( arguments, showPackage, \"-package\" );\n            addArgIf( arguments, showPrivate, \"-private\" );\n            addArgIf( arguments, showProtected, \"-protected\" );\n            addArgIf( arguments, public_, \"-public\" );\n            addArgIf( arguments, quiet, \"-quiet\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-source\", source, 1.4f );\n            addArgIf( arguments, verbose, \"-verbose\" );\n            addArgIfNotEmpty( arguments, \"-additionalparam\", additionalparam );\n\n            addArgIfNotEmpty( arguments, \"-sourcePath\", sourcePath.toString() );\n            if ( classpath.length() > 0 )\n            {\n                file = new File( javadocDirectory, \"classpath\" );\n                file.deleteOnExit();\n                FileUtils.fileWrite( file.getAbsolutePath(), classpath.toString() );\n                cmd.createArgument().setValue( \"@classpath\" );\n            }\n\n            // javadoc arguments for default doclet\n            if ( StringUtils.isEmpty( doclet ) )\n            {\n                bottom = StringUtils.replace( bottom, \"{currentYear}\", year );\n                if ( project.getInceptionYear() != null )\n                {\n                    bottom = StringUtils.replace( bottom, \"{inceptionYear}\", project.getInceptionYear() );\n                }\n                else\n                {\n                    bottom = StringUtils.replace( bottom, \"{inceptionYear}-\", \"\" );\n                }\n\n                if ( StringUtils.isEmpty( stylesheetfile ) )\n                {\n                    stylesheetfile = javadocDirectory + File.separator + DEFAULT_CSS_NAME;\n                }\n                // End Specify default values\n\n                addArgIf( arguments, author, \"-author\" );\n                addArgIfNotEmpty( arguments, \"-bottom\", bottom );\n                addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-charset\", charset );\n                addArgIfNotEmpty( arguments, \"-d\", javadocDirectory.toString() );\n                addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-docencoding\", docencoding );\n                addArgIfNotEmpty( arguments, \"-doctitle\", doctitle );\n                addArgIfNotEmpty( arguments, \"-excludePackageNames\", excludePackageNames );\n                addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", excludedocfilessubdir, 1.4f );\n                addArgIfNotEmpty( arguments, \"-footer\", footer );\n                addArgIfNotEmpty( arguments, \"-group\", group, true );\n                addArgIfNotEmpty( arguments, \"-header\", header );\n                addArgIfNotEmpty( arguments, \"-helpfile\", helpfile );\n                addArgIfNotEmpty( arguments, \"-link\", link, true );\n                addArgIfNotEmpty( arguments, \"-linkoffline\", linkoffline, true );\n                addArgIf( arguments, linksource, \"-linksource\", 1.4f );\n                addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n                addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n                addArgIf( arguments, nocomment, \"-nocomment\", 1.4f );\n                addArgIf( arguments, nohelp, \"-nohelp\" );\n                addArgIf( arguments, noindex, \"-noindex\" );\n                addArgIf( arguments, nonavbar, \"-nonavbar\" );\n                addArgIfNotEmpty( arguments, \"-noqualifier\", noqualifier, 1.4f );\n                addArgIf( arguments, nosince, \"-nosince\" );\n                addArgIf( arguments, notree, \"-notree\" );\n                addArgIf( arguments, serialwarn, \"-serialwarn\" );\n                addArgIf( arguments, splitindex, \"-splitindex\" );\n                addArgIfNotEmpty( arguments, \"-stylesheetfile\", stylesheetfile );\n                addArgIfNotEmpty( arguments, \"-tag\", tag, 1.4f, true );\n                addArgIfNotEmpty( arguments, \"-taglet\", taglet, 1.4f );\n                addArgIfNotEmpty( arguments, \"-tagletpath\", tagletpath, 1.4f );\n                addArgIf( arguments, use, \"-use\" );\n                addArgIf( arguments, version, \"-version\" );\n                addArgIfNotEmpty( arguments, \"-windowtitle\", windowtitle );\n            }\n\n            for ( Iterator it = arguments.iterator(); it.hasNext(); )\n            {\n                String current = (String) it.next();\n                cmd.createArgument().setValue( current );\n            }\n\n            cmd.createArgument().setValue( \"@files\" );\n\n            getLog().info( Commandline.toString( cmd.getCommandline() ) );\n\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), new DefaultConsumer() );\n\n            if ( exitCode != 0 )\n            {\n                throw new MavenReportException( \"Exit code: \" + exitCode );\n            }\n        }\n        catch ( Exception e )\n        {\n            getLog().debug( e );\n            throw new MavenReportException( \"An error has occurred in javadoc report generation.\", e );\n        }\n    }","id":92035,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            int actualYear = Calendar.getInstance().get( Calendar.YEAR );\n            String year = String.valueOf( actualYear );\n\n            Model model = getProject().getModel();\n            if ( model.getInceptionYear() != null )\n            {\n                if ( StringUtils.isNumeric( model.getInceptionYear() ) )\n                {\n                    if ( Integer.valueOf( model.getInceptionYear() ).intValue() != actualYear )\n                    {\n                        year = model.getInceptionYear() + \"-\" + String.valueOf( actualYear );\n                    }\n                }\n                else\n                {\n                    getLog().warn( \"The inception year is not a valid year.\" );\n                }\n            }\n\n            StringBuffer options = new StringBuffer();\n            StringBuffer classpath = new StringBuffer();\n            for ( Iterator i = getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\n            {\n                classpath.append( (String) i.next() );\n\n                if ( i.hasNext() )\n                {\n                    classpath.append( PATH_SEPARATOR );\n                }\n            }\n\n            if ( classpath.length() > 0 )\n            {\n                options.append( \"-classpath \" );\n                options.append( quotedPathArgument( classpath.toString() ) );\n            }\n\n            StringBuffer sourcePath = new StringBuffer();\n            StringBuffer files = new StringBuffer();\n            for ( Iterator i = getProject().getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String sourceDirectory = (String) i.next();\n                String[] fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[]{\"java\"} );\n                if ( fileList != null && fileList.length != 0 )\n                {\n                    for ( int j = 0; j < fileList.length; j++ )\n                    {\n                        files.append( quotedPathArgument( fileList[j] ) );\n                        files.append( \"\\n\" );\n                    }\n                }\n\n                sourcePath.append( sourceDirectory );\n\n                if ( i.hasNext() )\n                {\n                    sourcePath.append( PATH_SEPARATOR );\n                }\n            }\n\n            if ( files.length() == 0 )\n            {\n                return;\n            }\n\n            File javadocDirectory = getReportOutputDirectory();\n\n            if ( !javadocDirectory.equals( getOutputDirectory() ) )\n            {\n                // we're in site-embedded report mode, so Doxia has set the\n                // reportOutputDirectory to the basedir of the site.\n                // Append 'apidocs'.\n                javadocDirectory = new File( javadocDirectory, \"apidocs\" );\n            }\n            javadocDirectory.mkdirs();\n\n            File file = new File( javadocDirectory, \"files\" );\n            file.deleteOnExit();\n            FileUtils.fileWrite( file.getAbsolutePath(), files.toString() );\n\n            // Copy default style sheet\n            copyDefaultStylesheet( javadocDirectory );\n\n            Commandline cmd = new Commandline();\n\n            List arguments = new ArrayList();\n\n            cmd.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\n            cmd.setExecutable( getJavadocPath() );\n\n            // General javadoc arguments\n            addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n            if ( !StringUtils.isEmpty( doclet ) )\n            {\n                addArgIfNotEmpty( arguments, \"-doclet\", quotedArgument( doclet ) );\n                addArgIfNotEmpty( arguments, \"-docletPath\", quotedPathArgument( docletPath ) );\n            }\n            addArgIfNotEmpty( arguments, \"-encoding\", quotedArgument( encoding ) );\n            addArgIfNotEmpty( arguments, \"-extdirs\", quotedPathArgument( extdirs ) );\n            addArgIfNotEmpty( arguments, \"-exclude\", quotedArgument( excludePackageNames ), 1.4f );\n            addArgIfNotEmpty( arguments, \"-locale\", quotedArgument( this.locale ) );\n            if ( !StringUtils.isEmpty( maxmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( maxmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xmx\" + maxmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( maxmemory.substring( 0, maxmemory.length() - 1 ) ) ) &&\n                        ( maxmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xmx\" + maxmemory );\n                    }\n                    else\n                    {\n                        getLog().error(\n                            \"The maxmemory '\" + maxmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( !StringUtils.isEmpty( minmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( minmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xms\" + minmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( minmemory.substring( 0, minmemory.length() - 1 ) ) ) &&\n                        ( minmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xms\" + minmemory );\n                    }\n                    else\n                    {\n                        getLog().error(\n                            \"The minmemory '\" + minmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( old && SystemUtils.isJavaVersionAtLeast( 1.4f ) )\n            {\n                getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n            }\n            else\n            {\n                addArgIf( arguments, old, \"-1.1\" );\n            }\n\n            addArgIfNotEmpty( arguments, \"-overview\", quotedArgument( overview ) );\n            addArgIf( arguments, showPackage, \"-package\" );\n            addArgIf( arguments, showPrivate, \"-private\" );\n            addArgIf( arguments, showProtected, \"-protected\" );\n            addArgIf( arguments, public_, \"-public\" );\n            addArgIf( arguments, quiet, \"-quiet\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-source\", quotedArgument( source ), 1.4f );\n            addArgIf( arguments, verbose, \"-verbose\" );\n            addArgIfNotEmpty( arguments, \"-additionalparam\", quotedArgument( additionalparam ) );\n\n            addArgIfNotEmpty( arguments, \"-sourcePath\", quotedPathArgument( sourcePath.toString() ) );\n\n            // javadoc arguments for default doclet\n            if ( StringUtils.isEmpty( doclet ) )\n            {\n                bottom = StringUtils.replace( bottom, \"{currentYear}\", year );\n                if ( project.getInceptionYear() != null )\n                {\n                    bottom = StringUtils.replace( bottom, \"{inceptionYear}\", project.getInceptionYear() );\n                }\n                else\n                {\n                    bottom = StringUtils.replace( bottom, \"{inceptionYear}-\", \"\" );\n                }\n\n                if ( StringUtils.isEmpty( stylesheetfile ) )\n                {\n                    stylesheetfile = javadocDirectory + File.separator + DEFAULT_CSS_NAME;\n                }\n                // End Specify default values\n\n                addArgIf( arguments, author, \"-author\" );\n                addArgIfNotEmpty( arguments, \"-bottom\", quotedArgument( bottom ) );\n                addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-charset\", quotedArgument( charset ) );\n                addArgIfNotEmpty( arguments, \"-d\", quotedPathArgument( javadocDirectory.toString() ) );\n                addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-docencoding\", quotedArgument( docencoding ) );\n                addArgIfNotEmpty( arguments, \"-doctitle\", quotedArgument( doctitle ) );\n                addArgIfNotEmpty( arguments, \"-excludePackageNames\", quotedArgument( excludePackageNames ) );\n                addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", quotedPathArgument( excludedocfilessubdir ),\n                                  1.4f );\n                addArgIfNotEmpty( arguments, \"-footer\", quotedArgument( footer ) );\n                addArgIfNotEmpty( arguments, \"-group\", quotedArgument( group ), true );\n                addArgIfNotEmpty( arguments, \"-header\", quotedArgument( header ) );\n                addArgIfNotEmpty( arguments, \"-helpfile\", quotedPathArgument( helpfile ) );\n                addArgIfNotEmpty( arguments, \"-link\", quotedPathArgument( link ), true );\n                addArgIfNotEmpty( arguments, \"-linkoffline\", quotedPathArgument( linkoffline ), true );\n                addArgIf( arguments, linksource, \"-linksource\", 1.4f );\n                addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n                addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n                addArgIf( arguments, nocomment, \"-nocomment\", 1.4f );\n                addArgIf( arguments, nohelp, \"-nohelp\" );\n                addArgIf( arguments, noindex, \"-noindex\" );\n                addArgIf( arguments, nonavbar, \"-nonavbar\" );\n                addArgIfNotEmpty( arguments, \"-noqualifier\", quotedArgument( noqualifier ), 1.4f );\n                addArgIf( arguments, nosince, \"-nosince\" );\n                addArgIf( arguments, notree, \"-notree\" );\n                addArgIf( arguments, serialwarn, \"-serialwarn\" );\n                addArgIf( arguments, splitindex, \"-splitindex\" );\n                addArgIfNotEmpty( arguments, \"-stylesheetfile\", quotedPathArgument( stylesheetfile ) );\n                addArgIfNotEmpty( arguments, \"-tag\", quotedArgument( tag ), 1.4f, true );\n                addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglet ), 1.4f );\n                addArgIfNotEmpty( arguments, \"-tagletpath\", quotedPathArgument( tagletpath ), 1.4f );\n                addArgIf( arguments, use, \"-use\" );\n                addArgIf( arguments, version, \"-version\" );\n                addArgIfNotEmpty( arguments, \"-windowtitle\", quotedArgument( windowtitle ) );\n            }\n\n            if ( options.length() > 0 )\n            {\n                File optionsFile = new File( javadocDirectory, \"options\" );\n                for ( Iterator it = arguments.iterator(); it.hasNext(); )\n                {\n                    options.append( \" \" );\n                    options.append( (String) it.next() );\n                }\n                FileUtils.fileWrite( optionsFile.getAbsolutePath(), options.toString() );\n                cmd.createArgument().setValue( \"@options\" );\n                optionsFile.deleteOnExit();\n            }\n\n            cmd.createArgument().setValue( \"@files\" );\n\n            getLog().info( Commandline.toString( cmd.getCommandline() ) );\n\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), new DefaultConsumer() );\n\n            if ( exitCode != 0 )\n            {\n                throw new MavenReportException( \"Exit code: \" + exitCode );\n            }\n        }\n        catch ( Exception e )\n        {\n            getLog().debug( e );\n            throw new MavenReportException( \"An error has occurred in javadoc report generation.\", e );\n        }\n    }","commit_id":"7777edb624f6f1824362251220d26dac7833a92c","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            int actualYear = Calendar.getInstance().get( Calendar.YEAR );\n            String year = String.valueOf( actualYear );\n\n            Model model = getProject().getModel();\n            if ( model.getInceptionYear() != null )\n            {\n                if ( StringUtils.isNumeric( model.getInceptionYear() ) )\n                {\n                    if ( Integer.valueOf( model.getInceptionYear() ).intValue() != actualYear )\n                    {\n                        year = model.getInceptionYear() + \"-\" + String.valueOf( actualYear );\n                    }\n                }\n                else\n                {\n                    getLog().warn( \"The inception year is not a valid year.\" );\n                }\n            }\n\n            StringBuffer classpath = new StringBuffer();\n            for ( Iterator i = getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\n            {\n                classpath.append( (String) i.next() );\n\n                if ( i.hasNext() )\n                {\n                    classpath.append( PATH_SEPARATOR );\n                }\n            }\n            if ( classpath.length() > 0 )\n            {\n                classpath.insert( 0, \"-classpath \" );\n            }\n\n            StringBuffer sourcePath = new StringBuffer();\n            StringBuffer files = new StringBuffer();\n            for ( Iterator i = getProject().getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String sourceDirectory = (String) i.next();\n                String[] fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[]{\"java\"} );\n                if ( fileList != null && fileList.length != 0 )\n                {\n                    for ( int j = 0; j < fileList.length; j++ )\n                    {\n                        files.append( fileList[j] );\n                        files.append( \"\\n\" );\n                    }\n                }\n\n                sourcePath.append( sourceDirectory );\n\n                if ( i.hasNext() )\n                {\n                    sourcePath.append( PATH_SEPARATOR );\n                }\n            }\n\n            if ( files.length() == 0 )\n            {\n                return;\n            }\n\n            File javadocDirectory = getReportOutputDirectory();\n\n            if ( !javadocDirectory.equals( getOutputDirectory() ) )\n            {\n                // we're in site-embedded report mode, so Doxia has set the\n                // reportOutputDirectory to the basedir of the site.\n                // Append 'apidocs'.\n                javadocDirectory = new File( javadocDirectory, \"apidocs\" );\n            }\n            javadocDirectory.mkdirs();\n\n            File file = new File( javadocDirectory, \"files\" );\n            file.deleteOnExit();\n            FileUtils.fileWrite( file.getAbsolutePath(), files.toString() );\n\n            // Copy default style sheet\n            copyDefaultStylesheet( javadocDirectory );\n\n            Commandline cmd = new Commandline();\n\n            List arguments = new ArrayList();\n\n            cmd.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\n            cmd.setExecutable( getJavadocPath() );\n\n            // General javadoc arguments\n            addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n            if ( !StringUtils.isEmpty( doclet ) )\n            {\n                addArgIfNotEmpty( arguments, \"-doclet\", doclet );\n                addArgIfNotEmpty( arguments, \"-docletPath\", docletPath );\n            }\n            addArgIfNotEmpty( arguments, \"-encoding\", encoding );\n            addArgIfNotEmpty( arguments, \"-extdirs\", extdirs );\n            addArgIfNotEmpty( arguments, \"-exclude\", excludePackageNames, 1.4f );\n            addArgIfNotEmpty( arguments, \"-locale\", this.locale );\n            if ( !StringUtils.isEmpty( maxmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( maxmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xmx\" + maxmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( maxmemory.substring( 0, maxmemory.length() - 1 ) ) ) &&\n                        ( maxmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xmx\" + maxmemory );\n                    }\n                    else\n                    {\n                        getLog().error(\n                            \"The maxmemory '\" + maxmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( !StringUtils.isEmpty( minmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( minmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xms\" + minmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( minmemory.substring( 0, minmemory.length() - 1 ) ) ) &&\n                        ( minmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xms\" + minmemory );\n                    }\n                    else\n                    {\n                        getLog().error(\n                            \"The minmemory '\" + minmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( old && SystemUtils.isJavaVersionAtLeast( 1.4f ) )\n            {\n                getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n            }\n            else\n            {\n                addArgIf( arguments, old, \"-1.1\" );\n            }\n\n            addArgIfNotEmpty( arguments, \"-overview\", overview );\n            addArgIf( arguments, showPackage, \"-package\" );\n            addArgIf( arguments, showPrivate, \"-private\" );\n            addArgIf( arguments, showProtected, \"-protected\" );\n            addArgIf( arguments, public_, \"-public\" );\n            addArgIf( arguments, quiet, \"-quiet\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-source\", source, 1.4f );\n            addArgIf( arguments, verbose, \"-verbose\" );\n            addArgIfNotEmpty( arguments, \"-additionalparam\", additionalparam );\n\n            addArgIfNotEmpty( arguments, \"-sourcePath\", sourcePath.toString() );\n            if ( classpath.length() > 0 )\n            {\n                file = new File( javadocDirectory, \"classpath\" );\n                file.deleteOnExit();\n                FileUtils.fileWrite( file.getAbsolutePath(), classpath.toString() );\n                cmd.createArgument().setValue( \"@classpath\" );\n            }\n\n            // javadoc arguments for default doclet\n            if ( StringUtils.isEmpty( doclet ) )\n            {\n                bottom = StringUtils.replace( bottom, \"{currentYear}\", year );\n                if ( project.getInceptionYear() != null )\n                {\n                    bottom = StringUtils.replace( bottom, \"{inceptionYear}\", project.getInceptionYear() );\n                }\n                else\n                {\n                    bottom = StringUtils.replace( bottom, \"{inceptionYear}-\", \"\" );\n                }\n\n                if ( StringUtils.isEmpty( stylesheetfile ) )\n                {\n                    stylesheetfile = javadocDirectory + File.separator + DEFAULT_CSS_NAME;\n                }\n                // End Specify default values\n\n                addArgIf( arguments, author, \"-author\" );\n                addArgIfNotEmpty( arguments, \"-bottom\", bottom );\n                addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-charset\", charset );\n                addArgIfNotEmpty( arguments, \"-d\", javadocDirectory.toString() );\n                addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-docencoding\", docencoding );\n                addArgIfNotEmpty( arguments, \"-doctitle\", doctitle );\n                addArgIfNotEmpty( arguments, \"-excludePackageNames\", excludePackageNames );\n                addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", excludedocfilessubdir, 1.4f );\n                addArgIfNotEmpty( arguments, \"-footer\", footer );\n                addArgIfNotEmpty( arguments, \"-group\", group, true );\n                addArgIfNotEmpty( arguments, \"-header\", header );\n                addArgIfNotEmpty( arguments, \"-helpfile\", helpfile );\n                addArgIfNotEmpty( arguments, \"-link\", link, true );\n                addArgIfNotEmpty( arguments, \"-linkoffline\", linkoffline, true );\n                addArgIf( arguments, linksource, \"-linksource\", 1.4f );\n                addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n                addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n                addArgIf( arguments, nocomment, \"-nocomment\", 1.4f );\n                addArgIf( arguments, nohelp, \"-nohelp\" );\n                addArgIf( arguments, noindex, \"-noindex\" );\n                addArgIf( arguments, nonavbar, \"-nonavbar\" );\n                addArgIfNotEmpty( arguments, \"-noqualifier\", noqualifier, 1.4f );\n                addArgIf( arguments, nosince, \"-nosince\" );\n                addArgIf( arguments, notree, \"-notree\" );\n                addArgIf( arguments, serialwarn, \"-serialwarn\" );\n                addArgIf( arguments, splitindex, \"-splitindex\" );\n                addArgIfNotEmpty( arguments, \"-stylesheetfile\", stylesheetfile );\n                addArgIfNotEmpty( arguments, \"-tag\", tag, 1.4f, true );\n                addArgIfNotEmpty( arguments, \"-taglet\", taglet, 1.4f );\n                addArgIfNotEmpty( arguments, \"-tagletpath\", tagletpath, 1.4f );\n                addArgIf( arguments, use, \"-use\" );\n                addArgIf( arguments, version, \"-version\" );\n                addArgIfNotEmpty( arguments, \"-windowtitle\", windowtitle );\n            }\n\n            for ( Iterator it = arguments.iterator(); it.hasNext(); )\n            {\n                String current = (String) it.next();\n                cmd.createArgument().setValue( current );\n            }\n\n            cmd.createArgument().setValue( \"@files\" );\n\n            getLog().info( Commandline.toString( cmd.getCommandline() ) );\n\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), new DefaultConsumer() );\n\n            if ( exitCode != 0 )\n            {\n                throw new MavenReportException( \"Exit code: \" + exitCode );\n            }\n        }\n        catch ( Exception e )\n        {\n            getLog().debug( e );\n            throw new MavenReportException( \"An error has occurred in javadoc report generation.\", e );\n        }\n    }","id":92036,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            int actualYear = Calendar.getInstance().get( Calendar.YEAR );\n            String year = String.valueOf( actualYear );\n\n            Model model = getProject().getModel();\n            if ( model.getInceptionYear() != null )\n            {\n                if ( StringUtils.isNumeric( model.getInceptionYear() ) )\n                {\n                    if ( Integer.valueOf( model.getInceptionYear() ).intValue() != actualYear )\n                    {\n                        year = model.getInceptionYear() + \"-\" + String.valueOf( actualYear );\n                    }\n                }\n                else\n                {\n                    getLog().warn( \"The inception year is not a valid year.\" );\n                }\n            }\n\n            StringBuffer options = new StringBuffer();\n            StringBuffer classpath = new StringBuffer();\n            for ( Iterator i = getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\n            {\n                classpath.append( (String) i.next() );\n\n                if ( i.hasNext() )\n                {\n                    classpath.append( PATH_SEPARATOR );\n                }\n            }\n\n            if ( classpath.length() > 0 )\n            {\n                options.append( \"-classpath \" );\n                options.append( quotedPathArgument( classpath.toString() ) );\n            }\n\n            StringBuffer sourcePath = new StringBuffer();\n            StringBuffer files = new StringBuffer();\n            for ( Iterator i = getProject().getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String sourceDirectory = (String) i.next();\n                String[] fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[]{\"java\"} );\n                if ( fileList != null && fileList.length != 0 )\n                {\n                    for ( int j = 0; j < fileList.length; j++ )\n                    {\n                        files.append( quotedPathArgument( fileList[j] ) );\n                        files.append( \"\\n\" );\n                    }\n                }\n\n                sourcePath.append( sourceDirectory );\n\n                if ( i.hasNext() )\n                {\n                    sourcePath.append( PATH_SEPARATOR );\n                }\n            }\n\n            if ( files.length() == 0 )\n            {\n                return;\n            }\n\n            File javadocDirectory = getReportOutputDirectory();\n\n            if ( !javadocDirectory.equals( getOutputDirectory() ) )\n            {\n                // we're in site-embedded report mode, so Doxia has set the\n                // reportOutputDirectory to the basedir of the site.\n                // Append 'apidocs'.\n                javadocDirectory = new File( javadocDirectory, \"apidocs\" );\n            }\n            javadocDirectory.mkdirs();\n\n            File file = new File( javadocDirectory, \"files\" );\n            file.deleteOnExit();\n            FileUtils.fileWrite( file.getAbsolutePath(), files.toString() );\n\n            // Copy default style sheet\n            copyDefaultStylesheet( javadocDirectory );\n\n            Commandline cmd = new Commandline();\n\n            List arguments = new ArrayList();\n\n            cmd.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\n            cmd.setExecutable( getJavadocPath() );\n\n            // General javadoc arguments\n            addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n            if ( !StringUtils.isEmpty( doclet ) )\n            {\n                addArgIfNotEmpty( arguments, \"-doclet\", quotedArgument( doclet ) );\n                addArgIfNotEmpty( arguments, \"-docletPath\", quotedPathArgument( docletPath ) );\n            }\n            addArgIfNotEmpty( arguments, \"-encoding\", quotedArgument( encoding ) );\n            addArgIfNotEmpty( arguments, \"-extdirs\", quotedPathArgument( extdirs ) );\n            addArgIfNotEmpty( arguments, \"-exclude\", quotedArgument( excludePackageNames ), 1.4f );\n            addArgIfNotEmpty( arguments, \"-locale\", quotedArgument( this.locale ) );\n            if ( !StringUtils.isEmpty( maxmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( maxmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xmx\" + maxmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( maxmemory.substring( 0, maxmemory.length() - 1 ) ) ) &&\n                        ( maxmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xmx\" + maxmemory );\n                    }\n                    else\n                    {\n                        getLog().error(\n                            \"The maxmemory '\" + maxmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( !StringUtils.isEmpty( minmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( minmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xms\" + minmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( minmemory.substring( 0, minmemory.length() - 1 ) ) ) &&\n                        ( minmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xms\" + minmemory );\n                    }\n                    else\n                    {\n                        getLog().error(\n                            \"The minmemory '\" + minmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( old && SystemUtils.isJavaVersionAtLeast( 1.4f ) )\n            {\n                getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n            }\n            else\n            {\n                addArgIf( arguments, old, \"-1.1\" );\n            }\n\n            addArgIfNotEmpty( arguments, \"-overview\", quotedArgument( overview ) );\n            addArgIf( arguments, showPackage, \"-package\" );\n            addArgIf( arguments, showPrivate, \"-private\" );\n            addArgIf( arguments, showProtected, \"-protected\" );\n            addArgIf( arguments, public_, \"-public\" );\n            addArgIf( arguments, quiet, \"-quiet\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-source\", quotedArgument( source ), 1.4f );\n            addArgIf( arguments, verbose, \"-verbose\" );\n            addArgIfNotEmpty( arguments, \"-additionalparam\", quotedArgument( additionalparam ) );\n\n            addArgIfNotEmpty( arguments, \"-sourcePath\", quotedPathArgument( sourcePath.toString() ) );\n\n            // javadoc arguments for default doclet\n            if ( StringUtils.isEmpty( doclet ) )\n            {\n                bottom = StringUtils.replace( bottom, \"{currentYear}\", year );\n                if ( project.getInceptionYear() != null )\n                {\n                    bottom = StringUtils.replace( bottom, \"{inceptionYear}\", project.getInceptionYear() );\n                }\n                else\n                {\n                    bottom = StringUtils.replace( bottom, \"{inceptionYear}-\", \"\" );\n                }\n\n                if ( StringUtils.isEmpty( stylesheetfile ) )\n                {\n                    stylesheetfile = javadocDirectory + File.separator + DEFAULT_CSS_NAME;\n                }\n                // End Specify default values\n\n                addArgIf( arguments, author, \"-author\" );\n                addArgIfNotEmpty( arguments, \"-bottom\", quotedArgument( bottom ) );\n                addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-charset\", quotedArgument( charset ) );\n                addArgIfNotEmpty( arguments, \"-d\", quotedPathArgument( javadocDirectory.toString() ) );\n                addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-docencoding\", quotedArgument( docencoding ) );\n                addArgIfNotEmpty( arguments, \"-doctitle\", quotedArgument( doctitle ) );\n                addArgIfNotEmpty( arguments, \"-excludePackageNames\", quotedArgument( excludePackageNames ) );\n                addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", quotedPathArgument( excludedocfilessubdir ),\n                                  1.4f );\n                addArgIfNotEmpty( arguments, \"-footer\", quotedArgument( footer ) );\n                addArgIfNotEmpty( arguments, \"-group\", quotedArgument( group ), true );\n                addArgIfNotEmpty( arguments, \"-header\", quotedArgument( header ) );\n                addArgIfNotEmpty( arguments, \"-helpfile\", quotedPathArgument( helpfile ) );\n                addArgIfNotEmpty( arguments, \"-link\", quotedPathArgument( link ), true );\n                addArgIfNotEmpty( arguments, \"-linkoffline\", quotedPathArgument( linkoffline ), true );\n                addArgIf( arguments, linksource, \"-linksource\", 1.4f );\n                addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n                addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n                addArgIf( arguments, nocomment, \"-nocomment\", 1.4f );\n                addArgIf( arguments, nohelp, \"-nohelp\" );\n                addArgIf( arguments, noindex, \"-noindex\" );\n                addArgIf( arguments, nonavbar, \"-nonavbar\" );\n                addArgIfNotEmpty( arguments, \"-noqualifier\", quotedArgument( noqualifier ), 1.4f );\n                addArgIf( arguments, nosince, \"-nosince\" );\n                addArgIf( arguments, notree, \"-notree\" );\n                addArgIf( arguments, serialwarn, \"-serialwarn\" );\n                addArgIf( arguments, splitindex, \"-splitindex\" );\n                addArgIfNotEmpty( arguments, \"-stylesheetfile\", quotedPathArgument( stylesheetfile ) );\n                addArgIfNotEmpty( arguments, \"-tag\", quotedArgument( tag ), 1.4f, true );\n                addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglet ), 1.4f );\n                addArgIfNotEmpty( arguments, \"-tagletpath\", quotedPathArgument( tagletpath ), 1.4f );\n                addArgIf( arguments, use, \"-use\" );\n                addArgIf( arguments, version, \"-version\" );\n                addArgIfNotEmpty( arguments, \"-windowtitle\", quotedArgument( windowtitle ) );\n            }\n\n            if ( options.length() > 0 )\n            {\n                File optionsFile = new File( javadocDirectory, \"options\" );\n                for ( Iterator it = arguments.iterator(); it.hasNext(); )\n                {\n                    options.append( \" \" );\n                    options.append( (String) it.next() );\n                }\n                FileUtils.fileWrite( optionsFile.getAbsolutePath(), options.toString() );\n                cmd.createArgument().setValue( \"@options\" );\n                optionsFile.deleteOnExit();\n            }\n\n            cmd.createArgument().setValue( \"@files\" );\n\n            getLog().info( Commandline.toString( cmd.getCommandline() ) );\n\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), new DefaultConsumer() );\n\n            if ( exitCode != 0 )\n            {\n                throw new MavenReportException( \"Exit code: \" + exitCode );\n            }\n        }\n        catch ( Exception e )\n        {\n            getLog().debug( e );\n            throw new MavenReportException( \"An error has occurred in javadoc report generation.\", e );\n        }\n    }","commit_id":"589fbe30f95be3adc684fbdd1379fde3fc486d49","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            int actualYear = Calendar.getInstance().get( Calendar.YEAR );\n            String year = String.valueOf( actualYear );\n\n            Model model = getProject().getModel();\n            if ( model.getInceptionYear() != null )\n            {\n                if ( StringUtils.isNumeric( model.getInceptionYear() ) )\n                {\n                    if ( Integer.valueOf( model.getInceptionYear() ).intValue() != actualYear )\n                    {\n                        year = model.getInceptionYear() + \"-\" + String.valueOf( actualYear );\n                    }\n                }\n                else\n                {\n                    getLog().warn( \"The inception year is not a valid year.\" );\n                }\n            }\n\n            StringBuffer classpath = new StringBuffer();\n            for ( Iterator i = getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\n            {\n                classpath.append( (String) i.next() );\n\n                if ( i.hasNext() )\n                {\n                    classpath.append( PATH_SEPARATOR );\n                }\n            }\n\n            StringBuffer sourcePath = new StringBuffer();\n            String[] fileList = new String[1];\n            for ( Iterator i = getProject().getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String sourceDirectory = (String) i.next();\n                fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[] { \"java\" } );\n                sourcePath.append( sourceDirectory );\n\n                if ( i.hasNext() )\n                {\n                    sourcePath.append( PATH_SEPARATOR );\n                }\n            }\n\n            File javadocDirectory = getReportOutputDirectory();\n\n            if ( !javadocDirectory.equals( getOutputDirectory() ) )\n            {\n                // we're in site-embedded report mode, so Doxia has set the\n                // reportOutputDirectory to the basedir of the site.\n                // Append 'apidocs'.\n                javadocDirectory = new File( javadocDirectory, \"apidocs\" );\n            }\n\n            if ( fileList != null && fileList.length != 0 )\n            {\n                StringBuffer files = new StringBuffer();\n                for ( int i = 0; i < fileList.length; i++ )\n                {\n                    files.append( fileList[i] );\n                    files.append( \"\\n\" );\n                }\n                javadocDirectory.mkdirs();\n                FileUtils.fileWrite( new File( javadocDirectory, \"files\" ).getAbsolutePath(), files.toString() );\n            }\n            else\n            {\n                return;\n            }\n\n            // Copy default style sheet\n            copyDefaultStylesheet( javadocDirectory );\n\n            Commandline cmd = new Commandline();\n\n            List arguments = new ArrayList();\n\n            cmd.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\n            cmd.setExecutable( getJavadocPath() );\n\n            // General javadoc arguments\n            addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n            if ( !StringUtils.isEmpty( doclet ) )\n            {\n                addArgIfNotEmpty( arguments, \"-doclet\", doclet );\n                addArgIfNotEmpty( arguments, \"-docletPath\", docletPath );\n            }\n            addArgIfNotEmpty( arguments, \"-encoding\", encoding );\n            addArgIfNotEmpty( arguments, \"-extdirs\", extdirs );\n            addArgIfNotEmpty( arguments, \"-exclude\", excludePackageNames, 1.4f );\n            addArgIfNotEmpty( arguments, \"-locale\", this.locale );\n            if ( !StringUtils.isEmpty( maxmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( maxmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xmx\" + maxmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( maxmemory.substring( 0, maxmemory.length() - 1 ) ) )\n                        && ( maxmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xmx\" + maxmemory );\n                    }\n                    else\n                    {\n                        getLog().error( \"The maxmemory '\" + maxmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( !StringUtils.isEmpty( minmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( minmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xms\" + minmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( minmemory.substring( 0, minmemory.length() - 1 ) ) )\n                        && ( minmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xms\" + minmemory );\n                    }\n                    else\n                    {\n                        getLog().error( \"The minmemory '\" + minmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( old && SystemUtils.isJavaVersionAtLeast( 1.4f ) )\n            {\n                getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n            }\n            else\n            {\n                addArgIf( arguments, old, \"-1.1\" );\n            }\n\n            addArgIfNotEmpty( arguments, \"-overview\", overview );\n            addArgIf( arguments, showPackage, \"-package\" );\n            addArgIf( arguments, showPrivate, \"-private\" );\n            addArgIf( arguments, showProtected, \"-protected\" );\n            addArgIf( arguments, public_, \"-public\" );\n            addArgIf( arguments, quiet, \"-quiet\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-source\", source, 1.4f );\n            addArgIf( arguments, verbose, \"-verbose\" );\n            addArgIfNotEmpty( arguments, \"-additionalparam\", additionalparam );\n\n            addArgIfNotEmpty( arguments, \"-sourcePath\", sourcePath.toString() );\n            addArgIfNotEmpty( arguments, \"-classpath\", classpath.toString() );\n\n            // javadoc arguments for default doclet\n            if ( StringUtils.isEmpty( doclet ) )\n            {\n                // Specify default values\n                if ( bottom.equals( DEFAULT_BOTTOM ) )\n                {\n                    bottom = \"Copyright &copy; \" + year + \" \";\n\n                    if ( ( model.getOrganization() != null )\n                        && ( !StringUtils.isEmpty( model.getOrganization().getName() ) ) )\n                    {\n                        bottom += model.getOrganization().getName();\n                    }\n                    else\n                    {\n                        bottom += DEFAULT_ORGANIZATION_NAME;\n                    }\n                    bottom += \". All Rights Reserved.\";\n                }\n\n                if ( StringUtils.isEmpty( stylesheetfile ) )\n                {\n                    stylesheetfile = javadocDirectory + File.separator + DEFAULT_CSS_NAME;\n                }\n                if ( windowtitle.equals( DEFAULT_WINDOW_TITLE ) )\n                {\n                    windowtitle = ( model.getName() == null ? model.getArtifactId() : model.getName() ) + \" \"\n                        + model.getVersion() + \" API\";\n                }\n                if ( doctitle.equals( DEFAULT_DOCTITLE ) )\n                {\n                    doctitle = windowtitle;\n                }\n                // End Specify default values\n\n                addArgIf( arguments, author, \"-author\" );\n                addArgIfNotEmpty( arguments, \"-bottom\", bottom );\n                addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-charset\", charset );\n                addArgIfNotEmpty( arguments, \"-d\", javadocDirectory.toString() );\n                addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-docencoding\", docencoding );\n                addArgIfNotEmpty( arguments, \"-doctitle\", doctitle );\n                addArgIfNotEmpty( arguments, \"-excludePackageNames\", excludePackageNames );\n                addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", excludedocfilessubdir, 1.4f );\n                addArgIfNotEmpty( arguments, \"-footer\", footer );\n                addArgIfNotEmpty( arguments, \"-group\", group, true );\n                addArgIfNotEmpty( arguments, \"-header\", header );\n                addArgIfNotEmpty( arguments, \"-helpfile\", helpfile );\n                addArgIfNotEmpty( arguments, \"-link\", link, true );\n                addArgIfNotEmpty( arguments, \"-linkoffline\", linkoffline, true );\n                addArgIf( arguments, linksource, \"-linksource\", 1.4f );\n                addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n                addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n                addArgIf( arguments, nocomment, \"-nocomment\", 1.4f );\n                addArgIf( arguments, nohelp, \"-nohelp\" );\n                addArgIf( arguments, noindex, \"-noindex\" );\n                addArgIf( arguments, nonavbar, \"-nonavbar\" );\n                addArgIfNotEmpty( arguments, \"-noqualifier\", noqualifier, 1.4f );\n                addArgIf( arguments, nosince, \"-nosince\" );\n                addArgIf( arguments, notree, \"-notree\" );\n                addArgIf( arguments, serialwarn, \"-serialwarn\" );\n                addArgIf( arguments, splitindex, \"-splitindex\" );\n                addArgIfNotEmpty( arguments, \"-stylesheetfile\", stylesheetfile );\n                addArgIfNotEmpty( arguments, \"-tag\", tag, 1.4f, true );\n                addArgIfNotEmpty( arguments, \"-taglet\", taglet, 1.4f );\n                addArgIfNotEmpty( arguments, \"-tagletpath\", tagletpath, 1.4f );\n                addArgIf( arguments, use, \"-use\" );\n                addArgIf( arguments, version, \"-version\" );\n                addArgIfNotEmpty( arguments, \"-windowtitle\", windowtitle );\n            }\n\n            for ( Iterator it = arguments.iterator(); it.hasNext(); )\n            {\n                String current = (String) it.next();\n                cmd.createArgument().setValue( current );\n            }\n\n            cmd.createArgument().setValue( \"@files\" );\n\n            getLog().info( Commandline.toString( cmd.getCommandline() ) );\n\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), new DefaultConsumer() );\n\n            if ( exitCode != 0 )\n            {\n                throw new MavenReportException( \"Exit code: \" + exitCode );\n            }\n        }\n        catch ( Exception e )\n        {\n            getLog().debug( e );\n            throw new MavenReportException( \"An error has occurred in javadoc report generation.\", e );\n        }\n    }","id":92037,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            int actualYear = Calendar.getInstance().get( Calendar.YEAR );\n            String year = String.valueOf( actualYear );\n\n            Model model = getProject().getModel();\n            if ( model.getInceptionYear() != null )\n            {\n                if ( StringUtils.isNumeric( model.getInceptionYear() ) )\n                {\n                    if ( Integer.valueOf( model.getInceptionYear() ).intValue() != actualYear )\n                    {\n                        year = model.getInceptionYear() + \"-\" + String.valueOf( actualYear );\n                    }\n                }\n                else\n                {\n                    getLog().warn( \"The inception year is not a valid year.\" );\n                }\n            }\n\n            StringBuffer classpath = new StringBuffer();\n            for ( Iterator i = getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\n            {\n                classpath.append( (String) i.next() );\n\n                if ( i.hasNext() )\n                {\n                    classpath.append( PATH_SEPARATOR );\n                }\n            }\n            if ( classpath.length() > 0 )\n            {\n                classpath.insert( 0, \"-classpath \" );\n            }\n\n            StringBuffer sourcePath = new StringBuffer();\n            StringBuffer files = new StringBuffer();\n            for ( Iterator i = getProject().getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String sourceDirectory = (String) i.next();\n                String[] fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[]{\"java\"} );\n                if ( fileList != null && fileList.length != 0 )\n                {\n                    for ( int j = 0; j < fileList.length; j++ )\n                    {\n                        files.append( fileList[j] );\n                        files.append( \"\\n\" );\n                    }\n                }\n\n                sourcePath.append( sourceDirectory );\n\n                if ( i.hasNext() )\n                {\n                    sourcePath.append( PATH_SEPARATOR );\n                }\n            }\n\n            if ( files.length() == 0 )\n            {\n                return;\n            }\n\n            File javadocDirectory = getReportOutputDirectory();\n\n            if ( !javadocDirectory.equals( getOutputDirectory() ) )\n            {\n                // we're in site-embedded report mode, so Doxia has set the\n                // reportOutputDirectory to the basedir of the site.\n                // Append 'apidocs'.\n                javadocDirectory = new File( javadocDirectory, \"apidocs\" );\n            }\n            javadocDirectory.mkdirs();\n\n            File file = new File( javadocDirectory, \"files\" );\n            file.deleteOnExit();\n            FileUtils.fileWrite( file.getAbsolutePath(), files.toString() );\n\n            // Copy default style sheet\n            copyDefaultStylesheet( javadocDirectory );\n\n            Commandline cmd = new Commandline();\n\n            List arguments = new ArrayList();\n\n            cmd.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\n            cmd.setExecutable( getJavadocPath() );\n\n            // General javadoc arguments\n            addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n            if ( !StringUtils.isEmpty( doclet ) )\n            {\n                addArgIfNotEmpty( arguments, \"-doclet\", doclet );\n                addArgIfNotEmpty( arguments, \"-docletPath\", docletPath );\n            }\n            addArgIfNotEmpty( arguments, \"-encoding\", encoding );\n            addArgIfNotEmpty( arguments, \"-extdirs\", extdirs );\n            addArgIfNotEmpty( arguments, \"-exclude\", excludePackageNames, 1.4f );\n            addArgIfNotEmpty( arguments, \"-locale\", this.locale );\n            if ( !StringUtils.isEmpty( maxmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( maxmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xmx\" + maxmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( maxmemory.substring( 0, maxmemory.length() - 1 ) ) ) &&\n                        ( maxmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xmx\" + maxmemory );\n                    }\n                    else\n                    {\n                        getLog().error(\n                            \"The maxmemory '\" + maxmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( !StringUtils.isEmpty( minmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( minmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xms\" + minmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( minmemory.substring( 0, minmemory.length() - 1 ) ) ) &&\n                        ( minmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xms\" + minmemory );\n                    }\n                    else\n                    {\n                        getLog().error(\n                            \"The minmemory '\" + minmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( old && SystemUtils.isJavaVersionAtLeast( 1.4f ) )\n            {\n                getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n            }\n            else\n            {\n                addArgIf( arguments, old, \"-1.1\" );\n            }\n\n            addArgIfNotEmpty( arguments, \"-overview\", overview );\n            addArgIf( arguments, showPackage, \"-package\" );\n            addArgIf( arguments, showPrivate, \"-private\" );\n            addArgIf( arguments, showProtected, \"-protected\" );\n            addArgIf( arguments, public_, \"-public\" );\n            addArgIf( arguments, quiet, \"-quiet\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-source\", source, 1.4f );\n            addArgIf( arguments, verbose, \"-verbose\" );\n            addArgIfNotEmpty( arguments, \"-additionalparam\", additionalparam );\n\n            addArgIfNotEmpty( arguments, \"-sourcePath\", sourcePath.toString() );\n            if ( classpath.length() > 0 )\n            {\n                file = new File( javadocDirectory, \"classpath\" );\n                file.deleteOnExit();\n                FileUtils.fileWrite( file.getAbsolutePath(), classpath.toString() );\n                cmd.createArgument().setValue( \"@classpath\" );\n            }\n\n            // javadoc arguments for default doclet\n            if ( StringUtils.isEmpty( doclet ) )\n            {\n                // Specify default values\n                if ( bottom.equals( DEFAULT_BOTTOM ) )\n                {\n                    bottom = \"Copyright &copy; \" + year + \" \";\n\n                    if ( ( model.getOrganization() != null ) &&\n                        ( !StringUtils.isEmpty( model.getOrganization().getName() ) ) )\n                    {\n                        bottom += model.getOrganization().getName();\n                    }\n                    else\n                    {\n                        bottom += DEFAULT_ORGANIZATION_NAME;\n                    }\n                    bottom += \". All Rights Reserved.\";\n                }\n\n                if ( StringUtils.isEmpty( stylesheetfile ) )\n                {\n                    stylesheetfile = javadocDirectory + File.separator + DEFAULT_CSS_NAME;\n                }\n                if ( windowtitle.equals( DEFAULT_WINDOW_TITLE ) )\n                {\n                    windowtitle = ( model.getName() == null ? model.getArtifactId() : model.getName() ) + \" \" +\n                        model.getVersion() + \" API\";\n                }\n                if ( doctitle.equals( DEFAULT_DOCTITLE ) )\n                {\n                    doctitle = windowtitle;\n                }\n                // End Specify default values\n\n                addArgIf( arguments, author, \"-author\" );\n                addArgIfNotEmpty( arguments, \"-bottom\", bottom );\n                addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-charset\", charset );\n                addArgIfNotEmpty( arguments, \"-d\", javadocDirectory.toString() );\n                addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-docencoding\", docencoding );\n                addArgIfNotEmpty( arguments, \"-doctitle\", doctitle );\n                addArgIfNotEmpty( arguments, \"-excludePackageNames\", excludePackageNames );\n                addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", excludedocfilessubdir, 1.4f );\n                addArgIfNotEmpty( arguments, \"-footer\", footer );\n                addArgIfNotEmpty( arguments, \"-group\", group, true );\n                addArgIfNotEmpty( arguments, \"-header\", header );\n                addArgIfNotEmpty( arguments, \"-helpfile\", helpfile );\n                addArgIfNotEmpty( arguments, \"-link\", link, true );\n                addArgIfNotEmpty( arguments, \"-linkoffline\", linkoffline, true );\n                addArgIf( arguments, linksource, \"-linksource\", 1.4f );\n                addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n                addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n                addArgIf( arguments, nocomment, \"-nocomment\", 1.4f );\n                addArgIf( arguments, nohelp, \"-nohelp\" );\n                addArgIf( arguments, noindex, \"-noindex\" );\n                addArgIf( arguments, nonavbar, \"-nonavbar\" );\n                addArgIfNotEmpty( arguments, \"-noqualifier\", noqualifier, 1.4f );\n                addArgIf( arguments, nosince, \"-nosince\" );\n                addArgIf( arguments, notree, \"-notree\" );\n                addArgIf( arguments, serialwarn, \"-serialwarn\" );\n                addArgIf( arguments, splitindex, \"-splitindex\" );\n                addArgIfNotEmpty( arguments, \"-stylesheetfile\", stylesheetfile );\n                addArgIfNotEmpty( arguments, \"-tag\", tag, 1.4f, true );\n                addArgIfNotEmpty( arguments, \"-taglet\", taglet, 1.4f );\n                addArgIfNotEmpty( arguments, \"-tagletpath\", tagletpath, 1.4f );\n                addArgIf( arguments, use, \"-use\" );\n                addArgIf( arguments, version, \"-version\" );\n                addArgIfNotEmpty( arguments, \"-windowtitle\", windowtitle );\n            }\n\n            for ( Iterator it = arguments.iterator(); it.hasNext(); )\n            {\n                String current = (String) it.next();\n                cmd.createArgument().setValue( current );\n            }\n\n            cmd.createArgument().setValue( \"@files\" );\n\n            getLog().info( Commandline.toString( cmd.getCommandline() ) );\n\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), new DefaultConsumer() );\n\n            if ( exitCode != 0 )\n            {\n                throw new MavenReportException( \"Exit code: \" + exitCode );\n            }\n        }\n        catch ( Exception e )\n        {\n            getLog().debug( e );\n            throw new MavenReportException( \"An error has occurred in javadoc report generation.\", e );\n        }\n    }","commit_id":"1c576b6c09600a06ecbc74e6b1c5fe2ed4507ebc","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            int actualYear = Calendar.getInstance().get( Calendar.YEAR );\n            String year = String.valueOf( actualYear );\n\n            Model model = getProject().getModel();\n            if ( model.getInceptionYear() != null )\n            {\n                if ( StringUtils.isNumeric( model.getInceptionYear() ) )\n                {\n                    if ( Integer.valueOf( model.getInceptionYear() ).intValue() != actualYear )\n                    {\n                        year = model.getInceptionYear() + \"-\" + String.valueOf( actualYear );\n                    }\n                }\n                else\n                {\n                    getLog().warn( \"The inception year is not a valid year.\" );\n                }\n            }\n\n            StringBuffer classpath = new StringBuffer();\n            for ( Iterator i = getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\n            {\n                classpath.append( (String) i.next() );\n\n                if ( i.hasNext() )\n                {\n                    classpath.append( PATH_SEPARATOR );\n                }\n            }\n\n            StringBuffer sourcePath = new StringBuffer();\n            String[] fileList = new String[1];\n            for ( Iterator i = getProject().getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String sourceDirectory = (String) i.next();\n                fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[] { \"java\" } );\n                sourcePath.append( sourceDirectory );\n\n                if ( i.hasNext() )\n                {\n                    sourcePath.append( PATH_SEPARATOR );\n                }\n            }\n\n            File javadocDirectory = getReportOutputDirectory();\n\n            if ( !javadocDirectory.equals( getOutputDirectory() ) )\n            {\n                // we're in site-embedded report mode, so Doxia has set the\n                // reportOutputDirectory to the basedir of the site.\n                // Append 'apidocs'.\n                javadocDirectory = new File( javadocDirectory, \"apidocs\" );\n            }\n\n            if ( fileList != null && fileList.length != 0 )\n            {\n                StringBuffer files = new StringBuffer();\n                for ( int i = 0; i < fileList.length; i++ )\n                {\n                    files.append( fileList[i] );\n                    files.append( \"\\n\" );\n                }\n                javadocDirectory.mkdirs();\n                FileUtils.fileWrite( new File( javadocDirectory, \"files\" ).getAbsolutePath(), files.toString() );\n            }\n            else\n            {\n                return;\n            }\n\n            // Copy default style sheet\n            copyDefaultStylesheet( javadocDirectory );\n\n            Commandline cmd = new Commandline();\n\n            List arguments = new ArrayList();\n\n            cmd.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\n            cmd.setExecutable( getJavadocPath() );\n\n            // General javadoc arguments\n            addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n            if ( !StringUtils.isEmpty( doclet ) )\n            {\n                addArgIfNotEmpty( arguments, \"-doclet\", doclet );\n                addArgIfNotEmpty( arguments, \"-docletPath\", docletPath );\n            }\n            addArgIfNotEmpty( arguments, \"-encoding\", encoding );\n            addArgIfNotEmpty( arguments, \"-extdirs\", extdirs );\n            addArgIfNotEmpty( arguments, \"-exclude\", excludePackageNames, 1.4f );\n            addArgIfNotEmpty( arguments, \"-locale\", this.locale );\n            if ( !StringUtils.isEmpty( maxmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( maxmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xmx\" + maxmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( maxmemory.substring( 0, maxmemory.length() - 1 ) ) )\n                        && ( maxmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xmx\" + maxmemory );\n                    }\n                    else\n                    {\n                        getLog().error( \"The maxmemory '\" + maxmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( !StringUtils.isEmpty( minmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( minmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xms\" + minmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( minmemory.substring( 0, minmemory.length() - 1 ) ) )\n                        && ( minmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xms\" + minmemory );\n                    }\n                    else\n                    {\n                        getLog().error( \"The minmemory '\" + minmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( old && SystemUtils.isJavaVersionAtLeast( 1.4f ) )\n            {\n                getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n            }\n            else\n            {\n                addArgIf( arguments, old, \"-1.1\" );\n            }\n\n            addArgIfNotEmpty( arguments, \"-overview\", overview );\n            addArgIf( arguments, showPackage, \"-package\" );\n            addArgIf( arguments, showPrivate, \"-private\" );\n            addArgIf( arguments, showProtected, \"-protected\" );\n            addArgIf( arguments, public_, \"-public\" );\n            addArgIf( arguments, quiet, \"-quiet\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-source\", source, 1.4f );\n            addArgIf( arguments, verbose, \"-verbose\" );\n            addArgIfNotEmpty( arguments, \"-additionalparam\", additionalparam );\n\n            addArgIfNotEmpty( arguments, \"-sourcePath\", sourcePath.toString() );\n            addArgIfNotEmpty( arguments, \"-classpath\", classpath.toString() );\n\n            // javadoc arguments for default doclet\n            if ( StringUtils.isEmpty( doclet ) )\n            {\n                // Specify default values\n                if ( bottom.equals( DEFAULT_BOTTOM ) )\n                {\n                    bottom = \"Copyright &copy; \" + year + \" \";\n\n                    if ( ( model.getOrganization() != null )\n                        && ( !StringUtils.isEmpty( model.getOrganization().getName() ) ) )\n                    {\n                        bottom += model.getOrganization().getName();\n                    }\n                    else\n                    {\n                        bottom += DEFAULT_ORGANIZATION_NAME;\n                    }\n                    bottom += \". All Rights Reserved.\";\n                }\n\n                if ( StringUtils.isEmpty( stylesheetfile ) )\n                {\n                    stylesheetfile = javadocDirectory + File.separator + DEFAULT_CSS_NAME;\n                }\n                if ( windowtitle.equals( DEFAULT_WINDOW_TITLE ) )\n                {\n                    windowtitle = ( model.getName() == null ? model.getArtifactId() : model.getName() ) + \" \"\n                        + model.getVersion() + \" API\";\n                }\n                if ( doctitle.equals( DEFAULT_DOCTITLE ) )\n                {\n                    doctitle = windowtitle;\n                }\n                // End Specify default values\n\n                addArgIf( arguments, author, \"-author\" );\n                addArgIfNotEmpty( arguments, \"-bottom\", bottom );\n                addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-charset\", charset );\n                addArgIfNotEmpty( arguments, \"-d\", javadocDirectory.toString() );\n                addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-docencoding\", docencoding );\n                addArgIfNotEmpty( arguments, \"-doctitle\", doctitle );\n                addArgIfNotEmpty( arguments, \"-excludePackageNames\", excludePackageNames );\n                addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", excludedocfilessubdir, 1.4f );\n                addArgIfNotEmpty( arguments, \"-footer\", footer );\n                addArgIfNotEmpty( arguments, \"-group\", group, true );\n                addArgIfNotEmpty( arguments, \"-header\", header );\n                addArgIfNotEmpty( arguments, \"-helpfile\", helpfile );\n                addArgIfNotEmpty( arguments, \"-link\", link, true );\n                addArgIfNotEmpty( arguments, \"-linkoffline\", linkoffline, true );\n                addArgIf( arguments, linksource, \"-linksource\", 1.4f );\n                addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n                addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n                addArgIf( arguments, nocomment, \"-nocomment\", 1.4f );\n                addArgIf( arguments, nohelp, \"-nohelp\" );\n                addArgIf( arguments, noindex, \"-noindex\" );\n                addArgIf( arguments, nonavbar, \"-nonavbar\" );\n                addArgIfNotEmpty( arguments, \"-noqualifier\", noqualifier, 1.4f );\n                addArgIf( arguments, nosince, \"-nosince\" );\n                addArgIf( arguments, notree, \"-notree\" );\n                addArgIf( arguments, serialwarn, \"-serialwarn\" );\n                addArgIf( arguments, splitindex, \"-splitindex\" );\n                addArgIfNotEmpty( arguments, \"-stylesheetfile\", stylesheetfile );\n                addArgIfNotEmpty( arguments, \"-tag\", tag, 1.4f, true );\n                addArgIfNotEmpty( arguments, \"-taglet\", taglet, 1.4f );\n                addArgIfNotEmpty( arguments, \"-tagletpath\", tagletpath, 1.4f );\n                addArgIf( arguments, use, \"-use\" );\n                addArgIf( arguments, version, \"-version\" );\n                addArgIfNotEmpty( arguments, \"-windowtitle\", windowtitle );\n            }\n\n            for ( Iterator it = arguments.iterator(); it.hasNext(); )\n            {\n                String current = (String) it.next();\n                cmd.createArgument().setValue( current );\n            }\n\n            cmd.createArgument().setValue( \"@files\" );\n\n            getLog().info( Commandline.toString( cmd.getCommandline() ) );\n\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), new DefaultConsumer() );\n\n            if ( exitCode != 0 )\n            {\n                throw new MavenReportException( \"Exit code: \" + exitCode );\n            }\n        }\n        catch ( Exception e )\n        {\n            getLog().debug( e );\n            throw new MavenReportException( \"An error has occurred in javadoc report generation.\", e );\n        }\n    }","id":92038,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        try\n        {\n            int actualYear = Calendar.getInstance().get( Calendar.YEAR );\n            String year = String.valueOf( actualYear );\n\n            Model model = getProject().getModel();\n            if ( model.getInceptionYear() != null )\n            {\n                if ( StringUtils.isNumeric( model.getInceptionYear() ) )\n                {\n                    if ( Integer.valueOf( model.getInceptionYear() ).intValue() != actualYear )\n                    {\n                        year = model.getInceptionYear() + \"-\" + String.valueOf( actualYear );\n                    }\n                }\n                else\n                {\n                    getLog().warn( \"The inception year is not a valid year.\" );\n                }\n            }\n\n            StringBuffer classpath = new StringBuffer();\n            for ( Iterator i = getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\n            {\n                classpath.append( (String) i.next() );\n\n                if ( i.hasNext() )\n                {\n                    classpath.append( PATH_SEPARATOR );\n                }\n            }\n            if ( classpath.length() > 0 )\n            {\n                classpath.insert( 0, \"-classpath \" );\n            }\n\n            StringBuffer sourcePath = new StringBuffer();\n            StringBuffer files = new StringBuffer();\n            for ( Iterator i = getProject().getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String sourceDirectory = (String) i.next();\n                String[] fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[]{\"java\"} );\n                if ( fileList != null && fileList.length != 0 )\n                {\n                    for ( int j = 0; j < fileList.length; j++ )\n                    {\n                        files.append( fileList[j] );\n                        files.append( \"\\n\" );\n                    }\n                }\n\n                sourcePath.append( sourceDirectory );\n\n                if ( i.hasNext() )\n                {\n                    sourcePath.append( PATH_SEPARATOR );\n                }\n            }\n\n            if ( files.length() == 0 )\n            {\n                return;\n            }\n\n            File javadocDirectory = getReportOutputDirectory();\n\n            if ( !javadocDirectory.equals( getOutputDirectory() ) )\n            {\n                // we're in site-embedded report mode, so Doxia has set the\n                // reportOutputDirectory to the basedir of the site.\n                // Append 'apidocs'.\n                javadocDirectory = new File( javadocDirectory, \"apidocs\" );\n            }\n            javadocDirectory.mkdirs();\n\n            File file = new File( javadocDirectory, \"files\" );\n            file.deleteOnExit();\n            FileUtils.fileWrite( file.getAbsolutePath(), files.toString() );\n\n            // Copy default style sheet\n            copyDefaultStylesheet( javadocDirectory );\n\n            Commandline cmd = new Commandline();\n\n            List arguments = new ArrayList();\n\n            cmd.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\n            cmd.setExecutable( getJavadocPath() );\n\n            // General javadoc arguments\n            addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n            if ( !StringUtils.isEmpty( doclet ) )\n            {\n                addArgIfNotEmpty( arguments, \"-doclet\", doclet );\n                addArgIfNotEmpty( arguments, \"-docletPath\", docletPath );\n            }\n            addArgIfNotEmpty( arguments, \"-encoding\", encoding );\n            addArgIfNotEmpty( arguments, \"-extdirs\", extdirs );\n            addArgIfNotEmpty( arguments, \"-exclude\", excludePackageNames, 1.4f );\n            addArgIfNotEmpty( arguments, \"-locale\", this.locale );\n            if ( !StringUtils.isEmpty( maxmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( maxmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xmx\" + maxmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( maxmemory.substring( 0, maxmemory.length() - 1 ) ) ) &&\n                        ( maxmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xmx\" + maxmemory );\n                    }\n                    else\n                    {\n                        getLog().error(\n                            \"The maxmemory '\" + maxmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( !StringUtils.isEmpty( minmemory ) )\n            {\n                // Allow '128' or '128m'\n                if ( NumberUtils.isDigits( minmemory ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xms\" + minmemory + \"m\" );\n                }\n                else\n                {\n                    if ( ( NumberUtils.isDigits( minmemory.substring( 0, minmemory.length() - 1 ) ) ) &&\n                        ( minmemory.toLowerCase().endsWith( \"m\" ) ) )\n                    {\n                        addArgIf( arguments, true, \"-J-Xms\" + minmemory );\n                    }\n                    else\n                    {\n                        getLog().error(\n                            \"The minmemory '\" + minmemory + \"' is not a valid number. Ignore this option.\" );\n                    }\n                }\n            }\n\n            if ( old && SystemUtils.isJavaVersionAtLeast( 1.4f ) )\n            {\n                getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n            }\n            else\n            {\n                addArgIf( arguments, old, \"-1.1\" );\n            }\n\n            addArgIfNotEmpty( arguments, \"-overview\", overview );\n            addArgIf( arguments, showPackage, \"-package\" );\n            addArgIf( arguments, showPrivate, \"-private\" );\n            addArgIf( arguments, showProtected, \"-protected\" );\n            addArgIf( arguments, public_, \"-public\" );\n            addArgIf( arguments, quiet, \"-quiet\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-source\", source, 1.4f );\n            addArgIf( arguments, verbose, \"-verbose\" );\n            addArgIfNotEmpty( arguments, \"-additionalparam\", additionalparam );\n\n            addArgIfNotEmpty( arguments, \"-sourcePath\", sourcePath.toString() );\n            if ( classpath.length() > 0 )\n            {\n                file = new File( javadocDirectory, \"classpath\" );\n                file.deleteOnExit();\n                FileUtils.fileWrite( file.getAbsolutePath(), classpath.toString() );\n                cmd.createArgument().setValue( \"@classpath\" );\n            }\n\n            // javadoc arguments for default doclet\n            if ( StringUtils.isEmpty( doclet ) )\n            {\n                // Specify default values\n                if ( bottom.equals( DEFAULT_BOTTOM ) )\n                {\n                    bottom = \"Copyright &copy; \" + year + \" \";\n\n                    if ( ( model.getOrganization() != null ) &&\n                        ( !StringUtils.isEmpty( model.getOrganization().getName() ) ) )\n                    {\n                        bottom += model.getOrganization().getName();\n                    }\n                    else\n                    {\n                        bottom += DEFAULT_ORGANIZATION_NAME;\n                    }\n                    bottom += \". All Rights Reserved.\";\n                }\n\n                if ( StringUtils.isEmpty( stylesheetfile ) )\n                {\n                    stylesheetfile = javadocDirectory + File.separator + DEFAULT_CSS_NAME;\n                }\n                if ( windowtitle.equals( DEFAULT_WINDOW_TITLE ) )\n                {\n                    windowtitle = ( model.getName() == null ? model.getArtifactId() : model.getName() ) + \" \" +\n                        model.getVersion() + \" API\";\n                }\n                if ( doctitle.equals( DEFAULT_DOCTITLE ) )\n                {\n                    doctitle = windowtitle;\n                }\n                // End Specify default values\n\n                addArgIf( arguments, author, \"-author\" );\n                addArgIfNotEmpty( arguments, \"-bottom\", bottom );\n                addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-charset\", charset );\n                addArgIfNotEmpty( arguments, \"-d\", javadocDirectory.toString() );\n                addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", 1.4f );\n                addArgIfNotEmpty( arguments, \"-docencoding\", docencoding );\n                addArgIfNotEmpty( arguments, \"-doctitle\", doctitle );\n                addArgIfNotEmpty( arguments, \"-excludePackageNames\", excludePackageNames );\n                addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", excludedocfilessubdir, 1.4f );\n                addArgIfNotEmpty( arguments, \"-footer\", footer );\n                addArgIfNotEmpty( arguments, \"-group\", group, true );\n                addArgIfNotEmpty( arguments, \"-header\", header );\n                addArgIfNotEmpty( arguments, \"-helpfile\", helpfile );\n                addArgIfNotEmpty( arguments, \"-link\", link, true );\n                addArgIfNotEmpty( arguments, \"-linkoffline\", linkoffline, true );\n                addArgIf( arguments, linksource, \"-linksource\", 1.4f );\n                addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n                addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n                addArgIf( arguments, nocomment, \"-nocomment\", 1.4f );\n                addArgIf( arguments, nohelp, \"-nohelp\" );\n                addArgIf( arguments, noindex, \"-noindex\" );\n                addArgIf( arguments, nonavbar, \"-nonavbar\" );\n                addArgIfNotEmpty( arguments, \"-noqualifier\", noqualifier, 1.4f );\n                addArgIf( arguments, nosince, \"-nosince\" );\n                addArgIf( arguments, notree, \"-notree\" );\n                addArgIf( arguments, serialwarn, \"-serialwarn\" );\n                addArgIf( arguments, splitindex, \"-splitindex\" );\n                addArgIfNotEmpty( arguments, \"-stylesheetfile\", stylesheetfile );\n                addArgIfNotEmpty( arguments, \"-tag\", tag, 1.4f, true );\n                addArgIfNotEmpty( arguments, \"-taglet\", taglet, 1.4f );\n                addArgIfNotEmpty( arguments, \"-tagletpath\", tagletpath, 1.4f );\n                addArgIf( arguments, use, \"-use\" );\n                addArgIf( arguments, version, \"-version\" );\n                addArgIfNotEmpty( arguments, \"-windowtitle\", windowtitle );\n            }\n\n            for ( Iterator it = arguments.iterator(); it.hasNext(); )\n            {\n                String current = (String) it.next();\n                cmd.createArgument().setValue( current );\n            }\n\n            cmd.createArgument().setValue( \"@files\" );\n\n            getLog().info( Commandline.toString( cmd.getCommandline() ) );\n\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), new DefaultConsumer() );\n\n            if ( exitCode != 0 )\n            {\n                throw new MavenReportException( \"Exit code: \" + exitCode );\n            }\n        }\n        catch ( Exception e )\n        {\n            getLog().debug( e );\n            throw new MavenReportException( \"An error has occurred in javadoc report generation.\", e );\n        }\n    }","commit_id":"e37ab05b5098f64bf8179f1e0393f39551d138cd","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * full implementation\n     *   - apply sling:alias from the resource path\n     *   - apply /etc/map mappings (inkl. config backwards compat)\n     *   - return absolute uri if possible\n     * @see org.apache.sling.api.resource.ResourceResolver#map(javax.servlet.http.HttpServletRequest, java.lang.String)\n     */\n    public String map(final HttpServletRequest request, final String resourcePath) {\n        checkClosed();\n\n        // find a fragment or query\n        int fragmentQueryMark = resourcePath.indexOf('#');\n        if (fragmentQueryMark < 0) {\n            fragmentQueryMark = resourcePath.indexOf('?');\n        }\n\n        // cut fragment or query off the resource path\n        String mappedPath;\n        final String fragmentQuery;\n        if (fragmentQueryMark >= 0) {\n            fragmentQuery = resourcePath.substring(fragmentQueryMark);\n            mappedPath = resourcePath.substring(0, fragmentQueryMark);\n            LOGGER.debug(\"map: Splitting resource path '{}' into '{}' and '{}'\",\n                new Object[] { resourcePath, mappedPath, fragmentQuery });\n        } else {\n            fragmentQuery = null;\n            mappedPath = resourcePath;\n        }\n\n\n        // cut off scheme and host, if the same as requested\n        final String schemehostport;\n        final String schemePrefix;\n        if (request != null) {\n            schemehostport = MapEntry.getURI(request.getScheme(),\n                request.getServerName(), request.getServerPort(), \"/\");\n            schemePrefix = request.getScheme().concat(\"://\");\n            LOGGER.debug(\n                \"map: Mapping path {} for {} (at least with scheme prefix {})\",\n                new Object[] { resourcePath, schemehostport, schemePrefix });\n\n        } else {\n\n            schemehostport = null;\n            schemePrefix = null;\n            LOGGER.debug(\"map: Mapping path {} for default\", resourcePath);\n\n        }\n\n        Resource res = null;\n        String workspaceName = null;\n\n        if (useMultiWorkspaces) {\n            final int wsSepPos = mappedPath.indexOf(\":/\");\n            if (wsSepPos != -1) {\n                workspaceName = mappedPath.substring(0, wsSepPos);\n                if (workspaceName.equals(getSession().getWorkspace().getName())) {\n                    mappedPath = mappedPath.substring(wsSepPos + 1);\n                } else {\n                    try {\n                        JcrResourceResolver wsResolver = getResolverForWorkspace(workspaceName);\n                        mappedPath = mappedPath.substring(wsSepPos + 1);\n                        res = wsResolver.resolveInternal(mappedPath);\n                    } catch (LoginException e) {\n                        // requested a resource in a workspace I don't have access to.\n                        // we treat this as a not found resource\n                        return null;\n                    }\n                }\n            } else {\n                // check for workspace info in request\n                workspaceName = (request == null ? null :\n                    (String)request.getAttribute(ResourceResolver.REQUEST_ATTR_WORKSPACE_INFO));\n                if ( workspaceName != null && !workspaceName.equals(getSession().getWorkspace().getName())) {\n                    LOGGER.debug(\"Delegating resolving to resolver for workspace {}\", workspaceName);\n                    try {\n                        JcrResourceResolver wsResolver = getResolverForWorkspace(workspaceName);\n                        res = wsResolver.resolveInternal(mappedPath);\n                    } catch (LoginException e) {\n                        // requested a resource in a workspace I don't have access to.\n                        // we treat this as a not found resource\n                        return null;\n                    }\n\n                }\n            }\n        }\n\n        if (res == null) {\n            res = resolveInternal(mappedPath);\n        }\n\n        if (res != null) {\n\n            // keep, what we might have cut off in internal resolution\n            final String resolutionPathInfo = res.getResourceMetadata().getResolutionPathInfo();\n\n            LOGGER.debug(\"map: Path maps to resource {} with path info {}\", res,\n                resolutionPathInfo);\n\n            // find aliases for segments. we can't walk the parent chain\n            // since the request session might not have permissions to\n            // read all parents SLING-2093\n            String[] segments = Text.explode(res.getPath(), '/');\n            if (segments.length > 0) {\n                StringBuilder buf = new StringBuilder();\n                Resource current = res.getResourceResolver().getResource(\"/\");\n                for (String name: segments) {\n                    Resource child = current.getChild(name);\n                    if (child == null) {\n                        LOGGER.warn(\"map: could not load child resource {}/{} for alias mapping.\", buf, name);\n                        current = new NonExistingResource(res.getResourceResolver(), current.getPath() + \"/\" + name);\n                        buf.append('/').append(name);\n                    } else {\n                        String alias = getProperty(child, PROP_ALIAS);\n                        if (alias == null || alias.length() == 0) {\n                            alias = name;\n                        }\n                        buf.append('/').append(alias);\n                        current = child;\n                    }\n                }\n\n                // reappend the resolutionPathInfo\n                if (resolutionPathInfo != null) {\n                    buf.append(resolutionPathInfo);\n                }\n\n                // and then we have the mapped path to work on\n                mappedPath = buf.toString();\n            } else {\n                // root if no segments\n            \tmappedPath = \"/\";            \t\t            \t\n            }\n\n            LOGGER.debug(\"map: Alias mapping resolves to path {}\", mappedPath);\n\n        }\n\n        boolean mappedPathIsUrl = false;\n        for (final MapEntry mapEntry : this.factory.getMapEntries().getMapMaps()) {\n            final String[] mappedPaths = mapEntry.replace(mappedPath);\n            if (mappedPaths != null) {\n\n                LOGGER.debug(\"map: Match for Entry {}\", mapEntry);\n\n                mappedPathIsUrl = !mapEntry.isInternal();\n\n                if (mappedPathIsUrl && schemehostport != null) {\n\n                    mappedPath = null;\n\n                    for (final String candidate : mappedPaths) {\n                        if (candidate.startsWith(schemehostport)) {\n                            mappedPath = candidate.substring(schemehostport.length() - 1);\n                            mappedPathIsUrl = false;\n                            LOGGER.debug(\n                                \"map: Found host specific mapping {} resolving to {}\",\n                                candidate, mappedPath);\n                            break;\n                        } else if (candidate.startsWith(schemePrefix)\n                            && mappedPath == null) {\n                            mappedPath = candidate;\n                        }\n                    }\n\n                    if (mappedPath == null) {\n                        mappedPath = mappedPaths[0];\n                    }\n\n                } else {\n\n                    // we can only go with assumptions selecting the first entry\n                    mappedPath = mappedPaths[0];\n\n                }\n\n                LOGGER.debug(\n                    \"resolve: MapEntry {} matches, mapped path is {}\",\n                    mapEntry, mappedPath);\n\n                break;\n            }\n        }\n\n        // this should not be the case, since mappedPath is primed\n        if (mappedPath == null) {\n            mappedPath = resourcePath;\n        }\n\n        // [scheme:][//authority][path][?query][#fragment]\n        try {\n            // use commons-httpclient's URI instead of java.net.URI, as it can\n            // actually accept *unescaped* URIs, such as the \"mappedPath\" and\n            // return them in proper escaped form, including the path, via toString()\n            URI uri = new URI(mappedPath, false);\n\n            // 1. mangle the namespaces in the path\n            String path = mangleNamespaces(uri.getPath());\n\n            // 2. prepend servlet context path if we have a request\n            if (request != null && request.getContextPath() != null\n                && request.getContextPath().length() > 0) {\n                path = request.getContextPath().concat(path);\n            }\n            // update the path part of the URI\n            uri.setPath(path);\n\n            mappedPath = uri.toString();\n        } catch (URIException e) {\n            LOGGER.warn(\"map: Unable to mangle namespaces for \" + mappedPath\n                    + \" returning unmangled\", e);\n        }\n\n        LOGGER.debug(\"map: Returning URL {} as mapping for path {}\",\n            mappedPath, resourcePath);\n\n        // reappend fragment and/or query\n        if (fragmentQuery != null) {\n            mappedPath = mappedPath.concat(fragmentQuery);\n        }\n\n        return mappedPath;\n    }","id":92039,"modified_method":"/**\n     * full implementation\n     *   - apply sling:alias from the resource path\n     *   - apply /etc/map mappings (inkl. config backwards compat)\n     *   - return absolute uri if possible\n     * @see org.apache.sling.api.resource.ResourceResolver#map(javax.servlet.http.HttpServletRequest, java.lang.String)\n     */\n    public String map(final HttpServletRequest request, final String resourcePath) {\n        checkClosed();\n\n        // find a fragment or query\n        int fragmentQueryMark = resourcePath.indexOf('#');\n        if (fragmentQueryMark < 0) {\n            fragmentQueryMark = resourcePath.indexOf('?');\n        }\n\n        // cut fragment or query off the resource path\n        String mappedPath;\n        final String fragmentQuery;\n        if (fragmentQueryMark >= 0) {\n            fragmentQuery = resourcePath.substring(fragmentQueryMark);\n            mappedPath = resourcePath.substring(0, fragmentQueryMark);\n            LOGGER.debug(\"map: Splitting resource path '{}' into '{}' and '{}'\",\n                new Object[] { resourcePath, mappedPath, fragmentQuery });\n        } else {\n            fragmentQuery = null;\n            mappedPath = resourcePath;\n        }\n\n\n        // cut off scheme and host, if the same as requested\n        final String schemehostport;\n        final String schemePrefix;\n        if (request != null) {\n            schemehostport = MapEntry.getURI(request.getScheme(),\n                request.getServerName(), request.getServerPort(), \"/\");\n            schemePrefix = request.getScheme().concat(\"://\");\n            LOGGER.debug(\n                \"map: Mapping path {} for {} (at least with scheme prefix {})\",\n                new Object[] { resourcePath, schemehostport, schemePrefix });\n\n        } else {\n\n            schemehostport = null;\n            schemePrefix = null;\n            LOGGER.debug(\"map: Mapping path {} for default\", resourcePath);\n\n        }\n\n        Resource res = null;\n        String workspaceName = null;\n\n        if (useMultiWorkspaces) {\n            final int wsSepPos = mappedPath.indexOf(\":/\");\n            if (wsSepPos != -1) {\n                workspaceName = mappedPath.substring(0, wsSepPos);\n                if (workspaceName.equals(getSession().getWorkspace().getName())) {\n                    mappedPath = mappedPath.substring(wsSepPos + 1);\n                } else {\n                    try {\n                        JcrResourceResolver wsResolver = getResolverForWorkspace(workspaceName);\n                        mappedPath = mappedPath.substring(wsSepPos + 1);\n                        res = wsResolver.resolveInternal(mappedPath);\n                    } catch (LoginException e) {\n                        // requested a resource in a workspace I don't have access to.\n                        // we treat this as a not found resource\n                        return null;\n                    }\n                }\n            } else {\n                // check for workspace info in request\n                workspaceName = (request == null ? null :\n                    (String)request.getAttribute(ResourceResolver.REQUEST_ATTR_WORKSPACE_INFO));\n                if ( workspaceName != null && !workspaceName.equals(getSession().getWorkspace().getName())) {\n                    LOGGER.debug(\"Delegating resolving to resolver for workspace {}\", workspaceName);\n                    try {\n                        JcrResourceResolver wsResolver = getResolverForWorkspace(workspaceName);\n                        res = wsResolver.resolveInternal(mappedPath);\n                    } catch (LoginException e) {\n                        // requested a resource in a workspace I don't have access to.\n                        // we treat this as a not found resource\n                        return null;\n                    }\n\n                }\n            }\n        }\n\n        if (res == null) {\n            res = resolveInternal(mappedPath);\n        }\n\n        if (res != null) {\n\n            // keep, what we might have cut off in internal resolution\n            final String resolutionPathInfo = res.getResourceMetadata().getResolutionPathInfo();\n\n            LOGGER.debug(\"map: Path maps to resource {} with path info {}\", res,\n                resolutionPathInfo);\n\n            // find aliases for segments. we can't walk the parent chain\n            // since the request session might not have permissions to\n            // read all parents SLING-2093\n            final LinkedList<String> names = new LinkedList<String>();\n\n            Resource current = res;\n            String path = res.getPath();\n            while ( path != null ) {\n                String alias = null;\n                if ( current != null ) {\n                    alias = getProperty(current, PROP_ALIAS);\n                }\n                if (alias == null || alias.length() == 0) {\n                    alias = ResourceUtil.getName(path);\n                }\n                names.add(alias);\n                path = ResourceUtil.getParent(path);\n                if ( \"/\".equals(path) ) {\n                    path = null;\n                } else if ( path != null ) {\n                    current = res.getResourceResolver().resolve(path);\n                }\n            }\n\n            // build path from segment names\n            final StringBuilder buf = new StringBuilder();\n\n            // construct the path from the segments (or root if none)\n            if (names.isEmpty()) {\n                buf.append('/');\n            } else {\n                while (!names.isEmpty()) {\n                    buf.append('/');\n                    buf.append(names.removeLast());\n                }\n            }\n\n            // reappend the resolutionPathInfo\n            if (resolutionPathInfo != null) {\n                buf.append(resolutionPathInfo);\n            }\n\n            // and then we have the mapped path to work on\n            mappedPath = buf.toString();\n\n            LOGGER.debug(\"map: Alias mapping resolves to path {}\", mappedPath);\n\n        }\n\n        boolean mappedPathIsUrl = false;\n        for (final MapEntry mapEntry : this.factory.getMapEntries().getMapMaps()) {\n            final String[] mappedPaths = mapEntry.replace(mappedPath);\n            if (mappedPaths != null) {\n\n                LOGGER.debug(\"map: Match for Entry {}\", mapEntry);\n\n                mappedPathIsUrl = !mapEntry.isInternal();\n\n                if (mappedPathIsUrl && schemehostport != null) {\n\n                    mappedPath = null;\n\n                    for (final String candidate : mappedPaths) {\n                        if (candidate.startsWith(schemehostport)) {\n                            mappedPath = candidate.substring(schemehostport.length() - 1);\n                            mappedPathIsUrl = false;\n                            LOGGER.debug(\n                                \"map: Found host specific mapping {} resolving to {}\",\n                                candidate, mappedPath);\n                            break;\n                        } else if (candidate.startsWith(schemePrefix)\n                            && mappedPath == null) {\n                            mappedPath = candidate;\n                        }\n                    }\n\n                    if (mappedPath == null) {\n                        mappedPath = mappedPaths[0];\n                    }\n\n                } else {\n\n                    // we can only go with assumptions selecting the first entry\n                    mappedPath = mappedPaths[0];\n\n                }\n\n                LOGGER.debug(\n                    \"resolve: MapEntry {} matches, mapped path is {}\",\n                    mapEntry, mappedPath);\n\n                break;\n            }\n        }\n\n        // this should not be the case, since mappedPath is primed\n        if (mappedPath == null) {\n            mappedPath = resourcePath;\n        }\n\n        // [scheme:][//authority][path][?query][#fragment]\n        try {\n            // use commons-httpclient's URI instead of java.net.URI, as it can\n            // actually accept *unescaped* URIs, such as the \"mappedPath\" and\n            // return them in proper escaped form, including the path, via toString()\n            URI uri = new URI(mappedPath, false);\n\n            // 1. mangle the namespaces in the path\n            String path = mangleNamespaces(uri.getPath());\n\n            // 2. prepend servlet context path if we have a request\n            if (request != null && request.getContextPath() != null\n                && request.getContextPath().length() > 0) {\n                path = request.getContextPath().concat(path);\n            }\n            // update the path part of the URI\n            uri.setPath(path);\n\n            mappedPath = uri.toString();\n        } catch (URIException e) {\n            LOGGER.warn(\"map: Unable to mangle namespaces for \" + mappedPath\n                    + \" returning unmangled\", e);\n        }\n\n        LOGGER.debug(\"map: Returning URL {} as mapping for path {}\",\n            mappedPath, resourcePath);\n\n        // reappend fragment and/or query\n        if (fragmentQuery != null) {\n            mappedPath = mappedPath.concat(fragmentQuery);\n        }\n\n        return mappedPath;\n    }","commit_id":"0d207f0c3699a27c917b11d48f2a7631f075478e","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns an iterator of resources.\n     */\n    public Iterator<Resource> listChildren(Resource parent) {\n        File parentFile = parent.adaptTo(File.class);\n        if (parentFile == null) {\n            // not a FsResource, try to create one from the resource\n            parent = getResource(parent.getResourceResolver(), parent.getPath());\n            if (parent != null) {\n                parentFile = parent.adaptTo(File.class);\n            }\n        }\n\n        if (parentFile != null) {\n\n            final File[] children = parentFile.listFiles();\n\n            if (children != null && children.length > 0) {\n                final ResourceResolver resolver = parent.getResourceResolver();\n                final String parentPath = parent.getPath();\n                return new Iterator<Resource>() {\n                    int index = 0;\n\n                    public boolean hasNext() {\n                        return index < children.length;\n                    }\n\n                    public Resource next() {\n                        if (!hasNext()) {\n                            throw new NoSuchElementException();\n                        }\n\n                        File file = children[index];\n                        index++;\n\n                        return new FsResource(resolver, parentPath + \"/\"\n                            + file.getName(), file);\n                    }\n\n                    public void remove() {\n                        throw new UnsupportedOperationException(\"remove\");\n                    }\n                };\n            }\n        }\n\n        // no children\n        return null;\n    }","id":92040,"modified_method":"/**\n     * Returns an iterator of resources.\n     */\n    public Iterator<Resource> listChildren(Resource parent) {\n        File parentFile = parent.adaptTo(File.class);\n\n        // not a FsResource, try to create one from the resource\n        if (parentFile == null) {\n            // if the parent path is at or below the provider root, get\n            // the respective file\n            parentFile = getFile(parent.getPath());\n            \n            // if the parent path is actually the parent of the provider\n            // root, return a single element iterator just containing the\n            // provider file, unless the provider file is a directory and\n            // a repository item with the same path actually exists\n            if (parentFile == null) {\n                \n                String parentPath = parent.getPath().concat(\"/\");\n                if (providerRoot.startsWith(parentPath)) {\n                    String relPath = providerRoot.substring(parentPath.length());\n                    if (relPath.indexOf('/') < 0) {\n                        Resource res = getResource(\n                            parent.getResourceResolver(), providerRoot);\n                        if (res != null) {\n                            return Collections.singletonList(res).iterator();\n                        }\n                    }\n                }\n\n                // no children here\n                return null;\n            }\n        }\n\n        if (parentFile != null) {\n\n            final File[] children = parentFile.listFiles();\n\n            if (children != null && children.length > 0) {\n                final ResourceResolver resolver = parent.getResourceResolver();\n                final String parentPath = parent.getPath();\n                return new Iterator<Resource>() {\n                    int index = 0;\n\n                    public boolean hasNext() {\n                        return index < children.length;\n                    }\n\n                    public Resource next() {\n                        if (!hasNext()) {\n                            throw new NoSuchElementException();\n                        }\n\n                        File file = children[index];\n                        index++;\n\n                        return new FsResource(resolver, parentPath + \"/\"\n                            + file.getName(), file);\n                    }\n\n                    public void remove() {\n                        throw new UnsupportedOperationException(\"remove\");\n                    }\n                };\n            }\n        }\n\n        // no children\n        return null;\n    }","commit_id":"dd07eb383acf126638136b2508b7220d0d265d25","url":"https://github.com/apache/sling"},{"original_method":"protected void activate(ComponentContext context) {\n        Dictionary<?, ?> props = context.getProperties();\n\n        String providerRoot = (String) props.get(ROOTS);\n        if (providerRoot == null || providerRoot.length() == 0) {\n            throw new IllegalArgumentException(ROOTS + \" property must be set\");\n        }\n\n        String providerFileName = (String) props.get(PROP_PROVIDER_FILE);\n        if (providerFileName == null || providerFileName.length() == 0) {\n            throw new IllegalArgumentException(PROP_PROVIDER_FILE\n                + \" property must be set\");\n        }\n\n        this.providerRoot = providerRoot;\n        this.providerFile = getProviderFile(providerFileName,\n            context.getBundleContext());\n    }","id":92041,"modified_method":"protected void activate(ComponentContext context) {\n        Dictionary<?, ?> props = context.getProperties();\n\n        String providerRoot = (String) props.get(ROOTS);\n        if (providerRoot == null || providerRoot.length() == 0) {\n            throw new IllegalArgumentException(ROOTS + \" property must be set\");\n        }\n\n        String providerFileName = (String) props.get(PROP_PROVIDER_FILE);\n        if (providerFileName == null || providerFileName.length() == 0) {\n            throw new IllegalArgumentException(PROP_PROVIDER_FILE\n                + \" property must be set\");\n        }\n\n        this.providerRoot = providerRoot;\n        this.providerRootPrefix = providerRoot.concat(\"/\");\n        this.providerFile = getProviderFile(providerFileName,\n            context.getBundleContext());\n    }","commit_id":"dd07eb383acf126638136b2508b7220d0d265d25","url":"https://github.com/apache/sling"},{"original_method":"protected void deactivate(ComponentContext context) {\n        this.providerRoot = null;\n        this.providerFile = null;\n    }","id":92042,"modified_method":"protected void deactivate(ComponentContext context) {\n        this.providerRoot = null;\n        this.providerRootPrefix = null;\n        this.providerFile = null;\n    }","commit_id":"dd07eb383acf126638136b2508b7220d0d265d25","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns a resource wrapping a filesystem file or folder for the given\n     * path. If the <code>path<\/code> is equal to the configured resource tree\n     * location of this provider, the configured file system file or folder is\n     * used for the resource. Otherwise the configured resource tree location\n     * prefix is removed from the path and the remaining relative path is used\n     * to access the file or folder. If no such file or folder exists, this\n     * method returns <code>null<\/code>.\n     */\n    public Resource getResource(ResourceResolver resourceResolver, String path) {\n        File file;\n        if (path.equals(providerRoot)) {\n            file = providerFile;\n        } else {\n            String relPath = path.substring(providerRoot.length() + 1);\n            file = new File(providerFile, relPath);\n        }\n\n        if (file.exists()) {\n            return new FsResource(resourceResolver, path, file);\n        }\n\n        // not applicable or not an existing file path\n        return null;\n    }","id":92043,"modified_method":"/**\n     * Returns a resource wrapping a filesystem file or folder for the given\n     * path. If the <code>path<\/code> is equal to the configured resource tree\n     * location of this provider, the configured file system file or folder is\n     * used for the resource. Otherwise the configured resource tree location\n     * prefix is removed from the path and the remaining relative path is used\n     * to access the file or folder. If no such file or folder exists, this\n     * method returns <code>null<\/code>.\n     */\n    public Resource getResource(ResourceResolver resourceResolver, String path) {\n\n        // convert the path to a file\n        File file = getFile(path);\n        if (file != null) {\n\n            // if the file is a directory, and a repository item exists for\n            // the path, do not return the directory here\n            if (file.isDirectory()) {\n                Session session = resourceResolver.adaptTo(Session.class);\n                if (session != null) {\n                    try {\n                        if (session.itemExists(path)) {\n                            return null;\n                        }\n                    } catch (RepositoryException re) {\n                        // don't care\n                    }\n                }\n            }\n\n            // if the file exists, but is not a directory or no repository entry\n            // exists, return it as a resource\n            if (file.exists()) {\n                return new FsResource(resourceResolver, path, file);\n            }\n\n        }\n\n        // not applicable or not an existing file path\n        return null;\n    }","commit_id":"dd07eb383acf126638136b2508b7220d0d265d25","url":"https://github.com/apache/sling"},{"original_method":"public Resource getScriptResource() {\n        return scriptResource;\n    }","id":92044,"modified_method":"public Resource getScriptResource() {\n        final ResourceResolver resolver = requestResourceResolver.get();\n        if ( resolver == null ) {\n            // if we don't have a request resolver we directly return the script resource\n            return scriptResource;\n        }\n        Resource rsrc = resolver.getResource(this.scriptResource.getPath());\n        if ( rsrc == null ) {\n            rsrc = new SyntheticResource(resolver, this.scriptResource.getPath(), this.scriptResource.getResourceType());\n        }\n        return rsrc;\n    }","commit_id":"783cd5880094bd6618a38b29ceee3108fd8a2b6c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.api.scripting.SlingScript#call(org.apache.sling.api.scripting.SlingBindings, java.lang.String, java.lang.Object[])\n     * @throws ScriptEvaluationException\n     */\n    public Object call(SlingBindings props, String method, Object... args) {\n        final String scriptName = getScriptResource().getPath();\n\n        Bindings bindings = null;\n        Reader reader = null;\n        try {\n            bindings = verifySlingBindings(scriptName, props);\n\n            ScriptContext ctx = new SimpleScriptContext();\n            ctx.setBindings(bindings, ScriptContext.ENGINE_SCOPE);\n            ctx.setReader((Reader) bindings.get(READER));\n            ctx.setWriter((Writer) bindings.get(OUT));\n            ctx.setErrorWriter(new LogWriter((Logger) bindings.get(LOG)));\n\n            reader = getScriptReader();\n            if ( method != null && !(this.scriptEngine instanceof Invocable)) {\n                reader = getWrapperReader(reader, method, args);\n            }\n\n            // evaluate the script\n            final Object result = scriptEngine.eval(reader, ctx);\n\n            // call method - if supplied and script engine supports direct invocation\n            if ( method != null && (this.scriptEngine instanceof Invocable)) {\n                try {\n                    ((Invocable)scriptEngine).invokeFunction(method, Arrays.asList(args).toArray());\n                } catch (NoSuchMethodException e) {\n                    throw new ScriptEvaluationException(scriptName, \"Method \" + method + \" not found in script.\", e);\n                }\n            }\n            // optionall flush the output channel\n            Object flushObject = bindings.get(SlingBindings.FLUSH);\n            if (flushObject instanceof Boolean && (Boolean) flushObject) {\n                ctx.getWriter().flush();\n            }\n\n            // allways flush the error channel\n            ctx.getErrorWriter().flush();\n\n            return result;\n\n        } catch (IOException ioe) {\n            throw new ScriptEvaluationException(scriptName, ioe.getMessage(),\n                ioe);\n\n        } catch (ScriptException se) {\n            Throwable cause = (se.getCause() == null) ? se : se.getCause();\n            throw new ScriptEvaluationException(scriptName, se.getMessage(),\n                cause);\n\n        } finally {\n            // dispose of the SlingScriptHelper\n            if ( bindings != null ) {\n                final SlingScriptHelper helper = (SlingScriptHelper) bindings.get(SLING);\n                if ( helper != null ) {\n                    helper.dispose();\n                }\n            }\n\n            // close the script reader (SLING-380)\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException ignore) {\n                    // don't care\n                }\n            }\n        }\n    }","id":92045,"modified_method":"/**\n     * @see org.apache.sling.api.scripting.SlingScript#call(org.apache.sling.api.scripting.SlingBindings, java.lang.String, java.lang.Object[])\n     * @throws ScriptEvaluationException\n     */\n    public Object call(SlingBindings props, String method, Object... args) {\n        final String scriptName = getScriptResource().getPath();\n\n        Bindings bindings = null;\n        Reader reader = null;\n        try {\n            bindings = verifySlingBindings(scriptName, props);\n\n            ScriptContext ctx = new SimpleScriptContext();\n            ctx.setBindings(bindings, ScriptContext.ENGINE_SCOPE);\n            ctx.setReader((Reader) bindings.get(READER));\n            ctx.setWriter((Writer) bindings.get(OUT));\n            ctx.setErrorWriter(new LogWriter((Logger) bindings.get(LOG)));\n\n            // set the current resource resolver\n            requestResourceResolver.set(props.getRequest().getResourceResolver());\n\n            // set the script resource resolver as an attribute\n            ctx.setAttribute(SlingScriptConstants.ATTR_SCRIPT_RESOURCE_RESOLVER,\n                    this.scriptResource.getResourceResolver(), ScriptContext.ENGINE_SCOPE);\n\n            reader = getScriptReader();\n            if ( method != null && !(this.scriptEngine instanceof Invocable)) {\n                reader = getWrapperReader(reader, method, args);\n            }\n\n            // evaluate the script\n            final Object result = scriptEngine.eval(reader, ctx);\n\n            // call method - if supplied and script engine supports direct invocation\n            if ( method != null && (this.scriptEngine instanceof Invocable)) {\n                try {\n                    ((Invocable)scriptEngine).invokeFunction(method, Arrays.asList(args).toArray());\n                } catch (NoSuchMethodException e) {\n                    throw new ScriptEvaluationException(scriptName, \"Method \" + method + \" not found in script.\", e);\n                }\n            }\n            // optionall flush the output channel\n            Object flushObject = bindings.get(SlingBindings.FLUSH);\n            if (flushObject instanceof Boolean && (Boolean) flushObject) {\n                ctx.getWriter().flush();\n            }\n\n            // allways flush the error channel\n            ctx.getErrorWriter().flush();\n\n            return result;\n\n        } catch (IOException ioe) {\n            throw new ScriptEvaluationException(scriptName, ioe.getMessage(),\n                ioe);\n\n        } catch (ScriptException se) {\n            Throwable cause = (se.getCause() == null) ? se : se.getCause();\n            throw new ScriptEvaluationException(scriptName, se.getMessage(),\n                cause);\n\n        } finally {\n            // dispose of the SlingScriptHelper\n            if ( bindings != null ) {\n                final SlingScriptHelper helper = (SlingScriptHelper) bindings.get(SLING);\n                if ( helper != null ) {\n                    helper.dispose();\n                }\n            }\n\n            // close the script reader (SLING-380)\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException ignore) {\n                    // don't care\n                }\n            }\n            requestResourceResolver.remove();\n        }\n    }","commit_id":"783cd5880094bd6618a38b29ceee3108fd8a2b6c","url":"https://github.com/apache/sling"},{"original_method":"/**\n         * @see javax.script.ScriptEngine#eval(java.io.Reader, javax.script.ScriptContext)\n         */\n        public Object eval(Reader script, ScriptContext context)\n        throws ScriptException {\n            final Bindings props = context.getBindings(ScriptContext.ENGINE_SCOPE);\n            final SlingScriptHelper scriptHelper = (SlingScriptHelper) props.get(SLING);\n            if (scriptHelper != null) {\n                ((JavaScriptEngineFactory)this.getFactory()).callServlet(props, scriptHelper);\n            }\n            return null;\n        }","id":92046,"modified_method":"/**\n         * @see javax.script.ScriptEngine#eval(java.io.Reader, javax.script.ScriptContext)\n         */\n        public Object eval(Reader script, ScriptContext context)\n        throws ScriptException {\n            final Bindings props = context.getBindings(ScriptContext.ENGINE_SCOPE);\n            final SlingScriptHelper scriptHelper = (SlingScriptHelper) props.get(SLING);\n            if (scriptHelper != null) {\n                ((JavaScriptEngineFactory)this.getFactory()).callServlet(props, scriptHelper, context);\n            }\n            return null;\n        }","commit_id":"783cd5880094bd6618a38b29ceee3108fd8a2b6c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Call the servlet.\n     * @param scriptHelper\n     * @throws SlingServletException\n     * @throws SlingIOException\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void callServlet(Bindings bindings, SlingScriptHelper scriptHelper) {\n\n        ioProvider.setRequestResourceResolver(scriptHelper.getScript().getScriptResource().getResourceResolver());\n        try {\n            ServletWrapper servlet = getWrapperAdapter(scriptHelper);\n            // create a SlingBindings object\n            final SlingBindings slingBindings = new SlingBindings();\n            slingBindings.putAll(bindings);\n            servlet.service(slingBindings);\n        } finally {\n            ioProvider.resetRequestResourceResolver();\n        }\n    }","id":92047,"modified_method":"/**\n     * Call the servlet.\n     * @param binding The bindings for the script invocation\n     * @param scriptHelper The script helper.\n     * @param context The script context.\n     * @throws SlingServletException\n     * @throws SlingIOException\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void callServlet(final Bindings bindings,\n                             final SlingScriptHelper scriptHelper,\n                             final ScriptContext context) {\n        ResourceResolver resolver = (ResourceResolver) context.getAttribute(SlingScriptConstants.ATTR_SCRIPT_RESOURCE_RESOLVER,\n                ScriptContext.ENGINE_SCOPE);\n        if ( resolver == null ) {\n            resolver = scriptHelper.getScript().getScriptResource().getResourceResolver();\n        }\n        ioProvider.setRequestResourceResolver(resolver);\n        try {\n            final ServletWrapper servlet = getWrapperAdapter(scriptHelper);\n            // create a SlingBindings object\n            final SlingBindings slingBindings = new SlingBindings();\n            slingBindings.putAll(bindings);\n            servlet.service(slingBindings);\n        } finally {\n            ioProvider.resetRequestResourceResolver();\n        }\n    }","commit_id":"783cd5880094bd6618a38b29ceee3108fd8a2b6c","url":"https://github.com/apache/sling"},{"original_method":"public Object eval(Reader script, ScriptContext context)\n                throws ScriptException {\n            Bindings props = context.getBindings(ScriptContext.ENGINE_SCOPE);\n            SlingScriptHelper scriptHelper = (SlingScriptHelper) props.get(SLING);\n            if (scriptHelper != null) {\n\n                // set the current class loader as the thread context loader for\n                // the compilation and execution of the JSP script\n                ClassLoader old = Thread.currentThread().getContextClassLoader();\n                Thread.currentThread().setContextClassLoader(jspClassLoader);\n\n                try {\n                    callJsp(props, scriptHelper);\n                } catch (SlingServletException e) {\n                    // ServletExceptions use getRootCause() instead of getCause(),\n                    // so we have to extract the actual root cause and pass it as\n                    // cause in our new ScriptException\n                    if (e.getCause() != null) {\n                        // SlingServletException always wraps ServletExceptions\n                        Throwable rootCause = TagUtil.getRootCause((ServletException) e.getCause());\n                        // the ScriptException unfortunately does not accept a Throwable as cause,\n                        // but only a Exception, so we have to wrap it with a dummy Exception in Throwable cases\n                        if (rootCause instanceof Exception) {\n                            throw new BetterScriptException(rootCause.toString(), (Exception) rootCause);\n                        }\n                        throw new BetterScriptException(rootCause.toString(),\n                                new Exception(\"Wrapping Throwable: \" + rootCause.toString(), rootCause));\n                    }\n\n                    // fallback to standard behaviour\n                    throw new BetterScriptException(e.getMessage(), e);\n\n                } catch (Exception e) {\n\n                    throw new BetterScriptException(e.getMessage(), e);\n\n                } finally {\n\n                    // make sure the context loader is reset after setting up the\n                    // JSP runtime context\n                    Thread.currentThread().setContextClassLoader(old);\n\n                }\n            }\n            return null;\n        }","id":92048,"modified_method":"public Object eval(Reader script, ScriptContext context)\n                throws ScriptException {\n            Bindings props = context.getBindings(ScriptContext.ENGINE_SCOPE);\n            SlingScriptHelper scriptHelper = (SlingScriptHelper) props.get(SLING);\n            if (scriptHelper != null) {\n\n                // set the current class loader as the thread context loader for\n                // the compilation and execution of the JSP script\n                ClassLoader old = Thread.currentThread().getContextClassLoader();\n                Thread.currentThread().setContextClassLoader(jspClassLoader);\n\n                try {\n                    callJsp(props, scriptHelper, context);\n                } catch (SlingServletException e) {\n                    // ServletExceptions use getRootCause() instead of getCause(),\n                    // so we have to extract the actual root cause and pass it as\n                    // cause in our new ScriptException\n                    if (e.getCause() != null) {\n                        // SlingServletException always wraps ServletExceptions\n                        Throwable rootCause = TagUtil.getRootCause((ServletException) e.getCause());\n                        // the ScriptException unfortunately does not accept a Throwable as cause,\n                        // but only a Exception, so we have to wrap it with a dummy Exception in Throwable cases\n                        if (rootCause instanceof Exception) {\n                            throw new BetterScriptException(rootCause.toString(), (Exception) rootCause);\n                        }\n                        throw new BetterScriptException(rootCause.toString(),\n                                new Exception(\"Wrapping Throwable: \" + rootCause.toString(), rootCause));\n                    }\n\n                    // fallback to standard behaviour\n                    throw new BetterScriptException(e.getMessage(), e);\n\n                } catch (Exception e) {\n\n                    throw new BetterScriptException(e.getMessage(), e);\n\n                } finally {\n\n                    // make sure the context loader is reset after setting up the\n                    // JSP runtime context\n                    Thread.currentThread().setContextClassLoader(old);\n\n                }\n            }\n            return null;\n        }","commit_id":"783cd5880094bd6618a38b29ceee3108fd8a2b6c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @param scriptHelper\n     * @throws SlingServletException\n     * @throws SlingIOException\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void callJsp(Bindings bindings, SlingScriptHelper scriptHelper) {\n\n        ioProvider.setRequestResourceResolver(scriptHelper.getScript().getScriptResource().getResourceResolver());\n        try {\n            JspServletWrapperAdapter jsp = getJspWrapperAdapter(scriptHelper);\n            // create a SlingBindings object\n            final SlingBindings slingBindings = new SlingBindings();\n            slingBindings.putAll(bindings);\n            jsp.service(slingBindings);\n        } finally {\n            ioProvider.resetRequestResourceResolver();\n        }\n    }","id":92049,"modified_method":"/**\n     * @param scriptHelper\n     * @throws SlingServletException\n     * @throws SlingIOException\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void callJsp(final Bindings bindings,\n                         final SlingScriptHelper scriptHelper,\n                         final ScriptContext context) {\n\n        ResourceResolver resolver = (ResourceResolver) context.getAttribute(SlingScriptConstants.ATTR_SCRIPT_RESOURCE_RESOLVER,\n                ScriptContext.ENGINE_SCOPE);\n        if ( resolver == null ) {\n            resolver = scriptHelper.getScript().getScriptResource().getResourceResolver();\n        }\n        ioProvider.setRequestResourceResolver(resolver);\n        try {\n            final JspServletWrapperAdapter jsp = getJspWrapperAdapter(scriptHelper);\n            // create a SlingBindings object\n            final SlingBindings slingBindings = new SlingBindings();\n            slingBindings.putAll(bindings);\n            jsp.service(slingBindings);\n        } finally {\n            ioProvider.resetRequestResourceResolver();\n        }\n    }","commit_id":"783cd5880094bd6618a38b29ceee3108fd8a2b6c","url":"https://github.com/apache/sling"},{"original_method":"public void dragDropEnd(DragSourceDropEvent dsde) {\n      mySource.dragDropEnd();\n      getLastProcessedTarget().cleanUpOnLeave();\n      resetCurrentEvent(\"dragDropEnd:\" + dsde.getDragSourceContext().getComponent());\n      Highlighters.hide(TEXT | ERROR_TEXT);\n    }","id":92050,"modified_method":"public void dragDropEnd(DragSourceDropEvent dsde) {\n      mySource.dragDropEnd();\n      final DnDTarget target = getLastProcessedTarget();\n      if (target != null) {\n        target.cleanUpOnLeave();\n      }\n      resetCurrentEvent(\"dragDropEnd:\" + dsde.getDragSourceContext().getComponent());\n      Highlighters.hide(TEXT | ERROR_TEXT);\n    }","commit_id":"8158b3707679d24fab88964faa37508afb933fec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateCurrentEvent(Component aComponentOverDragging, Point aPoint, int nativeAction) {\n    LOG.debug(\"updateCurrentEvent: \" + aComponentOverDragging);\n    if (myCurrentDragContext == null) return;\n    if (myCurrentEvent == null) return;\n\n    myCurrentEvent.updateAction(getDnDActionForPlatformAction(nativeAction));\n    myCurrentEvent.setPoint(aPoint);\n    myCurrentEvent.setHandlerComponent(aComponentOverDragging);\n\n    boolean samePoint = myCurrentEvent.getPoint().equals(myLastProcessedPoint);\n    boolean sameComponent = myCurrentEvent.getCurrentOverComponent().equals(myLastProcessedOverComponent);\n    boolean sameAction = (nativeAction == myLastProcessedAction);\n\n    LOG.debug(\"updateCurrentEvent: point:\" + aPoint);\n    LOG.debug(\"updateCurrentEvent: action:\" + nativeAction);\n\n    if (samePoint && sameComponent && sameAction) {\n      return;\n    }\n\n    DnDTarget target = getTarget(aComponentOverDragging);\n    DnDTarget immediateTarget = target;\n    Component eachParent = aComponentOverDragging;\n\n    final Pair<Image, Point> pair = myCurrentEvent.getUserData(DRAGGED_IMAGE_KEY);\n    if (pair != null) {\n      target.updateDraggedImage(pair.first, aPoint, pair.second);\n    }\n\n    LOG.debug(\"updateCurrentEvent: action:\" + nativeAction);\n\n    while (true) {\n      boolean canGoToParent = update(target);\n\n      if (myCurrentEvent.isDropPossible()) {\n        if (myCurrentEvent.wasDelegated()) {\n          target = myCurrentEvent.getDelegatedTarget();\n        }\n        break;\n      }\n\n      if (!canGoToParent) {\n        break;\n      }\n\n      eachParent = findAllowedParentComponent(eachParent);\n      if (eachParent == null) {\n        break;\n      }\n\n      target = getTarget(eachParent);\n    }\n\n    LOG.debug(\"updateCurrentEvent: target:\" + target);\n    LOG.debug(\"updateCurrentEvent: immediateTarget:\" + immediateTarget);\n\n    if (!myCurrentEvent.isDropPossible() && !immediateTarget.equals(target)) {\n      update(immediateTarget);\n    }\n\n    updateCursor();\n\n    final Container current = (Container)myCurrentEvent.getCurrentOverComponent();\n    final Point point = myCurrentEvent.getPointOn(getLayeredPane(current));\n    Rectangle inPlaceRect = new Rectangle(point.x - 5, point.y - 5, 5, 5);\n\n    if (!myCurrentEvent.equals(myLastProcessedEvent)) {\n      hideCurrentHighlighter();\n    }\n\n    boolean sameTarget = getLastProcessedTarget() != null && getLastProcessedTarget().equals(target);\n    if (sameTarget) {\n      if (myCurrentEvent.isDropPossible()) {\n        if (!myLastProcessedPoint.equals(myCurrentEvent.getPoint())) {\n          if (!Highlighters.isVisibleExcept(TEXT | ERROR_TEXT)) {\n            hideCurrentHighlighter();\n            restartTimer();\n            queueTooltip(myCurrentEvent, getLayeredPane(current), inPlaceRect);\n          }\n        }\n      }\n      else {\n        if (myLastProcessedPoint == null || myCurrentEvent == null || !myLastProcessedPoint.equals(myCurrentEvent.getPoint())) {\n          hideCurrentHighlighter();\n          restartTimer();\n          queueTooltip(myCurrentEvent, getLayeredPane(current), inPlaceRect);\n        }\n      }\n    }\n    else {\n      hideCurrentHighlighter();\n      getLastProcessedTarget().cleanUpOnLeave();\n      myCurrentEvent.clearDropHandler();\n      restartTimer();\n\n      if (!myCurrentEvent.isDropPossible()) {\n        queueTooltip(myCurrentEvent, getLayeredPane(current), inPlaceRect);\n      }\n    }\n\n    myLastProcessedTarget = new WeakReference<DnDTarget>(target);\n    myLastProcessedPoint = myCurrentEvent.getPoint();\n    myLastProcessedOverComponent = myCurrentEvent.getCurrentOverComponent();\n    myLastProcessedAction = myCurrentEvent.getAction().getActionId();\n    myLastProcessedEvent = (DnDEvent)myCurrentEvent.clone();\n  }","id":92051,"modified_method":"private void updateCurrentEvent(Component aComponentOverDragging, Point aPoint, int nativeAction) {\n    LOG.debug(\"updateCurrentEvent: \" + aComponentOverDragging);\n    if (myCurrentDragContext == null) return;\n    if (myCurrentEvent == null) return;\n\n    myCurrentEvent.updateAction(getDnDActionForPlatformAction(nativeAction));\n    myCurrentEvent.setPoint(aPoint);\n    myCurrentEvent.setHandlerComponent(aComponentOverDragging);\n\n    boolean samePoint = myCurrentEvent.getPoint().equals(myLastProcessedPoint);\n    boolean sameComponent = myCurrentEvent.getCurrentOverComponent().equals(myLastProcessedOverComponent);\n    boolean sameAction = (nativeAction == myLastProcessedAction);\n\n    LOG.debug(\"updateCurrentEvent: point:\" + aPoint);\n    LOG.debug(\"updateCurrentEvent: action:\" + nativeAction);\n\n    if (samePoint && sameComponent && sameAction) {\n      return;\n    }\n\n    DnDTarget target = getTarget(aComponentOverDragging);\n    DnDTarget immediateTarget = target;\n    Component eachParent = aComponentOverDragging;\n\n    final Pair<Image, Point> pair = myCurrentEvent.getUserData(DRAGGED_IMAGE_KEY);\n    if (pair != null) {\n      target.updateDraggedImage(pair.first, aPoint, pair.second);\n    }\n\n    LOG.debug(\"updateCurrentEvent: action:\" + nativeAction);\n\n    while (true) {\n      boolean canGoToParent = update(target);\n\n      if (myCurrentEvent.isDropPossible()) {\n        if (myCurrentEvent.wasDelegated()) {\n          target = myCurrentEvent.getDelegatedTarget();\n        }\n        break;\n      }\n\n      if (!canGoToParent) {\n        break;\n      }\n\n      eachParent = findAllowedParentComponent(eachParent);\n      if (eachParent == null) {\n        break;\n      }\n\n      target = getTarget(eachParent);\n    }\n\n    LOG.debug(\"updateCurrentEvent: target:\" + target);\n    LOG.debug(\"updateCurrentEvent: immediateTarget:\" + immediateTarget);\n\n    if (!myCurrentEvent.isDropPossible() && !immediateTarget.equals(target)) {\n      update(immediateTarget);\n    }\n\n    updateCursor();\n\n    final Container current = (Container)myCurrentEvent.getCurrentOverComponent();\n    final Point point = myCurrentEvent.getPointOn(getLayeredPane(current));\n    Rectangle inPlaceRect = new Rectangle(point.x - 5, point.y - 5, 5, 5);\n\n    if (!myCurrentEvent.equals(myLastProcessedEvent)) {\n      hideCurrentHighlighter();\n    }\n\n    final DnDTarget processedTarget = getLastProcessedTarget();\n    boolean sameTarget = processedTarget != null && processedTarget.equals(target);\n    if (sameTarget) {\n      if (myCurrentEvent.isDropPossible()) {\n        if (!myLastProcessedPoint.equals(myCurrentEvent.getPoint())) {\n          if (!Highlighters.isVisibleExcept(TEXT | ERROR_TEXT)) {\n            hideCurrentHighlighter();\n            restartTimer();\n            queueTooltip(myCurrentEvent, getLayeredPane(current), inPlaceRect);\n          }\n        }\n      }\n      else {\n        if (myLastProcessedPoint == null || myCurrentEvent == null || !myLastProcessedPoint.equals(myCurrentEvent.getPoint())) {\n          hideCurrentHighlighter();\n          restartTimer();\n          queueTooltip(myCurrentEvent, getLayeredPane(current), inPlaceRect);\n        }\n      }\n    }\n    else {\n      hideCurrentHighlighter();\n      if (processedTarget != null) {\n        processedTarget.cleanUpOnLeave();\n      }\n      myCurrentEvent.clearDropHandler();\n      restartTimer();\n\n      if (!myCurrentEvent.isDropPossible()) {\n        queueTooltip(myCurrentEvent, getLayeredPane(current), inPlaceRect);\n      }\n    }\n\n    myLastProcessedTarget = new WeakReference<DnDTarget>(target);\n    myLastProcessedPoint = myCurrentEvent.getPoint();\n    myLastProcessedOverComponent = myCurrentEvent.getCurrentOverComponent();\n    myLastProcessedAction = myCurrentEvent.getAction().getActionId();\n    myLastProcessedEvent = (DnDEvent)myCurrentEvent.clone();\n  }","commit_id":"e4fe3d3b0d6e84b43617b93ebc6457bebb5db198","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void onDragExit() {\n    if (myCurrentDragContext != null) {\n      myCurrentDragContext.setCursor(null);\n    }\n\n    getLastProcessedTarget().cleanUpOnLeave();\n    hideCurrentHighlighter();\n    myHightlighterShowRequest = null;\n  }","id":92052,"modified_method":"private void onDragExit() {\n    if (myCurrentDragContext != null) {\n      myCurrentDragContext.setCursor(null);\n    }\n\n    final DnDTarget target = getLastProcessedTarget();\n    if (target != null) {\n      target.cleanUpOnLeave();\n    }\n    hideCurrentHighlighter();\n    myHightlighterShowRequest = null;\n  }","commit_id":"b40134bc25c3a4352e272bccad83ff410de9a01c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n        public void visitBinaryExpression(BinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            ClassNode lType = getType(expression.getLeftExpression(), classNode);\n            final Expression rightExpression = expression.getRightExpression();\n            ClassNode rType = getType(rightExpression, classNode);\n            int op = expression.getOperation().getType();\n            ClassNode resultType = getResultType(lType, op, rType, expression);\n            if (resultType==null) {\n                addStaticTypeError(\"tbd...\", expression);\n                resultType = lType;\n            }\n            // todo : if assignment of a primitive to an object (def, Object, whatever),\n            // the type inference engine should return an Object (not a primitive type)\n            storeType(expression, resultType);\n            if (isAssignment(op)) {\n                ClassNode leftRedirect;\n                if (isArrayAccessExpression(expression.getLeftExpression())) {\n                    // in case the left expression is in the form of an array access, we should use\n                    // the inferred type instead of the left expression type\n                    leftRedirect = lType;\n                }\n                else {\n                    leftRedirect = expression.getLeftExpression().getType().redirect();\n                }\n                final boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, resultType);\n                if (!compatible) {\n                    addStaticTypeError(\"Cannot assign value of type \" + resultType + \" to variable of type \" + lType, expression);\n                } else {\n                    // if left type is array, we should check the right component types\n                    if (lType.isArray()) {\n                        ClassNode leftComponentType = lType.getComponentType();\n                        ClassNode rightRedirect = rightExpression.getType().redirect();\n                        if (rightRedirect.isArray()) {\n                            ClassNode rightComponentType = rightRedirect.getComponentType();\n                            if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                            }\n                        } else if (rightExpression instanceof ListExpression) {\n                            for (Expression element : ((ListExpression) rightExpression).getExpressions()) {\n                                ClassNode rightComponentType = element.getType().redirect();\n                                if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                    addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                storeType(expression.getLeftExpression(), resultType);\n            } else if (op==KEYWORD_INSTANCEOF) {\n                Expression left = expression.getLeftExpression();\n                final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                Object key = left.getText();\n                if (left instanceof VariableExpression && rightExpression instanceof ClassExpression) {\n                    key = findTargetVariable((VariableExpression) left);\n                }\n                List<ClassNode> potentialTypes = tempo.get(key);\n                if (potentialTypes==null) {\n                    potentialTypes = new LinkedList<ClassNode>();\n                    tempo.put(key, potentialTypes);\n                }\n                potentialTypes.add(rightExpression.getType());\n            }\n        }","id":92053,"modified_method":"@Override\n        public void visitBinaryExpression(BinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            final Expression leftExpression = expression.getLeftExpression();\n            ClassNode lType = getType(leftExpression, classNode);\n            final Expression rightExpression = expression.getRightExpression();\n            ClassNode rType = getType(rightExpression, classNode);\n            int op = expression.getOperation().getType();\n            ClassNode resultType = getResultType(lType, op, rType, expression);\n            if (resultType==null) {\n                addStaticTypeError(\"tbd...\", expression);\n                resultType = lType;\n            }\n            // todo : if assignment of a primitive to an object (def, Object, whatever),\n            // the type inference engine should return an Object (not a primitive type)\n            storeType(expression, resultType);\n            if (isAssignment(op)) {\n                ClassNode leftRedirect;\n                if (isArrayAccessExpression(leftExpression) || leftExpression instanceof PropertyExpression) {\n                    // in case the left expression is in the form of an array access, we should use\n                    // the inferred type instead of the left expression type\n                    leftRedirect = lType;\n                }\n                else {\n                    leftRedirect = leftExpression.getType().redirect();\n                }\n                final boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, resultType);\n                if (!compatible) {\n                    addStaticTypeError(\"Cannot assign value of type \" + resultType + \" to variable of type \" + lType, expression);\n                } else {\n                    // if left type is array, we should check the right component types\n                    if (lType.isArray()) {\n                        ClassNode leftComponentType = lType.getComponentType();\n                        ClassNode rightRedirect = rightExpression.getType().redirect();\n                        if (rightRedirect.isArray()) {\n                            ClassNode rightComponentType = rightRedirect.getComponentType();\n                            if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                            }\n                        } else if (rightExpression instanceof ListExpression) {\n                            for (Expression element : ((ListExpression) rightExpression).getExpressions()) {\n                                ClassNode rightComponentType = element.getType().redirect();\n                                if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                    addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                storeType(leftExpression, resultType);\n            } else if (op==KEYWORD_INSTANCEOF) {\n                final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                Object key = leftExpression.getText();\n                if (leftExpression instanceof VariableExpression && rightExpression instanceof ClassExpression) {\n                    key = findTargetVariable((VariableExpression) leftExpression);\n                }\n                List<ClassNode> potentialTypes = tempo.get(key);\n                if (potentialTypes==null) {\n                    potentialTypes = new LinkedList<ClassNode>();\n                    tempo.put(key, potentialTypes);\n                }\n                potentialTypes.add(rightExpression.getType());\n            }\n        }","commit_id":"212c0e98042dc20c41ce81ea0dbe957f7f019695","url":"https://github.com/apache/groovy"},{"original_method":"private static ClassNode getType(Expression exp, ClassNode current) {\n            ClassNode cn = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.class);\n            if (cn!=null) return cn;\n            if (exp instanceof VariableExpression){\n                VariableExpression vexp = (VariableExpression) exp;\n                if (vexp==VariableExpression.THIS_EXPRESSION) return current;\n                if (vexp==VariableExpression.SUPER_EXPRESSION) return current.getSuperClass();\n                final Variable variable = vexp.getAccessedVariable();\n                if (variable!=null && variable !=vexp && variable instanceof VariableExpression) {\n                    return getType((Expression) variable, current);\n                }\n            } else if (exp instanceof PropertyExpression) {\n                PropertyExpression pexp = (PropertyExpression) exp;\n                if (pexp.getObjectExpression().getType().isEnum()) return pexp.getObjectExpression().getType();\n            }\n            return exp.getType();\n        }","id":92054,"modified_method":"private static ClassNode getType(Expression exp, ClassNode current) {\n            ClassNode cn = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.class);\n            if (cn!=null) return cn;\n            if (exp instanceof VariableExpression){\n                VariableExpression vexp = (VariableExpression) exp;\n                if (vexp==VariableExpression.THIS_EXPRESSION) return current;\n                if (vexp==VariableExpression.SUPER_EXPRESSION) return current.getSuperClass();\n                final Variable variable = vexp.getAccessedVariable();\n                if (variable!=null && variable !=vexp && variable instanceof VariableExpression) {\n                    return getType((Expression) variable, current);\n                }\n            } else if (exp instanceof PropertyExpression) {\n                PropertyExpression pexp = (PropertyExpression) exp;\n                if (pexp.getObjectExpression().getType().isEnum()) {\n                    return pexp.getObjectExpression().getType();\n                } else {\n                    ClassNode clazz = pexp.getObjectExpression().getType().redirect();\n                    final PropertyNode propertyNode = clazz.getProperty(pexp.getPropertyAsString());\n                    if (propertyNode==null) {\n                        return ClassHelper.OBJECT_TYPE;\n                    }\n                    return propertyNode.getType();\n                }\n            }\n            return exp.getType();\n        }","commit_id":"212c0e98042dc20c41ce81ea0dbe957f7f019695","url":"https://github.com/apache/groovy"},{"original_method":"private ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n\n        if (op == ASSIGN) {\n            if (leftRedirect.isArray() && !rightRedirect.isArray()) return leftRedirect;\n            if (leftRedirect.implementsInterface(Collection_TYPE) && rightRedirect.implementsInterface(Collection_TYPE)) {\n                return right;\n            }\n            if (rightRedirect.implementsInterface(Collection_TYPE) && rightRedirect.isDerivedFrom(leftRedirect)) {\n                // ex : def foos = ['a','b','c']\n                return right;\n            }\n            return rightRedirect;\n        } else if (isBoolIntrinsicOp(op)) {\n            return boolean_TYPE;\n        } else if (isArrayOp(op)) {\n            ClassNode arrayType = getType(expr.getLeftExpression());\n            if (ClassHelper.STRING_TYPE.equals(arrayType)) {\n                // special case here\n                return ClassHelper.STRING_TYPE;\n            }\n            return inferComponentType(arrayType);\n        } else if (op == FIND_REGEX) {\n            // this case always succeeds the result is a Matcher\n            return Matcher_TYPE;\n        }\n        // the left operand is determining the result of the operation\n        // for primitives and their wrapper we use a fixed table here\n        else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n            if (isOperationInGroup(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return Long_TYPE;\n                if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect)) return BigInteger_TYPE;\n                if (isBigDecCategory(leftRedirect) && isBigDecCategory(rightRedirect)) return BigDecimal_TYPE;\n                if (isDoubleCategory(leftRedirect) && isDoubleCategory(rightRedirect)) return double_TYPE;\n            } else if (isPowerOperator(op)) {\n                return Number_TYPE;\n            } else if (isBitOperator(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return Long_TYPE;\n                if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect)) return BigInteger_TYPE;\n            } else if (isCompareToBoolean(op) || op==COMPARE_EQUAL) {\n                return boolean_TYPE;\n            }\n        }\n\n\n        // try to find a method for the operation\n        String operationName = getOperationName(op);\n        if (isShiftOperation(operationName) && isNumberCategory(leftRedirect) && (isIntCategory(rightRedirect) || isLongCategory(rightRedirect))) {\n            return leftRedirect;\n        }\n        MethodNode method = findMethodOrFail(expr, leftRedirect, operationName, rightRedirect);\n        if (method != null) {\n            if (isCompareToBoolean(op)) return boolean_TYPE;\n            if (op == COMPARE_TO) return int_TYPE;\n            return method.getReturnType();\n        }\n        //TODO: other cases\n        return null;\n    }","id":92055,"modified_method":"private ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n\n        Expression leftExpression = expr.getLeftExpression();\n        if (op == ASSIGN) {\n            if (leftRedirect.isArray() && !rightRedirect.isArray()) return leftRedirect;\n            if (leftRedirect.implementsInterface(Collection_TYPE) && rightRedirect.implementsInterface(Collection_TYPE)) {\n                return right;\n            }\n            if (rightRedirect.implementsInterface(Collection_TYPE) && rightRedirect.isDerivedFrom(leftRedirect)) {\n                // ex : def foos = ['a','b','c']\n                return right;\n            }\n            if (leftExpression instanceof VariableExpression) {\n                VariableExpression target = (VariableExpression) leftExpression;\n                if (target.getAccessedVariable() instanceof VariableExpression && target.getAccessedVariable()!=leftExpression) {\n                    target = (VariableExpression) target.getAccessedVariable();\n                }\n                ClassNode initialType = target.getType().redirect();\n                // as anything can be assigned to a String, Class or boolean, return the left type instead\n                if (STRING_TYPE.equals(initialType)\n                        || CLASS_Type.equals(initialType)\n                        || Boolean_TYPE.equals(initialType)\n                        || isPrimitiveType(initialType)) {\n                    return initialType;\n                }\n            }\n            return rightRedirect;\n        } else if (isBoolIntrinsicOp(op)) {\n            return boolean_TYPE;\n        } else if (isArrayOp(op)) {\n            ClassNode arrayType = getType(leftExpression);\n            if (ClassHelper.STRING_TYPE.equals(arrayType)) {\n                // special case here\n                return ClassHelper.STRING_TYPE;\n            }\n            return inferComponentType(arrayType);\n        } else if (op == FIND_REGEX) {\n            // this case always succeeds the result is a Matcher\n            return Matcher_TYPE;\n        }\n        // the left operand is determining the result of the operation\n        // for primitives and their wrapper we use a fixed table here\n        else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n            if (isOperationInGroup(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return Long_TYPE;\n                if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect)) return BigInteger_TYPE;\n                if (isBigDecCategory(leftRedirect) && isBigDecCategory(rightRedirect)) return BigDecimal_TYPE;\n                if (isDoubleCategory(leftRedirect) && isDoubleCategory(rightRedirect)) return double_TYPE;\n            } else if (isPowerOperator(op)) {\n                return Number_TYPE;\n            } else if (isBitOperator(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return Long_TYPE;\n                if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect)) return BigInteger_TYPE;\n            } else if (isCompareToBoolean(op) || op==COMPARE_EQUAL) {\n                return boolean_TYPE;\n            }\n        }\n\n\n        // try to find a method for the operation\n        String operationName = getOperationName(op);\n        if (isShiftOperation(operationName) && isNumberCategory(leftRedirect) && (isIntCategory(rightRedirect) || isLongCategory(rightRedirect))) {\n            return leftRedirect;\n        }\n        MethodNode method = findMethodOrFail(expr, leftRedirect, operationName, rightRedirect);\n        if (method != null) {\n            if (isCompareToBoolean(op)) return boolean_TYPE;\n            if (op == COMPARE_TO) return int_TYPE;\n            return method.getReturnType();\n        }\n        //TODO: other cases\n        return null;\n    }","commit_id":"22d327cfbe4a3114ece4b4e2374de243a8d70730","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n        public void visitBinaryExpression(BinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            ClassNode lType = getType(expression.getLeftExpression(), classNode);\n            final Expression rightExpression = expression.getRightExpression();\n            ClassNode rType = getType(rightExpression, classNode);\n            int op = expression.getOperation().getType();\n            ClassNode resultType = getResultType(lType, op, rType, expression);\n            if (resultType==null) {\n                addStaticTypeError(\"tbd...\", expression);\n                resultType = lType;\n            }\n            // todo : if assignment of a primitive to an object (def, Object, whatever),\n            // the type inference engine should return an Object (not a primitive type)\n            storeType(expression, resultType);\n            if (isAssignment(op)) {\n                ClassNode leftRedirect;\n                if (isArrayAccessExpression(expression.getLeftExpression())) {\n                    // in case the left expression is in the form of an array access, we should use\n                    // the inferred type instead of the left expression type\n                    leftRedirect = lType;\n                }\n                else {\n                    leftRedirect = expression.getLeftExpression().getType().redirect();\n                }\n                final boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, resultType);\n                if (!compatible) {\n                    addStaticTypeError(\"Cannot assign value of type \" + resultType + \" to variable of type \" + lType, expression);\n                } else {\n                    // if left type is array, we should check the right component types\n                    if (lType.isArray()) {\n                        ClassNode leftComponentType = lType.getComponentType();\n                        ClassNode rightRedirect = rightExpression.getType().redirect();\n                        if (rightRedirect.isArray()) {\n                            ClassNode rightComponentType = rightRedirect.getComponentType();\n                            if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                            }\n                        } else if (rightExpression instanceof ListExpression) {\n                            for (Expression element : ((ListExpression) rightExpression).getExpressions()) {\n                                ClassNode rightComponentType = element.getType().redirect();\n                                if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                    addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                storeType(expression.getLeftExpression(), resultType);\n            } else if (op==KEYWORD_INSTANCEOF) {\n                Expression left = expression.getLeftExpression();\n                final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                Object key = left.getText();\n                if (left instanceof VariableExpression && rightExpression instanceof ClassExpression) {\n                    key = findTargetVariable((VariableExpression) left);\n                }\n                List<ClassNode> potentialTypes = tempo.get(key);\n                if (potentialTypes==null) {\n                    potentialTypes = new LinkedList<ClassNode>();\n                    tempo.put(key, potentialTypes);\n                }\n                potentialTypes.add(rightExpression.getType());\n            }\n        }","id":92056,"modified_method":"@Override\n        public void visitBinaryExpression(BinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            final Expression leftExpression = expression.getLeftExpression();\n            ClassNode lType = getType(leftExpression, classNode);\n            final Expression rightExpression = expression.getRightExpression();\n            ClassNode rType = getType(rightExpression, classNode);\n            int op = expression.getOperation().getType();\n            ClassNode resultType = getResultType(lType, op, rType, expression);\n            if (resultType==null) {\n                addStaticTypeError(\"tbd...\", expression);\n                resultType = lType;\n            }\n            // todo : if assignment of a primitive to an object (def, Object, whatever),\n            // the type inference engine should return an Object (not a primitive type)\n            storeType(expression, resultType);\n            if (isAssignment(op)) {\n                ClassNode leftRedirect;\n                if (isArrayAccessExpression(leftExpression) || leftExpression instanceof PropertyExpression) {\n                    // in case the left expression is in the form of an array access, we should use\n                    // the inferred type instead of the left expression type\n                    leftRedirect = lType;\n                }\n                else {\n                    leftRedirect = leftExpression.getType().redirect();\n                }\n                final boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, resultType);\n                if (!compatible) {\n                    addStaticTypeError(\"Cannot assign value of type \" + resultType + \" to variable of type \" + lType, expression);\n                } else {\n                    // if left type is array, we should check the right component types\n                    if (lType.isArray()) {\n                        ClassNode leftComponentType = lType.getComponentType();\n                        ClassNode rightRedirect = rightExpression.getType().redirect();\n                        if (rightRedirect.isArray()) {\n                            ClassNode rightComponentType = rightRedirect.getComponentType();\n                            if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                            }\n                        } else if (rightExpression instanceof ListExpression) {\n                            for (Expression element : ((ListExpression) rightExpression).getExpressions()) {\n                                ClassNode rightComponentType = element.getType().redirect();\n                                if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                    addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                storeType(leftExpression, resultType);\n            } else if (op==KEYWORD_INSTANCEOF) {\n                final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                Object key = leftExpression.getText();\n                if (leftExpression instanceof VariableExpression && rightExpression instanceof ClassExpression) {\n                    key = findTargetVariable((VariableExpression) leftExpression);\n                }\n                List<ClassNode> potentialTypes = tempo.get(key);\n                if (potentialTypes==null) {\n                    potentialTypes = new LinkedList<ClassNode>();\n                    tempo.put(key, potentialTypes);\n                }\n                potentialTypes.add(rightExpression.getType());\n            }\n        }","commit_id":"404d4826c0761569466ff8e744482bf9807cb39e","url":"https://github.com/apache/groovy"},{"original_method":"private static ClassNode getType(Expression exp, ClassNode current) {\n            ClassNode cn = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.class);\n            if (cn!=null) return cn;\n            if (exp instanceof VariableExpression){\n                VariableExpression vexp = (VariableExpression) exp;\n                if (vexp==VariableExpression.THIS_EXPRESSION) return current;\n                if (vexp==VariableExpression.SUPER_EXPRESSION) return current.getSuperClass();\n                final Variable variable = vexp.getAccessedVariable();\n                if (variable!=null && variable !=vexp && variable instanceof VariableExpression) {\n                    return getType((Expression) variable, current);\n                }\n            } else if (exp instanceof PropertyExpression) {\n                PropertyExpression pexp = (PropertyExpression) exp;\n                if (pexp.getObjectExpression().getType().isEnum()) return pexp.getObjectExpression().getType();\n            }\n            return exp.getType();\n        }","id":92057,"modified_method":"private static ClassNode getType(Expression exp, ClassNode current) {\n            ClassNode cn = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.class);\n            if (cn!=null) return cn;\n            if (exp instanceof VariableExpression){\n                VariableExpression vexp = (VariableExpression) exp;\n                if (vexp==VariableExpression.THIS_EXPRESSION) return current;\n                if (vexp==VariableExpression.SUPER_EXPRESSION) return current.getSuperClass();\n                final Variable variable = vexp.getAccessedVariable();\n                if (variable!=null && variable !=vexp && variable instanceof VariableExpression) {\n                    return getType((Expression) variable, current);\n                }\n            } else if (exp instanceof PropertyExpression) {\n                PropertyExpression pexp = (PropertyExpression) exp;\n                if (pexp.getObjectExpression().getType().isEnum()) {\n                    return pexp.getObjectExpression().getType();\n                } else {\n                    ClassNode clazz = pexp.getObjectExpression().getType().redirect();\n                    final PropertyNode propertyNode = clazz.getProperty(pexp.getPropertyAsString());\n                    if (propertyNode==null) {\n                        return ClassHelper.OBJECT_TYPE;\n                    }\n                    return propertyNode.getType();\n                }\n            }\n            return exp.getType();\n        }","commit_id":"404d4826c0761569466ff8e744482bf9807cb39e","url":"https://github.com/apache/groovy"},{"original_method":"boolean doBraceMatch() {\n      ourBraceStack.clear();\n      ourTagNameStack.clear();\n      ourBraceStack.push(brace1Token);\n      if (isStrict){\n        ourTagNameStack.push(brace1TagName);\n      }\n      boolean matched = false;\n      while(true){\n        if (!forward){\n          iterator.retreat();\n        }\n        else{\n          iterator.advance();\n        }\n        if (iterator.atEnd()) {\n          break;\n        }\n\n        IElementType tokenType = iterator.getTokenType();\n\n        if (getTokenGroup(tokenType, fileType) == group) {\n          String tagName = getTagName(fileText, iterator);\n          if (!isStrict && !Comparing.equal(brace1TagName, tagName, isCaseSensitive)) continue;\n          if (forward ? isLBraceToken(iterator, fileText, fileType) : isRBraceToken(iterator, fileText, fileType)){\n            ourBraceStack.push(tokenType);\n            if (isStrict){\n              ourTagNameStack.push(tagName);\n            }\n          }\n          else if (forward ? isRBraceToken(iterator, fileText,fileType) : isLBraceToken(iterator, fileText, fileType)){\n            IElementType topTokenType = ourBraceStack.pop();\n            String topTagName = null;\n            if (isStrict){\n              topTagName = ourTagNameStack.pop();\n            }\n\n            if (!isPairBraces(topTokenType, tokenType, fileType)\n              || isStrict && !Comparing.equal(topTagName, tagName, isCaseSensitive)\n            ){\n              matched = false;\n              break;\n            }\n\n            if (ourBraceStack.size() == 0){\n              matched = true;\n              break;\n            }\n          }\n        }\n      }\n      return matched;\n    }","id":92058,"modified_method":"boolean doBraceMatch() {\n      ourBraceStack.clear();\n      ourTagNameStack.clear();\n      ourBraceStack.push(brace1Token);\n      if (isStrict){\n        ourTagNameStack.push(brace1TagName);\n      }\n      boolean matched = false;\n      while(true){\n        if (!forward){\n          iterator.retreat();\n        }\n        else{\n          iterator.advance();\n        }\n        if (iterator.atEnd()) {\n          break;\n        }\n\n        IElementType tokenType = iterator.getTokenType();\n\n        if (getTokenGroup(tokenType, fileType) == group) {\n          String tagName = myMatcher == null ? null : myMatcher.getTagName(fileText, iterator);\n          if (!isStrict && !Comparing.equal(brace1TagName, tagName, isCaseSensitive)) continue;\n          if (forward ? isLBraceToken(iterator, fileText, fileType) : isRBraceToken(iterator, fileText, fileType)){\n            ourBraceStack.push(tokenType);\n            if (isStrict){\n              ourTagNameStack.push(tagName);\n            }\n          }\n          else if (forward ? isRBraceToken(iterator, fileText,fileType) : isLBraceToken(iterator, fileText, fileType)){\n            IElementType topTokenType = ourBraceStack.pop();\n            String topTagName = null;\n            if (isStrict){\n              topTagName = ourTagNameStack.pop();\n            }\n\n            if (!isPairBraces(topTokenType, tokenType, fileType)\n              || isStrict && !Comparing.equal(topTagName, tagName, isCaseSensitive)\n            ){\n              matched = false;\n              break;\n            }\n\n            if (ourBraceStack.size() == 0){\n              matched = true;\n              break;\n            }\n          }\n        }\n      }\n      return matched;\n    }","commit_id":"95f528e298547253000d05b5bb8a88e162e69aef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean findStructuralLeftBrace(FileType fileType, HighlighterIterator iterator, CharSequence fileText) {\n    ourBraceStack.clear();\n    ourTagNameStack.clear();\n\n    BraceMatcher matcher = getBraceMatcher(fileType);\n    if (matcher == null) return false;\n\n    while (!iterator.atEnd()) {\n      if (isStructuralBraceToken(fileType, iterator,fileText)) {\n        if (isRBraceToken(iterator, fileText, fileType)) {\n          ourBraceStack.push(iterator.getTokenType());\n          ourTagNameStack.push(getTagName(fileText, iterator));\n        }\n        if (isLBraceToken(iterator, fileText, fileType)) {\n          if (ourBraceStack.size() == 0) return true;\n\n          final int group = matcher.getTokenGroup(iterator.getTokenType());\n\n          final IElementType topTokenType = ourBraceStack.pop();\n          final IElementType tokenType = iterator.getTokenType();\n\n          boolean isStrict = matcher.isStrictTagMatching(fileType, group);\n          boolean isCaseSensitive = matcher.areTagsCaseSensitive(fileType, group);\n\n          String topTagName = null;\n          String tagName = null;\n          if (isStrict){\n            topTagName = ourTagNameStack.pop();\n            tagName = getTagName(fileText, iterator);\n          }\n\n          if (!isPairBraces(topTokenType, tokenType, fileType)\n            || isStrict && !Comparing.equal(topTagName, tagName, isCaseSensitive)) {\n            return false;\n          }\n        }\n      }\n\n      iterator.retreat();\n    }\n\n    return false;\n  }","id":92059,"modified_method":"public static boolean findStructuralLeftBrace(FileType fileType, HighlighterIterator iterator, CharSequence fileText) {\n    ourBraceStack.clear();\n    ourTagNameStack.clear();\n\n    BraceMatcher matcher = getBraceMatcher(fileType);\n    if (matcher == null) return false;\n\n    while (!iterator.atEnd()) {\n      if (isStructuralBraceToken(fileType, iterator,fileText)) {\n        if (isRBraceToken(iterator, fileText, fileType)) {\n          ourBraceStack.push(iterator.getTokenType());\n          ourTagNameStack.push(matcher.getTagName(fileText, iterator));\n        }\n        if (isLBraceToken(iterator, fileText, fileType)) {\n          if (ourBraceStack.size() == 0) return true;\n\n          final int group = matcher.getTokenGroup(iterator.getTokenType());\n\n          final IElementType topTokenType = ourBraceStack.pop();\n          final IElementType tokenType = iterator.getTokenType();\n\n          boolean isStrict = matcher.isStrictTagMatching(fileType, group);\n          boolean isCaseSensitive = matcher.areTagsCaseSensitive(fileType, group);\n\n          String topTagName = null;\n          String tagName = null;\n          if (isStrict){\n            topTagName = ourTagNameStack.pop();\n            tagName = matcher.getTagName(fileText, iterator);\n          }\n\n          if (!isPairBraces(topTokenType, tokenType, fileType)\n            || isStrict && !Comparing.equal(topTagName, tagName, isCaseSensitive)) {\n            return false;\n          }\n        }\n      }\n\n      iterator.retreat();\n    }\n\n    return false;\n  }","commit_id":"95f528e298547253000d05b5bb8a88e162e69aef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"MatchBraceContext(CharSequence _fileText, FileType _fileType, HighlighterIterator _iterator, boolean _forward) {\n      fileText = _fileText;\n      fileType = _fileType;\n      iterator = _iterator;\n      forward = _forward;\n\n      brace1Token = iterator.getTokenType();\n      group = getTokenGroup(brace1Token, fileType);\n      brace1TagName = getTagName(fileText, iterator);\n\n      BraceMatcher matcher = getBraceMatcher(_fileType);\n      isStrict = matcher != null && matcher.isStrictTagMatching(fileType, group);\n      isCaseSensitive = matcher != null && matcher.areTagsCaseSensitive(fileType, group);\n    }","id":92060,"modified_method":"MatchBraceContext(CharSequence _fileText, FileType _fileType, HighlighterIterator _iterator, boolean _forward) {\n      fileText = _fileText;\n      fileType = _fileType;\n      iterator = _iterator;\n      forward = _forward;\n\n      myMatcher = getBraceMatcher(_fileType);\n      brace1Token = iterator.getTokenType();\n      group = getTokenGroup(brace1Token, fileType);\n      brace1TagName = myMatcher == null ? null : myMatcher.getTagName(fileText, iterator);\n\n      isStrict = myMatcher != null && myMatcher.isStrictTagMatching(fileType, group);\n      isCaseSensitive = myMatcher != null && myMatcher.areTagsCaseSensitive(fileType, group);\n    }","commit_id":"95f528e298547253000d05b5bb8a88e162e69aef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isEndOfSingleHtmlTag(CharSequence text,HighlighterIterator iterator) {\n    String tagName = BraceMatchingUtil.getTagName(text,iterator);\n    return tagName != null && HtmlUtil.isSingleHtmlTag(tagName);\n  }","id":92061,"modified_method":"private boolean isEndOfSingleHtmlTag(CharSequence text,HighlighterIterator iterator) {\n    String tagName = getTagName(text,iterator);\n    return tagName != null && HtmlUtil.isSingleHtmlTag(tagName);\n  }","commit_id":"95f528e298547253000d05b5bb8a88e162e69aef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isRBraceToken(HighlighterIterator iterator, CharSequence fileText, FileType fileType) {\n    final IElementType tokenType = iterator.getTokenType();\n    PairedBraceMatcher matcher = LanguageBraceMatching.INSTANCE.forLanguage(tokenType.getLanguage());\n    if (matcher != null) {\n      BracePair[] pairs = matcher.getPairs();\n      for (BracePair pair : pairs) {\n        if (pair.getRightBraceType() == tokenType) return true;\n      }\n    }\n\n    if (tokenType == JavaTokenType.RPARENTH ||\n        tokenType == JavaTokenType.RBRACE ||\n        tokenType == JavaTokenType.RBRACKET ||\n        tokenType == XmlTokenType.XML_EMPTY_ELEMENT_END ||\n        tokenType == XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER ||\n        tokenType == JspTokenType.JSP_SCRIPTLET_END ||\n        tokenType == JspTokenType.JSP_EXPRESSION_END ||\n        tokenType == JspTokenType.JSP_DECLARATION_END ||\n        tokenType == JspTokenType.JSP_DIRECTIVE_END ||\n        tokenType == ELTokenType.JSP_EL_RBRACKET ||\n        tokenType == ELTokenType.JSP_EL_RPARENTH ||\n        tokenType == JavaDocTokenType.DOC_INLINE_TAG_END) {\n      return true;\n    }\n    else if (tokenType == XmlTokenType.XML_TAG_END) {\n      final boolean result = findEndTagStart(iterator);\n\n      if (fileType == StdFileTypes.HTML || fileType == StdFileTypes.JSP) {\n        final String tagName = BraceMatchingUtil.getTagName(fileText, iterator);\n\n        if (tagName != null && HtmlUtil.isSingleHtmlTag(tagName)) {\n          return !result;\n        }\n      }\n\n      return result;\n    }\n    else {\n      return false;\n    }\n  }","id":92062,"modified_method":"public boolean isRBraceToken(HighlighterIterator iterator, CharSequence fileText, FileType fileType) {\n    final IElementType tokenType = iterator.getTokenType();\n    PairedBraceMatcher matcher = LanguageBraceMatching.INSTANCE.forLanguage(tokenType.getLanguage());\n    if (matcher != null) {\n      BracePair[] pairs = matcher.getPairs();\n      for (BracePair pair : pairs) {\n        if (pair.getRightBraceType() == tokenType) return true;\n      }\n    }\n\n    if (tokenType == JavaTokenType.RPARENTH ||\n        tokenType == JavaTokenType.RBRACE ||\n        tokenType == JavaTokenType.RBRACKET ||\n        tokenType == XmlTokenType.XML_EMPTY_ELEMENT_END ||\n        tokenType == XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER ||\n        tokenType == JspTokenType.JSP_SCRIPTLET_END ||\n        tokenType == JspTokenType.JSP_EXPRESSION_END ||\n        tokenType == JspTokenType.JSP_DECLARATION_END ||\n        tokenType == JspTokenType.JSP_DIRECTIVE_END ||\n        tokenType == ELTokenType.JSP_EL_RBRACKET ||\n        tokenType == ELTokenType.JSP_EL_RPARENTH ||\n        tokenType == JavaDocTokenType.DOC_INLINE_TAG_END) {\n      return true;\n    }\n    else if (tokenType == XmlTokenType.XML_TAG_END) {\n      final boolean result = findEndTagStart(iterator);\n\n      if (fileType == StdFileTypes.HTML || fileType == StdFileTypes.JSP) {\n        final String tagName = getTagName(fileText, iterator);\n\n        if (tagName != null && HtmlUtil.isSingleHtmlTag(tagName)) {\n          return !result;\n        }\n      }\n\n      return result;\n    }\n    else {\n      return false;\n    }\n  }","commit_id":"95f528e298547253000d05b5bb8a88e162e69aef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void addAttribute(String type, String value, String valueType, String sourceModule) {\n            if (type.isEmpty()) {\n                throw new IllegalArgumentException(\"type argument is empty\");\n            }\n            if (value.isEmpty()) {\n                throw new IllegalArgumentException(\"value argument is empty\");\n            }\n            if (value.isEmpty()) {\n                valueType = ArtifactAttribute.DEFAULT_VALUE_TYPE;\n            }\n            if (sourceModule.isEmpty()) {\n                throw new IllegalArgumentException(\"sourceModule argument is empty\");\n            }\n            attributes.add(new ArtifactAttribute(type, value, valueType, sourceModule));\n        }","id":92063,"modified_method":"void addAttribute(String type, String value, String valueType, String sourceModule) {\n            if (type.isEmpty()) {\n                throw new IllegalArgumentException(\"type argument is empty\");\n            }\n            if (value.isEmpty()) {\n                throw new IllegalArgumentException(\"value argument is empty\");\n            }\n            if (valueType.isEmpty()) {\n                throw new IllegalArgumentException(\"value type argument is empty\");\n            }\n            attributes.add(new ArtifactAttribute(type, value, valueType, sourceModule));\n        }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private AbstractFile findFile(Content dataSource, String filePath) throws TskCoreException {\n        AbstractFile file = null;\n        Path path = Paths.get(filePath);\n        if (path.isAbsolute()) {\n            FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();\n            List<AbstractFile> files = fileManager.openFiles(dataSource, filePath);\n            if (files.size() > 0) {\n                file = files.get(0);\n                if (files.size() > 1) {\n                    String errorMessage = String.format(\"Ambiguous file path: %s\", filePath);\n                    ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);\n                    this.errors.add(new ErrorInfo(this.getClass().getName(), errorMessage));\n                }\n            }\n        } else {\n            // RJCTODO: Need a look up that goes for relative path            \n        }\n        return file;\n    }","id":92064,"modified_method":"private AbstractFile findFileInCaseDatabase(Content dataSource, String filePath) throws TskCoreException {\n        AbstractFile file = null;\n        // Split the path into the file name and the parent path.\n        String fileName = filePath;\n        String parentPath = \"\";\n        int charPos = filePath.lastIndexOf(\"/\");\n        if (charPos >= 0) {\n            fileName = filePath.substring(charPos + 1);\n            parentPath = filePath.substring(0, charPos + 1);\n        }\n        // Find the file.\n        String condition = \"name='\" + fileName + \"' AND parent_path='\" + parentPath + \"'\"; //NON-NLS\n        List<AbstractFile> files = Case.getCurrentCase().getSleuthkitCase().findAllFilesWhere(condition);\n        if (!files.isEmpty()) {\n            if (files.size() == 1) {\n                file = files.get(0);\n            } else {\n                String errorMessage = String.format(\"Parent file path %s is ambiguous\", filePath);\n                this.recordError(errorMessage);\n            }\n        }\n        return file;\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void importArtifacts(ExternalResults results) {\n        SleuthkitCase caseDb = Case.getCurrentCase().getSleuthkitCase();\n        for (ExternalResults.Artifact artifactData : results.getArtifacts()) {\n            try {\n                // Add the artifact to the case database.\n                boolean artifactTypeIsUserDefined = false;\n                int artifactTypeId = caseDb.getArtifactTypeIdIfExists(artifactData.getType());\n                if (artifactTypeId == -1) {\n                    artifactTypeId = caseDb.addArtifactType(artifactData.getType(), artifactData.getType());\n                    artifactTypeIsUserDefined = true;\n                }\n                Content sourceFile = findFile(results.getDataSource(), artifactData.getSourceFilePath());\n                BlackboardArtifact artifact = sourceFile.newArtifact(artifactTypeId);\n\n                // Add the artifact's attributes to the case database.\n                Collection<BlackboardAttribute> attributes = new ArrayList<>();\n                for (ExternalResults.ArtifactAttribute attributeData : artifactData.getAttributes()) {\n                    int attributeTypeId = caseDb.getAttrTypeIdIfExists(attributeData.getType());\n                    if (artifactTypeId == -1) {\n                        artifactTypeId = caseDb.addArtifactType(attributeData.getType(), attributeData.getType());\n                    }\n                    switch (attributeData.getValueType()) {\n                        case \"text\": //NON-NLS\n                            attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), attributeData.getValue()));\n                            break;\n                        case \"int32\": //NON-NLS\n                            int intValue = Integer.parseInt(attributeData.getValue());\n                            attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), intValue));\n                            break;\n                        case \"int64\": //NON-NLS\n                            long longValue = Long.parseLong(attributeData.getValue());\n                            attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), longValue));\n                            break;\n                        case \"double\": //NON-NLS\n                            double doubleValue = Double.parseDouble(attributeData.getValue());\n                            attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), doubleValue));\n                            break;\n                        default:\n                            String errorMessage = String.format(\"Could not import %s attribute, value = %s, for %s artifact from %s, unrecognized attribute value type: %s\", \n                                    attributeData.getType(), attributeData.getValue(), \n                                    artifactData.getType(), artifactData.getSourceFilePath(),\n                                    attributeData.getValueType());\n                            ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);\n                            this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));\n                            break;\n                    }\n                }\n                artifact.addAttributes(attributes);\n\n                if (!artifactTypeIsUserDefined) {\n                    IngestServices.getInstance().fireModuleDataEvent(new ModuleDataEvent(this.getClass().getSimpleName(), BlackboardArtifact.ARTIFACT_TYPE.fromID(artifactTypeId)));\n                }\n            } catch (TskCoreException ex) {\n                String errorMessage = String.format(\"Could not import %s artifact from %s, error updating case database\", artifactData.getType(), artifactData.getSourceFilePath());\n                ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage, ex);\n                this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage, ex));\n            }\n        }\n    }","id":92065,"modified_method":"private void importArtifacts(ExternalResults results) {\n        SleuthkitCase caseDb = Case.getCurrentCase().getSleuthkitCase();\n        for (ExternalResults.Artifact artifactData : results.getArtifacts()) {\n            try {\n                // Add the artifact to the case database.\n                boolean artifactTypeIsUserDefined = false;\n                int artifactTypeId = caseDb.getArtifactTypeIdIfExists(artifactData.getType());\n                if (artifactTypeId == -1) {\n                    artifactTypeId = caseDb.addArtifactType(artifactData.getType(), artifactData.getType());\n                    artifactTypeIsUserDefined = true;\n                }\n                Content sourceFile = findFileInCaseDatabase(results.getDataSource(), artifactData.getSourceFilePath());\n                if (sourceFile != null) {\n                    BlackboardArtifact artifact = sourceFile.newArtifact(artifactTypeId);\n\n                    // Add the artifact's attributes to the case database.\n                    Collection<BlackboardAttribute> attributes = new ArrayList<>();\n                    for (ExternalResults.ArtifactAttribute attributeData : artifactData.getAttributes()) {\n                        int attributeTypeId = caseDb.getAttrTypeIdIfExists(attributeData.getType());\n                        if (attributeTypeId == -1) {\n                            attributeTypeId = caseDb.addAttrType(attributeData.getType(), attributeData.getType());\n                        }\n                        switch (attributeData.getValueType()) {\n                            case \"text\": //NON-NLS\n                                attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), attributeData.getValue()));\n                                break;\n                            case \"int32\": //NON-NLS\n                                int intValue = Integer.parseInt(attributeData.getValue());\n                                attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), intValue));\n                                break;\n                            case \"int64\": //NON-NLS\n                                long longValue = Long.parseLong(attributeData.getValue());\n                                attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), longValue));\n                                break;\n                            case \"double\": //NON-NLS\n                                double doubleValue = Double.parseDouble(attributeData.getValue());\n                                attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), doubleValue));\n                                break;\n                            default:\n                                String errorMessage = String.format(\"Could not import %s attribute, value = %s, for %s artifact from %s, unrecognized attribute value type: %s\",\n                                        attributeData.getType(), attributeData.getValue(),\n                                        artifactData.getType(), artifactData.getSourceFilePath(),\n                                        attributeData.getValueType());\n                                ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);\n                                this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));\n                                break;\n                        }\n                    }\n                    artifact.addAttributes(attributes);\n\n                    if (!artifactTypeIsUserDefined) {\n                        IngestServices.getInstance().fireModuleDataEvent(new ModuleDataEvent(this.getClass().getSimpleName(), BlackboardArtifact.ARTIFACT_TYPE.fromID(artifactTypeId)));\n                    }\n                }\n            } catch (TskCoreException ex) {\n                String errorMessage = String.format(\"Could not import %s artifact from %s, error updating case database\", artifactData.getType(), artifactData.getSourceFilePath());\n                ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage, ex);\n                this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage, ex));\n            }\n        }\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void importReports(ExternalResults results) {\n        for (ExternalResults.Report report : results.getReports()) {\n            String reportPath = Case.getCurrentCase().getCaseDirectory() + File.separator + report.getLocalPath();\n            try {\n                File reportFile = new File(reportPath);\n                if (reportFile.exists()) {\n                    Case.getCurrentCase().getSleuthkitCase().addReport(reportPath, report.getDisplayName());\n                } else {\n                    String errorMessage = String.format(\"Could not import report at %s, file does not exist\", reportPath);\n                    ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);\n                    this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));\n                }\n            } catch (TskCoreException ex) {\n                String errorMessage = String.format(\"Could not import report at %s, error updating case database\", reportPath);\n                ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage, ex);\n                this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage, ex));\n            }\n        }\n    }","id":92066,"modified_method":"private void importReports(ExternalResults results) {\n        for (ExternalResults.Report report : results.getReports()) {\n            String reportPath = report.getLocalPath();\n            try {\n                File reportFile = new File(reportPath);\n                if (reportFile.exists()) {\n                    String relativePath = this.getPathRelativeToCaseFolder(reportPath);\n                    if (!relativePath.isEmpty()) {\n                        Case.getCurrentCase().getSleuthkitCase().addReport(relativePath, report.getDisplayName());\n                    }\n                } else {\n                    String errorMessage = String.format(\"Could not import report at %s, file does not exist\", reportPath);\n                    ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);\n                    this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));\n                }\n            } catch (TskCoreException ex) {\n                String errorMessage = String.format(\"Could not import report at %s, error updating case database\", reportPath);\n                ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage, ex);\n                this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage, ex));\n            }\n        }\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void importDerivedFiles(ExternalResults results) {\n        FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();\n        for (ExternalResults.DerivedFile fileData : results.getDerivedFiles()) {\n            String filePath = Case.getCurrentCase().getCaseDirectory() + File.separator + fileData.getLocalPath();\n            try {\n                File localFile = new File(filePath);\n                if (!localFile.exists()) {\n                    AbstractFile parentFile = findFile(results.getDataSource(), fileData.getParentPath());\n                    if (parentFile != null) {\n                        DerivedFile derivedFile = fileManager.addDerivedFile(localFile.getName(), fileData.getLocalPath(), localFile.length(),\n                                0, 0, 0, 0, // Do not currently have file times for derived files from external processes.\n                                true, parentFile,\n                                \"\", \"\", \"\", \"\"); // Not currently providing derivation info for derived files from external processes.\n                        IngestServices.getInstance().fireModuleContentEvent(new ModuleContentEvent(derivedFile));\n                    } else {\n                        String errorMessage = String.format(\"Could not import derived file at %s, parent file %s not found\", filePath);\n                        ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);\n                        this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));\n                    }\n                } else {\n                    String errorMessage = String.format(\"Could not import derived file at %s, file does not exist\", filePath);\n                    ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);\n                    this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));\n                }\n            } catch (TskCoreException ex) {\n                String errorMessage = String.format(\"Could not import derived file at %s, error querying/updating case database\", filePath);\n                ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage, ex);\n                this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage, ex));\n            }\n        }\n    }","id":92067,"modified_method":"private void importDerivedFiles(ExternalResults results) {\n        FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();\n        for (ExternalResults.DerivedFile fileData : results.getDerivedFiles()) {\n            String localPath = fileData.getLocalPath();\n            try {\n                File localFile = new File(localPath);\n                if (localFile.exists()) {\n                    String relativePath = this.getPathRelativeToCaseFolder(localPath);\n                    if (!relativePath.isEmpty()) {\n                        String parentFilePath = fileData.getParentPath();\n                        AbstractFile parentFile = findFileInCaseDatabase(results.getDataSource(), parentFilePath);\n                        if (parentFile != null) {\n                            DerivedFile derivedFile = fileManager.addDerivedFile(localFile.getName(), relativePath, localFile.length(),\n                                    0, 0, 0, 0, // Do not currently have file times for derived files from external processes.\n                                    true, parentFile,\n                                    \"\", \"\", \"\", \"\"); // Not currently providing derivation info for derived files from external processes.\n                            IngestServices.getInstance().fireModuleContentEvent(new ModuleContentEvent(derivedFile));\n                        } else {\n                            String errorMessage = String.format(\"Could not import derived file at %s, parent file %s not found\", localPath, parentFilePath);\n                            ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);\n                            this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));\n                        }\n                    }\n                } else {\n                    String errorMessage = String.format(\"Could not import derived file at %s, file does not exist\", localPath);\n                    ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);\n                    this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));\n                }\n            } catch (TskCoreException ex) {\n                String errorMessage = String.format(\"Could not import derived file at %s, error querying/updating case database\", localPath);\n                ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage, ex);\n                this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage, ex));\n            }\n        }\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void parseArtifacts(final Element root) {\n        NodeList artifactsListNodes = root.getElementsByTagName(TagNames.ARTIFACTS_LIST_ELEM.toString());\n        for (int i = 0; i < artifactsListNodes.getLength(); ++i) {\n            Element artifactsListElem = (Element) artifactsListNodes.item(i);\n            NodeList artifactNodes = artifactsListElem.getElementsByTagName(TagNames.ARTIFACT_ELEM.toString());\n            for (int j = 0; j < artifactNodes.getLength(); ++j) {\n                Element artifactElem = (Element) artifactNodes.item(j);\n                final String type = getElementAttributeValue(artifactElem, TagNames.TYPE_ATTR.toString());\n                if (!type.isEmpty()) {\n                    final String sourceFilePath = this.getChildElementContent((Element) artifactElem, TagNames.PATH_ELEM.toString());\n                    if (!sourceFilePath.isEmpty()) {\n                        ExternalResults.Artifact artifact = externalResults.addArtifact(type, sourceFilePath);\n                        parseArtifactAttributes(artifactElem, artifact);\n                    }\n                }\n            }\n        }\n    }","id":92068,"modified_method":"private void parseArtifacts(final Element root) {\n        // Get the artifact lists.\n        NodeList artifactsListNodes = root.getElementsByTagName(TagNames.ARTIFACTS_LIST_ELEM.toString());\n        for (int i = 0; i < artifactsListNodes.getLength(); ++i) {\n            Element artifactsListElem = (Element) artifactsListNodes.item(i);\n            // Get the artifacts.\n            NodeList artifactNodes = artifactsListElem.getElementsByTagName(TagNames.ARTIFACT_ELEM.toString());\n            for (int j = 0; j < artifactNodes.getLength(); ++j) {\n                Element artifactElem = (Element) artifactNodes.item(j);\n                // Get the artifact type.\n                final String type = getElementAttributeValue(artifactElem, AttributeNames.TYPE_ATTR.toString());\n                if (!type.isEmpty()) {\n                    // Get the source file of the artifact and the attributes,\n                    // if any.\n                    final String sourceFilePath = this.getChildElementContent((Element) artifactElem, TagNames.SOURCE_FILE_ELEM.toString(), true);\n                    if (!sourceFilePath.isEmpty()) {\n                        ExternalResults.Artifact artifact = this.resultsData.addArtifact(type, sourceFilePath);\n                        parseArtifactAttributes(artifactElem, artifact);\n                    }\n                }\n            }\n        }\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void recordError(String errorMessage) {\n        this.logger.log(Level.SEVERE, errorMessage);\n        this.errors.add(new ErrorInfo(this.getClass().getSimpleName(), errorMessage));\n    }","id":92069,"modified_method":"private void recordError(String errorMessage) {\n        ExternalResultsXMLParser.logger.log(Level.SEVERE, errorMessage);\n        this.errors.add(new ErrorInfo(this.getClass().getSimpleName(), errorMessage));\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private String getChildElementContent(Element parentElement, String childElementTagName) {\n        String content = \"\";\n        NodeList childNodes = parentElement.getElementsByTagName(childElementTagName);\n        if (childNodes.getLength() > 0) {\n            if (childNodes.getLength() > 1) {\n                logger.log(Level.SEVERE, \"Found multiple {0} child elements for {1} element in {2}, ignoring all but first occurrence\", new Object[]{\n                    childElementTagName,\n                    parentElement.getTagName(),\n                    this.resultsFilePath}); // NON-NLS\n            }\n            Element childElement = (Element) childNodes.item(0);\n            content = childElement.getTextContent();\n            if (content.isEmpty()) {\n                logger.log(Level.SEVERE, \"Found {0} element with {1} child element that has no content in {2}\", new Object[]{\n                    parentElement.getTagName(),\n                    childElementTagName,\n                    this.resultsFilePath}); // NON-NLS\n            }\n        } else {\n            logger.log(Level.SEVERE, \"Found {0} element missing {1} child element in {2}\", new Object[]{\n                parentElement.getTagName(),\n                childElementTagName,\n                this.resultsFilePath});  // NON-NLS   \n        }\n        return content;\n    }","id":92070,"modified_method":"private String getChildElementContent(Element parentElement, String childElementTagName, boolean required) {\n        String content = \"\";\n        Element childElement = this.getChildElement(parentElement, childElementTagName);\n        if (childElement != null) {\n            content = childElement.getTextContent();\n            if (content.isEmpty()) {\n                String errorMessage = String.format(\"Found %s element with %s child element that has no content in %s\",\n                        parentElement.getTagName(),\n                        childElementTagName,\n                        this.resultsFilePath);\n                this.recordError(errorMessage);\n            }\n        } else if (required) {\n            String errorMessage = String.format(\"Found %s element missing %s child element in %s\",\n                    parentElement.getTagName(),\n                    childElementTagName,\n                    this.resultsFilePath);\n            this.recordError(errorMessage);\n        }\n        return content;\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Constructor.\n     *\n     * @param importFilePath Full path of the results file to be parsed.\n     */\n    public ExternalResultsXMLParser(Content dataSource, String resultsFilePath) {\n        this.resultsFilePath = resultsFilePath;\n        externalResults = new ExternalResults(dataSource);\n    }","id":92071,"modified_method":"/**\n     * Constructor.\n     *\n     * @param importFilePath Full path of the results file to be parsed.\n     */\n    public ExternalResultsXMLParser(Content dataSource, String resultsFilePath) {\n        this.dataSource = dataSource;\n        this.resultsFilePath = resultsFilePath;\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public ExternalResults parse() {\n        try {\n            // Note that XMLUtil.loadDoc() logs a warning if the file does not\n            // conform to the XSD, but still returns a Document object. Until \n            // this behavior is improved, validation is still required. If \n            // XMLUtil.loadDoc() does return null, it failed to load the \n            // document and it logged the error.\n            final Document doc = XMLUtil.loadDoc(ExternalResultsXMLParser.class, this.resultsFilePath, XSD_FILE);\n            if (doc != null) {\n                final Element rootElem = doc.getDocumentElement();\n                if (rootElem != null && rootElem.getNodeName().equals(TagNames.ROOT_ELEM.toString())) {\n                    parseDerivedFiles(rootElem);\n                    parseArtifacts(rootElem);\n                    parseReports(rootElem);\n                } else {\n                    String errorMessage = String.format(\"Did not find %s root element of %s\", TagNames.ROOT_ELEM.toString(), this.resultsFilePath);\n                    recordError(errorMessage);\n                }\n            }\n        } catch (Exception ex) {\n            String errorMessage = String.format(\"Error parsing %s\", this.resultsFilePath);\n            recordError(errorMessage, ex);\n        }\n        return externalResults;\n    }","id":92072,"modified_method":"@Override\n    public ExternalResults parse() {\n        this.errors.clear();\n        this.resultsData = new ExternalResults(dataSource);\n        try {\n            // Note that XMLUtil.loadDoc() logs a warning if the file does not\n            // conform to the XSD, but still returns a Document object. Until \n            // this behavior is improved, validation is still required. If \n            // XMLUtil.loadDoc() does return null, it failed to load the \n            // document and it logged the error.\n            final Document doc = XMLUtil.loadDoc(ExternalResultsXMLParser.class, this.resultsFilePath, XSD_FILE);\n            if (doc != null) {\n                final Element rootElem = doc.getDocumentElement();\n                if (rootElem != null && rootElem.getNodeName().equals(TagNames.ROOT_ELEM.toString())) {\n                    parseDerivedFiles(rootElem);\n                    parseArtifacts(rootElem);\n                    parseReports(rootElem);\n                } else {\n                    String errorMessage = String.format(\"Did not find %s root element of %s\", TagNames.ROOT_ELEM.toString(), this.resultsFilePath);\n                    recordError(errorMessage);\n                }\n            }\n        } catch (Exception ex) {\n            String errorMessage = String.format(\"Error parsing %s\", this.resultsFilePath);\n            recordError(errorMessage, ex);\n        }\n        return this.resultsData;\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void parseReports(Element root) {\n        NodeList reportsListNodes = root.getElementsByTagName(TagNames.REPORTS_LIST_ELEM.toString());\n        for (int i = 0; i < reportsListNodes.getLength(); ++i) {\n            Element reportsListElem = (Element) reportsListNodes.item(i);\n            NodeList reportNodes = reportsListElem.getElementsByTagName(TagNames.REPORT_ELEM.toString());\n            for (int j = 0; j < reportNodes.getLength(); ++j) {\n                Element reportElem = (Element) reportNodes.item(j);\n                String displayName = getChildElementContent(reportElem, TagNames.DISPLAY_NAME_ELEM.toString());\n                if (displayName.isEmpty()) {\n                    continue;\n                }\n                String path = getChildElementContent(reportElem, TagNames.LOCAL_PATH_ELEM.toString());\n                if (displayName.isEmpty()) {\n                    continue;\n                }\n                externalResults.addReport(displayName, path);\n            }\n        }\n    }","id":92073,"modified_method":"private void parseReports(Element root) {\n        // Get the report lists.\n        NodeList reportsListNodes = root.getElementsByTagName(TagNames.REPORTS_LIST_ELEM.toString());\n        for (int i = 0; i < reportsListNodes.getLength(); ++i) {\n            Element reportsListElem = (Element) reportsListNodes.item(i);\n            // Get the reports.\n            NodeList reportNodes = reportsListElem.getElementsByTagName(TagNames.REPORT_ELEM.toString());\n            for (int j = 0; j < reportNodes.getLength(); ++j) {\n                Element reportElem = (Element) reportNodes.item(j);\n                // Get the display name.\n                String displayName = getChildElementContent(reportElem, TagNames.DISPLAY_NAME_ELEM.toString(), true);\n                if (displayName.isEmpty()) {\n                    continue;\n                }\n                // Get the local path.\n                String path = getChildElementContent(reportElem, TagNames.LOCAL_PATH_ELEM.toString(), true);\n                if (path.isEmpty()) {\n                    continue;\n                }\n                this.resultsData.addReport(displayName, path);\n            }\n        }\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void parseDerivedFiles(Element rootElement) {\n        NodeList derivedFilesListNodes = rootElement.getElementsByTagName(TagNames.DERIVED_FILES_LIST_ELEM.toString());\n        for (int i = 0; i < derivedFilesListNodes.getLength(); ++i) {\n            Element derivedFilesListElem = (Element) derivedFilesListNodes.item(i);\n            NodeList derivedFileNodes = derivedFilesListElem.getElementsByTagName(TagNames.DERIVED_FILE_ELEM.toString());\n            for (int j = 0; j < derivedFileNodes.getLength(); ++j) {\n                Element derivedFileElem = (Element) derivedFileNodes.item(j);\n                String path = getChildElementContent(derivedFileElem, TagNames.LOCAL_PATH_ELEM.toString());\n                if (path.isEmpty()) {\n                    continue;\n                }\n                String parentPath = getChildElementContent((Element) derivedFileNodes.item(j), TagNames.PARENT_PATH_ELEM.toString());\n                if (parentPath.isEmpty()) {\n                    continue;\n                }\n                externalResults.addDerivedFile(path, parentPath);\n            }\n        }\n    }","id":92074,"modified_method":"private void parseDerivedFiles(Element rootElement) {\n        // Get the derived file lists.\n        NodeList derivedFilesListNodes = rootElement.getElementsByTagName(TagNames.DERIVED_FILES_LIST_ELEM.toString());\n        for (int i = 0; i < derivedFilesListNodes.getLength(); ++i) {\n            Element derivedFilesListElem = (Element) derivedFilesListNodes.item(i);\n            // Get the derived files.\n            NodeList derivedFileNodes = derivedFilesListElem.getElementsByTagName(TagNames.DERIVED_FILE_ELEM.toString());\n            for (int j = 0; j < derivedFileNodes.getLength(); ++j) {\n                Element derivedFileElem = (Element) derivedFileNodes.item(j);\n                // Get the local path of the derived file.\n                String path = getChildElementContent(derivedFileElem, TagNames.LOCAL_PATH_ELEM.toString(), true);\n                if (path.isEmpty()) {\n                    continue;\n                }\n                // Get the parent file of the derived file.\n                String parentFile = getChildElementContent((Element) derivedFileNodes.item(j), TagNames.PARENT_FILE_ELEM.toString(), true);\n                if (parentFile.isEmpty()) {\n                    continue;\n                }\n                this.resultsData.addDerivedFile(path, parentFile);\n            }\n        }\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private Element getChildElement(Element parentElement, String childElementTagName) {\n        Element childElem = null;\n        NodeList childNodes = parentElement.getElementsByTagName(childElementTagName);\n        if (childNodes.getLength() > 0) {\n            if (childNodes.getLength() > 1) {\n                logger.log(Level.SEVERE, \"Found multiple {0} child elements for {1} element in {2}, ignoring all but first occurrence\", new Object[]{\n                    childElementTagName,\n                    parentElement.getTagName(),\n                    this.resultsFilePath}); // NON-NLS\n            }\n        }\n        return childElem;\n    }","id":92075,"modified_method":"private Element getChildElement(Element parentElement, String childElementTagName) {\n        Element childElem = null;\n        NodeList childNodes = parentElement.getElementsByTagName(childElementTagName);\n        if (childNodes.getLength() > 0) {\n            childElem = (Element) childNodes.item(0);\n            if (childNodes.getLength() > 1) {\n                String errorMessage = String.format(\"Found multiple %s child elements for %s element in %s, ignoring all but first occurrence\",\n                        childElementTagName,\n                        parentElement.getTagName(),\n                        this.resultsFilePath);\n                this.recordError(errorMessage);\n            }\n        }\n        return childElem;\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void recordError(String errorMessage, Exception ex) {\n        this.logger.log(Level.SEVERE, errorMessage, ex);\n        this.errors.add(new ErrorInfo(this.getClass().getSimpleName(), errorMessage, ex));\n    }","id":92076,"modified_method":"private void recordError(String errorMessage, Exception ex) {\n        ExternalResultsXMLParser.logger.log(Level.SEVERE, errorMessage, ex);\n        this.errors.add(new ErrorInfo(this.getClass().getSimpleName(), errorMessage, ex));\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void parseArtifactAttributes(final Element artifactElem, ExternalResults.Artifact artifact) {\n        NodeList attributeNodesList = artifactElem.getElementsByTagName(TagNames.ATTRIBUTE_ELEM.toString());\n        for (int i = 0; i < attributeNodesList.getLength(); ++i) {\n            // Get the type of the artifact attribute.\n            Element attributeElem = (Element) attributeNodesList.item(i);\n            final String type = getElementAttributeValue(attributeElem, TagNames.TYPE_ATTR.toString());\n            if (type.isEmpty()) {\n                continue;\n            }\n            // Get the value of the artifact attribute.\n            Element valueElem = this.getChildElement(attributeElem, TagNames.VALUE_ELEM.toString());\n            if (valueElem == null) {\n                continue;\n            }\n            final String value = valueElem.getTextContent();\n            if (value.isEmpty()) {\n                String errorMessage = String.format(\"Found %s element that has no content in %s\",\n                        TagNames.VALUE_ELEM.toString(), this.resultsFilePath);\n                recordError(errorMessage);\n                continue;\n            }\n            // Get the value type.\n            String valueType = valueElem.getAttribute(TagNames.TYPE_ATTR.toString());\n            if (valueType.isEmpty()) {\n                valueType = TagNames.VALUE_TYPE_TEXT.toString();\n            }\n            // Get the source module for the artifact attribute.\n            String sourceModule = \"\";\n            NodeList sourceModuleNodes = attributeElem.getElementsByTagName(TagNames.SOURCE_MODULE_ELEM.toString());\n            if (sourceModuleNodes.getLength() > 0) {\n                if (sourceModuleNodes.getLength() > 1) {\n                    String errorMessage = String.format(\"Found multiple %s child elements for %s element in %s, ignoring all but first occurrence\",\n                            TagNames.SOURCE_MODULE_ELEM.toString(), attributeElem.getTagName(), this.resultsFilePath);\n                    recordError(errorMessage);\n                }\n                Element srcModuleElem = (Element) sourceModuleNodes.item(0);\n                sourceModule = srcModuleElem.getTextContent();\n            }\n            // Add the attribute to the artifact.\n            artifact.addAttribute(type, value, valueType, sourceModule);\n        }\n    }","id":92077,"modified_method":"private void parseArtifactAttributes(final Element artifactElem, ExternalResults.Artifact artifact) {\n        // Get the artifact attributes.\n        NodeList attributeNodesList = artifactElem.getElementsByTagName(TagNames.ATTRIBUTE_ELEM.toString());\n        for (int i = 0; i < attributeNodesList.getLength(); ++i) {\n            Element attributeElem = (Element) attributeNodesList.item(i);\n            final String type = getElementAttributeValue(attributeElem, AttributeNames.TYPE_ATTR.toString());\n            if (type.isEmpty()) {\n                continue;\n            }\n            // Get the value of the artifact attribute.\n            Element valueElem = this.getChildElement(attributeElem, TagNames.VALUE_ELEM.toString());\n            if (valueElem == null) {\n                continue;\n            }\n            final String value = valueElem.getTextContent();\n            if (value.isEmpty()) {\n                String errorMessage = String.format(\"Found %s element that has no content in %s\",\n                        TagNames.VALUE_ELEM.toString(), this.resultsFilePath);\n                recordError(errorMessage);\n                continue;\n            }\n            // Get the value type.\n            String valueType = parseArtifactAttributeValueType(valueElem);\n            if (valueType.isEmpty()) {\n                continue;\n            }\n            // Get the optional source module.\n            String sourceModule = this.getChildElementContent(attributeElem, TagNames.SOURCE_MODULE_ELEM.toString(), false);\n            // Add the attribute to the artifact.\n            artifact.addAttribute(type, value, valueType, sourceModule);\n        }\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private List<String> generateSimulatedDerivedFiles() throws IOException {\n        List<String> filePaths = new ArrayList<>();\n        String fileContents = \"This is a simulated derived file.\";\n        for (int i = 0; i < 3; ++i) {\n            String fileName = String.format(\"job_%d_derived_file_%d.txt\", jobId, i);\n            generateFile(fileName, fileContents.getBytes());\n            filePaths.add(outputDirPath + File.separator + fileName);\n        }\n        return filePaths;\n    }","id":92078,"modified_method":"private List<String> generateSimulatedDerivedFiles() throws IOException {\n        List<String> filePaths = new ArrayList<>();\n        String fileContents = \"This is a simulated derived file.\";\n        for (int i = 0; i < 2; ++i) {\n            String fileName = String.format(\"job_%d_derived_file_%d.txt\", jobId, i);\n            filePaths.add(generateFile(fileName, fileContents.getBytes()));\n            if (i == 0) {\n                this.derivedFileInCaseDatabase = this.fileInCaseDatabase + \"/\" + fileName;\n            }\n        }\n        return filePaths;\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void generateSimulatedResults(String dataSourcePath, String resultsFilePath) throws ParserConfigurationException, IOException, TransformerConfigurationException, TransformerException {\n        List<String> derivedFilePaths = generateSimulatedDerivedFiles();\n        String reportFilePath = generateSimulatedReport();\n        generateSimulatedResultsFile(dataSourcePath, derivedFilePaths, reportFilePath, resultsFilePath);\n    }","id":92079,"modified_method":"private void generateSimulatedResults(String resultsFilePath) throws ParserConfigurationException, IOException, TransformerConfigurationException, TransformerException {\n        List<String> derivedFilePaths = generateSimulatedDerivedFiles();\n        String reportFilePath = generateSimulatedReport();\n        generateSimulatedResultsFile(derivedFilePaths, reportFilePath, resultsFilePath);\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public ProcessResult process(Content dataSource, DataSourceIngestModuleProgress progressBar) {\n        if (refCounter.get(jobId) == 1) {\n            try {\n                // There will be two tasks: data source analysis and import of \n                // the results of the analysis.\n                progressBar.switchToDeterminate(2);\n\n                // Do the analysis. The following commented out code could be \n                // used to run an executable. In this case the executable takes \n                // two command line arguments, the path to the data source to be \n                // analyzed and the path to a results file. The results file is \n                // an XML file (see org.sleuthkit.autopsy.externalresults.autopsy_external_results.xsd)\n                // with instructions for the import of blackboard artifacts, \n                // derived files, and reports generated by the analysis. In this \n                // sample ingest module, the generation of the analysis results is\n                // simulated. \n                String dataSourcePath = dataSource.getImage().getPaths()[0];\n                String resultsFilePath = outputDirPath + File.separator + String.format(\"job_%d_results.xml\", jobId);\n//                ExecUtil executor = new ExecUtil();\n//                executor.execute(\"some.exe\", dataSourcePath, resultsFilePath);\n                generateSimulatedResults(dataSourcePath, resultsFilePath);\n                progressBar.progress(1);\n\n                // Import the results of the analysis.\n                ExternalResults results = new ExternalResultsXMLParser(dataSource, resultsFilePath).parse(); \n                // RJCTODO: Get error messages\n                ExternalResultsImporter importer = new ExternalResultsImporter();\n                importer.importResults(results);\n                // RJCTODO: Get error messages\n                \n                progressBar.progress(2);\n            } catch (TskCoreException | ParserConfigurationException | TransformerException | IOException ex) {\n                Logger logger = IngestServices.getInstance().getLogger(moduleName);\n                logger.log(Level.SEVERE, \"Failed to simulate analysis and results import\", ex);  //NON-NLS\n                return ProcessResult.ERROR;\n            }\n        }\n\n        return ProcessResult.OK;\n    }","id":92080,"modified_method":"@Override\n    public ProcessResult process(Content dataSource, DataSourceIngestModuleProgress progressBar) {\n        if (refCounter.get(jobId) == 1) {\n            try {\n                // There will be two tasks: data source analysis and import of \n                // the results of the analysis.\n                progressBar.switchToDeterminate(2);\n\n                // Do the analysis. The following sample code could be used to \n                // run an executable. In this case the executable would take \n                // two command line arguments, the path to the data source to be \n                // analyzed and the path to a results file to be generated. The \n                // results file would be an an XML file (see org.sleuthkit.autopsy.externalresults.autopsy_external_results.xsd)\n                // with instructions for the import of blackboard artifacts, \n                // derived files, and reports generated by the analysis. In this \n                // sample ingest module, the generation of the analysis results is\n                // simulated. \n                String resultsFilePath = outputDirPath + File.separator + String.format(\"job_%d_results.xml\", jobId);\n                boolean haveRealExecutable = false;\n                if (haveRealExecutable) {\n                    String dataSourcePath = dataSource.getImage().getPaths()[0];\n                    ExecUtil executor = new ExecUtil();\n                    executor.execute(\"some.exe\", dataSourcePath, resultsFilePath);\n                } else {\n                    generateSimulatedResults(resultsFilePath);\n                }\n                progressBar.progress(1);\n\n                // Import the results of the analysis.\n                ExternalResultsXMLParser resultsParser = new ExternalResultsXMLParser(dataSource, resultsFilePath);\n                ExternalResults results = resultsParser.parse();\n                List<ErrorInfo> errors = resultsParser.getErrorInfo();\n                ExternalResultsImporter importer = new ExternalResultsImporter();\n                errors.addAll(importer.importResults(results));\n                // RJCTODO: Report error messages to UI                \n                progressBar.progress(2);\n            } catch (TskCoreException | InterruptedException | ParserConfigurationException | TransformerException | IOException ex) {\n                Logger logger = IngestServices.getInstance().getLogger(moduleName);\n                logger.log(Level.SEVERE, \"Failed to simulate analysis and results import\", ex);  //NON-NLS\n                return ProcessResult.ERROR;\n            }\n        }\n        return ProcessResult.OK;\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void generateSimulatedResultsFile(String dataSourcePath, List<String> derivedFilePaths, String reportPath, String resultsFilePath) throws ParserConfigurationException, TransformerConfigurationException, TransformerException {\n        // Create the XML DOM document and the root element.\n        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n        Document doc = docBuilder.newDocument();\n        Element rootElement = doc.createElement(ExternalResultsXMLParser.TagNames.ROOT_ELEM.toString());\n        doc.appendChild(rootElement);\n\n        // Add an artifacts list element to the root element.\n        Element artifactsListElement = doc.createElement(ExternalResultsXMLParser.TagNames.ARTIFACTS_LIST_ELEM.toString());\n        rootElement.appendChild(artifactsListElement);\n\n        // Add an artifact element to the artifacts list element. A standard \n        // artifact type is used as the required type attribute of this \n        // artifact element.\n        Element artifactElement = doc.createElement(ExternalResultsXMLParser.TagNames.ARTIFACT_ELEM.toString());\n        artifactElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT.getLabel());\n        artifactsListElement.appendChild(artifactElement);\n\n        // Add an optional file element to the artifact element, and add a path \n        // element to the file element. This is how a source file for an \n        // artifact is usually specified. If an artifact element has no file\n        // element, the data source is used as the default source file for the\n        // artifact.\n        Element fileElement = doc.createElement(ExternalResultsXMLParser.TagNames.SOURCE_FILE_ELEM.toString());\n        artifactElement.appendChild(fileElement);\n        Element pathElement = doc.createElement(ExternalResultsXMLParser.TagNames.PATH_ELEM.toString());\n        pathElement.setTextContent(dataSourcePath);\n        fileElement.appendChild(pathElement);\n\n        // Add an artifact attribute element to the artifact element. A standard \n        // artifact attribute type is used as the required type XML attribute of \n        // the artifact attribute element.\n        Element artifactAttrElement = doc.createElement(ExternalResultsXMLParser.TagNames.ATTRIBUTE_ELEM.toString());\n        artifactAttrElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), ATTRIBUTE_TYPE.TSK_SET_NAME.getLabel());\n        artifactElement.appendChild(artifactAttrElement);\n\n        // Add the required value element to the artifact attribute element, \n        // with an optional type XML attribute of ExternalXML.VALUE_TYPE_TEXT, \n        // which is the default.        \n        Element artifactAttributeValueElement = doc.createElement(ExternalResultsXMLParser.TagNames.VALUE_ELEM.toString());\n        artifactAttributeValueElement.setTextContent(\"SampleInterestingFilesSet\");\n        artifactAttrElement.appendChild(artifactAttributeValueElement);\n\n        // Add an optional source module element to the artifct attribute \n        // element.\n        Element artifactAttrSourceElement = doc.createElement(ExternalResultsXMLParser.TagNames.SOURCE_MODULE_ELEM.toString());\n        artifactAttrSourceElement.setTextContent(moduleName);\n        artifactAttrElement.appendChild(artifactAttrSourceElement);\n\n        // Add an artifact element with a user-defined type. No file element is \n        // added to the artifact element, so the data source will be used as the \n        // default for the source file.\n        artifactElement = doc.createElement(ExternalResultsXMLParser.TagNames.ARTIFACT_ELEM.toString());\n        artifactElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), \"SampleArtifactType\");\n        artifactsListElement.appendChild(artifactElement);\n\n        // Add artifact attribute elements with user-defined types to the \n        // artifact element, adding value elements of assorted types.\n        for (int i = 0; i < 4; ++i) {\n            artifactAttrElement = doc.createElement(ExternalResultsXMLParser.TagNames.ATTRIBUTE_ELEM.toString());\n            artifactAttrElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), \"SampleArtifactAttributeType\");\n            artifactElement.appendChild(artifactAttrElement);\n            artifactAttributeValueElement = doc.createElement(ExternalResultsXMLParser.TagNames.VALUE_ELEM.toString());\n            switch (i) {\n                case 0:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), ExternalResultsXMLParser.TagNames.VALUE_TYPE_TEXT.toString());\n                    artifactAttributeValueElement.setTextContent(\"One\");\n                    break;\n                case 1:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), ExternalResultsXMLParser.TagNames.VALUE_TYPE_INT32.toString());\n                    artifactAttributeValueElement.setTextContent(\"2\");\n                    break;\n                case 2:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), ExternalResultsXMLParser.TagNames.VALUE_TYPE_INT64.toString());\n                    artifactAttributeValueElement.setTextContent(\"3\");\n                    break;\n                case 3:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXMLParser.TagNames.TYPE_ATTR.toString(), ExternalResultsXMLParser.TagNames.VALUE_TYPE_DOUBLE.toString());\n                    artifactAttributeValueElement.setTextContent(\"4.0\");\n                    break;\n            }\n            artifactAttrElement.appendChild(artifactAttributeValueElement);\n        }\n\n        // Add a reports list element to the root element.\n        Element reportsListElement = doc.createElement(ExternalResultsXMLParser.TagNames.REPORTS_LIST_ELEM.toString());\n        rootElement.appendChild(reportsListElement);\n\n        // Add a report element to the reports list element.\n        Element reportElement = doc.createElement(ExternalResultsXMLParser.TagNames.REPORT_ELEM.toString());\n        reportsListElement.appendChild(reportElement);\n\n        // Add the required display name element to the report element.\n        Element reportDisplayNameElement = doc.createElement(ExternalResultsXMLParser.TagNames.DISPLAY_NAME_ELEM.toString());\n        reportDisplayNameElement.setTextContent(\"Sample Report\");\n        reportElement.appendChild(reportDisplayNameElement);\n\n        // Add the required local path element to the report element.\n        Element reportPathElement = doc.createElement(ExternalResultsXMLParser.TagNames.LOCAL_PATH_ELEM.toString());\n        reportPathElement.setTextContent(reportPath);\n        reportElement.appendChild(reportPathElement);\n\n        // Add a derived files list element to the root element.\n        Element derivedFilesListElement = doc.createElement(ExternalResultsXMLParser.TagNames.DERIVED_FILES_LIST_ELEM.toString());\n        rootElement.appendChild(derivedFilesListElement);\n\n        // Add derived file elements to the derived files list element. Each \n        // file element gets a required absolute path element and one gets an \n        // optional parent file path element. If the parent file path is not \n        // supplied, the data source root directory is used as the default \n        // parent.\n        Element parentPathElement = null;\n        for (String filePath : derivedFilePaths) {\n            Element derivedFileElement = doc.createElement(ExternalResultsXMLParser.TagNames.DERIVED_FILE_ELEM.toString());\n            derivedFilesListElement.appendChild(derivedFileElement);\n            Element localPathElement = doc.createElement(ExternalResultsXMLParser.TagNames.LOCAL_PATH_ELEM.toString());\n            localPathElement.setTextContent(filePath);\n            derivedFileElement.appendChild(localPathElement);\n            if (parentPathElement == null) {\n                parentPathElement = doc.createElement(ExternalResultsXMLParser.TagNames.PARENT_PATH_ELEM.toString());\n                parentPathElement.setTextContent(dataSourcePath);\n                derivedFileElement.appendChild(parentPathElement);\n            }\n        }\n\n        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n        Transformer transformer = transformerFactory.newTransformer();\n        DOMSource source = new DOMSource(doc);\n        StreamResult result = new StreamResult(new File(resultsFilePath));\n        transformer.transform(source, result);\n    }","id":92081,"modified_method":"private void generateSimulatedResultsFile(List<String> derivedFilePaths, String reportPath, String resultsFilePath) throws ParserConfigurationException, TransformerConfigurationException, TransformerException {\n        // Create the XML DOM document and the root element.\n        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n        Document doc = docBuilder.newDocument();\n        Element rootElement = doc.createElement(ExternalResultsXMLParser.TagNames.ROOT_ELEM.toString());\n        doc.appendChild(rootElement);\n\n        // Add a derived files list element to the root element.\n        Element derivedFilesListElement = doc.createElement(ExternalResultsXMLParser.TagNames.DERIVED_FILES_LIST_ELEM.toString());\n        rootElement.appendChild(derivedFilesListElement);\n\n        // Add derived file elements to the derived files list element. Each \n        // file element gets required local path and parent file child elements.\n        // Note that the local path of the derived file must be to a location in\n        // a subdirectory of the case directory and the parent file must be \n        // specified using the path format used in the case database.\n        for (int i = 0; i < derivedFilePaths.size(); ++i) {\n            String filePath = derivedFilePaths.get(i);\n            Element derivedFileElement = doc.createElement(ExternalResultsXMLParser.TagNames.DERIVED_FILE_ELEM.toString());\n            derivedFilesListElement.appendChild(derivedFileElement);\n            Element localPathElement = doc.createElement(ExternalResultsXMLParser.TagNames.LOCAL_PATH_ELEM.toString());\n            localPathElement.setTextContent(filePath);\n            derivedFileElement.appendChild(localPathElement);\n            Element parentPathElement = doc.createElement(ExternalResultsXMLParser.TagNames.PARENT_FILE_ELEM.toString());\n            if (i == 0) {\n                parentPathElement.setTextContent(this.fileInCaseDatabase);\n            } else {\n                parentPathElement.setTextContent(this.derivedFileInCaseDatabase);\n            }\n            derivedFileElement.appendChild(parentPathElement);\n        }\n\n        // Add an artifacts list element to the root element.\n        Element artifactsListElement = doc.createElement(ExternalResultsXMLParser.TagNames.ARTIFACTS_LIST_ELEM.toString());\n        rootElement.appendChild(artifactsListElement);\n\n        // Add an artifact element to the artifacts list element with the required\n        // artifact type attribute. A standard artifact type is used as the type \n        // attribute of this artifact element.\n        Element artifactElement = doc.createElement(ExternalResultsXMLParser.TagNames.ARTIFACT_ELEM.toString());\n        artifactElement.setAttribute(ExternalResultsXMLParser.AttributeNames.TYPE_ATTR.toString(), ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT.getLabel());\n        artifactsListElement.appendChild(artifactElement);\n\n        // Add the required source file element to the artifact element. Note \n        // that source file must be either the local path of a derived file or a \n        // file in the case database.\n        Element fileElement = doc.createElement(ExternalResultsXMLParser.TagNames.SOURCE_FILE_ELEM.toString());\n        fileElement.setTextContent(this.fileInCaseDatabase);\n        artifactElement.appendChild(fileElement);\n\n        // Add an artifact attribute element to the artifact element. A standard \n        // artifact attribute type is used as the required type XML attribute of \n        // the artifact attribute element.\n        Element artifactAttrElement = doc.createElement(ExternalResultsXMLParser.TagNames.ATTRIBUTE_ELEM.toString());\n        artifactAttrElement.setAttribute(ExternalResultsXMLParser.AttributeNames.TYPE_ATTR.toString(), ATTRIBUTE_TYPE.TSK_SET_NAME.getLabel());\n        artifactElement.appendChild(artifactAttrElement);\n\n        // Add the required value element to the artifact attribute element, \n        // with an optional type XML attribute of ExternalXML.VALUE_TYPE_TEXT, \n        // which is the default.        \n        Element artifactAttributeValueElement = doc.createElement(ExternalResultsXMLParser.TagNames.VALUE_ELEM.toString());\n        artifactAttributeValueElement.setTextContent(\"SampleInterestingFilesSet\");\n        artifactAttrElement.appendChild(artifactAttributeValueElement);\n\n        // Add an optional source module element to the artifact attribute \n        // element.\n        Element artifactAttrSourceElement = doc.createElement(ExternalResultsXMLParser.TagNames.SOURCE_MODULE_ELEM.toString());\n        artifactAttrSourceElement.setTextContent(moduleName);\n        artifactAttrElement.appendChild(artifactAttrSourceElement);\n\n        // Add an artifact element with a user-defined type.\n        artifactElement = doc.createElement(ExternalResultsXMLParser.TagNames.ARTIFACT_ELEM.toString());\n        artifactElement.setAttribute(ExternalResultsXMLParser.AttributeNames.TYPE_ATTR.toString(), \"SampleArtifactType\");\n        artifactsListElement.appendChild(artifactElement);\n\n        // Add the required source file element.\n        fileElement = doc.createElement(ExternalResultsXMLParser.TagNames.SOURCE_FILE_ELEM.toString());\n        fileElement.setTextContent(this.derivedFileInCaseDatabase);\n        artifactElement.appendChild(fileElement);\n\n        // Add artifact attribute elements with user-defined types to the \n        // artifact element, adding value elements of assorted types.\n        for (int i = 0; i < 4; ++i) {\n            artifactAttrElement = doc.createElement(ExternalResultsXMLParser.TagNames.ATTRIBUTE_ELEM.toString());\n            artifactAttrElement.setAttribute(ExternalResultsXMLParser.AttributeNames.TYPE_ATTR.toString(), \"SampleArtifactAttributeType\");\n            artifactElement.appendChild(artifactAttrElement);\n            artifactAttributeValueElement = doc.createElement(ExternalResultsXMLParser.TagNames.VALUE_ELEM.toString());\n            switch (i) {\n                case 0:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXMLParser.AttributeNames.TYPE_ATTR.toString(), ExternalResultsXMLParser.AttributeValues.VALUE_TYPE_TEXT.toString());\n                    artifactAttributeValueElement.setTextContent(\"One\");\n                    break;\n                case 1:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXMLParser.AttributeNames.TYPE_ATTR.toString(), ExternalResultsXMLParser.AttributeValues.VALUE_TYPE_INT32.toString());\n                    artifactAttributeValueElement.setTextContent(\"2\");\n                    break;\n                case 2:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXMLParser.AttributeNames.TYPE_ATTR.toString(), ExternalResultsXMLParser.AttributeValues.VALUE_TYPE_INT64.toString());\n                    artifactAttributeValueElement.setTextContent(\"3\");\n                    break;\n                case 3:\n                    artifactAttributeValueElement.setAttribute(ExternalResultsXMLParser.AttributeNames.TYPE_ATTR.toString(), ExternalResultsXMLParser.AttributeValues.VALUE_TYPE_DOUBLE.toString());\n                    artifactAttributeValueElement.setTextContent(\"4.0\");\n                    break;\n            }\n            artifactAttrElement.appendChild(artifactAttributeValueElement);\n        }\n\n        // Add a reports list element to the root element.\n        Element reportsListElement = doc.createElement(ExternalResultsXMLParser.TagNames.REPORTS_LIST_ELEM.toString());\n        rootElement.appendChild(reportsListElement);\n\n        // Add a report element to the reports list element.\n        Element reportElement = doc.createElement(ExternalResultsXMLParser.TagNames.REPORT_ELEM.toString());\n        reportsListElement.appendChild(reportElement);\n\n        // Add the required display name element to the report element.\n        Element reportDisplayNameElement = doc.createElement(ExternalResultsXMLParser.TagNames.DISPLAY_NAME_ELEM.toString());\n        reportDisplayNameElement.setTextContent(\"Sample Report\");\n        reportElement.appendChild(reportDisplayNameElement);\n\n        // Add the required local path element to the report element. Note that\n        // the local path must be an absolute path to a location in a \n        // subdirectory of the case direcotry.\n        Element reportPathElement = doc.createElement(ExternalResultsXMLParser.TagNames.LOCAL_PATH_ELEM.toString());\n        reportPathElement.setTextContent(reportPath);\n        reportElement.appendChild(reportPathElement);\n\n        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n        Transformer transformer = transformerFactory.newTransformer();\n        DOMSource source = new DOMSource(doc);\n        StreamResult result = new StreamResult(new File(resultsFilePath));\n        transformer.transform(source, result);\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void generateFile(String fileName, byte[] fileContents) throws IOException {\n        String filePath = outputDirPath + File.separator + fileName;\n        File file = new File(filePath);\n        if (!file.exists()) {\n            file.createNewFile();\n        }\n        try (FileOutputStream fileStream = new FileOutputStream(file)) {\n            fileStream.write(fileContents);\n            fileStream.flush();\n        }\n    }","id":92082,"modified_method":"private String generateFile(String fileName, byte[] fileContents) throws IOException {\n        String filePath = outputDirPath + File.separator + fileName;\n        File file = new File(filePath);\n        if (!file.exists()) {\n            file.createNewFile();\n        }\n        try (FileOutputStream fileStream = new FileOutputStream(file)) {\n            fileStream.write(fileContents);\n            fileStream.flush();\n        }\n        return filePath;\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private String generateSimulatedReport() throws IOException {\n        String reportFileName = String.format(\"job_%d_report.txt\", jobId);\n        String reportContents = \"This is a simulated report.\";\n        generateFile(reportFileName, reportContents.getBytes());\n        return outputDirPath + File.separator + reportFileName;\n    }","id":92083,"modified_method":"private String generateSimulatedReport() throws IOException {\n        String reportFileName = String.format(\"job_%d_report.txt\", jobId);\n        String reportContents = \"This is a simulated report.\";\n        return generateFile(reportFileName, reportContents.getBytes());\n    }","commit_id":"e4b1d9a9c9168b6e89cb027a92a96530273b8d80","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public Object postProcessAfterInitialization(Object bean, String beanName)\n\t\tthrows BeansException {\n\n\t\tif (bean instanceof ServiceBeanIdentifier) {\n\t\t\t((ServiceBeanIdentifier)bean).setIdentifier(beanName);\n\t\t}\n\t\telse if (beanName.endsWith(\"Service\")){\n\t\t\t_log.error(\"Service bean \" + beanName + \" does not implement \" +\n\t\t\t\tServiceBeanIdentifier.class.getName() + \" interface. This \"\n\t\t\t\t+ \"will make it unable to be invoked across cluster.\");\n\t\t}\n\n\t\treturn bean;\n\t}","id":92084,"modified_method":"public Object postProcessAfterInitialization(Object bean, String beanName)\n\t\tthrows BeansException {\n\n\t\tif (bean instanceof IdentifiableBean) {\n\t\t\tIdentifiableBean identifiableBean = (IdentifiableBean)bean;\n\n\t\t\tidentifiableBean.setBeanIdentifier(beanName);\n\t\t}\n\t\telse if (beanName.endsWith(\"Service\")){\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\tbeanName + \" should implement \" +\n\t\t\t\t\t\tIdentifiableBean.class.getName() +\n\t\t\t\t\t\t\t\" for \" + ClusterableAdvice.class.getName());\n\t\t\t}\n\t\t}\n\n\t\treturn bean;\n\t}","commit_id":"acc725d7c9226700625e11be314aea94d6979f81","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setServiceBeanIdentifier(String serviceBeanIdentifier) {\n\t\t_serviceBeanIdentifier = serviceBeanIdentifier;\n\t}","id":92085,"modified_method":"public void setBeanIdentifier(String beanIdentifier) {\n\t\t_beanIdentifier = beanIdentifier;\n\t}","commit_id":"acc725d7c9226700625e11be314aea94d6979f81","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getServiceBeanIdentifier() {\n\t\treturn _serviceBeanIdentifier;\n\t}","id":92086,"modified_method":"public String getBeanIdentifier() {\n\t\treturn _beanIdentifier;\n\t}","commit_id":"acc725d7c9226700625e11be314aea94d6979f81","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Object invoke(\n\t\t\tString servletContextName, String serviceBeanIdentifier,\n\t\t\tMethodHandler methodHandler)\n\t\tthrows Exception {\n\n\t\tif (servletContextName == null) {\n\t\t\tif (Validator.isNull(serviceBeanIdentifier)) {\n\t\t\t\treturn methodHandler.invoke(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn methodHandler.invoke(\n\t\t\t\t\tPortalBeanLocatorUtil.locate(serviceBeanIdentifier));\n\t\t\t}\n\t\t}\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\ttry {\n\t\t\tClassLoader classLoader =\n\t\t\t\t(ClassLoader)PortletBeanLocatorUtil.locate(\n\t\t\t\t\tservletContextName, \"portletClassLoader\");\n\n\t\t\tcurrentThread.setContextClassLoader(classLoader);\n\n\t\t\tif (Validator.isNull(serviceBeanIdentifier)) {\n\t\t\t\treturn methodHandler.invoke(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn methodHandler.invoke(\n\t\t\t\t\tPortletBeanLocatorUtil.locate(\n\t\t\t\t\t\tservletContextName, serviceBeanIdentifier));\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e) {\n\t\t\tthrow e;\n\t\t}\n\t\tfinally {\n\t\t\tcurrentThread.setContextClassLoader(contextClassLoader);\n\t\t}\n\t}","id":92087,"modified_method":"protected Object invoke(\n\t\t\tString servletContextName, String beanIdentifier,\n\t\t\tMethodHandler methodHandler)\n\t\tthrows Exception {\n\n\t\tif (servletContextName == null) {\n\t\t\tif (Validator.isNull(beanIdentifier)) {\n\t\t\t\treturn methodHandler.invoke(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject bean = PortalBeanLocatorUtil.locate(beanIdentifier);\n\n\t\t\t\treturn methodHandler.invoke(bean);\n\t\t\t}\n\t\t}\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\ttry {\n\t\t\tClassLoader classLoader =\n\t\t\t\t(ClassLoader)PortletBeanLocatorUtil.locate(\n\t\t\t\t\tservletContextName, \"portletClassLoader\");\n\n\t\t\tcurrentThread.setContextClassLoader(classLoader);\n\n\t\t\tif (Validator.isNull(beanIdentifier)) {\n\t\t\t\treturn methodHandler.invoke(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject bean = PortletBeanLocatorUtil.locate(\n\t\t\t\t\tservletContextName, beanIdentifier);\n\n\t\t\t\treturn methodHandler.invoke(bean);\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e) {\n\t\t\tthrow e;\n\t\t}\n\t\tfinally {\n\t\t\tcurrentThread.setContextClassLoader(contextClassLoader);\n\t\t}\n\t}","commit_id":"acc725d7c9226700625e11be314aea94d6979f81","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processClusterRequest(\n\t\tClusterRequest clusterRequest, org.jgroups.Address sourceAddress,\n\t\torg.jgroups.Address localAddress) {\n\n\t\tClusterMessageType clusterMessageType =\n\t\t\tclusterRequest.getClusterMessageType();\n\n\t\tClusterNodeResponse clusterNodeResponse = new ClusterNodeResponse();\n\n\t\ttry {\n\t\t\tClusterNode localClusterNode =\n\t\t\t\t_clusterExecutorImpl.getLocalClusterNode();\n\n\t\t\tclusterNodeResponse.setClusterNode(localClusterNode);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tclusterNodeResponse.setException(e);\n\t\t}\n\n\t\tif (clusterMessageType.equals(ClusterMessageType.NOTIFY) ||\n\t\t\tclusterMessageType.equals(ClusterMessageType.UPDATE)) {\n\n\t\t\tClusterNode originatingClusterNode =\n\t\t\t\tclusterRequest.getOriginatingClusterNode();\n\n\t\t\tif (originatingClusterNode != null) {\n\t\t\t\t_clusterExecutorImpl.memberJoined(\n\t\t\t\t\tnew AddressImpl(sourceAddress), originatingClusterNode);\n\n\t\t\t\tclusterNodeResponse.setClusterMessageType(clusterMessageType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Content of notify message does not contain cluster \" +\n\t\t\t\t\t\t\t\"node information\");\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tclusterNodeResponse.setClusterMessageType(\n\t\t\t\tClusterMessageType.EXECUTE);\n\t\t\tclusterNodeResponse.setMulticast(clusterRequest.isMulticast());\n\t\t\tclusterNodeResponse.setUuid(clusterRequest.getUuid());\n\n\t\t\tMethodHandler methodHandler = clusterRequest.getMethodHandler();\n\n\t\t\tif (methodHandler != null) {\n\t\t\t\ttry {\n\t\t\t\t\tClusterInvokeThreadLocal.setEnabled(false);\n\n\t\t\t\t\tObject returnValue = invoke(\n\t\t\t\t\t\tclusterRequest.getServletContextName(),\n\t\t\t\t\t\tclusterRequest.getServiceBeanIdentifier(),\n\t\t\t\t\t\tmethodHandler);\n\n\t\t\t\t\tif (returnValue instanceof Serializable) {\n\t\t\t\t\t\tclusterNodeResponse.setResult(returnValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (returnValue != null) {\n\t\t\t\t\t\tclusterNodeResponse.setException(\n\t\t\t\t\t\t\tnew ClusterException(\n\t\t\t\t\t\t\t\t\"Return value is not serializable\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tclusterNodeResponse.setException(e);\n\n\t\t\t\t\t_log.error(\"Failed to invoke method \" + methodHandler, e);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tClusterInvokeThreadLocal.setEnabled(true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclusterNodeResponse.setException(\n\t\t\t\t\tnew ClusterException(\n\t\t\t\t\t\t\"Payload is not of type \" +\n\t\t\t\t\t\t\tMethodHandler.class.getName()));\n\t\t\t}\n\t\t}\n\n\t\tChannel controlChannel = _clusterExecutorImpl.getControlChannel();\n\n\t\ttry {\n\t\t\tcontrolChannel.send(\n\t\t\t\tsourceAddress, localAddress, clusterNodeResponse);\n\t\t}\n\t\tcatch (ChannelException ce) {\n\t\t\t_log.error(\n\t\t\t\t\"Unable to send response message \" + clusterNodeResponse, ce);\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\t_log.error(t, t);\n\t\t}\n\t}","id":92088,"modified_method":"protected void processClusterRequest(\n\t\tClusterRequest clusterRequest, org.jgroups.Address sourceAddress,\n\t\torg.jgroups.Address localAddress) {\n\n\t\tClusterMessageType clusterMessageType =\n\t\t\tclusterRequest.getClusterMessageType();\n\n\t\tClusterNodeResponse clusterNodeResponse = new ClusterNodeResponse();\n\n\t\ttry {\n\t\t\tClusterNode localClusterNode =\n\t\t\t\t_clusterExecutorImpl.getLocalClusterNode();\n\n\t\t\tclusterNodeResponse.setClusterNode(localClusterNode);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tclusterNodeResponse.setException(e);\n\t\t}\n\n\t\tif (clusterMessageType.equals(ClusterMessageType.NOTIFY) ||\n\t\t\tclusterMessageType.equals(ClusterMessageType.UPDATE)) {\n\n\t\t\tClusterNode originatingClusterNode =\n\t\t\t\tclusterRequest.getOriginatingClusterNode();\n\n\t\t\tif (originatingClusterNode != null) {\n\t\t\t\t_clusterExecutorImpl.memberJoined(\n\t\t\t\t\tnew AddressImpl(sourceAddress), originatingClusterNode);\n\n\t\t\t\tclusterNodeResponse.setClusterMessageType(clusterMessageType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Content of notify message does not contain cluster \" +\n\t\t\t\t\t\t\t\"node information\");\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tclusterNodeResponse.setClusterMessageType(\n\t\t\t\tClusterMessageType.EXECUTE);\n\t\t\tclusterNodeResponse.setMulticast(clusterRequest.isMulticast());\n\t\t\tclusterNodeResponse.setUuid(clusterRequest.getUuid());\n\n\t\t\tMethodHandler methodHandler = clusterRequest.getMethodHandler();\n\n\t\t\tif (methodHandler != null) {\n\t\t\t\ttry {\n\t\t\t\t\tClusterInvokeThreadLocal.setEnabled(false);\n\n\t\t\t\t\tObject returnValue = invoke(\n\t\t\t\t\t\tclusterRequest.getServletContextName(),\n\t\t\t\t\t\tclusterRequest.getBeanIdentifier(), methodHandler);\n\n\t\t\t\t\tif (returnValue instanceof Serializable) {\n\t\t\t\t\t\tclusterNodeResponse.setResult(returnValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (returnValue != null) {\n\t\t\t\t\t\tclusterNodeResponse.setException(\n\t\t\t\t\t\t\tnew ClusterException(\n\t\t\t\t\t\t\t\t\"Return value is not serializable\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tclusterNodeResponse.setException(e);\n\n\t\t\t\t\t_log.error(\"Failed to invoke method \" + methodHandler, e);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tClusterInvokeThreadLocal.setEnabled(true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclusterNodeResponse.setException(\n\t\t\t\t\tnew ClusterException(\n\t\t\t\t\t\t\"Payload is not of type \" +\n\t\t\t\t\t\t\tMethodHandler.class.getName()));\n\t\t\t}\n\t\t}\n\n\t\tChannel controlChannel = _clusterExecutorImpl.getControlChannel();\n\n\t\ttry {\n\t\t\tcontrolChannel.send(\n\t\t\t\tsourceAddress, localAddress, clusterNodeResponse);\n\t\t}\n\t\tcatch (ChannelException ce) {\n\t\t\t_log.error(\n\t\t\t\t\"Unable to send response message \" + clusterNodeResponse, ce);\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\t_log.error(t, t);\n\t\t}\n\t}","commit_id":"acc725d7c9226700625e11be314aea94d6979f81","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void afterReturning(MethodInvocation methodInvocation, Object result)\n\t\tthrows Throwable {\n\n\t\tif (!ClusterInvokeThreadLocal.isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tMethodTargetClassKey methodTargetClassKey = buildMethodTargetClassKey(\n\t\t\tmethodInvocation);\n\n\t\tClusterable clusterable = findAnnotation(methodTargetClassKey);\n\n\t\tif (clusterable == _nullClusterable) {\n\t\t\treturn;\n\t\t}\n\n\t\tObject targetServiceBean = methodInvocation.getThis();\n\t\tif (!(targetServiceBean instanceof ServiceBeanIdentifier)) {\n\t\t\t_log.error(\"ServiceBean \" + targetServiceBean.getClass().getName() +\n\t\t\t\t\" does not implement interface \" +\n\t\t\t\tServiceBeanIdentifier.class.getName() +\n\t\t\t\t\", unable to proceed this request accross cluster.\");\n\t\t\treturn;\n\t\t}\n\n\t\tString serviceBeanIdentifier =\n\t\t\t((ServiceBeanIdentifier)targetServiceBean).getIdentifier();\n\n\t\tMethod method = methodTargetClassKey.getMethod();\n\n\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\tmethod, methodInvocation.getArguments());\n\n\t\tClusterRequest clusterRequest = ClusterRequest.createMulticastRequest(\n\t\t\tmethodHandler, true);\n\n\t\tclusterRequest.setServiceBeanIdentifier(serviceBeanIdentifier);\n\t\tclusterRequest.setServletContextName(_servletContextName);\n\n\t\tClusterExecutorUtil.execute(clusterRequest);\n\t}","id":92089,"modified_method":"public void afterReturning(MethodInvocation methodInvocation, Object result)\n\t\tthrows Throwable {\n\n\t\tif (!ClusterInvokeThreadLocal.isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tMethodTargetClassKey methodTargetClassKey = buildMethodTargetClassKey(\n\t\t\tmethodInvocation);\n\n\t\tClusterable clusterable = findAnnotation(methodTargetClassKey);\n\n\t\tif (clusterable == _nullClusterable) {\n\t\t\treturn;\n\t\t}\n\n\t\tObject targetBean = methodInvocation.getThis();\n\n\t\tif (!(targetBean instanceof IdentifiableBean)) {\n\t\t\t_log.error(\n\t\t\t\t\"Not clustering calls for \" + targetBean.getClass().getName() +\n\t\t\t\t\t\" because it does not implement \" +\n\t\t\t\t\t\tIdentifiableBean.class.getName());\n\n\t\t\treturn;\n\t\t}\n\n\t\tMethod method = methodTargetClassKey.getMethod();\n\n\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\tmethod, methodInvocation.getArguments());\n\n\t\tClusterRequest clusterRequest = ClusterRequest.createMulticastRequest(\n\t\t\tmethodHandler, true);\n\n\t\tIdentifiableBean identifiableBean = (IdentifiableBean)targetBean;\n\n\t\tclusterRequest.setBeanIdentifier(identifiableBean.getBeanIdentifier());\n\n\t\tclusterRequest.setServletContextName(_servletContextName);\n\n\t\tClusterExecutorUtil.execute(clusterRequest);\n\t}","commit_id":"acc725d7c9226700625e11be314aea94d6979f81","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setIdentifier(String identifier) {\n\t\t_identifier = identifier;\n\t}","id":92090,"modified_method":"public void setBeanIdentifier(String beanIdentifier) {\n\t\t_beanIdentifier = beanIdentifier;\n\t}","commit_id":"acc725d7c9226700625e11be314aea94d6979f81","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getIdentifier() {\n\t\treturn _identifier;\n\t}","id":92091,"modified_method":"public String getBeanIdentifier() {\n\t\treturn _beanIdentifier;\n\t}","commit_id":"acc725d7c9226700625e11be314aea94d6979f81","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getIdentifier() {\n\t\treturn identifier;\n\t}","id":92092,"modified_method":"public String getBeanIdentifier() {\n\t\treturn _beanIdentifier;\n\t}","commit_id":"acc725d7c9226700625e11be314aea94d6979f81","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setIdentifier(String identifier) {\n\t\tthis.identifier = identifier;\n\t}","id":92093,"modified_method":"public void setBeanIdentifier(String beanIdentifier) {\n\t\t_beanIdentifier = beanIdentifier;\n\t}","commit_id":"acc725d7c9226700625e11be314aea94d6979f81","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getIdentifier() {\n\t\treturn _identifier;\n\t}","id":92094,"modified_method":"public String getBeanIdentifier() {\n\t\treturn _beanIdentifier;\n\t}","commit_id":"acc725d7c9226700625e11be314aea94d6979f81","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setIdentifier(String identifier) {\n\t\t_identifier = identifier;\n\t}","id":92095,"modified_method":"public void setBeanIdentifier(String beanIdentifier) {\n\t\t_beanIdentifier = beanIdentifier;\n\t}","commit_id":"acc725d7c9226700625e11be314aea94d6979f81","url":"https://github.com/liferay/liferay-portal"},{"original_method":"InputStream getResourceAsStream(String path, boolean locate)\n\t\tthrows IOException, ServletException {\n\t\t\t//Note: _webctx will handle the renaming for debugJS (.src.js)\n\t\t\treturn _webctx.getResourceAsStream(\n\t\t\t\tlocate ?\n\t\t\t\t\tServlets.locate(_webctx.getServletContext(),\n\t\t\t\t\t\t_request, path, _webctx.getLocator()):\n\t\t\t\tpath);\n\t\t}","id":92096,"modified_method":"InputStream getResourceAsStream(String path, boolean locate)\n\t\tthrows IOException, ServletException {\n\t\t\tif (locate)\n\t\t\t\tpath = Servlets.locate(_webctx.getServletContext(),\n\t\t\t\t\t_request, path, _webctx.getLocator());\n\n\t\t\tif (_cache.getCheckPeriod() >= 0) {\n\t\t\t\t//Due to Web server might cache the result, we use URL if possible\n\t\t\t\ttry {\n\t\t\t\t\tURL url = _webctx.getResource(path);\n\t\t\t\t\tif (url != null)\n\t\t\t\t\t\treturn url.openStream();\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\tlog.warningBriefly(\"Unable to read from URL: \"+path, ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Note: _webctx will handle the renaming for debugJS (.src.js)\n\t\t\treturn _webctx.getResourceAsStream(path);\n\t\t}","commit_id":"c53f8e7cdc6c1fe823e4cfd4aaf7de9251f142ac","url":"https://github.com/zkoss/zk"},{"original_method":"public void service(HttpServletRequest req, HttpServletResponse res)\n\t\tthrows IOException, ServletException {\n\n\t\tString contentType = req.getHeader(HttpHeaders.CONTENT_TYPE);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Content type \" + contentType);\n\t\t}\n\n\t\tif ((contentType != null) &&\n\t\t\t(contentType.startsWith(ContentTypes.MULTIPART_FORM_DATA))) {\n\n\t\t\treq = new UploadServletRequest(req);\n\t\t}\n\n\t\tWorkflowComponentImpl workflowComponentImpl =\n\t\t\tnew WorkflowComponentImpl();\n\n\t\tString result = workflowComponentImpl.process(req);\n\n\t\tres.setContentType(\"text/xml\");\n\n\t\ttry {\n\t\t\tServletResponseUtil.write(res, result);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\t\t}\n\t}","id":92097,"modified_method":"public void service(HttpServletRequest req, HttpServletResponse res)\n\t\tthrows IOException, ServletException {\n\n\t\ttry {\n\t\t\tString contentType = req.getHeader(HttpHeaders.CONTENT_TYPE);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Content type \" + contentType);\n\t\t\t}\n\n\t\t\tif ((contentType != null) &&\n\t\t\t\t(contentType.startsWith(ContentTypes.MULTIPART_FORM_DATA))) {\n\n\t\t\t\treq = new UploadServletRequest(req);\n\t\t\t}\n\n\t\t\tWorkflowComponentImpl workflowComponentImpl =\n\t\t\t\tnew WorkflowComponentImpl();\n\n\t\t\tString result = workflowComponentImpl.process(req);\n\n\t\t\tres.setContentType(\"text/xml\");\n\n\t\t\tServletResponseUtil.write(res, result);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tres.sendError(\n\t\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n\t\t}\n\t}","commit_id":"516800394763434f9398f24dead8b660c9cda816","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String parse(ClassLoader classLoader, String s) {\n\t\tint x = s.indexOf(\"${\");\n\n\t\tif (x == -1) {\n\t\t\treturn s;\n\t\t}\n\n\t\tList<String> replaceFrom = new ArrayList<>();\n\t\tList<String> replaceWith = new ArrayList<>();\n\n\t\twhile (true) {\n\t\t\tif (x == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint y = s.indexOf(\"}\", x);\n\n\t\t\tif (y == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tString javaSnippet = s.substring(x + 2, y);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Java snippet \" + javaSnippet);\n\t\t\t}\n\n\t\t\tString className = _getClassName(javaSnippet);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Class name \" + className);\n\t\t\t}\n\n\t\t\tif (className == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tClass<?> clazz = null;\n\n\t\t\ttry {\n\t\t\t\tclazz = classLoader.loadClass(className);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"Unable to load class \" + className);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tString fieldName = _getFieldName(javaSnippet);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Field name \" + fieldName);\n\t\t\t}\n\n\t\t\tif (fieldName == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tString fieldValue = null;\n\n\t\t\ttry {\n\t\t\t\tField field = clazz.getField(fieldName);\n\n\t\t\t\tfieldValue = String.valueOf(field.get(null));\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Field value \" + fieldValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"Unable to load field \" + fieldName);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treplaceFrom.add(\"${\".concat(javaSnippet).concat(\"}\"));\n\t\t\treplaceWith.add(fieldValue);\n\n\t\t\tx = s.indexOf(\"${\", y);\n\t\t}\n\n\t\tif (replaceFrom.isEmpty()) {\n\t\t\treturn s;\n\t\t}\n\n\t\treturn StringUtil.replace(\n\t\t\ts, replaceFrom.toArray(new String[replaceFrom.size()]),\n\t\t\treplaceWith.toArray(new String[replaceWith.size()]));\n\t}","id":92098,"modified_method":"public static String parse(ClassLoader classLoader, String s) {\n\t\tint x = s.indexOf(\"${\");\n\n\t\tif (x == -1) {\n\t\t\treturn s;\n\t\t}\n\n\t\tList<String> replaceFrom = new ArrayList<>();\n\t\tList<String> replaceWith = new ArrayList<>();\n\n\t\twhile (true) {\n\t\t\tif (x == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint y = s.indexOf(\"}\", x);\n\n\t\t\tif (y == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tString javaSnippet = s.substring(x + 2, y);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Java snippet \" + javaSnippet);\n\t\t\t}\n\n\t\t\tString className = _getClassName(javaSnippet);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Class name \" + className);\n\t\t\t}\n\n\t\t\tif (className == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tClass<?> clazz = null;\n\n\t\t\ttry {\n\t\t\t\tclazz = classLoader.loadClass(className);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to load class \" + className, e);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tString fieldName = _getFieldName(javaSnippet);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Field name \" + fieldName);\n\t\t\t}\n\n\t\t\tif (fieldName == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tString fieldValue = null;\n\n\t\t\ttry {\n\t\t\t\tField field = clazz.getField(fieldName);\n\n\t\t\t\tfieldValue = String.valueOf(field.get(null));\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Field value \" + fieldValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to load field \" + fieldName, e);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treplaceFrom.add(\"${\".concat(javaSnippet).concat(\"}\"));\n\t\t\treplaceWith.add(fieldValue);\n\n\t\t\tx = s.indexOf(\"${\", y);\n\t\t}\n\n\t\tif (replaceFrom.isEmpty()) {\n\t\t\treturn s;\n\t\t}\n\n\t\treturn StringUtil.replace(\n\t\t\ts, replaceFrom.toArray(new String[replaceFrom.size()]),\n\t\t\treplaceWith.toArray(new String[replaceWith.size()]));\n\t}","commit_id":"4b79a21dd4268abd7fd3ca0eaf9f5b6f2adbc7c2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean hasGuestPermission(\n\t\t\tlong groupId, String name, String primKey, String actionId)\n\t\tthrows Exception {\n\n\t\tList<String> resourceActions = ResourceActionsUtil.getResourceActions(\n\t\t\tname);\n\n\t\tif (!resourceActions.contains(actionId)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (name.indexOf(CharPool.PERIOD) != -1) {\n\n\t\t\t// Check unsupported model actions\n\n\t\t\tList<String> actions =\n\t\t\t\tResourceActionsUtil.getModelResourceGuestUnsupportedActions(\n\t\t\t\t\tname);\n\n\t\t\tif (actions.contains(actionId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// Check unsupported portlet actions\n\n\t\t\tList<String> actions =\n\t\t\t\tResourceActionsUtil.getPortletResourceGuestUnsupportedActions(\n\t\t\t\t\tname);\n\n\t\t\tif (actions.contains(actionId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (groupId > 0) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tcompanyId = group.getCompanyId();\n\t\t}\n\n\t\ttry {\n\t\t\tif (ResourceBlockLocalServiceUtil.isSupported(name)) {\n\t\t\t\tResourceBlockIdsBag resourceBlockIdsBag =\n\t\t\t\t\tgetGuestResourceBlockIdsBag(companyId, groupId, name);\n\n\t\t\t\treturn ResourceBlockLocalServiceUtil.hasPermission(\n\t\t\t\t\tname, GetterUtil.getLong(primKey), actionId,\n\t\t\t\t\tresourceBlockIdsBag);\n\t\t\t}\n\n\t\t\tprimKey = fixLegacyPrimaryKey(companyId, name, primKey);\n\n\t\t\tList<Resource> resources = getResources(\n\t\t\t\tcompanyId, groupId, name, primKey, actionId);\n\n\t\t\treturn ResourceLocalServiceUtil.hasUserPermissions(\n\t\t\t\tdefaultUserId, groupId, resources, actionId,\n\t\t\t\tgetGuestUserRoleIds());\n\t\t}\n\t\tcatch (NoSuchResourcePermissionException nsrpe) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Someone may be trying to circumvent the permission checker: \" +\n\t\t\t\t\tnsrpe.getMessage(),\n\t\t\t\tnsrpe);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\treturn false;\n\t\t}\n\t}","id":92099,"modified_method":"protected boolean hasGuestPermission(\n\t\t\tlong groupId, String name, String primKey, String actionId)\n\t\tthrows Exception {\n\n\t\tList<String> resourceActions = ResourceActionsUtil.getResourceActions(\n\t\t\tname);\n\n\t\tif (!resourceActions.contains(actionId)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (name.indexOf(CharPool.PERIOD) != -1) {\n\n\t\t\t// Check unsupported model actions\n\n\t\t\tList<String> actions =\n\t\t\t\tResourceActionsUtil.getModelResourceGuestUnsupportedActions(\n\t\t\t\t\tname);\n\n\t\t\tif (actions.contains(actionId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// Check unsupported portlet actions\n\n\t\t\tList<String> actions =\n\t\t\t\tResourceActionsUtil.getPortletResourceGuestUnsupportedActions(\n\t\t\t\t\tname);\n\n\t\t\tif (actions.contains(actionId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (groupId > 0) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tcompanyId = group.getCompanyId();\n\t\t}\n\n\t\ttry {\n\t\t\tif (ResourceBlockLocalServiceUtil.isSupported(name)) {\n\t\t\t\tResourceBlockIdsBag resourceBlockIdsBag =\n\t\t\t\t\tgetGuestResourceBlockIdsBag(companyId, groupId, name);\n\n\t\t\t\treturn ResourceBlockLocalServiceUtil.hasPermission(\n\t\t\t\t\tname, GetterUtil.getLong(primKey), actionId,\n\t\t\t\t\tresourceBlockIdsBag);\n\t\t\t}\n\n\t\t\tprimKey = fixLegacyPrimaryKey(companyId, name, primKey);\n\n\t\t\tList<Resource> resources = getResources(\n\t\t\t\tcompanyId, groupId, name, primKey, actionId);\n\n\t\t\treturn ResourceLocalServiceUtil.hasUserPermissions(\n\t\t\t\tdefaultUserId, groupId, resources, actionId,\n\t\t\t\tgetGuestUserRoleIds());\n\t\t}\n\t\tcatch (NoSuchResourcePermissionException nsrpe) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Somebody is trying to circumvent permission framework \" +\n\t\t\t\t\t\"or there is a bug in permission framework caller: \" +\n\t\t\t\t\t\tnsrpe.getMessage(),\n\t\t\t\tnsrpe);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"a755d1e66d8fde96953fc9c0278adc0ac038dfdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String fixLegacyPrimaryKey(\n\t\tlong companyId, String name, String primKey) {\n\n\t\tif (((primKey.length() == 1) && (primKey.charAt(0) == 48)) ||\n\t\t\t(primKey.equals(String.valueOf(companyId)) &&\n\t\t\t !name.equals(Company.class.getName()))) {\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\tStringBundler sb = new StringBundler(9);\n\t\t\t\t\n\t\t\t\tsb.append(\"Using \");\n\t\t\t\tsb.append(name);\n\t\t\t\tsb.append(\" as the primary key instead of the legacy primary \");\n\t\t\t\tsb.append(\"key \");\n\t\t\t\tsb.append(primKey);\n\t\t\t\tsb.append(\" that was used for permission checking of \");\n\t\t\t\tsb.append(name);\n\t\t\t\tsb.append(\" in company \");\n\t\t\t\tsb.append(companyId);\n\n\t\t\t\t_log.warn(\n\t\t\t\t\tsb.toString(), new IllegalArgumentException(sb.toString()));\n\t\t\t}\n\n\t\t\treturn name;\n\t\t}\n\n\t\treturn primKey;\n\t}","id":92100,"modified_method":"protected String fixLegacyPrimaryKey(\n\t\tlong companyId, String name, String primKey) {\n\n\t\tif (((primKey.length() == 1) && (primKey.charAt(0) == 48)) ||\n\t\t\t(primKey.equals(String.valueOf(companyId)) &&\n\t\t\t !name.equals(Company.class.getName()))) {\n\n\t\t\tString message =\n\t\t\t\t\"Legacy primary key \" + primKey + \" was used for \" +\n\t\t\t\t\t\"permission checking of \" + name + \" in company \" +\n\t\t\t\t\tcompanyId + \". Please use \" + name + \" as the \" +\n\t\t\t\t\t\"primary key.\";\n\n\t\t\t_log.error(message, new IllegalArgumentException(message));\n\n\t\t\treturn name;\n\t\t}\n\n\t\treturn primKey;\n\t}","commit_id":"a755d1e66d8fde96953fc9c0278adc0ac038dfdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean hasUserPermissionImpl(\n\t\t\tlong groupId, String name, String primKey, long[] roleIds,\n\t\t\tString actionId)\n\t\tthrows Exception {\n\n\t\tStopWatch stopWatch = new StopWatch();\n\n\t\tstopWatch.start();\n\n\t\tif (isOmniadmin()) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (name.equals(Organization.class.getName())) {\n\t\t\tif (isOrganizationAdminImpl(GetterUtil.getLong(primKey))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (groupId > 0) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tcompanyId = group.getCompanyId();\n\t\t}\n\n\t\tprimKey = fixLegacyPrimaryKey(companyId, name, primKey);\n\n\t\ttry {\n\t\t\tboolean hasPermission = doCheckPermission(\n\t\t\t\tcompanyId, groupId, name, primKey, roleIds, actionId,\n\t\t\t\tstopWatch);\n\n\t\t\tif (hasPermission) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchResourcePermissionException nsrpe) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Someone may be trying to circumvent the permission checker: \" +\n\t\t\t\t\tnsrpe.getMessage(),\n\t\t\t\tnsrpe);\n\t\t}\n\n\t\tif (isCompanyAdminImpl(companyId)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isGroupAdminImpl(groupId)) {\n\t\t\tboolean hasLayoutManagerPermission = true;\n\n\t\t\t// Check if the layout manager has permission to do this action for\n\t\t\t// the current portlet\n\n\t\t\tif (Validator.isNotNull(name) && Validator.isNotNull(primKey) &&\n\t\t\t\tprimKey.contains(PortletConstants.LAYOUT_SEPARATOR)) {\n\n\t\t\t\thasLayoutManagerPermission =\n\t\t\t\t\tPortletPermissionUtil.hasLayoutManagerPermission(\n\t\t\t\t\t\tname, actionId);\n\t\t\t}\n\n\t\t\tif (hasLayoutManagerPermission) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":92101,"modified_method":"protected boolean hasUserPermissionImpl(\n\t\t\tlong groupId, String name, String primKey, long[] roleIds,\n\t\t\tString actionId)\n\t\tthrows Exception {\n\n\t\tStopWatch stopWatch = new StopWatch();\n\n\t\tstopWatch.start();\n\n\t\tif (isOmniadmin()) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (name.equals(Organization.class.getName())) {\n\t\t\tif (isOrganizationAdminImpl(GetterUtil.getLong(primKey))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (groupId > 0) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tcompanyId = group.getCompanyId();\n\t\t}\n\n\t\tprimKey = fixLegacyPrimaryKey(companyId, name, primKey);\n\n\t\ttry {\n\t\t\tboolean hasPermission = doCheckPermission(\n\t\t\t\tcompanyId, groupId, name, primKey, roleIds, actionId,\n\t\t\t\tstopWatch);\n\n\t\t\tif (hasPermission) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchResourcePermissionException nsrpe) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Somebody is trying to circumvent permission framework \" +\n\t\t\t\t\t\"or there is a bug in permission framework caller: \" +\n\t\t\t\t\t\tnsrpe.getMessage(),\n\t\t\t\tnsrpe);\n\t\t}\n\n\t\tif (isCompanyAdminImpl(companyId)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isGroupAdminImpl(groupId)) {\n\t\t\tboolean hasLayoutManagerPermission = true;\n\n\t\t\t// Check if the layout manager has permission to do this action for\n\t\t\t// the current portlet\n\n\t\t\tif (Validator.isNotNull(name) && Validator.isNotNull(primKey) &&\n\t\t\t\tprimKey.contains(PortletConstants.LAYOUT_SEPARATOR)) {\n\n\t\t\t\thasLayoutManagerPermission =\n\t\t\t\t\tPortletPermissionUtil.hasLayoutManagerPermission(\n\t\t\t\t\t\tname, actionId);\n\t\t\t}\n\n\t\t\tif (hasLayoutManagerPermission) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"a755d1e66d8fde96953fc9c0278adc0ac038dfdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Returns <code>true<\/code> if the roles have permission at the scope to\n\t * perform the action on the resources.\n\t *\n\t * <p>\n\t * Depending on the scope, the value of <code>primKey<\/code> will have\n\t * different meanings. For more information, see {@link\n\t * com.liferay.portal.model.impl.ResourcePermissionImpl}.\n\t * <\/p>\n\t *\n\t * @param  resources the resources\n\t * @param  roleIds the primary keys of the roles\n\t * @param  actionId the action ID\n\t * @return <code>true<\/code> if any one of the roles has permission to\n\t *         perform the action on any one of the resources;\n\t *         <code>false<\/code> otherwise\n\t */\n\t@Override\n\tpublic boolean hasResourcePermission(\n\t\t\tList<Resource> resources, long[] roleIds, String actionId)\n\t\tthrows PortalException {\n\n\t\tif (roleIds.length == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint size = resources.size();\n\n\t\tif (size < 2) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The list of resources must contain at least two values\");\n\t\t}\n\n\t\tResource individualResource = resources.get(0);\n\n\t\tif (individualResource.getScope() !=\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL) {\n\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The first resource must be an individual scope\");\n\t\t}\n\n\t\tResource companyResource = resources.get(size - 1);\n\n\t\tif (companyResource.getScope() != ResourceConstants.SCOPE_COMPANY) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The last resource must be a company scope\");\n\t\t}\n\n\t\t// See LPS-47464\n\n\t\tif (resourcePermissionPersistence.countByC_N_S_P(\n\t\t\t\tindividualResource.getCompanyId(), individualResource.getName(),\n\t\t\t\tindividualResource.getScope(),\n\t\t\t\tindividualResource.getPrimKey()) < 1) {\n\n\t\t\tStringBundler sb = new StringBundler(9);\n\n\t\t\tsb.append(\"{companyId=\");\n\t\t\tsb.append(individualResource.getCompanyId());\n\t\t\tsb.append(\", name=\");\n\t\t\tsb.append(individualResource.getName());\n\t\t\tsb.append(\", primKey=\");\n\t\t\tsb.append(individualResource.getPrimKey());\n\t\t\tsb.append(\", scope=\");\n\t\t\tsb.append(individualResource.getScope());\n\t\t\tsb.append(\"}\");\n\n\t\t\tthrow new NoSuchResourcePermissionException(sb.toString());\n\t\t}\n\n\t\t// Iterate the list of resources in reverse order to test permissions\n\t\t// from company scope to individual scope because it is more likely that\n\t\t// a permission is assigned at a higher scope. Optimizing this method to\n\t\t// one SQL call may actually slow things down since most of the calls\n\t\t// will pull from the cache after the first request.\n\n\t\tfor (int i = size - 1; i >= 0; i--) {\n\t\t\tResource resource = resources.get(i);\n\n\t\t\tif (hasResourcePermission(\n\t\t\t\t\tresource.getCompanyId(), resource.getName(),\n\t\t\t\t\tresource.getScope(), resource.getPrimKey(), roleIds,\n\t\t\t\t\tactionId)) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":92102,"modified_method":"/**\n\t * Returns <code>true<\/code> if the roles have permission at the scope to\n\t * perform the action on the resources.\n\t *\n\t * <p>\n\t * Depending on the scope, the value of <code>primKey<\/code> will have\n\t * different meanings. For more information, see {@link\n\t * com.liferay.portal.model.impl.ResourcePermissionImpl}.\n\t * <\/p>\n\t *\n\t * @param  resources the resources\n\t * @param  roleIds the primary keys of the roles\n\t * @param  actionId the action ID\n\t * @return <code>true<\/code> if any one of the roles has permission to\n\t *         perform the action on any one of the resources;\n\t *         <code>false<\/code> otherwise\n\t */\n\t@Override\n\tpublic boolean hasResourcePermission(\n\t\t\tList<Resource> resources, long[] roleIds, String actionId)\n\t\tthrows PortalException {\n\n\t\tif (roleIds.length == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint size = resources.size();\n\n\t\tif (size < 2) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The list of resources must contain at least two values\");\n\t\t}\n\n\t\tResource individualResource = resources.get(0);\n\n\t\tif (individualResource.getScope() !=\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL) {\n\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The first resource must be an individual scope\");\n\t\t}\n\n\t\tResource companyResource = resources.get(size - 1);\n\n\t\tif (companyResource.getScope() != ResourceConstants.SCOPE_COMPANY) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The last resource must be a company scope\");\n\t\t}\n\n\t\t// See LPS-47464\n\n\t\tif (resourcePermissionPersistence.countByC_N_S_P(\n\t\t\t\tindividualResource.getCompanyId(), individualResource.getName(),\n\t\t\t\tindividualResource.getScope(),\n\t\t\t\tindividualResource.getPrimKey()) < 1) {\n\n\t\t\tthrow new NoSuchResourcePermissionException(\n\t\t\t\t\"There is no \" + individualResource.getName() +\n\t\t\t\t\t\" with primary key \" + individualResource.getPrimKey() +\n\t\t\t\t\t\t\" and companyId \" + individualResource.getCompanyId());\n\t\t}\n\n\t\t// Iterate the list of resources in reverse order to test permissions\n\t\t// from company scope to individual scope because it is more likely that\n\t\t// a permission is assigned at a higher scope. Optimizing this method to\n\t\t// one SQL call may actually slow things down since most of the calls\n\t\t// will pull from the cache after the first request.\n\n\t\tfor (int i = size - 1; i >= 0; i--) {\n\t\t\tResource resource = resources.get(i);\n\n\t\t\tif (hasResourcePermission(\n\t\t\t\t\tresource.getCompanyId(), resource.getName(),\n\t\t\t\t\tresource.getScope(), resource.getPrimKey(), roleIds,\n\t\t\t\t\tactionId)) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"a755d1e66d8fde96953fc9c0278adc0ac038dfdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Nullable\n  private String validateRemoteUnderModal(@NotNull final String url) throws ProcessCanceledException {\n    return ProgressManager.getInstance().runProcessWithProgressSynchronously(new ThrowableComputable<String, ProcessCanceledException>() {\n      @Override\n      public String compute() throws ProcessCanceledException {\n        final GitCommandResult result = myGit.lsRemote(myRepository.getProject(), VfsUtilCore.virtualToIoFile(myRepository.getRoot()), url);\n        return !result.success() ? \"Remote URL test failed: \" + result.getErrorOutputAsHtmlString() : null;\n      }\n    }, \"Checking URL...\", true, myRepository.getProject());\n  }","id":92103,"modified_method":"@Nullable\n  private String validateRemoteUnderModal(@NotNull final String url) throws ProcessCanceledException {\n    return ProgressManager.getInstance().runProcessWithProgressSynchronously(() -> {\n      GitCommandResult result = myGit.lsRemote(myRepository.getProject(), virtualToIoFile(myRepository.getRoot()), url);\n      return !result.success() ? \"Remote URL test failed: \" + result.getErrorOutputAsHtmlString() : null;\n    }, \"Checking URL...\", true, myRepository.getProject());\n  }","commit_id":"39bad63abddfd1e77e0bf21e33552a152c77b44f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void createAndAddVirtualEnv(Project project, PyNewProjectSettings settings) {\n    final ProjectSdksModel model = PyConfigurableInterpreterList.getInstance(project).getModel();\n    final String baseSdk = getBaseSdk();\n\n    if (baseSdk != null) {\n      final PyPackageManager packageManager = PyPackageManager.getInstance(new PyDetectedSdk(baseSdk));\n      try {\n        final String path = packageManager.createVirtualEnv(project.getBasePath() + \"/.idea/VirtualEnvironment\", false);\n        AbstractCreateVirtualEnvDialog.setupVirtualEnvSdk(path, true, new AbstractCreateVirtualEnvDialog.VirtualEnvCallback() {\n          @Override\n          public void virtualEnvCreated(Sdk createdSdk, boolean associateWithProject) {\n            settings.setSdk(createdSdk);\n            model.addSdk(createdSdk);\n            try {\n              model.apply();\n            }\n            catch (ConfigurationException exception) {\n              LOG.error(\"Error adding created virtual env \" + exception.getMessage());\n            }\n          }\n        });\n      }\n      catch (ExecutionException e) {\n        LOG.warn(\"Failed to create virtual env \" + e.getMessage());\n      }\n    }\n  }","id":92104,"modified_method":"public void createAndAddVirtualEnv(Project project, PyNewProjectSettings settings) {\n    final ProjectSdksModel model = PyConfigurableInterpreterList.getInstance(project).getModel();\n    final String baseSdk = getBaseSdk(project);\n\n    if (baseSdk != null) {\n      final PyPackageManager packageManager = PyPackageManager.getInstance(new PyDetectedSdk(baseSdk));\n      try {\n        final String path = packageManager.createVirtualEnv(project.getBasePath() + \"/.idea/VirtualEnvironment\", false);\n        AbstractCreateVirtualEnvDialog.setupVirtualEnvSdk(path, true, new AbstractCreateVirtualEnvDialog.VirtualEnvCallback() {\n          @Override\n          public void virtualEnvCreated(Sdk createdSdk, boolean associateWithProject) {\n            settings.setSdk(createdSdk);\n            model.addSdk(createdSdk);\n            try {\n              model.apply();\n            }\n            catch (ConfigurationException exception) {\n              LOG.error(\"Error adding created virtual env \" + exception.getMessage());\n            }\n          }\n        });\n      }\n      catch (ExecutionException e) {\n        LOG.warn(\"Failed to create virtual env \" + e.getMessage());\n      }\n    }\n  }","commit_id":"8f42fbff7d0b2bca6ea2f06fe226c5270094bd16","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getBaseSdk() {\n    final PythonSdkFlavor flavor = PythonSdkFlavor.getApplicableFlavors(false).get(0);\n    String python3Sdk = null;\n    final Collection<String> baseSdks = flavor.suggestHomePaths();\n    for (String sdk : baseSdks) {\n      final String versionString = flavor.getVersionString(sdk);\n      final String prefix = flavor.getName() + \" \";\n      if (versionString != null && versionString.startsWith(prefix)) {\n        final LanguageLevel level = LanguageLevel.fromPythonVersion(versionString.substring(prefix.length()));\n        if (level.isAtLeast(LanguageLevel.PYTHON30)) {\n          python3Sdk = sdk;\n        }\n      }\n    }\n    return python3Sdk != null ? python3Sdk : baseSdks.iterator().next();\n  }","id":92105,"modified_method":"private String getBaseSdk(@NotNull final Project project) {\n    final Course course = myGenerator.getCourse(project);\n    LanguageLevel baseLevel = LanguageLevel.PYTHON30;\n    if (course != null) {\n      final String version = course.getLanguageVersion();\n      if (version != null) {\n        baseLevel = LanguageLevel.fromPythonVersion(version);\n      }\n    }\n    final PythonSdkFlavor flavor = PythonSdkFlavor.getApplicableFlavors(false).get(0);\n    String baseSdk = null;\n    final Collection<String> baseSdks = flavor.suggestHomePaths();\n    for (String sdk : baseSdks) {\n      final String versionString = flavor.getVersionString(sdk);\n      final String prefix = flavor.getName() + \" \";\n      if (versionString != null && versionString.startsWith(prefix)) {\n        final LanguageLevel level = LanguageLevel.fromPythonVersion(versionString.substring(prefix.length()));\n        if (level.isAtLeast(baseLevel)) {\n          baseSdk = sdk;\n          break;\n        }\n      }\n    }\n    return baseSdk != null ? baseSdk : baseSdks.iterator().next();\n  }","commit_id":"8f42fbff7d0b2bca6ea2f06fe226c5270094bd16","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void openFirstTask(@NotNull final Course course, @NotNull final Project project) {\n    LocalFileSystem.getInstance().refresh(false);\n    final Lesson firstLesson = StudyUtils.getFirst(course.getLessons());\n    final Task firstTask = StudyUtils.getFirst(firstLesson.getTaskList());\n    final VirtualFile taskDir = firstTask.getTaskDir(project);\n    if (taskDir == null) return;\n    final Map<String, TaskFile> taskFiles = firstTask.getTaskFiles();\n    VirtualFile activeVirtualFile = null;\n    for (Map.Entry<String, TaskFile> entry : taskFiles.entrySet()) {\n      final String name = entry.getKey();\n      final TaskFile taskFile = entry.getValue();\n      final VirtualFile virtualFile = ((VirtualDirectoryImpl)taskDir).refreshAndFindChild(name);\n      if (virtualFile != null) {\n        FileEditorManager.getInstance(project).openFile(virtualFile, true);\n        if (!taskFile.getAnswerPlaceholders().isEmpty()) {\n          activeVirtualFile = virtualFile;\n        }\n      }\n    }\n    if (activeVirtualFile != null) {\n      final PsiFile file = PsiManager.getInstance(project).findFile(activeVirtualFile);\n      ProjectView.getInstance(project).select(file, activeVirtualFile, true);\n      FileEditorManager.getInstance(project).openFile(activeVirtualFile, true);\n    }\n    else {\n      String first = StudyUtils.getFirst(taskFiles.keySet());\n      if (first != null) {\n        NewVirtualFile firstFile = ((VirtualDirectoryImpl)taskDir).refreshAndFindChild(first);\n        if (firstFile != null) {\n          FileEditorManager.getInstance(project).openFile(firstFile, true);\n        }\n      }\n    }\n  }","id":92106,"modified_method":"public static void openFirstTask(@NotNull final Course course, @NotNull final Project project) {\n    LocalFileSystem.getInstance().refresh(false);\n    final Lesson firstLesson = StudyUtils.getFirst(course.getLessons());\n    if (firstLesson == null) return;\n    final Task firstTask = StudyUtils.getFirst(firstLesson.getTaskList());\n    if (firstTask == null) return;\n    final VirtualFile taskDir = firstTask.getTaskDir(project);\n    if (taskDir == null) return;\n    final Map<String, TaskFile> taskFiles = firstTask.getTaskFiles();\n    VirtualFile activeVirtualFile = null;\n    for (Map.Entry<String, TaskFile> entry : taskFiles.entrySet()) {\n      final String name = entry.getKey();\n      final TaskFile taskFile = entry.getValue();\n      final VirtualFile virtualFile = ((VirtualDirectoryImpl)taskDir).refreshAndFindChild(name);\n      if (virtualFile != null) {\n        FileEditorManager.getInstance(project).openFile(virtualFile, true);\n        if (!taskFile.getAnswerPlaceholders().isEmpty()) {\n          activeVirtualFile = virtualFile;\n        }\n      }\n    }\n    if (activeVirtualFile != null) {\n      final PsiFile file = PsiManager.getInstance(project).findFile(activeVirtualFile);\n      ProjectView.getInstance(project).select(file, activeVirtualFile, true);\n      FileEditorManager.getInstance(project).openFile(activeVirtualFile, true);\n    }\n    else {\n      String first = StudyUtils.getFirst(taskFiles.keySet());\n      if (first != null) {\n        NewVirtualFile firstFile = ((VirtualDirectoryImpl)taskDir).refreshAndFindChild(first);\n        if (firstFile != null) {\n          FileEditorManager.getInstance(project).openFile(firstFile, true);\n        }\n      }\n    }\n  }","commit_id":"8f42fbff7d0b2bca6ea2f06fe226c5270094bd16","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected Course getCourse(@NotNull final Project project) {\n\n    final File courseFile = new File(new File(OUR_COURSES_DIR, mySelectedCourseInfo.getName()), EduNames.COURSE_META_FILE);\n    if (courseFile.exists()) {\n      return readCourseFromCache(courseFile, false);\n    }\n    else if (myUser != null) {\n      final File adaptiveCourseFile = new File(new File(OUR_COURSES_DIR, ADAPTIVE_COURSE_PREFIX +\n                                                                         mySelectedCourseInfo.getName() + \"_\" +\n                                                                         myUser.getEmail()), EduNames.COURSE_META_FILE);\n      if (adaptiveCourseFile.exists()) {\n        return readCourseFromCache(adaptiveCourseFile, true);\n      }\n    }\n    return ProgressManager.getInstance().runProcessWithProgressSynchronously(new ThrowableComputable<Course, RuntimeException>() {\n      @Override\n      public Course compute() throws RuntimeException {\n        ProgressManager.getInstance().getProgressIndicator().setIndeterminate(true);\n        return execCancelable(() -> {\n\n          final Course course = EduStepicConnector.getCourse(project, mySelectedCourseInfo);\n          if (course != null) {\n            flushCourse(project, course);\n            course.initCourse(false);\n          }\n          return course;\n        });\n      }\n    }, \"Creating Course\", true, project);\n  }","id":92107,"modified_method":"@Nullable\n  public Course getCourse(@NotNull final Project project) {\n\n    final File courseFile = new File(new File(OUR_COURSES_DIR, mySelectedCourseInfo.getName()), EduNames.COURSE_META_FILE);\n    if (courseFile.exists()) {\n      return readCourseFromCache(courseFile, false);\n    }\n    else if (myUser != null) {\n      final File adaptiveCourseFile = new File(new File(OUR_COURSES_DIR, ADAPTIVE_COURSE_PREFIX +\n                                                                         mySelectedCourseInfo.getName() + \"_\" +\n                                                                         myUser.getEmail()), EduNames.COURSE_META_FILE);\n      if (adaptiveCourseFile.exists()) {\n        return readCourseFromCache(adaptiveCourseFile, true);\n      }\n    }\n    return ProgressManager.getInstance().runProcessWithProgressSynchronously(() -> {\n      ProgressManager.getInstance().getProgressIndicator().setIndeterminate(true);\n      return execCancelable(() -> {\n\n        final Course course = EduStepicConnector.getCourse(project, mySelectedCourseInfo);\n        if (course != null) {\n          flushCourse(project, course);\n          course.initCourse(false);\n        }\n        return course;\n      });\n    }, \"Creating Course\", true, project);\n  }","commit_id":"8f42fbff7d0b2bca6ea2f06fe226c5270094bd16","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<CourseInfo> getCoursesUnderProgress(boolean force, @NotNull final String progressTitle, @NotNull final Project project) {\n    try {\n      return ProgressManager.getInstance()\n        .runProcessWithProgressSynchronously(new ThrowableComputable<List<CourseInfo>, RuntimeException>() {\n          @Override\n          public List<CourseInfo> compute() throws RuntimeException {\n            ProgressManager.getInstance().getProgressIndicator().setIndeterminate(true);\n            return getCourses(force);\n          }\n        }, progressTitle, true, project);\n    }\n    catch (RuntimeException e) {\n      return Collections.singletonList(CourseInfo.INVALID_COURSE);\n    }\n  }","id":92108,"modified_method":"public List<CourseInfo> getCoursesUnderProgress(boolean force, @NotNull final String progressTitle, @NotNull final Project project) {\n    try {\n      return ProgressManager.getInstance()\n        .runProcessWithProgressSynchronously(() -> {\n          ProgressManager.getInstance().getProgressIndicator().setIndeterminate(true);\n          return getCourses(force);\n        }, progressTitle, true, project);\n    }\n    catch (RuntimeException e) {\n      return Collections.singletonList(CourseInfo.INVALID_COURSE);\n    }\n  }","commit_id":"c7554f48b8a92da0b29f354331dd89ce8f762965","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void generateProject(@NotNull final Project project, @NotNull final VirtualFile baseDir) {\n    StudyTaskManager.getInstance(project).setUser(myUser);\n    final Course course = getCourse(project);\n    if (course == null) {\n      LOG.warn(\"Course is null\");\n      return;\n    }\n    final File courseDirectory = StudyUtils.getCourseDirectory(project, course);\n    StudyTaskManager.getInstance(project).setCourse(course);\n    ApplicationManager.getApplication().invokeLater(\n      () -> DumbService.allowStartingDumbModeInside(DumbModePermission.MAY_START_BACKGROUND,\n                                                    () -> ApplicationManager.getApplication().runWriteAction(() -> {\n                                                      StudyGenerator.createCourse(course, baseDir, courseDirectory, project);\n                                                      course.setCourseDirectory(courseDirectory.getAbsolutePath());\n                                                      VirtualFileManager.getInstance().refreshWithoutFileWatcher(true);\n                                                      StudyProjectComponent.getInstance(project).registerStudyToolWindow(course);\n                                                      openFirstTask(course, project);\n                                                    })));\n  }","id":92109,"modified_method":"public void generateProject(@NotNull final Project project, @NotNull final VirtualFile baseDir) {\n    StudyTaskManager.getInstance(project).setUser(myUser);\n    final Course course = getCourse(project);\n    if (course == null) {\n      LOG.warn(\"Course is null\");\n      return;\n    }\n    final File courseDirectory = StudyUtils.getCourseDirectory(project, course);\n    StudyTaskManager.getInstance(project).setCourse(course);\n    ApplicationManager.getApplication().invokeLater(\n      () -> DumbService.allowStartingDumbModeInside(DumbModePermission.MAY_START_BACKGROUND,\n                                                    () -> ApplicationManager.getApplication().runWriteAction(() -> {\n                                                      StudyGenerator.createCourse(course, baseDir, courseDirectory, project);\n                                                      course.setCourseDirectory(courseDirectory.getAbsolutePath());\n                                                      VirtualFileManager.getInstance().refreshWithoutFileWatcher(true);\n                                                      StudyProjectComponent.getInstance(project).registerStudyToolWindow(course);\n                                                      openFirstTask(course, project);\n                                                      installCourseRequirements(project);\n                                                    })));\n  }","commit_id":"c7554f48b8a92da0b29f354331dd89ce8f762965","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Parses course json meta file and finds course name\n   *\n   * @return information about course or null if course file is invalid\n   */\n  @Nullable\n  private static CourseInfo getCourseInfo(File courseFile) {\n    if (courseFile.isDirectory()) {\n      File[] courseFiles = courseFile.listFiles((dir, name) -> name.equals(EduNames.COURSE_META_FILE));\n      if (courseFiles.length != 1) {\n        LOG.info(\"More than one or without course files\");\n        return null;\n      }\n      courseFile = courseFiles[0];\n    }\n    CourseInfo courseInfo = null;\n    BufferedReader reader = null;\n    try {\n      if (courseFile.getName().equals(EduNames.COURSE_META_FILE)) {\n        reader = new BufferedReader(new InputStreamReader(new FileInputStream(courseFile), \"UTF-8\"));\n        JsonReader r = new JsonReader(reader);\n        JsonParser parser = new JsonParser();\n        JsonElement el = parser.parse(r);\n        String courseName = el.getAsJsonObject().get(COURSE_NAME_ATTRIBUTE).getAsString();\n        String courseDescription = el.getAsJsonObject().get(COURSE_DESCRIPTION).getAsString();\n        JsonArray courseAuthors = el.getAsJsonObject().get(AUTHOR_ATTRIBUTE).getAsJsonArray();\n        String language = el.getAsJsonObject().get(LANGUAGE_ATTRIBUTE).getAsString();\n        courseInfo = new CourseInfo();\n        courseInfo.setName(courseName);\n        courseInfo.setDescription(courseDescription);\n        courseInfo.setType(\"pycharm \" + language);\n        final ArrayList<StepicUser> authors = new ArrayList<>();\n        for (JsonElement author : courseAuthors) {\n          final JsonObject authorAsJsonObject = author.getAsJsonObject();\n          final StepicUser stepicUser = new StepicUser();\n          stepicUser.setFirstName(authorAsJsonObject.get(\"first_name\").getAsString());\n          stepicUser.setLastName(authorAsJsonObject.get(\"last_name\").getAsString());\n          authors.add(stepicUser);\n        }\n        courseInfo.setAuthors(authors);\n      }\n    }\n    catch (Exception e) {\n      //error will be shown in UI\n    }\n    finally {\n      StudyUtils.closeSilently(reader);\n    }\n    return courseInfo;\n  }","id":92110,"modified_method":"/**\n   * Parses course json meta file and finds course name\n   *\n   * @return information about course or null if course file is invalid\n   */\n  @Nullable\n  private static CourseInfo getCourseInfo(File courseFile) {\n    if (courseFile.isDirectory()) {\n      File[] courseFiles = courseFile.listFiles((dir, name) -> name.equals(EduNames.COURSE_META_FILE));\n      if (courseFiles == null || courseFiles.length != 1) {\n        LOG.info(\"More than one or without course files\");\n        return null;\n      }\n      courseFile = courseFiles[0];\n    }\n    CourseInfo courseInfo = null;\n    BufferedReader reader = null;\n    try {\n      if (courseFile.getName().equals(EduNames.COURSE_META_FILE)) {\n        reader = new BufferedReader(new InputStreamReader(new FileInputStream(courseFile), \"UTF-8\"));\n        JsonReader r = new JsonReader(reader);\n        JsonParser parser = new JsonParser();\n        JsonElement el = parser.parse(r);\n        String courseName = el.getAsJsonObject().get(COURSE_NAME_ATTRIBUTE).getAsString();\n        String courseDescription = el.getAsJsonObject().get(COURSE_DESCRIPTION).getAsString();\n        JsonArray courseAuthors = el.getAsJsonObject().get(AUTHOR_ATTRIBUTE).getAsJsonArray();\n        String language = el.getAsJsonObject().get(LANGUAGE_ATTRIBUTE).getAsString();\n        courseInfo = new CourseInfo();\n        courseInfo.setName(courseName);\n        courseInfo.setDescription(courseDescription);\n        courseInfo.setType(\"pycharm \" + language);\n        final ArrayList<StepicUser> authors = new ArrayList<>();\n        for (JsonElement author : courseAuthors) {\n          final JsonObject authorAsJsonObject = author.getAsJsonObject();\n          final StepicUser stepicUser = new StepicUser();\n          stepicUser.setFirstName(authorAsJsonObject.get(\"first_name\").getAsString());\n          stepicUser.setLastName(authorAsJsonObject.get(\"last_name\").getAsString());\n          authors.add(stepicUser);\n        }\n        courseInfo.setAuthors(authors);\n      }\n    }\n    catch (Exception e) {\n      //error will be shown in UI\n    }\n    finally {\n      StudyUtils.closeSilently(reader);\n    }\n    return courseInfo;\n  }","commit_id":"c7554f48b8a92da0b29f354331dd89ce8f762965","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Adds course to courses specified in params\n   *\n   * @param courses\n   * @param courseDir must be directory containing course file\n   * @return added course name or null if course is invalid\n   */\n  @Nullable\n  private static CourseInfo addCourse(List<CourseInfo> courses, File courseDir) {\n    if (courseDir.isDirectory()) {\n      File[] courseFiles = courseDir.listFiles((dir, name) -> name.equals(EduNames.COURSE_META_FILE));\n      if (courseFiles.length != 1) {\n        LOG.info(\"User tried to add course with more than one or without course files\");\n        return null;\n      }\n      File courseFile = courseFiles[0];\n      CourseInfo courseInfo = getCourseInfo(courseFile);\n      if (courseInfo != null) {\n        courses.add(courseInfo);\n      }\n      return courseInfo;\n    }\n    return null;\n  }","id":92111,"modified_method":"/**\n   * Adds course to courses specified in params\n   *\n   * @param courses\n   * @param courseDir must be directory containing course file\n   * @return added course name or null if course is invalid\n   */\n  @Nullable\n  private static CourseInfo addCourse(List<CourseInfo> courses, File courseDir) {\n    if (courseDir.isDirectory()) {\n      File[] courseFiles = courseDir.listFiles((dir, name) -> name.equals(EduNames.COURSE_META_FILE));\n      if (courseFiles == null || courseFiles.length != 1) {\n        LOG.info(\"User tried to add course with more than one or without course files\");\n        return null;\n      }\n      File courseFile = courseFiles[0];\n      CourseInfo courseInfo = getCourseInfo(courseFile);\n      if (courseInfo != null) {\n        courses.add(courseInfo);\n      }\n      return courseInfo;\n    }\n    return null;\n  }","commit_id":"c7554f48b8a92da0b29f354331dd89ce8f762965","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected Course getCourse(@NotNull final Project project) {\n\n    final File courseFile = new File(new File(OUR_COURSES_DIR, mySelectedCourseInfo.getName()), EduNames.COURSE_META_FILE);\n    if (courseFile.exists()) {\n      return readCourseFromCache(courseFile, false);\n    }\n    else if (myUser != null) {\n      final File adaptiveCourseFile = new File(new File(OUR_COURSES_DIR, ADAPTIVE_COURSE_PREFIX +\n                                                                         mySelectedCourseInfo.getName() + \"_\" +\n                                                                         myUser.getEmail()), EduNames.COURSE_META_FILE);\n      if (adaptiveCourseFile.exists()) {\n        return readCourseFromCache(adaptiveCourseFile, true);\n      }\n    }\n    return ProgressManager.getInstance().runProcessWithProgressSynchronously(new ThrowableComputable<Course, RuntimeException>() {\n      @Override\n      public Course compute() throws RuntimeException {\n        ProgressManager.getInstance().getProgressIndicator().setIndeterminate(true);\n        return execCancelable(() -> {\n\n          final Course course = EduStepicConnector.getCourse(project, mySelectedCourseInfo);\n          if (course != null) {\n            flushCourse(project, course);\n            course.initCourse(false);\n          }\n          return course;\n        });\n      }\n    }, \"Creating Course\", true, project);\n  }","id":92112,"modified_method":"@Nullable\n  protected Course getCourse(@NotNull final Project project) {\n\n    final File courseFile = new File(new File(OUR_COURSES_DIR, mySelectedCourseInfo.getName()), EduNames.COURSE_META_FILE);\n    if (courseFile.exists()) {\n      return readCourseFromCache(courseFile, false);\n    }\n    else if (myUser != null) {\n      final File adaptiveCourseFile = new File(new File(OUR_COURSES_DIR, ADAPTIVE_COURSE_PREFIX +\n                                                                         mySelectedCourseInfo.getName() + \"_\" +\n                                                                         myUser.getEmail()), EduNames.COURSE_META_FILE);\n      if (adaptiveCourseFile.exists()) {\n        return readCourseFromCache(adaptiveCourseFile, true);\n      }\n    }\n    return ProgressManager.getInstance().runProcessWithProgressSynchronously(() -> {\n      ProgressManager.getInstance().getProgressIndicator().setIndeterminate(true);\n      return execCancelable(() -> {\n\n        final Course course = EduStepicConnector.getCourse(project, mySelectedCourseInfo);\n        if (course != null) {\n          flushCourse(project, course);\n          course.initCourse(false);\n        }\n        return course;\n      });\n    }, \"Creating Course\", true, project);\n  }","commit_id":"abb8bea389b313f9169b8880d77aca6c3a209160","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void flushCourseJson(@NotNull final Course course, @NotNull final File courseDirectory) {\n    final Gson gson = new GsonBuilder().setPrettyPrinting().\n      registerTypeAdapter(AnswerPlaceholder.class, new StudySerializationUtils.Json.StepicAnswerPlaceholderAdapter()).\n      excludeFieldsWithoutExposeAnnotation().create();\n    final String json = gson.toJson(course);\n    final File courseJson = new File(courseDirectory, EduNames.COURSE_META_FILE);\n    final FileOutputStream fileOutputStream;\n    try {\n      fileOutputStream = new FileOutputStream(courseJson);\n      OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream, \"UTF-8\");\n      try {\n        outputStreamWriter.write(json);\n      }\n      catch (IOException e) {\n        Messages.showErrorDialog(e.getMessage(), \"Failed to Generate Json\");\n        LOG.info(e);\n      }\n      finally {\n        try {\n          outputStreamWriter.close();\n        }\n        catch (IOException e) {\n          LOG.info(e);\n        }\n      }\n    }\n    catch (FileNotFoundException | UnsupportedEncodingException e) {\n      LOG.info(e);\n    }\n  }","id":92113,"modified_method":"public static void flushCourseJson(@NotNull final Course course, @NotNull final File courseDirectory) {\n    final Gson gson = new GsonBuilder().setPrettyPrinting().\n      excludeFieldsWithoutExposeAnnotation().create();\n    final String json = gson.toJson(course);\n    final File courseJson = new File(courseDirectory, EduNames.COURSE_META_FILE);\n    final FileOutputStream fileOutputStream;\n    try {\n      fileOutputStream = new FileOutputStream(courseJson);\n      OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream, \"UTF-8\");\n      try {\n        outputStreamWriter.write(json);\n      }\n      catch (IOException e) {\n        Messages.showErrorDialog(e.getMessage(), \"Failed to Generate Json\");\n        LOG.info(e);\n      }\n      finally {\n        try {\n          outputStreamWriter.close();\n        }\n        catch (IOException e) {\n          LOG.info(e);\n        }\n      }\n    }\n    catch (FileNotFoundException | UnsupportedEncodingException e) {\n      LOG.info(e);\n    }\n  }","commit_id":"abb8bea389b313f9169b8880d77aca6c3a209160","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n      public JsonElement serialize(AnswerPlaceholder src, Type typeOfSrc, JsonSerializationContext context) {\n        final List<String> hints = src.getHints();\n\n        final int length = src.getLength();\n        final int start = src.getOffset();\n        final String possibleAnswer = src.getPossibleAnswer();\n        int line = -1;\n\n        final Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n        final JsonObject answerPlaceholder = new JsonObject();\n        answerPlaceholder.addProperty(LINE, line);\n        answerPlaceholder.addProperty(START, start);\n        answerPlaceholder.addProperty(LENGTH, length);\n        answerPlaceholder.addProperty(POSSIBLE_ANSWER, possibleAnswer);\n\n        final String jsonHints = gson.toJson(hints);\n        answerPlaceholder.addProperty(HINT, jsonHints);\n\n        return answerPlaceholder;\n      }","id":92114,"modified_method":"@Override\n      public JsonElement serialize(AnswerPlaceholder src, Type typeOfSrc, JsonSerializationContext context) {\n        final List<String> hints = src.getHints();\n\n        final int length = src.getLength();\n        final int start = src.getOffset();\n        final String possibleAnswer = src.getPossibleAnswer();\n\n        final Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n        final JsonObject answerPlaceholder = new JsonObject();\n        answerPlaceholder.addProperty(OFFSET, start);\n        answerPlaceholder.addProperty(LENGTH, length);\n        answerPlaceholder.addProperty(POSSIBLE_ANSWER, possibleAnswer);\n\n        final String jsonHints = gson.toJson(hints);\n        answerPlaceholder.addProperty(HINT, jsonHints);\n\n        return answerPlaceholder;\n      }","commit_id":"abb8bea389b313f9169b8880d77aca6c3a209160","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n    public void testCollectionAsArray() throws Exception{\n        String[] testArray = {\"t\"};\n        ConfigurationParameters options = ConfigurationParameters.of(Collections.singletonMap(\"test\", Arrays.asList(testArray)));\n        assertArrayEquals(testArray, options.getConfigValue(\"test\", null, String[].class));\n    }","id":92115,"modified_method":"@Test\n    public void testCollectionAsArray() throws Exception{\n        String[] testArray = {\"t\"};\n        ConfigurationParameters options = ConfigurationParameters.of(\"test\", Arrays.asList(testArray));\n        assertArrayEquals(testArray, options.getConfigValue(\"test\", null, String[].class));\n    }","commit_id":"7fe87c1cfa0b3a4149b1db25baf8afa8cbf56c70","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testConversionToSet() {\n        String[] stringArray = new String[] {\"a\", \"b\"};\n        Set<String> stringSet = ImmutableSet.copyOf(stringArray);\n\n        TestObject[] testObjectArray = new TestObject[] {new TestObject(\"a\"), new TestObject(\"b\")};\n        Set<TestObject> testObjectSet = ImmutableSet.copyOf(testObjectArray);\n\n        // map of config value (key) and expected result set.\n        Map<Object, Set> configValues = new HashMap<Object, Set>();\n        configValues.put(\"a\", ImmutableSet.of(\"a\"));\n        configValues.put(stringArray, stringSet);\n        configValues.put(stringSet, stringSet);\n        configValues.put(testObjectArray, testObjectSet);\n        configValues.put(testObjectSet, testObjectSet);\n        configValues.put(new String[0], Collections.<String>emptySet());\n        configValues.put(new HashSet(), Collections.emptySet());\n        configValues.put(ImmutableSet.of(), Collections.emptySet());\n        configValues.put(new ArrayList(), Collections.emptySet());\n        configValues.put(ConfigurationParameters.EMPTY, Collections.<String>emptySet());\n\n        Set<String> defaultStrings = ImmutableSet.of(\"abc\", \"def\", \"ghi\");\n        Set<TestObject> defaultObjects = ImmutableSet.of(new TestObject(\"abc\"), new TestObject(\"def\"));\n\n        for (Object value : configValues.keySet()) {\n            ConfigurationParameters config;\n            if (value instanceof ConfigurationParameters) {\n                config = ConfigurationParameters.of((ConfigurationParameters) value);\n            } else {\n                config = ConfigurationParameters.of(Collections.singletonMap(\"key\", value));\n            }\n\n            Set expected = configValues.get(value);\n            assertEquals(expected, config.getConfigValue(\"key\", Collections.emptySet()));\n            assertEquals(expected, config.getConfigValue(\"key\", Collections.<String>emptySet()));\n            assertEquals(expected, config.getConfigValue(\"key\", ImmutableSet.of()));\n\n            assertEquals(expected, config.getConfigValue(\"key\", Collections.emptySet(), Set.class));\n            assertEquals(expected, config.getConfigValue(\"key\", Collections.<String>emptySet(), Set.class));\n            assertEquals(expected, config.getConfigValue(\"key\", ImmutableSet.of(), Set.class));\n\n            // test with default values\n            if (!config.containsKey(\"key\")) {\n                assertEquals(defaultStrings, config.getConfigValue(\"key\", defaultStrings, Set.class));\n                assertEquals(defaultObjects, config.getConfigValue(\"key\", defaultObjects, Set.class));\n                assertEquals(null, config.getConfigValue(\"key\", null, Set.class));\n                assertEquals(defaultStrings, config.getConfigValue(\"key\", defaultStrings));\n                assertEquals(defaultObjects, config.getConfigValue(\"key\", defaultObjects));\n            } else {\n                assertEquals(expected, config.getConfigValue(\"key\", defaultStrings, Set.class));\n                assertEquals(expected, config.getConfigValue(\"key\", defaultObjects, Set.class));\n                assertEquals(expected, config.getConfigValue(\"key\", null, Set.class));\n                assertEquals(expected, config.getConfigValue(\"key\", defaultStrings));\n                assertEquals(expected, config.getConfigValue(\"key\", defaultObjects));\n            }\n\n            // non existing kez with default values\n            assertEquals(defaultStrings, config.getConfigValue(\"nonexisting\", defaultStrings));\n            assertEquals(defaultStrings, config.getConfigValue(\"nonexisting\", defaultStrings, Set.class));\n            assertEquals(defaultObjects, config.getConfigValue(\"nonexisting\", defaultObjects));\n            assertEquals(defaultObjects, config.getConfigValue(\"nonexisting\", defaultObjects, Set.class));\n        }\n    }","id":92116,"modified_method":"@Test\n    public void testConversionToSet() {\n        String[] stringArray = new String[] {\"a\", \"b\"};\n        Set<String> stringSet = ImmutableSet.copyOf(stringArray);\n\n        TestObject[] testObjectArray = new TestObject[] {new TestObject(\"a\"), new TestObject(\"b\")};\n        Set<TestObject> testObjectSet = ImmutableSet.copyOf(testObjectArray);\n\n        // map of config value (key) and expected result set.\n        Map<Object, Set> configValues = new HashMap<Object, Set>();\n        configValues.put(\"a\", ImmutableSet.of(\"a\"));\n        configValues.put(stringArray, stringSet);\n        configValues.put(stringSet, stringSet);\n        configValues.put(testObjectArray, testObjectSet);\n        configValues.put(testObjectSet, testObjectSet);\n        configValues.put(new String[0], Collections.<String>emptySet());\n        configValues.put(new HashSet(), Collections.emptySet());\n        configValues.put(ImmutableSet.of(), Collections.emptySet());\n        configValues.put(new ArrayList(), Collections.emptySet());\n        configValues.put(ConfigurationParameters.EMPTY, Collections.<String>emptySet());\n\n        Set<String> defaultStrings = ImmutableSet.of(\"abc\", \"def\", \"ghi\");\n        Set<TestObject> defaultObjects = ImmutableSet.of(new TestObject(\"abc\"), new TestObject(\"def\"));\n\n        for (Object value : configValues.keySet()) {\n            ConfigurationParameters config;\n            if (value instanceof ConfigurationParameters) {\n                config = ConfigurationParameters.of((ConfigurationParameters) value);\n            } else {\n                config = ConfigurationParameters.of(\"key\", value);\n            }\n\n            Set expected = configValues.get(value);\n            assertEquals(expected, config.getConfigValue(\"key\", Collections.emptySet()));\n            assertEquals(expected, config.getConfigValue(\"key\", Collections.<String>emptySet()));\n            assertEquals(expected, config.getConfigValue(\"key\", ImmutableSet.of()));\n\n            assertEquals(expected, config.getConfigValue(\"key\", Collections.emptySet(), Set.class));\n            assertEquals(expected, config.getConfigValue(\"key\", Collections.<String>emptySet(), Set.class));\n            assertEquals(expected, config.getConfigValue(\"key\", ImmutableSet.of(), Set.class));\n\n            // test with default values\n            if (!config.containsKey(\"key\")) {\n                assertEquals(defaultStrings, config.getConfigValue(\"key\", defaultStrings, Set.class));\n                assertEquals(defaultObjects, config.getConfigValue(\"key\", defaultObjects, Set.class));\n                assertEquals(null, config.getConfigValue(\"key\", null, Set.class));\n                assertEquals(defaultStrings, config.getConfigValue(\"key\", defaultStrings));\n                assertEquals(defaultObjects, config.getConfigValue(\"key\", defaultObjects));\n            } else {\n                assertEquals(expected, config.getConfigValue(\"key\", defaultStrings, Set.class));\n                assertEquals(expected, config.getConfigValue(\"key\", defaultObjects, Set.class));\n                assertEquals(expected, config.getConfigValue(\"key\", null, Set.class));\n                assertEquals(expected, config.getConfigValue(\"key\", defaultStrings));\n                assertEquals(expected, config.getConfigValue(\"key\", defaultObjects));\n            }\n\n            // non existing kez with default values\n            assertEquals(defaultStrings, config.getConfigValue(\"nonexisting\", defaultStrings));\n            assertEquals(defaultStrings, config.getConfigValue(\"nonexisting\", defaultStrings, Set.class));\n            assertEquals(defaultObjects, config.getConfigValue(\"nonexisting\", defaultObjects));\n            assertEquals(defaultObjects, config.getConfigValue(\"nonexisting\", defaultObjects, Set.class));\n        }\n    }","commit_id":"7fe87c1cfa0b3a4149b1db25baf8afa8cbf56c70","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testArrayDefaultValue2() {\n        TestObject[] testArray = new TestObject[] {new TestObject(\"t\")};\n\n        TestObject[] result = ConfigurationParameters.EMPTY.getConfigValue(\"test\", new TestObject[0], null);\n        assertNotNull(result);\n        assertEquals(0, result.length);\n        assertArrayEquals(testArray, ConfigurationParameters.EMPTY.getConfigValue(\"test\", testArray, null));\n        assertArrayEquals(testArray, ConfigurationParameters.EMPTY.getConfigValue(\"test\", testArray, TestObject[].class));\n\n        ConfigurationParameters options = ConfigurationParameters.of(Collections.singletonMap(\"test\", testArray));\n        assertArrayEquals(testArray, (TestObject[]) options.getConfigValue(\"test\", null, null));\n        assertArrayEquals(testArray, options.getConfigValue(\"test\", null, TestObject[].class));\n        assertArrayEquals(testArray, options.getConfigValue(\"test\", new TestObject[]{new TestObject(\"s\")}, null));\n        assertArrayEquals(testArray, options.getConfigValue(\"test\", new TestObject[]{new TestObject(\"s\")}, TestObject[].class));\n    }","id":92117,"modified_method":"@Test\n    public void testArrayDefaultValue2() {\n        TestObject[] testArray = new TestObject[] {new TestObject(\"t\")};\n\n        TestObject[] result = ConfigurationParameters.EMPTY.getConfigValue(\"test\", new TestObject[0], null);\n        assertNotNull(result);\n        assertEquals(0, result.length);\n        assertArrayEquals(testArray, ConfigurationParameters.EMPTY.getConfigValue(\"test\", testArray, null));\n        assertArrayEquals(testArray, ConfigurationParameters.EMPTY.getConfigValue(\"test\", testArray, TestObject[].class));\n\n        ConfigurationParameters options = ConfigurationParameters.of(\"test\", testArray);\n        assertArrayEquals(testArray, (TestObject[]) options.getConfigValue(\"test\", null, null));\n        assertArrayEquals(testArray, options.getConfigValue(\"test\", null, TestObject[].class));\n        assertArrayEquals(testArray, options.getConfigValue(\"test\", new TestObject[]{new TestObject(\"s\")}, null));\n        assertArrayEquals(testArray, options.getConfigValue(\"test\", new TestObject[]{new TestObject(\"s\")}, TestObject[].class));\n    }","commit_id":"7fe87c1cfa0b3a4149b1db25baf8afa8cbf56c70","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testArrayDefaultValue() {\n        TestObject[] testArray = new TestObject[] {new TestObject(\"t\")};\n\n        TestObject[] result = ConfigurationParameters.EMPTY.getConfigValue(\"test\", new TestObject[0]);\n        assertNotNull(result);\n        assertEquals(0, result.length);\n        assertArrayEquals(testArray, ConfigurationParameters.EMPTY.getConfigValue(\"test\", testArray));\n\n        ConfigurationParameters options = ConfigurationParameters.of(Collections.singletonMap(\"test\", testArray));\n        assertArrayEquals(testArray, options.getConfigValue(\"test\", new TestObject[] {new TestObject(\"s\")}));\n    }","id":92118,"modified_method":"@Test\n    public void testArrayDefaultValue() {\n        TestObject[] testArray = new TestObject[] {new TestObject(\"t\")};\n\n        TestObject[] result = ConfigurationParameters.EMPTY.getConfigValue(\"test\", new TestObject[0]);\n        assertNotNull(result);\n        assertEquals(0, result.length);\n        assertArrayEquals(testArray, ConfigurationParameters.EMPTY.getConfigValue(\"test\", testArray));\n\n        ConfigurationParameters options = ConfigurationParameters.of(\"test\", testArray);\n        assertArrayEquals(testArray, options.getConfigValue(\"test\", new TestObject[] {new TestObject(\"s\")}));\n    }","commit_id":"7fe87c1cfa0b3a4149b1db25baf8afa8cbf56c70","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testCreation() {\n        ConfigurationParameters params = ConfigurationParameters.of(\n                ConfigurationParameters.EMPTY,\n                null,\n                ConfigurationParameters.of(Collections.singletonMap(\"a\", \"a\")));\n        assertFalse(params.isEmpty());\n        assertEquals(1, params.size());\n        assertTrue(params.contains(\"a\"));\n    }","id":92119,"modified_method":"@Test\n    public void testCreation() {\n        ConfigurationParameters params = ConfigurationParameters.of(\n                ConfigurationParameters.EMPTY,\n                null,\n                ConfigurationParameters.of(\"a\", \"a\"));\n        assertFalse(params.isEmpty());\n        assertEquals(1, params.size());\n        assertTrue(params.contains(\"a\"));\n    }","commit_id":"7fe87c1cfa0b3a4149b1db25baf8afa8cbf56c70","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testConversionToStringArray() {\n        String[] stringArray = new String[] {\"a\", \"b\"};\n        Set<String> stringSet = ImmutableSet.copyOf(stringArray);\n\n        TestObject[] testObjectArray = new TestObject[] {new TestObject(\"a\"), new TestObject(\"b\")};\n        Set<TestObject> testObjectSet = ImmutableSet.copyOf(testObjectArray);\n\n        String[] defaultStrings = new String[]{\"abc\", \"def\", \"ghi\"};\n\n        // map of config value (key) and expected result set.\n        Map<Object, Object[]> configValues = new HashMap<Object, Object[]>();\n        configValues.put(\"a\", new String[] {\"a\"});\n        configValues.put(stringArray, stringArray);\n        configValues.put(stringSet, stringArray);\n        configValues.put(testObjectArray, stringArray);\n        configValues.put(testObjectSet, stringArray);\n        configValues.put(new String[0], new String[0]);\n        configValues.put(new HashSet(), new String[0]);\n        configValues.put(ImmutableSet.of(), new String[0]);\n        configValues.put(new ArrayList(), new String[0]);\n        configValues.put(ConfigurationParameters.EMPTY, new String[0]);\n\n        for (Object value : configValues.keySet()) {\n            ConfigurationParameters config;\n            if (value instanceof ConfigurationParameters) {\n                config = ConfigurationParameters.of((ConfigurationParameters) value);\n            } else {\n                config = ConfigurationParameters.of(Collections.singletonMap(\"key\", value));\n            }\n            Object[] expected = configValues.get(value);\n\n            assertArrayEquals(expected, config.getConfigValue(\"key\", new String[0]));\n            assertArrayEquals(expected, config.getConfigValue(\"key\", new String[0], String[].class));\n\n            // test with default values\n            if (!config.containsKey(\"key\")) {\n                assertArrayEquals(defaultStrings, config.getConfigValue(\"key\", defaultStrings, String[].class));\n                assertArrayEquals(null, config.getConfigValue(\"key\", null, String[].class));\n                assertArrayEquals(defaultStrings, config.getConfigValue(\"key\", defaultStrings));\n            } else {\n                assertArrayEquals(expected, config.getConfigValue(\"key\", defaultStrings, String[].class));\n                assertArrayEquals(expected, config.getConfigValue(\"key\", null, String[].class));\n                assertArrayEquals(expected, config.getConfigValue(\"key\", defaultStrings));\n            }\n\n            // non existing kez with default values\n            assertArrayEquals(defaultStrings, config.getConfigValue(\"nonexisting\", defaultStrings));\n            assertArrayEquals(defaultStrings, config.getConfigValue(\"nonexisting\", defaultStrings, String[].class));\n        }\n    }","id":92120,"modified_method":"@Test\n    public void testConversionToStringArray() {\n        String[] stringArray = new String[] {\"a\", \"b\"};\n        Set<String> stringSet = ImmutableSet.copyOf(stringArray);\n\n        TestObject[] testObjectArray = new TestObject[] {new TestObject(\"a\"), new TestObject(\"b\")};\n        Set<TestObject> testObjectSet = ImmutableSet.copyOf(testObjectArray);\n\n        String[] defaultStrings = new String[]{\"abc\", \"def\", \"ghi\"};\n\n        // map of config value (key) and expected result set.\n        Map<Object, Object[]> configValues = new HashMap<Object, Object[]>();\n        configValues.put(\"a\", new String[] {\"a\"});\n        configValues.put(stringArray, stringArray);\n        configValues.put(stringSet, stringArray);\n        configValues.put(testObjectArray, stringArray);\n        configValues.put(testObjectSet, stringArray);\n        configValues.put(new String[0], new String[0]);\n        configValues.put(new HashSet(), new String[0]);\n        configValues.put(ImmutableSet.of(), new String[0]);\n        configValues.put(new ArrayList(), new String[0]);\n        configValues.put(ConfigurationParameters.EMPTY, new String[0]);\n\n        for (Object value : configValues.keySet()) {\n            ConfigurationParameters config;\n            if (value instanceof ConfigurationParameters) {\n                config = ConfigurationParameters.of((ConfigurationParameters) value);\n            } else {\n                config = ConfigurationParameters.of(\"key\", value);\n            }\n            Object[] expected = configValues.get(value);\n\n            assertArrayEquals(expected, config.getConfigValue(\"key\", new String[0]));\n            assertArrayEquals(expected, config.getConfigValue(\"key\", new String[0], String[].class));\n\n            // test with default values\n            if (!config.containsKey(\"key\")) {\n                assertArrayEquals(defaultStrings, config.getConfigValue(\"key\", defaultStrings, String[].class));\n                assertArrayEquals(null, config.getConfigValue(\"key\", null, String[].class));\n                assertArrayEquals(defaultStrings, config.getConfigValue(\"key\", defaultStrings));\n            } else {\n                assertArrayEquals(expected, config.getConfigValue(\"key\", defaultStrings, String[].class));\n                assertArrayEquals(expected, config.getConfigValue(\"key\", null, String[].class));\n                assertArrayEquals(expected, config.getConfigValue(\"key\", defaultStrings));\n            }\n\n            // non existing kez with default values\n            assertArrayEquals(defaultStrings, config.getConfigValue(\"nonexisting\", defaultStrings));\n            assertArrayEquals(defaultStrings, config.getConfigValue(\"nonexisting\", defaultStrings, String[].class));\n        }\n    }","commit_id":"7fe87c1cfa0b3a4149b1db25baf8afa8cbf56c70","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        Map<String, String[]> map = new HashMap<String, String[]>();\n        map.put(AccessControlAction.GROUP_PRIVILEGE_NAMES, new String[] {PrivilegeConstants.JCR_READ});\n        map.put(AccessControlAction.USER_PRIVILEGE_NAMES, new String[] {PrivilegeConstants.JCR_ALL});\n\n        ConfigurationParameters userConfig = ConfigurationParameters.of(map);\n        return ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, userConfig));\n    }","id":92121,"modified_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters userConfig = ConfigurationParameters.of(\n                AccessControlAction.GROUP_PRIVILEGE_NAMES, new String[] {PrivilegeConstants.JCR_READ},\n                AccessControlAction.USER_PRIVILEGE_NAMES, new String[] {PrivilegeConstants.JCR_ALL}\n        );\n        return ConfigurationParameters.of(UserConfiguration.NAME, userConfig);\n    }","commit_id":"3e74addfb8f3a87ce044c3ff75ecb6fcbdf966ce","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testPasswordValidationActionOnChange() throws Exception {\n        testUser = getUserManager(root).createUser(\"testuser\", \"testPw123456\");\n        root.commit();\n        try {\n            pwAction.init(getSecurityProvider(), ConfigurationParameters.of(Collections.singletonMap(PasswordValidationAction.CONSTRAINT, \"abc\")));\n\n            String hashed = PasswordUtil.buildPasswordHash(\"abc\");\n            testUser.changePassword(hashed);\n\n            fail(\"Password change must always enforce password validation.\");\n\n        } catch (ConstraintViolationException e) {\n            // success\n        }\n    }","id":92122,"modified_method":"@Test\n    public void testPasswordValidationActionOnChange() throws Exception {\n        testUser = getUserManager(root).createUser(\"testuser\", \"testPw123456\");\n        root.commit();\n        try {\n            pwAction.init(getSecurityProvider(), ConfigurationParameters.of(PasswordValidationAction.CONSTRAINT, \"abc\"));\n\n            String hashed = PasswordUtil.buildPasswordHash(\"abc\");\n            testUser.changePassword(hashed);\n\n            fail(\"Password change must always enforce password validation.\");\n\n        } catch (ConstraintViolationException e) {\n            // success\n        }\n    }","commit_id":"3e74addfb8f3a87ce044c3ff75ecb6fcbdf966ce","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public <T> T getConfiguration(Class<T> configClass) {\n            if (UserConfiguration.class == configClass) {\n                return (T) new UserConfigurationImpl(this) {\n                    @Nonnull\n                    @Override\n                    public ConfigurationParameters getParameters() {\n                        Map<String, AuthorizableActionProvider> m = Collections.singletonMap(UserConstants.PARAM_AUTHORIZABLE_ACTION_PROVIDER, actionProvider);\n                        return ConfigurationParameters.of(super.getParameters(), ConfigurationParameters.of(m));\n                    }\n                };\n            } else {\n                return super.getConfiguration(configClass);\n            }\n        }","id":92123,"modified_method":"public <T> T getConfiguration(Class<T> configClass) {\n            if (UserConfiguration.class == configClass) {\n                return (T) new UserConfigurationImpl(this) {\n                    @Nonnull\n                    @Override\n                    public ConfigurationParameters getParameters() {\n                        return ConfigurationParameters.of(super.getParameters(),\n                                ConfigurationParameters.of(UserConstants.PARAM_AUTHORIZABLE_ACTION_PROVIDER, actionProvider));\n                    }\n                };\n            } else {\n                return super.getConfiguration(configClass);\n            }\n        }","commit_id":"3e74addfb8f3a87ce044c3ff75ecb6fcbdf966ce","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Before\n    public void before() throws Exception {\n        super.before();\n\n        user = (User) getUserManager(root).getAuthorizable(adminSession.getAuthInfo().getUserID());\n\n        testAction.reset();\n        pwAction.init(getSecurityProvider(), ConfigurationParameters.of(\n                Collections.singletonMap(PasswordValidationAction.CONSTRAINT, \"^.*(?=.{8,})(?=.*[a-z])(?=.*[A-Z]).*\")));\n\n    }","id":92124,"modified_method":"@Before\n    public void before() throws Exception {\n        super.before();\n\n        user = (User) getUserManager(root).getAuthorizable(adminSession.getAuthInfo().getUserID());\n\n        testAction.reset();\n        pwAction.init(getSecurityProvider(), ConfigurationParameters.of(\n                PasswordValidationAction.CONSTRAINT, \"^.*(?=.{8,})(?=.*[a-z])(?=.*[A-Z]).*\"));\n\n    }","commit_id":"3e74addfb8f3a87ce044c3ff75ecb6fcbdf966ce","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@CheckForNull\n    protected ConfigurationParameters getConfigurationParameters() {\n        String importBehavior = getImportBehavior();\n        if (importBehavior != null) {\n            Map<String, String> userParams = new HashMap<String, String>();\n            userParams.put(ProtectedItemImporter.PARAM_IMPORT_BEHAVIOR, getImportBehavior());\n            return ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, ConfigurationParameters.of(userParams)));\n        } else {\n            return null;\n        }\n    }","id":92125,"modified_method":"@CheckForNull\n    protected ConfigurationParameters getConfigurationParameters() {\n        String importBehavior = getImportBehavior();\n        if (importBehavior != null) {\n            Map<String, String> userParams = new HashMap<String, String>();\n            userParams.put(ProtectedItemImporter.PARAM_IMPORT_BEHAVIOR, getImportBehavior());\n            return ConfigurationParameters.of(UserConfiguration.NAME, ConfigurationParameters.of(userParams));\n        } else {\n            return null;\n        }\n    }","commit_id":"a0489842b66bd47611843cb5247be6e539e68600","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@CheckForNull\n    protected ConfigurationParameters getConfigurationParameters() {\n        HashMap<String, Object> userParams = new HashMap<String, Object>() {{\n            put(UserConstants.PARAM_PASSWORD_MAX_AGE, 10);\n        }};\n        return ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, ConfigurationParameters.of(userParams)));\n    }","id":92126,"modified_method":"@CheckForNull\n    protected ConfigurationParameters getConfigurationParameters() {\n        HashMap<String, Object> userParams = new HashMap<String, Object>() {{\n            put(UserConstants.PARAM_PASSWORD_MAX_AGE, 10);\n        }};\n        return ConfigurationParameters.of(UserConfiguration.NAME, ConfigurationParameters.of(userParams));\n    }","commit_id":"a0489842b66bd47611843cb5247be6e539e68600","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ConfigurationParameters getConfigurationParameters() {\n        Map<String, Object> userParams = new HashMap<String, Object>();\n        userParams.put(UserConstants.PARAM_AUTHORIZABLE_ACTION_PROVIDER, actionProvider);\n        return ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, ConfigurationParameters.of(userParams)));\n    }","id":92127,"modified_method":"@Override\n    protected ConfigurationParameters getConfigurationParameters() {\n        Map<String, Object> userParams = new HashMap<String, Object>();\n        userParams.put(UserConstants.PARAM_AUTHORIZABLE_ACTION_PROVIDER, actionProvider);\n        return ConfigurationParameters.of(UserConfiguration.NAME, ConfigurationParameters.of(userParams));\n    }","commit_id":"a0489842b66bd47611843cb5247be6e539e68600","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testAccessControlActionExecutionForUser() throws Exception {\n        AccessControlAction a1 = new AccessControlAction();\n        a1.init(securityProvider, ConfigurationParameters.of(Collections.singletonMap(AccessControlAction.USER_PRIVILEGE_NAMES, new String[] {Privilege.JCR_ALL})));\n\n        setAuthorizableActions(a1);\n\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"t\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:User<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:password\\\" sv:type=\\\"String\\\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>tPrincipal<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        doImport(USERPATH, xml);\n\n        Authorizable a = userMgr.getAuthorizable(\"t\");\n        assertNotNull(a);\n        assertFalse(a.isGroup());\n\n        AccessControlManager acMgr = adminSession.getAccessControlManager();\n        AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());\n        assertNotNull(policies);\n        assertEquals(1, policies.length);\n        assertTrue(policies[0] instanceof AccessControlList);\n\n        AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();\n        assertEquals(1, aces.length);\n        assertEquals(\"tPrincipal\", aces[0].getPrincipal().getName());\n    }","id":92128,"modified_method":"@Test\n    public void testAccessControlActionExecutionForUser() throws Exception {\n        AccessControlAction a1 = new AccessControlAction();\n        a1.init(securityProvider, ConfigurationParameters.of(AccessControlAction.USER_PRIVILEGE_NAMES, new String[] {Privilege.JCR_ALL}));\n\n        setAuthorizableActions(a1);\n\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"t\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:User<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:password\\\" sv:type=\\\"String\\\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>tPrincipal<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        doImport(USERPATH, xml);\n\n        Authorizable a = userMgr.getAuthorizable(\"t\");\n        assertNotNull(a);\n        assertFalse(a.isGroup());\n\n        AccessControlManager acMgr = adminSession.getAccessControlManager();\n        AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());\n        assertNotNull(policies);\n        assertEquals(1, policies.length);\n        assertTrue(policies[0] instanceof AccessControlList);\n\n        AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();\n        assertEquals(1, aces.length);\n        assertEquals(\"tPrincipal\", aces[0].getPrincipal().getName());\n    }","commit_id":"a0489842b66bd47611843cb5247be6e539e68600","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testAccessControlActionExecutionForUser2() throws Exception {\n        AccessControlAction a1 = new AccessControlAction();\n        a1.init(securityProvider, ConfigurationParameters.of(Collections.singletonMap(AccessControlAction.USER_PRIVILEGE_NAMES, new String[] {Privilege.JCR_ALL})));\n        setAuthorizableActions(a1);\n\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"t\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:User<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>tPrincipal<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:password\\\" sv:type=\\\"String\\\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        doImport(USERPATH, xml);\n\n        Authorizable a = userMgr.getAuthorizable(\"t\");\n        assertNotNull(a);\n        assertFalse(a.isGroup());\n\n        AccessControlManager acMgr = adminSession.getAccessControlManager();\n        AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());\n        assertNotNull(policies);\n        assertEquals(1, policies.length);\n        assertTrue(policies[0] instanceof AccessControlList);\n\n        AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();\n        assertEquals(1, aces.length);\n        assertEquals(\"tPrincipal\", aces[0].getPrincipal().getName());\n    }","id":92129,"modified_method":"@Test\n    public void testAccessControlActionExecutionForUser2() throws Exception {\n        AccessControlAction a1 = new AccessControlAction();\n        a1.init(securityProvider, ConfigurationParameters.of(AccessControlAction.USER_PRIVILEGE_NAMES, new String[] {Privilege.JCR_ALL}));\n        setAuthorizableActions(a1);\n\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"t\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:User<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>tPrincipal<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:password\\\" sv:type=\\\"String\\\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        doImport(USERPATH, xml);\n\n        Authorizable a = userMgr.getAuthorizable(\"t\");\n        assertNotNull(a);\n        assertFalse(a.isGroup());\n\n        AccessControlManager acMgr = adminSession.getAccessControlManager();\n        AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());\n        assertNotNull(policies);\n        assertEquals(1, policies.length);\n        assertTrue(policies[0] instanceof AccessControlList);\n\n        AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();\n        assertEquals(1, aces.length);\n        assertEquals(\"tPrincipal\", aces[0].getPrincipal().getName());\n    }","commit_id":"a0489842b66bd47611843cb5247be6e539e68600","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testAccessControlActionExecutionForGroup() throws Exception {\n        AccessControlAction a1 = new AccessControlAction();\n        a1.init(securityProvider, ConfigurationParameters.of(Collections.singletonMap(AccessControlAction.GROUP_PRIVILEGE_NAMES, new String[] {Privilege.JCR_READ})));\n        setAuthorizableActions(a1);\n\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"g\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:Group<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>gPrincipal<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        doImport(GROUPPATH, xml);\n\n        Authorizable a = userMgr.getAuthorizable(\"g\");\n        assertNotNull(a);\n        assertTrue(a.isGroup());\n\n        AccessControlManager acMgr = adminSession.getAccessControlManager();\n        AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());\n        assertNotNull(policies);\n        assertEquals(1, policies.length);\n        assertTrue(policies[0] instanceof AccessControlList);\n\n        AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();\n        assertEquals(1, aces.length);\n        assertEquals(\"gPrincipal\", aces[0].getPrincipal().getName());\n    }","id":92130,"modified_method":"@Test\n    public void testAccessControlActionExecutionForGroup() throws Exception {\n        AccessControlAction a1 = new AccessControlAction();\n        a1.init(securityProvider, ConfigurationParameters.of(AccessControlAction.GROUP_PRIVILEGE_NAMES, new String[] {Privilege.JCR_READ}));\n        setAuthorizableActions(a1);\n\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"g\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:Group<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>gPrincipal<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        doImport(GROUPPATH, xml);\n\n        Authorizable a = userMgr.getAuthorizable(\"g\");\n        assertNotNull(a);\n        assertTrue(a.isGroup());\n\n        AccessControlManager acMgr = adminSession.getAccessControlManager();\n        AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());\n        assertNotNull(policies);\n        assertEquals(1, policies.length);\n        assertTrue(policies[0] instanceof AccessControlList);\n\n        AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();\n        assertEquals(1, aces.length);\n        assertEquals(\"gPrincipal\", aces[0].getPrincipal().getName());\n    }","commit_id":"a0489842b66bd47611843cb5247be6e539e68600","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters userConfig = ConfigurationParameters.of(\n                Collections.singletonMap(UserConstants.PARAM_SUPPORT_AUTOSAVE, Boolean.TRUE));\n        return ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, userConfig));\n    }","id":92131,"modified_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters userConfig = ConfigurationParameters.of(\n                UserConstants.PARAM_SUPPORT_AUTOSAVE, Boolean.TRUE);\n        return ConfigurationParameters.of(UserConfiguration.NAME, userConfig);\n    }","commit_id":"9a9cbb0ded7adbd6b7be9033791b37209f762b37","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters parameters = ConfigurationParameters.of(new HashMap<String, Object>() {{\n            put(UserConstants.PARAM_PASSWORD_MAX_AGE, 10);\n            put(UserConstants.PARAM_PASSWORD_INITIAL_CHANGE, true);\n        }});\n        return ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, parameters));\n    }","id":92132,"modified_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters parameters = ConfigurationParameters.of(\n                UserConstants.PARAM_PASSWORD_MAX_AGE, 10,\n                UserConstants.PARAM_PASSWORD_INITIAL_CHANGE, true);\n        return ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, parameters));\n    }","commit_id":"9a9cbb0ded7adbd6b7be9033791b37209f762b37","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters userConfig = ConfigurationParameters.of(\n                ImmutableMap.of(\n                        UserConstants.PARAM_PASSWORD_MAX_AGE, 10,\n                        UserConstants.PARAM_SUPPORT_AUTOSAVE, true));\n        return ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, userConfig));\n    }","id":92133,"modified_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters userConfig = ConfigurationParameters.of(\n                UserConstants.PARAM_PASSWORD_MAX_AGE, 10,\n                UserConstants.PARAM_SUPPORT_AUTOSAVE, true);\n        return ConfigurationParameters.of(UserConfiguration.NAME, userConfig);\n    }","commit_id":"9a9cbb0ded7adbd6b7be9033791b37209f762b37","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters userConfig = ConfigurationParameters.of(UserConstants.PARAM_PASSWORD_MAX_AGE, 10);\n        return ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, userConfig));\n    }","id":92134,"modified_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters userConfig = ConfigurationParameters.of(UserConstants.PARAM_PASSWORD_MAX_AGE, 10);\n        return ConfigurationParameters.of(UserConfiguration.NAME, userConfig);\n    }","commit_id":"9a9cbb0ded7adbd6b7be9033791b37209f762b37","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters userConfig = ConfigurationParameters.of(\n                UserConstants.PARAM_PASSWORD_INITIAL_CHANGE, true);\n        return ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, userConfig));\n    }","id":92135,"modified_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters userConfig = ConfigurationParameters.of(\n                UserConstants.PARAM_PASSWORD_INITIAL_CHANGE, true);\n        return ConfigurationParameters.of(UserConfiguration.NAME, userConfig);\n    }","commit_id":"9a9cbb0ded7adbd6b7be9033791b37209f762b37","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters userConfig = ConfigurationParameters.of(UserConstants.PARAM_AUTHORIZABLE_NODE_NAME, nameGenerator);\n        return ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, userConfig));\n    }","id":92136,"modified_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters userConfig = ConfigurationParameters.of(UserConstants.PARAM_AUTHORIZABLE_NODE_NAME, nameGenerator);\n        return ConfigurationParameters.of(UserConfiguration.NAME, userConfig);\n    }","commit_id":"9a9cbb0ded7adbd6b7be9033791b37209f762b37","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters userConfig = ConfigurationParameters.of(UserConstants.PARAM_PASSWORD_MAX_AGE, 10);\n        return ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, userConfig));\n    }","id":92137,"modified_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters userConfig = ConfigurationParameters.of(UserConstants.PARAM_PASSWORD_MAX_AGE, 10);\n        return ConfigurationParameters.of(UserConfiguration.NAME, userConfig);\n    }","commit_id":"9a9cbb0ded7adbd6b7be9033791b37209f762b37","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        return ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, getParams()));\n    }","id":92138,"modified_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        return ConfigurationParameters.of(UserConfiguration.NAME, getParams());\n    }","commit_id":"9a9cbb0ded7adbd6b7be9033791b37209f762b37","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * @since OAK 1.0 The configuration defines if the password of the\n     * admin user is being set.\n     */\n    @Test\n    public void testAdminConfiguration() throws Exception {\n        Map<String,Object> userParams = new HashMap();\n        userParams.put(UserConstants.PARAM_ADMIN_ID, \"admin\");\n        userParams.put(UserConstants.PARAM_OMIT_ADMIN_PW, true);\n\n        ConfigurationParameters params = ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, ConfigurationParameters.of(userParams)));\n        SecurityProvider sp = new SecurityProviderImpl(params);\n        final ContentRepository repo = new Oak().with(new InitialContent())\n                .with(new PropertyIndexEditorProvider())\n                .with(new PropertyIndexProvider())\n                .with(new TypeEditorProvider())\n                .with(sp)\n                .createContentRepository();\n\n        ContentSession cs = Subject.doAs(SystemSubject.INSTANCE, new PrivilegedExceptionAction<ContentSession>() {\n            @Override\n            public ContentSession run() throws Exception {\n                return repo.login(null, null);\n            }\n        });\n        try {\n            Root root = cs.getLatestRoot();\n            UserConfiguration uc = sp.getConfiguration(UserConfiguration.class);\n            UserManager umgr = uc.getUserManager(root, NamePathMapper.DEFAULT);\n            Authorizable adminUser = umgr.getAuthorizable(\"admin\");\n            assertNotNull(adminUser);\n\n            Tree adminTree = root.getTree(adminUser.getPath());\n            assertTrue(adminTree.exists());\n            assertNull(adminTree.getProperty(UserConstants.REP_PASSWORD));\n        } finally {\n            cs.close();\n        }\n\n        // login as admin should fail\n        ContentSession adminSession = null;\n        try {\n            adminSession = repo.login(new SimpleCredentials(\"admin\", new char[0]), null);\n            fail();\n        } catch (LoginException e) {\n            //success\n        } finally {\n            if (adminSession != null) {\n                adminSession.close();\n            }\n        }\n    }","id":92139,"modified_method":"/**\n     * @since OAK 1.0 The configuration defines if the password of the\n     * admin user is being set.\n     */\n    @Test\n    public void testAdminConfiguration() throws Exception {\n        Map<String,Object> userParams = new HashMap();\n        userParams.put(UserConstants.PARAM_ADMIN_ID, \"admin\");\n        userParams.put(UserConstants.PARAM_OMIT_ADMIN_PW, true);\n\n        ConfigurationParameters params = ConfigurationParameters.of(UserConfiguration.NAME, ConfigurationParameters.of(userParams));\n        SecurityProvider sp = new SecurityProviderImpl(params);\n        final ContentRepository repo = new Oak().with(new InitialContent())\n                .with(new PropertyIndexEditorProvider())\n                .with(new PropertyIndexProvider())\n                .with(new TypeEditorProvider())\n                .with(sp)\n                .createContentRepository();\n\n        ContentSession cs = Subject.doAs(SystemSubject.INSTANCE, new PrivilegedExceptionAction<ContentSession>() {\n            @Override\n            public ContentSession run() throws Exception {\n                return repo.login(null, null);\n            }\n        });\n        try {\n            Root root = cs.getLatestRoot();\n            UserConfiguration uc = sp.getConfiguration(UserConfiguration.class);\n            UserManager umgr = uc.getUserManager(root, NamePathMapper.DEFAULT);\n            Authorizable adminUser = umgr.getAuthorizable(\"admin\");\n            assertNotNull(adminUser);\n\n            Tree adminTree = root.getTree(adminUser.getPath());\n            assertTrue(adminTree.exists());\n            assertNull(adminTree.getProperty(UserConstants.REP_PASSWORD));\n        } finally {\n            cs.close();\n        }\n\n        // login as admin should fail\n        ContentSession adminSession = null;\n        try {\n            adminSession = repo.login(new SimpleCredentials(\"admin\", new char[0]), null);\n            fail();\n        } catch (LoginException e) {\n            //success\n        } finally {\n            if (adminSession != null) {\n                adminSession.close();\n            }\n        }\n    }","commit_id":"9a9cbb0ded7adbd6b7be9033791b37209f762b37","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * @since OAK 1.0 The anonymous user is optional.\n     */\n    @Test\n    public void testAnonymousConfiguration() throws Exception {\n        Map<String,Object> userParams = new HashMap();\n        userParams.put(UserConstants.PARAM_ANONYMOUS_ID, \"\");\n\n        ConfigurationParameters params = ConfigurationParameters.of(ImmutableMap.of(UserConfiguration.NAME, ConfigurationParameters.of(userParams)));\n        SecurityProvider sp = new SecurityProviderImpl(params);\n        final ContentRepository repo = new Oak().with(new InitialContent())\n                .with(new PropertyIndexEditorProvider())\n                .with(new PropertyIndexProvider())\n                .with(new TypeEditorProvider())\n                .with(sp)\n                .createContentRepository();\n\n        ContentSession cs = Subject.doAs(SystemSubject.INSTANCE, new PrivilegedExceptionAction<ContentSession>() {\n            @Override\n            public ContentSession run() throws Exception {\n                return repo.login(null, null);\n            }\n        });\n        try {\n            Root root = cs.getLatestRoot();\n            UserConfiguration uc = sp.getConfiguration(UserConfiguration.class);\n            UserManager umgr = uc.getUserManager(root, NamePathMapper.DEFAULT);\n            Authorizable anonymous = umgr.getAuthorizable(UserConstants.DEFAULT_ANONYMOUS_ID);\n            assertNull(anonymous);\n        } finally {\n            cs.close();\n        }\n\n        // login as admin should fail\n        ContentSession anonymousSession = null;\n        try {\n            anonymousSession = repo.login(new GuestCredentials(), null);\n            fail();\n        } catch (LoginException e) {\n            //success\n        } finally {\n            if (anonymousSession != null) {\n                anonymousSession.close();\n            }\n        }\n    }","id":92140,"modified_method":"/**\n     * @since OAK 1.0 The anonymous user is optional.\n     */\n    @Test\n    public void testAnonymousConfiguration() throws Exception {\n        Map<String,Object> userParams = new HashMap();\n        userParams.put(UserConstants.PARAM_ANONYMOUS_ID, \"\");\n\n        ConfigurationParameters params = ConfigurationParameters.of(UserConfiguration.NAME, ConfigurationParameters.of(userParams));\n        SecurityProvider sp = new SecurityProviderImpl(params);\n        final ContentRepository repo = new Oak().with(new InitialContent())\n                .with(new PropertyIndexEditorProvider())\n                .with(new PropertyIndexProvider())\n                .with(new TypeEditorProvider())\n                .with(sp)\n                .createContentRepository();\n\n        ContentSession cs = Subject.doAs(SystemSubject.INSTANCE, new PrivilegedExceptionAction<ContentSession>() {\n            @Override\n            public ContentSession run() throws Exception {\n                return repo.login(null, null);\n            }\n        });\n        try {\n            Root root = cs.getLatestRoot();\n            UserConfiguration uc = sp.getConfiguration(UserConfiguration.class);\n            UserManager umgr = uc.getUserManager(root, NamePathMapper.DEFAULT);\n            Authorizable anonymous = umgr.getAuthorizable(UserConstants.DEFAULT_ANONYMOUS_ID);\n            assertNull(anonymous);\n        } finally {\n            cs.close();\n        }\n\n        // login as admin should fail\n        ContentSession anonymousSession = null;\n        try {\n            anonymousSession = repo.login(new GuestCredentials(), null);\n            fail();\n        } catch (LoginException e) {\n            //success\n        } finally {\n            if (anonymousSession != null) {\n                anonymousSession.close();\n            }\n        }\n    }","commit_id":"9a9cbb0ded7adbd6b7be9033791b37209f762b37","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters config = ConfigurationParameters.of(\n                Collections.singletonMap(TokenProviderImpl.PARAM_TOKEN_EXPIRATION, 60));\n        return ConfigurationParameters.of(ImmutableMap.of(TokenConfiguration.NAME, config));\n    }","id":92141,"modified_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters config = ConfigurationParameters.of(TokenProviderImpl.PARAM_TOKEN_EXPIRATION, 60);\n        return ConfigurationParameters.of(TokenConfiguration.NAME, config);\n    }","commit_id":"b80a6331e9cb1a491a4af02b510706c7dab1068c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void appendAttributes(Txn transaction, NodeList attribs) throws DOMException {\n    \tNodeList duplicateAttrs = findDupAttributes(attribs);\n    \tif(duplicateAttrs != null) {\n    \t\tremoveAppendAttributes(transaction, duplicateAttrs, attribs);\n    \t} else {\n    \t\tNodeImplRef last = new NodeImplRef(this);\n            final DocumentImpl owner = (DocumentImpl)getOwnerDocument();\n\t        if (children == 0) {\n\t            // no children: append a new child\n\t            appendChildren(transaction, null, firstChildID(), last, getPath(), attribs, true);\n\t        }\n\t        else {\n\t            final int level = owner.getTreeLevel(getGID());\n                owner.getMetadata().setReindexRequired(level + 1);\n                final StoredNode lastAttrib = getLastAttribute();\n\t            if (lastAttrib == null || lastAttrib.getGID() != lastChildID()) {\n                    appendChildren(transaction, null, firstChildID() + 1, last, getPath(), attribs, true);\n\t            } else {\n                   \tlast.setNode(lastAttrib);\n                    appendChildren(transaction, null, lastChildID() + 1, last, getPath(), attribs, true);\n\t            }\n\t        }\n\t        attributes += attribs.getLength();\n            getBroker().updateNode(transaction, this);\n            getBroker().reindexXMLResource(transaction, owner, owner, null);\n    \t}\n    }","id":92142,"modified_method":"public void appendAttributes(Txn transaction, NodeList attribs) throws DOMException {\n    \tNodeList duplicateAttrs = findDupAttributes(attribs);\n    \tremoveAppendAttributes(transaction, duplicateAttrs, attribs);\n//    \tif(duplicateAttrs != null) {\n//    \t\tremoveAppendAttributes(transaction, duplicateAttrs, attribs);\n//    \t} else {\n//    \t\tNodeImplRef last = new NodeImplRef(this);\n//            final DocumentImpl owner = (DocumentImpl)getOwnerDocument();\n//\t        if (children == 0) {\n//\t            // no children: append a new child\n//\t            appendChildren(transaction, nodeId.newChild(), -1, last, getPath(), attribs, true);\n//\t        }\n//\t        else {\n//\t        \tNamedNodeMap attrs = getAttributes();\n//                final StoredNode lastAttrib = (StoredNode) attrs.item(attrs.getLength() - 1);\n//\t            if (lastAttrib == null || attrs.getLength() == children) {\n//                    appendChildren(transaction, null, firstChildID() + 1, last, getPath(), attribs, true);\n//\t            } else {\n//                   \tlast.setNode(lastAttrib);\n//                    appendChildren(transaction, null, lastChildID() + 1, last, getPath(), attribs, true);\n//\t            }\n//\t        }\n//\t        attributes += attribs.getLength();\n//            getBroker().updateNode(transaction, this);\n//            getBroker().reindexXMLResource(transaction, owner, owner, null);\n//    \t}\n    }","commit_id":"9079d6f972b81a253c5776a4754a0f4d30397a96","url":"https://github.com/eXist-db/exist"},{"original_method":"public Node replaceChild(Txn transaction, Node newChild, Node oldChild) throws DOMException {\n        if (!(oldChild instanceof StoredNode))\n            throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, \"wrong node type\");\n        StoredNode oldNode = (StoredNode) oldChild;\n        if (oldNode.getParentGID() != getGID())\n            throw new DOMException(DOMException.NOT_FOUND_ERR,\n                    \"node is not a child of this element\");        \n        StoredNode previous = (StoredNode) oldNode.getPreviousSibling();\n        if (previous == null)\n            previous = this;\n        else\n            previous = getLastNode(previous);\n        getBroker().removeAllNodes(transaction, oldNode, oldNode.getPath());\n        getBroker().endRemove();\n        appendChild(transaction, null, oldNode.getGID(), new NodeImplRef(previous), getPath(), newChild, true);\n        // reindex if required\n        final DocumentImpl owner = (DocumentImpl)getOwnerDocument();\n        getBroker().reindexXMLResource(transaction, owner, owner, null);\n        getBroker().storeXMLResource(transaction, owner);\n        return oldChild;\t// method is spec'd to return the old child, even though that's probably useless in this case\n    }","id":92143,"modified_method":"public Node replaceChild(Txn transaction, Node newChild, Node oldChild) throws DOMException {\n        if (!(oldChild instanceof StoredNode))\n            throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, \"wrong node type\");\n        StoredNode oldNode = (StoredNode) oldChild;\n        if (!oldNode.nodeId.getParentId().equals(nodeId))\n            throw new DOMException(DOMException.NOT_FOUND_ERR,\n                    \"node is not a child of this element\");        \n        StoredNode previous = (StoredNode) oldNode.getPreviousSibling();\n        if (previous == null)\n            previous = this;\n        else\n            previous = getLastNode(previous);\n        getBroker().removeAllNodes(transaction, oldNode, oldNode.getPath());\n        getBroker().endRemove();\n        appendChild(transaction, oldNode.nodeId, -1, new NodeImplRef(previous), getPath(), newChild, true);\n        // reindex if required\n        final DocumentImpl owner = (DocumentImpl)getOwnerDocument();\n        getBroker().storeXMLResource(transaction, owner);\n        getBroker().flush();\n        return oldChild;\t// method is spec'd to return the old child, even though that's probably useless in this case\n    }","commit_id":"9079d6f972b81a253c5776a4754a0f4d30397a96","url":"https://github.com/eXist-db/exist"},{"original_method":"public void removeAppendAttributes(Txn transaction, NodeList removeList, NodeList appendList) {\n        final DocumentImpl owner = (DocumentImpl)getOwnerDocument();\n\t\tfinal int level = owner.getTreeLevel(getGID());\t\t\n\t\tfinal long lastChild = lastChildID();\t\t\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tfor (int i=0; i<removeList.getLength(); i++) {\n\t\t\t\t\tNode oldChild = removeList.item(i);\n\t\t\t\t\tif (!(oldChild instanceof StoredNode))\n\t\t\t\t\t\tthrow new DOMException(DOMException.WRONG_DOCUMENT_ERR, \"wrong node type\");\n\t\t\t\t\tStoredNode old = (StoredNode) oldChild;\n\t\t\t\t\tif (old.getParentGID() != getGID())\n\t\t\t\t\t\tthrow new DOMException(DOMException.NOT_FOUND_ERR, \"node is not a child of this element\");\n                    getBroker().removeNode(transaction, old, old.getPath(), null);\n\t\t\t\t\tif(old.getGID() < lastChild) owner.getMetadata().setReindexRequired(level + 1);\n\t\t\t\t\tchildren--;\n\t\t\t\t\tattributes--;\n\t\t\t\t}\n\t\t\t} finally {\n                getBroker().endRemove();\n\t\t\t}\t\t\t\n\t\t\tif (children == 0) {\n\t\t\t   appendChildren(transaction, null, firstChildID(), new NodeImplRef(this), getPath(), appendList, true);\n\t\t\t} else {\n\t\t\t    StoredNode lastAttrib = getLastAttribute();\n\t\t\t    if (lastAttrib == null || lastAttrib.getGID() != lastChildID())\n                    appendChildren(transaction, null, firstChildID() + 1, new NodeImplRef(this), getPath(), appendList, true);                    \n\t\t\t    else\n                    appendChildren(transaction, null, lastChildID() + 1, new NodeImplRef(lastAttrib), getPath(), appendList, true);\t\t\t        \n\t\t\t}\n\t\t\tattributes += appendList.getLength();\n\t\t} finally {\n            getBroker().updateNode(transaction, this);\n            getBroker().reindexXMLResource(transaction, owner, owner, null);\n\t\t}\n\t}","id":92144,"modified_method":"public void removeAppendAttributes(Txn transaction, NodeList removeList, NodeList appendList) {\n        final DocumentImpl owner = (DocumentImpl)getOwnerDocument();\n\t\ttry {\n\t\t\tif (removeList != null) {\n\t\t\t\ttry {\n\t\t\t\t\tfor (int i=0; i<removeList.getLength(); i++) {\n\t\t\t\t\t\tNode oldChild = removeList.item(i);\n\t\t\t\t\t\tif (!(oldChild instanceof StoredNode))\n\t\t\t\t\t\t\tthrow new DOMException(DOMException.WRONG_DOCUMENT_ERR, \"wrong node type\");\n\t\t\t\t\t\tStoredNode old = (StoredNode) oldChild;\n\t\t\t\t\t\tif (!old.nodeId.isChildOf(nodeId))\n\t\t\t\t\t\t\tthrow new DOMException(DOMException.NOT_FOUND_ERR, \"node \" + old.nodeId.getParentId() + \n\t\t\t\t\t\t\t\t\t\" is not a child of element \" + nodeId);\n\t\t\t\t\t\tgetBroker().removeNode(transaction, old, old.getPath(), null);\n\t\t\t\t\t\tchildren--;\n\t\t\t\t\t\tattributes--;\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tgetBroker().endRemove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (children == 0) {\n\t\t\t   appendChildren(transaction, nodeId.newChild(), -1, \n\t\t\t\t\t   new NodeImplRef(this), getPath(), appendList, true);\n\t\t\t} else {\n\t\t        if (attributes == 0) {\n\t\t        \tStoredNode firstChild = (StoredNode) getFirstChild();\n\t\t        \tNodeId newNodeId = firstChild.nodeId.insertBefore();\n                    appendChildren(transaction, newNodeId, -1, new NodeImplRef(this), getPath(), appendList, true);                    \n\t\t        } else {\n\t\t        \tAttribVisitor visitor = new AttribVisitor();\n\t\t\t        accept(visitor);\n\t\t\t        NodeId firstChildId = visitor.firstChild == null ? null : visitor.firstChild.nodeId;\n\t\t\t        NodeId newNodeId = visitor.lastAttrib.nodeId.insertNode(firstChildId);\n                    appendChildren(transaction, newNodeId, -1, new NodeImplRef(visitor.lastAttrib), \n                    \t\tgetPath(), appendList, true);\n\t\t        }\n\t\t\t}\n\t\t\tattributes += appendList.getLength();\n\t\t} finally {\n            getBroker().updateNode(transaction, this);\n            getBroker().flush();\n\t\t}\n\t}","commit_id":"9079d6f972b81a253c5776a4754a0f4d30397a96","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Returns a list of all attribute nodes in attrs that are already present\n     * in the current element.\n     *\n     * @param attrs\n     * @return\n     * @throws DOMException\n     */\n    private NodeList findDupAttributes(NodeList attrs) throws DOMException {\n    \tNodeListImpl dupList = null;\n    \tlong start = firstChildID();\n        for (long i = start; i < start + children; i++) {\n            Node child = ((DocumentImpl)getOwnerDocument()).getNode(i);\n            if (child.getNodeType() != Node.ATTRIBUTE_NODE)\n            \tbreak;\n            Node duplicate = findAttribute(child, attrs);\n            if (duplicate != null) {\n            \tLOG.debug(\"Found a duplicate attribute for '\" + child + \"':'\" + duplicate + \"'\");\n            \tif (dupList == null)\n            \t\tdupList = new NodeListImpl();\n            \tdupList.add(child);\n            }\n        }\n        return dupList;\n    }","id":92145,"modified_method":"/**\n     * Returns a list of all attribute nodes in attrs that are already present\n     * in the current element.\n     *\n     * @param attrs\n     * @return\n     * @throws DOMException\n     */\n    private NodeList findDupAttributes(NodeList attrs) throws DOMException {\n    \tNodeListImpl dupList = null;\n    \tNamedNodeMap map = getAttributes();\n    \tfor (int i = 0; i < attrs.getLength(); i++) {\n    \t\tNode attr = attrs.item(i);\n    \t\tNode duplicate = map.getNamedItemNS(attr.getNamespaceURI(), attr.getLocalName());\n    \t\tif (duplicate != null) {\n    \t\t\tif (dupList == null)\n            \t\tdupList = new NodeListImpl();\n            \tdupList.add(duplicate);\n    \t\t}\n    \t}\n        return dupList;\n    }","commit_id":"9079d6f972b81a253c5776a4754a0f4d30397a96","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * @see org.w3c.dom.Node#removeChild(org.w3c.dom.Node)\n     */\n    public Node removeChild(Txn transaction, Node oldChild) throws DOMException {\n        if (!(oldChild instanceof StoredNode))\n            throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, \"wrong node type\");\n        final StoredNode oldNode = (StoredNode) oldChild;\n        if (oldNode.getParentGID() != getGID())\n            throw new DOMException(DOMException.NOT_FOUND_ERR,\n                    \"node is not a child of this element\");\n        final DocumentImpl owner = (DocumentImpl)getOwnerDocument();\n        final int level = owner.getTreeLevel(getGID());        \n        final long lastChild = lastChildID();\n        getBroker().removeAllNodes(transaction, oldNode, oldNode.getPath());\n        --children;\n        getBroker().endRemove();\n        getBroker().updateNode(transaction, this);\n        if (oldNode.getGID() < lastChild) {\n            owner.getMetadata().setReindexRequired(level + 1);\n            getBroker().reindexXMLResource(transaction, owner, owner, this);\n        }\n        return oldNode;\n    }","id":92146,"modified_method":"/**\n     * @see org.w3c.dom.Node#removeChild(org.w3c.dom.Node)\n     */\n    public Node removeChild(Txn transaction, Node oldChild) throws DOMException {\n        if (!(oldChild instanceof StoredNode))\n            throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, \"wrong node type\");\n        final StoredNode oldNode = (StoredNode) oldChild;\n        if (!oldNode.nodeId.getParentId().equals(nodeId))\n            throw new DOMException(DOMException.NOT_FOUND_ERR,\n                    \"node is not a child of this element\");\n        getBroker().removeAllNodes(transaction, oldNode, oldNode.getPath());\n        --children;\n        getBroker().endRemove();\n        getBroker().updateNode(transaction, this);\n        getBroker().flush();\n        return oldNode;\n    }","commit_id":"b449e00ce994dc42d97e981434c74c844b7efba3","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Update the contents of this element. The passed list of nodes\n     * becomes the new content.\n     *\n     * @param newContent\n     * @throws DOMException\n     */\n    public void update(Txn transaction, NodeList newContent) throws DOMException {\n        final NodePath path = getPath();        \n        // remove old child nodes\n        NodeList nodes = getChildNodes();\n        StoredNode child, last = this;\n        long firstChildId = firstChildID();\n        int i = nodes.getLength();\n        for (; i > 0; i--) {\n            child = (StoredNode) nodes.item(i - 1);\n            if (child.getNodeType() == Node.ATTRIBUTE_NODE) {\n                firstChildId = child.getGID() + 1;\n                last = child;\n                break;\n            }\n            if (child.getNodeType() == Node.ELEMENT_NODE)\n                path.addComponent(child.getQName());\n            getBroker().removeAllNodes(transaction, child, path);\n            if (child.getNodeType() == Node.ELEMENT_NODE)\n                path.removeLastComponent();\n        }\n        getBroker().endRemove();\n        children = i;\n        // append new content\n        appendChildren(transaction, null, firstChildId, new NodeImplRef(last), getPath(), newContent, true);\n        getBroker().updateNode(transaction, this);\n        // reindex if required\n        final DocumentImpl owner = (DocumentImpl)getOwnerDocument();\n        getBroker().reindexXMLResource(transaction, owner, owner, null);\n    }","id":92147,"modified_method":"/**\n     * Update the contents of this element. The passed list of nodes\n     * becomes the new content.\n     *\n     * @param newContent\n     * @throws DOMException\n     */\n    public void update(Txn transaction, NodeList newContent) throws DOMException {\n        final NodePath path = getPath();        \n        // remove old child nodes\n        NodeList nodes = getChildNodes();\n        StoredNode child, last = this;\n        int i = nodes.getLength();\n        for (; i > 0; i--) {\n            child = (StoredNode) nodes.item(i - 1);\n            if (child.getNodeType() == Node.ATTRIBUTE_NODE) {\n                last = child;\n                break;\n            }\n            if (child.getNodeType() == Node.ELEMENT_NODE)\n                path.addComponent(child.getQName());\n            getBroker().removeAllNodes(transaction, child, path);\n            if (child.getNodeType() == Node.ELEMENT_NODE)\n                path.removeLastComponent();\n        }\n        getBroker().endRemove();\n        children = i;\n        NodeId newNodeId = last == this ? nodeId.newChild() : last.nodeId.nextSibling();\n        // append new content\n        appendChildren(transaction, newNodeId, -1, new NodeImplRef(last), getPath(), newContent, true);\n        getBroker().updateNode(transaction, this);\n        // reindex if required\n        getBroker().flush();\n    }","commit_id":"b449e00ce994dc42d97e981434c74c844b7efba3","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Update a child node. This method will only update the child node\n     * but not its potential descendant nodes.\n     *\n     * @param oldChild\n     * @param newChild\n     * @throws DOMException\n     */\n    public void updateChild(Txn transaction, Node oldChild, Node newChild) throws DOMException {\n        if (!(oldChild instanceof StoredNode))\n            throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, \"wrong node type\");\n        if (!(newChild instanceof StoredNode))\n            throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, \"wrong node type\");\n        StoredNode oldNode = (StoredNode) oldChild;\n        StoredNode newNode = (StoredNode) newChild;\n        if (oldNode.getParentGID() != getGID())\n            throw new DOMException(DOMException.NOT_FOUND_ERR,\n                    \"node is not a child of this element\");\n        if (newNode.getNodeType() == Node.ATTRIBUTE_NODE) {\n        \tif (newNode.getQName().equalsSimple(Namespaces.XML_ID_QNAME)) {\n\t\t\t\t\t// an xml:id attribute. Normalize the attribute and set its type to ID\n        \t\tAttrImpl attr = (AttrImpl) newNode;\n        \t\tattr.setValue(StringValue.trimWhitespace(StringValue.collapseWhitespace(attr.getValue())));\n        \t\tattr.setType(AttrImpl.ID);\n        \t}\n        }        \n        StoredNode previousNode = (StoredNode) oldNode.getPreviousSibling();\n        if (previousNode == null)\n            previousNode = this;\n        else\n            previousNode = getLastNode(previousNode);\n        getBroker().removeNode(transaction, oldNode, oldNode.getPath(), null);\n        getBroker().endRemove();\n        newNode.setGID(oldNode.getGID());\n        getBroker().insertNodeAfter(transaction, previousNode, newNode);\n        NodePath path = newNode.getPath();\n        getBroker().indexNode(transaction, newNode, path);\n\t\tif (newNode.getNodeType() == Node.ELEMENT_NODE)\n            getBroker().endElement(newNode, path, null);\n        getBroker().flush();\n    }","id":92148,"modified_method":"/**\n     * Update a child node. This method will only update the child node\n     * but not its potential descendant nodes.\n     *\n     * @param oldChild\n     * @param newChild\n     * @throws DOMException\n     */\n    public void updateChild(Txn transaction, Node oldChild, Node newChild) throws DOMException {\n        if (!(oldChild instanceof StoredNode))\n            throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, \"wrong node type\");\n        if (!(newChild instanceof StoredNode))\n            throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, \"wrong node type\");\n        StoredNode oldNode = (StoredNode) oldChild;\n        StoredNode newNode = (StoredNode) newChild;\n        if (!oldNode.nodeId.getParentId().equals(nodeId))\n            throw new DOMException(DOMException.NOT_FOUND_ERR,\n                    \"node is not a child of this element\");\n        if (newNode.getNodeType() == Node.ATTRIBUTE_NODE) {\n        \tif (newNode.getQName().equalsSimple(Namespaces.XML_ID_QNAME)) {\n\t\t\t\t\t// an xml:id attribute. Normalize the attribute and set its type to ID\n        \t\tAttrImpl attr = (AttrImpl) newNode;\n        \t\tattr.setValue(StringValue.trimWhitespace(StringValue.collapseWhitespace(attr.getValue())));\n        \t\tattr.setType(AttrImpl.ID);\n        \t}\n        }\n        StoredNode previousNode = (StoredNode) oldNode.getPreviousSibling();\n        if (previousNode == null)\n            previousNode = this;\n        else\n            previousNode = getLastNode(previousNode);\n        getBroker().removeNode(transaction, oldNode, oldNode.getPath(), null);\n        getBroker().endRemove();\n        newNode.nodeId = oldNode.nodeId;\n        getBroker().insertNodeAfter(transaction, previousNode, newNode);\n        NodePath path = newNode.getPath();\n        getBroker().indexNode(transaction, newNode, path);\n\t\tif (newNode.getNodeType() == Node.ELEMENT_NODE)\n            getBroker().endElement(newNode, path, null);\n        getBroker().flush();\n    }","commit_id":"b449e00ce994dc42d97e981434c74c844b7efba3","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testAddSitesSiteTypePrivate() throws Exception {\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Sites\"),\n\t\t\tselenium.getText(\"//div[@id='so-sidebar']/h3\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//button[contains(.,'Add Site')]/span[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Add Site\"),\n\t\t\tselenium.getText(\"//button[contains(.,'Add Site')]/span[2]\"));\n\t\tselenium.clickAt(\"//button[contains(.,'Add Site')]/span[2]\",\n\t\t\tRuntimeVariables.replace(\"Add Site\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Information\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertTrue(selenium.isVisible(\"//input[@id='_5_WAR_soportlet_name']\"));\n\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_name']\",\n\t\t\tRuntimeVariables.replace(\"Private Site Name\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//textarea[@id='_5_WAR_soportlet_description']\"));\n\t\tselenium.type(\"//textarea[@id='_5_WAR_soportlet_description']\",\n\t\t\tRuntimeVariables.replace(\"Private Site Description\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Settings\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[2]\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\",\n\t\t\tRuntimeVariables.replace(\"Default Social Office Site\"));\n\t\tassertTrue(selenium.isVisible(\"//select[@id='_5_WAR_soportlet_type']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_type']\",\n\t\t\tRuntimeVariables.replace(\"Private\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[3]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Customization\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[3]\"));\n\t\tassertTrue(selenium.isChecked(\"//div[4]/span[1]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[2]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[3]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[4]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[5]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[6]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[7]/input\"));\n\t\tassertEquals(\"Save\", selenium.getValue(\"//input[@value='Save']\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//div[@class='portlet-msg-success']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request processed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Private Site Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\"));\n\t}","id":92149,"modified_method":"public void testAddSitesSiteTypePrivate() throws Exception {\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Sites\"),\n\t\t\tselenium.getText(\"//div[@id='so-sidebar']/h3\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//button[contains(.,'Add Site')]/span[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Add Site\"),\n\t\t\tselenium.getText(\"//button[contains(.,'Add Site')]/span[2]\"));\n\t\tselenium.clickAt(\"//button[contains(.,'Add Site')]/span[2]\",\n\t\t\tRuntimeVariables.replace(\"Add Site\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Information\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertTrue(selenium.isVisible(\"//input[@id='_5_WAR_soportlet_name']\"));\n\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_name']\",\n\t\t\tRuntimeVariables.replace(\"Private Site Name\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//textarea[@id='_5_WAR_soportlet_description']\"));\n\t\tselenium.type(\"//textarea[@id='_5_WAR_soportlet_description']\",\n\t\t\tRuntimeVariables.replace(\"Private Site Description\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Settings\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[2]\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\",\n\t\t\tRuntimeVariables.replace(\"Default Social Office Site\"));\n\t\tassertTrue(selenium.isVisible(\"//select[@id='_5_WAR_soportlet_type']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_type']\",\n\t\t\tRuntimeVariables.replace(\"Private\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[3]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Customization\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[3]\"));\n\t\tassertTrue(selenium.isChecked(\"//div[4]/span[1]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[2]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[3]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[4]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[5]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[6]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[7]/input\"));\n\t\tassertEquals(\"Save\", selenium.getValue(\"//input[@value='Save']\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\n\t\t\t\t\t\t\t\"Your request processed successfully.\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='portlet-msg-success']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request processed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Private Site Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\"));\n\t}","commit_id":"77b423763cacd168cf78639fdc6c519f8e72ca73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddSitesSiteTypePrivate() throws Exception {\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Sites\"),\n\t\t\tselenium.getText(\"//div[@id='so-sidebar']/h3\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//button[contains(.,'Add Site')]/span[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Add Site\"),\n\t\t\tselenium.getText(\"//button[contains(.,'Add Site')]/span[2]\"));\n\t\tselenium.clickAt(\"//button[contains(.,'Add Site')]/span[2]\",\n\t\t\tRuntimeVariables.replace(\"Add Site\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Information\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertTrue(selenium.isVisible(\"//input[@id='_5_WAR_soportlet_name']\"));\n\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_name']\",\n\t\t\tRuntimeVariables.replace(\"Private Site Name\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//textarea[@id='_5_WAR_soportlet_description']\"));\n\t\tselenium.type(\"//textarea[@id='_5_WAR_soportlet_description']\",\n\t\t\tRuntimeVariables.replace(\"Private Site Description\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Settings\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[2]\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\",\n\t\t\tRuntimeVariables.replace(\"Default Social Office Site\"));\n\t\tassertTrue(selenium.isVisible(\"//select[@id='_5_WAR_soportlet_type']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_type']\",\n\t\t\tRuntimeVariables.replace(\"Private\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[3]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Customization\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[3]\"));\n\t\tassertTrue(selenium.isChecked(\"//div[4]/span[1]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[2]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[3]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[4]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[5]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[6]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[7]/input\"));\n\t\tassertEquals(\"Save\", selenium.getValue(\"//input[@value='Save']\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//div[@class='portlet-msg-success']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request processed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Private Site Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\"));\n\t}","id":92150,"modified_method":"public void testAddSitesSiteTypePrivate() throws Exception {\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Sites\"),\n\t\t\tselenium.getText(\"//div[@id='so-sidebar']/h3\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//button[contains(.,'Add Site')]/span[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Add Site\"),\n\t\t\tselenium.getText(\"//button[contains(.,'Add Site')]/span[2]\"));\n\t\tselenium.clickAt(\"//button[contains(.,'Add Site')]/span[2]\",\n\t\t\tRuntimeVariables.replace(\"Add Site\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Information\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertTrue(selenium.isVisible(\"//input[@id='_5_WAR_soportlet_name']\"));\n\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_name']\",\n\t\t\tRuntimeVariables.replace(\"Private Site Name\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//textarea[@id='_5_WAR_soportlet_description']\"));\n\t\tselenium.type(\"//textarea[@id='_5_WAR_soportlet_description']\",\n\t\t\tRuntimeVariables.replace(\"Private Site Description\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Settings\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[2]\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\",\n\t\t\tRuntimeVariables.replace(\"Default Social Office Site\"));\n\t\tassertTrue(selenium.isVisible(\"//select[@id='_5_WAR_soportlet_type']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_type']\",\n\t\t\tRuntimeVariables.replace(\"Private\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[3]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Customization\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[3]\"));\n\t\tassertTrue(selenium.isChecked(\"//div[4]/span[1]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[2]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[3]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[4]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[5]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[6]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[7]/input\"));\n\t\tassertEquals(\"Save\", selenium.getValue(\"//input[@value='Save']\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\n\t\t\t\t\t\t\t\"Your request processed successfully.\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='portlet-msg-success']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request processed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Private Site Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\"));\n\t}","commit_id":"77b423763cacd168cf78639fdc6c519f8e72ca73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddSitesSiteTypeRestricted() throws Exception {\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Sites\"),\n\t\t\tselenium.getText(\"//div[@id='so-sidebar']/h3\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//button[contains(.,'Add Site')]/span[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Add Site\"),\n\t\t\tselenium.getText(\"//button[contains(.,'Add Site')]/span[2]\"));\n\t\tselenium.clickAt(\"//button[contains(.,'Add Site')]/span[2]\",\n\t\t\tRuntimeVariables.replace(\"Add Site\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Information\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertTrue(selenium.isVisible(\"//input[@id='_5_WAR_soportlet_name']\"));\n\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_name']\",\n\t\t\tRuntimeVariables.replace(\"Restricted Site Name\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//textarea[@id='_5_WAR_soportlet_description']\"));\n\t\tselenium.type(\"//textarea[@id='_5_WAR_soportlet_description']\",\n\t\t\tRuntimeVariables.replace(\"Restricted Site Description\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Settings\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[2]\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\",\n\t\t\tRuntimeVariables.replace(\"Default Social Office Site\"));\n\t\tassertTrue(selenium.isVisible(\"//select[@id='_5_WAR_soportlet_type']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_type']\",\n\t\t\tRuntimeVariables.replace(\"Restricted\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[3]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Customization\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[3]\"));\n\t\tassertTrue(selenium.isChecked(\"//div[4]/span[1]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[2]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[3]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[4]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[5]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[6]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[7]/input\"));\n\t\tassertEquals(\"Save\", selenium.getValue(\"//input[@value='Save']\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//div[@class='portlet-msg-success']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request processed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\"));\n\t}","id":92151,"modified_method":"public void testAddSitesSiteTypeRestricted() throws Exception {\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Sites\"),\n\t\t\tselenium.getText(\"//div[@id='so-sidebar']/h3\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//button[contains(.,'Add Site')]/span[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Add Site\"),\n\t\t\tselenium.getText(\"//button[contains(.,'Add Site')]/span[2]\"));\n\t\tselenium.clickAt(\"//button[contains(.,'Add Site')]/span[2]\",\n\t\t\tRuntimeVariables.replace(\"Add Site\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Information\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertTrue(selenium.isVisible(\"//input[@id='_5_WAR_soportlet_name']\"));\n\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_name']\",\n\t\t\tRuntimeVariables.replace(\"Restricted Site Name\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//textarea[@id='_5_WAR_soportlet_description']\"));\n\t\tselenium.type(\"//textarea[@id='_5_WAR_soportlet_description']\",\n\t\t\tRuntimeVariables.replace(\"Restricted Site Description\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Settings\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[2]\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\",\n\t\t\tRuntimeVariables.replace(\"Default Social Office Site\"));\n\t\tassertTrue(selenium.isVisible(\"//select[@id='_5_WAR_soportlet_type']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_type']\",\n\t\t\tRuntimeVariables.replace(\"Restricted\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[3]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Customization\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[3]\"));\n\t\tassertTrue(selenium.isChecked(\"//div[4]/span[1]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[2]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[3]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[4]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[5]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[6]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[7]/input\"));\n\t\tassertEquals(\"Save\", selenium.getValue(\"//input[@value='Save']\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\n\t\t\t\t\t\t\t\"Your request processed successfully.\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='portlet-msg-success']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request processed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\"));\n\t}","commit_id":"77b423763cacd168cf78639fdc6c519f8e72ca73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddSitesSiteTypeRestricted() throws Exception {\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Sites\"),\n\t\t\tselenium.getText(\"//div[@id='so-sidebar']/h3\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//button[contains(.,'Add Site')]/span[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Add Site\"),\n\t\t\tselenium.getText(\"//button[contains(.,'Add Site')]/span[2]\"));\n\t\tselenium.clickAt(\"//button[contains(.,'Add Site')]/span[2]\",\n\t\t\tRuntimeVariables.replace(\"Add Site\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Information\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertTrue(selenium.isVisible(\"//input[@id='_5_WAR_soportlet_name']\"));\n\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_name']\",\n\t\t\tRuntimeVariables.replace(\"Restricted Site Name\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//textarea[@id='_5_WAR_soportlet_description']\"));\n\t\tselenium.type(\"//textarea[@id='_5_WAR_soportlet_description']\",\n\t\t\tRuntimeVariables.replace(\"Restricted Site Description\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Settings\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[2]\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\",\n\t\t\tRuntimeVariables.replace(\"Default Social Office Site\"));\n\t\tassertTrue(selenium.isVisible(\"//select[@id='_5_WAR_soportlet_type']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_type']\",\n\t\t\tRuntimeVariables.replace(\"Restricted\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[3]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Customization\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[3]\"));\n\t\tassertTrue(selenium.isChecked(\"//div[4]/span[1]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[2]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[3]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[4]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[5]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[6]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[7]/input\"));\n\t\tassertEquals(\"Save\", selenium.getValue(\"//input[@value='Save']\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//div[@class='portlet-msg-success']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request processed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\"));\n\t}","id":92152,"modified_method":"public void testAddSitesSiteTypeRestricted() throws Exception {\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Sites\"),\n\t\t\tselenium.getText(\"//div[@id='so-sidebar']/h3\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//button[contains(.,'Add Site')]/span[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Add Site\"),\n\t\t\tselenium.getText(\"//button[contains(.,'Add Site')]/span[2]\"));\n\t\tselenium.clickAt(\"//button[contains(.,'Add Site')]/span[2]\",\n\t\t\tRuntimeVariables.replace(\"Add Site\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Information\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertTrue(selenium.isVisible(\"//input[@id='_5_WAR_soportlet_name']\"));\n\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_name']\",\n\t\t\tRuntimeVariables.replace(\"Restricted Site Name\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//textarea[@id='_5_WAR_soportlet_description']\"));\n\t\tselenium.type(\"//textarea[@id='_5_WAR_soportlet_description']\",\n\t\t\tRuntimeVariables.replace(\"Restricted Site Description\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Settings\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[2]\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_layoutSetPrototypeSelect']\",\n\t\t\tRuntimeVariables.replace(\"Default Social Office Site\"));\n\t\tassertTrue(selenium.isVisible(\"//select[@id='_5_WAR_soportlet_type']\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_type']\",\n\t\t\tRuntimeVariables.replace(\"Restricted\"));\n\t\tassertEquals(\"Next\", selenium.getValue(\"//input[@value='Next']\"));\n\t\tselenium.clickAt(\"//input[@value='Next']\",\n\t\t\tRuntimeVariables.replace(\"Next\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[3]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Customization\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[3]\"));\n\t\tassertTrue(selenium.isChecked(\"//div[4]/span[1]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[2]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[3]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[4]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[5]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[6]/input\"));\n\t\tassertTrue(selenium.isChecked(\"//span[7]/input\"));\n\t\tassertEquals(\"Save\", selenium.getValue(\"//input[@value='Save']\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\n\t\t\t\t\t\t\t\"Your request processed successfully.\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='portlet-msg-success']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request processed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\"));\n\t}","commit_id":"77b423763cacd168cf78639fdc6c519f8e72ca73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testViewSitesDirectory() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\t\t\tloadRequiredJavaScriptModules();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//button[contains(.,'More Sites')]/span[2]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"More Sites\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//button[contains(.,'More Sites')]/span[2]\"));\n\t\t\t\tselenium.clickAt(\"//button[contains(.,'More Sites')]/span[2]\",\n\t\t\t\t\tRuntimeVariables.replace(\"More Sites\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Directory\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\n\t\t\t\tboolean mySitesChecked = selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_5_WAR_soportlet_userSites']\");\n\n\t\t\t\tif (!mySitesChecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@id='_5_WAR_soportlet_userSites']\",\n\t\t\t\t\tRuntimeVariables.replace(\"My Sites\"));\n\n\t\t\tcase 2:\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Liferay\"),\n\t\t\t\t\tselenium.getText(\"xPath=(//span[@class='name']/a)[1]\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Open Site1 Name\"),\n\t\t\t\t\tselenium.getText(\"xPath=(//span[@class='name']/a)[2]\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Open Site1 Description\"),\n\t\t\t\t\tselenium.getText(\"xPath=(//span[@class='description'])[2]\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site3 Name\"),\n\t\t\t\t\tselenium.getText(\"xPath=(//span[@class='name']/a)[3]\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Restricted Site3 Description\"),\n\t\t\t\t\tselenium.getText(\"xPath=(//span[@class='description'])[3]\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":92153,"modified_method":"public void testViewSitesDirectory() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\t\t\tloadRequiredJavaScriptModules();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//button[contains(.,'More Sites')]/span[2]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"More Sites\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//button[contains(.,'More Sites')]/span[2]\"));\n\t\t\t\tselenium.clickAt(\"//button[contains(.,'More Sites')]/span[2]\",\n\t\t\t\t\tRuntimeVariables.replace(\"More Sites\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Directory\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\n\t\t\t\tboolean mySitesChecked = selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_5_WAR_soportlet_userSites']\");\n\n\t\t\t\tif (!mySitesChecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@id='_5_WAR_soportlet_userSites']\",\n\t\t\t\t\tRuntimeVariables.replace(\"My Sites\"));\n\n\t\t\tcase 2:\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Liferay\"),\n\t\t\t\t\tselenium.getText(\"xPath=(//span[@class='name']/a)[1]\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Open Site1 Name\"),\n\t\t\t\t\tselenium.getText(\"xPath=(//span[@class='name']/a)[2]\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Open Site1 Description\"),\n\t\t\t\t\tselenium.getText(\"xPath=(//span[@class='description'])[2]\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site3 Name\"),\n\t\t\t\t\tselenium.getText(\"xPath=(//span[@class='name']/a)[3]\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Restricted Site3 Description\"),\n\t\t\t\t\tselenium.getText(\"xPath=(//span[@class='description'])[3]\"));\n\t\t\t\tassertFalse(selenium.isPartialText(\n\t\t\t\t\t\t\"//ul[@class='directory-list']\", \"Private Site2 Name\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"77b423763cacd168cf78639fdc6c519f8e72ca73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testViewSitesSite() throws Exception {\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//button[contains(.,'More Sites')]/span[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"More Sites\"),\n\t\t\tselenium.getText(\"//button[contains(.,'More Sites')]/span[2]\"));\n\t\tselenium.clickAt(\"//button[contains(.,'More Sites')]/span[2]\",\n\t\t\tRuntimeVariables.replace(\"More Sites\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Directory\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//input[@id='_5_WAR_soportlet_dialogKeywords']\"));\n\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_dialogKeywords']\",\n\t\t\tRuntimeVariables.replace(\"Open Site Name\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Open Site Name\"),\n\t\t\tselenium.getText(\"//span[@class='name']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Open Site Description\"),\n\t\t\tselenium.getText(\"//span[@class='description']\"));\n\t\tselenium.clickAt(\"//span[@class='name']/a\",\n\t\t\tRuntimeVariables.replace(\"Open Site Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tloadRequiredJavaScriptModules();\n\t\tassertEquals(RuntimeVariables.replace(\"Open Site Name\"),\n\t\t\tselenium.getText(\"//div[@class='community-title']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//nav/ul/li[1]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Calendar\"),\n\t\t\tselenium.getText(\"//nav/ul/li[2]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Documents\"),\n\t\t\tselenium.getText(\"//nav/ul/li[3]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Forums\"),\n\t\t\tselenium.getText(\"//nav/ul/li[4]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Blog\"),\n\t\t\tselenium.getText(\"//nav/ul/li[5]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Wiki\"),\n\t\t\tselenium.getText(\"//nav/ul/li[6]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Members\"),\n\t\t\tselenium.getText(\"//nav/ul/li[7]/a/span\"));\n\t}","id":92154,"modified_method":"public void testViewSitesSite() throws Exception {\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Sites\"),\n\t\t\tselenium.getText(\"//div[@id='so-sidebar']/h3\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//select[@id='_5_WAR_soportlet_tabs1']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertTrue(selenium.isPartialText(\n\t\t\t\t\"//select[@id='_5_WAR_soportlet_tabs1']\", \"All Sites\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_tabs1']\",\n\t\t\tRuntimeVariables.replace(\"All Sites\"));\n\t\tassertTrue(selenium.isVisible(\"//input[@class='search-input']\"));\n\t\tselenium.type(\"//input[@class='search-input']\",\n\t\t\tRuntimeVariables.replace(\"Open\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Open Site Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\"));\n\t\tselenium.clickAt(\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Open Site Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tloadRequiredJavaScriptModules();\n\t\tassertEquals(RuntimeVariables.replace(\"Open Site Name\"),\n\t\t\tselenium.getText(\"//div[@class='community-title']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//nav/ul/li[1]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Calendar\"),\n\t\t\tselenium.getText(\"//nav/ul/li[2]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Documents\"),\n\t\t\tselenium.getText(\"//nav/ul/li[3]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Forums\"),\n\t\t\tselenium.getText(\"//nav/ul/li[4]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Blog\"),\n\t\t\tselenium.getText(\"//nav/ul/li[5]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Wiki\"),\n\t\t\tselenium.getText(\"//nav/ul/li[6]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Members\"),\n\t\t\tselenium.getText(\"//nav/ul/li[7]/a/span\"));\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//button[contains(.,'More Sites')]/span[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"More Sites\"),\n\t\t\tselenium.getText(\"//button[contains(.,'More Sites')]/span[2]\"));\n\t\tselenium.clickAt(\"//button[contains(.,'More Sites')]/span[2]\",\n\t\t\tRuntimeVariables.replace(\"More Sites\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Directory\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//input[@id='_5_WAR_soportlet_dialogKeywords']\"));\n\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_dialogKeywords']\",\n\t\t\tRuntimeVariables.replace(\"Open Site Name\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Open Site Name\"),\n\t\t\tselenium.getText(\"//span[@class='name']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Open Site Description\"),\n\t\t\tselenium.getText(\"//span[@class='description']\"));\n\t\tselenium.clickAt(\"//span[@class='name']/a\",\n\t\t\tRuntimeVariables.replace(\"Open Site Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tloadRequiredJavaScriptModules();\n\t\tassertEquals(RuntimeVariables.replace(\"Open Site Name\"),\n\t\t\tselenium.getText(\"//div[@class='community-title']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//nav/ul/li[1]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Calendar\"),\n\t\t\tselenium.getText(\"//nav/ul/li[2]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Documents\"),\n\t\t\tselenium.getText(\"//nav/ul/li[3]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Forums\"),\n\t\t\tselenium.getText(\"//nav/ul/li[4]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Blog\"),\n\t\t\tselenium.getText(\"//nav/ul/li[5]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Wiki\"),\n\t\t\tselenium.getText(\"//nav/ul/li[6]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Members\"),\n\t\t\tselenium.getText(\"//nav/ul/li[7]/a/span\"));\n\t}","commit_id":"77b423763cacd168cf78639fdc6c519f8e72ca73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testViewSitesSiteTypePrivate() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\t\t\tloadRequiredJavaScriptModules();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//button[contains(.,'More Sites')]/span[2]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"More Sites\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//button[contains(.,'More Sites')]/span[2]\"));\n\t\t\t\tselenium.clickAt(\"//button[contains(.,'More Sites')]/span[2]\",\n\t\t\t\t\tRuntimeVariables.replace(\"More Sites\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Directory\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\n\t\t\t\tboolean mySitesChecked = selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_5_WAR_soportlet_userSites']\");\n\n\t\t\t\tif (mySitesChecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@id='_5_WAR_soportlet_userSites']\",\n\t\t\t\t\tRuntimeVariables.replace(\"My Sites\"));\n\n\t\t\tcase 2:\n\t\t\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\t\t\"//input[@id='_5_WAR_soportlet_dialogKeywords']\"));\n\t\t\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_dialogKeywords']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Private Site Name\"));\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Private Site Name\"),\n\t\t\t\t\tselenium.getText(\"//span[@class='name']/a\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Private Site Description\"),\n\t\t\t\t\tselenium.getText(\"//span[@class='description']\"));\n\t\t\t\tselenium.clickAt(\"//span[@class='name']/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Private Site Name\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tloadRequiredJavaScriptModules();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Private Site Name\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='community-title']\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[1]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Calendar\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[2]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Documents\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[3]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Forums\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[4]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Blog\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[5]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Wiki\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[6]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Members\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[7]/a/span\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":92155,"modified_method":"public void testViewSitesSiteTypePrivate() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\t\t\tloadRequiredJavaScriptModules();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sites\"),\n\t\t\t\t\tselenium.getText(\"//div[@id='so-sidebar']/h3\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//select[@id='_5_WAR_soportlet_tabs1']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertTrue(selenium.isPartialText(\n\t\t\t\t\t\t\"//select[@id='_5_WAR_soportlet_tabs1']\", \"All Sites\"));\n\t\t\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_tabs1']\",\n\t\t\t\t\tRuntimeVariables.replace(\"All Sites\"));\n\t\t\t\tassertTrue(selenium.isVisible(\"//input[@class='search-input']\"));\n\t\t\t\tselenium.type(\"//input[@class='search-input']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Private\"));\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Private Site Name\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\"));\n\t\t\t\tselenium.clickAt(\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Private Site Name\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tloadRequiredJavaScriptModules();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Private Site Name\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='community-title']\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[1]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Calendar\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[2]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Documents\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[3]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Forums\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[4]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Blog\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[5]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Wiki\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[6]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Members\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[7]/a/span\"));\n\t\t\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\t\t\tloadRequiredJavaScriptModules();\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//button[contains(.,'More Sites')]/span[2]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"More Sites\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//button[contains(.,'More Sites')]/span[2]\"));\n\t\t\t\tselenium.clickAt(\"//button[contains(.,'More Sites')]/span[2]\",\n\t\t\t\t\tRuntimeVariables.replace(\"More Sites\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Directory\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\n\t\t\t\tboolean mySitesChecked = selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_5_WAR_soportlet_userSites']\");\n\n\t\t\t\tif (mySitesChecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@id='_5_WAR_soportlet_userSites']\",\n\t\t\t\t\tRuntimeVariables.replace(\"My Sites\"));\n\n\t\t\tcase 2:\n\t\t\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\t\t\"//input[@id='_5_WAR_soportlet_dialogKeywords']\"));\n\t\t\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_dialogKeywords']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Private Site Name\"));\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Private Site Name\"),\n\t\t\t\t\tselenium.getText(\"//span[@class='name']/a\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Private Site Description\"),\n\t\t\t\t\tselenium.getText(\"//span[@class='description']\"));\n\t\t\t\tselenium.clickAt(\"//span[@class='name']/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Private Site Name\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tloadRequiredJavaScriptModules();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Private Site Name\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='community-title']\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[1]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Calendar\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[2]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Documents\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[3]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Forums\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[4]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Blog\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[5]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Wiki\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[6]/a/span\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Members\"),\n\t\t\t\t\tselenium.getText(\"//nav/ul/li[7]/a/span\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"77b423763cacd168cf78639fdc6c519f8e72ca73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testViewSitesSiteTypeRestricted() throws Exception {\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//button[contains(.,'More Sites')]/span[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"More Sites\"),\n\t\t\tselenium.getText(\"//button[contains(.,'More Sites')]/span[2]\"));\n\t\tselenium.clickAt(\"//button[contains(.,'More Sites')]/span[2]\",\n\t\t\tRuntimeVariables.replace(\"More Sites\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Directory\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//input[@id='_5_WAR_soportlet_dialogKeywords']\"));\n\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_dialogKeywords']\",\n\t\t\tRuntimeVariables.replace(\"Restricted Site Name\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site Name\"),\n\t\t\tselenium.getText(\"//span[@class='name']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site Description\"),\n\t\t\tselenium.getText(\"//span[@class='description']\"));\n\t\tselenium.clickAt(\"//span[@class='name']/a\",\n\t\t\tRuntimeVariables.replace(\"Restricted Site Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tloadRequiredJavaScriptModules();\n\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site Name\"),\n\t\t\tselenium.getText(\"//div[@class='community-title']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//nav/ul/li[1]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Calendar\"),\n\t\t\tselenium.getText(\"//nav/ul/li[2]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Documents\"),\n\t\t\tselenium.getText(\"//nav/ul/li[3]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Forums\"),\n\t\t\tselenium.getText(\"//nav/ul/li[4]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Blog\"),\n\t\t\tselenium.getText(\"//nav/ul/li[5]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Wiki\"),\n\t\t\tselenium.getText(\"//nav/ul/li[6]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Members\"),\n\t\t\tselenium.getText(\"//nav/ul/li[7]/a/span\"));\n\t}","id":92156,"modified_method":"public void testViewSitesSiteTypeRestricted() throws Exception {\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Sites\"),\n\t\t\tselenium.getText(\"//div[@id='so-sidebar']/h3\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//select[@id='_5_WAR_soportlet_tabs1']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertTrue(selenium.isPartialText(\n\t\t\t\t\"//select[@id='_5_WAR_soportlet_tabs1']\", \"All Sites\"));\n\t\tselenium.select(\"//select[@id='_5_WAR_soportlet_tabs1']\",\n\t\t\tRuntimeVariables.replace(\"All Sites\"));\n\t\tassertTrue(selenium.isVisible(\"//input[@class='search-input']\"));\n\t\tselenium.type(\"//input[@class='search-input']\",\n\t\t\tRuntimeVariables.replace(\"Restricted\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\"));\n\t\tselenium.clickAt(\"//li[contains(@class, 'social-office-enabled')]/span[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Restricted Site Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tloadRequiredJavaScriptModules();\n\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site Name\"),\n\t\t\tselenium.getText(\"//div[@class='community-title']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//nav/ul/li[1]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Calendar\"),\n\t\t\tselenium.getText(\"//nav/ul/li[2]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Documents\"),\n\t\t\tselenium.getText(\"//nav/ul/li[3]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Forums\"),\n\t\t\tselenium.getText(\"//nav/ul/li[4]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Blog\"),\n\t\t\tselenium.getText(\"//nav/ul/li[5]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Wiki\"),\n\t\t\tselenium.getText(\"//nav/ul/li[6]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Members\"),\n\t\t\tselenium.getText(\"//nav/ul/li[7]/a/span\"));\n\t\tselenium.open(\"/user/joebloggs/home1/\");\n\t\tloadRequiredJavaScriptModules();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//li[contains(@class, 'selected')]/a/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//li[contains(@class, 'selected')]/a/span\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//button[contains(.,'More Sites')]/span[2]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"More Sites\"),\n\t\t\tselenium.getText(\"//button[contains(.,'More Sites')]/span[2]\"));\n\t\tselenium.clickAt(\"//button[contains(.,'More Sites')]/span[2]\",\n\t\t\tRuntimeVariables.replace(\"More Sites\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"xPath=(//h1[@class='header-title']/span)[1]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Directory\"),\n\t\t\tselenium.getText(\"xPath=(//h1[@class='header-title']/span)[1]\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//input[@id='_5_WAR_soportlet_dialogKeywords']\"));\n\t\tselenium.type(\"//input[@id='_5_WAR_soportlet_dialogKeywords']\",\n\t\t\tRuntimeVariables.replace(\"Restricted Site Name\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site Name\"),\n\t\t\tselenium.getText(\"//span[@class='name']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site Description\"),\n\t\t\tselenium.getText(\"//span[@class='description']\"));\n\t\tselenium.clickAt(\"//span[@class='name']/a\",\n\t\t\tRuntimeVariables.replace(\"Restricted Site Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tloadRequiredJavaScriptModules();\n\t\tassertEquals(RuntimeVariables.replace(\"Restricted Site Name\"),\n\t\t\tselenium.getText(\"//div[@class='community-title']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Home\"),\n\t\t\tselenium.getText(\"//nav/ul/li[1]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Calendar\"),\n\t\t\tselenium.getText(\"//nav/ul/li[2]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Documents\"),\n\t\t\tselenium.getText(\"//nav/ul/li[3]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Forums\"),\n\t\t\tselenium.getText(\"//nav/ul/li[4]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Blog\"),\n\t\t\tselenium.getText(\"//nav/ul/li[5]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Wiki\"),\n\t\t\tselenium.getText(\"//nav/ul/li[6]/a/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Members\"),\n\t\t\tselenium.getText(\"//nav/ul/li[7]/a/span\"));\n\t}","commit_id":"77b423763cacd168cf78639fdc6c519f8e72ca73","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddVocabularyAssetTypeDDLRecord() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.clickAt(\"link=Categories\",\n\t\t\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.clickAt(\"//input[@value='Add Vocabulary']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Add Vocabulary\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//input[@id='_147_title_en_US']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.type(\"//input[@id='_147_title_en_US']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Vocabulary Name\"));\n\t\t\t\tselenium.type(\"//textarea[@id='_147_description_en_US']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Vocabulary Description\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Associated Asset Types\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@id='vocabularyExtraFieldsPanelContainer']/div/div/span\"));\n\n\t\t\t\tboolean chooseAssetTypeNotVisible = selenium.isVisible(\n\t\t\t\t\t\t\"_147_classNameId0\");\n\n\t\t\t\tif (chooseAssetTypeNotVisible) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//div[@id='vocabularyExtraFieldsPanelContainer']/div/div/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"Associated Asset Types\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//select[@id='_147_classNameId0']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\tcase 2:\n\t\t\t\tselenium.select(\"//select[@id='_147_classNameId0']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Document Library Document\"));\n\t\t\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-success']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Your request processed successfully.\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-success']\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary Name\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//span[@class='vocabulary-item']/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary Name\"),\n\t\t\t\t\tselenium.getText(\"//span[@class='vocabulary-item']/a\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":92157,"modified_method":"public void testAddVocabularyAssetTypeDDLRecord() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.clickAt(\"link=Categories\",\n\t\t\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.clickAt(\"//input[@value='Add Vocabulary']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Add Vocabulary\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//input[@id='_147_title_en_US']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.type(\"//input[@id='_147_title_en_US']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Vocabulary Name\"));\n\t\t\t\tselenium.type(\"//textarea[@id='_147_description_en_US']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Vocabulary Description\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Associated Asset Types\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@id='vocabularyExtraFieldsPanelContainer']/div/div/span\"));\n\n\t\t\t\tboolean chooseAssetTypeNotVisible = selenium.isVisible(\n\t\t\t\t\t\t\"_147_classNameId0\");\n\n\t\t\t\tif (chooseAssetTypeNotVisible) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//div[@id='vocabularyExtraFieldsPanelContainer']/div/div/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"Associated Asset Types\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//select[@id='_147_classNameId0']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\tcase 2:\n\t\t\t\tselenium.select(\"//select[@id='_147_classNameId0']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Dynamic Data Lists Record\"));\n\t\t\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Save\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-success']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Your request processed successfully.\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-success']\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary Name\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//span[@class='vocabulary-item']/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary Name\"),\n\t\t\t\t\tselenium.getText(\"//span[@class='vocabulary-item']/a\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"75b40d34c5698228ed4a1112e3079ef2b0bcfd3f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTest(AddCategoryTests.suite());\n\t\ttestSuite.addTest(AddCategoryMultipleTests.suite());\n\t\ttestSuite.addTest(AddCategoryPropertyTests.suite());\n\t\ttestSuite.addTest(AddCategoryToVocabularyTests.suite());\n\t\ttestSuite.addTest(AddCategoryViewableByAnyoneTests.suite());\n\t\ttestSuite.addTest(AddCategoryViewableByOwnerTests.suite());\n\t\ttestSuite.addTest(AddCategoryViewableBySiteMembersTests.suite());\n\t\ttestSuite.addTest(AddSubcategoryTests.suite());\n\t\ttestSuite.addTest(AddSubcategoryMultipleTests.suite());\n\t\ttestSuite.addTest(DeleteCategoryActionsTests.suite());\n\t\ttestSuite.addTest(DeleteCategoryDetailsTests.suite());\n\t\ttestSuite.addTest(DeleteCategoryMultipleTests.suite());\n\t\ttestSuite.addTest(DeleteSubcategoryActionsTests.suite());\n\t\ttestSuite.addTest(DeleteSubcategoryDetailsTests.suite());\n\t\ttestSuite.addTest(EditCategoryTests.suite());\n\t\ttestSuite.addTest(EditSubcategoryTests.suite());\n\t\ttestSuite.addTest(\n\t\t\tEditVocabulary1CategoryToVocabulary2DADTests.suite());\n\t\ttestSuite.addTest(\n\t\t\tEditVocabulary1CategoryToVocabulary2DetailsTests.suite());\n\n\t\treturn testSuite;\n\t}","id":92158,"modified_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTest(AddCategoryTests.suite());\n\t\ttestSuite.addTest(AddCategoryMultipleTests.suite());\n\t\ttestSuite.addTest(AddCategoryNameNullTests.suite());\n\t\ttestSuite.addTest(AddCategoryPropertyTests.suite());\n\t\ttestSuite.addTest(AddCategoryToVocabularyTests.suite());\n\t\ttestSuite.addTest(AddCategoryViewableByAnyoneTests.suite());\n\t\ttestSuite.addTest(AddCategoryViewableByOwnerTests.suite());\n\t\ttestSuite.addTest(AddCategoryViewableBySiteMembersTests.suite());\n\t\ttestSuite.addTest(AddSubcategoryTests.suite());\n\t\ttestSuite.addTest(AddSubcategoryMultipleTests.suite());\n\t\ttestSuite.addTest(DeleteCategoryActionsTests.suite());\n\t\ttestSuite.addTest(DeleteCategoryDetailsTests.suite());\n\t\ttestSuite.addTest(DeleteCategoryMultipleTests.suite());\n\t\ttestSuite.addTest(DeleteSubcategoryActionsTests.suite());\n\t\ttestSuite.addTest(DeleteSubcategoryDetailsTests.suite());\n\t\ttestSuite.addTest(EditCategoryTests.suite());\n\t\ttestSuite.addTest(EditSubcategoryTests.suite());\n\t\ttestSuite.addTest(\n\t\t\tEditVocabulary1CategoryToVocabulary2DADTests.suite());\n\t\ttestSuite.addTest(\n\t\t\tEditVocabulary1CategoryToVocabulary2DetailsTests.suite());\n\n\t\treturn testSuite;\n\t}","commit_id":"75b40d34c5698228ed4a1112e3079ef2b0bcfd3f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testCloseVocabulary() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.clickAt(\"link=Categories\",\n\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.clickAt(\"//input[@value='Add Vocabulary']\",\n\t\t\tRuntimeVariables.replace(\"Add Vocabulary\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@id='_147_title_en_US']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.type(\"//input[@id='_147_title_en_US']\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary Name\"));\n\t\tselenium.type(\"//textarea[@id='_147_description_en_US']\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary Description\"));\n\t\tselenium.clickAt(\"//input[@value='Close']\",\n\t\t\tRuntimeVariables.replace(\"Close\"));\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.clickAt(\"link=Categories\",\n\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertFalse(selenium.isTextPresent(\"Vocabulary name\"));\n\t}","id":92159,"modified_method":"public void testCloseVocabulary() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.clickAt(\"link=Categories\",\n\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.clickAt(\"//input[@value='Add Vocabulary']\",\n\t\t\tRuntimeVariables.replace(\"Add Vocabulary\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@id='_147_title_en_US']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.type(\"//input[@id='_147_title_en_US']\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary Name\"));\n\t\tselenium.type(\"//textarea[@id='_147_description_en_US']\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary Description\"));\n\t\tselenium.clickAt(\"//input[@value='Close']\",\n\t\t\tRuntimeVariables.replace(\"Close\"));\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.clickAt(\"link=Categories\",\n\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertFalse(selenium.isTextPresent(\"Vocabulary Name\"));\n\t}","commit_id":"75b40d34c5698228ed4a1112e3079ef2b0bcfd3f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testEditVocabulary1CategoryToVocabulary2DAD()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.clickAt(\"link=Categories\",\n\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//li/div/div[4]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//li/div/div[4]\"));\n\t\tselenium.clickAt(\"//li/div/div[4]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary1 Category Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='view-category']/div/h1/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//div[@class='view-category']/div/h1/span\"));\n\t\tselenium.dragAndDropToObject(\"//li/div/div[4]\",\n\t\t\t\"xPath=(//span[@class='vocabulary-item']/a)[2]\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary2 Name\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary2 Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//li/div/div[4]\"));\n\t}","id":92160,"modified_method":"public void testEditVocabulary1CategoryToVocabulary2DAD()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.clickAt(\"link=Categories\",\n\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//li/div/div[4]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//li/div/div[4]\"));\n\t\tselenium.clickAt(\"//li/div/div[4]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary1 Category Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='view-category']/div/h1/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//div[@class='view-category']/div/h1/span\"));\n\t\tThread.sleep(5000);\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//li/div/div[4]\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary2 Name\"),\n\t\t\tselenium.getText(\"xPath=(//span[@class='vocabulary-item']/a)[2]\"));\n\t\tselenium.dragAndDropToObject(\"//li/div/div[4]\",\n\t\t\t\"xPath=(//span[@class='vocabulary-item']/a)[2]\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary2 Name\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary2 Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//li/div/div[4]\"));\n\t}","commit_id":"75b40d34c5698228ed4a1112e3079ef2b0bcfd3f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testViewEditVocabulary1CategoryToVocabulary2DAD()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.clickAt(\"link=Categories\",\n\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Name\"),\n\t\t\tselenium.getText(\"xPath=(//span[@class='vocabulary-item']/a)[1]\"));\n\t\tselenium.clickAt(\"xPath=(//span[@class='vocabulary-item']/a)[1]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary1 Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary1 Name\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-info']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"There are no categories.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-info']\"));\n\t\tassertFalse(selenium.isTextPresent(\"Vocabulary1 Category\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary2 Name\"),\n\t\t\tselenium.getText(\"xPath=(//span[@class='vocabulary-item']/a)[2]\"));\n\t\tselenium.clickAt(\"xPath=(//span[@class='vocabulary-item']/a)[2]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary2 Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary2 Name\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary2 Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//li/div/div[4]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//li/div/div[4]\"));\n\t\tselenium.clickAt(\"//li/div/div[4]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary1 Category Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='view-category']/div/h1/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//div[@class='view-category']/div/h1/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Description: Vocabulary1 Category Description\"),\n\t\t\tselenium.getText(\"//div[@class='view-category']/div[2]\"));\n\t}","id":92161,"modified_method":"public void testViewEditVocabulary1CategoryToVocabulary2DAD()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.clickAt(\"link=Categories\",\n\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Name\"),\n\t\t\tselenium.getText(\"xPath=(//span[@class='vocabulary-item']/a)[1]\"));\n\t\tselenium.clickAt(\"xPath=(//span[@class='vocabulary-item']/a)[1]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary1 Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary1 Name\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-info']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"There are no categories.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-info']\"));\n\t\tassertFalse(selenium.isTextPresent(\"Vocabulary1 Category\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary2 Name\"),\n\t\t\tselenium.getText(\"xPath=(//span[@class='vocabulary-item']/a)[2]\"));\n\t\tselenium.clickAt(\"xPath=(//span[@class='vocabulary-item']/a)[2]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary2 Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary2 Name\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary2 Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary1 Category Name\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//li/div/div[4]\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//li/div/div[4]\"));\n\t\tselenium.clickAt(\"//li/div/div[4]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary1 Category Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='view-category']/div/h1/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//div[@class='view-category']/div/h1/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Description: Vocabulary1 Category Description\"),\n\t\t\tselenium.getText(\"//div[@class='view-category']/div[2]\"));\n\t}","commit_id":"75b40d34c5698228ed4a1112e3079ef2b0bcfd3f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testViewEditVocabulary1CategoryToVocabulary2Details()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.clickAt(\"link=Categories\",\n\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Name\"),\n\t\t\tselenium.getText(\"xPath=(//span[@class='vocabulary-item']/a)[1]\"));\n\t\tselenium.clickAt(\"xPath=(//span[@class='vocabulary-item']/a)[1]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary1 Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary1 Name\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-info']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"There are no categories.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-info']\"));\n\t\tassertFalse(selenium.isTextPresent(\"Vocabulary1 Category\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary2 Name\"),\n\t\t\tselenium.getText(\"xPath=(//span[@class='vocabulary-item']/a)[2]\"));\n\t\tselenium.clickAt(\"xPath=(//span[@class='vocabulary-item']/a)[2]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary2 Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary2 Name\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary2 Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//li/div/div[4]\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//li/div/div[4]\"));\n\t\tselenium.clickAt(\"//li/div/div[4]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary1 Category Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='view-category']/div/h1/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//div[@class='view-category']/div/h1/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Description: Vocabulary1 Category Description\"),\n\t\t\tselenium.getText(\"//div[@class='view-category']/div[2]\"));\n\t}","id":92162,"modified_method":"public void testViewEditVocabulary1CategoryToVocabulary2Details()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.clickAt(\"link=Categories\",\n\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Name\"),\n\t\t\tselenium.getText(\"xPath=(//span[@class='vocabulary-item']/a)[1]\"));\n\t\tselenium.clickAt(\"xPath=(//span[@class='vocabulary-item']/a)[1]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary1 Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary1 Name\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-info']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"There are no categories.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-info']\"));\n\t\tassertFalse(selenium.isTextPresent(\"Vocabulary1 Category\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary2 Name\"),\n\t\t\tselenium.getText(\"xPath=(//span[@class='vocabulary-item']/a)[2]\"));\n\t\tselenium.clickAt(\"xPath=(//span[@class='vocabulary-item']/a)[2]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary2 Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary2 Name\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary2 Name\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//li[contains(@class,'selected')]/div/span[@class='vocabulary-item']/a\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"Vocabulary1 Category Name\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//li/div/div[4]\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//li/div/div[4]\"));\n\t\tselenium.clickAt(\"//li/div/div[4]\",\n\t\t\tRuntimeVariables.replace(\"Vocabulary1 Category Name\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 90) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='view-category']/div/h1/span\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary1 Category Name\"),\n\t\t\tselenium.getText(\"//div[@class='view-category']/div/h1/span\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Description: Vocabulary1 Category Description\"),\n\t\t\tselenium.getText(\"//div[@class='view-category']/div[2]\"));\n\t}","commit_id":"75b40d34c5698228ed4a1112e3079ef2b0bcfd3f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testViewVocabularyAssetTypeDDLRecord()\n\t\tthrows Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.clickAt(\"link=Categories\",\n\t\t\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary Name\"),\n\t\t\t\t\tselenium.getText(\"//span[@class='vocabulary-item']/a\"));\n\t\t\t\tselenium.clickAt(\"//a[@class='vocabulary-item-actions-trigger']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Edit\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//input[@id='_147_title_en_US']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(\"Vocabulary Name\",\n\t\t\t\t\tselenium.getValue(\"//input[@id='_147_title_en_US']\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary Description\"),\n\t\t\t\t\tselenium.getText(\"//textarea[@id='_147_description_en_US']\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Associated Asset Types\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@id='vocabularyExtraFieldsPanelContainer']/div/div/span\"));\n\n\t\t\t\tboolean chooseAssetTypeNotVisible = selenium.isVisible(\n\t\t\t\t\t\t\"_147_classNameId0\");\n\n\t\t\t\tif (chooseAssetTypeNotVisible) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//div[@id='vocabularyExtraFieldsPanelContainer']/div/div/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"Associated Asset Types\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//select[@id='_147_classNameId0']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\tcase 2:\n\t\t\t\tassertEquals(\"Document Library Document\",\n\t\t\t\t\tselenium.getSelectedLabel(\n\t\t\t\t\t\t\"//select[@id='_147_classNameId0']\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":92163,"modified_method":"public void testViewVocabularyAssetTypeDDLRecord()\n\t\tthrows Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.clickAt(\"link=Categories\",\n\t\t\t\t\tRuntimeVariables.replace(\"Categories\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary Name\"),\n\t\t\t\t\tselenium.getText(\"//span[@class='vocabulary-item']/a\"));\n\t\t\t\tselenium.clickAt(\"//a[@class='vocabulary-item-actions-trigger']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Edit\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//input[@id='_147_title_en_US']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tassertEquals(\"Vocabulary Name\",\n\t\t\t\t\tselenium.getValue(\"//input[@id='_147_title_en_US']\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Vocabulary Description\"),\n\t\t\t\t\tselenium.getText(\"//textarea[@id='_147_description_en_US']\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Associated Asset Types\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@id='vocabularyExtraFieldsPanelContainer']/div/div/span\"));\n\n\t\t\t\tboolean chooseAssetTypeNotVisible = selenium.isVisible(\n\t\t\t\t\t\t\"_147_classNameId0\");\n\n\t\t\t\tif (chooseAssetTypeNotVisible) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//div[@id='vocabularyExtraFieldsPanelContainer']/div/div/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"Associated Asset Types\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 90) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//select[@id='_147_classNameId0']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\tcase 2:\n\t\t\t\tassertEquals(\"Dynamic Data Lists Record\",\n\t\t\t\t\tselenium.getSelectedLabel(\n\t\t\t\t\t\t\"//select[@id='_147_classNameId0']\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"75b40d34c5698228ed4a1112e3079ef2b0bcfd3f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTest(AddVocabularyTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeAllAssetTypesTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeBlogsEntryTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeCalendarEventTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeCommentsTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeDDLRecordTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeDLDocumentTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeMBCategoryTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeMBMessageTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypePageRevisionTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeRequiredTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeUserTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeWebContentTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeWikiPageTests.suite());\n\t\ttestSuite.addTest(\n\t\t\tAddVocabularyDisallowMultipleCategoriesTests.suite());\n\t\ttestSuite.addTest(AddVocabularyMultipleTests.suite());\n\t\ttestSuite.addTest(AddVocabularyViewableByAnyoneTests.suite());\n\t\ttestSuite.addTest(AddVocabularyViewableByOwnerTests.suite());\n\t\ttestSuite.addTest(AddVocabularyViewableBySiteMembersTests.suite());\n\t\ttestSuite.addTest(CloseVocabularyTests.suite());\n\t\ttestSuite.addTest(DeleteVocabularyActionsTests.suite());\n\t\ttestSuite.addTest(DeleteVocabularyDetailsTests.suite());\n\t\ttestSuite.addTest(EditVocabularyTests.suite());\n\n\t\treturn testSuite;\n\t}","id":92164,"modified_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTest(AddVocabularyTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeAllAssetTypesTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeBlogsEntryTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeCalendarEventTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeCommentsTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeDDLRecordTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeDLDocumentTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeMBCategoryTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeMBMessageTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypePageRevisionTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeRequiredTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeUserTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeWebContentTests.suite());\n\t\ttestSuite.addTest(AddVocabularyAssetTypeWikiPageTests.suite());\n\t\ttestSuite.addTest(\n\t\t\tAddVocabularyDisallowMultipleCategoriesTests.suite());\n\t\ttestSuite.addTest(AddVocabularyMultipleTests.suite());\n\t\ttestSuite.addTest(AddVocabularyNameNullTests.suite());\n\t\ttestSuite.addTest(AddVocabularyViewableByAnyoneTests.suite());\n\t\ttestSuite.addTest(AddVocabularyViewableByOwnerTests.suite());\n\t\ttestSuite.addTest(AddVocabularyViewableBySiteMembersTests.suite());\n\t\ttestSuite.addTest(CloseVocabularyTests.suite());\n\t\ttestSuite.addTest(DeleteVocabularyActionsTests.suite());\n\t\ttestSuite.addTest(DeleteVocabularyDetailsTests.suite());\n\t\ttestSuite.addTest(EditVocabularyTests.suite());\n\n\t\treturn testSuite;\n\t}","commit_id":"75b40d34c5698228ed4a1112e3079ef2b0bcfd3f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void savePaxosProposal(Commit commit)\n    {\n        processInternal(String.format(\"UPDATE %s USING TIMESTAMP %d AND TTL %d SET proposal = 0x%s WHERE row_key = 0x%s AND cf_id = %s\",\n                                      PAXOS_CF,\n                                      UUIDGen.microsTimestamp(commit.ballot),\n                                      commit.update.metadata().getGcGraceSeconds(),\n                                      ByteBufferUtil.bytesToHex(commit.update.toBytes()),\n                                      ByteBufferUtil.bytesToHex(commit.key),\n                                      commit.update.id()));\n    }","id":92165,"modified_method":"public static void savePaxosProposal(Commit commit)\n    {\n        processInternal(String.format(\"UPDATE %s USING TIMESTAMP %d AND TTL %d SET proposal = 0x%s WHERE row_key = 0x%s AND cf_id = %s\",\n                                      PAXOS_CF,\n                                      UUIDGen.microsTimestamp(commit.ballot),\n                                      paxosTtl(commit.update.metadata),\n                                      ByteBufferUtil.bytesToHex(commit.update.toBytes()),\n                                      ByteBufferUtil.bytesToHex(commit.key),\n                                      commit.update.id()));\n    }","commit_id":"a7b80d78ab181c3eb1c51b94621a74023bc5d76f","url":"https://github.com/apache/cassandra"},{"original_method":"public static void savePaxosPromise(Commit promise)\n    {\n        String req = \"UPDATE %s USING TIMESTAMP %d AND TTL %d SET in_progress_ballot = %s WHERE row_key = 0x%s AND cf_id = %s\";\n        processInternal(String.format(req,\n                                      PAXOS_CF,\n                                      UUIDGen.microsTimestamp(promise.ballot),\n                                      promise.update.metadata().getGcGraceSeconds(),\n                                      promise.ballot,\n                                      ByteBufferUtil.bytesToHex(promise.key),\n                                      promise.update.id()));\n    }","id":92166,"modified_method":"public static void savePaxosPromise(Commit promise)\n    {\n        String req = \"UPDATE %s USING TIMESTAMP %d AND TTL %d SET in_progress_ballot = %s WHERE row_key = 0x%s AND cf_id = %s\";\n        processInternal(String.format(req,\n                                      PAXOS_CF,\n                                      UUIDGen.microsTimestamp(promise.ballot),\n                                      paxosTtl(promise.update.metadata),\n                                      promise.ballot,\n                                      ByteBufferUtil.bytesToHex(promise.key),\n                                      promise.update.id()));\n    }","commit_id":"a7b80d78ab181c3eb1c51b94621a74023bc5d76f","url":"https://github.com/apache/cassandra"},{"original_method":"public static void savePaxosCommit(Commit commit, boolean eraseInProgressProposal)\n    {\n        String preserveCql = \"UPDATE %s USING TIMESTAMP %d AND TTL %d SET most_recent_commit_at = %s, most_recent_commit = 0x%s WHERE row_key = 0x%s AND cf_id = %s\";\n        // identical except adds proposal = null\n        String eraseCql = \"UPDATE %s USING TIMESTAMP %d AND TTL %d SET proposal = null, most_recent_commit_at = %s, most_recent_commit = 0x%s WHERE row_key = 0x%s AND cf_id = %s\";\n        processInternal(String.format(eraseInProgressProposal ? eraseCql : preserveCql,\n                                      PAXOS_CF,\n                                      UUIDGen.microsTimestamp(commit.ballot),\n                                      commit.update.metadata().getGcGraceSeconds(),\n                                      commit.ballot,\n                                      ByteBufferUtil.bytesToHex(commit.update.toBytes()),\n                                      ByteBufferUtil.bytesToHex(commit.key),\n                                      commit.update.id()));\n    }","id":92167,"modified_method":"public static void savePaxosCommit(Commit commit, boolean eraseInProgressProposal)\n    {\n        String preserveCql = \"UPDATE %s USING TIMESTAMP %d AND TTL %d SET most_recent_commit_at = %s, most_recent_commit = 0x%s WHERE row_key = 0x%s AND cf_id = %s\";\n        // identical except adds proposal = null\n        String eraseCql = \"UPDATE %s USING TIMESTAMP %d AND TTL %d SET proposal = null, most_recent_commit_at = %s, most_recent_commit = 0x%s WHERE row_key = 0x%s AND cf_id = %s\";\n        processInternal(String.format(eraseInProgressProposal ? eraseCql : preserveCql,\n                                      PAXOS_CF,\n                                      UUIDGen.microsTimestamp(commit.ballot),\n                                      paxosTtl(commit.update.metadata),\n                                      commit.ballot,\n                                      ByteBufferUtil.bytesToHex(commit.update.toBytes()),\n                                      ByteBufferUtil.bytesToHex(commit.key),\n                                      commit.update.id()));\n    }","commit_id":"a7b80d78ab181c3eb1c51b94621a74023bc5d76f","url":"https://github.com/apache/cassandra"},{"original_method":"protected <E extends AbstractExtension> E createExtension(XWikiDocument extensionDocument, String version)\n    {\n        BaseObject extensionObject = getExtensionObject(extensionDocument);\n        DocumentReference extensionDocumentReference = extensionDocument.getDocumentReference();\n\n        if (extensionObject == null) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        AbstractExtension extension;\n        ExtensionVersion extensionVersion;\n        BaseObject extensionVersionObject;\n        if (version == null) {\n            extension = this.extensionObjectFactory.createExtension();\n            extensionVersion = null;\n            extensionVersionObject = null;\n        } else {\n            extensionVersionObject = getExtensionVersionObject(extensionDocument, version);\n\n            if (extensionVersionObject == null) {\n                throw new WebApplicationException(Status.NOT_FOUND);\n            }\n\n            extensionVersion = this.extensionObjectFactory.createExtensionVersion();\n            extension = extensionVersion;\n            extensionVersion\n                .setVersion((String) getValue(extensionVersionObject, XWikiRepositoryModel.PROP_VERSION_VERSION));\n        }\n\n        extension.setId((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_ID));\n        extension.setType((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_TYPE));\n\n        License license = this.extensionObjectFactory.createLicense();\n        license.setName((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_LICENSENAME));\n        extension.getLicenses().add(license);\n\n        extension.setRating(getExtensionRating(extensionDocumentReference));\n        extension.setSummary((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_SUMMARY));\n        extension.setDescription((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_DESCRIPTION));\n        extension.setName((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_NAME));\n        extension.setCategory((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_CATEGORY));\n        extension.setWebsite(\n            StringUtils.defaultIfEmpty((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_WEBSITE),\n                extensionDocument.getExternalURL(\"view\", getXWikiContext())));\n\n        // SCM\n        ExtensionScm scm = new ExtensionScm();\n        scm.setUrl((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_SCMURL));\n        scm.setConnection(\n            toScmConnection((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_SCMCONNECTION)));\n        scm.setDeveloperConnection(\n            toScmConnection((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_SCMDEVCONNECTION)));\n        extension.setScm(scm);\n\n        // Issue Management\n        ExtensionIssueManagement issueManagement = new ExtensionIssueManagement();\n        issueManagement\n            .setSystem((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_SYSTEM));\n        issueManagement\n            .setUrl((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_URL));\n        if (StringUtils.isNotEmpty(issueManagement.getSystem()) || StringUtils.isNotEmpty(issueManagement.getUrl())) {\n            extension.setIssueManagement(issueManagement);\n        }\n\n        // Authors\n        List<String> authors = (List<String>) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_AUTHORS);\n        if (authors != null) {\n            for (String authorId : authors) {\n                extension.getAuthors().add(resolveExtensionAuthor(authorId));\n            }\n        }\n\n        // Features\n        List<String> features =\n            (List<String>) getValue(extensionVersionObject, XWikiRepositoryModel.PROP_VERSION_FEATURES);\n        extension.withFeatures(features);\n        for (String feature : features) {\n            org.xwiki.extension.ExtensionId extensionId = ExtensionIdConverter.toExtensionId(feature, null);\n            ExtensionId extensionFeature = this.extensionObjectFactory.createExtensionId();\n            extensionFeature.setId(extensionId.getId());\n            if (extensionId.getVersion() != null) {\n                extensionFeature.setVersion(extensionId.getVersion().getValue());\n            }\n            extension.getExtensionFeatures().add(extensionFeature);\n        }\n\n        // Allowed namespaces\n        List<String> namespaces =\n            (List<String>) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_ALLOWEDNAMESPACES);\n        if (namespaces != null && !namespaces.isEmpty()) {\n            Namespaces restNamespaces = this.extensionObjectFactory.createNamespaces();\n            restNamespaces.withNamespaces(namespaces);\n            extension.setAllowedNamespaces(restNamespaces);\n        }\n\n        // Repositories\n        if (extensionVersionObject != null) {\n            List<String> repositories =\n                (List<String>) getValue(extensionVersionObject, XWikiRepositoryModel.PROP_VERSION_REPOSITORIES);\n            extensionVersion.withRepositories(toExtensionRepositories(repositories));\n        }\n\n        // Properties\n        addProperties(extension,\n            (List<String>) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_PROPERTIES));\n\n        // Dependencies\n        if (extensionVersion != null) {\n            List<BaseObject> dependencies =\n                extensionDocument.getXObjects(XWikiRepositoryModel.EXTENSIONDEPENDENCY_CLASSREFERENCE);\n            if (dependencies != null) {\n                for (BaseObject dependencyObject : dependencies) {\n                    if (dependencyObject != null) {\n                        if (StringUtils.equals(getValue(dependencyObject,\n                            XWikiRepositoryModel.PROP_DEPENDENCY_EXTENSIONVERSION, (String) null), version)) {\n                            ExtensionDependency dependency = extensionObjectFactory.createExtensionDependency();\n                            dependency\n                                .setId((String) getValue(dependencyObject, XWikiRepositoryModel.PROP_DEPENDENCY_ID));\n                            dependency.setConstraint(\n                                (String) getValue(dependencyObject, XWikiRepositoryModel.PROP_DEPENDENCY_CONSTRAINT));\n                            List<String> repositories = (List<String>) getValue(dependencyObject,\n                                XWikiRepositoryModel.PROP_DEPENDENCY_REPOSITORIES);\n                            dependency.withRepositories(toExtensionRepositories(repositories));\n\n                            extensionVersion.getDependencies().add(dependency);\n                        }\n                    }\n                }\n            }\n        }\n\n        return (E) extension;\n    }","id":92168,"modified_method":"protected <E extends AbstractExtension> E createExtension(XWikiDocument extensionDocument, String version)\n    {\n        BaseObject extensionObject = getExtensionObject(extensionDocument);\n        DocumentReference extensionDocumentReference = extensionDocument.getDocumentReference();\n\n        if (extensionObject == null) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        AbstractExtension extension;\n        ExtensionVersion extensionVersion;\n        BaseObject extensionVersionObject;\n        if (version == null) {\n            extension = this.extensionObjectFactory.createExtension();\n            extensionVersion = null;\n            extensionVersionObject = null;\n        } else {\n            extensionVersionObject = getExtensionVersionObject(extensionDocument, version);\n\n            if (extensionVersionObject == null) {\n                throw new WebApplicationException(Status.NOT_FOUND);\n            }\n\n            extensionVersion = this.extensionObjectFactory.createExtensionVersion();\n            extension = extensionVersion;\n            extensionVersion\n                .setVersion((String) getValue(extensionVersionObject, XWikiRepositoryModel.PROP_VERSION_VERSION));\n        }\n\n        extension.setId((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_ID));\n        extension.setType((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_TYPE));\n\n        License license = this.extensionObjectFactory.createLicense();\n        license.setName((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_LICENSENAME));\n        extension.getLicenses().add(license);\n\n        extension.setRating(getExtensionRating(extensionDocumentReference));\n        extension.setSummary((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_SUMMARY));\n        extension.setDescription((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_DESCRIPTION));\n        extension.setName((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_NAME));\n        extension.setCategory((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_CATEGORY));\n        extension.setWebsite(\n            StringUtils.defaultIfEmpty((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_WEBSITE),\n                extensionDocument.getExternalURL(\"view\", getXWikiContext())));\n\n        // SCM\n        ExtensionScm scm = new ExtensionScm();\n        scm.setUrl((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_SCMURL));\n        scm.setConnection(\n            toScmConnection((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_SCMCONNECTION)));\n        scm.setDeveloperConnection(\n            toScmConnection((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_SCMDEVCONNECTION)));\n        extension.setScm(scm);\n\n        // Issue Management\n        ExtensionIssueManagement issueManagement = new ExtensionIssueManagement();\n        issueManagement\n            .setSystem((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_SYSTEM));\n        issueManagement\n            .setUrl((String) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_URL));\n        if (StringUtils.isNotEmpty(issueManagement.getSystem()) || StringUtils.isNotEmpty(issueManagement.getUrl())) {\n            extension.setIssueManagement(issueManagement);\n        }\n\n        // Authors\n        List<String> authors = (List<String>) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_AUTHORS);\n        if (authors != null) {\n            for (String authorId : authors) {\n                extension.getAuthors().add(resolveExtensionAuthor(authorId));\n            }\n        }\n\n        // Features\n        List<String> features =\n            (List<String>) getValue(extensionVersionObject, XWikiRepositoryModel.PROP_VERSION_FEATURES);\n        if (features != null && !features.isEmpty()) {\n            extension.withFeatures(features);\n            for (String feature : features) {\n                org.xwiki.extension.ExtensionId extensionId = ExtensionIdConverter.toExtensionId(feature, null);\n                ExtensionId extensionFeature = this.extensionObjectFactory.createExtensionId();\n                extensionFeature.setId(extensionId.getId());\n                if (extensionId.getVersion() != null) {\n                    extensionFeature.setVersion(extensionId.getVersion().getValue());\n                }\n                extension.getExtensionFeatures().add(extensionFeature);\n            }\n        }\n\n        // Allowed namespaces\n        List<String> namespaces =\n            (List<String>) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_ALLOWEDNAMESPACES);\n        if (namespaces != null && !namespaces.isEmpty()) {\n            Namespaces restNamespaces = this.extensionObjectFactory.createNamespaces();\n            restNamespaces.withNamespaces(namespaces);\n            extension.setAllowedNamespaces(restNamespaces);\n        }\n\n        // Repositories\n        if (extensionVersionObject != null) {\n            List<String> repositories =\n                (List<String>) getValue(extensionVersionObject, XWikiRepositoryModel.PROP_VERSION_REPOSITORIES);\n            extensionVersion.withRepositories(toExtensionRepositories(repositories));\n        }\n\n        // Properties\n        addProperties(extension,\n            (List<String>) getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_PROPERTIES));\n\n        // Dependencies\n        if (extensionVersion != null) {\n            List<BaseObject> dependencies =\n                extensionDocument.getXObjects(XWikiRepositoryModel.EXTENSIONDEPENDENCY_CLASSREFERENCE);\n            if (dependencies != null) {\n                for (BaseObject dependencyObject : dependencies) {\n                    if (dependencyObject != null) {\n                        if (StringUtils.equals(getValue(dependencyObject,\n                            XWikiRepositoryModel.PROP_DEPENDENCY_EXTENSIONVERSION, (String) null), version)) {\n                            ExtensionDependency dependency = extensionObjectFactory.createExtensionDependency();\n                            dependency\n                                .setId((String) getValue(dependencyObject, XWikiRepositoryModel.PROP_DEPENDENCY_ID));\n                            dependency.setConstraint(\n                                (String) getValue(dependencyObject, XWikiRepositoryModel.PROP_DEPENDENCY_CONSTRAINT));\n                            List<String> repositories = (List<String>) getValue(dependencyObject,\n                                XWikiRepositoryModel.PROP_DEPENDENCY_REPOSITORIES);\n                            dependency.withRepositories(toExtensionRepositories(repositories));\n\n                            extensionVersion.getDependencies().add(dependency);\n                        }\n                    }\n                }\n            }\n        }\n\n        return (E) extension;\n    }","commit_id":"1bb3292f78849890f17be7fa32d5907ecd2eeae3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected ExtensionVersion createExtensionVersionFromQueryResult(Object[] entry)\n    {\n        XWikiContext xcontext = getXWikiContext();\n\n        String documentName = (String) entry[0];\n        String documentSpace = (String) entry[1];\n\n        ExtensionVersion extension = this.extensionObjectFactory.createExtensionVersion();\n\n        extension.setId(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_ID));\n        extension.setType(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_TYPE));\n        extension.setName(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_NAME));\n        extension.setSummary(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_SUMMARY));\n\n        // SCM\n        ExtensionScm scm = new ExtensionScm();\n        scm.setUrl(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_SCMURL));\n        scm.setConnection(\n            toScmConnection(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_SCMCONNECTION)));\n        scm.setDeveloperConnection(\n            toScmConnection(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_SCMDEVCONNECTION)));\n        extension.setScm(scm);\n\n        // Issue Management\n        ExtensionIssueManagement issueManagement = new ExtensionIssueManagement();\n        issueManagement\n            .setSystem(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_SYSTEM));\n        issueManagement\n            .setUrl(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_URL));\n        if (StringUtils.isNotEmpty(issueManagement.getSystem()) || StringUtils.isNotEmpty(issueManagement.getUrl())) {\n            extension.setIssueManagement(issueManagement);\n        }\n\n        // Rating\n        DocumentReference extensionDocumentReference =\n            new DocumentReference(xcontext.getWikiId(), documentSpace, documentName);\n        // FIXME: this adds potentially tons of new request to what used to be carefully crafted to produce a single\n        // request for the whole search... Should be cached in a filed of the document (like the last version is for\n        // example).\n        extension.setRating(getExtensionRating(extensionDocumentReference));\n\n        // Website\n        extension.setWebsite(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_WEBSITE));\n        if (StringUtils.isBlank(extension.getWebsite())) {\n            extension.setWebsite(xcontext.getWiki()\n                .getURL(new DocumentReference(xcontext.getWikiId(), documentSpace, documentName), \"view\", xcontext));\n        }\n\n        // Authors\n        for (String authorId : ListClass.getListFromString(\n            this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_AUTHORS), \"|\", false)) {\n            extension.getAuthors().add(resolveExtensionAuthor(authorId));\n        }\n\n        // Features\n        List<String> features = ListClass.getListFromString(\n            this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_FEATURES), \"|\", false);\n        extension.withFeatures(features);\n        for (String feature : features) {\n            org.xwiki.extension.ExtensionId extensionId = ExtensionIdConverter.toExtensionId(feature, null);\n            ExtensionId extensionFeature = this.extensionObjectFactory.createExtensionId();\n            extensionFeature.setId(extensionId.getId());\n            if (extensionId.getVersion() != null) {\n                extensionFeature.setVersion(extensionId.getVersion().getValue());\n            }\n            extension.getExtensionFeatures().add(extensionFeature);\n        }\n\n        // Allowed namespaces\n        String namespacesString =\n            this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_ALLOWEDNAMESPACES);\n        if (!StringUtils.isEmpty(namespacesString)) {\n            List<String> namespaces = ListClass.getListFromString(namespacesString, \"|\", false);\n            Namespaces restNamespaces = this.extensionObjectFactory.createNamespaces();\n            restNamespaces.withNamespaces(namespaces);\n            extension.setAllowedNamespaces(restNamespaces);\n        }\n\n        // License\n        License license = this.extensionObjectFactory.createLicense();\n        license.setName(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_LICENSENAME));\n        extension.getLicenses().add(license);\n\n        // Version\n        extension.setVersion((String) entry[EPROPERTIES_INDEX.size()]);\n\n        // TODO: add support for\n        // * description\n        // * dependencies\n\n        return extension;\n    }","id":92169,"modified_method":"protected ExtensionVersion createExtensionVersionFromQueryResult(Object[] entry)\n    {\n        XWikiContext xcontext = getXWikiContext();\n\n        String documentName = (String) entry[0];\n        String documentSpace = (String) entry[1];\n\n        ExtensionVersion extension = this.extensionObjectFactory.createExtensionVersion();\n\n        extension.setId(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_ID));\n        extension.setType(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_TYPE));\n        extension.setName(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_NAME));\n        extension.setSummary(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_SUMMARY));\n\n        // SCM\n        ExtensionScm scm = new ExtensionScm();\n        scm.setUrl(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_SCMURL));\n        scm.setConnection(\n            toScmConnection(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_SCMCONNECTION)));\n        scm.setDeveloperConnection(\n            toScmConnection(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_SCMDEVCONNECTION)));\n        extension.setScm(scm);\n\n        // Issue Management\n        ExtensionIssueManagement issueManagement = new ExtensionIssueManagement();\n        issueManagement\n            .setSystem(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_SYSTEM));\n        issueManagement\n            .setUrl(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_URL));\n        if (StringUtils.isNotEmpty(issueManagement.getSystem()) || StringUtils.isNotEmpty(issueManagement.getUrl())) {\n            extension.setIssueManagement(issueManagement);\n        }\n\n        // Rating\n        DocumentReference extensionDocumentReference =\n            new DocumentReference(xcontext.getWikiId(), documentSpace, documentName);\n        // FIXME: this adds potentially tons of new request to what used to be carefully crafted to produce a single\n        // request for the whole search... Should be cached in a filed of the document (like the last version is for\n        // example).\n        extension.setRating(getExtensionRating(extensionDocumentReference));\n\n        // Website\n        extension.setWebsite(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_WEBSITE));\n        if (StringUtils.isBlank(extension.getWebsite())) {\n            extension.setWebsite(xcontext.getWiki()\n                .getURL(new DocumentReference(xcontext.getWikiId(), documentSpace, documentName), \"view\", xcontext));\n        }\n\n        // Authors\n        for (String authorId : ListClass.getListFromString(\n            this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_AUTHORS), \"|\", false)) {\n            extension.getAuthors().add(resolveExtensionAuthor(authorId));\n        }\n\n        // Features\n        List<String> features = ListClass.getListFromString(\n            this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_FEATURES), \"|\", false);\n        if (features != null && !features.isEmpty()) {\n            extension.withFeatures(features);\n            for (String feature : features) {\n                org.xwiki.extension.ExtensionId extensionId = ExtensionIdConverter.toExtensionId(feature, null);\n                ExtensionId extensionFeature = this.extensionObjectFactory.createExtensionId();\n                extensionFeature.setId(extensionId.getId());\n                if (extensionId.getVersion() != null) {\n                    extensionFeature.setVersion(extensionId.getVersion().getValue());\n                }\n                extension.getExtensionFeatures().add(extensionFeature);\n            }\n        }\n\n        // Allowed namespaces\n        String namespacesString =\n            this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_ALLOWEDNAMESPACES);\n        if (!StringUtils.isEmpty(namespacesString)) {\n            List<String> namespaces = ListClass.getListFromString(namespacesString, \"|\", false);\n            Namespaces restNamespaces = this.extensionObjectFactory.createNamespaces();\n            restNamespaces.withNamespaces(namespaces);\n            extension.setAllowedNamespaces(restNamespaces);\n        }\n\n        // License\n        License license = this.extensionObjectFactory.createLicense();\n        license.setName(this.<String>getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_LICENSENAME));\n        extension.getLicenses().add(license);\n\n        // Version\n        extension.setVersion((String) entry[EPROPERTIES_INDEX.size()]);\n\n        // TODO: add support for\n        // * description\n        // * dependencies\n\n        return extension;\n    }","commit_id":"1bb3292f78849890f17be7fa32d5907ecd2eeae3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected ExtensionVersion createExtensionVersionFromSolrDocument(SolrDocument document)\n    {\n        XWikiContext xcontext = getXWikiContext();\n\n        ExtensionVersion extension = this.extensionObjectFactory.createExtensionVersion();\n\n        extension.setId(this.<String>getSolrValue(document, Extension.FIELD_ID, true));\n        extension.setType(this.<String>getSolrValue(document, Extension.FIELD_TYPE, true));\n        extension.setName(this.<String>getSolrValue(document, Extension.FIELD_NAME, false));\n        extension.setSummary(this.<String>getSolrValue(document, Extension.FIELD_SUMMARY, false));\n\n        // SCM\n        ExtensionScm scm = new ExtensionScm();\n        scm.setUrl(this.<String>getSolrValue(document, Extension.FIELD_SCM, true));\n        scm.setConnection(toScmConnection(\n            this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_SCMCONNECTION, true)));\n        scm.setDeveloperConnection(toScmConnection(\n            this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_SCMDEVCONNECTION, true)));\n        if (scm.getUrl() != null || scm.getConnection() != null || scm.getDeveloperConnection() != null) {\n            extension.setScm(scm);\n        }\n\n        // Issue Management\n        ExtensionIssueManagement issueManagement = new ExtensionIssueManagement();\n        issueManagement.setSystem(\n            this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_SYSTEM, true));\n        issueManagement\n            .setUrl(this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_URL, true));\n        if (issueManagement.getSystem() != null || issueManagement.getUrl() != null) {\n            extension.setIssueManagement(issueManagement);\n        }\n\n        // Rating\n        ExtensionRating extensionRating = this.extensionObjectFactory.createExtensionRating();\n        extensionRating.setTotalVotes(getSolrValue(document, XWikiRepositoryModel.PROP_RATING_TOTALVOTES, false, 0));\n        extensionRating\n            .setAverageVote(getSolrValue(document, XWikiRepositoryModel.PROP_RATING_AVERAGEVOTE, false, 0.0f));\n        extension.setRating(extensionRating);\n\n        // Website\n        extension.setWebsite(this.<String>getSolrValue(document, Extension.FIELD_WEBSITE, true));\n        if (extension.getWebsite() == null) {\n            DocumentReference extensionDocumentReference = this.solrDocumentReferenceResolver.resolve(document);\n            extension.setWebsite(xcontext.getWiki().getURL(extensionDocumentReference, xcontext));\n        }\n\n        // Authors\n        Collection<String> authors = this.<String>getSolrValues(document, Extension.FIELD_AUTHORS);\n        if (authors != null) {\n            for (String authorId : authors) {\n                extension.getAuthors().add(resolveExtensionAuthor(authorId));\n            }\n        }\n\n        // Features\n        Collection<String> features = this.<String>getSolrValues(document, Extension.FIELD_FEATURES);\n        if (features != null) {\n            extension.withFeatures(features);\n            for (String feature : features) {\n                org.xwiki.extension.ExtensionId extensionId = ExtensionIdConverter.toExtensionId(feature, null);\n                ExtensionId extensionFeature = this.extensionObjectFactory.createExtensionId();\n                extensionFeature.setId(extensionId.getId());\n                if (extensionId.getVersion() != null) {\n                    extensionFeature.setVersion(extensionId.getVersion().getValue());\n                }\n                extension.getExtensionFeatures().add(extensionFeature);\n            }\n        }\n\n        // License\n        String licenseName = this.<String>getSolrValue(document, Extension.FIELD_LICENSE, true);\n        if (licenseName != null) {\n            License license = this.extensionObjectFactory.createLicense();\n            license.setName(licenseName);\n            extension.getLicenses().add(license);\n        }\n\n        // Allowed namespaces\n        Collection<String> namespaces = this.<String>getSolrValues(document, Extension.FIELD_ALLOWEDNAMESPACES);\n        if (namespaces != null && !namespaces.isEmpty()) {\n            Namespaces restNamespaces = this.extensionObjectFactory.createNamespaces();\n            restNamespaces.withNamespaces(namespaces);\n            extension.setAllowedNamespaces(restNamespaces);\n        }\n\n        // Version\n        extension.setVersion(this.<String>getSolrValue(document, Extension.FIELD_VERSION, true));\n\n        // Properties\n        addProperties(extension, this.<String>getSolrValues(document, Extension.FIELD_PROPERTIES));\n\n        // TODO: add support for\n        // * dependencies\n\n        return extension;\n    }","id":92170,"modified_method":"protected ExtensionVersion createExtensionVersionFromSolrDocument(SolrDocument document)\n    {\n        XWikiContext xcontext = getXWikiContext();\n\n        ExtensionVersion extension = this.extensionObjectFactory.createExtensionVersion();\n\n        extension.setId(this.<String>getSolrValue(document, Extension.FIELD_ID, true));\n        extension.setType(this.<String>getSolrValue(document, Extension.FIELD_TYPE, true));\n        extension.setName(this.<String>getSolrValue(document, Extension.FIELD_NAME, false));\n        extension.setSummary(this.<String>getSolrValue(document, Extension.FIELD_SUMMARY, false));\n\n        // SCM\n        ExtensionScm scm = new ExtensionScm();\n        scm.setUrl(this.<String>getSolrValue(document, Extension.FIELD_SCM, true));\n        scm.setConnection(toScmConnection(\n            this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_SCMCONNECTION, true)));\n        scm.setDeveloperConnection(toScmConnection(\n            this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_SCMDEVCONNECTION, true)));\n        if (scm.getUrl() != null || scm.getConnection() != null || scm.getDeveloperConnection() != null) {\n            extension.setScm(scm);\n        }\n\n        // Issue Management\n        ExtensionIssueManagement issueManagement = new ExtensionIssueManagement();\n        issueManagement.setSystem(\n            this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_SYSTEM, true));\n        issueManagement\n            .setUrl(this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_URL, true));\n        if (issueManagement.getSystem() != null || issueManagement.getUrl() != null) {\n            extension.setIssueManagement(issueManagement);\n        }\n\n        // Rating\n        ExtensionRating extensionRating = this.extensionObjectFactory.createExtensionRating();\n        extensionRating.setTotalVotes(getSolrValue(document, XWikiRepositoryModel.PROP_RATING_TOTALVOTES, false, 0));\n        extensionRating\n            .setAverageVote(getSolrValue(document, XWikiRepositoryModel.PROP_RATING_AVERAGEVOTE, false, 0.0f));\n        extension.setRating(extensionRating);\n\n        // Website\n        extension.setWebsite(this.<String>getSolrValue(document, Extension.FIELD_WEBSITE, true));\n        if (extension.getWebsite() == null) {\n            DocumentReference extensionDocumentReference = this.solrDocumentReferenceResolver.resolve(document);\n            extension.setWebsite(xcontext.getWiki().getURL(extensionDocumentReference, xcontext));\n        }\n\n        // Authors\n        Collection<String> authors = this.<String>getSolrValues(document, Extension.FIELD_AUTHORS);\n        if (authors != null) {\n            for (String authorId : authors) {\n                extension.getAuthors().add(resolveExtensionAuthor(authorId));\n            }\n        }\n\n        // Features\n        Collection<String> features = this.<String>getSolrValues(document, Extension.FIELD_FEATURES);\n        if (features != null && !features.isEmpty()) {\n            extension.withFeatures(features);\n            for (String feature : features) {\n                org.xwiki.extension.ExtensionId extensionId = ExtensionIdConverter.toExtensionId(feature, null);\n                ExtensionId extensionFeature = this.extensionObjectFactory.createExtensionId();\n                extensionFeature.setId(extensionId.getId());\n                if (extensionId.getVersion() != null) {\n                    extensionFeature.setVersion(extensionId.getVersion().getValue());\n                }\n                extension.getExtensionFeatures().add(extensionFeature);\n            }\n        }\n\n        // License\n        String licenseName = this.<String>getSolrValue(document, Extension.FIELD_LICENSE, true);\n        if (licenseName != null) {\n            License license = this.extensionObjectFactory.createLicense();\n            license.setName(licenseName);\n            extension.getLicenses().add(license);\n        }\n\n        // Allowed namespaces\n        Collection<String> namespaces = this.<String>getSolrValues(document, Extension.FIELD_ALLOWEDNAMESPACES);\n        if (namespaces != null && !namespaces.isEmpty()) {\n            Namespaces restNamespaces = this.extensionObjectFactory.createNamespaces();\n            restNamespaces.withNamespaces(namespaces);\n            extension.setAllowedNamespaces(restNamespaces);\n        }\n\n        // Version\n        extension.setVersion(this.<String>getSolrValue(document, Extension.FIELD_VERSION, true));\n\n        // Properties\n        addProperties(extension, this.<String>getSolrValues(document, Extension.FIELD_PROPERTIES));\n\n        // TODO: add support for\n        // * dependencies\n\n        return extension;\n    }","commit_id":"1bb3292f78849890f17be7fa32d5907ecd2eeae3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected ExtensionVersion createExtensionVersionFromSolrDocument(SolrDocument document)\n    {\n        XWikiContext xcontext = getXWikiContext();\n\n        ExtensionVersion extension = this.extensionObjectFactory.createExtensionVersion();\n\n        extension.setId(this.<String>getSolrValue(document, Extension.FIELD_ID, true));\n        extension.setType(this.<String>getSolrValue(document, Extension.FIELD_TYPE, true));\n        extension.setName(this.<String>getSolrValue(document, Extension.FIELD_NAME, false));\n        extension.setSummary(this.<String>getSolrValue(document, Extension.FIELD_SUMMARY, false));\n\n        // SCM\n        ExtensionScm scm = new ExtensionScm();\n        scm.setUrl(this.<String>getSolrValue(document, Extension.FIELD_SCM, true));\n        scm.setConnection(toScmConnection(\n            this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_SCMCONNECTION, true)));\n        scm.setDeveloperConnection(toScmConnection(\n            this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_SCMDEVCONNECTION, true)));\n        if (scm.getUrl() != null || scm.getConnection() != null || scm.getDeveloperConnection() != null) {\n            extension.setScm(scm);\n        }\n\n        // Issue Management\n        ExtensionIssueManagement issueManagement = new ExtensionIssueManagement();\n        issueManagement.setSystem(\n            this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_SYSTEM, true));\n        issueManagement\n            .setUrl(this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_URL, true));\n        if (issueManagement.getSystem() != null || issueManagement.getUrl() != null) {\n            extension.setIssueManagement(issueManagement);\n        }\n\n        // Rating\n        ExtensionRating extensionRating = this.extensionObjectFactory.createExtensionRating();\n        extensionRating.setTotalVotes(getSolrValue(document, XWikiRepositoryModel.PROP_RATING_TOTALVOTES, false, 0));\n        extensionRating\n            .setAverageVote(getSolrValue(document, XWikiRepositoryModel.PROP_RATING_AVERAGEVOTE, false, 0.0f));\n        extension.setRating(extensionRating);\n\n        // Website\n        extension.setWebsite(this.<String>getSolrValue(document, Extension.FIELD_WEBSITE, true));\n        if (extension.getWebsite() == null) {\n            DocumentReference extensionDocumentReference = this.solrDocumentReferenceResolver.resolve(document);\n            extension.setWebsite(xcontext.getWiki().getURL(extensionDocumentReference, xcontext));\n        }\n\n        // Authors\n        Collection<String> authors = this.<String>getSolrValues(document, Extension.FIELD_AUTHORS);\n        if (authors != null) {\n            for (String authorId : authors) {\n                extension.getAuthors().add(resolveExtensionAuthor(authorId));\n            }\n        }\n\n        // Features\n        Collection<String> features = this.<String>getSolrValues(document, Extension.FIELD_FEATURES);\n        extension.withFeatures(features);\n        for (String feature : features) {\n            org.xwiki.extension.ExtensionId extensionId = ExtensionIdConverter.toExtensionId(feature, null);\n            ExtensionId extensionFeature = this.extensionObjectFactory.createExtensionId();\n            extensionFeature.setId(extensionId.getId());\n            extensionFeature.setVersion(extensionId.getVersion().getValue());\n            extension.getExtensionFeatures().add(extensionFeature);\n        }\n\n        // License\n        String licenseName = this.<String>getSolrValue(document, Extension.FIELD_LICENSE, true);\n        if (licenseName != null) {\n            License license = this.extensionObjectFactory.createLicense();\n            license.setName(licenseName);\n            extension.getLicenses().add(license);\n        }\n\n        // Allowed namespaces\n        Collection<String> namespaces = this.<String>getSolrValues(document, Extension.FIELD_ALLOWEDNAMESPACES);\n        if (namespaces != null && !namespaces.isEmpty()) {\n            Namespaces restNamespaces = this.extensionObjectFactory.createNamespaces();\n            restNamespaces.withNamespaces(namespaces);\n            extension.setAllowedNamespaces(restNamespaces);\n        }\n\n        // Version\n        extension.setVersion(this.<String>getSolrValue(document, Extension.FIELD_VERSION, true));\n\n        // TODO: add support for\n        // * dependencies\n\n        return extension;\n    }","id":92171,"modified_method":"protected ExtensionVersion createExtensionVersionFromSolrDocument(SolrDocument document)\n    {\n        XWikiContext xcontext = getXWikiContext();\n\n        ExtensionVersion extension = this.extensionObjectFactory.createExtensionVersion();\n\n        extension.setId(this.<String>getSolrValue(document, Extension.FIELD_ID, true));\n        extension.setType(this.<String>getSolrValue(document, Extension.FIELD_TYPE, true));\n        extension.setName(this.<String>getSolrValue(document, Extension.FIELD_NAME, false));\n        extension.setSummary(this.<String>getSolrValue(document, Extension.FIELD_SUMMARY, false));\n\n        // SCM\n        ExtensionScm scm = new ExtensionScm();\n        scm.setUrl(this.<String>getSolrValue(document, Extension.FIELD_SCM, true));\n        scm.setConnection(toScmConnection(\n            this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_SCMCONNECTION, true)));\n        scm.setDeveloperConnection(toScmConnection(\n            this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_SCMDEVCONNECTION, true)));\n        if (scm.getUrl() != null || scm.getConnection() != null || scm.getDeveloperConnection() != null) {\n            extension.setScm(scm);\n        }\n\n        // Issue Management\n        ExtensionIssueManagement issueManagement = new ExtensionIssueManagement();\n        issueManagement.setSystem(\n            this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_SYSTEM, true));\n        issueManagement\n            .setUrl(this.<String>getSolrValue(document, XWikiRepositoryModel.PROP_EXTENSION_ISSUEMANAGEMENT_URL, true));\n        if (issueManagement.getSystem() != null || issueManagement.getUrl() != null) {\n            extension.setIssueManagement(issueManagement);\n        }\n\n        // Rating\n        ExtensionRating extensionRating = this.extensionObjectFactory.createExtensionRating();\n        extensionRating.setTotalVotes(getSolrValue(document, XWikiRepositoryModel.PROP_RATING_TOTALVOTES, false, 0));\n        extensionRating\n            .setAverageVote(getSolrValue(document, XWikiRepositoryModel.PROP_RATING_AVERAGEVOTE, false, 0.0f));\n        extension.setRating(extensionRating);\n\n        // Website\n        extension.setWebsite(this.<String>getSolrValue(document, Extension.FIELD_WEBSITE, true));\n        if (extension.getWebsite() == null) {\n            DocumentReference extensionDocumentReference = this.solrDocumentReferenceResolver.resolve(document);\n            extension.setWebsite(xcontext.getWiki().getURL(extensionDocumentReference, xcontext));\n        }\n\n        // Authors\n        Collection<String> authors = this.<String>getSolrValues(document, Extension.FIELD_AUTHORS);\n        if (authors != null) {\n            for (String authorId : authors) {\n                extension.getAuthors().add(resolveExtensionAuthor(authorId));\n            }\n        }\n\n        // Features\n        Collection<String> features = this.<String>getSolrValues(document, Extension.FIELD_FEATURES);\n        if (features != null) {\n            extension.withFeatures(features);\n            for (String feature : features) {\n                org.xwiki.extension.ExtensionId extensionId = ExtensionIdConverter.toExtensionId(feature, null);\n                ExtensionId extensionFeature = this.extensionObjectFactory.createExtensionId();\n                extensionFeature.setId(extensionId.getId());\n                extensionFeature.setVersion(extensionId.getVersion().getValue());\n                extension.getExtensionFeatures().add(extensionFeature);\n            }\n        }\n\n        // License\n        String licenseName = this.<String>getSolrValue(document, Extension.FIELD_LICENSE, true);\n        if (licenseName != null) {\n            License license = this.extensionObjectFactory.createLicense();\n            license.setName(licenseName);\n            extension.getLicenses().add(license);\n        }\n\n        // Allowed namespaces\n        Collection<String> namespaces = this.<String>getSolrValues(document, Extension.FIELD_ALLOWEDNAMESPACES);\n        if (namespaces != null && !namespaces.isEmpty()) {\n            Namespaces restNamespaces = this.extensionObjectFactory.createNamespaces();\n            restNamespaces.withNamespaces(namespaces);\n            extension.setAllowedNamespaces(restNamespaces);\n        }\n\n        // Version\n        extension.setVersion(this.<String>getSolrValue(document, Extension.FIELD_VERSION, true));\n\n        // TODO: add support for\n        // * dependencies\n\n        return extension;\n    }","commit_id":"afef983bf6aef1463c15f5f6afcd41a7dd48d84f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testImportExtension() throws Exception\n    {\n        getUtil().createUser(USER_CREDENTIALS.getUserName(), USER_CREDENTIALS.getPassword(), null, \"first_name\",\n            \"User\", \"last_name\", \"Name\");\n\n        ExtensionsPage extensionsPage = ExtensionsPage.gotoPage();\n\n        ExtensionImportPage importPage = extensionsPage.clickImport();\n\n        importPage.setExtensionId(\"maven:extension\");\n        importPage.setSourceRepository(\"maven-test\");\n        ExtensionPage extensionPage = importPage.clickImport();\n\n        // Check\n\n        Assert.assertEquals(\"1.1\", extensionPage.getMetaDataValue(\"version\"));\n        Assert.assertTrue(extensionPage.isValidExtension());\n\n        // 2.0\n\n        TestExtension emptyExtension =\n            getRepositoryTestUtils().getTestExtension(new ExtensionId(\"emptyjar\", \"1.0\"), \"jar\");\n\n        long fileSize = FileUtils.sizeOf(emptyExtension.getFile().getFile());\n\n        ExtensionVersion extension =\n            getUtil().rest().getResource(Resources.EXTENSION_VERSION, null, \"maven:extension\", \"2.0\");\n\n        Assert.assertEquals(\"maven:extension\", extension.getId());\n        Assert.assertEquals(\"jar\", extension.getType());\n        Assert.assertEquals(\"2.0\", extension.getVersion());\n        Assert.assertEquals(\"name\", extension.getName());\n        Assert.assertEquals(\"summary2\", extension.getSummary());\n        Assert.assertEquals(\"summary2\\n      some more details\", extension.getDescription());\n        Assert.assertEquals(this.baseAuthor.getName(), extension.getAuthors().get(0).getName());\n        Assert.assertEquals(this.baseAuthor.getURL().toString(), extension.getAuthors().get(0).getUrl());\n        Assert.assertEquals(Arrays.asList(\"maven:oldextension\"), extension.getFeatures());\n        Assert.assertEquals(\"GNU Lesser General Public License 2.1\", extension.getLicenses().get(0).getName());\n\n        Assert.assertEquals(fileSize,\n            getUtil().rest().getBuffer(Resources.EXTENSION_VERSION_FILE, null, \"maven:extension\", \"2.0\").length);\n\n        // 1.0\n\n        extension = getUtil().rest().getResource(Resources.EXTENSION_VERSION, null, \"maven:extension\", \"1.0\");\n\n        Assert.assertEquals(\"maven:extension\", extension.getId());\n        Assert.assertEquals(\"jar\", extension.getType());\n        Assert.assertEquals(\"1.0\", extension.getVersion());\n        Assert.assertEquals(\"name\", extension.getName());\n        Assert.assertEquals(\"summary2\", extension.getSummary());\n        Assert.assertEquals(\"summary2\\n      some more details\", extension.getDescription());\n        Assert.assertEquals(this.baseAuthor.getName(), extension.getAuthors().get(0).getName());\n        Assert.assertEquals(this.baseAuthor.getURL().toString(), extension.getAuthors().get(0).getUrl());\n        Assert.assertEquals(Arrays.asList(\"maven:oldextension\"), extension.getFeatures());\n        Assert.assertEquals(\"GNU Lesser General Public License 2.1\", extension.getLicenses().get(0).getName());\n\n        Assert.assertEquals(FileUtils.sizeOf(emptyExtension.getFile().getFile()),\n            getUtil().rest().getBuffer(Resources.EXTENSION_VERSION_FILE, null, \"maven:extension\", \"1.0\").length);\n\n        // 0.9\n\n        extension = getUtil().rest().getResource(Resources.EXTENSION_VERSION, null, \"maven:extension\", \"0.9\");\n\n        Assert.assertEquals(\"maven:extension\", extension.getId());\n        Assert.assertEquals(\"jar\", extension.getType());\n        Assert.assertEquals(\"0.9\", extension.getVersion());\n        Assert.assertEquals(\"name\", extension.getName());\n        Assert.assertEquals(\"summary2\", extension.getSummary());\n        Assert.assertEquals(\"summary2\\n      some more details\", extension.getDescription());\n        Assert.assertEquals(this.baseAuthor.getName(), extension.getAuthors().get(0).getName());\n        Assert.assertEquals(this.baseAuthor.getURL().toString(), extension.getAuthors().get(0).getUrl());\n        Assert.assertEquals(Arrays.asList(\"maven:oldextension\"), extension.getFeatures());\n        Assert.assertEquals(\"GNU Lesser General Public License 2.1\", extension.getLicenses().get(0).getName());\n\n        Assert.assertEquals(fileSize,\n            getUtil().rest().getBuffer(Resources.EXTENSION_VERSION_FILE, null, \"maven:extension\", \"0.9\").length);\n\n        // Import again\n\n        extensionPage = extensionPage.updateExtension();\n\n        Assert.assertEquals(\"1.1\", extensionPage.getMetaDataValue(\"version\"));\n    }","id":92172,"modified_method":"@Test\n    public void testImportExtension() throws Exception\n    {\n        getUtil().createUser(USER_CREDENTIALS.getUserName(), USER_CREDENTIALS.getPassword(), null, \"first_name\",\n            \"User\", \"last_name\", \"Name\");\n\n        ExtensionsPage extensionsPage = ExtensionsPage.gotoPage();\n\n        ExtensionImportPage importPage = extensionsPage.clickImport();\n\n        importPage.setExtensionId(\"maven:extension\");\n        importPage.setSourceRepository(\"maven-test\");\n        ExtensionPage extensionPage = importPage.clickImport();\n\n        // Check\n\n        Assert.assertEquals(\"1.1\", extensionPage.getMetaDataValue(\"version\"));\n        Assert.assertTrue(extensionPage.isValidExtension());\n\n        // 2.0\n\n        TestExtension emptyExtension =\n            getRepositoryTestUtils().getTestExtension(new ExtensionId(\"emptyjar\", \"1.0\"), \"jar\");\n\n        long fileSize = FileUtils.sizeOf(emptyExtension.getFile().getFile());\n\n        ExtensionVersion extension =\n            getUtil().rest().getResource(Resources.EXTENSION_VERSION, null, \"maven:extension\", \"2.0\");\n\n        Assert.assertEquals(\"maven:extension\", extension.getId());\n        Assert.assertEquals(\"jar\", extension.getType());\n        Assert.assertEquals(\"2.0\", extension.getVersion());\n        Assert.assertEquals(\"name\", extension.getName());\n        Assert.assertEquals(\"summary2\", extension.getSummary());\n        Assert.assertEquals(\"summary2\\n      some more details\", extension.getDescription());\n        Assert.assertEquals(this.baseAuthor.getName(), extension.getAuthors().get(0).getName());\n        Assert.assertEquals(this.baseAuthor.getURL().toString(), extension.getAuthors().get(0).getUrl());\n        Assert.assertEquals(Arrays.asList(\"maven:oldextension/2.0\"), extension.getFeatures());\n        Assert.assertEquals(\"GNU Lesser General Public License 2.1\", extension.getLicenses().get(0).getName());\n\n        Assert.assertEquals(fileSize,\n            getUtil().rest().getBuffer(Resources.EXTENSION_VERSION_FILE, null, \"maven:extension\", \"2.0\").length);\n\n        // 1.0\n\n        extension = getUtil().rest().getResource(Resources.EXTENSION_VERSION, null, \"maven:extension\", \"1.0\");\n\n        Assert.assertEquals(\"maven:extension\", extension.getId());\n        Assert.assertEquals(\"jar\", extension.getType());\n        Assert.assertEquals(\"1.0\", extension.getVersion());\n        Assert.assertEquals(\"name\", extension.getName());\n        Assert.assertEquals(\"summary2\", extension.getSummary());\n        Assert.assertEquals(\"summary2\\n      some more details\", extension.getDescription());\n        Assert.assertEquals(this.baseAuthor.getName(), extension.getAuthors().get(0).getName());\n        Assert.assertEquals(this.baseAuthor.getURL().toString(), extension.getAuthors().get(0).getUrl());\n        Assert.assertEquals(Arrays.asList(\"maven:oldextension/1.0\"), extension.getFeatures());\n        Assert.assertEquals(\"GNU Lesser General Public License 2.1\", extension.getLicenses().get(0).getName());\n\n        Assert.assertEquals(FileUtils.sizeOf(emptyExtension.getFile().getFile()),\n            getUtil().rest().getBuffer(Resources.EXTENSION_VERSION_FILE, null, \"maven:extension\", \"1.0\").length);\n\n        // 0.9\n\n        extension = getUtil().rest().getResource(Resources.EXTENSION_VERSION, null, \"maven:extension\", \"0.9\");\n\n        Assert.assertEquals(\"maven:extension\", extension.getId());\n        Assert.assertEquals(\"jar\", extension.getType());\n        Assert.assertEquals(\"0.9\", extension.getVersion());\n        Assert.assertEquals(\"name\", extension.getName());\n        Assert.assertEquals(\"summary2\", extension.getSummary());\n        Assert.assertEquals(\"summary2\\n      some more details\", extension.getDescription());\n        Assert.assertEquals(this.baseAuthor.getName(), extension.getAuthors().get(0).getName());\n        Assert.assertEquals(this.baseAuthor.getURL().toString(), extension.getAuthors().get(0).getUrl());\n        Assert.assertEquals(Arrays.asList(\"maven:oldextension/0.9\"), extension.getFeatures());\n        Assert.assertEquals(\"GNU Lesser General Public License 2.1\", extension.getLicenses().get(0).getName());\n\n        Assert.assertEquals(fileSize,\n            getUtil().rest().getBuffer(Resources.EXTENSION_VERSION_FILE, null, \"maven:extension\", \"0.9\").length);\n\n        // Import again\n\n        extensionPage = extensionPage.updateExtension();\n\n        Assert.assertEquals(\"1.1\", extensionPage.getMetaDataValue(\"version\"));\n    }","commit_id":"afef983bf6aef1463c15f5f6afcd41a7dd48d84f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Creates an instance of <tt>AccountsConfigurationForm<\/tt>.\n     *\n     * @param mainFrame the main application window\n     */\n    public AccountsConfigurationForm(MainFrame mainFrame) {\n        super(new BorderLayout());\n\n        this.mainFrame = mainFrame;\n\n        GuiActivator.bundleContext.addServiceListener(this);\n\n        this.tableInit();\n\n        this.buttonsPanelInit();\n\n        this.add(tablePane, BorderLayout.CENTER);\n        this.add(rightPanel, BorderLayout.EAST);\n    }","id":92173,"modified_method":"/**\n     * Creates an instance of <tt>AccountsConfigurationForm<\/tt>.\n     *\n     * @param mainFrame the main application window\n     */\n    public AccountsConfigurationForm(MainFrame mainFrame) {\n        super(new BorderLayout());\n\n        this.mainFrame = mainFrame;\n\n        GuiActivator.bundleContext.addServiceListener(this);\n\n        this.tableInit();\n\n        this.buttonsPanelInit();\n\n        this.add(tablePane, BorderLayout.CENTER);\n        this.add(rightPanel, BorderLayout.EAST);\n        \n        this.setPreferredSize(new Dimension(500, 400));\n    }","commit_id":"f4c5c6cb19d0730bcec8b6eafc9aa2270aebd40c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>ConfigurationManagerImpl<\/tt>.\n     * \n     * @param mainFrame The main application window.\n     */\n    public ConfigurationFrame(MainFrame mainFrame) {\n        \n        super(mainFrame);\n       \n        this.mainFrame = mainFrame;\n\n        this.setTitle(Messages.getString(\"configuration\"));\n        \n        this.getContentPane().setLayout(new BorderLayout());\n\n        this.addDefaultForms();\n\n        this.centerPanel.add(formScrollPane, BorderLayout.CENTER);\n\n        this.getContentPane().add(centerPanel, BorderLayout.CENTER);\n\n        this.getContentPane().add(configList, BorderLayout.WEST);\n        \n        this.buttonsPanel.add(cancelButton);\n        \n        this.cancelButton.addActionListener(new ActionListener(){\n\n            public void actionPerformed(ActionEvent e)\n            {\n                dispose();\n            }\n        });\n        \n        this.getContentPane().add(buttonsPanel, BorderLayout.SOUTH);         \n    }","id":92174,"modified_method":"/**\n     * Creates an instance of <tt>ConfigurationManagerImpl<\/tt>.\n     * \n     * @param mainFrame The main application window.\n     */\n    public ConfigurationFrame(MainFrame mainFrame) {\n        \n        super(mainFrame);\n       \n        this.mainFrame = mainFrame;\n\n        this.setTitle(Messages.getString(\"configuration\"));\n        \n        this.getContentPane().setLayout(new BorderLayout());\n\n        this.addDefaultForms();\n\n        this.centerPanel.add(formScrollPane, BorderLayout.CENTER);\n\n        this.mainPanel.add(centerPanel, BorderLayout.CENTER);\n\n        this.mainPanel.add(configList, BorderLayout.WEST);\n        \n        this.buttonsPanel.add(cancelButton);\n        \n        this.cancelButton.addActionListener(new ActionListener(){\n\n            public void actionPerformed(ActionEvent e)\n            {\n                dispose();\n            }\n        });\n        \n        this.mainPanel.add(buttonsPanel, BorderLayout.SOUTH);\n        \n        this.getContentPane().add(mainPanel);\n    }","commit_id":"f4c5c6cb19d0730bcec8b6eafc9aa2270aebd40c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Calculates the size of the frame depending on the size of the largest\n     * contained form.\n     */\n    public void recalculateSize() {\n\n        double width = 0;\n\n        double height = 0;\n\n        for (int i = 0; i < configContainer.size(); i++) {\n\n            ConfigurationForm configForm = (ConfigurationForm) configContainer\n                    .get(i);\n            \n            Component form = (Component)configForm.getForm();\n            if (width < form.getPreferredSize().getWidth())\n                width = form.getPreferredSize().getWidth();\n\n            if (height < form.getPreferredSize().getHeight())\n                height = form.getPreferredSize().getHeight();\n        }\n\n        if (width > Constants.CONFIG_FRAME_MAX_WIDTH)\n            width = Constants.CONFIG_FRAME_MAX_WIDTH;\n\n        if (height > Constants.CONFIG_FRAME_MAX_HEIGHT)\n            height = Constants.CONFIG_FRAME_MAX_HEIGHT;\n\n        width = width + configList.getPreferredSize().getWidth();\n\n        height = height + titlePanel.getPreferredSize().getHeight();\n\n        this.setSize((int) width + 120, (int) height + 50);\n    }","id":92175,"modified_method":"/**\n     * Calculates the size of the frame depending on the size of the largest\n     * contained form.\n     */\n    public void recalculateSize() {\n\n        double width = 0;\n\n        double height = 0;\n\n        for (int i = 0; i < configContainer.size(); i++) {\n\n            ConfigurationForm configForm = (ConfigurationForm) configContainer\n                    .get(i);\n            \n            Component form = (Component)configForm.getForm();\n            if (width < form.getPreferredSize().getWidth())\n                width = form.getPreferredSize().getWidth();\n\n            if (height < form.getPreferredSize().getHeight())\n                height = form.getPreferredSize().getHeight();\n        }\n        \n        this.mainPanel.setPreferredSize(new Dimension(\n            (int) width + 150, (int) height + 100));\n    }","commit_id":"f4c5c6cb19d0730bcec8b6eafc9aa2270aebd40c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initiates the content of this frame.\n     */\n    private void init()\n    {\n        this.addKeyBinding(KeyStroke.getKeyStroke(KeyEvent.VK_F2, 0),\n                new RenameAction());\n\n        this.menusPanel.add(menu, BorderLayout.NORTH);\n        this.menusPanel.add(quickMenu, BorderLayout.CENTER);\n\n        this.contactListPanel.add(tabbedPane, BorderLayout.CENTER);\n        this.contactListPanel.add(callManager, BorderLayout.SOUTH);\n\n        this.getContentPane().add(menusPanel, BorderLayout.NORTH);\n        this.getContentPane().add(contactListPanel, BorderLayout.CENTER);\n        this.getContentPane().add(statusPanel, BorderLayout.SOUTH);\n    }","id":92176,"modified_method":"/**\n     * Initiates the content of this frame.\n     */\n    private void init()\n    {\n        this.addKeyBinding(KeyStroke.getKeyStroke(KeyEvent.VK_F2, 0),\n                new RenameAction());\n\n        this.setJMenuBar(menu);\n        \n        this.contactListPanel.add(tabbedPane, BorderLayout.CENTER);\n        this.contactListPanel.add(callManager, BorderLayout.SOUTH);\n        \n        this.mainPanel.add(quickMenu, BorderLayout.NORTH);\n        this.mainPanel.add(contactListPanel, BorderLayout.CENTER);\n        this.mainPanel.add(statusPanel, BorderLayout.SOUTH);\n        \n        this.getContentPane().add(mainPanel);\n    }","commit_id":"e804392b3ed7298b1a9588e6cec1ad2b6f1c77a6","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes buttons order in the call tool bar.\n     */\n    private void initButtonIndexes()\n    {\n        dialButton.setIndex(0);\n        conferenceButton.setIndex(1);\n        holdButton.setIndex(2);\n        recordButton.setIndex(3);\n        mergeButton.setIndex(4);\n        transferCallButton.setIndex(5);\n\n        localLevel.setIndex(6);\n        if (remoteLevel instanceof OrderedComponent)\n            ((OrderedComponent) remoteLevel).setIndex(7);\n\n        desktopSharingButton.setIndex(8);\n        fullScreenButton.setIndex(10);\n        videoButton.setIndex(11);\n        showHideVideoButton.setIndex(12);\n        chatButton.setIndex(19);\n\n        if (infoButton != null)\n            infoButton.setIndex(20);\n\n        hangupButton.setIndex(100);\n    }","id":92177,"modified_method":"/**\n     * Initializes buttons order in the call tool bar.\n     */\n    private void initButtonIndexes()\n    {\n        dialButton.setIndex(0);\n        conferenceButton.setIndex(1);\n        holdButton.setIndex(2);\n        if (recordButton != null)\n            recordButton.setIndex(3);\n        mergeButton.setIndex(4);\n        transferCallButton.setIndex(5);\n\n        localLevel.setIndex(6);\n        if (remoteLevel instanceof OrderedComponent)\n            ((OrderedComponent) remoteLevel).setIndex(7);\n\n        desktopSharingButton.setIndex(8);\n        fullScreenButton.setIndex(10);\n        videoButton.setIndex(11);\n        showHideVideoButton.setIndex(12);\n        chatButton.setIndex(19);\n\n        if (infoButton != null)\n            infoButton.setIndex(20);\n\n        hangupButton.setIndex(100);\n    }","commit_id":"d58ed356459f8f913787fba206730d73109b5fbb","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Checks whether recording is currently enabled or not, state retrieved\n     * from call record button state.\n     *\n     * @return <tt>true<\/tt> if the recording is already started, <tt>false<\/tt>\n     * otherwise\n     */\n    public boolean isRecordingStarted()\n    {\n        return recordButton.isSelected();\n    }","id":92178,"modified_method":"/**\n     * Checks whether recording is currently enabled or not, state retrieved\n     * from call record button state.\n     *\n     * @return <tt>true<\/tt> if the recording is already started, <tt>false<\/tt>\n     * otherwise\n     */\n    public boolean isRecordingStarted()\n    {\n        if (recordButton == null)\n            return false;\n\n        return recordButton.isSelected();\n    }","commit_id":"d58ed356459f8f913787fba206730d73109b5fbb","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the user interface hierarchy of this <tt>CallPanel<\/tt> i.e.\n     * the AWT <tt>Component<\/tt>s which constitute the user interface to be\n     * displayed by this <tt>Component<\/tt>. Their state does not have to depict\n     * the current state of the model of this view because\n     * {@link #updateViewFromModel()} will be invoked before this view becomes\n     * visible. At the center of the user interface of this view is\n     * {@link #callPanel} but it is dynamically added and removed multiple times\n     * as part of the execution of the <tt>updateViewFromModel<\/tt> method so\n     * it is not dealt with here.\n     */\n    private void initializeUserInterfaceHierarchy()\n    {\n        /*\n         * The settingsPanel will contain the buttons. It is initialized before\n         * the buttons in case any of the buttons need it (which is hard to\n         * determine at the time of this writing).\n         */\n        settingsPanel = new CallToolBar(isFullScreen(), false);\n\n        /*\n         * TODO CallPanel depicts a whole CallConference which may have multiple\n         * Calls, new Calls may be added to the CallConference and existing\n         * Calls may be removed from the CallConference. For example, the\n         * buttons which accept a Call as an argument should be changed to take\n         * into account the whole CallConference.\n         */\n        Call aCall = this.callConference.getCalls().get(0);\n\n        chatButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.CHAT_BUTTON_SMALL_WHITE),\n                    CHAT_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.CHAT\"));\n        conferenceButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.ADD_TO_CALL_BUTTON),\n                    CONFERENCE_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.CREATE_CONFERENCE_CALL\"));\n        desktopSharingButton = new DesktopSharingButton(aCall);\n        dialButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.DIAL_BUTTON),\n                    DIAL_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.DIALPAD\"));\n        fullScreenButton = new FullScreenButton(this);\n        hangupButton = new HangupButton(this);\n        holdButton = new HoldButton(aCall);\n        if(GuiActivator.getConfigurationService().getBoolean(\n                SHOW_CALL_INFO_BUTON_PROP,\n                true))\n        {\n            infoButton\n                = new CallToolBarButton(\n                        ImageLoader.getImage(ImageLoader.CALL_INFO),\n                        INFO_BUTTON,\n                        GuiActivator.getResources().getI18NString(\n                                \"service.gui.PRESS_FOR_CALL_INFO\"));\n        }\n        mergeButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.MERGE_CALL_BUTTON),\n                    MERGE_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.MERGE_TO_CALL\"));\n        recordButton = new RecordButton(aCall);\n        showHideVideoButton = new ShowHideVideoButton(uiVideoHandler);\n        transferCallButton = new TransferCallButton(aCall);\n        videoButton = new LocalVideoButton(aCall);\n\n        localLevel\n            = new InputVolumeControlButton(\n                    aCall,\n                    ImageLoader.MICROPHONE,\n                    ImageLoader.MUTE_BUTTON,\n                    true,\n                    false);\n        remoteLevel\n            = new OutputVolumeControlButton(\n                    ImageLoader.VOLUME_CONTROL_BUTTON,\n                    false,\n                    true)\n                .getComponent();\n\n        /*\n         * Now that the buttons have been initialized, set their order indexes\n         * so that they get added in the correct order later on.\n         */\n        initButtonIndexes();\n\n        chatButton.addActionListener(this);\n        conferenceButton.addActionListener(this);\n        dialButton.addActionListener(this);\n        if (infoButton != null)\n            infoButton.addActionListener(this);\n        mergeButton.addActionListener(this);\n\n        settingsPanel.add(chatButton);\n        settingsPanel.add(conferenceButton);\n        settingsPanel.add(desktopSharingButton);\n        settingsPanel.add(dialButton);\n        settingsPanel.add(fullScreenButton);\n        settingsPanel.add(hangupButton);\n        settingsPanel.add(holdButton);\n        if (infoButton != null)\n            settingsPanel.add(infoButton);\n        settingsPanel.add(mergeButton);\n        settingsPanel.add(recordButton);\n        settingsPanel.add(showHideVideoButton);\n        settingsPanel.add(transferCallButton);\n        settingsPanel.add(videoButton);\n\n        // The bottom bar will contain the settingsPanel.\n        add(createBottomBar(), BorderLayout.SOUTH);\n    }","id":92179,"modified_method":"/**\n     * Initializes the user interface hierarchy of this <tt>CallPanel<\/tt> i.e.\n     * the AWT <tt>Component<\/tt>s which constitute the user interface to be\n     * displayed by this <tt>Component<\/tt>. Their state does not have to depict\n     * the current state of the model of this view because\n     * {@link #updateViewFromModel()} will be invoked before this view becomes\n     * visible. At the center of the user interface of this view is\n     * {@link #callPanel} but it is dynamically added and removed multiple times\n     * as part of the execution of the <tt>updateViewFromModel<\/tt> method so\n     * it is not dealt with here.\n     */\n    private void initializeUserInterfaceHierarchy()\n    {\n        /*\n         * The settingsPanel will contain the buttons. It is initialized before\n         * the buttons in case any of the buttons need it (which is hard to\n         * determine at the time of this writing).\n         */\n        settingsPanel = new CallToolBar(isFullScreen(), false);\n\n        /*\n         * TODO CallPanel depicts a whole CallConference which may have multiple\n         * Calls, new Calls may be added to the CallConference and existing\n         * Calls may be removed from the CallConference. For example, the\n         * buttons which accept a Call as an argument should be changed to take\n         * into account the whole CallConference.\n         */\n        Call aCall = this.callConference.getCalls().get(0);\n\n        chatButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.CHAT_BUTTON_SMALL_WHITE),\n                    CHAT_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.CHAT\"));\n        conferenceButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.ADD_TO_CALL_BUTTON),\n                    CONFERENCE_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.CREATE_CONFERENCE_CALL\"));\n        desktopSharingButton = new DesktopSharingButton(aCall);\n        dialButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.DIAL_BUTTON),\n                    DIAL_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.DIALPAD\"));\n        fullScreenButton = new FullScreenButton(this);\n        hangupButton = new HangupButton(this);\n        holdButton = new HoldButton(aCall);\n        if(GuiActivator.getConfigurationService().getBoolean(\n                SHOW_CALL_INFO_BUTON_PROP,\n                true))\n        {\n            infoButton\n                = new CallToolBarButton(\n                        ImageLoader.getImage(ImageLoader.CALL_INFO),\n                        INFO_BUTTON,\n                        GuiActivator.getResources().getI18NString(\n                                \"service.gui.PRESS_FOR_CALL_INFO\"));\n        }\n        mergeButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.MERGE_CALL_BUTTON),\n                    MERGE_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.MERGE_TO_CALL\"));\n\n        if(GuiActivator.getConfigurationService().getBoolean(\n            SHOW_CALL_RECORD_BUTON_PROP,\n            true))\n        {\n            recordButton = new RecordButton(aCall);\n        }\n        showHideVideoButton = new ShowHideVideoButton(uiVideoHandler);\n        transferCallButton = new TransferCallButton(aCall);\n        videoButton = new LocalVideoButton(aCall);\n\n        localLevel\n            = new InputVolumeControlButton(\n                    aCall,\n                    ImageLoader.MICROPHONE,\n                    ImageLoader.MUTE_BUTTON,\n                    true,\n                    false);\n        remoteLevel\n            = new OutputVolumeControlButton(\n                    ImageLoader.VOLUME_CONTROL_BUTTON,\n                    false,\n                    true)\n                .getComponent();\n\n        /*\n         * Now that the buttons have been initialized, set their order indexes\n         * so that they get added in the correct order later on.\n         */\n        initButtonIndexes();\n\n        chatButton.addActionListener(this);\n        conferenceButton.addActionListener(this);\n        dialButton.addActionListener(this);\n        if (infoButton != null)\n            infoButton.addActionListener(this);\n        mergeButton.addActionListener(this);\n\n        settingsPanel.add(chatButton);\n        settingsPanel.add(conferenceButton);\n        settingsPanel.add(desktopSharingButton);\n        settingsPanel.add(dialButton);\n        settingsPanel.add(fullScreenButton);\n        settingsPanel.add(hangupButton);\n        settingsPanel.add(holdButton);\n        if (infoButton != null)\n            settingsPanel.add(infoButton);\n        settingsPanel.add(mergeButton);\n        if (recordButton != null)\n            settingsPanel.add(recordButton);\n        settingsPanel.add(showHideVideoButton);\n        settingsPanel.add(transferCallButton);\n        settingsPanel.add(videoButton);\n\n        // The bottom bar will contain the settingsPanel.\n        add(createBottomBar(), BorderLayout.SOUTH);\n    }","commit_id":"d58ed356459f8f913787fba206730d73109b5fbb","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Updates {@link #settingsPanel} from the model of this view. The update is\n     * performed in the AWT event dispatching thread.\n     * <p>\n     * The center of this view is occupied by {@link #callPanel}, the bottom of\n     * this view is dedicated to <tt>settingsPanel<\/tt>. The method\n     * {@link #updateViewFromModelInEventDispatchThread()} updates\n     * <tt>callPanel<\/tt> from the model of this view and then invokes the\n     * method <tt>updateSettingsPanelInEventDispatchThread()<\/tt>. Thus this\n     * whole view is updated so that it depicts the current state of its model.\n     * <\/p>\n     *\n     * @param callConferenceIsEnded <tt>true<\/tt> if the method\n     * <tt>updateViewFromModelInEventDispatchThread()<\/tt> considers the\n     * {@link #callConference} ended; otherwise, <tt>false<\/tt>. When the\n     * <tt>callConference<\/tt> is considered ended, the <tt>callPanel<\/tt>\n     * instance will not be switched to a specific type (one-to-one, audio-only,\n     * or audio/video) because, otherwise, the switch will leave it\n     * <tt>null<\/tt> and this view will remain blank. In such a case,\n     * <tt>settingsPanel<\/tt> may wish to do pretty much the same but disable\n     * and/or hide the buttons it contains.\n     */\n    private void doUpdateSettingsPanelInEventDispatchThread(\n            boolean callConferenceIsEnded)\n    {\n        settingsPanel.setFullScreen(isFullScreen());\n\n        boolean isConference = (callPanel instanceof BasicConferenceCallPanel);\n\n        /*\n         * For whatever reason, we're treating the localLevel and the\n         * remoteLevel buttons differently and we're adding and removing them in\n         * accord with the conference state of the user interface.\n         */\n        if (isConference)\n        {\n            settingsPanel.add(localLevel);\n            settingsPanel.add(remoteLevel);\n        }\n        else\n        {\n            settingsPanel.remove(localLevel);\n            settingsPanel.remove(remoteLevel);\n        }\n\n        /*\n         * We do not support chat conferencing with the participants in a\n         * telephony conference at this time so we do not want the chatButton\n         * visible in such a scenario.\n         */\n        List<Contact> imContacts = getIMCapableCallPeers(1);\n        chatButton.setVisible(\n                !isConference && (imContacts.size() == 1));\n        if(chatButton.isVisible() && operationSetPresence == null)\n        {\n            Contact contact = imContacts.get(0);\n            operationSetPresence =\n                contact.getProtocolProvider()\n                    .getOperationSet(OperationSetPresence.class);\n            if(operationSetPresence != null)\n                operationSetPresence.addContactPresenceStatusListener(this);\n\n            chatButton.setIconImage(\n                Constants.getMessageStatusIcon(contact.getPresenceStatus()));\n            chatButton.repaint();\n        }\n\n        updateHoldButtonState();\n        updateMergeButtonState();\n\n        List<Call> calls = callConference.getCalls();\n        /*\n         * OperationSetAdvancedTelephony implements call transfer. The feature\n         * is not supported if the local user/peer is a conference focus.\n         * Instead of disabling the transferCallButton in this case though, we\n         * want it hidden.\n         */\n        boolean advancedTelephony = !calls.isEmpty();\n        boolean telephonyConferencing = false;\n        boolean videoTelephony = false;\n        boolean videoTelephonyIsLocalVideoAllowed = false;\n        boolean videoTelephonyIsLocalVideoStreaming = false;\n        boolean desktopSharing = false;\n        boolean desktopSharingIsStreamed = false;\n        boolean allCallsConnected = true;\n\n        for (Call call : calls)\n        {\n            ProtocolProviderService pps = call.getProtocolProvider();\n\n            /*\n             * The transferCallButton requires OperationSetAdvancedTelephony\n             * for all Calls.\n             */\n            if (advancedTelephony)\n            {\n                OperationSetAdvancedTelephony<?> osat\n                    = pps.getOperationSet(OperationSetAdvancedTelephony.class);\n\n                if (osat == null)\n                    advancedTelephony = false;\n            }\n\n            /*\n             * The conferenceButton needs at least one Call with\n             * OperationSetTelephonyConferencing,\n             */\n            if (!telephonyConferencing)\n            {\n                OperationSetTelephonyConferencing ostc\n                    = pps.getOperationSet(\n                            OperationSetTelephonyConferencing.class);\n\n                if (ostc != null)\n                    telephonyConferencing = true;\n            }\n\n            if (!videoTelephony\n                    || !videoTelephonyIsLocalVideoAllowed\n                    || !videoTelephonyIsLocalVideoStreaming)\n            {\n                OperationSetVideoTelephony osvt\n                    = pps.getOperationSet(OperationSetVideoTelephony.class);\n\n                if (osvt != null)\n                {\n                    if (!videoTelephony)\n                        videoTelephony = true;\n                    if (!videoTelephonyIsLocalVideoAllowed\n                            && osvt.isLocalVideoAllowed(call))\n                        videoTelephonyIsLocalVideoAllowed = true;\n                    if (!videoTelephonyIsLocalVideoStreaming\n                            && osvt.isLocalVideoStreaming(call))\n                        videoTelephonyIsLocalVideoStreaming = true;\n                }\n            }\n\n            if(!desktopSharing)\n            {\n                OperationSetDesktopStreaming osds\n                    = pps.getOperationSet(\n                            OperationSetDesktopStreaming.class);\n                if(osds != null)\n                {\n                    desktopSharing = true;\n\n                    if(videoTelephonyIsLocalVideoStreaming\n                            && call instanceof MediaAwareCall\n                            && ((MediaAwareCall<?,?,?>) call).getMediaUseCase()\n                                == MediaUseCase.DESKTOP)\n                    {\n                        desktopSharingIsStreamed = true;\n                    }\n                }\n            }\n\n            if (CallState.CALL_IN_PROGRESS != call.getCallState())\n            {\n                allCallsConnected = false;\n            }\n        }\n\n        if(conferenceButton != null)\n            conferenceButton.setEnabled(telephonyConferencing);\n\n        transferCallButton.setEnabled(advancedTelephony);\n        transferCallButton.setVisible(!callConference.isConferenceFocus());\n\n        /*\n         * The videoButton is a beast of its own kind because it depends not\n         * only on the state of the depicted telephony conference but also on\n         * the global application state.\n         */\n        videoButton.setEnabled(allCallsConnected && videoTelephony);\n        videoButton.setSelected(videoTelephonyIsLocalVideoAllowed);\n\n        /*\n         * Consequently, the showHideVideoButton which depends on videoButton\n         * has to be updated depending on the state of the videoButton as well.\n         */\n        showHideVideoButton.setEnabled(\n                videoButton.isEnabled()\n                    && videoTelephonyIsLocalVideoAllowed);\n        showHideVideoButton.setSelected(\n                showHideVideoButton.isEnabled()\n                    && uiVideoHandler.isLocalVideoVisible());\n        showHideVideoButton.setVisible(showHideVideoButton.isEnabled());\n\n        // The desktop sharing button depends on the operation set desktop\n        // sharing server.\n        desktopSharingButton.setEnabled(desktopSharing);\n        desktopSharingButton.setSelected(desktopSharingIsStreamed);\n        if (callPanel instanceof OneToOneCallPanel)\n        {\n            OneToOneCallPanel oneToOneCallPanel = (OneToOneCallPanel) callPanel;\n            if(desktopSharingIsStreamed)\n                oneToOneCallPanel.addDesktopSharingComponents();\n            else\n                oneToOneCallPanel.removeDesktopSharingComponents();\n        }\n    }","id":92180,"modified_method":"/**\n     * Updates {@link #settingsPanel} from the model of this view. The update is\n     * performed in the AWT event dispatching thread.\n     * <p>\n     * The center of this view is occupied by {@link #callPanel}, the bottom of\n     * this view is dedicated to <tt>settingsPanel<\/tt>. The method\n     * {@link #updateViewFromModelInEventDispatchThread()} updates\n     * <tt>callPanel<\/tt> from the model of this view and then invokes the\n     * method <tt>updateSettingsPanelInEventDispatchThread()<\/tt>. Thus this\n     * whole view is updated so that it depicts the current state of its model.\n     * <\/p>\n     *\n     * @param callConferenceIsEnded <tt>true<\/tt> if the method\n     * <tt>updateViewFromModelInEventDispatchThread()<\/tt> considers the\n     * {@link #callConference} ended; otherwise, <tt>false<\/tt>. When the\n     * <tt>callConference<\/tt> is considered ended, the <tt>callPanel<\/tt>\n     * instance will not be switched to a specific type (one-to-one, audio-only,\n     * or audio/video) because, otherwise, the switch will leave it\n     * <tt>null<\/tt> and this view will remain blank. In such a case,\n     * <tt>settingsPanel<\/tt> may wish to do pretty much the same but disable\n     * and/or hide the buttons it contains.\n     */\n    private void doUpdateSettingsPanelInEventDispatchThread(\n            boolean callConferenceIsEnded)\n    {\n        settingsPanel.setFullScreen(isFullScreen());\n\n        boolean isConference = (callPanel instanceof BasicConferenceCallPanel);\n\n        /*\n         * For whatever reason, we're treating the localLevel and the\n         * remoteLevel buttons differently and we're adding and removing them in\n         * accord with the conference state of the user interface.\n         */\n        if (isConference)\n        {\n            settingsPanel.add(localLevel);\n            settingsPanel.add(remoteLevel);\n        }\n        else\n        {\n            settingsPanel.remove(localLevel);\n            settingsPanel.remove(remoteLevel);\n        }\n\n        /*\n         * We do not support chat conferencing with the participants in a\n         * telephony conference at this time so we do not want the chatButton\n         * visible in such a scenario.\n         */\n        List<Contact> imContacts = getIMCapableCallPeers(1);\n        chatButton.setVisible(\n                !isConference && (imContacts.size() == 1));\n        if(chatButton.isVisible() && operationSetPresence == null)\n        {\n            Contact contact = imContacts.get(0);\n            operationSetPresence =\n                contact.getProtocolProvider()\n                    .getOperationSet(OperationSetPresence.class);\n            if(operationSetPresence != null)\n                operationSetPresence.addContactPresenceStatusListener(this);\n\n            chatButton.setIconImage(\n                Constants.getMessageStatusIcon(contact.getPresenceStatus()));\n            chatButton.repaint();\n        }\n\n        updateHoldButtonState();\n        updateMergeButtonState();\n\n        List<Call> calls = callConference.getCalls();\n        /*\n         * OperationSetAdvancedTelephony implements call transfer. The feature\n         * is not supported if the local user/peer is a conference focus.\n         * Instead of disabling the transferCallButton in this case though, we\n         * want it hidden.\n         */\n        boolean advancedTelephony = !calls.isEmpty();\n        boolean telephonyConferencing = false;\n        boolean videoTelephony = false;\n        boolean videoTelephonyIsLocalVideoAllowed = false;\n        boolean videoTelephonyIsLocalVideoStreaming = false;\n        boolean desktopSharing = false;\n        boolean desktopSharingIsStreamed = false;\n        boolean allCallsConnected = true;\n\n        for (Call call : calls)\n        {\n            ProtocolProviderService pps = call.getProtocolProvider();\n\n            /*\n             * The transferCallButton requires OperationSetAdvancedTelephony\n             * for all Calls.\n             */\n            if (advancedTelephony)\n            {\n                OperationSetAdvancedTelephony<?> osat\n                    = pps.getOperationSet(OperationSetAdvancedTelephony.class);\n\n                if (osat == null)\n                    advancedTelephony = false;\n            }\n\n            /*\n             * The conferenceButton needs at least one Call with\n             * OperationSetTelephonyConferencing,\n             */\n            if (!telephonyConferencing)\n            {\n                OperationSetTelephonyConferencing ostc\n                    = pps.getOperationSet(\n                            OperationSetTelephonyConferencing.class);\n\n                if (ostc != null)\n                    telephonyConferencing = true;\n            }\n\n            if (!videoTelephony\n                    || !videoTelephonyIsLocalVideoAllowed\n                    || !videoTelephonyIsLocalVideoStreaming)\n            {\n                OperationSetVideoTelephony osvt\n                    = pps.getOperationSet(OperationSetVideoTelephony.class);\n\n                if (osvt != null)\n                {\n                    if (!videoTelephony)\n                        videoTelephony = true;\n                    if (!videoTelephonyIsLocalVideoAllowed\n                            && osvt.isLocalVideoAllowed(call))\n                        videoTelephonyIsLocalVideoAllowed = true;\n                    if (!videoTelephonyIsLocalVideoStreaming\n                            && osvt.isLocalVideoStreaming(call))\n                        videoTelephonyIsLocalVideoStreaming = true;\n                }\n            }\n\n            if(!desktopSharing)\n            {\n                OperationSetDesktopStreaming osds\n                    = pps.getOperationSet(\n                            OperationSetDesktopStreaming.class);\n                if(osds != null)\n                {\n                    desktopSharing = true;\n\n                    if(videoTelephonyIsLocalVideoStreaming\n                            && call instanceof MediaAwareCall\n                            && ((MediaAwareCall<?,?,?>) call).getMediaUseCase()\n                                == MediaUseCase.DESKTOP)\n                    {\n                        desktopSharingIsStreamed = true;\n                    }\n                }\n            }\n\n            if (CallState.CALL_IN_PROGRESS != call.getCallState())\n            {\n                allCallsConnected = false;\n            }\n        }\n\n        if(conferenceButton != null)\n            conferenceButton.setEnabled(telephonyConferencing);\n\n        if(transferCallButton != null)\n        {\n            transferCallButton.setEnabled(advancedTelephony);\n            transferCallButton.setVisible(!callConference.isConferenceFocus());\n        }\n\n        /*\n         * The videoButton is a beast of its own kind because it depends not\n         * only on the state of the depicted telephony conference but also on\n         * the global application state.\n         */\n        videoButton.setEnabled(allCallsConnected && videoTelephony);\n        videoButton.setSelected(videoTelephonyIsLocalVideoAllowed);\n\n        /*\n         * Consequently, the showHideVideoButton which depends on videoButton\n         * has to be updated depending on the state of the videoButton as well.\n         */\n        showHideVideoButton.setEnabled(\n                videoButton.isEnabled()\n                    && videoTelephonyIsLocalVideoAllowed);\n        showHideVideoButton.setSelected(\n                showHideVideoButton.isEnabled()\n                    && uiVideoHandler.isLocalVideoVisible());\n        showHideVideoButton.setVisible(showHideVideoButton.isEnabled());\n\n        // The desktop sharing button depends on the operation set desktop\n        // sharing server.\n        desktopSharingButton.setEnabled(desktopSharing);\n        desktopSharingButton.setSelected(desktopSharingIsStreamed);\n        if (callPanel instanceof OneToOneCallPanel)\n        {\n            OneToOneCallPanel oneToOneCallPanel = (OneToOneCallPanel) callPanel;\n            if(desktopSharingIsStreamed)\n                oneToOneCallPanel.addDesktopSharingComponents();\n            else\n                oneToOneCallPanel.removeDesktopSharingComponents();\n        }\n    }","commit_id":"7f0c0810dba7004d36e26eca6c5a28188c01fc93","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Updates the state of the general hold button. The hold button is selected\n     * only if all call peers are locally or mutually on hold at the same time.\n     * In all other cases the hold button is unselected.\n     */\n    public void updateHoldButtonState()\n    {\n        if(!SwingUtilities.isEventDispatchThread())\n        {\n            SwingUtilities.invokeLater(new Runnable()\n            {\n                public void run()\n                {\n                    updateHoldButtonState();\n                }\n            });\n\n            return;\n        }\n\n        List<CallPeer> peers = callConference.getCallPeers();\n        boolean areAllPeersLocallyOnHold;\n\n        if (peers.isEmpty())\n        {\n            /*\n             * It feels natural to not have the holdButton selected when there\n             * are no peers.\n             */\n            areAllPeersLocallyOnHold = false;\n        }\n        else\n        {\n            areAllPeersLocallyOnHold = true;\n            for (CallPeer peer : callConference.getCallPeers())\n            {\n                CallPeerState state = peer.getState();\n\n                // If we have clicked the hold button in a full screen mode\n                // we need to update the state of the call dialog hold button.\n                if (!state.equals(CallPeerState.ON_HOLD_LOCALLY)\n                    && !state.equals(CallPeerState.ON_HOLD_MUTUALLY))\n                {\n                    areAllPeersLocallyOnHold = false;\n                    break;\n                }\n            }\n        }\n\n        // If we have clicked the hold button in a full screen mode or selected\n        // hold of the peer menu in a conference call we need to update the\n        // state of the call dialog hold button.\n        holdButton.setSelected(areAllPeersLocallyOnHold);\n    }","id":92181,"modified_method":"/**\n     * Updates the state of the general hold button. The hold button is selected\n     * only if all call peers are locally or mutually on hold at the same time.\n     * In all other cases the hold button is unselected.\n     */\n    public void updateHoldButtonState()\n    {\n        // If the hold button has been disabled by its configuration property we\n        // have nothing more to do here.\n        if (holdButton == null)\n            return;\n\n        if(!SwingUtilities.isEventDispatchThread())\n        {\n            SwingUtilities.invokeLater(new Runnable()\n            {\n                public void run()\n                {\n                    updateHoldButtonState();\n                }\n            });\n\n            return;\n        }\n\n        List<CallPeer> peers = callConference.getCallPeers();\n        boolean areAllPeersLocallyOnHold;\n\n        if (peers.isEmpty())\n        {\n            /*\n             * It feels natural to not have the holdButton selected when there\n             * are no peers.\n             */\n            areAllPeersLocallyOnHold = false;\n        }\n        else\n        {\n            areAllPeersLocallyOnHold = true;\n            for (CallPeer peer : callConference.getCallPeers())\n            {\n                CallPeerState state = peer.getState();\n\n                // If we have clicked the hold button in a full screen mode\n                // we need to update the state of the call dialog hold button.\n                if (!state.equals(CallPeerState.ON_HOLD_LOCALLY)\n                    && !state.equals(CallPeerState.ON_HOLD_MUTUALLY))\n                {\n                    areAllPeersLocallyOnHold = false;\n                    break;\n                }\n            }\n        }\n\n        // If we have clicked the hold button in a full screen mode or selected\n        // hold of the peer menu in a conference call we need to update the\n        // state of the call dialog hold button.\n        holdButton.setSelected(areAllPeersLocallyOnHold);\n    }","commit_id":"7f0c0810dba7004d36e26eca6c5a28188c01fc93","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Updates the <tt>visible<\/tt> state/property of {@link #mergeButton}.\n     */\n    private void updateMergeButtonState()\n    {\n        List<CallConference> conferences = new ArrayList<CallConference>();\n        int cpt = 0;\n\n        for (Call call : CallManager.getInProgressCalls())\n        {\n            CallConference conference = call.getConference();\n\n            if (conference == null)\n                cpt++;\n            else if (!conferences.contains(conference))\n            {\n                conferences.add(conference);\n                cpt++;\n            }\n            else\n                continue;\n\n            if (cpt > 1)\n                break;\n        }\n\n        mergeButton.setVisible(cpt > 1);\n    }","id":92182,"modified_method":"/**\n     * Updates the <tt>visible<\/tt> state/property of {@link #mergeButton} if\n     * the merge button is present.\n     */\n    private void updateMergeButtonState()\n    {\n        // If the merge button isn't present, for example if it's hidden by\n        // its configuration property we have nothing more to do here.\n        if (mergeButton == null)\n            return;\n\n        List<CallConference> conferences = new ArrayList<CallConference>();\n        int cpt = 0;\n\n        for (Call call : CallManager.getInProgressCalls())\n        {\n            CallConference conference = call.getConference();\n\n            if (conference == null)\n                cpt++;\n            else if (!conferences.contains(conference))\n            {\n                conferences.add(conference);\n                cpt++;\n            }\n            else\n                continue;\n\n            if (cpt > 1)\n                break;\n        }\n\n        mergeButton.setVisible(cpt > 1);\n    }","commit_id":"7f0c0810dba7004d36e26eca6c5a28188c01fc93","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Reloads icons.\n     */\n    public void loadSkin()\n    {\n        dialButton.setBackgroundImage(\n                ImageLoader.getImage(ImageLoader.CALL_SETTING_BUTTON_BG));\n        dialButton.setIconImage(\n                ImageLoader.getImage(ImageLoader.DIAL_BUTTON));\n\n        if (conferenceButton != null)\n        {\n            conferenceButton.setBackgroundImage(\n                ImageLoader.getImage(ImageLoader.CALL_SETTING_BUTTON_BG));\n            conferenceButton.setIconImage(\n                    ImageLoader.getImage(ImageLoader.ADD_TO_CALL_BUTTON));\n        }\n\n        if (hangupButton != null)\n            hangupButton.setBackgroundImage(\n                    ImageLoader.getImage(ImageLoader.HANGUP_BUTTON_BG));\n    }","id":92183,"modified_method":"/**\n     * Reloads icons.\n     */\n    public void loadSkin()\n    {\n        if (dialButton != null)\n        {\n            dialButton.setBackgroundImage(\n                ImageLoader.getImage(ImageLoader.CALL_SETTING_BUTTON_BG));\n            dialButton.setIconImage(\n                    ImageLoader.getImage(ImageLoader.DIAL_BUTTON));\n        }\n\n        if (conferenceButton != null)\n        {\n            conferenceButton.setBackgroundImage(\n                ImageLoader.getImage(ImageLoader.CALL_SETTING_BUTTON_BG));\n            conferenceButton.setIconImage(\n                    ImageLoader.getImage(ImageLoader.ADD_TO_CALL_BUTTON));\n        }\n\n        if (hangupButton != null)\n            hangupButton.setBackgroundImage(\n                    ImageLoader.getImage(ImageLoader.HANGUP_BUTTON_BG));\n    }","commit_id":"7f0c0810dba7004d36e26eca6c5a28188c01fc93","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes buttons order in the call tool bar.\n     */\n    private void initButtonIndexes()\n    {\n        dialButton.setIndex(0);\n        if (conferenceButton != null)\n            conferenceButton.setIndex(1);\n        holdButton.setIndex(2);\n        if (recordButton != null)\n            recordButton.setIndex(3);\n        mergeButton.setIndex(4);\n        transferCallButton.setIndex(5);\n\n        localLevel.setIndex(6);\n        if (remoteLevel instanceof OrderedComponent)\n            ((OrderedComponent) remoteLevel).setIndex(7);\n\n        desktopSharingButton.setIndex(8);\n        fullScreenButton.setIndex(10);\n        videoButton.setIndex(11);\n        showHideVideoButton.setIndex(12);\n        chatButton.setIndex(19);\n\n        if (infoButton != null)\n            infoButton.setIndex(20);\n\n        hangupButton.setIndex(100);\n    }","id":92184,"modified_method":"/**\n     * Initializes buttons order in the call tool bar.\n     */\n    private void initButtonIndexes()\n    {\n        if (dialButton != null)\n            dialButton.setIndex(0);\n        if (conferenceButton != null)\n            conferenceButton.setIndex(1);\n        if (holdButton != null)\n            holdButton.setIndex(2);\n        if (recordButton != null)\n            recordButton.setIndex(3);\n        if (mergeButton != null)\n            mergeButton.setIndex(4);\n        if (transferCallButton != null)\n            transferCallButton.setIndex(5);\n\n        localLevel.setIndex(6);\n        if (remoteLevel instanceof OrderedComponent)\n            ((OrderedComponent) remoteLevel).setIndex(7);\n\n        desktopSharingButton.setIndex(8);\n        fullScreenButton.setIndex(10);\n        videoButton.setIndex(11);\n        showHideVideoButton.setIndex(12);\n        chatButton.setIndex(19);\n\n        if (infoButton != null)\n            infoButton.setIndex(20);\n\n        hangupButton.setIndex(100);\n    }","commit_id":"7f0c0810dba7004d36e26eca6c5a28188c01fc93","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the user interface hierarchy of this <tt>CallPanel<\/tt> i.e.\n     * the AWT <tt>Component<\/tt>s which constitute the user interface to be\n     * displayed by this <tt>Component<\/tt>. Their state does not have to depict\n     * the current state of the model of this view because\n     * {@link #updateViewFromModel()} will be invoked before this view becomes\n     * visible. At the center of the user interface of this view is\n     * {@link #callPanel} but it is dynamically added and removed multiple times\n     * as part of the execution of the <tt>updateViewFromModel<\/tt> method so\n     * it is not dealt with here.\n     */\n    private void initializeUserInterfaceHierarchy()\n    {\n        /*\n         * The settingsPanel will contain the buttons. It is initialized before\n         * the buttons in case any of the buttons need it (which is hard to\n         * determine at the time of this writing).\n         */\n        settingsPanel = new CallToolBar(isFullScreen(), false);\n\n        /*\n         * TODO CallPanel depicts a whole CallConference which may have multiple\n         * Calls, new Calls may be added to the CallConference and existing\n         * Calls may be removed from the CallConference. For example, the\n         * buttons which accept a Call as an argument should be changed to take\n         * into account the whole CallConference.\n         */\n        Call aCall = callConference.getCalls().get(0);\n\n        chatButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.CHAT_BUTTON_SMALL_WHITE),\n                    CHAT_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.CHAT\"));\n\n        if(!GuiActivator.getConfigurationService().getBoolean(\n           HIDE_CONFERENCE_BUTON_PROP,\n           false))\n        {\n            conferenceButton\n                = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.ADD_TO_CALL_BUTTON),\n                    CONFERENCE_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.CREATE_CONFERENCE_CALL\"));\n        }\n\n        desktopSharingButton = new DesktopSharingButton(aCall);\n        dialButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.DIAL_BUTTON),\n                    DIAL_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.DIALPAD\"));\n        fullScreenButton = new FullScreenButton(this);\n        hangupButton = new HangupButton(this);\n        holdButton = new HoldButton(aCall);\n        if(!GuiActivator.getConfigurationService().getBoolean(\n                HIDE_CALL_INFO_BUTON_PROP,\n                false))\n        {\n            infoButton\n                = new CallToolBarButton(\n                        ImageLoader.getImage(ImageLoader.CALL_INFO),\n                        INFO_BUTTON,\n                        GuiActivator.getResources().getI18NString(\n                                \"service.gui.PRESS_FOR_CALL_INFO\"));\n        }\n        mergeButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.MERGE_CALL_BUTTON),\n                    MERGE_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.MERGE_TO_CALL\"));\n\n        if(!GuiActivator.getConfigurationService().getBoolean(\n            HIDE_CALL_RECORD_BUTON_PROP,\n            false))\n        {\n            recordButton = new RecordButton(aCall);\n        }\n        showHideVideoButton = new ShowHideVideoButton(uiVideoHandler);\n        transferCallButton = new TransferCallButton(aCall);\n        videoButton = new LocalVideoButton(aCall);\n\n        localLevel\n            = new InputVolumeControlButton(\n                    aCall,\n                    ImageLoader.MICROPHONE,\n                    ImageLoader.MUTE_BUTTON,\n                    true,\n                    false);\n        remoteLevel\n            = new OutputVolumeControlButton(\n                    callConference,\n                    ImageLoader.VOLUME_CONTROL_BUTTON,\n                    false,\n                    true)\n                .getComponent();\n\n        /*\n         * Now that the buttons have been initialized, set their order indexes\n         * so that they get added in the correct order later on.\n         */\n        initButtonIndexes();\n\n        chatButton.addActionListener(this);\n        if (conferenceButton != null)\n            conferenceButton.addActionListener(this);\n        dialButton.addActionListener(this);\n        if (infoButton != null)\n            infoButton.addActionListener(this);\n        mergeButton.addActionListener(this);\n\n        settingsPanel.add(chatButton);\n        if (conferenceButton != null)\n            settingsPanel.add(conferenceButton);\n        settingsPanel.add(desktopSharingButton);\n        settingsPanel.add(dialButton);\n        settingsPanel.add(fullScreenButton);\n        settingsPanel.add(hangupButton);\n        settingsPanel.add(holdButton);\n        if (infoButton != null)\n            settingsPanel.add(infoButton);\n        settingsPanel.add(mergeButton);\n        if (recordButton != null)\n            settingsPanel.add(recordButton);\n        settingsPanel.add(showHideVideoButton);\n        settingsPanel.add(transferCallButton);\n        settingsPanel.add(videoButton);\n\n        // The bottom bar will contain the settingsPanel.\n        add(createBottomBar(), BorderLayout.SOUTH);\n    }","id":92185,"modified_method":"/**\n     * Initializes the user interface hierarchy of this <tt>CallPanel<\/tt> i.e.\n     * the AWT <tt>Component<\/tt>s which constitute the user interface to be\n     * displayed by this <tt>Component<\/tt>. Their state does not have to depict\n     * the current state of the model of this view because\n     * {@link #updateViewFromModel()} will be invoked before this view becomes\n     * visible. At the center of the user interface of this view is\n     * {@link #callPanel} but it is dynamically added and removed multiple times\n     * as part of the execution of the <tt>updateViewFromModel<\/tt> method so\n     * it is not dealt with here.\n     */\n    private void initializeUserInterfaceHierarchy()\n    {\n        /*\n         * The settingsPanel will contain the buttons. It is initialized before\n         * the buttons in case any of the buttons need it (which is hard to\n         * determine at the time of this writing).\n         */\n        settingsPanel = new CallToolBar(isFullScreen(), false);\n\n        /*\n         * TODO CallPanel depicts a whole CallConference which may have multiple\n         * Calls, new Calls may be added to the CallConference and existing\n         * Calls may be removed from the CallConference. For example, the\n         * buttons which accept a Call as an argument should be changed to take\n         * into account the whole CallConference.\n         */\n        Call aCall = callConference.getCalls().get(0);\n\n        chatButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.CHAT_BUTTON_SMALL_WHITE),\n                    CHAT_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.CHAT\"));\n\n        if(!GuiActivator.getConfigurationService().getBoolean(\n           HIDE_CONFERENCE_BUTON_PROP,\n           false))\n        {\n            conferenceButton\n                = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.ADD_TO_CALL_BUTTON),\n                    CONFERENCE_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.CREATE_CONFERENCE_CALL\"));\n        }\n\n        desktopSharingButton = new DesktopSharingButton(aCall);\n        if(!GuiActivator.getConfigurationService().getBoolean(\n            HIDE_DIAL_BUTON_PROP,\n            false))\n        {\n            dialButton\n                = new CallToolBarButton(\n                        ImageLoader.getImage(ImageLoader.DIAL_BUTTON),\n                        DIAL_BUTTON,\n                        GuiActivator.getResources().getI18NString(\n                                \"service.gui.DIALPAD\"));\n        }\n\n        fullScreenButton = new FullScreenButton(this);\n        hangupButton = new HangupButton(this);\n        if(!GuiActivator.getConfigurationService().getBoolean(\n            HIDE_CALL_HOLD_BUTON_PROP,\n            false))\n        {\n            holdButton = new HoldButton(aCall);\n        }\n\n        if(!GuiActivator.getConfigurationService().getBoolean(\n                HIDE_CALL_INFO_BUTON_PROP,\n                false))\n        {\n            infoButton\n                = new CallToolBarButton(\n                        ImageLoader.getImage(ImageLoader.CALL_INFO),\n                        INFO_BUTTON,\n                        GuiActivator.getResources().getI18NString(\n                                \"service.gui.PRESS_FOR_CALL_INFO\"));\n        }\n        if(!GuiActivator.getConfigurationService().getBoolean(\n            HIDE_CALL_MERGE_BUTON_PROP,\n            false))\n        {\n            mergeButton\n                = new CallToolBarButton(\n                        ImageLoader.getImage(ImageLoader.MERGE_CALL_BUTTON),\n                        MERGE_BUTTON,\n                        GuiActivator.getResources().getI18NString(\n                                \"service.gui.MERGE_TO_CALL\"));\n\n        }\n\n        if(!GuiActivator.getConfigurationService().getBoolean(\n            HIDE_CALL_RECORD_BUTON_PROP,\n            false))\n        {\n            recordButton = new RecordButton(aCall);\n        }\n\n        showHideVideoButton = new ShowHideVideoButton(uiVideoHandler);\n\n        if(!GuiActivator.getConfigurationService().getBoolean(\n            HIDE_CALL_TRANSFER_BUTON_PROP,\n            false))\n        {\n            transferCallButton = new TransferCallButton(aCall);\n        }\n\n        videoButton = new LocalVideoButton(aCall);\n\n        localLevel\n            = new InputVolumeControlButton(\n                    aCall,\n                    ImageLoader.MICROPHONE,\n                    ImageLoader.MUTE_BUTTON,\n                    true,\n                    false);\n        remoteLevel\n            = new OutputVolumeControlButton(\n                    callConference,\n                    ImageLoader.VOLUME_CONTROL_BUTTON,\n                    false,\n                    true)\n                .getComponent();\n\n        /*\n         * Now that the buttons have been initialized, set their order indexes\n         * so that they get added in the correct order later on.\n         */\n        initButtonIndexes();\n\n        chatButton.addActionListener(this);\n        if (conferenceButton != null)\n            conferenceButton.addActionListener(this);\n        if (dialButton != null)\n            dialButton.addActionListener(this);\n        if (infoButton != null)\n            infoButton.addActionListener(this);\n        if (mergeButton != null)\n            mergeButton.addActionListener(this);\n\n        settingsPanel.add(chatButton);\n        if (conferenceButton != null)\n            settingsPanel.add(conferenceButton);\n        settingsPanel.add(desktopSharingButton);\n        if (dialButton != null)\n            settingsPanel.add(dialButton);\n        settingsPanel.add(fullScreenButton);\n        settingsPanel.add(hangupButton);\n        if (holdButton != null)\n            settingsPanel.add(holdButton);\n        if (infoButton != null)\n            settingsPanel.add(infoButton);\n        if (mergeButton != null)\n            settingsPanel.add(mergeButton);\n        if (recordButton != null)\n            settingsPanel.add(recordButton);\n        settingsPanel.add(showHideVideoButton);\n        if (mergeButton != null)\n            settingsPanel.add(transferCallButton);\n        settingsPanel.add(videoButton);\n\n        // The bottom bar will contain the settingsPanel.\n        add(createBottomBar(), BorderLayout.SOUTH);\n    }","commit_id":"7f0c0810dba7004d36e26eca6c5a28188c01fc93","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Updates {@link #settingsPanel} from the model of this view. The update is\n     * performed in the AWT event dispatching thread.\n     * <p>\n     * The center of this view is occupied by {@link #callPanel}, the bottom of\n     * this view is dedicated to <tt>settingsPanel<\/tt>. The method\n     * {@link #updateViewFromModelInEventDispatchThread()} updates\n     * <tt>callPanel<\/tt> from the model of this view and then invokes the\n     * method <tt>updateSettingsPanelInEventDispatchThread()<\/tt>. Thus this\n     * whole view is updated so that it depicts the current state of its model.\n     * <\/p>\n     *\n     * @param callConferenceIsEnded <tt>true<\/tt> if the method\n     * <tt>updateViewFromModelInEventDispatchThread()<\/tt> considers the\n     * {@link #callConference} ended; otherwise, <tt>false<\/tt>. When the\n     * <tt>callConference<\/tt> is considered ended, the <tt>callPanel<\/tt>\n     * instance will not be switched to a specific type (one-to-one, audio-only,\n     * or audio/video) because, otherwise, the switch will leave it\n     * <tt>null<\/tt> and this view will remain blank. In such a case,\n     * <tt>settingsPanel<\/tt> may wish to do pretty much the same but disable\n     * and/or hide the buttons it contains.\n     */\n    private void doUpdateSettingsPanelInEventDispatchThread(\n            boolean callConferenceIsEnded)\n    {\n        settingsPanel.setFullScreen(isFullScreen());\n\n        boolean isConference = (callPanel instanceof BasicConferenceCallPanel);\n\n        /*\n         * For whatever reason, we're treating the localLevel and the\n         * remoteLevel buttons differently and we're adding and removing them in\n         * accord with the conference state of the user interface.\n         */\n        if (isConference)\n        {\n            settingsPanel.add(localLevel);\n            settingsPanel.add(remoteLevel);\n        }\n        else\n        {\n            settingsPanel.remove(localLevel);\n            settingsPanel.remove(remoteLevel);\n        }\n\n        /*\n         * We do not support chat conferencing with the participants in a\n         * telephony conference at this time so we do not want the chatButton\n         * visible in such a scenario.\n         */\n        List<Contact> imContacts = getIMCapableCallPeers(1);\n        chatButton.setVisible(\n                !isConference && (imContacts.size() == 1));\n        if(chatButton.isVisible() && operationSetPresence == null)\n        {\n            Contact contact = imContacts.get(0);\n            operationSetPresence =\n                contact.getProtocolProvider()\n                    .getOperationSet(OperationSetPresence.class);\n            if(operationSetPresence != null)\n                operationSetPresence.addContactPresenceStatusListener(this);\n\n            chatButton.setIconImage(\n                Constants.getMessageStatusIcon(contact.getPresenceStatus()));\n            chatButton.repaint();\n        }\n\n        updateHoldButtonState();\n        updateMergeButtonState();\n\n        List<Call> calls = callConference.getCalls();\n        /*\n         * OperationSetAdvancedTelephony implements call transfer. The feature\n         * is not supported if the local user/peer is a conference focus.\n         * Instead of disabling the transferCallButton in this case though, we\n         * want it hidden.\n         */\n        boolean advancedTelephony = !calls.isEmpty();\n        boolean telephonyConferencing = false;\n        boolean videoTelephony = false;\n        boolean videoTelephonyIsLocalVideoAllowed = false;\n        boolean videoTelephonyIsLocalVideoStreaming = false;\n        boolean desktopSharing = false;\n        boolean desktopSharingIsStreamed = false;\n        boolean allCallsConnected = true;\n\n        for (Call call : calls)\n        {\n            ProtocolProviderService pps = call.getProtocolProvider();\n\n            /*\n             * The transferCallButton requires OperationSetAdvancedTelephony\n             * for all Calls.\n             */\n            if (advancedTelephony)\n            {\n                OperationSetAdvancedTelephony<?> osat\n                    = pps.getOperationSet(OperationSetAdvancedTelephony.class);\n\n                if (osat == null)\n                    advancedTelephony = false;\n            }\n\n            /*\n             * The conferenceButton needs at least one Call with\n             * OperationSetTelephonyConferencing,\n             */\n            if (!telephonyConferencing)\n            {\n                OperationSetTelephonyConferencing ostc\n                    = pps.getOperationSet(\n                            OperationSetTelephonyConferencing.class);\n\n                if (ostc != null)\n                    telephonyConferencing = true;\n            }\n\n            if (!videoTelephony\n                    || !videoTelephonyIsLocalVideoAllowed\n                    || !videoTelephonyIsLocalVideoStreaming)\n            {\n                OperationSetVideoTelephony osvt\n                    = pps.getOperationSet(OperationSetVideoTelephony.class);\n\n                if (osvt != null)\n                {\n                    if (!videoTelephony)\n                        videoTelephony = true;\n                    if (!videoTelephonyIsLocalVideoAllowed\n                            && osvt.isLocalVideoAllowed(call))\n                        videoTelephonyIsLocalVideoAllowed = true;\n                    if (!videoTelephonyIsLocalVideoStreaming\n                            && osvt.isLocalVideoStreaming(call))\n                        videoTelephonyIsLocalVideoStreaming = true;\n                }\n            }\n\n            if(!desktopSharing)\n            {\n                OperationSetDesktopStreaming osds\n                    = pps.getOperationSet(\n                            OperationSetDesktopStreaming.class);\n                if(osds != null)\n                {\n                    desktopSharing = true;\n\n                    if(videoTelephonyIsLocalVideoStreaming\n                            && call instanceof MediaAwareCall\n                            && ((MediaAwareCall<?,?,?>) call).getMediaUseCase()\n                                == MediaUseCase.DESKTOP)\n                    {\n                        desktopSharingIsStreamed = true;\n                    }\n                }\n            }\n\n            if (CallState.CALL_IN_PROGRESS != call.getCallState())\n            {\n                allCallsConnected = false;\n            }\n        }\n\n        if(conferenceButton != null)\n            conferenceButton.setEnabled(telephonyConferencing);\n\n        if(transferCallButton != null)\n        {\n            transferCallButton.setEnabled(advancedTelephony);\n            transferCallButton.setVisible(!callConference.isConferenceFocus());\n        }\n\n        /*\n         * The videoButton is a beast of its own kind because it depends not\n         * only on the state of the depicted telephony conference but also on\n         * the global application state.\n         */\n        videoButton.setEnabled(allCallsConnected && videoTelephony);\n        videoButton.setSelected(videoTelephonyIsLocalVideoAllowed);\n\n        /*\n         * Consequently, the showHideVideoButton which depends on videoButton\n         * has to be updated depending on the state of the videoButton as well.\n         */\n        showHideVideoButton.setEnabled(\n                videoButton.isEnabled()\n                    && videoTelephonyIsLocalVideoAllowed);\n        showHideVideoButton.setSelected(\n                showHideVideoButton.isEnabled()\n                    && uiVideoHandler.isLocalVideoVisible());\n        showHideVideoButton.setVisible(showHideVideoButton.isEnabled());\n\n        // The desktop sharing button depends on the operation set desktop\n        // sharing server.\n        desktopSharingButton.setEnabled(desktopSharing);\n        desktopSharingButton.setSelected(desktopSharingIsStreamed);\n        if (callPanel instanceof OneToOneCallPanel)\n        {\n            OneToOneCallPanel oneToOneCallPanel = (OneToOneCallPanel) callPanel;\n            if(desktopSharingIsStreamed)\n                oneToOneCallPanel.addDesktopSharingComponents();\n            else\n                oneToOneCallPanel.removeDesktopSharingComponents();\n        }\n    }","id":92186,"modified_method":"/**\n     * Updates {@link #settingsPanel} from the model of this view. The update is\n     * performed in the AWT event dispatching thread.\n     * <p>\n     * The center of this view is occupied by {@link #callPanel}, the bottom of\n     * this view is dedicated to <tt>settingsPanel<\/tt>. The method\n     * {@link #updateViewFromModelInEventDispatchThread()} updates\n     * <tt>callPanel<\/tt> from the model of this view and then invokes the\n     * method <tt>updateSettingsPanelInEventDispatchThread()<\/tt>. Thus this\n     * whole view is updated so that it depicts the current state of its model.\n     * <\/p>\n     *\n     * @param callConferenceIsEnded <tt>true<\/tt> if the method\n     * <tt>updateViewFromModelInEventDispatchThread()<\/tt> considers the\n     * {@link #callConference} ended; otherwise, <tt>false<\/tt>. When the\n     * <tt>callConference<\/tt> is considered ended, the <tt>callPanel<\/tt>\n     * instance will not be switched to a specific type (one-to-one, audio-only,\n     * or audio/video) because, otherwise, the switch will leave it\n     * <tt>null<\/tt> and this view will remain blank. In such a case,\n     * <tt>settingsPanel<\/tt> may wish to do pretty much the same but disable\n     * and/or hide the buttons it contains.\n     */\n    private void doUpdateSettingsPanelInEventDispatchThread(\n            boolean callConferenceIsEnded)\n    {\n        settingsPanel.setFullScreen(isFullScreen());\n\n        boolean isConference = (callPanel instanceof BasicConferenceCallPanel);\n\n        /*\n         * For whatever reason, we're treating the localLevel and the\n         * remoteLevel buttons differently and we're adding and removing them in\n         * accord with the conference state of the user interface.\n         */\n        if (isConference)\n        {\n            settingsPanel.add(localLevel);\n            settingsPanel.add(remoteLevel);\n        }\n        else\n        {\n            settingsPanel.remove(localLevel);\n            settingsPanel.remove(remoteLevel);\n        }\n\n        /*\n         * We do not support chat conferencing with the participants in a\n         * telephony conference at this time so we do not want the chatButton\n         * visible in such a scenario.\n         */\n        List<Contact> imContacts = getIMCapableCallPeers(1);\n        chatButton.setVisible(\n                !isConference && (imContacts.size() == 1));\n        if(chatButton.isVisible() && operationSetPresence == null)\n        {\n            Contact contact = imContacts.get(0);\n            operationSetPresence =\n                contact.getProtocolProvider()\n                    .getOperationSet(OperationSetPresence.class);\n            if(operationSetPresence != null)\n                operationSetPresence.addContactPresenceStatusListener(this);\n\n            chatButton.setIconImage(\n                Constants.getMessageStatusIcon(contact.getPresenceStatus()));\n            chatButton.repaint();\n        }\n\n        updateHoldButtonState();\n        updateMergeButtonState();\n\n        List<Call> calls = callConference.getCalls();\n        /*\n         * OperationSetAdvancedTelephony implements call transfer. The feature\n         * is not supported if the local user/peer is a conference focus.\n         * Instead of disabling the transferCallButton in this case though, we\n         * want it hidden.\n         */\n        boolean advancedTelephony = !calls.isEmpty();\n        boolean telephonyConferencing = false;\n        boolean videoTelephony = false;\n        boolean videoTelephonyIsLocalVideoAllowed = false;\n        boolean videoTelephonyIsLocalVideoStreaming = false;\n        boolean desktopSharing = false;\n        boolean desktopSharingIsStreamed = false;\n        boolean allCallsConnected = true;\n\n        for (Call call : calls)\n        {\n            ProtocolProviderService pps = call.getProtocolProvider();\n\n            /*\n             * The transferCallButton requires OperationSetAdvancedTelephony\n             * for all Calls.\n             */\n            if (advancedTelephony)\n            {\n                OperationSetAdvancedTelephony<?> osat\n                    = pps.getOperationSet(OperationSetAdvancedTelephony.class);\n\n                if (osat == null)\n                    advancedTelephony = false;\n            }\n\n            /*\n             * The conferenceButton needs at least one Call with\n             * OperationSetTelephonyConferencing,\n             */\n            if (!telephonyConferencing)\n            {\n                OperationSetTelephonyConferencing ostc\n                    = pps.getOperationSet(\n                            OperationSetTelephonyConferencing.class);\n\n                if (ostc != null)\n                    telephonyConferencing = true;\n            }\n\n            if (!videoTelephony\n                    || !videoTelephonyIsLocalVideoAllowed\n                    || !videoTelephonyIsLocalVideoStreaming)\n            {\n                OperationSetVideoTelephony osvt\n                    = pps.getOperationSet(OperationSetVideoTelephony.class);\n\n                if (osvt != null)\n                {\n                    if (!videoTelephony)\n                        videoTelephony = true;\n                    if (!videoTelephonyIsLocalVideoAllowed\n                            && osvt.isLocalVideoAllowed(call))\n                        videoTelephonyIsLocalVideoAllowed = true;\n                    if (!videoTelephonyIsLocalVideoStreaming\n                            && osvt.isLocalVideoStreaming(call))\n                        videoTelephonyIsLocalVideoStreaming = true;\n                }\n            }\n\n            if(!desktopSharing)\n            {\n                OperationSetDesktopStreaming osds\n                    = pps.getOperationSet(\n                            OperationSetDesktopStreaming.class);\n                if(osds != null)\n                {\n                    desktopSharing = true;\n\n                    if(videoTelephonyIsLocalVideoStreaming\n                            && call instanceof MediaAwareCall\n                            && ((MediaAwareCall<?,?,?>) call).getMediaUseCase()\n                                == MediaUseCase.DESKTOP)\n                    {\n                        desktopSharingIsStreamed = true;\n                    }\n                }\n            }\n\n            if (CallState.CALL_IN_PROGRESS != call.getCallState())\n            {\n                allCallsConnected = false;\n            }\n        }\n\n        if(conferenceButton != null)\n            conferenceButton.setEnabled(telephonyConferencing);\n\n        if(transferCallButton != null)\n        {\n            transferCallButton.setEnabled(advancedTelephony);\n            transferCallButton.setVisible(!callConference.isConferenceFocus());\n        }\n\n        /*\n         * The videoButton is a beast of its own kind because it depends not\n         * only on the state of the depicted telephony conference but also on\n         * the global application state.\n         */\n        if(videoButton != null)\n        {\n            videoButton.setEnabled(allCallsConnected && videoTelephony);\n            videoButton.setSelected(videoTelephonyIsLocalVideoAllowed);\n\n            /*\n             * Consequently, the showHideVideoButton which depends on videoButton\n             * has to be updated depending on the state of the videoButton as well.\n             */\n            if(showHideVideoButton != null)\n            {\n                showHideVideoButton.setEnabled(\n                        videoButton.isEnabled()\n                            && videoTelephonyIsLocalVideoAllowed);\n                showHideVideoButton.setSelected(\n                        showHideVideoButton.isEnabled()\n                            && uiVideoHandler.isLocalVideoVisible());\n                showHideVideoButton.setVisible(showHideVideoButton.isEnabled());\n            }\n        }\n\n        // The desktop sharing button depends on the operation set desktop\n        // sharing server.\n        if(desktopSharingButton != null)\n        {\n            desktopSharingButton.setEnabled(desktopSharing);\n            desktopSharingButton.setSelected(desktopSharingIsStreamed);\n        }\n\n        if (callPanel instanceof OneToOneCallPanel)\n        {\n            OneToOneCallPanel oneToOneCallPanel = (OneToOneCallPanel) callPanel;\n            if(desktopSharingIsStreamed)\n                oneToOneCallPanel.addDesktopSharingComponents();\n            else\n                oneToOneCallPanel.removeDesktopSharingComponents();\n        }\n    }","commit_id":"9b94292e57b32c026576eb83c39d298d3143596d","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the user interface hierarchy of this <tt>CallPanel<\/tt> i.e.\n     * the AWT <tt>Component<\/tt>s which constitute the user interface to be\n     * displayed by this <tt>Component<\/tt>. Their state does not have to depict\n     * the current state of the model of this view because\n     * {@link #updateViewFromModel()} will be invoked before this view becomes\n     * visible. At the center of the user interface of this view is\n     * {@link #callPanel} but it is dynamically added and removed multiple times\n     * as part of the execution of the <tt>updateViewFromModel<\/tt> method so\n     * it is not dealt with here.\n     */\n    private void initializeUserInterfaceHierarchy()\n    {\n        /*\n         * The settingsPanel will contain the buttons. It is initialized before\n         * the buttons in case any of the buttons need it (which is hard to\n         * determine at the time of this writing).\n         */\n        settingsPanel = new CallToolBar(isFullScreen(), false);\n\n        /*\n         * TODO CallPanel depicts a whole CallConference which may have multiple\n         * Calls, new Calls may be added to the CallConference and existing\n         * Calls may be removed from the CallConference. For example, the\n         * buttons which accept a Call as an argument should be changed to take\n         * into account the whole CallConference.\n         */\n        Call aCall = callConference.getCalls().get(0);\n\n        chatButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.CHAT_BUTTON_SMALL_WHITE),\n                    CHAT_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.CHAT\"));\n\n        if(!GuiActivator.getConfigurationService().getBoolean(\n           HIDE_CONFERENCE_BUTON_PROP,\n           false))\n        {\n            conferenceButton\n                = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.ADD_TO_CALL_BUTTON),\n                    CONFERENCE_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.CREATE_CONFERENCE_CALL\"));\n        }\n\n        desktopSharingButton = new DesktopSharingButton(aCall);\n        if(!GuiActivator.getConfigurationService().getBoolean(\n            HIDE_DIAL_BUTON_PROP,\n            false))\n        {\n            dialButton\n                = new CallToolBarButton(\n                        ImageLoader.getImage(ImageLoader.DIAL_BUTTON),\n                        DIAL_BUTTON,\n                        GuiActivator.getResources().getI18NString(\n                                \"service.gui.DIALPAD\"));\n        }\n\n        fullScreenButton = new FullScreenButton(this);\n        hangupButton = new HangupButton(this);\n        if(!GuiActivator.getConfigurationService().getBoolean(\n            HIDE_CALL_HOLD_BUTON_PROP,\n            false))\n        {\n            holdButton = new HoldButton(aCall);\n        }\n\n        if(!GuiActivator.getConfigurationService().getBoolean(\n                HIDE_CALL_INFO_BUTON_PROP,\n                false))\n        {\n            infoButton\n                = new CallToolBarButton(\n                        ImageLoader.getImage(ImageLoader.CALL_INFO),\n                        INFO_BUTTON,\n                        GuiActivator.getResources().getI18NString(\n                                \"service.gui.PRESS_FOR_CALL_INFO\"));\n        }\n        if(!GuiActivator.getConfigurationService().getBoolean(\n            HIDE_CALL_MERGE_BUTON_PROP,\n            false))\n        {\n            mergeButton\n                = new CallToolBarButton(\n                        ImageLoader.getImage(ImageLoader.MERGE_CALL_BUTTON),\n                        MERGE_BUTTON,\n                        GuiActivator.getResources().getI18NString(\n                                \"service.gui.MERGE_TO_CALL\"));\n\n        }\n\n        if(!GuiActivator.getConfigurationService().getBoolean(\n            HIDE_CALL_RECORD_BUTON_PROP,\n            false))\n        {\n            recordButton = new RecordButton(aCall);\n        }\n\n        showHideVideoButton = new ShowHideVideoButton(uiVideoHandler);\n\n        if(!GuiActivator.getConfigurationService().getBoolean(\n            HIDE_CALL_TRANSFER_BUTON_PROP,\n            false))\n        {\n            transferCallButton = new TransferCallButton(aCall);\n        }\n\n        videoButton = new LocalVideoButton(aCall);\n\n        localLevel\n            = new InputVolumeControlButton(\n                    aCall,\n                    ImageLoader.MICROPHONE,\n                    ImageLoader.MUTE_BUTTON,\n                    true,\n                    false);\n        remoteLevel\n            = new OutputVolumeControlButton(\n                    callConference,\n                    ImageLoader.VOLUME_CONTROL_BUTTON,\n                    false,\n                    true)\n                .getComponent();\n\n        /*\n         * Now that the buttons have been initialized, set their order indexes\n         * so that they get added in the correct order later on.\n         */\n        initButtonIndexes();\n\n        chatButton.addActionListener(this);\n        if (conferenceButton != null)\n            conferenceButton.addActionListener(this);\n        if (dialButton != null)\n            dialButton.addActionListener(this);\n        if (infoButton != null)\n            infoButton.addActionListener(this);\n        if (mergeButton != null)\n            mergeButton.addActionListener(this);\n\n        settingsPanel.add(chatButton);\n        if (conferenceButton != null)\n            settingsPanel.add(conferenceButton);\n        settingsPanel.add(desktopSharingButton);\n        if (dialButton != null)\n            settingsPanel.add(dialButton);\n        settingsPanel.add(fullScreenButton);\n        settingsPanel.add(hangupButton);\n        if (holdButton != null)\n            settingsPanel.add(holdButton);\n        if (infoButton != null)\n            settingsPanel.add(infoButton);\n        if (mergeButton != null)\n            settingsPanel.add(mergeButton);\n        if (recordButton != null)\n            settingsPanel.add(recordButton);\n        settingsPanel.add(showHideVideoButton);\n        if (mergeButton != null)\n            settingsPanel.add(transferCallButton);\n        settingsPanel.add(videoButton);\n\n        // The bottom bar will contain the settingsPanel.\n        add(createBottomBar(), BorderLayout.SOUTH);\n    }","id":92187,"modified_method":"/**\n     * Initializes the user interface hierarchy of this <tt>CallPanel<\/tt> i.e.\n     * the AWT <tt>Component<\/tt>s which constitute the user interface to be\n     * displayed by this <tt>Component<\/tt>. Their state does not have to depict\n     * the current state of the model of this view because\n     * {@link #updateViewFromModel()} will be invoked before this view becomes\n     * visible. At the center of the user interface of this view is\n     * {@link #callPanel} but it is dynamically added and removed multiple times\n     * as part of the execution of the <tt>updateViewFromModel<\/tt> method so\n     * it is not dealt with here.\n     */\n    private void initializeUserInterfaceHierarchy()\n    {\n        /*\n         * The settingsPanel will contain the buttons. It is initialized before\n         * the buttons in case any of the buttons need it (which is hard to\n         * determine at the time of this writing).\n         */\n        settingsPanel = new CallToolBar(isFullScreen(), false);\n\n        /*\n         * TODO CallPanel depicts a whole CallConference which may have multiple\n         * Calls, new Calls may be added to the CallConference and existing\n         * Calls may be removed from the CallConference. For example, the\n         * buttons which accept a Call as an argument should be changed to take\n         * into account the whole CallConference.\n         */\n        Call aCall = callConference.getCalls().get(0);\n\n        chatButton\n            = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.CHAT_BUTTON_SMALL_WHITE),\n                    CHAT_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                            \"service.gui.CHAT\"));\n\n        if(isButtonEnabled(HIDE_CONFERENCE_BUTON_PROP))\n        {\n            conferenceButton\n                = new CallToolBarButton(\n                    ImageLoader.getImage(ImageLoader.ADD_TO_CALL_BUTTON),\n                    CONFERENCE_BUTTON,\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.CREATE_CONFERENCE_CALL\"));\n        }\n\n        if(isButtonEnabled(HIDE_DESKTOP_SHARING_BUTON_PROP))\n        {\n            desktopSharingButton = new DesktopSharingButton(aCall);\n        }\n\n        if(isButtonEnabled(HIDE_DIAL_BUTON_PROP))\n        {\n            dialButton\n                = new CallToolBarButton(\n                        ImageLoader.getImage(ImageLoader.DIAL_BUTTON),\n                        DIAL_BUTTON,\n                        GuiActivator.getResources().getI18NString(\n                                \"service.gui.DIALPAD\"));\n        }\n\n        if(isButtonEnabled(HIDE_FULL_SCREEN_BUTON_PROP))\n        {\n            fullScreenButton = new FullScreenButton(this);\n        }\n\n        hangupButton = new HangupButton(this);\n\n        if(isButtonEnabled(HIDE_CALL_HOLD_BUTON_PROP))\n        {\n            holdButton = new HoldButton(aCall);\n        }\n\n        if(isButtonEnabled(HIDE_CALL_INFO_BUTON_PROP))\n        {\n            infoButton\n                = new CallToolBarButton(\n                        ImageLoader.getImage(ImageLoader.CALL_INFO),\n                        INFO_BUTTON,\n                        GuiActivator.getResources().getI18NString(\n                                \"service.gui.PRESS_FOR_CALL_INFO\"));\n        }\n\n        if(isButtonEnabled(HIDE_CALL_MERGE_BUTON_PROP))\n        {\n            mergeButton\n                = new CallToolBarButton(\n                        ImageLoader.getImage(ImageLoader.MERGE_CALL_BUTTON),\n                        MERGE_BUTTON,\n                        GuiActivator.getResources().getI18NString(\n                                \"service.gui.MERGE_TO_CALL\"));\n\n        }\n\n        if(isButtonEnabled(HIDE_CALL_RECORD_BUTON_PROP))\n        {\n            recordButton = new RecordButton(aCall);\n        }\n\n        if(isButtonEnabled(HIDE_TOGGLE_VIDEO_BUTON_PROP))\n        {\n            showHideVideoButton = new ShowHideVideoButton(uiVideoHandler);\n        }\n\n        if(isButtonEnabled(HIDE_CALL_TRANSFER_BUTON_PROP))\n        {\n            transferCallButton = new TransferCallButton(aCall);\n        }\n\n        if(isButtonEnabled(HIDE_VIDEO_BUTON_PROP))\n        {\n            videoButton = new LocalVideoButton(aCall);\n        }\n\n        localLevel\n            = new InputVolumeControlButton(\n                    aCall,\n                    ImageLoader.MICROPHONE,\n                    ImageLoader.MUTE_BUTTON,\n                    true,\n                    false);\n        remoteLevel\n            = new OutputVolumeControlButton(\n                    callConference,\n                    ImageLoader.VOLUME_CONTROL_BUTTON,\n                    false,\n                    true)\n                .getComponent();\n\n        /*\n         * Now that the buttons have been initialized, set their order indexes\n         * so that they get added in the correct order later on.\n         */\n        initButtonIndexes();\n\n        chatButton.addActionListener(this);\n        if (conferenceButton != null)\n            conferenceButton.addActionListener(this);\n        if (dialButton != null)\n            dialButton.addActionListener(this);\n        if (infoButton != null)\n            infoButton.addActionListener(this);\n        if (mergeButton != null)\n            mergeButton.addActionListener(this);\n\n        settingsPanel.add(chatButton);\n        if (conferenceButton != null)\n            settingsPanel.add(conferenceButton);\n        if (desktopSharingButton != null)\n            settingsPanel.add(desktopSharingButton);\n        if (dialButton != null)\n            settingsPanel.add(dialButton);\n        if (fullScreenButton != null)\n            settingsPanel.add(fullScreenButton);\n\n        settingsPanel.add(hangupButton);\n\n        if (holdButton != null)\n            settingsPanel.add(holdButton);\n        if (infoButton != null)\n            settingsPanel.add(infoButton);\n        if (mergeButton != null)\n            settingsPanel.add(mergeButton);\n        if (recordButton != null)\n            settingsPanel.add(recordButton);\n        if (showHideVideoButton != null)\n            settingsPanel.add(showHideVideoButton);\n        if (mergeButton != null)\n            settingsPanel.add(transferCallButton);\n        if (videoButton != null)\n            settingsPanel.add(videoButton);\n\n        // The bottom bar will contain the settingsPanel.\n        add(createBottomBar(), BorderLayout.SOUTH);\n    }","commit_id":"9b94292e57b32c026576eb83c39d298d3143596d","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes buttons order in the call tool bar.\n     */\n    private void initButtonIndexes()\n    {\n        if (dialButton != null)\n            dialButton.setIndex(0);\n        if (conferenceButton != null)\n            conferenceButton.setIndex(1);\n        if (holdButton != null)\n            holdButton.setIndex(2);\n        if (recordButton != null)\n            recordButton.setIndex(3);\n        if (mergeButton != null)\n            mergeButton.setIndex(4);\n        if (transferCallButton != null)\n            transferCallButton.setIndex(5);\n\n        localLevel.setIndex(6);\n        if (remoteLevel instanceof OrderedComponent)\n            ((OrderedComponent) remoteLevel).setIndex(7);\n\n        desktopSharingButton.setIndex(8);\n        fullScreenButton.setIndex(10);\n        videoButton.setIndex(11);\n        showHideVideoButton.setIndex(12);\n        chatButton.setIndex(19);\n\n        if (infoButton != null)\n            infoButton.setIndex(20);\n\n        hangupButton.setIndex(100);\n    }","id":92188,"modified_method":"/**\n     * Initializes buttons order in the call tool bar.\n     */\n    private void initButtonIndexes()\n    {\n        if (dialButton != null)\n            dialButton.setIndex(0);\n        if (conferenceButton != null)\n            conferenceButton.setIndex(1);\n        if (holdButton != null)\n            holdButton.setIndex(2);\n        if (recordButton != null)\n            recordButton.setIndex(3);\n        if (mergeButton != null)\n            mergeButton.setIndex(4);\n        if (transferCallButton != null)\n            transferCallButton.setIndex(5);\n\n        localLevel.setIndex(6);\n        if (remoteLevel instanceof OrderedComponent)\n            ((OrderedComponent) remoteLevel).setIndex(7);\n\n        if (desktopSharingButton != null)\n            desktopSharingButton.setIndex(8);\n\n        if (fullScreenButton != null)\n            fullScreenButton.setIndex(10);\n\n        if (videoButton != null)\n            videoButton.setIndex(11);\n        if (showHideVideoButton != null)\n            showHideVideoButton.setIndex(12);\n        chatButton.setIndex(19);\n\n        if (infoButton != null)\n            infoButton.setIndex(20);\n\n        hangupButton.setIndex(100);\n    }","commit_id":"9b94292e57b32c026576eb83c39d298d3143596d","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param callee the address of the callee that we should invite to a new\n     * call.\n     * @param device video device that will be used to stream desktop.\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    @Override\n    public Call createVideoCall(Contact callee, MediaDevice device)\n        throws OperationFailedException\n    {\n        CallJabberImpl call = (CallJabberImpl)super.createVideoCall(callee,\n                device);\n        CallPeerJabberImpl callPeer = call.getCallPeers().next();\n        callPeer.addCallPeerListener(callPeerListener);\n\n        size = (((VideoMediaFormat)call.getDefaultDevice(\n                MediaType.VIDEO).getFormat()).getSize());\n        origin = null;\n        return call;\n    }","id":92189,"modified_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param callee the address of the callee that we should invite to a new\n     * call.\n     * @param device video device that will be used to stream desktop.\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    @Override\n    public Call createVideoCall(Contact callee, MediaDevice device)\n        throws OperationFailedException\n    {\n        CallJabberImpl call = (CallJabberImpl)super.createVideoCall(callee,\n                device);\n        CallPeerJabberImpl callPeer = call.getCallPeers().next();\n        callPeer.addCallPeerListener(callPeerListener);\n\n        size = (((VideoMediaFormat)call.getDefaultDevice(\n                MediaType.VIDEO).getFormat()).getSize());\n        origin = getOriginForMediaDevice(device);\n        return call;\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param uri the address of the callee that we should invite to a new\n     * call.\n     * @param device video device that will be used to stream desktop.\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    @Override\n    public Call createVideoCall(String uri, MediaDevice device)\n        throws OperationFailedException, ParseException\n    {\n        CallJabberImpl call = (CallJabberImpl)super.createVideoCall(uri,\n                device);\n        CallPeerJabberImpl callPeer = call.getCallPeers().next();\n        callPeer.addCallPeerListener(callPeerListener);\n\n        size = (((VideoMediaFormat)call.getDefaultDevice(\n                MediaType.VIDEO).getFormat()).getSize());\n        origin = null;\n        return call;\n    }","id":92190,"modified_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param uri the address of the callee that we should invite to a new\n     * call.\n     * @param device video device that will be used to stream desktop.\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    @Override\n    public Call createVideoCall(String uri, MediaDevice device)\n        throws OperationFailedException, ParseException\n    {\n        CallJabberImpl call = (CallJabberImpl)super.createVideoCall(uri,\n                device);\n        CallPeerJabberImpl callPeer = call.getCallPeers().next();\n        callPeer.addCallPeerListener(callPeerListener);\n\n        size = (((VideoMediaFormat)call.getDefaultDevice(\n                MediaType.VIDEO).getFormat()).getSize());\n        origin = getOriginForMediaDevice(device);\n        return call;\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param callee the address of the callee that we should invite to a new\n     * call.\n     * @param device <tt>MediaDevice<\/tt> to use for this call\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    @Override\n    public Call createVideoCall(Contact callee, MediaDevice device)\n        throws OperationFailedException\n    {\n        CallSipImpl call = (CallSipImpl)super.createVideoCall(callee, device);\n        CallPeerSipImpl callPeer = call.getCallPeers().next();\n        callPeer.addMethodProcessorListener(this);\n        callPeer.addCallPeerListener(callPeerListener);\n\n        size = (((VideoMediaFormat)call.getDefaultDevice(MediaType.VIDEO).\n                getFormat()).getSize());\n        origin = null;\n        return call;\n    }","id":92191,"modified_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param callee the address of the callee that we should invite to a new\n     * call.\n     * @param device <tt>MediaDevice<\/tt> to use for this call\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    @Override\n    public Call createVideoCall(Contact callee, MediaDevice device)\n        throws OperationFailedException\n    {\n        CallSipImpl call = (CallSipImpl)super.createVideoCall(callee, device);\n        CallPeerSipImpl callPeer = call.getCallPeers().next();\n        callPeer.addMethodProcessorListener(this);\n        callPeer.addCallPeerListener(callPeerListener);\n\n        size = (((VideoMediaFormat)call.getDefaultDevice(MediaType.VIDEO).\n                getFormat()).getSize());\n        origin = getOriginForMediaDevice(device);\n        return call;\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param uri the address of the callee that we should invite to a new\n     * call.\n     * @param device <tt>MediaDevice<\/tt> to use for this call\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     * @throws ParseException if <tt>callee<\/tt> is not a valid sip address\n     * string.\n     */\n    @Override\n    public Call createVideoCall(String uri, MediaDevice device)\n        throws OperationFailedException, ParseException\n    {\n        CallSipImpl call = (CallSipImpl)super.createVideoCall(uri, device);\n        CallPeerSipImpl callPeer = call.getCallPeers().next();\n        callPeer.addMethodProcessorListener(this);\n        callPeer.addCallPeerListener(callPeerListener);\n\n        size = (((VideoMediaFormat)call.getDefaultDevice(MediaType.VIDEO).\n                getFormat()).getSize());\n        origin = null;\n        return call;\n    }","id":92192,"modified_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param uri the address of the callee that we should invite to a new\n     * call.\n     * @param device <tt>MediaDevice<\/tt> to use for this call\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     * @throws ParseException if <tt>callee<\/tt> is not a valid sip address\n     * string.\n     */\n    @Override\n    public Call createVideoCall(String uri, MediaDevice device)\n        throws OperationFailedException, ParseException\n    {\n        CallSipImpl call = (CallSipImpl)super.createVideoCall(uri, device);\n        CallPeerSipImpl callPeer = call.getCallPeers().next();\n        callPeer.addMethodProcessorListener(this);\n        callPeer.addCallPeerListener(callPeerListener);\n\n        size = (((VideoMediaFormat)call.getDefaultDevice(MediaType.VIDEO).\n                getFormat()).getSize());\n        origin = getOriginForMediaDevice(device);\n        return call;\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Check if the remote part supports Jingle video.\n     *\n     * @param calleeAddress Contact address\n     * @param videoDevice <tt>MediaDevice<\/tt> used\n     * @return true if contact support Jingle video, false otherwise\n     *\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    protected Call createOutgoingVideoCall(String calleeAddress,\n                                           MediaDevice videoDevice)\n        throws OperationFailedException\n    {\n        if (parentProvider.getConnection() == null)\n        {\n            throw new OperationFailedException(\n                    \"Failed to create OutgoingJingleSession.\\n\"\n                    + \"we don't have a valid XMPPConnection.\"\n                    , OperationFailedException.INTERNAL_ERROR);\n        }\n\n        CallJabberImpl call = new CallJabberImpl(basicTelephony);\n\n        /* enable video */\n        call.setVideoDevice(videoDevice);\n        call.setLocalVideoAllowed(true, getMediaUseCase());\n\n        basicTelephony.createOutgoingCall(call, calleeAddress);\n        origin = null;\n        return call;\n    }","id":92193,"modified_method":"/**\n     * Check if the remote part supports Jingle video.\n     *\n     * @param calleeAddress Contact address\n     * @param videoDevice <tt>MediaDevice<\/tt> used\n     * @return true if contact support Jingle video, false otherwise\n     *\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    protected Call createOutgoingVideoCall(String calleeAddress,\n                                           MediaDevice videoDevice)\n        throws OperationFailedException\n    {\n        if (parentProvider.getConnection() == null)\n        {\n            throw new OperationFailedException(\n                    \"Failed to create OutgoingJingleSession.\\n\"\n                    + \"we don't have a valid XMPPConnection.\"\n                    , OperationFailedException.INTERNAL_ERROR);\n        }\n\n        CallJabberImpl call = new CallJabberImpl(basicTelephony);\n\n        /* enable video */\n        call.setVideoDevice(videoDevice);\n        call.setLocalVideoAllowed(true, getMediaUseCase());\n\n        basicTelephony.createOutgoingCall(call, calleeAddress);\n        origin = getOriginForMediaDevice(videoDevice);\n        return call;\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param uri the address of the callee that we should invite to a new\n     * call.\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    @Override\n    public Call createVideoCall(String uri)\n        throws OperationFailedException\n    {\n        Call call = createOutgoingVideoCall(uri);\n        size = (((VideoMediaFormat)((CallJabberImpl)call).getDefaultDevice(\n                MediaType.VIDEO).getFormat()).getSize());\n        origin = null;\n        return call;\n    }","id":92194,"modified_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param uri the address of the callee that we should invite to a new\n     * call.\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    @Override\n    public Call createVideoCall(String uri)\n        throws OperationFailedException\n    {\n        Call call = createOutgoingVideoCall(uri);\n        MediaDevice device = ((CallJabberImpl)call).getDefaultDevice(\n                MediaType.VIDEO);\n        size = (((VideoMediaFormat)device.getFormat()).getSize());\n        origin = getOriginForMediaDevice(device);\n        return call;\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param callee the address of the callee that we should invite to a new\n     * call.\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    @Override\n    public Call createVideoCall(Contact callee) throws OperationFailedException\n    {\n        Call call = createOutgoingVideoCall(callee.getAddress());\n        size = (((VideoMediaFormat)((CallJabberImpl)call).getDefaultDevice(\n                MediaType.VIDEO).getFormat()).getSize());\n        origin = null;\n        return call;\n    }","id":92195,"modified_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param callee the address of the callee that we should invite to a new\n     * call.\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    @Override\n    public Call createVideoCall(Contact callee) throws OperationFailedException\n    {\n        Call call = createOutgoingVideoCall(callee.getAddress());\n        MediaDevice device = ((CallJabberImpl)call).getDefaultDevice(\n                MediaType.VIDEO);\n        size = (((VideoMediaFormat)device.getFormat()).getSize());\n        origin = getOriginForMediaDevice(device);\n        return call;\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements OperationSetVideoTelephony#setLocalVideoAllowed(Call,\n     * boolean). Modifies the local media setup to reflect the requested setting\n     * for the streaming of the local video and then re-invites all\n     * CallPeers to re-negotiate the modified media setup.\n     *\n     * @param call the call where we'd like to allow sending local video.\n     * @param allowed <tt>true<\/tt> if local video transmission is allowed and\n     * <tt>false<\/tt> otherwise.\n     *\n     *  @throws OperationFailedException if video initialization fails.\n     */\n    @Override\n    public void setLocalVideoAllowed(Call call, boolean allowed)\n        throws OperationFailedException\n    {\n        ((CallJabberImpl)call).setLocalVideoAllowed(allowed,\n                MediaUseCase.DESKTOP);\n        size = (((VideoMediaFormat)((CallJabberImpl)call).getDefaultDevice(\n                MediaType.VIDEO).getFormat()).getSize());\n        ((CallJabberImpl)call).modifyVideoContent(allowed);\n        origin = null;\n    }","id":92196,"modified_method":"/**\n     * Implements OperationSetVideoTelephony#setLocalVideoAllowed(Call,\n     * boolean). Modifies the local media setup to reflect the requested setting\n     * for the streaming of the local video and then re-invites all\n     * CallPeers to re-negotiate the modified media setup.\n     *\n     * @param call the call where we'd like to allow sending local video.\n     * @param allowed <tt>true<\/tt> if local video transmission is allowed and\n     * <tt>false<\/tt> otherwise.\n     *\n     *  @throws OperationFailedException if video initialization fails.\n     */\n    @Override\n    public void setLocalVideoAllowed(Call call, boolean allowed)\n        throws OperationFailedException\n    {\n        ((CallJabberImpl)call).setLocalVideoAllowed(allowed,\n                MediaUseCase.DESKTOP);\n        MediaDevice device = ((CallJabberImpl)call).getDefaultDevice(\n                MediaType.VIDEO);\n        size = (((VideoMediaFormat)device.getFormat()).getSize());\n        ((CallJabberImpl)call).modifyVideoContent(allowed);\n        origin = getOriginForMediaDevice(device);\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the indicator which determines whether the streaming of local video\n     * in a specific <tt>Call<\/tt> is allowed. The setting does not reflect\n     * the availability of actual video capture devices, it just expresses the\n     * desire of the user to have the local video streamed in the case the\n     * system is actually able to do so.\n     *\n     * @param call the <tt>Call<\/tt> to allow/disallow the streaming of local\n     * video for\n     * @param mediaDevice the media device to use for the desktop streaming\n     * @param allowed <tt>true<\/tt> to allow the streaming of local video for\n     * the specified <tt>Call<\/tt>; <tt>false<\/tt> to disallow it\n     *\n     * @throws OperationFailedException if initializing local video fails.\n     */\n    public void setLocalVideoAllowed(Call call,\n                                     MediaDevice mediaDevice,\n                                     boolean allowed)\n        throws OperationFailedException\n    {\n        ((CallJabberImpl)call).setLocalVideoAllowed(allowed,\n                MediaUseCase.DESKTOP);\n        ((CallJabberImpl)call).setVideoDevice(mediaDevice);\n        size = ((VideoMediaFormat)mediaDevice.getFormat()).getSize();\n        ((CallJabberImpl)call).modifyVideoContent(allowed);\n        origin = null;\n    }","id":92197,"modified_method":"/**\n     * Sets the indicator which determines whether the streaming of local video\n     * in a specific <tt>Call<\/tt> is allowed. The setting does not reflect\n     * the availability of actual video capture devices, it just expresses the\n     * desire of the user to have the local video streamed in the case the\n     * system is actually able to do so.\n     *\n     * @param call the <tt>Call<\/tt> to allow/disallow the streaming of local\n     * video for\n     * @param mediaDevice the media device to use for the desktop streaming\n     * @param allowed <tt>true<\/tt> to allow the streaming of local video for\n     * the specified <tt>Call<\/tt>; <tt>false<\/tt> to disallow it\n     *\n     * @throws OperationFailedException if initializing local video fails.\n     */\n    public void setLocalVideoAllowed(Call call,\n                                     MediaDevice mediaDevice,\n                                     boolean allowed)\n        throws OperationFailedException\n    {\n        ((CallJabberImpl)call).setLocalVideoAllowed(allowed,\n                MediaUseCase.DESKTOP);\n        ((CallJabberImpl)call).setVideoDevice(mediaDevice);\n        size = ((VideoMediaFormat)mediaDevice.getFormat()).getSize();\n        ((CallJabberImpl)call).modifyVideoContent(allowed);\n        origin = getOriginForMediaDevice(mediaDevice);\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements OperationSetVideoTelephony#setLocalVideoAllowed(Call,\n     * boolean). Modifies the local media setup to reflect the requested setting\n     * for the streaming of the local video and then re-invites all\n     * CallPeers to re-negotiate the modified media setup.\n     *\n     * @param call the call where we'd like to allow sending local video.\n     * @param allowed <tt>true<\/tt> if local video transmission is allowed and\n     * <tt>false<\/tt> otherwise.\n     *\n     *  @throws OperationFailedException if video initialization fails.\n     */\n    @Override\n    public void setLocalVideoAllowed(Call call, boolean allowed)\n        throws OperationFailedException\n    {\n        ((CallSipImpl)call).setLocalVideoAllowed(allowed, MediaUseCase.DESKTOP);\n\n        size = (((VideoMediaFormat)((CallSipImpl)call).\n                getDefaultDevice(MediaType.VIDEO).\n                getFormat()).getSize());\n        origin = null;\n\n        /* reinvite all peers */\n        ((CallSipImpl)call).reInvite();\n    }","id":92198,"modified_method":"/**\n     * Implements OperationSetVideoTelephony#setLocalVideoAllowed(Call,\n     * boolean). Modifies the local media setup to reflect the requested setting\n     * for the streaming of the local video and then re-invites all\n     * CallPeers to re-negotiate the modified media setup.\n     *\n     * @param call the call where we'd like to allow sending local video.\n     * @param allowed <tt>true<\/tt> if local video transmission is allowed and\n     * <tt>false<\/tt> otherwise.\n     *\n     *  @throws OperationFailedException if video initialization fails.\n     */\n    @Override\n    public void setLocalVideoAllowed(Call call, boolean allowed)\n        throws OperationFailedException\n    {\n        ((CallSipImpl)call).setLocalVideoAllowed(allowed, MediaUseCase.DESKTOP);\n\n        MediaDevice device = ((CallSipImpl)call).getDefaultDevice(\n                MediaType.VIDEO);\n        size = (((VideoMediaFormat)device.getFormat()).getSize());\n        origin = getOriginForMediaDevice(device);\n\n        /* reinvite all peers */\n        ((CallSipImpl)call).reInvite();\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the indicator which determines whether the streaming of local video\n     * in a specific <tt>Call<\/tt> is allowed. The setting does not reflect\n     * the availability of actual video capture devices, it just expresses the\n     * desire of the user to have the local video streamed in the case the\n     * system is actually able to do so.\n     *\n     * @param call the <tt>Call<\/tt> to allow/disallow the streaming of local\n     * video for\n     * @param mediaDevice the media device to use for the desktop streaming\n     * @param allowed <tt>true<\/tt> to allow the streaming of local video for\n     * the specified <tt>Call<\/tt>; <tt>false<\/tt> to disallow it\n     *\n     * @throws OperationFailedException if initializing local video fails.\n     */\n    public void setLocalVideoAllowed(Call call,\n                                     MediaDevice mediaDevice,\n                                     boolean allowed)\n        throws OperationFailedException\n    {\n        ((CallSipImpl)call).setVideoDevice(mediaDevice);\n        ((CallSipImpl)call).setLocalVideoAllowed(allowed, MediaUseCase.DESKTOP);\n        size = (((VideoMediaFormat)((CallSipImpl)call).\n                getDefaultDevice(MediaType.VIDEO).\n                getFormat()).getSize());\n        origin = null;\n\n        /* reinvite all peers */\n        ((CallSipImpl)call).reInvite();\n    }","id":92199,"modified_method":"/**\n     * Sets the indicator which determines whether the streaming of local video\n     * in a specific <tt>Call<\/tt> is allowed. The setting does not reflect\n     * the availability of actual video capture devices, it just expresses the\n     * desire of the user to have the local video streamed in the case the\n     * system is actually able to do so.\n     *\n     * @param call the <tt>Call<\/tt> to allow/disallow the streaming of local\n     * video for\n     * @param mediaDevice the media device to use for the desktop streaming\n     * @param allowed <tt>true<\/tt> to allow the streaming of local video for\n     * the specified <tt>Call<\/tt>; <tt>false<\/tt> to disallow it\n     *\n     * @throws OperationFailedException if initializing local video fails.\n     */\n    public void setLocalVideoAllowed(Call call,\n                                     MediaDevice mediaDevice,\n                                     boolean allowed)\n        throws OperationFailedException\n    {\n        ((CallSipImpl)call).setVideoDevice(mediaDevice);\n        ((CallSipImpl)call).setLocalVideoAllowed(allowed, MediaUseCase.DESKTOP);\n        size = (((VideoMediaFormat)((CallSipImpl)call).\n                getDefaultDevice(MediaType.VIDEO).\n                getFormat()).getSize());\n        origin = getOriginForMediaDevice(mediaDevice);\n\n        /* reinvite all peers */\n        ((CallSipImpl)call).reInvite();\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param callee the address of the callee that we should invite to a new\n     * call.\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    @Override\n    public Call createVideoCall(Contact callee) throws OperationFailedException\n    {\n        Call call = super.createVideoCall(callee);\n        size = (((VideoMediaFormat)((CallSipImpl)call).\n                getDefaultDevice(MediaType.VIDEO).\n                getFormat()).getSize());\n        origin = null;\n        return call;\n    }","id":92200,"modified_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param callee the address of the callee that we should invite to a new\n     * call.\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    @Override\n    public Call createVideoCall(Contact callee) throws OperationFailedException\n    {\n        Call call = super.createVideoCall(callee);\n        MediaDevice device = ((CallSipImpl)call).getDefaultDevice(\n                MediaType.VIDEO);\n        size = (((VideoMediaFormat)device.getFormat()).getSize());\n        origin = getOriginForMediaDevice(device);\n        return call;\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param uri the address of the callee that we should invite to a new\n     * call.\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     * @throws ParseException if <tt>callee<\/tt> is not a valid sip address\n     * string.\n     */\n    @Override\n    public Call createVideoCall(String uri)\n        throws OperationFailedException, ParseException\n    {\n        Call call = super.createVideoCall(uri);\n        size = (((VideoMediaFormat)((CallSipImpl)call).\n                getDefaultDevice(MediaType.VIDEO).\n                getFormat()).getSize());\n        origin = null;\n        return call;\n    }","id":92201,"modified_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param uri the address of the callee that we should invite to a new\n     * call.\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     * @throws ParseException if <tt>callee<\/tt> is not a valid sip address\n     * string.\n     */\n    @Override\n    public Call createVideoCall(String uri)\n        throws OperationFailedException, ParseException\n    {\n        Call call = super.createVideoCall(uri);\n        MediaDevice device = ((CallSipImpl)call).getDefaultDevice(\n                MediaType.VIDEO);\n        size = (((VideoMediaFormat)device.getFormat()).getSize());\n        origin = getOriginForMediaDevice(device);\n        return call;\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param uri the address of the callee that we should invite to a new\n     * call.\n     * @param mediaDevice the media device to use for the desktop streaming\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     * @throws ParseException if <tt>callee<\/tt> is not a valid sip address\n     * string.\n     */\n    public Call createVideoCall(String uri, MediaDevice mediaDevice)\n        throws OperationFailedException, ParseException\n    {\n        Address toAddress = parentProvider.parseAddressString(uri);\n\n        CallSipImpl call = basicTelephony.createOutgoingCall();\n        call.setVideoDevice(mediaDevice);\n        call.setLocalVideoAllowed(true, getMediaUseCase());\n        call.invite(toAddress, null);\n        origin = null;\n        return call;\n    }","id":92202,"modified_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param uri the address of the callee that we should invite to a new\n     * call.\n     * @param mediaDevice the media device to use for the desktop streaming\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipatn instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     * @throws ParseException if <tt>callee<\/tt> is not a valid sip address\n     * string.\n     */\n    public Call createVideoCall(String uri, MediaDevice mediaDevice)\n        throws OperationFailedException, ParseException\n    {\n        Address toAddress = parentProvider.parseAddressString(uri);\n\n        CallSipImpl call = basicTelephony.createOutgoingCall();\n        call.setVideoDevice(mediaDevice);\n        call.setLocalVideoAllowed(true, getMediaUseCase());\n        call.invite(toAddress, null);\n        origin = getOriginForMediaDevice(mediaDevice);\n        return call;\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param callee the address of the callee that we should invite to a new\n     * call.\n     * @param mediaDevice the media device to use for the desktop streaming\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipant instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    public Call createVideoCall(Contact callee, MediaDevice mediaDevice)\n        throws OperationFailedException\n    {\n        Address toAddress;\n\n        try\n        {\n            toAddress = parentProvider.parseAddressString(callee.getAddress());\n        }\n        catch (ParseException ex)\n        {\n            throw new IllegalArgumentException(ex.getMessage());\n        }\n\n        CallSipImpl call = basicTelephony.createOutgoingCall();\n        call.setLocalVideoAllowed(true, getMediaUseCase());\n        call.setVideoDevice(mediaDevice);\n        call.invite(toAddress, null);\n        origin = null;\n\n        return call;\n    }","id":92203,"modified_method":"/**\n     * Create a new video call and invite the specified CallPeer to it.\n     *\n     * @param callee the address of the callee that we should invite to a new\n     * call.\n     * @param mediaDevice the media device to use for the desktop streaming\n     * @return CallPeer the CallPeer that will represented by the\n     * specified uri. All following state change events will be delivered\n     * through that call peer. The Call that this peer is a member\n     * of could be retrieved from the CallParticipant instance with the use\n     * of the corresponding method.\n     * @throws OperationFailedException with the corresponding code if we fail\n     * to create the video call.\n     */\n    public Call createVideoCall(Contact callee, MediaDevice mediaDevice)\n        throws OperationFailedException\n    {\n        Address toAddress;\n\n        try\n        {\n            toAddress = parentProvider.parseAddressString(callee.getAddress());\n        }\n        catch (ParseException ex)\n        {\n            throw new IllegalArgumentException(ex.getMessage());\n        }\n\n        CallSipImpl call = basicTelephony.createOutgoingCall();\n        call.setLocalVideoAllowed(true, getMediaUseCase());\n        call.setVideoDevice(mediaDevice);\n        call.invite(toAddress, null);\n        origin = getOriginForMediaDevice(mediaDevice);\n\n        return call;\n    }","commit_id":"3f2715a21a403f57113294feb2d1f866aaaf32d8","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n    public ELContext getELContext() {\n        // instead decorate!!!\n\n        if (elContext == null) {\n            elContext = rootJspCtxt.getELContext();\n        }\n        return elContext;\n\n        /*\n        if (this.elContext != null) {\n            JspFactory jspFact = JspFactory.getDefaultFactory();\n            ServletContext servletContext = this.getServletContext();\n            JspApplicationContextImpl jspCtx = (JspApplicationContextImpl) jspFact\n                    .getJspApplicationContext(servletContext);\n            this.elContext = jspCtx.createELContext(this);\n        }\n        return this.elContext;\n        */\n    }","id":92204,"modified_method":"@Override\n    public ELContext getELContext() {\n        if (elContext == null) {\n            elContext = new ELContextWrapper(rootJspCtxt.getELContext(), this);\n        }\n        return elContext;\n    }","commit_id":"8d743bd65877e997af7127f440524cba893658a6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Proprietary method to evaluate EL expressions. XXX - This method should\n     * go away once the EL interpreter moves out of JSTL and into its own\n     * project. For now, this is necessary because the standard machinery is too\n     * slow.\n     *\n     * @param expression\n     *            The expression to be evaluated\n     * @param expectedType\n     *            The expected resulting type\n     * @param pageContext\n     *            The page context\n     * @param functionMap\n     *            Maps prefix and name to Method\n     * @return The result of the evaluation\n     */\n    public static Object proprietaryEvaluate(final String expression,\n            final Class<?> expectedType, final PageContext pageContext,\n            final ProtectedFunctionMapper functionMap)\n            throws ELException {\n        final ExpressionFactory exprFactory = jspf.getJspApplicationContext(pageContext.getServletContext()).getExpressionFactory();\n        ELContextImpl ctx = (ELContextImpl) pageContext.getELContext();\n        ctx.setFunctionMapper(functionMap);\n        ValueExpression ve = exprFactory.createValueExpression(ctx, expression, expectedType);\n        return ve.getValue(ctx);\n    }","id":92205,"modified_method":"/**\n     * Proprietary method to evaluate EL expressions. XXX - This method should\n     * go away once the EL interpreter moves out of JSTL and into its own\n     * project. For now, this is necessary because the standard machinery is too\n     * slow.\n     *\n     * @param expression\n     *            The expression to be evaluated\n     * @param expectedType\n     *            The expected resulting type\n     * @param pageContext\n     *            The page context\n     * @param functionMap\n     *            Maps prefix and name to Method\n     * @return The result of the evaluation\n     */\n    public static Object proprietaryEvaluate(final String expression,\n            final Class<?> expectedType, final PageContext pageContext,\n            final ProtectedFunctionMapper functionMap)\n            throws ELException {\n        final ExpressionFactory exprFactory = jspf.getJspApplicationContext(pageContext.getServletContext()).getExpressionFactory();\n        ELContext ctx = pageContext.getELContext();\n        ELContextImpl ctxImpl;\n        if (ctx instanceof ELContextWrapper) {\n            ctxImpl = (ELContextImpl) ((ELContextWrapper) ctx).getWrappedELContext();\n        } else {\n            ctxImpl = (ELContextImpl) ctx;\n        }\n        ctxImpl.setFunctionMapper(functionMap);\n        ValueExpression ve = exprFactory.createValueExpression(ctx, expression, expectedType);\n        return ve.getValue(ctx);\n    }","commit_id":"8d743bd65877e997af7127f440524cba893658a6","url":"https://github.com/apache/tomcat"},{"original_method":"public Object getValue(ELContext ctx, Object base, Object property)\n\tthrows PropertyNotFoundException, ELException {\n\t\tObject value = super.getValue(ctx, base, property);\n\t\t\n\t\tfinal BindELContext bctx = (BindELContext)((EvaluationContext)ctx).getELContext();\n\t\t\n\t\tObject ignoreRefVal = bctx.getAttribute(BinderImpl.IGNORE_REF_VALUE);\n\t\t\n\t\t//ZK-950: The expression reference doesn't update while change the instant of the reference\n\t\tfinal ReferenceBinding rbinding = value instanceof ReferenceBinding ? (ReferenceBinding)value : null;\n\t\tif (rbinding != null) {\n\t\t\t//ZK-1299 Use @ref and save after will cause null point exception\n\t\t\tif (Boolean.TRUE.equals(ignoreRefVal)) {\n\t\t\t\treturn rbinding;\n\t\t\t}\n//\t\t\tvalue = rbinding.getValue((BindELContext) ((EvaluationContext)ctx).getELContext());\n\t\t\tvalue = rbinding.getValue(bctx);\n\t\t\tfinal Object invalidateRef = bctx.getAttribute(BinderCtrl.INVALIDATE_REF_VALUE);\n\t\t\tif (\"true\".equalsIgnoreCase(String.valueOf(invalidateRef)))\n\t\t\t\trbinding.invalidateCache();\n\t\t} \n\t\t//If value evaluated to a ReferenceBinding, always tie the ReferenceBinding itself as the \n\t\t//evaluated bean, @see TrackerImpl#getLoadBindings0() and TrackerImpl#getAllTrackerNodesByBeanNodes()\n\t\ttieValue(ctx, base, property, rbinding != null ? rbinding : value, false);\n\t\treturn value;\n\t}","id":92206,"modified_method":"public Object getValue(ELContext ctx, Object base, Object property)\n\tthrows PropertyNotFoundException, ELException {\n\t\tObject value = super.getValue(ctx, base, property);\n\t\t\n\t\t// in order to support more complex case, ex: .stream().filter(x -> x.contains(vm.value))\n\t\tfinal BindELContext bctx;\n\t\tELContext ec = ((EvaluationContext)ctx).getELContext();\n\t\tif (ec instanceof BindELContext)\n\t\t\tbctx = (BindELContext)ec;\n\t\telse {\n\t\t\tbctx = (BindELContext)((EvaluationContext)ec).getELContext();\n\t\t}\n\t\t\n\t\tObject ignoreRefVal = bctx.getAttribute(BinderImpl.IGNORE_REF_VALUE);\n\t\t\n\t\t//ZK-950: The expression reference doesn't update while change the instant of the reference\n\t\tfinal ReferenceBinding rbinding = value instanceof ReferenceBinding ? (ReferenceBinding)value : null;\n\t\tif (rbinding != null) {\n\t\t\t//ZK-1299 Use @ref and save after will cause null point exception\n\t\t\tif (Boolean.TRUE.equals(ignoreRefVal)) {\n\t\t\t\treturn rbinding;\n\t\t\t}\n//\t\t\tvalue = rbinding.getValue((BindELContext) ((EvaluationContext)ctx).getELContext());\n\t\t\tvalue = rbinding.getValue(bctx);\n\t\t\tfinal Object invalidateRef = bctx.getAttribute(BinderCtrl.INVALIDATE_REF_VALUE);\n\t\t\tif (\"true\".equalsIgnoreCase(String.valueOf(invalidateRef)))\n\t\t\t\trbinding.invalidateCache();\n\t\t} \n\t\t//If value evaluated to a ReferenceBinding, always tie the ReferenceBinding itself as the \n\t\t//evaluated bean, @see TrackerImpl#getLoadBindings0() and TrackerImpl#getAllTrackerNodesByBeanNodes()\n\t\ttieValue(ctx, base, property, rbinding != null ? rbinding : value, false);\n\t\treturn value;\n\t}","commit_id":"8d243e4b8f159bd8379e627c09999388cbc65aad","url":"https://github.com/zkoss/zk"},{"original_method":"protected void tieValue(ELContext elCtx, Object base, Object property, Object value, boolean allownotify) {\n\t\tfinal BindELContext ctx = (BindELContext)((EvaluationContext)elCtx).getELContext();\n\t\t\n\t\tif(ctx.ignoreTracker()) return; \n\t\tfinal Binding binding = ctx.getBinding();\n\t\t//only there is a binding that needs tie tracking to value\n\t\tif (binding != null) {\n        \tfinal int nums = ((Integer) ctx.getContext(Integer.class)).intValue(); //get numOfKids, see #PathResolver\n        \tfinal Path path = getPathList(ctx);\n        \t\n        \tString script = null;\n        \t//ZK-1960 save binding to an array throws ClassCastException\n        \tString propName = property==null?null:property.toString();\n        \tboolean isForm = base instanceof Form;\n        \t//ZK-1189, form shouldn't count on property directly\n        \tString formFieldName = null;\n\t\t\tif (isForm) {\n\t\t\t\t\tscript = path.getTrackFieldName();//script is the expression, ex, bean[a.b.c]\n\t\t\t\tformFieldName = path.getAccessFieldName();//filedname is the evaluated value, ex, bean.k (a.b.c is k in script case)\n\t\t\t} else {\n\t\t\t\tscript = path.getTrackProperty();\n\t\t\t}\n\t\t\tfinal Binder binder = binding.getBinder();\n\t\t\tfinal BindContext bctx = (BindContext) ctx.getAttribute(BinderImpl.BINDCTX);\n\t\t\tfinal Component ctxcomp = bctx != null ? bctx.getComponent() : binding.getComponent();\n\t\t\t((BinderCtrl)binder).getTracker().tieValue(ctxcomp, base, script, propName, value, path.getTrackBasePath());\n\t\t\t\n\t\t\tif (base != null) {\n\t\t\t\tif (binding instanceof SaveBinding) {\n\t\t\t\t\tif (nums == 0) { //a done save operation, form or not form\n\t\t\t\t\t\t//handle equal beans\n\t\t\t\t\t\tsaveEqualBeans(elCtx, base, (String) propName, value);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//ZK-913 Value is reload after validation fail, \n\t\t\t\t\t\t//only when notify is allowed.\n\t\t\t\t\t\t//parse @NotifyChange and collect Property to publish PropertyChangeEvent\n\t\t\t\t\t\tif (allownotify) { \n\t\t\t\t\t\t\t//ZK-905 Save into a Form should fire NotifyChange\n\t\t\t\t\t\t\tif (isForm) {\n\t\t\t\t\t\t\t\t//collect notify property, kept in BindContext\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//notify indirect form properties that have same expression, \n\t\t\t\t\t\t\t\t//ex: bean[a.b.c] of fx, whose expression is 'bean[a.b.c]'\n\t\t\t\t\t\t\t\tBindELContext.addNotifys(base, script, value, bctx); \n\t\t\t\t\t\t\t\t//notify form property whose value equals expression result, \n\t\t\t\t\t\t\t\t//ex, bean[a.b.c] of fx, if a.b.c is 'prop', them it notify bean.prop of fx \n\t\t\t\t\t\t\t\tif(!script.equals(formFieldName)){\n\t\t\t\t\t\t\t\t\tBindELContext.addNotifys(base, (String) formFieldName, value, bctx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (base instanceof Form)\n\t\t\t\t\t\t\t\t\tBindELContext.addNotifys(((Form)base).getFormStatus(), \".\", null, bctx);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfinal Method m = (Method) ctx.getContext(Method.class);\n\t\t\t\t\t\t\t\t//collect Property for @NotifyChange, kept in BindContext\n\t\t\t\t\t\t\t\t//see BinderImpl$CommandEventListener#onEvent()\n\t\t\t\t\t\t\t\tBindELContext.addNotifys(m, base, (String) propName, value, bctx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (!(base instanceof Form) && binding instanceof LoadBinding) { //no @DependsOn in Form bean\n\t\t\t\t\t//parse @DependsOn and add into dependency tracking\n\t\t\t\t\tfinal Method m = (Method) ctx.getContext(Method.class);\n\t\t\t\t\tif (m != null) {\n\t\t\t\t\t\tfinal boolean prompt = bctx != null && bctx.getCommandName() == null; \n\t\t\t\t\t\tif (prompt) {\n\t\t\t\t\t\t\t//FormBinding shall not check @DependsOn() for dependent nodes\n\t\t\t\t\t\t\tif (!(binding instanceof LoadFormBindingImpl) || ((LoadFormBindingImpl)binding).getSeriesLength() <= path.size()) {\n\t\t\t\t\t\t\t\tBindELContext.addDependsOnTrackings(m, path.getTrackBasePath(), path.getTrackFieldsList(), binding, bctx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\tif(binding instanceof ReferenceBinding && nums == 0 && allownotify){\n\t\t\t\t\tfinal Method m = (Method) ctx.getContext(Method.class);\n\t\t\t\t\t//collect Property for @NotifyChange, kept in BindContext\n\t\t\t\t\t//see BinderImpl$CommandEventListener#onEvent()\n\t\t\t\t\tBindELContext.addNotifys(m, base, (String) propName, value, bctx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":92207,"modified_method":"protected void tieValue(ELContext elCtx, Object base, Object property, Object value, boolean allownotify) {\n\t\t//in order to support more complex case, ex: .stream().filter(x -> x.contains(vm.value))\n\t\tfinal BindELContext ctx;\n\t\tELContext ec = ((EvaluationContext)elCtx).getELContext();\n\t\tif (ec instanceof BindELContext)\n\t\t\tctx = (BindELContext)ec;\n\t\telse {\n\t\t\tctx = (BindELContext)((EvaluationContext)ec).getELContext();\n\t\t}\n\t\t\n\t\tif(ctx.ignoreTracker()) return; \n\t\tfinal Binding binding = ctx.getBinding();\n\t\t//only there is a binding that needs tie tracking to value\n\t\tif (binding != null) {\n        \tfinal int nums = ((Integer) ctx.getContext(Integer.class)).intValue(); //get numOfKids, see #PathResolver\n        \tfinal Path path = getPathList(ctx);\n        \t\n        \tString script = null;\n        \t//ZK-1960 save binding to an array throws ClassCastException\n        \tString propName = property==null?null:property.toString();\n        \tboolean isForm = base instanceof Form;\n        \t//ZK-1189, form shouldn't count on property directly\n        \tString formFieldName = null;\n\t\t\tif (isForm) {\n\t\t\t\t\tscript = path.getTrackFieldName();//script is the expression, ex, bean[a.b.c]\n\t\t\t\tformFieldName = path.getAccessFieldName();//filedname is the evaluated value, ex, bean.k (a.b.c is k in script case)\n\t\t\t} else {\n\t\t\t\tscript = path.getTrackProperty();\n\t\t\t}\n\t\t\tfinal Binder binder = binding.getBinder();\n\t\t\tfinal BindContext bctx = (BindContext) ctx.getAttribute(BinderImpl.BINDCTX);\n\t\t\tfinal Component ctxcomp = bctx != null ? bctx.getComponent() : binding.getComponent();\n\t\t\t((BinderCtrl)binder).getTracker().tieValue(ctxcomp, base, script, propName, value, path.getTrackBasePath());\n\t\t\t\n\t\t\tif (base != null) {\n\t\t\t\tif (binding instanceof SaveBinding) {\n\t\t\t\t\tif (nums == 0) { //a done save operation, form or not form\n\t\t\t\t\t\t//handle equal beans\n\t\t\t\t\t\tsaveEqualBeans(elCtx, base, (String) propName, value);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//ZK-913 Value is reload after validation fail, \n\t\t\t\t\t\t//only when notify is allowed.\n\t\t\t\t\t\t//parse @NotifyChange and collect Property to publish PropertyChangeEvent\n\t\t\t\t\t\tif (allownotify) { \n\t\t\t\t\t\t\t//ZK-905 Save into a Form should fire NotifyChange\n\t\t\t\t\t\t\tif (isForm) {\n\t\t\t\t\t\t\t\t//collect notify property, kept in BindContext\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//notify indirect form properties that have same expression, \n\t\t\t\t\t\t\t\t//ex: bean[a.b.c] of fx, whose expression is 'bean[a.b.c]'\n\t\t\t\t\t\t\t\tBindELContext.addNotifys(base, script, value, bctx); \n\t\t\t\t\t\t\t\t//notify form property whose value equals expression result, \n\t\t\t\t\t\t\t\t//ex, bean[a.b.c] of fx, if a.b.c is 'prop', them it notify bean.prop of fx \n\t\t\t\t\t\t\t\tif(!script.equals(formFieldName)){\n\t\t\t\t\t\t\t\t\tBindELContext.addNotifys(base, (String) formFieldName, value, bctx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (base instanceof Form)\n\t\t\t\t\t\t\t\t\tBindELContext.addNotifys(((Form)base).getFormStatus(), \".\", null, bctx);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfinal Method m = (Method) ctx.getContext(Method.class);\n\t\t\t\t\t\t\t\t//collect Property for @NotifyChange, kept in BindContext\n\t\t\t\t\t\t\t\t//see BinderImpl$CommandEventListener#onEvent()\n\t\t\t\t\t\t\t\tBindELContext.addNotifys(m, base, (String) propName, value, bctx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (!(base instanceof Form) && binding instanceof LoadBinding) { //no @DependsOn in Form bean\n\t\t\t\t\t//parse @DependsOn and add into dependency tracking\n\t\t\t\t\tfinal Method m = (Method) ctx.getContext(Method.class);\n\t\t\t\t\tif (m != null) {\n\t\t\t\t\t\tfinal boolean prompt = bctx != null && bctx.getCommandName() == null; \n\t\t\t\t\t\tif (prompt) {\n\t\t\t\t\t\t\t//FormBinding shall not check @DependsOn() for dependent nodes\n\t\t\t\t\t\t\tif (!(binding instanceof LoadFormBindingImpl) || ((LoadFormBindingImpl)binding).getSeriesLength() <= path.size()) {\n\t\t\t\t\t\t\t\tBindELContext.addDependsOnTrackings(m, path.getTrackBasePath(), path.getTrackFieldsList(), binding, bctx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\tif(binding instanceof ReferenceBinding && nums == 0 && allownotify){\n\t\t\t\t\tfinal Method m = (Method) ctx.getContext(Method.class);\n\t\t\t\t\t//collect Property for @NotifyChange, kept in BindContext\n\t\t\t\t\t//see BinderImpl$CommandEventListener#onEvent()\n\t\t\t\t\tBindELContext.addNotifys(m, base, (String) propName, value, bctx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"8d243e4b8f159bd8379e627c09999388cbc65aad","url":"https://github.com/zkoss/zk"},{"original_method":"public static void main(String[] args) {\r\n\t\tELProcessor elProc = new ELProcessor();\r\n\t\t\r\n\t\tSystem.out.println(elProc.eval(\"xxx.xxx\"));\r\n\t\tSystem.out.println(elProc.eval(\"var = 'hi'; var.xxx\"));\r\n\t\telProc.defineBean(\"foo\", new BigDecimal(\"123\"));\r\n\t\telProc.defineBean(\"bar\", \"blahblah\");\r\n\t\t//System.out.println(elProc.eval(\"Math.sqrt(16)\"));\r\n\t\t//System.out.println(elProc.eval(\"incr = x -> x+1; incr(10)\"));\r\n\t\t\r\n\t\tString expression = \"bar += 'hi' += foo\";\r\n\t\tString ret1 = (String) elProc.getValue(expression, String.class);\r\n\t\t//System.out.println(ret1);\r\n\t}","id":92208,"modified_method":"public static void main(String[] args) {\r\n\t\tELProcessor elProc = new ELProcessor();\r\n\t\t\r\n\t\t//System.out.println(elProc.eval(\"xxx.xxx\"));\r\n\t\t//System.out.println(elProc.eval(\"var = 'hi'; var.xxx\"));\r\n\t\t//elProc.defineBean(\"foo\", new BigDecimal(\"123\"));\r\n\t\t//elProc.defineBean(\"bar\", \"blahblah\");\r\n\t\t//System.out.println(elProc.eval(\"Math.sqrt(16)\"));\r\n\t\t//System.out.println(elProc.eval(\"incr = x -> x+1; incr(10)\"));\r\n\t\tSystem.out.println(elProc.eval(\"[1, 2, 3, 4, 5].stream().sum()\"));\r\n\t\t\r\n\t\tString expression = \"bar += 'hi' += foo\";\r\n\t\tString ret1 = (String) elProc.getValue(expression, String.class);\r\n\t\t//System.out.println(ret1);\r\n\t}","commit_id":"8d243e4b8f159bd8379e627c09999388cbc65aad","url":"https://github.com/zkoss/zk"},{"original_method":"@Test\r\n\tpublic void test() {\r\n\t\ttry {\r\n\t\t\tDesktopAgent desktop = connect();\r\n\t\t\tComponentAgent lb2 = desktop.query(\"#lb2\");\r\n\t\t\tComponentAgent lb3 = desktop.query(\"#lb3\");\r\n\t\t\tComponentAgent lb4 = desktop.query(\"#lb4\");\r\n\t\t\tComponentAgent lb5 = desktop.query(\"#lb5\");\r\n\t\t\tComponentAgent lb6 = desktop.query(\"#lb6\");\r\n\t\t\tComponentAgent lb7 = desktop.query(\"#lb7\");\r\n\t\t\tComponentAgent lb8 = desktop.query(\"#lb8\");\r\n\t\t\tComponentAgent lb9 = desktop.query(\"#lb9\");\r\n\t\t\tComponentAgent lb10 = desktop.query(\"#lb10\");\r\n\t\t\tComponentAgent lb11 = desktop.query(\"#lb11\");\r\n\t\t\tComponentAgent lb12 = desktop.query(\"#lb12\");\r\n\t\t\tComponentAgent lb13 = desktop.query(\"#lb13\");\r\n\t\t\tComponentAgent lb14 = desktop.query(\"#lb14\");\r\n\t\t\tComponentAgent btn1 = desktop.query(\"#btn1\");\r\n\t\t\tComponentAgent btn2 = desktop.query(\"#btn2\");\r\n\t\t\t\r\n\t\t\tassertEquals(\"4.0\", lb2.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"4\", lb3.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"value\", lb4.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"value6\", lb5.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"valuehi\", lb6.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"valuevalue\", lb7.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"one value two\", lb8.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"11\", lb9.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"11\", lb10.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"4\", lb11.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"120\", lb12.as(Label.class).getValue());\r\n\t\t\tbtn1.click();\r\n\t\t\tassertEquals(\"value6\", lb13.as(Label.class).getValue());\r\n\t\t\tbtn2.click();\r\n\t\t\tassertEquals(\"value611\", lb14.as(Label.class).getValue());\r\n\t\t} catch (Exception e) {\r\n\t\t\t// can't go here\r\n\t\t\tassertTrue(false);\r\n\t\t}\r\n\t}","id":92209,"modified_method":"@Test\r\n\tpublic void test() {\r\n\t\ttry {\r\n\t\t\tDesktopAgent desktop = connect();\r\n\t\t\tComponentAgent lb2 = desktop.query(\"#lb2\");\r\n\t\t\tComponentAgent lb3 = desktop.query(\"#lb3\");\r\n\t\t\tComponentAgent lb4 = desktop.query(\"#lb4\");\r\n\t\t\tComponentAgent lb5 = desktop.query(\"#lb5\");\r\n\t\t\tComponentAgent lb6 = desktop.query(\"#lb6\");\r\n\t\t\tComponentAgent lb7 = desktop.query(\"#lb7\");\r\n\t\t\tComponentAgent lb8 = desktop.query(\"#lb8\");\r\n\t\t\tComponentAgent lb9 = desktop.query(\"#lb9\");\r\n\t\t\tComponentAgent lb10 = desktop.query(\"#lb10\");\r\n\t\t\tComponentAgent lb11 = desktop.query(\"#lb11\");\r\n\t\t\tComponentAgent lb12 = desktop.query(\"#lb12\");\r\n\t\t\tComponentAgent lb13 = desktop.query(\"#lb13\");\r\n\t\t\tComponentAgent lb14 = desktop.query(\"#lb14\");\r\n\t\t\tComponentAgent btn1 = desktop.query(\"#btn1\");\r\n\t\t\tComponentAgent btn2 = desktop.query(\"#btn2\");\r\n\t\t\t\r\n\t\t\tassertEquals(\"4.0\", lb2.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"4\", lb3.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"value\", lb4.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"value6\", lb5.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"valuehi\", lb6.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"valuevalue\", lb7.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"one value two\", lb8.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"11\", lb9.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"11\", lb10.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"21\", lb11.as(Label.class).getValue());\r\n\t\t\tassertEquals(\"120\", lb12.as(Label.class).getValue());\r\n\t\t\tbtn1.click();\r\n\t\t\tassertEquals(\"value6\", lb13.as(Label.class).getValue());\r\n\t\t\tbtn2.click();\r\n\t\t\tassertEquals(\"value611\", lb14.as(Label.class).getValue());\r\n\t\t} catch (Exception e) {\r\n\t\t\t// can't go here\r\n\t\t\tassertTrue(false);\r\n\t\t}\r\n\t}","commit_id":"8d243e4b8f159bd8379e627c09999388cbc65aad","url":"https://github.com/zkoss/zk"},{"original_method":"@Override\n    public VerifyingTransactionInterceptor create( XaDataSource ds,\n            Object options )\n    {\n        if ( !( options instanceof String ) )\n        {\n            return null;\n        }\n        VerifyingTransactionInterceptor.CheckerMode mode;\n        try\n        {\n            mode = VerifyingTransactionInterceptor.CheckerMode.valueOf( ( (String) options ).toUpperCase() );\n        }\n        catch ( Exception ex )\n        {\n            return null;\n        }\n        return new VerifyingTransactionInterceptor( (NeoStoreXaDataSource) ds, mode, false );\n    }","id":92210,"modified_method":"@Override\n    public VerifyingTransactionInterceptor create( XaDataSource ds,\n            Object options )\n    {\n        if ( !( options instanceof String ) )\n        {\n            return null;\n        }\n        VerifyingTransactionInterceptor.CheckerMode mode;\n        String[] config = ((String) options).split( \";\" );\n        try\n        {\n            mode = VerifyingTransactionInterceptor.CheckerMode.valueOf( config[0].toUpperCase() );\n        }\n        catch ( Exception ex )\n        {\n            return null;\n        }\n        Map<String, String> extra = new HashMap<String, String>();\n        for ( int i = 1; i < config.length; i++ )\n        {\n            String[] parts = config[i].split( \"=\", 2 );\n            extra.put( parts[0].toLowerCase(), parts.length == 1 ? \"true\" : parts[1] );\n        }\n        return new VerifyingTransactionInterceptor( (NeoStoreXaDataSource) ds, mode, false, extra );\n    }","commit_id":"ffdf0a5fda84d730b3aea9817a0a259ed29960e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public VerifyingTransactionInterceptor create( TransactionInterceptor next,\n            XaDataSource ds, Object options )\n    {\n        VerifyingTransactionInterceptor result = create( ds, options );\n        result.setNext( next );\n        return result;\n    }","id":92211,"modified_method":"@Override\n    public TransactionInterceptor create( TransactionInterceptor next,\n            XaDataSource ds, Object options )\n    {\n        VerifyingTransactionInterceptor result = create( ds, options );\n        if ( result != null )\n        {\n            result.setNext( next );\n            return result;\n        }\n        else\n        {\n            return next;\n        }\n    }","commit_id":"ffdf0a5fda84d730b3aea9817a0a259ed29960e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"static EmbeddedGraphDatabase startTemporaryDb( String targetDirectory, VerificationLevel verification )\n    {\n        if ( verification != VerificationLevel.NONE ) {\n            return new EmbeddedGraphDatabase( targetDirectory, MapUtil.stringMap(\n                            Config.INTERCEPT_DESERIALIZED_TRANSACTIONS, \"true\",\n                            TransactionInterceptorProvider.class.getSimpleName()\n                            +\".\"+verification.interceptorName, verification.configValue ) );\n        }\n        else\n            return new EmbeddedGraphDatabase( targetDirectory );\n    }","id":92212,"modified_method":"static EmbeddedGraphDatabase startTemporaryDb( String targetDirectory, ConfigParam... params )\n    {\n        if (params != null && params.length > 0) {\n            Map<String,String> config = new HashMap<String, String>();\n            for ( ConfigParam param : params )\n                if ( param != null ) param.configure( config );\n            return new EmbeddedGraphDatabase( targetDirectory, config );\n        }\n        else\n            return new EmbeddedGraphDatabase( targetDirectory );\n    }","commit_id":"ffdf0a5fda84d730b3aea9817a0a259ed29960e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( String[] args )\n    {\n        if ( args == null )\n        {\n            printUsage();\n            return;\n        }\n        Args params = new Args( args );\n        boolean full = params.getBoolean( \"full\", false, true );\n        args = params.orphans().toArray( new String[0] );\n        if ( args.length != 2 )\n        {\n            printUsage( \"Exactly two positional arguments expected: <source dir with logs> <target dir for graphdb>\" );\n            System.exit( -1 );\n            return;\n        }\n        File source = new File( args[0] ), target = new File( args[1] );\n        if ( !source.isDirectory() )\n        {\n            printUsage( source + \" is not a directory\" );\n            System.exit( -1 );\n            return;\n        }\n        if ( target.exists() )\n        {\n            if ( target.isDirectory() )\n            {\n                if ( OnlineBackup.directoryContainsDb( target.getAbsolutePath() ) )\n                {\n                    printUsage( \"target graph database already exists\" );\n                    System.exit( -1 );\n                    return;\n                }\n                else\n                {\n                    System.err.println( \"WARNING: the directory \" + target + \" already exists\" );\n                }\n            }\n            else\n            {\n                printUsage( target + \" is a file\" );\n                System.exit( -1 );\n                return;\n            }\n        }\n        if ( findMaxLogFileId( source ) < 0 )\n        {\n            printUsage( \"Inconsistent number of log files found in \" + source );\n            System.exit( -1 );\n            return;\n        }\n        AbstractGraphDatabase graphdb = OnlineBackup.startTemporaryDb(\n                target.getAbsolutePath(), full ? VerificationLevel.FULL_WITH_LOGGING : VerificationLevel.LOGGING );\n        try\n        {\n            try\n            {\n                new RebuildFromLogs( graphdb ).applyTransactionsFrom( source ).fullCheck(!full);\n            }\n            finally\n            {\n                graphdb.shutdown();\n            }\n        }\n        catch ( IOException e )\n        {\n            System.err.println();\n            e.printStackTrace( System.err );\n            System.exit( -1 );\n            return;\n        }\n    }","id":92213,"modified_method":"public static void main( String[] args )\n    {\n        if ( args == null )\n        {\n            printUsage();\n            return;\n        }\n        Args params = new Args( args );\n        @SuppressWarnings( \"boxing\" )\n        boolean full = params.getBoolean( \"full\", false, true );\n        args = params.orphans().toArray( new String[0] );\n        if ( args.length != 2 )\n        {\n            printUsage( \"Exactly two positional arguments expected: \"\n                        + \"<source dir with logs> <target dir for graphdb>, got \" + args.length );\n            System.exit( -1 );\n            return;\n        }\n        File source = new File( args[0] ), target = new File( args[1] );\n        if ( !source.isDirectory() )\n        {\n            printUsage( source + \" is not a directory\" );\n            System.exit( -1 );\n            return;\n        }\n        if ( target.exists() )\n        {\n            if ( target.isDirectory() )\n            {\n                if ( OnlineBackup.directoryContainsDb( target.getAbsolutePath() ) )\n                {\n                    printUsage( \"target graph database already exists\" );\n                    System.exit( -1 );\n                    return;\n                }\n                else\n                {\n                    System.err.println( \"WARNING: the directory \" + target + \" already exists\" );\n                }\n            }\n            else\n            {\n                printUsage( target + \" is a file\" );\n                System.exit( -1 );\n                return;\n            }\n        }\n        if ( findMaxLogFileId( source ) < 0 )\n        {\n            printUsage( \"Inconsistent number of log files found in \" + source );\n            System.exit( -1 );\n            return;\n        }\n        String txdifflog = params.get( \"txdifflog\", null, new File( target, \"txdiff.log\" ).getAbsolutePath() );\n        AbstractGraphDatabase graphdb = OnlineBackup.startTemporaryDb( target.getAbsolutePath(),\n                                                                       new TxDiffLogConfig( full\n                                                                               ? VerificationLevel.FULL_WITH_LOGGING\n                                                                               : VerificationLevel.LOGGING, txdifflog ) );\n        try\n        {\n            try\n            {\n                new RebuildFromLogs( graphdb ).applyTransactionsFrom( source ).fullCheck( !full );\n            }\n            finally\n            {\n                graphdb.shutdown();\n            }\n        }\n        catch ( IOException e )\n        {\n            System.err.println();\n            e.printStackTrace( System.err );\n            System.exit( -1 );\n            return;\n        }\n    }","commit_id":"ffdf0a5fda84d730b3aea9817a0a259ed29960e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"VerifyingTransactionInterceptor(\n            NeoStoreXaDataSource ds, CheckerMode mode, boolean rejectInconsistentTransactions )\n    {\n        this.rejectInconsistentTransactions = rejectInconsistentTransactions;\n        this.diffs = new DiffStore( ds.getNeoStore() );\n        this.msgLog = ds.getMsgLog();\n        this.mode = mode;\n    }","id":92214,"modified_method":"VerifyingTransactionInterceptor( NeoStoreXaDataSource ds, CheckerMode mode, boolean rejectInconsistentTransactions,\n                                     Map<String, String> extraConfig )\n    {\n        this.rejectInconsistentTransactions = rejectInconsistentTransactions;\n        this.diffs = new DiffStore( ds.getNeoStore() );\n        this.msgLog = ds.getMsgLog();\n        this.mode = mode;\n        String log = extraConfig.get( \"log\" );\n        this.difflog = log == null ? null : ( \"true\".equalsIgnoreCase( log )\n                ? msgLog\n                : StringLogger.logger( new File( log ) ) );\n    }","commit_id":"ffdf0a5fda84d730b3aea9817a0a259ed29960e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private StringBuilder messageHeader( String type )\n    {\n        StringBuilder log = new StringBuilder( type ).append( \" in transaction\" );\n        if ( commitEntry != null )\n            log.append( \" (txId=\" ).append( commitEntry.getTxId() ).append( \")\" );\n        else if ( startEntry != null )\n            log.append( \" (log local id = \" ).append( startEntry.getIdentifier() ).append( \")\" );\n        return log.append( \":\\n\\t\" );\n    }","id":92215,"modified_method":"private StringBuilder messageHeader( String type )\n    {\n        StringBuilder log = new StringBuilder( type ).append( \" in transaction\" );\n        if ( commitEntry != null )\n            log.append( \" (txId=\" ).append( commitEntry.getTxId() ).append( \")\" );\n        else if ( startEntry != null )\n            log.append( \" (log local id = \" ).append( startEntry.getIdentifier() ).append( \")\" );\n        return log.append( ':' );\n    }","commit_id":"ffdf0a5fda84d730b3aea9817a0a259ed29960e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static <R extends AbstractBaseRecord> void logRecord( StringBuilder log, RecordStore<? extends R> store,\n            R record )\n    {\n        DiffRecordStore<? extends R> diff = (DiffRecordStore<? extends R>) store;\n        if ( diff.isModified( record.getLongId() ) )\n        {\n            log.append( \"- \" ).append( diff.forceGetRaw( record.getLongId() ) ).append( \"\\n\\t+ \" );\n            record = store.forceGetRecord( record.getLongId() );\n        }\n        log.append( record ).append( \"\\n\\t\" );\n    }","id":92216,"modified_method":"private static <R extends AbstractBaseRecord> void logRecord( final StringBuilder log,\n                                                                  RecordStore<? extends R> store, R record )\n    {\n        logRecord( new LineLogger()\n        {\n            @Override\n            public void logLine( String line )\n            {\n                log.append( line ).append( \"\\n\\t\" );\n            }\n        }, store, record );\n    }","commit_id":"ffdf0a5fda84d730b3aea9817a0a259ed29960e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void complete() throws DataInconsistencyError\n    {\n        /*\n         *  Here goes the actual verification code. If it passes,\n         *  just return - if not, throw Error so that the\n         *  store remains safe.\n         */\n        ConsistencyCheck consistency = mode.apply( diffs, new ConsistencyCheck( diffs, mode.checkProp )\n        {\n            @Override\n            protected <R extends AbstractBaseRecord> void report( RecordStore<R> recordStore, R record, InconsistencyType inconsistency )\n            {\n                if ( inconsistency.isWarning() ) return;\n                StringBuilder log = messageHeader( \"Inconsistencies\" );\n                logRecord( log, recordStore, record );\n                log.append( inconsistency.message() );\n                msgLog.logMessage( log.toString() );\n            }\n\n            @Override\n            protected <R1 extends AbstractBaseRecord, R2 extends AbstractBaseRecord> void report(\n                    RecordStore<R1> recordStore, R1 record, RecordStore<? extends R2> referredStore, R2 referred,\n                    InconsistencyType inconsistency )\n            {\n                if ( inconsistency.isWarning() ) return;\n                if ( recordStore == referredStore && record.getLongId() == referred.getLongId() )\n                { // inconsistency between versions, logRecord() handles that, treat as single record\n                    report( recordStore, record, inconsistency );\n                    return;\n                }\n                StringBuilder log = messageHeader( \"Inconsistencies\" );\n                logRecord( log, recordStore, record );\n                logRecord( log, referredStore, referred );\n                log.append( inconsistency.message() );\n                msgLog.logMessage( log.toString() );\n            }\n        } );\n        try\n        {\n            consistency.checkResult();\n        }\n        catch ( AssertionError e )\n        {\n            DataInconsistencyError error = new DataInconsistencyError( \"Cannot apply transaction\\n\\t\"\n                                                                       + ( startEntry == null\n                                                                               ? \"NO START ENTRY\"\n                                                                               : startEntry.toString() )\n                                                                       + \"\\n\\t\"\n                                                                       + ( commitEntry == null\n                                                                               ? \"NO COMMIT ENTRY\"\n                                                                               : commitEntry.toString() ) + \"\\n\\t\"\n                                                                       + e.getMessage() );\n            msgLog.logMessage( error.getMessage() );\n            if ( rejectInconsistentTransactions )\n            {\n                throw error;\n            }\n            else // we log it\n            {\n                // FIXME: there is a memory hazard here, this StringBuilder could grow quite large...\n                final StringBuilder changes = messageHeader( \"Changes\" );\n                diffs.applyToAll( new RecordStore.Processor()\n                {\n                    @Override\n                    protected <R extends AbstractBaseRecord> void processRecord( Class<R> type, RecordStore<R> store,\n                            R record )\n                    {\n                        DiffRecordStore<R> diff = (DiffRecordStore<R>) store;\n                        if ( diff.isModified( record.getLongId() ) )\n                        {\n                            logRecord( changes, store, record );\n                        }\n                    }\n                } );\n                for ( RecordStore<?> store : diffs.allStores() )\n                {\n                    changes.append( store ).append( \": highId(before) = \" );\n                    changes.append( ( (DiffRecordStore<?>) store ).getRawHighId() );\n                    changes.append( \", highId(after) = \" ).append( store.getHighId() ).append( \"\\n\\t\" );\n                }\n                msgLog.logMessage( changes.toString() );\n            }\n        }\n        // Chain of Responsibility continues\n        if ( next != null )\n        {\n            next.complete();\n        }\n    }","id":92217,"modified_method":"public void complete() throws DataInconsistencyError\n    {\n        /*\n         *  Here goes the actual verification code. If it passes,\n         *  just return - if not, throw Error so that the\n         *  store remains safe.\n         */\n        ConsistencyCheck consistency = mode.apply( diffs, new ConsistencyCheck( diffs, mode.checkProp )\n        {\n            @Override\n            protected <R extends AbstractBaseRecord> void report( RecordStore<R> recordStore, R record, InconsistencyType inconsistency )\n            {\n                if ( inconsistency.isWarning() ) return;\n                StringBuilder log = messageHeader( \"Inconsistencies\" ).append( \"\\n\\t\" );\n                logRecord( log, recordStore, record );\n                log.append( inconsistency.message() );\n                msgLog.logMessage( log.toString() );\n                if ( difflog != null && difflog != msgLog ) difflog.logMessage( log.toString() );\n            }\n\n            @Override\n            protected <R1 extends AbstractBaseRecord, R2 extends AbstractBaseRecord> void report(\n                    RecordStore<R1> recordStore, R1 record, RecordStore<? extends R2> referredStore, R2 referred,\n                    InconsistencyType inconsistency )\n            {\n                if ( inconsistency.isWarning() ) return;\n                if ( recordStore == referredStore && record.getLongId() == referred.getLongId() )\n                { // inconsistency between versions, logRecord() handles that, treat as single record\n                    report( recordStore, record, inconsistency );\n                    return;\n                }\n                StringBuilder log = messageHeader( \"Inconsistencies\" ).append( \"\\n\\t\" );\n                logRecord( log, recordStore, record );\n                logRecord( log, referredStore, referred );\n                log.append( inconsistency.message() );\n                msgLog.logMessage( log.toString() );\n                if ( difflog != null && difflog != msgLog ) difflog.logMessage( log.toString() );\n            }\n        } );\n        DataInconsistencyError error = null;\n        try\n        {\n            consistency.checkResult();\n        }\n        catch ( AssertionError e )\n        {\n            error = new DataInconsistencyError( \"Inconsistencies in transaction\\n\\t\"\n                                                + ( startEntry == null ? \"NO START ENTRY\" : startEntry.toString() )\n                                                + \"\\n\\t\"\n                                                + ( commitEntry == null ? \"NO COMMIT ENTRY\" : commitEntry.toString() )\n                                                + \"\\n\\t\" + e.getMessage() );\n            msgLog.logMessage( error.getMessage() );\n            if ( difflog != null && difflog != msgLog ) difflog.logMessage( error.getMessage() );\n        }\n        if ( difflog != null || error != null )\n        {\n            //new DiffLogger().log( messageHeader( \"Changes\" ).toString() );\n\n            final String header = messageHeader( \"Changes\" ).toString();\n            StringLogger target = null;\n            Visitor<StringLogger.LineLogger> visitor = null;\n            if ( error != null )\n            {\n                target = msgLog;\n                if ( difflog != null && difflog != msgLog )\n                {\n                    visitor = new Visitor<StringLogger.LineLogger>()\n                    {\n                        @Override\n                        public boolean visit( final LineLogger first )\n                        {\n                            difflog.logLongMessage( header, new Visitor<StringLogger.LineLogger>()\n                            {\n                                @Override\n                                public boolean visit( final LineLogger other )\n                                {\n                                    other.logLine( startEntry == null ? \"NO START ENTRY\" : startEntry.toString() );\n                                    other.logLine( commitEntry == null ? \"NO COMMIT ENTRY\" : commitEntry.toString() );\n                                    logDiffLines( new LineLogger()\n                                    {\n                                        @Override\n                                        public void logLine( String line )\n                                        {\n                                            first.logLine( line );\n                                            other.logLine( line );\n                                        }\n                                    } );\n                                    return false;\n                                }\n                            } );\n                            return false;\n                        }\n                    };\n                }\n                else\n                {\n                    visitor = new Visitor<StringLogger.LineLogger>()\n                    {\n                        @Override\n                        public boolean visit( LineLogger lines )\n                        {\n                            logDiffLines( lines );\n                            return false;\n                        }\n                    };\n                }\n            }\n            else\n            {\n                target = difflog;\n                visitor = new Visitor<StringLogger.LineLogger>()\n                {\n                    @Override\n                    public boolean visit( LineLogger lines )\n                    {\n                        lines.logLine( startEntry == null ? \"NO START ENTRY\" : startEntry.toString() );\n                        lines.logLine( commitEntry == null ? \"NO COMMIT ENTRY\" : commitEntry.toString() );\n                        logDiffLines( lines );\n                        return false;\n                    }\n                };\n            }\n            target.logLongMessage( header, visitor );\n        }\n        if ( difflog != null ) difflog.close();\n        // re-throw error if we are rejecting inconsistencies\n        if ( error != null && rejectInconsistentTransactions ) throw error;\n        // Chain of Responsibility continues\n        if ( next != null ) next.complete();\n    }","commit_id":"ffdf0a5fda84d730b3aea9817a0a259ed29960e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public VerifyingTransactionInterceptor create( XaDataSource ds,\n            Object options )\n    {\n        if ( !( options instanceof String ) )\n        {\n            return null;\n        }\n        String config = (String) options;\n        if ( !\"true\".equalsIgnoreCase( config ) )\n        {\n            return null;\n        }\n        return new VerifyingTransactionInterceptor( (NeoStoreXaDataSource) ds,\n                VerifyingTransactionInterceptor.CheckerMode.DIFF, true );\n    }","id":92218,"modified_method":"@Override\n    public VerifyingTransactionInterceptor create( XaDataSource ds,\n            Object options )\n    {\n        if ( !( options instanceof String ) )\n        {\n            return null;\n        }\n        String[] config = ((String) options).split( \";\" );\n        if ( !\"true\".equalsIgnoreCase( config[0] ) )\n        {\n            return null;\n        }\n        Map<String, String> extra = new HashMap<String, String>();\n        for ( int i = 1; i < config.length; i++ )\n        {\n            String[] parts = config[i].split( \"=\", 2 );\n            extra.put( parts[0].toLowerCase(), parts.length == 1 ? \"true\" : parts[1] );\n        }\n        return new VerifyingTransactionInterceptor( (NeoStoreXaDataSource) ds,\n                VerifyingTransactionInterceptor.CheckerMode.DIFF, true, extra );\n    }","commit_id":"ffdf0a5fda84d730b3aea9817a0a259ed29960e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public VerifyingTransactionInterceptor create( TransactionInterceptor next,\n            XaDataSource ds, Object options )\n    {\n        VerifyingTransactionInterceptor result = create( ds, options );\n        result.setNext( next );\n        return result;\n    }","id":92219,"modified_method":"@Override\n    public TransactionInterceptor create( TransactionInterceptor next,\n            XaDataSource ds, Object options )\n    {\n        VerifyingTransactionInterceptor result = create( ds, options );\n        if ( result != null )\n        {\n            result.setNext( next );\n            return result;\n        }\n        else\n        {\n            return next;\n        }\n    }","commit_id":"ffdf0a5fda84d730b3aea9817a0a259ed29960e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void showError( Logger logger, String message, Throwable e, boolean showStackTrace )\n    {\n        if ( logger == null )\n        {\n            logger = new PrintStreamLogger( System.out );\n        }\n\n        if ( showStackTrace )\n        {\n            logger.error( message, e );\n        }\n        else\n        {\n            logger.error( message );\n\n            if ( e != null )\n            {\n                logger.error( e.getMessage() );\n\n                for ( Throwable cause = e.getCause(); cause != null; cause = cause.getCause() )\n                {\n                    logger.error( \"Caused by: \" + cause.getMessage() );\n                }\n            }\n        }\n    }","id":92220,"modified_method":"public static void showError( Logger logger, String message, Throwable e, boolean showStackTrace )\n    {\n        if ( showStackTrace )\n        {\n            logger.error( message, e );\n        }\n        else\n        {\n            logger.error( message );\n\n            if ( e != null )\n            {\n                logger.error( e.getMessage() );\n\n                for ( Throwable cause = e.getCause(); cause != null; cause = cause.getCause() )\n                {\n                    logger.error( \"Caused by: \" + cause.getMessage() );\n                }\n            }\n        }\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"public static void showVersion( PrintStream stdout )\n    {\n        Properties properties = getBuildProperties();\n        stdout.println( createMavenVersionString( properties ) );\n        String shortName = reduce( properties.getProperty( \"distributionShortName\" ) );\n\n        stdout.println( shortName + \" home: \" + System.getProperty( \"maven.home\", \"<unknown maven home>\" ) );\n\n        stdout.println( \"Java version: \" + System.getProperty( \"java.version\", \"<unknown java version>\" )\n            + \", vendor: \" + System.getProperty( \"java.vendor\", \"<unknown vendor>\" ) );\n\n        stdout.println( \"Java home: \" + System.getProperty( \"java.home\", \"<unknown java home>\" ) );\n\n        stdout.println( \"Default locale: \" + Locale.getDefault() + \", platform encoding: \"\n            + System.getProperty( \"file.encoding\", \"<unknown encoding>\" ) );\n\n        stdout.println( \"OS name: \\\"\" + Os.OS_NAME + \"\\\", version: \\\"\" + Os.OS_VERSION + \"\\\", arch: \\\"\" + Os.OS_ARCH\n            + \"\\\", family: \\\"\" + Os.OS_FAMILY + \"\\\"\" );\n    }","id":92221,"modified_method":"public static String showVersion()\n    {\n        String LS = System.getProperty(\"line.separator\");\n        Properties properties = getBuildProperties();\n        StringBuffer version = new StringBuffer();\n        version.append( createMavenVersionString( properties ) ).append( LS );\n        version.append( reduce( properties.getProperty( \"distributionShortName\" ) + \" home: \" + System.getProperty( \"maven.home\", \"<unknown maven home>\" ) ) ).append( LS );\n        version.append( \"Java version: \" + System.getProperty( \"java.version\", \"<unknown java version>\" ) + \", vendor: \" + System.getProperty( \"java.vendor\", \"<unknown vendor>\" ) ).append( LS );\n        version.append( \"Java home: \" + System.getProperty( \"java.home\", \"<unknown java home>\" ) ).append( LS );\n        version.append( \"Default locale: \" + Locale.getDefault() + \", platform encoding: \" + System.getProperty( \"file.encoding\", \"<unknown encoding>\" ) ).append( LS );\n        version.append( \"OS name: \\\"\" + Os.OS_NAME + \"\\\", version: \\\"\" + Os.OS_VERSION + \"\\\", arch: \\\"\" + Os.OS_ARCH + \"\\\", family: \\\"\" + Os.OS_FAMILY + \"\\\"\" );\n        return version.toString();\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"private void version( CliRequest cliRequest )\n    {\n        if ( cliRequest.debug || cliRequest.commandLine.hasOption( CLIManager.SHOW_VERSION ) )\n        {\n            CLIReportingUtils.showVersion( System.out );\n        }\n    }","id":92222,"modified_method":"private void version( CliRequest cliRequest )\n    {\n        if ( cliRequest.debug || cliRequest.commandLine.hasOption( CLIManager.SHOW_VERSION ) )\n        {\n            System.out.print(CLIReportingUtils.showVersion());\n        }\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"private ClassRealm setupContainerRealm( CliRequest cliRequest )\n        throws Exception\n    {\n        ClassRealm containerRealm = null;\n\n        String extClassPath = cliRequest.userProperties.getProperty( EXT_CLASS_PATH );\n        if ( extClassPath == null )\n        {\n            extClassPath = cliRequest.systemProperties.getProperty( EXT_CLASS_PATH );\n        }\n\n        if ( StringUtils.isNotEmpty( extClassPath ) )\n        {\n            String[] jars = StringUtils.split( extClassPath, File.pathSeparator );\n\n            if ( jars.length > 0 )\n            {\n                ClassRealm coreRealm = cliRequest.classWorld.getClassRealm( \"plexus.core\" );\n                if ( coreRealm == null )\n                {\n                    coreRealm = (ClassRealm) cliRequest.classWorld.getRealms().iterator().next();\n                }\n\n                ClassRealm extRealm = cliRequest.classWorld.newRealm( \"maven.ext\", null );\n\n                logger.debug( \"Populating class realm \" + extRealm.getId() );\n\n                for ( String jar : jars )\n                {\n                    File file = resolveFile( new File( jar ), cliRequest.workingDirectory );\n\n                    logger.debug( \"  Included \" + file );\n\n                    extRealm.addURL( file.toURI().toURL() );\n                }\n\n                extRealm.setParentRealm( coreRealm );\n\n                containerRealm = extRealm;\n            }\n        }\n\n        return containerRealm;\n    }","id":92223,"modified_method":"private ClassRealm setupContainerRealm( CliRequest cliRequest )\n        throws Exception\n    {\n        ClassRealm containerRealm = null;\n\n        String extClassPath = cliRequest.userProperties.getProperty( EXT_CLASS_PATH );\n        if ( extClassPath == null )\n        {\n            extClassPath = cliRequest.systemProperties.getProperty( EXT_CLASS_PATH );\n        }\n\n        if ( StringUtils.isNotEmpty( extClassPath ) )\n        {\n            String[] jars = StringUtils.split( extClassPath, File.pathSeparator );\n\n            if ( jars.length > 0 )\n            {\n                ClassRealm coreRealm = cliRequest.classWorld.getClassRealm( \"plexus.core\" );\n                if ( coreRealm == null )\n                {\n                    coreRealm = (ClassRealm) cliRequest.classWorld.getRealms().iterator().next();\n                }\n\n                ClassRealm extRealm = cliRequest.classWorld.newRealm( \"maven.ext\", null );\n\n                slf4jLogger.debug( \"Populating class realm \" + extRealm.getId() );\n\n                for ( String jar : jars )\n                {\n                    File file = resolveFile( new File( jar ), cliRequest.workingDirectory );\n\n                    slf4jLogger.debug( \"  Included \" + file );\n\n                    extRealm.addURL( file.toURI().toURL() );\n                }\n\n                extRealm.setParentRealm( coreRealm );\n\n                containerRealm = extRealm;\n            }\n        }\n\n        return containerRealm;\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"private void logSummary( ExceptionSummary summary, Map<String, String> references, String indent,\n                             boolean showErrors )\n    {\n        String referenceKey = \"\";\n\n        if ( StringUtils.isNotEmpty( summary.getReference() ) )\n        {\n            referenceKey = references.get( summary.getReference() );\n            if ( referenceKey == null )\n            {\n                referenceKey = \"[Help \" + ( references.size() + 1 ) + \"]\";\n                references.put( summary.getReference(), referenceKey );\n            }\n        }\n\n        String msg = summary.getMessage();\n\n        if ( StringUtils.isNotEmpty( referenceKey ) )\n        {\n            if ( msg.indexOf( '\\n' ) < 0 )\n            {\n                msg += \" -> \" + referenceKey;\n            }\n            else\n            {\n                msg += \"\\n-> \" + referenceKey;\n            }\n        }\n\n        String[] lines = msg.split( \"(\\r\\n)|(\\r)|(\\n)\" );\n\n        for ( int i = 0; i < lines.length; i++ )\n        {\n            String line = indent + lines[i].trim();\n\n            if ( i == lines.length - 1 && ( showErrors || ( summary.getException() instanceof InternalErrorException ) ) )\n            {\n                logger.error( line, summary.getException() );\n            }\n            else\n            {\n                logger.error( line );\n            }\n        }\n\n        indent += \"  \";\n\n        for ( ExceptionSummary child : summary.getChildren() )\n        {\n            logSummary( child, references, indent, showErrors );\n        }\n    }","id":92224,"modified_method":"private void logSummary( ExceptionSummary summary, Map<String, String> references, String indent,\n                             boolean showErrors )\n    {\n        String referenceKey = \"\";\n\n        if ( StringUtils.isNotEmpty( summary.getReference() ) )\n        {\n            referenceKey = references.get( summary.getReference() );\n            if ( referenceKey == null )\n            {\n                referenceKey = \"[Help \" + ( references.size() + 1 ) + \"]\";\n                references.put( summary.getReference(), referenceKey );\n            }\n        }\n\n        String msg = summary.getMessage();\n\n        if ( StringUtils.isNotEmpty( referenceKey ) )\n        {\n            if ( msg.indexOf( '\\n' ) < 0 )\n            {\n                msg += \" -> \" + referenceKey;\n            }\n            else\n            {\n                msg += \"\\n-> \" + referenceKey;\n            }\n        }\n\n        String[] lines = msg.split( \"(\\r\\n)|(\\r)|(\\n)\" );\n\n        for ( int i = 0; i < lines.length; i++ )\n        {\n            String line = indent + lines[i].trim();\n\n            if ( i == lines.length - 1 && ( showErrors || ( summary.getException() instanceof InternalErrorException ) ) )\n            {\n                slf4jLogger.error( line, summary.getException() );\n            }\n            else\n            {\n                slf4jLogger.error( line );\n            }\n        }\n\n        indent += \"  \";\n\n        for ( ExceptionSummary child : summary.getChildren() )\n        {\n            logSummary( child, references, indent, showErrors );\n        }\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"private MavenExecutionRequest populateRequest( CliRequest cliRequest )\n    {\n        MavenExecutionRequest request = cliRequest.request;\n        CommandLine commandLine = cliRequest.commandLine;\n        String workingDirectory = cliRequest.workingDirectory;\n        boolean quiet = cliRequest.quiet;\n        boolean showErrors = cliRequest.showErrors;\n\n        String[] deprecatedOptions = { \"up\", \"npu\", \"cpu\", \"npr\" };\n        for ( String deprecatedOption : deprecatedOptions )\n        {\n            if ( commandLine.hasOption( deprecatedOption ) )\n            {\n                logger.warn( \"Command line option -\" + deprecatedOption\n                    + \" is deprecated and will be removed in future Maven versions.\" );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Now that we have everything that we need we will fire up plexus and\n        // bring the maven component to life for use.\n        // ----------------------------------------------------------------------\n\n        if ( commandLine.hasOption( CLIManager.BATCH_MODE ) )\n        {\n            request.setInteractiveMode( false );\n        }\n\n        boolean noSnapshotUpdates = false;\n        if ( commandLine.hasOption( CLIManager.SUPRESS_SNAPSHOT_UPDATES ) )\n        {\n            noSnapshotUpdates = true;\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        @SuppressWarnings( \"unchecked\" )\n        List<String> goals = commandLine.getArgList();\n\n        boolean recursive = true;\n\n        // this is the default behavior.\n        String reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_FAST;\n\n        if ( commandLine.hasOption( CLIManager.NON_RECURSIVE ) )\n        {\n            recursive = false;\n        }\n\n        if ( commandLine.hasOption( CLIManager.FAIL_FAST ) )\n        {\n            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_FAST;\n        }\n        else if ( commandLine.hasOption( CLIManager.FAIL_AT_END ) )\n        {\n            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_AT_END;\n        }\n        else if ( commandLine.hasOption( CLIManager.FAIL_NEVER ) )\n        {\n            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_NEVER;\n        }\n\n        if ( commandLine.hasOption( CLIManager.OFFLINE ) )\n        {\n            request.setOffline( true );\n        }\n\n        boolean updateSnapshots = false;\n\n        if ( commandLine.hasOption( CLIManager.UPDATE_SNAPSHOTS ) )\n        {\n            updateSnapshots = true;\n        }\n\n        String globalChecksumPolicy = null;\n\n        if ( commandLine.hasOption( CLIManager.CHECKSUM_FAILURE_POLICY ) )\n        {\n            globalChecksumPolicy = MavenExecutionRequest.CHECKSUM_POLICY_FAIL;\n        }\n        else if ( commandLine.hasOption( CLIManager.CHECKSUM_WARNING_POLICY ) )\n        {\n            globalChecksumPolicy = MavenExecutionRequest.CHECKSUM_POLICY_WARN;\n        }\n\n        File baseDirectory = new File( workingDirectory, \"\" ).getAbsoluteFile();\n\n        // ----------------------------------------------------------------------\n        // Profile Activation\n        // ----------------------------------------------------------------------\n\n        List<String> activeProfiles = new ArrayList<String>();\n\n        List<String> inactiveProfiles = new ArrayList<String>();\n\n        if ( commandLine.hasOption( CLIManager.ACTIVATE_PROFILES ) )\n        {\n            String[] profileOptionValues = commandLine.getOptionValues( CLIManager.ACTIVATE_PROFILES );\n            if ( profileOptionValues != null )\n            {\n                for ( int i = 0; i < profileOptionValues.length; ++i )\n                {\n                    StringTokenizer profileTokens = new StringTokenizer( profileOptionValues[i], \",\" );\n\n                    while ( profileTokens.hasMoreTokens() )\n                    {\n                        String profileAction = profileTokens.nextToken().trim();\n\n                        if ( profileAction.startsWith( \"-\" ) || profileAction.startsWith( \"!\" ) )\n                        {\n                            inactiveProfiles.add( profileAction.substring( 1 ) );\n                        }\n                        else if ( profileAction.startsWith( \"+\" ) )\n                        {\n                            activeProfiles.add( profileAction.substring( 1 ) );\n                        }\n                        else\n                        {\n                            activeProfiles.add( profileAction );\n                        }\n                    }\n                }\n            }\n        }\n\n        TransferListener transferListener;\n\n        if ( quiet )\n        {\n            transferListener = new QuietMavenTransferListener();\n        }\n        else if ( request.isInteractiveMode() )\n        {\n            transferListener = new ConsoleMavenTransferListener( System.out );\n        }\n        else\n        {\n            transferListener = new BatchModeMavenTransferListener( System.out );\n        }\n\n        ExecutionListener executionListener = new ExecutionEventLogger( logger );\n        executionListener = eventSpyDispatcher.chainListener( executionListener );\n\n        String alternatePomFile = null;\n        if ( commandLine.hasOption( CLIManager.ALTERNATE_POM_FILE ) )\n        {\n            alternatePomFile = commandLine.getOptionValue( CLIManager.ALTERNATE_POM_FILE );\n        }\n\n        File userToolchainsFile;\n        if ( commandLine.hasOption( CLIManager.ALTERNATE_USER_TOOLCHAINS ) )\n        {\n            userToolchainsFile = new File( commandLine.getOptionValue( CLIManager.ALTERNATE_USER_TOOLCHAINS ) );\n            userToolchainsFile = resolveFile( userToolchainsFile, workingDirectory );\n        }\n        else\n        {\n            userToolchainsFile = MavenCli.DEFAULT_USER_TOOLCHAINS_FILE;\n        }\n\n        request.setBaseDirectory( baseDirectory ).setGoals( goals )\n            .setSystemProperties( cliRequest.systemProperties )\n            .setUserProperties( cliRequest.userProperties )\n            .setReactorFailureBehavior( reactorFailureBehaviour ) // default: fail fast\n            .setRecursive( recursive ) // default: true\n            .setShowErrors( showErrors ) // default: false\n            .addActiveProfiles( activeProfiles ) // optional\n            .addInactiveProfiles( inactiveProfiles ) // optional\n            .setExecutionListener( executionListener )\n            .setTransferListener( transferListener ) // default: batch mode which goes along with interactive\n            .setUpdateSnapshots( updateSnapshots ) // default: false\n            .setNoSnapshotUpdates( noSnapshotUpdates ) // default: false\n            .setGlobalChecksumPolicy( globalChecksumPolicy ) // default: warn\n            .setUserToolchainsFile( userToolchainsFile );\n\n        if ( alternatePomFile != null )\n        {\n            File pom = resolveFile( new File( alternatePomFile ), workingDirectory );\n            if ( pom.isDirectory() )\n            {\n                pom = new File( pom, \"pom.xml\" );\n            }\n\n            request.setPom( pom );\n        }\n        else\n        {\n            File pom = modelProcessor.locatePom( baseDirectory );\n\n            if ( pom.isFile() )\n            {\n                request.setPom( pom );\n            }\n        }\n\n        if ( ( request.getPom() != null ) && ( request.getPom().getParentFile() != null ) )\n        {\n            request.setBaseDirectory( request.getPom().getParentFile() );\n        }\n\n        if ( commandLine.hasOption( CLIManager.RESUME_FROM ) )\n        {\n            request.setResumeFrom( commandLine.getOptionValue( CLIManager.RESUME_FROM ) );\n        }\n\n        if ( commandLine.hasOption( CLIManager.PROJECT_LIST ) )\n        {\n            String[] values = commandLine.getOptionValues( CLIManager.PROJECT_LIST );\n            List<String> projects = new ArrayList<String>();\n            for ( int i = 0; i < values.length; i++ )\n            {\n                String[] tmp = StringUtils.split( values[i], \",\" );\n                projects.addAll( Arrays.asList( tmp ) );\n            }\n            request.setSelectedProjects( projects );\n        }\n\n        if ( commandLine.hasOption( CLIManager.ALSO_MAKE )\n                        && !commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )\n        {\n            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_UPSTREAM );\n        }\n        else if ( !commandLine.hasOption( CLIManager.ALSO_MAKE )\n                        && commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )\n        {\n            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_DOWNSTREAM );\n        }\n        else if ( commandLine.hasOption( CLIManager.ALSO_MAKE )\n                        && commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )\n        {\n            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_BOTH );\n        }\n\n        String localRepoProperty = request.getUserProperties().getProperty( MavenCli.LOCAL_REPO_PROPERTY );\n\n        if ( localRepoProperty == null )\n        {\n            localRepoProperty = request.getSystemProperties().getProperty( MavenCli.LOCAL_REPO_PROPERTY );\n        }\n\n        if ( localRepoProperty != null )\n        {\n            request.setLocalRepositoryPath( localRepoProperty );\n        }\n\n        final String threadConfiguration = commandLine.hasOption( CLIManager.THREADS )\n            ? commandLine.getOptionValue( CLIManager.THREADS )\n            : request.getSystemProperties().getProperty(\n                MavenCli.THREADS_DEPRECATED ); // TODO: Remove this setting. Note that the int-tests use it\n\n        if ( threadConfiguration != null )\n        {\n            request.setPerCoreThreadCount( threadConfiguration.contains( \"C\" ) );\n            if ( threadConfiguration.contains( \"W\" ) )\n            {\n                LifecycleWeaveBuilder.setWeaveMode( request.getUserProperties() );\n            }\n            request.setThreadCount( threadConfiguration.replace( \"C\", \"\" ).replace( \"W\", \"\" ).replace( \"auto\", \"\" ) );\n        }\n\n        request.setCacheNotFound( true );\n        request.setCacheTransferError( false );\n\n        return request;\n    }","id":92225,"modified_method":"private MavenExecutionRequest populateRequest( CliRequest cliRequest )\n    {\n        MavenExecutionRequest request = cliRequest.request;\n        CommandLine commandLine = cliRequest.commandLine;\n        String workingDirectory = cliRequest.workingDirectory;\n        boolean quiet = cliRequest.quiet;\n        boolean showErrors = cliRequest.showErrors;\n\n        String[] deprecatedOptions = { \"up\", \"npu\", \"cpu\", \"npr\" };\n        for ( String deprecatedOption : deprecatedOptions )\n        {\n            if ( commandLine.hasOption( deprecatedOption ) )\n            {\n                slf4jLogger.warn( \"Command line option -\" + deprecatedOption\n                    + \" is deprecated and will be removed in future Maven versions.\" );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Now that we have everything that we need we will fire up plexus and\n        // bring the maven component to life for use.\n        // ----------------------------------------------------------------------\n\n        if ( commandLine.hasOption( CLIManager.BATCH_MODE ) )\n        {\n            request.setInteractiveMode( false );\n        }\n\n        boolean noSnapshotUpdates = false;\n        if ( commandLine.hasOption( CLIManager.SUPRESS_SNAPSHOT_UPDATES ) )\n        {\n            noSnapshotUpdates = true;\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        @SuppressWarnings( \"unchecked\" )\n        List<String> goals = commandLine.getArgList();\n\n        boolean recursive = true;\n\n        // this is the default behavior.\n        String reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_FAST;\n\n        if ( commandLine.hasOption( CLIManager.NON_RECURSIVE ) )\n        {\n            recursive = false;\n        }\n\n        if ( commandLine.hasOption( CLIManager.FAIL_FAST ) )\n        {\n            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_FAST;\n        }\n        else if ( commandLine.hasOption( CLIManager.FAIL_AT_END ) )\n        {\n            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_AT_END;\n        }\n        else if ( commandLine.hasOption( CLIManager.FAIL_NEVER ) )\n        {\n            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_NEVER;\n        }\n\n        if ( commandLine.hasOption( CLIManager.OFFLINE ) )\n        {\n            request.setOffline( true );\n        }\n\n        boolean updateSnapshots = false;\n\n        if ( commandLine.hasOption( CLIManager.UPDATE_SNAPSHOTS ) )\n        {\n            updateSnapshots = true;\n        }\n\n        String globalChecksumPolicy = null;\n\n        if ( commandLine.hasOption( CLIManager.CHECKSUM_FAILURE_POLICY ) )\n        {\n            globalChecksumPolicy = MavenExecutionRequest.CHECKSUM_POLICY_FAIL;\n        }\n        else if ( commandLine.hasOption( CLIManager.CHECKSUM_WARNING_POLICY ) )\n        {\n            globalChecksumPolicy = MavenExecutionRequest.CHECKSUM_POLICY_WARN;\n        }\n\n        File baseDirectory = new File( workingDirectory, \"\" ).getAbsoluteFile();\n\n        // ----------------------------------------------------------------------\n        // Profile Activation\n        // ----------------------------------------------------------------------\n\n        List<String> activeProfiles = new ArrayList<String>();\n\n        List<String> inactiveProfiles = new ArrayList<String>();\n\n        if ( commandLine.hasOption( CLIManager.ACTIVATE_PROFILES ) )\n        {\n            String[] profileOptionValues = commandLine.getOptionValues( CLIManager.ACTIVATE_PROFILES );\n            if ( profileOptionValues != null )\n            {\n                for ( int i = 0; i < profileOptionValues.length; ++i )\n                {\n                    StringTokenizer profileTokens = new StringTokenizer( profileOptionValues[i], \",\" );\n\n                    while ( profileTokens.hasMoreTokens() )\n                    {\n                        String profileAction = profileTokens.nextToken().trim();\n\n                        if ( profileAction.startsWith( \"-\" ) || profileAction.startsWith( \"!\" ) )\n                        {\n                            inactiveProfiles.add( profileAction.substring( 1 ) );\n                        }\n                        else if ( profileAction.startsWith( \"+\" ) )\n                        {\n                            activeProfiles.add( profileAction.substring( 1 ) );\n                        }\n                        else\n                        {\n                            activeProfiles.add( profileAction );\n                        }\n                    }\n                }\n            }\n        }\n\n        TransferListener transferListener;\n\n        if ( quiet )\n        {\n            transferListener = new QuietMavenTransferListener();\n        }\n        else if ( request.isInteractiveMode() )\n        {\n            transferListener = new ConsoleMavenTransferListener( slf4jLogger );\n        }\n        else\n        {\n            transferListener = new BatchModeMavenTransferListener( slf4jLogger );\n        }\n\n        ExecutionListener executionListener = new ExecutionEventLogger( slf4jLogger );\n        executionListener = eventSpyDispatcher.chainListener( executionListener );\n\n        String alternatePomFile = null;\n        if ( commandLine.hasOption( CLIManager.ALTERNATE_POM_FILE ) )\n        {\n            alternatePomFile = commandLine.getOptionValue( CLIManager.ALTERNATE_POM_FILE );\n        }\n\n        File userToolchainsFile;\n        if ( commandLine.hasOption( CLIManager.ALTERNATE_USER_TOOLCHAINS ) )\n        {\n            userToolchainsFile = new File( commandLine.getOptionValue( CLIManager.ALTERNATE_USER_TOOLCHAINS ) );\n            userToolchainsFile = resolveFile( userToolchainsFile, workingDirectory );\n        }\n        else\n        {\n            userToolchainsFile = MavenCli.DEFAULT_USER_TOOLCHAINS_FILE;\n        }\n\n        request.setBaseDirectory( baseDirectory ).setGoals( goals )\n            .setSystemProperties( cliRequest.systemProperties )\n            .setUserProperties( cliRequest.userProperties )\n            .setReactorFailureBehavior( reactorFailureBehaviour ) // default: fail fast\n            .setRecursive( recursive ) // default: true\n            .setShowErrors( showErrors ) // default: false\n            .addActiveProfiles( activeProfiles ) // optional\n            .addInactiveProfiles( inactiveProfiles ) // optional\n            .setExecutionListener( executionListener )\n            .setTransferListener( transferListener ) // default: batch mode which goes along with interactive\n            .setUpdateSnapshots( updateSnapshots ) // default: false\n            .setNoSnapshotUpdates( noSnapshotUpdates ) // default: false\n            .setGlobalChecksumPolicy( globalChecksumPolicy ) // default: warn\n            .setUserToolchainsFile( userToolchainsFile );\n\n        if ( alternatePomFile != null )\n        {\n            File pom = resolveFile( new File( alternatePomFile ), workingDirectory );\n            if ( pom.isDirectory() )\n            {\n                pom = new File( pom, \"pom.xml\" );\n            }\n\n            request.setPom( pom );\n        }\n        else\n        {\n            File pom = modelProcessor.locatePom( baseDirectory );\n\n            if ( pom.isFile() )\n            {\n                request.setPom( pom );\n            }\n        }\n\n        if ( ( request.getPom() != null ) && ( request.getPom().getParentFile() != null ) )\n        {\n            request.setBaseDirectory( request.getPom().getParentFile() );\n        }\n\n        if ( commandLine.hasOption( CLIManager.RESUME_FROM ) )\n        {\n            request.setResumeFrom( commandLine.getOptionValue( CLIManager.RESUME_FROM ) );\n        }\n\n        if ( commandLine.hasOption( CLIManager.PROJECT_LIST ) )\n        {\n            String[] values = commandLine.getOptionValues( CLIManager.PROJECT_LIST );\n            List<String> projects = new ArrayList<String>();\n            for ( int i = 0; i < values.length; i++ )\n            {\n                String[] tmp = StringUtils.split( values[i], \",\" );\n                projects.addAll( Arrays.asList( tmp ) );\n            }\n            request.setSelectedProjects( projects );\n        }\n\n        if ( commandLine.hasOption( CLIManager.ALSO_MAKE )\n                        && !commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )\n        {\n            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_UPSTREAM );\n        }\n        else if ( !commandLine.hasOption( CLIManager.ALSO_MAKE )\n                        && commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )\n        {\n            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_DOWNSTREAM );\n        }\n        else if ( commandLine.hasOption( CLIManager.ALSO_MAKE )\n                        && commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )\n        {\n            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_BOTH );\n        }\n\n        String localRepoProperty = request.getUserProperties().getProperty( MavenCli.LOCAL_REPO_PROPERTY );\n\n        if ( localRepoProperty == null )\n        {\n            localRepoProperty = request.getSystemProperties().getProperty( MavenCli.LOCAL_REPO_PROPERTY );\n        }\n\n        if ( localRepoProperty != null )\n        {\n            request.setLocalRepositoryPath( localRepoProperty );\n        }\n\n        final String threadConfiguration = commandLine.hasOption( CLIManager.THREADS )\n            ? commandLine.getOptionValue( CLIManager.THREADS )\n            : request.getSystemProperties().getProperty(\n                MavenCli.THREADS_DEPRECATED ); // TODO: Remove this setting. Note that the int-tests use it\n\n        if ( threadConfiguration != null )\n        {\n            request.setPerCoreThreadCount( threadConfiguration.contains( \"C\" ) );\n            if ( threadConfiguration.contains( \"W\" ) )\n            {\n                LifecycleWeaveBuilder.setWeaveMode( request.getUserProperties() );\n            }\n            request.setThreadCount( threadConfiguration.replace( \"C\", \"\" ).replace( \"W\", \"\" ).replace( \"auto\", \"\" ) );\n        }\n\n        request.setCacheNotFound( true );\n        request.setCacheTransferError( false );\n\n        return request;\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"private PrintStreamLogger setupLogger( CliRequest cliRequest )\n    {\n        PrintStreamLogger logger = new PrintStreamLogger( new PrintStreamLogger.Provider()\n        {\n            public PrintStream getStream()\n            {\n                return System.out;\n            }\n        } );\n\n        logger.setThreshold( cliRequest.request.getLoggingLevel() );\n\n        return logger;\n    }","id":92226,"modified_method":"private PrintStreamLogger setupLogger( int loggingLevel )\n    {\n        PrintStreamLogger logger = new PrintStreamLogger( new PrintStreamLogger.Provider()\n        {\n            public PrintStream getStream()\n            {\n                return System.out;\n            }\n        } );\n\n        logger.setThreshold( loggingLevel );\n\n        return logger;\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"public int doMain( CliRequest cliRequest )\n    {\n        PlexusContainer localContainer = this.container;\n        try\n        {\n            initialize( cliRequest );\n            // Need to process cli options first to get possible logging options\n            cli( cliRequest );\n            logging( cliRequest );\n            version( cliRequest );\n            properties( cliRequest );\n            localContainer = container( cliRequest );\n            commands( cliRequest );\n            settings( cliRequest );\n            populateRequest( cliRequest );\n            encryption( cliRequest );\n            return execute( cliRequest );\n        }\n        catch ( ExitException e )\n        {\n            return e.exitCode;\n        }\n        catch ( UnrecognizedOptionException e )\n        {\n            // pure user error, suppress stack trace\n            return 1;\n        }\n        catch ( BuildAbort e )\n        {\n            CLIReportingUtils.showError( logger, \"ABORTED\", e, cliRequest.showErrors );\n\n            return 2;\n        }\n        catch ( Exception e )\n        {\n            CLIReportingUtils.showError( logger, \"Error executing Maven.\", e, cliRequest.showErrors );\n\n            return 1;\n        }\n        finally\n        {\n            if ( localContainer != this.container )\n            {\n                localContainer.dispose();\n            }\n            if ( cliRequest.fileStream != null )\n            {\n                cliRequest.fileStream.close();\n            }\n        }\n    }","id":92227,"modified_method":"public int doMain( CliRequest cliRequest )\n    {\n        PlexusContainer localContainer = this.container;\n        try\n        {\n            initialize( cliRequest );\n            cli( cliRequest );\n            logging( cliRequest );\n            version( cliRequest );\n            properties( cliRequest );\n            localContainer = container( cliRequest );\n            commands( cliRequest );\n            settings( cliRequest );\n            populateRequest( cliRequest );\n            encryption( cliRequest );\n            return execute( cliRequest );\n        }\n        catch ( ExitException e )\n        {\n            return e.exitCode;\n        }\n        catch ( UnrecognizedOptionException e )\n        {\n            // pure user error, suppress stack trace\n            return 1;\n        }\n        catch ( BuildAbort e )\n        {\n            CLIReportingUtils.showError( slf4jLogger, \"ABORTED\", e, cliRequest.showErrors );\n\n            return 2;\n        }\n        catch ( Exception e )\n        {\n            CLIReportingUtils.showError( slf4jLogger, \"Error executing Maven.\", e, cliRequest.showErrors );\n\n            return 1;\n        }\n        finally\n        {\n            if ( localContainer != this.container )\n            {\n                localContainer.dispose();\n            }\n        }\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"private void logging( CliRequest cliRequest )\n    {\n        cliRequest.debug = cliRequest.commandLine.hasOption( CLIManager.DEBUG );\n        cliRequest.quiet = !cliRequest.debug && cliRequest.commandLine.hasOption( CLIManager.QUIET );\n        cliRequest.showErrors = cliRequest.debug || cliRequest.commandLine.hasOption( CLIManager.ERRORS );\n\n        if ( cliRequest.debug )\n        {\n            cliRequest.request.setLoggingLevel( MavenExecutionRequest.LOGGING_LEVEL_DEBUG );\n        }\n        else if ( cliRequest.quiet )\n        {\n            // TODO: we need to do some more work here. Some plugins use sys out or log errors at info level.\n            // Ideally, we could use Warn across the board\n            cliRequest.request.setLoggingLevel( MavenExecutionRequest.LOGGING_LEVEL_ERROR );\n            // TODO:Additionally, we can't change the mojo level because the component key includes the version and\n            // it isn't known ahead of time. This seems worth changing.\n        }\n        else\n        {\n            cliRequest.request.setLoggingLevel( MavenExecutionRequest.LOGGING_LEVEL_INFO );\n        }\n\n        if ( cliRequest.commandLine.hasOption( CLIManager.LOG_FILE ) )\n        {\n            File logFile = new File( cliRequest.commandLine.getOptionValue( CLIManager.LOG_FILE ) );\n            logFile = resolveFile( logFile, cliRequest.workingDirectory );\n\n            try\n            {\n                cliRequest.fileStream = new PrintStream( logFile );\n\n                System.setOut( cliRequest.fileStream );\n                System.setErr( cliRequest.fileStream );\n            }\n            catch ( FileNotFoundException e )\n            {\n                System.err.println( e );\n            }\n        }\n    }","id":92228,"modified_method":"private void logging( CliRequest cliRequest )\n    {\n        cliRequest.debug = cliRequest.commandLine.hasOption( CLIManager.DEBUG );\n        cliRequest.quiet = !cliRequest.debug && cliRequest.commandLine.hasOption( CLIManager.QUIET );\n        cliRequest.showErrors = cliRequest.debug || cliRequest.commandLine.hasOption( CLIManager.ERRORS );\n\n        if ( cliRequest.debug )\n        {\n            cliRequest.request.setLoggingLevel( MavenExecutionRequest.LOGGING_LEVEL_DEBUG );\n            System.setProperty( \"org.slf4j.simpleLogger.defaultLogLevel\", \"debug\" );            \n        }\n        else if ( cliRequest.quiet )\n        {\n            cliRequest.request.setLoggingLevel( MavenExecutionRequest.LOGGING_LEVEL_ERROR );\n            System.setProperty( \"org.slf4j.simpleLogger.defaultLogLevel\", \"error\" );            \n        }\n        else\n        {\n            cliRequest.request.setLoggingLevel( MavenExecutionRequest.LOGGING_LEVEL_INFO );\n            System.setProperty( \"org.slf4j.simpleLogger.defaultLogLevel\", \"info\" );\n        }\n\n        if ( cliRequest.commandLine.hasOption( CLIManager.LOG_FILE ) )\n        {\n            File logFile = new File( cliRequest.commandLine.getOptionValue( CLIManager.LOG_FILE ) );\n            logFile = resolveFile( logFile, cliRequest.workingDirectory );\n            System.setProperty(\"org.slf4j.simpleLogger.logFile\", logFile.getAbsolutePath());\n        }\n\n        plexusLoggerManager = new Slf4jLoggerManager();       \n        slf4jLoggerFactory = LoggerFactory.getILoggerFactory();\n        slf4jLogger = slf4jLoggerFactory.getLogger(this.getClass().getName());\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"private void settings( CliRequest cliRequest )\n        throws Exception\n    {\n        File userSettingsFile;\n\n        if ( cliRequest.commandLine.hasOption( CLIManager.ALTERNATE_USER_SETTINGS ) )\n        {\n            userSettingsFile = new File( cliRequest.commandLine.getOptionValue( CLIManager.ALTERNATE_USER_SETTINGS ) );\n            userSettingsFile = resolveFile( userSettingsFile, cliRequest.workingDirectory );\n\n            if ( !userSettingsFile.isFile() )\n            {\n                throw new FileNotFoundException( \"The specified user settings file does not exist: \"\n                    + userSettingsFile );\n            }\n        }\n        else\n        {\n            userSettingsFile = DEFAULT_USER_SETTINGS_FILE;\n        }\n\n        File globalSettingsFile;\n\n        if ( cliRequest.commandLine.hasOption( CLIManager.ALTERNATE_GLOBAL_SETTINGS ) )\n        {\n            globalSettingsFile =\n                new File( cliRequest.commandLine.getOptionValue( CLIManager.ALTERNATE_GLOBAL_SETTINGS ) );\n            globalSettingsFile = resolveFile( globalSettingsFile, cliRequest.workingDirectory );\n\n            if ( !globalSettingsFile.isFile() )\n            {\n                throw new FileNotFoundException( \"The specified global settings file does not exist: \"\n                    + globalSettingsFile );\n            }\n        }\n        else\n        {\n            globalSettingsFile = DEFAULT_GLOBAL_SETTINGS_FILE;\n        }\n\n        cliRequest.request.setGlobalSettingsFile( globalSettingsFile );\n        cliRequest.request.setUserSettingsFile( userSettingsFile );\n\n        SettingsBuildingRequest settingsRequest = new DefaultSettingsBuildingRequest();\n        settingsRequest.setGlobalSettingsFile( globalSettingsFile );\n        settingsRequest.setUserSettingsFile( userSettingsFile );\n        settingsRequest.setSystemProperties( cliRequest.systemProperties );\n        settingsRequest.setUserProperties( cliRequest.userProperties );\n\n        eventSpyDispatcher.onEvent( settingsRequest );\n\n        logger.debug( \"Reading global settings from \"\n            + getSettingsLocation( settingsRequest.getGlobalSettingsSource(), settingsRequest.getGlobalSettingsFile() ) );\n        logger.debug( \"Reading user settings from \"\n            + getSettingsLocation( settingsRequest.getUserSettingsSource(), settingsRequest.getUserSettingsFile() ) );\n\n        SettingsBuildingResult settingsResult = settingsBuilder.build( settingsRequest );\n\n        eventSpyDispatcher.onEvent( settingsResult );\n\n        executionRequestPopulator.populateFromSettings( cliRequest.request, settingsResult.getEffectiveSettings() );\n\n        if ( !settingsResult.getProblems().isEmpty() && logger.isWarnEnabled() )\n        {\n            logger.warn( \"\" );\n            logger.warn( \"Some problems were encountered while building the effective settings\" );\n\n            for ( SettingsProblem problem : settingsResult.getProblems() )\n            {\n                logger.warn( problem.getMessage() + \" @ \" + problem.getLocation() );\n            }\n\n            logger.warn( \"\" );\n        }\n    }","id":92229,"modified_method":"private void settings( CliRequest cliRequest )\n        throws Exception\n    {\n        File userSettingsFile;\n\n        if ( cliRequest.commandLine.hasOption( CLIManager.ALTERNATE_USER_SETTINGS ) )\n        {\n            userSettingsFile = new File( cliRequest.commandLine.getOptionValue( CLIManager.ALTERNATE_USER_SETTINGS ) );\n            userSettingsFile = resolveFile( userSettingsFile, cliRequest.workingDirectory );\n\n            if ( !userSettingsFile.isFile() )\n            {\n                throw new FileNotFoundException( \"The specified user settings file does not exist: \"\n                    + userSettingsFile );\n            }\n        }\n        else\n        {\n            userSettingsFile = DEFAULT_USER_SETTINGS_FILE;\n        }\n\n        File globalSettingsFile;\n\n        if ( cliRequest.commandLine.hasOption( CLIManager.ALTERNATE_GLOBAL_SETTINGS ) )\n        {\n            globalSettingsFile =\n                new File( cliRequest.commandLine.getOptionValue( CLIManager.ALTERNATE_GLOBAL_SETTINGS ) );\n            globalSettingsFile = resolveFile( globalSettingsFile, cliRequest.workingDirectory );\n\n            if ( !globalSettingsFile.isFile() )\n            {\n                throw new FileNotFoundException( \"The specified global settings file does not exist: \"\n                    + globalSettingsFile );\n            }\n        }\n        else\n        {\n            globalSettingsFile = DEFAULT_GLOBAL_SETTINGS_FILE;\n        }\n\n        cliRequest.request.setGlobalSettingsFile( globalSettingsFile );\n        cliRequest.request.setUserSettingsFile( userSettingsFile );\n\n        SettingsBuildingRequest settingsRequest = new DefaultSettingsBuildingRequest();\n        settingsRequest.setGlobalSettingsFile( globalSettingsFile );\n        settingsRequest.setUserSettingsFile( userSettingsFile );\n        settingsRequest.setSystemProperties( cliRequest.systemProperties );\n        settingsRequest.setUserProperties( cliRequest.userProperties );\n\n        eventSpyDispatcher.onEvent( settingsRequest );\n\n        slf4jLogger.debug( \"Reading global settings from \"\n            + getSettingsLocation( settingsRequest.getGlobalSettingsSource(), settingsRequest.getGlobalSettingsFile() ) );\n        slf4jLogger.debug( \"Reading user settings from \"\n            + getSettingsLocation( settingsRequest.getUserSettingsSource(), settingsRequest.getUserSettingsFile() ) );\n\n        SettingsBuildingResult settingsResult = settingsBuilder.build( settingsRequest );\n\n        eventSpyDispatcher.onEvent( settingsResult );\n\n        executionRequestPopulator.populateFromSettings( cliRequest.request, settingsResult.getEffectiveSettings() );\n\n        if ( !settingsResult.getProblems().isEmpty() && slf4jLogger.isWarnEnabled() )\n        {\n            slf4jLogger.warn( \"\" );\n            slf4jLogger.warn( \"Some problems were encountered while building the effective settings\" );\n\n            for ( SettingsProblem problem : settingsResult.getProblems() )\n            {\n                slf4jLogger.warn( problem.getMessage() + \" @ \" + problem.getLocation() );\n            }\n\n            slf4jLogger.warn( \"\" );\n        }\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"private void commands( CliRequest cliRequest )\n    {\n        if ( cliRequest.showErrors )\n        {\n            logger.info( \"Error stacktraces are turned on.\" );\n        }\n\n        if ( MavenExecutionRequest.CHECKSUM_POLICY_WARN.equals( cliRequest.request.getGlobalChecksumPolicy() ) )\n        {\n            logger.info( \"Disabling strict checksum verification on all artifact downloads.\" );\n        }\n        else if ( MavenExecutionRequest.CHECKSUM_POLICY_FAIL.equals( cliRequest.request.getGlobalChecksumPolicy() ) )\n        {\n            logger.info( \"Enabling strict checksum verification on all artifact downloads.\" );\n        }\n    }","id":92230,"modified_method":"private void commands( CliRequest cliRequest )\n    {\n        if ( cliRequest.showErrors )\n        {\n            slf4jLogger.info( \"Error stacktraces are turned on.\" );\n        }\n\n        if ( MavenExecutionRequest.CHECKSUM_POLICY_WARN.equals( cliRequest.request.getGlobalChecksumPolicy() ) )\n        {\n            slf4jLogger.info( \"Disabling strict checksum verification on all artifact downloads.\" );\n        }\n        else if ( MavenExecutionRequest.CHECKSUM_POLICY_FAIL.equals( cliRequest.request.getGlobalChecksumPolicy() ) )\n        {\n            slf4jLogger.info( \"Enabling strict checksum verification on all artifact downloads.\" );\n        }\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"private PlexusContainer container( CliRequest cliRequest )\n        throws Exception\n    {\n        if ( cliRequest.classWorld == null )\n        {\n            cliRequest.classWorld = new ClassWorld( \"plexus.core\", Thread.currentThread().getContextClassLoader() );\n        }\n\n        DefaultPlexusContainer container = this.container;\n\n        if ( container == null )\n        {\n            logger = setupLogger( cliRequest );\n\n            final MavenLoggerManager loggerManager = new MavenLoggerManager( logger ) ;\n\n            ContainerConfiguration cc = new DefaultContainerConfiguration()\n                .setClassWorld( cliRequest.classWorld )\n                .setRealm( setupContainerRealm( cliRequest ) )\n                .setClassPathScanning( PlexusConstants.SCANNING_INDEX )\n                .setAutoWiring( true )\n                .setName( \"maven\" );\n\n            container = new DefaultPlexusContainer( cc, new AbstractModule()\n            {\n\n                protected void configure()\n                {\n                    bind( ILoggerFactory.class ).toInstance( new PlexusLoggerFactory( loggerManager ) );\n                }\n\n            } );\n\n            // NOTE: To avoid inconsistencies, we'll use the TCCL exclusively for lookups\n            container.setLookupRealm( null );\n\n            container.setLoggerManager( loggerManager );\n\n            customizeContainer( container );\n\n            if ( cliRequest.classWorld == classWorld )\n            {\n                this.container = container;\n            }\n        }\n\n        container.getLoggerManager().setThresholds( cliRequest.request.getLoggingLevel() );\n\n        Thread.currentThread().setContextClassLoader( container.getContainerRealm() );\n\n        eventSpyDispatcher = container.lookup( EventSpyDispatcher.class );\n\n        DefaultEventSpyContext eventSpyContext = new DefaultEventSpyContext();\n        Map<String, Object> data = eventSpyContext.getData();\n        data.put( \"plexus\", container );\n        data.put( \"workingDirectory\", cliRequest.workingDirectory );\n        data.put( \"systemProperties\", cliRequest.systemProperties );\n        data.put( \"userProperties\", cliRequest.userProperties );\n        data.put( \"versionProperties\", CLIReportingUtils.getBuildProperties() );\n        eventSpyDispatcher.init( eventSpyContext );\n\n        // refresh logger in case container got customized by spy\n        logger = container.getLoggerManager().getLoggerForComponent( MavenCli.class.getName(), null );\n\n        maven = container.lookup( Maven.class );\n\n        executionRequestPopulator = container.lookup( MavenExecutionRequestPopulator.class );\n\n        modelProcessor = createModelProcessor( container );\n\n        settingsBuilder = container.lookup( SettingsBuilder.class );\n\n        dispatcher = (DefaultSecDispatcher) container.lookup( SecDispatcher.class, \"maven\" );\n\n        return container;\n    }","id":92231,"modified_method":"private PlexusContainer container( CliRequest cliRequest )\n        throws Exception\n    {\n        if ( cliRequest.classWorld == null )\n        {\n            cliRequest.classWorld = new ClassWorld( \"plexus.core\", Thread.currentThread().getContextClassLoader() );\n        }\n\n        DefaultPlexusContainer container = this.container;\n\n        if ( container == null )\n        {\n            ContainerConfiguration cc = new DefaultContainerConfiguration()\n                .setClassWorld( cliRequest.classWorld )\n                .setRealm( setupContainerRealm( cliRequest ) )\n                .setClassPathScanning( PlexusConstants.SCANNING_INDEX )\n                .setAutoWiring( true )\n                .setName( \"maven\" );\n\n            container = new DefaultPlexusContainer( cc, new AbstractModule()\n            {\n\n                protected void configure()\n                {\n                    bind( ILoggerFactory.class ).toInstance( slf4jLoggerFactory );\n                }\n\n            } );\n\n            // NOTE: To avoid inconsistencies, we'll use the TCCL exclusively for lookups\n            container.setLookupRealm( null );\n\n            container.setLoggerManager( plexusLoggerManager );\n\n            customizeContainer( container );\n\n            if ( cliRequest.classWorld == classWorld )\n            {\n                this.container = container;\n            }\n        }\n\n        container.getLoggerManager().setThresholds( cliRequest.request.getLoggingLevel() );\n\n        Thread.currentThread().setContextClassLoader( container.getContainerRealm() );\n\n        eventSpyDispatcher = container.lookup( EventSpyDispatcher.class );\n\n        DefaultEventSpyContext eventSpyContext = new DefaultEventSpyContext();\n        Map<String, Object> data = eventSpyContext.getData();\n        data.put( \"plexus\", container );\n        data.put( \"workingDirectory\", cliRequest.workingDirectory );\n        data.put( \"systemProperties\", cliRequest.systemProperties );\n        data.put( \"userProperties\", cliRequest.userProperties );\n        data.put( \"versionProperties\", CLIReportingUtils.getBuildProperties() );\n        eventSpyDispatcher.init( eventSpyContext );\n\n        // refresh logger in case container got customized by spy\n        slf4jLogger = slf4jLoggerFactory.getLogger(this.getClass().getName());\n\n        maven = container.lookup( Maven.class );\n\n        executionRequestPopulator = container.lookup( MavenExecutionRequestPopulator.class );\n\n        modelProcessor = createModelProcessor( container );\n\n        settingsBuilder = container.lookup( SettingsBuilder.class );\n\n        dispatcher = (DefaultSecDispatcher) container.lookup( SecDispatcher.class, \"maven\" );\n\n        return container;\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"private void cli( CliRequest cliRequest )\n        throws Exception\n    {\n        CLIManager cliManager = new CLIManager();\n\n        try\n        {\n            cliRequest.commandLine = cliManager.parse( cliRequest.args );\n        }\n        catch ( ParseException e )\n        {\n            System.err.println( \"Unable to parse command line options: \" + e.getMessage() );\n            cliManager.displayHelp( System.out );\n            throw e;\n        }\n\n        // TODO: these should be moved out of here. Wrong place.\n        //\n        if ( cliRequest.commandLine.hasOption( CLIManager.HELP ) )\n        {\n            cliManager.displayHelp( System.out );\n            throw new ExitException( 0 );\n        }\n\n        if ( cliRequest.commandLine.hasOption( CLIManager.VERSION ) )\n        {\n            CLIReportingUtils.showVersion( System.out );\n            throw new ExitException( 0 );\n        }\n    }","id":92232,"modified_method":"private void cli( CliRequest cliRequest )\n        throws Exception\n    {\n        CLIManager cliManager = new CLIManager();\n\n        try\n        {\n            cliRequest.commandLine = cliManager.parse( cliRequest.args );\n        }\n        catch ( ParseException e )\n        {\n            System.err.println( \"Unable to parse command line options: \" + e.getMessage() );\n            cliManager.displayHelp( System.out );\n            throw e;\n        }\n\n        if ( cliRequest.commandLine.hasOption( CLIManager.HELP ) )\n        {\n            cliManager.displayHelp( System.out );\n            throw new ExitException( 0 );\n        }\n\n        if ( cliRequest.commandLine.hasOption( CLIManager.VERSION ) )\n        {\n            System.out.println(CLIReportingUtils.showVersion());\n            throw new ExitException( 0 );\n        }\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"private int execute( CliRequest cliRequest )\n    {\n        eventSpyDispatcher.onEvent( cliRequest.request );\n\n        MavenExecutionResult result = maven.execute( cliRequest.request );\n\n        eventSpyDispatcher.onEvent( result );\n\n        eventSpyDispatcher.close();\n\n        if ( result.hasExceptions() )\n        {\n            ExceptionHandler handler = new DefaultExceptionHandler();\n\n            Map<String, String> references = new LinkedHashMap<String, String>();\n\n            MavenProject project = null;\n\n            for ( Throwable exception : result.getExceptions() )\n            {\n                ExceptionSummary summary = handler.handleException( exception );\n\n                logSummary( summary, references, \"\", cliRequest.showErrors );\n\n                if ( project == null && exception instanceof LifecycleExecutionException )\n                {\n                    project = ( (LifecycleExecutionException) exception ).getProject();\n                }\n            }\n\n            logger.error( \"\" );\n\n            if ( !cliRequest.showErrors )\n            {\n                logger.error( \"To see the full stack trace of the errors, re-run Maven with the -e switch.\" );\n            }\n            if ( !logger.isDebugEnabled() )\n            {\n                logger.error( \"Re-run Maven using the -X switch to enable full debug logging.\" );\n            }\n\n            if ( !references.isEmpty() )\n            {\n                logger.error( \"\" );\n                logger.error( \"For more information about the errors and possible solutions\"\n                              + \", please read the following articles:\" );\n\n                for ( Map.Entry<String, String> entry : references.entrySet() )\n                {\n                    logger.error( entry.getValue() + \" \" + entry.getKey() );\n                }\n            }\n\n            if ( project != null && !project.equals( result.getTopologicallySortedProjects().get( 0 ) ) )\n            {\n                logger.error( \"\" );\n                logger.error( \"After correcting the problems, you can resume the build with the command\" );\n                logger.error( \"  mvn <goals> -rf :\" + project.getArtifactId() );\n            }\n\n            if ( MavenExecutionRequest.REACTOR_FAIL_NEVER.equals( cliRequest.request.getReactorFailureBehavior() ) )\n            {\n                logger.info( \"Build failures were ignored.\" );\n\n                return 0;\n            }\n            else\n            {\n                return 1;\n            }\n        }\n        else\n        {\n            return 0;\n        }\n    }","id":92233,"modified_method":"private int execute( CliRequest cliRequest )\n    {\n        eventSpyDispatcher.onEvent( cliRequest.request );\n\n        MavenExecutionResult result = maven.execute( cliRequest.request );\n\n        eventSpyDispatcher.onEvent( result );\n\n        eventSpyDispatcher.close();\n\n        if ( result.hasExceptions() )\n        {\n            ExceptionHandler handler = new DefaultExceptionHandler();\n\n            Map<String, String> references = new LinkedHashMap<String, String>();\n\n            MavenProject project = null;\n\n            for ( Throwable exception : result.getExceptions() )\n            {\n                ExceptionSummary summary = handler.handleException( exception );\n\n                logSummary( summary, references, \"\", cliRequest.showErrors );\n\n                if ( project == null && exception instanceof LifecycleExecutionException )\n                {\n                    project = ( (LifecycleExecutionException) exception ).getProject();\n                }\n            }\n\n            slf4jLogger.error( \"\" );\n\n            if ( !cliRequest.showErrors )\n            {\n                slf4jLogger.error( \"To see the full stack trace of the errors, re-run Maven with the -e switch.\" );\n            }\n            if ( !slf4jLogger.isDebugEnabled() )\n            {\n                slf4jLogger.error( \"Re-run Maven using the -X switch to enable full debug logging.\" );\n            }\n\n            if ( !references.isEmpty() )\n            {\n                slf4jLogger.error( \"\" );\n                slf4jLogger.error( \"For more information about the errors and possible solutions\"\n                              + \", please read the following articles:\" );\n\n                for ( Map.Entry<String, String> entry : references.entrySet() )\n                {\n                    slf4jLogger.error( entry.getValue() + \" \" + entry.getKey() );\n                }\n            }\n\n            if ( project != null && !project.equals( result.getTopologicallySortedProjects().get( 0 ) ) )\n            {\n                slf4jLogger.error( \"\" );\n                slf4jLogger.error( \"After correcting the problems, you can resume the build with the command\" );\n                slf4jLogger.error( \"  mvn <goals> -rf :\" + project.getArtifactId() );\n            }\n\n            if ( MavenExecutionRequest.REACTOR_FAIL_NEVER.equals( cliRequest.request.getReactorFailureBehavior() ) )\n            {\n                slf4jLogger.info( \"Build failures were ignored.\" );\n\n                return 0;\n            }\n            else\n            {\n                return 1;\n            }\n        }\n        else\n        {\n            return 0;\n        }\n    }","commit_id":"a23f7cfd10c04da702c7efb299cce6b3499c18ab","url":"https://github.com/apache/maven"},{"original_method":"public void doCheckout(@NotNull final Project project, @Nullable final Listener listener) {\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        FileDocumentManager.getInstance().saveAllDocuments();\n      }\n    });\n\n    final HgCloneDialog dialog = new HgCloneDialog(project);\n    dialog.show();\n    if (!dialog.isOK()) {\n      return;\n    }\n    final VirtualFile destinationParent = LocalFileSystem.getInstance().findFileByIoFile(new File(dialog.getParentDirectory()));\n    if (destinationParent == null) {\n      return;\n    }\n    final String targetDir = destinationParent.getPath() + File.separator + dialog.getDirectoryName();\n\n    final String sourceRepositoryURL = dialog.getSourceRepositoryURL();\n    new Task.Backgroundable(project, HgVcsMessages.message(\"hg4idea.clone.progress\", sourceRepositoryURL), true) {\n      @Override public void run(@NotNull ProgressIndicator indicator) {\n        // clone\n        HgCloneCommand clone = new HgCloneCommand(project);\n        clone.setRepositoryURL(sourceRepositoryURL);\n        clone.setDirectory(targetDir);\n\n        // handle result\n        try {\n          final HgCommandResult myCloneResult = clone.execute();\n          if (myCloneResult == null) {\n            notifyError(\"Clone failed\", \"Clone failed due to unknown error\", project);\n          } else if (myCloneResult.getExitValue() != 0) {\n            notifyError(\"Clone failed\", \"Clone from \" + sourceRepositoryURL + \" failed.<br/><br/>\" + myCloneResult.getRawError(), project);\n          } else {\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              @Override\n              public void run() {\n                if (listener != null) {\n                  listener.directoryCheckedOut(new File(dialog.getParentDirectory(), dialog.getDirectoryName()));\n                  listener.checkoutCompleted();\n                }\n              }\n            });\n          }\n        } finally {\n          cleanupAuthDataFromHgrc(targetDir);\n        }\n      }\n    }.queue();\n\n  }","id":92234,"modified_method":"public void doCheckout(@NotNull final Project project, @Nullable final Listener listener) {\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        FileDocumentManager.getInstance().saveAllDocuments();\n      }\n    });\n\n    final HgCloneDialog dialog = new HgCloneDialog(project);\n    dialog.show();\n    if (!dialog.isOK()) {\n      return;\n    }\n    final VirtualFile destinationParent = LocalFileSystem.getInstance().findFileByIoFile(new File(dialog.getParentDirectory()));\n    if (destinationParent == null) {\n      return;\n    }\n    final String targetDir = destinationParent.getPath() + File.separator + dialog.getDirectoryName();\n\n    final String sourceRepositoryURL = dialog.getSourceRepositoryURL();\n    new Task.Backgroundable(project, HgVcsMessages.message(\"hg4idea.clone.progress\", sourceRepositoryURL), true) {\n      @Override public void run(@NotNull ProgressIndicator indicator) {\n        // clone\n        HgCloneCommand clone = new HgCloneCommand(project);\n        clone.setRepositoryURL(sourceRepositoryURL);\n        clone.setDirectory(targetDir);\n\n        // handle result\n        final HgCommandResult myCloneResult = clone.execute();\n        if (myCloneResult == null) {\n          notifyError(\"Clone failed\", \"Clone failed due to unknown error\", project);\n        } else if (myCloneResult.getExitValue() != 0) {\n          notifyError(\"Clone failed\", \"Clone from \" + sourceRepositoryURL + \" failed.<br/><br/>\" + myCloneResult.getRawError(), project);\n        } else {\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              if (listener != null) {\n                listener.directoryCheckedOut(new File(dialog.getParentDirectory(), dialog.getDirectoryName()));\n                listener.checkoutCompleted();\n              }\n            }\n          });\n        }\n      }\n    }.queue();\n\n  }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public HgCommandResult execute() {\n    final List<String> arguments = new ArrayList<String>(2);\n    arguments.add(repositoryURL);\n    arguments.add(directory);\n    return authenticator.executeCommandAndAuthenticateIfNecessary(project, null, repositoryURL, \"clone\", arguments);\n  }","id":92235,"modified_method":"@Nullable\n  public HgCommandResult execute() {\n    final List<String> arguments = new ArrayList<String>(2);\n    arguments.add(repositoryURL);\n    arguments.add(directory);\n    return HgCommandService.getInstance(project).execute(null, \"clone\", arguments);\n  }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Init components\n   */\n  private void initListeners() {\n    FileChooserDescriptor fcd = new FileChooserDescriptor(false, true, false, false, false, false);\n    fcd.setShowFileSystemRoots(true);\n    fcd.setTitle(HgVcsMessages.message(\"hg4idea.clone.parent.directory.title\"));\n    fcd.setDescription(HgVcsMessages.message(\"hg4idea.clone.parent.directory.description\"));\n    fcd.setHideIgnored(false);\n    parentDirectory.addActionListener(\n      new ComponentWithBrowseButton.BrowseFolderActionListener<JTextField>(fcd.getTitle(), fcd.getDescription(), parentDirectory,\n        project, fcd, TextComponentAccessor.TEXT_FIELD_WHOLE_TEXT) {\n        @Override\n        protected VirtualFile getInitialFile() {\n          // suggest project base directory only if nothing is typed in the component.\n          String text = getComponentText();\n          if (text.length() == 0) {\n            VirtualFile file = project.getBaseDir();\n            if (file != null) {\n              return file;\n            }\n          }\n          return super.getInitialFile();\n        }\n      });\n    final DocumentListener updateOkButtonListener = new DocumentListener() {\n      // update Ok button state depending on the current state of the fields\n      public void insertUpdate(final DocumentEvent e) {\n        updateCloneButton();\n      }\n\n      public void removeUpdate(final DocumentEvent e) {\n        updateCloneButton();\n      }\n\n      public void changedUpdate(final DocumentEvent e) {\n        updateCloneButton();\n      }\n    };\n    parentDirectory.getChildComponent().getDocument().addDocumentListener(updateOkButtonListener);\n    directoryName.getDocument().addDocumentListener(updateOkButtonListener);\n    repositoryURL.getDocument().addDocumentListener(new DocumentListener() {\n      // enable test button only if something is entered in repository URL\n      public void insertUpdate(final DocumentEvent e) {\n        changed();\n      }\n\n      public void removeUpdate(final DocumentEvent e) {\n        changed();\n      }\n\n      public void changedUpdate(final DocumentEvent e) {\n        changed();\n      }\n\n      private void changed() {\n        final String url = repositoryURL.getText();\n        testButton.setEnabled(url.length() != 0);\n        if (defaultDirectoryName.equals(directoryName.getText()) || directoryName.getText().length() == 0) {\n          // modify field if it was unmodified or blank\n          defaultDirectoryName = defaultDirectoryName(url);\n          directoryName.setText(defaultDirectoryName);\n        }\n        updateCloneButton();\n      }\n    });\n\n    testButton.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        testURL = repositoryURL.getText();\n        final boolean finished = ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n          public void run() {\n            testResult = testRepository(project, testURL);\n          }\n        }, HgVcsMessages.message(\"hg4idea.clone.test.progress\", testURL), true, project, clonePanel);\n\n        if (!finished) {\n          return;\n        }\n\n        if (testResult) {\n          Messages.showInfoMessage(testButton, HgVcsMessages.message(\"hg4idea.clone.test.success.message\", testURL),\n                                   HgVcsMessages.message(\"hg4idea.clone.test.success\"));\n        }\n        updateCloneButton();\n      }\n    });\n\n    setOKActionEnabled(false);\n  }","id":92236,"modified_method":"/**\n   * Init components\n   */\n  private void initListeners() {\n    FileChooserDescriptor fcd = new FileChooserDescriptor(false, true, false, false, false, false);\n    fcd.setShowFileSystemRoots(true);\n    fcd.setTitle(HgVcsMessages.message(\"hg4idea.clone.parent.directory.title\"));\n    fcd.setDescription(HgVcsMessages.message(\"hg4idea.clone.parent.directory.description\"));\n    fcd.setHideIgnored(false);\n    parentDirectory.addActionListener(\n      new ComponentWithBrowseButton.BrowseFolderActionListener<JTextField>(fcd.getTitle(), fcd.getDescription(), parentDirectory,\n        project, fcd, TextComponentAccessor.TEXT_FIELD_WHOLE_TEXT) {\n        @Override\n        protected VirtualFile getInitialFile() {\n          // suggest project base directory only if nothing is typed in the component.\n          String text = getComponentText();\n          if (text.length() == 0) {\n            VirtualFile file = project.getBaseDir();\n            if (file != null) {\n              return file;\n            }\n          }\n          return super.getInitialFile();\n        }\n      });\n    final DocumentListener updateOkButtonListener = new DocumentListener() {\n      // update Ok button state depending on the current state of the fields\n      public void insertUpdate(final DocumentEvent e) {\n        updateCloneButton();\n      }\n\n      public void removeUpdate(final DocumentEvent e) {\n        updateCloneButton();\n      }\n\n      public void changedUpdate(final DocumentEvent e) {\n        updateCloneButton();\n      }\n    };\n    parentDirectory.getChildComponent().getDocument().addDocumentListener(updateOkButtonListener);\n    directoryName.getDocument().addDocumentListener(updateOkButtonListener);\n    repositoryURL.getDocument().addDocumentListener(new DocumentListener() {\n      // enable test button only if something is entered in repository URL\n      public void insertUpdate(final DocumentEvent e) {\n        changed();\n      }\n\n      public void removeUpdate(final DocumentEvent e) {\n        changed();\n      }\n\n      public void changedUpdate(final DocumentEvent e) {\n        changed();\n      }\n\n      private void changed() {\n        final String url = repositoryURL.getText();\n        testButton.setEnabled(url.length() != 0);\n        if (defaultDirectoryName.equals(directoryName.getText()) || directoryName.getText().length() == 0) {\n          // modify field if it was unmodified or blank\n          defaultDirectoryName = defaultDirectoryName(url);\n          directoryName.setText(defaultDirectoryName);\n        }\n        updateCloneButton();\n      }\n    });\n\n    testButton.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        testURL = repositoryURL.getText();\n        ProgressManager.getInstance().run(new Task.Backgroundable(project,HgVcsMessages.message(\"hg4idea.clone.test.progress\", testURL), true) {\n          @Override\n          public void run(@NotNull ProgressIndicator indicator) {\n            testResult = testRepository(project, testURL);\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              @Override\n              public void run() {\n                if (testResult) {\n                  Messages.showInfoMessage(testButton, HgVcsMessages.message(\"hg4idea.clone.test.success.message\", testURL),\n                                           HgVcsMessages.message(\"hg4idea.clone.test.success\"));\n                }\n                updateCloneButton();\n              }\n            });\n          }\n        });\n      }\n    });\n\n    setOKActionEnabled(false);\n  }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GetPasswordRunnable(Project project, HgUrl hgUrl) {\n      this.hgUrl = hgUrl;\n      this.project = project;\n    }","id":92237,"modified_method":"public GetPasswordRunnable(Project project, String proposedLogin, String uri, String path) {\n      this.myProject = project;\n      this.myProposedLogin = proposedLogin;\n      this.myURL = uri + path;\n    }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String keyForUrlAndLogin(String stringUrl, String login) {\n    return stringUrl + login;\n  }","id":92238,"modified_method":"private static String keyForUrlAndLogin(String stringUrl, String login) {\n    return login + \":\" + stringUrl;\n  }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void run() {\n\n      // get the string representation of the url\n      @Nullable String stringUrl = null;\n      try {\n        stringUrl = hgUrl.asString();\n      }\n      catch (URISyntaxException e) {\n        LOG.warn(\"Couldn't parse hgUrl: [\" + hgUrl + \"]\", e);\n      }\n\n      // find if we've already been here\n      final HgVcs vcs = HgVcs.getInstance(project);\n      if (vcs == null) { return; }\n\n      final HgGlobalSettings hgGlobalSettings = vcs.getGlobalSettings();\n      final Map<String, List<String>> urls = hgGlobalSettings.getRememberedUrls();\n      @Nullable List<String> rememberedLoginsForUrl = urls.get(stringUrl);\n\n      String login = hgUrl.getUsername();\n      if (StringUtils.isBlank(login)) {\n        // find the last used login\n        if (rememberedLoginsForUrl != null && !rememberedLoginsForUrl.isEmpty()) {\n          login = rememberedLoginsForUrl.get(0);\n        }\n      }\n\n      String password = hgUrl.getPassword();\n      if (StringUtils.isBlank(password) && stringUrl != null) {\n        // if we've logged in with this login, search for password\n        final String key = keyForUrlAndLogin(stringUrl, login);\n        try {\n          final PasswordSafeImpl passwordSafe = (PasswordSafeImpl)PasswordSafe.getInstance();\n          password = passwordSafe.getMemoryProvider().getPassword(project, HgCommandAuthenticator.class, key);\n          if (password == null && passwordSafe.getSettings().getProviderType().equals(PasswordSafeSettings.ProviderType.MASTER_PASSWORD)) {\n            password = passwordSafe.getMasterKeyProvider().getPassword(project, HgCommandAuthenticator.class, key);\n          }\n        } catch (PasswordSafeException e) {\n          LOG.info(\"Couldn't get password for key [\" + key + \"]\", e);\n        }\n      }\n\n      // don't show dialog if we can (not forced + both fields are known)\n      if (!myForceShowDialog && !StringUtils.isBlank(password) && !StringUtils.isBlank(login)) {\n        userName = login;\n        myPassword = password;\n        ok = true;\n        return;\n      }\n\n      String url;\n      try {\n        url = hgUrl.asString(false);\n      }\n      catch (URISyntaxException e) {\n        url = null;\n      }\n      final HgUsernamePasswordDialog dialog = new HgUsernamePasswordDialog(project, url, login, password);\n      dialog.show();\n      if (dialog.isOK()) {\n        userName = dialog.getUsername();\n        myPassword = dialog.getPassword();\n        ok = true;\n\n        myRememberPassword = dialog.isRememberPassword();\n        if (stringUrl != null) {\n          myURL = stringUrl;\n        }\n      }\n    }","id":92239,"modified_method":"public void run() {\n\n      // find if we've already been here\n      final HgVcs vcs = HgVcs.getInstance(myProject);\n      if (vcs == null) { return; }\n\n      final HgGlobalSettings hgGlobalSettings = vcs.getGlobalSettings();\n      @Nullable String rememberedLoginsForUrl = null;\n      if (!StringUtils.isBlank(myURL)) {\n        rememberedLoginsForUrl = hgGlobalSettings.getRememberedUserName(myURL);\n      }\n\n      String login = myProposedLogin;\n      if (StringUtils.isBlank(login)) {\n        // find the last used login\n        login = rememberedLoginsForUrl;\n      }\n\n      String password = null;\n      if (!StringUtils.isBlank(login) && myURL != null) {\n        // if we've logged in with this login, search for password\n        final String key = keyForUrlAndLogin(myURL, login);\n        try {\n          final PasswordSafeImpl passwordSafe = (PasswordSafeImpl)PasswordSafe.getInstance();\n          password = passwordSafe.getMemoryProvider().getPassword(myProject, HgCommandAuthenticator.class, key);\n          if (password == null && passwordSafe.getSettings().getProviderType().equals(PasswordSafeSettings.ProviderType.MASTER_PASSWORD)) {\n            password = passwordSafe.getMasterKeyProvider().getPassword(myProject, HgCommandAuthenticator.class, key);\n          }\n        } catch (PasswordSafeException e) {\n          LOG.info(\"Couldn't get password for key [\" + key + \"]\", e);\n        }\n      }\n\n      // don't show dialog if we don't have to (both fields are known)\n      if (!StringUtils.isBlank(password) && !StringUtils.isBlank(login)) {\n        myUserName = login;\n        myPassword = password;\n        ok = true;\n        return;\n      }\n\n      final HgUsernamePasswordDialog dialog = new HgUsernamePasswordDialog(myProject, myURL, login, password);\n      dialog.show();\n      if (dialog.isOK()) {\n        myUserName = dialog.getUsername();\n        myPassword = dialog.getPassword();\n        myRememberPassword = dialog.isRememberPassword();\n        ok = true;\n      }\n    }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getUserName() {\n      return userName;\n    }","id":92240,"modified_method":"public String getUserName() {\n      return myUserName;\n    }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean handleConnection(Socket socket) throws IOException {\n      DataInputStream dataInput = new DataInputStream(socket.getInputStream());\n      final String message = new String(readDataBlock(dataInput));\n      int numOfChoices = dataInput.readInt();\n      final Choice[] choices = new Choice[numOfChoices];\n      for (int i = 0; i < numOfChoices; i++) {\n        String choice = new String(readDataBlock(dataInput));\n        choices[i] = new Choice(choice);\n      }\n      int defaultChoiceInt = dataInput.readInt();\n      final Choice defaultChoice = choices[defaultChoiceInt];\n\n      final int[] index = new int[]{-1};\n      ApplicationManager.getApplication().invokeAndWait(new Runnable() {\n        public void run() {\n          Window parent = ApplicationManager.getApplication().getComponent(Window.class);\n          index[0] = JOptionPane.showOptionDialog(\n            parent,\n            message,\n            \"hg4idea\",\n            JOptionPane.OK_CANCEL_OPTION,\n            JOptionPane.QUESTION_MESSAGE,\n            null,\n            choices,\n            defaultChoice);\n        }\n      }, ModalityState.defaultModalityState());\n\n      int chosen = index[0];\n      DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n      if (chosen == JOptionPane.CLOSED_OPTION) {\n        out.writeInt(-1);\n      } else {\n        out.writeInt(chosen);\n      }\n      return true;\n    }","id":92241,"modified_method":"public boolean handleConnection(Socket socket) throws IOException {\n      DataInputStream dataInput = new DataInputStream(socket.getInputStream());\n      DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n      final String message = new String(readDataBlock(dataInput));\n      int numOfChoices = dataInput.readInt();\n      final Choice[] choices = new Choice[numOfChoices];\n      for (int i = 0; i < numOfChoices; i++) {\n        String choice = new String(readDataBlock(dataInput));\n        choices[i] = new Choice(choice);\n      }\n      int defaultChoiceInt = dataInput.readInt();\n      final Choice defaultChoice = choices[defaultChoiceInt];\n\n      final int[] index = new int[]{-1};\n      try {\n        EventQueue.invokeAndWait(new Runnable() {\n          public void run() {\n            Window parent = ApplicationManager.getApplication().getComponent(Window.class);\n            index[0] = JOptionPane\n              .showOptionDialog(parent, message, \"hg4idea\", JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, choices,\n                                defaultChoice);\n          }\n        });\n        \n        int chosen = index[0];\n        if (chosen == JOptionPane.CLOSED_OPTION) {\n          out.writeInt(-1);\n        } else {\n          out.writeInt(chosen);\n        }\n        return true;\n      }\n      catch (InterruptedException e) {\n        //do nothing\n        return true;\n      }\n      catch (InvocationTargetException e) {\n        //shouldn't happen\n        throw new RuntimeException(e);\n      }\n    }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  HgCommandResult execute(VirtualFile repo, List<String> hgOptions, String operation, List<String> arguments, Charset charset, boolean silent) {\n    if (myProject.isDisposed()) {\n      return null;\n    }\n\n    final List<String> cmdLine = new LinkedList<String>();\n    cmdLine.add(myVcs.getHgExecutable());\n    if (repo != null) {\n      cmdLine.add(\"--repository\");\n      cmdLine.add(repo.getPath());\n    }\n\n    SocketServer promptServer = new SocketServer(new PromptReceiver());\n    WarningReceiver warningReceiver = new WarningReceiver();\n    SocketServer warningServer = new SocketServer(warningReceiver);\n    if (PROMPT_HOOKS_PLUGIN == null) {\n      throw new RuntimeException(\"Could not hook into the prompt mechanism of Mercurial\");\n    }\n    try {\n      int promptPort = promptServer.start();\n      int warningPort = warningServer.start();\n      cmdLine.add(\"--config\");\n      cmdLine.add(\"extensions.hg4ideapromptextension=\" + PROMPT_HOOKS_PLUGIN.getAbsolutePath());\n      cmdLine.add(\"--config\");\n      cmdLine.add(\"hg4ideaprompt.port=\" + promptPort);\n      cmdLine.add(\"--config\");\n      cmdLine.add(\"hg4ideawarn.port=\" + warningPort);\n\n      // Other parts of the plugin count on the availability of the MQ extension, so make sure it is enabled\n      cmdLine.add(\"--config\");\n      cmdLine.add(\"extensions.mq=\");\n    } catch (IOException e) {\n      showError(e);\n      LOG.info(\"IOException during preparing command\", e);\n      return null;\n    }\n    cmdLine.addAll(hgOptions);\n    cmdLine.add(operation);\n    if (arguments != null && arguments.size() != 0) {\n      cmdLine.addAll(arguments);\n    }\n    ShellCommand shellCommand = new ShellCommand(mySettings.isRunViaBash());\n    HgCommandResult result;\n    try {\n      String workingDir = repo != null ? repo.getPath() : null;\n      result = shellCommand.execute(cmdLine, workingDir, charset);\n    } catch (ShellCommandException e) {\n      if (!silent) {\n        if (myValidator.checkExecutableAndNotifyIfNeeded()) {\n          // if the problem was not with invalid executable - show error.\n          showError(e);\n          LOG.info(e.getMessage(), e);\n        }\n      } else {\n        LOG.info(e.getMessage(), e);\n      }\n      return null;\n    } catch (InterruptedException e) { // this may happen during project closing, no need to notify the user.\n      LOG.info(e.getMessage(), e);\n      return null;\n    } finally {\n      promptServer.stop();\n      warningServer.stop();\n    }\n    String warnings = warningReceiver.getWarnings();\n    result.setWarnings(warnings);\n\n    // logging to the Version Control console (without extensions and configs)\n    final String cmdString = String.format(\"%s %s %s\", mySettings.isRunViaBash() ? \"bash -c \" + HgVcs.HG_EXECUTABLE_FILE_NAME : HgVcs.HG_EXECUTABLE_FILE_NAME, operation,\n            StringUtils.join(maskAuthInfoFromUrl(arguments), \" \"));\n    myVcs.showMessageInConsole(cmdString, ConsoleViewContentType.NORMAL_OUTPUT.getAttributes());\n    LOG.info(cmdString);\n    if (!silent) {\n      myVcs.showMessageInConsole(result.getRawOutput(), ConsoleViewContentType.SYSTEM_OUTPUT.getAttributes());\n      LOG.info(result.getRawOutput());\n    }\n    myVcs.showMessageInConsole(result.getRawError(), ConsoleViewContentType.ERROR_OUTPUT.getAttributes());\n    LOG.info(result.getRawError());\n\n    return result;\n  }","id":92242,"modified_method":"@Nullable\n  HgCommandResult execute(final VirtualFile repo, final List<String> hgOptions, final String operation, final List<String> arguments, final Charset charset, final boolean silent) {\n      return executeOffOfEDT(repo, hgOptions, operation, arguments, charset, silent);\n  }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HgCommandService(Project project, HgGlobalSettings settings) {\n    myProject = project;\n    mySettings = settings;\n    if (PROMPT_HOOKS_PLUGIN == null) {\n      PROMPT_HOOKS_PLUGIN = HgUtil.getTemporaryPythonFile(\"prompthooks\");\n    }\n    myVcs = HgVcs.getInstance(myProject);\n    LOG.assertTrue(myVcs != null);\n    myValidator = myVcs.getExecutableValidator();\n  }","id":92243,"modified_method":"public HgCommandService(Project project, HgGlobalSettings settings) {\n    myProject = project;\n    mySettings = settings;\n    if (myPromptHooksExtensionFile == null) {\n      myPromptHooksExtensionFile = HgUtil.getTemporaryPythonFile(\"prompthooks\");\n    }\n    myVcs = HgVcs.getInstance(myProject);\n    LOG.assertTrue(myVcs != null);\n    myValidator = myVcs.getExecutableValidator();\n  }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Adds the information about visited URL.\n   * @param stringUrl String representation of the URL. If null or blank String is passed, nothing is saved.\n   * @param username  Login used to access the URL. If null is passed, a blank String is used.\n   */\n  public void addRememberedUrl(@Nullable String stringUrl, @Nullable String username) {\n    if (StringUtils.isBlank(stringUrl)) {\n      return;\n    }\n    if (username == null) {\n      username = \"\";\n    }\n    List<String> list = myRememberedUrls.get(stringUrl);\n    if (list == null) {\n      list = new LinkedList<String>();\n      myRememberedUrls.put(stringUrl, list);\n    }\n    list.add(username);\n  }","id":92244,"modified_method":"/**\n   * Adds the information about visited URL.\n   * @param stringUrl String representation of the URL. If null or blank String is passed, nothing is saved.\n   * @param username  Login used to access the URL. If null is passed, a blank String is used.\n   */\n  public void addRememberedUrl(@Nullable String stringUrl, @Nullable String username) {\n    if (StringUtils.isBlank(stringUrl)) {\n      return;\n    }\n    if (username == null) {\n      username = \"\";\n    }\n    myRememberedUserNames.put(stringUrl, username);\n  }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public HgCommandResult execute() {\n    final List<String> arguments = new LinkedList<String>();\n    arguments.add(source);\n    return authenticator.executeCommandAndAuthenticateIfNecessary(project, null, source, \"identify\", arguments);\n  }","id":92245,"modified_method":"@Nullable\n  public HgCommandResult execute() {\n    final List<String> arguments = new LinkedList<String>();\n    arguments.add(source);\n    return HgCommandService.getInstance(project).execute(null, \"identify\", arguments);\n  }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HgCommandResult execute() {\n    List<String> arguments = new LinkedList<String>();\n    if (update) {\n      arguments.add(\"--update\");\n    } else if (rebase) {\n      arguments.add(\"--rebase\");\n    }\n\n    if (StringUtils.isNotBlank(revision)) {\n      arguments.add(\"--rev\");\n      arguments.add(revision);\n    }\n\n    arguments.add(source);\n\n    HgCommandResult result = authenticator.executeCommandAndAuthenticateIfNecessary(project, repo, source, \"pull\", arguments, arguments.size()-1);\n\n    project.getMessageBus().syncPublisher(HgVcs.REMOTE_TOPIC).update(project);\n\n    return result;\n  }","id":92246,"modified_method":"public HgCommandResult execute() {\n    List<String> arguments = new LinkedList<String>();\n    if (update) {\n      arguments.add(\"--update\");\n    } else if (rebase) {\n      arguments.add(\"--rebase\");\n    }\n\n    if (StringUtils.isNotBlank(revision)) {\n      arguments.add(\"--rev\");\n      arguments.add(revision);\n    }\n\n    arguments.add(source);\n\n    HgCommandResult result = HgCommandService.getInstance(project).execute(repo, \"pull\", arguments);\n\n    project.getMessageBus().syncPublisher(HgVcs.REMOTE_TOPIC).update(project);\n\n    return result;\n  }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HgCommandResult execute() {\n    final List<String> arguments = new LinkedList<String>();\n    if (StringUtils.isNotBlank(myRevision)) {\n      arguments.add(\"-r\");\n      arguments.add(myRevision);\n    }\n    if (myBranch != null) {\n      arguments.add(\"-b\");\n      arguments.add(myBranch.getName());\n    }\n    if (myForce) {\n      arguments.add(\"-f\");\n    }\n    arguments.add(myDestination);\n\n    final HgCommandResult result = authenticator.executeCommandAndAuthenticateIfNecessary(myProject, myRepo, myDestination, \"push\", arguments, arguments.size()-1);\n    myProject.getMessageBus().syncPublisher(HgVcs.REMOTE_TOPIC).update(myProject);\n    return result;\n  }","id":92247,"modified_method":"public HgCommandResult execute() {\n    final List<String> arguments = new LinkedList<String>();\n    if (StringUtils.isNotBlank(myRevision)) {\n      arguments.add(\"-r\");\n      arguments.add(myRevision);\n    }\n    if (myBranch != null) {\n      arguments.add(\"-b\");\n      arguments.add(myBranch.getName());\n    }\n    if (myForce) {\n      arguments.add(\"-f\");\n    }\n    arguments.add(myDestination);\n\n    final HgCommandResult result = HgCommandService.getInstance(myProject).execute(myRepo, \"push\", arguments);\n    myProject.getMessageBus().syncPublisher(HgVcs.REMOTE_TOPIC).update(myProject);\n    return result;\n  }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected HgCommandResult executeCommand(VirtualFile repo, List<String> args) {\n    String repositoryURL = new HgShowConfigCommand(project).getDefaultPath(repo);\n    HgCommandResult result = new HgCommandAuthenticator().executeCommandAndAuthenticateIfNecessary(project, repo, repositoryURL, command, args, args.size()-1);\n    if (result == HgCommandResult.CANCELLED) {\n      final HgVcs vcs = HgVcs.getInstance(project);\n      Notifications.Bus.notify(new Notification(HgVcs.NOTIFICATION_GROUP_ID, \"Checking for incoming/outgoing changes disabled\",\n                                                \"Authentication is required to check incoming/outgoing changes in \" + repositoryURL +\n                                                \"<br/>You may enable checking for changes <a href='#'>in the Settings<\/a>.\"\n        , NotificationType.ERROR, new NotificationListener() {\n          @Override\n          public void hyperlinkUpdate(@NotNull Notification notification, @NotNull HyperlinkEvent event) {\n            ShowSettingsUtil.getInstance().showSettingsDialog(project, vcs.getConfigurable());\n          }\n        }), project);\n      final HgProjectSettings projectSettings = vcs.getProjectSettings();\n      projectSettings.setCheckIncoming(false);\n      projectSettings.setCheckOutgoing(false);\n    }\n    return result;\n  }","id":92248,"modified_method":"@Override\n  protected HgCommandResult executeCommand(VirtualFile repo, List<String> args) {\n    String repositoryURL = new HgShowConfigCommand(project).getDefaultPath(repo);\n    HgCommandResult result = HgCommandService.getInstance(project).execute(repo, command, args);\n    if (result == HgCommandResult.CANCELLED) {\n      final HgVcs vcs = HgVcs.getInstance(project);\n      Notifications.Bus.notify(new Notification(HgVcs.NOTIFICATION_GROUP_ID, \"Checking for incoming/outgoing changes disabled\",\n                                                \"Authentication is required to check incoming/outgoing changes in \" + repositoryURL +\n                                                \"<br/>You may enable checking for changes <a href='#'>in the Settings<\/a>.\"\n        , NotificationType.ERROR, new NotificationListener() {\n          @Override\n          public void hyperlinkUpdate(@NotNull Notification notification, @NotNull HyperlinkEvent event) {\n            ShowSettingsUtil.getInstance().showSettingsDialog(project, vcs.getConfigurable());\n          }\n        }), project);\n      final HgProjectSettings projectSettings = vcs.getProjectSettings();\n      projectSettings.setCheckIncoming(false);\n      projectSettings.setCheckOutgoing(false);\n    }\n    return result;\n  }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HgUsernamePasswordDialog(Project project, String url, String login, String password) {\n    super(project, false);\n    setTitle(HgVcsMessages.message(\"hgidea.dialog.login.password.required\"));\n    final String desc = (url == null ? null : \"Login to \" + url);\n    authPanel = new AuthenticationPanel(desc, login, password, false);\n    init();\n  }","id":92249,"modified_method":"public HgUsernamePasswordDialog(Project project, String url, String login, String password) {\n    super(project, false);\n    setTitle(HgVcsMessages.message(\"hg4idea.dialog.login.password.required\"));\n    authPanel = new AuthenticationPanel(HgVcsMessages.message(\"hg4idea.dialog.login.description\", url), login, password,\n                                        !StringUtils.isBlank(password));\n    init();\n  }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int start() throws IOException {\n    serverSocket = new ServerSocket(0);\n    int port = serverSocket.getLocalPort();\n\n    String name = \"hg4idea prompt server\";\n    serverThread = new Thread(name) {\n      @Override\n      public void run() {\n        try {\n          boolean _continue = true;\n          while (_continue) {\n            Socket socket = serverSocket.accept();\n            _continue = protocol.handleConnection(socket);\n          }\n        } catch (SocketException e) {\n          //socket was closed, that's OK\n        } catch (IOException e) {\n          throw new RuntimeException(e); //TODO implement catch clause\n        }\n      }\n    };\n    serverThread.start();\n\n    return port;\n  }","id":92250,"modified_method":"public int start() throws IOException {\n    serverSocket = new ServerSocket(0);\n    int port = serverSocket.getLocalPort();\n\n    serverThread = new Thread(\"hg4idea prompt server\") {\n      @Override\n      public void run() {\n        try {\n          boolean _continue = true;\n          while (_continue) {\n            Socket socket = serverSocket.accept();\n            try {\n              _continue = protocol.handleConnection(socket);\n            }\n            finally {\n              socket.close();\n            }\n          }\n        } catch (SocketException e) {\n          //socket was closed, that's OK\n        } catch (IOException e) {\n          throw new RuntimeException(e); //TODO implement catch clause\n        }\n      }\n    };\n    serverThread.start();\n\n    return port;\n  }","commit_id":"246f584ac38b19e91050ec949f60f0f692d0073f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Tries to forward to the configured error page for the current site root if present.<p>\n     * \n     * @param rootPath the resource to be used as error page\n     * \n     * @return <code>true<\/code> if the forward was successful performed, <code>false<\/code> otherwise\n     */\n    public boolean forwardToErrorPage(String rootPath) {\n\n        try {\n\n            // get the site of the the error page resource\n            CmsSite site = OpenCms.getSiteManager().getSiteForRootPath(rootPath);\n\n            // initialize a CMS object for the given resource\n            CmsObject clone = OpenCms.initCmsObject(getCmsObject());\n            clone.getRequestContext().setSiteRoot(site.getSiteRoot());\n            String relPath = clone.getRequestContext().removeSiteRoot(rootPath);\n            clone.getRequestContext().setUri(relPath);\n\n            // create a new flex controller together with its flex request/response\n            // initialized with the context of the error page\n            CmsFlexController ori = CmsFlexController.getController(getRequest());\n            CmsFlexController controller = new CmsFlexController(\n                clone,\n                clone.readResource(relPath),\n                ori.getCmsCache(),\n                getRequest(),\n                getResponse(),\n                false,\n                false);\n            // controller.setForwardMode(true);\n            CmsFlexController.setController(getRequest(), controller);\n            CmsFlexRequest f_req = new CmsFlexRequest(getRequest(), controller);\n            CmsFlexResponse f_res = new CmsFlexResponse(getResponse(), controller, false, false);\n            controller.push(f_req, f_res);\n\n            // send the forward\n            CmsRequestUtil.forwardRequest(\n                OpenCms.getStaticExportManager().getVfsPrefix() + relPath,\n                getRequest(),\n                getResponse());\n\n        } catch (Throwable e) {\n            // something went wrong log the exception and return false \n            LOG.error(e.getMessage(), e);\n            return false;\n        }\n        // return success flag\n        return true;\n    }","id":92251,"modified_method":"/**\n     * Tries to forward to the configured error page for the current site root if present.<p>\n     *\n     * @param rootPath the resource to be used as error page\n     *\n     * @return <code>true<\/code> if the forward was successful performed, <code>false<\/code> otherwise\n     */\n    public boolean forwardToErrorPage(String rootPath) {\n\n        try {\n\n            // get the site of the the error page resource\n            CmsSite site = OpenCms.getSiteManager().getSiteForRootPath(rootPath);\n\n            // initialize a CMS object for the given resource\n            CmsObject clone = OpenCms.initCmsObject(getCmsObject());\n            if (site != null) {\n                clone.getRequestContext().setSiteRoot(site.getSiteRoot());\n            }\n            String relPath = clone.getRequestContext().removeSiteRoot(rootPath);\n            clone.getRequestContext().setUri(relPath);\n\n            // create a new flex controller together with its flex request/response\n            // initialized with the context of the error page\n            CmsFlexController ori = CmsFlexController.getController(getRequest());\n            CmsFlexController controller = new CmsFlexController(\n                clone,\n                clone.readResource(relPath),\n                ori.getCmsCache(),\n                getRequest(),\n                getResponse(),\n                false,\n                false);\n            // controller.setForwardMode(true);\n            CmsFlexController.setController(getRequest(), controller);\n            CmsFlexRequest f_req = new CmsFlexRequest(getRequest(), controller);\n            CmsFlexResponse f_res = new CmsFlexResponse(getResponse(), controller, false, false);\n            controller.push(f_req, f_res);\n\n            // send the forward\n            CmsRequestUtil.forwardRequest(\n                OpenCms.getStaticExportManager().getVfsPrefix() + relPath,\n                getRequest(),\n                getResponse());\n\n        } catch (Throwable e) {\n            // something went wrong log the exception and return false\n            LOG.error(e.getMessage(), e);\n            return false;\n        }\n        // return success flag\n        return true;\n    }","commit_id":"c9f7effdb3ba1e1b4be882a56c6936a3ae3b5f28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentHandler#resolveMapping(org.opencms.file.CmsObject, org.opencms.xml.content.CmsXmlContent, org.opencms.xml.types.I_CmsXmlContentValue)\n     */\n    public void resolveMapping(CmsObject cms, CmsXmlContent content, I_CmsXmlContentValue value) throws CmsException {\n\n        if (!value.isSimpleType()) {\n            // no mappings for a nested schema are possible\n            // note that the sub-elements of the nested schema ARE mapped by the node visitor,\n            // it's just the nested schema value itself that does not support mapping\n            return;\n        }\n\n        // get the original VFS file from the content\n        CmsFile file = content.getFile();\n        if (file == null) {\n            throw new CmsXmlException(Messages.get().container(Messages.ERR_XMLCONTENT_RESOLVE_FILE_NOT_FOUND_0));\n        }\n\n        // get the mapping for the element name        \n        String mapping = getMapping(value.getPath());\n\n        if (CmsStringUtil.isNotEmpty(mapping)) {\n\n            // get root path of the file \n            String rootPath = content.getFile().getRootPath();\n            String storedSiteRoot = cms.getRequestContext().getSiteRoot();\n\n            try {\n                // try / catch to ensure site root is always restored\n                cms.getRequestContext().setSiteRoot(\"/\");\n\n                // read all siblings of the file\n                List siblings = cms.readSiblings(rootPath, CmsResourceFilter.IGNORE_EXPIRATION);\n\n                // for multilanguage mappings, we need to ensure \n                // a) all siblings are handled\n                // b) only the \"right\" locale is mapped to a sibling\n\n                for (int i = (siblings.size() - 1); i >= 0; i--) {\n                    // get filename\n                    String filename = ((CmsResource)siblings.get(i)).getRootPath();\n                    Locale locale = OpenCms.getLocaleManager().getDefaultLocale(cms, filename);\n\n                    if (!locale.equals(value.getLocale())) {\n                        // only map property if the locale fits\n                        continue;\n                    }\n\n                    // get the string value of the current node\n                    String stringValue = value.getStringValue(cms);\n                    if (mapping.startsWith(MAPTO_PROPERTY_LIST) && (value.getIndex() == 0)) {\n\n                        boolean mapToShared;\n                        int prefixLength;\n                        // check which mapping is used (shared or individual)\n                        if (mapping.startsWith(MAPTO_PROPERTY_LIST_SHARED)) {\n                            mapToShared = true;\n                            prefixLength = MAPTO_PROPERTY_LIST_SHARED.length();\n                        } else if (mapping.startsWith(MAPTO_PROPERTY_LIST_INDIVIDUAL)) {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY_LIST_INDIVIDUAL.length();\n                        } else {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY_LIST.length();\n                        }\n\n                        // this is a property list mapping\n                        String property = mapping.substring(prefixLength);\n\n                        String path = CmsXmlUtils.removeXpathIndex(value.getPath());\n                        List values = content.getValues(path, locale);\n                        Iterator j = values.iterator();\n                        StringBuffer result = new StringBuffer(values.size() * 64);\n                        while (j.hasNext()) {\n                            I_CmsXmlContentValue val = (I_CmsXmlContentValue)j.next();\n                            result.append(val.getStringValue(cms));\n                            if (j.hasNext()) {\n                                result.append(CmsProperty.VALUE_LIST_DELIMITER);\n                            }\n                        }\n\n                        CmsProperty p;\n                        if (mapToShared) {\n                            // map to shared value\n                            p = new CmsProperty(property, null, result.toString());\n                        } else {\n                            // map to individual value\n                            p = new CmsProperty(property, result.toString(), null);\n                        }\n                        // write the created list string value in the selected property\n                        cms.writePropertyObject(filename, p);\n                        if (mapToShared) {\n                            // special case: shared mappings must be written only to one sibling, end loop\n                            i = 0;\n                        }\n\n                    } else if (mapping.startsWith(MAPTO_PROPERTY)) {\n\n                        boolean mapToShared;\n                        int prefixLength;\n                        // check which mapping is used (shared or individual)                        \n                        if (mapping.startsWith(MAPTO_PROPERTY_SHARED)) {\n                            mapToShared = true;\n                            prefixLength = MAPTO_PROPERTY_SHARED.length();\n                        } else if (mapping.startsWith(MAPTO_PROPERTY_INDIVIDUAL)) {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY_INDIVIDUAL.length();\n                        } else {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY.length();\n                        }\n\n                        // this is a property mapping\n                        String property = mapping.substring(prefixLength);\n\n                        CmsProperty p;\n                        if (mapToShared) {\n                            // map to shared value\n                            p = new CmsProperty(property, null, stringValue);\n                        } else {\n                            // map to individual value\n                            p = new CmsProperty(property, stringValue, null);\n                        }\n                        // just store the string value in the selected property\n                        cms.writePropertyObject(filename, p);\n                        if (mapToShared) {\n                            // special case: shared mappings must be written only to one sibling, end loop\n                            i = 0;\n                        }\n\n                    } else if (mapping.startsWith(MAPTO_ATTRIBUTE)) {\n\n                        // this is an attribute mapping                        \n                        String attribute = mapping.substring(MAPTO_ATTRIBUTE.length());\n                        switch (ATTRIBUTES.indexOf(attribute)) {\n                            case 0: // date released\n                                long date = 0;\n                                try {\n                                    date = Long.valueOf(stringValue).longValue();\n                                } catch (NumberFormatException e) {\n                                    // ignore, value can be a macro\n                                }\n                                if (date == 0) {\n                                    date = CmsResource.DATE_RELEASED_DEFAULT;\n                                }\n                                file.setDateReleased(date);\n                                break;\n                            case 1: // date expired\n                                date = 0;\n                                try {\n                                    date = Long.valueOf(stringValue).longValue();\n                                } catch (NumberFormatException e) {\n                                    // ignore, value can be a macro\n                                }\n                                if (date == 0) {\n                                    date = CmsResource.DATE_EXPIRED_DEFAULT;\n                                }\n                                file.setDateExpired(date);\n                                break;\n                            default:\n                                // ignore invalid / other mappings                                \n                        }\n                    }\n                }\n\n            } finally {\n                // restore the saved site root\n                cms.getRequestContext().setSiteRoot(storedSiteRoot);\n            }\n        }\n    }","id":92252,"modified_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentHandler#resolveMapping(org.opencms.file.CmsObject, org.opencms.xml.content.CmsXmlContent, org.opencms.xml.types.I_CmsXmlContentValue)\n     */\n    public void resolveMapping(CmsObject cms, CmsXmlContent content, I_CmsXmlContentValue value) throws CmsException {\n\n        if (!value.isSimpleType()) {\n            // no mappings for a nested schema are possible\n            // note that the sub-elements of the nested schema ARE mapped by the node visitor,\n            // it's just the nested schema value itself that does not support mapping\n            return;\n        }\n\n        // get the original VFS file from the content\n        CmsFile file = content.getFile();\n        if (file == null) {\n            throw new CmsXmlException(Messages.get().container(Messages.ERR_XMLCONTENT_RESOLVE_FILE_NOT_FOUND_0));\n        }\n\n        // get the mappings for the element name        \n        String[] mappings = getMappings(value.getPath());\n        if (mappings == null) {\n            // nothing to do if we have no mappings at all\n            return;\n        }\n        // create OpenCms user context initialized with \"/\" as site root to read all siblings\n        CmsObject rootCms = OpenCms.initCmsObject(cms);\n        rootCms.getRequestContext().setSiteRoot(\"/\");\n        // read all siblings of the file\n        List siblings = rootCms.readSiblings(content.getFile().getRootPath(), CmsResourceFilter.IGNORE_EXPIRATION);\n\n        // since 7.0.2 multiple mappings are possible\n        for (int m = mappings.length - 1; m >= 0; m--) {\n\n            // for multiple language mappings, we need to ensure \n            // a) all siblings are handled\n            // b) only the \"right\" locale is mapped to a sibling\n            String mapping = mappings[m];\n            if (CmsStringUtil.isNotEmpty(mapping)) {\n                for (int i = (siblings.size() - 1); i >= 0; i--) {\n                    // get filename\n                    String filename = ((CmsResource)siblings.get(i)).getRootPath();\n                    Locale locale = OpenCms.getLocaleManager().getDefaultLocale(rootCms, filename);\n\n                    if (!locale.equals(value.getLocale())) {\n                        // only map property if the locale fits\n                        continue;\n                    }\n\n                    // get the string value of the current node\n                    String stringValue = value.getStringValue(rootCms);\n                    if (mapping.startsWith(MAPTO_PROPERTY_LIST) && (value.getIndex() == 0)) {\n\n                        boolean mapToShared;\n                        int prefixLength;\n                        // check which mapping is used (shared or individual)\n                        if (mapping.startsWith(MAPTO_PROPERTY_LIST_SHARED)) {\n                            mapToShared = true;\n                            prefixLength = MAPTO_PROPERTY_LIST_SHARED.length();\n                        } else if (mapping.startsWith(MAPTO_PROPERTY_LIST_INDIVIDUAL)) {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY_LIST_INDIVIDUAL.length();\n                        } else {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY_LIST.length();\n                        }\n\n                        // this is a property list mapping\n                        String property = mapping.substring(prefixLength);\n\n                        String path = CmsXmlUtils.removeXpathIndex(value.getPath());\n                        List values = content.getValues(path, locale);\n                        Iterator j = values.iterator();\n                        StringBuffer result = new StringBuffer(values.size() * 64);\n                        while (j.hasNext()) {\n                            I_CmsXmlContentValue val = (I_CmsXmlContentValue)j.next();\n                            result.append(val.getStringValue(rootCms));\n                            if (j.hasNext()) {\n                                result.append(CmsProperty.VALUE_LIST_DELIMITER);\n                            }\n                        }\n\n                        CmsProperty p;\n                        if (mapToShared) {\n                            // map to shared value\n                            p = new CmsProperty(property, null, result.toString());\n                        } else {\n                            // map to individual value\n                            p = new CmsProperty(property, result.toString(), null);\n                        }\n                        // write the created list string value in the selected property\n                        rootCms.writePropertyObject(filename, p);\n                        if (mapToShared) {\n                            // special case: shared mappings must be written only to one sibling, end loop\n                            i = 0;\n                        }\n\n                    } else if (mapping.startsWith(MAPTO_PROPERTY)) {\n\n                        boolean mapToShared;\n                        int prefixLength;\n                        // check which mapping is used (shared or individual)                        \n                        if (mapping.startsWith(MAPTO_PROPERTY_SHARED)) {\n                            mapToShared = true;\n                            prefixLength = MAPTO_PROPERTY_SHARED.length();\n                        } else if (mapping.startsWith(MAPTO_PROPERTY_INDIVIDUAL)) {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY_INDIVIDUAL.length();\n                        } else {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY.length();\n                        }\n\n                        // this is a property mapping\n                        String property = mapping.substring(prefixLength);\n\n                        CmsProperty p;\n                        if (mapToShared) {\n                            // map to shared value\n                            p = new CmsProperty(property, null, stringValue);\n                        } else {\n                            // map to individual value\n                            p = new CmsProperty(property, stringValue, null);\n                        }\n                        // just store the string value in the selected property\n                        rootCms.writePropertyObject(filename, p);\n                        if (mapToShared) {\n                            // special case: shared mappings must be written only to one sibling, end loop\n                            i = 0;\n                        }\n\n                    } else if (mapping.startsWith(MAPTO_ATTRIBUTE)) {\n\n                        // this is an attribute mapping                        \n                        String attribute = mapping.substring(MAPTO_ATTRIBUTE.length());\n                        switch (ATTRIBUTES.indexOf(attribute)) {\n                            case 0: // date released\n                                long date = 0;\n                                try {\n                                    date = Long.valueOf(stringValue).longValue();\n                                } catch (NumberFormatException e) {\n                                    // ignore, value can be a macro\n                                }\n                                if (date == 0) {\n                                    date = CmsResource.DATE_RELEASED_DEFAULT;\n                                }\n                                file.setDateReleased(date);\n                                break;\n                            case 1: // date expired\n                                date = 0;\n                                try {\n                                    date = Long.valueOf(stringValue).longValue();\n                                } catch (NumberFormatException e) {\n                                    // ignore, value can be a macro\n                                }\n                                if (date == 0) {\n                                    date = CmsResource.DATE_EXPIRED_DEFAULT;\n                                }\n                                file.setDateExpired(date);\n                                break;\n                            default:\n                                // ignore invalid / other mappings                                \n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"bcaa79d3c81dc1660a1b185c5e26c34054bce7c4","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds an element mapping.<p>\n     * \n     * @param contentDefinition the XML content definition this XML content handler belongs to\n     * @param elementName the element name to map\n     * @param mapping the mapping to use\n     * \n     * @throws CmsXmlException in case an unknown element name is used\n     */\n    protected void addMapping(CmsXmlContentDefinition contentDefinition, String elementName, String mapping)\n    throws CmsXmlException {\n\n        if (contentDefinition.getSchemaType(elementName) == null) {\n            throw new CmsXmlException(Messages.get().container(\n                Messages.ERR_XMLCONTENT_INVALID_ELEM_MAPPING_1,\n                elementName));\n        }\n\n        // store mappings as xpath to allow better control about what is mapped\n        String xpath = CmsXmlUtils.createXpath(elementName, 1);\n        m_elementMappings.put(xpath, mapping);\n    }","id":92253,"modified_method":"/**\n     * Adds an element mapping.<p>\n     * \n     * @param contentDefinition the XML content definition this XML content handler belongs to\n     * @param elementName the element name to map\n     * @param mapping the mapping to use\n     * \n     * @throws CmsXmlException in case an unknown element name is used\n     */\n    protected void addMapping(CmsXmlContentDefinition contentDefinition, String elementName, String mapping)\n    throws CmsXmlException {\n\n        if (contentDefinition.getSchemaType(elementName) == null) {\n            throw new CmsXmlException(Messages.get().container(\n                Messages.ERR_XMLCONTENT_INVALID_ELEM_MAPPING_1,\n                elementName));\n        }\n\n        // store mappings as xpath to allow better control about what is mapped\n        String xpath = CmsXmlUtils.createXpath(elementName, 1);\n        // since 7.0.2 multiple mappings are possible, so the mappings are stored in an array\n        String[] values = (String[])m_elementMappings.get(xpath);\n        if (values == null) {\n            values = new String[] {mapping};\n        } else {\n            String[] newValues = new String[values.length + 1];\n            System.arraycopy(values, 0, newValues, 0, values.length);\n            newValues[values.length] = mapping;\n            values = newValues;\n        }\n        m_elementMappings.put(xpath, values);\n    }","commit_id":"bcaa79d3c81dc1660a1b185c5e26c34054bce7c4","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Removes property values on resources for non-existing, optional elements.<p>\n     * \n     * @param cms the current users OpenCms context\n     * @param content the XML content to remove the property values for\n     * \n     * @throws CmsException in case of read/write errors accessing the OpenCms VFS\n     */\n    protected void removeEmptyMappings(CmsObject cms, CmsXmlContent content) throws CmsException {\n\n        String rootPath = null;\n        List siblings = null;\n\n        Iterator mappings = m_elementMappings.entrySet().iterator();\n        while (mappings.hasNext()) {\n            Map.Entry e = (Map.Entry)mappings.next();\n            String path = e.getKey().toString();\n            String mapping = e.getValue().toString();\n            if (mapping.startsWith(MAPTO_PROPERTY_LIST) || mapping.startsWith(MAPTO_PROPERTY)) {\n\n                // get root path of the file\n                if (rootPath == null) {\n                    rootPath = content.getFile().getRootPath();\n                }\n\n                String storedSiteRoot = cms.getRequestContext().getSiteRoot();\n                try {\n                    // try / catch to ensure site root is always restored\n                    cms.getRequestContext().setSiteRoot(\"/\");\n\n                    // read all siblings of the file\n                    if (siblings == null) {\n                        siblings = cms.readSiblings(rootPath, CmsResourceFilter.IGNORE_EXPIRATION);\n                    }\n\n                    for (int i = 0; i < siblings.size(); i++) {\n\n                        // get sibline filename and locale\n                        String filename = ((CmsResource)siblings.get(i)).getRootPath();\n                        Locale locale = OpenCms.getLocaleManager().getDefaultLocale(cms, filename);\n\n                        if (!content.hasLocale(locale)) {\n                            // only remove property if the locale fits\n                            continue;\n                        }\n                        if (content.hasValue(path, locale)) {\n                            // value is available, property must be kept\n                            continue;\n                        }\n\n                        String property;\n                        if (mapping.startsWith(MAPTO_PROPERTY_LIST)) {\n                            // this is a property list mapping\n                            property = mapping.substring(MAPTO_PROPERTY_LIST.length());\n                        } else {\n                            // this is a property mapping\n                            property = mapping.substring(MAPTO_PROPERTY.length());\n                        }\n                        // delete the property value for the not existing node\n                        cms.writePropertyObject(filename, new CmsProperty(property, CmsProperty.DELETE_VALUE, null));\n                    }\n\n                } finally {\n                    // restore the saved site root\n                    cms.getRequestContext().setSiteRoot(storedSiteRoot);\n                }\n            }\n        }\n    }","id":92254,"modified_method":"/**\n     * Removes property values on resources for non-existing, optional elements.<p>\n     * \n     * @param cms the current users OpenCms context\n     * @param content the XML content to remove the property values for\n     * \n     * @throws CmsException in case of read/write errors accessing the OpenCms VFS\n     */\n    protected void removeEmptyMappings(CmsObject cms, CmsXmlContent content) throws CmsException {\n\n        List siblings = null;\n        CmsObject rootCms = null;\n\n        Iterator mappings = m_elementMappings.entrySet().iterator();\n        while (mappings.hasNext()) {\n            Map.Entry e = (Map.Entry)mappings.next();\n            String path = String.valueOf(e.getKey());\n            String[] values = (String[])e.getValue();\n            if (values == null) {\n                // nothing to do if we have no mappings at all\n                continue;\n            }\n            if ((siblings == null) || (rootCms == null)) {\n                // create OpenCms user context initialized with \"/\" as site root to read all siblings\n                rootCms = OpenCms.initCmsObject(cms);\n                rootCms.getRequestContext().setSiteRoot(\"/\");\n                siblings = rootCms.readSiblings(content.getFile().getRootPath(), CmsResourceFilter.IGNORE_EXPIRATION);\n            }\n            for (int v = values.length - 1; v >= 0; v--) {\n                String mapping = values[v];\n                if (mapping.startsWith(MAPTO_PROPERTY_LIST) || mapping.startsWith(MAPTO_PROPERTY)) {\n\n                    for (int i = 0; i < siblings.size(); i++) {\n\n                        // get siblings filename and locale\n                        String filename = ((CmsResource)siblings.get(i)).getRootPath();\n                        Locale locale = OpenCms.getLocaleManager().getDefaultLocale(rootCms, filename);\n\n                        if (!content.hasLocale(locale)) {\n                            // only remove property if the locale fits\n                            continue;\n                        }\n                        if (content.hasValue(path, locale)) {\n                            // value is available, property must be kept\n                            continue;\n                        }\n\n                        String property;\n                        if (mapping.startsWith(MAPTO_PROPERTY_LIST)) {\n                            // this is a property list mapping\n                            property = mapping.substring(MAPTO_PROPERTY_LIST.length());\n                        } else {\n                            // this is a property mapping\n                            property = mapping.substring(MAPTO_PROPERTY.length());\n                        }\n                        // delete the property value for the not existing node\n                        rootCms.writePropertyObject(filename, new CmsProperty(property, CmsProperty.DELETE_VALUE, null));\n                    }\n                }\n            }\n        }\n    }","commit_id":"bcaa79d3c81dc1660a1b185c5e26c34054bce7c4","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the mapping defined for the given element xpath.<p>\n     * \n     * @param elementName the element xpath to look up the mapping for\n     * @return the mapping defined for the given element xpath\n     */\n    public String getMapping(String elementName) {\n\n        return (String)m_elementMappings.get(elementName);\n    }","id":92255,"modified_method":"/**\n     * Returns the first mapping defined for the given element xpath.<p>\n     * \n     * Since OpenCms version 7.0.2, multiple mappings for an element are possible, so \n     * use {@link #getMapping(String)} instead.<p>\n     * \n     * @param elementName the element xpath to look up the mapping for\n     * \n     * @return the mapping defined for the given element xpath\n     * \n     * @deprecated use {@link #getMappings(String)} instead to recieve all mappings\n     */\n    public String getMapping(String elementName) {\n\n        String[] mappings = getMappings(elementName);\n        return (mappings == null) ? null : mappings[0];\n    }","commit_id":"bcaa79d3c81dc1660a1b185c5e26c34054bce7c4","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Tests the element mappings from the appinfo node.<p>\n     * \n     * @throws Exception in case something goes wrong\n     */\n    public void testMappings() throws Exception {\n\n        CmsObject cms = getCmsObject();\n        echo(\"Testing mapping of values in the XML content\");\n\n        CmsXmlEntityResolver resolver = new CmsXmlEntityResolver(cms);\n\n        String content;\n        CmsXmlContent xmlcontent;\n\n        // unmarshal content definition\n        content = CmsFileUtil.readFile(\"org/opencms/xml/content/xmlcontent-definition-8.xsd\", CmsEncoder.ENCODING_UTF_8);\n        // store content definition in entitiy resolver\n        CmsXmlEntityResolver.cacheSystemId(SCHEMA_SYSTEM_ID_8, content.getBytes(CmsEncoder.ENCODING_ISO_8859_1));\n\n        // now read the XML content\n        content = CmsFileUtil.readFile(\"org/opencms/xml/content/xmlcontent-8.xml\", CmsEncoder.ENCODING_ISO_8859_1);\n        xmlcontent = CmsXmlContentFactory.unmarshal(content, CmsEncoder.ENCODING_ISO_8859_1, resolver);\n        // validate the XML structure\n        xmlcontent.validateXmlStructure(resolver);\n\n        String resourcename = \"/mappingtext.html\";\n        // create a file in the VFS with this content (required for mappings to work)\n        cms.createResource(\n            resourcename,\n            OpenCms.getResourceManager().getResourceType(\"xmlcontent\").getTypeId(),\n            content.getBytes(CmsEncoder.ENCODING_ISO_8859_1),\n            Collections.EMPTY_LIST);\n\n        CmsFile file = cms.readFile(resourcename);\n        xmlcontent = CmsXmlContentFactory.unmarshal(cms, file);\n\n        CmsProperty titleProperty = cms.readPropertyObject(resourcename, CmsPropertyDefinition.PROPERTY_TITLE, false);\n        assertSame(titleProperty, CmsProperty.getNullProperty());\n\n        CmsProperty localeProperty = cms.readPropertyObject(resourcename, CmsPropertyDefinition.PROPERTY_LOCALE, false);\n        assertSame(localeProperty, CmsProperty.getNullProperty());\n\n        CmsProperty navImageProperty = cms.readPropertyObject(\n            resourcename,\n            CmsPropertyDefinition.PROPERTY_NAVIMAGE,\n            false);\n        assertSame(navImageProperty, CmsProperty.getNullProperty());\n\n        CmsProperty navInfoProperty = cms.readPropertyObject(\n            resourcename,\n            CmsPropertyDefinition.PROPERTY_NAVINFO,\n            false);\n        assertSame(navInfoProperty, CmsProperty.getNullProperty());\n\n        String titleStr = \"This must be the Title\";\n        String navImageStr = \"This is the String with xpath String[2]\";\n        String navInfoStr = \"Here we have the String with xpath String[3]\";\n\n        I_CmsXmlContentValue value;\n        value = xmlcontent.addValue(cms, \"String\", Locale.ENGLISH, 0);\n        value.setStringValue(cms, titleStr);\n\n        // set values for Title[2] and Title[3]\n        CmsXmlContentValueSequence seq = xmlcontent.getValueSequence(\"String\", Locale.ENGLISH);\n        assertEquals(1, seq.getElementCount());\n        value = seq.addValue(cms, 1);\n        value.setStringValue(cms, navImageStr);\n        value = seq.addValue(cms, 2);\n        value.setStringValue(cms, navInfoStr);\n\n        String localeStr = \"en\";\n        value = xmlcontent.addValue(cms, \"Locale\", Locale.ENGLISH, 0);\n        value.setStringValue(cms, localeStr);\n\n        file.setContents(xmlcontent.toString().getBytes(CmsEncoder.ENCODING_ISO_8859_1));\n        cms.writeFile(file);\n\n        titleProperty = cms.readPropertyObject(resourcename, CmsPropertyDefinition.PROPERTY_TITLE, false);\n        assertEquals(titleStr, titleProperty.getValue());\n        assertEquals(titleStr, titleProperty.getStructureValue());\n        assertNull(titleProperty.getResourceValue());\n\n        navImageProperty = cms.readPropertyObject(resourcename, CmsPropertyDefinition.PROPERTY_NAVIMAGE, false);\n        assertEquals(navImageStr, navImageProperty.getValue());\n        assertEquals(navImageStr, navImageProperty.getResourceValue());\n        assertNull(navImageProperty.getStructureValue());\n\n        navInfoProperty = cms.readPropertyObject(resourcename, CmsPropertyDefinition.PROPERTY_NAVINFO, false);\n        assertEquals(navInfoStr, navInfoProperty.getValue());\n        assertEquals(navInfoStr, navInfoProperty.getStructureValue());\n        assertNull(navInfoProperty.getResourceValue());\n\n        localeProperty = cms.readPropertyObject(resourcename, CmsPropertyDefinition.PROPERTY_LOCALE, false);\n        assertEquals(localeStr, localeProperty.getValue());\n        assertEquals(localeStr, localeProperty.getResourceValue());\n        assertNull(localeProperty.getStructureValue());\n    }","id":92256,"modified_method":"/**\n     * Tests the element mappings from the appinfo node.<p>\n     * \n     * @throws Exception in case something goes wrong\n     */\n    public void testMappings() throws Exception {\n\n        CmsObject cms = getCmsObject();\n        echo(\"Testing mapping of values in the XML content\");\n\n        CmsXmlEntityResolver resolver = new CmsXmlEntityResolver(cms);\n\n        String content;\n        CmsXmlContent xmlcontent;\n\n        // unmarshal content definition\n        content = CmsFileUtil.readFile(\"org/opencms/xml/content/xmlcontent-definition-8.xsd\", CmsEncoder.ENCODING_UTF_8);\n        // store content definition in entitiy resolver\n        CmsXmlEntityResolver.cacheSystemId(SCHEMA_SYSTEM_ID_8, content.getBytes(CmsEncoder.ENCODING_ISO_8859_1));\n\n        // now read the XML content\n        content = CmsFileUtil.readFile(\"org/opencms/xml/content/xmlcontent-8.xml\", CmsEncoder.ENCODING_ISO_8859_1);\n        xmlcontent = CmsXmlContentFactory.unmarshal(content, CmsEncoder.ENCODING_ISO_8859_1, resolver);\n        // validate the XML structure\n        xmlcontent.validateXmlStructure(resolver);\n\n        String resourcename = \"/mappingtext.html\";\n        // create a file in the VFS with this content (required for mappings to work)\n        cms.createResource(\n            resourcename,\n            OpenCms.getResourceManager().getResourceType(\"xmlcontent\").getTypeId(),\n            content.getBytes(CmsEncoder.ENCODING_ISO_8859_1),\n            Collections.EMPTY_LIST);\n\n        CmsFile file = cms.readFile(resourcename);\n        xmlcontent = CmsXmlContentFactory.unmarshal(cms, file);\n\n        CmsProperty titleProperty = cms.readPropertyObject(resourcename, CmsPropertyDefinition.PROPERTY_TITLE, false);\n        assertSame(titleProperty, CmsProperty.getNullProperty());\n\n        CmsProperty localeProperty = cms.readPropertyObject(resourcename, CmsPropertyDefinition.PROPERTY_LOCALE, false);\n        assertSame(localeProperty, CmsProperty.getNullProperty());\n\n        CmsProperty navImageProperty = cms.readPropertyObject(\n            resourcename,\n            CmsPropertyDefinition.PROPERTY_NAVIMAGE,\n            false);\n        assertSame(navImageProperty, CmsProperty.getNullProperty());\n\n        CmsProperty navInfoProperty = cms.readPropertyObject(\n            resourcename,\n            CmsPropertyDefinition.PROPERTY_NAVINFO,\n            false);\n        assertSame(navInfoProperty, CmsProperty.getNullProperty());\n\n        String titleStr = \"This must be the Title\";\n        String navImageStr = \"This is the String with xpath String[2]\";\n        String navInfoStr = \"Here we have the String with xpath String[3]\";\n\n        I_CmsXmlContentValue value;\n        value = xmlcontent.addValue(cms, \"String\", Locale.ENGLISH, 0);\n        value.setStringValue(cms, titleStr);\n\n        // set values for Title[2] and Title[3]\n        CmsXmlContentValueSequence seq = xmlcontent.getValueSequence(\"String\", Locale.ENGLISH);\n        assertEquals(1, seq.getElementCount());\n        value = seq.addValue(cms, 1);\n        value.setStringValue(cms, navImageStr);\n        value = seq.addValue(cms, 2);\n        value.setStringValue(cms, navInfoStr);\n\n        String localeStr = \"en\";\n        value = xmlcontent.addValue(cms, \"Locale\", Locale.ENGLISH, 0);\n        value.setStringValue(cms, localeStr);\n\n        file.setContents(xmlcontent.toString().getBytes(CmsEncoder.ENCODING_ISO_8859_1));\n        cms.writeFile(file);\n\n        titleProperty = cms.readPropertyObject(resourcename, CmsPropertyDefinition.PROPERTY_TITLE, false);\n        assertEquals(titleStr, titleProperty.getValue());\n        assertEquals(titleStr, titleProperty.getStructureValue());\n        assertNull(titleProperty.getResourceValue());\n\n        // check multiple mappings\n        CmsProperty myTitleProperty = cms.readPropertyObject(resourcename, \"MyTitle\", false);\n        assertEquals(titleStr, myTitleProperty.getValue());\n        assertEquals(titleStr, myTitleProperty.getStructureValue());\n        assertNull(myTitleProperty.getResourceValue());\n\n        navImageProperty = cms.readPropertyObject(resourcename, CmsPropertyDefinition.PROPERTY_NAVIMAGE, false);\n        assertEquals(navImageStr, navImageProperty.getValue());\n        assertEquals(navImageStr, navImageProperty.getResourceValue());\n        assertNull(navImageProperty.getStructureValue());\n\n        navInfoProperty = cms.readPropertyObject(resourcename, CmsPropertyDefinition.PROPERTY_NAVINFO, false);\n        assertEquals(navInfoStr, navInfoProperty.getValue());\n        assertEquals(navInfoStr, navInfoProperty.getStructureValue());\n        assertNull(navInfoProperty.getResourceValue());\n\n        localeProperty = cms.readPropertyObject(resourcename, CmsPropertyDefinition.PROPERTY_LOCALE, false);\n        assertEquals(localeStr, localeProperty.getValue());\n        assertEquals(localeStr, localeProperty.getResourceValue());\n        assertNull(localeProperty.getStructureValue());\n    }","commit_id":"bcaa79d3c81dc1660a1b185c5e26c34054bce7c4","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public DiscussionTopic getNextTopic(DiscussionTopic topic)\r\n  {\r\n    if (usingHelper)\r\n    {\r\n      if (hasNextTopic(topic))\r\n      {\r\n        return helper.getNextTopic(topic);\r\n      }\r\n      else\r\n      {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // TODO: Needs optimized\r\n    boolean next = false;\r\n    DiscussionForum forum = getForumById(topic.getBaseForum().getId().toString());\r\n    if (forum != null && forum.getTopics() != null) {\r\n        for (Iterator iter = forum.getTopics().iterator(); iter.hasNext();) {\r\n            Topic t = (Topic) iter.next();\r\n            if (next) {\r\n                return (DiscussionTopic) t;\r\n            }\r\n            if (t.getId().equals(topic.getId())) {\r\n                next = true;\r\n            }\r\n        }\r\n    }\r\n    \r\n    // if we get here, there is no next topic\r\n    return null;\r\n  }","id":92257,"modified_method":"public DiscussionTopic getNextTopic(DiscussionTopic topic)\r\n  {\r\n    if (usingHelper)\r\n    {\r\n      if (hasNextTopic(topic))\r\n      {\r\n        return helper.getNextTopic(topic);\r\n      }\r\n      else\r\n      {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // TODO: Needs optimized\r\n    boolean next = false;\r\n    DiscussionForum forum = (DiscussionForum) topic.getBaseForum();\r\n    if (forum != null && forum.getTopics() != null) {\r\n        for (Iterator iter = forum.getTopics().iterator(); iter.hasNext();) {\r\n            Topic t = (Topic) iter.next();\r\n            if (next) {\r\n                return (DiscussionTopic) t;\r\n            }\r\n            if (t.getId().equals(topic.getId())) {\r\n                next = true;\r\n            }\r\n        }\r\n    }\r\n    \r\n    // if we get here, there is no next topic\r\n    return null;\r\n  }","commit_id":"fb8c344a5fca4b5009f54d2104d63f77819f5912","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean hasNextTopic(DiscussionTopic topic)\r\n  {\r\n    if (usingHelper)\r\n    {\r\n      return helper.hasNextTopic(topic);\r\n    }\r\n    \r\n    // TODO: Needs optimized\r\n    boolean next = false;\r\n    DiscussionForum forum = getForumById(topic.getBaseForum().getId().toString());\r\n    if (forum != null && forum.getTopics() != null) {\r\n        for (Iterator iter = forum.getTopics().iterator(); iter.hasNext();) {\r\n            Topic t = (Topic) iter.next();\r\n            if (next) {\r\n                return true;\r\n            }\r\n            if (t.getId().equals(topic.getId())) {\r\n                next = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // if we get here, there is no next topic\r\n    return false;\r\n  }","id":92258,"modified_method":"public boolean hasNextTopic(DiscussionTopic topic)\r\n  {\r\n    if (usingHelper)\r\n    {\r\n      return helper.hasNextTopic(topic);\r\n    }\r\n    \r\n    // TODO: Needs optimized\r\n    boolean next = false;\r\n    DiscussionForum forum = (DiscussionForum) topic.getBaseForum();\r\n    if (forum != null && forum.getTopics() != null) {\r\n        for (Iterator iter = forum.getTopics().iterator(); iter.hasNext();) {\r\n            Topic t = (Topic) iter.next();\r\n            if (next) {\r\n                return true;\r\n            }\r\n            if (t.getId().equals(topic.getId())) {\r\n                next = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // if we get here, there is no next topic\r\n    return false;\r\n  }","commit_id":"fb8c344a5fca4b5009f54d2104d63f77819f5912","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public DiscussionTopic getPreviousTopic(DiscussionTopic topic)\r\n  {\r\n    if (usingHelper)\r\n    {\r\n      if (hasPreviousTopic(topic))\r\n      {\r\n        return helper.getPreviousTopic(topic);\r\n      }\r\n      else\r\n      {\r\n        return null;\r\n      }\r\n     \r\n    }\r\n    \r\n    // TODO: Needs optimized\r\n    DiscussionTopic prev = null;        \r\n    DiscussionForum forum = getForumById(topic.getBaseForum().getId().toString());\r\n    if (forum != null && forum.getTopics() != null) {\r\n        for (Iterator iter = forum.getTopics().iterator(); iter.hasNext();) {\r\n        Topic t = (Topic) iter.next();\r\n            if (t.getId().equals(topic.getId())) {\r\n                return prev;\r\n            }\r\n            prev = (DiscussionTopic) t;\r\n        }\r\n    }\r\n        \r\n    // if we get here, there is no previous topic\r\n    return null;\r\n  }","id":92259,"modified_method":"public DiscussionTopic getPreviousTopic(DiscussionTopic topic)\r\n  {\r\n    if (usingHelper)\r\n    {\r\n      if (hasPreviousTopic(topic))\r\n      {\r\n        return helper.getPreviousTopic(topic);\r\n      }\r\n      else\r\n      {\r\n        return null;\r\n      }\r\n     \r\n    }\r\n    \r\n    // TODO: Needs optimized\r\n    DiscussionTopic prev = null;        \r\n    DiscussionForum forum = (DiscussionForum) topic.getBaseForum();\r\n    if (forum != null && forum.getTopics() != null) {\r\n        for (Iterator iter = forum.getTopics().iterator(); iter.hasNext();) {\r\n        Topic t = (Topic) iter.next();\r\n            if (t.getId().equals(topic.getId())) {\r\n                return prev;\r\n            }\r\n            prev = (DiscussionTopic) t;\r\n        }\r\n    }\r\n        \r\n    // if we get here, there is no previous topic\r\n    return null;\r\n  }","commit_id":"fb8c344a5fca4b5009f54d2104d63f77819f5912","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean hasPreviousTopic(DiscussionTopic topic)\r\n  {\r\n    if (usingHelper)\r\n    {\r\n      return helper.hasPreviousTopic(topic);\r\n    }\r\n\r\n    // TODO: Needs optimized\r\n    DiscussionTopic prev = null;        \r\n    DiscussionForum forum = getForumById(topic.getBaseForum().getId().toString());\r\n    if (forum != null && forum.getTopics() != null) {\r\n        for (Iterator iter = forum.getTopics().iterator(); iter.hasNext();) {\r\n        Topic t = (Topic) iter.next();\r\n            if (t.getId().equals(topic.getId())) {\r\n                // need to check null because we might be on the first topic\r\n                // which means there is no previous one\r\n                return prev != null;\r\n            }\r\n            prev = (DiscussionTopic) t;\r\n        }\r\n    }\r\n        \r\n    // if we get here, there is no previous topic\r\n    return false;\r\n  }","id":92260,"modified_method":"public boolean hasPreviousTopic(DiscussionTopic topic)\r\n  {\r\n    if (usingHelper)\r\n    {\r\n      return helper.hasPreviousTopic(topic);\r\n    }\r\n\r\n    // TODO: Needs optimized\r\n    DiscussionTopic prev = null;        \r\n    DiscussionForum forum = (DiscussionForum) topic.getBaseForum();\r\n    if (forum != null && forum.getTopics() != null) {\r\n        for (Iterator iter = forum.getTopics().iterator(); iter.hasNext();) {\r\n        Topic t = (Topic) iter.next();\r\n            if (t.getId().equals(topic.getId())) {\r\n                // need to check null because we might be on the first topic\r\n                // which means there is no previous one\r\n                return prev != null;\r\n            }\r\n            prev = (DiscussionTopic) t;\r\n        }\r\n    }\r\n        \r\n    // if we get here, there is no previous topic\r\n    return false;\r\n  }","commit_id":"fb8c344a5fca4b5009f54d2104d63f77819f5912","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public Api_PluginInitializer() {\n    PluginUtil.addStandaloneAppPlugin(new Api_ApplicationPlugin());\n    PluginUtil.addStandaloneProjPlugin(new Api_ProjectPlugin());\n  }","id":92261,"modified_method":"public Api_PluginInitializer() {\n    PluginUtil.addPluginContributor(new PluginContributor() {\n      public BaseApplicationPlugin createApplicationPlugin() {\n        return new Api_ApplicationPlugin();\n      }\n\n      public BaseProjectPlugin createProjectPlugin() {\n        return new Api_ProjectPlugin();\n      }\n    });\n  }","commit_id":"d1beb639c4e0e257f71d762c45fd2180f378fce1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Editor_PluginInitializer() {\n    PluginUtil.addStandaloneAppPlugin(new Editor_ApplicationPlugin());\n    PluginUtil.addStandaloneProjPlugin(new Editor_ProjectPlugin());\n  }","id":92262,"modified_method":"public Editor_PluginInitializer() {\n    PluginUtil.addPluginContributor(new PluginContributor() {\n      public BaseApplicationPlugin createApplicationPlugin() {\n        return new Editor_ApplicationPlugin();\n      }\n\n      public BaseProjectPlugin createProjectPlugin() {\n        return new Editor_ProjectPlugin();\n      }\n    });\n  }","commit_id":"d1beb639c4e0e257f71d762c45fd2180f378fce1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Ide_PluginInitializer() {\n    PluginUtil.addStandaloneAppPlugin(new Ide_ApplicationPlugin());\n    PluginUtil.addStandaloneProjPlugin(new Ide_ProjectPlugin());\n  }","id":92263,"modified_method":"public Ide_PluginInitializer() {\n    PluginUtil.addPluginContributor(new PluginContributor() {\n      public BaseApplicationPlugin createApplicationPlugin() {\n        return new Ide_ApplicationPlugin();\n      }\n\n      public BaseProjectPlugin createProjectPlugin() {\n        return new Ide_ProjectPlugin();\n      }\n    });\n  }","commit_id":"d1beb639c4e0e257f71d762c45fd2180f378fce1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Java_PluginInitializer() {\n    PluginUtil.addStandaloneAppPlugin(new Java_ApplicationPlugin());\n    PluginUtil.addStandaloneProjPlugin(new Java_ProjectPlugin());\n  }","id":92264,"modified_method":"public Java_PluginInitializer() {\n    PluginUtil.addPluginContributor(new PluginContributor() {\n      public BaseApplicationPlugin createApplicationPlugin() {\n        return new Java_ApplicationPlugin();\n      }\n\n      public BaseProjectPlugin createProjectPlugin() {\n        return new Java_ProjectPlugin();\n      }\n    });\n  }","commit_id":"d1beb639c4e0e257f71d762c45fd2180f378fce1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Make_PluginInitializer() {\n    PluginUtil.addStandaloneAppPlugin(new Make_ApplicationPlugin());\n    PluginUtil.addStandaloneProjPlugin(new Make_ProjectPlugin());\n  }","id":92265,"modified_method":"public Make_PluginInitializer() {\n    PluginUtil.addPluginContributor(new PluginContributor() {\n      public BaseApplicationPlugin createApplicationPlugin() {\n        return new Make_ApplicationPlugin();\n      }\n\n      public BaseProjectPlugin createProjectPlugin() {\n        return new Make_ProjectPlugin();\n      }\n    });\n  }","commit_id":"d1beb639c4e0e257f71d762c45fd2180f378fce1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Migration_PluginInitializer() {\n    PluginUtil.addStandaloneAppPlugin(new Migration_ApplicationPlugin());\n    PluginUtil.addStandaloneProjPlugin(new Migration_ProjectPlugin());\n  }","id":92266,"modified_method":"public Migration_PluginInitializer() {\n    PluginUtil.addPluginContributor(new PluginContributor() {\n      public BaseApplicationPlugin createApplicationPlugin() {\n        return new Migration_ApplicationPlugin();\n      }\n\n      public BaseProjectPlugin createProjectPlugin() {\n        return new Migration_ProjectPlugin();\n      }\n    });\n  }","commit_id":"d1beb639c4e0e257f71d762c45fd2180f378fce1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Modelchecker_PluginInitializer() {\n    PluginUtil.addStandaloneAppPlugin(new Modelchecker_ApplicationPlugin());\n    PluginUtil.addStandaloneProjPlugin(new Modelchecker_ProjectPlugin());\n  }","id":92267,"modified_method":"public Modelchecker_PluginInitializer() {\n    PluginUtil.addPluginContributor(new PluginContributor() {\n      public BaseApplicationPlugin createApplicationPlugin() {\n        return new Modelchecker_ApplicationPlugin();\n      }\n\n      public BaseProjectPlugin createProjectPlugin() {\n        return new Modelchecker_ProjectPlugin();\n      }\n    });\n  }","commit_id":"d1beb639c4e0e257f71d762c45fd2180f378fce1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Mpsdevkit_PluginInitializer() {\n    PluginUtil.addStandaloneAppPlugin(new Mpsdevkit_ApplicationPlugin());\n    PluginUtil.addStandaloneProjPlugin(new Mpsdevkit_ProjectPlugin());\n  }","id":92268,"modified_method":"public Mpsdevkit_PluginInitializer() {\n    PluginUtil.addPluginContributor(new PluginContributor() {\n      public BaseApplicationPlugin createApplicationPlugin() {\n        return new Mpsdevkit_ApplicationPlugin();\n      }\n\n      public BaseProjectPlugin createProjectPlugin() {\n        return new Mpsdevkit_ProjectPlugin();\n      }\n    });\n  }","commit_id":"d1beb639c4e0e257f71d762c45fd2180f378fce1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Vcs_PluginInitializer() {\n    PluginUtil.addStandaloneAppPlugin(new Vcs_ApplicationPlugin());\n    PluginUtil.addStandaloneProjPlugin(new Vcs_ProjectPlugin());\n  }","id":92269,"modified_method":"public Vcs_PluginInitializer() {\n    PluginUtil.addPluginContributor(new PluginContributor() {\n      public BaseApplicationPlugin createApplicationPlugin() {\n        return new Vcs_ApplicationPlugin();\n      }\n\n      public BaseProjectPlugin createProjectPlugin() {\n        return new Vcs_ProjectPlugin();\n      }\n    });\n  }","commit_id":"d1beb639c4e0e257f71d762c45fd2180f378fce1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public JComponent getPreferredFocusedComponent() {\n      if (myPreferredComponent != null) {\n        if (myPreparePreferredComponent != null) {\n          myPreparePreferredComponent.run();\n        }\n        myPreparePreferredComponent = null;\n        return myPreferredComponent;\n      }\n      return IdeFocusTraversalPolicy.getPreferredFocusedComponent(myTabbedPane.getComponent());\n    }","id":92270,"modified_method":"public JComponent getPreferredFocusedComponent() {\n      if (myPreferredComponent != null) {\n        if (myPreparePreferredComponent != null) {\n          myPreparePreferredComponent.run();\n        }\n        myPreparePreferredComponent = null;\n        return myPreferredComponent;\n      }\n      final TabbedPaneWrapper tabbedPane = myTabbedPane;\n      return tabbedPane != null? IdeFocusTraversalPolicy.getPreferredFocusedComponent(tabbedPane.getComponent()) : null;\n    }","commit_id":"88aa597e908ee9f7486ef5eaae62e99973e4ef32","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JComponent getPreferredFocusedComponent() {\n    return mySpacesPanel.getPreferredFocusedComponent();\n  }","id":92271,"modified_method":"public JComponent getPreferredFocusedComponent() {\n    return mySpacesPanel != null ? mySpacesPanel.getPreferredFocusedComponent() \n                                 : myWrappingPanel.getPreferredFocusedComponent();\n  }","commit_id":"e8bf0282cdf16a1d044c37bc8faae269c41c4d44","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void init() {\n      Collection<String> settingNames = mySettingsToShow.getSettings(getSettingsType());\n      if (settingNames.isEmpty()) {\n        settingNames = mySettingsToShow.getOtherSetting();\n      }\n      \n      initTables();\n\n      Collection<String> fields = populateWithAssociatedFields(settingNames);\n      fields.add(\"KEEP_LINE_BREAKS\");\n\n      String[] names = ContainerUtil.toArray(fields, new String[fields.size()]);\n      showStandardOptions(names);\n\n      myTreeTable = createOptionsTree(getSettings());\n      JBScrollPane scrollPane = new JBScrollPane(myTreeTable) {\n        @Override\n        public Dimension getMinimumSize() {\n          return super.getPreferredSize();\n        }\n      };\n\n      myPanel = new JPanel(new BorderLayout());\n      myPanel.add(scrollPane);\n\n      showStandardOptions(names);\n\n      isFirstUpdate = false;\n    }","id":92272,"modified_method":"@Override\n    protected void init() {\n      Collection<String> settingNames = mySettingsToShow.getSettings(getSettingsType());\n      if (settingNames.isEmpty()) {\n        settingNames = mySettingsToShow.getOtherSetting();\n      }\n      \n      initTables();\n\n      Collection<String> fields = populateWithAssociatedFields(settingNames);\n      fields.add(\"KEEP_LINE_BREAKS\");\n\n      String[] names = ContainerUtil.toArray(fields, new String[fields.size()]);\n      showStandardOptions(names);\n\n      myTreeTable = createOptionsTree(getSettings());\n      JBScrollPane scrollPane = new JBScrollPane(myTreeTable) {\n        @Override\n        public Dimension getMinimumSize() {\n          return myTreeTable.getPreferredSize();\n        }\n      };\n\n      myPanel = new JPanel(new BorderLayout());\n      myPanel.add(scrollPane);\n\n      showStandardOptions(names);\n\n      isFirstUpdate = false;\n    }","commit_id":"e8bf0282cdf16a1d044c37bc8faae269c41c4d44","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void initTabs(CodeStyleSettings settings) {\n    mySpacesPanel = new SpacesPanelWithoutPreview(settings);\n    addTab(mySpacesPanel);\n    addTab(new WrappingAndBracesPanelWithoutPreview(settings));\n    reset(getSettings());\n  }","id":92273,"modified_method":"@Override\n  protected void initTabs(CodeStyleSettings settings) {\n    SpacesPanelWithoutPreview panel = getSpacesPanel(settings);\n    if (panel != null) {\n      mySpacesPanel = panel;\n      addTab(mySpacesPanel);\n    }\n\n    myWrappingPanel = new WrappingAndBracesPanelWithoutPreview(settings);\n    addTab(myWrappingPanel);\n    reset(getSettings());\n  }","commit_id":"e8bf0282cdf16a1d044c37bc8faae269c41c4d44","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private RowResizeAnimator(JTable table, int row, int height, JBTableRowEditor editor) {\n      super(\"Row Animator\");\n      myTable = table;\n      myRow = row;\n      neededHeight = height;\n      myEditor = editor;\n      currentHeight = myTable.getRowHeight(myRow);\n    }","id":92274,"modified_method":"private RowResizeAnimator(JTable table, int row, int height, JBTableRowEditor editor, @NotNull Ref<Integer> index) {\n      super(\"Row Animator\");\n      myTable = table;\n      myRow = row;\n      neededHeight = height;\n      myEditor = editor;\n      myIndex = index;\n      currentHeight = myTable.getRowHeight(myRow);\n    }","commit_id":"8951bc03741e3dbaee44a98322be3cb4bcdc0684","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JBListTable(@NotNull final JTable t) {\n    super(new BorderLayout());\n    myInternalTable = t;\n    final JBListTableModel model = new JBListTableModel(t.getModel()) {\n      @Override\n      public JBTableRow getRow(int index) {\n        return getRowAt(index);\n      }\n\n      @Override\n      public boolean isCellEditable(int rowIndex, int columnIndex) {\n        return isRowEditable(rowIndex);\n      }\n    };\n    mainTable = new JBTable(model) {\n      private MouseEvent myMouseEvent;\n\n      @Override\n      protected void processKeyEvent(KeyEvent e) {\n        myMouseEvent = null;\n        \n        //Mnemonics\n        if (e.isAltDown()) {\n          super.processKeyEvent(e);\n          return;\n        }\n\n        if (e.getKeyCode() == VK_TAB) {\n          if (e.getID() == KEY_PRESSED) {\n            final KeyboardFocusManager keyboardFocusManager = KeyboardFocusManager.getCurrentKeyboardFocusManager();\n            if (e.isShiftDown()) {\n              keyboardFocusManager.focusPreviousComponent(this);\n            } else {\n              keyboardFocusManager.focusNextComponent(this);\n            }\n          }\n          e.consume();\n          return;\n        }\n\n        super.processKeyEvent(e);\n      }\n\n      @Override\n      protected void processMouseEvent(MouseEvent e) {\n        myMouseEvent = e;\n        super.processMouseEvent(e);\n      }\n\n      @Override\n      public TableCellRenderer getCellRenderer(int row, int column) {\n        return new DefaultTableCellRenderer() {\n          @Override\n          public Component getTableCellRendererComponent(JTable table, Object value, boolean selected, boolean hasFocus, int row, int col) {\n            return getRowRenderer(t, row, selected, hasFocus);\n          }\n        };\n      }\n\n      @Override\n      protected boolean processKeyBinding(KeyStroke ks, KeyEvent e, int condition, boolean pressed) {\n        //Mnemonics and actions\n        if (e.isAltDown() || e.isMetaDown() || e.isControlDown()) {\n          return false;\n        }\n\n        if (e.getKeyCode() == VK_ENTER) {\n          if (e.getID() == KEY_PRESSED) {\n            if (!isEditing() && e.getModifiers() == 0) {\n              editCellAt(getSelectedRow(), getSelectedColumn());\n            } else if (isEditing()) {\n              TableUtil.stopEditing(this);\n              if (e.isControlDown() || e.isMetaDown()) {\n                return false;\n              } else {\n                final int row = getSelectedRow() + 1;\n                if (row < getRowCount()) {\n                  getSelectionModel().setSelectionInterval(row, row);\n                }\n              }\n            } else {\n              if (e.isControlDown() || e.isMetaDown()) {\n                return false;\n              }\n            }\n          }\n          e.consume();\n          return true;\n        }\n\n        if (isEditing() && e.getKeyCode() == VK_TAB) {\n          if (pressed) {\n            final KeyboardFocusManager mgr = KeyboardFocusManager.getCurrentKeyboardFocusManager();\n            if (e.isShiftDown()) {\n              mgr.focusPreviousComponent();\n            } else {\n              mgr.focusNextComponent();\n            }\n          }\n          return true;\n        }\n\n        final boolean isUp = e.getKeyCode() == KeyEvent.VK_UP;\n        final boolean isDown = e.getKeyCode() == KeyEvent.VK_DOWN;\n\n        if (isEditing() && (isUp || isDown) && e.getModifiers() == 0 && e.getID() == KEY_PRESSED) {\n          int row = getSelectedRow();\n          super.processKeyBinding(ks, e, condition, pressed);\n          if (!isEditing() && row != getSelectedRow()) {\n            TableUtil.editCellAt(this, getSelectedRow(), 0);\n            e.consume();\n            return true;\n          }\n        }\n\n        return super.processKeyBinding(ks, e, condition, pressed);\n      }\n\n      @Override\n      public TableCellEditor getCellEditor(final int row, int column) {\n        final JBTableRowEditor editor = getRowEditor(row);\n        if (editor != null) {\n          editor.setMouseEvent(myMouseEvent);\n          editor.prepareEditor(t, row);\n          installPaddingAndBordersForEditors(editor);\n          editor.setFocusCycleRoot(true);\n\n          editor.setFocusTraversalPolicy(new JBListTableFocusTraversalPolicy(editor));\n          MouseSuppressor.install(editor);\n\n          return new AbstractTableCellEditor() {\n            JTable curTable = null;\n                @Override\n                public Component getTableCellEditorComponent(final JTable table, Object value, boolean isSelected, final int row, int column) {\n                  curTable = table;\n                  final JPanel p = new JPanel(new BorderLayout()) {\n                    @Override\n                    public void addNotify() {\n                      super.addNotify();\n                      final int height = (int)getPreferredSize().getHeight();\n                      if (height > table.getRowHeight(row)) {\n                        new RowResizeAnimator(table, row, height, editor).start();\n                      }\n                    }\n\n                    public void removeNotify() {\n                      super.removeNotify();\n                      new RowResizeAnimator(table, row, table.getRowHeight(), null).start();\n                    }\n                  };\n                  p.add(editor, BorderLayout.CENTER);\n                  p.setFocusable(false);\n                  return p;\n                }\n          \n                @Override\n                public Object getCellEditorValue() {\n                  return editor.getValue();\n                }};\n        }\n        return null;\n      }\n\n      @Override\n      public Component prepareEditor(TableCellEditor editor, int row, int column) {\n        Object value = getValueAt(row, column);\n        boolean isSelected = isCellSelected(row, column);\n        return editor.getTableCellEditorComponent(this, value, isSelected, row, column);\n      }\n    };\n    mainTable.setStriped(true);\n  }","id":92275,"modified_method":"public JBListTable(@NotNull final JTable t) {\n    super(new BorderLayout());\n    myInternalTable = t;\n    final JBListTableModel model = new JBListTableModel(t.getModel()) {\n      @Override\n      public JBTableRow getRow(int index) {\n        return getRowAt(index);\n      }\n\n      @Override\n      public boolean isCellEditable(int rowIndex, int columnIndex) {\n        return isRowEditable(rowIndex);\n      }\n    };\n    mainTable = new JBTable(model) {\n      private MouseEvent myMouseEvent;      \n\n      @Override\n      protected void processKeyEvent(KeyEvent e) {\n        myMouseEvent = null;\n        \n        //Mnemonics\n        if (e.isAltDown()) {\n          super.processKeyEvent(e);\n          return;\n        }\n\n        if (e.getKeyCode() == VK_TAB) {\n          if (e.getID() == KEY_PRESSED) {\n            final KeyboardFocusManager keyboardFocusManager = KeyboardFocusManager.getCurrentKeyboardFocusManager();\n            if (e.isShiftDown()) {\n              keyboardFocusManager.focusPreviousComponent(this);\n            }\n            else {\n              keyboardFocusManager.focusNextComponent(this);\n            }\n          }\n          e.consume();\n          return;\n        }\n\n        super.processKeyEvent(e);\n      }\n\n      @Override\n      protected void processMouseEvent(MouseEvent e) {\n        myMouseEvent = e;\n        super.processMouseEvent(e);\n      }\n\n      @Override\n      public TableCellRenderer getCellRenderer(int row, int column) {\n        return new DefaultTableCellRenderer() {\n          @Override\n          public Component getTableCellRendererComponent(JTable table, Object value, boolean selected, boolean hasFocus, int row, int col) {\n            return getRowRenderer(t, row, selected, hasFocus);\n          }\n        };\n      }\n\n      @Override\n      protected boolean processKeyBinding(KeyStroke ks, KeyEvent e, int condition, boolean pressed) {\n        //Mnemonics and actions\n        if (e.isAltDown() || e.isMetaDown() || e.isControlDown()) {\n          return false;\n        }\n\n        if (e.getKeyCode() == VK_ENTER) {\n          if (e.getID() == KEY_PRESSED) {\n            if (!isEditing() && e.getModifiers() == 0) {\n              editCellAt(getSelectedRow(), getSelectedColumn());\n            }\n            else if (isEditing()) {\n              TableUtil.stopEditing(this);\n              if (e.isControlDown() || e.isMetaDown()) {\n                return false;\n              }\n              else {\n                final int row = getSelectedRow() + 1;\n                if (row < getRowCount()) {\n                  getSelectionModel().setSelectionInterval(row, row);\n                }\n              }\n            }\n            else {\n              if (e.isControlDown() || e.isMetaDown()) {\n                return false;\n              }\n            }\n          }\n          e.consume();\n          return true;\n        }\n\n        if (isEditing() && e.getKeyCode() == VK_TAB) {\n          if (pressed) {\n            final KeyboardFocusManager mgr = KeyboardFocusManager.getCurrentKeyboardFocusManager();\n            if (e.isShiftDown()) {\n              mgr.focusPreviousComponent();\n            }\n            else {\n              mgr.focusNextComponent();\n            }\n          }\n          return true;\n        }\n\n        final boolean isUp = e.getKeyCode() == KeyEvent.VK_UP;\n        final boolean isDown = e.getKeyCode() == KeyEvent.VK_DOWN;\n\n        if (isEditing() && (isUp || isDown) && e.getModifiers() == 0 && e.getID() == KEY_PRESSED) {\n          int row = getSelectedRow();\n          super.processKeyBinding(ks, e, condition, pressed);\n          if (!isEditing() && row != getSelectedRow()) {\n            TableUtil.editCellAt(this, getSelectedRow(), 0);\n            e.consume();\n            return true;\n          }\n        }\n\n        return super.processKeyBinding(ks, e, condition, pressed);\n      }\n\n      @Override\n      public TableCellEditor getCellEditor(final int row, int column) {\n        final JBTableRowEditor editor = getRowEditor(row);\n        if (editor != null) {\n          editor.setMouseEvent(myMouseEvent);\n          editor.prepareEditor(t, row);\n          installPaddingAndBordersForEditors(editor);\n          editor.setFocusCycleRoot(true);\n\n          editor.setFocusTraversalPolicy(new JBListTableFocusTraversalPolicy(editor));\n          MouseSuppressor.install(editor);\n\n          myCellEditor = new MyCellEditor(editor);\n          return myCellEditor;\n        }\n        myCellEditor = null;\n        return myCellEditor;\n      }\n\n      @Override\n      public Component prepareEditor(TableCellEditor editor, int row, int column) {\n        Object value = getValueAt(row, column);\n        boolean isSelected = isCellSelected(row, column);\n        return editor.getTableCellEditorComponent(this, value, isSelected, row, column);\n      }\n    };\n    mainTable.setStriped(true);\n  }","commit_id":"8951bc03741e3dbaee44a98322be3cb4bcdc0684","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void run() {\n      try {\n        sleep(50);\n        \n        while (currentHeight != neededHeight) {\n          if (Math.abs(currentHeight - neededHeight) < step) {\n            currentHeight = neededHeight;\n          } else {\n            currentHeight += currentHeight < neededHeight ? step : -step;\n          }\n          SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n              myTable.setRowHeight(myRow, currentHeight);\n            }\n          });\n          sleep(15);\n        }\n        if (myEditor != null) {\n          final JComponent focus = myEditor.getPreferredFocusedComponent();\n          if (focus != null) {\n            focus.requestFocus();\n          }\n        }\n      }\n      catch (InterruptedException e) {        \n      }\n    }","id":92276,"modified_method":"@Override\n    public void run() {\n      try {\n        sleep(50);\n\n        while (currentHeight != neededHeight) {\n          if (Math.abs(currentHeight - neededHeight) < step) {\n            currentHeight = neededHeight;\n          }\n          else {\n            currentHeight += currentHeight < neededHeight ? step : -step;\n          }\n          SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n              myTable.setRowHeight(myRow, currentHeight);\n            }\n          });\n          sleep(15);\n        }\n        if (myEditor != null) {\n          JComponent[] components = myEditor.getFocusableComponents();\n          JComponent focus = null;\n          if (myIndex.get() != null) {\n            int index = myIndex.get().intValue();\n            if (0 <= index && index < components.length) {\n              focus = components[index];\n            }\n          }\n          if (focus == null) {\n            focus = myEditor.getPreferredFocusedComponent();\n          }\n          if (focus != null) {\n            focus.requestFocus();\n          }\n        }\n      }\n      catch (InterruptedException e) {\n      }\n    }","commit_id":"8951bc03741e3dbaee44a98322be3cb4bcdc0684","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createDefaultTableActions(@Nullable final ElementProducer<?> producer) {\n    final JTable table = myTable;\n    final EditableModel tableModel = (EditableModel)myTableModel;\n\n    myAddAction = new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        TableUtil.stopEditing(table);\n        final int rowCount = table.getRowCount();\n        if (tableModel instanceof ListTableModel && producer != null) {\n          //noinspection unchecked\n          ((ListTableModel)tableModel).addRow(producer.createElement());\n        } else {\n          tableModel.addRow();\n        }\n        if (rowCount == table.getRowCount()) return;\n        final int index = myTableModel.getRowCount() - 1;\n        table.editCellAt(index, 0);\n        table.setRowSelectionInterval(index, index);\n        table.setColumnSelectionInterval(0, 0);\n        table.getParent().repaint();\n        final Component editorComponent = table.getEditorComponent();\n        if (editorComponent != null) {\n          final Rectangle bounds = editorComponent.getBounds();\n          table.scrollRectToVisible(bounds);\n          editorComponent.requestFocus();\n        }\n      }\n    };\n\n    myRemoveAction = new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        TableUtil.stopEditing(table);\n        int index = table.getSelectedRow();\n        if (0 <= index && index < myTableModel.getRowCount()) {\n          tableModel.removeRow(index);\n          if (index < myTableModel.getRowCount()) {\n            table.setRowSelectionInterval(index, index);\n          }\n          else {\n            if (index > 0) {\n              table.setRowSelectionInterval(index - 1, index - 1);\n            }\n          }\n          updateButtons();\n        }\n\n        table.getParent().repaint();\n        table.requestFocus();\n      }\n    };\n\n    myUpAction = new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        TableUtil.stopEditing(table);\n        final int[] indexes = table.getSelectedRows();\n        for (int index : indexes) {\n          if (0 < index && index < myTableModel.getRowCount()) {\n            tableModel.exchangeRows(index, index - 1);\n            table.setRowSelectionInterval(index - 1, index - 1);\n          }\n        }\n        table.requestFocus();\n      }\n    };\n\n    myDownAction = new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        TableUtil.stopEditing(table);\n        final int[] indexes = table.getSelectedRows();\n        for (int index : indexes) {\n          if (0 <= index && index < myTableModel.getRowCount() - 1) {\n            tableModel.exchangeRows(index, index + 1);\n            table.setRowSelectionInterval(index + 1, index + 1);\n          }\n        }\n        table.requestFocus();\n      }\n    };\n  }","id":92277,"modified_method":"private void createDefaultTableActions(@Nullable final ElementProducer<?> producer) {\n    final JTable table = myTable;\n    final EditableModel tableModel = (EditableModel)myTableModel;\n\n    myAddAction = new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        TableUtil.stopEditing(table);\n        final int rowCount = table.getRowCount();\n        if (tableModel instanceof ListTableModel && producer != null) {\n          //noinspection unchecked\n          ((ListTableModel)tableModel).addRow(producer.createElement());\n        } else {\n          tableModel.addRow();\n        }\n        if (rowCount == table.getRowCount()) return;\n        final int index = myTableModel.getRowCount() - 1;\n        table.editCellAt(index, 0);\n        table.setRowSelectionInterval(index, index);\n        table.setColumnSelectionInterval(0, 0);\n        table.getParent().repaint();\n        final Component editorComponent = table.getEditorComponent();\n        if (editorComponent != null) {\n          final Rectangle bounds = editorComponent.getBounds();\n          table.scrollRectToVisible(bounds);\n          editorComponent.requestFocus();\n        }\n      }\n    };\n\n    myRemoveAction = new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        TableUtil.stopEditing(table);\n        int index = table.getSelectedRow();\n        if (0 <= index && index < myTableModel.getRowCount()) {\n          tableModel.removeRow(index);\n          if (index < myTableModel.getRowCount()) {\n            table.setRowSelectionInterval(index, index);\n          }\n          else {\n            if (index > 0) {\n              table.setRowSelectionInterval(index - 1, index - 1);\n            }\n          }\n          updateButtons();\n        }\n\n        table.getParent().repaint();\n        table.requestFocus();\n      }\n    };\n\n    myUpAction = new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {        \n        final int row = table.getEditingRow();\n        final int col = table.getEditingColumn();\n        TableUtil.stopEditing(table);\n        final int[] indexes = table.getSelectedRows();\n        for (int index : indexes) {\n          if (0 < index && index < myTableModel.getRowCount()) {\n            tableModel.exchangeRows(index, index - 1);\n            table.setRowSelectionInterval(index - 1, index - 1);\n          }\n        }        \n        table.requestFocus();\n        if (row > 0 && col != -1) {\n          table.editCellAt(row - 1, col);\n        }\n      }\n    };\n\n    myDownAction = new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        final int row = table.getEditingRow();\n        final int col = table.getEditingColumn();\n\n        TableUtil.stopEditing(table);\n        final int[] indexes = table.getSelectedRows();\n        for (int index : indexes) {\n          if (0 <= index && index < myTableModel.getRowCount() - 1) {\n            tableModel.exchangeRows(index, index + 1);\n            table.setRowSelectionInterval(index + 1, index + 1);\n          }\n        }\n        table.requestFocus();\n        if (row < table.getRowCount() - 1 && col != -1) {\n          table.editCellAt(row + 1, col);\n        }\n      }\n    };\n  }","commit_id":"8951bc03741e3dbaee44a98322be3cb4bcdc0684","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public int compare(DeclarationDescriptor o1, DeclarationDescriptor o2) {\n        int prioritiesCompareTo = getDeclarationPriority(o2) - getDeclarationPriority(o1);\n        if (prioritiesCompareTo != 0) {\n            return prioritiesCompareTo;\n        }\n\n        int namesCompareTo = o1.getName().compareTo(o2.getName());\n        if (namesCompareTo != 0) {\n            return namesCompareTo;\n        }\n\n        if (!(o1 instanceof CallableDescriptor) || !(o2 instanceof CallableDescriptor)) {\n            assert false;\n        }\n\n        CallableDescriptor c1 = (CallableDescriptor)o1;\n        CallableDescriptor c2 = (CallableDescriptor)o2;\n\n        ReceiverParameterDescriptor c1ReceiverParameter = c1.getReceiverParameter();\n        ReceiverParameterDescriptor c2ReceiverParameter = c2.getReceiverParameter();\n        assert (c1ReceiverParameter != null) == (c2ReceiverParameter != null);\n        if (c1ReceiverParameter != null) {\n            String r1 = DescriptorRenderer.TEXT.renderType(c1ReceiverParameter.getType());\n            String r2 = DescriptorRenderer.TEXT.renderType(c2ReceiverParameter.getType());\n            int receiversCompareTo = r1.compareTo(r2);\n            if (receiversCompareTo != 0) {\n                return receiversCompareTo;\n            }\n        }\n\n        for (int i = 0; i < Math.min(c1.getValueParameters().size(), c2.getValueParameters().size()); i++) {\n            String p1 = DescriptorRenderer.TEXT.renderType(c1.getValueParameters().get(i).getType());\n            String p2 = DescriptorRenderer.TEXT.renderType(c2.getValueParameters().get(i).getType());\n            int parametersCompareTo = p1.compareTo(p2);\n            if (parametersCompareTo != 0) {\n                return parametersCompareTo;\n            }\n        }\n\n        return c1.getValueParameters().size() - c2.getValueParameters().size();\n    }","id":92278,"modified_method":"@Override\n    public int compare(DeclarationDescriptor o1, DeclarationDescriptor o2) {\n        int prioritiesCompareTo = getDeclarationPriority(o2) - getDeclarationPriority(o1);\n        if (prioritiesCompareTo != 0) {\n            return prioritiesCompareTo;\n        }\n\n        int namesCompareTo = o1.getName().compareTo(o2.getName());\n        if (namesCompareTo != 0) {\n            return namesCompareTo;\n        }\n\n        if (!(o1 instanceof CallableDescriptor) || !(o2 instanceof CallableDescriptor)) {\n            assert false;\n        }\n\n        CallableDescriptor c1 = (CallableDescriptor)o1;\n        CallableDescriptor c2 = (CallableDescriptor)o2;\n\n        ReceiverParameterDescriptor c1ReceiverParameter = c1.getReceiverParameter();\n        ReceiverParameterDescriptor c2ReceiverParameter = c2.getReceiverParameter();\n        assert (c1ReceiverParameter != null) == (c2ReceiverParameter != null);\n        if (c1ReceiverParameter != null) {\n            String r1 = DescriptorRenderer.TEXT.renderType(c1ReceiverParameter.getType());\n            String r2 = DescriptorRenderer.TEXT.renderType(c2ReceiverParameter.getType());\n            int receiversCompareTo = r1.compareTo(r2);\n            if (receiversCompareTo != 0) {\n                return receiversCompareTo;\n            }\n        }\n\n        List<ValueParameterDescriptor> c1ValueParameters = c1.getValueParameters();\n        List<ValueParameterDescriptor> c2ValueParameters = c2.getValueParameters();\n        for (int i = 0; i < Math.min(c1ValueParameters.size(), c2ValueParameters.size()); i++) {\n            String p1 = DescriptorRenderer.TEXT.renderType(c1ValueParameters.get(i).getType());\n            String p2 = DescriptorRenderer.TEXT.renderType(c2ValueParameters.get(i).getType());\n            int parametersCompareTo = p1.compareTo(p2);\n            if (parametersCompareTo != 0) {\n                return parametersCompareTo;\n            }\n        }\n\n        int valueParametersNumberCompareTo = c1ValueParameters.size() - c2ValueParameters.size();\n        if (valueParametersNumberCompareTo != 0) {\n            return valueParametersNumberCompareTo;\n        }\n\n        List<TypeParameterDescriptor> c1TypeParameters = c1.getTypeParameters();\n        List<TypeParameterDescriptor> c2TypeParameters = c2.getTypeParameters();\n        for (int i = 0; i < Math.min(c1TypeParameters.size(), c2TypeParameters.size()); i++) {\n            String p1 = DescriptorRenderer.TEXT.renderType(c1TypeParameters.get(i).getUpperBoundsAsType());\n            String p2 = DescriptorRenderer.TEXT.renderType(c2TypeParameters.get(i).getUpperBoundsAsType());\n            int parametersCompareTo = p1.compareTo(p2);\n            if (parametersCompareTo != 0) {\n                return parametersCompareTo;\n            }\n        }\n\n        return c1TypeParameters.size() - c2TypeParameters.size();\n    }","commit_id":"9d4447e3aedb287a6e4a8b363daed5cc7b08781a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void generateDefaultImplBody(\n            @NotNull MethodContext methodContext,\n            @NotNull JvmMethodSignature signature,\n            @NotNull FunctionDescriptor functionDescriptor,\n            boolean isStatic,\n            @NotNull MethodVisitor mv,\n            @NotNull DefaultParameterValueLoader loadStrategy,\n            @Nullable JetNamedFunction function,\n            @NotNull MemberCodegen<?> parentCodegen,\n            @NotNull GenerationState state\n    ) {\n        FrameMap frameMap = new FrameMap();\n\n        if (!isStatic) {\n            frameMap.enterTemp(OBJECT_TYPE);\n        }\n\n        ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, signature.getReturnType(), methodContext, state, parentCodegen);\n\n        Type[] argTypes = signature.getAsmMethod().getArgumentTypes();\n        List<ValueParameterDescriptor> paramDescrs = functionDescriptor.getValueParameters();\n        Iterator<ValueParameterDescriptor> iterator = paramDescrs.iterator();\n\n        int countOfExtraVarsInMethodArgs = 0;\n\n        for (JvmMethodParameterSignature parameterSignature : signature.getValueParameters()) {\n            if (parameterSignature.getKind() != JvmMethodParameterKind.VALUE) {\n                countOfExtraVarsInMethodArgs++;\n                frameMap.enterTemp(parameterSignature.getAsmType());\n            }\n            else {\n                frameMap.enter(iterator.next(), parameterSignature.getAsmType());\n            }\n        }\n\n        int maskIndex = frameMap.enterTemp(Type.INT_TYPE);\n\n        CallGenerator generator = codegen.getOrCreateCallGenerator(functionDescriptor, function);\n\n        InstructionAdapter iv = new InstructionAdapter(mv);\n        loadExplicitArgumentsOnStack(iv, OBJECT_TYPE, isStatic, signature);\n        generator.putHiddenParams();\n\n        for (int index = 0; index < paramDescrs.size(); index++) {\n            ValueParameterDescriptor parameterDescriptor = paramDescrs.get(index);\n\n            Type t = argTypes[countOfExtraVarsInMethodArgs + index];\n\n            int parameterIndex = frameMap.getIndex(parameterDescriptor);\n            if (parameterDescriptor.declaresDefaultValue()) {\n                iv.load(maskIndex, Type.INT_TYPE);\n                iv.iconst(1 << index);\n                iv.and(Type.INT_TYPE);\n                Label loadArg = new Label();\n                iv.ifeq(loadArg);\n\n                loadStrategy.putValueOnStack(parameterDescriptor, codegen);\n\n                iv.store(parameterIndex, t);\n\n                iv.mark(loadArg);\n            }\n\n            generator.putValueIfNeeded(parameterDescriptor, t, StackValue.local(parameterIndex, t));\n        }\n\n        CallableMethod method;\n        if (functionDescriptor instanceof ConstructorDescriptor) {\n            method = state.getTypeMapper().mapToCallableMethod((ConstructorDescriptor) functionDescriptor);\n        }\n        else {\n            method = state.getTypeMapper().mapToCallableMethod(functionDescriptor, false, methodContext);\n        }\n\n        generator.genCallWithoutAssertions(method, codegen);\n\n        iv.areturn(signature.getReturnType());\n    }","id":92279,"modified_method":"public static void generateDefaultImplBody(\n            @NotNull MethodContext methodContext,\n            @NotNull JvmMethodSignature signature,\n            @NotNull FunctionDescriptor functionDescriptor,\n            boolean isStatic,\n            @NotNull MethodVisitor mv,\n            @NotNull DefaultParameterValueLoader loadStrategy,\n            @Nullable JetNamedFunction function,\n            @NotNull MemberCodegen<?> parentCodegen,\n            @NotNull GenerationState state\n    ) {\n        FrameMap frameMap = createFrameMap(state, functionDescriptor, signature, isStatic);\n\n        ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, signature.getReturnType(), methodContext, state, parentCodegen);\n\n        int maskIndex = frameMap.enterTemp(Type.INT_TYPE);\n\n        CallGenerator generator = codegen.getOrCreateCallGenerator(functionDescriptor, function);\n\n        InstructionAdapter iv = new InstructionAdapter(mv);\n        loadExplicitArgumentsOnStack(iv, OBJECT_TYPE, isStatic, signature);\n        generator.putHiddenParams();\n\n        List<JvmMethodParameterSignature> mappedParameters = signature.getValueParameters();\n        int capturedArgumentsCount = 0;\n        while (capturedArgumentsCount < mappedParameters.size() &&\n               mappedParameters.get(capturedArgumentsCount).getKind() != JvmMethodParameterKind.VALUE) {\n            capturedArgumentsCount++;\n        }\n\n        List<ValueParameterDescriptor> valueParameters = functionDescriptor.getValueParameters();\n        for (int index = 0; index < valueParameters.size(); index++) {\n            ValueParameterDescriptor parameterDescriptor = valueParameters.get(index);\n            Type type = mappedParameters.get(capturedArgumentsCount + index).getAsmType();\n\n            int parameterIndex = frameMap.getIndex(parameterDescriptor);\n            if (parameterDescriptor.declaresDefaultValue()) {\n                iv.load(maskIndex, Type.INT_TYPE);\n                iv.iconst(1 << index);\n                iv.and(Type.INT_TYPE);\n                Label loadArg = new Label();\n                iv.ifeq(loadArg);\n\n                loadStrategy.putValueOnStack(parameterDescriptor, codegen);\n\n                iv.store(parameterIndex, type);\n\n                iv.mark(loadArg);\n            }\n\n            generator.putValueIfNeeded(parameterDescriptor, type, StackValue.local(parameterIndex, type));\n        }\n\n        CallableMethod method;\n        if (functionDescriptor instanceof ConstructorDescriptor) {\n            method = state.getTypeMapper().mapToCallableMethod((ConstructorDescriptor) functionDescriptor);\n        }\n        else {\n            method = state.getTypeMapper().mapToCallableMethod(functionDescriptor, false, methodContext);\n        }\n\n        generator.genCallWithoutAssertions(method, codegen);\n\n        iv.areturn(signature.getReturnType());\n    }","commit_id":"93fdf3a254cba79c1fa02e60563c28c677c3757c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void generateMethodBody(\n            @NotNull MethodVisitor mv,\n            @NotNull FunctionDescriptor functionDescriptor,\n            @NotNull MethodContext context,\n            @NotNull JvmMethodSignature signature,\n            @NotNull FunctionGenerationStrategy strategy,\n            @NotNull MemberCodegen<?> parentCodegen\n    ) {\n        mv.visitCode();\n\n        Label methodBegin = new Label();\n        mv.visitLabel(methodBegin);\n\n        JetTypeMapper typeMapper = parentCodegen.typeMapper;\n\n        if (context.getParentContext() instanceof PackageFacadeContext) {\n            generateStaticDelegateMethodBody(mv, signature.getAsmMethod(), (PackageFacadeContext) context.getParentContext());\n        }\n        else {\n            FrameMap frameMap = new FrameMap();\n            if (context.getContextKind() == OwnerKind.IMPLEMENTATION) {\n                frameMap.enterTemp(OBJECT_TYPE); // 0 slot for this\n            }\n            for (JvmMethodParameterSignature parameter : signature.getValueParameters()) {\n                if (parameter.getKind() != JvmMethodParameterKind.VALUE) {\n                    frameMap.enterTemp(parameter.getAsmType());\n                }\n            }\n            for (ValueParameterDescriptor parameter : functionDescriptor.getValueParameters()) {\n                frameMap.enter(parameter, typeMapper.mapType(parameter));\n            }\n\n            Label methodEntry = new Label();\n            mv.visitLabel(methodEntry);\n            context.setMethodStartLabel(methodEntry);\n\n            if (!JetTypeMapper.isAccessor(functionDescriptor)) {\n                genNotNullAssertionsForParameters(new InstructionAdapter(mv), parentCodegen.state, functionDescriptor, frameMap);\n            }\n\n            strategy.generateBody(mv, frameMap, signature, context, parentCodegen);\n        }\n\n        Label methodEnd = new Label();\n        mv.visitLabel(methodEnd);\n\n        Type thisType = getThisTypeForFunction(functionDescriptor, context, typeMapper);\n        generateLocalVariableTable(mv, signature, functionDescriptor, thisType, methodBegin, methodEnd, context.getContextKind());\n    }","id":92280,"modified_method":"public static void generateMethodBody(\n            @NotNull MethodVisitor mv,\n            @NotNull FunctionDescriptor functionDescriptor,\n            @NotNull MethodContext context,\n            @NotNull JvmMethodSignature signature,\n            @NotNull FunctionGenerationStrategy strategy,\n            @NotNull MemberCodegen<?> parentCodegen\n    ) {\n        mv.visitCode();\n\n        Label methodBegin = new Label();\n        mv.visitLabel(methodBegin);\n\n        JetTypeMapper typeMapper = parentCodegen.typeMapper;\n\n        if (context.getParentContext() instanceof PackageFacadeContext) {\n            generateStaticDelegateMethodBody(mv, signature.getAsmMethod(), (PackageFacadeContext) context.getParentContext());\n        }\n        else {\n            FrameMap frameMap = createFrameMap(parentCodegen.state, functionDescriptor, signature, isStatic(context.getContextKind()));\n\n            Label methodEntry = new Label();\n            mv.visitLabel(methodEntry);\n            context.setMethodStartLabel(methodEntry);\n\n            if (!JetTypeMapper.isAccessor(functionDescriptor)) {\n                genNotNullAssertionsForParameters(new InstructionAdapter(mv), parentCodegen.state, functionDescriptor, frameMap);\n            }\n\n            strategy.generateBody(mv, frameMap, signature, context, parentCodegen);\n        }\n\n        Label methodEnd = new Label();\n        mv.visitLabel(methodEnd);\n\n        Type thisType = getThisTypeForFunction(functionDescriptor, context, typeMapper);\n        generateLocalVariableTable(mv, signature, functionDescriptor, thisType, methodBegin, methodEnd, context.getContextKind());\n    }","commit_id":"93fdf3a254cba79c1fa02e60563c28c677c3757c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * @see org.apache.maven.plugin.eclipse.writers.EclipseWriter#write()\n     */\n    public void write()\n        throws MojoExecutionException\n    {\n\n        Writer w;\n\n        try\n        {\n            w =\n                new OutputStreamWriter( new FileOutputStream( new File( config.getEclipseProjectDirectory(),\n                                                                        FILE_DOT_CLASSPATH ) ), \"UTF-8\" );\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( ELT_CLASSPATH );\n\n        String defaultOutput =\n            IdeUtils.toRelativeAndFixSeparator( config.getProjectBaseDir(), config.getBuildOutputDirectory(), false );\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        // List<EclipseSourceDir>\n        List specialSources = new ArrayList();\n\n        // Map<String,List<EclipseSourceDir>>\n        Map byOutputDir = new HashMap();\n\n        for ( int j = 0; j < config.getSourceDirs().length; j++ )\n        {\n            EclipseSourceDir dir = config.getSourceDirs()[j];\n\n            // List<EclipseSourceDir>\n            List byOutputDirs = (List) byOutputDir.get( dir.getOutput() );\n            if ( byOutputDirs == null )\n            {\n                // ArrayList<EclipseSourceDir>\n                byOutputDir.put( dir.getOutput() == null ? defaultOutput : dir.getOutput(), byOutputDirs =\n                    new ArrayList() );\n            }\n            byOutputDirs.add( dir );\n        }\n\n        for ( int j = 0; j < config.getSourceDirs().length; j++ )\n        {\n            EclipseSourceDir dir = config.getSourceDirs()[j];\n\n            log.debug( \"Processing \" + ( dir.isResource() ? \"re\" : \"\" ) + \"source \" + dir.getPath() + \": output=\"\n                + dir.getOutput() + \"; default output=\" + defaultOutput );\n\n            boolean isSpecial = false;\n\n            // handle resource with nested output folders\n            if ( dir.isResource() )\n            {\n                // Check if the output is a subdirectory of the default output,\n                // and if the default output has any sources that copy there.\n\n                if ( dir.getOutput() != null // resource output dir is set\n                    && !dir.getOutput().equals( defaultOutput ) // output dir is not default target/classes\n                    && dir.getOutput().startsWith( defaultOutput ) // ... but is nested\n                    && byOutputDir.get( defaultOutput ) != null // ???\n                    && !( (List) byOutputDir.get( defaultOutput ) ).isEmpty() // ???\n                )\n                {\n                    // do not specify as source since the output will be nested. Instead, mark\n                    // it as a todo, and handle it with a custom build.xml file later.\n\n                    log.debug( \"Marking as special to prevent output folder nesting: \" + dir.getPath() + \" (output=\"\n                        + dir.getOutput() + \")\" );\n\n                    isSpecial = true;\n                    specialSources.add( dir );\n                }\n            }\n\n            writer.startElement( ELT_CLASSPATHENTRY );\n\n            writer.addAttribute( ATTR_KIND, \"src\" ); //$NON-NLS-1$\n            writer.addAttribute( ATTR_PATH, dir.getPath() );\n\n            if ( !isSpecial && dir.getOutput() != null && !defaultOutput.equals( dir.getOutput() ) )\n            {\n                writer.addAttribute( ATTR_OUTPUT, dir.getOutput() );\n            }\n\n            String includes = dir.getInclude();\n\n            if ( !dir.isResource() )\n            {\n                // automatically include java files only: eclipse doesn't have the concept of a source only directory so it \n                // will try to include non-java files found in maven source dirs\n                includes = StringUtils.isEmpty( includes ) ? \"**/*.java\" : includes + \"|**/*.java\";\n            }\n            \n            if ( StringUtils.isNotEmpty( includes ) )\n            {\n                writer.addAttribute( ATTR_INCLUDING, includes );\n            }\n\n            String excludes = dir.getExclude();\n\n            if ( dir.isResource() )\n            {\n                // automatically exclude java files: eclipse doesn't have the concept of resource directory so it will\n                // try to compile any java file found in maven resource dirs\n                excludes = StringUtils.isEmpty( excludes ) ? \"**/*.java\" : excludes + \"|**/*.java\";\n            }\n\n            if ( StringUtils.isNotEmpty( excludes ) )\n            {\n                writer.addAttribute( ATTR_EXCLUDING, excludes );\n            }\n\n            writer.endElement();\n\n        }\n\n        // handle the special sources.\n        if ( !specialSources.isEmpty() )\n        {\n            log.info( \"Creating maven-eclipse.xml Ant file to handle resources\" );\n\n            try\n            {\n                Writer buildXmlWriter =\n                    new OutputStreamWriter( new FileOutputStream( new File( config.getEclipseProjectDirectory(),\n                                                                            \"maven-eclipse.xml\" ) ), \"UTF-8\" );\n                PrettyPrintXMLWriter buildXmlPrinter = new PrettyPrintXMLWriter( buildXmlWriter );\n\n                buildXmlPrinter.startElement( \"project\" );\n                buildXmlPrinter.addAttribute( \"default\", \"copy-resources\" );\n\n                buildXmlPrinter.startElement( \"target\" );\n                buildXmlPrinter.addAttribute( NAME, \"init\" );\n                // initialize filtering tokens here\n                buildXmlPrinter.endElement();\n\n                buildXmlPrinter.startElement( \"target\" );\n                buildXmlPrinter.addAttribute( NAME, \"copy-resources\" );\n                buildXmlPrinter.addAttribute( \"depends\", \"init\" );\n\n                for ( Iterator it = specialSources.iterator(); it.hasNext(); )\n                {\n                    // TODO: merge source dirs on output path+filtering to reduce\n                    // <copy> tags for speed.\n                    EclipseSourceDir dir = (EclipseSourceDir) it.next();\n                    buildXmlPrinter.startElement( \"copy\" );\n                    buildXmlPrinter.addAttribute( \"todir\", dir.getOutput() );\n                    buildXmlPrinter.addAttribute( \"filtering\", \"\" + dir.isFiltering() );\n\n                    buildXmlPrinter.startElement( \"fileset\" );\n                    buildXmlPrinter.addAttribute( \"dir\", dir.getPath() );\n                    if ( dir.getInclude() != null )\n                    {\n                        buildXmlPrinter.addAttribute( \"includes\", dir.getInclude() );\n                    }\n                    if ( dir.getExclude() != null )\n                    {\n                        buildXmlPrinter.addAttribute( \"excludes\", dir.getExclude() );\n                    }\n                    buildXmlPrinter.endElement();\n\n                    buildXmlPrinter.endElement();\n                }\n\n                buildXmlPrinter.endElement();\n\n                buildXmlPrinter.endElement();\n\n                IOUtil.close( buildXmlWriter );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot create \" + config.getEclipseProjectDirectory()\n                    + \"/maven-eclipse.xml\", e );\n            }\n\n            log.info( \"Creating external launcher file\" );\n            // now create the launcher\n            new EclipseAntExternalLaunchConfigurationWriter().init( log, config, \"Maven_Ant_Builder.launch\",\n                                                                    \"maven-eclipse.xml\" ).write();\n\n            // finally add it to the project writer.\n\n            config.getBuildCommands().add(\n                                           new BuildCommand(\n                                                             \"org.eclipse.ui.externaltools.ExternalToolBuilder\",\n                                                             \"LaunchConfigHandle\",\n                                                             \"<project>/\"\n                                                                 + EclipseLaunchConfigurationWriter.FILE_DOT_EXTERNAL_TOOL_BUILDERS\n                                                                 + \"Maven_Ant_Builder.launch\" ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( ELT_CLASSPATHENTRY );\n        writer.addAttribute( ATTR_KIND, ATTR_OUTPUT );\n        writer.addAttribute( ATTR_PATH, defaultOutput );\n        writer.endElement();\n\n        Set addedDependencies = new HashSet();\n        // TODO if (..magic property equals orderDependencies..)\n\n        // ----------------------------------------------------------------------\n        // Java API dependencies that may complete the classpath container so must\n        // be declared BEFORE so that container access rules don't fail\n        // ----------------------------------------------------------------------\n        IdeDependency[] depsToWrite = config.getDepsOrdered();\n        for ( int j = 0; j < depsToWrite.length; j++ )\n        {\n            IdeDependency dep = depsToWrite[j];\n            if ( dep.isJavaApi() )\n            {\n                String depId = getDependencyId( dep );\n                if ( !addedDependencies.contains( depId ) )\n                {\n                    addDependency( writer, dep );\n                    addedDependencies.add( depId );\n                }\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n        for ( int j = 0; j < depsToWrite.length; j++ )\n        {\n            IdeDependency dep = depsToWrite[j];\n\n            if ( dep.isAddedToClasspath() )\n            {\n                String depId = getDependencyId( dep );\n                /* avoid duplicates in the classpath for artifacts with different types (like ejbs or test-jars) */\n                if ( !addedDependencies.contains( depId ) )\n                {\n                    addDependency( writer, dep );\n                    addedDependencies.add( depId );\n                }\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = config.getClasspathContainers().iterator(); it.hasNext(); )\n        {\n            writer.startElement( ELT_CLASSPATHENTRY );\n            writer.addAttribute( ATTR_KIND, \"con\" ); //$NON-NLS-1$\n            writer.addAttribute( ATTR_PATH, (String) it.next() );\n            writer.endElement(); // name\n        }\n        \n        writer.endElement();\n\n        IOUtil.close( w );\n\n    }","id":92281,"modified_method":"/**\n     * @see org.apache.maven.plugin.eclipse.writers.EclipseWriter#write()\n     */\n    public void write()\n        throws MojoExecutionException\n    {\n\n        Writer w;\n\n        try\n        {\n            w =\n                new OutputStreamWriter( new FileOutputStream( new File( config.getEclipseProjectDirectory(),\n                                                                        FILE_DOT_CLASSPATH ) ), \"UTF-8\" );\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( ELT_CLASSPATH );\n\n        String defaultOutput =\n            IdeUtils.toRelativeAndFixSeparator( config.getProjectBaseDir(), config.getBuildOutputDirectory(), false );\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        // List<EclipseSourceDir>\n        List specialSources = new ArrayList();\n\n        // Map<String,List<EclipseSourceDir>>\n        Map byOutputDir = new HashMap();\n\n        for ( int j = 0; j < config.getSourceDirs().length; j++ )\n        {\n            EclipseSourceDir dir = config.getSourceDirs()[j];\n\n            // List<EclipseSourceDir>\n            List byOutputDirs = (List) byOutputDir.get( dir.getOutput() );\n            if ( byOutputDirs == null )\n            {\n                // ArrayList<EclipseSourceDir>\n                byOutputDir.put( dir.getOutput() == null ? defaultOutput : dir.getOutput(), byOutputDirs =\n                    new ArrayList() );\n            }\n            byOutputDirs.add( dir );\n        }\n\n        for ( int j = 0; j < config.getSourceDirs().length; j++ )\n        {\n            EclipseSourceDir dir = config.getSourceDirs()[j];\n\n            log.debug( \"Processing classpath for: \" + dir.toString() + \"; default output=\" + defaultOutput );\n\n            boolean isSpecial = false;\n\n            // handle resource with nested output folders\n            if ( dir.isResource() )\n            {\n                // Check if the output is a subdirectory of the default output,\n                // and if the default output has any sources that copy there.\n\n                if ( dir.getOutput() != null // resource output dir is set\n                    && !dir.getOutput().equals( defaultOutput ) // output dir is not default target/classes\n                    && dir.getOutput().startsWith( defaultOutput ) // ... but is nested\n                    && byOutputDir.get( defaultOutput ) != null // ???\n                    && !( (List) byOutputDir.get( defaultOutput ) ).isEmpty() // ???\n                )\n                {\n                    // do not specify as source since the output will be nested. Instead, mark\n                    // it as a todo, and handle it with a custom build.xml file later.\n\n                    log.debug( \"Marking as special to prevent output folder nesting: \" + dir.getPath() + \" (output=\"\n                        + dir.getOutput() + \")\" );\n\n                    isSpecial = true;\n                    specialSources.add( dir );\n                }\n            }\n\n            writer.startElement( ELT_CLASSPATHENTRY );\n\n            writer.addAttribute( ATTR_KIND, \"src\" ); //$NON-NLS-1$\n            writer.addAttribute( ATTR_PATH, dir.getPath() );\n\n            if ( !isSpecial && dir.getOutput() != null && !defaultOutput.equals( dir.getOutput() ) )\n            {\n                writer.addAttribute( ATTR_OUTPUT, dir.getOutput() );\n            }\n\n            String includes = dir.getInclude();\n            if ( StringUtils.isNotEmpty( includes ) )\n            {\n                writer.addAttribute( ATTR_INCLUDING, includes );\n            }\n\n            String excludes = dir.getExclude();\n            if ( StringUtils.isNotEmpty( excludes ) )\n            {\n                writer.addAttribute( ATTR_EXCLUDING, excludes );\n            }\n\n            writer.endElement();\n\n        }\n\n        // handle the special sources.\n        if ( !specialSources.isEmpty() )\n        {\n            log.info( \"Creating maven-eclipse.xml Ant file to handle resources\" );\n\n            try\n            {\n                Writer buildXmlWriter =\n                    new OutputStreamWriter( new FileOutputStream( new File( config.getEclipseProjectDirectory(),\n                                                                            \"maven-eclipse.xml\" ) ), \"UTF-8\" );\n                PrettyPrintXMLWriter buildXmlPrinter = new PrettyPrintXMLWriter( buildXmlWriter );\n\n                buildXmlPrinter.startElement( \"project\" );\n                buildXmlPrinter.addAttribute( \"default\", \"copy-resources\" );\n\n                buildXmlPrinter.startElement( \"target\" );\n                buildXmlPrinter.addAttribute( NAME, \"init\" );\n                // initialize filtering tokens here\n                buildXmlPrinter.endElement();\n\n                buildXmlPrinter.startElement( \"target\" );\n                buildXmlPrinter.addAttribute( NAME, \"copy-resources\" );\n                buildXmlPrinter.addAttribute( \"depends\", \"init\" );\n\n                for ( Iterator it = specialSources.iterator(); it.hasNext(); )\n                {\n                    // TODO: merge source dirs on output path+filtering to reduce\n                    // <copy> tags for speed.\n                    EclipseSourceDir dir = (EclipseSourceDir) it.next();\n                    buildXmlPrinter.startElement( \"copy\" );\n                    buildXmlPrinter.addAttribute( \"todir\", dir.getOutput() );\n                    buildXmlPrinter.addAttribute( \"filtering\", \"\" + dir.isFiltering() );\n\n                    buildXmlPrinter.startElement( \"fileset\" );\n                    buildXmlPrinter.addAttribute( \"dir\", dir.getPath() );\n                    if ( dir.getInclude() != null )\n                    {\n                        buildXmlPrinter.addAttribute( \"includes\", dir.getInclude() );\n                    }\n                    if ( dir.getExclude() != null )\n                    {\n                        buildXmlPrinter.addAttribute( \"excludes\", dir.getExclude() );\n                    }\n                    buildXmlPrinter.endElement();\n\n                    buildXmlPrinter.endElement();\n                }\n\n                buildXmlPrinter.endElement();\n\n                buildXmlPrinter.endElement();\n\n                IOUtil.close( buildXmlWriter );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot create \" + config.getEclipseProjectDirectory()\n                    + \"/maven-eclipse.xml\", e );\n            }\n\n            log.info( \"Creating external launcher file\" );\n            // now create the launcher\n            new EclipseAntExternalLaunchConfigurationWriter().init( log, config, \"Maven_Ant_Builder.launch\",\n                                                                    \"maven-eclipse.xml\" ).write();\n\n            // finally add it to the project writer.\n\n            config.getBuildCommands().add(\n                                           new BuildCommand(\n                                                             \"org.eclipse.ui.externaltools.ExternalToolBuilder\",\n                                                             \"LaunchConfigHandle\",\n                                                             \"<project>/\"\n                                                                 + EclipseLaunchConfigurationWriter.FILE_DOT_EXTERNAL_TOOL_BUILDERS\n                                                                 + \"Maven_Ant_Builder.launch\" ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( ELT_CLASSPATHENTRY );\n        writer.addAttribute( ATTR_KIND, ATTR_OUTPUT );\n        writer.addAttribute( ATTR_PATH, defaultOutput );\n        writer.endElement();\n\n        Set addedDependencies = new HashSet();\n        // TODO if (..magic property equals orderDependencies..)\n\n        // ----------------------------------------------------------------------\n        // Java API dependencies that may complete the classpath container so must\n        // be declared BEFORE so that container access rules don't fail\n        // ----------------------------------------------------------------------\n        IdeDependency[] depsToWrite = config.getDepsOrdered();\n        for ( int j = 0; j < depsToWrite.length; j++ )\n        {\n            IdeDependency dep = depsToWrite[j];\n            if ( dep.isJavaApi() )\n            {\n                String depId = getDependencyId( dep );\n                if ( !addedDependencies.contains( depId ) )\n                {\n                    addDependency( writer, dep );\n                    addedDependencies.add( depId );\n                }\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n        for ( int j = 0; j < depsToWrite.length; j++ )\n        {\n            IdeDependency dep = depsToWrite[j];\n\n            if ( dep.isAddedToClasspath() )\n            {\n                String depId = getDependencyId( dep );\n                /* avoid duplicates in the classpath for artifacts with different types (like ejbs or test-jars) */\n                if ( !addedDependencies.contains( depId ) )\n                {\n                    addDependency( writer, dep );\n                    addedDependencies.add( depId );\n                }\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = config.getClasspathContainers().iterator(); it.hasNext(); )\n        {\n            writer.startElement( ELT_CLASSPATHENTRY );\n            writer.addAttribute( ATTR_KIND, \"con\" ); //$NON-NLS-1$\n            writer.addAttribute( ATTR_PATH, (String) it.next() );\n            writer.endElement(); // name\n        }\n        \n        writer.endElement();\n\n        IOUtil.close( w );\n\n    }","commit_id":"537572f1ed11f2d9e9f9e4c5294c867ca8f8c797","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void extractAspectDirs( Set directories, MavenProject project, File basedir, File projectBaseDir,\n                                    String testOutput )\n        throws MojoExecutionException\n    {\n        Xpp3Dom configuration = getAspectjConfiguration( project );\n        if ( configuration != null )\n        {\n            String aspectDirectory = DEFAULT_ASPECT_DIRECTORY;\n            Xpp3Dom aspectDirectoryElement = configuration.getChild( ASPECT_DIRECTORY );\n            if ( aspectDirectoryElement != null )\n            {\n                aspectDirectory = aspectDirectoryElement.getValue();\n            }\n\n            File aspectDirectoryFile = new File( basedir, aspectDirectory );\n            if ( aspectDirectoryFile.exists() && aspectDirectoryFile.isDirectory() )\n            {\n                String sourceRoot =\n                    IdeUtils.toRelativeAndFixSeparator( projectBaseDir, aspectDirectoryFile,\n                                                        !projectBaseDir.equals( basedir ) );\n\n                directories.add( new EclipseSourceDir( sourceRoot, null, false, false, null, null, false ) );\n            }\n\n            String testAspectDirectory = DEFAULT_TEST_ASPECT_DIRECTORY;\n            Xpp3Dom testAspectDirectoryElement = configuration.getChild( TEST_ASPECT_DIRECTORY );\n            if ( testAspectDirectoryElement != null )\n            {\n                testAspectDirectory = testAspectDirectoryElement.getValue();\n            }\n\n            File testAspectDirectoryFile = new File( basedir, testAspectDirectory );\n            if ( testAspectDirectoryFile.exists() && testAspectDirectoryFile.isDirectory() )\n            {\n                String sourceRoot =\n                    IdeUtils.toRelativeAndFixSeparator( projectBaseDir, testAspectDirectoryFile,\n                                                        !projectBaseDir.equals( basedir ) );\n\n                directories.add( new EclipseSourceDir( sourceRoot, testOutput, false, true, null, null, false ) );\n            }\n        }\n    }","id":92282,"modified_method":"private void extractAspectDirs( Set directories, MavenProject project, File basedir, File projectBaseDir,\n                                    String testOutput )\n        throws MojoExecutionException\n    {\n        Xpp3Dom configuration = getAspectjConfiguration( project );\n        if ( configuration != null )\n        {\n            List includes = new ArrayList();\n            includes.add( JAVA_FILE_PATTERN );\n            includes.add( ASPECTJ_FILE_PATTERN) ;\n            String includePattern = StringUtils.join( includes.iterator(), \"|\" );   \n            \n            String aspectDirectory = DEFAULT_ASPECT_DIRECTORY;\n            Xpp3Dom aspectDirectoryElement = configuration.getChild( ASPECT_DIRECTORY );\n            if ( aspectDirectoryElement != null )\n            {\n                aspectDirectory = aspectDirectoryElement.getValue();\n            }\n\n            File aspectDirectoryFile = new File( basedir, aspectDirectory );\n            if ( aspectDirectoryFile.exists() && aspectDirectoryFile.isDirectory() )\n            {\n                String sourceRoot =\n                    IdeUtils.toRelativeAndFixSeparator( projectBaseDir, aspectDirectoryFile,\n                                                        !projectBaseDir.equals( basedir ) );\n\n                directories.add( new EclipseSourceDir( sourceRoot, null, false, false, includePattern, null, false ) );\n            }\n\n            String testAspectDirectory = DEFAULT_TEST_ASPECT_DIRECTORY;\n            Xpp3Dom testAspectDirectoryElement = configuration.getChild( TEST_ASPECT_DIRECTORY );\n            if ( testAspectDirectoryElement != null )\n            {\n                testAspectDirectory = testAspectDirectoryElement.getValue();\n            }\n\n            File testAspectDirectoryFile = new File( basedir, testAspectDirectory );\n            if ( testAspectDirectoryFile.exists() && testAspectDirectoryFile.isDirectory() )\n            {\n                String sourceRoot =\n                    IdeUtils.toRelativeAndFixSeparator( projectBaseDir, testAspectDirectoryFile,\n                                                        !projectBaseDir.equals( basedir ) );\n\n                directories.add( new EclipseSourceDir( sourceRoot, testOutput, false, true, includePattern, null, false ) );\n            }\n        }\n    }","commit_id":"537572f1ed11f2d9e9f9e4c5294c867ca8f8c797","url":"https://github.com/apache/maven-plugins"},{"original_method":"final void extractResourceDirs( Set directories, List resources, File basedir, File workspaceProjectBaseDir,\n                              boolean test, final String output )\n        throws MojoExecutionException\n    {\n        for ( Iterator it = resources.iterator(); it.hasNext(); )\n        {\n            Resource resource = (Resource) it.next();\n\n            getLog().debug( \"Processing resource dir: \" + resource.getDirectory() );\n\n            String includePattern = null;\n            String excludePattern = null;\n\n            if ( resource.getIncludes().size() != 0 )\n            {\n                includePattern = StringUtils.join( resource.getIncludes().iterator(), \"|\" );\n            }\n\n            if ( resource.getExcludes().size() != 0 )\n            {\n                excludePattern = StringUtils.join( resource.getExcludes().iterator(), \"|\" );\n            }\n\n            // TODO: figure out how to merge if the same dir is specified twice\n            // with different in/exclude patterns.\n\n            File resourceDirectory = new File( /* basedir, */resource.getDirectory() );\n\n            if ( !resourceDirectory.exists() || !resourceDirectory.isDirectory() )\n            {\n                getLog().debug( \"Resource dir: \" + resourceDirectory + \" either missing or not a directory.\" );\n                continue;\n            }\n\n            String resourceDir =\n                IdeUtils.toRelativeAndFixSeparator( workspaceProjectBaseDir, resourceDirectory,\n                                                    !workspaceProjectBaseDir.equals( basedir ) );\n            String thisOutput = output;\n            if ( thisOutput != null )\n            {\n                // sometimes thisOutput is already an absolute path\n                File outputFile = new File( thisOutput );\n                if ( !outputFile.isAbsolute() )\n                {\n                    outputFile = new File( workspaceProjectBaseDir, thisOutput );\n                }\n                // create output dir if it doesn't exist\n                outputFile.mkdirs();\n\n                if ( !StringUtils.isEmpty( resource.getTargetPath() ) )\n                {\n                    outputFile = new File( outputFile, resource.getTargetPath() );\n                    // create output dir if it doesn't exist\n                    outputFile.mkdirs();\n                }\n\n                getLog().debug(\n                                \"Making relative and fixing separator: { \" + workspaceProjectBaseDir + \", \"\n                                    + outputFile + \", false }.\" );\n                thisOutput = IdeUtils.toRelativeAndFixSeparator( workspaceProjectBaseDir, outputFile, false );\n            }\n\n            getLog().debug(\n                            \"Adding eclipse source dir: { \" + resourceDir + \", \" + thisOutput + \", true, \" + test\n                                + \", \" + includePattern + \", \" + excludePattern + \" }.\" );\n\n            directories.add( new EclipseSourceDir( resourceDir, thisOutput, true, test, includePattern, excludePattern,\n                                                   resource.isFiltering() ) );\n        }\n    }","id":92283,"modified_method":"final void extractResourceDirs( Set directories, List resources, File basedir, File workspaceProjectBaseDir,\n                              boolean test, final String output )\n        throws MojoExecutionException\n    {\n        for ( Iterator it = resources.iterator(); it.hasNext(); )\n        {\n            Resource resource = (Resource) it.next();\n\n            getLog().debug( \"Processing resource dir: \" + resource.getDirectory() );\n\n            String includePattern = StringUtils.join( resource.getIncludes().iterator(), \"|\" );         \n            \n            List excludes = new ArrayList( resource.getExcludes() );\n            // automatically exclude java files: eclipse doesn't have the concept of resource directory so it will\n            // try to compile any java file found in maven resource dirs\n            excludes.add( JAVA_FILE_PATTERN );\n            String excludePattern = StringUtils.join( excludes.iterator(), \"|\" );\n\n            // TODO: figure out how to merge if the same dir is specified twice\n            // with different in/exclude patterns.\n\n            File resourceDirectory = new File( /* basedir, */resource.getDirectory() );\n\n            if ( !resourceDirectory.exists() || !resourceDirectory.isDirectory() )\n            {\n                getLog().debug( \"Resource dir: \" + resourceDirectory + \" either missing or not a directory.\" );\n                continue;\n            }\n\n            String resourceDir =\n                IdeUtils.toRelativeAndFixSeparator( workspaceProjectBaseDir, resourceDirectory,\n                                                    !workspaceProjectBaseDir.equals( basedir ) );\n            String thisOutput = output;\n            if ( thisOutput != null )\n            {\n                // sometimes thisOutput is already an absolute path\n                File outputFile = new File( thisOutput );\n                if ( !outputFile.isAbsolute() )\n                {\n                    outputFile = new File( workspaceProjectBaseDir, thisOutput );\n                }\n                // create output dir if it doesn't exist\n                outputFile.mkdirs();\n\n                if ( !StringUtils.isEmpty( resource.getTargetPath() ) )\n                {\n                    outputFile = new File( outputFile, resource.getTargetPath() );\n                    // create output dir if it doesn't exist\n                    outputFile.mkdirs();\n                }\n\n                getLog().debug(\n                                \"Making relative and fixing separator: { \" + workspaceProjectBaseDir + \", \"\n                                    + outputFile + \", false }.\" );\n                thisOutput = IdeUtils.toRelativeAndFixSeparator( workspaceProjectBaseDir, outputFile, false );\n            }\n\n            getLog().debug(\n                            \"Adding eclipse source dir: { \" + resourceDir + \", \" + thisOutput + \", true, \" + test\n                                + \", \" + includePattern + \", \" + excludePattern + \" }.\" );\n\n            directories.add( new EclipseSourceDir( resourceDir, thisOutput, true, test, includePattern, excludePattern,\n                                                   resource.isFiltering() ) );\n        }\n    }","commit_id":"537572f1ed11f2d9e9f9e4c5294c867ca8f8c797","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void extractSourceDirs( Set directories, List sourceRoots, File basedir, File projectBaseDir, boolean test,\n                                    String output )\n        throws MojoExecutionException\n    {\n        for ( Iterator it = sourceRoots.iterator(); it.hasNext(); )\n        {\n\n            File sourceRootFile = new File( (String) it.next() );\n\n            if ( sourceRootFile.isDirectory() )\n            {\n                String sourceRoot =\n                    IdeUtils.toRelativeAndFixSeparator( projectBaseDir, sourceRootFile,\n                                                        !projectBaseDir.equals( basedir ) );\n\n                directories.add( new EclipseSourceDir( sourceRoot, output, false, test, null, null, false ) );\n            }\n        }\n    }","id":92284,"modified_method":"private void extractSourceDirs( Set directories, List sourceRoots, File basedir, File projectBaseDir, boolean test,\n                                    String output )\n        throws MojoExecutionException\n    {\n        List includes = new ArrayList();\n        // automatically include java files only: eclipse doesn't have the concept of a source only directory so it \n        // will try to include non-java files found in maven source dirs        \n        includes.add( JAVA_FILE_PATTERN );\n        if ( ajdt ) {\n            includes.add( ASPECTJ_FILE_PATTERN );\n        }\n        String includePattern = StringUtils.join( includes.iterator(), \"|\" );\n        \n        List excludes = new ArrayList();       \n        String excludePattern = StringUtils.join( excludes.iterator(), \"|\" );\n        \n        for ( Iterator it = sourceRoots.iterator(); it.hasNext(); )\n        {\n\n            File sourceRootFile = new File( (String) it.next() );\n\n            if ( sourceRootFile.isDirectory() )\n            {\n                String sourceRoot =\n                    IdeUtils.toRelativeAndFixSeparator( projectBaseDir, sourceRootFile,\n                                                        !projectBaseDir.equals( basedir ) );\n\n                directories.add( new EclipseSourceDir( sourceRoot, output, false, test, includePattern, excludePattern, false ) );\n            }\n        }\n    }","commit_id":"537572f1ed11f2d9e9f9e4c5294c867ca8f8c797","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected RuleChain getChain(String networkId, String accountID,\n                               String routerName, RuleChainCode chainCode){\n        String chainName = getChainName(networkId, routerName, chainCode);\n\n        MultivaluedMap findChain = new MultivaluedMapImpl();\n        findChain.add(\"tenant_id\", accountID);\n\n        ResourceCollection<RuleChain> ruleChains = api.getChains(findChain);\n\n        for(RuleChain chain : ruleChains){\n            if(chain.getName().equals(chainName)){\n                return chain;\n            }\n        }\n\n        return null;\n    }","id":92285,"modified_method":"protected RuleChain getChain(String networkId, String accountUuid,\n                               String routerName, RuleChainCode chainCode){\n        String chainName = getChainName(networkId, routerName, chainCode);\n\n        MultivaluedMap findChain = new MultivaluedMapImpl();\n        findChain.add(\"tenant_id\", accountUuid);\n\n        ResourceCollection<RuleChain> ruleChains = api.getChains(findChain);\n\n        for(RuleChain chain : ruleChains){\n            if(chain.getName().equals(chainName)){\n                return chain;\n            }\n        }\n\n        return null;\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"protected void resetEgressACLFilter(Network network) {\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n        String routerName = getRouterName(isVpc, id);\n\n        RuleChain egressChain = getChain(String.valueOf(network.getId()),\n                                         String.valueOf(network.getAccountId()),\n                                         routerName,\n                                         RuleChainCode.ACL_EGRESS);\n\n        // Clear all the rules out\n        for (Rule rule : egressChain.getRules()) {\n            rule.delete();\n        }\n\n        // Add a matchForwardFlow rule so that we can accept all return traffic\n        egressChain.addRule().type(DtoRule.Accept)\n            .matchForwardFlow(true)\n            .position(1)\n            .create();\n    }","id":92286,"modified_method":"protected void resetEgressACLFilter(Network network) {\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n        String routerName = getRouterName(isVpc, id);\n\n        RuleChain egressChain = getChain(String.valueOf(network.getId()),\n                                         getAccountUuid(network),\n                                         routerName,\n                                         RuleChainCode.ACL_EGRESS);\n\n        // Clear all the rules out\n        for (Rule rule : egressChain.getRules()) {\n            rule.delete();\n        }\n\n        // Add a matchForwardFlow rule so that we can accept all return traffic\n        egressChain.addRule().type(DtoRule.Accept)\n            .matchForwardFlow(true)\n            .position(1)\n            .create();\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"private Bridge getOrCreateNetworkBridge(long networkID, long accountID){\n        Bridge netBridge = getNetworkBridge(networkID, accountID);\n        if(netBridge == null){\n\n            String accountIdStr = String.valueOf(accountID);\n            String networkUUIDStr = String.valueOf(networkID);\n\n            netBridge = api.addBridge().tenantId(accountIdStr).name(networkUUIDStr).create();\n        }\n        return netBridge;\n    }","id":92287,"modified_method":"private Bridge getOrCreateNetworkBridge(long networkID, String accountUuid){\n        Bridge netBridge = getNetworkBridge(networkID, accountUuid);\n        if(netBridge == null){\n\n            String networkUUIDStr = String.valueOf(networkID);\n\n            netBridge = api.addBridge().tenantId(accountUuid).name(networkUUIDStr).create();\n        }\n        return netBridge;\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"private Bridge getOrCreateNetworkBridge(Network network){\n        // Find the single bridge for this network, create if doesn't exist\n        return getOrCreateNetworkBridge(network.getId(), network.getAccountId());\n    }","id":92288,"modified_method":"private Bridge getOrCreateNetworkBridge(Network network){\n        // Find the single bridge for this network, create if doesn't exist\n        return getOrCreateNetworkBridge(network.getId(), getAccountUuid(network));\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"protected RuleChain getChain(String accountID, String routerName, RuleChainCode chainCode){\n        return getChain(\"\", accountID, routerName, chainCode);\n    }","id":92289,"modified_method":"protected RuleChain getChain(String accountUuid, String routerName, RuleChainCode chainCode){\n        return getChain(\"\", accountUuid, routerName, chainCode);\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"private void deleteNetworkBridges(Network network){\n        long accountID = network.getAccountId();\n        long networkID = network.getId();\n\n        Bridge netBridge = getNetworkBridge(networkID, accountID);\n        if(netBridge != null){\n\n            cleanBridge(netBridge);\n\n            // Delete DHCP subnets\n            for(Object dhcpSubnet : netBridge.getDhcpSubnets()){\n                DhcpSubnet sub = (DhcpSubnet) dhcpSubnet;\n                sub.delete();\n            }\n\n            netBridge.delete();\n        }\n    }","id":92290,"modified_method":"private void deleteNetworkBridges(Network network){\n        String accountUuid = getAccountUuid(network);\n        long networkID = network.getId();\n\n        Bridge netBridge = getNetworkBridge(networkID, accountUuid);\n        if(netBridge != null){\n\n            cleanBridge(netBridge);\n\n            // Delete DHCP subnets\n            for(Object dhcpSubnet : netBridge.getDhcpSubnets()){\n                DhcpSubnet sub = (DhcpSubnet) dhcpSubnet;\n                sub.delete();\n            }\n\n            netBridge.delete();\n        }\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"private Router getGuestNetworkRouter(long id, long accountID, boolean isVpc){\n\n        MultivaluedMap qNetRouter = new MultivaluedMapImpl();\n        String accountIdStr = String.valueOf(accountID);\n        String routerName = getRouterName(isVpc, id);\n\n        qNetRouter.add(\"tenant_id\", accountIdStr);\n\n        for (Router router : api.getRouters(qNetRouter)) {\n            if(router.getName().equals(routerName)){\n                return router;\n            }\n        }\n\n        return null;\n    }","id":92291,"modified_method":"private Router getGuestNetworkRouter(long id, String accountUuid, boolean isVpc){\n\n        MultivaluedMap qNetRouter = new MultivaluedMapImpl();\n        String routerName = getRouterName(isVpc, id);\n\n        qNetRouter.add(\"tenant_id\", accountUuid);\n\n        for (Router router : api.getRouters(qNetRouter)) {\n            if(router.getName().equals(routerName)){\n                return router;\n            }\n        }\n\n        return null;\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean associatePublicIP(Network network, final List<? extends PublicIpAddress> ipAddress)\n        throws ResourceUnavailableException {\n\n        s_logger.debug(\"associatePublicIP called with network: \" + network.toString());\n        /*\n         * Get Mido Router for this network and set source rules\n         * These should only be allocated inside the for loop, because\n         * this function could be called as a part of network cleanup. In\n         * that case, we do not want to recreate the guest network or\n         * any ports.\n         */\n        boolean resources = false;\n        Router tenantRouter = null;\n        Router providerRouter = null;\n        RouterPort[] ports = null;\n\n        RouterPort tenantUplink = null;\n        RouterPort providerDownlink = null;\n\n        RuleChain preNat = null;\n        RuleChain post = null;\n        String accountIdStr = null;\n        String routerName = null;\n\n        // Set Source NAT rules on router\n        for (PublicIpAddress ip : ipAddress) {\n            // ip is the external one we sourcenat to\n            if(ip.isSourceNat()){\n                if (resources == false) {\n                    tenantRouter = getOrCreateGuestNetworkRouter(network);\n                    providerRouter = api.getRouter(_providerRouterId);\n                    ports = getOrCreateProviderRouterPorts(tenantRouter, providerRouter);\n\n                    tenantUplink = ports[0];\n                    providerDownlink = ports[1];\n\n                    accountIdStr = String.valueOf(network.getAccountId());\n                    boolean isVpc = getIsVpc(network);\n                    long id = getRouterId(network, isVpc);\n                    routerName = getRouterName(isVpc, id);\n\n                    preNat = getChain(accountIdStr, routerName, RuleChainCode.TR_PRENAT);\n                    post = api.getChain(tenantRouter.getOutboundFilterId());\n                    resources = true;\n                }\n\n                applySourceNat(tenantRouter, providerRouter,    // Routers\n                               tenantUplink, providerDownlink,  // Ports\n                               preNat, post,                       // Chains\n                               ip);                             // The IP\n            }\n        }\n\n        return true;\n    }","id":92292,"modified_method":"public boolean associatePublicIP(Network network, final List<? extends PublicIpAddress> ipAddress)\n        throws ResourceUnavailableException {\n\n        s_logger.debug(\"associatePublicIP called with network: \" + network.toString());\n        /*\n         * Get Mido Router for this network and set source rules\n         * These should only be allocated inside the for loop, because\n         * this function could be called as a part of network cleanup. In\n         * that case, we do not want to recreate the guest network or\n         * any ports.\n         */\n        boolean resources = false;\n        Router tenantRouter = null;\n        Router providerRouter = null;\n        RouterPort[] ports = null;\n\n        RouterPort tenantUplink = null;\n        RouterPort providerDownlink = null;\n\n        RuleChain preNat = null;\n        RuleChain post = null;\n        String accountIdStr = null;\n        String routerName = null;\n\n        // Set Source NAT rules on router\n        for (PublicIpAddress ip : ipAddress) {\n            // ip is the external one we sourcenat to\n            if(ip.isSourceNat()){\n                if (resources == false) {\n                    tenantRouter = getOrCreateGuestNetworkRouter(network);\n                    providerRouter = api.getRouter(_providerRouterId);\n                    ports = getOrCreateProviderRouterPorts(tenantRouter, providerRouter);\n\n                    tenantUplink = ports[0];\n                    providerDownlink = ports[1];\n\n                    accountIdStr = getAccountUuid(network);\n                    boolean isVpc = getIsVpc(network);\n                    long id = getRouterId(network, isVpc);\n                    routerName = getRouterName(isVpc, id);\n\n                    preNat = getChain(accountIdStr, routerName, RuleChainCode.TR_PRENAT);\n                    post = api.getChain(tenantRouter.getOutboundFilterId());\n                    resources = true;\n                }\n\n                applySourceNat(tenantRouter, providerRouter,    // Routers\n                               tenantUplink, providerDownlink,  // Ports\n                               preNat, post,                       // Chains\n                               ip);                             // The IP\n            }\n        }\n\n        return true;\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Router createRouter(long id, long accountID, boolean isVpc) {\n\n        String accountIdStr = String.valueOf(accountID);\n        String routerName = getRouterName(isVpc, id);\n\n        //Set up rule chains\n        RuleChain pre = api.addChain()\n                            .name(getChainName(routerName, RuleChainCode.TR_PRE))\n                            .tenantId(accountIdStr)\n                            .create();\n        RuleChain post = api.addChain()\n                            .name(getChainName(routerName, RuleChainCode.TR_POST))\n                            .tenantId(accountIdStr)\n                            .create();\n\n        // Set up NAT and filter chains for pre-routing\n        RuleChain preFilter = api.addChain()\n                                  .name(getChainName(routerName, RuleChainCode.TR_PREFILTER))\n                                  .tenantId(accountIdStr)\n                                  .create();\n        RuleChain preNat = api.addChain()\n                                  .name(getChainName(routerName, RuleChainCode.TR_PRENAT))\n                                  .tenantId(accountIdStr)\n                                  .create();\n\n        // Hook the chains in - first jump to Filter chain, then jump to Nat chain\n        pre.addRule().type(DtoRule.Jump)\n                     .jumpChainId(preFilter.getId())\n                     .position(1)\n                     .create();\n        pre.addRule().type(DtoRule.Jump)\n                     .jumpChainId(preNat.getId())\n                     .position(2)\n                     .create();\n\n        return api.addRouter()\n                   .tenantId(accountIdStr)\n                   .name(routerName)\n                   .inboundFilterId(pre.getId())\n                   .outboundFilterId(post.getId())\n                   .create();\n    }","id":92293,"modified_method":"protected Router createRouter(long id, String accountUuid, boolean isVpc) {\n\n        String routerName = getRouterName(isVpc, id);\n\n        //Set up rule chains\n        RuleChain pre = api.addChain()\n                            .name(getChainName(routerName, RuleChainCode.TR_PRE))\n                            .tenantId(accountUuid)\n                            .create();\n        RuleChain post = api.addChain()\n                            .name(getChainName(routerName, RuleChainCode.TR_POST))\n                            .tenantId(accountUuid)\n                            .create();\n\n        // Set up NAT and filter chains for pre-routing\n        RuleChain preFilter = api.addChain()\n                                  .name(getChainName(routerName, RuleChainCode.TR_PREFILTER))\n                                  .tenantId(accountUuid)\n                                  .create();\n        RuleChain preNat = api.addChain()\n                                  .name(getChainName(routerName, RuleChainCode.TR_PRENAT))\n                                  .tenantId(accountUuid)\n                                  .create();\n\n        // Hook the chains in - first jump to Filter chain, then jump to Nat chain\n        pre.addRule().type(DtoRule.Jump)\n                     .jumpChainId(preFilter.getId())\n                     .position(1)\n                     .create();\n        pre.addRule().type(DtoRule.Jump)\n                     .jumpChainId(preNat.getId())\n                     .position(2)\n                     .create();\n\n        return api.addRouter()\n                   .tenantId(accountUuid)\n                   .name(routerName)\n                   .inboundFilterId(pre.getId())\n                   .outboundFilterId(post.getId())\n                   .create();\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean applyPFRules(Network network, List<PortForwardingRule> rules)\n                    throws ResourceUnavailableException {\n        s_logger.debug(\"applyPFRules called with network \" + network.toString());\n        if (!midoInNetwork(network)) {\n            return false;\n        }\n        if (!canHandle(network, Service.PortForwarding)) {\n            return false;\n        }\n\n        String accountIdStr = String.valueOf(network.getAccountId());\n        String networkUUIDStr = String.valueOf(network.getId());\n        RuleChain preNat = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PRENAT);\n        RuleChain postNat = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_POST);\n        RuleChain preFilter = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PREFILTER);\n        Router providerRouter = api.getRouter(_providerRouterId);\n        Router tenantRouter = getOrCreateGuestNetworkRouter(network);\n        RouterPort[] ports = getOrCreateProviderRouterPorts(tenantRouter, providerRouter);\n        RouterPort providerDownlink = ports[1];\n\n        // Rules in the preNat table\n        Map<String, Rule> existingPreNatRules = new HashMap<String, Rule>();\n        for (Rule existingRule : preNat.getRules()) {\n            String ruleString = new SimpleFirewallRule(existingRule).toStringArray()[0];\n            existingPreNatRules.put(ruleString, existingRule);\n        }\n\n        /*\n         * Counts of rules associated with an IP address. Use this to check\n         * how many rules we have of a given IP address. When it reaches 0,\n         * we can delete the route associated with it.\n         */\n        Map<String, Integer> ipRuleCounts = new HashMap<String, Integer>();\n        for (Rule rule : preNat.getRules()) {\n            String ip = rule.getNwDstAddress();\n            if (ip != null && rule.getNwDstLength() == 32) {\n                if (ipRuleCounts.containsKey(ip)) {\n                    ipRuleCounts.put(ip, new Integer(ipRuleCounts.get(ip).intValue() + 1));\n                } else {\n                    ipRuleCounts.put(ip, new Integer(1));\n                }\n            }\n        }\n\n        /*\n         * Routes associated with IP. When we delete all the rules associated\n         * with a given IP, we can delete the route associated with it.\n         */\n        Map<String, Route> routes = new HashMap<String, Route>();\n        for (Route route : providerRouter.getRoutes(new MultivaluedMapImpl())) {\n            String ip = route.getDstNetworkAddr();\n            if (ip != null && route.getDstNetworkLength() == 32) {\n                routes.put(ip, route);\n            }\n        }\n\n        for (PortForwardingRule rule : rules) {\n            IpAddress dstIp = _networkModel.getIp(rule.getSourceIpAddressId());\n            PortForwardingRuleTO ruleTO = new PortForwardingRuleTO(rule, null, dstIp.getAddress().addr());\n            SimpleFirewallRule fwRule = new SimpleFirewallRule(ruleTO);\n            String[] ruleStrings = fwRule.toStringArray();\n\n            if (rule.getState() == FirewallRule.State.Revoke) {\n                /*\n                 * Lookup in existingRules, delete if present\n                 * We need to delete from both the preNat table and the\n                 * postNat table.\n                 */\n                for(String revokeRuleString : ruleStrings){\n                    Rule foundPreNatRule = existingPreNatRules.get(revokeRuleString);\n                    if(foundPreNatRule != null){\n                        String ip = foundPreNatRule.getNwDstAddress();\n                        // is this the last rule associated with this IP?\n                        Integer cnt = ipRuleCounts.get(ip);\n                        if (cnt != null) {\n                            if (cnt == 1) {\n                                ipRuleCounts.remove(ip);\n                                // no more rules for this IP. delete the route.\n                                Route route = routes.remove(ip);\n                                route.delete();\n                            } else {\n                                ipRuleCounts.put(ip, new Integer(ipRuleCounts.get(ip).intValue() - 1));\n                            }\n                        }\n                        foundPreNatRule.delete();\n                    }\n                }\n            } else if (rule.getState() == FirewallRule.State.Add) {\n                for(int i = 0; i < ruleStrings.length; i++){\n                    String ruleString = ruleStrings[i];\n                    Rule foundRule = existingPreNatRules.get(ruleString);\n                    if(foundRule == null){\n\n                        String vmIp = ruleTO.getDstIp();\n                        String publicIp = dstIp.getAddress().addr();\n                        int privPortStart = ruleTO.getDstPortRange()[0];\n                        int privPortEnd = ruleTO.getDstPortRange()[1];\n                        int pubPortStart = ruleTO.getSrcPortRange()[0];\n                        int pubPortEnd = ruleTO.getSrcPortRange()[1];\n\n                        DtoRule.DtoNatTarget[] preTargets = new DtoRule.DtoNatTarget[]{\n                            new DtoRule.DtoNatTarget(vmIp, vmIp, privPortStart, privPortEnd)};\n\n                        Rule preNatRule = preNat.addRule()\n                            .type(DtoRule.DNAT)\n                            .flowAction(DtoRule.Accept)\n                            .nwDstAddress(publicIp)\n                            .nwDstLength(32)\n                            .tpDstStart(pubPortStart)\n                            .tpDstEnd(pubPortEnd)\n                            .natTargets(preTargets)\n                            .nwProto(SimpleFirewallRule.stringToProtocolNumber(rule.getProtocol()))\n                            .position(1);\n\n                        Integer cnt = ipRuleCounts.get(publicIp);\n                        if (cnt != null) {\n                            ipRuleCounts.put(publicIp, new Integer(cnt.intValue() + 1));\n                        } else {\n                            ipRuleCounts.put(publicIp, new Integer(1));\n                        }\n                        String preNatRuleStr = new SimpleFirewallRule(preNatRule).toStringArray()[0];\n                        existingPreNatRules.put(preNatRuleStr, preNatRule);\n                        preNatRule.create();\n\n                        if (routes.get(publicIp) == null) {\n                            Route route = providerRouter.addRoute()\n                                            .type(\"Normal\")\n                                            .weight(100)\n                                            .srcNetworkAddr(\"0.0.0.0\")\n                                            .srcNetworkLength(0)\n                                            .dstNetworkAddr(publicIp)\n                                            .dstNetworkLength(32)\n                                            .nextHopPort(providerDownlink.getId());\n                            route.create();\n                            routes.put(publicIp, route);\n                        }\n\n                        // If Firewall is in our service offering, set up the\n                        // default firewall rule\n                        if (canHandle(network, Service.Firewall)) {\n                            boolean defaultBlock = false;\n                            for (Rule filterRule : preFilter.getRules()) {\n                                String pfDstIp = filterRule.getNwDstAddress();\n                                if (pfDstIp != null && filterRule.getNwDstAddress().equals(publicIp)) {\n                                    defaultBlock = true;\n                                    break;\n                                }\n                            }\n                            if (!defaultBlock) {\n                                preFilter.addRule().type(DtoRule.Drop)\n                                    .nwDstAddress(publicIp)\n                                    .nwDstLength(32)\n                                    .create();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }","id":92294,"modified_method":"@Override\n    public boolean applyPFRules(Network network, List<PortForwardingRule> rules)\n                    throws ResourceUnavailableException {\n        s_logger.debug(\"applyPFRules called with network \" + network.toString());\n        if (!midoInNetwork(network)) {\n            return false;\n        }\n        if (!canHandle(network, Service.PortForwarding)) {\n            return false;\n        }\n\n        String accountIdStr = getAccountUuid(network);\n        String networkUUIDStr = String.valueOf(network.getId());\n        RuleChain preNat = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PRENAT);\n        RuleChain postNat = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_POST);\n        RuleChain preFilter = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PREFILTER);\n        Router providerRouter = api.getRouter(_providerRouterId);\n        Router tenantRouter = getOrCreateGuestNetworkRouter(network);\n        RouterPort[] ports = getOrCreateProviderRouterPorts(tenantRouter, providerRouter);\n        RouterPort providerDownlink = ports[1];\n\n        // Rules in the preNat table\n        Map<String, Rule> existingPreNatRules = new HashMap<String, Rule>();\n        for (Rule existingRule : preNat.getRules()) {\n            String ruleString = new SimpleFirewallRule(existingRule).toStringArray()[0];\n            existingPreNatRules.put(ruleString, existingRule);\n        }\n\n        /*\n         * Counts of rules associated with an IP address. Use this to check\n         * how many rules we have of a given IP address. When it reaches 0,\n         * we can delete the route associated with it.\n         */\n        Map<String, Integer> ipRuleCounts = new HashMap<String, Integer>();\n        for (Rule rule : preNat.getRules()) {\n            String ip = rule.getNwDstAddress();\n            if (ip != null && rule.getNwDstLength() == 32) {\n                if (ipRuleCounts.containsKey(ip)) {\n                    ipRuleCounts.put(ip, new Integer(ipRuleCounts.get(ip).intValue() + 1));\n                } else {\n                    ipRuleCounts.put(ip, new Integer(1));\n                }\n            }\n        }\n\n        /*\n         * Routes associated with IP. When we delete all the rules associated\n         * with a given IP, we can delete the route associated with it.\n         */\n        Map<String, Route> routes = new HashMap<String, Route>();\n        for (Route route : providerRouter.getRoutes(new MultivaluedMapImpl())) {\n            String ip = route.getDstNetworkAddr();\n            if (ip != null && route.getDstNetworkLength() == 32) {\n                routes.put(ip, route);\n            }\n        }\n\n        for (PortForwardingRule rule : rules) {\n            IpAddress dstIp = _networkModel.getIp(rule.getSourceIpAddressId());\n            PortForwardingRuleTO ruleTO = new PortForwardingRuleTO(rule, null, dstIp.getAddress().addr());\n            SimpleFirewallRule fwRule = new SimpleFirewallRule(ruleTO);\n            String[] ruleStrings = fwRule.toStringArray();\n\n            if (rule.getState() == FirewallRule.State.Revoke) {\n                /*\n                 * Lookup in existingRules, delete if present\n                 * We need to delete from both the preNat table and the\n                 * postNat table.\n                 */\n                for(String revokeRuleString : ruleStrings){\n                    Rule foundPreNatRule = existingPreNatRules.get(revokeRuleString);\n                    if(foundPreNatRule != null){\n                        String ip = foundPreNatRule.getNwDstAddress();\n                        // is this the last rule associated with this IP?\n                        Integer cnt = ipRuleCounts.get(ip);\n                        if (cnt != null) {\n                            if (cnt == 1) {\n                                ipRuleCounts.remove(ip);\n                                // no more rules for this IP. delete the route.\n                                Route route = routes.remove(ip);\n                                route.delete();\n                            } else {\n                                ipRuleCounts.put(ip, new Integer(ipRuleCounts.get(ip).intValue() - 1));\n                            }\n                        }\n                        foundPreNatRule.delete();\n                    }\n                }\n            } else if (rule.getState() == FirewallRule.State.Add) {\n                for(int i = 0; i < ruleStrings.length; i++){\n                    String ruleString = ruleStrings[i];\n                    Rule foundRule = existingPreNatRules.get(ruleString);\n                    if(foundRule == null){\n\n                        String vmIp = ruleTO.getDstIp();\n                        String publicIp = dstIp.getAddress().addr();\n                        int privPortStart = ruleTO.getDstPortRange()[0];\n                        int privPortEnd = ruleTO.getDstPortRange()[1];\n                        int pubPortStart = ruleTO.getSrcPortRange()[0];\n                        int pubPortEnd = ruleTO.getSrcPortRange()[1];\n\n                        DtoRule.DtoNatTarget[] preTargets = new DtoRule.DtoNatTarget[]{\n                            new DtoRule.DtoNatTarget(vmIp, vmIp, privPortStart, privPortEnd)};\n\n                        Rule preNatRule = preNat.addRule()\n                            .type(DtoRule.DNAT)\n                            .flowAction(DtoRule.Accept)\n                            .nwDstAddress(publicIp)\n                            .nwDstLength(32)\n                            .tpDstStart(pubPortStart)\n                            .tpDstEnd(pubPortEnd)\n                            .natTargets(preTargets)\n                            .nwProto(SimpleFirewallRule.stringToProtocolNumber(rule.getProtocol()))\n                            .position(1);\n\n                        Integer cnt = ipRuleCounts.get(publicIp);\n                        if (cnt != null) {\n                            ipRuleCounts.put(publicIp, new Integer(cnt.intValue() + 1));\n                        } else {\n                            ipRuleCounts.put(publicIp, new Integer(1));\n                        }\n                        String preNatRuleStr = new SimpleFirewallRule(preNatRule).toStringArray()[0];\n                        existingPreNatRules.put(preNatRuleStr, preNatRule);\n                        preNatRule.create();\n\n                        if (routes.get(publicIp) == null) {\n                            Route route = providerRouter.addRoute()\n                                            .type(\"Normal\")\n                                            .weight(100)\n                                            .srcNetworkAddr(\"0.0.0.0\")\n                                            .srcNetworkLength(0)\n                                            .dstNetworkAddr(publicIp)\n                                            .dstNetworkLength(32)\n                                            .nextHopPort(providerDownlink.getId());\n                            route.create();\n                            routes.put(publicIp, route);\n                        }\n\n                        // If Firewall is in our service offering, set up the\n                        // default firewall rule\n                        if (canHandle(network, Service.Firewall)) {\n                            boolean defaultBlock = false;\n                            for (Rule filterRule : preFilter.getRules()) {\n                                String pfDstIp = filterRule.getNwDstAddress();\n                                if (pfDstIp != null && filterRule.getNwDstAddress().equals(publicIp)) {\n                                    defaultBlock = true;\n                                    break;\n                                }\n                            }\n                            if (!defaultBlock) {\n                                preFilter.addRule().type(DtoRule.Drop)\n                                    .nwDstAddress(publicIp)\n                                    .nwDstLength(32)\n                                    .create();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"private void deleteGuestNetworkRouters(Network network){\n        long accountID = network.getAccountId();\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n\n        Router tenantRouter = getGuestNetworkRouter(id, accountID, isVpc);\n\n        // Delete any peer ports corresponding to this router\n        for(Port peerPort : tenantRouter.getPeerPorts((new MultivaluedMapImpl()))){\n            if(peerPort != null && peerPort instanceof RouterPort){\n                RouterPort checkPort = (RouterPort) peerPort;\n                if(checkPort.getType().equals(\"ExteriorRouter\")) {\n                    checkPort.vifId(null).update();\n                } else if (checkPort.getType().equals(\"InteriorRouter\")) {\n                    checkPort.unlink();\n                }\n                checkPort.delete();\n            } else if (peerPort != null && peerPort instanceof BridgePort) {\n                BridgePort checkPort = (BridgePort) peerPort;\n                if(checkPort.getType().equals(\"ExteriorBridge\")) {\n                    checkPort.vifId(null).update();\n                } else if (checkPort.getType().equals(\"InteriorBridge\")) {\n                    checkPort.unlink();\n                }\n                checkPort.delete();\n            }\n        }\n\n        if(tenantRouter != null){\n            // Remove all peer ports if any exist\n            for(RouterPort p : tenantRouter.getPorts(new MultivaluedMapImpl())) {\n                if(p.getType().equals(\"ExteriorRouter\")) {\n                    // Set VIF ID to null\n                    p.vifId(null).update();\n                    // the port might have some chains associated with it\n                }\n\n                if(p.getType().equals(\"InteriorRouter\")) {\n                    p.unlink();\n                }\n\n                // Delete port\n                p.delete();\n            }\n\n            // Remove inbound and outbound filter chains\n            String accountIdStr = String.valueOf(accountID);\n            String routerName = getRouterName(isVpc, id);\n\n            RuleChain pre = api.getChain(tenantRouter.getInboundFilterId());\n            RuleChain preFilter = getChain(accountIdStr, routerName, RuleChainCode.TR_PREFILTER);\n            RuleChain preNat = getChain(accountIdStr, routerName, RuleChainCode.TR_PRENAT);\n            RuleChain post = api.getChain(tenantRouter.getOutboundFilterId());\n\n            pre.delete();\n            preFilter.delete();\n            preNat.delete();\n            post.delete();\n\n\n            // Remove routes\n            for(Route r : tenantRouter.getRoutes(new MultivaluedMapImpl())) {\n                r.delete();\n            }\n\n            tenantRouter.delete();\n        }\n    }","id":92295,"modified_method":"private void deleteGuestNetworkRouters(Network network){\n        String accountUuid = getAccountUuid(network);\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n\n        Router tenantRouter = getGuestNetworkRouter(id, accountUuid, isVpc);\n\n        // Delete any peer ports corresponding to this router\n        for(Port peerPort : tenantRouter.getPeerPorts((new MultivaluedMapImpl()))){\n            if(peerPort != null && peerPort instanceof RouterPort){\n                RouterPort checkPort = (RouterPort) peerPort;\n                if(checkPort.getType().equals(\"ExteriorRouter\")) {\n                    checkPort.vifId(null).update();\n                } else if (checkPort.getType().equals(\"InteriorRouter\")) {\n                    checkPort.unlink();\n                }\n                checkPort.delete();\n            } else if (peerPort != null && peerPort instanceof BridgePort) {\n                BridgePort checkPort = (BridgePort) peerPort;\n                if(checkPort.getType().equals(\"ExteriorBridge\")) {\n                    checkPort.vifId(null).update();\n                } else if (checkPort.getType().equals(\"InteriorBridge\")) {\n                    checkPort.unlink();\n                }\n                checkPort.delete();\n            }\n        }\n\n        if(tenantRouter != null){\n            // Remove all peer ports if any exist\n            for(RouterPort p : tenantRouter.getPorts(new MultivaluedMapImpl())) {\n                if(p.getType().equals(\"ExteriorRouter\")) {\n                    // Set VIF ID to null\n                    p.vifId(null).update();\n                    // the port might have some chains associated with it\n                }\n\n                if(p.getType().equals(\"InteriorRouter\")) {\n                    p.unlink();\n                }\n\n                // Delete port\n                p.delete();\n            }\n\n            // Remove inbound and outbound filter chains\n            String accountIdStr = String.valueOf(accountUuid);\n            String routerName = getRouterName(isVpc, id);\n\n            RuleChain pre = api.getChain(tenantRouter.getInboundFilterId());\n            RuleChain preFilter = getChain(accountIdStr, routerName, RuleChainCode.TR_PREFILTER);\n            RuleChain preNat = getChain(accountIdStr, routerName, RuleChainCode.TR_PRENAT);\n            RuleChain post = api.getChain(tenantRouter.getOutboundFilterId());\n\n            pre.delete();\n            preFilter.delete();\n            preNat.delete();\n            post.delete();\n\n\n            // Remove routes\n            for(Route r : tenantRouter.getRoutes(new MultivaluedMapImpl())) {\n                r.delete();\n            }\n\n            tenantRouter.delete();\n        }\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean midoInNetwork(Network network) {\n        for (String pname : _ntwkSrvcDao.getDistinctProviders(network.getId())) {\n            if (pname.equals(getProvider().getName())) {\n                return true;\n            }\n        }\n        return false;\n    }","id":92296,"modified_method":"public boolean midoInNetwork(Network network) {\n        if((network.getTrafficType() == Networks.TrafficType.Public) &&\n           (network.getBroadcastDomainType() == Networks.BroadcastDomainType.Mido)){\n            return true;\n        }\n        if((network.getTrafficType() == Networks.TrafficType.Guest) &&\n           (network.getBroadcastDomainType() == Networks.BroadcastDomainType.Mido)){\n            return true;\n        }\n        return false;\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * From interface StaticNatServiceProvider\n     */\n    @Override\n    public boolean applyStaticNats(Network network,\n                                   List<? extends StaticNat> rules)\n            throws ResourceUnavailableException {\n        s_logger.debug(\"applyStaticNats called with network: \" + network.toString());\n        if (!midoInNetwork(network)) {\n            return false;\n        }\n        if (!canHandle(network, Service.StaticNat)) {\n            return false;\n        }\n\n        boolean resources = false;\n        Router tenantRouter = null;\n        Router providerRouter = null;\n\n        RouterPort[] ports = null;\n\n        RouterPort tenantUplink = null;\n        RouterPort providerDownlink = null;\n\n        RuleChain preFilter = null;\n        RuleChain preNat = null;\n        RuleChain post = null;\n\n        String accountIdStr = String.valueOf(network.getAccountId());\n        String networkUUIDStr = String.valueOf(network.getId());\n\n        for (StaticNat rule : rules) {\n            IpAddress sourceIp = _networkModel.getIp(rule.getSourceIpAddressId());\n            String sourceIpAddr = sourceIp.getAddress().addr();\n\n            if (resources == false) {\n                tenantRouter = getOrCreateGuestNetworkRouter(network);\n                providerRouter = api.getRouter(_providerRouterId);\n\n                ports = getOrCreateProviderRouterPorts(tenantRouter, providerRouter);\n\n                tenantUplink = ports[0];\n                providerDownlink = ports[1];\n\n                boolean isVpc = getIsVpc(network);\n                long id = getRouterId(network, isVpc);\n                String routerName = getRouterName(isVpc, id);\n\n                preFilter = getChain(accountIdStr, routerName, RuleChainCode.TR_PREFILTER);\n                preNat = getChain(accountIdStr, routerName, RuleChainCode.TR_PRENAT);\n                post = api.getChain(tenantRouter.getOutboundFilterId());\n                resources = true;\n            }\n\n            if (rule.isForRevoke()) {\n                removeMidonetStaticNAT(preFilter, preNat, post,\n                                       sourceIpAddr, rule.getDestIpAddress(),\n                                       providerRouter);\n            } else {\n                addMidonetStaticNAT(preFilter, preNat, post,\n                                    sourceIpAddr, rule.getDestIpAddress(),\n                                    tenantUplink, providerDownlink,\n                                    providerRouter,\n                                    network);\n            }\n        }\n\n        return true;\n    }","id":92297,"modified_method":"/**\n     * From interface StaticNatServiceProvider\n     */\n    @Override\n    public boolean applyStaticNats(Network network,\n                                   List<? extends StaticNat> rules)\n            throws ResourceUnavailableException {\n        s_logger.debug(\"applyStaticNats called with network: \" + network.toString());\n        if (!midoInNetwork(network)) {\n            return false;\n        }\n        if (!canHandle(network, Service.StaticNat)) {\n            return false;\n        }\n\n        boolean resources = false;\n        Router tenantRouter = null;\n        Router providerRouter = null;\n\n        RouterPort[] ports = null;\n\n        RouterPort tenantUplink = null;\n        RouterPort providerDownlink = null;\n\n        RuleChain preFilter = null;\n        RuleChain preNat = null;\n        RuleChain post = null;\n\n        String accountIdStr = getAccountUuid(network);\n        String networkUUIDStr = String.valueOf(network.getId());\n\n        for (StaticNat rule : rules) {\n            IpAddress sourceIp = _networkModel.getIp(rule.getSourceIpAddressId());\n            String sourceIpAddr = sourceIp.getAddress().addr();\n\n            if (resources == false) {\n                tenantRouter = getOrCreateGuestNetworkRouter(network);\n                providerRouter = api.getRouter(_providerRouterId);\n\n                ports = getOrCreateProviderRouterPorts(tenantRouter, providerRouter);\n\n                tenantUplink = ports[0];\n                providerDownlink = ports[1];\n\n                boolean isVpc = getIsVpc(network);\n                long id = getRouterId(network, isVpc);\n                String routerName = getRouterName(isVpc, id);\n\n                preFilter = getChain(accountIdStr, routerName, RuleChainCode.TR_PREFILTER);\n                preNat = getChain(accountIdStr, routerName, RuleChainCode.TR_PRENAT);\n                post = api.getChain(tenantRouter.getOutboundFilterId());\n                resources = true;\n            }\n\n            if (rule.isForRevoke()) {\n                removeMidonetStaticNAT(preFilter, preNat, post,\n                                       sourceIpAddr, rule.getDestIpAddress(),\n                                       providerRouter);\n            } else {\n                addMidonetStaticNAT(preFilter, preNat, post,\n                                    sourceIpAddr, rule.getDestIpAddress(),\n                                    tenantUplink, providerDownlink,\n                                    providerRouter,\n                                    network);\n            }\n        }\n\n        return true;\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"private Router getOrCreateGuestNetworkRouter(Network network){\n        // Find the single bridge for this (isolated) guest network, create if doesn't exist\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n\n        return getOrCreateGuestNetworkRouter(id, network.getAccountId(), isVpc);\n\n    }","id":92298,"modified_method":"private Router getOrCreateGuestNetworkRouter(Network network){\n        // Find the single bridge for this (isolated) guest network, create if doesn't exist\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n\n        return getOrCreateGuestNetworkRouter(id, getAccountUuid(network), isVpc);\n\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean applyFWRules(Network config, List<? extends FirewallRule> rulesToApply) throws ResourceUnavailableException {\n        if (!midoInNetwork(config)) {\n            return false;\n        }\n        if (canHandle(config, Service.Firewall)) {\n            String accountIdStr = String.valueOf(config.getAccountId());\n            String networkUUIDStr = String.valueOf(config.getId());\n            RuleChain preFilter = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PREFILTER);\n            RuleChain preNat = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PRENAT);\n\n            // Create a map of Rule description -> Rule for quicker lookups\n            Map<String, Rule> existingRules = new HashMap<String, Rule>();\n\n            for (Rule existingRule : preFilter.getRules()) {\n                // The \"whitelist\" rules we're interested in are the Jump rules where src address is specified\n                if(existingRule.getType().equals(DtoRule.Jump) && existingRule.getNwSrcAddress() != null){\n                    String ruleString = new SimpleFirewallRule(existingRule).toStringArray()[0];\n                    existingRules.put(ruleString, existingRule);\n                }\n            }\n\n            for (FirewallRule rule : rulesToApply) {\n                IpAddress dstIp = _networkModel.getIp(rule.getSourceIpAddressId());\n                FirewallRuleTO ruleTO = new FirewallRuleTO(rule, null, dstIp.getAddress().addr());\n\n                // Convert to string representation\n                SimpleFirewallRule fwRule = new SimpleFirewallRule(ruleTO);\n                String[] ruleStrings = fwRule.toStringArray();\n\n                if (rule.getState() == FirewallRule.State.Revoke) {\n                    // Lookup in existingRules, delete if present\n                    for(String revokeRuleString : ruleStrings){\n                        Rule foundRule = existingRules.get(revokeRuleString);\n                        if(foundRule != null){\n                            foundRule.delete();\n                        }\n                    }\n                } else if (rule.getState() == FirewallRule.State.Add) {\n                    // Lookup in existingRules, add if not present\n                    for(int i = 0; i < ruleStrings.length; i++){\n                        String ruleString = ruleStrings[i];\n                        Rule foundRule = existingRules.get(ruleString);\n                        if(foundRule == null){\n                            // Get the cidr for the related entry in the Source Cidrs list\n                            String relatedCidr = fwRule.sourceCidrs.get(i);\n                            Pair<String,Integer> cidrParts = NetUtils.getCidr(relatedCidr);\n\n                            // Create rule with correct proto, cidr, ACCEPT, dst IP\n                            Rule toApply = preFilter.addRule()\n                                    .type(DtoRule.Jump)\n                                    .jumpChainId(preNat.getId())\n                                    .position(1)\n                                    .nwSrcAddress(cidrParts.first())\n                                    .nwSrcLength(cidrParts.second())\n                                    .nwDstAddress(ruleTO.getSrcIp())\n                                    .nwDstLength(32)\n                                    .nwProto(SimpleFirewallRule.stringToProtocolNumber(rule.getProtocol()));\n\n                            if(rule.getProtocol().equals(\"icmp\")){\n                                // ICMP rules - reuse port fields\n                                toApply.tpSrcStart(fwRule.icmpType).tpSrcEnd(fwRule.icmpType)\n                                    .tpDstStart(fwRule.icmpCode).tpDstEnd(fwRule.icmpCode);\n                            } else {\n                                toApply.tpDstStart(fwRule.dstPortStart)\n                                        .tpDstEnd(fwRule.dstPortEnd);\n                            }\n\n                            toApply.create();\n                        }\n                    }\n                }\n            }\n            return true;\n        } else {\n            return true;\n        }\n    }","id":92299,"modified_method":"@Override\n    public boolean applyFWRules(Network config, List<? extends FirewallRule> rulesToApply) throws ResourceUnavailableException {\n        if (!midoInNetwork(config)) {\n            return false;\n        }\n        if (canHandle(config, Service.Firewall)) {\n            String accountIdStr = getAccountUuid(config);\n            String networkUUIDStr = String.valueOf(config.getId());\n            RuleChain preFilter = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PREFILTER);\n            RuleChain preNat = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PRENAT);\n\n            // Create a map of Rule description -> Rule for quicker lookups\n            Map<String, Rule> existingRules = new HashMap<String, Rule>();\n\n            for (Rule existingRule : preFilter.getRules()) {\n                // The \"whitelist\" rules we're interested in are the Jump rules where src address is specified\n                if(existingRule.getType().equals(DtoRule.Jump) && existingRule.getNwSrcAddress() != null){\n                    String ruleString = new SimpleFirewallRule(existingRule).toStringArray()[0];\n                    existingRules.put(ruleString, existingRule);\n                }\n            }\n\n            for (FirewallRule rule : rulesToApply) {\n                IpAddress dstIp = _networkModel.getIp(rule.getSourceIpAddressId());\n                FirewallRuleTO ruleTO = new FirewallRuleTO(rule, null, dstIp.getAddress().addr());\n\n                // Convert to string representation\n                SimpleFirewallRule fwRule = new SimpleFirewallRule(ruleTO);\n                String[] ruleStrings = fwRule.toStringArray();\n\n                if (rule.getState() == FirewallRule.State.Revoke) {\n                    // Lookup in existingRules, delete if present\n                    for(String revokeRuleString : ruleStrings){\n                        Rule foundRule = existingRules.get(revokeRuleString);\n                        if(foundRule != null){\n                            foundRule.delete();\n                        }\n                    }\n                } else if (rule.getState() == FirewallRule.State.Add) {\n                    // Lookup in existingRules, add if not present\n                    for(int i = 0; i < ruleStrings.length; i++){\n                        String ruleString = ruleStrings[i];\n                        Rule foundRule = existingRules.get(ruleString);\n                        if(foundRule == null){\n                            // Get the cidr for the related entry in the Source Cidrs list\n                            String relatedCidr = fwRule.sourceCidrs.get(i);\n                            Pair<String,Integer> cidrParts = NetUtils.getCidr(relatedCidr);\n\n                            // Create rule with correct proto, cidr, ACCEPT, dst IP\n                            Rule toApply = preFilter.addRule()\n                                    .type(DtoRule.Jump)\n                                    .jumpChainId(preNat.getId())\n                                    .position(1)\n                                    .nwSrcAddress(cidrParts.first())\n                                    .nwSrcLength(cidrParts.second())\n                                    .nwDstAddress(ruleTO.getSrcIp())\n                                    .nwDstLength(32)\n                                    .nwProto(SimpleFirewallRule.stringToProtocolNumber(rule.getProtocol()));\n\n                            if(rule.getProtocol().equals(\"icmp\")){\n                                // ICMP rules - reuse port fields\n                                toApply.tpSrcStart(fwRule.icmpType).tpSrcEnd(fwRule.icmpType)\n                                    .tpDstStart(fwRule.icmpCode).tpDstEnd(fwRule.icmpCode);\n                            } else {\n                                toApply.tpDstStart(fwRule.dstPortStart)\n                                        .tpDstEnd(fwRule.dstPortEnd);\n                            }\n\n                            toApply.create();\n                        }\n                    }\n                }\n            }\n            return true;\n        } else {\n            return true;\n        }\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"private Router getOrCreateGuestNetworkRouter(long id, long accountID, boolean isVpc) {\n        Router tenantRouter = getGuestNetworkRouter(id, accountID, isVpc);\n        if(tenantRouter == null){\n            tenantRouter = createRouter(id, accountID, isVpc);\n        }\n        return tenantRouter;\n    }","id":92300,"modified_method":"private Router getOrCreateGuestNetworkRouter(long id, String accountUuid, boolean isVpc) {\n        Router tenantRouter = getGuestNetworkRouter(id, accountUuid, isVpc);\n        if(tenantRouter == null){\n            tenantRouter = createRouter(id, accountUuid, isVpc);\n        }\n        return tenantRouter;\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"private Bridge getNetworkBridge(long networkID, long accountID){\n\n        MultivaluedMap qNetBridge = new MultivaluedMapImpl();\n        String accountIdStr = String.valueOf(accountID);\n        String networkUUIDStr = String.valueOf(networkID);\n        qNetBridge.add(\"tenant_id\", accountIdStr);\n\n        for (Bridge b : this. api.getBridges(qNetBridge)) {\n            if(b.getName().equals(networkUUIDStr)){\n                return b;\n            }\n        }\n\n        return null;\n    }","id":92301,"modified_method":"private Bridge getNetworkBridge(long networkID, String accountUuid){\n\n        MultivaluedMap qNetBridge = new MultivaluedMapImpl();\n        String networkUUIDStr = String.valueOf(networkID);\n        qNetBridge.add(\"tenant_id\", accountUuid);\n\n        for (Bridge b : this. api.getBridges(qNetBridge)) {\n            if(b.getName().equals(networkUUIDStr)){\n                return b;\n            }\n        }\n\n        return null;\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"private void connectBridgeToRouter(Network network, Bridge netBridge, Router netRouter){\n\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n        String routerName = getRouterName(isVpc, id);\n        String accountIdStr = String.valueOf(network.getAccountId());\n\n        // Add interior port on bridge side\n        BridgePort bridgePort = netBridge.addInteriorPort().create();\n\n        // Add interior port on router side, with network details\n        RouterPort routerPort = netRouter.addInteriorRouterPort();\n        String cidr = network.getCidr();\n        String cidrSubnet = NetUtils.getCidrSubNet(cidr);\n        int cidrSize = (int) NetUtils.getCidrSize(NetUtils.cidr2Netmask(cidr));\n\n        routerPort.networkAddress(cidrSubnet);\n        routerPort.networkLength(cidrSize);\n        routerPort.portAddress(network.getGateway());\n\n\n        // If this is a VPC, then we will be using NetworkACLs, which is\n        // implemented via chains on the router port to that network.\n        if (getIsVpc(network)) {\n            // Create ACL filter chain for traffic coming INTO the network\n            // (outbound from the port\n            int pos = 1;\n\n            RuleChain inc = api.addChain()\n                .name(getChainName(String.valueOf(network.getId()),\n                                   routerName,\n                                   RuleChainCode.ACL_INGRESS))\n                .tenantId(accountIdStr)\n                .create();\n\n\n            // If it is ARP, accept it\n            inc.addRule().type(DtoRule.Accept)\n                         .dlType((short)0x0806)\n                         .position(pos++)\n                         .create();\n\n            // If it is connection tracked, accept that as well\n            inc.addRule().type(DtoRule.Accept)\n                         .matchReturnFlow(true)\n                         .position(pos++)\n                         .create();\n\n            inc.addRule().type(DtoRule.Drop)\n                         .position(pos)\n                         .create();\n\n            //\n            RuleChain out = api.addChain()\n                .name(getChainName(String.valueOf(network.getId()),\n                                   routerName,\n                                   RuleChainCode.ACL_EGRESS))\n                .tenantId(accountIdStr)\n                .create();\n\n            // Creating the first default rule here that does nothing\n            // but start connection tracking.\n            out.addRule().type(DtoRule.Accept)\n                         .matchForwardFlow(true)\n                         .position(1)\n                         .create();\n\n            routerPort.outboundFilterId(inc.getId());\n            routerPort.inboundFilterId(out.getId());\n        }\n\n        routerPort.create();\n\n        // Link them up\n        bridgePort.link(routerPort.getId()).update();\n\n        // Set up default route from router to subnet\n        netRouter.addRoute().type(\"Normal\").weight(100)\n                .srcNetworkAddr(\"0.0.0.0\").srcNetworkLength(0)\n                .dstNetworkAddr(cidrSubnet).dstNetworkLength(cidrSize)\n                .nextHopPort(routerPort.getId()).nextHopGateway(null).create();\n    }","id":92302,"modified_method":"private void connectBridgeToRouter(Network network, Bridge netBridge, Router netRouter){\n\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n        String routerName = getRouterName(isVpc, id);\n        String accountIdStr = getAccountUuid(network);\n\n        // Add interior port on bridge side\n        BridgePort bridgePort = netBridge.addInteriorPort().create();\n\n        // Add interior port on router side, with network details\n        RouterPort routerPort = netRouter.addInteriorRouterPort();\n        String cidr = network.getCidr();\n        String cidrSubnet = NetUtils.getCidrSubNet(cidr);\n        int cidrSize = (int) NetUtils.getCidrSize(NetUtils.cidr2Netmask(cidr));\n\n        routerPort.networkAddress(cidrSubnet);\n        routerPort.networkLength(cidrSize);\n        routerPort.portAddress(network.getGateway());\n\n\n        // If this is a VPC, then we will be using NetworkACLs, which is\n        // implemented via chains on the router port to that network.\n        if (getIsVpc(network)) {\n            // Create ACL filter chain for traffic coming INTO the network\n            // (outbound from the port\n            int pos = 1;\n\n            RuleChain inc = api.addChain()\n                .name(getChainName(String.valueOf(network.getId()),\n                                   routerName,\n                                   RuleChainCode.ACL_INGRESS))\n                .tenantId(accountIdStr)\n                .create();\n\n\n            // If it is ARP, accept it\n            inc.addRule().type(DtoRule.Accept)\n                         .dlType((short)0x0806)\n                         .position(pos++)\n                         .create();\n\n            // If it is ICMP to the router, accept that\n            inc.addRule().type(DtoRule.Accept)\n                   .nwProto(SimpleFirewallRule.stringToProtocolNumber(\"icmp\"))\n                         .nwDstAddress(network.getGateway())\n                         .nwDstLength(32)\n                         .position(pos++)\n                         .create();\n\n            // If it is connection tracked, accept that as well\n            inc.addRule().type(DtoRule.Accept)\n                         .matchReturnFlow(true)\n                         .position(pos++)\n                         .create();\n\n            inc.addRule().type(DtoRule.Drop)\n                         .position(pos)\n                         .create();\n\n            //\n            RuleChain out = api.addChain()\n                .name(getChainName(String.valueOf(network.getId()),\n                                   routerName,\n                                   RuleChainCode.ACL_EGRESS))\n                .tenantId(accountIdStr)\n                .create();\n\n            // Creating the first default rule here that does nothing\n            // but start connection tracking.\n            out.addRule().type(DtoRule.Accept)\n                         .matchForwardFlow(true)\n                         .position(1)\n                         .create();\n\n            routerPort.outboundFilterId(inc.getId());\n            routerPort.inboundFilterId(out.getId());\n        }\n\n        routerPort.create();\n\n        // Link them up\n        bridgePort.link(routerPort.getId()).update();\n\n        // Set up default route from router to subnet\n        netRouter.addRoute().type(\"Normal\").weight(100)\n                .srcNetworkAddr(\"0.0.0.0\").srcNetworkLength(0)\n                .dstNetworkAddr(cidrSubnet).dstNetworkLength(cidrSize)\n                .nextHopPort(routerPort.getId()).nextHopGateway(null).create();\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"protected RuleChain getOrInitEgressACLFilter(Network network) {\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n        String routerName = getRouterName(isVpc, id);\n\n        RuleChain egressChain = getChain(String.valueOf(network.getId()),\n                                         String.valueOf(network.getAccountId()),\n                                         routerName,\n                                         RuleChainCode.ACL_EGRESS);\n\n        // Rules set by the user will have a protocol, so we count the ACL\n        // rules by counting how much have the nwProto field set.\n        int totalRules = 0;\n        for (Rule rule : egressChain.getRules()) {\n            if (rule.getNwProto() != 0) {\n                totalRules++;\n            }\n        }\n\n        if (totalRules > 0) {\n            // There are already rules present, no need to init.\n            return egressChain;\n        } else {\n            // We need to delete any placeholder rules\n            for (Rule rule : egressChain.getRules()) {\n                rule.delete();\n            }\n        }\n\n        int pos = 1;\n        // If it is ARP, accept it\n        egressChain.addRule().type(DtoRule.Accept)\n            .dlType((short)0x0806)\n            .position(pos++)\n            .create();\n\n        // Everything else gets dropped\n        egressChain.addRule()\n            .type(DtoRule.Drop)\n            .position(pos)\n            .create();\n\n        return egressChain;\n    }","id":92303,"modified_method":"protected RuleChain getOrInitEgressACLFilter(Network network) {\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n        String routerName = getRouterName(isVpc, id);\n\n        RuleChain egressChain = getChain(String.valueOf(network.getId()),\n                                         getAccountUuid(network),\n                                         routerName,\n                                         RuleChainCode.ACL_EGRESS);\n\n        // Rules set by the user will have a protocol, so we count the ACL\n        // rules by counting how much have the nwProto field set.\n        int totalRules = 0;\n        for (Rule rule : egressChain.getRules()) {\n            if (rule.getNwProto() != 0) {\n                totalRules++;\n            }\n        }\n\n        if (totalRules > 0) {\n            // There are already rules present, no need to init.\n            return egressChain;\n        } else {\n            // We need to delete any placeholder rules\n            for (Rule rule : egressChain.getRules()) {\n                rule.delete();\n            }\n        }\n\n        int pos = 1;\n        // If it is ARP, accept it\n        egressChain.addRule().type(DtoRule.Accept)\n            .dlType((short)0x0806)\n            .position(pos++)\n            .create();\n\n        // If it is ICMP to the router, accept that\n        egressChain.addRule().type(DtoRule.Accept)\n            .nwProto(SimpleFirewallRule.stringToProtocolNumber(\"icmp\"))\n            .nwDstAddress(network.getGateway())\n            .nwDstLength(32)\n            .position(pos++)\n            .create();\n\n        // Everything else gets dropped\n        egressChain.addRule()\n            .type(DtoRule.Drop)\n            .position(pos)\n            .create();\n\n        return egressChain;\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"public void testAddDhcpEntry() {\n\n        //mockMgmt\n        MidonetApi api = mock(MidonetApi.class, RETURNS_DEEP_STUBS);\n        ArrayList<String> arr = new ArrayList<String>();\n        arr.add(\"MidoNet\");\n        NetworkServiceMapDao mockNSMD = mock(NetworkServiceMapDao.class);\n        when(mockNSMD.getDistinctProviders(anyLong())).thenReturn(arr);\n\n        //mockDhcpHost\n        DhcpHost mockDhcpHost = mock(DhcpHost.class);\n\n        //mockHostCollection\n        ResourceCollection<DhcpHost> hosts =\n                new ResourceCollection<DhcpHost>(new ArrayList<DhcpHost>());\n\n        //mockDhcpSubnet\n        DhcpSubnet mockSub = mock(DhcpSubnet.class);\n        when(mockSub.addDhcpHost()).thenReturn(mockDhcpHost);\n        when(mockSub.getDhcpHosts()).thenReturn(hosts);\n\n        //mockSubnetCollection\n        ResourceCollection mockSubnetCollection = mock(ResourceCollection.class);\n        when(mockSubnetCollection.get(anyInt())).thenReturn(mockSub);\n\n        //mockBridge\n        Bridge mockBridge = mock(Bridge.class);\n        when(api.addBridge().tenantId(anyString()).name(anyString()).create()).thenReturn(mockBridge);\n        when(mockBridge.getDhcpSubnets()).thenReturn(mockSubnetCollection);\n\n        //mockRouter\n        Router mockRouter = mock(Router.class);\n        when(api.addRouter().tenantId(anyString()).name(anyString()).create()).thenReturn(mockRouter);\n\n        //mockNetwork\n        Network mockNetwork = mock(Network.class);\n        when(mockNetwork.getAccountId()).thenReturn((long)1);\n        when(mockNetwork.getGateway()).thenReturn(\"1.2.3.4\");\n        when(mockNetwork.getCidr()).thenReturn(\"1.2.3.0/24\");\n        when(mockNetwork.getId()).thenReturn((long)2);\n\n        //mockNic\n        NicProfile mockNic = mock(NicProfile.class);\n        when(mockNic.getIp4Address()).thenReturn(\"10.10.10.170\");\n        when(mockNic.getMacAddress()).thenReturn(\"02:00:73:3e:00:01\");\n        when(mockNic.getName()).thenReturn(\"Fake Name\");\n\n        //mockVm\n        @SuppressWarnings(\"unchecked\")\n        VirtualMachineProfile<? extends VirtualMachine> mockVm =\n                (VirtualMachineProfile<? extends VirtualMachine>)mock(VirtualMachineProfile.class);\n        when(mockVm.getType()).thenReturn(VirtualMachine.Type.User);\n\n        MidoNetElement elem = new MidoNetElement();\n        elem.setNtwkSrvcDao(mockNSMD);\n        elem.setMidonetApi(api);\n\n        boolean result = false;\n        try {\n            result = elem.addDhcpEntry(mockNetwork, mockNic, mockVm, null, null);\n        } catch (ConcurrentOperationException e) {\n            fail(e.getMessage());\n        } catch (InsufficientCapacityException e) {\n            fail(e.getMessage());\n        } catch (ResourceUnavailableException e) {\n            fail(e.getMessage());\n        }\n\n        assertEquals(result, true);\n    }","id":92304,"modified_method":"public void testAddDhcpEntry() {\n\n        //mockMgmt\n        MidonetApi api = mock(MidonetApi.class, RETURNS_DEEP_STUBS);\n\n        //mockDhcpHost\n        DhcpHost mockDhcpHost = mock(DhcpHost.class);\n\n        //mockHostCollection\n        ResourceCollection<DhcpHost> hosts =\n                new ResourceCollection<DhcpHost>(new ArrayList<DhcpHost>());\n\n        //mockDhcpSubnet\n        DhcpSubnet mockSub = mock(DhcpSubnet.class);\n        when(mockSub.addDhcpHost()).thenReturn(mockDhcpHost);\n        when(mockSub.getDhcpHosts()).thenReturn(hosts);\n\n        //mockSubnetCollection\n        ResourceCollection mockSubnetCollection = mock(ResourceCollection.class);\n        when(mockSubnetCollection.get(anyInt())).thenReturn(mockSub);\n\n        //mockBridge\n        Bridge mockBridge = mock(Bridge.class);\n        when(api.addBridge().tenantId(anyString()).name(anyString()).create()).thenReturn(mockBridge);\n        when(mockBridge.getDhcpSubnets()).thenReturn(mockSubnetCollection);\n\n        //mockRouter\n        Router mockRouter = mock(Router.class);\n        when(api.addRouter().tenantId(anyString()).name(anyString()).create()).thenReturn(mockRouter);\n\n        //mockNetwork\n        Network mockNetwork = mock(Network.class);\n        when(mockNetwork.getAccountId()).thenReturn((long)1);\n        when(mockNetwork.getGateway()).thenReturn(\"1.2.3.4\");\n        when(mockNetwork.getCidr()).thenReturn(\"1.2.3.0/24\");\n        when(mockNetwork.getId()).thenReturn((long)2);\n        when(mockNetwork.getBroadcastDomainType()).thenReturn(Networks.BroadcastDomainType.Mido);\n        when(mockNetwork.getTrafficType()).thenReturn(Networks.TrafficType.Guest);\n\n        //mockAccountDao\n        AccountDao mockAccountDao = mock(AccountDao.class);\n        AccountVO mockAccountVO = mock(AccountVO.class);\n        when(mockAccountDao.findById(anyLong())).thenReturn(mockAccountVO);\n        when(mockAccountVO.getUuid()).thenReturn(\"1\");\n\n        //mockNic\n        NicProfile mockNic = mock(NicProfile.class);\n        when(mockNic.getIp4Address()).thenReturn(\"10.10.10.170\");\n        when(mockNic.getMacAddress()).thenReturn(\"02:00:73:3e:00:01\");\n        when(mockNic.getName()).thenReturn(\"Fake Name\");\n\n        //mockVm\n        @SuppressWarnings(\"unchecked\")\n        VirtualMachineProfile<? extends VirtualMachine> mockVm =\n                (VirtualMachineProfile<? extends VirtualMachine>)mock(VirtualMachineProfile.class);\n        when(mockVm.getType()).thenReturn(VirtualMachine.Type.User);\n\n        MidoNetElement elem = new MidoNetElement();\n        elem.setMidonetApi(api);\n        elem.setAccountDao(mockAccountDao);\n\n        boolean result = false;\n        try {\n            result = elem.addDhcpEntry(mockNetwork, mockNic, mockVm, null, null);\n        } catch (ConcurrentOperationException e) {\n            fail(e.getMessage());\n        } catch (InsufficientCapacityException e) {\n            fail(e.getMessage());\n        } catch (ResourceUnavailableException e) {\n            fail(e.getMessage());\n        }\n\n        assertEquals(result, true);\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"public void testImplement() {\n        //mock\n        MidonetApi api = mock(MidonetApi.class, RETURNS_DEEP_STUBS);\n        ArrayList<String> arr = new ArrayList<String>();\n        arr.add(\"MidoNet\");\n        NetworkServiceMapDao mockNSMD = mock(NetworkServiceMapDao.class);\n        when(mockNSMD.getDistinctProviders(anyLong())).thenReturn(arr);\n\n        MidoNetElement elem = new MidoNetElement();\n        elem.setNtwkSrvcDao(mockNSMD);\n        elem.setMidonetApi(api);\n\n        //mockRPort\n        RouterPort mockRPort = mock(RouterPort.class);\n        when(mockRPort.getId()).thenReturn(UUID.fromString(\"550e8400-e29b-41d4-a716-446655440000\"));\n\n        //mockBPort\n        BridgePort mockBPort = mock(BridgePort.class);\n        when(mockBPort.link(any(UUID.class))).thenReturn(mockBPort);\n\n        //mockPort\n        Port mockPort = mock(Port.class);\n\n        ResourceCollection<Port> peerPorts =\n            new ResourceCollection<Port>(new ArrayList<Port>());\n\n        peerPorts.add(mockPort);\n\n        //mockBridge\n        Bridge mockBridge = mock(Bridge.class, RETURNS_DEEP_STUBS);\n        when(api.addBridge().tenantId(anyString()).name(anyString()).create()).thenReturn(mockBridge);\n        when(mockBridge.addInteriorPort().create()).thenReturn(mockBPort);\n        when(mockBridge.getPeerPorts()).thenReturn(peerPorts);\n\n        //mockRouter\n        Router mockRouter = mock(Router.class, RETURNS_DEEP_STUBS);\n        when(api.addRouter().tenantId(anyString()).name(anyString()).create()).thenReturn(mockRouter);\n        when(mockRouter.addInteriorRouterPort().create()).thenReturn(mockRPort);\n\n        //mockNetwork\n        Network mockNetwork = mock(Network.class);\n        when(mockNetwork.getAccountId()).thenReturn((long)1);\n        when(mockNetwork.getGateway()).thenReturn(\"1.2.3.4\");\n        when(mockNetwork.getCidr()).thenReturn(\"1.2.3.0/24\");\n        when(mockNetwork.getId()).thenReturn((long)2);\n\n        boolean result = false;\n        try {\n            result = elem.implement(mockNetwork, null, null, null);\n        } catch (ConcurrentOperationException e) {\n            fail(e.getMessage());\n        } catch (InsufficientCapacityException e) {\n            fail(e.getMessage());\n        } catch (ResourceUnavailableException e) {\n            fail(e.getMessage());\n        }\n\n        assertEquals(result, true);\n    }","id":92305,"modified_method":"public void testImplement() {\n        //mock\n        MidonetApi api = mock(MidonetApi.class, RETURNS_DEEP_STUBS);\n\n        //mockAccountDao\n        AccountDao mockAccountDao = mock(AccountDao.class);\n        AccountVO mockAccountVO = mock(AccountVO.class);\n        when(mockAccountDao.findById(anyLong())).thenReturn(mockAccountVO);\n        when(mockAccountVO.getUuid()).thenReturn(\"1\");\n        MidoNetElement elem = new MidoNetElement();\n\n        elem.setMidonetApi(api);\n        elem.setAccountDao(mockAccountDao);\n\n        //mockRPort\n        RouterPort mockRPort = mock(RouterPort.class);\n        when(mockRPort.getId()).thenReturn(UUID.fromString(\"550e8400-e29b-41d4-a716-446655440000\"));\n\n        //mockBPort\n        BridgePort mockBPort = mock(BridgePort.class);\n        when(mockBPort.link(any(UUID.class))).thenReturn(mockBPort);\n\n        //mockPort\n        Port mockPort = mock(Port.class);\n\n        ResourceCollection<Port> peerPorts =\n            new ResourceCollection<Port>(new ArrayList<Port>());\n\n        peerPorts.add(mockPort);\n\n        //mockBridge\n        Bridge mockBridge = mock(Bridge.class, RETURNS_DEEP_STUBS);\n        when(api.addBridge().tenantId(anyString()).name(anyString()).create()).thenReturn(mockBridge);\n        when(mockBridge.addInteriorPort().create()).thenReturn(mockBPort);\n        when(mockBridge.getPeerPorts()).thenReturn(peerPorts);\n\n        //mockRouter\n        Router mockRouter = mock(Router.class, RETURNS_DEEP_STUBS);\n        when(api.addRouter().tenantId(anyString()).name(anyString()).create()).thenReturn(mockRouter);\n        when(mockRouter.addInteriorRouterPort().create()).thenReturn(mockRPort);\n\n        //mockNetwork\n        Network mockNetwork = mock(Network.class);\n        when(mockNetwork.getAccountId()).thenReturn((long)1);\n        when(mockNetwork.getGateway()).thenReturn(\"1.2.3.4\");\n        when(mockNetwork.getCidr()).thenReturn(\"1.2.3.0/24\");\n        when(mockNetwork.getId()).thenReturn((long)2);\n        when(mockNetwork.getBroadcastDomainType()).thenReturn(Networks.BroadcastDomainType.Mido);\n        when(mockNetwork.getTrafficType()).thenReturn(Networks.TrafficType.Public);\n\n        boolean result = false;\n        try {\n            result = elem.implement(mockNetwork, null, null, null);\n        } catch (ConcurrentOperationException e) {\n            fail(e.getMessage());\n        } catch (InsufficientCapacityException e) {\n            fail(e.getMessage());\n        } catch (ResourceUnavailableException e) {\n            fail(e.getMessage());\n        }\n\n        assertEquals(result, true);\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Network implement(Network network, NetworkOffering offering,\n                             DeployDestination dest, ReservationContext context)\n            throws InsufficientVirtualNetworkCapcityException {\n        assert (network.getState() == Network.State.Implementing) : \"Why are we implementing \" + network;\n        s_logger.debug(\"implement called network: \" + network.toString());\n\n        long dcId = dest.getDataCenter().getId();\n\n        //get physical network id\n        long physicalNetworkId = _networkModel.findPhysicalNetworkId(dcId, offering.getTags(), offering.getTrafficType());\n\n        NetworkVO implemented = new NetworkVO(network.getTrafficType(), network.getMode(), network.getBroadcastDomainType(), network.getNetworkOfferingId(), Network.State.Allocated,\n                network.getDataCenterId(), physicalNetworkId);\n\n        if (network.getGateway() != null) {\n            implemented.setGateway(network.getGateway());\n        }\n\n        if (network.getCidr() != null) {\n            implemented.setCidr(network.getCidr());\n        }\n\n        String accountIdStr = String.valueOf(network.getAccountId());\n        String routerName = \"\";\n        if (network.getVpcId() != null) {\n            routerName = \"VPC\" + String.valueOf(network.getVpcId());\n        } else {\n            routerName = String.valueOf(network.getId());\n        }\n\n        String broadcastUriStr = accountIdStr + \".\" + String.valueOf(network.getId()) + \":\" + routerName;\n\n        implemented.setBroadcastUri(Networks.BroadcastDomainType.Mido.toUri(broadcastUriStr));\n        s_logger.debug(\"Broadcast URI set to \" + broadcastUriStr);\n\n        return implemented;\n    }","id":92306,"modified_method":"@Override\n    public Network implement(Network network, NetworkOffering offering,\n                             DeployDestination dest, ReservationContext context)\n            throws InsufficientVirtualNetworkCapcityException {\n        assert (network.getState() == Network.State.Implementing) : \"Why are we implementing \" + network;\n        s_logger.debug(\"implement called network: \" + network.toString());\n\n        long dcId = dest.getDataCenter().getId();\n\n        //get physical network id\n        long physicalNetworkId = _networkModel.findPhysicalNetworkId(dcId, offering.getTags(), offering.getTrafficType());\n\n        NetworkVO implemented = new NetworkVO(network.getTrafficType(), network.getMode(), network.getBroadcastDomainType(), network.getNetworkOfferingId(), Network.State.Allocated,\n                network.getDataCenterId(), physicalNetworkId);\n\n        if (network.getGateway() != null) {\n            implemented.setGateway(network.getGateway());\n        }\n\n        if (network.getCidr() != null) {\n            implemented.setCidr(network.getCidr());\n        }\n\n        AccountVO acc = _accountDao.findById(network.getAccountId());\n        String accountUUIDStr = acc.getUuid();\n        String routerName = \"\";\n        if (network.getVpcId() != null) {\n            routerName = \"VPC\" + String.valueOf(network.getVpcId());\n        } else {\n            routerName = String.valueOf(network.getId());\n        }\n\n        String broadcastUriStr = accountUUIDStr + \".\"\n                                 + String.valueOf(network.getId())\n                                 + \":\" + routerName;\n\n        implemented.setBroadcastUri(Networks.BroadcastDomainType.Mido.toUri(broadcastUriStr));\n        s_logger.debug(\"Broadcast URI set to \" + broadcastUriStr);\n\n        return implemented;\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"private URI generateBroadcastUri(Network network){\n        String accountIdStr = String.valueOf(network.getAccountId());\n        String networkUUIDStr = String.valueOf(network.getId());\n        return Networks.BroadcastDomainType.Mido.toUri(accountIdStr +\n                                                       \".\" +\n                                                       networkUUIDStr +\n                                                       \":\" +\n                                                       networkUUIDStr);\n    }","id":92307,"modified_method":"private URI generateBroadcastUri(Network network){\n        AccountVO acc = _accountDao.findById(network.getAccountId());\n        String accountUUIDStr = acc.getUuid();\n        String networkUUIDStr = String.valueOf(network.getId());\n        return Networks.BroadcastDomainType.Mido.toUri(accountUUIDStr +\n                                                       \".\" +\n                                                       networkUUIDStr +\n                                                       \":\" +\n                                                       networkUUIDStr);\n    }","commit_id":"21cb2c67b200e0d5dc3bf0af75e44c5d1fe314bc","url":"https://github.com/apache/cloudstack"},{"original_method":"protected RuleChain getOrInitEgressACLFilter(Network network) {\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n        String routerName = getRouterName(isVpc, id);\n\n        RuleChain egressChain = getChain(String.valueOf(network.getId()),\n                                         String.valueOf(network.getAccountId()),\n                                         routerName,\n                                         RuleChainCode.ACL_EGRESS);\n\n        // Rules set by the user will have a protocol, so we count the ACL\n        // rules by counting how much have the nwProto field set.\n        int totalRules = 0;\n        for (Rule rule : egressChain.getRules()) {\n            if (rule.getNwProto() != 0) {\n                totalRules++;\n            }\n        }\n\n        if (totalRules > 0) {\n            // There are already rules present, no need to init.\n            return egressChain;\n        } else {\n            // We need to delete any placeholder rules\n            for (Rule rule : egressChain.getRules()) {\n                rule.delete();\n            }\n        }\n\n        int pos = 1;\n        // If it is ARP, accept it\n        egressChain.addRule().type(DtoRule.Accept)\n            .dlType((short)0x0806)\n            .position(pos++)\n            .create();\n\n        // Everything else gets dropped\n        egressChain.addRule()\n            .type(DtoRule.Drop)\n            .position(pos)\n            .create();\n\n        return egressChain;\n    }","id":92308,"modified_method":"protected RuleChain getOrInitEgressACLFilter(Network network) {\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n        String routerName = getRouterName(isVpc, id);\n\n        RuleChain egressChain = getChain(String.valueOf(network.getId()),\n                                         getAccountUuid(network),\n                                         routerName,\n                                         RuleChainCode.ACL_EGRESS);\n\n        // Rules set by the user will have a protocol, so we count the ACL\n        // rules by counting how much have the nwProto field set.\n        int totalRules = 0;\n        for (Rule rule : egressChain.getRules()) {\n            if (rule.getNwProto() != 0) {\n                totalRules++;\n            }\n        }\n\n        if (totalRules > 0) {\n            // There are already rules present, no need to init.\n            return egressChain;\n        } else {\n            // We need to delete any placeholder rules\n            for (Rule rule : egressChain.getRules()) {\n                rule.delete();\n            }\n        }\n\n        int pos = 1;\n        // If it is ARP, accept it\n        egressChain.addRule().type(DtoRule.Accept)\n            .dlType((short)0x0806)\n            .position(pos++)\n            .create();\n\n        // If it is ICMP to the router, accept that\n        egressChain.addRule().type(DtoRule.Accept)\n            .nwProto(SimpleFirewallRule.stringToProtocolNumber(\"icmp\"))\n            .nwDstAddress(network.getGateway())\n            .nwDstLength(32)\n            .position(pos++)\n            .create();\n\n        // Everything else gets dropped\n        egressChain.addRule()\n            .type(DtoRule.Drop)\n            .position(pos)\n            .create();\n\n        return egressChain;\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"protected void resetEgressACLFilter(Network network) {\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n        String routerName = getRouterName(isVpc, id);\n\n        RuleChain egressChain = getChain(String.valueOf(network.getId()),\n                                         String.valueOf(network.getAccountId()),\n                                         routerName,\n                                         RuleChainCode.ACL_EGRESS);\n\n        // Clear all the rules out\n        for (Rule rule : egressChain.getRules()) {\n            rule.delete();\n        }\n\n        // Add a matchForwardFlow rule so that we can accept all return traffic\n        egressChain.addRule().type(DtoRule.Accept)\n            .matchForwardFlow(true)\n            .position(1)\n            .create();\n    }","id":92309,"modified_method":"protected void resetEgressACLFilter(Network network) {\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n        String routerName = getRouterName(isVpc, id);\n\n        RuleChain egressChain = getChain(String.valueOf(network.getId()),\n                                         getAccountUuid(network),\n                                         routerName,\n                                         RuleChainCode.ACL_EGRESS);\n\n        // Clear all the rules out\n        for (Rule rule : egressChain.getRules()) {\n            rule.delete();\n        }\n\n        // Add a matchForwardFlow rule so that we can accept all return traffic\n        egressChain.addRule().type(DtoRule.Accept)\n            .matchForwardFlow(true)\n            .position(1)\n            .create();\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"private void connectBridgeToRouter(Network network, Bridge netBridge, Router netRouter){\n\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n        String routerName = getRouterName(isVpc, id);\n        String accountIdStr = String.valueOf(network.getAccountId());\n\n        // Add interior port on bridge side\n        BridgePort bridgePort = netBridge.addInteriorPort().create();\n\n        // Add interior port on router side, with network details\n        RouterPort routerPort = netRouter.addInteriorRouterPort();\n        String cidr = network.getCidr();\n        String cidrSubnet = NetUtils.getCidrSubNet(cidr);\n        int cidrSize = (int) NetUtils.getCidrSize(NetUtils.cidr2Netmask(cidr));\n\n        routerPort.networkAddress(cidrSubnet);\n        routerPort.networkLength(cidrSize);\n        routerPort.portAddress(network.getGateway());\n\n\n        // If this is a VPC, then we will be using NetworkACLs, which is\n        // implemented via chains on the router port to that network.\n        if (getIsVpc(network)) {\n            // Create ACL filter chain for traffic coming INTO the network\n            // (outbound from the port\n            int pos = 1;\n\n            RuleChain inc = api.addChain()\n                .name(getChainName(String.valueOf(network.getId()),\n                                   routerName,\n                                   RuleChainCode.ACL_INGRESS))\n                .tenantId(accountIdStr)\n                .create();\n\n\n            // If it is ARP, accept it\n            inc.addRule().type(DtoRule.Accept)\n                         .dlType((short)0x0806)\n                         .position(pos++)\n                         .create();\n\n            // If it is connection tracked, accept that as well\n            inc.addRule().type(DtoRule.Accept)\n                         .matchReturnFlow(true)\n                         .position(pos++)\n                         .create();\n\n            inc.addRule().type(DtoRule.Drop)\n                         .position(pos)\n                         .create();\n\n            //\n            RuleChain out = api.addChain()\n                .name(getChainName(String.valueOf(network.getId()),\n                                   routerName,\n                                   RuleChainCode.ACL_EGRESS))\n                .tenantId(accountIdStr)\n                .create();\n\n            // Creating the first default rule here that does nothing\n            // but start connection tracking.\n            out.addRule().type(DtoRule.Accept)\n                         .matchForwardFlow(true)\n                         .position(1)\n                         .create();\n\n            routerPort.outboundFilterId(inc.getId());\n            routerPort.inboundFilterId(out.getId());\n        }\n\n        routerPort.create();\n\n        // Link them up\n        bridgePort.link(routerPort.getId()).update();\n\n        // Set up default route from router to subnet\n        netRouter.addRoute().type(\"Normal\").weight(100)\n                .srcNetworkAddr(\"0.0.0.0\").srcNetworkLength(0)\n                .dstNetworkAddr(cidrSubnet).dstNetworkLength(cidrSize)\n                .nextHopPort(routerPort.getId()).nextHopGateway(null).create();\n    }","id":92310,"modified_method":"private void connectBridgeToRouter(Network network, Bridge netBridge, Router netRouter){\n\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n        String routerName = getRouterName(isVpc, id);\n        String accountIdStr = getAccountUuid(network);\n\n        // Add interior port on bridge side\n        BridgePort bridgePort = netBridge.addInteriorPort().create();\n\n        // Add interior port on router side, with network details\n        RouterPort routerPort = netRouter.addInteriorRouterPort();\n        String cidr = network.getCidr();\n        String cidrSubnet = NetUtils.getCidrSubNet(cidr);\n        int cidrSize = (int) NetUtils.getCidrSize(NetUtils.cidr2Netmask(cidr));\n\n        routerPort.networkAddress(cidrSubnet);\n        routerPort.networkLength(cidrSize);\n        routerPort.portAddress(network.getGateway());\n\n\n        // If this is a VPC, then we will be using NetworkACLs, which is\n        // implemented via chains on the router port to that network.\n        if (getIsVpc(network)) {\n            // Create ACL filter chain for traffic coming INTO the network\n            // (outbound from the port\n            int pos = 1;\n\n            RuleChain inc = api.addChain()\n                .name(getChainName(String.valueOf(network.getId()),\n                                   routerName,\n                                   RuleChainCode.ACL_INGRESS))\n                .tenantId(accountIdStr)\n                .create();\n\n\n            // If it is ARP, accept it\n            inc.addRule().type(DtoRule.Accept)\n                         .dlType((short)0x0806)\n                         .position(pos++)\n                         .create();\n\n            // If it is ICMP to the router, accept that\n            inc.addRule().type(DtoRule.Accept)\n                   .nwProto(SimpleFirewallRule.stringToProtocolNumber(\"icmp\"))\n                         .nwDstAddress(network.getGateway())\n                         .nwDstLength(32)\n                         .position(pos++)\n                         .create();\n\n            // If it is connection tracked, accept that as well\n            inc.addRule().type(DtoRule.Accept)\n                         .matchReturnFlow(true)\n                         .position(pos++)\n                         .create();\n\n            inc.addRule().type(DtoRule.Drop)\n                         .position(pos)\n                         .create();\n\n            //\n            RuleChain out = api.addChain()\n                .name(getChainName(String.valueOf(network.getId()),\n                                   routerName,\n                                   RuleChainCode.ACL_EGRESS))\n                .tenantId(accountIdStr)\n                .create();\n\n            // Creating the first default rule here that does nothing\n            // but start connection tracking.\n            out.addRule().type(DtoRule.Accept)\n                         .matchForwardFlow(true)\n                         .position(1)\n                         .create();\n\n            routerPort.outboundFilterId(inc.getId());\n            routerPort.inboundFilterId(out.getId());\n        }\n\n        routerPort.create();\n\n        // Link them up\n        bridgePort.link(routerPort.getId()).update();\n\n        // Set up default route from router to subnet\n        netRouter.addRoute().type(\"Normal\").weight(100)\n                .srcNetworkAddr(\"0.0.0.0\").srcNetworkLength(0)\n                .dstNetworkAddr(cidrSubnet).dstNetworkLength(cidrSize)\n                .nextHopPort(routerPort.getId()).nextHopGateway(null).create();\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"private Bridge getOrCreateNetworkBridge(long networkID, long accountID){\n        Bridge netBridge = getNetworkBridge(networkID, accountID);\n        if(netBridge == null){\n\n            String accountIdStr = String.valueOf(accountID);\n            String networkUUIDStr = String.valueOf(networkID);\n\n            netBridge = api.addBridge().tenantId(accountIdStr).name(networkUUIDStr).create();\n        }\n        return netBridge;\n    }","id":92311,"modified_method":"private Bridge getOrCreateNetworkBridge(long networkID, String accountUuid){\n        Bridge netBridge = getNetworkBridge(networkID, accountUuid);\n        if(netBridge == null){\n\n            String networkUUIDStr = String.valueOf(networkID);\n\n            netBridge = api.addBridge().tenantId(accountUuid).name(networkUUIDStr).create();\n        }\n        return netBridge;\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean applyPFRules(Network network, List<PortForwardingRule> rules)\n                    throws ResourceUnavailableException {\n        s_logger.debug(\"applyPFRules called with network \" + network.toString());\n        if (!midoInNetwork(network)) {\n            return false;\n        }\n        if (!canHandle(network, Service.PortForwarding)) {\n            return false;\n        }\n\n        String accountIdStr = String.valueOf(network.getAccountId());\n        String networkUUIDStr = String.valueOf(network.getId());\n        RuleChain preNat = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PRENAT);\n        RuleChain postNat = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_POST);\n        RuleChain preFilter = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PREFILTER);\n        Router providerRouter = api.getRouter(_providerRouterId);\n        Router tenantRouter = getOrCreateGuestNetworkRouter(network);\n        RouterPort[] ports = getOrCreateProviderRouterPorts(tenantRouter, providerRouter);\n        RouterPort providerDownlink = ports[1];\n\n        // Rules in the preNat table\n        Map<String, Rule> existingPreNatRules = new HashMap<String, Rule>();\n        for (Rule existingRule : preNat.getRules()) {\n            String ruleString = new SimpleFirewallRule(existingRule).toStringArray()[0];\n            existingPreNatRules.put(ruleString, existingRule);\n        }\n\n        /*\n         * Counts of rules associated with an IP address. Use this to check\n         * how many rules we have of a given IP address. When it reaches 0,\n         * we can delete the route associated with it.\n         */\n        Map<String, Integer> ipRuleCounts = new HashMap<String, Integer>();\n        for (Rule rule : preNat.getRules()) {\n            String ip = rule.getNwDstAddress();\n            if (ip != null && rule.getNwDstLength() == 32) {\n                if (ipRuleCounts.containsKey(ip)) {\n                    ipRuleCounts.put(ip, new Integer(ipRuleCounts.get(ip).intValue() + 1));\n                } else {\n                    ipRuleCounts.put(ip, new Integer(1));\n                }\n            }\n        }\n\n        /*\n         * Routes associated with IP. When we delete all the rules associated\n         * with a given IP, we can delete the route associated with it.\n         */\n        Map<String, Route> routes = new HashMap<String, Route>();\n        for (Route route : providerRouter.getRoutes(new MultivaluedMapImpl())) {\n            String ip = route.getDstNetworkAddr();\n            if (ip != null && route.getDstNetworkLength() == 32) {\n                routes.put(ip, route);\n            }\n        }\n\n        for (PortForwardingRule rule : rules) {\n            IpAddress dstIp = _networkModel.getIp(rule.getSourceIpAddressId());\n            PortForwardingRuleTO ruleTO = new PortForwardingRuleTO(rule, null, dstIp.getAddress().addr());\n            SimpleFirewallRule fwRule = new SimpleFirewallRule(ruleTO);\n            String[] ruleStrings = fwRule.toStringArray();\n\n            if (rule.getState() == FirewallRule.State.Revoke) {\n                /*\n                 * Lookup in existingRules, delete if present\n                 * We need to delete from both the preNat table and the\n                 * postNat table.\n                 */\n                for(String revokeRuleString : ruleStrings){\n                    Rule foundPreNatRule = existingPreNatRules.get(revokeRuleString);\n                    if(foundPreNatRule != null){\n                        String ip = foundPreNatRule.getNwDstAddress();\n                        // is this the last rule associated with this IP?\n                        Integer cnt = ipRuleCounts.get(ip);\n                        if (cnt != null) {\n                            if (cnt == 1) {\n                                ipRuleCounts.remove(ip);\n                                // no more rules for this IP. delete the route.\n                                Route route = routes.remove(ip);\n                                route.delete();\n                            } else {\n                                ipRuleCounts.put(ip, new Integer(ipRuleCounts.get(ip).intValue() - 1));\n                            }\n                        }\n                        foundPreNatRule.delete();\n                    }\n                }\n            } else if (rule.getState() == FirewallRule.State.Add) {\n                for(int i = 0; i < ruleStrings.length; i++){\n                    String ruleString = ruleStrings[i];\n                    Rule foundRule = existingPreNatRules.get(ruleString);\n                    if(foundRule == null){\n\n                        String vmIp = ruleTO.getDstIp();\n                        String publicIp = dstIp.getAddress().addr();\n                        int privPortStart = ruleTO.getDstPortRange()[0];\n                        int privPortEnd = ruleTO.getDstPortRange()[1];\n                        int pubPortStart = ruleTO.getSrcPortRange()[0];\n                        int pubPortEnd = ruleTO.getSrcPortRange()[1];\n\n                        DtoRule.DtoNatTarget[] preTargets = new DtoRule.DtoNatTarget[]{\n                            new DtoRule.DtoNatTarget(vmIp, vmIp, privPortStart, privPortEnd)};\n\n                        Rule preNatRule = preNat.addRule()\n                            .type(DtoRule.DNAT)\n                            .flowAction(DtoRule.Accept)\n                            .nwDstAddress(publicIp)\n                            .nwDstLength(32)\n                            .tpDstStart(pubPortStart)\n                            .tpDstEnd(pubPortEnd)\n                            .natTargets(preTargets)\n                            .nwProto(SimpleFirewallRule.stringToProtocolNumber(rule.getProtocol()))\n                            .position(1);\n\n                        Integer cnt = ipRuleCounts.get(publicIp);\n                        if (cnt != null) {\n                            ipRuleCounts.put(publicIp, new Integer(cnt.intValue() + 1));\n                        } else {\n                            ipRuleCounts.put(publicIp, new Integer(1));\n                        }\n                        String preNatRuleStr = new SimpleFirewallRule(preNatRule).toStringArray()[0];\n                        existingPreNatRules.put(preNatRuleStr, preNatRule);\n                        preNatRule.create();\n\n                        if (routes.get(publicIp) == null) {\n                            Route route = providerRouter.addRoute()\n                                            .type(\"Normal\")\n                                            .weight(100)\n                                            .srcNetworkAddr(\"0.0.0.0\")\n                                            .srcNetworkLength(0)\n                                            .dstNetworkAddr(publicIp)\n                                            .dstNetworkLength(32)\n                                            .nextHopPort(providerDownlink.getId());\n                            route.create();\n                            routes.put(publicIp, route);\n                        }\n\n                        // If Firewall is in our service offering, set up the\n                        // default firewall rule\n                        if (canHandle(network, Service.Firewall)) {\n                            boolean defaultBlock = false;\n                            for (Rule filterRule : preFilter.getRules()) {\n                                String pfDstIp = filterRule.getNwDstAddress();\n                                if (pfDstIp != null && filterRule.getNwDstAddress().equals(publicIp)) {\n                                    defaultBlock = true;\n                                    break;\n                                }\n                            }\n                            if (!defaultBlock) {\n                                preFilter.addRule().type(DtoRule.Drop)\n                                    .nwDstAddress(publicIp)\n                                    .nwDstLength(32)\n                                    .create();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }","id":92312,"modified_method":"@Override\n    public boolean applyPFRules(Network network, List<PortForwardingRule> rules)\n                    throws ResourceUnavailableException {\n        s_logger.debug(\"applyPFRules called with network \" + network.toString());\n        if (!midoInNetwork(network)) {\n            return false;\n        }\n        if (!canHandle(network, Service.PortForwarding)) {\n            return false;\n        }\n\n        String accountIdStr = getAccountUuid(network);\n        String networkUUIDStr = String.valueOf(network.getId());\n        RuleChain preNat = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PRENAT);\n        RuleChain postNat = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_POST);\n        RuleChain preFilter = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PREFILTER);\n        Router providerRouter = api.getRouter(_providerRouterId);\n        Router tenantRouter = getOrCreateGuestNetworkRouter(network);\n        RouterPort[] ports = getOrCreateProviderRouterPorts(tenantRouter, providerRouter);\n        RouterPort providerDownlink = ports[1];\n\n        // Rules in the preNat table\n        Map<String, Rule> existingPreNatRules = new HashMap<String, Rule>();\n        for (Rule existingRule : preNat.getRules()) {\n            String ruleString = new SimpleFirewallRule(existingRule).toStringArray()[0];\n            existingPreNatRules.put(ruleString, existingRule);\n        }\n\n        /*\n         * Counts of rules associated with an IP address. Use this to check\n         * how many rules we have of a given IP address. When it reaches 0,\n         * we can delete the route associated with it.\n         */\n        Map<String, Integer> ipRuleCounts = new HashMap<String, Integer>();\n        for (Rule rule : preNat.getRules()) {\n            String ip = rule.getNwDstAddress();\n            if (ip != null && rule.getNwDstLength() == 32) {\n                if (ipRuleCounts.containsKey(ip)) {\n                    ipRuleCounts.put(ip, new Integer(ipRuleCounts.get(ip).intValue() + 1));\n                } else {\n                    ipRuleCounts.put(ip, new Integer(1));\n                }\n            }\n        }\n\n        /*\n         * Routes associated with IP. When we delete all the rules associated\n         * with a given IP, we can delete the route associated with it.\n         */\n        Map<String, Route> routes = new HashMap<String, Route>();\n        for (Route route : providerRouter.getRoutes(new MultivaluedMapImpl())) {\n            String ip = route.getDstNetworkAddr();\n            if (ip != null && route.getDstNetworkLength() == 32) {\n                routes.put(ip, route);\n            }\n        }\n\n        for (PortForwardingRule rule : rules) {\n            IpAddress dstIp = _networkModel.getIp(rule.getSourceIpAddressId());\n            PortForwardingRuleTO ruleTO = new PortForwardingRuleTO(rule, null, dstIp.getAddress().addr());\n            SimpleFirewallRule fwRule = new SimpleFirewallRule(ruleTO);\n            String[] ruleStrings = fwRule.toStringArray();\n\n            if (rule.getState() == FirewallRule.State.Revoke) {\n                /*\n                 * Lookup in existingRules, delete if present\n                 * We need to delete from both the preNat table and the\n                 * postNat table.\n                 */\n                for(String revokeRuleString : ruleStrings){\n                    Rule foundPreNatRule = existingPreNatRules.get(revokeRuleString);\n                    if(foundPreNatRule != null){\n                        String ip = foundPreNatRule.getNwDstAddress();\n                        // is this the last rule associated with this IP?\n                        Integer cnt = ipRuleCounts.get(ip);\n                        if (cnt != null) {\n                            if (cnt == 1) {\n                                ipRuleCounts.remove(ip);\n                                // no more rules for this IP. delete the route.\n                                Route route = routes.remove(ip);\n                                route.delete();\n                            } else {\n                                ipRuleCounts.put(ip, new Integer(ipRuleCounts.get(ip).intValue() - 1));\n                            }\n                        }\n                        foundPreNatRule.delete();\n                    }\n                }\n            } else if (rule.getState() == FirewallRule.State.Add) {\n                for(int i = 0; i < ruleStrings.length; i++){\n                    String ruleString = ruleStrings[i];\n                    Rule foundRule = existingPreNatRules.get(ruleString);\n                    if(foundRule == null){\n\n                        String vmIp = ruleTO.getDstIp();\n                        String publicIp = dstIp.getAddress().addr();\n                        int privPortStart = ruleTO.getDstPortRange()[0];\n                        int privPortEnd = ruleTO.getDstPortRange()[1];\n                        int pubPortStart = ruleTO.getSrcPortRange()[0];\n                        int pubPortEnd = ruleTO.getSrcPortRange()[1];\n\n                        DtoRule.DtoNatTarget[] preTargets = new DtoRule.DtoNatTarget[]{\n                            new DtoRule.DtoNatTarget(vmIp, vmIp, privPortStart, privPortEnd)};\n\n                        Rule preNatRule = preNat.addRule()\n                            .type(DtoRule.DNAT)\n                            .flowAction(DtoRule.Accept)\n                            .nwDstAddress(publicIp)\n                            .nwDstLength(32)\n                            .tpDstStart(pubPortStart)\n                            .tpDstEnd(pubPortEnd)\n                            .natTargets(preTargets)\n                            .nwProto(SimpleFirewallRule.stringToProtocolNumber(rule.getProtocol()))\n                            .position(1);\n\n                        Integer cnt = ipRuleCounts.get(publicIp);\n                        if (cnt != null) {\n                            ipRuleCounts.put(publicIp, new Integer(cnt.intValue() + 1));\n                        } else {\n                            ipRuleCounts.put(publicIp, new Integer(1));\n                        }\n                        String preNatRuleStr = new SimpleFirewallRule(preNatRule).toStringArray()[0];\n                        existingPreNatRules.put(preNatRuleStr, preNatRule);\n                        preNatRule.create();\n\n                        if (routes.get(publicIp) == null) {\n                            Route route = providerRouter.addRoute()\n                                            .type(\"Normal\")\n                                            .weight(100)\n                                            .srcNetworkAddr(\"0.0.0.0\")\n                                            .srcNetworkLength(0)\n                                            .dstNetworkAddr(publicIp)\n                                            .dstNetworkLength(32)\n                                            .nextHopPort(providerDownlink.getId());\n                            route.create();\n                            routes.put(publicIp, route);\n                        }\n\n                        // If Firewall is in our service offering, set up the\n                        // default firewall rule\n                        if (canHandle(network, Service.Firewall)) {\n                            boolean defaultBlock = false;\n                            for (Rule filterRule : preFilter.getRules()) {\n                                String pfDstIp = filterRule.getNwDstAddress();\n                                if (pfDstIp != null && filterRule.getNwDstAddress().equals(publicIp)) {\n                                    defaultBlock = true;\n                                    break;\n                                }\n                            }\n                            if (!defaultBlock) {\n                                preFilter.addRule().type(DtoRule.Drop)\n                                    .nwDstAddress(publicIp)\n                                    .nwDstLength(32)\n                                    .create();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"protected RuleChain getChain(String accountID, String routerName, RuleChainCode chainCode){\n        return getChain(\"\", accountID, routerName, chainCode);\n    }","id":92313,"modified_method":"protected RuleChain getChain(String accountUuid, String routerName, RuleChainCode chainCode){\n        return getChain(\"\", accountUuid, routerName, chainCode);\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean associatePublicIP(Network network, final List<? extends PublicIpAddress> ipAddress)\n        throws ResourceUnavailableException {\n\n        s_logger.debug(\"associatePublicIP called with network: \" + network.toString());\n        /*\n         * Get Mido Router for this network and set source rules\n         * These should only be allocated inside the for loop, because\n         * this function could be called as a part of network cleanup. In\n         * that case, we do not want to recreate the guest network or\n         * any ports.\n         */\n        boolean resources = false;\n        Router tenantRouter = null;\n        Router providerRouter = null;\n        RouterPort[] ports = null;\n\n        RouterPort tenantUplink = null;\n        RouterPort providerDownlink = null;\n\n        RuleChain preNat = null;\n        RuleChain post = null;\n        String accountIdStr = null;\n        String routerName = null;\n\n        // Set Source NAT rules on router\n        for (PublicIpAddress ip : ipAddress) {\n            // ip is the external one we sourcenat to\n            if(ip.isSourceNat()){\n                if (resources == false) {\n                    tenantRouter = getOrCreateGuestNetworkRouter(network);\n                    providerRouter = api.getRouter(_providerRouterId);\n                    ports = getOrCreateProviderRouterPorts(tenantRouter, providerRouter);\n\n                    tenantUplink = ports[0];\n                    providerDownlink = ports[1];\n\n                    accountIdStr = String.valueOf(network.getAccountId());\n                    boolean isVpc = getIsVpc(network);\n                    long id = getRouterId(network, isVpc);\n                    routerName = getRouterName(isVpc, id);\n\n                    preNat = getChain(accountIdStr, routerName, RuleChainCode.TR_PRENAT);\n                    post = api.getChain(tenantRouter.getOutboundFilterId());\n                    resources = true;\n                }\n\n                applySourceNat(tenantRouter, providerRouter,    // Routers\n                               tenantUplink, providerDownlink,  // Ports\n                               preNat, post,                       // Chains\n                               ip);                             // The IP\n            }\n        }\n\n        return true;\n    }","id":92314,"modified_method":"public boolean associatePublicIP(Network network, final List<? extends PublicIpAddress> ipAddress)\n        throws ResourceUnavailableException {\n\n        s_logger.debug(\"associatePublicIP called with network: \" + network.toString());\n        /*\n         * Get Mido Router for this network and set source rules\n         * These should only be allocated inside the for loop, because\n         * this function could be called as a part of network cleanup. In\n         * that case, we do not want to recreate the guest network or\n         * any ports.\n         */\n        boolean resources = false;\n        Router tenantRouter = null;\n        Router providerRouter = null;\n        RouterPort[] ports = null;\n\n        RouterPort tenantUplink = null;\n        RouterPort providerDownlink = null;\n\n        RuleChain preNat = null;\n        RuleChain post = null;\n        String accountIdStr = null;\n        String routerName = null;\n\n        // Set Source NAT rules on router\n        for (PublicIpAddress ip : ipAddress) {\n            // ip is the external one we sourcenat to\n            if(ip.isSourceNat()){\n                if (resources == false) {\n                    tenantRouter = getOrCreateGuestNetworkRouter(network);\n                    providerRouter = api.getRouter(_providerRouterId);\n                    ports = getOrCreateProviderRouterPorts(tenantRouter, providerRouter);\n\n                    tenantUplink = ports[0];\n                    providerDownlink = ports[1];\n\n                    accountIdStr = getAccountUuid(network);\n                    boolean isVpc = getIsVpc(network);\n                    long id = getRouterId(network, isVpc);\n                    routerName = getRouterName(isVpc, id);\n\n                    preNat = getChain(accountIdStr, routerName, RuleChainCode.TR_PRENAT);\n                    post = api.getChain(tenantRouter.getOutboundFilterId());\n                    resources = true;\n                }\n\n                applySourceNat(tenantRouter, providerRouter,    // Routers\n                               tenantUplink, providerDownlink,  // Ports\n                               preNat, post,                       // Chains\n                               ip);                             // The IP\n            }\n        }\n\n        return true;\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"private Bridge getOrCreateNetworkBridge(Network network){\n        // Find the single bridge for this network, create if doesn't exist\n        return getOrCreateNetworkBridge(network.getId(), network.getAccountId());\n    }","id":92315,"modified_method":"private Bridge getOrCreateNetworkBridge(Network network){\n        // Find the single bridge for this network, create if doesn't exist\n        return getOrCreateNetworkBridge(network.getId(), getAccountUuid(network));\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"private void deleteNetworkBridges(Network network){\n        long accountID = network.getAccountId();\n        long networkID = network.getId();\n\n        Bridge netBridge = getNetworkBridge(networkID, accountID);\n        if(netBridge != null){\n\n            cleanBridge(netBridge);\n\n            // Delete DHCP subnets\n            for(Object dhcpSubnet : netBridge.getDhcpSubnets()){\n                DhcpSubnet sub = (DhcpSubnet) dhcpSubnet;\n                sub.delete();\n            }\n\n            netBridge.delete();\n        }\n    }","id":92316,"modified_method":"private void deleteNetworkBridges(Network network){\n        String accountUuid = getAccountUuid(network);\n        long networkID = network.getId();\n\n        Bridge netBridge = getNetworkBridge(networkID, accountUuid);\n        if(netBridge != null){\n\n            cleanBridge(netBridge);\n\n            // Delete DHCP subnets\n            for(Object dhcpSubnet : netBridge.getDhcpSubnets()){\n                DhcpSubnet sub = (DhcpSubnet) dhcpSubnet;\n                sub.delete();\n            }\n\n            netBridge.delete();\n        }\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"private Router getOrCreateGuestNetworkRouter(long id, long accountID, boolean isVpc) {\n        Router tenantRouter = getGuestNetworkRouter(id, accountID, isVpc);\n        if(tenantRouter == null){\n            tenantRouter = createRouter(id, accountID, isVpc);\n        }\n        return tenantRouter;\n    }","id":92317,"modified_method":"private Router getOrCreateGuestNetworkRouter(long id, String accountUuid, boolean isVpc) {\n        Router tenantRouter = getGuestNetworkRouter(id, accountUuid, isVpc);\n        if(tenantRouter == null){\n            tenantRouter = createRouter(id, accountUuid, isVpc);\n        }\n        return tenantRouter;\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean midoInNetwork(Network network) {\n        for (String pname : _ntwkSrvcDao.getDistinctProviders(network.getId())) {\n            if (pname.equals(getProvider().getName())) {\n                return true;\n            }\n        }\n        return false;\n    }","id":92318,"modified_method":"public boolean midoInNetwork(Network network) {\n        if((network.getTrafficType() == Networks.TrafficType.Public) &&\n           (network.getBroadcastDomainType() == Networks.BroadcastDomainType.Mido)){\n            return true;\n        }\n        if((network.getTrafficType() == Networks.TrafficType.Guest) &&\n           (network.getBroadcastDomainType() == Networks.BroadcastDomainType.Mido)){\n            return true;\n        }\n        return false;\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean applyFWRules(Network config, List<? extends FirewallRule> rulesToApply) throws ResourceUnavailableException {\n        if (!midoInNetwork(config)) {\n            return false;\n        }\n        if (canHandle(config, Service.Firewall)) {\n            String accountIdStr = String.valueOf(config.getAccountId());\n            String networkUUIDStr = String.valueOf(config.getId());\n            RuleChain preFilter = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PREFILTER);\n            RuleChain preNat = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PRENAT);\n\n            // Create a map of Rule description -> Rule for quicker lookups\n            Map<String, Rule> existingRules = new HashMap<String, Rule>();\n\n            for (Rule existingRule : preFilter.getRules()) {\n                // The \"whitelist\" rules we're interested in are the Jump rules where src address is specified\n                if(existingRule.getType().equals(DtoRule.Jump) && existingRule.getNwSrcAddress() != null){\n                    String ruleString = new SimpleFirewallRule(existingRule).toStringArray()[0];\n                    existingRules.put(ruleString, existingRule);\n                }\n            }\n\n            for (FirewallRule rule : rulesToApply) {\n                IpAddress dstIp = _networkModel.getIp(rule.getSourceIpAddressId());\n                FirewallRuleTO ruleTO = new FirewallRuleTO(rule, null, dstIp.getAddress().addr());\n\n                // Convert to string representation\n                SimpleFirewallRule fwRule = new SimpleFirewallRule(ruleTO);\n                String[] ruleStrings = fwRule.toStringArray();\n\n                if (rule.getState() == FirewallRule.State.Revoke) {\n                    // Lookup in existingRules, delete if present\n                    for(String revokeRuleString : ruleStrings){\n                        Rule foundRule = existingRules.get(revokeRuleString);\n                        if(foundRule != null){\n                            foundRule.delete();\n                        }\n                    }\n                } else if (rule.getState() == FirewallRule.State.Add) {\n                    // Lookup in existingRules, add if not present\n                    for(int i = 0; i < ruleStrings.length; i++){\n                        String ruleString = ruleStrings[i];\n                        Rule foundRule = existingRules.get(ruleString);\n                        if(foundRule == null){\n                            // Get the cidr for the related entry in the Source Cidrs list\n                            String relatedCidr = fwRule.sourceCidrs.get(i);\n                            Pair<String,Integer> cidrParts = NetUtils.getCidr(relatedCidr);\n\n                            // Create rule with correct proto, cidr, ACCEPT, dst IP\n                            Rule toApply = preFilter.addRule()\n                                    .type(DtoRule.Jump)\n                                    .jumpChainId(preNat.getId())\n                                    .position(1)\n                                    .nwSrcAddress(cidrParts.first())\n                                    .nwSrcLength(cidrParts.second())\n                                    .nwDstAddress(ruleTO.getSrcIp())\n                                    .nwDstLength(32)\n                                    .nwProto(SimpleFirewallRule.stringToProtocolNumber(rule.getProtocol()));\n\n                            if(rule.getProtocol().equals(\"icmp\")){\n                                // ICMP rules - reuse port fields\n                                toApply.tpSrcStart(fwRule.icmpType).tpSrcEnd(fwRule.icmpType)\n                                    .tpDstStart(fwRule.icmpCode).tpDstEnd(fwRule.icmpCode);\n                            } else {\n                                toApply.tpDstStart(fwRule.dstPortStart)\n                                        .tpDstEnd(fwRule.dstPortEnd);\n                            }\n\n                            toApply.create();\n                        }\n                    }\n                }\n            }\n            return true;\n        } else {\n            return true;\n        }\n    }","id":92319,"modified_method":"@Override\n    public boolean applyFWRules(Network config, List<? extends FirewallRule> rulesToApply) throws ResourceUnavailableException {\n        if (!midoInNetwork(config)) {\n            return false;\n        }\n        if (canHandle(config, Service.Firewall)) {\n            String accountIdStr = getAccountUuid(config);\n            String networkUUIDStr = String.valueOf(config.getId());\n            RuleChain preFilter = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PREFILTER);\n            RuleChain preNat = getChain(accountIdStr, networkUUIDStr, RuleChainCode.TR_PRENAT);\n\n            // Create a map of Rule description -> Rule for quicker lookups\n            Map<String, Rule> existingRules = new HashMap<String, Rule>();\n\n            for (Rule existingRule : preFilter.getRules()) {\n                // The \"whitelist\" rules we're interested in are the Jump rules where src address is specified\n                if(existingRule.getType().equals(DtoRule.Jump) && existingRule.getNwSrcAddress() != null){\n                    String ruleString = new SimpleFirewallRule(existingRule).toStringArray()[0];\n                    existingRules.put(ruleString, existingRule);\n                }\n            }\n\n            for (FirewallRule rule : rulesToApply) {\n                IpAddress dstIp = _networkModel.getIp(rule.getSourceIpAddressId());\n                FirewallRuleTO ruleTO = new FirewallRuleTO(rule, null, dstIp.getAddress().addr());\n\n                // Convert to string representation\n                SimpleFirewallRule fwRule = new SimpleFirewallRule(ruleTO);\n                String[] ruleStrings = fwRule.toStringArray();\n\n                if (rule.getState() == FirewallRule.State.Revoke) {\n                    // Lookup in existingRules, delete if present\n                    for(String revokeRuleString : ruleStrings){\n                        Rule foundRule = existingRules.get(revokeRuleString);\n                        if(foundRule != null){\n                            foundRule.delete();\n                        }\n                    }\n                } else if (rule.getState() == FirewallRule.State.Add) {\n                    // Lookup in existingRules, add if not present\n                    for(int i = 0; i < ruleStrings.length; i++){\n                        String ruleString = ruleStrings[i];\n                        Rule foundRule = existingRules.get(ruleString);\n                        if(foundRule == null){\n                            // Get the cidr for the related entry in the Source Cidrs list\n                            String relatedCidr = fwRule.sourceCidrs.get(i);\n                            Pair<String,Integer> cidrParts = NetUtils.getCidr(relatedCidr);\n\n                            // Create rule with correct proto, cidr, ACCEPT, dst IP\n                            Rule toApply = preFilter.addRule()\n                                    .type(DtoRule.Jump)\n                                    .jumpChainId(preNat.getId())\n                                    .position(1)\n                                    .nwSrcAddress(cidrParts.first())\n                                    .nwSrcLength(cidrParts.second())\n                                    .nwDstAddress(ruleTO.getSrcIp())\n                                    .nwDstLength(32)\n                                    .nwProto(SimpleFirewallRule.stringToProtocolNumber(rule.getProtocol()));\n\n                            if(rule.getProtocol().equals(\"icmp\")){\n                                // ICMP rules - reuse port fields\n                                toApply.tpSrcStart(fwRule.icmpType).tpSrcEnd(fwRule.icmpType)\n                                    .tpDstStart(fwRule.icmpCode).tpDstEnd(fwRule.icmpCode);\n                            } else {\n                                toApply.tpDstStart(fwRule.dstPortStart)\n                                        .tpDstEnd(fwRule.dstPortEnd);\n                            }\n\n                            toApply.create();\n                        }\n                    }\n                }\n            }\n            return true;\n        } else {\n            return true;\n        }\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"protected RuleChain getChain(String networkId, String accountID,\n                               String routerName, RuleChainCode chainCode){\n        String chainName = getChainName(networkId, routerName, chainCode);\n\n        MultivaluedMap findChain = new MultivaluedMapImpl();\n        findChain.add(\"tenant_id\", accountID);\n\n        ResourceCollection<RuleChain> ruleChains = api.getChains(findChain);\n\n        for(RuleChain chain : ruleChains){\n            if(chain.getName().equals(chainName)){\n                return chain;\n            }\n        }\n\n        return null;\n    }","id":92320,"modified_method":"protected RuleChain getChain(String networkId, String accountUuid,\n                               String routerName, RuleChainCode chainCode){\n        String chainName = getChainName(networkId, routerName, chainCode);\n\n        MultivaluedMap findChain = new MultivaluedMapImpl();\n        findChain.add(\"tenant_id\", accountUuid);\n\n        ResourceCollection<RuleChain> ruleChains = api.getChains(findChain);\n\n        for(RuleChain chain : ruleChains){\n            if(chain.getName().equals(chainName)){\n                return chain;\n            }\n        }\n\n        return null;\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"private void deleteGuestNetworkRouters(Network network){\n        long accountID = network.getAccountId();\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n\n        Router tenantRouter = getGuestNetworkRouter(id, accountID, isVpc);\n\n        // Delete any peer ports corresponding to this router\n        for(Port peerPort : tenantRouter.getPeerPorts((new MultivaluedMapImpl()))){\n            if(peerPort != null && peerPort instanceof RouterPort){\n                RouterPort checkPort = (RouterPort) peerPort;\n                if(checkPort.getType().equals(\"ExteriorRouter\")) {\n                    checkPort.vifId(null).update();\n                } else if (checkPort.getType().equals(\"InteriorRouter\")) {\n                    checkPort.unlink();\n                }\n                checkPort.delete();\n            } else if (peerPort != null && peerPort instanceof BridgePort) {\n                BridgePort checkPort = (BridgePort) peerPort;\n                if(checkPort.getType().equals(\"ExteriorBridge\")) {\n                    checkPort.vifId(null).update();\n                } else if (checkPort.getType().equals(\"InteriorBridge\")) {\n                    checkPort.unlink();\n                }\n                checkPort.delete();\n            }\n        }\n\n        if(tenantRouter != null){\n            // Remove all peer ports if any exist\n            for(RouterPort p : tenantRouter.getPorts(new MultivaluedMapImpl())) {\n                if(p.getType().equals(\"ExteriorRouter\")) {\n                    // Set VIF ID to null\n                    p.vifId(null).update();\n                    // the port might have some chains associated with it\n                }\n\n                if(p.getType().equals(\"InteriorRouter\")) {\n                    p.unlink();\n                }\n\n                // Delete port\n                p.delete();\n            }\n\n            // Remove inbound and outbound filter chains\n            String accountIdStr = String.valueOf(accountID);\n            String routerName = getRouterName(isVpc, id);\n\n            RuleChain pre = api.getChain(tenantRouter.getInboundFilterId());\n            RuleChain preFilter = getChain(accountIdStr, routerName, RuleChainCode.TR_PREFILTER);\n            RuleChain preNat = getChain(accountIdStr, routerName, RuleChainCode.TR_PRENAT);\n            RuleChain post = api.getChain(tenantRouter.getOutboundFilterId());\n\n            pre.delete();\n            preFilter.delete();\n            preNat.delete();\n            post.delete();\n\n\n            // Remove routes\n            for(Route r : tenantRouter.getRoutes(new MultivaluedMapImpl())) {\n                r.delete();\n            }\n\n            tenantRouter.delete();\n        }\n    }","id":92321,"modified_method":"private void deleteGuestNetworkRouters(Network network){\n        String accountUuid = getAccountUuid(network);\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n\n        Router tenantRouter = getGuestNetworkRouter(id, accountUuid, isVpc);\n\n        // Delete any peer ports corresponding to this router\n        for(Port peerPort : tenantRouter.getPeerPorts((new MultivaluedMapImpl()))){\n            if(peerPort != null && peerPort instanceof RouterPort){\n                RouterPort checkPort = (RouterPort) peerPort;\n                if(checkPort.getType().equals(\"ExteriorRouter\")) {\n                    checkPort.vifId(null).update();\n                } else if (checkPort.getType().equals(\"InteriorRouter\")) {\n                    checkPort.unlink();\n                }\n                checkPort.delete();\n            } else if (peerPort != null && peerPort instanceof BridgePort) {\n                BridgePort checkPort = (BridgePort) peerPort;\n                if(checkPort.getType().equals(\"ExteriorBridge\")) {\n                    checkPort.vifId(null).update();\n                } else if (checkPort.getType().equals(\"InteriorBridge\")) {\n                    checkPort.unlink();\n                }\n                checkPort.delete();\n            }\n        }\n\n        if(tenantRouter != null){\n            // Remove all peer ports if any exist\n            for(RouterPort p : tenantRouter.getPorts(new MultivaluedMapImpl())) {\n                if(p.getType().equals(\"ExteriorRouter\")) {\n                    // Set VIF ID to null\n                    p.vifId(null).update();\n                    // the port might have some chains associated with it\n                }\n\n                if(p.getType().equals(\"InteriorRouter\")) {\n                    p.unlink();\n                }\n\n                // Delete port\n                p.delete();\n            }\n\n            // Remove inbound and outbound filter chains\n            String accountIdStr = String.valueOf(accountUuid);\n            String routerName = getRouterName(isVpc, id);\n\n            RuleChain pre = api.getChain(tenantRouter.getInboundFilterId());\n            RuleChain preFilter = getChain(accountIdStr, routerName, RuleChainCode.TR_PREFILTER);\n            RuleChain preNat = getChain(accountIdStr, routerName, RuleChainCode.TR_PRENAT);\n            RuleChain post = api.getChain(tenantRouter.getOutboundFilterId());\n\n            pre.delete();\n            preFilter.delete();\n            preNat.delete();\n            post.delete();\n\n\n            // Remove routes\n            for(Route r : tenantRouter.getRoutes(new MultivaluedMapImpl())) {\n                r.delete();\n            }\n\n            tenantRouter.delete();\n        }\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"private Bridge getNetworkBridge(long networkID, long accountID){\n\n        MultivaluedMap qNetBridge = new MultivaluedMapImpl();\n        String accountIdStr = String.valueOf(accountID);\n        String networkUUIDStr = String.valueOf(networkID);\n        qNetBridge.add(\"tenant_id\", accountIdStr);\n\n        for (Bridge b : this. api.getBridges(qNetBridge)) {\n            if(b.getName().equals(networkUUIDStr)){\n                return b;\n            }\n        }\n\n        return null;\n    }","id":92322,"modified_method":"private Bridge getNetworkBridge(long networkID, String accountUuid){\n\n        MultivaluedMap qNetBridge = new MultivaluedMapImpl();\n        String networkUUIDStr = String.valueOf(networkID);\n        qNetBridge.add(\"tenant_id\", accountUuid);\n\n        for (Bridge b : this. api.getBridges(qNetBridge)) {\n            if(b.getName().equals(networkUUIDStr)){\n                return b;\n            }\n        }\n\n        return null;\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"private Router getGuestNetworkRouter(long id, long accountID, boolean isVpc){\n\n        MultivaluedMap qNetRouter = new MultivaluedMapImpl();\n        String accountIdStr = String.valueOf(accountID);\n        String routerName = getRouterName(isVpc, id);\n\n        qNetRouter.add(\"tenant_id\", accountIdStr);\n\n        for (Router router : api.getRouters(qNetRouter)) {\n            if(router.getName().equals(routerName)){\n                return router;\n            }\n        }\n\n        return null;\n    }","id":92323,"modified_method":"private Router getGuestNetworkRouter(long id, String accountUuid, boolean isVpc){\n\n        MultivaluedMap qNetRouter = new MultivaluedMapImpl();\n        String routerName = getRouterName(isVpc, id);\n\n        qNetRouter.add(\"tenant_id\", accountUuid);\n\n        for (Router router : api.getRouters(qNetRouter)) {\n            if(router.getName().equals(routerName)){\n                return router;\n            }\n        }\n\n        return null;\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * From interface StaticNatServiceProvider\n     */\n    @Override\n    public boolean applyStaticNats(Network network,\n                                   List<? extends StaticNat> rules)\n            throws ResourceUnavailableException {\n        s_logger.debug(\"applyStaticNats called with network: \" + network.toString());\n        if (!midoInNetwork(network)) {\n            return false;\n        }\n        if (!canHandle(network, Service.StaticNat)) {\n            return false;\n        }\n\n        boolean resources = false;\n        Router tenantRouter = null;\n        Router providerRouter = null;\n\n        RouterPort[] ports = null;\n\n        RouterPort tenantUplink = null;\n        RouterPort providerDownlink = null;\n\n        RuleChain preFilter = null;\n        RuleChain preNat = null;\n        RuleChain post = null;\n\n        String accountIdStr = String.valueOf(network.getAccountId());\n        String networkUUIDStr = String.valueOf(network.getId());\n\n        for (StaticNat rule : rules) {\n            IpAddress sourceIp = _networkModel.getIp(rule.getSourceIpAddressId());\n            String sourceIpAddr = sourceIp.getAddress().addr();\n\n            if (resources == false) {\n                tenantRouter = getOrCreateGuestNetworkRouter(network);\n                providerRouter = api.getRouter(_providerRouterId);\n\n                ports = getOrCreateProviderRouterPorts(tenantRouter, providerRouter);\n\n                tenantUplink = ports[0];\n                providerDownlink = ports[1];\n\n                boolean isVpc = getIsVpc(network);\n                long id = getRouterId(network, isVpc);\n                String routerName = getRouterName(isVpc, id);\n\n                preFilter = getChain(accountIdStr, routerName, RuleChainCode.TR_PREFILTER);\n                preNat = getChain(accountIdStr, routerName, RuleChainCode.TR_PRENAT);\n                post = api.getChain(tenantRouter.getOutboundFilterId());\n                resources = true;\n            }\n\n            if (rule.isForRevoke()) {\n                removeMidonetStaticNAT(preFilter, preNat, post,\n                                       sourceIpAddr, rule.getDestIpAddress(),\n                                       providerRouter);\n            } else {\n                addMidonetStaticNAT(preFilter, preNat, post,\n                                    sourceIpAddr, rule.getDestIpAddress(),\n                                    tenantUplink, providerDownlink,\n                                    providerRouter,\n                                    network);\n            }\n        }\n\n        return true;\n    }","id":92324,"modified_method":"/**\n     * From interface StaticNatServiceProvider\n     */\n    @Override\n    public boolean applyStaticNats(Network network,\n                                   List<? extends StaticNat> rules)\n            throws ResourceUnavailableException {\n        s_logger.debug(\"applyStaticNats called with network: \" + network.toString());\n        if (!midoInNetwork(network)) {\n            return false;\n        }\n        if (!canHandle(network, Service.StaticNat)) {\n            return false;\n        }\n\n        boolean resources = false;\n        Router tenantRouter = null;\n        Router providerRouter = null;\n\n        RouterPort[] ports = null;\n\n        RouterPort tenantUplink = null;\n        RouterPort providerDownlink = null;\n\n        RuleChain preFilter = null;\n        RuleChain preNat = null;\n        RuleChain post = null;\n\n        String accountIdStr = getAccountUuid(network);\n        String networkUUIDStr = String.valueOf(network.getId());\n\n        for (StaticNat rule : rules) {\n            IpAddress sourceIp = _networkModel.getIp(rule.getSourceIpAddressId());\n            String sourceIpAddr = sourceIp.getAddress().addr();\n\n            if (resources == false) {\n                tenantRouter = getOrCreateGuestNetworkRouter(network);\n                providerRouter = api.getRouter(_providerRouterId);\n\n                ports = getOrCreateProviderRouterPorts(tenantRouter, providerRouter);\n\n                tenantUplink = ports[0];\n                providerDownlink = ports[1];\n\n                boolean isVpc = getIsVpc(network);\n                long id = getRouterId(network, isVpc);\n                String routerName = getRouterName(isVpc, id);\n\n                preFilter = getChain(accountIdStr, routerName, RuleChainCode.TR_PREFILTER);\n                preNat = getChain(accountIdStr, routerName, RuleChainCode.TR_PRENAT);\n                post = api.getChain(tenantRouter.getOutboundFilterId());\n                resources = true;\n            }\n\n            if (rule.isForRevoke()) {\n                removeMidonetStaticNAT(preFilter, preNat, post,\n                                       sourceIpAddr, rule.getDestIpAddress(),\n                                       providerRouter);\n            } else {\n                addMidonetStaticNAT(preFilter, preNat, post,\n                                    sourceIpAddr, rule.getDestIpAddress(),\n                                    tenantUplink, providerDownlink,\n                                    providerRouter,\n                                    network);\n            }\n        }\n\n        return true;\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Router createRouter(long id, long accountID, boolean isVpc) {\n\n        String accountIdStr = String.valueOf(accountID);\n        String routerName = getRouterName(isVpc, id);\n\n        //Set up rule chains\n        RuleChain pre = api.addChain()\n                            .name(getChainName(routerName, RuleChainCode.TR_PRE))\n                            .tenantId(accountIdStr)\n                            .create();\n        RuleChain post = api.addChain()\n                            .name(getChainName(routerName, RuleChainCode.TR_POST))\n                            .tenantId(accountIdStr)\n                            .create();\n\n        // Set up NAT and filter chains for pre-routing\n        RuleChain preFilter = api.addChain()\n                                  .name(getChainName(routerName, RuleChainCode.TR_PREFILTER))\n                                  .tenantId(accountIdStr)\n                                  .create();\n        RuleChain preNat = api.addChain()\n                                  .name(getChainName(routerName, RuleChainCode.TR_PRENAT))\n                                  .tenantId(accountIdStr)\n                                  .create();\n\n        // Hook the chains in - first jump to Filter chain, then jump to Nat chain\n        pre.addRule().type(DtoRule.Jump)\n                     .jumpChainId(preFilter.getId())\n                     .position(1)\n                     .create();\n        pre.addRule().type(DtoRule.Jump)\n                     .jumpChainId(preNat.getId())\n                     .position(2)\n                     .create();\n\n        return api.addRouter()\n                   .tenantId(accountIdStr)\n                   .name(routerName)\n                   .inboundFilterId(pre.getId())\n                   .outboundFilterId(post.getId())\n                   .create();\n    }","id":92325,"modified_method":"protected Router createRouter(long id, String accountUuid, boolean isVpc) {\n\n        String routerName = getRouterName(isVpc, id);\n\n        //Set up rule chains\n        RuleChain pre = api.addChain()\n                            .name(getChainName(routerName, RuleChainCode.TR_PRE))\n                            .tenantId(accountUuid)\n                            .create();\n        RuleChain post = api.addChain()\n                            .name(getChainName(routerName, RuleChainCode.TR_POST))\n                            .tenantId(accountUuid)\n                            .create();\n\n        // Set up NAT and filter chains for pre-routing\n        RuleChain preFilter = api.addChain()\n                                  .name(getChainName(routerName, RuleChainCode.TR_PREFILTER))\n                                  .tenantId(accountUuid)\n                                  .create();\n        RuleChain preNat = api.addChain()\n                                  .name(getChainName(routerName, RuleChainCode.TR_PRENAT))\n                                  .tenantId(accountUuid)\n                                  .create();\n\n        // Hook the chains in - first jump to Filter chain, then jump to Nat chain\n        pre.addRule().type(DtoRule.Jump)\n                     .jumpChainId(preFilter.getId())\n                     .position(1)\n                     .create();\n        pre.addRule().type(DtoRule.Jump)\n                     .jumpChainId(preNat.getId())\n                     .position(2)\n                     .create();\n\n        return api.addRouter()\n                   .tenantId(accountUuid)\n                   .name(routerName)\n                   .inboundFilterId(pre.getId())\n                   .outboundFilterId(post.getId())\n                   .create();\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"private Router getOrCreateGuestNetworkRouter(Network network){\n        // Find the single bridge for this (isolated) guest network, create if doesn't exist\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n\n        return getOrCreateGuestNetworkRouter(id, network.getAccountId(), isVpc);\n\n    }","id":92326,"modified_method":"private Router getOrCreateGuestNetworkRouter(Network network){\n        // Find the single bridge for this (isolated) guest network, create if doesn't exist\n        boolean isVpc = getIsVpc(network);\n        long id = getRouterId(network, isVpc);\n\n        return getOrCreateGuestNetworkRouter(id, getAccountUuid(network), isVpc);\n\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"public void testAddDhcpEntry() {\n\n        //mockMgmt\n        MidonetApi api = mock(MidonetApi.class, RETURNS_DEEP_STUBS);\n        ArrayList<String> arr = new ArrayList<String>();\n        arr.add(\"MidoNet\");\n        NetworkServiceMapDao mockNSMD = mock(NetworkServiceMapDao.class);\n        when(mockNSMD.getDistinctProviders(anyLong())).thenReturn(arr);\n\n        //mockDhcpHost\n        DhcpHost mockDhcpHost = mock(DhcpHost.class);\n\n        //mockHostCollection\n        ResourceCollection<DhcpHost> hosts =\n                new ResourceCollection<DhcpHost>(new ArrayList<DhcpHost>());\n\n        //mockDhcpSubnet\n        DhcpSubnet mockSub = mock(DhcpSubnet.class);\n        when(mockSub.addDhcpHost()).thenReturn(mockDhcpHost);\n        when(mockSub.getDhcpHosts()).thenReturn(hosts);\n\n        //mockSubnetCollection\n        ResourceCollection mockSubnetCollection = mock(ResourceCollection.class);\n        when(mockSubnetCollection.get(anyInt())).thenReturn(mockSub);\n\n        //mockBridge\n        Bridge mockBridge = mock(Bridge.class);\n        when(api.addBridge().tenantId(anyString()).name(anyString()).create()).thenReturn(mockBridge);\n        when(mockBridge.getDhcpSubnets()).thenReturn(mockSubnetCollection);\n\n        //mockRouter\n        Router mockRouter = mock(Router.class);\n        when(api.addRouter().tenantId(anyString()).name(anyString()).create()).thenReturn(mockRouter);\n\n        //mockNetwork\n        Network mockNetwork = mock(Network.class);\n        when(mockNetwork.getAccountId()).thenReturn((long)1);\n        when(mockNetwork.getGateway()).thenReturn(\"1.2.3.4\");\n        when(mockNetwork.getCidr()).thenReturn(\"1.2.3.0/24\");\n        when(mockNetwork.getId()).thenReturn((long)2);\n\n        //mockNic\n        NicProfile mockNic = mock(NicProfile.class);\n        when(mockNic.getIp4Address()).thenReturn(\"10.10.10.170\");\n        when(mockNic.getMacAddress()).thenReturn(\"02:00:73:3e:00:01\");\n        when(mockNic.getName()).thenReturn(\"Fake Name\");\n\n        //mockVm\n        @SuppressWarnings(\"unchecked\")\n        VirtualMachineProfile<? extends VirtualMachine> mockVm =\n                (VirtualMachineProfile<? extends VirtualMachine>)mock(VirtualMachineProfile.class);\n        when(mockVm.getType()).thenReturn(VirtualMachine.Type.User);\n\n        MidoNetElement elem = new MidoNetElement();\n        elem.setNtwkSrvcDao(mockNSMD);\n        elem.setMidonetApi(api);\n\n        boolean result = false;\n        try {\n            result = elem.addDhcpEntry(mockNetwork, mockNic, mockVm, null, null);\n        } catch (ConcurrentOperationException e) {\n            fail(e.getMessage());\n        } catch (InsufficientCapacityException e) {\n            fail(e.getMessage());\n        } catch (ResourceUnavailableException e) {\n            fail(e.getMessage());\n        }\n\n        assertEquals(result, true);\n    }","id":92327,"modified_method":"public void testAddDhcpEntry() {\n\n        //mockMgmt\n        MidonetApi api = mock(MidonetApi.class, RETURNS_DEEP_STUBS);\n\n        //mockDhcpHost\n        DhcpHost mockDhcpHost = mock(DhcpHost.class);\n\n        //mockHostCollection\n        ResourceCollection<DhcpHost> hosts =\n                new ResourceCollection<DhcpHost>(new ArrayList<DhcpHost>());\n\n        //mockDhcpSubnet\n        DhcpSubnet mockSub = mock(DhcpSubnet.class);\n        when(mockSub.addDhcpHost()).thenReturn(mockDhcpHost);\n        when(mockSub.getDhcpHosts()).thenReturn(hosts);\n\n        //mockSubnetCollection\n        ResourceCollection mockSubnetCollection = mock(ResourceCollection.class);\n        when(mockSubnetCollection.get(anyInt())).thenReturn(mockSub);\n\n        //mockBridge\n        Bridge mockBridge = mock(Bridge.class);\n        when(api.addBridge().tenantId(anyString()).name(anyString()).create()).thenReturn(mockBridge);\n        when(mockBridge.getDhcpSubnets()).thenReturn(mockSubnetCollection);\n\n        //mockRouter\n        Router mockRouter = mock(Router.class);\n        when(api.addRouter().tenantId(anyString()).name(anyString()).create()).thenReturn(mockRouter);\n\n        //mockNetwork\n        Network mockNetwork = mock(Network.class);\n        when(mockNetwork.getAccountId()).thenReturn((long)1);\n        when(mockNetwork.getGateway()).thenReturn(\"1.2.3.4\");\n        when(mockNetwork.getCidr()).thenReturn(\"1.2.3.0/24\");\n        when(mockNetwork.getId()).thenReturn((long)2);\n        when(mockNetwork.getBroadcastDomainType()).thenReturn(Networks.BroadcastDomainType.Mido);\n        when(mockNetwork.getTrafficType()).thenReturn(Networks.TrafficType.Guest);\n\n        //mockAccountDao\n        AccountDao mockAccountDao = mock(AccountDao.class);\n        AccountVO mockAccountVO = mock(AccountVO.class);\n        when(mockAccountDao.findById(anyLong())).thenReturn(mockAccountVO);\n        when(mockAccountVO.getUuid()).thenReturn(\"1\");\n\n        //mockNic\n        NicProfile mockNic = mock(NicProfile.class);\n        when(mockNic.getIp4Address()).thenReturn(\"10.10.10.170\");\n        when(mockNic.getMacAddress()).thenReturn(\"02:00:73:3e:00:01\");\n        when(mockNic.getName()).thenReturn(\"Fake Name\");\n\n        //mockVm\n        @SuppressWarnings(\"unchecked\")\n        VirtualMachineProfile<? extends VirtualMachine> mockVm =\n                (VirtualMachineProfile<? extends VirtualMachine>)mock(VirtualMachineProfile.class);\n        when(mockVm.getType()).thenReturn(VirtualMachine.Type.User);\n\n        MidoNetElement elem = new MidoNetElement();\n        elem.setMidonetApi(api);\n        elem.setAccountDao(mockAccountDao);\n\n        boolean result = false;\n        try {\n            result = elem.addDhcpEntry(mockNetwork, mockNic, mockVm, null, null);\n        } catch (ConcurrentOperationException e) {\n            fail(e.getMessage());\n        } catch (InsufficientCapacityException e) {\n            fail(e.getMessage());\n        } catch (ResourceUnavailableException e) {\n            fail(e.getMessage());\n        }\n\n        assertEquals(result, true);\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"public void testImplement() {\n        //mock\n        MidonetApi api = mock(MidonetApi.class, RETURNS_DEEP_STUBS);\n        ArrayList<String> arr = new ArrayList<String>();\n        arr.add(\"MidoNet\");\n        NetworkServiceMapDao mockNSMD = mock(NetworkServiceMapDao.class);\n        when(mockNSMD.getDistinctProviders(anyLong())).thenReturn(arr);\n\n        MidoNetElement elem = new MidoNetElement();\n        elem.setNtwkSrvcDao(mockNSMD);\n        elem.setMidonetApi(api);\n\n        //mockRPort\n        RouterPort mockRPort = mock(RouterPort.class);\n        when(mockRPort.getId()).thenReturn(UUID.fromString(\"550e8400-e29b-41d4-a716-446655440000\"));\n\n        //mockBPort\n        BridgePort mockBPort = mock(BridgePort.class);\n        when(mockBPort.link(any(UUID.class))).thenReturn(mockBPort);\n\n        //mockPort\n        Port mockPort = mock(Port.class);\n\n        ResourceCollection<Port> peerPorts =\n            new ResourceCollection<Port>(new ArrayList<Port>());\n\n        peerPorts.add(mockPort);\n\n        //mockBridge\n        Bridge mockBridge = mock(Bridge.class, RETURNS_DEEP_STUBS);\n        when(api.addBridge().tenantId(anyString()).name(anyString()).create()).thenReturn(mockBridge);\n        when(mockBridge.addInteriorPort().create()).thenReturn(mockBPort);\n        when(mockBridge.getPeerPorts()).thenReturn(peerPorts);\n\n        //mockRouter\n        Router mockRouter = mock(Router.class, RETURNS_DEEP_STUBS);\n        when(api.addRouter().tenantId(anyString()).name(anyString()).create()).thenReturn(mockRouter);\n        when(mockRouter.addInteriorRouterPort().create()).thenReturn(mockRPort);\n\n        //mockNetwork\n        Network mockNetwork = mock(Network.class);\n        when(mockNetwork.getAccountId()).thenReturn((long)1);\n        when(mockNetwork.getGateway()).thenReturn(\"1.2.3.4\");\n        when(mockNetwork.getCidr()).thenReturn(\"1.2.3.0/24\");\n        when(mockNetwork.getId()).thenReturn((long)2);\n\n        boolean result = false;\n        try {\n            result = elem.implement(mockNetwork, null, null, null);\n        } catch (ConcurrentOperationException e) {\n            fail(e.getMessage());\n        } catch (InsufficientCapacityException e) {\n            fail(e.getMessage());\n        } catch (ResourceUnavailableException e) {\n            fail(e.getMessage());\n        }\n\n        assertEquals(result, true);\n    }","id":92328,"modified_method":"public void testImplement() {\n        //mock\n        MidonetApi api = mock(MidonetApi.class, RETURNS_DEEP_STUBS);\n\n        //mockAccountDao\n        AccountDao mockAccountDao = mock(AccountDao.class);\n        AccountVO mockAccountVO = mock(AccountVO.class);\n        when(mockAccountDao.findById(anyLong())).thenReturn(mockAccountVO);\n        when(mockAccountVO.getUuid()).thenReturn(\"1\");\n        MidoNetElement elem = new MidoNetElement();\n\n        elem.setMidonetApi(api);\n        elem.setAccountDao(mockAccountDao);\n\n        //mockRPort\n        RouterPort mockRPort = mock(RouterPort.class);\n        when(mockRPort.getId()).thenReturn(UUID.fromString(\"550e8400-e29b-41d4-a716-446655440000\"));\n\n        //mockBPort\n        BridgePort mockBPort = mock(BridgePort.class);\n        when(mockBPort.link(any(UUID.class))).thenReturn(mockBPort);\n\n        //mockPort\n        Port mockPort = mock(Port.class);\n\n        ResourceCollection<Port> peerPorts =\n            new ResourceCollection<Port>(new ArrayList<Port>());\n\n        peerPorts.add(mockPort);\n\n        //mockBridge\n        Bridge mockBridge = mock(Bridge.class, RETURNS_DEEP_STUBS);\n        when(api.addBridge().tenantId(anyString()).name(anyString()).create()).thenReturn(mockBridge);\n        when(mockBridge.addInteriorPort().create()).thenReturn(mockBPort);\n        when(mockBridge.getPeerPorts()).thenReturn(peerPorts);\n\n        //mockRouter\n        Router mockRouter = mock(Router.class, RETURNS_DEEP_STUBS);\n        when(api.addRouter().tenantId(anyString()).name(anyString()).create()).thenReturn(mockRouter);\n        when(mockRouter.addInteriorRouterPort().create()).thenReturn(mockRPort);\n\n        //mockNetwork\n        Network mockNetwork = mock(Network.class);\n        when(mockNetwork.getAccountId()).thenReturn((long)1);\n        when(mockNetwork.getGateway()).thenReturn(\"1.2.3.4\");\n        when(mockNetwork.getCidr()).thenReturn(\"1.2.3.0/24\");\n        when(mockNetwork.getId()).thenReturn((long)2);\n        when(mockNetwork.getBroadcastDomainType()).thenReturn(Networks.BroadcastDomainType.Mido);\n        when(mockNetwork.getTrafficType()).thenReturn(Networks.TrafficType.Public);\n\n        boolean result = false;\n        try {\n            result = elem.implement(mockNetwork, null, null, null);\n        } catch (ConcurrentOperationException e) {\n            fail(e.getMessage());\n        } catch (InsufficientCapacityException e) {\n            fail(e.getMessage());\n        } catch (ResourceUnavailableException e) {\n            fail(e.getMessage());\n        }\n\n        assertEquals(result, true);\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Network implement(Network network, NetworkOffering offering,\n                             DeployDestination dest, ReservationContext context)\n            throws InsufficientVirtualNetworkCapcityException {\n        assert (network.getState() == Network.State.Implementing) : \"Why are we implementing \" + network;\n        s_logger.debug(\"implement called network: \" + network.toString());\n\n        long dcId = dest.getDataCenter().getId();\n\n        //get physical network id\n        long physicalNetworkId = _networkModel.findPhysicalNetworkId(dcId, offering.getTags(), offering.getTrafficType());\n\n        NetworkVO implemented = new NetworkVO(network.getTrafficType(), network.getMode(), network.getBroadcastDomainType(), network.getNetworkOfferingId(), Network.State.Allocated,\n                network.getDataCenterId(), physicalNetworkId);\n\n        if (network.getGateway() != null) {\n            implemented.setGateway(network.getGateway());\n        }\n\n        if (network.getCidr() != null) {\n            implemented.setCidr(network.getCidr());\n        }\n\n        String accountIdStr = String.valueOf(network.getAccountId());\n        String routerName = \"\";\n        if (network.getVpcId() != null) {\n            routerName = \"VPC\" + String.valueOf(network.getVpcId());\n        } else {\n            routerName = String.valueOf(network.getId());\n        }\n\n        String broadcastUriStr = accountIdStr + \".\" + String.valueOf(network.getId()) + \":\" + routerName;\n\n        implemented.setBroadcastUri(Networks.BroadcastDomainType.Mido.toUri(broadcastUriStr));\n        s_logger.debug(\"Broadcast URI set to \" + broadcastUriStr);\n\n        return implemented;\n    }","id":92329,"modified_method":"@Override\n    public Network implement(Network network, NetworkOffering offering,\n                             DeployDestination dest, ReservationContext context)\n            throws InsufficientVirtualNetworkCapcityException {\n        assert (network.getState() == Network.State.Implementing) : \"Why are we implementing \" + network;\n        s_logger.debug(\"implement called network: \" + network.toString());\n\n        long dcId = dest.getDataCenter().getId();\n\n        //get physical network id\n        long physicalNetworkId = _networkModel.findPhysicalNetworkId(dcId, offering.getTags(), offering.getTrafficType());\n\n        NetworkVO implemented = new NetworkVO(network.getTrafficType(), network.getMode(), network.getBroadcastDomainType(), network.getNetworkOfferingId(), Network.State.Allocated,\n                network.getDataCenterId(), physicalNetworkId);\n\n        if (network.getGateway() != null) {\n            implemented.setGateway(network.getGateway());\n        }\n\n        if (network.getCidr() != null) {\n            implemented.setCidr(network.getCidr());\n        }\n\n        AccountVO acc = _accountDao.findById(network.getAccountId());\n        String accountUUIDStr = acc.getUuid();\n        String routerName = \"\";\n        if (network.getVpcId() != null) {\n            routerName = \"VPC\" + String.valueOf(network.getVpcId());\n        } else {\n            routerName = String.valueOf(network.getId());\n        }\n\n        String broadcastUriStr = accountUUIDStr + \".\"\n                                 + String.valueOf(network.getId())\n                                 + \":\" + routerName;\n\n        implemented.setBroadcastUri(Networks.BroadcastDomainType.Mido.toUri(broadcastUriStr));\n        s_logger.debug(\"Broadcast URI set to \" + broadcastUriStr);\n\n        return implemented;\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"private URI generateBroadcastUri(Network network){\n        String accountIdStr = String.valueOf(network.getAccountId());\n        String networkUUIDStr = String.valueOf(network.getId());\n        return Networks.BroadcastDomainType.Mido.toUri(accountIdStr +\n                                                       \".\" +\n                                                       networkUUIDStr +\n                                                       \":\" +\n                                                       networkUUIDStr);\n    }","id":92330,"modified_method":"private URI generateBroadcastUri(Network network){\n        AccountVO acc = _accountDao.findById(network.getAccountId());\n        String accountUUIDStr = acc.getUuid();\n        String networkUUIDStr = String.valueOf(network.getId());\n        return Networks.BroadcastDomainType.Mido.toUri(accountUUIDStr +\n                                                       \".\" +\n                                                       networkUUIDStr +\n                                                       \":\" +\n                                                       networkUUIDStr);\n    }","commit_id":"987c3427dd26f36a060571d022efb7043d0ee473","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n   * Visibility has been relaxed for tests.\n   */\n  void processQueue() {\n    NotificationQueue.Element element = queue.get();\n    while (element != null) {\n      deliver(element);\n      element = queue.get();\n    }\n  }","id":92331,"modified_method":"/**\n   * Visibility has been relaxed for tests.\n   */\n  void processQueue() {\n    NotificationQueueElement queueElement = manager.getFromQueue();\n    while (queueElement != null) {\n      deliver(queueElement.getNotification());\n      queueElement = manager.getFromQueue();\n    }\n  }","commit_id":"5f730dc9ed7a80ad2de100940e051279c2018e1d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void start() {\n    executorService = Executors.newSingleThreadScheduledExecutor();\n    executorService.scheduleWithFixedDelay(new Runnable() {\n      public void run() {\n        processQueue();\n      }\n    }, 0, period, TimeUnit.MILLISECONDS);\n    LOG.info(\"Notification service started\");\n  }","id":92332,"modified_method":"public NotificationService(DefaultNotificationManager manager, NotificationDispatcher[] dispatchers, NotificationChannel[] channels) {\n    this.manager = manager;\n    this.channels = channels;\n    this.dispatchers = dispatchers;\n  }","commit_id":"5f730dc9ed7a80ad2de100940e051279c2018e1d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() {\n    queue = mock(NotificationQueue.class);\n    service = spy(new NotificationService(queue));\n    service.setPeriod(10);\n  }","id":92333,"modified_method":"@Before\n  public void setUp() {\n    emailChannel = mock(NotificationChannel.class);\n    when(emailChannel.getKey()).thenReturn(\"email\");\n\n    gtalkChannel = mock(NotificationChannel.class);\n    when(gtalkChannel.getKey()).thenReturn(\"gtalk\");\n\n    commentOnReviewAssignedToMe = mock(NotificationDispatcher.class);\n    when(commentOnReviewAssignedToMe.getKey()).thenReturn(\"comment on review assigned to me\");\n    doAnswer(new Answer<Object>() {\n      public Object answer(InvocationOnMock invocation) throws Throwable {\n        ((NotificationDispatcher.Context) invocation.getArguments()[1]).addUser(assignee);\n        return null;\n      }\n    }).when(commentOnReviewAssignedToMe).dispatch(any(Notification.class), any(NotificationDispatcher.Context.class));\n\n    commentOnReviewCreatedByMe = mock(NotificationDispatcher.class);\n    when(commentOnReviewCreatedByMe.getKey()).thenReturn(\"comment on review created by me\");\n    doAnswer(new Answer<Object>() {\n      public Object answer(InvocationOnMock invocation) throws Throwable {\n        ((NotificationDispatcher.Context) invocation.getArguments()[1]).addUser(creator);\n        return null;\n      }\n    }).when(commentOnReviewCreatedByMe).dispatch(any(Notification.class), any(NotificationDispatcher.Context.class));\n\n    NotificationDispatcher[] dispatchers = new NotificationDispatcher[] { commentOnReviewAssignedToMe, commentOnReviewCreatedByMe };\n    NotificationChannel[] channels = new NotificationChannel[] { emailChannel, gtalkChannel };\n    manager = mock(DefaultNotificationManager.class);\n    service = spy(new NotificationService(manager, dispatchers, channels));\n    doReturn(false).when(service).isEnabled(any(String.class), any(NotificationChannel.class), any(NotificationDispatcher.class));\n  }","commit_id":"5f730dc9ed7a80ad2de100940e051279c2018e1d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldPeriodicallyProcessQueue() throws Exception {\n    service.start();\n\n    NotificationQueue.Element element = mock(NotificationQueue.Element.class);\n    when(queue.get()).thenReturn(element);\n    Thread.sleep(50);\n\n    verify(service, atLeastOnce()).deliver(element);\n\n    service.stop();\n  }","id":92334,"modified_method":"@Test\n  public void shouldPeriodicallyProcessQueue() throws Exception {\n    NotificationQueueElement queueElement = mock(NotificationQueueElement.class);\n    Notification notification = mock(Notification.class);\n    when(queueElement.getNotification()).thenReturn(notification);\n    when(manager.getFromQueue()).thenReturn(queueElement).thenReturn(null);\n    doNothing().when(service).deliver(any(Notification.class));\n\n    service.setPeriod(10);\n    service.start();\n    Thread.sleep(50);\n    service.stop();\n\n    verify(service).deliver(notification);\n  }","commit_id":"5f730dc9ed7a80ad2de100940e051279c2018e1d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * plugin extensions + all the components that depend on plugin extensions\n   */\n  private void startServiceComponents() {\n    servicesContainer = coreContainer.makeChildContainer();\n\n    ServerPluginRepository pluginRepository = servicesContainer.getComponent(ServerPluginRepository.class);\n    pluginRepository.registerExtensions(servicesContainer);\n\n    servicesContainer.as(Characteristics.CACHE).addComponent(DefaultModelFinder.class); // depends on plugins\n    servicesContainer.as(Characteristics.CACHE).addComponent(DefaultModelManager.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(Plugins.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(ChartFactory.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(Languages.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(Views.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(CodeColorizers.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(RulesDao.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(MeasuresDao.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(org.sonar.api.database.daos.MeasuresDao.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(ProfilesDao.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(DaoFacade.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(DefaultRulesManager.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(ProfilesManager.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(Backup.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(AuthenticatorFactory.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(ServerLifecycleNotifier.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(AnnotationProfileParser.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(XMLProfileParser.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(XMLProfileSerializer.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(AnnotationRuleParser.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(XMLRuleParser.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(DefaultRuleFinder.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(DefaultMetricFinder.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(ProfilesConsole.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(RulesConsole.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(JRubyI18n.class);\n\n    // Notifications\n    servicesContainer.as(Characteristics.CACHE).addComponent(NotificationQueue.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(NotificationService.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(NotificationManager.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(ReviewsNotificationManager.class);\n    // FIXME next five lines here just for tests:\n    servicesContainer.as(Characteristics.CACHE).addComponent(EmailConfiguration.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(EmailNotificationChannel.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(CommentOnReviewEmailTemplate.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(CommentOnReviewAssignedToMe.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(CommentOnReviewCreatedByMe.class);\n\n    servicesContainer.start();\n  }","id":92335,"modified_method":"/**\n   * plugin extensions + all the components that depend on plugin extensions\n   */\n  private void startServiceComponents() {\n    servicesContainer = coreContainer.makeChildContainer();\n\n    ServerPluginRepository pluginRepository = servicesContainer.getComponent(ServerPluginRepository.class);\n    pluginRepository.registerExtensions(servicesContainer);\n\n    servicesContainer.as(Characteristics.CACHE).addComponent(DefaultModelFinder.class); // depends on plugins\n    servicesContainer.as(Characteristics.CACHE).addComponent(DefaultModelManager.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(Plugins.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(ChartFactory.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(Languages.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(Views.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(CodeColorizers.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(RulesDao.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(MeasuresDao.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(org.sonar.api.database.daos.MeasuresDao.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(ProfilesDao.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(DaoFacade.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(DefaultRulesManager.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(ProfilesManager.class);\n    servicesContainer.as(Characteristics.NO_CACHE).addComponent(Backup.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(AuthenticatorFactory.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(ServerLifecycleNotifier.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(AnnotationProfileParser.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(XMLProfileParser.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(XMLProfileSerializer.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(AnnotationRuleParser.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(XMLRuleParser.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(DefaultRuleFinder.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(DefaultMetricFinder.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(ProfilesConsole.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(RulesConsole.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(JRubyI18n.class);\n\n    // Notifications\n    servicesContainer.as(Characteristics.CACHE).addComponent(NotificationService.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(DefaultNotificationManager.class);\n    servicesContainer.as(Characteristics.CACHE).addComponent(ReviewsNotificationManager.class);\n\n    servicesContainer.start();\n  }","commit_id":"5f730dc9ed7a80ad2de100940e051279c2018e1d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void notifyCommentAdded(Long reviewId, Integer userId, String comment) {\n    Review review = getReviewById(reviewId);\n    User author = getUserById(userId);\n    CommentOnReviewNotification notification = new CommentOnReviewNotification(review, author, comment);\n    notificationManager.scheduleForSending(notification);\n  }","id":92336,"modified_method":"public void notifyCommentAdded(Long reviewId, Integer userId, String comment) {\n    Review review = getReviewById(reviewId);\n    User author = getUserById(userId);\n\n    Notification notification = new Notification(\"review\");\n    notification // FIXME include info about review\n        .setFieldValue(\"author\", author.getLogin())\n        .setFieldValue(\"comment\", comment);\n\n    notificationManager.scheduleForSending(notification);\n  }","commit_id":"5f730dc9ed7a80ad2de100940e051279c2018e1d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void addErrorMessage(GroovyRuntimeException exception, List collector) {\n    ASTNode astNode = exception.getNode();\n    ModuleNode module = exception.getModule();\n    if (module == null) {\n      module = findModule(astNode);\n    }\n    collector.add(new CompilerMessage(GroovyCompilerMessageCategories.ERROR, exception.getMessageWithoutLocationText(),\n        module == null ? \"<no module>\" : module.getDescription(),\n        astNode.getLineNumber(), astNode.getColumnNumber()));\n  }","id":92337,"modified_method":"private static void addErrorMessage(GroovyRuntimeException exception, List collector) {\n    ASTNode astNode = exception.getNode();\n    ModuleNode module = exception.getModule();\n    if (module == null) {\n      module = findModule(astNode);\n    }\n    String moduleName = module == null ? \"<no module>\" : module.getDescription();\n\n    int lineNumber = astNode == null ? -1 : astNode.getLineNumber();\n    int columnNumber = astNode == null ? -1 : astNode.getColumnNumber();\n\n    String message = exception.getMessageWithoutLocationText();\n    if (message == null) {\n      StringWriter stringWriter = new StringWriter();\n      //noinspection IOResourceOpenedButNotSafelyClosed\n      PrintWriter writer = new PrintWriter(stringWriter);\n      exception.printStackTrace(writer);\n      message = stringWriter.getBuffer().toString();\n    }\n\n    collector.add(new CompilerMessage(GroovyCompilerMessageCategories.ERROR, message, moduleName, lineNumber, columnNumber));\n  }","commit_id":"165109334d24b3c3d2fbc4efd0b1016627493080","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Settings readSettings( File settingsFile, SettingsBuildingRequest request, List<SettingsProblem> problems )\n    {\n        if ( settingsFile == null || !settingsFile.exists() )\n        {\n            return new Settings();\n        }\n\n        Settings settings;\n\n        try\n        {\n            Map<String, ?> options = Collections.singletonMap( SettingsReader.IS_STRICT, Boolean.TRUE );\n\n            try\n            {\n                settings = settingsReader.read( settingsFile, options );\n            }\n            catch ( SettingsParseException e )\n            {\n                options = Collections.singletonMap( SettingsReader.IS_STRICT, Boolean.FALSE );\n\n                settings = settingsReader.read( settingsFile, options );\n\n                problems.add( new DefaultSettingsProblem( e.getMessage(), SettingsProblem.Severity.WARNING,\n                                                          settingsFile.getAbsolutePath(), e.getLineNumber(),\n                                                          e.getColumnNumber(), e ) );\n            }\n        }\n        catch ( SettingsParseException e )\n        {\n            problems.add( new DefaultSettingsProblem( \"Non-parseable settings \" + settingsFile + \": \" + e.getMessage(),\n                                                      SettingsProblem.Severity.FATAL, settingsFile.getAbsolutePath(),\n                                                      e.getLineNumber(), e.getColumnNumber(), e ) );\n            return new Settings();\n        }\n        catch ( IOException e )\n        {\n            problems.add( new DefaultSettingsProblem( \"Non-readable settings \" + settingsFile + \": \" + e.getMessage(),\n                                                      SettingsProblem.Severity.FATAL, settingsFile.getAbsolutePath(),\n                                                      -1, -1, e ) );\n            return new Settings();\n        }\n\n        SettingsValidationResult result = settingsValidator.validate( settings );\n\n        for ( String error : result.getMessages() )\n        {\n            problems.add( new DefaultSettingsProblem( error, SettingsProblem.Severity.ERROR,\n                                                      settingsFile.getAbsolutePath(), -1, -1, null ) );\n        }\n\n        return settings;\n    }","id":92338,"modified_method":"private Settings readSettings( File settingsFile, SettingsBuildingRequest request,\n                                   DefaultSettingsProblemCollector problems )\n    {\n        if ( settingsFile == null || !settingsFile.exists() )\n        {\n            return new Settings();\n        }\n\n        problems.setSource( settingsFile.getAbsolutePath() );\n\n        Settings settings;\n\n        try\n        {\n            Map<String, ?> options = Collections.singletonMap( SettingsReader.IS_STRICT, Boolean.TRUE );\n\n            try\n            {\n                settings = settingsReader.read( settingsFile, options );\n            }\n            catch ( SettingsParseException e )\n            {\n                options = Collections.singletonMap( SettingsReader.IS_STRICT, Boolean.FALSE );\n\n                settings = settingsReader.read( settingsFile, options );\n\n                problems.add( SettingsProblem.Severity.WARNING, e.getMessage(), e.getLineNumber(), e.getColumnNumber(),\n                              e );\n            }\n        }\n        catch ( SettingsParseException e )\n        {\n            problems.add( SettingsProblem.Severity.FATAL, \"Non-parseable settings \" + settingsFile + \": \"\n                + e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e );\n            return new Settings();\n        }\n        catch ( IOException e )\n        {\n            problems.add( SettingsProblem.Severity.FATAL, \"Non-readable settings \" + settingsFile + \": \"\n                + e.getMessage(), -1, -1, e );\n            return new Settings();\n        }\n\n        settingsValidator.validate( settings, problems );\n\n        return settings;\n    }","commit_id":"2e814346e62c9a7e8ea117638243e4130668d563","url":"https://github.com/apache/maven"},{"original_method":"private Settings interpolate( Settings settings, SettingsBuildingRequest request, List<SettingsProblem> problems )\n    {\n        StringWriter writer = new StringWriter( 1024 * 4 );\n\n        try\n        {\n            settingsWriter.write( writer, null, settings );\n        }\n        catch ( IOException e )\n        {\n            throw new IllegalStateException( \"Failed to serialize settings to memory\", e );\n        }\n\n        String serializedSettings = writer.toString();\n\n        RegexBasedInterpolator interpolator = new RegexBasedInterpolator();\n\n        interpolator.addValueSource( new PropertiesBasedValueSource( request.getUserProperties() ) );\n\n        interpolator.addValueSource( new PropertiesBasedValueSource( request.getSystemProperties() ) );\n\n        try\n        {\n            interpolator.addValueSource( new EnvarBasedValueSource() );\n        }\n        catch ( IOException e )\n        {\n            problems.add( new DefaultSettingsProblem( \"Failed to use environment variables for interpolation: \"\n                + e.getMessage(), SettingsProblem.Severity.WARNING, \"\", -1, -1, e ) );\n        }\n\n        try\n        {\n            serializedSettings = interpolator.interpolate( serializedSettings, \"settings\" );\n        }\n        catch ( InterpolationException e )\n        {\n            problems.add( new DefaultSettingsProblem( \"Failed to interpolate settings: \" + e.getMessage(),\n                                                      SettingsProblem.Severity.ERROR, \"\", -1, -1, e ) );\n\n            return settings;\n        }\n\n        Settings result;\n        try\n        {\n            Map<String, ?> options = Collections.singletonMap( SettingsReader.IS_STRICT, Boolean.FALSE );\n            result = settingsReader.read( new StringReader( serializedSettings ), options );\n        }\n        catch ( IOException e )\n        {\n            problems.add( new DefaultSettingsProblem( \"Failed to interpolate settings: \" + e.getMessage(),\n                                                      SettingsProblem.Severity.ERROR, \"\", -1, -1, e ) );\n            return settings;\n        }\n\n        return result;\n    }","id":92339,"modified_method":"private Settings interpolate( Settings settings, SettingsBuildingRequest request, SettingsProblemCollector problems )\n    {\n        StringWriter writer = new StringWriter( 1024 * 4 );\n\n        try\n        {\n            settingsWriter.write( writer, null, settings );\n        }\n        catch ( IOException e )\n        {\n            throw new IllegalStateException( \"Failed to serialize settings to memory\", e );\n        }\n\n        String serializedSettings = writer.toString();\n\n        RegexBasedInterpolator interpolator = new RegexBasedInterpolator();\n\n        interpolator.addValueSource( new PropertiesBasedValueSource( request.getUserProperties() ) );\n\n        interpolator.addValueSource( new PropertiesBasedValueSource( request.getSystemProperties() ) );\n\n        try\n        {\n            interpolator.addValueSource( new EnvarBasedValueSource() );\n        }\n        catch ( IOException e )\n        {\n            problems.add( SettingsProblem.Severity.WARNING, \"Failed to use environment variables for interpolation: \"\n                + e.getMessage(), -1, -1, e );\n        }\n\n        try\n        {\n            serializedSettings = interpolator.interpolate( serializedSettings, \"settings\" );\n        }\n        catch ( InterpolationException e )\n        {\n            problems.add( SettingsProblem.Severity.ERROR, \"Failed to interpolate settings: \" + e.getMessage(), -1, -1,\n                          e );\n\n            return settings;\n        }\n\n        Settings result;\n        try\n        {\n            Map<String, ?> options = Collections.singletonMap( SettingsReader.IS_STRICT, Boolean.FALSE );\n            result = settingsReader.read( new StringReader( serializedSettings ), options );\n        }\n        catch ( IOException e )\n        {\n            problems.add( SettingsProblem.Severity.ERROR, \"Failed to interpolate settings: \" + e.getMessage(), -1, -1,\n                          e );\n            return settings;\n        }\n\n        return result;\n    }","commit_id":"2e814346e62c9a7e8ea117638243e4130668d563","url":"https://github.com/apache/maven"},{"original_method":"public SettingsBuildingResult build( SettingsBuildingRequest request )\n        throws SettingsBuildingException\n    {\n        List<SettingsProblem> problems = new ArrayList<SettingsProblem>();\n\n        Settings globalSettings = readSettings( request.getGlobalSettingsFile(), request, problems );\n\n        Settings userSettings = readSettings( request.getUserSettingsFile(), request, problems );\n\n        SettingsUtils.merge( userSettings, globalSettings, TrackableBase.GLOBAL_LEVEL );\n\n        userSettings = interpolate( userSettings, request, problems );\n\n        // for the special case of a drive-relative Windows path, make sure it's absolute to save plugins from trouble\n        String localRepository = userSettings.getLocalRepository();\n        if ( localRepository != null && localRepository.length() > 0 )\n        {\n            File file = new File( localRepository );\n            if ( !file.isAbsolute() && file.getPath().startsWith( File.separator ) )\n            {\n                userSettings.setLocalRepository( file.getAbsolutePath() );\n            }\n        }\n\n        if ( hasErrors( problems ) )\n        {\n            throw new SettingsBuildingException( problems );\n        }\n\n        return new DefaultSettingsBuildingResult( userSettings, problems );\n    }","id":92340,"modified_method":"public SettingsBuildingResult build( SettingsBuildingRequest request )\n        throws SettingsBuildingException\n    {\n        DefaultSettingsProblemCollector problems = new DefaultSettingsProblemCollector( null );\n\n        Settings globalSettings = readSettings( request.getGlobalSettingsFile(), request, problems );\n\n        Settings userSettings = readSettings( request.getUserSettingsFile(), request, problems );\n\n        SettingsUtils.merge( userSettings, globalSettings, TrackableBase.GLOBAL_LEVEL );\n\n        problems.setSource( \"\" );\n\n        userSettings = interpolate( userSettings, request, problems );\n\n        // for the special case of a drive-relative Windows path, make sure it's absolute to save plugins from trouble\n        String localRepository = userSettings.getLocalRepository();\n        if ( localRepository != null && localRepository.length() > 0 )\n        {\n            File file = new File( localRepository );\n            if ( !file.isAbsolute() && file.getPath().startsWith( File.separator ) )\n            {\n                userSettings.setLocalRepository( file.getAbsolutePath() );\n            }\n        }\n\n        if ( hasErrors( problems.getProblems() ) )\n        {\n            throw new SettingsBuildingException( problems.getProblems() );\n        }\n\n        return new DefaultSettingsBuildingResult( userSettings, problems.getProblems() );\n    }","commit_id":"2e814346e62c9a7e8ea117638243e4130668d563","url":"https://github.com/apache/maven"},{"original_method":"private void validateRepositories( SettingsValidationResult result, List<Repository> repositories, String prefix )\n    {\n        for ( Repository repository : repositories )\n        {\n            validateStringNotEmpty( prefix + \".id\", result, repository.getId() );\n\n            validateStringNotEmpty( prefix + \".url\", result, repository.getUrl() );\n        }\n    }","id":92341,"modified_method":"private void validateRepositories( SettingsProblemCollector problems, List<Repository> repositories, String prefix )\n    {\n        for ( Repository repository : repositories )\n        {\n            validateStringNotEmpty( problems, prefix + \".id\", repository.getId() );\n\n            validateStringNotEmpty( problems, prefix + \".url\", repository.getUrl() );\n        }\n    }","commit_id":"2e814346e62c9a7e8ea117638243e4130668d563","url":"https://github.com/apache/maven"},{"original_method":"private boolean validateStringNotEmpty( String fieldName, SettingsValidationResult result, String string )\n    {\n        return validateStringNotEmpty( fieldName, result, string, null );\n    }","id":92342,"modified_method":"/**\n     * Asserts:\n     * <p/>\n     * <ul>\n     * <li><code>string.length != null<\/code>\n     * <li><code>string.length > 0<\/code>\n     * <\/ul>\n     */\n    private boolean validateStringNotEmpty( SettingsProblemCollector problems, String fieldName, String string, String sourceHint )\n    {\n        if ( !validateNotNull( problems, fieldName, string, sourceHint ) )\n        {\n            return false;\n        }\n\n        if ( string.length() > 0 )\n        {\n            return true;\n        }\n\n        String msg;\n        if ( sourceHint != null )\n        {\n            msg = \"'\" + fieldName + \"' is missing for \" + sourceHint;\n        }\n        else\n        {\n            msg = \"'\" + fieldName + \"' is missing.\";\n        }\n        addError( problems, msg );\n\n        return false;\n    }","commit_id":"2e814346e62c9a7e8ea117638243e4130668d563","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Asserts:\n     * <p/>\n     * <ul>\n     * <li><code>string != null<\/code>\n     * <\/ul>\n     */\n    private boolean validateNotNull( String fieldName, SettingsValidationResult result, Object object, String sourceHint )\n    {\n        if ( object != null )\n        {\n            return true;\n        }\n\n        if ( sourceHint != null )\n        {\n            result.addMessage( \"'\" + fieldName + \"' is missing for \" + sourceHint );\n        }\n        else\n        {\n            result.addMessage( \"'\" + fieldName + \"' is missing.\" );\n        }\n\n        return false;\n    }","id":92343,"modified_method":"/**\n     * Asserts:\n     * <p/>\n     * <ul>\n     * <li><code>string != null<\/code>\n     * <\/ul>\n     */\n    private boolean validateNotNull( SettingsProblemCollector problems, String fieldName, Object object,\n                                     String sourceHint )\n    {\n        if ( object != null )\n        {\n            return true;\n        }\n\n        String msg;\n        if ( sourceHint != null )\n        {\n            msg = \"'\" + fieldName + \"' is missing for \" + sourceHint;\n        }\n        else\n        {\n            msg = \"'\" + fieldName + \"' is missing.\";\n        }\n        addError( problems, msg );\n\n        return false;\n    }","commit_id":"2e814346e62c9a7e8ea117638243e4130668d563","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Asserts:\n     * <p/>\n     * <ul>\n     * <li><code>string.length != null<\/code>\n     * <li><code>string.length > 0<\/code>\n     * <\/ul>\n     */\n    private boolean validateStringNotEmpty( String fieldName, SettingsValidationResult result, String string, String sourceHint )\n    {\n        if ( !validateNotNull( fieldName, result, string, sourceHint ) )\n        {\n            return false;\n        }\n\n        if ( string.length() > 0 )\n        {\n            return true;\n        }\n\n        if ( sourceHint != null )\n        {\n            result.addMessage( \"'\" + fieldName + \"' is missing for \" + sourceHint );\n        }\n        else\n        {\n            result.addMessage( \"'\" + fieldName + \"' is missing.\" );\n        }\n\n        return false;\n    }","id":92344,"modified_method":"private boolean validateStringNotEmpty( SettingsProblemCollector problems, String fieldName, String string )\n    {\n        return validateStringNotEmpty( problems, fieldName, string, null );\n    }","commit_id":"2e814346e62c9a7e8ea117638243e4130668d563","url":"https://github.com/apache/maven"},{"original_method":"public SettingsValidationResult validate( Settings model )\n    {\n        SettingsValidationResult result = new SettingsValidationResult();\n\n        List<Profile> profiles = model.getProfiles();\n        if ( profiles != null )\n        {\n            for (Profile prof : profiles )\n            {\n                validateRepositories( result, prof.getRepositories(), \"repositories.repository\" );\n                validateRepositories( result, prof.getPluginRepositories(), \"pluginRepositories.pluginRepository\" );\n            }\n        }\n\n        return result;\n    }","id":92345,"modified_method":"public void validate( Settings settings, SettingsProblemCollector problems )\n    {\n        List<Profile> profiles = settings.getProfiles();\n\n        if ( profiles != null )\n        {\n            for ( Profile prof : profiles )\n            {\n                validateRepositories( problems, prof.getRepositories(), \"repositories.repository\" );\n                validateRepositories( problems, prof.getPluginRepositories(), \"pluginRepositories.pluginRepository\" );\n            }\n        }\n    }","commit_id":"2e814346e62c9a7e8ea117638243e4130668d563","url":"https://github.com/apache/maven"},{"original_method":"public void testValidate()\n    {\n        Settings model = new Settings();\n        Profile prof = new Profile();\n        prof.setId( \"xxx\" );\n        model.addProfile( prof );\n        DefaultSettingsValidator instance = new DefaultSettingsValidator();\n        SettingsValidationResult result = instance.validate( model );\n        assertEquals( 0, result.getMessageCount() );\n\n        Repository repo = new Repository();\n        prof.addRepository( repo );\n        result = instance.validate( model );\n        assertEquals( 2, result.getMessageCount() );\n\n        repo.setUrl( \"http://xxx.xxx.com\" );\n        result = instance.validate( model );\n        assertEquals( 1, result.getMessageCount() );\n\n        repo.setId( \"xxx\" );\n        result = instance.validate( model );\n        assertEquals( 0, result.getMessageCount() );\n\n    }","id":92346,"modified_method":"public void testValidate()\n    {\n        Settings model = new Settings();\n        Profile prof = new Profile();\n        prof.setId( \"xxx\" );\n        model.addProfile( prof );\n        DefaultSettingsValidator instance = new DefaultSettingsValidator();\n        SimpleProblemCollector problems = new SimpleProblemCollector();\n        instance.validate( model, problems );\n        assertEquals( 0, problems.messages.size() );\n\n        Repository repo = new Repository();\n        prof.addRepository( repo );\n        problems = new SimpleProblemCollector();\n        instance.validate( model, problems );\n        assertEquals( 2, problems.messages.size() );\n\n        repo.setUrl( \"http://xxx.xxx.com\" );\n        problems = new SimpleProblemCollector();\n        instance.validate( model, problems );\n        assertEquals( 1, problems.messages.size() );\n\n        repo.setId( \"xxx\" );\n        problems = new SimpleProblemCollector();\n        instance.validate( model, problems );\n        assertEquals( 0, problems.messages.size() );\n\n    }","commit_id":"2e814346e62c9a7e8ea117638243e4130668d563","url":"https://github.com/apache/maven"},{"original_method":"/**\r\n     * This function is used to do the anti compaction process , it spits out the file which has keys that belong to a given range\r\n     * If the target is not specified it spits out the file as a compacted file with the unecessary ranges wiped out.\r\n     * @param files\r\n     * @param ranges\r\n     * @param target\r\n     * @param fileList\r\n     * @return\r\n     * @throws IOException\r\n     */\r\n    boolean doFileAntiCompaction(List<String> files, List<Range> ranges, EndPoint target, List<String> fileList, List<BloomFilter> compactedBloomFilters)\r\n    {\r\n    \tboolean result = false;\r\n        long startTime = System.currentTimeMillis();\r\n        long totalBytesRead = 0;\r\n        long totalBytesWritten = 0;\r\n        long totalkeysRead = 0;\r\n        long totalkeysWritten = 0;\r\n        String rangeFileLocation = null;\r\n        String mergedFileName = null;\r\n        try\r\n        {\r\n\t        // Calculate the expected compacted filesize\r\n\t    \tlong expectedRangeFileSize = getExpectedCompactedFileSize(files);\r\n\t    \t/* in the worst case a node will be giving out alf of its data so we take a chance */\r\n\t    \texpectedRangeFileSize = expectedRangeFileSize / 2;\r\n\t        rangeFileLocation = DatabaseDescriptor.getCompactionFileLocation(expectedRangeFileSize);\r\n//\t        boolean isLoop = isLoopAround( ranges );\r\n//\t        Range maxRange = getMaxRange( ranges );\r\n\t        // If the compaction file path is null that means we have no space left for this compaction.\r\n\t        if( rangeFileLocation == null )\r\n\t        {\r\n\t            logger_.warn(\"Total bytes to be written for range compaction  ...\"\r\n\t                    + expectedRangeFileSize + \"   is greater than the safe limit of the disk space available.\");\r\n\t            return result;\r\n\t        }\r\n\t        PriorityQueue<FileStruct> pq = initializePriorityQueue(files, ranges, ColumnFamilyStore.bufSize_);\r\n\t        if (pq.size() > 0)\r\n\t        {\r\n\t            mergedFileName = getTempFileName();\r\n\t            SSTable ssTableRange = null ;\r\n\t            String lastkey = null;\r\n\t            List<FileStruct> lfs = new ArrayList<FileStruct>();\r\n\t            DataOutputBuffer bufOut = new DataOutputBuffer();\r\n\t            int expectedBloomFilterSize = SSTable.getApproximateKeyCount(files);\r\n\t            expectedBloomFilterSize = (expectedBloomFilterSize > 0) ? expectedBloomFilterSize : SSTable.indexInterval();\r\n\t            logger_.debug(\"Expected bloom filter size : \" + expectedBloomFilterSize);\r\n\t            /* Create the bloom filter for the compacted file. */\r\n\t            BloomFilter compactedRangeBloomFilter = new BloomFilter(expectedBloomFilterSize, 15);\r\n\t            List<ColumnFamily> columnFamilies = new ArrayList<ColumnFamily>();\r\n\r\n\t            while (pq.size() > 0 || lfs.size() > 0)\r\n\t            {\r\n\t                FileStruct fs = null;\r\n\t                if (pq.size() > 0)\r\n\t                {\r\n\t                    fs = pq.poll();\r\n\t                }\r\n\t                if (fs != null\r\n\t                        && (lastkey == null || lastkey.compareTo(fs.key_) == 0))\r\n\t                {\r\n\t                    // The keys are the same so we need to add this to the\r\n\t                    // ldfs list\r\n\t                    lastkey = fs.key_;\r\n\t                    lfs.add(fs);\r\n\t                }\r\n\t                else\r\n\t                {\r\n\t                    Collections.sort(lfs, new FileStructComparator());\r\n\t                    ColumnFamily columnFamily = null;\r\n\t                    bufOut.reset();\r\n\t                    if(lfs.size() > 1)\r\n\t                    {\r\n\t\t                    for (FileStruct filestruct : lfs)\r\n\t\t                    {\r\n\t\t                    \ttry\r\n\t\t                    \t{\r\n\t                                /* read the length although we don't need it */\r\n\t                                filestruct.bufIn_.readInt();\r\n\t                                // Skip the Index\r\n                                    IndexHelper.skipBloomFilterAndIndex(filestruct.bufIn_);\r\n\t                                // We want to add only 2 and resolve them right there in order to save on memory footprint\r\n\t                                if(columnFamilies.size() > 1)\r\n\t                                {\r\n\t    \t\t                        // Now merge the 2 column families\r\n                                        merge(columnFamilies);\r\n\t                                }\r\n\t\t\t                        // deserialize into column families\r\n\t\t\t                        columnFamilies.add(ColumnFamily.serializer().deserialize(filestruct.bufIn_));\r\n\t\t                    \t}\r\n\t\t                    \tcatch ( Exception ex)\r\n\t\t                    \t{\r\n                                    logger_.warn(LogUtil.throwableToString(ex));\r\n                                }\r\n\t\t                    }\r\n\t\t                    // Now after merging all crap append to the sstable\r\n\t\t                    columnFamily = resolveAndRemoveDeleted(columnFamilies);\r\n\t\t                    columnFamilies.clear();\r\n\t\t                    if( columnFamily != null )\r\n\t\t                    {\r\n\t\t\t                \t/* serialize the cf with column indexes */\r\n\t\t\t                    ColumnFamily.serializerWithIndexes().serialize(columnFamily, bufOut);\r\n\t\t                    }\r\n\t                    }\r\n\t                    else\r\n\t                    {\r\n\t\t                    FileStruct filestruct = lfs.get(0);\r\n\t                    \ttry\r\n\t                    \t{\r\n\t\t                        /* read the length although we don't need it */\r\n\t\t                        int size = filestruct.bufIn_.readInt();\r\n\t\t                        bufOut.write(filestruct.bufIn_, size);\r\n\t                    \t}\r\n\t                    \tcatch ( Exception ex)\r\n\t                    \t{\r\n\t                    \t\tlogger_.warn(LogUtil.throwableToString(ex));\r\n\t                            filestruct.reader_.close();\r\n\t                            continue;\r\n\t                    \t}\r\n\t                    }\r\n\t                    if ( Range.isKeyInRanges(lastkey, ranges) )\r\n\t                    {\r\n\t                        if(ssTableRange == null )\r\n\t                        {\r\n\t                        \tif( target != null )\r\n\t                        \t\trangeFileLocation = rangeFileLocation + System.getProperty(\"file.separator\") + \"bootstrap\";\r\n\t                \t        FileUtils.createDirectory(rangeFileLocation);\r\n\t                            ssTableRange = new SSTable(rangeFileLocation, mergedFileName);\r\n\t                        }\t                        \r\n\t                        try\r\n\t                        {\r\n\t\t                        ssTableRange.append(lastkey, bufOut);\r\n\t\t                        compactedRangeBloomFilter.fill(lastkey);                                \r\n\t                        }\r\n\t                        catch(Exception ex)\r\n\t                        {\r\n\t                            logger_.warn( LogUtil.throwableToString(ex) );\r\n\t                        }\r\n\t                    }\r\n\t                    totalkeysWritten++;\r\n\t                    for (FileStruct filestruct : lfs)\r\n\t                    {\r\n\t                    \ttry\r\n\t                    \t{\r\n\t                    \t\tfilestruct = getNextKey\t( filestruct );\r\n\t                    \t\tif(filestruct == null)\r\n\t                    \t\t{\r\n\t                    \t\t\tcontinue;\r\n\t                    \t\t}\r\n\t                    \t\t/* keep on looping until we find a key in the range */\r\n\t                            while ( !Range.isKeyInRanges(filestruct.key_, ranges) )\r\n\t                            {\r\n\t\t                    \t\tfilestruct = getNextKey\t( filestruct );\r\n\t\t                    \t\tif(filestruct == null)\r\n\t\t                    \t\t{\r\n\t\t                    \t\t\tbreak;\r\n\t\t                    \t\t}\r\n\t        \t                    /* check if we need to continue , if we are done with ranges empty the queue and close all file handles and exit */\r\n\t        \t                    //if( !isLoop && StorageService.token(filestruct.key).compareTo(maxRange.right()) > 0 && !filestruct.key.equals(\"\"))\r\n\t        \t                    //{\r\n\t                                    //filestruct.reader.close();\r\n\t                                    //filestruct = null;\r\n\t                                    //break;\r\n\t        \t                    //}\r\n\t                            }\r\n\t                            if ( filestruct != null)\r\n\t                            {\r\n\t                            \tpq.add(filestruct);\r\n\t                            }\r\n\t\t                        totalkeysRead++;\r\n\t                    \t}\r\n\t                    \tcatch ( Exception ex )\r\n\t                    \t{\r\n\t                    \t\t// Ignore the exception as it might be a corrupted file\r\n\t                    \t\t// in any case we have read as far as possible from it\r\n\t                    \t\t// and it will be deleted after compaction.\r\n                                logger_.warn(LogUtil.throwableToString(ex));\r\n\t                            filestruct.reader_.close();\r\n                            }\r\n\t                    }\r\n\t                    lfs.clear();\r\n\t                    lastkey = null;\r\n\t                    if (fs != null)\r\n\t                    {\r\n\t                        // Add back the fs since we processed the rest of\r\n\t                        // filestructs\r\n\t                        pq.add(fs);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            if( ssTableRange != null )\r\n\t            {\r\n                    if ( fileList == null )\r\n                        fileList = new ArrayList<String>();\r\n                    ssTableRange.closeRename(compactedRangeBloomFilter, fileList);\r\n                    if(compactedBloomFilters != null)\r\n                    \tcompactedBloomFilters.add(compactedRangeBloomFilter);\r\n\t            }\r\n\t        }\r\n        }\r\n        catch ( Exception ex)\r\n        {\r\n            logger_.warn( LogUtil.throwableToString(ex) );\r\n        }\r\n        logger_.debug(\"Total time taken for range split   ...\"\r\n                + (System.currentTimeMillis() - startTime));\r\n        logger_.debug(\"Total bytes Read for range split  ...\" + totalBytesRead);\r\n        logger_.debug(\"Total bytes written for range split  ...\"\r\n                + totalBytesWritten + \"   Total keys read ...\" + totalkeysRead);\r\n        return result;\r\n    }","id":92347,"modified_method":"/**\r\n     * This function is used to do the anti compaction process , it spits out the file which has keys that belong to a given range\r\n     * If the target is not specified it spits out the file as a compacted file with the unecessary ranges wiped out.\r\n     * @param files\r\n     * @param ranges\r\n     * @param target\r\n     * @param fileList\r\n     * @return\r\n     * @throws IOException\r\n     */\r\n    boolean doFileAntiCompaction(List<String> files, List<Range> ranges, EndPoint target, List<String> fileList, List<BloomFilter> compactedBloomFilters)\r\n    {\r\n    \tboolean result = false;\r\n        long startTime = System.currentTimeMillis();\r\n        long totalBytesRead = 0;\r\n        long totalBytesWritten = 0;\r\n        long totalkeysRead = 0;\r\n        long totalkeysWritten = 0;\r\n        String rangeFileLocation = null;\r\n        String mergedFileName = null;\r\n        try\r\n        {\r\n\t        // Calculate the expected compacted filesize\r\n\t    \tlong expectedRangeFileSize = getExpectedCompactedFileSize(files);\r\n\t    \t/* in the worst case a node will be giving out alf of its data so we take a chance */\r\n\t    \texpectedRangeFileSize = expectedRangeFileSize / 2;\r\n\t        rangeFileLocation = DatabaseDescriptor.getCompactionFileLocation(expectedRangeFileSize);\r\n//\t        boolean isLoop = isLoopAround( ranges );\r\n//\t        Range maxRange = getMaxRange( ranges );\r\n\t        // If the compaction file path is null that means we have no space left for this compaction.\r\n\t        if( rangeFileLocation == null )\r\n\t        {\r\n\t            logger_.warn(\"Total bytes to be written for range compaction  ...\"\r\n\t                    + expectedRangeFileSize + \"   is greater than the safe limit of the disk space available.\");\r\n\t            return result;\r\n\t        }\r\n\t        PriorityQueue<FileStruct> pq = initializePriorityQueue(files, ranges, ColumnFamilyStore.bufSize_);\r\n\t        if (pq.size() > 0)\r\n\t        {\r\n\t            mergedFileName = getTempFileName();\r\n\t            SSTable ssTableRange = null ;\r\n\t            String lastkey = null;\r\n\t            List<FileStruct> lfs = new ArrayList<FileStruct>();\r\n\t            DataOutputBuffer bufOut = new DataOutputBuffer();\r\n\t            int expectedBloomFilterSize = SSTable.getApproximateKeyCount(files);\r\n\t            expectedBloomFilterSize = (expectedBloomFilterSize > 0) ? expectedBloomFilterSize : SSTable.indexInterval();\r\n\t            logger_.debug(\"Expected bloom filter size : \" + expectedBloomFilterSize);\r\n\t            /* Create the bloom filter for the compacted file. */\r\n\t            BloomFilter compactedRangeBloomFilter = new BloomFilter(expectedBloomFilterSize, 15);\r\n\t            List<ColumnFamily> columnFamilies = new ArrayList<ColumnFamily>();\r\n\r\n\t            while (pq.size() > 0 || lfs.size() > 0)\r\n\t            {\r\n\t                FileStruct fs = null;\r\n\t                if (pq.size() > 0)\r\n\t                {\r\n\t                    fs = pq.poll();\r\n\t                }\r\n\t                if (fs != null\r\n\t                        && (lastkey == null || lastkey.compareTo(fs.getKey()) == 0))\r\n\t                {\r\n\t                    // The keys are the same so we need to add this to the\r\n\t                    // ldfs list\r\n\t                    lastkey = fs.getKey();\r\n\t                    lfs.add(fs);\r\n\t                }\r\n\t                else\r\n\t                {\r\n\t                    Collections.sort(lfs, new FileStructComparator());\r\n\t                    ColumnFamily columnFamily = null;\r\n\t                    bufOut.reset();\r\n\t                    if(lfs.size() > 1)\r\n\t                    {\r\n\t\t                    for (FileStruct filestruct : lfs)\r\n\t\t                    {\r\n\t\t                    \ttry\r\n\t\t                    \t{\r\n\t                                /* read the length although we don't need it */\r\n\t                                filestruct.getBufIn().readInt();\r\n\t                                // Skip the Index\r\n                                    IndexHelper.skipBloomFilterAndIndex(filestruct.getBufIn());\r\n\t                                // We want to add only 2 and resolve them right there in order to save on memory footprint\r\n\t                                if(columnFamilies.size() > 1)\r\n\t                                {\r\n\t    \t\t                        // Now merge the 2 column families\r\n                                        merge(columnFamilies);\r\n\t                                }\r\n\t\t\t                        // deserialize into column families\r\n\t\t\t                        columnFamilies.add(ColumnFamily.serializer().deserialize(filestruct.getBufIn()));\r\n\t\t                    \t}\r\n\t\t                    \tcatch ( Exception ex)\r\n\t\t                    \t{\r\n                                    logger_.warn(LogUtil.throwableToString(ex));\r\n                                }\r\n\t\t                    }\r\n\t\t                    // Now after merging all crap append to the sstable\r\n\t\t                    columnFamily = resolveAndRemoveDeleted(columnFamilies);\r\n\t\t                    columnFamilies.clear();\r\n\t\t                    if( columnFamily != null )\r\n\t\t                    {\r\n\t\t\t                \t/* serialize the cf with column indexes */\r\n\t\t\t                    ColumnFamily.serializerWithIndexes().serialize(columnFamily, bufOut);\r\n\t\t                    }\r\n\t                    }\r\n\t                    else\r\n\t                    {\r\n\t\t                    FileStruct filestruct = lfs.get(0);\r\n\t                    \ttry\r\n\t                    \t{\r\n\t\t                        /* read the length although we don't need it */\r\n\t\t                        int size = filestruct.getBufIn().readInt();\r\n\t\t                        bufOut.write(filestruct.getBufIn(), size);\r\n\t                    \t}\r\n\t                    \tcatch ( Exception ex)\r\n\t                    \t{\r\n\t                    \t\tlogger_.warn(LogUtil.throwableToString(ex));\r\n\t                            filestruct.close();\r\n\t                            continue;\r\n\t                    \t}\r\n\t                    }\r\n\t                    if ( Range.isKeyInRanges(lastkey, ranges) )\r\n\t                    {\r\n\t                        if(ssTableRange == null )\r\n\t                        {\r\n\t                        \tif( target != null )\r\n\t                        \t\trangeFileLocation = rangeFileLocation + System.getProperty(\"file.separator\") + \"bootstrap\";\r\n\t                \t        FileUtils.createDirectory(rangeFileLocation);\r\n\t                            ssTableRange = new SSTable(rangeFileLocation, mergedFileName);\r\n\t                        }\t                        \r\n\t                        try\r\n\t                        {\r\n\t\t                        ssTableRange.append(lastkey, bufOut);\r\n\t\t                        compactedRangeBloomFilter.fill(lastkey);                                \r\n\t                        }\r\n\t                        catch(Exception ex)\r\n\t                        {\r\n\t                            logger_.warn( LogUtil.throwableToString(ex) );\r\n\t                        }\r\n\t                    }\r\n\t                    totalkeysWritten++;\r\n\t                    for (FileStruct filestruct : lfs)\r\n\t                    {\r\n\t                    \ttry\r\n\t                    \t{\r\n                                filestruct.getNextKey();\r\n\t                    \t\tif (filestruct.isExhausted())\r\n\t                    \t\t{\r\n\t                    \t\t\tcontinue;\r\n\t                    \t\t}\r\n\t                    \t\t/* keep on looping until we find a key in the range */\r\n\t                            while ( !Range.isKeyInRanges(filestruct.getKey(), ranges) )\r\n\t                            {\r\n                                    filestruct.getNextKey();\r\n                                    if (filestruct.isExhausted())\r\n\t\t                    \t\t{\r\n\t\t                    \t\t\tbreak;\r\n\t\t                    \t\t}\r\n\t        \t                    /* check if we need to continue , if we are done with ranges empty the queue and close all file handles and exit */\r\n\t        \t                    //if( !isLoop && StorageService.token(filestruct.key).compareTo(maxRange.right()) > 0 && !filestruct.key.equals(\"\"))\r\n\t        \t                    //{\r\n\t                                    //filestruct.reader.close();\r\n\t                                    //filestruct = null;\r\n\t                                    //break;\r\n\t        \t                    //}\r\n\t                            }\r\n\t                            if (!filestruct.isExhausted())\r\n\t                            {\r\n\t                            \tpq.add(filestruct);\r\n\t                            }\r\n\t\t                        totalkeysRead++;\r\n\t                    \t}\r\n\t                    \tcatch ( Exception ex )\r\n\t                    \t{\r\n\t                    \t\t// Ignore the exception as it might be a corrupted file\r\n\t                    \t\t// in any case we have read as far as possible from it\r\n\t                    \t\t// and it will be deleted after compaction.\r\n                                logger_.warn(LogUtil.throwableToString(ex));\r\n\t                            filestruct.close();\r\n                            }\r\n\t                    }\r\n\t                    lfs.clear();\r\n\t                    lastkey = null;\r\n\t                    if (fs != null)\r\n\t                    {\r\n\t                        // Add back the fs since we processed the rest of\r\n\t                        // filestructs\r\n\t                        pq.add(fs);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            if( ssTableRange != null )\r\n\t            {\r\n                    if ( fileList == null )\r\n                        fileList = new ArrayList<String>();\r\n                    ssTableRange.closeRename(compactedRangeBloomFilter, fileList);\r\n                    if(compactedBloomFilters != null)\r\n                    \tcompactedBloomFilters.add(compactedRangeBloomFilter);\r\n\t            }\r\n\t        }\r\n        }\r\n        catch ( Exception ex)\r\n        {\r\n            logger_.warn( LogUtil.throwableToString(ex) );\r\n        }\r\n        logger_.debug(\"Total time taken for range split   ...\"\r\n                + (System.currentTimeMillis() - startTime));\r\n        logger_.debug(\"Total bytes Read for range split  ...\" + totalBytesRead);\r\n        logger_.debug(\"Total bytes written for range split  ...\"\r\n                + totalBytesWritten + \"   Total keys read ...\" + totalkeysRead);\r\n        return result;\r\n    }","commit_id":"bf684eea956dbbbf7a35ef3deca8b4462b139136","url":"https://github.com/apache/cassandra"},{"original_method":"void  doFileCompaction(List<String> files,  int minBufferSize)\r\n    {\r\n    \tString newfile = null;\r\n        long startTime = System.currentTimeMillis();\r\n        long totalBytesRead = 0;\r\n        long totalBytesWritten = 0;\r\n        long totalkeysRead = 0;\r\n        long totalkeysWritten = 0;\r\n        try\r\n        {\r\n\t        // Calculate the expected compacted filesize\r\n\t    \tlong expectedCompactedFileSize = getExpectedCompactedFileSize(files);\r\n\t        String compactionFileLocation = DatabaseDescriptor.getCompactionFileLocation(expectedCompactedFileSize);\r\n\t        // If the compaction file path is null that means we have no space left for this compaction.\r\n\t        if( compactionFileLocation == null )\r\n\t        {\r\n        \t\tString maxFile = getMaxSizeFile( files );\r\n        \t\tfiles.remove( maxFile );\r\n        \t\tdoFileCompaction(files , minBufferSize);\r\n        \t\treturn;\r\n\t        }\r\n\t        PriorityQueue<FileStruct> pq = initializePriorityQueue(files, null, minBufferSize);\r\n\t        if (pq.size() > 0)\r\n\t        {\r\n\t            String mergedFileName = getTempFileName( files );\r\n\t            SSTable ssTable = null;\r\n\t            String lastkey = null;\r\n\t            List<FileStruct> lfs = new ArrayList<FileStruct>();\r\n\t            DataOutputBuffer bufOut = new DataOutputBuffer();\r\n\t            int expectedBloomFilterSize = SSTable.getApproximateKeyCount(files);\r\n\t            expectedBloomFilterSize = (expectedBloomFilterSize > 0) ? expectedBloomFilterSize : SSTable.indexInterval();\r\n\t            logger_.debug(\"Expected bloom filter size : \" + expectedBloomFilterSize);\r\n\t            /* Create the bloom filter for the compacted file. */\r\n\t            BloomFilter compactedBloomFilter = new BloomFilter(expectedBloomFilterSize, 15);\r\n\t            List<ColumnFamily> columnFamilies = new ArrayList<ColumnFamily>();\r\n\r\n\t            while (pq.size() > 0 || lfs.size() > 0)\r\n\t            {\r\n\t                FileStruct fs = null;\r\n\t                if (pq.size() > 0)\r\n\t                {\r\n\t                    fs = pq.poll();                        \r\n\t                }\r\n\t                if (fs != null\r\n\t                        && (lastkey == null || lastkey.compareTo(fs.key_) == 0))\r\n\t                {\r\n\t                    // The keys are the same so we need to add this to the\r\n\t                    // ldfs list\r\n\t                    lastkey = fs.key_;\r\n\t                    lfs.add(fs);\r\n\t                }\r\n\t                else\r\n\t                {\r\n\t                    Collections.sort(lfs, new FileStructComparator());\r\n\t                    ColumnFamily columnFamily = null;\r\n\t                    bufOut.reset();\r\n\t                    if(lfs.size() > 1)\r\n\t                    {\r\n\t\t                    for (FileStruct filestruct : lfs)\r\n\t\t                    {\r\n\t\t                    \ttry\r\n\t\t                    \t{\r\n\t                                /* read the length although we don't need it */\r\n\t                                filestruct.bufIn_.readInt();\r\n\t                                // Skip the Index\r\n                                    IndexHelper.skipBloomFilterAndIndex(filestruct.bufIn_);\r\n\t                                // We want to add only 2 and resolve them right there in order to save on memory footprint\r\n\t                                if(columnFamilies.size() > 1)\r\n\t                                {\r\n\t    \t\t                        merge(columnFamilies);\r\n\t                                }\r\n\t\t\t                        // deserialize into column families                                    \r\n\t\t\t                        columnFamilies.add(ColumnFamily.serializer().deserialize(filestruct.bufIn_));\r\n\t\t                    \t}\r\n\t\t                    \tcatch ( Exception ex)\r\n\t\t                    \t{\r\n                                    logger_.warn(\"error in filecompaction\", ex);\r\n                                }\r\n\t\t                    }\r\n\t\t                    // Now after merging all crap append to the sstable\r\n\t\t                    columnFamily = resolveAndRemoveDeleted(columnFamilies);\r\n\t\t                    columnFamilies.clear();\r\n\t\t                    if( columnFamily != null )\r\n\t\t                    {\r\n\t\t\t                \t/* serialize the cf with column indexes */\r\n\t\t\t                    ColumnFamily.serializerWithIndexes().serialize(columnFamily, bufOut);\r\n\t\t                    }\r\n\t                    }\r\n\t                    else\r\n\t                    {\r\n\t\t                    FileStruct filestruct = lfs.get(0);\r\n\t                    \ttry\r\n\t                    \t{\r\n\t\t                        /* read the length although we don't need it */\r\n\t\t                        int size = filestruct.bufIn_.readInt();\r\n\t\t                        bufOut.write(filestruct.bufIn_, size);\r\n\t                    \t}\r\n\t                    \tcatch ( Exception ex)\r\n\t                    \t{\r\n\t                    \t\tex.printStackTrace();\r\n\t                            filestruct.reader_.close();\r\n\t                            continue;\r\n\t                    \t}\r\n\t                    }\r\n\t                    \t         \r\n\t                    if ( ssTable == null )\r\n\t                    {\r\n\t                    \tssTable = new SSTable(compactionFileLocation, mergedFileName);\t                    \t\r\n\t                    }\r\n                        ssTable.append(lastkey, bufOut);\r\n\r\n                        /* Fill the bloom filter with the key */\r\n\t                    doFill(compactedBloomFilter, lastkey);                        \r\n\t                    totalkeysWritten++;\r\n\t                    for (FileStruct filestruct : lfs)\r\n\t                    {\r\n\t                    \ttry\r\n\t                    \t{\r\n\t                    \t\tfilestruct = getNextKey(filestruct);\r\n\t                    \t\tif(filestruct == null)\r\n\t                    \t\t{\r\n\t                    \t\t\tcontinue;\r\n\t                    \t\t}\r\n\t                    \t\tpq.add(filestruct);\r\n\t\t                        totalkeysRead++;\r\n\t                    \t}\r\n\t                    \tcatch ( Throwable ex )\r\n\t                    \t{\r\n\t                    \t\t// Ignore the exception as it might be a corrupted file\r\n\t                    \t\t// in any case we have read as far as possible from it\r\n\t                    \t\t// and it will be deleted after compaction.\r\n\t                            filestruct.reader_.close();\r\n                            }\r\n\t                    }\r\n\t                    lfs.clear();\r\n\t                    lastkey = null;\r\n\t                    if (fs != null)\r\n\t                    {\r\n\t                        /* Add back the fs since we processed the rest of filestructs */\r\n\t                        pq.add(fs);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            if ( ssTable != null )\r\n\t            {\r\n\t                ssTable.closeRename(compactedBloomFilter);\r\n\t                newfile = ssTable.getDataFileLocation();\r\n\t            }\r\n\t            lock_.writeLock().lock();\r\n\t            try\r\n\t            {\r\n\t                for (String file : files)\r\n\t                {\r\n\t                    ssTables_.remove(file);\r\n\t                    SSTable.removeAssociatedBloomFilter(file);\r\n\t                }\r\n\t                if ( newfile != null )\r\n\t                {\r\n\t                    ssTables_.add(newfile);\r\n\t                    logger_.debug(\"Inserting bloom filter for file \" + newfile);\r\n\t                    SSTable.storeBloomFilter(newfile, compactedBloomFilter);\r\n\t                    totalBytesWritten = (new File(newfile)).length();\r\n\t                }\r\n\t            }\r\n\t            finally\r\n\t            {\r\n\t                lock_.writeLock().unlock();\r\n\t            }\r\n\t            for (String file : files)\r\n\t            {\r\n\t                SSTable.delete(file);\r\n\t            }\r\n\t        }\r\n        }\r\n        catch ( Exception ex)\r\n        {\r\n            logger_.warn( LogUtil.throwableToString(ex) );\r\n        }\r\n        logger_.debug(\"Total time taken for compaction  ...\"\r\n                + (System.currentTimeMillis() - startTime));\r\n        logger_.debug(\"Total bytes Read for compaction  ...\" + totalBytesRead);\r\n        logger_.debug(\"Total bytes written for compaction  ...\"\r\n                + totalBytesWritten + \"   Total keys read ...\" + totalkeysRead);\r\n    }","id":92348,"modified_method":"void  doFileCompaction(List<String> files,  int minBufferSize)\r\n    {\r\n    \tString newfile = null;\r\n        long startTime = System.currentTimeMillis();\r\n        long totalBytesRead = 0;\r\n        long totalBytesWritten = 0;\r\n        long totalkeysRead = 0;\r\n        long totalkeysWritten = 0;\r\n        try\r\n        {\r\n\t        // Calculate the expected compacted filesize\r\n\t    \tlong expectedCompactedFileSize = getExpectedCompactedFileSize(files);\r\n\t        String compactionFileLocation = DatabaseDescriptor.getCompactionFileLocation(expectedCompactedFileSize);\r\n\t        // If the compaction file path is null that means we have no space left for this compaction.\r\n\t        if( compactionFileLocation == null )\r\n\t        {\r\n        \t\tString maxFile = getMaxSizeFile( files );\r\n        \t\tfiles.remove( maxFile );\r\n        \t\tdoFileCompaction(files , minBufferSize);\r\n        \t\treturn;\r\n\t        }\r\n\t        PriorityQueue<FileStruct> pq = initializePriorityQueue(files, null, minBufferSize);\r\n\t        if (pq.size() > 0)\r\n\t        {\r\n\t            String mergedFileName = getTempFileName( files );\r\n\t            SSTable ssTable = null;\r\n\t            String lastkey = null;\r\n\t            List<FileStruct> lfs = new ArrayList<FileStruct>();\r\n\t            DataOutputBuffer bufOut = new DataOutputBuffer();\r\n\t            int expectedBloomFilterSize = SSTable.getApproximateKeyCount(files);\r\n\t            expectedBloomFilterSize = (expectedBloomFilterSize > 0) ? expectedBloomFilterSize : SSTable.indexInterval();\r\n\t            logger_.debug(\"Expected bloom filter size : \" + expectedBloomFilterSize);\r\n\t            /* Create the bloom filter for the compacted file. */\r\n\t            BloomFilter compactedBloomFilter = new BloomFilter(expectedBloomFilterSize, 15);\r\n\t            List<ColumnFamily> columnFamilies = new ArrayList<ColumnFamily>();\r\n\r\n\t            while (pq.size() > 0 || lfs.size() > 0)\r\n\t            {\r\n\t                FileStruct fs = null;\r\n\t                if (pq.size() > 0)\r\n\t                {\r\n\t                    fs = pq.poll();                        \r\n\t                }\r\n\t                if (fs != null\r\n\t                        && (lastkey == null || lastkey.compareTo(fs.getKey()) == 0))\r\n\t                {\r\n\t                    // The keys are the same so we need to add this to the\r\n\t                    // ldfs list\r\n\t                    lastkey = fs.getKey();\r\n\t                    lfs.add(fs);\r\n\t                }\r\n\t                else\r\n\t                {\r\n\t                    Collections.sort(lfs, new FileStructComparator());\r\n\t                    ColumnFamily columnFamily = null;\r\n\t                    bufOut.reset();\r\n\t                    if(lfs.size() > 1)\r\n\t                    {\r\n\t\t                    for (FileStruct filestruct : lfs)\r\n\t\t                    {\r\n\t\t                    \ttry\r\n\t\t                    \t{\r\n\t                                /* read the length although we don't need it */\r\n\t                                filestruct.getBufIn().readInt();\r\n\t                                // Skip the Index\r\n                                    IndexHelper.skipBloomFilterAndIndex(filestruct.getBufIn());\r\n\t                                // We want to add only 2 and resolve them right there in order to save on memory footprint\r\n\t                                if(columnFamilies.size() > 1)\r\n\t                                {\r\n\t    \t\t                        merge(columnFamilies);\r\n\t                                }\r\n\t\t\t                        // deserialize into column families                                    \r\n\t\t\t                        columnFamilies.add(ColumnFamily.serializer().deserialize(filestruct.getBufIn()));\r\n\t\t                    \t}\r\n\t\t                    \tcatch ( Exception ex)\r\n\t\t                    \t{\r\n                                    logger_.warn(\"error in filecompaction\", ex);\r\n                                }\r\n\t\t                    }\r\n\t\t                    // Now after merging all crap append to the sstable\r\n\t\t                    columnFamily = resolveAndRemoveDeleted(columnFamilies);\r\n\t\t                    columnFamilies.clear();\r\n\t\t                    if( columnFamily != null )\r\n\t\t                    {\r\n\t\t\t                \t/* serialize the cf with column indexes */\r\n\t\t\t                    ColumnFamily.serializerWithIndexes().serialize(columnFamily, bufOut);\r\n\t\t                    }\r\n\t                    }\r\n\t                    else\r\n\t                    {\r\n\t\t                    FileStruct filestruct = lfs.get(0);\r\n\t                    \ttry\r\n\t                    \t{\r\n\t\t                        /* read the length although we don't need it */\r\n\t\t                        int size = filestruct.getBufIn().readInt();\r\n\t\t                        bufOut.write(filestruct.getBufIn(), size);\r\n\t                    \t}\r\n\t                    \tcatch ( Exception ex)\r\n\t                    \t{\r\n\t                    \t\tex.printStackTrace();\r\n\t                            filestruct.close();\r\n\t                            continue;\r\n\t                    \t}\r\n\t                    }\r\n\t                    \t         \r\n\t                    if ( ssTable == null )\r\n\t                    {\r\n\t                    \tssTable = new SSTable(compactionFileLocation, mergedFileName);\t                    \t\r\n\t                    }\r\n                        ssTable.append(lastkey, bufOut);\r\n\r\n                        /* Fill the bloom filter with the key */\r\n\t                    doFill(compactedBloomFilter, lastkey);                        \r\n\t                    totalkeysWritten++;\r\n\t                    for (FileStruct filestruct : lfs)\r\n\t                    {\r\n\t                    \ttry\r\n\t                    \t{\r\n                                filestruct.getNextKey();\r\n\t                    \t\tif (filestruct.isExhausted())\r\n\t                    \t\t{\r\n\t                    \t\t\tcontinue;\r\n\t                    \t\t}\r\n\t                    \t\tpq.add(filestruct);\r\n\t\t                        totalkeysRead++;\r\n\t                    \t}\r\n\t                    \tcatch ( Throwable ex )\r\n\t                    \t{\r\n\t                    \t\t// Ignore the exception as it might be a corrupted file\r\n\t                    \t\t// in any case we have read as far as possible from it\r\n\t                    \t\t// and it will be deleted after compaction.\r\n\t                            filestruct.close();\r\n                            }\r\n\t                    }\r\n\t                    lfs.clear();\r\n\t                    lastkey = null;\r\n\t                    if (fs != null)\r\n\t                    {\r\n\t                        /* Add back the fs since we processed the rest of filestructs */\r\n\t                        pq.add(fs);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            if ( ssTable != null )\r\n\t            {\r\n\t                ssTable.closeRename(compactedBloomFilter);\r\n\t                newfile = ssTable.getDataFileLocation();\r\n\t            }\r\n\t            lock_.writeLock().lock();\r\n\t            try\r\n\t            {\r\n\t                for (String file : files)\r\n\t                {\r\n\t                    ssTables_.remove(file);\r\n\t                    SSTable.removeAssociatedBloomFilter(file);\r\n\t                }\r\n\t                if ( newfile != null )\r\n\t                {\r\n\t                    ssTables_.add(newfile);\r\n\t                    logger_.debug(\"Inserting bloom filter for file \" + newfile);\r\n\t                    SSTable.storeBloomFilter(newfile, compactedBloomFilter);\r\n\t                    totalBytesWritten = (new File(newfile)).length();\r\n\t                }\r\n\t            }\r\n\t            finally\r\n\t            {\r\n\t                lock_.writeLock().unlock();\r\n\t            }\r\n\t            for (String file : files)\r\n\t            {\r\n\t                SSTable.delete(file);\r\n\t            }\r\n\t        }\r\n        }\r\n        catch ( Exception ex)\r\n        {\r\n            logger_.warn( LogUtil.throwableToString(ex) );\r\n        }\r\n        logger_.debug(\"Total time taken for compaction  ...\"\r\n                + (System.currentTimeMillis() - startTime));\r\n        logger_.debug(\"Total bytes Read for compaction  ...\" + totalBytesRead);\r\n        logger_.debug(\"Total bytes written for compaction  ...\"\r\n                + totalBytesWritten + \"   Total keys read ...\" + totalkeysRead);\r\n    }","commit_id":"bf684eea956dbbbf7a35ef3deca8b4462b139136","url":"https://github.com/apache/cassandra"},{"original_method":"PriorityQueue<FileStruct> initializePriorityQueue(List<String> files, List<Range> ranges, int minBufferSize)\r\n    {\r\n        PriorityQueue<FileStruct> pq = new PriorityQueue<FileStruct>();\r\n        if (files.size() > 1 || (ranges != null &&  files.size() > 0))\r\n        {\r\n            int bufferSize = Math.min( (ColumnFamilyStore.compactionMemoryThreshold_ / files.size()), minBufferSize ) ;\r\n            FileStruct fs = null;\r\n            for (String file : files)\r\n            {\r\n            \ttry\r\n            \t{\r\n            \t\tfs = new FileStruct();\r\n\t                fs.bufIn_ = new DataInputBuffer();\r\n\t                fs.bufOut_ = new DataOutputBuffer();\r\n\t                fs.reader_ = SequenceFile.bufferedReader(file, bufferSize);                    \r\n\t                fs.key_ = null;\r\n\t                fs = getNextKey(fs);\r\n\t                if(fs == null)\r\n\t                \tcontinue;\r\n\t                pq.add(fs);\r\n            \t}\r\n            \tcatch ( Exception ex)\r\n            \t{\r\n            \t\tex.printStackTrace();\r\n            \t\ttry\r\n            \t\t{\r\n            \t\t\tif(fs != null)\r\n            \t\t\t{\r\n            \t\t\t\tfs.reader_.close();\r\n            \t\t\t}\r\n            \t\t}\r\n            \t\tcatch(Exception e)\r\n            \t\t{\r\n            \t\t\tlogger_.warn(\"Unable to close file :\" + file);\r\n            \t\t}\r\n                }\r\n            }\r\n        }\r\n        return pq;\r\n    }","id":92349,"modified_method":"PriorityQueue<FileStruct> initializePriorityQueue(List<String> files, List<Range> ranges, int minBufferSize)\r\n    {\r\n        PriorityQueue<FileStruct> pq = new PriorityQueue<FileStruct>();\r\n        if (files.size() > 1 || (ranges != null &&  files.size() > 0))\r\n        {\r\n            int bufferSize = Math.min( (ColumnFamilyStore.compactionMemoryThreshold_ / files.size()), minBufferSize ) ;\r\n            FileStruct fs = null;\r\n            for (String file : files)\r\n            {\r\n            \ttry\r\n            \t{\r\n            \t\tfs = new FileStruct(SequenceFile.bufferedReader(file, bufferSize));\r\n\t                fs.getNextKey();\r\n\t                if(fs.isExhausted())\r\n\t                \tcontinue;\r\n\t                pq.add(fs);\r\n            \t}\r\n            \tcatch ( Exception ex)\r\n            \t{\r\n            \t\tex.printStackTrace();\r\n            \t\ttry\r\n            \t\t{\r\n            \t\t\tif (fs != null)\r\n            \t\t\t{\r\n            \t\t\t\tfs.close();\r\n            \t\t\t}\r\n            \t\t}\r\n            \t\tcatch(Exception e)\r\n            \t\t{\r\n            \t\t\tlogger_.warn(\"Unable to close file :\" + file);\r\n            \t\t}\r\n                }\r\n            }\r\n        }\r\n        return pq;\r\n    }","commit_id":"bf684eea956dbbbf7a35ef3deca8b4462b139136","url":"https://github.com/apache/cassandra"},{"original_method":"public String getKey()\r\n    {\r\n        return key_;\r\n    }","id":92350,"modified_method":"public String getKey()\r\n    {\r\n        return key;\r\n    }","commit_id":"bf684eea956dbbbf7a35ef3deca8b4462b139136","url":"https://github.com/apache/cassandra"},{"original_method":"public FileStruct(String file, int bufSize) throws IOException\r\n    {\r\n        bufIn_ = new DataInputBuffer();\r\n        bufOut_ = new DataOutputBuffer();\r\n        reader_ = SequenceFile.bufferedReader(file, bufSize);\r\n        long bytesRead = advance();\r\n        if ( bytesRead == -1L )\r\n            throw new IOException(\"Either the file is empty or EOF has been reached.\");          \r\n    }","id":92351,"modified_method":"public FileStruct(IFileReader reader)\r\n    {\r\n        this.reader = reader;\r\n        bufIn = new DataInputBuffer();\r\n        bufOut = new DataOutputBuffer();\r\n    }","commit_id":"bf684eea956dbbbf7a35ef3deca8b4462b139136","url":"https://github.com/apache/cassandra"},{"original_method":"public void close() throws IOException\r\n    {\r\n        bufIn_.close();\r\n        bufOut_.close();\r\n        reader_.close();\r\n    }","id":92352,"modified_method":"public void close() throws IOException\r\n    {\r\n        reader.close();\r\n    }","commit_id":"bf684eea956dbbbf7a35ef3deca8b4462b139136","url":"https://github.com/apache/cassandra"},{"original_method":"public int compareTo(FileStruct f)\r\n    {\r\n        return StorageService.getPartitioner().getDecoratedKeyComparator().compare(key_, f.key_);\r\n    }","id":92353,"modified_method":"public int compareTo(FileStruct f)\r\n    {\r\n        return key.compareTo(f.key);\r\n    }","commit_id":"bf684eea956dbbbf7a35ef3deca8b4462b139136","url":"https://github.com/apache/cassandra"},{"original_method":"public DataOutputBuffer getBuffer()\r\n    {\r\n        return bufOut_;\r\n    }","id":92354,"modified_method":"public DataInputBuffer getBufIn()\r\n    {\r\n        return bufIn;\r\n    }","commit_id":"bf684eea956dbbbf7a35ef3deca8b4462b139136","url":"https://github.com/apache/cassandra"},{"original_method":"public int compare(FileStruct f, FileStruct f2)\r\n    {\r\n        return f.reader_.getFileName().compareTo(f2.reader_.getFileName());\r\n    }","id":92355,"modified_method":"public int compare(FileStruct f, FileStruct f2)\r\n    {\r\n        return f.getFileName().compareTo(f2.getFileName());\r\n    }","commit_id":"bf684eea956dbbbf7a35ef3deca8b4462b139136","url":"https://github.com/apache/cassandra"},{"original_method":"private Coordinate getCoordinates(String decoratedKey, IFileReader dataReader) throws IOException\r\n    {\r\n    \tList<KeyPositionInfo> indexInfo = indexMetadataMap_.get(dataFile_);\r\n    \tint size = (indexInfo == null) ? 0 : indexInfo.size();\r\n    \tlong start = 0L;\r\n    \tlong end = dataReader.getEOF();\r\n        if ( size > 0 )\r\n        {\r\n            int index = Collections.binarySearch(indexInfo, new KeyPositionInfo(decoratedKey));\r\n            if ( index < 0 )\r\n            {\r\n                /*\r\n                 * We are here which means that the requested\r\n                 * key is not an index.\r\n                */\r\n                index = (++index)*(-1);\r\n                /*\r\n                 * This means key is not present at all. Hence\r\n                 * a scan is in order.\r\n                */\r\n                start = (index == 0) ? 0 : indexInfo.get(index - 1).position();\r\n                if ( index < size )\r\n                {\r\n                    end = indexInfo.get(index).position();\r\n                }\r\n                else\r\n                {\r\n                    /* This is the Block Index in the file. */\r\n                    end = start;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /*\r\n                 * If we are here that means the key is in the index file\r\n                 * and we can retrieve it w/o a scan. In reality we would\r\n                 * like to have a retreive(key, fromPosition) but for now\r\n                 * we use scan(start, start + 1) - a hack.\r\n                */\r\n                start = indexInfo.get(index).position();                \r\n                end = start;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /*\r\n             * We are here which means there are less than\r\n             * 128 keys in the system and hence our only recourse\r\n             * is a linear scan from start to finish. Automatically\r\n             * use memory mapping since we have a huge file and very\r\n             * few keys.\r\n            */\r\n            end = dataReader.getEOF();\r\n        }  \r\n        \r\n        return new Coordinate(start, end);\r\n    }","id":92356,"modified_method":"public static Coordinate getCoordinates(String decoratedKey, IFileReader dataReader) throws IOException\r\n    {\r\n    \tList<KeyPositionInfo> indexInfo = indexMetadataMap_.get(dataReader.getFileName());\r\n    \tint size = (indexInfo == null) ? 0 : indexInfo.size();\r\n    \tlong start = 0L;\r\n    \tlong end = dataReader.getEOF();\r\n        if ( size > 0 )\r\n        {\r\n            int index = Collections.binarySearch(indexInfo, new KeyPositionInfo(decoratedKey));\r\n            if ( index < 0 )\r\n            {\r\n                /*\r\n                 * We are here which means that the requested\r\n                 * key is not an index.\r\n                */\r\n                index = (++index)*(-1);\r\n                /*\r\n                 * This means key is not present at all. Hence\r\n                 * a scan is in order.\r\n                */\r\n                start = (index == 0) ? 0 : indexInfo.get(index - 1).position();\r\n                if ( index < size )\r\n                {\r\n                    end = indexInfo.get(index).position();\r\n                }\r\n                else\r\n                {\r\n                    /* This is the Block Index in the file. */\r\n                    end = start;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /*\r\n                 * If we are here that means the key is in the index file\r\n                 * and we can retrieve it w/o a scan. In reality we would\r\n                 * like to have a retreive(key, fromPosition) but for now\r\n                 * we use scan(start, start + 1) - a hack.\r\n                */\r\n                start = indexInfo.get(index).position();                \r\n                end = start;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /*\r\n             * We are here which means there are less than\r\n             * 128 keys in the system and hence our only recourse\r\n             * is a linear scan from start to finish. Automatically\r\n             * use memory mapping since we have a huge file and very\r\n             * few keys.\r\n            */\r\n            end = dataReader.getEOF();\r\n        }  \r\n        \r\n        return new Coordinate(start, end);\r\n    }","commit_id":"bf684eea956dbbbf7a35ef3deca8b4462b139136","url":"https://github.com/apache/cassandra"},{"original_method":"private void recursiveWriteComponent(BatchResource batchResource, BatchReportWriter writer) {\n    Resource r = batchResource.resource();\n    BatchReport.Component.Builder builder = BatchReport.Component.newBuilder();\n\n    // non-null fields\n    builder.setRef(batchResource.batchId());\n    builder.setType(getType(r));\n\n    // protocol buffers does not accept null values\n\n    String uuid = r.getUuid();\n    if (uuid != null) {\n      builder.setUuid(uuid);\n    }\n    Integer sid = batchResource.snapshotId();\n    if (sid != null) {\n      builder.setSnapshotId(sid);\n    }\n    if (ResourceUtils.isFile(r)) {\n      builder.setIsTest(ResourceUtils.isUnitTestClass(r));\n    }\n    String name = getName(r);\n    if (name != null) {\n      builder.setName(name);\n    }\n    String path = r.getPath();\n    if (path != null) {\n      builder.setPath(path);\n    }\n    String lang = getLanguageKey(r);\n    if (lang != null) {\n      builder.setLanguage(lang);\n    }\n    for (BatchResource child : batchResource.children()) {\n      builder.addChildRef(child.batchId());\n    }\n    writeLinks(r, builder);\n    writeVersion(r, builder);\n    writeEvents(batchResource, builder);\n    writer.writeComponent(builder.build());\n\n    for (BatchResource child : batchResource.children()) {\n      recursiveWriteComponent(child, writer);\n    }\n  }","id":92357,"modified_method":"private void recursiveWriteComponent(BatchResource batchResource, BatchReportWriter writer) {\n    Resource r = batchResource.resource();\n    BatchReport.Component.Builder builder = BatchReport.Component.newBuilder();\n\n    // non-null fields\n    builder.setRef(batchResource.batchId());\n    builder.setType(getType(r));\n    builder.setKey(r.getKey());\n\n    // protocol buffers does not accept null values\n\n    String uuid = r.getUuid();\n    if (uuid != null) {\n      builder.setUuid(uuid);\n    }\n    Integer sid = batchResource.snapshotId();\n    if (sid != null) {\n      builder.setSnapshotId(sid);\n    }\n    if (ResourceUtils.isFile(r)) {\n      builder.setIsTest(ResourceUtils.isUnitTestClass(r));\n    }\n    String name = getName(r);\n    if (name != null) {\n      builder.setName(name);\n    }\n    String path = r.getPath();\n    if (path != null) {\n      builder.setPath(path);\n    }\n    String lang = getLanguageKey(r);\n    if (lang != null) {\n      builder.setLanguage(lang);\n    }\n    for (BatchResource child : batchResource.children()) {\n      builder.addChildRef(child.batchId());\n    }\n    writeLinks(r, builder);\n    writeVersion(r, builder);\n    writeEvents(batchResource, builder);\n    writer.writeComponent(builder.build());\n\n    for (BatchResource child : batchResource.children()) {\n      recursiveWriteComponent(child, writer);\n    }\n  }","commit_id":"46dfa139944cb0ff94e5f05f18a55533b489ef10","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void add_components_to_report() throws Exception {\n    // inputs\n    Project root = new Project(\"foo\").setName(\"Root project\")\n      .setAnalysisDate(DateUtils.parseDate((\"2012-12-12\")));\n    root.setId(1).setUuid(\"PROJECT_UUID\");\n    resourceCache.add(root, null).setSnapshot(new Snapshot().setId(11));\n\n    Project module1 = new Project(\"module1\").setName(\"Module1\");\n    module1.setParent(root);\n    module1.setId(2).setUuid(\"MODULE_UUID\");\n    resourceCache.add(module1, root).setSnapshot(new Snapshot().setId(12));\n    reactor.getRoot().addSubProject(ProjectDefinition.create().setKey(\"module1\"));\n\n    Directory dir = Directory.create(\"src\");\n    dir.setEffectiveKey(\"module1:src\");\n    dir.setId(3).setUuid(\"DIR_UUID\");\n    resourceCache.add(dir, module1).setSnapshot(new Snapshot().setId(13));\n\n    org.sonar.api.resources.File file = org.sonar.api.resources.File.create(\"src/Foo.java\", Java.INSTANCE, false);\n    file.setEffectiveKey(\"module1:src/Foo.java\");\n    file.setId(4).setUuid(\"FILE_UUID\");\n    resourceCache.add(file, dir).setSnapshot(new Snapshot().setId(14));\n\n    org.sonar.api.resources.File fileWithoutLang = org.sonar.api.resources.File.create(\"src/make\", null, false);\n    fileWithoutLang.setEffectiveKey(\"module1:src/make\");\n    fileWithoutLang.setId(5).setUuid(\"FILE_WITHOUT_LANG_UUID\");\n    resourceCache.add(fileWithoutLang, dir).setSnapshot(new Snapshot().setId(15));\n\n    org.sonar.api.resources.File testFile = org.sonar.api.resources.File.create(\"test/FooTest.java\", Java.INSTANCE, true);\n    testFile.setEffectiveKey(\"module1:test/FooTest.java\");\n    testFile.setId(6).setUuid(\"TEST_FILE_UUID\");\n    resourceCache.add(testFile, dir).setSnapshot(new Snapshot().setId(16));\n\n    File outputDir = temp.newFolder();\n    BatchReportWriter writer = new BatchReportWriter(outputDir);\n    publisher.publish(writer);\n\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 1)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 2)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 3)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 4)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 5)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 6)).isTrue();\n\n    // no such reference\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 7)).isFalse();\n\n    BatchReportReader reader = new BatchReportReader(outputDir);\n    Component rootProtobuf = reader.readComponent(1);\n    assertThat(rootProtobuf.getVersion()).isEqualTo(\"1.0\");\n    assertThat(rootProtobuf.getLinkCount()).isEqualTo(0);\n\n    Component module1Protobuf = reader.readComponent(2);\n    assertThat(module1Protobuf.getVersion()).isEqualTo(\"1.0\");\n  }","id":92358,"modified_method":"@Test\n  public void add_components_to_report() throws Exception {\n    // inputs\n    Project root = new Project(\"foo\").setName(\"Root project\")\n      .setAnalysisDate(DateUtils.parseDate((\"2012-12-12\")));\n    root.setId(1).setUuid(\"PROJECT_UUID\");\n    resourceCache.add(root, null).setSnapshot(new Snapshot().setId(11));\n\n    Project module1 = new Project(\"module1\").setName(\"Module1\");\n    module1.setParent(root);\n    module1.setId(2).setUuid(\"MODULE_UUID\");\n    resourceCache.add(module1, root).setSnapshot(new Snapshot().setId(12));\n    reactor.getRoot().addSubProject(ProjectDefinition.create().setKey(\"module1\"));\n\n    Directory dir = Directory.create(\"src\");\n    dir.setEffectiveKey(\"module1:src\");\n    dir.setId(3).setUuid(\"DIR_UUID\");\n    resourceCache.add(dir, module1).setSnapshot(new Snapshot().setId(13));\n\n    org.sonar.api.resources.File file = org.sonar.api.resources.File.create(\"src/Foo.java\", Java.INSTANCE, false);\n    file.setEffectiveKey(\"module1:src/Foo.java\");\n    file.setId(4).setUuid(\"FILE_UUID\");\n    resourceCache.add(file, dir).setSnapshot(new Snapshot().setId(14));\n\n    org.sonar.api.resources.File fileWithoutLang = org.sonar.api.resources.File.create(\"src/make\", null, false);\n    fileWithoutLang.setEffectiveKey(\"module1:src/make\");\n    fileWithoutLang.setId(5).setUuid(\"FILE_WITHOUT_LANG_UUID\");\n    resourceCache.add(fileWithoutLang, dir).setSnapshot(new Snapshot().setId(15));\n\n    org.sonar.api.resources.File testFile = org.sonar.api.resources.File.create(\"test/FooTest.java\", Java.INSTANCE, true);\n    testFile.setEffectiveKey(\"module1:test/FooTest.java\");\n    testFile.setId(6).setUuid(\"TEST_FILE_UUID\");\n    resourceCache.add(testFile, dir).setSnapshot(new Snapshot().setId(16));\n\n    File outputDir = temp.newFolder();\n    BatchReportWriter writer = new BatchReportWriter(outputDir);\n    publisher.publish(writer);\n\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 1)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 2)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 3)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 4)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 5)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 6)).isTrue();\n\n    // no such reference\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 7)).isFalse();\n\n    BatchReportReader reader = new BatchReportReader(outputDir);\n    Component rootProtobuf = reader.readComponent(1);\n    assertThat(rootProtobuf.getKey()).isEqualTo(\"foo\");\n    assertThat(rootProtobuf.getVersion()).isEqualTo(\"1.0\");\n    assertThat(rootProtobuf.getLinkCount()).isEqualTo(0);\n\n    Component module1Protobuf = reader.readComponent(2);\n    assertThat(module1Protobuf.getKey()).isEqualTo(\"module1\");\n    assertThat(module1Protobuf.getVersion()).isEqualTo(\"1.0\");\n  }","commit_id":"46dfa139944cb0ff94e5f05f18a55533b489ef10","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void recursivelyProcessComponent(DuplicationContext duplicationContext, @Nullable Integer parentComponentRef, int componentRef) {\n    BatchReportReader reportReader = duplicationContext.context().getReportReader();\n    BatchReport.Component component = reportReader.readComponent(componentRef);\n    List<BatchReport.Duplication> duplications = reportReader.readComponentDuplications(componentRef);\n    if (!duplications.isEmpty() && parentComponentRef != null) {\n      saveDuplications(duplicationContext, reportReader.readComponent(parentComponentRef), component, duplications);\n    }\n\n    for (Integer childRef : component.getChildRefList()) {\n      recursivelyProcessComponent(duplicationContext, componentRef, childRef);\n    }\n  }","id":92359,"modified_method":"private void recursivelyProcessComponent(DuplicationContext duplicationContext, int parentModuleRef, int componentRef) {\n    BatchReportReader reportReader = duplicationContext.context().getReportReader();\n    BatchReport.Component component = reportReader.readComponent(componentRef);\n    List<BatchReport.Duplication> duplications = reportReader.readComponentDuplications(componentRef);\n    if (!duplications.isEmpty()) {\n      saveDuplications(duplicationContext, reportReader.readComponent(parentModuleRef), component, duplications);\n    }\n\n    for (Integer childRef : component.getChildRefList()) {\n      // If current component is a folder, we need to keep the parent reference to module parent\n      int nextParent = !component.getType().equals(Constants.ComponentType.PROJECT) && !component.getType().equals(Constants.ComponentType.MODULE) ?\n        parentModuleRef : componentRef;\n      recursivelyProcessComponent(duplicationContext, nextParent, childRef);\n    }\n  }","commit_id":"46dfa139944cb0ff94e5f05f18a55533b489ef10","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void execute(ComputationContext context) {\n    DbSession session = dbClient.openSession(true);\n    try {\n      MetricDto duplicationMetric = dbClient.metricDao().selectByKey(session, CoreMetrics.DUPLICATIONS_DATA_KEY);\n      DuplicationContext duplicationContext = new DuplicationContext(context, duplicationMetric, session);\n      int rootComponentRef = context.getReportMetadata().getRootComponentRef();\n      recursivelyProcessComponent(duplicationContext, null, rootComponentRef);\n      session.commit();\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","id":92360,"modified_method":"@Override\n  public void execute(ComputationContext context) {\n    DbSession session = dbClient.openSession(true);\n    try {\n      MetricDto duplicationMetric = dbClient.metricDao().selectByKey(session, CoreMetrics.DUPLICATIONS_DATA_KEY);\n      DuplicationContext duplicationContext = new DuplicationContext(context, duplicationMetric, session);\n      int rootComponentRef = context.getReportMetadata().getRootComponentRef();\n      recursivelyProcessComponent(duplicationContext, rootComponentRef, rootComponentRef);\n      session.commit();\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","commit_id":"46dfa139944cb0ff94e5f05f18a55533b489ef10","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void persist_duplications_on_different_files() throws Exception {\n    saveDuplicationMetric();\n    BatchReportWriter writer = initReportWithProjectAndFile();\n\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.FILE)\n      .setUuid(\"UUID_C\")\n      .setSnapshotId(12L)\n      .setPath(\"file2\")\n      .build());\n\n    BatchReport.Duplication duplication = BatchReport.Duplication.newBuilder()\n      .setOriginBlock(BatchReport.DuplicationBlock.newBuilder()\n        .setOtherComponentRef(2)\n        .setStartLine(1)\n        .setEndLine(5)\n        .build())\n      .addDuplicatedBy(BatchReport.DuplicationBlock.newBuilder()\n        .setOtherComponentRef(3)\n        .setStartLine(6)\n        .setEndLine(10)\n        .build())\n      .build();\n    writer.writeComponentDuplications(2, newArrayList(duplication));\n\n    sut.execute(new ComputationContext(new BatchReportReader(reportDir), ComponentTesting.newProjectDto(\"PROJECT\")));\n\n    assertThat(dbTester.countRowsOfTable(\"project_measures\")).isEqualTo(1);\n\n    Map<String, Object> dto =  dbTester.selectFirst(\"select snapshot_id as \\\"snapshotId\\\", text_value as \\\"textValue\\\" from project_measures\");\n    assertThat(dto.get(\"snapshotId\")).isEqualTo(11L);\n    assertThat(dto.get(\"textValue\")).isEqualTo(\"<duplications><g><b s=\\\"1\\\" l=\\\"4\\\" r=\\\"PROJECT_KEY:file\\\"/><b s=\\\"6\\\" l=\\\"4\\\" r=\\\"PROJECT_KEY:file2\\\"/><\/g><\/duplications>\");\n  }","id":92361,"modified_method":"@Test\n  public void persist_duplications_on_different_files() throws Exception {\n    saveDuplicationMetric();\n    BatchReportWriter writer = initReportWithProjectAndFile();\n\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.FILE)\n      .setSnapshotId(12L)\n      .setPath(\"file2\")\n      .build());\n\n    BatchReport.Duplication duplication = BatchReport.Duplication.newBuilder()\n      .setOriginBlock(BatchReport.DuplicationBlock.newBuilder()\n        .setOtherComponentRef(2)\n        .setStartLine(1)\n        .setEndLine(5)\n        .build())\n      .addDuplicatedBy(BatchReport.DuplicationBlock.newBuilder()\n        .setOtherComponentRef(3)\n        .setStartLine(6)\n        .setEndLine(10)\n        .build())\n      .build();\n    writer.writeComponentDuplications(2, newArrayList(duplication));\n\n    sut.execute(new ComputationContext(new BatchReportReader(reportDir), ComponentTesting.newProjectDto(\"PROJECT\")));\n\n    assertThat(dbTester.countRowsOfTable(\"project_measures\")).isEqualTo(1);\n\n    Map<String, Object> dto =  dbTester.selectFirst(\"select snapshot_id as \\\"snapshotId\\\", text_value as \\\"textValue\\\" from project_measures\");\n    assertThat(dto.get(\"snapshotId\")).isEqualTo(11L);\n    assertThat(dto.get(\"textValue\")).isEqualTo(\"<duplications><g><b s=\\\"1\\\" l=\\\"4\\\" r=\\\"PROJECT_KEY:file\\\"/><b s=\\\"6\\\" l=\\\"4\\\" r=\\\"PROJECT_KEY:file2\\\"/><\/g><\/duplications>\");\n  }","commit_id":"46dfa139944cb0ff94e5f05f18a55533b489ef10","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private BatchReportWriter initReportWithProjectAndFile() throws IOException {\n    BatchReportWriter writer = new BatchReportWriter(reportDir);\n    writer.writeMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .setProjectKey(\"PROJECT_KEY\")\n      .setAnalysisDate(150000000L)\n      .build());\n\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setUuid(\"UUID_A\")\n      .setKey(\"PROJECT_KEY\")\n      .setSnapshotId(10L)\n      .addChildRef(2)\n      .build());\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.FILE)\n      .setUuid(\"UUID_B\")\n      .setSnapshotId(11L)\n      .setPath(\"file\")\n      .build());\n\n    return writer;\n  }","id":92362,"modified_method":"private BatchReportWriter initReportWithProjectAndFile() throws IOException {\n    BatchReportWriter writer = new BatchReportWriter(reportDir);\n    writer.writeMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .build());\n\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(\"PROJECT_KEY\")\n      .setSnapshotId(10L)\n      .addChildRef(2)\n      .build());\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.FILE)\n      .setSnapshotId(11L)\n      .setPath(\"file\")\n      .build());\n\n    return writer;\n  }","commit_id":"46dfa139944cb0ff94e5f05f18a55533b489ef10","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void persist_duplications_on_same_file_when_a_branch_is_used() throws Exception {\n    saveDuplicationMetric();\n\n    File reportDir = temp.newFolder();\n    BatchReportWriter writer = new BatchReportWriter(reportDir);\n    writer.writeMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .setProjectKey(\"PROJECT_KEY\")\n      .setBranch(\"origin/master\")\n      .setAnalysisDate(150000000L)\n      .build());\n\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setUuid(\"UUID_A\")\n      .setKey(\"PROJECT_KEY\")\n      .setSnapshotId(10L)\n      .addChildRef(2)\n      .build());\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.FILE)\n      .setUuid(\"UUID_B\")\n      .setSnapshotId(11L)\n      .setPath(\"file\")\n      .build());\n\n    BatchReport.Duplication duplication = BatchReport.Duplication.newBuilder()\n      .setOriginBlock(BatchReport.DuplicationBlock.newBuilder()\n        .setOtherComponentRef(2)\n        .setStartLine(1)\n        .setEndLine(5)\n        .build())\n      .addDuplicatedBy(BatchReport.DuplicationBlock.newBuilder()\n        .setOtherComponentRef(2)\n        .setStartLine(6)\n        .setEndLine(10)\n        .build())\n      .build();\n    writer.writeComponentDuplications(2, newArrayList(duplication));\n\n    sut.execute(new ComputationContext(new BatchReportReader(reportDir), ComponentTesting.newProjectDto(\"PROJECT\")));\n\n    assertThat(dbTester.countRowsOfTable(\"project_measures\")).isEqualTo(1);\n\n    Map<String, Object> dto =  dbTester.selectFirst(\"select snapshot_id as \\\"snapshotId\\\", text_value as \\\"textValue\\\" from project_measures\");\n    assertThat(dto.get(\"snapshotId\")).isEqualTo(11L);\n    assertThat(dto.get(\"textValue\")).isEqualTo(\"<duplications><g><b s=\\\"1\\\" l=\\\"4\\\" r=\\\"PROJECT_KEY:file:origin/master\\\"/><b s=\\\"6\\\" l=\\\"4\\\" r=\\\"PROJECT_KEY:file:origin/master\\\"/><\/g><\/duplications>\");\n  }","id":92363,"modified_method":"@Test\n  public void persist_duplications_on_same_file_when_a_branch_is_used() throws Exception {\n    saveDuplicationMetric();\n\n    File reportDir = temp.newFolder();\n    BatchReportWriter writer = new BatchReportWriter(reportDir);\n    writer.writeMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .setBranch(\"origin/master\")\n      .build());\n\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(\"PROJECT_KEY\")\n      .setSnapshotId(10L)\n      .addChildRef(2)\n      .build());\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.FILE)\n      .setSnapshotId(11L)\n      .setPath(\"file\")\n      .build());\n\n    BatchReport.Duplication duplication = BatchReport.Duplication.newBuilder()\n      .setOriginBlock(BatchReport.DuplicationBlock.newBuilder()\n        .setOtherComponentRef(2)\n        .setStartLine(1)\n        .setEndLine(5)\n        .build())\n      .addDuplicatedBy(BatchReport.DuplicationBlock.newBuilder()\n        .setOtherComponentRef(2)\n        .setStartLine(6)\n        .setEndLine(10)\n        .build())\n      .build();\n    writer.writeComponentDuplications(2, newArrayList(duplication));\n\n    sut.execute(new ComputationContext(new BatchReportReader(reportDir), ComponentTesting.newProjectDto(\"PROJECT\")));\n\n    assertThat(dbTester.countRowsOfTable(\"project_measures\")).isEqualTo(1);\n\n    Map<String, Object> dto =  dbTester.selectFirst(\"select snapshot_id as \\\"snapshotId\\\", text_value as \\\"textValue\\\" from project_measures\");\n    assertThat(dto.get(\"snapshotId\")).isEqualTo(11L);\n    assertThat(dto.get(\"textValue\")).isEqualTo(\"<duplications><g><b s=\\\"1\\\" l=\\\"4\\\" r=\\\"PROJECT_KEY:file:origin/master\\\"/><b s=\\\"6\\\" l=\\\"4\\\" r=\\\"PROJECT_KEY:file:origin/master\\\"/><\/g><\/duplications>\");\n  }","commit_id":"46dfa139944cb0ff94e5f05f18a55533b489ef10","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void persist_duplications_on_same_file_linked_on_a_module() throws Exception {\n    saveDuplicationMetric();\n\n    File reportDir = temp.newFolder();\n    BatchReportWriter writer = new BatchReportWriter(reportDir);\n    writer.writeMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .setProjectKey(\"PROJECT_KEY\")\n      .setAnalysisDate(150000000L)\n      .build());\n\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setUuid(\"UUID_A\")\n      .setKey(\"PROJECT_KEY\")\n      .setSnapshotId(10L)\n      .addChildRef(2)\n      .build());\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.PROJECT)\n      .setUuid(\"UUID_B\")\n      .setKey(\"MODULE_KEY\")\n      .setSnapshotId(11L)\n      .addChildRef(3)\n      .build());\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.FILE)\n      .setUuid(\"UUID_C\")\n      .setSnapshotId(12L)\n      .setPath(\"file\")\n      .build());\n\n    BatchReport.Duplication duplication = BatchReport.Duplication.newBuilder()\n      .setOriginBlock(BatchReport.DuplicationBlock.newBuilder()\n        .setOtherComponentRef(3)\n        .setStartLine(1)\n        .setEndLine(5)\n        .build())\n      .addDuplicatedBy(BatchReport.DuplicationBlock.newBuilder()\n        .setOtherComponentRef(3)\n        .setStartLine(6)\n        .setEndLine(10)\n        .build())\n      .build();\n    writer.writeComponentDuplications(3, newArrayList(duplication));\n\n    sut.execute(new ComputationContext(new BatchReportReader(reportDir), ComponentTesting.newProjectDto(\"PROJECT\")));\n\n    assertThat(dbTester.countRowsOfTable(\"project_measures\")).isEqualTo(1);\n\n    Map<String, Object> dto =  dbTester.selectFirst(\"select snapshot_id as \\\"snapshotId\\\", text_value as \\\"textValue\\\" from project_measures\");\n    assertThat(dto.get(\"snapshotId\")).isEqualTo(12L);\n    assertThat(dto.get(\"textValue\")).isEqualTo(\"<duplications><g><b s=\\\"1\\\" l=\\\"4\\\" r=\\\"MODULE_KEY:file\\\"/><b s=\\\"6\\\" l=\\\"4\\\" r=\\\"MODULE_KEY:file\\\"/><\/g><\/duplications>\");\n  }","id":92364,"modified_method":"@Test\n  public void persist_duplications_on_same_file_linked_on_a_module() throws Exception {\n    saveDuplicationMetric();\n\n    File reportDir = temp.newFolder();\n    BatchReportWriter writer = new BatchReportWriter(reportDir);\n    writer.writeMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .build());\n\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(\"PROJECT_KEY\")\n      .setSnapshotId(10L)\n      .addChildRef(2)\n      .build());\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"MODULE_KEY\")\n      .setSnapshotId(11L)\n      .addChildRef(3)\n      .build());\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.FILE)\n      .setSnapshotId(12L)\n      .setPath(\"file\")\n      .build());\n\n    BatchReport.Duplication duplication = BatchReport.Duplication.newBuilder()\n      .setOriginBlock(BatchReport.DuplicationBlock.newBuilder()\n        .setOtherComponentRef(3)\n        .setStartLine(1)\n        .setEndLine(5)\n        .build())\n      .addDuplicatedBy(BatchReport.DuplicationBlock.newBuilder()\n        .setOtherComponentRef(3)\n        .setStartLine(6)\n        .setEndLine(10)\n        .build())\n      .build();\n    writer.writeComponentDuplications(3, newArrayList(duplication));\n\n    sut.execute(new ComputationContext(new BatchReportReader(reportDir), ComponentTesting.newProjectDto(\"PROJECT\")));\n\n    assertThat(dbTester.countRowsOfTable(\"project_measures\")).isEqualTo(1);\n\n    Map<String, Object> dto =  dbTester.selectFirst(\"select snapshot_id as \\\"snapshotId\\\", text_value as \\\"textValue\\\" from project_measures\");\n    assertThat(dto.get(\"snapshotId\")).isEqualTo(12L);\n    assertThat(dto.get(\"textValue\")).isEqualTo(\"<duplications><g><b s=\\\"1\\\" l=\\\"4\\\" r=\\\"MODULE_KEY:file\\\"/><b s=\\\"6\\\" l=\\\"4\\\" r=\\\"MODULE_KEY:file\\\"/><\/g><\/duplications>\");\n  }","commit_id":"46dfa139944cb0ff94e5f05f18a55533b489ef10","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void appendText(int total, int included, FileStatus fileStatus, String labelKey) {\n    String pattern = total == included ? \"%s %d\" : \"%s %d of %d\";\n    String text = String.format(pattern, VcsBundle.message(labelKey), included, total);\n    myRootPanel.append(text, new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, fileStatus.getColor()));\n  }","id":92365,"modified_method":"private void appendText(int total, int included, @NotNull FileStatus fileStatus, @NotNull String labelKey) {\n    if (total > 0) {\n      if (!isPanelEmpty()) {\n        appendSpace();\n      }\n      String pattern = total == included ? \"%s %d\" : \"%s %d of %d\";\n      String text = String.format(pattern, VcsBundle.message(labelKey), included, total);\n      myRootPanel.append(text, new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, fileStatus.getColor()));\n    }\n  }","commit_id":"11b72f44ecbbb97b3594366a03b0dc8dab6f0fa7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update() {\n    final int deleted = myInfoCalculator.getDeleted();\n    final int modified = myInfoCalculator.getModified();\n    final int cntNew = myInfoCalculator.getNew();\n\n    myRootPanel.clear();\n    if (cntNew > 0) {\n      appendText(cntNew, myInfoCalculator.getIncludedNew(), FileStatus.ADDED, \"commit.legend.new\");\n      if (modified > 0 || deleted > 0) {\n        appendSpace();\n      }\n    }\n    if (modified > 0) {\n      appendText(modified, myInfoCalculator.getIncludedModified(), FileStatus.MODIFIED, \"commit.legend.modified\");\n      if (deleted > 0) {\n        appendSpace();\n      }\n    }\n    if (deleted > 0) {\n      appendText(deleted, myInfoCalculator.getIncludedDeleted(), FileStatus.DELETED, \"commit.legend.deleted\");\n    }\n  }","id":92366,"modified_method":"public void update() {\n    myRootPanel.clear();\n    appendText(myInfoCalculator.getNew(), myInfoCalculator.getIncludedNew(), FileStatus.ADDED, \"commit.legend.new\");\n    appendText(myInfoCalculator.getModified(), myInfoCalculator.getIncludedModified(), FileStatus.MODIFIED, \"commit.legend.modified\");\n    appendText(myInfoCalculator.getDeleted(), myInfoCalculator.getIncludedDeleted(), FileStatus.DELETED, \"commit.legend.deleted\");\n  }","commit_id":"11b72f44ecbbb97b3594366a03b0dc8dab6f0fa7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * If the node has a name-key or id-key, this is displayed. If not, (lat,lon)\n\t * is displayed.\n\t */\n\tpublic void visit(Node n) {\n\t\tname = n.get(\"name\");\n\t\tif (name == null) {\n\t\t\tif (n.incomplete) {\n\t\t\t\tname = \"incomplete\" + (n.id==0?\"\":\" \"+n.id);\n\t\t\t} else {\n\t\t\t\tname = (n.id==0?\"\":\"\"+n.id)+\" (\"+latLonFormat.format(n.coor.lat())+\", \"+latLonFormat.format(n.coor.lon())+\")\";\n\t\t\t}\n\t\t}\n\t\taddId(n);\n\t\ticon = ImageProvider.get(\"data\", \"node\");\n\t\ttrn(\"node\", \"nodes\", 0); // no marktrn available\n\t\tclassName = \"node\";\n\t}","id":92367,"modified_method":"/**\n\t * If the node has a name-key or id-key, this is displayed. If not, (lat,lon)\n\t * is displayed.\n\t */\n\tpublic void visit(Node n) {\n\t\tif (n.incomplete) {\n\t\t\tname = tr(\"incomplete\");\n\t\t} else {\n\t\t\tname = n.get(\"name\");\n\t\t\tif (name == null) {\n\t\t\t\tname = n.id == 0 ? \"\" : \"\"+n.id;\n\t\t\t}\n\t\t\tname += \" (\"+latLonFormat.format(n.coor.lat())+\", \"+latLonFormat.format(n.coor.lon())+\")\";\n\t\t}\n\t\taddId(n);\n\t\ticon = ImageProvider.get(\"data\", \"node\");\n\t\ttrn(\"node\", \"nodes\", 0); // no marktrn available\n\t\tclassName = \"node\";\n\t}","commit_id":"d418af05b90e0d85b273e2425718bdfe1992df1f","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n\t */\n\tpublic void visit(Relation e) {\n\t\tname = e.get(\"type\");\n\t\t// FIXME add names of members\n\t\tif (name == null)\n\t\t\tname = \"relation\";\n\t\taddId(e);\n\t\ticon = ImageProvider.get(\"data\", \"relation\");\n\t\ttrn(\"relation\", \"relations\", 0); // no marktrn available\n\t\tclassName = \"relation\";\n\t}","id":92368,"modified_method":"/**\n\t */\n\tpublic void visit(Relation e) {\n\t\tif (e.incomplete) {\n\t\t\tname = tr(\"incomplete\");\n\t\t} else {\n\t\t\tname = e.get(\"type\");\n\t\t\t// FIXME add names of members\n\t\t\tif (name == null)\n\t\t\t\tname = \"relation\";\n\t\t}\n\t\taddId(e);\n\t\ticon = ImageProvider.get(\"data\", \"relation\");\n\t\ttrn(\"relation\", \"relations\", 0); // no marktrn available\n\t\tclassName = \"relation\";\n\t}","commit_id":"d418af05b90e0d85b273e2425718bdfe1992df1f","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n\t * If the way has a name-key or id-key, this is displayed. If not, (x nodes)\n\t * is displayed with x being the number of nodes in the way.\n\t */\n\tpublic void visit(Way w) {\n\t\tname = w.get(\"name\");\n\t\tif (name == null) name = w.get(\"ref\");\n\t\tif (name == null) {\n\t\t\tString what = (w.get(\"highway\") != null) ? \"highway \" : (w.get(\"railway\") != null) ? \"railway \" : (w.get(\"waterway\") != null) ? \"waterway \" : \"\";\n\t\t\tint nodesNo = new HashSet<Node>(w.nodes).size();\n\t\t\tname = what + trn(\"{0} node\", \"{0} nodes\", nodesNo, nodesNo);\n\t\t}\n\t\taddId(w);\n\t\ticon = ImageProvider.get(\"data\", \"way\");\n\t\ttrn(\"way\", \"ways\", 0); // no marktrn available\n\t\tclassName = \"way\";\n\t}","id":92369,"modified_method":"/**\n\t * If the way has a name-key or id-key, this is displayed. If not, (x nodes)\n\t * is displayed with x being the number of nodes in the way.\n\t */\n\tpublic void visit(Way w) {\n\t\tif (w.incomplete) {\n\t\t\tname = tr(\"incomplete\");\n\t\t} else {\n\t\t\tname = w.get(\"name\");\n\t\t\tif (name == null) name = w.get(\"ref\");\n\t\t\tif (name == null) {\n\t\t\t\tname = \n\t\t\t\t\t(w.get(\"highway\") != null) ? \"highway\" :\n\t\t\t\t\t(w.get(\"railway\") != null) ? \"railway\" :\n\t\t\t\t\t(w.get(\"waterway\") != null) ? \"waterway\" : \"\";\n\t\t\t}\n\n\t\t\tint nodesNo = new HashSet<Node>(w.nodes).size();\n\t\t\tname += trn(\" ({0} node)\", \" ({0} nodes)\", nodesNo, nodesNo);\n\t\t}\n\t\taddId(w);\n\t\ticon = ImageProvider.get(\"data\", \"way\");\n\t\ttrn(\"way\", \"ways\", 0); // no marktrn available\n\t\tclassName = \"way\";\n\t}","commit_id":"d418af05b90e0d85b273e2425718bdfe1992df1f","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * calculates the sum of the lengths of all track segments\n     */\n    public double length(){\n        double result = 0.0; // in meters\n        WayPoint last = null;\n\n        for (GpxTrack trk : tracks) {\n            for (Collection<WayPoint> trkseg : trk.trackSegs) {\n                for (WayPoint tpt : trkseg) {\n                    if(last != null){\n                        Double d = last.getCoor().greatCircleDistance(tpt.getCoor());\n                        if(!d.isNaN() && !d.isInfinite())\n                          result += d;\n                    }\n                    last = tpt;\n                }\n                last = null; // restart for each track segment\n            }\n        }\n        return result;\n    }","id":92370,"modified_method":"/**\n     * calculates the sum of the lengths of all track segments\n     */\n    public double length(){\n        double result = 0.0; // in meters\n        WayPoint last = null;\n\n        for (GpxTrack trk : tracks)\n\t    result += trk.length();\n\n        return result;\n    }","commit_id":"aa80632df5bb55b36b49bd48b2f8ef6bdaada9da","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public String getToolTipText() {\n        StringBuilder info = new StringBuilder().append(\"<html>\");\n\n        info.append(trn(\"{0} track, \", \"{0} tracks, \", data.tracks.size(), data.tracks.size())).append(\n                trn(\"{0} route, \", \"{0} routes, \", data.routes.size(), data.routes.size())).append(\n                        trn(\"{0} waypoint\", \"{0} waypoints\", data.waypoints.size(), data.waypoints.size())).append(\"<br>\");\n\n        if (data.attr.containsKey(\"name\")) {\n            info.append(tr(\"Name: {0}\", data.attr.get(GpxData.META_NAME))).append(\"<br>\");\n        }\n\n        if (data.attr.containsKey(\"desc\")) {\n            info.append(tr(\"Description: {0}\", data.attr.get(GpxData.META_DESC))).append(\"<br>\");\n        }\n\n        if (data.tracks.size() > 0) {\n            boolean first = true;\n            WayPoint earliest = null, latest = null;\n\n            for (GpxTrack trk : data.tracks) {\n                for (Collection<WayPoint> seg : trk.trackSegs) {\n                    for (WayPoint pnt : seg) {\n                        if (first) {\n                            latest = earliest = pnt;\n                            first = false;\n                        } else {\n                            if (pnt.compareTo(earliest) < 0) {\n                                earliest = pnt;\n                            } else {\n                                latest = pnt;\n                            }\n                        }\n                    }\n                }\n            }\n            if (earliest != null && latest != null) {\n                DateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT);\n                info.append(tr(\"Timespan: \") + df.format(new Date((long) (earliest.time * 1000))) + \" - \"\n                        + df.format(new Date((long) (latest.time * 1000))));\n                int diff = (int) (latest.time - earliest.time);\n                info.append(\" (\" + (diff / 3600) + \":\" + ((diff % 3600) / 60) + \")\");\n                info.append(\"<br>\");\n            }\n        }\n        info.append(tr(\"Length: \") + new DecimalFormat(\"#0.00\").format(data.length() / 1000) + \"km\");\n        info.append(\"<br>\");\n\n        return info.append(\"<\/html>\").toString();\n    }","id":92371,"modified_method":"@Override\n    public String getToolTipText() {\n        StringBuilder info = new StringBuilder().append(\"<html>\");\n\n        if (data.attr.containsKey(\"name\")) {\n            info.append(tr(\"Name: {0}\", data.attr.get(GpxData.META_NAME))).append(\"<br>\");\n        }\n\n        if (data.attr.containsKey(\"desc\")) {\n            info.append(tr(\"Description: {0}\", data.attr.get(GpxData.META_DESC))).append(\"<br>\");\n        }\n\n        if (data.tracks.size() > 0) {\n\t    info.append(\"<table><thead align=\\\"center\\\"><tr><td colspan=\\\"5\\\">\"\n\t\t+ trn(\"{0} track\", \"{0} tracks\", data.tracks.size(), data.tracks.size())\n\t\t+ \"<\/td><\/tr><tr><td>\" + tr(\"Name\") + \"<\/td><td>\"\n\t\t+ tr(\"Description\") + \"<\/td><td>\" + tr(\"Timespan\")\n\t\t+ \"<\/td><td>\" + tr(\"Length\") + \"<\/td><td>\" + tr(\"URL\")\n\t\t+ \"<\/td><\/tr><\/thead>\");\n\n            for (GpxTrack trk : data.tracks) {\n\t\tWayPoint earliest = null, latest = null;\n\n\t\tinfo.append(\"<tr><td>\");\n\t\tif (trk.attr.containsKey(\"name\"))\n\t\t    info.append(trk.attr.get(\"name\"));\n\t\tinfo.append(\"<\/td><td>\");\n\t\tif (trk.attr.containsKey(\"desc\"))\n\t\t    info.append(\" \").append(trk.attr.get(\"desc\"));\n\t\tinfo.append(\"<\/td><td>\");\n\n                for (Collection<WayPoint> seg : trk.trackSegs) {\n                    for (WayPoint pnt : seg) {\n                        if (latest == null) {\n                            latest = earliest = pnt;\n                        } else {\n                            if (pnt.compareTo(earliest) < 0) {\n                                earliest = pnt;\n                            } else {\n                                latest = pnt;\n                            }\n                        }\n                    }\n                }\n\n\t\tif (earliest != null && latest != null) {\n\t\t    DateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT);\n\t\t    info.append(df.format(new Date((long) (earliest.time * 1000))) + \" - \"\n                        + df.format(new Date((long) (latest.time * 1000))));\n\t\t    int diff = (int) (latest.time - earliest.time);\n\t\t    info.append(\" (\" + (diff / 3600) + \":\" + ((diff % 3600) / 60) + \")\");\n\t\t}\n\n\t\tinfo.append(\"<\/td><td>\");\n\t\tinfo.append(new DecimalFormat(\"#0.00\").format(trk.length() / 1000) + \"km\");\n\t\tinfo.append(\"<\/td><td>\");\n\t\tif (trk.attr.containsKey(\"url\"))\n\t\t    info.append(trk.attr.get(\"url\"));\n\t\tinfo.append(\"<\/td><\/tr>\");\n            }\n\n\t    info.append(\"<\/table><br><br>\");\n\n        }\n\n        info.append(tr(\"Length: \") + new DecimalFormat(\"#0.00\").format(data.length() / 1000) + \"km\");\n        info.append(\"<br>\");\n\n\tinfo.append(trn(\"{0} route, \", \"{0} routes, \", data.routes.size(), data.routes.size())).append(\n                        trn(\"{0} waypoint\", \"{0} waypoints\", data.waypoints.size(), data.waypoints.size())).append(\"<br>\");\n\n        return info.append(\"<\/html>\").toString();\n    }","commit_id":"aa80632df5bb55b36b49bd48b2f8ef6bdaada9da","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override public void endElement(String namespaceURI, String qName, String rqName) {\n            switch (currentState) {\n            case metadata:\n                if (qName.equals(\"name\")) {\n                    currentData.attr.put(GpxData.META_NAME, accumulator.toString());\n                } else if (qName.equals(\"desc\")) {\n                    currentData.attr.put(GpxData.META_DESC, accumulator.toString());\n                } else if (qName.equals(\"time\")) {\n                    currentData.attr.put(GpxData.META_TIME, accumulator.toString());\n                } else if (qName.equals(\"keywords\")) {\n                    currentData.attr.put(GpxData.META_KEYWORDS, accumulator.toString());\n                } else if (qName.equals(\"metadata\")) {\n                    currentState = states.pop();\n                }\n                //TODO: parse bounds, extensions\n                break;\n            case author:\n                if (qName.equals(\"author\")) {\n                    currentState = states.pop();\n                } else if (qName.equals(\"name\")) {\n                    currentData.attr.put(GpxData.META_AUTHOR_NAME, accumulator.toString());\n                } else if (qName.equals(\"email\")) {\n                    // do nothing, has been parsed on startElement\n                } else if (qName.equals(\"link\")) {\n                    currentData.attr.put(GpxData.META_AUTHOR_LINK, currentLink);\n                }\n                break;\n            case copyright:\n                if (qName.equals(\"copyright\")) {\n                    currentState = states.pop();\n                } else if (qName.equals(\"year\")) {\n                    currentData.attr.put(GpxData.META_COPYRIGHT_YEAR, accumulator.toString());\n                } else if (qName.equals(\"license\")) {\n                    currentData.attr.put(GpxData.META_COPYRIGHT_LICENSE, accumulator.toString());\n                }\n                break;\n            case link:\n                if (qName.equals(\"text\")) {\n                    currentLink.text = accumulator.toString();\n                } else if (qName.equals(\"type\")) {\n                    currentLink.type = accumulator.toString();\n                } else if (qName.equals(\"link\")) {\n                    currentState = states.pop();\n                }\n                if (currentState == state.author) {\n                    currentData.attr.put(GpxData.META_AUTHOR_LINK, currentLink);\n                } else if (currentState != state.link) {\n                    Map<String, Object> attr = getAttr();\n                    if (!attr.containsKey(GpxData.META_LINKS)) {\n                        attr.put(GpxData.META_LINKS, new LinkedList<GpxLink>());\n                    }\n                    ((Collection<GpxLink>) attr.get(GpxData.META_LINKS)).add(currentLink);\n                }\n                break;\n            case wpt:\n                if (   qName.equals(\"ele\")  || qName.equals(\"magvar\")\n                    || qName.equals(\"name\") || qName.equals(\"geoidheight\")\n                    || qName.equals(\"type\") || qName.equals(\"sym\")) {\n                    currentWayPoint.attr.put(qName, accumulator.toString());\n                } else if(qName.equals(\"hdop\") /*|| qName.equals(\"vdop\") ||\n                        qName.equals(\"pdop\")*/) {\n                    try {\n                        currentWayPoint.attr.put(qName, Float.parseFloat(accumulator.toString()));\n                    } catch(Exception e) {\n                        currentWayPoint.attr.put(qName, new Float(0));\n                    }\n                } else if (qName.equals(\"time\")) {\n                    currentWayPoint.attr.put(qName, accumulator.toString());\n                    currentWayPoint.setTime();\n                } else if (qName.equals(\"cmt\") || qName.equals(\"desc\")) {\n                    currentWayPoint.attr.put(qName, accumulator.toString());\n                    currentWayPoint.setTime();\n                } else if (qName.equals(\"rtept\")) {\n                    currentState = states.pop();\n                    currentRoute.routePoints.add(currentWayPoint);\n                } else if (qName.equals(\"trkpt\")) {\n                    currentState = states.pop();\n                    currentTrackSeg.add(currentWayPoint);\n                } else if (qName.equals(\"wpt\")) {\n                    currentState = states.pop();\n                    currentData.waypoints.add(currentWayPoint);\n                }\n                break;\n            case trkseg:\n                if (qName.equals(\"trkseg\")) {\n                    currentState = states.pop();\n                    currentTrack.trackSegs.add(currentTrackSeg);\n                }\n                break;\n            case trk:\n                if (qName.equals(\"trk\")) {\n                    currentState = states.pop();\n                    currentData.tracks.add(currentTrack);\n                } else if (qName.equals(\"name\") || qName.equals(\"cmt\")\n                        || qName.equals(\"desc\") || qName.equals(\"src\")\n                        || qName.equals(\"type\") || qName.equals(\"number\")) {\n                    currentTrack.attr.put(qName, accumulator.toString());\n                }\n                break;\n            case ext:\n                if (qName.equals(\"extensions\")) {\n                    currentState = states.pop();\n                }\n                break;\n            default:\n                if (qName.equals(\"wpt\")) {\n                    currentState = states.pop();\n                } else if (qName.equals(\"rte\")) {\n                    currentState = states.pop();\n                    currentData.routes.add(currentRoute);\n                }\n            }\n        }","id":92372,"modified_method":"@Override public void endElement(String namespaceURI, String qName, String rqName) {\n            switch (currentState) {\n            case metadata:\n                if (qName.equals(\"name\")) {\n                    currentData.attr.put(GpxData.META_NAME, accumulator.toString());\n                } else if (qName.equals(\"desc\")) {\n                    currentData.attr.put(GpxData.META_DESC, accumulator.toString());\n                } else if (qName.equals(\"time\")) {\n                    currentData.attr.put(GpxData.META_TIME, accumulator.toString());\n                } else if (qName.equals(\"keywords\")) {\n                    currentData.attr.put(GpxData.META_KEYWORDS, accumulator.toString());\n                } else if (qName.equals(\"metadata\")) {\n                    currentState = states.pop();\n                }\n                //TODO: parse bounds, extensions\n                break;\n            case author:\n                if (qName.equals(\"author\")) {\n                    currentState = states.pop();\n                } else if (qName.equals(\"name\")) {\n                    currentData.attr.put(GpxData.META_AUTHOR_NAME, accumulator.toString());\n                } else if (qName.equals(\"email\")) {\n                    // do nothing, has been parsed on startElement\n                } else if (qName.equals(\"link\")) {\n                    currentData.attr.put(GpxData.META_AUTHOR_LINK, currentLink);\n                }\n                break;\n            case copyright:\n                if (qName.equals(\"copyright\")) {\n                    currentState = states.pop();\n                } else if (qName.equals(\"year\")) {\n                    currentData.attr.put(GpxData.META_COPYRIGHT_YEAR, accumulator.toString());\n                } else if (qName.equals(\"license\")) {\n                    currentData.attr.put(GpxData.META_COPYRIGHT_LICENSE, accumulator.toString());\n                }\n                break;\n            case link:\n                if (qName.equals(\"text\")) {\n                    currentLink.text = accumulator.toString();\n                } else if (qName.equals(\"type\")) {\n                    currentLink.type = accumulator.toString();\n                } else if (qName.equals(\"link\")) {\n                    currentState = states.pop();\n                }\n                if (currentState == state.author) {\n                    currentData.attr.put(GpxData.META_AUTHOR_LINK, currentLink);\n                } else if (currentState != state.link) {\n                    Map<String, Object> attr = getAttr();\n                    if (!attr.containsKey(GpxData.META_LINKS)) {\n                        attr.put(GpxData.META_LINKS, new LinkedList<GpxLink>());\n                    }\n                    ((Collection<GpxLink>) attr.get(GpxData.META_LINKS)).add(currentLink);\n                }\n                break;\n            case wpt:\n                if (   qName.equals(\"ele\")  || qName.equals(\"magvar\")\n                    || qName.equals(\"name\") || qName.equals(\"geoidheight\")\n                    || qName.equals(\"type\") || qName.equals(\"sym\")) {\n                    currentWayPoint.attr.put(qName, accumulator.toString());\n                } else if(qName.equals(\"hdop\") /*|| qName.equals(\"vdop\") ||\n                        qName.equals(\"pdop\")*/) {\n                    try {\n                        currentWayPoint.attr.put(qName, Float.parseFloat(accumulator.toString()));\n                    } catch(Exception e) {\n                        currentWayPoint.attr.put(qName, new Float(0));\n                    }\n                } else if (qName.equals(\"time\")) {\n                    currentWayPoint.attr.put(qName, accumulator.toString());\n                    currentWayPoint.setTime();\n                } else if (qName.equals(\"cmt\") || qName.equals(\"desc\")) {\n                    currentWayPoint.attr.put(qName, accumulator.toString());\n                    currentWayPoint.setTime();\n                } else if (qName.equals(\"rtept\")) {\n                    currentState = states.pop();\n                    currentRoute.routePoints.add(currentWayPoint);\n                } else if (qName.equals(\"trkpt\")) {\n                    currentState = states.pop();\n                    currentTrackSeg.add(currentWayPoint);\n                } else if (qName.equals(\"wpt\")) {\n                    currentState = states.pop();\n                    currentData.waypoints.add(currentWayPoint);\n                }\n                break;\n            case trkseg:\n                if (qName.equals(\"trkseg\")) {\n                    currentState = states.pop();\n                    currentTrack.trackSegs.add(currentTrackSeg);\n                }\n                break;\n            case trk:\n                if (qName.equals(\"trk\")) {\n                    currentState = states.pop();\n                    currentData.tracks.add(currentTrack);\n                } else if (qName.equals(\"name\") || qName.equals(\"cmt\")\n                        || qName.equals(\"desc\") || qName.equals(\"src\")\n                        || qName.equals(\"type\") || qName.equals(\"number\")\n\t\t\t|| qName.equals(\"url\")) {\n                    currentTrack.attr.put(qName, accumulator.toString());\n                }\n                break;\n            case ext:\n                if (qName.equals(\"extensions\")) {\n                    currentState = states.pop();\n                }\n                break;\n            default:\n                if (qName.equals(\"wpt\")) {\n                    currentState = states.pop();\n                } else if (qName.equals(\"rte\")) {\n                    currentState = states.pop();\n                    currentData.routes.add(currentRoute);\n                }\n            }\n        }","commit_id":"aa80632df5bb55b36b49bd48b2f8ef6bdaada9da","url":"https://github.com/openstreetmap/josm"},{"original_method":"public JMenu addMenu(String name, int mnemonicKey, int position, String relativeHelpTopic) {\n        JMenu menu = new JMenu(tr(name));\n        Shortcut.registerShortcut(\"menu:\" + name, tr(\"Menu: {0}\", tr(name)), mnemonicKey,\n                Shortcut.GROUP_MNEMONIC).setMnemonic(menu);\n        add(menu, position);\n        menu.putClientProperty(\"help\", relativeHelpTopic);\n        return menu;\n    }","id":92373,"modified_method":"public JMenu addMenu(String name, int mnemonicKey, int position, String relativeHelpTopic) {\n        JMenu menu = new JMenu(name);\n        Shortcut.registerShortcut(\"menu:\" + name, tr(\"Menu: {0}\", tr(name)), mnemonicKey,\n                Shortcut.GROUP_MNEMONIC).setMnemonic(menu);\n        add(menu, position);\n        menu.putClientProperty(\"help\", relativeHelpTopic);\n        return menu;\n    }","commit_id":"98f6c00208308d42d8ff11829d7283fdc8cb33b0","url":"https://github.com/openstreetmap/josm"},{"original_method":"public MainMenu() {\n        JMenuItem current;\n\n        add(fileMenu, newAction);\n        add(fileMenu, openFile);\n        add(fileMenu, openLocation);\n        fileMenu.addSeparator();\n        add(fileMenu, save);\n        add(fileMenu, saveAs);\n        add(fileMenu, gpxExport);\n        fileMenu.addSeparator();\n        add(fileMenu, download);\n        add(fileMenu, downloadReferrers);\n        add(fileMenu, update);\n        add(fileMenu, updateSelection);\n        fileMenu.addSeparator();\n        add(fileMenu, upload);\n        add(fileMenu, uploadSelection);\n        fileMenu.addSeparator();\n        add(fileMenu, closeChangesetAction);\n        fileMenu.addSeparator();\n        add(fileMenu, exit);\n\n        add(editMenu, undo);\n        add(editMenu, redo);\n        editMenu.addSeparator();\n        add(editMenu, copy);\n        add(editMenu, paste);\n        add(editMenu, pasteTags);\n        add(editMenu, duplicate);\n        add(editMenu, delete);\n        editMenu.addSeparator();\n        add(editMenu,merge);\n        add(editMenu,mergeSelected);\n        editMenu.addSeparator();\n        add(editMenu, selectAll);\n        add(editMenu, unselectAll);\n        editMenu.addSeparator();\n        add(editMenu, search);\n        editMenu.addSeparator();\n        add(editMenu, preferences);\n\n        // TODO move code to an \"action\" like the others?\n        final JCheckBoxMenuItem wireframe = new JCheckBoxMenuItem(tr(\"Wireframe View\"));\n        wireframe.setSelected(Main.pref.getBoolean(\"draw.wireframe\", false));\n        wireframe.setAccelerator(Shortcut.registerShortcut(\"menu:view:wireframe\", tr(\"Toggle Wireframe view\"),\n                KeyEvent.VK_W, Shortcut.GROUP_MENU).getKeyStroke());\n        wireframe.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent ev) {\n                Main.pref.put(\"draw.wireframe\", wireframe.isSelected());\n                if (Main.map != null) {\n                    Main.map.mapView.repaint();\n                }\n            }\n        });\n        viewMenu.add(wireframe);\n        viewMenu.addSeparator();\n        add(viewMenu, new ZoomInAction());\n        add(viewMenu, new ZoomOutAction());\n        viewMenu.addSeparator();\n        for (String mode : AutoScaleAction.modes) {\n            JosmAction autoScaleAction = new AutoScaleAction(mode);\n            add(viewMenu, autoScaleAction);\n        }\n\n        //\n        // Full Screen action\n        //\n        final GraphicsDevice gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();\n\n        if (Main.platform instanceof PlatformHookUnixoid && gd.isFullScreenSupported()) {\n            final JCheckBoxMenuItem fullscreen = new JCheckBoxMenuItem(tr(\"Full Screen\"));\n            fullscreen.setSelected(Main.pref.getBoolean(\"draw.fullscreen\", false));\n            fullscreen.setAccelerator(Shortcut.registerShortcut(\"menu:view:fullscreen\", tr(\"Toggle Full Screen view\"),\n                    KeyEvent.VK_F11, Shortcut.GROUP_DIRECT).getKeyStroke());\n\n            fullscreen.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent ev) {\n                    Main.pref.put(\"draw.fullscreen\", fullscreen.isSelected());\n\n                    if (Main.pref.getBoolean(\"draw.fullscreen\")) {\n                        Frame frame = (Frame)Main.parent;\n                        gd.setFullScreenWindow(frame);\n                    } else {\n                        gd.setFullScreenWindow(null);\n                    }\n                }\n            });\n            viewMenu.addSeparator();\n            viewMenu.add(fullscreen);\n        }\n\n        add(toolsMenu, splitWay);\n        add(toolsMenu, combineWay);\n        toolsMenu.addSeparator();\n        add(toolsMenu, reverseWay);\n        toolsMenu.addSeparator();\n        add(toolsMenu, alignInCircle);\n        add(toolsMenu, alignInLine);\n        add(toolsMenu, distribute);\n        add(toolsMenu, ortho);\n        add(toolsMenu, mirror);\n        toolsMenu.addSeparator();\n        add(toolsMenu, addnode);\n        add(toolsMenu, createCircle);\n        toolsMenu.addSeparator();\n        add(toolsMenu, mergeNodes);\n        add(toolsMenu, joinNodeWay);\n        add(toolsMenu, unglueNodes);\n        toolsMenu.addSeparator();\n        add(toolsMenu, info);\n        add(toolsMenu, historyinfo);\n\n        if (!Main.pref.getBoolean(\"audio.menuinvisible\", false)) {\n            audioMenu = addMenu(marktr(\"Audio\"), KeyEvent.VK_A, 5, ht(\"/Menu/Audio\"));\n            add(audioMenu, audioPlayPause);\n            add(audioMenu, audioNext);\n            add(audioMenu, audioPrev);\n            add(audioMenu, audioFwd);\n            add(audioMenu, audioBack);\n            add(audioMenu, audioSlower);\n            add(audioMenu, audioFaster);\n        }\n\n        helpMenu.add(statusreport);\n\n        current = helpMenu.add(help); // FIXME why is help not a JosmAction?\n        current.setAccelerator(Shortcut.registerShortcut(\"system:help\", tr(\"Help\"), KeyEvent.VK_F1,\n                Shortcut.GROUP_DIRECT).getKeyStroke());\n        add(helpMenu, about);\n\n        new PresetsMenuEnabler(presetsMenu).refreshEnabled();\n    }","id":92374,"modified_method":"public MainMenu() {\n        JMenuItem current;\n\n        add(fileMenu, newAction);\n        add(fileMenu, openFile);\n        add(fileMenu, openLocation);\n        fileMenu.addSeparator();\n        add(fileMenu, save);\n        add(fileMenu, saveAs);\n        add(fileMenu, gpxExport);\n        fileMenu.addSeparator();\n        add(fileMenu, download);\n        add(fileMenu, downloadReferrers);\n        add(fileMenu, update);\n        add(fileMenu, updateSelection);\n        fileMenu.addSeparator();\n        add(fileMenu, upload);\n        add(fileMenu, uploadSelection);\n        fileMenu.addSeparator();\n        add(fileMenu, closeChangesetAction);\n        fileMenu.addSeparator();\n        add(fileMenu, exit);\n\n        add(editMenu, undo);\n        add(editMenu, redo);\n        editMenu.addSeparator();\n        add(editMenu, copy);\n        add(editMenu, paste);\n        add(editMenu, pasteTags);\n        add(editMenu, duplicate);\n        add(editMenu, delete);\n        editMenu.addSeparator();\n        add(editMenu,merge);\n        add(editMenu,mergeSelected);\n        editMenu.addSeparator();\n        add(editMenu, selectAll);\n        add(editMenu, unselectAll);\n        editMenu.addSeparator();\n        add(editMenu, search);\n        editMenu.addSeparator();\n        add(editMenu, preferences);\n\n        // TODO move code to an \"action\" like the others?\n        final JCheckBoxMenuItem wireframe = new JCheckBoxMenuItem(tr(\"Wireframe View\"));\n        wireframe.setSelected(Main.pref.getBoolean(\"draw.wireframe\", false));\n        wireframe.setAccelerator(Shortcut.registerShortcut(\"menu:view:wireframe\", tr(\"Toggle Wireframe view\"),\n                KeyEvent.VK_W, Shortcut.GROUP_MENU).getKeyStroke());\n        wireframe.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent ev) {\n                Main.pref.put(\"draw.wireframe\", wireframe.isSelected());\n                if (Main.map != null) {\n                    Main.map.mapView.repaint();\n                }\n            }\n        });\n        viewMenu.add(wireframe);\n        viewMenu.addSeparator();\n        add(viewMenu, new ZoomInAction());\n        add(viewMenu, new ZoomOutAction());\n        viewMenu.addSeparator();\n        for (String mode : AutoScaleAction.modes) {\n            JosmAction autoScaleAction = new AutoScaleAction(mode);\n            add(viewMenu, autoScaleAction);\n        }\n\n        //\n        // Full Screen action\n        //\n        final GraphicsDevice gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();\n\n        if (Main.platform instanceof PlatformHookUnixoid && gd.isFullScreenSupported()) {\n            final JCheckBoxMenuItem fullscreen = new JCheckBoxMenuItem(tr(\"Full Screen\"));\n            fullscreen.setSelected(Main.pref.getBoolean(\"draw.fullscreen\", false));\n            fullscreen.setAccelerator(Shortcut.registerShortcut(\"menu:view:fullscreen\", tr(\"Toggle Full Screen view\"),\n                    KeyEvent.VK_F11, Shortcut.GROUP_DIRECT).getKeyStroke());\n\n            fullscreen.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent ev) {\n                    Main.pref.put(\"draw.fullscreen\", fullscreen.isSelected());\n\n                    if (Main.pref.getBoolean(\"draw.fullscreen\")) {\n                        Frame frame = (Frame)Main.parent;\n                        gd.setFullScreenWindow(frame);\n                    } else {\n                        gd.setFullScreenWindow(null);\n                    }\n                }\n            });\n            viewMenu.addSeparator();\n            viewMenu.add(fullscreen);\n        }\n\n        add(toolsMenu, splitWay);\n        add(toolsMenu, combineWay);\n        toolsMenu.addSeparator();\n        add(toolsMenu, reverseWay);\n        toolsMenu.addSeparator();\n        add(toolsMenu, alignInCircle);\n        add(toolsMenu, alignInLine);\n        add(toolsMenu, distribute);\n        add(toolsMenu, ortho);\n        add(toolsMenu, mirror);\n        toolsMenu.addSeparator();\n        add(toolsMenu, addnode);\n        add(toolsMenu, createCircle);\n        toolsMenu.addSeparator();\n        add(toolsMenu, mergeNodes);\n        add(toolsMenu, joinNodeWay);\n        add(toolsMenu, unglueNodes);\n        toolsMenu.addSeparator();\n        add(toolsMenu, info);\n        add(toolsMenu, historyinfo);\n\n        if (!Main.pref.getBoolean(\"audio.menuinvisible\", false)) {\n            audioMenu = addMenu(tr(\"Audio\"), KeyEvent.VK_A, 5, ht(\"/Menu/Audio\"));\n            add(audioMenu, audioPlayPause);\n            add(audioMenu, audioNext);\n            add(audioMenu, audioPrev);\n            add(audioMenu, audioFwd);\n            add(audioMenu, audioBack);\n            add(audioMenu, audioSlower);\n            add(audioMenu, audioFaster);\n        }\n\n        helpMenu.add(statusreport);\n\n        current = helpMenu.add(help); // FIXME why is help not a JosmAction?\n        current.setAccelerator(Shortcut.registerShortcut(\"system:help\", tr(\"Help\"), KeyEvent.VK_F1,\n                Shortcut.GROUP_DIRECT).getKeyStroke());\n        add(helpMenu, about);\n\n        new PresetsMenuEnabler(presetsMenu).refreshEnabled();\n    }","commit_id":"98f6c00208308d42d8ff11829d7283fdc8cb33b0","url":"https://github.com/openstreetmap/josm"},{"original_method":"private UpdateTask(Collection<PluginInformation> toUpdate, boolean up) {\n            super(up ? tr(\"Update Plugins\") : tr(\"Download Plugins\"));\n            this.toUpdate = toUpdate;\n        }","id":92375,"modified_method":"private UpdateTask(Collection<PluginInformation> toUpdate, boolean up, boolean restart) {\n            super(up ? tr(\"Update Plugins\") : tr(\"Download Plugins\"));\n            this.toUpdate = toUpdate;\n            this.restart = restart;\n        }","commit_id":"98f6c00208308d42d8ff11829d7283fdc8cb33b0","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Collection<PluginInformation> download(Collection<PluginInformation> download) {\n        // Execute task in current thread instead of executing it in other thread and waiting for result\n        // Waiting for result is not a good idea because the waiting thread will probably be either EDT\n        // or worker thread. Blocking one of these threads will cause deadlock\n        UpdateTask t = new UpdateTask(download, false);\n        t.run();\n        return t.failed;\n    }","id":92376,"modified_method":"public Collection<PluginInformation> download(Collection<PluginInformation> download) {\n        // Execute task in current thread instead of executing it in other thread and waiting for result\n        // Waiting for result is not a good idea because the waiting thread will probably be either EDT\n        // or worker thread. Blocking one of these threads will cause deadlock\n        UpdateTask t = new UpdateTask(download, false, true);\n        t.run();\n        return t.failed;\n    }","commit_id":"98f6c00208308d42d8ff11829d7283fdc8cb33b0","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override protected void finish() {\n            if (errors.length() > 0) {\n                JOptionPane.showMessageDialog(\n                        Main.parent,\n                        tr(\"There were problems with the following plugins:\\n\\n {0}\",errors),\n                        tr(\"Error\"),\n                        JOptionPane.ERROR_MESSAGE\n                );\n            } else {\n                JOptionPane.showMessageDialog(\n                        Main.parent,\n                        trn(\"{0} Plugin successfully downloaded. Please restart JOSM.\", \"{0} Plugins successfully downloaded. Please restart JOSM.\", count, count),\n                        tr(\"Information\"),\n                        JOptionPane.INFORMATION_MESSAGE\n                );\n            }\n        }","id":92377,"modified_method":"@Override protected void finish() {\n            if (errors.length() > 0) {\n                JOptionPane.showMessageDialog(\n                        Main.parent,\n                        tr(\"There were problems with the following plugins:\\n\\n {0}\",errors),\n                        tr(\"Error\"),\n                        JOptionPane.ERROR_MESSAGE\n                );\n            } else {\n                String txt = trn(\"{0} Plugin successfully downloaded.\", \"{0} Plugins successfully downloaded.\", count, count);\n                if(restart)\n                    txt += \"\\n\"+tr(\"Please restart JOSM.\");\n\n                JOptionPane.showMessageDialog(\n                        Main.parent,\n                        txt,\n                        tr(\"Information\"),\n                        JOptionPane.INFORMATION_MESSAGE\n                );\n            }\n        }","commit_id":"98f6c00208308d42d8ff11829d7283fdc8cb33b0","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static void update(Collection<PluginInformation> update) {\n        Main.worker.execute(new UpdateTask(update, true));\n    }","id":92378,"modified_method":"public static void update(Collection<PluginInformation> update, boolean restart) {\n        Main.worker.execute(new UpdateTask(update, true, restart));\n    }","commit_id":"98f6c00208308d42d8ff11829d7283fdc8cb33b0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Load all plugins specified in preferences. If the parameter is\n     * <code>true<\/code>, all early plugins are loaded (before constructor).\n     */\n    public static void loadPlugins(boolean early) {\n        List<String> plugins = new LinkedList<String>();\n        Collection<String> cp = Main.pref.getCollection(\"plugins\", null);\n        if (cp != null) {\n            plugins.addAll(cp);\n        }\n        if (System.getProperty(\"josm.plugins\") != null) {\n            plugins.addAll(Arrays.asList(System.getProperty(\"josm.plugins\").split(\",\")));\n        }\n\n        String [] oldplugins = new String[] {\"mappaint\", \"unglueplugin\",\n                \"lang-de\", \"lang-en_GB\", \"lang-fr\", \"lang-it\", \"lang-pl\", \"lang-ro\",\n                \"lang-ru\", \"ewmsplugin\", \"ywms\", \"tways-0.2\", \"geotagged\", \"landsat\",\n                \"namefinder\", \"waypoints\", \"slippy_map_chooser\", \"tcx-support\", \"usertools\"};\n        String [] unmaintained = new String[] {\"gpsbabelgui\", \"Intersect_way\"};\n\n        for (String p : oldplugins) {\n            if (plugins.contains(p)) {\n                plugins.remove(p);\n                Main.pref.removeFromCollection(\"plugins\", p);\n                JOptionPane.showMessageDialog(\n                        Main.parent,\n                        tr(\"Loading of {0} plugin was requested. This plugin is no longer required.\", p),\n                        tr(\"Warning\"),\n                        JOptionPane.WARNING_MESSAGE\n                );\n            }\n        }\n        if(early)\n        {\n            for (String p : unmaintained) {\n                if (plugins.contains(p) && disablePlugin(tr(\"<html>Loading of {0} plugin was requested.\"\n                        +\"<br>This plugin is no longer developed and very likely will produce errors.\"\n                        +\"<br>It should be disabled.<br>Delete from preferences?<\/html>\", p), p)) {\n                    plugins.remove(p);\n                }\n            }\n        }\n\n\n        if (plugins.isEmpty())\n            return;\n\n        SortedMap<Integer, Collection<PluginInformation>> p = new TreeMap<Integer, Collection<PluginInformation>>();\n        for (String pluginName : plugins) {\n            PluginInformation info = PluginInformation.findPlugin(pluginName);\n            if (info != null) {\n                if (info.early != early) {\n                    continue;\n                }\n                int josmVersion = Version.getInstance().getVersion();\n                if (info.mainversion > josmVersion && josmVersion != Version.JOSM_UNKNOWN_VERSION) {\n                    JOptionPane.showMessageDialog(\n                            Main.parent,\n                            tr(\"Plugin {0} requires JOSM update to version {1}.\", pluginName,\n                                    info.mainversion),\n                                    tr(\"Warning\"),\n                                    JOptionPane.WARNING_MESSAGE\n                    );\n                    continue;\n                }\n\n                if(info.requires != null)\n                {\n                    String warn = null;\n                    for(String n : info.requires.split(\";\"))\n                    {\n                        if(!plugins.contains(n))\n                        { warn = n; break; }\n                    }\n                    if(warn != null)\n                    {\n                        JOptionPane.showMessageDialog(Main.parent,\n                                tr(\"Plugin {0} is required by plugin {1} but was not found.\",\n                                        warn, pluginName),\n                                        tr(\"Error\"),\n                                        JOptionPane.ERROR_MESSAGE\n                        );\n                        continue;\n                    }\n                }\n                if (!p.containsKey(info.stage)) {\n                    p.put(info.stage, new LinkedList<PluginInformation>());\n                }\n                p.get(info.stage).add(info);\n            } else if(early) {\n                JOptionPane.showMessageDialog(\n                        Main.parent,\n                        tr(\"Plugin not found: {0}.\", pluginName),\n                        tr(\"Error\"),\n                        JOptionPane.ERROR_MESSAGE\n                );\n            }\n        }\n\n        if (!early) {\n            long tim = System.currentTimeMillis();\n            long last = Main.pref.getLong(\"pluginmanager.lastupdate\", 0);\n            Integer maxTime = Main.pref.getInteger(\"pluginmanager.warntime\", 30);\n            long d = (tim - last)/(24*60*60*1000l);\n            if ((last <= 0) || (maxTime <= 0)) {\n                Main.pref.put(\"pluginmanager.lastupdate\",Long.toString(tim));\n            } else if (d > maxTime) {\n                JOptionPane.showMessageDialog(Main.parent,\n                        \"<html>\" +\n                        tr(\"Last plugin update more than {0} days ago.\", d) +\n                        \"<br><em>\" +\n                        tr(\"(You can change the number of days after which this warning appears<br>by setting the config option 'pluginmanager.warntime'.)\") +\n                        \"<\/html>\",\n                        tr(\"Warning\"),\n                        JOptionPane.WARNING_MESSAGE\n                );\n            }\n        }\n\n        // iterate all plugins and collect all libraries of all plugins:\n        List<URL> allPluginLibraries = new ArrayList<URL>();\n        for (Collection<PluginInformation> c : p.values()) {\n            for (PluginInformation info : c) {\n                allPluginLibraries.addAll(info.libraries);\n            }\n        }\n        // create a classloader for all plugins:\n        URL[] jarUrls = new URL[allPluginLibraries.size()];\n        jarUrls = allPluginLibraries.toArray(jarUrls);\n        URLClassLoader pluginClassLoader = new URLClassLoader(jarUrls, Main.class.getClassLoader());\n        ImageProvider.sources.add(0, pluginClassLoader);\n\n        for (Collection<PluginInformation> c : p.values()) {\n            for (PluginInformation info : c) {\n                try {\n                    Class<?> klass = info.loadClass(pluginClassLoader);\n                    if (klass != null) {\n                        System.out.println(\"loading \"+info.name);\n                        pluginList.add(info.load(klass));\n                    }\n                } catch (Throwable e) {\n                    e.printStackTrace();\n                    disablePlugin(tr(\"Could not load plugin {0}. Delete from preferences?\", info.name), info.name);\n                }\n            }\n        }\n    }","id":92379,"modified_method":"/**\n     * Load all plugins specified in preferences. If the parameter is\n     * <code>true<\/code>, all early plugins are loaded (before constructor).\n     */\n    public static void loadPlugins(boolean early) {\n        List<String> plugins = new LinkedList<String>();\n        Collection<String> cp = Main.pref.getCollection(\"plugins\", null);\n        if (cp != null) {\n            plugins.addAll(cp);\n        }\n        if (System.getProperty(\"josm.plugins\") != null) {\n            plugins.addAll(Arrays.asList(System.getProperty(\"josm.plugins\").split(\",\")));\n        }\n\n        String [] oldplugins = new String[] {\"mappaint\", \"unglueplugin\",\n                \"lang-de\", \"lang-en_GB\", \"lang-fr\", \"lang-it\", \"lang-pl\", \"lang-ro\",\n                \"lang-ru\", \"ewmsplugin\", \"ywms\", \"tways-0.2\", \"geotagged\", \"landsat\",\n                \"namefinder\", \"waypoints\", \"slippy_map_chooser\", \"tcx-support\", \"usertools\"};\n        String [] unmaintained = new String[] {\"gpsbabelgui\", \"Intersect_way\"};\n\n        for (String p : oldplugins) {\n            if (plugins.contains(p)) {\n                plugins.remove(p);\n                Main.pref.removeFromCollection(\"plugins\", p);\n                JOptionPane.showMessageDialog(\n                        Main.parent,\n                        tr(\"Loading of {0} plugin was requested. This plugin is no longer required.\", p),\n                        tr(\"Warning\"),\n                        JOptionPane.WARNING_MESSAGE\n                );\n            }\n        }\n        if(early)\n        {\n            for (String p : unmaintained) {\n                if (plugins.contains(p) && disablePlugin(tr(\"<html>Loading of {0} plugin was requested.\"\n                        +\"<br>This plugin is no longer developed and very likely will produce errors.\"\n                        +\"<br>It should be disabled.<br>Delete from preferences?<\/html>\", p), p)) {\n                    plugins.remove(p);\n                }\n            }\n        }\n\n        if (plugins.isEmpty())\n            return;\n\n        if(early)\n        {\n            String doUpdate = null;\n            String check = null;\n            int v = Version.getInstance().getVersion();\n            if(Main.pref.getInteger(\"pluginmanager.version\", 0) < v)\n            {\n                doUpdate = tr(\"You updated your JOSM software\\nTo prevent problems the plugins should be updated as well.\\n\"\n                        + \"Update plugins now?\");\n                check = \"pluginmanger.version\";\n            }\n            else\n            {\n                long tim = System.currentTimeMillis();\n                long last = Main.pref.getLong(\"pluginmanager.lastupdate\", 0);\n                Integer maxTime = Main.pref.getInteger(\"pluginmanager.warntime\", 60);\n                long d = (tim - last)/(24*60*60*1000l);\n                if ((last <= 0) || (maxTime <= 0)) {\n                    Main.pref.put(\"pluginmanager.lastupdate\",Long.toString(tim));\n                } else if (d > maxTime) {\n                    doUpdate = tr(\"Last plugin update more than {0} days ago.\", d);\n                    check = \"pluginmanager.time\";\n                }\n            }\n            if(doUpdate != null)\n            {\n                ExtendedDialog dialog = new ExtendedDialog(\n                        Main.parent,\n                        tr(\"Update plugins\"),\n                        new String[] {tr(\"Update plugins\"), tr(\"Skip update\")}\n                );\n                dialog.setContent(doUpdate);\n                dialog.toggleEnable(check);\n                dialog.setButtonIcons( new String[] {\"dialogs/refresh.png\", \"cancel.png\"});\n                dialog.showDialog();\n                if(dialog.getValue() == 1)\n                    new PluginSelection().update();\n            }\n        }\n\n        SortedMap<Integer, Collection<PluginInformation>> p = new TreeMap<Integer, Collection<PluginInformation>>();\n        for (String pluginName : plugins) {\n            PluginInformation info = PluginInformation.findPlugin(pluginName);\n            if (info != null) {\n                if (info.early != early) {\n                    continue;\n                }\n                int josmVersion = Version.getInstance().getVersion();\n                if (info.mainversion > josmVersion && josmVersion != Version.JOSM_UNKNOWN_VERSION) {\n                    JOptionPane.showMessageDialog(\n                            Main.parent,\n                            tr(\"Plugin {0} requires JOSM update to version {1}.\", pluginName,\n                                    info.mainversion),\n                                    tr(\"Warning\"),\n                                    JOptionPane.WARNING_MESSAGE\n                    );\n                    continue;\n                }\n\n                if(info.requires != null)\n                {\n                    String warn = null;\n                    for(String n : info.requires.split(\";\"))\n                    {\n                        if(!plugins.contains(n))\n                        { warn = n; break; }\n                    }\n                    if(warn != null)\n                    {\n                        JOptionPane.showMessageDialog(Main.parent,\n                                tr(\"Plugin {0} is required by plugin {1} but was not found.\",\n                                        warn, pluginName),\n                                        tr(\"Error\"),\n                                        JOptionPane.ERROR_MESSAGE\n                        );\n                        continue;\n                    }\n                }\n                if (!p.containsKey(info.stage)) {\n                    p.put(info.stage, new LinkedList<PluginInformation>());\n                }\n                p.get(info.stage).add(info);\n            } else if(early) {\n                JOptionPane.showMessageDialog(\n                        Main.parent,\n                        tr(\"Plugin not found: {0}.\", pluginName),\n                        tr(\"Error\"),\n                        JOptionPane.ERROR_MESSAGE\n                );\n            }\n        }\n\n        // iterate all plugins and collect all libraries of all plugins:\n        List<URL> allPluginLibraries = new ArrayList<URL>();\n        for (Collection<PluginInformation> c : p.values()) {\n            for (PluginInformation info : c) {\n                allPluginLibraries.addAll(info.libraries);\n            }\n        }\n        // create a classloader for all plugins:\n        URL[] jarUrls = new URL[allPluginLibraries.size()];\n        jarUrls = allPluginLibraries.toArray(jarUrls);\n        URLClassLoader pluginClassLoader = new URLClassLoader(jarUrls, Main.class.getClassLoader());\n        ImageProvider.sources.add(0, pluginClassLoader);\n\n        for (Collection<PluginInformation> c : p.values()) {\n            for (PluginInformation info : c) {\n                try {\n                    Class<?> klass = info.loadClass(pluginClassLoader);\n                    if (klass != null) {\n                        System.out.println(\"loading \"+info.name);\n                        pluginList.add(info.load(klass));\n                    }\n                } catch (Throwable e) {\n                    e.printStackTrace();\n                    disablePlugin(tr(\"Could not load plugin {0}. Delete from preferences?\", info.name), info.name);\n                }\n            }\n        }\n    }","commit_id":"98f6c00208308d42d8ff11829d7283fdc8cb33b0","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void update(JPanel pluginPanel) {\n        // refresh description\n        int num = PluginDownloader.downloadDescription();\n        Boolean done = false;\n        loadPlugins();\n        drawPanel(pluginPanel);\n\n        Set<PluginInformation> toUpdate = new HashSet<PluginInformation>();\n        StringBuilder toUpdateStr = new StringBuilder();\n        for (String pluginName : Main.pref.getCollection(\"plugins\", Collections.<String>emptySet())) {\n            PluginInformation local = localPlugins.get(pluginName);\n            PluginInformation description = availablePlugins.get(pluginName);\n\n            if (description == null) {\n                System.out.println(tr(\"Plug-in named {0} is not available. Update skipped.\", pluginName));\n                continue;\n            }\n\n            if (local == null || (description.version != null && !description.version.equals(local.version))) {\n                toUpdate.add(description);\n                toUpdateStr.append(pluginName+\"\\n\");\n            }\n        }\n        if (toUpdate.isEmpty()) {\n            JOptionPane.showMessageDialog(\n                    Main.parent,\n                    tr(\"All installed plugins are up to date.\"),\n                    tr(\"Information\"),\n                    JOptionPane.INFORMATION_MESSAGE\n            );\n            done = true;\n        } else {\n            ExtendedDialog ed = new ExtendedDialog(Main.parent,\n                    tr(\"Update\"),\n                    new String[] {tr(\"Update Plugins\"), tr(\"Cancel\")});\n            ed.setButtonIcons(new String[] {\"dialogs/refresh.png\", \"cancel.png\"});\n            ed.setContent(tr(\"Update the following plugins:\\n\\n{0}\", toUpdateStr.toString()));\n            ed.showDialog();\n\n            if (ed.getValue() == 1) {\n                PluginDownloader.update(toUpdate);\n                done = true;\n            }\n        }\n        if (done && num >= 1) {\n            Main.pref.put(\"pluginmanager.lastupdate\", Long.toString(System.currentTimeMillis()));\n        }\n        loadPlugins();\n        drawPanel(pluginPanel);\n    }","id":92380,"modified_method":"public void update(JPanel pluginPanel) {\n        // refresh description\n        int num = PluginDownloader.downloadDescription();\n        Boolean done = false;\n        loadPlugins();\n        if(pluginPanel != null)\n            drawPanel(pluginPanel);\n\n        Set<PluginInformation> toUpdate = new HashSet<PluginInformation>();\n        StringBuilder toUpdateStr = new StringBuilder();\n        for (String pluginName : Main.pref.getCollection(\"plugins\", Collections.<String>emptySet())) {\n            PluginInformation local = localPlugins.get(pluginName);\n            PluginInformation description = availablePlugins.get(pluginName);\n\n            if (description == null) {\n                System.out.println(tr(\"Plug-in named {0} is not available. Update skipped.\", pluginName));\n                continue;\n            }\n\n            if (local == null || (description.version != null && !description.version.equals(local.version))) {\n                toUpdate.add(description);\n                toUpdateStr.append(pluginName+\"\\n\");\n            }\n        }\n        if (toUpdate.isEmpty()) {\n            JOptionPane.showMessageDialog(\n                    Main.parent,\n                    tr(\"All installed plugins are up to date.\"),\n                    tr(\"Information\"),\n                    JOptionPane.INFORMATION_MESSAGE\n            );\n            done = true;\n        } else {\n            ExtendedDialog ed = new ExtendedDialog(Main.parent,\n                    tr(\"Update\"),\n                    new String[] {tr(\"Update Plugins\"), tr(\"Cancel\")});\n            ed.setButtonIcons(new String[] {\"dialogs/refresh.png\", \"cancel.png\"});\n            ed.setContent(tr(\"Update the following plugins:\\n\\n{0}\", toUpdateStr.toString()));\n            ed.showDialog();\n\n            if (ed.getValue() == 1) {\n                PluginDownloader.update(toUpdate, pluginPanel != null);\n                done = true;\n            }\n        }\n        if (done && num >= 1) {\n            Main.pref.put(\"pluginmanager.lastupdate\", Long.toString(System.currentTimeMillis()));\n            Main.pref.putInteger(\"pluginmanager.version\", Version.getInstance().getVersion());\n        }\n        loadPlugins();\n        if(pluginPanel != null)\n            drawPanel(pluginPanel);\n    }","commit_id":"98f6c00208308d42d8ff11829d7283fdc8cb33b0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Called after every put. In case of a problem, do nothing but output the error\n     * in log.\n     */\n    public void save() throws IOException {\n        /* currently unused, but may help to fix configuration issues in future */\n        properties.put(\"josm.version\", Version.getInstance().getVersionString());\n\n        updateSystemProperties();\n        File prefFile = new File(getPreferencesDirFile(), \"preferences\");\n\n        // Backup old preferences if there are old preferences\n        if(prefFile.exists()) {\n            copyFile(prefFile, new File(prefFile + \"_backup\"));\n        }\n\n        final PrintWriter out = new PrintWriter(new OutputStreamWriter(\n                new FileOutputStream(prefFile + \"_tmp\"), \"utf-8\"), false);\n        for (final Entry<String, String> e : properties.entrySet()) {\n            String s = defaults.get(e.getKey());\n            /* don't save default values */\n            if(s == null || !s.equals(e.getValue())) {\n                out.println(e.getKey() + \"=\" + e.getValue());\n            }\n        }\n        out.close();\n\n        File tmpFile = new File(prefFile + \"_tmp\");\n        copyFile(tmpFile, prefFile);\n        tmpFile.delete();\n    }","id":92381,"modified_method":"/**\n     * Called after every put. In case of a problem, do nothing but output the error\n     * in log.\n     */\n    public void save() throws IOException {\n        /* currently unused, but may help to fix configuration issues in future */\n        putInteger(\"josm.version\", Version.getInstance().getVersion());\n\n        updateSystemProperties();\n        File prefFile = new File(getPreferencesDirFile(), \"preferences\");\n\n        // Backup old preferences if there are old preferences\n        if(prefFile.exists()) {\n            copyFile(prefFile, new File(prefFile + \"_backup\"));\n        }\n\n        final PrintWriter out = new PrintWriter(new OutputStreamWriter(\n                new FileOutputStream(prefFile + \"_tmp\"), \"utf-8\"), false);\n        for (final Entry<String, String> e : properties.entrySet()) {\n            String s = defaults.get(e.getKey());\n            /* don't save default values */\n            if(s == null || !s.equals(e.getValue())) {\n                out.println(e.getKey() + \"=\" + e.getValue());\n            }\n        }\n        out.close();\n\n        File tmpFile = new File(prefFile + \"_tmp\");\n        copyFile(tmpFile, prefFile);\n        tmpFile.delete();\n    }","commit_id":"98f6c00208308d42d8ff11829d7283fdc8cb33b0","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void updateMessage() {\n        int numObjectsToDelete = model.getNumObjectsToDelete();\n        int numParentRelations = model.getNumParentRelations();\n        @I18n.QuirkyPluralString\n        final String msg;\n        if (numParentRelations == 1) {\n            msg = trn(\n                    \"<html>Please confirm to remove <strong>{0} object<\/strong> from <strong>1 relation<\/strong>.<\/html>\",\n                    \"<html>Please confirm to remove <strong>{0} objects<\/strong> from <strong>1 relation<\/strong>.<\/html>\",\n                    numObjectsToDelete, numObjectsToDelete);\n        } else {\n            msg = trn(\n                    \"<html>Please confirm to remove <strong>{0} object<\/strong> from <strong>{1} relations<\/strong>.<\/html>\",\n                    \"<html>Please confirm to remove <strong>{0} objects<\/strong> from <strong>{1} relations<\/strong>.<\/html>\",\n                    numObjectsToDelete, numObjectsToDelete, numParentRelations);\n        }\n        htmlPanel.getEditorPane().setText(msg);\n        invalidate();\n    }","id":92382,"modified_method":"protected void updateMessage() {\n        int numObjectsToDelete = model.getNumObjectsToDelete();\n        int numParentRelations = model.getNumParentRelations();\n        final String msg1 = trn(\n                \"Please confirm to remove <strong>{0} object<\/strong>.\",\n                \"Please confirm to remove <strong>{0} objects<\/strong>.\",\n                numObjectsToDelete, numObjectsToDelete);\n        final String msg2 = trn(\n                \"{0} relation is affected.\",\n                \"{0} relations are affected.\",\n                numParentRelations, numParentRelations);\n        @I18n.QuirkyPluralString\n        final String msg = \"<html>\" + msg1 + \" \" + msg2 + \"<\/html>\";\n        htmlPanel.getEditorPane().setText(msg);\n        invalidate();\n    }","commit_id":"83c8bf858ce02b7c435b6c5cc43be7c58bd92680","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void update(Observable o, Object arg) {\r\n        lblMyVersion.setText(\r\n                tr(\"My version \")\r\n                + trn(\"({0} entry)\", \"({0} entries)\", model.getMyEntriesSize(), model.getMyEntriesSize())\r\n        );\r\n        lblMergedVersion.setText(\r\n                tr(\"Merged version \")\r\n                + trn(\"({0} entry)\", \"({0} entries)\", model.getMergedEntriesSize(), model.getMergedEntriesSize())\r\n        );\r\n        lblTheirVersion.setText(\r\n                tr(\"Their version \")\r\n                + trn(\"({0} entry)\", \"({0} entries)\", model.getTheirEntriesSize(), model.getTheirEntriesSize())\r\n        );\r\n    }","id":92383,"modified_method":"public void update(Observable o, Object arg) {\r\n        lblMyVersion.setText(\r\n                trn(\"My version ({0} entry)\", \"My version ({0} entries)\", model.getMyEntriesSize(), model.getMyEntriesSize())\r\n        );\r\n        lblMergedVersion.setText(\r\n                trn(\"Merged version ({0} entry)\", \"Merged version ({0} entries)\", model.getMergedEntriesSize(), model.getMergedEntriesSize())\r\n        );\r\n        lblTheirVersion.setText(\r\n                trn(\"Their version ({0} entry)\", \"Their version ({0} entries)\", model.getTheirEntriesSize(), model.getTheirEntriesSize())\r\n        );\r\n    }","commit_id":"e22d2b7f006467544f5dbef96fa65cd009eaa56f","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override public void importData(File file) throws IOException {\n        try {\n            OsmReader osm = OsmReader.parseDataSetOsm(new FileInputStream(file), null, Main.pleaseWaitDlg);\n            DataSet dataSet = osm.getDs();\n            OsmDataLayer layer = new OsmDataLayer(dataSet, file.getName(), file);\n            Main.main.addLayer(layer);\n            layer.fireDataChange();\n            if (osm.getParseNotes().length() != 0) {\n                /* display at most five lines */\n                String notes = osm.getParseNotes();\n                int j = 0;\n                for (int i = 0; i < 5; i++)\n                    j = notes.indexOf('\\n', j + 1);\n                j = j >= 0 ? j : notes.length();\n                JOptionPane.showMessageDialog(Main.parent, notes.substring(0, j));\n            }\n        } catch (HeadlessException e) {\n            e.printStackTrace();\n            throw new IOException(tr(\"Could not read \\\"{0}\\\"\", file.getName()));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            throw new IOException(tr(\"Could not read \\\"{0}\\\"\", file.getName()));\n        } catch (SAXException e) {\n            e.printStackTrace();\n            throw new IOException(tr(\"Could not read \\\"{0}\\\"\", file.getName()));\n        }\n    }","id":92384,"modified_method":"@Override public void importData(File file) throws IOException {\n        try {\n            FileInputStream in = new FileInputStream(file);\n            importData(in, file);\n        } catch (HeadlessException e) {\n            e.printStackTrace();\n            throw new IOException(tr(\"Could not read \\\"{0}\\\"\", file.getName()));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            throw new IOException(tr(\"Could not read \\\"{0}\\\"\", file.getName()));\n        } catch (SAXException e) {\n            e.printStackTrace();\n            throw new IOException(tr(\"Could not read \\\"{0}\\\"\", file.getName()));\n        }\n    }","commit_id":"e22d2b7f006467544f5dbef96fa65cd009eaa56f","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static void save(File file, OsmDataLayer layer) {\n        File tmpFile = null;\n        try {\n            GpxImporter gpxImExporter = new GpxImporter();\n            OsmImporter osmImExporter = new OsmImporter();\n            if (gpxImExporter.acceptFile(file))\n                GpxExportAction.exportGpx(file, layer);\n            else if (osmImExporter.acceptFile(file)) {\n                // use a tmp file because if something errors out in the\n                // process of writing the file, we might just end up with\n                // a truncated file.  That can destroy lots of work.\n                if (file.exists()) {\n                    tmpFile = new File(file.getPath() + \"~\");\n                    copy(file, tmpFile);\n                }\n                OsmWriter w = new OsmWriter(new PrintWriter(file, \"UTF-8\"), false, layer.data.version);\n                w.header();\n                w.writeDataSources(layer.data);\n                w.writeContent(layer.data);\n                w.footer();\n                w.close();\n                // FIXME - how to close?\n                if (!Main.pref.getBoolean(\"save.keepbackup\") && (tmpFile != null))\n                    tmpFile.delete();\n            } else {\n                JOptionPane.showMessageDialog(Main.parent, tr(\"Unknown file extension.\"));\n                return;\n            }\n            layer.cleanData(null, false);\n        } catch (IOException e) {\n            e.printStackTrace();\n            JOptionPane.showMessageDialog(Main.parent, tr(\"An error occurred while saving.\")+\"\\n\"+e.getMessage());\n\n            try {\n                // if the file save failed, then the tempfile will not\n                // be deleted.  So, restore the backup if we made one.\n                if (tmpFile != null && tmpFile.exists()) {\n                    copy(tmpFile, file);\n                }\n            } catch (IOException e2) {\n                e2.printStackTrace();\n                JOptionPane.showMessageDialog(Main.parent, tr(\"An error occurred while restoring backup file.\")+\"\\n\"+e2.getMessage());\n            }\n        }\n    }","id":92385,"modified_method":"public static void save(File file, OsmDataLayer layer) {\n        File tmpFile = null;\n        try {\n            GpxImporter gpxImExporter = new GpxImporter();\n            OsmImporter osmImExporter = new OsmImporter();\n            OsmGzipImporter osmGzipImporter = new OsmGzipImporter();\n            OsmBzip2Importer osmBzip2Importer = new OsmBzip2Importer();\n            if (gpxImExporter.acceptFile(file))\n                GpxExportAction.exportGpx(file, layer);\n            else if (osmImExporter.acceptFile(file) \n                    || osmGzipImporter.acceptFile(file)\n                    || osmBzip2Importer.acceptFile(file)) \n            {\n                // use a tmp file because if something errors out in the\n                // process of writing the file, we might just end up with\n                // a truncated file.  That can destroy lots of work.\n                if (file.exists()) {\n                    tmpFile = new File(file.getPath() + \"~\");\n                    copy(file, tmpFile);\n                }\n\n                // create outputstream and wrap it with gzip or bzip, if necessary\n                OutputStream out = new FileOutputStream(file);\n                if(osmGzipImporter.acceptFile(file)) {\n                    out = new GZIPOutputStream(out);\n                } else if(osmBzip2Importer.acceptFile(file)) {\n                    out.write('B');\n                    out.write('Z');\n                    out = new CBZip2OutputStream(out);\n                }\n                Writer writer = new OutputStreamWriter(out, \"UTF-8\"); \n\n                OsmWriter w = new OsmWriter(new PrintWriter(writer), false, layer.data.version);\n                w.header();\n                w.writeDataSources(layer.data);\n                w.writeContent(layer.data);\n                w.footer();\n                w.close();\n                // FIXME - how to close?\n                if (!Main.pref.getBoolean(\"save.keepbackup\") && (tmpFile != null))\n                    tmpFile.delete();\n            } else {\n                JOptionPane.showMessageDialog(Main.parent, tr(\"Unknown file extension.\"));\n                return;\n            }\n            layer.cleanData(null, false);\n        } catch (IOException e) {\n            e.printStackTrace();\n            JOptionPane.showMessageDialog(Main.parent, tr(\"An error occurred while saving.\")+\"\\n\"+e.getMessage());\n\n            try {\n                // if the file save failed, then the tempfile will not\n                // be deleted.  So, restore the backup if we made one.\n                if (tmpFile != null && tmpFile.exists()) {\n                    copy(tmpFile, file);\n                }\n            } catch (IOException e2) {\n                e2.printStackTrace();\n                JOptionPane.showMessageDialog(Main.parent, tr(\"An error occurred while restoring backup file.\")+\"\\n\"+e2.getMessage());\n            }\n        }\n    }","commit_id":"e22d2b7f006467544f5dbef96fa65cd009eaa56f","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Sends a DTMF tone to the current DTMF operation set of the given call.\n     *\n     * @param call The call to which we send DTMF-s.\n     * @param info The DTMF tone to send.\n     */\n    private void startSendingDtmfTone(Call call, DTMFToneInfo info)\n    {\n        Iterator<? extends CallPeer> callPeers = call.getCallPeers();\n\n        try\n        {\n            while (callPeers.hasNext())\n            {\n                CallPeer peer = callPeers.next();\n                OperationSetDTMF dtmfOpSet\n                    = peer.getProtocolProvider().getOperationSet(\n                            OperationSetDTMF.class);\n\n                if (dtmfOpSet != null)\n                {\n                    dtmfOpSet.startSendingDTMF(peer, info.tone);\n\n                    CallPeerRenderer peerRenderer\n                        = callContainer\n                            .getCurrentCallRenderer()\n                                .getCallPeerRenderer(peer);\n\n                    if (peerRenderer != null)\n                        peerRenderer.printDTMFTone(info.keyChar);\n                }\n            }\n        }\n        catch (Throwable t)\n        {\n            logger.error(\"Failed to send a DTMF tone.\", t);\n        }\n    }","id":92386,"modified_method":"/**\n     * Sends a DTMF tone to the current DTMF operation set of the given call.\n     *\n     * @param call The call to which we send DTMF-s.\n     * @param info The DTMF tone to send.\n     */\n    private void startSendingDtmfTone(Call call, DTMFToneInfo info)\n    {\n        Iterator<? extends CallPeer> callPeers = call.getCallPeers();\n\n        try\n        {\n            while (callPeers.hasNext())\n            {\n                CallPeer peer = callPeers.next();\n                OperationSetDTMF dtmfOpSet\n                    = peer.getProtocolProvider().getOperationSet(\n                            OperationSetDTMF.class);\n\n                if (dtmfOpSet != null)\n                {\n                    dtmfOpSet.startSendingDTMF(peer, info.tone);\n\n                    CallPeerRenderer peerRenderer\n                        = callContainer\n                            .getCurrentCallRenderer()\n                                .getCallPeerRenderer(peer);\n\n                    if (peerRenderer != null)\n                        peerRenderer.printDTMFTone(info.keyChar);\n                }\n            }\n        }\n        catch (Throwable t)\n        {\n            if (t instanceof InterruptedException)\n                Thread.currentThread().interrupt();\n            else if (t instanceof ThreadDeath)\n                throw (ThreadDeath) t;\n            else\n                logger.error(\"Failed to send a DTMF tone.\", t);\n        }\n    }","commit_id":"fcec891d0fe50599ec453901d2ecfc7f16edd9c3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sends a DTMF tone to the current DTMF operation set.\n     *\n     * @param info The DTMF tone to send.\n     */\n    private synchronized void startSendingDtmfTone(DTMFToneInfo info)\n    {\n        if(info.sound != null)\n        {\n            synchronized(dtmfToneNotifications)\n            {\n                boolean startThread = (dtmfToneNotifications.size() == 0);\n\n                dtmfToneNotifications.add(info);\n                if(startThread)\n                {\n                    Thread dtmfToneNotificationThread = new Thread(this);\n\n                    dtmfToneNotificationThread.setDaemon(true);\n                    dtmfToneNotificationThread.setName(\n                            \"DTMFHandler: DTMF tone notification player\");\n                    dtmfToneNotificationThread.start();\n                }\n            }\n        }\n\n        if (callContainer != null)\n        {\n            for (Call c : callContainer.getCallConference().getCalls())\n            {\n                startSendingDtmfTone(c, info);\n            }\n        }\n        else\n        {\n            Collection<Call> activeCalls = CallManager.getInProgressCalls();\n\n            if (activeCalls != null)\n            {\n                for (Call activeCall : activeCalls)\n                    startSendingDtmfTone(activeCall, info);\n            }\n        }\n    }","id":92387,"modified_method":"/**\n     * Sends a DTMF tone to the current DTMF operation set.\n     *\n     * @param info The DTMF tone to send.\n     */\n    private synchronized void startSendingDtmfTone(DTMFToneInfo info)\n    {\n        if(info.sound != null)\n        {\n            synchronized(dtmfToneNotifications)\n            {\n                dtmfToneNotifications.add(info);\n                startDTMFToneNotificationThreadIfNecessary();\n            }\n        }\n\n        Collection<Call> calls\n            = (callContainer == null)\n                ? CallManager.getInProgressCalls()\n                : callContainer.getCallConference().getCalls();\n\n        if ((calls != null) && !calls.isEmpty())\n        {\n            for (Call call : calls)\n                startSendingDtmfTone(call, info);\n        }\n    }","commit_id":"fcec891d0fe50599ec453901d2ecfc7f16edd9c3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stops sending DTMF tone to the given call.\n     *\n     * @param call The call to which we send DTMF-s.\n     */\n    private void stopSendingDtmfTone(Call call)\n    {\n        Iterator<? extends CallPeer> callPeers = call.getCallPeers();\n\n        try\n        {\n            while (callPeers.hasNext())\n            {\n                CallPeer peer = callPeers.next();\n                OperationSetDTMF dtmfOpSet\n                    = peer.getProtocolProvider().getOperationSet(\n                            OperationSetDTMF.class);\n\n                if (dtmfOpSet != null)\n                    dtmfOpSet.stopSendingDTMF(peer);\n            }\n        }\n        catch (Throwable t)\n        {\n            logger.error(\"Failed to send a DTMF tone.\", t);\n        }\n    }","id":92388,"modified_method":"/**\n     * Stops sending DTMF tone to the given call.\n     *\n     * @param call The call to which we send DTMF-s.\n     */\n    private void stopSendingDtmfTone(Call call)\n    {\n        Iterator<? extends CallPeer> callPeers = call.getCallPeers();\n\n        try\n        {\n            while (callPeers.hasNext())\n            {\n                CallPeer peer = callPeers.next();\n                OperationSetDTMF dtmfOpSet\n                    = peer.getProtocolProvider().getOperationSet(\n                            OperationSetDTMF.class);\n\n                if (dtmfOpSet != null)\n                    dtmfOpSet.stopSendingDTMF(peer);\n            }\n        }\n        catch (Throwable t)\n        {\n            if (t instanceof InterruptedException)\n                Thread.currentThread().interrupt();\n            else if (t instanceof ThreadDeath)\n                throw (ThreadDeath) t;\n            else\n                logger.error(\"Failed to send a DTMF tone.\", t);\n        }\n    }","commit_id":"fcec891d0fe50599ec453901d2ecfc7f16edd9c3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Load the defaults for dtmf tones.\n     */\n    public static void loadDefaults()\n    {\n        synchronized(defaultsLoaded)\n        {\n            if(defaultsLoaded)\n                return;\n\n            // init the\n            NotificationService notificationService =\n                GuiActivator.getNotificationService();\n\n            for(DTMFToneInfo info : AVAILABLE_TONES)\n            {\n                notificationService.registerDefaultNotificationForEvent(\n                    DTMF_TONE_PREFIX + info.tone.getValue(),\n                    new SoundNotificationAction(\n                        info.sound, 0, false, true, false));\n            }\n\n            defaultsLoaded = true;\n        }\n    }","id":92389,"modified_method":"/**\n     * Load the defaults for DTMF tones.\n     */\n    public static synchronized void loadDefaults()\n    {\n        if(defaultsLoaded)\n            return;\n\n        NotificationService notificationService\n            = GuiActivator.getNotificationService();\n\n        for(DTMFToneInfo info : AVAILABLE_TONES)\n        {\n            notificationService.registerDefaultNotificationForEvent(\n                    DTMF_TONE_PREFIX + info.tone.getValue(),\n                    new SoundNotificationAction(\n                            info.sound,\n                            0,\n                            false, true, false));\n        }\n\n        defaultsLoaded = true;\n    }","commit_id":"fcec891d0fe50599ec453901d2ecfc7f16edd9c3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stop sending DTMF tone.\n     */\n    public synchronized void stopSendingDtmfTone()\n    {\n        if (callContainer != null)\n        {\n            for (Call c : callContainer.getCallConference().getCalls())\n            {\n                stopSendingDtmfTone(c);\n            }\n        }\n        else\n        {\n            Collection<Call> activeCalls = CallManager.getInProgressCalls();\n\n            if (activeCalls != null)\n            {\n                for (Call activeCall : activeCalls)\n                    stopSendingDtmfTone(activeCall);\n            }\n        }\n    }","id":92390,"modified_method":"/**\n     * Stop sending DTMF tone.\n     */\n    public synchronized void stopSendingDtmfTone()\n    {\n        Collection<Call> calls\n            = (callContainer == null)\n                ? CallManager.getInProgressCalls()\n                : callContainer.getCallConference().getCalls();\n\n        if ((calls != null) &&  !calls.isEmpty())\n        {\n            for (Call call : calls)\n                stopSendingDtmfTone(call);\n        }\n    }","commit_id":"fcec891d0fe50599ec453901d2ecfc7f16edd9c3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Notifies this telephony conference that a <tt>CallPeer<\/tt> has been\n     * added to a <tt>Call<\/tt>.\n     *\n     * @param ev a <tt>CallPeerEvent<\/tt> which specifies the <tt>CallPeer<\/tt>\n     * which has been added and the <tt>Call<\/tt> to which it has been added\n     */\n    private void callPeerAdded(CallPeerEvent ev)\n    {\n        if (containsCall(ev.getSourceCall()))\n        {\n            /*\n             * Update the conferenceFocus state. Following the line of thinking\n             * expressed in the callAdded and callRemoved methods, only update\n             * it if the new conferenceFocus value is in accord with the\n             * expectations.\n             */\n            boolean conferenceFocus = isConferenceFocus(getCalls());\n\n            switch (ev.getEventID())\n            {\n            case CallPeerEvent.CALL_PEER_ADDED:\n                if (conferenceFocus)\n                    setConferenceFocus(conferenceFocus);\n                break;\n            case CallPeerEvent.CALL_PEER_REMOVED:\n                if (!conferenceFocus)\n                    setConferenceFocus(conferenceFocus);\n                break;\n            default:\n                /*\n                 * We're interested in the adding and removing of CallPeers\n                 * only.\n                 */\n                break;\n            }\n        }\n    }","id":92391,"modified_method":"/**\n     * Notifies this telephony conference that a <tt>CallPeer<\/tt> has been\n     * added to a <tt>Call<\/tt>.\n     *\n     * @param ev a <tt>CallPeerEvent<\/tt> which specifies the <tt>CallPeer<\/tt>\n     * which has been added and the <tt>Call<\/tt> to which it has been added\n     */\n    private void callPeerAdded(CallPeerEvent ev)\n    {\n        if (containsCall(ev.getSourceCall()))\n        {\n            /*\n             * Update the conferenceFocus state. Following the line of thinking\n             * expressed in the callAdded and callRemoved methods, only update\n             * it if the new conferenceFocus value is in accord with the\n             * expectations.\n             */\n            int eventID = ev.getEventID();\n            boolean conferenceFocus = isConferenceFocus(getCalls());\n\n            switch (eventID)\n            {\n            case CallPeerEvent.CALL_PEER_ADDED:\n                if (conferenceFocus)\n                    setConferenceFocus(conferenceFocus);\n                break;\n            case CallPeerEvent.CALL_PEER_REMOVED:\n                if (!conferenceFocus)\n                    setConferenceFocus(conferenceFocus);\n                break;\n            default:\n                /*\n                 * We're interested in the adding and removing of CallPeers\n                 * only.\n                 */\n                break;\n            }\n\n            // Forward the CallPeerEvent to the callChangeListeners.\n            for (CallChangeListener l : getCallChangeListeners())\n            {\n                switch (eventID)\n                {\n                case CallPeerEvent.CALL_PEER_ADDED:\n                    l.callPeerAdded(ev);\n                    break;\n                case CallPeerEvent.CALL_PEER_REMOVED:\n                    l.callPeerRemoved(ev);\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Gets the list of <tt>Call<\/tt> participating in this telephony\n     * conference.\n     *\n     * @return the list of <tt>Call<\/tt>s participating in this telephony\n     * conference. An empty array of <tt>Call<\/tt> element type is returned if\n     * there are no <tt>Call<\/tt>s in this telephony conference-related state.\n     */\n    public Call[] getCalls()\n    {\n        synchronized (calls)\n        {\n            return calls.toArray(new Call[calls.size()]);\n        }\n    }","id":92392,"modified_method":"/**\n     * Gets the list of <tt>Call<\/tt> participating in this telephony\n     * conference.\n     *\n     * @return the list of <tt>Call<\/tt>s participating in this telephony\n     * conference. An empty array of <tt>Call<\/tt> element type is returned if\n     * there are no <tt>Call<\/tt>s in this telephony conference-related state.\n     */\n    public List<Call> getCalls()\n    {\n        synchronized (callsSyncRoot)\n        {\n            return immutableCalls;\n        }\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds a specific <tt>Call<\/tt> to the list of <tt>Call<\/tt>s participating\n     * in this telephony conference.\n     *\n     * @param call the <tt>Call<\/tt> to add to the list of <tt>Call<\/tt>s\n     * participating in this telephony conference\n     * @return <tt>true<\/tt> if the list of <tt>Call<\/tt>s participating in this\n     * telephony conference changed as a result of the method call; otherwise,\n     * <tt>false<\/tt>\n     */\n    boolean addCall(Call call)\n    {\n        synchronized (calls)\n        {\n            if (calls.contains(call) || !calls.add(call))\n                return false;\n        }\n\n        callAdded(call);\n        return true;\n    }","id":92393,"modified_method":"/**\n     * Adds a specific <tt>Call<\/tt> to the list of <tt>Call<\/tt>s participating\n     * in this telephony conference.\n     *\n     * @param call the <tt>Call<\/tt> to add to the list of <tt>Call<\/tt>s\n     * participating in this telephony conference\n     * @return <tt>true<\/tt> if the list of <tt>Call<\/tt>s participating in this\n     * telephony conference changed as a result of the method call; otherwise,\n     * <tt>false<\/tt>\n     * @throws NullPointerException if <tt>call<\/tt> is <tt>null<\/tt>\n     */\n    boolean addCall(Call call)\n    {\n        if (call == null)\n            throw new NullPointerException(\"call\");\n\n        synchronized (callsSyncRoot)\n        {\n            if (mutableCalls.contains(call))\n                return false;\n\n            /*\n             * Implement the List of Calls participating in this telephony\n             * conference as a copy-on-write storage in order to optimize the\n             * getCalls method which is likely to be executed much more often\n             * than the addCall and removeCall methods.\n             */\n            List<Call> newMutableCalls = new ArrayList<Call>(mutableCalls);\n\n            if (newMutableCalls.add(call))\n            {\n                mutableCalls = newMutableCalls;\n                immutableCalls = Collections.unmodifiableList(mutableCalls);\n            }\n            else\n                return false;\n        }\n\n        callAdded(call);\n        return true;\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Gets the list of <tt>Call<\/tt>s participating in the telephony conference\n     * in which a specific <tt>Call<\/tt> is participating.\n     *\n     * @param call the <tt>Call<\/tt> which participates in the telephony\n     * conference the list of participating <tt>Call<\/tt>s of which is to be\n     * returned\n     * @return the list of <tt>Call<\/tt>s participating in the telephony\n     * conference in which the specified <tt>call<\/tt> is participating\n     */\n    public static Call[] getCalls(Call call)\n    {\n        CallConference conference = call.getConference();\n\n        return\n            (conference == null) ? new Call[] { call } : conference.getCalls();\n    }","id":92394,"modified_method":"/**\n     * Gets the list of <tt>Call<\/tt>s participating in the telephony conference\n     * in which a specific <tt>Call<\/tt> is participating.\n     *\n     * @param call the <tt>Call<\/tt> which participates in the telephony\n     * conference the list of participating <tt>Call<\/tt>s of which is to be\n     * returned\n     * @return the list of <tt>Call<\/tt>s participating in the telephony\n     * conference in which the specified <tt>call<\/tt> is participating\n     */\n    public static List<Call> getCalls(Call call)\n    {\n        CallConference conference = call.getConference();\n        List<Call> calls;\n\n        if (conference == null)\n            calls = Collections.emptyList();\n        else\n            calls = conference.getCalls();\n        return calls;\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Gets the number of <tt>Call<\/tt>s that are participating in this\n     * telephony conference.\n     *\n     * @return the number of <tt>Call<\/tt>s that are participating in this\n     * telephony conference\n     */\n    public int getCallCount()\n    {\n        synchronized (calls)\n        {\n            return calls.size();\n        }\n    }","id":92395,"modified_method":"/**\n     * Gets the number of <tt>Call<\/tt>s that are participating in this\n     * telephony conference.\n     *\n     * @return the number of <tt>Call<\/tt>s that are participating in this\n     * telephony conference\n     */\n    public int getCallCount()\n    {\n        synchronized (callsSyncRoot)\n        {\n            return mutableCalls.size();\n        }\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes a specific <tt>Call<\/tt> from the list of <tt>Call<\/tt>s\n     * participating in this telephony conference.\n     *\n     * @param call the <tt>Call<\/tt> to remove from the list of <tt>Call<\/tt>s\n     * participating in this telephony conference\n     * @return <tt>true<\/tt> if the list of <tt>Call<\/tt>s participating in this\n     * telephony conference changed as a result of the method call; otherwise,\n     * <tt>false<\/tt>\n     */\n    boolean removeCall(Call call)\n    {\n        synchronized (calls)\n        {\n            if (!calls.remove(call))\n                return false;\n        }\n\n        callRemoved(call);\n        return true;\n    }","id":92396,"modified_method":"/**\n     * Removes a specific <tt>Call<\/tt> from the list of <tt>Call<\/tt>s\n     * participating in this telephony conference.\n     *\n     * @param call the <tt>Call<\/tt> to remove from the list of <tt>Call<\/tt>s\n     * participating in this telephony conference\n     * @return <tt>true<\/tt> if the list of <tt>Call<\/tt>s participating in this\n     * telephony conference changed as a result of the method call; otherwise,\n     * <tt>false<\/tt>\n     */\n    boolean removeCall(Call call)\n    {\n        if (call == null)\n            return false;\n\n        synchronized (callsSyncRoot)\n        {\n            if (!mutableCalls.contains(call))\n                return false;\n\n            /*\n             * Implement the List of Calls participating in this telephony\n             * conference as a copy-on-write storage in order to optimize the\n             * getCalls method which is likely to be executed much more often\n             * than the addCall and removeCall methods.\n             */\n            List<Call> newMutableCalls = new ArrayList<Call>(mutableCalls);\n\n            if (newMutableCalls.remove(call))\n            {\n                mutableCalls = newMutableCalls;\n                immutableCalls = Collections.unmodifiableList(mutableCalls);\n            }\n            else\n                return false;\n        }\n\n        callRemoved(call);\n        return true;\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes a new <tt>CallConference<\/tt> instance.\n     */\n    public CallConference()\n    {\n    }","id":92397,"modified_method":"/**\n     * Initializes a new <tt>CallConference<\/tt> instance.\n     */\n    public CallConference()\n    {\n        mutableCalls = new ArrayList<Call>();\n        immutableCalls = Collections.unmodifiableList(mutableCalls);\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Determines whether a specific <tt>Call<\/tt> is participating in this\n     * telephony conference.\n     *\n     * @param call the <tt>Call<\/tt> which is to be checked whether it is\n     * participating in this telephony conference\n     * @return <tt>true<\/tt> if the specified <tt>call<\/tt> is participating in\n     * this telephony conference\n     */\n    public boolean containsCall(Call call)\n    {\n        synchronized (calls)\n        {\n            return calls.contains(call);\n        }\n    }","id":92398,"modified_method":"/**\n     * Determines whether a specific <tt>Call<\/tt> is participating in this\n     * telephony conference.\n     *\n     * @param call the <tt>Call<\/tt> which is to be checked whether it is\n     * participating in this telephony conference\n     * @return <tt>true<\/tt> if the specified <tt>call<\/tt> is participating in\n     * this telephony conference\n     */\n    public boolean containsCall(Call call)\n    {\n        synchronized (callsSyncRoot)\n        {\n            return mutableCalls.contains(call);\n        }\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Determines whether a <tt>CallConference<\/tt> is to report the local\n     * peer/user as a conference focus judging by a specific list of\n     * <tt>Call<\/tt>s.\n     * \n     * @param calls the list of <tt>Call<\/tt> which are to be judged whether\n     * the local peer/user that they represent is to be considered as a\n     * conference focus \n     * @return <tt>true<\/tt> if the local peer/user represented by the specified\n     * <tt>calls<\/tt> is judged to be a conference focus; otherwise,\n     * <tt>false<\/tt>\n     */\n    private static boolean isConferenceFocus(Call[] calls)\n    {\n        boolean conferenceFocus;\n\n        if (calls.length < 1)\n            conferenceFocus = false;\n        else if (calls.length > 1)\n            conferenceFocus = true;\n        else\n            conferenceFocus = (calls[0].getCallPeerCount() > 1);\n        return conferenceFocus;\n    }","id":92399,"modified_method":"/**\n     * Determines whether a <tt>CallConference<\/tt> is to report the local\n     * peer/user as a conference focus judging by a specific list of\n     * <tt>Call<\/tt>s.\n     * \n     * @param calls the list of <tt>Call<\/tt> which are to be judged whether\n     * the local peer/user that they represent is to be considered as a\n     * conference focus \n     * @return <tt>true<\/tt> if the local peer/user represented by the specified\n     * <tt>calls<\/tt> is judged to be a conference focus; otherwise,\n     * <tt>false<\/tt>\n     */\n    private static boolean isConferenceFocus(List<Call> calls)\n    {\n        int callCount = calls.size();\n        boolean conferenceFocus;\n\n        if (callCount < 1)\n            conferenceFocus = false;\n        else if (callCount > 1)\n            conferenceFocus = true;\n        else\n            conferenceFocus = (calls.get(0).getCallPeerCount() > 1);\n        return conferenceFocus;\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Notifies this telephony conference that the <tt>CallState<\/tt> of a\n     * <tt>Call<\/tt> has changed.\n     *\n     * @param ev a <tt>CallChangeEvent<\/tt> which specifies the <tt>Call<\/tt>\n     * which had its <tt>CallState<\/tt> changed and the old and new\n     * <tt>CallState<\/tt>s of that <tt>Call<\/tt>\n     */\n    private void callStateChanged(CallChangeEvent ev)\n    {\n        Call call = ev.getSourceCall();\n\n        if (containsCall(call) && CallState.CALL_ENDED.equals(ev.getNewValue()))\n        {\n            /*\n             * Should not be vital because Call will remove itself. Anyway, do\n             * it for the sake of completeness.\n             */\n            removeCall(call);\n        }\n    }","id":92400,"modified_method":"/**\n     * Notifies this telephony conference that the <tt>CallState<\/tt> of a\n     * <tt>Call<\/tt> has changed.\n     *\n     * @param ev a <tt>CallChangeEvent<\/tt> which specifies the <tt>Call<\/tt>\n     * which had its <tt>CallState<\/tt> changed and the old and new\n     * <tt>CallState<\/tt>s of that <tt>Call<\/tt>\n     */\n    private void callStateChanged(CallChangeEvent ev)\n    {\n        Call call = ev.getSourceCall();\n\n        if (containsCall(call))\n        {\n            try\n            {\n                // Forward the CallChangeEvent to the callChangeListeners.\n                for (CallChangeListener l : getCallChangeListeners())\n                    l.callStateChanged(ev);\n            }\n            finally\n            {\n                if (CallState.CALL_ENDED.equals(ev.getNewValue()))\n                {\n                    /*\n                     * Should not be vital because Call will remove itself.\n                     * Anyway, do it for the sake of completeness.\n                     */\n                    removeCall(call);\n                }\n            }\n        }\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Constructs the call info text.\n     */\n    private void constructCallInfo()\n    {\n        StringBuffer stringBuffer = new StringBuffer();\n\n        stringBuffer.append(\n            \"<html><body><p align=\\\"left\\\">\"\n                + \"<font color=\\\"\" + fontColor + \"\\\" size=\\\"3\\\">\");\n\n        stringBuffer.append(getLineString(resources.getI18NString(\n            \"service.gui.callinfo.CALL_INFORMATION\"), \"\"));\n\n        stringBuffer.append(getLineString(resources.getI18NString(\n            \"service.gui.callinfo.CALL_IDENTITY\"),\n            call.getProtocolProvider().getAccountID().getDisplayName()));\n\n        int callPeerCount = call.getCallPeerCount();\n        if (call.getCallPeerCount() > 1)\n            stringBuffer.append(\n                getLineString(resources.getI18NString(\n                    \"service.gui.callinfo.PEER_COUNT\"),\n                    String.valueOf(callPeerCount)));\n\n        boolean isConfFocus = call.isConferenceFocus();\n\n        if (isConfFocus)\n            stringBuffer.append(getLineString(\n                resources.getI18NString(\n                    \"service.gui.callinfo.IS_CONFERENCE_FOCUS\"),\n                String.valueOf(isConfFocus)));\n\n        TransportProtocol preferredTransport =\n            call.getProtocolProvider().getTransportProtocol();\n\n        if (preferredTransport != TransportProtocol.UNKNOWN)\n            stringBuffer.append(getLineString(\n                resources.getI18NString(\"service.gui.callinfo.CALL_TRANSPORT\"),\n                preferredTransport.toString()));\n\n        constructCallPeersInfo(stringBuffer);\n\n        stringBuffer.append(\"<\/font><\/p><\/body><\/html>\");\n\n        infoTextPane.setText(stringBuffer.toString());\n        infoTextPane.revalidate();\n        infoTextPane.repaint();\n    }","id":92401,"modified_method":"/**\n     * Constructs the call info text.\n     */\n    private void constructCallInfo()\n    {\n        StringBuffer stringBuffer = new StringBuffer();\n\n        stringBuffer.append(\n            \"<html><body><p align=\\\"left\\\">\"\n                + \"<font color=\\\"\" + fontColor + \"\\\" size=\\\"3\\\">\");\n\n        stringBuffer.append(getLineString(resources.getI18NString(\n            \"service.gui.callinfo.CALL_INFORMATION\"), \"\"));\n\n        List<Call> calls = callConference.getCalls();\n        /*\n         * TODO A telephony conference may consist of a single Call with\n         * multiple CallPeers but it may as well consist of multiple Calls.\n         */\n        Call aCall = calls.get(0);\n\n        stringBuffer.append(\n                getLineString(\n                        resources.getI18NString(\n                                \"service.gui.callinfo.CALL_IDENTITY\"),\n                                aCall.getProtocolProvider().getAccountID()\n                                        .getDisplayName()));\n\n        int callPeerCount = callConference.getCallPeerCount();\n        if (callPeerCount > 1)\n        {\n            stringBuffer.append(\n                    getLineString(resources.getI18NString(\n                            \"service.gui.callinfo.PEER_COUNT\"),\n                            String.valueOf(callPeerCount)));\n        }\n\n        boolean isConfFocus = callConference.isConferenceFocus();\n\n        if (isConfFocus)\n        {\n            stringBuffer.append(getLineString(\n                    resources.getI18NString(\n                            \"service.gui.callinfo.IS_CONFERENCE_FOCUS\"),\n                    String.valueOf(isConfFocus)));\n        }\n\n        TransportProtocol preferredTransport\n            = aCall.getProtocolProvider().getTransportProtocol();\n\n        if (preferredTransport != TransportProtocol.UNKNOWN)\n            stringBuffer.append(getLineString(\n                resources.getI18NString(\"service.gui.callinfo.CALL_TRANSPORT\"),\n                preferredTransport.toString()));\n\n        constructCallPeersInfo(stringBuffer);\n\n        stringBuffer.append(\"<\/font><\/p><\/body><\/html>\");\n\n        infoTextPane.setText(stringBuffer.toString());\n        infoTextPane.revalidate();\n        infoTextPane.repaint();\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Constructs call peers' info.\n     *\n     * @param stringBuffer the <tt>StringBuffer<\/tt>, where call peer info will\n     * be added\n     */\n    private void constructCallPeersInfo(StringBuffer stringBuffer)\n    {\n        Iterator<? extends CallPeer> callPeers = this.call.getCallPeers();\n\n        while(callPeers.hasNext())\n        {\n            CallPeer callPeer = callPeers.next();\n            if(callPeer instanceof MediaAwareCallPeer)\n            {\n                ((MediaAwareCallPeer)callPeer).getMediaHandler()\n                    .addPropertyChangeListener(this);\n            }\n            stringBuffer.append(\"<br/>\");\n            constructPeerInfo(callPeer, stringBuffer);\n        }\n    }","id":92402,"modified_method":"/**\n     * Constructs call peers' info.\n     *\n     * @param stringBuffer the <tt>StringBuffer<\/tt>, where call peer info will\n     * be added\n     */\n    private void constructCallPeersInfo(StringBuffer stringBuffer)\n    {\n        for (CallPeer callPeer : callConference.getCallPeers())\n        {\n            if(callPeer instanceof MediaAwareCallPeer)\n            {\n                ((MediaAwareCallPeer<?,?,?>) callPeer)\n                    .getMediaHandler()\n                        .addPropertyChangeListener(this);\n            }\n            stringBuffer.append(\"<br/>\");\n            constructPeerInfo(callPeer, stringBuffer);\n        }\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates a new frame containing the statistical information for a call.\n     *\n     * @param call The call from which are computed the statistics displayed.\n     */\n    public CallInfoFrame(Call call)\n    {\n        this.call = call;\n\n        JScrollPane scrollPane = new JScrollPane();\n        scrollPane.setOpaque(false);\n        scrollPane.getViewport().setOpaque(false);\n\n        infoTextPane = createGeneralInfoPane();\n        scrollPane.getViewport().add(infoTextPane);\n\n        callInfoWindow\n            = createCallInfoWindow(\n                GuiActivator.getResources().getI18NString(\n                    \"service.gui.callinfo.TECHNICAL_CALL_INFO\"));\n\n        callInfoWindow.getContentPane().add(scrollPane);\n\n        this.constructCallInfo();\n    }","id":92403,"modified_method":"/**\n     * Creates a new frame containing the statistical information for a specific\n     * telephony conference.\n     *\n     * @param callConference the telephony conference to compute and display the\n     * statistics of\n     */\n    public CallInfoFrame(CallConference callConference)\n    {\n        this.callConference = callConference;\n\n        JScrollPane scrollPane = new JScrollPane();\n        scrollPane.setOpaque(false);\n        scrollPane.getViewport().setOpaque(false);\n\n        infoTextPane = createGeneralInfoPane();\n        scrollPane.getViewport().add(infoTextPane);\n\n        callInfoWindow\n            = createCallInfoWindow(\n                GuiActivator.getResources().getI18NString(\n                    \"service.gui.callinfo.TECHNICAL_CALL_INFO\"));\n\n        callInfoWindow.getContentPane().add(scrollPane);\n\n        this.constructCallInfo();\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Appends to the string buffer the stream encryption method (null, MIKEY,\n     * SDES, ZRTP) used for a given media stream (type AUDIO or VIDEO).\n     *\n     * @param stringBuffer The string buffer containing the call information\n     * statistics.\n     * @param callPeerMediaHandler The media handler containing the different\n     * media streams.\n     * @param mediaStream the <tt>MediaStream<\/tt> that gives us access to\n     * audio/video info.\n     * @param mediaType The media type used to determine which stream of the\n     * media handler must returns it encryption method.\n     */\n    private void appendStreamEncryptionMethod(\n            StringBuffer stringBuffer,\n            CallPeerMediaHandler callPeerMediaHandler,\n            MediaStream mediaStream,\n            MediaType mediaType)\n    {\n        String transportProtocolString = \"\";\n        StreamConnector.Protocol transportProtocol =\n            mediaStream.getTransportProtocol();\n        if(transportProtocol != null)\n        {\n            transportProtocolString = transportProtocol.toString();\n        }\n\n        String rtpType;\n        SrtpControl srtpControl\n            = callPeerMediaHandler.getEncryptionMethod(mediaType);\n        // If the stream is secured.\n        if(srtpControl != null)\n        {\n            String info;\n            if (srtpControl instanceof ZrtpControl) \n            {\n                info = \"ZRTP \" + ((ZrtpControl)srtpControl).getCipherString();\n            }\n            else\n            {\n                info = \"SDES\";\n            }\n\n            rtpType = resources.getI18NString(\n                \"service.gui.callinfo.MEDIA_STREAM_SRTP\")\n                + \" (\" \n                + resources.getI18NString(\n                    \"service.gui.callinfo.KEY_EXCHANGE_PROTOCOL\")\n                + \": \"\n                + info\n                + \")\";\n        }\n        // If the stream is not secured.\n        else\n        {\n            rtpType = resources.getI18NString(\n                            \"service.gui.callinfo.MEDIA_STREAM_RTP\");\n        }\n        // Appends the encryption status String.\n        stringBuffer.append(getLineString(\n                    resources.getI18NString(\n                        \"service.gui.callinfo.MEDIA_STREAM_TRANSPORT_PROTOCOL\"),\n                    transportProtocolString + \" / \" + rtpType));\n\n    }","id":92404,"modified_method":"/**\n     * Appends to the string buffer the stream encryption method (null, MIKEY,\n     * SDES, ZRTP) used for a given media stream (type AUDIO or VIDEO).\n     *\n     * @param stringBuffer The string buffer containing the call information\n     * statistics.\n     * @param callPeerMediaHandler The media handler containing the different\n     * media streams.\n     * @param mediaStream the <tt>MediaStream<\/tt> that gives us access to\n     * audio/video info.\n     * @param mediaType The media type used to determine which stream of the\n     * media handler must returns it encryption method.\n     */\n    private void appendStreamEncryptionMethod(\n            StringBuffer stringBuffer,\n            CallPeerMediaHandler<?> callPeerMediaHandler,\n            MediaStream mediaStream,\n            MediaType mediaType)\n    {\n        String transportProtocolString = \"\";\n        StreamConnector.Protocol transportProtocol =\n            mediaStream.getTransportProtocol();\n        if(transportProtocol != null)\n        {\n            transportProtocolString = transportProtocol.toString();\n        }\n\n        String rtpType;\n        SrtpControl srtpControl\n            = callPeerMediaHandler.getEncryptionMethod(mediaType);\n        // If the stream is secured.\n        if(srtpControl != null)\n        {\n            String info;\n            if (srtpControl instanceof ZrtpControl) \n            {\n                info = \"ZRTP \" + ((ZrtpControl)srtpControl).getCipherString();\n            }\n            else\n            {\n                info = \"SDES\";\n            }\n\n            rtpType = resources.getI18NString(\n                \"service.gui.callinfo.MEDIA_STREAM_SRTP\")\n                + \" (\" \n                + resources.getI18NString(\n                    \"service.gui.callinfo.KEY_EXCHANGE_PROTOCOL\")\n                + \": \"\n                + info\n                + \")\";\n        }\n        // If the stream is not secured.\n        else\n        {\n            rtpType = resources.getI18NString(\n                            \"service.gui.callinfo.MEDIA_STREAM_RTP\");\n        }\n        // Appends the encryption status String.\n        stringBuffer.append(getLineString(\n                    resources.getI18NString(\n                        \"service.gui.callinfo.MEDIA_STREAM_TRANSPORT_PROTOCOL\"),\n                    transportProtocolString + \" / \" + rtpType));\n\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Constructs peer info.\n     *\n     * @param callPeer the <tt>CallPeer<\/tt>, for which we'll construct the info\n     * @param stringBuffer the <tt>StringBuffer<\/tt>, where call peer info will\n     * be added\n     */\n    private void constructPeerInfo(CallPeer callPeer, StringBuffer stringBuffer)\n    {\n        stringBuffer.append(getLineString(callPeer.getAddress(), \"\"));\n\n        if(callPeer.getCallDurationStartTime() !=\n                CallPeer.CALL_DURATION_START_TIME_UNKNOWN)\n        {\n            Date startTime = new Date(callPeer.getCallDurationStartTime());\n            stringBuffer.append(getLineString(\n                resources.getI18NString(\"service.gui.callinfo.CALL_DURATION\"),\n                GuiUtils.formatTime(startTime.getTime(),\n                                    System.currentTimeMillis())));\n        }\n\n        if(callPeer instanceof MediaAwareCallPeer)\n        {\n            CallPeerMediaHandler callPeerMediaHandler\n                = ((MediaAwareCallPeer) callPeer).getMediaHandler();\n\n            if(callPeerMediaHandler != null)\n            {\n                String iceCandidateExtendedType =\n                    callPeerMediaHandler.getICECandidateExtendedType();\n                if(iceCandidateExtendedType != null)\n                {\n                    stringBuffer.append(getLineString(resources.getI18NString(\n                            \"service.gui.callinfo.ICE_CANDIDATE_EXTENDED_TYPE\"),\n                                iceCandidateExtendedType));\n                }\n\n                String iceState = callPeerMediaHandler.getICEState();\n                if(iceState != null && !iceState.equals(\"Terminated\"))\n                {\n                    stringBuffer.append(getLineString(\n                        resources.getI18NString(\n                            \"service.gui.callinfo.ICE_STATE\"),\n                        resources.getI18NString(\n                            \"service.gui.callinfo.ICE_STATE.\" + iceState)));\n                }\n\n                MediaStream mediaStream =\n                    callPeerMediaHandler.getStream(MediaType.AUDIO);\n\n                if (mediaStream != null && mediaStream.isStarted())\n                {\n                    stringBuffer.append(\"<br/>\");\n                    stringBuffer.append(getLineString(resources.getI18NString(\n                        \"service.gui.callinfo.AUDIO_INFO\"), \"\"));\n\n                    this.appendStreamEncryptionMethod(\n                            stringBuffer,\n                            callPeerMediaHandler,\n                            mediaStream,\n                            MediaType.AUDIO);\n\n                    constructAudioVideoInfo(\n                            mediaStream,\n                            stringBuffer,\n                            MediaType.AUDIO);\n                }\n\n                mediaStream = callPeerMediaHandler.getStream(MediaType.VIDEO);\n\n                if (mediaStream != null && mediaStream.isStarted())\n                {\n                    stringBuffer.append(\"<br/>\");\n                    stringBuffer.append(getLineString(resources.getI18NString(\n                        \"service.gui.callinfo.VIDEO_INFO\"), \"\"));\n\n                    this.appendStreamEncryptionMethod(\n                            stringBuffer,\n                            callPeerMediaHandler,\n                            mediaStream,\n                            MediaType.VIDEO);\n\n                    constructAudioVideoInfo(\n                            mediaStream,\n                            stringBuffer,\n                            MediaType.VIDEO);\n                }\n            }\n        }\n    }","id":92405,"modified_method":"/**\n     * Constructs peer info.\n     *\n     * @param callPeer the <tt>CallPeer<\/tt>, for which we'll construct the info\n     * @param stringBuffer the <tt>StringBuffer<\/tt>, where call peer info will\n     * be added\n     */\n    private void constructPeerInfo(CallPeer callPeer, StringBuffer stringBuffer)\n    {\n        stringBuffer.append(getLineString(callPeer.getAddress(), \"\"));\n\n        if(callPeer.getCallDurationStartTime() !=\n                CallPeer.CALL_DURATION_START_TIME_UNKNOWN)\n        {\n            Date startTime = new Date(callPeer.getCallDurationStartTime());\n            stringBuffer.append(getLineString(\n                resources.getI18NString(\"service.gui.callinfo.CALL_DURATION\"),\n                GuiUtils.formatTime(startTime.getTime(),\n                                    System.currentTimeMillis())));\n        }\n\n        if(callPeer instanceof MediaAwareCallPeer)\n        {\n            CallPeerMediaHandler<?> callPeerMediaHandler\n                = ((MediaAwareCallPeer<?,?,?>) callPeer).getMediaHandler();\n\n            if(callPeerMediaHandler != null)\n            {\n                String iceCandidateExtendedType =\n                    callPeerMediaHandler.getICECandidateExtendedType();\n                if(iceCandidateExtendedType != null)\n                {\n                    stringBuffer.append(getLineString(resources.getI18NString(\n                            \"service.gui.callinfo.ICE_CANDIDATE_EXTENDED_TYPE\"),\n                                iceCandidateExtendedType));\n                }\n\n                String iceState = callPeerMediaHandler.getICEState();\n                if(iceState != null && !iceState.equals(\"Terminated\"))\n                {\n                    stringBuffer.append(getLineString(\n                        resources.getI18NString(\n                            \"service.gui.callinfo.ICE_STATE\"),\n                        resources.getI18NString(\n                            \"service.gui.callinfo.ICE_STATE.\" + iceState)));\n                }\n\n                MediaStream mediaStream =\n                    callPeerMediaHandler.getStream(MediaType.AUDIO);\n\n                if (mediaStream != null && mediaStream.isStarted())\n                {\n                    stringBuffer.append(\"<br/>\");\n                    stringBuffer.append(getLineString(resources.getI18NString(\n                        \"service.gui.callinfo.AUDIO_INFO\"), \"\"));\n\n                    this.appendStreamEncryptionMethod(\n                            stringBuffer,\n                            callPeerMediaHandler,\n                            mediaStream,\n                            MediaType.AUDIO);\n\n                    constructAudioVideoInfo(\n                            mediaStream,\n                            stringBuffer,\n                            MediaType.AUDIO);\n                }\n\n                mediaStream = callPeerMediaHandler.getStream(MediaType.VIDEO);\n\n                if (mediaStream != null && mediaStream.isStarted())\n                {\n                    stringBuffer.append(\"<br/>\");\n                    stringBuffer.append(getLineString(resources.getI18NString(\n                        \"service.gui.callinfo.VIDEO_INFO\"), \"\"));\n\n                    this.appendStreamEncryptionMethod(\n                            stringBuffer,\n                            callPeerMediaHandler,\n                            mediaStream,\n                            MediaType.VIDEO);\n\n                    constructAudioVideoInfo(\n                            mediaStream,\n                            stringBuffer,\n                            MediaType.VIDEO);\n                }\n            }\n        }\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates a <tt>LocalVideoButton<\/tt> by specifying the corresponding\n     * <tt>call<\/tt>.\n     *\n     * @param call  the <tt>Call<\/tt> to be associated with the new instance and\n     * to be put on/off hold upon performing its action\n     * @param fullScreen <tt>true<\/tt> if the new instance is to be used in\n     * full-screen UI; otherwise, <tt>false<\/tt>\n     * @param selected <tt>true<\/tt> if the new toggle button is to be initially\n     * selected; otherwise, <tt>false<\/tt>\n     */\n    public LocalVideoButton(Call call, boolean fullScreen, boolean selected)\n    {\n        super(  call,\n            fullScreen,\n            true,\n            selected,\n            ImageLoader.LOCAL_VIDEO_BUTTON,\n            ImageLoader.LOCAL_VIDEO_BUTTON_PRESSED,\n            \"service.gui.LOCAL_VIDEO_BUTTON_TOOL_TIP\");\n\n\n        OperationSetVideoTelephony videoTelephony\n                = call.getProtocolProvider().getOperationSet(\n                OperationSetVideoTelephony.class);\n\n        MediaDevice videoDevice = GuiActivator.getMediaService()\n                .getDefaultDevice(MediaType.VIDEO, MediaUseCase.CALL);\n\n        /* Check whether we can send video and set the appropriate tooltip */\n        if(videoDevice == null ||\n                videoDevice.getDirection().equals(MediaDirection.RECVONLY))\n        {\n            setToolTipText(GuiActivator.getResources()\n                    .getI18NString(\"service.gui.NO_CAMERA_AVAILABLE\"));\n            videoAvailable = false;\n        }\n        else if (videoTelephony == null)\n        {\n            setToolTipText(GuiActivator.getResources()\n                    .getI18NString(\"service.gui.NO_VIDEO_FOR_PROTOCOL\"));\n            videoAvailable = false;\n        }\n        else if(!ConfigurationManager.hasEnabledVideoFormat(\n                call.getProtocolProvider()))\n        {\n            setToolTipText(GuiActivator.getResources()\n                    .getI18NString(\"service.gui.NO_VIDEO_ENCODINGS\"));\n            videoAvailable = false;\n        }\n        else\n        {\n            setToolTipText(GuiActivator.getResources()\n                    .getI18NString(\"service.gui.LOCAL_VIDEO_BUTTON_TOOL_TIP\"));\n            videoAvailable = true;\n        }\n\n        super.setEnabled(videoAvailable);\n    }","id":92406,"modified_method":"/**\n     * Initializes a new <tt>LocalVideoButton<\/tt> instance which is to\n     * start/stop the streaming of the local video to the remote peers\n     * participating in a specific telephony conference.\n     *\n     * @param call the <tt>Call<\/tt> which participates in the telephony\n     * conference to start/stop the streaming of the local video to the remote\n     * peers in\n     * @param fullScreen <tt>true<\/tt> if the new instance is to be used in a\n     * full-screen UI; otherwise, <tt>false<\/tt>\n     * @param selected <tt>true<\/tt> if the new instance is to be initially\n     * selected; otherwise, <tt>false<\/tt>\n     */\n    public LocalVideoButton(Call call, boolean fullScreen, boolean selected)\n    {\n        super(\n                null,\n                fullScreen,\n                true,\n                selected,\n                ImageLoader.LOCAL_VIDEO_BUTTON,\n                ImageLoader.LOCAL_VIDEO_BUTTON_PRESSED,\n                \"service.gui.LOCAL_VIDEO_BUTTON_TOOL_TIP\");\n\n        this.callConference = call.getConference();\n\n        MediaDevice videoDevice\n            = GuiActivator.getMediaService().getDefaultDevice(\n                    MediaType.VIDEO,\n                    MediaUseCase.CALL);\n        String toolTipTextKey;\n\n        /* Check whether we can send video and set the appropriate tooltip. */\n        if((videoDevice == null)\n                || !videoDevice.getDirection().allowsSending())\n        {\n            toolTipTextKey = \"service.gui.NO_CAMERA_AVAILABLE\";\n            videoAvailable = false;\n        }\n        else\n        {\n            boolean hasVideoTelephony = false;\n            boolean hasEnabledVideoFormat = false;\n\n            for (Call conferenceCall : callConference.getCalls())\n            {\n                ProtocolProviderService protocolProvider\n                    = conferenceCall.getProtocolProvider();\n\n                if (!hasVideoTelephony)\n                {\n                    OperationSetVideoTelephony videoTelephony\n                        = protocolProvider.getOperationSet(\n                                OperationSetVideoTelephony.class);\n\n                    if (videoTelephony != null)\n                        hasVideoTelephony = true;\n                }\n                if (!hasEnabledVideoFormat\n                        && ConfigurationManager.hasEnabledVideoFormat(\n                                protocolProvider))\n                {\n                    hasEnabledVideoFormat = true;\n                }\n\n                if (hasVideoTelephony && hasEnabledVideoFormat)\n                    break;\n            }\n\n            if (!hasVideoTelephony)\n            {\n                toolTipTextKey = \"service.gui.NO_VIDEO_FOR_PROTOCOL\";\n                videoAvailable = false;\n            }\n            else if(!hasEnabledVideoFormat)\n            {\n                toolTipTextKey = \"service.gui.NO_VIDEO_ENCODINGS\";\n                videoAvailable = false;\n            }\n            else\n            {\n                toolTipTextKey = \"service.gui.LOCAL_VIDEO_BUTTON_TOOL_TIP\";\n                videoAvailable = true;\n            }\n        }\n        setToolTipText(\n                GuiActivator.getResources().getI18NString(toolTipTextKey));\n\n        super.setEnabled(videoAvailable);\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Enables or disables local video when the button is toggled/untoggled.\n     */\n    public void buttonPressed()\n    {\n        CallManager.enableLocalVideo(call,\n            !CallManager.isLocalVideoEnabled(call));\n    }","id":92407,"modified_method":"/**\n     * Enables or disables local video when the button is toggled/untoggled.\n     */\n    public void buttonPressed()\n    {\n        /*\n         * CallManager actually enables/disables the local video for the\n         * telephony conference associated with the Call so pick up a Call\n         * participating in callConference and it should do.\n         */\n        List<Call> calls = callConference.getCalls();\n\n        if (!calls.isEmpty())\n        {\n            Call call = calls.get(0);\n\n            CallManager.enableLocalVideo(\n                    call,\n                    !CallManager.isLocalVideoEnabled(call));\n        }\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates a new <tt>Recorder<\/tt> which is to record this <tt>Call<\/tt>\n     * (into a file which is to be specified when starting the returned\n     * <tt>Recorder<\/tt>).\n     *\n     * @return a new <tt>Recorder<\/tt> which is to record this <tt>Call<\/tt>\n     * (into a file which is to be specified when starting the returned\n     * <tt>Recorder<\/tt>)\n     * @throws OperationFailedException if anything goes wrong while creating\n     * the new <tt>Recorder<\/tt> for this <tt>Call<\/tt>\n     */\n    public Recorder createRecorder()\n        throws OperationFailedException\n    {\n        final Recorder recorder\n            = ProtocolMediaActivator.getMediaService().createRecorder(\n                    getDefaultDevice(MediaType.AUDIO));\n\n        if (recorder != null)\n        {\n            // listens for mute event to update recorder\n            final PropertyChangeListener muteListener\n                = new PropertyChangeListener()\n            {\n                public void propertyChange(PropertyChangeEvent evt)\n                {\n                    if(evt.getPropertyName()\n                        .equals(CallPeer.MUTE_PROPERTY_NAME))\n                    {\n                        updateRecorderMuteState(recorder);\n                    }\n                }\n            };\n\n            // Make sure the recorder is stopped when this call ends.\n            final CallChangeListener callChangeListener\n                = new CallChangeListener()\n                {\n                    /**\n                     * When call ends we stop recording.\n                     * @param evt the <tt>CallChangeEvent<\/tt> instance\n                     * containing the source\n                     */\n                    public void callStateChanged(CallChangeEvent evt)\n                    {\n                        if (CallState.CALL_ENDED.equals(evt.getNewValue()))\n                            recorder.stop();\n                    }\n\n                    /**\n                     * We listen for mute on newly added call peers.\n                     * @param evt the <tt>CallPeerEvent<\/tt> containing\n                     * the source call\n                     */\n                    public void callPeerAdded(CallPeerEvent evt)\n                    {\n                        updateRecorderMuteState(recorder);\n                        evt.getSourceCallPeer()\n                            .addPropertyChangeListener(muteListener);\n                    }\n\n                    /**\n                     * We stop listen for mute on removed call peers.\n                     * @param evt the <tt>CallPeerEvent<\/tt> containing\n                     * the source call\n                     */\n                    public void callPeerRemoved(CallPeerEvent evt)\n                    {\n                        updateRecorderMuteState(recorder);\n                        evt.getSourceCallPeer()\n                            .removePropertyChangeListener(muteListener);\n                    }\n                };\n\n            addCallChangeListener(callChangeListener);\n\n            Iterator<Recorder.Listener> iterListeners =\n                ProtocolMediaActivator.getMediaService().getRecorderListeners();\n            while(iterListeners.hasNext())\n                recorder.addListener(iterListeners.next());\n\n            /*\n             * If the recorder gets stopped earlier than this call ends, don't\n             * wait for the end of the call because callChangeListener will keep\n             * a reference to the stopped recorder.\n             */\n            recorder.addListener(\n                    new Recorder.Listener()\n                    {\n                        public void recorderStopped(Recorder recorder)\n                        {\n                            removeCallChangeListener(callChangeListener);\n\n                            Iterator<Recorder.Listener> iter =\n                                ProtocolMediaActivator.getMediaService()\n                                    .getRecorderListeners();\n                            while(iter.hasNext())\n                            {\n                                recorder.removeListener(iter.next());\n                            }\n                        }\n                    });\n\n            // add listener for mute event to all current peers\n            Iterator<T> iter = getCallPeers();\n            while(iter.hasNext())\n                iter.next().addPropertyChangeListener(muteListener);\n\n            updateRecorderMuteState(recorder);\n        }\n        return recorder;\n    }","id":92408,"modified_method":"/**\n     * Creates a new <tt>Recorder<\/tt> which is to record this <tt>Call<\/tt>\n     * (into a file which is to be specified when starting the returned\n     * <tt>Recorder<\/tt>).\n     *\n     * @return a new <tt>Recorder<\/tt> which is to record this <tt>Call<\/tt>\n     * (into a file which is to be specified when starting the returned\n     * <tt>Recorder<\/tt>)\n     * @throws OperationFailedException if anything goes wrong while creating\n     * the new <tt>Recorder<\/tt> for this <tt>Call<\/tt>\n     */\n    public Recorder createRecorder()\n        throws OperationFailedException\n    {\n        final Recorder recorder\n            = ProtocolMediaActivator.getMediaService().createRecorder(\n                    getDefaultDevice(MediaType.AUDIO));\n\n        if (recorder != null)\n        {\n            // listens for mute event to update recorder\n            final PropertyChangeListener muteListener\n                = new PropertyChangeListener()\n            {\n                public void propertyChange(PropertyChangeEvent evt)\n                {\n                    if(evt.getPropertyName()\n                        .equals(CallPeer.MUTE_PROPERTY_NAME))\n                    {\n                        updateRecorderMuteState(recorder);\n                    }\n                }\n            };\n\n            // Make sure the recorder is stopped when this call ends.\n            final CallChangeListener callChangeListener\n                = new CallChangeListener()\n                {\n                    /**\n                     * When call ends we stop recording.\n                     * @param evt the <tt>CallChangeEvent<\/tt> instance\n                     * containing the source\n                     */\n                    public void callStateChanged(CallChangeEvent evt)\n                    {\n                        if (CallState.CALL_ENDED.equals(evt.getNewValue()))\n                            recorder.stop();\n                    }\n\n                    /**\n                     * We listen for mute on newly added call peers.\n                     * @param evt the <tt>CallPeerEvent<\/tt> containing\n                     * the source call\n                     */\n                    public void callPeerAdded(CallPeerEvent evt)\n                    {\n                        updateRecorderMuteState(recorder);\n                        evt.getSourceCallPeer()\n                            .addPropertyChangeListener(muteListener);\n                    }\n\n                    /**\n                     * We stop listen for mute on removed call peers.\n                     * @param evt the <tt>CallPeerEvent<\/tt> containing\n                     * the source call\n                     */\n                    public void callPeerRemoved(CallPeerEvent evt)\n                    {\n                        updateRecorderMuteState(recorder);\n                        evt.getSourceCallPeer()\n                            .removePropertyChangeListener(muteListener);\n                    }\n                };\n\n            addCallChangeListener(callChangeListener);\n\n            Iterator<Recorder.Listener> iterListeners =\n                ProtocolMediaActivator.getMediaService().getRecorderListeners();\n            while(iterListeners.hasNext())\n                recorder.addListener(iterListeners.next());\n\n            /*\n             * If the recorder gets stopped earlier than this call ends, don't\n             * wait for the end of the call because callChangeListener will keep\n             * a reference to the stopped recorder.\n             */\n            recorder.addListener(\n                    new Recorder.Listener()\n                    {\n                        public void recorderStopped(Recorder recorder)\n                        {\n                            removeCallChangeListener(callChangeListener);\n\n                            Iterator<Recorder.Listener> iter\n                                = ProtocolMediaActivator.getMediaService()\n                                    .getRecorderListeners();\n\n                            while(iter.hasNext())\n                                recorder.removeListener(iter.next());\n                        }\n                    });\n\n            // add listener for mute event to all current peers\n            Iterator<T> iter = getCallPeers();\n            while(iter.hasNext())\n                iter.next().addPropertyChangeListener(muteListener);\n\n            updateRecorderMuteState(recorder);\n        }\n        return recorder;\n    }","commit_id":"31edde5063e297c242e568cfd851586caa9f22c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n  public void visitReferenceExpression(GrReferenceExpression referenceExpression) {\n    GroovyResolveResult resolveResult = referenceExpression.advancedResolve();\n    GroovyResolveResult[] results = referenceExpression.multiResolve(false); //cached\n    for (GroovyResolveResult result : results) {\n      registerUsedImport(referenceExpression, result);\n    }\n\n    PsiElement resolved = resolveResult.getElement();\n    final PsiElement parent = referenceExpression.getParent();\n    if (resolved != null) {\n      if (resolved instanceof PsiMember) {\n        highlightMemberResolved(myHolder, referenceExpression, ((PsiMember)resolved));\n      }\n      if (!resolveResult.isAccessible()) {\n        String message = GroovyBundle.message(\"cannot.access\", referenceExpression.getReferenceName());\n        final Annotation annotation = myHolder.createWarningAnnotation(getElementToHighlight(referenceExpression), message);\n        if (resolved instanceof PsiMember) {\n          registerAccessFix(annotation, referenceExpression, ((PsiMember)resolved));\n        }\n      }\n      if (!resolveResult.isStaticsOK() && resolved instanceof PsiModifierListOwner) {\n        if (!((PsiModifierListOwner)resolved).hasModifierProperty(GrModifier.STATIC)) {\n          myHolder.createErrorAnnotation(referenceExpression,\n                                         GroovyBundle.message(\"cannot.reference.nonstatic\", referenceExpression.getReferenceName()));\n        }\n      }\n    }\n    else {\n      GrExpression qualifier = referenceExpression.getQualifierExpression();\n      if (qualifier == null && isDeclarationAssignment(referenceExpression)) return;\n\n      if (parent instanceof GrReferenceExpression && \"class\".equals(((GrReferenceExpression)parent).getReferenceName())) {\n        checkSingleResolvedElement(myHolder, referenceExpression, resolveResult, false);\n      }\n    }\n\n    if (parent instanceof GrCall) {\n      if (resolved == null && results.length > 0) {\n        resolved = results[0].getElement();\n        resolveResult = results[0];\n      }\n      if (resolved instanceof PsiMethod && resolved.getUserData(GrMethod.BUILDER_METHOD) == null) {\n        checkMethodApplicability(resolveResult, referenceExpression, myHolder);\n      }\n      else {\n        checkClosureApplicability(resolveResult, referenceExpression.getType(), referenceExpression, myHolder);\n      }\n    }\n    if (isDeclarationAssignment(referenceExpression) || resolved instanceof PsiPackage) return;\n\n    if (resolved == null) {\n      PsiElement refNameElement = referenceExpression.getReferenceNameElement();\n      PsiElement elt = refNameElement == null ? referenceExpression : refNameElement;\n      Annotation annotation = myHolder.createInfoAnnotation(elt, null);\n      final GrExpression qualifier = referenceExpression.getQualifierExpression();\n      if (qualifier == null) {\n        if (!(parent instanceof GrCall)) {\n          registerCreateClassByTypeFix(referenceExpression, annotation);\n          registerAddImportFixes(referenceExpression, annotation);\n        }\n        else {\n          registerStaticImportFix(referenceExpression, annotation);\n        }\n      }\n      else {\n        if (qualifier.getType() == null) {\n          return;\n        }\n      }\n      registerReferenceFixes(referenceExpression, annotation);\n      annotation.setTextAttributes(DefaultHighlighter.UNRESOLVED_ACCESS);\n    }\n  }","id":92409,"modified_method":"@Override\n  public void visitReferenceExpression(GrReferenceExpression referenceExpression) {\n    GroovyResolveResult resolveResult = referenceExpression.advancedResolve();\n    GroovyResolveResult[] results = referenceExpression.multiResolve(false); //cached\n    for (GroovyResolveResult result : results) {\n      registerUsedImport(referenceExpression, result);\n    }\n\n    PsiElement resolved = resolveResult.getElement();\n    final PsiElement parent = referenceExpression.getParent();\n    if (resolved != null) {\n      if (resolved instanceof PsiMember) {\n        highlightMemberResolved(myHolder, referenceExpression, ((PsiMember)resolved));\n      }\n      if (!resolveResult.isAccessible()) {\n        String message = GroovyBundle.message(\"cannot.access\", referenceExpression.getReferenceName());\n        final Annotation annotation = myHolder.createWarningAnnotation(getElementToHighlight(referenceExpression), message);\n        if (resolved instanceof PsiMember) {\n          registerAccessFix(annotation, referenceExpression, ((PsiMember)resolved));\n        }\n      }\n      if (!resolveResult.isStaticsOK() && resolved instanceof PsiModifierListOwner) {\n        if (!((PsiModifierListOwner)resolved).hasModifierProperty(GrModifier.STATIC)) {\n          Annotation annotation = myHolder.createInfoAnnotation(referenceExpression,\n                                         GroovyBundle.message(\"cannot.reference.nonstatic\", referenceExpression.getReferenceName()));\n          annotation.setTextAttributes(DefaultHighlighter.UNRESOLVED_ACCESS);\n        }\n      }\n    }\n    else {\n      GrExpression qualifier = referenceExpression.getQualifierExpression();\n      if (qualifier == null && isDeclarationAssignment(referenceExpression)) return;\n\n      if (parent instanceof GrReferenceExpression && \"class\".equals(((GrReferenceExpression)parent).getReferenceName())) {\n        checkSingleResolvedElement(myHolder, referenceExpression, resolveResult, false);\n      }\n    }\n\n    if (parent instanceof GrCall) {\n      if (resolved == null && results.length > 0) {\n        resolved = results[0].getElement();\n        resolveResult = results[0];\n      }\n      if (resolved instanceof PsiMethod && resolved.getUserData(GrMethod.BUILDER_METHOD) == null) {\n        checkMethodApplicability(resolveResult, referenceExpression, myHolder);\n      }\n      else {\n        checkClosureApplicability(resolveResult, referenceExpression.getType(), referenceExpression, myHolder);\n      }\n    }\n    if (isDeclarationAssignment(referenceExpression) || resolved instanceof PsiPackage) return;\n\n    if (resolved == null) {\n      PsiElement refNameElement = referenceExpression.getReferenceNameElement();\n      PsiElement elt = refNameElement == null ? referenceExpression : refNameElement;\n      Annotation annotation = myHolder.createInfoAnnotation(elt, null);\n      final GrExpression qualifier = referenceExpression.getQualifierExpression();\n      if (qualifier == null) {\n        if (!(parent instanceof GrCall)) {\n          registerCreateClassByTypeFix(referenceExpression, annotation);\n          registerAddImportFixes(referenceExpression, annotation);\n        }\n        else {\n          registerStaticImportFix(referenceExpression, annotation);\n        }\n      }\n      else {\n        if (qualifier.getType() == null) {\n          return;\n        }\n      }\n      registerReferenceFixes(referenceExpression, annotation);\n      annotation.setTextAttributes(DefaultHighlighter.UNRESOLVED_ACCESS);\n    }\n  }","commit_id":"72a458392fd7619e25012b4ee7c1f2f206fb1958","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitNewExpression(GrNewExpression newExpression) {\n    final GrTypeElement typeElement = newExpression.getTypeElement();\n\n    if (typeElement instanceof GrBuiltInTypeElement) {\n      if (newExpression.getArrayCount() == 0) {\n        myHolder.createErrorAnnotation(typeElement, GroovyBundle.message(\"create.instance.of.built-in.type\"));\n      }\n    }\n\n    if (newExpression.getArrayCount() > 0) return;\n\n    GrCodeReferenceElement refElement = newExpression.getReferenceElement();\n    if (refElement == null) return;\n    final PsiElement element = refElement.resolve();\n    if (element instanceof PsiClass) {\n      PsiClass clazz = (PsiClass)element;\n      if (clazz.hasModifierProperty(GrModifier.ABSTRACT)) {\n        if (newExpression.getAnonymousClassDefinition() == null) {\n          String message = clazz.isInterface()\n                           ? GroovyBundle.message(\"cannot.instantiate.interface\", clazz.getName())\n                           : GroovyBundle.message(\"cannot.instantiate.abstract.class\", clazz.getName());\n          myHolder.createErrorAnnotation(refElement, message);\n        }\n        return;\n      }\n      if (newExpression.getQualifier() != null) {\n        if (clazz.hasModifierProperty(GrModifier.STATIC)) {\n          myHolder.createErrorAnnotation(newExpression, GroovyBundle.message(\"qualified.new.of.static.class\"));\n        }\n      }\n      else {\n        final PsiClass outerClass = clazz.getContainingClass();\n        if (com.intellij.psi.util.PsiUtil.isInnerClass(clazz) && !PsiUtil.hasEnclosingInstanceInScope(outerClass, newExpression, true)) {\n          myHolder.createErrorAnnotation(newExpression, GroovyBundle.message(\"cannot.reference.nonstatic\", clazz.getQualifiedName()));\n        }\n      }\n    }\n\n    final GroovyResolveResult constructorResolveResult = newExpression.resolveConstructorGenerics();\n    final PsiElement constructor = constructorResolveResult.getElement();\n    if (constructor != null) {\n      final GrArgumentList argList = newExpression.getArgumentList();\n      if (argList != null &&\n          argList.getExpressionArguments().length == 0 &&\n          ((PsiMethod)constructor).getParameterList().getParametersCount() == 0) {\n        checkDefaultMapConstructor(myHolder, argList, constructor);\n      }\n      else {\n        checkMethodApplicability(constructorResolveResult, refElement, myHolder);\n      }\n    }\n    else {\n      final GroovyResolveResult[] results = newExpression.multiResolveConstructor();\n      final GrArgumentList argList = newExpression.getArgumentList();\n      PsiElement toHighlight = argList != null ? argList : getElementToHighlight(refElement);\n\n      if (results.length > 0) {\n        String message = GroovyBundle.message(\"ambiguous.constructor.call\");\n        myHolder.createWarningAnnotation(toHighlight, message);\n      }\n      else {\n        if (element instanceof PsiClass) {\n          //default constructor invocation\n          PsiType[] argumentTypes = PsiUtil.getArgumentTypes(refElement, true);\n          if (argumentTypes == null ||\n              argumentTypes.length == 0 ||\n              (argumentTypes.length == 1 &&\n               InheritanceUtil.isInheritor(argumentTypes[0], CommonClassNames.JAVA_UTIL_MAP))) {\n            checkDefaultMapConstructor(myHolder, argList, element);\n          }\n          else {\n            String message = GroovyBundle.message(\"cannot.find.default.constructor\", ((PsiClass)element).getName());\n            myHolder.createWarningAnnotation(toHighlight, message);\n          }\n        }\n      }\n    }\n  }","id":92410,"modified_method":"@Override\n  public void visitNewExpression(GrNewExpression newExpression) {\n    final GrTypeElement typeElement = newExpression.getTypeElement();\n\n    if (typeElement instanceof GrBuiltInTypeElement) {\n      if (newExpression.getArrayCount() == 0) {\n        myHolder.createErrorAnnotation(typeElement, GroovyBundle.message(\"create.instance.of.built-in.type\"));\n      }\n    }\n\n    if (newExpression.getArrayCount() > 0) return;\n\n    GrCodeReferenceElement refElement = newExpression.getReferenceElement();\n    if (refElement == null) return;\n    final PsiElement element = refElement.resolve();\n    if (element instanceof PsiClass) {\n      PsiClass clazz = (PsiClass)element;\n      if (clazz.hasModifierProperty(GrModifier.ABSTRACT)) {\n        if (newExpression.getAnonymousClassDefinition() == null) {\n          String message = clazz.isInterface()\n                           ? GroovyBundle.message(\"cannot.instantiate.interface\", clazz.getName())\n                           : GroovyBundle.message(\"cannot.instantiate.abstract.class\", clazz.getName());\n          myHolder.createErrorAnnotation(refElement, message);\n        }\n        return;\n      }\n      if (newExpression.getQualifier() != null) {\n        if (clazz.hasModifierProperty(GrModifier.STATIC)) {\n          myHolder.createErrorAnnotation(newExpression, GroovyBundle.message(\"qualified.new.of.static.class\"));\n        }\n      }\n      else {\n        final PsiClass outerClass = clazz.getContainingClass();\n        if (com.intellij.psi.util.PsiUtil.isInnerClass(clazz) && !PsiUtil.hasEnclosingInstanceInScope(outerClass, newExpression, true)) {\n          Annotation annotation = myHolder.createErrorAnnotation(newExpression, GroovyBundle.message(\"cannot.reference.nonstatic\", clazz.getQualifiedName()));\n          annotation.setTextAttributes(DefaultHighlighter.UNRESOLVED_ACCESS);\n        }\n      }\n    }\n\n    final GroovyResolveResult constructorResolveResult = newExpression.resolveConstructorGenerics();\n    final PsiElement constructor = constructorResolveResult.getElement();\n    if (constructor != null) {\n      final GrArgumentList argList = newExpression.getArgumentList();\n      if (argList != null &&\n          argList.getExpressionArguments().length == 0 &&\n          ((PsiMethod)constructor).getParameterList().getParametersCount() == 0) {\n        checkDefaultMapConstructor(myHolder, argList, constructor);\n      }\n      else {\n        checkMethodApplicability(constructorResolveResult, refElement, myHolder);\n      }\n    }\n    else {\n      final GroovyResolveResult[] results = newExpression.multiResolveConstructor();\n      final GrArgumentList argList = newExpression.getArgumentList();\n      PsiElement toHighlight = argList != null ? argList : getElementToHighlight(refElement);\n\n      if (results.length > 0) {\n        String message = GroovyBundle.message(\"ambiguous.constructor.call\");\n        myHolder.createWarningAnnotation(toHighlight, message);\n      }\n      else {\n        if (element instanceof PsiClass) {\n          //default constructor invocation\n          PsiType[] argumentTypes = PsiUtil.getArgumentTypes(refElement, true);\n          if (argumentTypes == null ||\n              argumentTypes.length == 0 ||\n              (argumentTypes.length == 1 &&\n               InheritanceUtil.isInheritor(argumentTypes[0], CommonClassNames.JAVA_UTIL_MAP))) {\n            checkDefaultMapConstructor(myHolder, argList, element);\n          }\n          else {\n            String message = GroovyBundle.message(\"cannot.find.default.constructor\", ((PsiClass)element).getName());\n            myHolder.createWarningAnnotation(toHighlight, message);\n          }\n        }\n      }\n    }\n  }","commit_id":"72a458392fd7619e25012b4ee7c1f2f206fb1958","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void checkThisOrSuperReferenceExpression(GrExpression expression, AnnotationHolder holder) {\n    if (GroovyConfigUtils.getInstance().isVersionAtLeast(expression, GroovyConfigUtils.GROOVY1_8)) return;\n    \n    final GrReferenceExpression qualifier = expression instanceof GrThisReferenceExpression\n                                            ? ((GrThisReferenceExpression)expression).getQualifier()\n                                            : ((GrSuperReferenceExpression)expression).getQualifier();\n    if (qualifier == null) {\n      if (expression instanceof GrSuperReferenceExpression) { //'this' refers to java.lang.Class<ThisClass> in static context\n        final GrMethod method = PsiTreeUtil.getParentOfType(expression, GrMethod.class);\n        if (method != null && method.hasModifierProperty(GrModifier.STATIC)) {\n          holder.createErrorAnnotation(expression, GroovyBundle.message(\"cannot.reference.nonstatic\", expression.getText()));\n        }\n      }\n    }\n    else {\n      final PsiElement resolved = qualifier.resolve();\n      if (resolved instanceof PsiClass) {\n        if (PsiTreeUtil.isAncestor(resolved, expression, true)) {\n          if (!PsiUtil.hasEnclosingInstanceInScope((PsiClass)resolved, expression, true)) {\n            holder.createErrorAnnotation(expression, GroovyBundle.message(\"cannot.reference.nonstatic\", expression.getText()));\n          }\n        }\n        else {\n          holder.createErrorAnnotation(expression, GroovyBundle.message(\"is.not.enclosing.class\", ((PsiClass)resolved).getQualifiedName()));\n        }\n      }\n      else {\n        holder.createErrorAnnotation(qualifier, GroovyBundle.message(\"unknown.class\", qualifier.getText()));\n      }\n    }\n  }","id":92411,"modified_method":"private static void checkThisOrSuperReferenceExpression(GrExpression expression, AnnotationHolder holder) {\n    if (GroovyConfigUtils.getInstance().isVersionAtLeast(expression, GroovyConfigUtils.GROOVY1_8)) return;\n    \n    final GrReferenceExpression qualifier = expression instanceof GrThisReferenceExpression\n                                            ? ((GrThisReferenceExpression)expression).getQualifier()\n                                            : ((GrSuperReferenceExpression)expression).getQualifier();\n    if (qualifier == null) {\n      if (expression instanceof GrSuperReferenceExpression) { //'this' refers to java.lang.Class<ThisClass> in static context\n        final GrMethod method = PsiTreeUtil.getParentOfType(expression, GrMethod.class);\n        if (method != null && method.hasModifierProperty(GrModifier.STATIC)) {\n          Annotation annotation = holder.createInfoAnnotation(expression, GroovyBundle.message(\"cannot.reference.nonstatic\", expression.getText()));\n          annotation.setTextAttributes(DefaultHighlighter.UNRESOLVED_ACCESS);\n        }\n      }\n    }\n    else {\n      final PsiElement resolved = qualifier.resolve();\n      if (resolved instanceof PsiClass) {\n        if (PsiTreeUtil.isAncestor(resolved, expression, true)) {\n          if (!PsiUtil.hasEnclosingInstanceInScope((PsiClass)resolved, expression, true)) {\n            Annotation annotation = holder.createInfoAnnotation(expression, GroovyBundle.message(\"cannot.reference.nonstatic\", expression.getText()));\n            annotation.setTextAttributes(DefaultHighlighter.UNRESOLVED_ACCESS);\n          }\n        }\n        else {\n          holder.createErrorAnnotation(expression, GroovyBundle.message(\"is.not.enclosing.class\", ((PsiClass)resolved).getQualifiedName()));\n        }\n      }\n      else {\n        holder.createErrorAnnotation(qualifier, GroovyBundle.message(\"unknown.class\", qualifier.getText()));\n      }\n    }\n  }","commit_id":"72a458392fd7619e25012b4ee7c1f2f206fb1958","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement getDocumentationElementForLookupItem(final PsiManager psiManager, Object object, PsiElement element) {\n    final PsiElement originalElement = element;\n    boolean isAttrCompletion = element instanceof XmlAttribute;\n\n    if (!isAttrCompletion && element instanceof XmlToken) {\n      final IElementType tokenType = ((XmlToken)element).getTokenType();\n\n      if (tokenType == XmlTokenType.XML_EMPTY_ELEMENT_END || tokenType == XmlTokenType.XML_TAG_END) {\n        isAttrCompletion = true;\n      } else if (element.getParent() instanceof XmlAttribute) {\n        isAttrCompletion = true;\n      }\n    }\n\n    element = PsiTreeUtil.getParentOfType(element, XmlTag.class, false);\n\n    if (element instanceof XmlTag) {\n      XmlTag xmlTag = (XmlTag)element;\n      XmlElementDescriptor elementDescriptor;\n\n      if (isAttrCompletion && object instanceof String) {\n        elementDescriptor = xmlTag.getDescriptor();\n\n        if (elementDescriptor != null) {\n          final XmlAttributeDescriptor attributeDescriptor = elementDescriptor.getAttributeDescriptor((String)object, xmlTag);\n          if (attributeDescriptor != null) {\n            final PsiElement declaration = attributeDescriptor.getDeclaration();\n            if (declaration != null) return declaration;\n          }\n        }\n      }\n\n      try {\n        @NonNls StringBuffer tagText = new StringBuffer(object.toString());\n        String namespacePrefix = XmlUtil.findPrefixByQualifiedName(object.toString());\n        String namespace = xmlTag.getNamespaceByPrefix(namespacePrefix);\n\n        if (namespace!=null && namespace.length() > 0) {\n          tagText.append(\" xmlns\");\n          if (namespacePrefix.length() > 0) tagText.append(\":\").append(namespacePrefix);\n          tagText.append(\"=\\\"\").append(namespace).append(\"\\\"\");\n        }\n\n        XmlTag tagFromText = XmlElementFactory.getInstance(xmlTag.getProject()).createTagFromText(\"<\" + tagText +\"/>\");\n        XmlElementDescriptor parentDescriptor = xmlTag.getDescriptor();\n        elementDescriptor = (parentDescriptor!=null)?parentDescriptor.getElementDescriptor(tagFromText, xmlTag):null;\n\n        if (elementDescriptor==null) {\n          PsiElement parent = xmlTag.getParent();\n          if (parent instanceof XmlTag) {\n            parentDescriptor = ((XmlTag)parent).getDescriptor();\n            elementDescriptor = (parentDescriptor!=null)?parentDescriptor.getElementDescriptor(tagFromText, (XmlTag)parent):null;\n          }\n        }\n\n        if (elementDescriptor instanceof AnyXmlElementDescriptor) {\n          final XmlNSDescriptor nsDescriptor = xmlTag.getNSDescriptor(xmlTag.getNamespaceByPrefix(namespacePrefix), true);\n          elementDescriptor = (nsDescriptor != null)?nsDescriptor.getElementDescriptor(tagFromText):null;\n        }\n\n        // The very special case of xml file\n        final PsiFile containingFile = xmlTag.getContainingFile();\n        final XmlFile xmlFile = XmlUtil.getContainingFile(xmlTag);\n        if (xmlFile != containingFile) {\n          final XmlTag rootTag = xmlFile.getDocument().getRootTag();\n          if (rootTag != null) {\n            final XmlNSDescriptor nsDescriptor = rootTag.getNSDescriptor(rootTag.getNamespaceByPrefix(namespacePrefix), true);\n            elementDescriptor = (nsDescriptor != null) ? nsDescriptor.getElementDescriptor(tagFromText) : null;\n          }\n        }\n\n        if (elementDescriptor != null) {\n          PsiElement declaration = elementDescriptor.getDeclaration();\n          if (declaration!=null) declaration.putUserData(DESCRIPTOR_KEY,elementDescriptor);\n          return declaration;\n        }\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n    }\n\n    if (object instanceof String && originalElement != null) {\n      return findDeclWithName((String)object, originalElement);\n    }\n    if (object instanceof XmlElementDescriptor) {\n      return ((XmlElementDescriptor)object).getDeclaration();\n    }\n    return super.getDocumentationElementForLookupItem(psiManager, object, element);\n  }","id":92412,"modified_method":"public PsiElement getDocumentationElementForLookupItem(final PsiManager psiManager, Object object, PsiElement element) {\n    final PsiElement originalElement = element;\n    boolean isAttrCompletion = element instanceof XmlAttribute;\n\n    if (!isAttrCompletion && element instanceof XmlToken) {\n      final IElementType tokenType = ((XmlToken)element).getTokenType();\n\n      if (tokenType == XmlTokenType.XML_EMPTY_ELEMENT_END || tokenType == XmlTokenType.XML_TAG_END) {\n        isAttrCompletion = true;\n      } else if (element.getParent() instanceof XmlAttribute) {\n        isAttrCompletion = true;\n      }\n    }\n\n    element = PsiTreeUtil.getParentOfType(element, XmlTag.class, false);\n\n    if (element instanceof XmlTag) {\n      XmlTag xmlTag = (XmlTag)element;\n      XmlElementDescriptor elementDescriptor;\n\n      if (isAttrCompletion && object instanceof String) {\n        elementDescriptor = xmlTag.getDescriptor();\n\n        if (elementDescriptor != null) {\n          final XmlAttributeDescriptor attributeDescriptor = elementDescriptor.getAttributeDescriptor((String)object, xmlTag);\n          if (attributeDescriptor != null) {\n            final PsiElement declaration = attributeDescriptor.getDeclaration();\n            if (declaration != null) return declaration;\n          }\n        }\n      }\n\n      try {\n        @NonNls StringBuffer tagText = new StringBuffer(object.toString());\n        String namespacePrefix = XmlUtil.findPrefixByQualifiedName(object.toString());\n        String namespace = xmlTag.getNamespaceByPrefix(namespacePrefix);\n\n        if (namespace!=null && namespace.length() > 0) {\n          tagText.append(\" xmlns\");\n          if (namespacePrefix.length() > 0) tagText.append(\":\").append(namespacePrefix);\n          tagText.append(\"=\\\"\").append(namespace).append(\"\\\"\");\n        }\n\n        XmlTag tagFromText = XmlElementFactory.getInstance(xmlTag.getProject()).createTagFromText(\"<\" + tagText +\"/>\");\n        XmlElementDescriptor parentDescriptor = xmlTag.getDescriptor();\n        elementDescriptor = (parentDescriptor!=null)?parentDescriptor.getElementDescriptor(tagFromText, xmlTag):null;\n\n        if (elementDescriptor==null) {\n          PsiElement parent = xmlTag.getParent();\n          if (parent instanceof XmlTag) {\n            parentDescriptor = ((XmlTag)parent).getDescriptor();\n            elementDescriptor = (parentDescriptor!=null)?parentDescriptor.getElementDescriptor(tagFromText, (XmlTag)parent):null;\n          }\n        }\n\n        if (elementDescriptor instanceof AnyXmlElementDescriptor) {\n          final XmlNSDescriptor nsDescriptor = xmlTag.getNSDescriptor(xmlTag.getNamespaceByPrefix(namespacePrefix), true);\n          elementDescriptor = (nsDescriptor != null)?nsDescriptor.getElementDescriptor(tagFromText):null;\n        }\n\n        // The very special case of xml file\n        final PsiFile containingFile = xmlTag.getContainingFile();\n        final XmlFile xmlFile = XmlUtil.getContainingFile(xmlTag);\n        if (xmlFile != containingFile) {\n          final XmlTag rootTag = xmlFile.getDocument().getRootTag();\n          if (rootTag != null) {\n            final XmlNSDescriptor nsDescriptor = rootTag.getNSDescriptor(rootTag.getNamespaceByPrefix(namespacePrefix), true);\n            elementDescriptor = (nsDescriptor != null) ? nsDescriptor.getElementDescriptor(tagFromText) : null;\n          }\n        }\n\n        if (elementDescriptor != null) {\n          PsiElement declaration = elementDescriptor.getDeclaration();\n          if (declaration!=null) declaration.putUserData(DESCRIPTOR_KEY,elementDescriptor);\n          return declaration;\n        }\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n    }\n\n    if (object instanceof String && originalElement != null) {\n      PsiElement result = findDeclWithName((String)object, originalElement);\n      \n      if (result == null && element instanceof XmlTag && originalElement.getParent() instanceof XmlAttributeValue) {\n        XmlElementDescriptor descriptor = ((XmlTag)element).getDescriptor();\n\n        if (descriptor != null && descriptor.getDeclaration() instanceof XmlTag) {\n          result = findEnumerationValue((String)object, (XmlTag)descriptor.getDeclaration());\n        }\n      }\n      return result;\n    }\n    if (object instanceof XmlElementDescriptor) {\n      return ((XmlElementDescriptor)object).getDeclaration();\n    }\n    return super.getDocumentationElementForLookupItem(psiManager, object, element);\n  }","commit_id":"d45d01835206c624c056b64512cb02b1b4ad01d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String generateDoc(String str, String name, String typeName, String version) {\n    if (str == null) return null;\n    StringBuilder buf = new StringBuilder(str.length() + 20);\n\n    if (typeName==null) {\n      DocumentationUtil.formatEntityName(XmlBundle.message(\"xml.javadoc.tag.name.message\"),name,buf);\n    } else {\n      DocumentationUtil.formatEntityName(XmlBundle.message(\"xml.javadoc.complex.type.message\"),name,buf);\n    }\n\n    final String indent = \"  \";\n    final StringBuilder builder = buf.append(XmlBundle.message(\"xml.javadoc.description.message\")).append(indent).\n        append(HtmlDocumentationProvider.NBSP).append(str);\n    if (version != null) {\n      builder.append(HtmlDocumentationProvider.BR).append(XmlBundle.message(\"xml.javadoc.version.message\")).append(indent)\n          .append(HtmlDocumentationProvider.NBSP).append(version);\n    }\n    return builder.toString();\n  }","id":92413,"modified_method":"private static String generateDoc(String str, String name, String typeName, String version) {\n    if (str == null) return null;\n    StringBuilder buf = new StringBuilder(str.length() + 20);\n\n    DocumentationUtil.formatEntityName(typeName == null ? XmlBundle.message(\"xml.javadoc.tag.name.message\"):typeName,name,buf);\n\n    final String indent = \"  \";\n    final StringBuilder builder = buf.append(XmlBundle.message(\"xml.javadoc.description.message\")).append(indent).\n        append(HtmlDocumentationProvider.NBSP).append(str);\n    if (version != null) {\n      builder.append(HtmlDocumentationProvider.BR).append(XmlBundle.message(\"xml.javadoc.version.message\")).append(indent)\n          .append(HtmlDocumentationProvider.NBSP).append(version);\n    }\n    return builder.toString();\n  }","commit_id":"d45d01835206c624c056b64512cb02b1b4ad01d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String generateDoc(PsiElement element, PsiElement originalElement) {\n    if (element instanceof XmlElementDecl) {\n      PsiElement curElement = findPreviousComment(element);\n\n      if (curElement!=null) {\n        return formatDocFromComment(curElement, ((XmlElementDecl)element).getNameElement().getText());\n      }\n    } else if (element instanceof XmlTag) {\n      XmlTag tag = (XmlTag)element;\n      MyPsiElementProcessor processor = new MyPsiElementProcessor();\n      XmlUtil.processXmlElements(tag,processor, true);\n      String name = tag.getAttributeValue(NAME_ATTR_NAME);\n      String typeName = null;\n\n      if (processor.result == null) {\n        XmlTag declaration = getComplexOrSimpleTypeDefinition(element, originalElement);\n\n        if (declaration != null) {\n          XmlUtil.processXmlElements(declaration,processor, true);\n          name = declaration.getAttributeValue(NAME_ATTR_NAME);\n          typeName = declaration.getName();\n        }\n      }\n      if (processor.result == null) {\n        final String s = super.generateDoc(element, originalElement);\n        if (s != null) {\n          return s;\n        }\n        final PsiElement comment = findPreviousComment(element);\n        if (comment != null) {\n          return formatDocFromComment(comment, ((XmlTag)element).getName());\n        }\n      }\n\n      String doc = generateDoc(processor.result, name, typeName, processor.version);\n      if (doc != null) {\n        doc += generateHtmlAdditionalDocTemplate(originalElement);\n      }\n      return doc;\n\n    } else if (element instanceof XmlAttributeDecl) {\n      // Check for comment before attlist, it should not be right after previous declaration\n      final PsiElement parent = element.getParent();\n      final PsiElement previousComment = findPreviousComment(parent);\n      final String referenceName = ((XmlAttributeDecl)element).getNameElement().getText();\n\n      if (previousComment instanceof PsiComment) {\n        final PsiElement prevSibling = previousComment.getPrevSibling();\n\n        if (prevSibling == null ||\n            ( prevSibling instanceof PsiWhiteSpace &&\n              prevSibling.getText().indexOf('\\n') >= 0\n            )\n           ) {\n          return formatDocFromComment(previousComment, referenceName);\n        }\n      }\n\n      return findDocRightAfterElement(parent, referenceName);\n    } else if (element instanceof XmlEntityDecl) {\n      final XmlEntityDecl entityDecl = (XmlEntityDecl)element;\n\n      return findDocRightAfterElement(element, entityDecl.getName());\n    }\n\n    return super.generateDoc(element, originalElement);\n  }","id":92414,"modified_method":"public String generateDoc(PsiElement element, final PsiElement originalElement) {\n    if (element instanceof XmlElementDecl) {\n      PsiElement curElement = findPreviousComment(element);\n\n      if (curElement!=null) {\n        return formatDocFromComment(curElement, ((XmlElementDecl)element).getNameElement().getText());\n      }\n    } else if (element instanceof XmlTag) {\n      XmlTag tag = (XmlTag)element;\n      MyPsiElementProcessor processor = new MyPsiElementProcessor();\n      String name = tag.getAttributeValue(NAME_ATTR_NAME);\n      String typeName = null;\n\n      if (originalElement != null && originalElement.getParent() instanceof XmlAttributeValue) {\n        String toSearch = StringUtil.stripQuotesAroundValue(originalElement.getText());\n        XmlTag enumerationTag;\n        \n        if (XmlUtil.ENUMERATION_TAG_NAME.equals(tag.getLocalName())) {\n          enumerationTag = tag;\n          name = enumerationTag.getAttributeValue(XmlUtil.VALUE_ATTR_NAME);\n        } else {\n          enumerationTag = findEnumerationValue(toSearch, tag);\n          name = toSearch;\n        }\n\n        if (enumerationTag != null) {\n          XmlUtil.processXmlElements(enumerationTag,processor, true);\n\n          if (processor.result != null) {\n            typeName = XmlBundle.message(\"xml.javadoc.enumeration.value.message\");\n          }\n        }\n      }\n\n      if (processor.result == null) XmlUtil.processXmlElements(tag,processor, true);\n\n      if (processor.result == null) {\n        XmlTag declaration = getComplexOrSimpleTypeDefinition(element, originalElement);\n\n        if (declaration != null) {\n          XmlUtil.processXmlElements(declaration,processor, true);\n          name = declaration.getAttributeValue(NAME_ATTR_NAME);\n          typeName = XmlBundle.message(\"xml.javadoc.complex.type.message\");\n        }\n      }\n      if (processor.result == null) {\n        final String s = super.generateDoc(element, originalElement);\n        if (s != null) {\n          return s;\n        }\n        final PsiElement comment = findPreviousComment(element);\n        if (comment != null) {\n          return formatDocFromComment(comment, ((XmlTag)element).getName());\n        }\n      }\n\n      String doc = generateDoc(processor.result, name, typeName, processor.version);\n      if (doc != null) {\n        doc += generateHtmlAdditionalDocTemplate(originalElement);\n      }\n      return doc;\n\n    } else if (element instanceof XmlAttributeDecl) {\n      // Check for comment before attlist, it should not be right after previous declaration\n      final PsiElement parent = element.getParent();\n      final PsiElement previousComment = findPreviousComment(parent);\n      final String referenceName = ((XmlAttributeDecl)element).getNameElement().getText();\n\n      if (previousComment instanceof PsiComment) {\n        final PsiElement prevSibling = previousComment.getPrevSibling();\n\n        if (prevSibling == null ||\n            ( prevSibling instanceof PsiWhiteSpace &&\n              prevSibling.getText().indexOf('\\n') >= 0\n            )\n           ) {\n          return formatDocFromComment(previousComment, referenceName);\n        }\n      }\n\n      return findDocRightAfterElement(parent, referenceName);\n    } else if (element instanceof XmlEntityDecl) {\n      final XmlEntityDecl entityDecl = (XmlEntityDecl)element;\n\n      return findDocRightAfterElement(element, entityDecl.getName());\n    }\n\n    return super.generateDoc(element, originalElement);\n  }","commit_id":"d45d01835206c624c056b64512cb02b1b4ad01d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean collectEnumerationValues(final XmlTag element, final HashSet<String> variants) {\n    boolean exaustiveEnum = true;\n\n    for (final XmlTag tag : element.getSubTags()) {\n      @NonNls final String localName = tag.getLocalName();\n\n      if (localName.equals(\"enumeration\")) {\n        final String attributeValue = tag.getAttributeValue(\"value\");\n        if (attributeValue != null) variants.add(attributeValue);\n      }\n      else if (localName.equals(\"union\")) {\n        exaustiveEnum = false;\n        collectEnumerationValues(tag, variants);\n      }\n      else if (!localName.equals(\"annotation\")) {\n        // don't go into annotation\n        exaustiveEnum &= collectEnumerationValues(tag, variants);\n      }\n    }\n    return exaustiveEnum;\n  }","id":92415,"modified_method":"public static boolean collectEnumerationValues(final XmlTag element, final HashSet<String> variants) {\n    return processEnumerationValues(element, new Processor<XmlTag>() {\n      public boolean process(XmlTag xmlTag) {\n        variants.add(xmlTag.getAttributeValue(VALUE_ATTR_NAME));\n        return true;\n      }\n    });\n  }","commit_id":"d45d01835206c624c056b64512cb02b1b4ad01d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PsiElement resolveInner() {\n    final PsiElement[] result = new PsiElement[1];\n\n    XmlUtil.processXmlElements(\n      getFile(),\n      new PsiElementProcessor() {\n        public boolean execute(final PsiElement element) {\n          final String anchorValue = getAnchorValue(element);\n\n          if (anchorValue!=null && anchorValue.equals(myAnchor)) {\n            final XmlTag xmlTag = (XmlTag)element;\n            XmlAttribute attribute = xmlTag.getAttribute(\"id\", null);\n            if (attribute==null) attribute = xmlTag.getAttribute(\"name\",null);\n            result[0] = attribute.getValueElement();\n            return false;\n          }\n          return true;\n        }\n      },\n      true\n    );\n\n    return result[0];\n  }","id":92416,"modified_method":"private PsiElement resolveInner() {\n    final PsiElement[] result = new PsiElement[1];\n\n    final XmlFile file = getFile();\n    if (file != null) {\n      processXmlElements(\n        file.getDocument().getRootTag(),\n        new PsiElementProcessor() {\n          public boolean execute(final PsiElement element) {\n            final String anchorValue = getAnchorValue(element);\n\n            if (anchorValue!=null && anchorValue.equals(myAnchor)) {\n              final XmlTag xmlTag = (XmlTag)element;\n              XmlAttribute attribute = xmlTag.getAttribute(\"id\", null);\n              if (attribute==null) attribute = xmlTag.getAttribute(\"name\",null);\n              result[0] = attribute.getValueElement();\n              return false;\n            }\n            return true;\n          }\n        }\n      );\n    }\n\n    return result[0];\n  }","commit_id":"a11b5c789d7fcfca359d22b0c33a333eccfd8b4e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getVariants() {\n    final List<String> variants = new ArrayList<String>(3);\n\n    XmlUtil.processXmlElements(\n      getFile(),\n      new PsiElementProcessor() {\n        public boolean execute(final PsiElement element) {\n          final String anchorValue = getAnchorValue(element);\n\n          if (anchorValue!=null) {\n            variants.add(anchorValue);\n          }\n          return true;\n        }\n      },\n      true\n    );\n\n    return variants.toArray(new String[variants.size()]);\n  }","id":92417,"modified_method":"public Object[] getVariants() {\n    final List<String> variants = new ArrayList<String>(3);\n\n    final XmlFile file = getFile();\n    if (file!=null) {\n      processXmlElements(\n        file.getDocument().getRootTag(),\n        new PsiElementProcessor() {\n          public boolean execute(final PsiElement element) {\n            final String anchorValue = getAnchorValue(element);\n\n            if (anchorValue!=null) {\n              variants.add(anchorValue);\n            }\n            return true;\n          }\n        }\n      );\n    }\n\n    return variants.toArray(new String[variants.size()]);\n  }","commit_id":"a11b5c789d7fcfca359d22b0c33a333eccfd8b4e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int readPmdCmd() {\n        OVsPMDCommand command = new OVsPMDCommand();\n        \n        if (m_ovspmd.OVsReceive(command) < 0) {\n            log(\"error calling OVsReceive\");\n        }\n        \n        return command.code;\n    }","id":92418,"modified_method":"public int readPmdCmd() {\n        OVsPMDCommand command = new OVsPMDCommand();\n        \n        if (NNM.OVsReceive(command) < 0) {\n            log(\"error calling OVsReceive\");\n        }\n        \n        return command.getCode();\n    }","commit_id":"fc6b29caef7d98ec0fd26c18ff65f692bf7cca40","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setStatus(String message) {\n        if (m_ovspmd.OVsResponse(OVsPMD.OVS_RSP_LAST_MSG, message) < 0) {\n            log(\"error calling OVsResponse\");\n        }\n    }","id":92419,"modified_method":"public void setStatus(String message) {\n        log(\"OVsResponse(OVS_RSP_LAST_MSG, \\\"\"+message+\"\\\")\");\n        if (NNM.OVsResponse(NNM.OVS_RSP_LAST_MSG, message) < 0) {\n            log(\"error calling OVsResponse\");\n        }\n    }","commit_id":"fc6b29caef7d98ec0fd26c18ff65f692bf7cca40","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Object call() throws Exception {\n            long start = System.currentTimeMillis();\n            long end = start;\n            int code = OVsPMD.OVS_CMD_NOOP; \n            \n            CLibrary clib = CLibrary.INSTANCE;\n            \n            fd_set fdset = new fd_set();\n            timeval tm = new timeval();\n\n            boolean finished = false;\n            while (!finished) {\n                fdset.zero();\n                fdset.set(getPmdFd());\n            \n                if (!tm.isSet()) {\n                    tm.setTimeInMillis(1000);\n                }\n            \n                long selectStart = System.currentTimeMillis();\n                int fds = clib.select(getPmdFd()+1, fdset, null, null, tm);\n                long selectEnd = System.currentTimeMillis();\n                end = selectEnd;\n                \n                setStatus(\"Select returned after \"+(selectEnd - selectStart)+ \" millis.  pmd \" + \n                        (fdset.isSet(getPmdFd()) ? \"is\" : \"is not\") + \" set in readfds, return val is \"+fds+\", elapsed time = \"+(end - start)+ \"ms\");\n                \n                code = OVsPMD.OVS_CMD_NOOP;\n                if (fdset.isSet(getPmdFd())) {\n                    code = readPmdCmd();\n                    setStatus(\"Received cmd code \"+code+\" from pmd\");\n                }\n                \n                if (code == OVsPMD.OVS_CMD_EXIT) {\n                    finished = true;\n                }\n            }     \n            \n            Thread.sleep(5000);\n            end = System.currentTimeMillis();\n            return \"DefaultOVsDaemon has finished and is now exiting after \"+(end-start)+\" ms. code was \"+code+\" pmdfs set is \"+fdset.isSet(getPmdFd());\n        }","id":92420,"modified_method":"public Object call() throws Exception {\n            long start = System.currentTimeMillis();\n            long end = start;\n            int code = NNM.OVS_CMD_NOOP; \n            \n\n            fd_set fdset = new fd_set();\n            timeval tm = new timeval();\n\n            boolean finished = false;\n            while (!finished) {\n                fdset.zero();\n                fdset.set(getPmdFd());\n            \n                tm.setTimeInMillis(1000);\n                \n            \n                long selectStart = System.currentTimeMillis();\n                int fds = NNM.select(getPmdFd()+1, fdset, null, null, tm);\n                long selectEnd = System.currentTimeMillis();\n                end = selectEnd;\n                \n                setStatus(\"Select returned after \"+(selectEnd - selectStart)+ \" millis.  pmd \" + \n                        (fdset.isSet(getPmdFd()) ? \"is\" : \"is not\") + \" set in readfds, return val is \"+fds+\", elapsed time = \"+(end - start)+ \"ms\");\n                \n                code = NNM.OVS_CMD_NOOP;\n                if (fdset.isSet(getPmdFd())) {\n                    code = readPmdCmd();\n                    setStatus(\"Received cmd code \"+code+\" from pmd\");\n                }\n                \n                if (code == NNM.OVS_CMD_EXIT) {\n                    finished = true;\n                }\n            }     \n            \n            Thread.sleep(5000);\n            end = System.currentTimeMillis();\n            return \"DefaultOVsDaemon has finished and is now exiting after \"+(end-start)+\" ms. code was \"+code+\" pmdfs set is \"+fdset.isSet(getPmdFd());\n        }","commit_id":"fc6b29caef7d98ec0fd26c18ff65f692bf7cca40","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void execute() {\n\n        IntByReference sp = new IntByReference();\n\n        if (m_ovspmd.OVsInit(sp) < 0) {\n            log(\"error calling OVsInit\");\n        }\n        \n        m_ovspmdFd = sp.getValue();\n\n        String initResponse = \"\";\n        int success = OVsPMD.OVS_RSP_FAILURE;\n        try {\n        \n            initResponse = onInit();\n            success = OVsPMD.OVS_RSP_SUCCESS;\n            \n        } catch (Throwable t) {\n            initResponse = \"Exception occurred initializing \"+this+\": \"+t;\n            log(initResponse, t);\n        }\n\n        if (m_ovspmd.OVsInitComplete(success, initResponse) < 0) {\n            log(\"error calling OVsInitComplete\");\n        }\n        \n        String callmsg;\n        try {\n            callmsg = (String)call();\n        } catch (Throwable t) {\n            callmsg = \"Exception occurred calling \"+this+\": \"+t;\n            log(callmsg, t);\n        }\n        \n        if (m_ovspmd.OVsDone(callmsg) < 0) {\n            log(\"error occurred calling OVsDone\");\n        }\n    }","id":92421,"modified_method":"public void execute() {\n\n        int[] sp = new int[1];\n\n        if (NNM.OVsInit(sp) < 0) {\n            log(\"error calling OVsInit\");\n        }\n        \n        m_ovspmdFd = sp[0];\n\n        String initResponse = \"\";\n        int success = NNM.OVS_RSP_FAILURE;\n        try {\n        \n            initResponse = onInit();\n            success = NNM.OVS_RSP_SUCCESS;\n            \n        } catch (Throwable t) {\n            initResponse = \"Exception occurred initializing \"+this+\": \"+t;\n            log(initResponse, t);\n        }\n\n        if (initComplete(initResponse, success) < 0) {\n            log(\"error calling OVsInitComplete\");\n        }\n        \n        String callmsg;\n        try {\n            callmsg = (String)call();\n        } catch (Throwable t) {\n            callmsg = \"Exception occurred calling \"+this+\": \"+t;\n            log(callmsg, t);\n        }\n        \n        if (NNM.OVsDone(callmsg) < 0) {\n            log(\"error occurred calling OVsDone\");\n        }\n    }","commit_id":"fc6b29caef7d98ec0fd26c18ff65f692bf7cca40","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testCreatePdu() throws Exception {\n        String sysName = \".1.3.6.1.2.1.1.5.0\";\n        \n        ObjectID oid = new ObjectID();\n        \n        int len = oid.fromString(sysName);\n        \n        \n        OVsnmpPdu pdu = OVsnmpPdu.createGet();\n        \n        System.err.println(pdu);\n        \n        pdu.addNullVarBind(oid, len);\n        \n        System.err.println(pdu);\n\n        Thread.sleep(3000);\n        \n        pdu.free();\n\n    }","id":92422,"modified_method":"public void testCreatePdu() throws Exception {\n        String sysName = \".1.3.6.1.2.1.1.5.0\";\n        \n        //ObjectID oid = new ObjectID();\n        \n        //int len = oid.fromString(sysName);\n        \n        //System.err.println(\"len = \" + len + \" oid = \" + oid.toString(len));\n        \n        //OVsnmpPdu pdu = OVsnmpPdu.createGet();\n        \n        //System.err.println(pdu);\n        \n        //pdu.addNullVarBind(oid, len);\n        \n        //System.err.println(pdu);\n\n        //Thread.sleep(3000);\n        \n        //pdu.free();\n\n    }","commit_id":"fc6b29caef7d98ec0fd26c18ff65f692bf7cca40","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void XXXtestOpenClose() throws Exception {\n        OVsnmpSession sess = OVsnmpSession.open(\"localhost\", 9162);\n        sess.close();\n    }","id":92423,"modified_method":"public void testOpenClose() throws Exception {\n\n        OVsnmpSession sess = open(\"localhost\", 9162);\n        assertNotNull(sess);\n        close(sess);\n    }","commit_id":"fc6b29caef7d98ec0fd26c18ff65f692bf7cca40","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Object call() throws Exception {\n            long start = System.currentTimeMillis();\n            long end = start;\n            int code = OVsPMD.OVS_CMD_NOOP; \n            \n            CLibrary clib = CLibrary.INSTANCE;\n            \n            fd_set fdset = new fd_set();\n            timeval tm = new timeval();\n\n            boolean finished = false;\n            while (!finished) {\n                fdset.zero();\n                fdset.set(getPmdFd());\n            \n                if (!tm.isSet()) {\n                    tm.setTimeInMillis(1000);\n                }\n            \n                long selectStart = System.currentTimeMillis();\n                int fds = clib.select(getPmdFd()+1, fdset, null, null, tm);\n                long selectEnd = System.currentTimeMillis();\n                end = selectEnd;\n                \n                setStatus(\"Select returned after \"+(selectEnd - selectStart)+ \" millis.  pmd \" + \n                        (fdset.isSet(getPmdFd()) ? \"is\" : \"is not\") + \" set in readfds, return val is \"+fds+\", elapsed time = \"+(end - start)+ \"ms\");\n                \n                code = OVsPMD.OVS_CMD_NOOP;\n                if (fdset.isSet(getPmdFd())) {\n                    code = readPmdCmd();\n                    setStatus(\"Received cmd code \"+code+\" from pmd\");\n                }\n                \n                if (code == OVsPMD.OVS_CMD_EXIT) {\n                    finished = true;\n                }\n            }     \n            \n            Thread.sleep(5000);\n            end = System.currentTimeMillis();\n            return \"DefaultOVsDaemon has finished and is now exiting after \"+(end-start)+\" ms. code was \"+code+\" pmdfs set is \"+fdset.isSet(getPmdFd());\n        }","id":92424,"modified_method":"public Object call() throws Exception {\n            long start = System.currentTimeMillis();\n            long end = start;\n            int code = NNM.OVS_CMD_NOOP; \n            \n\n            fd_set fdset = new fd_set();\n            timeval tm = new timeval();\n\n            boolean finished = false;\n            while (!finished) {\n                fdset.zero();\n                fdset.set(getPmdFd());\n            \n                tm.setTimeInMillis(1000);\n                \n            \n                long selectStart = System.currentTimeMillis();\n                int fds = NNM.select(getPmdFd()+1, fdset, null, null, tm);\n                long selectEnd = System.currentTimeMillis();\n                end = selectEnd;\n                \n                setStatus(\"Select returned after \"+(selectEnd - selectStart)+ \" millis.  pmd \" + \n                        (fdset.isSet(getPmdFd()) ? \"is\" : \"is not\") + \" set in readfds, return val is \"+fds+\", elapsed time = \"+(end - start)+ \"ms\");\n                \n                code = NNM.OVS_CMD_NOOP;\n                if (fdset.isSet(getPmdFd())) {\n                    code = readPmdCmd();\n                    setStatus(\"Received cmd code \"+code+\" from pmd\");\n                }\n                \n                if (code == NNM.OVS_CMD_EXIT) {\n                    finished = true;\n                }\n            }     \n            \n            Thread.sleep(5000);\n            end = System.currentTimeMillis();\n            return \"DefaultOVsDaemon has finished and is now exiting after \"+(end-start)+\" ms. code was \"+code+\" pmdfs set is \"+fdset.isSet(getPmdFd());\n        }","commit_id":"4aa70bf37c6d9ae3628cb8dafa1044a72580c739","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void execute() {\n\n        IntByReference sp = new IntByReference();\n\n        if (m_ovspmd.OVsInit(sp) < 0) {\n            log(\"error calling OVsInit\");\n        }\n        \n        m_ovspmdFd = sp.getValue();\n\n        String initResponse = \"\";\n        int success = OVsPMD.OVS_RSP_FAILURE;\n        try {\n        \n            initResponse = onInit();\n            success = OVsPMD.OVS_RSP_SUCCESS;\n            \n        } catch (Throwable t) {\n            initResponse = \"Exception occurred initializing \"+this+\": \"+t;\n            log(initResponse, t);\n        }\n\n        if (m_ovspmd.OVsInitComplete(success, initResponse) < 0) {\n            log(\"error calling OVsInitComplete\");\n        }\n        \n        String callmsg;\n        try {\n            callmsg = (String)call();\n        } catch (Throwable t) {\n            callmsg = \"Exception occurred calling \"+this+\": \"+t;\n            log(callmsg, t);\n        }\n        \n        if (m_ovspmd.OVsDone(callmsg) < 0) {\n            log(\"error occurred calling OVsDone\");\n        }\n    }","id":92425,"modified_method":"public void execute() {\n\n        int[] sp = new int[1];\n\n        if (NNM.OVsInit(sp) < 0) {\n            log(\"error calling OVsInit\");\n        }\n        \n        m_ovspmdFd = sp[0];\n\n        String initResponse = \"\";\n        int success = NNM.OVS_RSP_FAILURE;\n        try {\n        \n            initResponse = onInit();\n            success = NNM.OVS_RSP_SUCCESS;\n            \n        } catch (Throwable t) {\n            initResponse = \"Exception occurred initializing \"+this+\": \"+t;\n            log(initResponse, t);\n        }\n\n        if (initComplete(initResponse, success) < 0) {\n            log(\"error calling OVsInitComplete\");\n        }\n        \n        String callmsg;\n        try {\n            callmsg = (String)call();\n        } catch (Throwable t) {\n            callmsg = \"Exception occurred calling \"+this+\": \"+t;\n            log(callmsg, t);\n        }\n        \n        if (NNM.OVsDone(callmsg) < 0) {\n            log(\"error occurred calling OVsDone\");\n        }\n    }","commit_id":"4aa70bf37c6d9ae3628cb8dafa1044a72580c739","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setStatus(String message) {\n        if (m_ovspmd.OVsResponse(OVsPMD.OVS_RSP_LAST_MSG, message) < 0) {\n            log(\"error calling OVsResponse\");\n        }\n    }","id":92426,"modified_method":"public void setStatus(String message) {\n        log(\"OVsResponse(OVS_RSP_LAST_MSG, \\\"\"+message+\"\\\")\");\n        if (NNM.OVsResponse(NNM.OVS_RSP_LAST_MSG, message) < 0) {\n            log(\"error calling OVsResponse\");\n        }\n    }","commit_id":"4aa70bf37c6d9ae3628cb8dafa1044a72580c739","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public int readPmdCmd() {\n        OVsPMDCommand command = new OVsPMDCommand();\n        \n        if (m_ovspmd.OVsReceive(command) < 0) {\n            log(\"error calling OVsReceive\");\n        }\n        \n        return command.code;\n    }","id":92427,"modified_method":"public int readPmdCmd() {\n        OVsPMDCommand command = new OVsPMDCommand();\n        \n        if (NNM.OVsReceive(command) < 0) {\n            log(\"error calling OVsReceive\");\n        }\n        \n        return command.getCode();\n    }","commit_id":"4aa70bf37c6d9ae3628cb8dafa1044a72580c739","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void XXXtestOpenClose() throws Exception {\n        OVsnmpSession sess = OVsnmpSession.open(\"localhost\", 9162);\n        sess.close();\n    }","id":92428,"modified_method":"public void testOpenClose() throws Exception {\n\n        OVsnmpSession sess = open(\"localhost\", 9162);\n        assertNotNull(sess);\n        close(sess);\n    }","commit_id":"4aa70bf37c6d9ae3628cb8dafa1044a72580c739","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testCreatePdu() throws Exception {\n        String sysName = \".1.3.6.1.2.1.1.5.0\";\n        \n        ObjectID oid = new ObjectID();\n        \n        int len = oid.fromString(sysName);\n        \n        \n        OVsnmpPdu pdu = OVsnmpPdu.createGet();\n        \n        System.err.println(pdu);\n        \n        pdu.addNullVarBind(oid, len);\n        \n        System.err.println(pdu);\n\n        Thread.sleep(3000);\n        \n        pdu.free();\n\n    }","id":92429,"modified_method":"public void testCreatePdu() throws Exception {\n        String sysName = \".1.3.6.1.2.1.1.5.0\";\n        \n        //ObjectID oid = new ObjectID();\n        \n        //int len = oid.fromString(sysName);\n        \n        //System.err.println(\"len = \" + len + \" oid = \" + oid.toString(len));\n        \n        //OVsnmpPdu pdu = OVsnmpPdu.createGet();\n        \n        //System.err.println(pdu);\n        \n        //pdu.addNullVarBind(oid, len);\n        \n        //System.err.println(pdu);\n\n        //Thread.sleep(3000);\n        \n        //pdu.free();\n\n    }","commit_id":"4aa70bf37c6d9ae3628cb8dafa1044a72580c739","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Object call() throws Exception {\n            long start = System.currentTimeMillis();\n            long end = start;\n            int code = OVsPMD.OVS_CMD_NOOP; \n            \n            CLibrary clib = CLibrary.INSTANCE;\n            \n            fd_set fdset = new fd_set();\n            timeval tm = new timeval();\n\n            boolean finished = false;\n            while (!finished) {\n                fdset.zero();\n                fdset.set(getPmdFd());\n            \n                if (!tm.isSet()) {\n                    tm.setTimeInMillis(1000);\n                }\n            \n                long selectStart = System.currentTimeMillis();\n                int fds = clib.select(getPmdFd()+1, fdset, null, null, tm);\n                long selectEnd = System.currentTimeMillis();\n                end = selectEnd;\n                \n                setStatus(\"Select returned after \"+(selectEnd - selectStart)+ \" millis.  pmd \" + \n                        (fdset.isSet(getPmdFd()) ? \"is\" : \"is not\") + \" set in readfds, return val is \"+fds+\", elapsed time = \"+(end - start)+ \"ms\");\n                \n                code = OVsPMD.OVS_CMD_NOOP;\n                if (fdset.isSet(getPmdFd())) {\n                    code = readPmdCmd();\n                    setStatus(\"Received cmd code \"+code+\" from pmd\");\n                }\n                \n                if (code == OVsPMD.OVS_CMD_EXIT) {\n                    finished = true;\n                }\n            }     \n            \n            Thread.sleep(5000);\n            end = System.currentTimeMillis();\n            return \"DefaultOVsDaemon has finished and is now exiting after \"+(end-start)+\" ms. code was \"+code+\" pmdfs set is \"+fdset.isSet(getPmdFd());\n        }","id":92430,"modified_method":"public Object call() throws Exception {\n            long start = System.currentTimeMillis();\n            long end = start;\n            int code = NNM.OVS_CMD_NOOP; \n            \n\n            fd_set fdset = new fd_set();\n            timeval tm = new timeval();\n\n            boolean finished = false;\n            while (!finished) {\n                fdset.zero();\n                fdset.set(getPmdFd());\n            \n                tm.setTimeInMillis(1000);\n                \n            \n                long selectStart = System.currentTimeMillis();\n                int fds = NNM.select(getPmdFd()+1, fdset, null, null, tm);\n                long selectEnd = System.currentTimeMillis();\n                end = selectEnd;\n                \n                setStatus(\"Select returned after \"+(selectEnd - selectStart)+ \" millis.  pmd \" + \n                        (fdset.isSet(getPmdFd()) ? \"is\" : \"is not\") + \" set in readfds, return val is \"+fds+\", elapsed time = \"+(end - start)+ \"ms\");\n                \n                code = NNM.OVS_CMD_NOOP;\n                if (fdset.isSet(getPmdFd())) {\n                    code = readPmdCmd();\n                    setStatus(\"Received cmd code \"+code+\" from pmd\");\n                }\n                \n                if (code == NNM.OVS_CMD_EXIT) {\n                    finished = true;\n                }\n            }     \n            \n            Thread.sleep(5000);\n            end = System.currentTimeMillis();\n            return \"DefaultOVsDaemon has finished and is now exiting after \"+(end-start)+\" ms. code was \"+code+\" pmdfs set is \"+fdset.isSet(getPmdFd());\n        }","commit_id":"7fde1afdea973ab42cc49f764dd01bce704d612a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public int readPmdCmd() {\n        OVsPMDCommand command = new OVsPMDCommand();\n        \n        if (m_ovspmd.OVsReceive(command) < 0) {\n            log(\"error calling OVsReceive\");\n        }\n        \n        return command.code;\n    }","id":92431,"modified_method":"public int readPmdCmd() {\n        OVsPMDCommand command = new OVsPMDCommand();\n        \n        if (NNM.OVsReceive(command) < 0) {\n            log(\"error calling OVsReceive\");\n        }\n        \n        return command.getCode();\n    }","commit_id":"7fde1afdea973ab42cc49f764dd01bce704d612a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setStatus(String message) {\n        if (m_ovspmd.OVsResponse(OVsPMD.OVS_RSP_LAST_MSG, message) < 0) {\n            log(\"error calling OVsResponse\");\n        }\n    }","id":92432,"modified_method":"public void setStatus(String message) {\n        log(\"OVsResponse(OVS_RSP_LAST_MSG, \\\"\"+message+\"\\\")\");\n        if (NNM.OVsResponse(NNM.OVS_RSP_LAST_MSG, message) < 0) {\n            log(\"error calling OVsResponse\");\n        }\n    }","commit_id":"7fde1afdea973ab42cc49f764dd01bce704d612a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void execute() {\n\n        IntByReference sp = new IntByReference();\n\n        if (m_ovspmd.OVsInit(sp) < 0) {\n            log(\"error calling OVsInit\");\n        }\n        \n        m_ovspmdFd = sp.getValue();\n\n        String initResponse = \"\";\n        int success = OVsPMD.OVS_RSP_FAILURE;\n        try {\n        \n            initResponse = onInit();\n            success = OVsPMD.OVS_RSP_SUCCESS;\n            \n        } catch (Throwable t) {\n            initResponse = \"Exception occurred initializing \"+this+\": \"+t;\n            log(initResponse, t);\n        }\n\n        if (m_ovspmd.OVsInitComplete(success, initResponse) < 0) {\n            log(\"error calling OVsInitComplete\");\n        }\n        \n        String callmsg;\n        try {\n            callmsg = (String)call();\n        } catch (Throwable t) {\n            callmsg = \"Exception occurred calling \"+this+\": \"+t;\n            log(callmsg, t);\n        }\n        \n        if (m_ovspmd.OVsDone(callmsg) < 0) {\n            log(\"error occurred calling OVsDone\");\n        }\n    }","id":92433,"modified_method":"public void execute() {\n\n        int[] sp = new int[1];\n\n        if (NNM.OVsInit(sp) < 0) {\n            log(\"error calling OVsInit\");\n        }\n        \n        m_ovspmdFd = sp[0];\n\n        String initResponse = \"\";\n        int success = NNM.OVS_RSP_FAILURE;\n        try {\n        \n            initResponse = onInit();\n            success = NNM.OVS_RSP_SUCCESS;\n            \n        } catch (Throwable t) {\n            initResponse = \"Exception occurred initializing \"+this+\": \"+t;\n            log(initResponse, t);\n        }\n\n        if (initComplete(initResponse, success) < 0) {\n            log(\"error calling OVsInitComplete\");\n        }\n        \n        String callmsg;\n        try {\n            callmsg = (String)call();\n        } catch (Throwable t) {\n            callmsg = \"Exception occurred calling \"+this+\": \"+t;\n            log(callmsg, t);\n        }\n        \n        if (NNM.OVsDone(callmsg) < 0) {\n            log(\"error occurred calling OVsDone\");\n        }\n    }","commit_id":"7fde1afdea973ab42cc49f764dd01bce704d612a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testCreatePdu() throws Exception {\n        String sysName = \".1.3.6.1.2.1.1.5.0\";\n        \n        ObjectID oid = new ObjectID();\n        \n        int len = oid.fromString(sysName);\n        \n        \n        OVsnmpPdu pdu = OVsnmpPdu.createGet();\n        \n        System.err.println(pdu);\n        \n        pdu.addNullVarBind(oid, len);\n        \n        System.err.println(pdu);\n\n        Thread.sleep(3000);\n        \n        pdu.free();\n\n    }","id":92434,"modified_method":"public void testCreatePdu() throws Exception {\n        String sysName = \".1.3.6.1.2.1.1.5.0\";\n        \n        //ObjectID oid = new ObjectID();\n        \n        //int len = oid.fromString(sysName);\n        \n        //System.err.println(\"len = \" + len + \" oid = \" + oid.toString(len));\n        \n        //OVsnmpPdu pdu = OVsnmpPdu.createGet();\n        \n        //System.err.println(pdu);\n        \n        //pdu.addNullVarBind(oid, len);\n        \n        //System.err.println(pdu);\n\n        //Thread.sleep(3000);\n        \n        //pdu.free();\n\n    }","commit_id":"7fde1afdea973ab42cc49f764dd01bce704d612a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void XXXtestOpenClose() throws Exception {\n        OVsnmpSession sess = OVsnmpSession.open(\"localhost\", 9162);\n        sess.close();\n    }","id":92435,"modified_method":"public void testOpenClose() throws Exception {\n\n        OVsnmpSession sess = open(\"localhost\", 9162);\n        assertNotNull(sess);\n        close(sess);\n    }","commit_id":"7fde1afdea973ab42cc49f764dd01bce704d612a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDeleteAllOneIndex() {\n\n        String json = \"{\" + \"\\\"user\\\":\\\"kimchy\\\",\" + \"\\\"postDate\\\":\\\"2013-01-30\\\",\" + \"\\\"message\\\":\\\"trying out Elastic Search\\\"\" + \"}\";\n\n        client().prepareIndex(\"twitter\", \"tweet\").setSource(json).setRefresh(true).execute().actionGet();\n\n        SearchResponse search = client().prepareSearch().setQuery(QueryBuilders.matchAllQuery()).execute().actionGet();\n        assertThat(search.getHits().totalHits(), equalTo(1l));\n        DeleteByQueryRequestBuilder deleteByQueryRequestBuilder = client().prepareDeleteByQuery();\n        deleteByQueryRequestBuilder.setQuery(QueryBuilders.matchAllQuery());\n\n        DeleteByQueryResponse actionGet = deleteByQueryRequestBuilder.execute().actionGet();\n        assertThat(actionGet.status(), equalTo(RestStatus.OK));\n        assertThat(actionGet.getIndex(\"twitter\"), notNullValue());\n        assertThat(actionGet.getIndex(\"twitter\").getFailedShards(), equalTo(0));\n\n        client().admin().indices().prepareRefresh().execute().actionGet();\n        search = client().prepareSearch().setQuery(QueryBuilders.matchAllQuery()).execute().actionGet();\n        assertThat(search.getHits().totalHits(), equalTo(0l));\n    }","id":92436,"modified_method":"@Test\n    public void testDeleteAllOneIndex() {\n        String json = \"{\" + \"\\\"user\\\":\\\"kimchy\\\",\" + \"\\\"postDate\\\":\\\"2013-01-30\\\",\" + \"\\\"message\\\":\\\"trying out Elastic Search\\\"\" + \"}\";\n        final long iters = randomIntBetween(1, 50);\n        for (int i = 0; i < iters; i++) {\n            client().prepareIndex(\"twitter\", \"tweet\", \"\" + i).setSource(json).execute().actionGet();\n        }\n        refresh();\n        SearchResponse search = client().prepareSearch().setQuery(QueryBuilders.matchAllQuery()).execute().actionGet();\n        assertThat(search.getHits().totalHits(), equalTo(iters));\n        DeleteByQueryRequestBuilder deleteByQueryRequestBuilder = client().prepareDeleteByQuery();\n        deleteByQueryRequestBuilder.setQuery(QueryBuilders.matchAllQuery());\n\n        DeleteByQueryResponse actionGet = deleteByQueryRequestBuilder.execute().actionGet();\n        assertThat(actionGet.status(), equalTo(RestStatus.OK));\n        assertThat(actionGet.getIndex(\"twitter\"), notNullValue());\n        assertThat(actionGet.getIndex(\"twitter\").getFailedShards(), equalTo(0));\n\n        client().admin().indices().prepareRefresh().execute().actionGet();\n        search = client().prepareSearch().setQuery(QueryBuilders.matchAllQuery()).execute().actionGet();\n        assertThat(search.getHits().totalHits(), equalTo(0l));\n    }","commit_id":"0b4bf88dae825ca0410a2fcf73ba615be9b79071","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void parseProperties(ObjectMapper.Builder objBuilder, Map<String, Object> propsNode, ParserContext parserContext) {\n            for (Map.Entry<String, Object> entry : propsNode.entrySet()) {\n                String propName = Strings.toUnderscoreCase(entry.getKey());\n                Map<String, Object> propNode = (Map<String, Object>) entry.getValue();\n\n                String type;\n                Object typeNode = propNode.get(\"type\");\n                if (typeNode != null) {\n                    type = typeNode.toString();\n                } else {\n                    // lets see if we can derive this...\n                    if (propNode.get(\"properties\") != null) {\n                        type = ObjectMapper.CONTENT_TYPE;\n                    } else if (propNode.get(\"fields\") != null) {\n                        type = MultiFieldMapper.CONTENT_TYPE;\n                    } else {\n                        throw new MapperParsingException(\"No type specified for property [\" + propName + \"]\");\n                    }\n                }\n\n                XContentMapper.TypeParser typeParser = parserContext.typeParser(type);\n                if (typeParser == null) {\n                    throw new MapperParsingException(\"No handler for type [\" + type + \"] declared on field [\" + propName + \"]\");\n                }\n                objBuilder.add(typeParser.parse(propName, propNode, parserContext));\n            }\n        }","id":92437,"modified_method":"private void parseProperties(ObjectMapper.Builder objBuilder, Map<String, Object> propsNode, ParserContext parserContext) {\n            for (Map.Entry<String, Object> entry : propsNode.entrySet()) {\n                String propName = entry.getKey();\n                Map<String, Object> propNode = (Map<String, Object>) entry.getValue();\n\n                String type;\n                Object typeNode = propNode.get(\"type\");\n                if (typeNode != null) {\n                    type = typeNode.toString();\n                } else {\n                    // lets see if we can derive this...\n                    if (propNode.get(\"properties\") != null) {\n                        type = ObjectMapper.CONTENT_TYPE;\n                    } else if (propNode.get(\"fields\") != null) {\n                        type = MultiFieldMapper.CONTENT_TYPE;\n                    } else {\n                        throw new MapperParsingException(\"No type specified for property [\" + propName + \"]\");\n                    }\n                }\n\n                XContentMapper.TypeParser typeParser = parserContext.typeParser(type);\n                if (typeParser == null) {\n                    throw new MapperParsingException(\"No handler for type [\" + type + \"] declared on field [\" + propName + \"]\");\n                }\n                objBuilder.add(typeParser.parse(propName, propNode, parserContext));\n            }\n        }","commit_id":"beb77c9b0ae5ca65026d9a4874bfd73aa47d9c60","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test public void testSingleNodeNoFlush() throws Exception {\n        buildNode(\"node1\", settingsBuilder().put(\"gateway.type\", \"local\").build());\n        cleanAndCloseNodes();\n\n        Node node1 = startNode(\"node1\", settingsBuilder().put(\"gateway.type\", \"local\").put(\"index.number_of_shards\", 1).build());\n        node1.client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject().field(\"field\", \"value1\").field(\"num\", 1).endObject()).execute().actionGet();\n        node1.client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject().field(\"field\", \"value2\").field(\"num\", 2).endObject()).execute().actionGet();\n\n        node1.client().admin().indices().prepareRefresh().execute().actionGet();\n        for (int i = 0; i < 10; i++) {\n            assertThat(node1.client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().count(), equalTo(2l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"field\", \"value1\")).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"field\", \"value2\")).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"num\", 1)).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"num\", 2)).execute().actionGet().count(), equalTo(1l));\n        }\n\n        closeNode(\"node1\");\n        node1 = startNode(\"node1\", settingsBuilder().put(\"gateway.type\", \"local\").build());\n\n        logger.info(\"Running Cluster Health (wait for the shards to startup)\");\n        ClusterHealthResponse clusterHealth = client(\"node1\").admin().cluster().health(clusterHealthRequest().waitForYellowStatus().waitForActiveShards(1)).actionGet();\n        logger.info(\"Done Cluster Health, status \" + clusterHealth.status());\n        assertThat(clusterHealth.timedOut(), equalTo(false));\n        assertThat(clusterHealth.status(), equalTo(ClusterHealthStatus.YELLOW));\n\n        for (int i = 0; i < 10; i++) {\n            assertThat(node1.client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().count(), equalTo(2l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"field\", \"value1\")).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"field\", \"value2\")).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"num\", 1)).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"num\", 2)).execute().actionGet().count(), equalTo(1l));\n        }\n\n        closeNode(\"node1\");\n        node1 = startNode(\"node1\", settingsBuilder().put(\"gateway.type\", \"local\").build());\n\n        logger.info(\"Running Cluster Health (wait for the shards to startup)\");\n        clusterHealth = client(\"node1\").admin().cluster().health(clusterHealthRequest().waitForYellowStatus().waitForActiveShards(1)).actionGet();\n        logger.info(\"Done Cluster Health, status \" + clusterHealth.status());\n        assertThat(clusterHealth.timedOut(), equalTo(false));\n        assertThat(clusterHealth.status(), equalTo(ClusterHealthStatus.YELLOW));\n\n        for (int i = 0; i < 10; i++) {\n            assertThat(node1.client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().count(), equalTo(2l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"field\", \"value1\")).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"field\", \"value2\")).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"num\", 1)).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"num\", 2)).execute().actionGet().count(), equalTo(1l));\n        }\n    }","id":92438,"modified_method":"@Test public void testSingleNodeNoFlush() throws Exception {\n        buildNode(\"node1\", settingsBuilder().put(\"gateway.type\", \"local\").build());\n        cleanAndCloseNodes();\n\n        Node node1 = startNode(\"node1\", settingsBuilder().put(\"gateway.type\", \"local\").put(\"index.number_of_shards\", 1).build());\n        for (int i = 0; i < 100; i++) {\n            node1.client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject().field(\"_id\", \"1\").field(\"field\", \"value1\").startArray(\"num\").value(14).value(179).endArray().endObject()).execute().actionGet();\n            node1.client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject().field(\"_id\", \"2\").field(\"field\", \"value2\").startArray(\"num\").value(14).endArray().endObject()).execute().actionGet();\n        }\n\n        node1.client().admin().indices().prepareRefresh().execute().actionGet();\n        for (int i = 0; i < 10; i++) {\n            assertThat(node1.client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().count(), equalTo(2l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"field\", \"value1\")).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"field\", \"value2\")).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"num\", 179)).execute().actionGet().count(), equalTo(1l));\n        }\n\n        closeNode(\"node1\");\n        node1 = startNode(\"node1\", settingsBuilder().put(\"gateway.type\", \"local\").build());\n\n        logger.info(\"Running Cluster Health (wait for the shards to startup)\");\n        ClusterHealthResponse clusterHealth = client(\"node1\").admin().cluster().health(clusterHealthRequest().waitForYellowStatus().waitForActiveShards(1)).actionGet();\n        logger.info(\"Done Cluster Health, status \" + clusterHealth.status());\n        assertThat(clusterHealth.timedOut(), equalTo(false));\n        assertThat(clusterHealth.status(), equalTo(ClusterHealthStatus.YELLOW));\n\n        for (int i = 0; i < 10; i++) {\n            assertThat(node1.client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().count(), equalTo(2l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"field\", \"value1\")).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"field\", \"value2\")).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"num\", 179)).execute().actionGet().count(), equalTo(1l));\n        }\n\n        closeNode(\"node1\");\n        node1 = startNode(\"node1\", settingsBuilder().put(\"gateway.type\", \"local\").build());\n\n        logger.info(\"Running Cluster Health (wait for the shards to startup)\");\n        clusterHealth = client(\"node1\").admin().cluster().health(clusterHealthRequest().waitForYellowStatus().waitForActiveShards(1)).actionGet();\n        logger.info(\"Done Cluster Health, status \" + clusterHealth.status());\n        assertThat(clusterHealth.timedOut(), equalTo(false));\n        assertThat(clusterHealth.status(), equalTo(ClusterHealthStatus.YELLOW));\n\n        for (int i = 0; i < 10; i++) {\n            assertThat(node1.client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().count(), equalTo(2l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"field\", \"value1\")).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"field\", \"value2\")).execute().actionGet().count(), equalTo(1l));\n            assertThat(node1.client().prepareCount().setQuery(termQuery(\"num\", 179)).execute().actionGet().count(), equalTo(1l));\n        }\n    }","commit_id":"beb77c9b0ae5ca65026d9a4874bfd73aa47d9c60","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n\tprotected TypeQualifierAnnotation lookupAnnotation(XMethod xm) {\n\t\treturn TypeQualifierApplications.getEffectiveTypeQualifierAnnotation(xm, parameter, getTypeQualifierValue());\n\t}","id":92439,"modified_method":"@Override\n\tprotected TypeQualifierAnnotation lookupAnnotation(XMethod xm) {\n\t\toverrides = true;\n\t\treturn TypeQualifierApplications.getEffectiveTypeQualifierAnnotation(xm, parameter, getTypeQualifierValue());\n\t}","commit_id":"07ce5d214e1efa9957c1156788c8fb55951b68b7","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tprotected TypeQualifierAnnotation lookupAnnotation(XMethod xm) {\n\t\treturn TypeQualifierApplications.getEffectiveTypeQualifierAnnotation(xm, getTypeQualifierValue());\n    }","id":92440,"modified_method":"@Override\n\tprotected TypeQualifierAnnotation lookupAnnotation(XMethod xm) {\n\t\toverrides = true;\n\t\treturn TypeQualifierApplications.getEffectiveTypeQualifierAnnotation(xm, getTypeQualifierValue());\n    }","commit_id":"07ce5d214e1efa9957c1156788c8fb55951b68b7","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Get the effective inherited TypeQualifierAnnotation on given\n\t * instance method.\n\t *\n\t * @param o                  an XMethod\n\t * @param typeQualifierValue the kind of TypeQualifierValue we are looking for\n\t * @return effective TypeQualifierAnnotation inherited from overridden supertype methods,\n\t *         or null if there is no inherited TypeQualifierAnnotation\n\t */\n\tprivate static TypeQualifierAnnotation getInheritedTypeQualifierAnnotation(XMethod o, TypeQualifierValue typeQualifierValue) {\n\t\tassert !o.isStatic();\n\n\t\tReturnTypeAnnotationAccumulator accumulator = new ReturnTypeAnnotationAccumulator(typeQualifierValue, o);\n\t\ttry {\n\t\t\tAnalysisContext.currentAnalysisContext().getSubtypes2().traverseSupertypes(o.getClassDescriptor(), accumulator);\n\t\t\treturn accumulator.getResult().getEffectiveTypeQualifierAnnotation();\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tAnalysisContext.currentAnalysisContext().getLookupFailureCallback().reportMissingClass(e);\n\t\t\treturn null;\n\t\t}\n\t}","id":92441,"modified_method":"/**\n\t * Get the effective inherited TypeQualifierAnnotation on given\n\t * instance method.\n\t *\n\t * @param o                  an XMethod\n\t * @param typeQualifierValue the kind of TypeQualifierValue we are looking for\n\t * @return effective TypeQualifierAnnotation inherited from overridden supertype methods,\n\t *         or null if there is no inherited TypeQualifierAnnotation\n\t */\n\tprivate static TypeQualifierAnnotation getInheritedTypeQualifierAnnotation(XMethod o, TypeQualifierValue typeQualifierValue) {\n\t\tassert !o.isStatic();\n\n\t\tReturnTypeAnnotationAccumulator accumulator = new ReturnTypeAnnotationAccumulator(typeQualifierValue, o);\n\t\ttry {\n\t\t\tAnalysisContext.currentAnalysisContext().getSubtypes2().traverseSupertypes(o.getClassDescriptor(), accumulator);\n\t\t\tTypeQualifierAnnotation result = accumulator.getResult().getEffectiveTypeQualifierAnnotation();\n\t\t\tif (result == null && accumulator.overrides()) \n\t\t\t\treturn TypeQualifierAnnotation.OVERRIDES_BUT_NO_ANNOTATION;\n\t\t\treturn result;\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tAnalysisContext.currentAnalysisContext().getLookupFailureCallback().reportMissingClass(e);\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"07ce5d214e1efa9957c1156788c8fb55951b68b7","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Get the default (outer-scope) TypeQualifierAnnotation on given method parameter.\n\t *\n\t * @param xmethod            a method\n\t * @param typeQualifierValue the kind of TypeQualifierValue we are looking for\n\t * @return the default (outer scope) TypeQualifierAnnotation on the parameter,\n\t *         or null if there is no default TypeQualifierAnnotation\n\t */\n\tprivate static @CheckForNull TypeQualifierAnnotation getDefaultTypeQualifierAnnotationForParameters(\n\t\t\tXMethod xmethod,\n\t\t\tTypeQualifierValue typeQualifierValue) {\n\n\t\tif (xmethod.isSynthetic())\n\t\t\treturn null;  // synthetic methods don't get default annotations\n\t\t// System.out.println(\"Looking for default \" + typeQualifierValue + \" annotation of parameters of \" + xmethod);\n\t\tAnnotatedObject o = xmethod;\n\t\twhile (true) {\n\t\t\to =  o.getContainingScope();\n\t\t\tif (o == null) return null;\n\t\t\t\n\t\t\t// Check for direct type qualifier annotation\n\t\t\tSet<TypeQualifierAnnotation> applications = new HashSet<TypeQualifierAnnotation>();\n\t\t\tgetDirectApplications(applications, o, ElementType.PARAMETER);\n\t\t\tTypeQualifierAnnotation tqa = findMatchingTypeQualifierAnnotation(applications, typeQualifierValue);\n\t\t\tif (tqa != null) {\n\t\t\t\t// Found matching annotation in outer scope\n\t\t\t\treturn tqa;\n\t\t\t}\n\n\t\t\t// Check for default annotation\n\t\t\ttqa = getDefaultAnnotation(o, typeQualifierValue, ElementType.PARAMETER);\n\t\t\tif (tqa != null) {\n\t\t\t\treturn tqa;\n\t\t\t}\n\t\t}\n\n\t}","id":92442,"modified_method":"/**\n\t * Get the default (outer-scope) TypeQualifierAnnotation on given method parameter.\n\t *\n\t * @param xmethod            a method\n\t * @param typeQualifierValue the kind of TypeQualifierValue we are looking for\n\t * @param stopAtMethodScope TODO\n\t * @return the default (outer scope) TypeQualifierAnnotation on the parameter,\n\t *         or null if there is no default TypeQualifierAnnotation\n\t */\n\tprivate static @CheckForNull TypeQualifierAnnotation getDefaultTypeQualifierAnnotationForParameters(\n\t\t\tXMethod xmethod,\n\t\t\tTypeQualifierValue typeQualifierValue, boolean stopAtMethodScope) {\n\n\t\tif (xmethod.isSynthetic())\n\t\t\treturn null;  // synthetic methods don't get default annotations\n\t\t// System.out.println(\"Looking for default \" + typeQualifierValue + \" annotation of parameters of \" + xmethod);\n\t\tAnnotatedObject o = xmethod;\n\t\twhile (true) {\n\t\t\to =  o.getContainingScope();\n\t\t\tif (o == null) return null;\n\t\t\t\n\t\t\tif (stopAtMethodScope && o instanceof XClass)\n\t\t\t\treturn null;\n\t\t\t// Check for direct type qualifier annotation\n\t\t\tSet<TypeQualifierAnnotation> applications = new HashSet<TypeQualifierAnnotation>();\n\t\t\tgetDirectApplications(applications, o, ElementType.PARAMETER);\n\t\t\tTypeQualifierAnnotation tqa = findMatchingTypeQualifierAnnotation(applications, typeQualifierValue);\n\t\t\tif (tqa != null) {\n\t\t\t\t// Found matching annotation in outer scope\n\t\t\t\treturn tqa;\n\t\t\t}\n\n\t\t\t// Check for default annotation\n\t\t\ttqa = getDefaultAnnotation(o, typeQualifierValue, ElementType.PARAMETER);\n\t\t\tif (tqa != null) {\n\t\t\t\treturn tqa;\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"07ce5d214e1efa9957c1156788c8fb55951b68b7","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static TypeQualifierAnnotation computeEffectiveTypeQualifierAnnotation(TypeQualifierValue typeQualifierValue, AnnotatedObject o) {\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Looking up application of \" + typeQualifierValue + \" on \" + o);\n\t\t}\n\n\t\tMap<AnnotatedObject, TypeQualifierAnnotation> map = getEffectiveObjectAnnotations().get(typeQualifierValue);\n\t\tif (map == null) {\n\t\t\tmap = new HashMap<AnnotatedObject, TypeQualifierAnnotation>();\n\t\t\tgetEffectiveObjectAnnotations().put(typeQualifierValue, map);\n\t\t}\n\n\t\t// Check cached answer\n\t\tTypeQualifierAnnotation result;\n\n\t\tif (map.containsKey(o)) {\n\t\t\tresult = map.get(o);\n\t\t} else {\n\t\t\t// Compute answer\n\t\t\tTypeQualifierAnnotation tqa;\n\n\t\t\t// See if there is a direct application\n\t\t\ttqa = getDirectTypeQualifierAnnotation(o, typeQualifierValue);\n\n\t\t\t// If it's an instance method, check for an inherited annotation\n\t\t\tif (tqa == null && (o instanceof XMethod) && !((XMethod) o).isStatic() \n\t\t\t\t\t&& !((XMethod) o).isPrivate() && !((XMethod) o).getName().equals(\"<init>\") ) {\n\t\t\t\ttqa = getInheritedTypeQualifierAnnotation((XMethod) o, typeQualifierValue);\n\t\t\t}\n\n\t\t\t// Check for a default (outer scope) annotation\n\t\t\tif (tqa == null) {\n\t\t\t\ttqa = getDefaultTypeQualifierAnnotation(o, typeQualifierValue);\n\t\t\t}\n\n\t\t\t// Cache computed answer\n\t\t\tresult = tqa;\n\t\t\tmap.put(o, result);\n\t\t}\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"  => Answer: \" + result);\n\t\t}\n\n\t\t// Return cached answer\n\t\treturn result;\n\t}","id":92443,"modified_method":"private static TypeQualifierAnnotation computeEffectiveTypeQualifierAnnotation(TypeQualifierValue typeQualifierValue, AnnotatedObject o) {\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Looking up application of \" + typeQualifierValue + \" on \" + o);\n\t\t}\n\n\t\tMap<AnnotatedObject, TypeQualifierAnnotation> map = getEffectiveObjectAnnotations().get(typeQualifierValue);\n\t\tif (map == null) {\n\t\t\tmap = new HashMap<AnnotatedObject, TypeQualifierAnnotation>();\n\t\t\tgetEffectiveObjectAnnotations().put(typeQualifierValue, map);\n\t\t}\n\n\t\t// Check cached answer\n\t\tTypeQualifierAnnotation result;\n\n\t\tif (map.containsKey(o)) {\n\t\t\tresult = map.get(o);\n\t\t} else {\n\t\t\t// Compute answer\n\t\t\tTypeQualifierAnnotation tqa;\n\n\t\t\t// See if there is a direct application\n\t\t\ttqa = getDirectTypeQualifierAnnotation(o, typeQualifierValue);\n\n\t\t\t// If it's an instance method, check for an inherited annotation\n\t\t\tif (tqa == null && (o instanceof XMethod) && !((XMethod) o).isStatic() \n\t\t\t\t\t&& !((XMethod) o).isPrivate() && !((XMethod) o).getName().equals(\"<init>\") ) {\n\t\t\t\ttqa = getInheritedTypeQualifierAnnotation((XMethod) o, typeQualifierValue);\n\t\t\t}\n\n\t\t\tboolean methodOverrides = false;\n\t\t\tif (tqa == TypeQualifierAnnotation.OVERRIDES_BUT_NO_ANNOTATION) {\n\t\t\t\tmethodOverrides = true;\n\t\t\t\ttqa = null;\n\t\t\t}\n\t\t\t// Check for a default (outer scope) annotation\n\t\t\tif (tqa == null) {\n\t\t\t\ttqa = getDefaultTypeQualifierAnnotation(o, typeQualifierValue, methodOverrides);\n\t\t\t}\n\n\t\t\t// Cache computed answer\n\t\t\tresult = tqa;\n\t\t\tmap.put(o, result);\n\t\t}\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"  => Answer: \" + result);\n\t\t}\n\n\t\t// Return cached answer\n\t\treturn result;\n\t}","commit_id":"07ce5d214e1efa9957c1156788c8fb55951b68b7","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static TypeQualifierAnnotation computeEffectiveTypeQualifierAnnotation(TypeQualifierValue typeQualifierValue, XMethod xmethod, int parameter) {\n\t\tif (DEBUG) {\n//\t\t\tSystem.out.println(\"XX: \" +System.identityHashCode(typeQualifierValue));\n\t\t\tif (typeQualifierValue.value != null) {\n\t\t\t\tSystem.out.println(\"  Value is \" + typeQualifierValue.value +\"(\"+typeQualifierValue.value.getClass().toString()+\")\");\n\t\t\t}\n\t\t}\n\t\tMap<TypeQualifierValue, DualKeyHashMap<XMethod, Integer, TypeQualifierAnnotation>> effectiveParameterAnnotations = getEffectiveParameterAnnotations();\n\t\tDualKeyHashMap<XMethod, Integer, TypeQualifierAnnotation> map = effectiveParameterAnnotations.get(typeQualifierValue);\n\t\tif (map == null) {\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"computeEffectiveTypeQualifierAnnotation: Creating map for \" + typeQualifierValue);\n\t\t\t}\n\t\t\tmap = new DualKeyHashMap<XMethod, Integer, TypeQualifierAnnotation>();\n\t\t\teffectiveParameterAnnotations.put(typeQualifierValue, map);\n\t\t}\n\n\t\t// Check cached answer\n\t\tTypeQualifierAnnotation result;\n\t\tif (map.containsKey(xmethod, parameter)) {\n\t\t\tresult = map.get(xmethod, parameter);\n\t\t} else {\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"Looking up application of \" + typeQualifierValue + \" on \" + xmethod + \" parameter \" + parameter);\n\t\t\t}\n\n//\t\t\tString desc = xmethod.toString()+\":\"+parameter+\":\"+typeQualifierValue;\n//\t\t\tif (checked.containsKey(desc)) {\n//\t\t\t\t//throw new IllegalStateException(\"Repeating computation of \" + desc, checked.get(desc));\n//\t\t\t\tSystem.out.println(\"Repeating computation of \" + desc);\n//\t\t\t\tSystem.out.println(\"Previously computed:\");\n//\t\t\t\tchecked.get(desc).printStackTrace(System.out);\n//\t\t\t\tthrow new IllegalStateException();\n//\t\t\t}\n//\t\t\tchecked.put(desc, new Throwable().fillInStackTrace());\n\n\t\t\t// Compute answer\n\t\t\tTypeQualifierAnnotation tqa;\n\n\t\t\t// Check direct application\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.print(\"  (1) Checking direct application...\");\n\t\t\t}\n\t\t\ttqa = getDirectTypeQualifierAnnotation(xmethod, parameter, typeQualifierValue);\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(tqa != null ? \"FOUND\" : \"none\");\n\t\t\t}\n\n\t\t\t// If it's an instance method, check for inherited annotation\n\t\t\tif (tqa == null && !xmethod.isStatic() \t&& !xmethod.isPrivate() && !xmethod.getName().equals(\"<init>\")) {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.print(\"  (2) Checking inherited...\");\n\t\t\t\t}\n\t\t\t\ttqa = getInheritedTypeQualifierAnnotation(xmethod, parameter, typeQualifierValue);\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(tqa != null ? \"FOUND\" : \"none\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for default (outer scope) annotation\n\t\t\tif (tqa == null) {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.print(\"  (3) Checking default...\");\n\t\t\t\t}\n\t\t\t\ttqa = getDefaultTypeQualifierAnnotationForParameters(xmethod, typeQualifierValue);\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(tqa != null ? \"FOUND\" : \"none\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cache answer\n\t\t\tresult = tqa;\n\t\t\tmap.put(xmethod, parameter, result);\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"  => Answer: \" + result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!map.containsKey(xmethod, parameter)) {\n\t\t\tthrow new IllegalStateException(\"Did not populate cache?\");\n\t\t}\n\n\t\t// Return cached answer\n\t\treturn result;\n\t}","id":92444,"modified_method":"private static TypeQualifierAnnotation computeEffectiveTypeQualifierAnnotation(TypeQualifierValue typeQualifierValue, XMethod xmethod, int parameter) {\n\t\tif (DEBUG) {\n//\t\t\tSystem.out.println(\"XX: \" +System.identityHashCode(typeQualifierValue));\n\t\t\tif (typeQualifierValue.value != null) {\n\t\t\t\tSystem.out.println(\"  Value is \" + typeQualifierValue.value +\"(\"+typeQualifierValue.value.getClass().toString()+\")\");\n\t\t\t}\n\t\t}\n\t\tMap<TypeQualifierValue, DualKeyHashMap<XMethod, Integer, TypeQualifierAnnotation>> effectiveParameterAnnotations = getEffectiveParameterAnnotations();\n\t\tDualKeyHashMap<XMethod, Integer, TypeQualifierAnnotation> map = effectiveParameterAnnotations.get(typeQualifierValue);\n\t\tif (map == null) {\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"computeEffectiveTypeQualifierAnnotation: Creating map for \" + typeQualifierValue);\n\t\t\t}\n\t\t\tmap = new DualKeyHashMap<XMethod, Integer, TypeQualifierAnnotation>();\n\t\t\teffectiveParameterAnnotations.put(typeQualifierValue, map);\n\t\t}\n\n\t\t// Check cached answer\n\t\tTypeQualifierAnnotation result;\n\t\tif (map.containsKey(xmethod, parameter)) {\n\t\t\tresult = map.get(xmethod, parameter);\n\t\t} else {\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"Looking up application of \" + typeQualifierValue + \" on \" + xmethod + \" parameter \" + parameter);\n\t\t\t}\n\n//\t\t\tString desc = xmethod.toString()+\":\"+parameter+\":\"+typeQualifierValue;\n//\t\t\tif (checked.containsKey(desc)) {\n//\t\t\t\t//throw new IllegalStateException(\"Repeating computation of \" + desc, checked.get(desc));\n//\t\t\t\tSystem.out.println(\"Repeating computation of \" + desc);\n//\t\t\t\tSystem.out.println(\"Previously computed:\");\n//\t\t\t\tchecked.get(desc).printStackTrace(System.out);\n//\t\t\t\tthrow new IllegalStateException();\n//\t\t\t}\n//\t\t\tchecked.put(desc, new Throwable().fillInStackTrace());\n\n\t\t\t// Compute answer\n\t\t\tTypeQualifierAnnotation tqa;\n\n\t\t\t// Check direct application\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.print(\"  (1) Checking direct application...\");\n\t\t\t}\n\t\t\ttqa = getDirectTypeQualifierAnnotation(xmethod, parameter, typeQualifierValue);\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(tqa != null ? \"FOUND\" : \"none\");\n\t\t\t}\n\n\t\t\t\n\t\t\t// If it's an instance method, check for inherited annotation\n\t\t\tif (tqa == null && !xmethod.isStatic() \t&& !xmethod.isPrivate() && !xmethod.getName().equals(\"<init>\")) {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.print(\"  (2) Checking inherited...\");\n\t\t\t\t}\n\t\t\t\ttqa = getInheritedTypeQualifierAnnotation(xmethod, parameter, typeQualifierValue);\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(tqa != null ? \"FOUND\" : \"none\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean overriddenMethod = false;\n\t\t\tif (tqa == TypeQualifierAnnotation.OVERRIDES_BUT_NO_ANNOTATION) {\n\t\t\t\toverriddenMethod = true;\n\t\t\t\ttqa = null;\n\t\t\t}\n\t\t\t// Check for default (outer scope) annotation\n\t\t\tif (tqa == null) {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.print(\"  (3) Checking default...\");\n\t\t\t\t}\n\n\t\t\t\ttqa = getDefaultTypeQualifierAnnotation(xmethod, typeQualifierValue, overriddenMethod);\n\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(tqa != null ? \"FOUND\" : \"none\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cache answer\n\t\t\tresult = tqa;\n\t\t\tmap.put(xmethod, parameter, result);\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"  => Answer: \" + result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!map.containsKey(xmethod, parameter)) {\n\t\t\tthrow new IllegalStateException(\"Did not populate cache?\");\n\t\t}\n\n\t\t// Return cached answer\n\t\treturn result;\n\t}","commit_id":"07ce5d214e1efa9957c1156788c8fb55951b68b7","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Get the default (outer scope) annotation applicable to given\n\t * AnnotatedObject.\n\t *\n\t * @param o                  an AnnotatedObject\n\t * @param typeQualifierValue the kind of TypeQualifierValue we are looking for\n\t * @return the applicable default TypeQualifierAnnotation, or null\n\t *         if there is no default TypeQualifierAnnotation\n\t */\n\tprivate static TypeQualifierAnnotation getDefaultTypeQualifierAnnotation(AnnotatedObject o,\n\t\t\tTypeQualifierValue typeQualifierValue) {\n\n\t\tif (o.isSynthetic())\n\t\t\t\treturn null; // synthetic methods don't get default annotations\n\t\t\n\t\tElementType elementType = o.getElementType();\n\t\twhile (true) {\n\t\t\to = o.getContainingScope();\n\t\t\tif (o == null) return null;\n\t\t\tTypeQualifierAnnotation result;\n\n\t\t\t// Check direct applications of the type qualifier\n\t\t\tSet<TypeQualifierAnnotation> applications = new HashSet<TypeQualifierAnnotation>();\n\t\t\tgetDirectApplications(applications, o, elementType);\n\t\t\tresult = findMatchingTypeQualifierAnnotation(applications, typeQualifierValue);\n\t\t\tif (result != null) {\n\t\t\t\t// Great - found an outer scope with a relevant annotation\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// Check default annotations\n\t\t\tresult = getDefaultAnnotation(o, typeQualifierValue, elementType);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}","id":92445,"modified_method":"/**\n\t * Get the default (outer scope) annotation applicable to given\n\t * AnnotatedObject.\n\t *\n\t * @param o                  an AnnotatedObject\n\t * @param typeQualifierValue the kind of TypeQualifierValue we are looking for\n\t * @return the applicable default TypeQualifierAnnotation, or null\n\t *         if there is no default TypeQualifierAnnotation\n\t */\n\tprivate static TypeQualifierAnnotation getDefaultTypeQualifierAnnotation(AnnotatedObject o,\n\t\t\tTypeQualifierValue typeQualifierValue, boolean stopAtClassScope) {\n\n\t\tif (o.isSynthetic())\n\t\t\t\treturn null; // synthetic methods don't get default annotations\n\t\t\n\t\tElementType elementType = o.getElementType();\n\t\twhile (true) {\n\t\t\to = o.getContainingScope();\n\t\t\tif (o == null) \n\t\t\t\treturn null;\n\t\t\tif (stopAtClassScope && o instanceof XClass)\n\t\t\t\treturn null;\n\t\t\tTypeQualifierAnnotation result;\n\n\t\t\t// Check direct applications of the type qualifier\n\t\t\tSet<TypeQualifierAnnotation> applications = new HashSet<TypeQualifierAnnotation>();\n\t\t\tgetDirectApplications(applications, o, elementType);\n\t\t\tresult = findMatchingTypeQualifierAnnotation(applications, typeQualifierValue);\n\t\t\tif (result != null) {\n\t\t\t\t// Great - found an outer scope with a relevant annotation\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// Check default annotations\n\t\t\tresult = getDefaultAnnotation(o, typeQualifierValue, elementType);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}","commit_id":"07ce5d214e1efa9957c1156788c8fb55951b68b7","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Get the effective inherited TypeQualifierAnnotation on the given\n\t * instance method parameter.\n\t *\n\t * @param xmethod            an instance method\n\t * @param parameter          a parameter (0 == first parameter)\n\t * @param typeQualifierValue the kind of TypeQualifierValue we are looking for\n\t * @return effective inherited TypeQualifierAnnotation on the parameter,\n\t *         or null if there is not effective TypeQualifierAnnotation\n\t */\n\tprivate static @CheckForNull TypeQualifierAnnotation getInheritedTypeQualifierAnnotation(XMethod xmethod, int parameter,\n\t\t\tTypeQualifierValue typeQualifierValue) {\n\t\tassert !xmethod.isStatic();\n\n\t\tParameterAnnotationAccumulator accumulator = new ParameterAnnotationAccumulator(typeQualifierValue, xmethod, parameter);\n\t\ttry {\n\t\t\tAnalysisContext.currentAnalysisContext().getSubtypes2().traverseSupertypes(xmethod.getClassDescriptor(), accumulator);\n\t\t\treturn accumulator.getResult().getEffectiveTypeQualifierAnnotation();\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tAnalysisContext.currentAnalysisContext().getLookupFailureCallback().reportMissingClass(e);\n\t\t\treturn null;\n\t\t}\n\t}","id":92446,"modified_method":"/**\n\t * Get the effective inherited TypeQualifierAnnotation on the given\n\t * instance method parameter.\n\t *\n\t * @param xmethod            an instance method\n\t * @param parameter          a parameter (0 == first parameter)\n\t * @param typeQualifierValue the kind of TypeQualifierValue we are looking for\n\t * @return effective inherited TypeQualifierAnnotation on the parameter,\n\t *         or null if there is not effective TypeQualifierAnnotation\n\t */\n\tprivate static @CheckForNull TypeQualifierAnnotation getInheritedTypeQualifierAnnotation(XMethod xmethod, int parameter,\n\t\t\tTypeQualifierValue typeQualifierValue) {\n\t\tassert !xmethod.isStatic();\n\n\t\tParameterAnnotationAccumulator accumulator = new ParameterAnnotationAccumulator(typeQualifierValue, xmethod, parameter);\n\t\ttry {\n\t\t\tAnalysisContext.currentAnalysisContext().getSubtypes2().traverseSupertypes(xmethod.getClassDescriptor(), accumulator);\n\t\t\tTypeQualifierAnnotation result = accumulator.getResult().getEffectiveTypeQualifierAnnotation();\n\t\t\tif (result == null && accumulator.overrides()) \n\t\t\t\treturn TypeQualifierAnnotation.OVERRIDES_BUT_NO_ANNOTATION;\n\t\t\treturn result;\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tAnalysisContext.currentAnalysisContext().getLookupFailureCallback().reportMissingClass(e);\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"07ce5d214e1efa9957c1156788c8fb55951b68b7","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tprotected TypeQualifierAnnotation lookupAnnotation(XMethod xm) {\n\t\toverrides = true;\n\t\treturn TypeQualifierApplications.getEffectiveTypeQualifierAnnotation(xm, parameter, getTypeQualifierValue());\n\t}","id":92447,"modified_method":"@Override\n\tprotected TypeQualifierAnnotation lookupAnnotation(XMethod xm) {\n\t\toverrides = true;\n\t\tTypeQualifierAnnotation result = TypeQualifierApplications.getEffectiveTypeQualifierAnnotation(xm, parameter, getTypeQualifierValue());\n\t\tif (TypeQualifierApplications.DEBUG && result != null) {\n\t\t\tSystem.out.println(\"Inherit \" + result.when + \" from \" + xm);\n\t\t}\n\t\treturn result;\n\t\n\t}","commit_id":"e51d4035e77deb4116f092fa9e244309486ac2de","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static TypeQualifierAnnotation computeEffectiveTypeQualifierAnnotation(TypeQualifierValue typeQualifierValue, XMethod xmethod, int parameter) {\n\t\tif (DEBUG) {\n//\t\t\tSystem.out.println(\"XX: \" +System.identityHashCode(typeQualifierValue));\n\t\t\tif (typeQualifierValue.value != null) {\n\t\t\t\tSystem.out.println(\"  Value is \" + typeQualifierValue.value +\"(\"+typeQualifierValue.value.getClass().toString()+\")\");\n\t\t\t}\n\t\t}\n\t\tMap<TypeQualifierValue, DualKeyHashMap<XMethod, Integer, TypeQualifierAnnotation>> effectiveParameterAnnotations = getEffectiveParameterAnnotations();\n\t\tDualKeyHashMap<XMethod, Integer, TypeQualifierAnnotation> map = effectiveParameterAnnotations.get(typeQualifierValue);\n\t\tif (map == null) {\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"computeEffectiveTypeQualifierAnnotation: Creating map for \" + typeQualifierValue);\n\t\t\t}\n\t\t\tmap = new DualKeyHashMap<XMethod, Integer, TypeQualifierAnnotation>();\n\t\t\teffectiveParameterAnnotations.put(typeQualifierValue, map);\n\t\t}\n\n\t\t// Check cached answer\n\t\tTypeQualifierAnnotation result;\n\t\tif (map.containsKey(xmethod, parameter)) {\n\t\t\tresult = map.get(xmethod, parameter);\n\t\t} else {\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"Looking up application of \" + typeQualifierValue + \" on \" + xmethod + \" parameter \" + parameter);\n\t\t\t}\n\n//\t\t\tString desc = xmethod.toString()+\":\"+parameter+\":\"+typeQualifierValue;\n//\t\t\tif (checked.containsKey(desc)) {\n//\t\t\t\t//throw new IllegalStateException(\"Repeating computation of \" + desc, checked.get(desc));\n//\t\t\t\tSystem.out.println(\"Repeating computation of \" + desc);\n//\t\t\t\tSystem.out.println(\"Previously computed:\");\n//\t\t\t\tchecked.get(desc).printStackTrace(System.out);\n//\t\t\t\tthrow new IllegalStateException();\n//\t\t\t}\n//\t\t\tchecked.put(desc, new Throwable().fillInStackTrace());\n\n\t\t\t// Compute answer\n\t\t\tTypeQualifierAnnotation tqa;\n\n\t\t\t// Check direct application\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.print(\"  (1) Checking direct application...\");\n\t\t\t}\n\t\t\ttqa = getDirectTypeQualifierAnnotation(xmethod, parameter, typeQualifierValue);\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(tqa != null ? \"FOUND\" : \"none\");\n\t\t\t}\n\n\t\t\t\n\t\t\t// If it's an instance method, check for inherited annotation\n\t\t\tif (tqa == null && !xmethod.isStatic() \t&& !xmethod.isPrivate() && !xmethod.getName().equals(\"<init>\")) {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.print(\"  (2) Checking inherited...\");\n\t\t\t\t}\n\t\t\t\ttqa = getInheritedTypeQualifierAnnotation(xmethod, parameter, typeQualifierValue);\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(tqa != null ? \"FOUND\" : \"none\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean overriddenMethod = false;\n\t\t\tif (tqa == TypeQualifierAnnotation.OVERRIDES_BUT_NO_ANNOTATION) {\n\t\t\t\toverriddenMethod = true;\n\t\t\t\ttqa = null;\n\t\t\t}\n\t\t\t// Check for default (outer scope) annotation\n\t\t\tif (tqa == null) {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.print(\"  (3) Checking default...\");\n\t\t\t\t}\n\n\t\t\t\ttqa = getDefaultTypeQualifierAnnotationForParameters(xmethod, typeQualifierValue, overriddenMethod);\n\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(tqa != null ? \"FOUND\" : \"none\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cache answer\n\t\t\tresult = tqa;\n\t\t\tmap.put(xmethod, parameter, result);\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"  => Answer: \" + result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!map.containsKey(xmethod, parameter)) {\n\t\t\tthrow new IllegalStateException(\"Did not populate cache?\");\n\t\t}\n\n\t\t// Return cached answer\n\t\treturn result;\n\t}","id":92448,"modified_method":"private static TypeQualifierAnnotation computeEffectiveTypeQualifierAnnotation(TypeQualifierValue typeQualifierValue, XMethod xmethod, int parameter) {\n\t\tif (DEBUG) {\n//\t\t\tSystem.out.println(\"XX: \" +System.identityHashCode(typeQualifierValue));\n\t\t\tif (typeQualifierValue.value != null) {\n\t\t\t\tSystem.out.println(\"  Value is \" + typeQualifierValue.value +\"(\"+typeQualifierValue.value.getClass().toString()+\")\");\n\t\t\t}\n\t\t}\n\t\tMap<TypeQualifierValue, DualKeyHashMap<XMethod, Integer, TypeQualifierAnnotation>> effectiveParameterAnnotations = getEffectiveParameterAnnotations();\n\t\tDualKeyHashMap<XMethod, Integer, TypeQualifierAnnotation> map = effectiveParameterAnnotations.get(typeQualifierValue);\n\t\tif (map == null) {\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"computeEffectiveTypeQualifierAnnotation: Creating map for \" + typeQualifierValue);\n\t\t\t}\n\t\t\tmap = new DualKeyHashMap<XMethod, Integer, TypeQualifierAnnotation>();\n\t\t\teffectiveParameterAnnotations.put(typeQualifierValue, map);\n\t\t}\n\n\t\t// Check cached answer\n\t\tTypeQualifierAnnotation result;\n\t\tif (map.containsKey(xmethod, parameter)) {\n\t\t\tresult = map.get(xmethod, parameter);\n\t\t} else {\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"Looking up application of \" + typeQualifierValue + \" on \" + xmethod + \" parameter \" + parameter);\n\t\t\t}\n\n//\t\t\tString desc = xmethod.toString()+\":\"+parameter+\":\"+typeQualifierValue;\n//\t\t\tif (checked.containsKey(desc)) {\n//\t\t\t\t//throw new IllegalStateException(\"Repeating computation of \" + desc, checked.get(desc));\n//\t\t\t\tSystem.out.println(\"Repeating computation of \" + desc);\n//\t\t\t\tSystem.out.println(\"Previously computed:\");\n//\t\t\t\tchecked.get(desc).printStackTrace(System.out);\n//\t\t\t\tthrow new IllegalStateException();\n//\t\t\t}\n//\t\t\tchecked.put(desc, new Throwable().fillInStackTrace());\n\n\t\t\t// Compute answer\n\t\t\tTypeQualifierAnnotation tqa;\n\n\t\t\t// Check direct application\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.print(\"  (1) Checking direct application...\");\n\t\t\t}\n\t\t\ttqa = getDirectTypeQualifierAnnotation(xmethod, parameter, typeQualifierValue);\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(tqa != null ? \"FOUND\" : \"none\");\n\t\t\t}\n\n\t\t\t\n\t\t\t// If it's an instance method, check for inherited annotation\n\t\t\tif (tqa == null && !xmethod.isStatic() \t&& !xmethod.isPrivate() && !xmethod.getName().equals(\"<init>\")) {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.print(\"  (2) Checking inherited...\");\n\t\t\t\t}\n\t\t\t\ttqa = getInheritedTypeQualifierAnnotation(xmethod, parameter, typeQualifierValue);\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tif (tqa == TypeQualifierAnnotation.OVERRIDES_BUT_NO_ANNOTATION) \n\t\t\t\t\t\tSystem.out.println(\"Overridden, no annotation inherited\");\n\t\t\t\t\telse if (tqa != null)\n\t\t\t\t\t\tSystem.out.println(\"Inherited \" + tqa.when);\n\t\t\t\t\telse System.out.println(\"Nothing inherited\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean overriddenMethod = false;\n\t\t\tif (tqa == TypeQualifierAnnotation.OVERRIDES_BUT_NO_ANNOTATION) {\n\t\t\t\toverriddenMethod = true;\n\t\t\t\ttqa = null;\n\t\t\t}\n\t\t\t// Check for default (outer scope) annotation\n\t\t\tif (tqa == null) {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.print(\"  (3) Checking default...\");\n\t\t\t\t}\n\n\t\t\t\ttqa = getDefaultTypeQualifierAnnotationForParameters(xmethod, typeQualifierValue, overriddenMethod);\n\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(tqa != null ? \"FOUND\" : \"none\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cache answer\n\t\t\tresult = tqa;\n\t\t\tmap.put(xmethod, parameter, result);\n\n\t\t\tif (DEBUG ) {\n\t\t\t\tif (result == null)\n\t\t\t\t\tSystem.out.println(\"  => Answer: no annotation on parameter \" + parameter + \" of \" + xmethod);\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"  => Answer: \" + result.when + \" on parameter \" + parameter + \" of \" + xmethod);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!map.containsKey(xmethod, parameter)) {\n\t\t\tthrow new IllegalStateException(\"Did not populate cache?\");\n\t\t}\n\n\t\t// Return cached answer\n\t\treturn result;\n\t}","commit_id":"e51d4035e77deb4116f092fa9e244309486ac2de","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static TypeQualifierAnnotation computeEffectiveTypeQualifierAnnotation(TypeQualifierValue typeQualifierValue, AnnotatedObject o) {\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Looking up application of \" + typeQualifierValue + \" on \" + o);\n\t\t}\n\n\t\tMap<AnnotatedObject, TypeQualifierAnnotation> map = getEffectiveObjectAnnotations().get(typeQualifierValue);\n\t\tif (map == null) {\n\t\t\tmap = new HashMap<AnnotatedObject, TypeQualifierAnnotation>();\n\t\t\tgetEffectiveObjectAnnotations().put(typeQualifierValue, map);\n\t\t}\n\n\t\t// Check cached answer\n\t\tTypeQualifierAnnotation result;\n\n\t\tif (map.containsKey(o)) {\n\t\t\tresult = map.get(o);\n\t\t} else {\n\t\t\t// Compute answer\n\t\t\tTypeQualifierAnnotation tqa;\n\n\t\t\t// See if there is a direct application\n\t\t\ttqa = getDirectTypeQualifierAnnotation(o, typeQualifierValue);\n\n\t\t\t// If it's an instance method, check for an inherited annotation\n\t\t\tif (tqa == null && (o instanceof XMethod) && !((XMethod) o).isStatic() \n\t\t\t\t\t&& !((XMethod) o).isPrivate() && !((XMethod) o).getName().equals(\"<init>\") ) {\n\t\t\t\ttqa = getInheritedTypeQualifierAnnotation((XMethod) o, typeQualifierValue);\n\t\t\t}\n\n\t\t\tboolean methodOverrides = false;\n\t\t\tif (tqa == TypeQualifierAnnotation.OVERRIDES_BUT_NO_ANNOTATION) {\n\t\t\t\tmethodOverrides = true;\n\t\t\t\ttqa = null;\n\t\t\t}\n\t\t\t// Check for a default (outer scope) annotation\n\t\t\tif (tqa == null) {\n\t\t\t\ttqa = getDefaultTypeQualifierAnnotation(o, typeQualifierValue, methodOverrides);\n\t\t\t}\n\n\t\t\t// Cache computed answer\n\t\t\tresult = tqa;\n\t\t\tmap.put(o, result);\n\t\t}\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"  => Answer: \" + result);\n\t\t}\n\n\t\t// Return cached answer\n\t\treturn result;\n\t}","id":92449,"modified_method":"private static TypeQualifierAnnotation computeEffectiveTypeQualifierAnnotation(TypeQualifierValue typeQualifierValue, AnnotatedObject o) {\n\t\t\n\t\tMap<AnnotatedObject, TypeQualifierAnnotation> map = getEffectiveObjectAnnotations().get(typeQualifierValue);\n\t\tif (map == null) {\n\t\t\tmap = new HashMap<AnnotatedObject, TypeQualifierAnnotation>();\n\t\t\tgetEffectiveObjectAnnotations().put(typeQualifierValue, map);\n\t\t}\n\n\t\t// Check cached answer\n\t\tTypeQualifierAnnotation result;\n\n\t\tif (map.containsKey(o)) {\n\t\t\tresult = map.get(o);\n\t\t} else {\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"Looking up application of \" + typeQualifierValue + \" on \" + o);\n\t\t\t}\n\n\t\t\t// Compute answer\n\t\t\tTypeQualifierAnnotation tqa;\n\n\t\t\t// See if there is a direct application\n\t\t\ttqa = getDirectTypeQualifierAnnotation(o, typeQualifierValue);\n\n\t\t\t// If it's an instance method, check for an inherited annotation\n\t\t\tif (tqa == null && (o instanceof XMethod) && !((XMethod) o).isStatic() \n\t\t\t\t\t&& !((XMethod) o).isPrivate() && !((XMethod) o).getName().equals(\"<init>\") ) {\n\t\t\t\ttqa = getInheritedTypeQualifierAnnotation((XMethod) o, typeQualifierValue);\n\t\t\t}\n\n\t\t\tboolean methodOverrides = false;\n\t\t\tif (tqa == TypeQualifierAnnotation.OVERRIDES_BUT_NO_ANNOTATION) {\n\t\t\t\tmethodOverrides = true;\n\t\t\t\ttqa = null;\n\t\t\t}\n\t\t\t// Check for a default (outer scope) annotation\n\t\t\tif (tqa == null) {\n\t\t\t\ttqa = getDefaultTypeQualifierAnnotation(o, typeQualifierValue, methodOverrides);\n\t\t\t}\n\n\t\t\t// Cache computed answer\n\t\t\tresult = tqa;\n\t\t\tmap.put(o, result);\n\t\t\tif (DEBUG && result != null) {\n\t\t\t\tif (result == null)\n\t\t\t\t\tSystem.out.println(\"  => Answer: no annotation on \" + o);\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"  => Answer: \" + result.when  + \" on \" + o);\n\t\t\t\tif (o instanceof XMethod \n\t\t\t\t\t\t&& ((XMethod)o).getClassName().equals(\"java.lang.StringBuilder\")\n\t\t\t\t\t    && ((XMethod)o).getName().equals(\"toString\"))\n\t\t\t\t\tSystem.out.println(\"huh\");\n\t\t\t}\n\n\t\t}\n\n\t\t// Return cached answer\n\t\treturn result;\n\t}","commit_id":"e51d4035e77deb4116f092fa9e244309486ac2de","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"protected boolean checkForClose(final boolean iForce) {\r\n    lock.acquireSharedLock();\r\n    try {\r\n      if (status == STATUS.CLOSED)\r\n        return false;\r\n\r\n      final int remainingUsers = getUsers() > 0 ? removeUser() : 0;\r\n\r\n      return iForce || (!OGlobalConfiguration.STORAGE_KEEP_OPEN.getValueAsBoolean() && remainingUsers == 0);\r\n    } finally {\r\n      lock.releaseSharedLock();\r\n    }\r\n  }","id":92450,"modified_method":"protected boolean checkForClose(final boolean iForce) {\r\n    lock.acquireSharedLock();\r\n    try {\r\n      if (status == STATUS.CLOSED)\r\n        return false;\r\n\r\n      final int remainingUsers = getUsers() > 0 ? removeUser() : 0;\r\n\r\n      return iForce || (!(OGlobalConfiguration.STORAGE_KEEP_OPEN.getValueAsBoolean() && this instanceof OStorageEmbedded) && remainingUsers == 0);\r\n    } finally {\r\n      lock.releaseSharedLock();\r\n    }\r\n  }","commit_id":"6e097ae2c2e2d36d4c61459938a983bff5b0b3eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void updateIdentityAfterCommit(final ORID oldRid, final ORID newRid) {\r\n    if (oldRid.equals(newRid))\r\n      // NO CHANGE, IGNORE IT\r\n      return;\r\n\r\n    final ORecordOperation rec = getRecordEntry(oldRid);\r\n    if (rec != null) {\r\n      if (allEntries.remove(oldRid) != null)\r\n        allEntries.put(newRid, rec);\r\n\r\n      if (recordEntries.remove(oldRid) != null)\r\n        recordEntries.put(newRid, rec);\r\n\r\n      if (!rec.getRecord().getIdentity().equals(newRid)) {\r\n        rec.getRecord().onBeforeIdentityChanged(oldRid);\r\n        rec.getRecord().setIdentity(new ORecordId(newRid));\r\n        rec.getRecord().onAfterIdentityChanged(rec.getRecord());\r\n      }\r\n    }\r\n\r\n    // UPDATE INDEXES\r\n    final List<OTransactionRecordIndexOperation> transactionIndexOperations = recordIndexOperations.get(oldRid);\r\n    if (transactionIndexOperations != null) {\r\n      for (final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations) {\r\n        OTransactionIndexChanges indexEntryChanges = indexEntries.get(indexOperation.index);\r\n        if (indexEntryChanges == null)\r\n          continue;\r\n\r\n        final OTransactionIndexChangesPerKey changesPerKey = indexEntryChanges.getChangesPerKey(indexOperation.key);\r\n        updateChangesIdentity(oldRid, newRid, changesPerKey);\r\n      }\r\n    }\r\n  }","id":92451,"modified_method":"public void updateIdentityAfterCommit(final ORID oldRid, final ORID newRid) {\r\n    if (oldRid.equals(newRid))\r\n      // NO CHANGE, IGNORE IT\r\n      return;\r\n\r\n    final ORecordOperation rec = getRecordEntry(oldRid);\r\n    if (rec != null) {\r\n      if (allEntries.remove(oldRid) != null)\r\n        allEntries.put(newRid, rec);\r\n\r\n      if (recordEntries.remove(oldRid) != null)\r\n        recordEntries.put(newRid, rec);\r\n\r\n      if (!rec.getRecord().getIdentity().equals(newRid)) {\r\n        rec.getRecord().onBeforeIdentityChanged(oldRid);\r\n\r\n\t\t\t\tfinal ORecordId recordId = (ORecordId)rec.getRecord().getIdentity();\r\n\t\t\t\tif (recordId == null) {\r\n\t\t\t\t\trec.getRecord().setIdentity(new ORecordId(newRid));\r\n\t\t\t\t} else {\r\n\t\t\t\t\trecordId.clusterPosition = newRid.getClusterPosition();\r\n\t\t\t\t\trecordId.clusterId = newRid.getClusterId();\r\n\t\t\t\t}\r\n\r\n        rec.getRecord().onAfterIdentityChanged(rec.getRecord());\r\n      }\r\n    }\r\n\r\n    // UPDATE INDEXES\r\n    final List<OTransactionRecordIndexOperation> transactionIndexOperations = recordIndexOperations.get(oldRid);\r\n    if (transactionIndexOperations != null) {\r\n      for (final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations) {\r\n        OTransactionIndexChanges indexEntryChanges = indexEntries.get(indexOperation.index);\r\n        if (indexEntryChanges == null)\r\n          continue;\r\n\r\n        final OTransactionIndexChangesPerKey changesPerKey = indexEntryChanges.getChangesPerKey(indexOperation.key);\r\n        updateChangesIdentity(oldRid, newRid, changesPerKey);\r\n      }\r\n    }\r\n  }","commit_id":"6e097ae2c2e2d36d4c61459938a983bff5b0b3eb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean isEmbeddedStreaming() {\r\n\t\tif (embeddedStreaming) {\r\n\t\t\tfinal int binaryThreshold = OGlobalConfiguration.MVRBTREE_RID_BINARY_THRESHOLD.getValueAsInteger();\r\n\t\t\tif (binaryThreshold > 0 && size > binaryThreshold) {\r\n\t\t\t\t// CHANGE TO EXTERNAL BINARY\r\n\t\t\t\ttree.setDirtyOwner();\r\n\t\t\t\tembeddedStreaming = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn embeddedStreaming;\r\n\t}","id":92452,"modified_method":"public boolean isEmbeddedStreaming() {\r\n\t\tif (embeddedStreaming && !marshalling) {\r\n\t\t\tfinal int binaryThreshold = OGlobalConfiguration.MVRBTREE_RID_BINARY_THRESHOLD.getValueAsInteger();\r\n\t\t\tif (binaryThreshold > 0 && size > binaryThreshold && tree != null) {\r\n\t\t\t\t// CHANGE TO EXTERNAL BINARY\r\n\t\t\t\ttree.setDirtyOwner();\r\n\t\t\t\tembeddedStreaming = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn embeddedStreaming;\r\n\t}","commit_id":"4d87ebfcca0faa018e9ff58ff49fb135657b6b09","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OMVRBTreeRIDProvider(final OStorage iStorage, final int iClusterId, final ORID iRID) {\r\n\t\tthis(iStorage, getDatabase().getClusterNameById(iClusterId));\r\n\t\trecord.setIdentity(iRID.getClusterId(), iRID.getClusterPosition());\r\n\t}","id":92453,"modified_method":"public OMVRBTreeRIDProvider(final OStorage iStorage, final int iClusterId, final ORID iRID) {\r\n\t\tthis(iStorage, getDatabase().getClusterNameById(iClusterId));\r\n\t\tif (iRID != null)\r\n\t\t\trecord.setIdentity(iRID.getClusterId(), iRID.getClusterPosition());\r\n\t}","commit_id":"4d87ebfcca0faa018e9ff58ff49fb135657b6b09","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OMVRBTreeRIDProvider(final OStorage iStorage, final String iClusterName) {\r\n\t\tsuper(new ODocument(getDatabase()), iStorage, iClusterName);\r\n\t\t((ODocument) record).field(\"pageSize\", pageSize);\r\n\t}","id":92454,"modified_method":"public OMVRBTreeRIDProvider(final OMVRBTreeRIDProvider iSource) {\r\n\t\tthis(null, iSource.getClusterId(), iSource.getRoot());\r\n\t}","commit_id":"4d87ebfcca0faa018e9ff58ff49fb135657b6b09","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OMVRBTreeRIDSet copy() {\r\n\t\tfinal OMVRBTreeRIDSet clone = new OMVRBTreeRIDSet(new OMVRBTreeRID(new OMVRBTreeRIDProvider(null, tree.getProvider()\r\n\t\t\t\t.getClusterId())));\r\n\t\tclone.addAll(this);\r\n\t\treturn clone;\r\n\t}","id":92455,"modified_method":"public OMVRBTreeRIDSet copy() {\r\n\t\tfinal OMVRBTreeRIDSet clone = new OMVRBTreeRIDSet(this);\r\n\t\treturn clone;\r\n\t}","commit_id":"4d87ebfcca0faa018e9ff58ff49fb135657b6b09","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * <p>Contructor to be used by all child classes to create a\n     * new instance and get the name right.\n     *\n     * @param clazz        the Grails class\n     */\n    public GrailsHibernateDomainClass(Class clazz, SessionFactory sessionFactory,ClassMetadata metaData) {\n        super(clazz, \"\");\n\n        BeanWrapper bean = getReference();\n        // configure identity property\n        String ident = metaData.getIdentifierPropertyName();\n        Class identType = bean.getPropertyType(ident);\n        this.identifier = new GrailsHibernateDomainClassProperty(this,ident);\n        this.identifier.setIdentity(true);\n        this.identifier.setType(identType);\n\n        propertyMap.put(ident,identifier);\n\n        // configure remaining properties\n        String[] propertyNames = metaData.getPropertyNames();\n        for (int i = 0; i < propertyNames.length; i++) {\n            String propertyName = propertyNames[i];\n            if(!propertyName.equals(ident)) {\n                GrailsHibernateDomainClassProperty prop = new GrailsHibernateDomainClassProperty(this,propertyName);\n                prop.setType(bean.getPropertyType(propertyName));\n                Type hibernateType = metaData.getPropertyType(propertyName);\n                // if its an association type\n                if(hibernateType.isAssociationType()) {\n                    prop.setAssociation(true);\n                    // get the associated type from the session factory\n                    // and set it on the property\n                    AssociationType assType = (AssociationType)hibernateType;\n                    String associatedEntity = assType.getAssociatedEntityName((SessionFactoryImplementor)sessionFactory);\n                    ClassMetadata associatedMetaData = sessionFactory.getClassMetadata(associatedEntity);\n                    prop.setRelatedClassType(associatedMetaData.getMappedClass(EntityMode.POJO));\n                    // configure type of relationship\n                    if(hibernateType.isCollectionType()) {\n                        prop.setOneToMany(true);\n                    }\n                    else if(hibernateType.isEntityType()) {\n                        prop.setManyToOne(true);\n                        // might not really be true, but for our purposes this is ok\n                        prop.setOneToOne(true);\n                    }\n                }\n                propertyMap.put(propertyName,prop);\n            }\n        }\n\n        this.properties = (GrailsDomainClassProperty[])propertyMap.values().toArray(new GrailsDomainClassProperty[propertyMap.size()]);\n\t\t// process the constraints\n\t\tevaluateConstraints();        \n    }","id":92456,"modified_method":"/**\n     * <p>Contructor to be used by all child classes to create a\n     * new instance and get the name right.\n     *\n     * @param clazz        the Grails class\n     */\n    public GrailsHibernateDomainClass(Class clazz, SessionFactory sessionFactory,ClassMetadata metaData) {\n        super(clazz, \"\");\n\n        BeanWrapper bean = getReference();\n        // configure identity property\n        String ident = metaData.getIdentifierPropertyName();\n\n        if(ident != null) {\n            Class identType = bean.getPropertyType(ident);\n            this.identifier = new GrailsHibernateDomainClassProperty(this,ident);\n            this.identifier.setIdentity(true);\n            this.identifier.setType(identType);\n        }\n\n        propertyMap.put(ident,identifier);\n\n        // configure remaining properties\n        String[] propertyNames = metaData.getPropertyNames();\n        for (int i = 0; i < propertyNames.length; i++) {\n            String propertyName = propertyNames[i];\n            if(!propertyName.equals(ident)) {\n                GrailsHibernateDomainClassProperty prop = new GrailsHibernateDomainClassProperty(this,propertyName);\n                prop.setType(bean.getPropertyType(propertyName));\n                Type hibernateType = metaData.getPropertyType(propertyName);\n                // if its an association type\n                if(hibernateType.isAssociationType()) {\n                    prop.setAssociation(true);\n                    // get the associated type from the session factory\n                    // and set it on the property\n                    AssociationType assType = (AssociationType)hibernateType;\n                    String associatedEntity = assType.getAssociatedEntityName((SessionFactoryImplementor)sessionFactory);\n                    ClassMetadata associatedMetaData = sessionFactory.getClassMetadata(associatedEntity);\n                    prop.setRelatedClassType(associatedMetaData.getMappedClass(EntityMode.POJO));\n                    // configure type of relationship\n                    if(hibernateType.isCollectionType()) {\n                        prop.setOneToMany(true);\n                    }\n                    else if(hibernateType.isEntityType()) {\n                        prop.setManyToOne(true);\n                        // might not really be true, but for our purposes this is ok\n                        prop.setOneToOne(true);\n                    }\n                }\n                propertyMap.put(propertyName,prop);\n            }\n        }\n\n        this.properties = (GrailsDomainClassProperty[])propertyMap.values().toArray(new GrailsDomainClassProperty[propertyMap.size()]);\n\t\t// process the constraints\n\t\tevaluateConstraints();        \n    }","commit_id":"769a1bd1b79e9aa5db97379464271540063d5444","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n  public String getHelpTopic() {\n    return myChildren.get(myTabs.getSelectedIndex()).getHelpTopic();\n  }","id":92457,"modified_method":"@Override\n  public String getHelpTopic() {\n    final String helpTopic = myChildren.get(myTabs.getSelectedIndex()).getHelpTopic();\n    return helpTopic != null ? helpTopic : getMainChild().getHelpTopic();\n  }","commit_id":"c26871df3effe841ce388b12365ca338fa755134","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public String getHelpTopic() {\n    return null;\n  }","id":92458,"modified_method":"public String getHelpTopic() {\n    return \"Build_Configuration_page\";\n  }","commit_id":"c26871df3effe841ce388b12365ca338fa755134","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void addRootNodes(final MasterDetailsComponent.MyNode parent, final Project project, final Runnable treeUpdater) {\n    myProject = project;\n    final ProjectStructureConfigurable projectConfig = ProjectStructureConfigurable.getInstance(project);\n    {\n      MasterDetailsComponent.MyNode globalLibrariesNode = new MasterDetailsComponent.MyNode(\n        new TextConfigurable<Object>(GLOBAL_LIBRARIES, \"Global libraries\", \"Global Libraries\",\n                                     \"Use global libraries to share code between many projects\", PlatformIcons.LIBRARY_ICON,\n                                     PlatformIcons.LIBRARY_ICON));\n      projectConfig.getModulesConfig().addNode(globalLibrariesNode, parent);\n\n      LibrariesModifiableModel globalLibrariesModel =\n        ProjectStructureConfigurable.getInstance(project).getContext().getGlobalLibrariesProvider().getModifiableModel();\n      addLibrariesNodes(globalLibrariesModel, globalLibrariesNode, treeUpdater, project);\n    }\n\n    {\n      MasterDetailsComponent.MyNode projectLibrariesNode = new MasterDetailsComponent.MyNode(\n        new TextConfigurable<Object>(PROJECT_LIBRARIES, \"Project libraries\", \"Project Libraries\",\n                                     \"Use project libraries to share code between modules in the project\", PlatformIcons.LIBRARY_ICON,\n                                     PlatformIcons.LIBRARY_ICON));\n      projectConfig.getModulesConfig().addNode(projectLibrariesNode, parent);\n\n      LibrariesModifiableModel projectLibrariesModel =\n        ProjectStructureConfigurable.getInstance(project).getContext().getProjectLibrariesProvider().getModifiableModel();\n      addLibrariesNodes(projectLibrariesModel, projectLibrariesNode, treeUpdater, project);\n    }\n  }","id":92459,"modified_method":"public void addRootNodes(final MasterDetailsComponent.MyNode parent, final Project project, final Runnable treeUpdater) {\n    myProject = project;\n    final ProjectStructureConfigurable projectConfig = ProjectStructureConfigurable.getInstance(project);\n    {\n      MasterDetailsComponent.MyNode globalLibrariesNode = new MasterDetailsComponent.MyNode(\n        new SharedLibraryParentNodeConfigurable(GLOBAL_LIBRARIES, \"Global libraries\", \"Global Libraries\",\n                                     \"Use global libraries to share code between many projects\"));\n      projectConfig.getModulesConfig().addNode(globalLibrariesNode, parent);\n\n      LibrariesModifiableModel globalLibrariesModel =\n        ProjectStructureConfigurable.getInstance(project).getContext().getGlobalLibrariesProvider().getModifiableModel();\n      addLibrariesNodes(globalLibrariesModel, globalLibrariesNode, treeUpdater, project);\n    }\n\n    {\n      MasterDetailsComponent.MyNode projectLibrariesNode = new MasterDetailsComponent.MyNode(\n        new SharedLibraryParentNodeConfigurable(PROJECT_LIBRARIES, \"Project libraries\", \"Project Libraries\",\n                                     \"Use project libraries to share code between modules in the project\"));\n      projectConfig.getModulesConfig().addNode(projectLibrariesNode, parent);\n\n      LibrariesModifiableModel projectLibrariesModel =\n        ProjectStructureConfigurable.getInstance(project).getContext().getProjectLibrariesProvider().getModifiableModel();\n      addLibrariesNodes(projectLibrariesModel, projectLibrariesNode, treeUpdater, project);\n    }\n  }","commit_id":"c26871df3effe841ce388b12365ca338fa755134","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public String getHelpTopic() {\n    return null; // TODO\n  }","id":92460,"modified_method":"@Override\n  public String getHelpTopic() {\n    return \"projectStructure.modules.sources\";\n  }","commit_id":"c26871df3effe841ce388b12365ca338fa755134","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NonNls\n  public String getHelpTopic() {\n    NewCodeStyleSettingsPanel selectedPanel = ensureCurrentPanel();\n    if (selectedPanel == null) {\n      return \"reference.settingsdialog.IDE.globalcodestyle\";\n    }\n    return selectedPanel.getHelpTopic();\n  }","id":92461,"modified_method":"@NonNls\n  public String getHelpTopic() {\n    NewCodeStyleSettingsPanel selectedPanel = ensureCurrentPanel();\n    if (selectedPanel == null) {\n      return \"reference.settingsdialog.IDE.globalcodestyle\";\n    }\n    String helpTopic = selectedPanel.getHelpTopic();\n    if (helpTopic != null) {\n      return helpTopic;\n    }\n    return \"\";\n  }","commit_id":"7941afe048a9ebdd0149d08eb22110ef9d547df9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected PsiFile doReformat(final Project project, final PsiFile psiFile) {\n    final String text = psiFile.getText();\n    final PsiDocumentManager manager = PsiDocumentManager.getInstance(project);\n    final Document doc = manager.getDocument(psiFile);\n    CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            doc.replaceString(0, doc.getTextLength(), text);\n            manager.commitDocument(doc);\n            try {\n              CodeStyleManager.getInstance(project).reformat(psiFile);\n            }\n            catch (IncorrectOperationException e) {\n              LOG.error(e);\n            }\n          }\n        });\n      }\n    }, \"\", \"\");\n    manager.commitDocument(doc);\n    return psiFile;\n  }","id":92462,"modified_method":"@Override\n  protected PsiFile doReformat(final Project project, final PsiFile psiFile) {\n    final String text = psiFile.getText();\n    final PsiDocumentManager manager = PsiDocumentManager.getInstance(project);\n    final Document doc = manager.getDocument(psiFile);\n    CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            doc.replaceString(0, doc.getTextLength(), text);\n            manager.commitDocument(doc);\n            try {\n              CodeStyleManager.getInstance(project).reformat(psiFile);\n            }\n            catch (IncorrectOperationException e) {\n              LOG.error(e);\n            }\n          }\n        });\n      }\n    }, \"\", \"\");\n    if (doc != null) {\n      manager.commitDocument(doc);\n    }\n    return psiFile;\n  }","commit_id":"7941afe048a9ebdd0149d08eb22110ef9d547df9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected final FileType getFileType() {\n    if (myLanguage != null) {\n      return myLanguage.getAssociatedFileType();\n    }\n    Language langs[] = LanguageCodeStyleSettingsProvider.getLanguagesWithCodeStyleSettings();\n    if (langs.length > 0) {\n      myLanguage = langs[0];\n      FileType type = langs[0].getAssociatedFileType();\n      if (type != null) return type;\n    }\n    return StdFileTypes.JAVA;\n  }","id":92463,"modified_method":"@NotNull\n  @Override\n  protected final FileType getFileType() {\n    if (myLanguage != null) {\n      FileType assocType = myLanguage.getAssociatedFileType();\n      if (assocType != null) {\n        return assocType;\n      }\n    }\n    Language[] langs = LanguageCodeStyleSettingsProvider.getLanguagesWithCodeStyleSettings();\n    if (langs.length > 0) {\n      setCurrLanguage(langs[0]);\n      FileType type = langs[0].getAssociatedFileType();\n      if (type != null) return type;\n    }\n    return StdFileTypes.JAVA;\n  }","commit_id":"7941afe048a9ebdd0149d08eb22110ef9d547df9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected EditorHighlighter createHighlighter(final EditorColorsScheme scheme) {\n    Project project = PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext());\n    if (project == null) {\n      project = ProjectManager.getInstance().getDefaultProject();\n    }\n    if (getFileType() instanceof LanguageFileType) {\n      return ((LanguageFileType)getFileType()).getEditorHighlighter(project, null, scheme);\n    }\n    return null;\n  }","id":92464,"modified_method":"@Nullable\n  protected EditorHighlighter createHighlighter(final EditorColorsScheme scheme) {\n    Project project = PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(this.getPanel()));\n    if (project == null) {\n      project = ProjectManager.getInstance().getDefaultProject();\n    }\n    if (getFileType() instanceof LanguageFileType) {\n      return ((LanguageFileType)getFileType()).getEditorHighlighter(project, null, scheme);\n    }\n    return null;\n  }","commit_id":"7941afe048a9ebdd0149d08eb22110ef9d547df9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected String getPreviewText() {\n    if (myLanguage == null) return \"\";\n    return LanguageCodeStyleSettingsProvider.getCodeSample(myLanguage, getSettingsType());\n  }","id":92465,"modified_method":"@Override\n  protected String getPreviewText() {\n    if (myLanguage == null) return \"\";\n    String sample = LanguageCodeStyleSettingsProvider.getCodeSample(myLanguage, getSettingsType());\n    if (sample == null) return \"\";\n    return sample;\n  }","commit_id":"7941afe048a9ebdd0149d08eb22110ef9d547df9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setLanguage(Language language) {\n    myLanguage = language;\n    updatePreviewEditor();\n  }","id":92466,"modified_method":"public void setLanguage(Language language) {\n    setCurrLanguage(language);\n    updatePreviewEditor();\n  }","commit_id":"7941afe048a9ebdd0149d08eb22110ef9d547df9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getHelpTopic() {\n    return ObjectUtils.notNull(super.getHelpTopic(), \"reference.settings.clouds\");\n  }","id":92467,"modified_method":"@Override\n  public String getHelpTopic() {\n    String result = super.getHelpTopic();\n    if (result == null) {\n      ServerType<?> singleServerType = getSingleServerType();\n      if (singleServerType != null) {\n        return singleServerType.getHelpTopic();\n      }\n    }\n    return \"reference.settings.clouds\";\n  }","commit_id":"aa1d2b82f361a9fccd4257be2f446f423d4e20a9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Execute the given HTTP method, returning an HTTP response.\n     * \n     * Note that when you are done with the response, you must call {@link #closeResponse()} so that it gets cleaned up properly.\n     */\n    public CloseableHttpResponse execute(final HttpUriRequest method) throws ClientProtocolException, IOException {\n        LOG.debug(\"execute: \" + this.toString());\n        // override some headers with our versions\n        final HttpRequestWrapper requestWrapper = HttpRequestWrapper.wrap(method);\n        if (m_userAgent != null && !m_userAgent.trim().isEmpty()) {\n            requestWrapper.setHeader(HTTP.USER_AGENT, m_userAgent);\n        }\n        if (m_virtualHost != null && !m_virtualHost.trim().isEmpty()) {\n            requestWrapper.setHeader(HTTP.TARGET_HOST, m_virtualHost);\n        }\n        if (m_version != null) {\n            requestWrapper.setProtocolVersion(m_version);\n        }\n\n        return getClient().execute(requestWrapper);\n    }","id":92468,"modified_method":"/**\n     * Execute the given HTTP method, returning an HTTP response.\n     * \n     * Note that when you are done with the response, you must call {@link #closeResponse()} so that it gets cleaned up properly.\n     */\n    public CloseableHttpResponse execute(final HttpUriRequest method) throws ClientProtocolException, IOException {\n        LOG.debug(\"execute: \" + this.toString() + \"; method: \" + method.toString());\n        // override some headers with our versions\n        final HttpRequestWrapper requestWrapper = HttpRequestWrapper.wrap(method);\n        if (m_userAgent != null && !m_userAgent.trim().isEmpty()) {\n            requestWrapper.setHeader(HTTP.USER_AGENT, m_userAgent);\n        }\n        if (m_virtualHost != null && !m_virtualHost.trim().isEmpty()) {\n            requestWrapper.setHeader(HTTP.TARGET_HOST, m_virtualHost);\n        }\n        if (m_version != null) {\n            requestWrapper.setProtocolVersion(m_version);\n        }\n\n        return getClient().execute(requestWrapper);\n    }","commit_id":"84a473fef40a2572456d3bd15050f7fe73c39b9f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n        public void setQueryParameters(List<NameValuePair> parms) {\n            URI uri = this.getURI();\n            URI uriWithQueryString = null;\n            try {\n                String query = URLEncodedUtils.format(parms, \"UTF-8\");\n                URIBuilder ub = new URIBuilder(uri);\n                final List<NameValuePair> params = URLEncodedUtils.parse(query, Charset.forName(\"UTF-8\"));\n                ub.setParameters(params);\n                uriWithQueryString = ub.build();\n                this.setURI(uriWithQueryString);\n            } catch (URISyntaxException e) {\n                LOG.warn(e.getMessage(), e);\n            }\n        }","id":92469,"modified_method":"@Override\n        public void setQueryParameters(List<NameValuePair> parms) {\n            URI uri = this.getURI();\n            URI uriWithQueryString = null;\n            try {\n                String query = URLEncodedUtils.format(parms, \"UTF-8\");\n                URIBuilder ub = new URIBuilder(uri);\n                final List<NameValuePair> params = URLEncodedUtils.parse(query, Charset.forName(\"UTF-8\"));\n                if (!params.isEmpty()) {\n                    ub.setParameters(params);\n                }\n                uriWithQueryString = ub.build();\n                this.setURI(uriWithQueryString);\n            } catch (URISyntaxException e) {\n                LOG.warn(e.getMessage(), e);\n            }\n        }","commit_id":"84a473fef40a2572456d3bd15050f7fe73c39b9f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private URI getURI(MonitoredService svc) throws URISyntaxException {\n            Properties svcProps = getServiceProperties(svc);\n            Properties seqProps = getSequenceProperties();\n            String host = getHost(seqProps, svcProps);\n            if (m_page.getRequireIPv4()) {\n                try {\n                    InetAddress address = DnsUtils.resolveHostname(host, false);\n                    if (!(address instanceof Inet4Address)) throw new UnknownHostException();\n                    host = InetAddressUtils.str(address);\n                } catch (UnknownHostException e) {\n                    throw new PageSequenceMonitorException(\"failed to find IPv4 address for hostname: \" + host);\n                }\n            } else if (m_page.getRequireIPv6()) {\n                try {\n                    InetAddress address = DnsUtils.resolveHostname(host, true);\n                    host = \"[\" + InetAddressUtils.str(address) + \"]\";\n                } catch (UnknownHostException e) {\n                    throw new PageSequenceMonitorException(\"failed to find IPv6 address for hostname: \" + host);\n                }\n            } else {\n                // Just leave the hostname as-is, let httpclient resolve it using the platform preferences\n            }\n            URIBuilder ub = new URIBuilder();\n            ub.setScheme(getScheme());\n            ub.setHost(host);\n            ub.setPort(getPort());\n            ub.setPath(getPath(seqProps, svcProps));\n            final List<NameValuePair> params = URLEncodedUtils.parse(getQuery(seqProps, svcProps), Charset.forName(\"UTF-8\"));\n            ub.setParameters(params);\n            ub.setFragment(getFragment(seqProps, svcProps));\n            return ub.build();\n        }","id":92470,"modified_method":"private URI getURI(MonitoredService svc) throws URISyntaxException {\n            Properties svcProps = getServiceProperties(svc);\n            Properties seqProps = getSequenceProperties();\n            String host = getHost(seqProps, svcProps);\n            if (m_page.getRequireIPv4()) {\n                try {\n                    InetAddress address = DnsUtils.resolveHostname(host, false);\n                    if (!(address instanceof Inet4Address)) throw new UnknownHostException();\n                    host = InetAddressUtils.str(address);\n                } catch (UnknownHostException e) {\n                    throw new PageSequenceMonitorException(\"failed to find IPv4 address for hostname: \" + host);\n                }\n            } else if (m_page.getRequireIPv6()) {\n                try {\n                    InetAddress address = DnsUtils.resolveHostname(host, true);\n                    host = \"[\" + InetAddressUtils.str(address) + \"]\";\n                } catch (UnknownHostException e) {\n                    throw new PageSequenceMonitorException(\"failed to find IPv6 address for hostname: \" + host);\n                }\n            } else {\n                // Just leave the hostname as-is, let httpclient resolve it using the platform preferences\n            }\n            URIBuilder ub = new URIBuilder();\n            ub.setScheme(getScheme());\n            ub.setHost(host);\n            ub.setPort(getPort());\n            ub.setPath(getPath(seqProps, svcProps));\n            final List<NameValuePair> params = URLEncodedUtils.parse(getQuery(seqProps, svcProps), Charset.forName(\"UTF-8\"));\n            if (!params.isEmpty()) {\n                ub.setParameters(params);\n            }\n            ub.setFragment(getFragment(seqProps, svcProps));\n            return ub.build();\n        }","commit_id":"84a473fef40a2572456d3bd15050f7fe73c39b9f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static HttpGet buildGetMethod(final URI uri, final HttpCollectionSet collectionSet) {\n        URI uriWithQueryString = null;\n        List<NameValuePair> queryParams = buildRequestParameters(collectionSet);\n        try {\n            StringBuffer query = new StringBuffer();\n            query.append(URLEncodedUtils.format(queryParams, \"UTF-8\"));\n            if (uri.getQuery() != null && !uri.getQuery().trim().isEmpty()) {\n                if (query.length() > 0) {\n                    query.append(\"&\");\n                }\n                query.append(uri.getQuery());\n            }\n            final URIBuilder ub = new URIBuilder(uri);\n            if (query.length() > 0) {\n                final List<NameValuePair> params = URLEncodedUtils.parse(query.toString(), Charset.forName(\"UTF-8\"));\n                ub.setParameters(params);\n            }\n            uriWithQueryString = ub.build();\n            return new HttpGet(uriWithQueryString);\n        } catch (URISyntaxException e) {\n            LOG.warn(e.getMessage(), e);\n            return new HttpGet(uri);\n        }\n    }","id":92471,"modified_method":"private static HttpGet buildGetMethod(final URI uri, final HttpCollectionSet collectionSet) {\n        URI uriWithQueryString = null;\n        List<NameValuePair> queryParams = buildRequestParameters(collectionSet);\n        try {\n            StringBuffer query = new StringBuffer();\n            query.append(URLEncodedUtils.format(queryParams, \"UTF-8\"));\n            if (uri.getQuery() != null && !uri.getQuery().trim().isEmpty()) {\n                if (query.length() > 0) {\n                    query.append(\"&\");\n                }\n                query.append(uri.getQuery());\n            }\n            final URIBuilder ub = new URIBuilder(uri);\n            if (query.length() > 0) {\n                final List<NameValuePair> params = URLEncodedUtils.parse(query.toString(), Charset.forName(\"UTF-8\"));\n                if (!params.isEmpty()) {\n                    ub.setParameters(params);\n                }\n            }\n            uriWithQueryString = ub.build();\n            return new HttpGet(uriWithQueryString);\n        } catch (URISyntaxException e) {\n            LOG.warn(e.getMessage(), e);\n            return new HttpGet(uri);\n        }\n    }","commit_id":"41ed2f62e8d0f1d671982204fd2c395668dc5ce3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public InputStream getInputStream() throws IOException {\n        try {\n            if (m_clientWrapper == null) {\n                connect();\n            }\n\n            // Build URL\n            int port = m_url.getPort() > 0 ? m_url.getPort() : m_url.getDefaultPort();\n            URIBuilder ub = new URIBuilder();\n            ub.setPort(port);\n            ub.setScheme(m_url.getProtocol());\n            ub.setHost(m_url.getHost());\n            ub.setPath(m_url.getPath());\n            if (m_url.getQuery() != null && !m_url.getQuery().trim().isEmpty()) {\n                final List<NameValuePair> params = URLEncodedUtils.parse(m_url.getQuery(), Charset.forName(\"UTF-8\"));\n                ub.addParameters(params);\n            }\n\n            // Build Request\n            HttpRequestBase request = null;\n            if (m_request != null && m_request.getMethod().equalsIgnoreCase(\"post\")) {\n                final Content cnt = m_request.getContent();\n                HttpPost post = new HttpPost(ub.build());\n                ContentType contentType = ContentType.create(cnt.getType());\n                LOG.info(\"Processing POST request for %s\", contentType);\n                if (contentType.getMimeType().equals(ContentType.APPLICATION_FORM_URLENCODED.getMimeType())) {\n                    FormFields fields = JaxbUtils.unmarshal(FormFields.class, cnt.getData());\n                    post.setEntity(fields.getEntity());\n                } else {\n                    StringEntity entity = new StringEntity(cnt.getData(), contentType);\n                    post.setEntity(entity);\n                }\n                request = post;\n            } else {\n                request = new HttpGet(ub.build());\n            }\n\n            if (m_request != null) {\n                // Add Custom Headers\n                for (final Header header : m_request.getHeaders()) {\n                    request.addHeader(header.getName(), header.getValue());\n                }\n            }\n\n            // Get Response\n            CloseableHttpResponse response = m_clientWrapper.execute(request);\n            return response.getEntity().getContent();\n        } catch (Exception e) {\n            throw new IOException(\"Can't retrieve \" + m_url.getPath() + \" from \" + m_url.getHost() + \" because \" + e.getMessage(), e);\n        }\n    }","id":92472,"modified_method":"@Override\n    public InputStream getInputStream() throws IOException {\n        try {\n            if (m_clientWrapper == null) {\n                connect();\n            }\n\n            // Build URL\n            int port = m_url.getPort() > 0 ? m_url.getPort() : m_url.getDefaultPort();\n            URIBuilder ub = new URIBuilder();\n            ub.setPort(port);\n            ub.setScheme(m_url.getProtocol());\n            ub.setHost(m_url.getHost());\n            ub.setPath(m_url.getPath());\n            if (m_url.getQuery() != null && !m_url.getQuery().trim().isEmpty()) {\n                final List<NameValuePair> params = URLEncodedUtils.parse(m_url.getQuery(), Charset.forName(\"UTF-8\"));\n                if (!params.isEmpty()) {\n                    ub.addParameters(params);\n                }\n            }\n\n            // Build Request\n            HttpRequestBase request = null;\n            if (m_request != null && m_request.getMethod().equalsIgnoreCase(\"post\")) {\n                final Content cnt = m_request.getContent();\n                HttpPost post = new HttpPost(ub.build());\n                ContentType contentType = ContentType.create(cnt.getType());\n                LOG.info(\"Processing POST request for %s\", contentType);\n                if (contentType.getMimeType().equals(ContentType.APPLICATION_FORM_URLENCODED.getMimeType())) {\n                    FormFields fields = JaxbUtils.unmarshal(FormFields.class, cnt.getData());\n                    post.setEntity(fields.getEntity());\n                } else {\n                    StringEntity entity = new StringEntity(cnt.getData(), contentType);\n                    post.setEntity(entity);\n                }\n                request = post;\n            } else {\n                request = new HttpGet(ub.build());\n            }\n\n            if (m_request != null) {\n                // Add Custom Headers\n                for (final Header header : m_request.getHeaders()) {\n                    request.addHeader(header.getName(), header.getValue());\n                }\n            }\n\n            // Get Response\n            CloseableHttpResponse response = m_clientWrapper.execute(request);\n            return response.getEntity().getContent();\n        } catch (Exception e) {\n            throw new IOException(\"Can't retrieve \" + m_url.getPath() + \" from \" + m_url.getHost() + \" because \" + e.getMessage(), e);\n        }\n    }","commit_id":"41ed2f62e8d0f1d671982204fd2c395668dc5ce3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void connect(InetAddress address, int port, int timeout) throws IOException, Exception {\n        final URIBuilder ub = new URIBuilder();\n        ub.setScheme(m_schema);\n        ub.setHost(InetAddressUtils.str(address));\n        ub.setPort(port);\n        ub.setPath(m_path);\n        if (m_queryString != null && m_queryString.trim().length() > 0) {\n            final List<NameValuePair> params = URLEncodedUtils.parse(m_queryString, Charset.forName(\"UTF-8\"));\n            ub.setParameters(params);\n        }\n\n        m_httpMethod = new HttpGet(ub.build());\n        m_httpMethod.setProtocolVersion(m_version);\n\n        m_httpClientWrapper = HttpClientWrapper.create();\n        if (m_overrideSSL) {\n            try {\n                m_httpClientWrapper.trustSelfSigned(\"https\");\n            } catch (final Exception e) {\n                LOG.warn(\"Failed to create relaxed SSL client.\", e);\n            }\n        }\n        if (m_userAgent != null && !m_userAgent.trim().isEmpty()) {\n            m_httpClientWrapper.setUserAgent(m_userAgent);\n        }\n        if (timeout > 0) {\n            m_httpClientWrapper.setConnectionTimeout(timeout);\n            m_httpClientWrapper.setSocketTimeout(timeout);\n        }\n        if (m_virtualHost != null && !m_virtualHost.trim().isEmpty()) {\n            m_httpClientWrapper.setVirtualHost(m_virtualHost);\n        }\n        if (m_userName != null && !m_userName.trim().isEmpty()) {\n            m_httpClientWrapper.addBasicCredentials(m_userName, m_password);\n        }\n        if (m_authPreemptive) {\n            m_httpClientWrapper.usePreemptiveAuth();\n        }\n    }","id":92473,"modified_method":"@Override\n    public void connect(InetAddress address, int port, int timeout) throws IOException, Exception {\n        final URIBuilder ub = new URIBuilder();\n        ub.setScheme(m_schema);\n        ub.setHost(InetAddressUtils.str(address));\n        ub.setPort(port);\n        ub.setPath(m_path);\n        if (m_queryString != null && m_queryString.trim().length() > 0) {\n            final List<NameValuePair> params = URLEncodedUtils.parse(m_queryString, Charset.forName(\"UTF-8\"));\n            if (!params.isEmpty()) {\n                ub.setParameters(params);\n            }\n        }\n\n        m_httpMethod = new HttpGet(ub.build());\n        m_httpMethod.setProtocolVersion(m_version);\n\n        m_httpClientWrapper = HttpClientWrapper.create();\n        if (m_overrideSSL) {\n            try {\n                m_httpClientWrapper.trustSelfSigned(\"https\");\n            } catch (final Exception e) {\n                LOG.warn(\"Failed to create relaxed SSL client.\", e);\n            }\n        }\n        if (m_userAgent != null && !m_userAgent.trim().isEmpty()) {\n            m_httpClientWrapper.setUserAgent(m_userAgent);\n        }\n        if (timeout > 0) {\n            m_httpClientWrapper.setConnectionTimeout(timeout);\n            m_httpClientWrapper.setSocketTimeout(timeout);\n        }\n        if (m_virtualHost != null && !m_virtualHost.trim().isEmpty()) {\n            m_httpClientWrapper.setVirtualHost(m_virtualHost);\n        }\n        if (m_userName != null && !m_userName.trim().isEmpty()) {\n            m_httpClientWrapper.addBasicCredentials(m_userName, m_password);\n        }\n        if (m_authPreemptive) {\n            m_httpClientWrapper.usePreemptiveAuth();\n        }\n    }","commit_id":"41ed2f62e8d0f1d671982204fd2c395668dc5ce3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public PollStatus poll(MonitoredService svc, Map<String,Object> map) {\n        PollStatus pollStatus = PollStatus.unresponsive();\n        HttpClientWrapper clientWrapper = HttpClientWrapper.create();\n\n        try {\n            final String hostAddress = InetAddressUtils.str(svc.getAddress());\n\n            URIBuilder ub = new URIBuilder();\n            ub.setScheme(ParameterMap.getKeyedString(map, \"scheme\", DEFAULT_SCHEME));\n            ub.setHost(hostAddress);\n            ub.setPort(ParameterMap.getKeyedInteger(map, \"port\", DEFAULT_PORT));\n            ub.setPath(ParameterMap.getKeyedString(map, \"path\", DEFAULT_PATH));\n\n            String queryString = ParameterMap.getKeyedString(map,\"queryString\",null);\n            if (queryString != null && !queryString.trim().isEmpty()) {\n                final List<NameValuePair> params = URLEncodedUtils.parse(queryString, Charset.forName(\"UTF-8\"));\n                ub.setParameters(params);\n            }\n\n            final HttpGet getMethod = new HttpGet(ub.build());\n            clientWrapper.setConnectionTimeout(ParameterMap.getKeyedInteger(map, \"timeout\", DEFAULT_TIMEOUT))\n                .setSocketTimeout(ParameterMap.getKeyedInteger(map, \"timeout\", DEFAULT_TIMEOUT));\n\n            final String userAgent = ParameterMap.getKeyedString(map,\"user-agent\",DEFAULT_USER_AGENT);\n            if (userAgent != null && !userAgent.trim().isEmpty()) {\n                clientWrapper.setUserAgent(userAgent);\n            }\n\n            final String virtualHost = ParameterMap.getKeyedString(map,\"virtual-host\", hostAddress);\n            if (virtualHost != null && !virtualHost.trim().isEmpty()) {\n                clientWrapper.setVirtualHost(virtualHost);\n            }\n\n            if(ParameterMap.getKeyedBoolean(map, \"http-1.0\", false)) {\n                clientWrapper.setVersion(HttpVersion.HTTP_1_0);\n            }\n\n            for(final Object okey : map.keySet()) {\n                final String key = okey.toString();\n                if(key.matches(\"header_[0-9]+$\")){\n                    final String headerName  = ParameterMap.getKeyedString(map,key,null);\n                    final String headerValue = ParameterMap.getKeyedString(map,key + \"_value\",null);\n                    getMethod.setHeader(headerName, headerValue);\n                }\n            }\n\n            if(ParameterMap.getKeyedBoolean(map,\"auth-enabled\",false)) {\n                clientWrapper.addBasicCredentials(ParameterMap.getKeyedString(map, \"auth-user\", DEFAULT_USER), ParameterMap.getKeyedString(map, \"auth-password\", DEFAULT_PASSWORD));\n                if (ParameterMap.getKeyedBoolean(map, \"auth-preemptive\", true)) {\n                    clientWrapper.usePreemptiveAuth();\n                }\n            }\n\n            LOG.debug(\"getMethod parameters: {}\", getMethod);\n            CloseableHttpResponse response = clientWrapper.execute(getMethod);\n            int statusCode = response.getStatusLine().getStatusCode();\n            String statusText = response.getStatusLine().getReasonPhrase();\n            String expectedText = ParameterMap.getKeyedString(map,\"response-text\",null);\n\n            LOG.debug(\"returned results are:\");\n\n            if(!inRange(ParameterMap.getKeyedString(map, \"response-range\", DEFAULT_HTTP_STATUS_RANGE),statusCode)){\n                pollStatus = PollStatus.unavailable(statusText);\n            }\n            else {\n                pollStatus = PollStatus.available();\n            }\n\n            if (expectedText!=null){\n                String responseText = EntityUtils.toString(response.getEntity()); \n                if(expectedText.charAt(0)=='~'){\n                    if(!responseText.matches(expectedText.substring(1))){\n                        pollStatus = PollStatus.unavailable(\"Regex Failed\");\n                    }\n                    else \n                        pollStatus = PollStatus.available();\n                }\n                else {\n                    if(expectedText.equals(responseText))\n                        pollStatus = PollStatus.available();\n                    else\n                        pollStatus = PollStatus.unavailable(\"Did not find expected Text\");\n                }\n            }\n\n        } catch (IOException e) {\n            LOG.info(e.getMessage());\n        } catch (URISyntaxException e) {\n            LOG.info(e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(clientWrapper);\n        }\n        return pollStatus;\n    }","id":92474,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public PollStatus poll(MonitoredService svc, Map<String,Object> map) {\n        PollStatus pollStatus = PollStatus.unresponsive();\n        HttpClientWrapper clientWrapper = HttpClientWrapper.create();\n\n        try {\n            final String hostAddress = InetAddressUtils.str(svc.getAddress());\n\n            URIBuilder ub = new URIBuilder();\n            ub.setScheme(ParameterMap.getKeyedString(map, \"scheme\", DEFAULT_SCHEME));\n            ub.setHost(hostAddress);\n            ub.setPort(ParameterMap.getKeyedInteger(map, \"port\", DEFAULT_PORT));\n            ub.setPath(ParameterMap.getKeyedString(map, \"path\", DEFAULT_PATH));\n\n            String queryString = ParameterMap.getKeyedString(map,\"queryString\",null);\n            if (queryString != null && !queryString.trim().isEmpty()) {\n                final List<NameValuePair> params = URLEncodedUtils.parse(queryString, Charset.forName(\"UTF-8\"));\n                if (!params.isEmpty()) {\n                    ub.setParameters(params);\n                }\n            }\n\n            final HttpGet getMethod = new HttpGet(ub.build());\n            clientWrapper.setConnectionTimeout(ParameterMap.getKeyedInteger(map, \"timeout\", DEFAULT_TIMEOUT))\n                .setSocketTimeout(ParameterMap.getKeyedInteger(map, \"timeout\", DEFAULT_TIMEOUT));\n\n            final String userAgent = ParameterMap.getKeyedString(map,\"user-agent\",DEFAULT_USER_AGENT);\n            if (userAgent != null && !userAgent.trim().isEmpty()) {\n                clientWrapper.setUserAgent(userAgent);\n            }\n\n            final String virtualHost = ParameterMap.getKeyedString(map,\"virtual-host\", hostAddress);\n            if (virtualHost != null && !virtualHost.trim().isEmpty()) {\n                clientWrapper.setVirtualHost(virtualHost);\n            }\n\n            if(ParameterMap.getKeyedBoolean(map, \"http-1.0\", false)) {\n                clientWrapper.setVersion(HttpVersion.HTTP_1_0);\n            }\n\n            for(final Object okey : map.keySet()) {\n                final String key = okey.toString();\n                if(key.matches(\"header_[0-9]+$\")){\n                    final String headerName  = ParameterMap.getKeyedString(map,key,null);\n                    final String headerValue = ParameterMap.getKeyedString(map,key + \"_value\",null);\n                    getMethod.setHeader(headerName, headerValue);\n                }\n            }\n\n            if(ParameterMap.getKeyedBoolean(map,\"auth-enabled\",false)) {\n                clientWrapper.addBasicCredentials(ParameterMap.getKeyedString(map, \"auth-user\", DEFAULT_USER), ParameterMap.getKeyedString(map, \"auth-password\", DEFAULT_PASSWORD));\n                if (ParameterMap.getKeyedBoolean(map, \"auth-preemptive\", true)) {\n                    clientWrapper.usePreemptiveAuth();\n                }\n            }\n\n            LOG.debug(\"getMethod parameters: {}\", getMethod);\n            CloseableHttpResponse response = clientWrapper.execute(getMethod);\n            int statusCode = response.getStatusLine().getStatusCode();\n            String statusText = response.getStatusLine().getReasonPhrase();\n            String expectedText = ParameterMap.getKeyedString(map,\"response-text\",null);\n\n            LOG.debug(\"returned results are:\");\n\n            if(!inRange(ParameterMap.getKeyedString(map, \"response-range\", DEFAULT_HTTP_STATUS_RANGE),statusCode)){\n                pollStatus = PollStatus.unavailable(statusText);\n            }\n            else {\n                pollStatus = PollStatus.available();\n            }\n\n            if (expectedText!=null){\n                String responseText = EntityUtils.toString(response.getEntity()); \n                if(expectedText.charAt(0)=='~'){\n                    if(!responseText.matches(expectedText.substring(1))){\n                        pollStatus = PollStatus.unavailable(\"Regex Failed\");\n                    }\n                    else \n                        pollStatus = PollStatus.available();\n                }\n                else {\n                    if(expectedText.equals(responseText))\n                        pollStatus = PollStatus.available();\n                    else\n                        pollStatus = PollStatus.unavailable(\"Did not find expected Text\");\n                }\n            }\n\n        } catch (IOException e) {\n            LOG.info(e.getMessage());\n        } catch (URISyntaxException e) {\n            LOG.info(e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(clientWrapper);\n        }\n        return pollStatus;\n    }","commit_id":"41ed2f62e8d0f1d671982204fd2c395668dc5ce3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Execute the given HTTP method, returning an HTTP response.\n     * \n     * Note that when you are done with the response, you must call {@link #closeResponse()} so that it gets cleaned up properly.\n     */\n    public CloseableHttpResponse execute(final HttpUriRequest method) throws ClientProtocolException, IOException {\n        LOG.debug(\"execute: \" + this.toString());\n        // override some headers with our versions\n        final HttpRequestWrapper requestWrapper = HttpRequestWrapper.wrap(method);\n        if (m_userAgent != null && !m_userAgent.trim().isEmpty()) {\n            requestWrapper.setHeader(HTTP.USER_AGENT, m_userAgent);\n        }\n        if (m_virtualHost != null && !m_virtualHost.trim().isEmpty()) {\n            requestWrapper.setHeader(HTTP.TARGET_HOST, m_virtualHost);\n        }\n        if (m_version != null) {\n            requestWrapper.setProtocolVersion(m_version);\n        }\n\n        return getClient().execute(requestWrapper);\n    }","id":92475,"modified_method":"/**\n     * Execute the given HTTP method, returning an HTTP response.\n     * \n     * Note that when you are done with the response, you must call {@link #closeResponse()} so that it gets cleaned up properly.\n     */\n    public CloseableHttpResponse execute(final HttpUriRequest method) throws ClientProtocolException, IOException {\n        LOG.debug(\"execute: \" + this.toString() + \"; method: \" + method.toString());\n        // override some headers with our versions\n        final HttpRequestWrapper requestWrapper = HttpRequestWrapper.wrap(method);\n        if (m_userAgent != null && !m_userAgent.trim().isEmpty()) {\n            requestWrapper.setHeader(HTTP.USER_AGENT, m_userAgent);\n        }\n        if (m_virtualHost != null && !m_virtualHost.trim().isEmpty()) {\n            requestWrapper.setHeader(HTTP.TARGET_HOST, m_virtualHost);\n        }\n        if (m_version != null) {\n            requestWrapper.setProtocolVersion(m_version);\n        }\n\n        return getClient().execute(requestWrapper);\n    }","commit_id":"7d35791f78a7c6028d37db18f7a84cdcf3fd6ce8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n        public void setQueryParameters(List<NameValuePair> parms) {\n            URI uri = this.getURI();\n            URI uriWithQueryString = null;\n            try {\n                String query = URLEncodedUtils.format(parms, \"UTF-8\");\n                URIBuilder ub = new URIBuilder(uri);\n                final List<NameValuePair> params = URLEncodedUtils.parse(query, Charset.forName(\"UTF-8\"));\n                ub.setParameters(params);\n                uriWithQueryString = ub.build();\n                this.setURI(uriWithQueryString);\n            } catch (URISyntaxException e) {\n                LOG.warn(e.getMessage(), e);\n            }\n        }","id":92476,"modified_method":"@Override\n        public void setQueryParameters(List<NameValuePair> parms) {\n            URI uri = this.getURI();\n            URI uriWithQueryString = null;\n            try {\n                String query = URLEncodedUtils.format(parms, \"UTF-8\");\n                URIBuilder ub = new URIBuilder(uri);\n                final List<NameValuePair> params = URLEncodedUtils.parse(query, Charset.forName(\"UTF-8\"));\n                if (!params.isEmpty()) {\n                    ub.setParameters(params);\n                }\n                uriWithQueryString = ub.build();\n                this.setURI(uriWithQueryString);\n            } catch (URISyntaxException e) {\n                LOG.warn(e.getMessage(), e);\n            }\n        }","commit_id":"7d35791f78a7c6028d37db18f7a84cdcf3fd6ce8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private URI getURI(MonitoredService svc) throws URISyntaxException {\n            Properties svcProps = getServiceProperties(svc);\n            Properties seqProps = getSequenceProperties();\n            String host = getHost(seqProps, svcProps);\n            if (m_page.getRequireIPv4()) {\n                try {\n                    InetAddress address = DnsUtils.resolveHostname(host, false);\n                    if (!(address instanceof Inet4Address)) throw new UnknownHostException();\n                    host = InetAddressUtils.str(address);\n                } catch (UnknownHostException e) {\n                    throw new PageSequenceMonitorException(\"failed to find IPv4 address for hostname: \" + host);\n                }\n            } else if (m_page.getRequireIPv6()) {\n                try {\n                    InetAddress address = DnsUtils.resolveHostname(host, true);\n                    host = \"[\" + InetAddressUtils.str(address) + \"]\";\n                } catch (UnknownHostException e) {\n                    throw new PageSequenceMonitorException(\"failed to find IPv6 address for hostname: \" + host);\n                }\n            } else {\n                // Just leave the hostname as-is, let httpclient resolve it using the platform preferences\n            }\n            URIBuilder ub = new URIBuilder();\n            ub.setScheme(getScheme());\n            ub.setHost(host);\n            ub.setPort(getPort());\n            ub.setPath(getPath(seqProps, svcProps));\n            final List<NameValuePair> params = URLEncodedUtils.parse(getQuery(seqProps, svcProps), Charset.forName(\"UTF-8\"));\n            ub.setParameters(params);\n            ub.setFragment(getFragment(seqProps, svcProps));\n            return ub.build();\n        }","id":92477,"modified_method":"private URI getURI(MonitoredService svc) throws URISyntaxException {\n            Properties svcProps = getServiceProperties(svc);\n            Properties seqProps = getSequenceProperties();\n            String host = getHost(seqProps, svcProps);\n            if (m_page.getRequireIPv4()) {\n                try {\n                    InetAddress address = DnsUtils.resolveHostname(host, false);\n                    if (!(address instanceof Inet4Address)) throw new UnknownHostException();\n                    host = InetAddressUtils.str(address);\n                } catch (UnknownHostException e) {\n                    throw new PageSequenceMonitorException(\"failed to find IPv4 address for hostname: \" + host);\n                }\n            } else if (m_page.getRequireIPv6()) {\n                try {\n                    InetAddress address = DnsUtils.resolveHostname(host, true);\n                    host = \"[\" + InetAddressUtils.str(address) + \"]\";\n                } catch (UnknownHostException e) {\n                    throw new PageSequenceMonitorException(\"failed to find IPv6 address for hostname: \" + host);\n                }\n            } else {\n                // Just leave the hostname as-is, let httpclient resolve it using the platform preferences\n            }\n            URIBuilder ub = new URIBuilder();\n            ub.setScheme(getScheme());\n            ub.setHost(host);\n            ub.setPort(getPort());\n            ub.setPath(getPath(seqProps, svcProps));\n            final List<NameValuePair> params = URLEncodedUtils.parse(getQuery(seqProps, svcProps), Charset.forName(\"UTF-8\"));\n            if (!params.isEmpty()) {\n                ub.setParameters(params);\n            }\n            ub.setFragment(getFragment(seqProps, svcProps));\n            return ub.build();\n        }","commit_id":"7d35791f78a7c6028d37db18f7a84cdcf3fd6ce8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@SuppressLint(\"NewApi\")\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tgetMyApplication().applyTheme(this);\n\t\tsupportRequestWindowFeature(Window.FEATURE_NO_TITLE);\n\t\tif (Build.VERSION.SDK_INT > Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n\t\t\tgetWindow().setUiOptions(ActivityInfo.UIOPTION_SPLIT_ACTION_BAR_WHEN_NARROW);\n\t\t}\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tString title = getString(R.string.shared_string_help);\n\t\tString url = \"index.html\";\n\t\tif(getIntent() != null) {\n\t\t\tString tl = getIntent().getStringExtra(TITLE);\n\t\t\tif(tl != null) {\n\t\t\t\ttitle = tl;\n\t\t\t}\n\t\t\tString ul = getIntent().getStringExtra(URL);\n\t\t\tif(ul != null) {\n\t\t\t\turl = ul;\n\t\t\t}\n\t\t}\n\t\tgetSupportActionBar().setTitle(title);\n\t\tsetContentView(R.layout.help_activity);\n\t\twv = (WebView) findViewById(R.id.webView);\n\t\twv.setFocusable(true);\n        wv.setFocusableInTouchMode(true);\n\t\twv.requestFocus(View.FOCUS_DOWN);\n\t\twv.setOnTouchListener(new View.OnTouchListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\tif (!v.hasFocus()) {\n\t\t\t\t\t\tv.requestFocus();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\t\n\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onPageFinished(WebView view, String url) {\n\t\t\t\twv.requestFocus(View.FOCUS_DOWN);\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onLoadResource(WebView view, String url) {\n\t\t\t\tsuper.onLoadResource(view, url);\n\t\t\t}\n\t\t});\n\t\twv.loadUrl(FILE_ANDROID_ASSET_HELP + url);  \n\t}","id":92478,"modified_method":"@SuppressLint(\"NewApi\")\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tgetMyApplication().applyTheme(this);\n\t\tsupportRequestWindowFeature(Window.FEATURE_NO_TITLE);\n\t\tif (Build.VERSION.SDK_INT > Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n\t\t\tgetWindow().setUiOptions(ActivityInfo.UIOPTION_SPLIT_ACTION_BAR_WHEN_NARROW);\n\t\t}\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tString title = getString(R.string.shared_string_help);\n\t\tString url = \"index.html\";\n\t\tif(getIntent() != null) {\n\t\t\tString tl = getIntent().getStringExtra(TITLE);\n\t\t\tif(tl != null) {\n\t\t\t\ttitle = tl;\n\t\t\t}\n\t\t\tString ul = getIntent().getStringExtra(URL);\n\t\t\tif(ul != null) {\n\t\t\t\turl = ul;\n\t\t\t}\n\t\t}\n\t\tgetSupportActionBar().setTitle(title);\n\t\tsetContentView(R.layout.help_activity);\n\t\tmWebView = (WebView) findViewById(R.id.webView);\n\t\tmWebView.setFocusable(true);\n        mWebView.setFocusableInTouchMode(true);\n\t\tmWebView.requestFocus(View.FOCUS_DOWN);\n\t\tmWebView.setOnTouchListener(new View.OnTouchListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onTouch(View view, MotionEvent event) {\n\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\tif (!view.hasFocus()) {\n\t\t\t\t\t\t\tview.requestFocus();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\tmWebView.setWebViewClient(new WebViewClient() {\n\n\t\t\t@Override\n\t\t\tpublic void onPageFinished(WebView view, String url) {\n\t\t\t\tmWebView.requestFocus(View.FOCUS_DOWN);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onLoadResource(WebView view, String url) {\n\t\t\t\tsuper.onLoadResource(view, url);\n\t\t\t}\n\t\t});\n\t\tif (savedInstanceState != null) {\n\t\t\tmWebView.restoreState(savedInstanceState);\n\t\t} else {\n\t\t\tmWebView.loadUrl(FILE_ANDROID_ASSET_HELP + url);\n\t\t}\n\t}","commit_id":"899f093dc30d8cb152a80b40be4312b8a3599901","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tint itemId = item.getItemId();\n\t\tswitch (itemId) {\n\t\tcase android.R.id.home:\n\t\t\tfinish();\n\t\t\treturn true;\n\t\tcase HOME:\n\t\t\twv.loadUrl(FILE_ANDROID_ASSET_HELP + \"index.html\");\n\t\t\treturn true;\n\t\tcase BACK:\n\t\t\tif(wv.canGoBack()) {\n\t\t\t\twv.goBack();\n\t\t\t}\n\t\t\treturn true;\n\t\tcase FORWARD:\n\t\t\tif(wv.canGoForward()) {\n\t\t\t\twv.goForward();\n\t\t\t}\n\t\t\treturn true;\n\t\tcase CLOSE:\n\t\t\tfinish();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":92479,"modified_method":"@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tint itemId = item.getItemId();\n\t\tswitch (itemId) {\n\t\tcase android.R.id.home:\n\t\t\tfinish();\n\t\t\treturn true;\n\t\tcase HOME:\n\t\t\tmWebView.loadUrl(FILE_ANDROID_ASSET_HELP + \"index.html\");\n\t\t\treturn true;\n\t\tcase BACK:\n\t\t\tif(mWebView.canGoBack()) {\n\t\t\t\tmWebView.goBack();\n\t\t\t}\n\t\t\treturn true;\n\t\tcase FORWARD:\n\t\t\tif(mWebView.canGoForward()) {\n\t\t\t\tmWebView.goForward();\n\t\t\t}\n\t\t\treturn true;\n\t\tcase CLOSE:\n\t\t\tfinish();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"899f093dc30d8cb152a80b40be4312b8a3599901","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tint itemId = item.getItemId();\n\t\tswitch (itemId) {\n\t\tcase android.R.id.home:\n\t\t\tfinish();\n\t\t\treturn true;\n\t\tcase HOME:\n\t\t\twv.loadUrl(FILE_ANDROID_ASSET_HELP + \"index.html\");\n\t\t\treturn true;\n\t\tcase BACK:\n\t\t\tif(wv.canGoBack()) {\n\t\t\t\twv.goBack();\n\t\t\t}\n\t\t\treturn true;\n\t\tcase FORWARD:\n\t\t\tif(wv.canGoForward()) {\n\t\t\t\twv.goForward();\n\t\t\t}\n\t\t\treturn true;\n\t\tcase CLOSE:\n\t\t\tfinish();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":92480,"modified_method":"@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tint itemId = item.getItemId();\n\t\tswitch (itemId) {\n\t\tcase android.R.id.home:\n\t\t\tfinish();\n\t\t\treturn true;\n\t\tcase HOME:\n\t\t\tmWebView.loadUrl(FILE_ANDROID_ASSET_HELP + \"index.html\");\n\t\t\treturn true;\n\t\tcase BACK:\n\t\t\tif(mWebView.canGoBack()) {\n\t\t\t\tmWebView.goBack();\n\t\t\t}\n\t\t\treturn true;\n\t\tcase FORWARD:\n\t\t\tif(mWebView.canGoForward()) {\n\t\t\t\tmWebView.goForward();\n\t\t\t}\n\t\t\treturn true;\n\t\tcase CLOSE:\n\t\t\tfinish();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"362aecfc7a5d7b2bc0298548fa1bd6898d2e3bf2","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@SuppressLint(\"NewApi\")\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tgetMyApplication().applyTheme(this);\n\t\tsupportRequestWindowFeature(Window.FEATURE_NO_TITLE);\n\t\tif (Build.VERSION.SDK_INT > Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n\t\t\tgetWindow().setUiOptions(ActivityInfo.UIOPTION_SPLIT_ACTION_BAR_WHEN_NARROW);\n\t\t}\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tString title = getString(R.string.shared_string_help);\n\t\tString url = \"index.html\";\n\t\tif(getIntent() != null) {\n\t\t\tString tl = getIntent().getStringExtra(TITLE);\n\t\t\tif(tl != null) {\n\t\t\t\ttitle = tl;\n\t\t\t}\n\t\t\tString ul = getIntent().getStringExtra(URL);\n\t\t\tif(ul != null) {\n\t\t\t\turl = ul;\n\t\t\t}\n\t\t}\n\t\tgetSupportActionBar().setTitle(title);\n\t\tsetContentView(R.layout.help_activity);\n\t\twv = (WebView) findViewById(R.id.webView);\n\t\twv.setFocusable(true);\n        wv.setFocusableInTouchMode(true);\n\t\twv.requestFocus(View.FOCUS_DOWN);\n\t\twv.setOnTouchListener(new View.OnTouchListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\tif (!v.hasFocus()) {\n\t\t\t\t\t\tv.requestFocus();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\t\n\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onPageFinished(WebView view, String url) {\n\t\t\t\twv.requestFocus(View.FOCUS_DOWN);\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onLoadResource(WebView view, String url) {\n\t\t\t\tsuper.onLoadResource(view, url);\n\t\t\t}\n\t\t});\n\t\twv.loadUrl(FILE_ANDROID_ASSET_HELP + url);  \n\t}","id":92481,"modified_method":"@SuppressLint(\"NewApi\")\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tgetMyApplication().applyTheme(this);\n\t\tsupportRequestWindowFeature(Window.FEATURE_NO_TITLE);\n\t\tif (Build.VERSION.SDK_INT > Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n\t\t\tgetWindow().setUiOptions(ActivityInfo.UIOPTION_SPLIT_ACTION_BAR_WHEN_NARROW);\n\t\t}\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tString title = getString(R.string.shared_string_help);\n\t\tString url = \"index.html\";\n\t\tif(getIntent() != null) {\n\t\t\tString tl = getIntent().getStringExtra(TITLE);\n\t\t\tif(tl != null) {\n\t\t\t\ttitle = tl;\n\t\t\t}\n\t\t\tString ul = getIntent().getStringExtra(URL);\n\t\t\tif(ul != null) {\n\t\t\t\turl = ul;\n\t\t\t}\n\t\t}\n\t\tgetSupportActionBar().setTitle(title);\n\t\tsetContentView(R.layout.help_activity);\n\t\tmWebView = (WebView) findViewById(R.id.webView);\n\t\tmWebView.setFocusable(true);\n        mWebView.setFocusableInTouchMode(true);\n\t\tmWebView.requestFocus(View.FOCUS_DOWN);\n\t\tmWebView.setOnTouchListener(new View.OnTouchListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onTouch(View view, MotionEvent event) {\n\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\tif (!view.hasFocus()) {\n\t\t\t\t\t\t\tview.requestFocus();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\tmWebView.setWebViewClient(new WebViewClient() {\n\n\t\t\t@Override\n\t\t\tpublic void onPageFinished(WebView view, String url) {\n\t\t\t\tmWebView.requestFocus(View.FOCUS_DOWN);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onLoadResource(WebView view, String url) {\n\t\t\t\tsuper.onLoadResource(view, url);\n\t\t\t}\n\t\t});\n\t\tif (savedInstanceState != null) {\n\t\t\tmWebView.restoreState(savedInstanceState);\n\t\t} else {\n\t\t\tmWebView.loadUrl(FILE_ANDROID_ASSET_HELP + url);\n\t\t}\n\t}","commit_id":"362aecfc7a5d7b2bc0298548fa1bd6898d2e3bf2","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n     * Retrieve raw gps waypoints from the server API.\n     * @return A list of all primitives retrieved. Currently, the list of lists\n     *      contain only one list, since the server cannot distinguish between\n     *      ways.\n     */\n    public GpxData parseRawGps(ProgressMonitor progressMonitor) throws IOException, SAXException,OsmTransferException {\n        progressMonitor.beginTask(\"\", 1);\n        try {\n            progressMonitor.indeterminateSubTask(tr(\"Contacting OSM Server...\"));\n            String url = \"trackpoints?bbox=\"+lon1+\",\"+lat1+\",\"+lon2+\",\"+lat2+\"&page=\";\n\n            boolean done = false;\n            GpxData result = null;\n            for (int i = 0;!done;++i) {\n                progressMonitor.subTask(tr(\"Downloading points {0} to {1}...\", i * 5000, ((i + 1) * 5000)));\n                InputStream in = getInputStream(url+i, progressMonitor.createSubTaskMonitor(1, true));\n                if (in == null) {\n                    break;\n                }\n                progressMonitor.setTicks(0);\n                GpxReader reader = new GpxReader(in);\n                reader.parse(false);\n                GpxData currentGpx = reader.data;\n                if (result == null) {\n                    result = currentGpx;\n                } else if (currentGpx.hasTrackPoints()) {\n                    result.mergeFrom(currentGpx);\n                } else{\n                    done = true;\n                }\n                in.close();\n                activeConnection = null;\n            }\n            result.fromServer = true;\n            return result;\n        } catch (IllegalArgumentException e) {\n            // caused by HttpUrlConnection in case of illegal stuff in the response\n            if (cancel)\n                return null;\n            throw new SAXException(\"Illegal characters within the HTTP-header response.\", e);\n        } catch (IOException e) {\n            if (cancel)\n                return null;\n            throw e;\n        } catch (SAXException e) {\n            throw e;\n        } catch (OsmTransferException e) {\n            throw e;\n        } catch (RuntimeException e) {\n            if (cancel)\n                return null;\n            throw e;\n        } finally {\n            progressMonitor.finishTask();\n        }\n    }","id":92482,"modified_method":"/**\n     * Retrieve raw gps waypoints from the server API.\n     * @return A list of all primitives retrieved. Currently, the list of lists\n     *      contain only one list, since the server cannot distinguish between\n     *      ways.\n     */\n    @Override\n    public GpxData parseRawGps(ProgressMonitor progressMonitor) throws OsmTransferException {\n        progressMonitor.beginTask(\"\", 1);\n        try {\n            progressMonitor.indeterminateSubTask(tr(\"Contacting OSM Server...\"));\n            String url = \"trackpoints?bbox=\"+lon1+\",\"+lat1+\",\"+lon2+\",\"+lat2+\"&page=\";\n\n            boolean done = false;\n            GpxData result = null;\n            for (int i = 0;!done;++i) {\n                progressMonitor.subTask(tr(\"Downloading points {0} to {1}...\", i * 5000, ((i + 1) * 5000)));\n                InputStream in = getInputStream(url+i, progressMonitor.createSubTaskMonitor(1, true));\n                if (in == null) {\n                    break;\n                }\n                progressMonitor.setTicks(0);\n                GpxReader reader = new GpxReader(in);\n                reader.parse(false);\n                GpxData currentGpx = reader.data;\n                if (result == null) {\n                    result = currentGpx;\n                } else if (currentGpx.hasTrackPoints()) {\n                    result.mergeFrom(currentGpx);\n                } else{\n                    done = true;\n                }\n                in.close();\n                activeConnection = null;\n            }\n            result.fromServer = true;\n            return result;\n        } catch (IllegalArgumentException e) {\n            // caused by HttpUrlConnection in case of illegal stuff in the response\n            if (cancel)\n                return null;\n            throw new OsmTransferException(\"Illegal characters within the HTTP-header response.\", e);\n        } catch (IOException e) {\n            if (cancel)\n                return null;\n            throw new OsmTransferException(e);\n        } catch (SAXException e) {\n            throw new OsmTransferException(e);\n        } catch (OsmTransferException e) {\n            throw e;\n        } catch (RuntimeException e) {\n            if (cancel)\n                return null;\n            throw e;\n        } finally {\n            progressMonitor.finishTask();\n        }\n    }","commit_id":"d08005d4b965b6895c5c977c5cfedde3bd7b5dd7","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Bounds(String asString, String separator) throws IllegalArgumentException {\n        CheckParameterUtil.ensureParameterNotNull(asString, \"asString\");\n        String[] components = asString.split(separator);\n        if (components.length != 4)\n            throw new IllegalArgumentException(MessageFormat.format(\"Exactly four doubles excpected in string, got {0}: {1}\", components.length, asString));\n        double[] values = new double[4];\n        for (int i=0; i<4; i++) {\n            try {\n                values[i] = Double.parseDouble(components[i]);\n            } catch(NumberFormatException e) {\n                throw new IllegalArgumentException(MessageFormat.format(\"Illegal double value ''{0}''\", components[i]));\n            }\n        }\n        if (!LatLon.isValidLat(values[0]))\n            throw new IllegalArgumentException(tr(\"Illegal latitude value ''{0}''\", values[0]));\n        if (!LatLon.isValidLon(values[1]))\n            throw new IllegalArgumentException(tr(\"Illegal longitude value ''{0}''\", values[1]));\n        if (!LatLon.isValidLat(values[2]))\n            throw new IllegalArgumentException(tr(\"Illegal latitude value ''{0}''\", values[2]));\n        if (!LatLon.isValidLon(values[3]))\n            throw new IllegalArgumentException(tr(\"Illegal latitude value ''{0}''\", values[3]));\n\n        this.minLat = LatLon.roundToOsmPrecision(values[0]);\n        this.minLon = LatLon.roundToOsmPrecision(values[1]);\n        this.maxLat = LatLon.roundToOsmPrecision(values[2]);\n        this.maxLon = LatLon.roundToOsmPrecision(values[3]);\n    }","id":92483,"modified_method":"public Bounds(String asString, String separator) throws IllegalArgumentException {\n        this(asString, separator, ParseMethod.MINLAT_MINLON_MAXLAT_MAXLON);\n    }","commit_id":"d08005d4b965b6895c5c977c5cfedde3bd7b5dd7","url":"https://github.com/openstreetmap/josm"},{"original_method":"public DownloadTask(boolean newLayer, BoundingBoxDownloader reader, ProgressMonitor progressMonitor) {\n            super(tr(\"Downloading GPS data\"));\n            this.reader = reader;\n            this.newLayer = newLayer;\n        }","id":92484,"modified_method":"public DownloadTask(boolean newLayer, OsmServerReader reader, ProgressMonitor progressMonitor) {\n            super(tr(\"Downloading GPS data\"));\n            this.reader = reader;\n            this.newLayer = newLayer;\n        }","commit_id":"d08005d4b965b6895c5c977c5cfedde3bd7b5dd7","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Future<?> loadUrl(boolean a,java.lang.String b,  ProgressMonitor progressMonitor) {\n        return null;\n        // FIXME this is not currently used\n    }","id":92485,"modified_method":"public Future<?> loadUrl(boolean newLayer, String url, ProgressMonitor progressMonitor) {\n        if (url != null && url.matches(PATTERN_TRACE_ID)) {\n            downloadTask = new DownloadTask(newLayer,\n                    new OsmServerLocationReader(url), progressMonitor);\n            // We need submit instead of execute so we can wait for it to finish and get the error\n            // message if necessary. If no one calls getErrorMessage() it just behaves like execute.\n            return Main.worker.submit(downloadTask);\n            \n        } else if (url != null && url.matches(PATTERN_TRACKPOINTS_BBOX)) {\n            String[] table = url.split(\"\\\\?|=|&\");\n            for (int i = 0; i<table.length; i++) {\n                if (table[i].equals(\"bbox\") && i<table.length-1 ) {\n                    return download(newLayer, new Bounds(table[i+1], \",\", ParseMethod.LEFT_BOTTOM_RIGHT_TOP), progressMonitor);\n                }\n            }\n        }\n        return null;\n    }","commit_id":"d08005d4b965b6895c5c977c5cfedde3bd7b5dd7","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Create an open action. The name is \"Open a file\".\n     */\n    public OpenLocationAction() {\n        /* I18N: Command to download a specific location/URL */\n        super(tr(\"Open Location...\"), \"openlocation\", tr(\"Open an URL.\"),\n                Shortcut.registerShortcut(\"system:open_location\", tr(\"File: {0}\", tr(\"Open Location...\")), KeyEvent.VK_L, Shortcut.GROUP_MENU), true);\n        putValue(\"help\", ht(\"/Action/OpenLocation\"));\n    }","id":92486,"modified_method":"/**\n     * Create an open action. The name is \"Open a file\".\n     */\n    public OpenLocationAction() {\n        /* I18N: Command to download a specific location/URL */\n        super(tr(\"Open Location...\"), \"openlocation\", tr(\"Open an URL.\"),\n                Shortcut.registerShortcut(\"system:open_location\", tr(\"File: {0}\", tr(\"Open Location...\")), KeyEvent.VK_L, Shortcut.GROUP_MENU), true);\n        putValue(\"help\", ht(\"/Action/OpenLocation\"));\n        this.downloadTasks = new ArrayList<Class<? extends DownloadTask>>();\n        addDownloadTaskClass(DownloadOsmTask.class);\n        addDownloadTaskClass(DownloadGpsTask.class);\n    }","commit_id":"d08005d4b965b6895c5c977c5cfedde3bd7b5dd7","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Open the given file.\n     */\n    public void openUrl(boolean new_layer, String url) {\n        DownloadOsmTask task = new DownloadOsmTask();\n        PleaseWaitProgressMonitor monitor = new PleaseWaitProgressMonitor(tr(\"Download Data\"));\n        Future<?> future = task.loadUrl(new_layer, url, monitor);\n        Main.worker.submit(new PostDownloadHandler(task, future));\n    }","id":92487,"modified_method":"/**\n     * Open the given URL.\n     */\n    public void openUrl(boolean new_layer, final String url) {\n        PleaseWaitProgressMonitor monitor = new PleaseWaitProgressMonitor(tr(\"Download Data\"));\n        DownloadTask task = null;\n        Future<?> future = null;\n        for (int i = 0; future == null && i < downloadTasks.size(); i++) {\n            Class<? extends DownloadTask> taskClass = downloadTasks.get(i);\n            if (taskClass != null) {\n                try {\n                    task = taskClass.getConstructor().newInstance();\n                    if (task.acceptsUrl(url)) {\n                        future = task.loadUrl(new_layer, url, monitor);\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        if (future != null) {\n            Main.worker.submit(new PostDownloadHandler(task, future));\n        } else {\n            SwingUtilities.invokeLater(new Runnable() {\n                public void run() {\n                    JOptionPane.showMessageDialog(Main.parent, tr(\n                            \"<html>Cannot open URL ''{0}'' because no suitable download task is available.<\/html>\",\n                            url), tr(\"Download Location\"), JOptionPane.ERROR_MESSAGE);\n                }\n            });\n        }\n    }","commit_id":"d08005d4b965b6895c5c977c5cfedde3bd7b5dd7","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Method to download OSM files from somewhere\n     */\n    @Override\n    public DataSet parseOsm(ProgressMonitor progressMonitor) throws OsmTransferException {\n        InputStream in = null;\n        progressMonitor.beginTask(tr(\"Contacting Server...\", 10));\n        try {\n            in = getInputStreamRaw(url, progressMonitor.createSubTaskMonitor(9, false));\n            if (in == null)\n                return null;\n            progressMonitor.subTask(tr(\"Downloading OSM data...\"));\n            return OsmReader.parseDataSet(in, progressMonitor.createSubTaskMonitor(1, false));\n        } catch(OsmTransferException e) {\n            throw e;\n        } catch (Exception e) {\n            if (cancel)\n                return null;\n            throw new OsmTransferException(e);\n        } finally {\n            progressMonitor.finishTask();\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                activeConnection = null;\n            } catch(Exception e) {/* ignore it */}\n        }\n    }","id":92488,"modified_method":"/**\n     * Method to download OSM files from somewhere\n     */\n    @Override\n    public DataSet parseOsm(ProgressMonitor progressMonitor) throws OsmTransferException {\n        InputStream in = null;\n        progressMonitor.beginTask(tr(\"Contacting Server...\", 10));\n        try {\n            in = getInputStreamRaw(url, progressMonitor.createSubTaskMonitor(9, false));\n            if (in == null)\n                return null;\n            progressMonitor.subTask(tr(\"Downloading OSM data...\"));\n            return OsmReader.parseDataSet(in, progressMonitor.createSubTaskMonitor(1, false));\n        } catch(OsmTransferException e) {\n            throw e;\n        } catch (Exception e) {\n            if (cancel)\n                return null;\n            throw new OsmTransferException(e);\n        } finally {\n            progressMonitor.finishTask();\n            try {\n                activeConnection = null;\n                if (in != null) {\n                    in.close();\n                }\n            } catch(Exception e) {/* ignore it */}\n        }\n    }","commit_id":"d08005d4b965b6895c5c977c5cfedde3bd7b5dd7","url":"https://github.com/openstreetmap/josm"},{"original_method":"public DefaultMapReduceSpecification(MapReduce mapReduce) {\n    MapReduceSpecification configureSpec = mapReduce.configure();\n\n    Set<String> dataSets = Sets.newHashSet(configureSpec.getDataSets());\n    Map<String, String> properties = Maps.newHashMap();\n\n    Reflections.visit(mapReduce, TypeToken.of(mapReduce.getClass()),\n                      new PropertyFieldExtractor(properties),\n                      new DataSetFieldExtractor(dataSets));\n    properties.putAll(configureSpec.getArguments());\n\n    this.className = mapReduce.getClass().getName();\n    this.name = configureSpec.getName();\n    this.description = configureSpec.getDescription();\n    this.inputDataSet = configureSpec.getInputDataSet();\n    this.outputDataSet = configureSpec.getOutputDataSet();\n\n    this.dataSets = ImmutableSet.copyOf(dataSets);\n    this.arguments = ImmutableMap.copyOf(properties);\n\n    this.mapperMemoryMB = configureSpec.getMapperMemoryMB();\n    this.reducerMemoryMB = configureSpec.getReducerMemoryMB();\n  }","id":92489,"modified_method":"public DefaultMapReduceSpecification(MapReduce mapReduce) {\n    MapReduceSpecification configureSpec = mapReduce.configure();\n\n    Set<String> dataSets = Sets.newHashSet(configureSpec.getDataSets());\n    Map<String, String> properties = Maps.newHashMap(configureSpec.getArguments());\n\n    Reflections.visit(mapReduce, TypeToken.of(mapReduce.getClass()),\n                      new PropertyFieldExtractor(properties),\n                      new DataSetFieldExtractor(dataSets));\n\n    this.className = mapReduce.getClass().getName();\n    this.name = configureSpec.getName();\n    this.description = configureSpec.getDescription();\n    this.inputDataSet = configureSpec.getInputDataSet();\n    this.outputDataSet = configureSpec.getOutputDataSet();\n\n    this.dataSets = ImmutableSet.copyOf(dataSets);\n    this.arguments = ImmutableMap.copyOf(properties);\n\n    this.mapperMemoryMB = configureSpec.getMapperMemoryMB();\n    this.reducerMemoryMB = configureSpec.getReducerMemoryMB();\n  }","commit_id":"1e996a5809941dd7fe9ad529dd9791bd233fe61b","url":"https://github.com/caskdata/cdap"},{"original_method":"public DefaultProcedureSpecification(Procedure procedure) {\n    ProcedureSpecification configureSpec = procedure.configure();\n    Set<String> dataSets = Sets.newHashSet(configureSpec.getDataSets());\n    Map<String, String> properties = Maps.newHashMap();\n\n    Reflections.visit(procedure, TypeToken.of(procedure.getClass()),\n                      new PropertyFieldExtractor(properties),\n                      new DataSetFieldExtractor(dataSets));\n    properties.putAll(configureSpec.getArguments());\n\n    this.className = procedure.getClass().getName();\n    this.name = configureSpec.getName();\n    this.description = configureSpec.getDescription();\n    this.dataSets = ImmutableSet.copyOf(dataSets);\n    this.arguments = ImmutableMap.copyOf(properties);\n    this.resources = configureSpec.getResources();\n  }","id":92490,"modified_method":"public DefaultProcedureSpecification(Procedure procedure) {\n    ProcedureSpecification configureSpec = procedure.configure();\n    Set<String> dataSets = Sets.newHashSet(configureSpec.getDataSets());\n    Map<String, String> properties = Maps.newHashMap(configureSpec.getArguments());\n\n    Reflections.visit(procedure, TypeToken.of(procedure.getClass()),\n                      new PropertyFieldExtractor(properties),\n                      new DataSetFieldExtractor(dataSets));\n\n    this.className = procedure.getClass().getName();\n    this.name = configureSpec.getName();\n    this.description = configureSpec.getDescription();\n    this.dataSets = ImmutableSet.copyOf(dataSets);\n    this.arguments = ImmutableMap.copyOf(properties);\n    this.resources = configureSpec.getResources();\n  }","commit_id":"1e996a5809941dd7fe9ad529dd9791bd233fe61b","url":"https://github.com/caskdata/cdap"},{"original_method":"public DefaultWorkflowActionSpecification(WorkflowAction action) {\n    WorkflowActionSpecification spec = action.configure();\n\n    Map<String, String> properties = Maps.newHashMap();\n    Reflections.visit(action, TypeToken.of(action.getClass()),\n                      new PropertyFieldExtractor(properties));\n    properties.putAll(spec.getOptions());\n\n    this.className = action.getClass().getName();\n    this.name = spec.getName();\n    this.description = spec.getDescription();\n    this.options = ImmutableMap.copyOf(properties);\n  }","id":92491,"modified_method":"public DefaultWorkflowActionSpecification(WorkflowAction action) {\n    WorkflowActionSpecification spec = action.configure();\n\n    Map<String, String> properties = Maps.newHashMap(spec.getOptions());\n    Reflections.visit(action, TypeToken.of(action.getClass()),\n                      new PropertyFieldExtractor(properties));\n\n    this.className = action.getClass().getName();\n    this.name = spec.getName();\n    this.description = spec.getDescription();\n    this.options = ImmutableMap.copyOf(properties);\n  }","commit_id":"1e996a5809941dd7fe9ad529dd9791bd233fe61b","url":"https://github.com/caskdata/cdap"},{"original_method":"FlowletDefinition(String flowletName, Flowlet flowlet, int instances) {\n    FlowletSpecification flowletSpec = flowlet.configure();\n\n    this.instances = instances;\n\n    Set<String> datasets = Sets.newHashSet(flowletSpec.getDataSets());\n    Map<String, Set<Type>> inputTypes = Maps.newHashMap();\n    Map<String, Set<Type>> outputTypes = Maps.newHashMap();\n    Map<String, String> properties = Maps.newHashMap();\n    try {\n      Reflections.visit(flowlet, TypeToken.of(flowlet.getClass()),\n                        new DataSetFieldExtractor(datasets),\n                        new PropertyFieldExtractor(properties),\n                        new OutputEmitterFieldExtractor(outputTypes),\n                        new ProcessMethodExtractor(inputTypes));\n    } catch (Exception e) {\n      throw new IllegalArgumentException(e);\n    }\n\n    this.datasets = ImmutableSet.copyOf(datasets);\n    this.inputTypes = immutableCopyOf(inputTypes);\n    this.outputTypes = immutableCopyOf(outputTypes);\n\n    properties.putAll(flowletSpec.getArguments());\n    this.flowletSpec = new DefaultFlowletSpecification(flowlet.getClass().getName(),\n                                                       flowletName == null ? flowletSpec.getName() : flowletName,\n                                                       flowletSpec.getDescription(), flowletSpec.getFailurePolicy(),\n                                                       datasets, properties,\n                                                       flowletSpec.getResources());\n  }","id":92492,"modified_method":"FlowletDefinition(String flowletName, Flowlet flowlet, int instances) {\n    FlowletSpecification flowletSpec = flowlet.configure();\n\n    this.instances = instances;\n\n    Set<String> datasets = Sets.newHashSet(flowletSpec.getDataSets());\n    Map<String, Set<Type>> inputTypes = Maps.newHashMap();\n    Map<String, Set<Type>> outputTypes = Maps.newHashMap();\n    Map<String, String> properties = Maps.newHashMap(flowletSpec.getArguments());\n    Reflections.visit(flowlet, TypeToken.of(flowlet.getClass()),\n                      new DataSetFieldExtractor(datasets),\n                      new PropertyFieldExtractor(properties),\n                      new OutputEmitterFieldExtractor(outputTypes),\n                      new ProcessMethodExtractor(inputTypes));\n\n    this.datasets = ImmutableSet.copyOf(datasets);\n    this.inputTypes = immutableCopyOf(inputTypes);\n    this.outputTypes = immutableCopyOf(outputTypes);\n    this.flowletSpec = new DefaultFlowletSpecification(flowlet.getClass().getName(),\n                                                       flowletName == null ? flowletSpec.getName() : flowletName,\n                                                       flowletSpec.getDescription(), flowletSpec.getFailurePolicy(),\n                                                       datasets, properties,\n                                                       flowletSpec.getResources());\n  }","commit_id":"1e996a5809941dd7fe9ad529dd9791bd233fe61b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void visit(Object instance, TypeToken<?> inspectType, TypeToken<?> declareType, Field field) throws Exception {\n    if (field.isAnnotationPresent(Property.class)) {\n\n      // Key name is \"className.fieldName\".\n      String key = declareType.getRawType().getName() + '.' + field.getName();\n      String value = getStringValue(instance, field);\n\n      if (value != null) {\n        properties.put(key, value);\n      }\n    }\n  }","id":92493,"modified_method":"@Override\n  public void visit(Object instance, TypeToken<?> inspectType, TypeToken<?> declareType, Field field) throws Exception {\n    if (field.isAnnotationPresent(Property.class)) {\n\n      // Key name is \"className.fieldName\".\n      String key = declareType.getRawType().getName() + '.' + field.getName();\n      if (properties.containsKey(key)) {\n        return;\n      }\n\n      String value = getStringValue(instance, field);\n      if (value != null) {\n        properties.put(key, value);\n      }\n    }\n  }","commit_id":"1e996a5809941dd7fe9ad529dd9791bd233fe61b","url":"https://github.com/caskdata/cdap"},{"original_method":"@NotNull\n    private TranslationContext getFunctionBodyContextForLiteral() {\n        ClassDescriptor containingClass = getContainingClass(descriptor);\n        if (containingClass == null) {\n            return getContextWithFunctionBodyBlock();\n        }\n        JsExpression thisQualifier = TranslationUtils.getThisObject(context(), containingClass);\n        aliasForContaingClassThis = context().declareTemporary(thisQualifier);\n        return getContextWithFunctionBodyBlock().innerContextWithThisAliased(containingClass, aliasForContaingClassThis.name());\n    }","id":92494,"modified_method":"@NotNull\n    private TranslationContext getFunctionBodyContextForLiteral() {\n        ClassDescriptor containingClass = getContainingClass(descriptor);\n        if (containingClass == null) {\n            return getContextWithFunctionBodyBlock();\n        }\n        JsExpression thisQualifier = TranslationUtils.getThisObject(context(), containingClass);\n        aliasForContainingClassThis = context().declareTemporary(thisQualifier);\n        return getContextWithFunctionBodyBlock().innerContextWithThisAliased(containingClass, aliasForContainingClassThis.name());\n    }","commit_id":"9b2dc6f5841e28cb42f456d9002e2b6b810981a6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private JsExpression mayBeWrapWithThisAlias() {\n        if (!shouldAliasThisObject()) {\n            return functionObject;\n        }\n        assert aliasForContaingClassThis != null;\n        return AstUtil.newSequence(aliasForContaingClassThis.assignmentExpression(), functionObject);\n    }","id":92495,"modified_method":"@NotNull\n    private JsExpression mayBeWrapWithThisAlias() {\n        if (!shouldAliasThisObject()) {\n            return functionObject;\n        }\n        assert aliasForContainingClassThis != null;\n        return AstUtil.newSequence(aliasForContainingClassThis.assignmentExpression(), functionObject);\n    }","commit_id":"9b2dc6f5841e28cb42f456d9002e2b6b810981a6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void translateBody() {\n        JetExpression jetBodyExpression = functionDeclaration.getBodyExpression();\n        if (jetBodyExpression == null) {\n            assert descriptor.getModality().equals(Modality.ABSTRACT);\n            return;\n        }\n        JsNode realBody = Translation.translateExpression(jetBodyExpression, functionBodyContext);\n        functionBody.getStatements().add(mayBeWrapWithReturn(realBody));\n    }","id":92496,"modified_method":"private void translateBody() {\n        JetExpression jetBodyExpression = functionDeclaration.getBodyExpression();\n        if (jetBodyExpression == null) {\n            assert descriptor.getModality().equals(Modality.ABSTRACT);\n            return;\n        }\n        functionBody.getStatements().add(translateFunctionBody(descriptor, functionDeclaration, functionBodyContext));\n    }","commit_id":"9b2dc6f5841e28cb42f456d9002e2b6b810981a6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void testFunctionWithoutParameters() throws Exception {\n        String filename = \"functionWithoutParameters.kt\";\n        checkFooBoxIsTrue(filename);\n        String generatedJSFilePath = getOutputFilePath(filename);\n        String outputFileText = FileUtil.loadFile(new File(generatedJSFilePath));\n        assertTrue(countOccurrences(outputFileText, \"myInlineFun\") == 1);\n    }","id":92497,"modified_method":"public void testFunctionWithoutParameters() throws Exception {\n        checkFooBoxIsTrueAndFunctionNameIsNotReferenced(\"functionWithoutParameters.kt\", \"myInlineFun\");\n    }","commit_id":"9b2dc6f5841e28cb42f456d9002e2b6b810981a6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private JsExpression translate() {\n        TranslationContext contextWithAllParametersAliased = createContextWithAllParametersAliased();\n        JetFunction function = BindingUtils.getFunctionForDescriptor(bindingContext(), getFunctionDescriptor());\n        return Translation.translateAsExpression(function.getBodyExpression(), contextWithAllParametersAliased);\n    }","id":92498,"modified_method":"@NotNull\n    private JsExpression translate() {\n        TranslationContext contextWithAllParametersAliased = createContextForInlining();\n        JsNode translatedBody = translateFunctionBody(getFunctionDescriptor(), getFunctionBody(), contextWithAllParametersAliased);\n        //TODO: declare uninitialized temporary\n        TemporaryVariable temporaryVariable = contextWithAllParametersAliased.declareTemporary(program().getNullLiteral());\n        JsNode mutatedBody = LastExpressionMutator.mutateLastExpression(translatedBody, new InlineFunctionMutator(temporaryVariable));\n        context().addStatementToCurrentBlock(JsAstUtils.convertToBlock(mutatedBody));\n        return temporaryVariable.reference();\n    }","commit_id":"9b2dc6f5841e28cb42f456d9002e2b6b810981a6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private TranslationContext createContextWithAllParametersAliased() {\n        Map<DeclarationDescriptor, JsName> aliases = Maps.newHashMap();\n        for (ValueParameterDescriptor parameterDescriptor : resolvedCall.getResultingDescriptor().getValueParameters()) {\n            ResolvedValueArgument actualArgument = resolvedCall.getValueArgumentsByIndex().get(parameterDescriptor.getIndex());\n            JsExpression translatedArgument = translateArgument(parameterDescriptor, actualArgument);\n            TemporaryVariable aliasForArgument = context().declareTemporary(translatedArgument);\n            aliases.put(parameterDescriptor, aliasForArgument.name());\n            context().addStatementToCurrentBlock(aliasForArgument.assignmentExpression().makeStmt());\n        }\n        return context().innerContextWithDescriptorsAliased(aliases);\n    }","id":92499,"modified_method":"@NotNull\n    private TranslationContext createContextWithAliasesForParameters(@NotNull TranslationContext contextForInlining) {\n        Map<DeclarationDescriptor, JsName> aliases = Maps.newHashMap();\n        for (ValueParameterDescriptor parameterDescriptor : resolvedCall.getResultingDescriptor().getValueParameters()) {\n            TemporaryVariable aliasForArgument = createAliasForArgument(parameterDescriptor);\n            aliases.put(parameterDescriptor, aliasForArgument.name());\n        }\n        return contextForInlining.innerContextWithDescriptorsAliased(aliases);\n    }","commit_id":"9b2dc6f5841e28cb42f456d9002e2b6b810981a6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public JsName getNameForDescriptor(@NotNull DeclarationDescriptor descriptor) {\n        return staticContext.getNameForDescriptor(descriptor);\n    }","id":92500,"modified_method":"@NotNull\n    public JsName getNameForDescriptor(@NotNull DeclarationDescriptor descriptor) {\n        JsName alias = aliasingContext.getAliasForDescriptor(descriptor);\n        if (alias != null) {\n            return alias;\n        }\n        return staticContext.getNameForDescriptor(descriptor);\n    }","commit_id":"9b2dc6f5841e28cb42f456d9002e2b6b810981a6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private TranslationContext createContextWithAliasForThisExpression(@NotNull TranslationContext contextForInlining) {\n        ClassDescriptor classDescriptorForMethod = DescriptorUtils.getClassDescriptorForMethod(getFunctionDescriptor());\n        if (classDescriptorForMethod == null) {\n            return contextForInlining;\n        }\n        TranslationContext contextWithAliasForThisExpression = contextForInlining;\n        TemporaryVariable aliasForThis = contextWithAliasForThisExpression.declareTemporary(getReceiver());\n        contextWithAliasForThisExpression = contextForInlining.innerContextWithThisAliased(classDescriptorForMethod, aliasForThis.name());\n        contextWithAliasForThisExpression.addStatementToCurrentBlock(aliasForThis.assignmentExpression().makeStmt());\n        return contextWithAliasForThisExpression;\n    }","id":92501,"modified_method":"@NotNull\n    private TranslationContext createContextWithAliasForThisExpression(@NotNull TranslationContext contextForInlining) {\n        TranslationContext contextWithAliasForThisExpression = contextForInlining;\n        SimpleFunctionDescriptor functionDescriptor = getFunctionDescriptor();\n        CallParameters callParameters = resolveCallParameters(receiver, null, functionDescriptor, resolvedCall, contextForInlining);\n        JsExpression receiver = callParameters.getReceiver();\n        if (receiver != null) {\n            contextWithAliasForThisExpression =\n                contextWithAlias(contextWithAliasForThisExpression, receiver, getExpectedReceiverDescriptor(functionDescriptor));\n        }\n        JsExpression thisObject = callParameters.getThisObject();\n        if (thisObject != null) {\n            contextWithAliasForThisExpression =\n                contextWithAlias(contextWithAliasForThisExpression, thisObject, getExpectedThisDescriptor(functionDescriptor));\n        }\n        return contextWithAliasForThisExpression;\n    }","commit_id":"fd1d6e8dfcdaf85c092c3df19b4e668973b70a34","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private Parameters getMethodParametersWithCaptured(\n            @NotNull ParametersBuilder capturedBuilder,\n            @NotNull MethodNode sourceNode\n    ) {\n        ParametersBuilder builder = ParametersBuilder.newBuilder();\n        buildInvokeParamsFor(builder, sourceNode);\n        for (CapturedParamInfo param : capturedBuilder.listCaptured()) {\n            builder.addCapturedParamCopy(param);\n        }\n        return builder.buildParameters();\n    }","id":92502,"modified_method":"@NotNull\n    private Parameters getMethodParametersWithCaptured(\n            @NotNull ParametersBuilder capturedBuilder,\n            @NotNull MethodNode sourceNode\n    ) {\n        ParametersBuilder builder = ParametersBuilder.initializeBuilderFrom(oldObjectType, sourceNode.desc);\n        for (CapturedParamInfo param : capturedBuilder.listCaptured()) {\n            builder.addCapturedParamCopy(param);\n        }\n        return builder.buildParameters();\n    }","commit_id":"03158ed9c359819a42e852b7bb468bcbe2682078","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public Parameters addAllParameters(FieldRemapper remapper) {\n        ParametersBuilder builder = ParametersBuilder.newBuilder();\n        //add skipped this cause inlined lambda doesn't have it\n        builder.addThis(AsmTypes.OBJECT_TYPE, true).setLambda(this);\n\n        FunctionDescriptor lambdaDescriptor = getFunctionDescriptor();\n        ReceiverParameterDescriptor extensionParameter = lambdaDescriptor.getExtensionReceiverParameter();\n        if (extensionParameter != null) {\n            Type type = typeMapper.mapType(extensionParameter.getType());\n            builder.addNextParameter(type, false, null);\n        }\n\n        List<ValueParameterDescriptor> valueParameters = lambdaDescriptor.getValueParameters();\n        for (ValueParameterDescriptor parameter : valueParameters) {\n            Type type = typeMapper.mapType(parameter.getType());\n            builder.addNextParameter(type, false, null);\n        }\n\n        for (CapturedParamDesc info : getCapturedVars()) {\n            CapturedParamInfo field = remapper.findField(new FieldInsnNode(0, info.getContainingLambdaName(), info.getFieldName(), \"\"));\n            builder.addCapturedParam(field, info.getFieldName());\n        }\n\n        return builder.buildParameters();\n    }","id":92503,"modified_method":"@NotNull\n    public Parameters addAllParameters(FieldRemapper remapper) {\n        JvmMethodSignature signature = typeMapper.mapSignature(getFunctionDescriptor());\n        ParametersBuilder builder =\n                ParametersBuilder.initializeBuilderFrom(AsmTypes.OBJECT_TYPE, signature.getAsmMethod().getDescriptor(), this);\n\n        for (CapturedParamDesc info : getCapturedVars()) {\n            CapturedParamInfo field = remapper.findField(new FieldInsnNode(0, info.getContainingLambdaName(), info.getFieldName(), \"\"));\n            builder.addCapturedParam(field, info.getFieldName());\n        }\n\n        return builder.buildParameters();\n    }","commit_id":"03158ed9c359819a42e852b7bb468bcbe2682078","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void addCreatePrincipalsStage(Cluster cluster, String clusterHostInfoJson,\n                                         String hostParamsJson, ServiceComponentHostServerActionEvent event,\n                                         Map<String, String> commandParameters,\n                                         RoleCommandOrder roleCommandOrder, RequestStageContainer requestStageContainer)\n        throws AmbariException {\n      Stage stage = createServerActionStage(requestStageContainer.getLastStageId(),\n          cluster,\n          requestStageContainer.getId(),\n          \"Create Principals\",\n          clusterHostInfoJson,\n          \"{}\",\n          hostParamsJson,\n          CreatePrincipalsServerAction.class,\n          event,\n          commandParameters,\n          \"Create Principals\",\n          configuration.getDefaultServerTaskTimeout());\n\n      RoleGraph roleGraph = roleGraphFactory.createNew(roleCommandOrder);\n      roleGraph.build(stage);\n      requestStageContainer.addStages(roleGraph.getStages());\n    }","id":92504,"modified_method":"public void addCreatePrincipalsStage(Cluster cluster, String clusterHostInfoJson,\n                                         String hostParamsJson, ServiceComponentHostServerActionEvent event,\n                                         Map<String, String> commandParameters,\n                                         RoleCommandOrder roleCommandOrder, RequestStageContainer requestStageContainer)\n        throws AmbariException {\n      Stage stage = createServerActionStage(requestStageContainer.getLastStageId(),\n          cluster,\n          requestStageContainer.getId(),\n          \"Create Principals\",\n          clusterHostInfoJson,\n          \"{}\",\n          hostParamsJson,\n          CreatePrincipalsServerAction.class,\n          event,\n          commandParameters,\n          \"Create Principals\",\n          Math.max(ServerAction.DEFAULT_LONG_RUNNING_TASK_TIMEOUT_SECONDS, configuration.getDefaultServerTaskTimeout()));\n\n      RoleGraph roleGraph = roleGraphFactory.createNew(roleCommandOrder);\n      roleGraph.build(stage);\n      requestStageContainer.addStages(roleGraph.getStages());\n    }","commit_id":"0a61db5666f3ee8b82cdab0d50a1c8450b177ae7","url":"https://github.com/apache/ambari"},{"original_method":"public void addDestroyPrincipalsStage(Cluster cluster, String clusterHostInfoJson,\n                                          String hostParamsJson, ServiceComponentHostServerActionEvent event,\n                                          Map<String, String> commandParameters,\n                                          RoleCommandOrder roleCommandOrder, RequestStageContainer requestStageContainer)\n        throws AmbariException {\n      Stage stage = createServerActionStage(requestStageContainer.getLastStageId(),\n          cluster,\n          requestStageContainer.getId(),\n          \"Destroy Principals\",\n          clusterHostInfoJson,\n          \"{}\",\n          hostParamsJson,\n          DestroyPrincipalsServerAction.class,\n          event,\n          commandParameters,\n          \"Destroy Principals\",\n          configuration.getDefaultServerTaskTimeout());\n\n      RoleGraph roleGraph = roleGraphFactory.createNew(roleCommandOrder);\n      roleGraph.build(stage);\n      requestStageContainer.addStages(roleGraph.getStages());\n    }","id":92505,"modified_method":"public void addDestroyPrincipalsStage(Cluster cluster, String clusterHostInfoJson,\n                                          String hostParamsJson, ServiceComponentHostServerActionEvent event,\n                                          Map<String, String> commandParameters,\n                                          RoleCommandOrder roleCommandOrder, RequestStageContainer requestStageContainer)\n        throws AmbariException {\n      Stage stage = createServerActionStage(requestStageContainer.getLastStageId(),\n          cluster,\n          requestStageContainer.getId(),\n          \"Destroy Principals\",\n          clusterHostInfoJson,\n          \"{}\",\n          hostParamsJson,\n          DestroyPrincipalsServerAction.class,\n          event,\n          commandParameters,\n          \"Destroy Principals\",\n          Math.max(ServerAction.DEFAULT_LONG_RUNNING_TASK_TIMEOUT_SECONDS, configuration.getDefaultServerTaskTimeout()));\n\n      RoleGraph roleGraph = roleGraphFactory.createNew(roleCommandOrder);\n      roleGraph.build(stage);\n      requestStageContainer.addStages(roleGraph.getStages());\n    }","commit_id":"0a61db5666f3ee8b82cdab0d50a1c8450b177ae7","url":"https://github.com/apache/ambari"},{"original_method":"public void addCreateKeytabFilesStage(Cluster cluster, String clusterHostInfoJson,\n                                          String hostParamsJson, ServiceComponentHostServerActionEvent event,\n                                          Map<String, String> commandParameters,\n                                          RoleCommandOrder roleCommandOrder, RequestStageContainer requestStageContainer)\n        throws AmbariException {\n      Stage stage = createServerActionStage(requestStageContainer.getLastStageId(),\n          cluster,\n          requestStageContainer.getId(),\n          \"Create Keytabs\",\n          clusterHostInfoJson,\n          \"{}\",\n          hostParamsJson,\n          CreateKeytabFilesServerAction.class,\n          event,\n          commandParameters,\n          \"Create Keytabs\",\n          configuration.getDefaultServerTaskTimeout());\n\n      RoleGraph roleGraph = roleGraphFactory.createNew(roleCommandOrder);\n      roleGraph.build(stage);\n      requestStageContainer.addStages(roleGraph.getStages());\n    }","id":92506,"modified_method":"public void addCreateKeytabFilesStage(Cluster cluster, String clusterHostInfoJson,\n                                          String hostParamsJson, ServiceComponentHostServerActionEvent event,\n                                          Map<String, String> commandParameters,\n                                          RoleCommandOrder roleCommandOrder, RequestStageContainer requestStageContainer)\n        throws AmbariException {\n      Stage stage = createServerActionStage(requestStageContainer.getLastStageId(),\n          cluster,\n          requestStageContainer.getId(),\n          \"Create Keytabs\",\n          clusterHostInfoJson,\n          \"{}\",\n          hostParamsJson,\n          CreateKeytabFilesServerAction.class,\n          event,\n          commandParameters,\n          \"Create Keytabs\",\n          Math.max(ServerAction.DEFAULT_LONG_RUNNING_TASK_TIMEOUT_SECONDS, configuration.getDefaultServerTaskTimeout()));\n\n      RoleGraph roleGraph = roleGraphFactory.createNew(roleCommandOrder);\n      roleGraph.build(stage);\n      requestStageContainer.addStages(roleGraph.getStages());\n    }","commit_id":"0a61db5666f3ee8b82cdab0d50a1c8450b177ae7","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Changes the group for the directory or file with the path specified in args.\n   *\n   * @param path The {@link TachyonURI} path as the input of the command\n   * @param group The group to be updated to the file or directory\n   * @param recursive Whether change the group recursively\n   * @throws IOException\n   */\n  protected void chgrp(TachyonURI path, String group, boolean recursive) throws IOException {\n    try {\n      SetAclOptions options =\n          new SetAclOptions.Builder().setGroup(group).setRecursive(recursive).build();\n      mTfs.setAcl(path, options);\n      System.out.println(\"Changed group of \" + path + \" to \" + group);\n    } catch (TachyonException e) {\n      throw new IOException(\"Failed to changed group of \" + path + \" to \" + group + \" : \"\n          + e.getMessage());\n    }\n  }","id":92507,"modified_method":"/**\n   * Changes the group for the directory or file with the path specified in args.\n   *\n   * @param path The {@link TachyonURI} path as the input of the command\n   * @param group The group to be updated to the file or directory\n   * @param recursive Whether change the group recursively\n   * @throws IOException\n   */\n  protected void chgrp(TachyonURI path, String group, boolean recursive) throws IOException {\n    try {\n      SetAclOptions options = SetAclOptions.defaults().setGroup(group).setRecursive(recursive);\n      mTfs.setAcl(path, options);\n      System.out.println(\"Changed group of \" + path + \" to \" + group);\n    } catch (TachyonException e) {\n      throw new IOException(\"Failed to changed group of \" + path + \" to \" + group + \" : \"\n          + e.getMessage());\n    }\n  }","commit_id":"d167880c38b26652a692de5d73024033b30f6e9a","url":"https://github.com/amplab/tachyon"},{"original_method":"protected AbstractAclCommand(TachyonConf conf, TachyonFileSystem tfs) {\n    super(conf, tfs);\n  }","id":92508,"modified_method":"protected AbstractAclCommand(TachyonConf conf, FileSystem tfs) {\n    super(conf, tfs);\n  }","commit_id":"d167880c38b26652a692de5d73024033b30f6e9a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Changes the owner for the directory or file with the path specified in args.\n   *\n   * @param path The {@link TachyonURI} path as the input of the command\n   * @param owner The owner to be updated to the file or directory\n   * @param recursive Whether change the owner recursively\n   * @throws IOException if command failed\n   */\n  protected void chown(TachyonURI path, String owner, boolean recursive) throws IOException {\n    try {\n      SetAclOptions options =\n          new SetAclOptions.Builder().setOwner(owner).setRecursive(recursive).build();\n      mTfs.setAcl(path, options);\n      System.out.println(\"Changed owner of \" + path + \" to \" + owner);\n    } catch (TachyonException e) {\n      throw new IOException(\"Failed to changed owner of \" + path + \" to \" + owner + \" : \"\n          + e.getMessage());\n    }\n  }","id":92509,"modified_method":"/**\n   * Changes the owner for the directory or file with the path specified in args.\n   *\n   * @param path The {@link TachyonURI} path as the input of the command\n   * @param owner The owner to be updated to the file or directory\n   * @param recursive Whether change the owner recursively\n   * @throws IOException if command failed\n   */\n  protected void chown(TachyonURI path, String owner, boolean recursive) throws IOException {\n    try {\n      SetAclOptions options = SetAclOptions.defaults().setOwner(owner).setRecursive(recursive);\n      mTfs.setAcl(path, options);\n      System.out.println(\"Changed owner of \" + path + \" to \" + owner);\n    } catch (TachyonException e) {\n      throw new IOException(\"Failed to changed owner of \" + path + \" to \" + owner + \" : \"\n          + e.getMessage());\n    }\n  }","commit_id":"d167880c38b26652a692de5d73024033b30f6e9a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Changes the permissions of directory or file with the path specified in args.\n   *\n   * @param path The {@link TachyonURI} path as the input of the command\n   * @param modeStr The new permission to be updated to the file or directory\n   * @param recursive Whether change the permission recursively\n   * @throws IOException if command failed\n   */\n  protected void chmod(TachyonURI path, String modeStr, boolean recursive) throws IOException {\n    short newPermission = 0;\n    try {\n      newPermission = Short.parseShort(modeStr, 8);\n      SetAclOptions options =\n          new SetAclOptions.Builder().setPermission(newPermission).setRecursive(recursive).build();\n      mTfs.setAcl(path, options);\n      System.out.println(\"Changed permission of \" + path + \" to \"\n          + Integer.toOctalString(newPermission));\n    } catch (Exception e) {\n      throw new IOException(\"Failed to changed permission of  \" + path + \" to \"\n          + Integer.toOctalString(newPermission) + \" : \" + e.getMessage());\n    }\n  }","id":92510,"modified_method":"/**\n   * Changes the permissions of directory or file with the path specified in args.\n   *\n   * @param path The {@link TachyonURI} path as the input of the command\n   * @param modeStr The new permission to be updated to the file or directory\n   * @param recursive Whether change the permission recursively\n   * @throws IOException if command failed\n   */\n  protected void chmod(TachyonURI path, String modeStr, boolean recursive) throws IOException {\n    short newPermission = 0;\n    try {\n      newPermission = Short.parseShort(modeStr, 8);\n      SetAclOptions options =\n          SetAclOptions.defaults().setPermission(newPermission).setRecursive(recursive);\n      mTfs.setAcl(path, options);\n      System.out.println(\"Changed permission of \" + path + \" to \"\n          + Integer.toOctalString(newPermission));\n    } catch (Exception e) {\n      throw new IOException(\"Failed to changed permission of  \" + path + \" to \"\n          + Integer.toOctalString(newPermission) + \" : \" + e.getMessage());\n    }\n  }","commit_id":"d167880c38b26652a692de5d73024033b30f6e9a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Changes permission of a path.\n   *\n   * @param path path to set permission\n   * @param permission permission set to path\n   * @throws IOException if the path failed to be changed permission\n   */\n  public void setPermission(Path path, FsPermission permission) throws IOException {\n    TachyonURI tPath = new TachyonURI(Utils.getPathWithoutScheme(path));\n    Path hdfsPath = Utils.getHDFSPath(tPath, mUnderFSAddress);\n    LOG.info(\"setPermission({},{}) HDFS Path: {} Tachyon Path: {}{}\", path, permission.toString(),\n        hdfsPath, mTachyonHeader, tPath);\n    try {\n      SetAclOptions options =\n          new SetAclOptions.Builder().setPermission(permission.toShort()).setRecursive(false)\n              .build();\n      mTFS.setAcl(tPath, options);\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n  }","id":92511,"modified_method":"/**\n   * Changes permission of a path.\n   *\n   * @param path path to set permission\n   * @param permission permission set to path\n   * @throws IOException if the path failed to be changed permission\n   */\n  public void setPermission(Path path, FsPermission permission) throws IOException {\n    TachyonURI tPath = new TachyonURI(Utils.getPathWithoutScheme(path));\n    Path hdfsPath = Utils.getHDFSPath(tPath, mUnderFSAddress);\n    LOG.info(\"setPermission({},{}) HDFS Path: {} Tachyon Path: {}{}\", path, permission.toString(),\n        hdfsPath, mTachyonHeader, tPath);\n    try {\n      SetAclOptions options =\n          SetAclOptions.defaults().setPermission(permission.toShort()).setRecursive(false);\n      mTFS.setAcl(tPath, options);\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n  }","commit_id":"d167880c38b26652a692de5d73024033b30f6e9a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Changes owner or group of a path (i.e. a file or a directory). If username is null, the\n   * original username remains unchanged. Same as groupname. If username and groupname are non-null,\n   * both of them will be changed.\n   *\n   * @param path path to set owner or group\n   * @param username username to be set\n   * @param groupname groupname to be set\n   * @throws IOException if changing owner or group of the path failed\n   */\n  @Override\n  public void setOwner(Path path, final String username, final String groupname)\n      throws IOException {\n    TachyonURI tPath = new TachyonURI(Utils.getPathWithoutScheme(path));\n    Path hdfsPath = Utils.getHDFSPath(tPath, mUnderFSAddress);\n    LOG.info(\"setOwner({},{},{}) HDFS Path: {} Tachyon Path: {}{}\", path, username, groupname,\n        hdfsPath, mTachyonHeader, tPath);\n    try {\n      SetAclOptions.Builder optionsBuilder = new SetAclOptions.Builder();\n      boolean ownerOrGroupChanged = false;\n      if (username != null && !username.isEmpty()) {\n        optionsBuilder.setOwner(username).setRecursive(false);\n        ownerOrGroupChanged = true;\n      }\n      if (groupname != null && !groupname.isEmpty()) {\n        optionsBuilder.setGroup(groupname).setRecursive(false);\n        ownerOrGroupChanged = true;\n      }\n      if (ownerOrGroupChanged) {\n        mTFS.setAcl(tPath, optionsBuilder.build());\n      }\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n  }","id":92512,"modified_method":"/**\n   * Changes owner or group of a path (i.e. a file or a directory). If username is null, the\n   * original username remains unchanged. Same as groupname. If username and groupname are non-null,\n   * both of them will be changed.\n   *\n   * @param path path to set owner or group\n   * @param username username to be set\n   * @param groupname groupname to be set\n   * @throws IOException if changing owner or group of the path failed\n   */\n  @Override\n  public void setOwner(Path path, final String username, final String groupname)\n      throws IOException {\n    TachyonURI tPath = new TachyonURI(Utils.getPathWithoutScheme(path));\n    Path hdfsPath = Utils.getHDFSPath(tPath, mUnderFSAddress);\n    LOG.info(\"setOwner({},{},{}) HDFS Path: {} Tachyon Path: {}{}\", path, username, groupname,\n        hdfsPath, mTachyonHeader, tPath);\n    try {\n      SetAclOptions options = SetAclOptions.defaults();\n      boolean ownerOrGroupChanged = false;\n      if (username != null && !username.isEmpty()) {\n        options.setOwner(username).setRecursive(false);\n        ownerOrGroupChanged = true;\n      }\n      if (groupname != null && !groupname.isEmpty()) {\n        options.setGroup(groupname).setRecursive(false);\n        ownerOrGroupChanged = true;\n      }\n      if (ownerOrGroupChanged) {\n        mTFS.setAcl(tPath, options);\n      }\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n  }","commit_id":"d167880c38b26652a692de5d73024033b30f6e9a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link ChgrpCommand}.\n   *\n   * @param conf a Tachyon configuration\n   * @param tfs a Tachyon file system handle\n   */\n  public ChgrpCommand(TachyonConf conf, TachyonFileSystem tfs) {\n    super(conf, tfs);\n  }","id":92513,"modified_method":"/**\n   * Creates a new instance of {@link ChgrpCommand}.\n   *\n   * @param conf a Tachyon configuration\n   * @param tfs a Tachyon file system handle\n   */\n  public ChgrpCommand(TachyonConf conf, FileSystem tfs) {\n    super(conf, tfs);\n  }","commit_id":"d167880c38b26652a692de5d73024033b30f6e9a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link ChgrpRecursiveCommand}.\n   *\n   * @param conf a Tachyon configuration\n   * @param tfs a Tachyon file system handle\n   */\n  public ChgrpRecursiveCommand(TachyonConf conf, TachyonFileSystem tfs) {\n    super(conf, tfs);\n  }","id":92514,"modified_method":"/**\n   * Creates a new instance of {@link ChgrpRecursiveCommand}.\n   *\n   * @param conf a Tachyon configuration\n   * @param tfs a Tachyon file system handle\n   */\n  public ChgrpRecursiveCommand(TachyonConf conf, FileSystem tfs) {\n    super(conf, tfs);\n  }","commit_id":"d167880c38b26652a692de5d73024033b30f6e9a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link ChmodCommand}.\n   *\n   * @param conf a Tachyon configuration\n   * @param tfs a Tachyon file system handle\n   */\n  public ChmodCommand(TachyonConf conf, TachyonFileSystem tfs) {\n    super(conf, tfs);\n  }","id":92515,"modified_method":"/**\n   * Creates a new instance of {@link ChmodCommand}.\n   *\n   * @param conf a Tachyon configuration\n   * @param tfs a Tachyon file system handle\n   */\n  public ChmodCommand(TachyonConf conf, FileSystem tfs) {\n    super(conf, tfs);\n  }","commit_id":"d167880c38b26652a692de5d73024033b30f6e9a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link ChmodRecursiveCommand}.\n   *\n   * @param conf a Tachyon configuration\n   * @param tfs a Tachyon file system handle\n   */\n  public ChmodRecursiveCommand(TachyonConf conf, TachyonFileSystem tfs) {\n    super(conf, tfs);\n  }","id":92516,"modified_method":"/**\n   * Creates a new instance of {@link ChmodRecursiveCommand}.\n   *\n   * @param conf a Tachyon configuration\n   * @param tfs a Tachyon file system handle\n   */\n  public ChmodRecursiveCommand(TachyonConf conf, FileSystem tfs) {\n    super(conf, tfs);\n  }","commit_id":"d167880c38b26652a692de5d73024033b30f6e9a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link ChownCommand}.\n   *\n   * @param conf a Tachyon configuration\n   * @param tfs a Tachyon file system handle\n   */\n  public ChownCommand(TachyonConf conf, TachyonFileSystem tfs) {\n    super(conf, tfs);\n  }","id":92517,"modified_method":"/**\n   * Creates a new instance of {@link ChownCommand}.\n   *\n   * @param conf a Tachyon configuration\n   * @param tfs a Tachyon file system handle\n   */\n  public ChownCommand(TachyonConf conf, FileSystem tfs) {\n    super(conf, tfs);\n  }","commit_id":"d167880c38b26652a692de5d73024033b30f6e9a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link ChownRecursiveCommand}.\n   *\n   * @param conf a Tachyon configuration\n   * @param tfs a Tachyon file system handle\n   */\n  public ChownRecursiveCommand(TachyonConf conf, TachyonFileSystem tfs) {\n    super(conf, tfs);\n  }","id":92518,"modified_method":"/**\n   * Creates a new instance of {@link ChownRecursiveCommand}.\n   *\n   * @param conf a Tachyon configuration\n   * @param tfs a Tachyon file system handle\n   */\n  public ChownRecursiveCommand(TachyonConf conf, FileSystem tfs) {\n    super(conf, tfs);\n  }","commit_id":"d167880c38b26652a692de5d73024033b30f6e9a","url":"https://github.com/amplab/tachyon"},{"original_method":"private SetAclOptions(Builder builder) {\n    mOwner = builder.mOwner;\n    mGroup = builder.mGroup;\n    mPermission = builder.mPermission;\n    mRecursive = builder.mRecursive;\n  }","id":92519,"modified_method":"private SetAclOptions() {\n    mOwner = null;\n    mGroup = null;\n    mPermission = Constants.INVALID_PERMISSION;\n    mRecursive = false;\n  }","commit_id":"d167880c38b26652a692de5d73024033b30f6e9a","url":"https://github.com/amplab/tachyon"},{"original_method":"public static boolean compare(Period op1, CompareType cmp, Period op2) {\n    DateTime now = new DateTime(currentZone.get());\n    warn(now);\n    int compareValue;\n\n    if(op1 == null) {\n      compareValue = op2 != null ? -1 : 0;\n    } else {\n      if (op2 == null) {\n        compareValue = 1;\n      } else {\n        Duration d1 = op1.toDurationFrom(now);\n        warn(d1);\n        Duration d2 = op2.toDurationFrom(now);\n        warn(d2);\n        compareValue = d1.compareTo(d2);\n        warn(compareValue);\n      }\n    }\n\n    return compareResult(compareValue, cmp);\n  }","id":92520,"modified_method":"public static boolean compare(Period op1, CompareType cmp, Period op2) {\n    DateTime now = new DateTime(currentZone.get());\n    int compareValue;\n\n    if(op1 == null) {\n      compareValue = op2 != null ? -1 : 0;\n    } else {\n      compareValue = op2 != null ? op1.toDurationFrom(now).compareTo(op2.toDurationFrom(now)) : 1;\n    }\n\n    return compareResult(compareValue, cmp);\n  }","commit_id":"e7065ff9d7bb8a00c08b303c835e838ce2834f7b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean compare(Period op1, CompareType cmp, Period op2) {\n    DateTime now = new DateTime(currentZone.get());\n    int compareValue;\n\n    if(op1 == null) {\n      compareValue = op2 != null ? -1 : 0;\n    } else {\n      compareValue = op2 != null ? op1.toDurationFrom(now).compareTo(op2.toDurationFrom(now)) : 1;\n    }\n\n    return compareResult(compareValue, cmp);\n  }","id":92521,"modified_method":"public static boolean compare(Period op1, CompareType cmp, Period op2) {\n    DateTime now = new DateTime(currentZone.get());\n    warn(now);\n    int compareValue;\n\n    if(op1 == null) {\n      compareValue = op2 != null ? -1 : 0;\n    } else {\n      if (op2 == null) {\n        compareValue = 1;\n      } else {\n        Duration d1 = op1.toDurationFrom(now);\n        warn(d1);\n        Duration d2 = op2.toDurationFrom(now);\n        warn(d2);\n        compareValue = d1.compareTo(d2);\n        warn(compareValue);\n      }\n    }\n\n    return compareResult(compareValue, cmp);\n  }","commit_id":"d2177172aab4ca051c64914248f710af82ab34d2","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n\t * Execute a checkpoint - detect our internet IP address and log it\n\t * @param preferedAddress An address that for some reason is prefered above others. Might be null\n\t */\n\tprotected synchronized void checkpoint() {\n\t\tboolean logDEBUG = Logger.shouldLog(Logger.DEBUG, this);\n\t\tVector addrs = new Vector();\n\n\t\tEnumeration interfaces = null;\n\t\ttry {\n\t\t\tinterfaces = java.net.NetworkInterface.getNetworkInterfaces();\n\t\t} catch (SocketException e) {\n\t\t\tLogger.error(\n\t\t\t\tthis,\n\t\t\t\t\"SocketException trying to detect NetworkInterfaces\",\n\t\t\t\te);\n\t\t\taddrs.add(oldDetect());\n\t\t\told = true;\n\t\t}\n\n\t\tif (!old) {\n\t\t\twhile (interfaces.hasMoreElements()) {\n\t\t\t\tjava.net.NetworkInterface iface =\n\t\t\t\t\t(java.net.NetworkInterface) (interfaces.nextElement());\n\t\t\t\tif (logDEBUG)\n\t\t\t\t\tLogger.debug(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\"Scanning NetworkInterface \" + iface.getDisplayName());\n\t\t\t\tEnumeration ee = iface.getInetAddresses();\n\t\t\t\twhile (ee.hasMoreElements()) {\n\n\t\t\t\t\tInetAddress addr = (InetAddress) (ee.nextElement());\n\t\t\t\t\taddrs.add(addr);\n\t\t\t\t\tif (logDEBUG)\n\t\t\t\t\t\tLogger.debug(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\"Adding address \"\n\t\t\t\t\t\t\t\t+ addr\n\t\t\t\t\t\t\t\t+ \" from \"\n\t\t\t\t\t\t\t\t+ iface.getDisplayName());\n\t\t\t\t}\n\t\t\t\tif (logDEBUG)\n\t\t\t\t\tLogger.debug(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\"Finished scanning interface \" + iface.getDisplayName());\n\t\t\t}\n\t\t\tif (logDEBUG)\n\t\t\t\tLogger.debug(\n\t\t\t\t\tthis,\n\t\t\t\t\t\"Finished scanning interfaces\");\n\t\t}\n\n\t\t// FIXME: what are we doing here? lastInetAddress is always null.\n\t\tInetAddress[] oldAddressList = lastAddressList;\n\t\tonGetAddresses(addrs);\n\t\tlastDetectedTime = System.currentTimeMillis();\n\t\tif(oldAddressList != lastAddressList && (oldAddressList == null && lastAddressList != null ||\n\t\t\t\toldAddressList != null && lastAddressList != null && !Arrays.equals(oldAddressList, lastAddressList))) {\n\t\t\t// Something changed.\n\t\t\t// Yes I know it could just have changed the order, but this is unlikely hopefully. FIXME.\n\t\t\tdetector.redetectAddress();\n\t\t}\n\t}","id":92522,"modified_method":"/**\n\t * Execute a checkpoint - detect our internet IP address and log it\n\t * @param preferedAddress An address that for some reason is preferred above others. Might be null\n\t */\n\tprotected synchronized void checkpoint() {\n\t\tboolean logDEBUG = Logger.shouldLog(Logger.DEBUG, this);\n\t\tList<InetAddress> addrs = new ArrayList<InetAddress>();\n\n\t\tEnumeration<java.net.NetworkInterface> interfaces = null;\n\t\ttry {\n\t\t\tinterfaces = java.net.NetworkInterface.getNetworkInterfaces();\n\t\t} catch (SocketException e) {\n\t\t\tLogger.error(\n\t\t\t\tthis,\n\t\t\t\t\"SocketException trying to detect NetworkInterfaces\",\n\t\t\t\te);\n\t\t\taddrs.add(oldDetect());\n\t\t\told = true;\n\t\t}\n\n\t\tif (!old) {\n\t\t\twhile (interfaces.hasMoreElements()) {\n\t\t\t\tjava.net.NetworkInterface iface = interfaces.nextElement();\n\t\t\t\tif (logDEBUG)\n\t\t\t\t\tLogger.debug(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\"Scanning NetworkInterface \" + iface.getDisplayName());\n\t\t\t\tEnumeration<InetAddress> ee = iface.getInetAddresses();\n\t\t\t\twhile (ee.hasMoreElements()) {\n\n\t\t\t\t\tInetAddress addr = ee.nextElement();\n\t\t\t\t\taddrs.add(addr);\n\t\t\t\t\tif (logDEBUG)\n\t\t\t\t\t\tLogger.debug(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\"Adding address \"\n\t\t\t\t\t\t\t\t+ addr\n\t\t\t\t\t\t\t\t+ \" from \"\n\t\t\t\t\t\t\t\t+ iface.getDisplayName());\n\t\t\t\t}\n\t\t\t\tif (logDEBUG)\n\t\t\t\t\tLogger.debug(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\"Finished scanning interface \" + iface.getDisplayName());\n\t\t\t}\n\t\t\tif (logDEBUG)\n\t\t\t\tLogger.debug(\n\t\t\t\t\tthis,\n\t\t\t\t\t\"Finished scanning interfaces\");\n\t\t}\n\n\t\t// FIXME: what are we doing here? lastInetAddress is always null.\n\t\tInetAddress[] oldAddressList = lastAddressList;\n\t\tonGetAddresses(addrs);\n\t\tlastDetectedTime = System.currentTimeMillis();\n\t\tif(oldAddressList != lastAddressList && (oldAddressList == null && lastAddressList != null ||\n\t\t\t\toldAddressList != null && lastAddressList != null && !Arrays.equals(oldAddressList, lastAddressList))) {\n\t\t\t// Something changed.\n\t\t\t// Yes I know it could just have changed the order, but this is unlikely hopefully. FIXME.\n\t\t\tdetector.redetectAddress();\n\t\t}\n\t}","commit_id":"ecc40d558f9e09a1826c4145af2be13074783a1c","url":"https://github.com/freenet/fred"},{"original_method":"/** Do something with the list of detected IP addresses.\n\t * @param v Vector of InetAddresses\n\t */\n\tprotected void onGetAddresses(Vector v) {\n\t\tVector output = new Vector();\n\t\tboolean logDEBUG = Logger.shouldLog(Logger.DEBUG, this);\n\t\tif (logDEBUG)\n\t\t\tLogger.debug(\n\t\t\t\tthis,\n\t\t\t\t\"onGetAddresses found \" + v.size() + \" potential addresses)\");\n\t\tif (v.size() == 0) {\n\t\t\tLogger.error(this, \"No addresses found!\");\n\t\t\tlastAddressList = null;\n\t\t\treturn;\n\t\t} else {\n//\t\t\tInetAddress lastNonValidAddress = null;\n\t\t\tfor (int x = 0; x < v.size(); x++) {\n\t\t\t\tif (v.elementAt(x) != null) {\n\t\t\t\t\tInetAddress i = (InetAddress) (v.elementAt(x));\n\t\t\t\t\tif (logDEBUG)\n\t\t\t\t\t\tLogger.debug(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\"Address \" + x + \": \" + i);\n\t\t\t\t\tif(i.isAnyLocalAddress()) {\n\t\t\t\t\t\t// Wildcard address, 0.0.0.0, ignore.\n\t\t\t\t\t} else if(i.isLinkLocalAddress() || i.isLoopbackAddress() ||\n\t\t\t\t\t\t\ti.isSiteLocalAddress()) {\n\t\t\t\t\t\t// Will be filtered out later if necessary.\n\t\t\t\t\t\toutput.add(i);\n\t\t\t\t\t} else if(i.isMulticastAddress()) {\n\t\t\t\t\t\t// Ignore\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Ignore ISATAP addresses\n\t\t\t\t\t\t// @see http://archives.freenetproject.org/message/20071129.220955.ac2a2a36.en.html\n\t\t\t\t\t\tif(!AddressIdentifier.isAnISATAPIPv6Address(i.toString()))\n\t\t\t\t\t\t\toutput.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlastAddressList = (InetAddress[]) output.toArray(new InetAddress[output.size()]);\n\t}","id":92523,"modified_method":"/**\n\t * Do something with the list of detected IP addresses.\n\t * \n\t * @param addrs\n\t *            Vector of InetAddresses\n\t */\n\tprotected void onGetAddresses(List<InetAddress> addrs) {\n\t\tList<InetAddress> output = new ArrayList<InetAddress>();\n\t\tboolean logDEBUG = Logger.shouldLog(Logger.DEBUG, this);\n\t\tif (logDEBUG)\n\t\t\tLogger.debug(\n\t\t\t\tthis,\n\t\t\t\t\"onGetAddresses found \" + addrs.size() + \" potential addresses)\");\n\t\tif (addrs.size() == 0) {\n\t\t\tLogger.error(this, \"No addresses found!\");\n\t\t\tlastAddressList = null;\n\t\t\treturn;\n\t\t} else {\n//\t\t\tInetAddress lastNonValidAddress = null;\n\t\t\tfor (int x = 0; x < addrs.size(); x++) {\n\t\t\t\tif (addrs.get(x) != null) {\n\t\t\t\t\tInetAddress i = addrs.get(x);\n\t\t\t\t\tif (logDEBUG)\n\t\t\t\t\t\tLogger.debug(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\"Address \" + x + \": \" + i);\n\t\t\t\t\tif(i.isAnyLocalAddress()) {\n\t\t\t\t\t\t// Wildcard address, 0.0.0.0, ignore.\n\t\t\t\t\t} else if(i.isLinkLocalAddress() || i.isLoopbackAddress() ||\n\t\t\t\t\t\t\ti.isSiteLocalAddress()) {\n\t\t\t\t\t\t// Will be filtered out later if necessary.\n\t\t\t\t\t\toutput.add(i);\n\t\t\t\t\t} else if(i.isMulticastAddress()) {\n\t\t\t\t\t\t// Ignore\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Ignore ISATAP addresses\n\t\t\t\t\t\t// @see http://archives.freenetproject.org/message/20071129.220955.ac2a2a36.en.html\n\t\t\t\t\t\tif(!AddressIdentifier.isAnISATAPIPv6Address(i.toString()))\n\t\t\t\t\t\t\toutput.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlastAddressList = output.toArray(new InetAddress[output.size()]);\n\t}","commit_id":"ecc40d558f9e09a1826c4145af2be13074783a1c","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Creates an instance of <tt>AddContactWizardPage2<\/tt>.\n     * @param wizard the parent wizard, where this page is contained\n     * @param newContact An object that collects all user choices through the\n     * wizard.\n     * @param groupsList The list of all <tt>MetaContactGroup<\/tt>s, from which\n     * the user could select.\n     */\n    public AddContactWizardPage2(   AddContactWizard wizard, \n                                    NewContact newContact,\n                                    Iterator groupsList)\n    {\n        this.wizard = wizard;\n\n        this.newContact = newContact;\n\n        selectGroupPanel = new SelectGroupPanel(wizard, newContact);\n    }","id":92524,"modified_method":"/**\n     * Creates an instance of <tt>AddContactWizardPage2<\/tt>.\n     * @param wizard the parent wizard, where this page is contained\n     * @param newContact An object that collects all user choices through the\n     * wizard.\n     * @param groupsList The list of all <tt>MetaContactGroup<\/tt>s, from which\n     * the user could select.\n     */\n    public AddContactWizardPage2(   AddContactWizard wizard, \n                                    NewContact newContact,\n                                    Iterator groupsList)\n    {\n        this.newContact = newContact;\n\n        selectGroupPanel = new SelectGroupPanel(wizard, newContact);\n    }","commit_id":"a36ab57e97b1fd498185964a8d981f7c63f44454","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void initPool()\n    {\n        Enumeration localIfaces = null;\n        try\n        {\n            localIfaces = NetworkInterface.getNetworkInterfaces();\n        }\n        catch (SocketException ex)\n        {\n            throw new RuntimeException(\n                \"Failed to retrieve local interfaces!\");\n        }\n\n        //loop over all local network interfaces\n        while (localIfaces.hasMoreElements())\n        {\n            NetworkInterface iFace =\n                (NetworkInterface) localIfaces.nextElement();\n\n            Enumeration addresses = iFace.getInetAddresses();\n\n            //addresses loop\n            while (addresses.hasMoreElements())\n            {\n                InetAddress address = (InetAddress) addresses.nextElement();\n\n                //we don't care about loopback addresses\n                if(address.isLoopbackAddress())\n                    continue;\n\n                AddressPoolEntry addrEntry =\n                    new AddressPoolEntry(address, iFace);\n                AddressDiagnosticsKit diagKit =\n                        new AddressDiagnosticsKit(addrEntry);\n\n                addressEntries.add(addrEntry);\n                diagnosticsKits.put(addrEntry, diagKit);\n                diagKit.start();\n            } //addresses loop\n        } //interfaces loop\n    }","id":92525,"modified_method":"private void initPool()\n    {\n        Enumeration<NetworkInterface> localIfaces = null;\n        try\n        {\n            localIfaces = NetworkInterface.getNetworkInterfaces();\n        }\n        catch (SocketException ex)\n        {\n            throw new RuntimeException(\n                \"Failed to retrieve local interfaces!\");\n        }\n\n        //loop over all local network interfaces\n        while (localIfaces.hasMoreElements())\n        {\n            NetworkInterface iFace = localIfaces.nextElement();\n\n            Enumeration<InetAddress> addresses = iFace.getInetAddresses();\n\n            //addresses loop\n            while (addresses.hasMoreElements())\n            {\n                InetAddress address = addresses.nextElement();\n\n                //we don't care about loopback addresses\n                if(address.isLoopbackAddress())\n                    continue;\n\n                AddressPoolEntry addrEntry =\n                    new AddressPoolEntry(address, iFace);\n                AddressDiagnosticsKit diagKit =\n                        new AddressDiagnosticsKit(addrEntry);\n\n                addressEntries.add(addrEntry);\n                diagnosticsKits.put(addrEntry, diagKit);\n                diagKit.start();\n            } //addresses loop\n        } //interfaces loop\n    }","commit_id":"a36ab57e97b1fd498185964a8d981f7c63f44454","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>ChatRoomsListRightButtonMenu<\/tt>.\n     */\n    public ChatRoomCommonRightButtonMenu(   MainFrame mainFrame,\n                                            ChatRoomProviderWrapper provider)\n    {\n        super();\n\n        this.mainFrame = mainFrame;\n\n        this.chatRoomProvider = provider;\n\n        this.setLocation(getLocation());\n\n        this.init();\n    }","id":92526,"modified_method":"/**\n     * Creates an instance of <tt>ChatRoomsListRightButtonMenu<\/tt>.\n     */\n    public ChatRoomCommonRightButtonMenu(   MainFrame mainFrame,\n                                            ChatRoomProviderWrapper provider)\n    {\n        this.chatRoomProvider = provider;\n\n        this.setLocation(getLocation());\n\n        this.init();\n    }","commit_id":"a36ab57e97b1fd498185964a8d981f7c63f44454","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates the scroll panel containing the chat rooms list.\n     *\n     * @param frame the main application frame\n     */\n    public ChatRoomListUI(ChatRoomListDialog parentDialog)\n    {\n        this.parentDialog = parentDialog;\n\n        GuiActivator.getUIService().getConferenceChatManager()\n            .addChatRoomListChangeListener(this);\n\n        this.treePanel.add(chatRoomList, BorderLayout.NORTH);\n\n        this.setViewportView(treePanel);\n\n        this.setHorizontalScrollBarPolicy(\n            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\n        this.getActionMap().put(\"runChat\", new ChatRoomsListPanelEnterAction());\n\n        InputMap imap = this.getInputMap(\n                JComponent.WHEN_IN_FOCUSED_WINDOW);\n\n        imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), \"runChat\");\n\n        this.setPreferredSize(new Dimension(200, 450));\n        this.setMinimumSize(new Dimension(80, 200));\n\n        this.initChatRoomList();\n    }","id":92527,"modified_method":"/**\n     * Creates the scroll panel containing the chat rooms list.\n     *\n     * @param frame the main application frame\n     */\n    public ChatRoomListUI(ChatRoomListDialog parentDialog)\n    {\n        GuiActivator.getUIService().getConferenceChatManager()\n            .addChatRoomListChangeListener(this);\n\n        this.treePanel.add(chatRoomList, BorderLayout.NORTH);\n\n        this.setViewportView(treePanel);\n\n        this.setHorizontalScrollBarPolicy(\n            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\n        this.getActionMap().put(\"runChat\", new ChatRoomsListPanelEnterAction());\n\n        InputMap imap = this.getInputMap(\n                JComponent.WHEN_IN_FOCUSED_WINDOW);\n\n        imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), \"runChat\");\n\n        this.setPreferredSize(new Dimension(200, 450));\n        this.setMinimumSize(new Dimension(80, 200));\n\n        this.initChatRoomList();\n    }","commit_id":"a36ab57e97b1fd498185964a8d981f7c63f44454","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n\t * <span class=\"en\">\n\t * Returns the localized value for a key. An @ keypath such as \n\t * <code>session.localizer.@locale.getLanguage<\/code> indicates that\n\t * the methods on ERXLocalizer itself should be called instead of\n\t * searching the strings file for a '@locale.getLanguage' key.\n\t * @param key the keyPath string\n\t * @return a localized string value or the object value of the @ keyPath\n\t * <\/span>\n\t * \n   * <span class=\"ja\">\n   * キーを使って、ローカライズ・オブジェクトを戻します\n   * @ キーパス <code>session.localizer.@locale.getLanguage<\/code> で\n   * キーファイルを探すかわりに ERXLocalicer メソッドを実行します。\n   * @param key - キー\n   * \n   * @return ローカライズ済みオブジェクト又は @ キーパス\n   * <\/span>\n\t */\n\tpublic Object localizedValueForKey(String key) {\n\t\tif(!ERXStringUtilities.stringIsNullOrEmpty(key) && _localizerMethodIndicatorCharacter == key.charAt(0)) {\n\t\t\tint dotIndex = key.indexOf(NSKeyValueCodingAdditions.KeyPathSeparator);\n\t\t\tString methodKey = (dotIndex>0)?key.substring(1, dotIndex):key.substring(1, key.length());\n\t\t\ttry {\n\t\t\t\tMethod m = ERXLocalizer.class.getMethod(methodKey);\n\t\t\t\treturn m.invoke(this, (Object[])null);\n\t\t\t} catch(NoSuchMethodException nsme) {\n\t\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(nsme);\n\t\t\t} catch(IllegalAccessException iae) {\n\t\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(iae);\n\t\t\t} catch(InvocationTargetException ite) {\n\t\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(ite);\n\t\t\t}\n\t\t}\n\t\tObject result = cache.objectForKey(key);\n\t\tif (key == null || result == NOT_FOUND)\n\t\t\treturn null;\n\t\tif (result != null)\n\t\t\treturn result;\n\n\t\tif (createdKeysLog.isDebugEnabled()) {\n\t\t\tlog.debug(\"Key not found: '\" + key + \"'/\" + language);\n\t\t}\n\t\tif (fallbackToDefaultLanguage() && !defaultLanguage().equals(language)) {\n\t\t\tObject valueInDefaultLanguage = defaultLocalizer().localizedValueForKey(key);\n\t\t\tsetCacheValueForKey(valueInDefaultLanguage == null ? NOT_FOUND : valueInDefaultLanguage, key);\n\t\t\treturn valueInDefaultLanguage;\n\t\t}\n\t\tsetCacheValueForKey(NOT_FOUND, key);\n\t\treturn null;\n\t}","id":92528,"modified_method":"/**\n\t * <span class=\"en\">\n\t * Returns the localized value for a key. An @ keypath such as \n\t * <code>session.localizer.@locale.getLanguage<\/code> indicates that\n\t * the methods on ERXLocalizer itself should be called instead of\n\t * searching the strings file for a '@locale.getLanguage' key.\n\t * @param key the keyPath string\n\t * @return a localized string value or the object value of the @ keyPath\n\t * <\/span>\n\t * \n   * <span class=\"ja\">\n   * キーを使って、ローカライズ・オブジェクトを戻します\n   * @ キーパス <code>session.localizer.@locale.getLanguage<\/code> で\n   * キーファイルを探すかわりに ERXLocalicer メソッドを実行します。\n   * @param key - キー\n   * \n   * @return ローカライズ済みオブジェクト又は @ キーパス\n   * <\/span>\n\t */\n\tpublic Object localizedValueForKey(String key) {\n\t\tif(!ERXStringUtilities.stringIsNullOrEmpty(key) && _localizerMethodIndicatorCharacter == key.charAt(0)) {\n\t\t\tint dotIndex = key.indexOf(NSKeyValueCodingAdditions.KeyPathSeparator);\n\t\t\tString methodKey = (dotIndex>0)?key.substring(1, dotIndex):key.substring(1, key.length());\n\t\t\ttry {\n\t\t\t\tMethod m = ERXLocalizer.class.getMethod(methodKey);\n\t\t\t\treturn m.invoke(this, (Object[])null);\n\t\t\t} catch(NoSuchMethodException nsme) {\n\t\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(nsme);\n\t\t\t} catch(IllegalAccessException iae) {\n\t\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(iae);\n\t\t\t} catch(InvocationTargetException ite) {\n\t\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(ite);\n\t\t\t}\n\t\t}\n\t\tObject result = cache.objectForKey(key);\n\t\tif (key == null || result == NOT_FOUND)\n\t\t\treturn null;\n\t\tif (result != null)\n\t\t\treturn result;\n\n\t\tif (createdKeysLog.isDebugEnabled()) {\n\t\t  if(log.isDebugEnabled())\n\t\t    log.debug(\"Key not found: '\" + key + \"'/\" + language);\n\t\t}\n\t\tif (fallbackToDefaultLanguage() && !defaultLanguage().equals(language)) {\n\t\t\tObject valueInDefaultLanguage = defaultLocalizer().localizedValueForKey(key);\n\t\t\tsetCacheValueForKey(valueInDefaultLanguage == null ? NOT_FOUND : valueInDefaultLanguage, key);\n\t\t\treturn valueInDefaultLanguage;\n\t\t}\n\t\tsetCacheValueForKey(NOT_FOUND, key);\n\t\treturn null;\n\t}","commit_id":"5702aee652edc9756ef9d8cc5e47cd42d3502cca","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * <span class=\"ja\">\n   * キー・リストをダンプします\n   * <\/span>\n   */\n\tpublic void dumpCreatedKeys() {\n\t\tlog.info(NSPropertyListSerialization.stringFromPropertyList(createdKeys()));\n\t}","id":92529,"modified_method":"/**\n   * <span class=\"ja\">\n   * キー・リストをダンプします\n   * <\/span>\n   */\n\tpublic void dumpCreatedKeys() {\n\t  if(log.isInfoEnabled())\n\t    log.info(NSPropertyListSerialization.stringFromPropertyList(createdKeys()));\n\t}","commit_id":"5702aee652edc9756ef9d8cc5e47cd42d3502cca","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * <span class=\"en\">\n\t * Returns a localized string for the given prefix and keyPath, inserting it \"prefix.keyPath\" = \"Key Path\"; Also\n\t * tries to find \"Key Path\"\n\t * \n\t * @param prefix\n\t * @param key\n\t * \n\t * @return the localized string\n\t * <\/span>\n\t * \n   * <span class=\"ja\">\n   * 指定の prefix と key のローカライズ済みの文字列を戻します。<br />\n   * 例えば、 <br />\n   * s = <<ERXLocalizer>>.localizedDisplayNameForKey( \"Tester\", \"samplekey\" )<br />\n   * <br />\n   * Tester.samplekey になります<br />\n   * 　　あれば、そのローカライズ済み String が戻ります<br />\n   * 　　なければ、ERXStringUtilities.displayNameForKey処理が行われ、<br />\n   * Tester.samplekey -> Samplekey になり、再度ローカライザーへ問い合わせが行きます。<br />\n   * 　　あれば、そのローカライズ済み String が戻ります<br />\n   * 　　なければ、キーが戻ります。<br />\n   * \n   * @param prefix - \n   * @param key - キー\n   * \n   * @return　ローカライズ済み String\n   * <\/span>\n\t */\n\tpublic String localizedDisplayNameForKey(String prefix, String key) {\n\t\tString localizerKey = prefix + \".\" + key;\n\t\tString result = localizedStringForKey(localizerKey);\n\t\tif (result == null) {\n\t\t\tresult = displayNameForKey(key);\n\t\t\tString localized = localizedStringForKey(result);\n\t\t\tif (localized != null) {\n\t\t\t\tresult = localized;\n\t\t\t\tlog.info(\"Found an old-style entry: \" + localizerKey + \"->\" + result);\n\t\t\t}\n\t\t\ttakeValueForKey(result, localizerKey);\n\t\t}\n\t\treturn result;\n\t}","id":92530,"modified_method":"/**\n\t * <span class=\"en\">\n\t * Returns a localized string for the given prefix and keyPath, inserting it \"prefix.keyPath\" = \"Key Path\"; Also\n\t * tries to find \"Key Path\"\n\t * \n\t * @param prefix\n\t * @param key\n\t * \n\t * @return the localized string\n\t * <\/span>\n\t * \n   * <span class=\"ja\">\n   * 指定の prefix と key のローカライズ済みの文字列を戻します。<br />\n   * 例えば、 <br />\n   * s = <<ERXLocalizer>>.localizedDisplayNameForKey( \"Tester\", \"samplekey\" )<br />\n   * <br />\n   * Tester.samplekey になります<br />\n   * 　　あれば、そのローカライズ済み String が戻ります<br />\n   * 　　なければ、ERXStringUtilities.displayNameForKey処理が行われ、<br />\n   * Tester.samplekey -> Samplekey になり、再度ローカライザーへ問い合わせが行きます。<br />\n   * 　　あれば、そのローカライズ済み String が戻ります<br />\n   * 　　なければ、キーが戻ります。<br />\n   * \n   * @param prefix - \n   * @param key - キー\n   * \n   * @return　ローカライズ済み String\n   * <\/span>\n\t */\n\tpublic String localizedDisplayNameForKey(String prefix, String key) {\n\t\tString localizerKey = prefix + \".\" + key;\n\t\tString result = localizedStringForKey(localizerKey);\n\t\tif (result == null) {\n\t\t\tresult = displayNameForKey(key);\n\t\t\tString localized = localizedStringForKey(result);\n\t\t\tif (localized != null) {\n\t\t\t\tresult = localized;\n\t\t\t\tif(log.isInfoEnabled())\n\t\t\t\t  log.info(\"Found an old-style entry: \" + localizerKey + \"->\" + result);\n\t\t\t}\n\t\t\ttakeValueForKey(result, localizerKey);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"5702aee652edc9756ef9d8cc5e47cd42d3502cca","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * <span class=\"ja\">\n   * フレームワーク検索パスをセットします\n   * \n   * @param value - フレームワーク検索\n   * <\/span>\n   */\n\tpublic static void setFrameworkSearchPath(NSArray value) {\n\t\tframeworkSearchPath = value;\n\t\tresetCache();\n\t}","id":92531,"modified_method":"/**\n   * <span class=\"ja\">\n   * フレームワーク検索パスをセットします\n   * \n   * @param value - フレームワーク検索\n   * <\/span>\n   */\n\tpublic static void setFrameworkSearchPath(NSArray<String> value) {\n\t\tframeworkSearchPath = value;\n\t\tresetCache();\n\t}","commit_id":"5702aee652edc9756ef9d8cc5e47cd42d3502cca","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * <span class=\"ja\">\n   * ウォッチするファイル名をセットします\n   * \n   * @param value - ファイル配列\n   * <\/span>\n   */\n\tpublic static void setFileNamesToWatch(NSArray value) {\n\t\tfileNamesToWatch = value;\n\t\tresetCache();\n\t}","id":92532,"modified_method":"/**\n   * <span class=\"ja\">\n   * ウォッチするファイル名をセットします\n   * \n   * @param value - ファイル配列\n   * <\/span>\n   */\n\tpublic static void setFileNamesToWatch(NSArray<String> value) {\n\t\tfileNamesToWatch = value;\n\t\tresetCache();\n\t}","commit_id":"5702aee652edc9756ef9d8cc5e47cd42d3502cca","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * <span class=\"ja\">\n   * フレームワーク検索パスの配列を戻します\n   * \n   * @return フレームワーク検索パスの配列\n   * <\/span>\n   */\n\tpublic static NSArray<String> frameworkSearchPath() {\n\t\tif (frameworkSearchPath == null) {\n\t\t\tframeworkSearchPath = ERXProperties.arrayForKey(\"er.extensions.ERXLocalizer.frameworkSearchPath\");\n\t\t\tif(frameworkSearchPath == null) {\n\t\t\t\tNSMutableArray<String> defaultValue = new NSMutableArray<String>();\n\t\t\t\tfor (Enumeration e = NSBundle.frameworkBundles().objectEnumerator(); e.hasMoreElements();) {\n\t\t\t\t\tNSBundle bundle = (NSBundle) e.nextElement();\n\t\t\t\t\tString name = bundle.name();\n\t\t\t\t\tif(!(name.equals(\"ERCoreBusinessLogic\") || name.equals(\"ERDirectToWeb\") || name.equals(\"ERExtensions\"))) {\n\t\t\t\t\t\tdefaultValue.addObject(name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(NSBundle.bundleForName(\"ERCoreBusinessLogic\") != null) \n\t\t\t\t\tdefaultValue.addObject(\"ERCoreBusinessLogic\");\n\t\t\t\tif(NSBundle.bundleForName(\"ERDirectToWeb\") != null) \n\t\t\t\t\tdefaultValue.addObject(\"ERDirectToWeb\");\n\t\t\t\tif(NSBundle.bundleForName(\"ERExtensions\") != null) \n\t\t\t\t\tdefaultValue.addObject(\"ERExtensions\");\n\t\t\t\tdefaultValue.insertObjectAtIndex(\"app\", 0);\n\t\t\t\tframeworkSearchPath = defaultValue;\n\t\t\t}\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"FrameworkSearchPath: \" + frameworkSearchPath);\n\t\t}\n\t\treturn frameworkSearchPath;\n\t}","id":92533,"modified_method":"/**\n   * <span class=\"ja\">\n   * フレームワーク検索パスの配列を戻します\n   * \n   * @return フレームワーク検索パスの配列\n   * <\/span>\n   */\n\tpublic static NSArray<String> frameworkSearchPath() {\n\t\tif (frameworkSearchPath == null) {\n\t\t\tframeworkSearchPath = ERXProperties.arrayForKey(\"er.extensions.ERXLocalizer.frameworkSearchPath\");\n\t\t\tif(frameworkSearchPath == null) {\n\t\t\t\tNSMutableArray<String> defaultValue = new NSMutableArray<String>();\n\t\t\t\tfor (Enumeration<NSBundle> e = NSBundle.frameworkBundles().objectEnumerator(); e.hasMoreElements();) {\n\t\t\t\t\tNSBundle bundle = e.nextElement();\n\t\t\t\t\tString name = bundle.name();\n\t\t\t\t\tif(!(name.equals(\"ERCoreBusinessLogic\") || name.equals(\"ERDirectToWeb\") || name.equals(\"ERExtensions\"))) {\n\t\t\t\t\t\tdefaultValue.addObject(name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(NSBundle.bundleForName(\"ERCoreBusinessLogic\") != null) \n\t\t\t\t\tdefaultValue.addObject(\"ERCoreBusinessLogic\");\n\t\t\t\tif(NSBundle.bundleForName(\"ERDirectToWeb\") != null) \n\t\t\t\t\tdefaultValue.addObject(\"ERDirectToWeb\");\n\t\t\t\tif(NSBundle.bundleForName(\"ERExtensions\") != null) \n\t\t\t\t\tdefaultValue.addObject(\"ERExtensions\");\n\t\t\t\tdefaultValue.insertObjectAtIndex(\"app\", 0);\n\t\t\t\tframeworkSearchPath = defaultValue;\n\t\t\t}\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"FrameworkSearchPath: \" + frameworkSearchPath.componentsJoinedByString(\" / \"));\n\t\t}\n\t\treturn frameworkSearchPath;\n\t}","commit_id":"5702aee652edc9756ef9d8cc5e47cd42d3502cca","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** <span class=\"ja\">ローカライザーのロード作業<\/span> */\n\tpublic void load() {\n\t\tcache.removeAllObjects();\n\t\tcreatedKeys.removeAllObjects();\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"Loading templates for language: \" + language + \" for files: \" + fileNamesToWatch() + \" with search path: \" + frameworkSearchPath());\n\n\t\tNSArray<String> languages = new NSArray<String>(language);\n\t\tEnumeration fn = fileNamesToWatch().objectEnumerator();\n\t\twhile (fn.hasMoreElements()) {\n\t\t\tString fileName = (String) fn.nextElement();\n\t\t\tEnumeration fr = frameworkSearchPath().reverseObjectEnumerator();\n\t\t\twhile (fr.hasMoreElements()) {\n\t\t\t\tString framework = (String) fr.nextElement();\n\n\t\t\t\tURL path = ERXFileUtilities.pathURLForResourceNamed(fileName, framework, languages);\n\t\t\t\tif (path != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tframework = \"app\".equals(framework) ? null : framework;\n\t\t\t\t\t\tlog.debug(\"Loading: \" + fileName + \" - \" + (framework == null ? \"app\" : framework) + \" - \" + languages + path);\n\t\t\t\t\t\tNSDictionary<String, Object> dict = (NSDictionary<String, Object>) ERXFileUtilities.readPropertyListFromFileInFramework(fileName, framework, languages);\n\t\t\t\t\t\t// HACK: ak we have could have a collision between the search path for validation strings and\n\t\t\t\t\t\t// the normal localized strings.\n\t\t\t\t\t\tif (fileName.indexOf(ERXValidationFactory.VALIDATION_TEMPLATE_PREFIX) == 0) {\n\t\t\t\t\t\t\tNSMutableDictionary<String, Object> newDict = new NSMutableDictionary<String, Object>();\n\t\t\t\t\t\t\tfor (Enumeration keys = dict.keyEnumerator(); keys.hasMoreElements();) {\n\t\t\t\t\t\t\t\tString key = (String) keys.nextElement();\n\t\t\t\t\t\t\t\tnewDict.setObjectForKey(dict.objectForKey(key), ERXValidationFactory.VALIDATION_TEMPLATE_PREFIX + key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdict = newDict;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddEntriesToCache(dict);\n\t\t\t\t\t\tif (!WOApplication.application().isCachingEnabled()) {\n\t\t\t\t\t\t\tsynchronized (monitoredFiles) {\n\t\t\t\t\t\t\t\tif (!monitoredFiles.containsObject(path)) {\n\t\t\t\t\t\t\t\t\tERXFileNotificationCenter.defaultCenter().addObserver(observer, new NSSelector(\"fileDidChange\", ERXConstant.NotificationClassArray), path.getFile());\n\t\t\t\t\t\t\t\t\tmonitoredFiles.addObject(path);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tlog.warn(\"Exception loading: \" + fileName + \" - \" + (framework == null ? \"app\" : framework) + \" - \" + languages + \":\" + ex, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug(\"Unable to create path for resource named: \" + fileName + \" framework: \" + (framework == null ? \"app\" : framework) + \" languages: \" + languages);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t_plurifyRules = plurifyRules();\n\t\t_singularifyRules = singularifyRules();\n\t}","id":92534,"modified_method":"/** <span class=\"ja\">ローカライザーのロード作業<\/span> */\n\tpublic void load() {\n\t\tcache.removeAllObjects();\n\t\tcreatedKeys.removeAllObjects();\n\n\t\tif (log.isDebugEnabled())\n\t\t  log.debug(\"Loading templates for language: \" + language + \" for files: \" + fileNamesToWatch().componentsJoinedByString(\" / \") + \" with search path: \" + frameworkSearchPath().componentsJoinedByString(\" / \"));\n\n\t\tNSArray<String> languages = new NSArray<String>(language);\n\t\tEnumeration<String> fn = fileNamesToWatch().objectEnumerator();\n\t\twhile (fn.hasMoreElements()) {\n\t\t\tString fileName = fn.nextElement();\n\t\t\tEnumeration<String> fr = frameworkSearchPath().reverseObjectEnumerator();\n\t\t\twhile (fr.hasMoreElements()) {\n\t\t\t\tString framework = fr.nextElement();\n\n\t\t\t\tURL path = ERXFileUtilities.pathURLForResourceNamed(fileName, framework, languages);\n\t\t\t\tif (path != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tframework = \"app\".equals(framework) ? null : framework;\n\t\t\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\t\t  log.debug(\"Loading: \" + fileName + \" - \" + (framework == null ? \"app\" : framework) + \" - \" + languages.componentsJoinedByString(\" / \") + \" \" + path);\n\t\t\t\t\t\t\n\t\t\t\t\t\tNSDictionary<String, Object> dict = (NSDictionary<String, Object>) ERXFileUtilities.readPropertyListFromFileInFramework(fileName, framework, languages);\n\t\t\t\t\t\t// HACK: ak we have could have a collision between the search path for validation strings and\n\t\t\t\t\t\t// the normal localized strings.\n\t\t\t\t\t\tif (fileName.indexOf(ERXValidationFactory.VALIDATION_TEMPLATE_PREFIX) == 0) {\n\t\t\t\t\t\t\tNSMutableDictionary<String, Object> newDict = new NSMutableDictionary<String, Object>();\n\t\t\t\t\t\t\tfor (Enumeration<String> keys = dict.keyEnumerator(); keys.hasMoreElements();) {\n\t\t\t\t\t\t\t\tString key = keys.nextElement();\n\t\t\t\t\t\t\t\tnewDict.setObjectForKey(dict.objectForKey(key), ERXValidationFactory.VALIDATION_TEMPLATE_PREFIX + key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdict = newDict;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddEntriesToCache(dict);\n\t\t\t\t\t\tif (!WOApplication.application().isCachingEnabled()) {\n\t\t\t\t\t\t\tsynchronized (monitoredFiles) {\n\t\t\t\t\t\t\t\tif (!monitoredFiles.containsObject(path)) {\n\t\t\t\t\t\t\t\t\tERXFileNotificationCenter.defaultCenter().addObserver(observer, new NSSelector(\"fileDidChange\", ERXConstant.NotificationClassArray), path.getFile());\n\t\t\t\t\t\t\t\t\tmonitoredFiles.addObject(path);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n            log.warn(\"Exception loading: \" + fileName + \" - \" + (framework == null ? \"app\" : framework) + \" - \" + languages.componentsJoinedByString(\" / \") + \":\" + ex, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t  if(log.isDebugEnabled())\n\t\t\t\t    log.debug(\"Unable to create path for resource named: \" + fileName + \" framework: \" + (framework == null ? \"app\" : framework) + \" languages: \" + languages.componentsJoinedByString(\" / \"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t_plurifyRules = plurifyRules();\n\t\t_singularifyRules = singularifyRules();\n\t}","commit_id":"5702aee652edc9756ef9d8cc5e47cd42d3502cca","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * <span class=\"ja\">\n   * ウォッチするファイル名配列を戻します\n   * \n   * @return NSAray - ファイル名配列\n   * <\/span>\n   */\n\tpublic static NSArray fileNamesToWatch() {\n\t\tif (fileNamesToWatch == null) {\n\t\t\tfileNamesToWatch = ERXProperties.arrayForKeyWithDefault(\"er.extensions.ERXLocalizer.fileNamesToWatch\", new NSArray(new Object[] { \"Localizable.strings\", \"ValidationTemplate.strings\" }));\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"FileNamesToWatch: \" + fileNamesToWatch);\n\t\t}\n\t\treturn fileNamesToWatch;\n\t}","id":92535,"modified_method":"/**\n   * <span class=\"ja\">\n   * ウォッチするファイル名配列を戻します\n   * \n   * @return NSAray - ファイル名配列\n   * <\/span>\n   */\n\tpublic static NSArray<String> fileNamesToWatch() {\n\t\tif (fileNamesToWatch == null) {\n\t\t\tfileNamesToWatch = ERXProperties.arrayForKeyWithDefault(\"er.extensions.ERXLocalizer.fileNamesToWatch\", new NSArray<String>(new String[] { \"Localizable.strings\", \"ValidationTemplate.strings\" }));\n\t\t\tif (log.isDebugEnabled())\n        log.debug(\"FileNamesToWatch: \" + fileNamesToWatch.componentsJoinedByString(\" / \"));\n\t\t}\n\t\treturn fileNamesToWatch;\n\t}","commit_id":"5702aee652edc9756ef9d8cc5e47cd42d3502cca","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * <span class=\"en\">\n\t * Gets the best localizer for a set of languages.\n\t * \n\t * @param languages\n\t * @return localizer\n\t * <\/span>\n\t * \n   * <span class=\"ja\">\n   * 言語配列に一番適用ローカライザーを戻します\n   * \n   * @param languages - 言語配列セット\n   * \n   * @return ローカライザー\n   * <\/span>\n\t */\n\tpublic static ERXLocalizer localizerForLanguages(NSArray<String> languages) {\n\t\tif (!isLocalizationEnabled)\n\t\t\treturn createLocalizerForLanguage(\"Nonlocalized\", false);\n\n\t\tif (languages == null || languages.isEmpty())\n\t\t\treturn localizerForLanguage(defaultLanguage());\n\t\tERXLocalizer l = null;\n\t\tEnumeration e = languages.objectEnumerator();\n\t\twhile (e.hasMoreElements()) {\n\t\t\tString language = (String) e.nextElement();\n\t\t\tl = localizers.objectForKey(language);\n\t\t\tif (l != null) {\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\tif (availableLanguages().containsObject(language)) {\n\t\t\t\treturn localizerForLanguage(language);\n\t\t\t}\n\t\t\t// try to do a fallback to the base language if this was regionalized\n\t\t\tint index = language.indexOf('_');\n\t\t\tif (index > 0) {\n\t\t\t\tlanguage = language.substring(0, index);\n\t\t\t\tif (availableLanguages().containsObject(language)) {\n\t\t\t\t\treturn localizerForLanguage(language);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn localizerForLanguage(languages.objectAtIndex(0));\n\t}","id":92536,"modified_method":"/**\n\t * <span class=\"en\">\n\t * Gets the best localizer for a set of languages.\n\t * \n\t * @param languages\n\t * @return localizer\n\t * <\/span>\n\t * \n   * <span class=\"ja\">\n   * 言語配列に一番適用ローカライザーを戻します\n   * \n   * @param languages - 言語配列セット\n   * \n   * @return ローカライザー\n   * <\/span>\n\t */\n\tpublic static ERXLocalizer localizerForLanguages(NSArray<String> languages) {\n\t\tif (!isLocalizationEnabled)\n\t\t\treturn createLocalizerForLanguage(\"Nonlocalized\", false);\n\n\t\tif (languages == null || languages.isEmpty())\n\t\t\treturn localizerForLanguage(defaultLanguage());\n\t\t\n\t\tERXLocalizer l = null;\n\t\tEnumeration<String> e = languages.objectEnumerator();\n\t\twhile (e.hasMoreElements()) {\n\t\t\tString language = e.nextElement();\n\t\t\tl = localizers.objectForKey(language);\n\t\t\tif (l != null) {\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\tif (availableLanguages().containsObject(language)) {\n\t\t\t\treturn localizerForLanguage(language);\n\t\t\t}\n\t\t\t// try to do a fallback to the base language if this was regionalized\n\t\t\tint index = language.indexOf('_');\n\t\t\tif (index > 0) {\n\t\t\t\tlanguage = language.substring(0, index);\n\t\t\t\tif (availableLanguages().containsObject(language)) {\n\t\t\t\t\treturn localizerForLanguage(language);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn localizerForLanguage(languages.objectAtIndex(0));\n\t}","commit_id":"5702aee652edc9756ef9d8cc5e47cd42d3502cca","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * <span class=\"ja\">\n   * 使用可能な言語を配列として戻します\n   * \n   * @return 使用可能な言語のNSArray\n   * <\/span>\n   */\n\tpublic static NSArray<String> availableLanguages() {\n\t\tif (availableLanguages == null) {\n\t\t\tavailableLanguages = ERXProperties.arrayForKeyWithDefault(\"er.extensions.ERXLocalizer.availableLanguages\", new NSArray(new String[] { \"English\", \"German\", \"Japanese\" }));\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"AvailableLanguages: \" + availableLanguages);\n\t\t}\n\t\treturn availableLanguages;\n\t}","id":92537,"modified_method":"/**\n   * <span class=\"ja\">\n   * 使用可能な言語を配列として戻します\n   * \n   * @return 使用可能な言語のNSArray\n   * <\/span>\n   */\n\tpublic static NSArray<String> availableLanguages() {\n\t\tif (availableLanguages == null) {\n\t\t\tavailableLanguages = ERXProperties.arrayForKeyWithDefault(\"er.extensions.ERXLocalizer.availableLanguages\", new NSArray(new String[] { \"English\", \"German\", \"Japanese\" }));\n\t\t\tif (log.isDebugEnabled())\n        log.debug(\"AvailableLanguages: \" + availableLanguages.componentsJoinedByString(\" / \"));\n\t\t}\n\t\treturn availableLanguages;\n\t}","commit_id":"5702aee652edc9756ef9d8cc5e47cd42d3502cca","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Apply the set of rules in the given Map to the input String and return\n\t * a modified string that matches the case of the input string.  For instance,\n\t * if the input string is \"Person\" and the rules are _plurifyRules, then this\n\t * would return \"People\".\n\t *   \n\t * @param str the input string\n\t * @param rules the rules to apply\n\t * @return a case-matched string converted according to the rules\n\t */\n\tprotected String applyRules(String str, Map<Pattern, String> rules) {\n\t\tString result = str;\n\t\tif (str != null) {\n\t\t\tboolean converted = false;\n\t\t\tIterator rulesIter = rules.entrySet().iterator();\n\t\t\twhile (!converted && rulesIter.hasNext()) {\n\t\t\t\tMap.Entry<Pattern, String> rule = (Map.Entry<Pattern, String>) rulesIter.next();\n\t\t\t\tPattern rulePattern = rule.getKey();\n\t\t\t\tMatcher ruleMatcher = rulePattern.matcher(str);\n\t\t\t\tif (ruleMatcher.matches()) {\n\t\t\t\t\tString ruleReplacement = rule.getValue(); \n\t\t\t\t\tresult = ruleMatcher.replaceFirst(ruleReplacement);\n\t\t\t\t\tconverted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (converted) {\n\t\t\t\tresult = ERXStringUtilities.matchCase(str, result);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":92538,"modified_method":"/**\n\t * Apply the set of rules in the given Map to the input String and return\n\t * a modified string that matches the case of the input string.  For instance,\n\t * if the input string is \"Person\" and the rules are _plurifyRules, then this\n\t * would return \"People\".\n\t *   \n\t * @param str the input string\n\t * @param rules the rules to apply\n\t * @return a case-matched string converted according to the rules\n\t */\n\tprotected String applyRules(String str, Map<Pattern, String> rules) {\n\t\tString result = str;\n\t\tif (str != null) {\n\t\t\tboolean converted = false;\n\t\t\tIterator<Map.Entry<Pattern, String>> rulesIter = rules.entrySet().iterator();\n\t\t\twhile (!converted && rulesIter.hasNext()) {\n\t\t\t\tMap.Entry<Pattern, String> rule = rulesIter.next();\n\t\t\t\tPattern rulePattern = rule.getKey();\n\t\t\t\tMatcher ruleMatcher = rulePattern.matcher(str);\n\t\t\t\tif (ruleMatcher.matches()) {\n\t\t\t\t\tString ruleReplacement = rule.getValue(); \n\t\t\t\t\tresult = ruleMatcher.replaceFirst(ruleReplacement);\n\t\t\t\t\tconverted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (converted) {\n\t\t\t\tresult = ERXStringUtilities.matchCase(str, result);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"5702aee652edc9756ef9d8cc5e47cd42d3502cca","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * <span class=\"en\">\n\t * Resets the localizer cache. If WOCaching is enabled then after being reinitialize all of the localizers will be\n\t * reloaded.\n\t * <\/span>\n\t * \n   * <span class=\"ja\">\n   * ローカライザー・キャシュをリセットする\n   * WOCaching が使用可能な場合、リセットする時にすべてのローカライザーをリロードします\n   * <\/span>\n\t */\n\tpublic static void resetCache() {\n\t\tinitialize();\n\t\tif (WOApplication.application().isCachingEnabled()) {\n\t\t\tEnumeration e = localizers.objectEnumerator();\n\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\t((ERXLocalizer) e.nextElement()).load();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlocalizers = new NSMutableDictionary<String, ERXLocalizer>();\n\t\t}\n\t}","id":92539,"modified_method":"/**\n\t * <span class=\"en\">\n\t * Resets the localizer cache. If WOCaching is enabled then after being reinitialize all of the localizers will be\n\t * reloaded.\n\t * <\/span>\n\t * \n   * <span class=\"ja\">\n   * ローカライザー・キャシュをリセットする\n   * WOCaching が使用可能な場合、リセットする時にすべてのローカライザーをリロードします\n   * <\/span>\n\t */\n\tpublic static void resetCache() {\n\t\tinitialize();\n\t\tif (WOApplication.application().isCachingEnabled()) {\n\t\t\tEnumeration<ERXLocalizer> e = localizers.objectEnumerator();\n\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\te.nextElement().load();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlocalizers = new NSMutableDictionary<String, ERXLocalizer>();\n\t\t}\n\t}","commit_id":"5702aee652edc9756ef9d8cc5e47cd42d3502cca","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static void main(String[] args) throws SocketException {\n        Enumeration en=NetworkInterface.getNetworkInterfaces();\n        while(en.hasMoreElements()) {\n            NetworkInterface i=(NetworkInterface)en.nextElement();\n            System.out.println(i.getName() + ':');\n            System.out.println(\"  \\t\" + i.getDisplayName());\n            for(Enumeration en2=i.getInetAddresses(); en2.hasMoreElements();) {\n                InetAddress addr=(InetAddress)en2.nextElement();\n                System.out.println(\"  \\t\" + addr + \" (\" + addr.getHostName() + ')');\n            }\n            System.out.println(\"---------------------\");\n        }\n    }","id":92540,"modified_method":"public static void main(String[] args) throws SocketException {\n        Enumeration<NetworkInterface> en=NetworkInterface.getNetworkInterfaces();\n        while(en.hasMoreElements()) {\n            NetworkInterface i=en.nextElement();\n            System.out.println(i.getName() + ':');\n            System.out.println(\"  \\t\" + i.getDisplayName());\n            for(Enumeration<InetAddress> en2=i.getInetAddresses(); en2.hasMoreElements();) {\n                InetAddress addr=en2.nextElement();\n                System.out.println(\"  \\t\" + addr + \" (\" + addr.getHostName() + ')');\n            }\n            System.out.println(\"---------------------\");\n        }\n    }","commit_id":"2b6546dbda012a2206040a6ec57075b84762d6f5","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void main(String[] args) throws SocketException {\n        Enumeration en=NetworkInterface.getNetworkInterfaces();\n        while(en.hasMoreElements()) {\n            NetworkInterface i=(NetworkInterface)en.nextElement();\n            System.out.println(i.getName() + ':');\n            System.out.println(\"  \\t\" + i.getDisplayName());\n            for(Enumeration en2=i.getInetAddresses(); en2.hasMoreElements();) {\n                InetAddress addr=(InetAddress)en2.nextElement();\n                System.out.println(\"  \\t\" + addr + \" (\" + addr.getHostName() + ')');\n            }\n            System.out.println(\"---------------------\");\n        }\n    }","id":92541,"modified_method":"public static void main(String[] args) throws SocketException {\n        Enumeration<NetworkInterface> en=NetworkInterface.getNetworkInterfaces();\n        while(en.hasMoreElements()) {\n            NetworkInterface i=en.nextElement();\n            System.out.println(i.getName() + ':');\n            System.out.println(\"  \\t\" + i.getDisplayName());\n            for(Enumeration<InetAddress> en2=i.getInetAddresses(); en2.hasMoreElements();) {\n                InetAddress addr=en2.nextElement();\n                System.out.println(\"  \\t\" + addr + \" (\" + addr.getHostName() + ')');\n            }\n            System.out.println(\"---------------------\");\n        }\n    }","commit_id":"f904d2f43ca33727770daeb4817fdb17b09c129f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Stops and closes all streams that have been initialized for local\n     * RTP managers.\n     */\n    public void stopStreaming()\n    {\n        RTPManager audioRtpManager = getAudioRtpManager();\n        if (audioRtpManager != null)\n        {\n            stopStreaming(audioRtpManager, \"audio\");\n        }\n        this.audioRtpManager = null;\n        RTPManager videoRtpManager = getVideoRtpManager();\n        if (videoRtpManager != null)\n        {\n            stopStreaming(videoRtpManager, \"video\");\n        }\n        this.videoRtpManager = null;\n    }","id":92542,"modified_method":"/**\n     * Stops and closes all streams that have been initialized for local\n     * RTP managers.\n     */\n    public boolean stopStreaming()\n    {\n        boolean stoppedStreaming = false;\n\n        RTPManager audioRtpManager = getAudioRtpManager();\n        if (audioRtpManager != null)\n        {\n            stoppedStreaming = stopStreaming(audioRtpManager);\n            this.audioRtpManager = null;\n        }\n        RTPManager videoRtpManager = getVideoRtpManager();\n        if (videoRtpManager != null)\n        {\n            stoppedStreaming =\n                stopStreaming(videoRtpManager) || stoppedStreaming;\n            this.videoRtpManager = null;\n        }\n\n        lastIntendedDestination = null;\n        return stoppedStreaming;\n    }","commit_id":"2067dddab6f37d193fb1ace4926f78022b7273ec","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Indicates that a change has occurred in the state of the source call.\n     * @param evt the <tt>CallChangeEvent<\/tt> instance containing the source\n     * calls and its old and new state.\n     */\n    public void callStateChanged(CallChangeEvent evt)\n    {\n        if( evt.getNewValue() == CallState.CALL_IN_PROGRESS\n            && evt.getNewValue() != evt.getOldValue())\n        {\n            try\n            {\n                logger.debug(\"call connected. starting streaming\");\n                startStreaming();\n                mediaServCallback.getMediaControl(getCall())\n                    .startProcessingMedia(this);\n            }\n            catch (MediaException ex)\n            {\n                /** @todo need to notify someone */\n                logger.error(\"Failed to start streaming.\", ex);\n            }\n        }\n        else if( evt.getNewValue() == CallState.CALL_ENDED\n                 && evt.getNewValue() != evt.getOldValue())\n        {\n            logger.warn(\"Stopping streaming.\");\n            stopStreaming();\n            mediaServCallback.getMediaControl(getCall())\n                .stopProcessingMedia(this);\n\n            //close all players that we have created in this session\n            Iterator playersIter = players.iterator();\n\n            while(playersIter.hasNext())\n            {\n                Player player = ( Player )playersIter.next();\n                player.stop();\n                player.deallocate();\n                player.close();\n                playersIter.remove();\n            }\n\n            //close all video frames that we have created in this session\n            Iterator videoFramesIter = videoFrames.iterator();\n            while(videoFramesIter.hasNext())\n            {\n                javax.swing.JFrame frame\n                    = ( javax.swing.JFrame )videoFramesIter.next();\n                frame.setVisible(false);\n                frame.dispose();\n                videoFramesIter.remove();\n            }\n\n            //remove ourselves as listeners from the call\n            evt.getSourceCall().removeCallChangeListener(this);\n\n            RTPManager audioRtpMan = getAudioRtpManager();\n\n            if(audioRtpMan != null)\n                audioRtpMan.dispose();\n\n            RTPManager videoRtpMan = getVideoRtpManager();\n            if(videoRtpMan != null)\n                videoRtpMan.dispose();\n        }\n    }","id":92543,"modified_method":"/**\n     * Indicates that a change has occurred in the state of the source call.\n     * @param evt the <tt>CallChangeEvent<\/tt> instance containing the source\n     * calls and its old and new state.\n     */\n    public void callStateChanged(CallChangeEvent evt)\n    {\n        if( evt.getNewValue() == CallState.CALL_IN_PROGRESS\n            && evt.getNewValue() != evt.getOldValue())\n        {\n            try\n            {\n                logger.debug(\"call connected. starting streaming\");\n                startStreaming();\n                mediaServCallback.getMediaControl(getCall())\n                    .startProcessingMedia(this);\n            }\n            catch (MediaException ex)\n            {\n                /** @todo need to notify someone */\n                logger.error(\"Failed to start streaming.\", ex);\n            }\n        }\n        else if( evt.getNewValue() == CallState.CALL_ENDED\n                 && evt.getNewValue() != evt.getOldValue())\n        {\n            logger.warn(\"Stopping streaming.\");\n            stopStreaming();\n            mediaServCallback.getMediaControl(getCall())\n                .stopProcessingMedia(this);\n\n            //close all players that we have created in this session\n            Iterator<Player> playersIter = players.iterator();\n\n            while(playersIter.hasNext())\n            {\n                Player player = playersIter.next();\n                player.stop();\n                player.deallocate();\n                player.close();\n                playersIter.remove();\n            }\n\n            // close all video frames that we have created in this session\n            Iterator<javax.swing.JFrame> videoFramesIter =\n                videoFrames.iterator();\n            while(videoFramesIter.hasNext())\n            {\n                javax.swing.JFrame frame = videoFramesIter.next();\n                frame.setVisible(false);\n                frame.dispose();\n                videoFramesIter.remove();\n            }\n\n            //remove ourselves as listeners from the call\n            evt.getSourceCall().removeCallChangeListener(this);\n\n            RTPManager audioRtpMan = getAudioRtpManager();\n\n            if(audioRtpMan != null)\n                audioRtpMan.dispose();\n\n            RTPManager videoRtpMan = getVideoRtpManager();\n            if(videoRtpMan != null)\n                videoRtpMan.dispose();\n        }\n    }","commit_id":"2067dddab6f37d193fb1ace4926f78022b7273ec","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the supported key management types and establishes\n     * default usage priorities for them.\n     * This part should be further developed (by adding a more detailed\n     * priority setting mechanism in case of addition of other security\n     * providers).\n     */\n    public void initializeSupportedKeyProviders()\n    {\n        if (keySharingAlgorithms == null)\n            keySharingAlgorithms = new Vector();\n\n        DummyKeyProvider dummyProvider = new DummyKeyProvider(1);\n        ZRTPKeyProvider zrtpKeyProvider = new ZRTPKeyProvider(0);\n\n        keySharingAlgorithms.add(zrtpKeyProvider.getPriority(), zrtpKeyProvider);\n        keySharingAlgorithms.add(dummyProvider.getPriority(), dummyProvider);\n    }","id":92544,"modified_method":"/**\n     * Initializes the supported key management types and establishes\n     * default usage priorities for them.\n     * This part should be further developed (by adding a more detailed\n     * priority setting mechanism in case of addition of other security\n     * providers).\n     */\n    public void initializeSupportedKeyProviders()\n    {\n        if (keySharingAlgorithms == null)\n            keySharingAlgorithms = new Vector<KeyProviderAlgorithm>();\n\n        DummyKeyProvider dummyProvider = new DummyKeyProvider(1);\n        ZRTPKeyProvider zrtpKeyProvider = new ZRTPKeyProvider(0);\n\n        keySharingAlgorithms.add(zrtpKeyProvider.getPriority(), zrtpKeyProvider);\n        keySharingAlgorithms.add(dummyProvider.getPriority(), dummyProvider);\n    }","commit_id":"2067dddab6f37d193fb1ace4926f78022b7273ec","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * This method is called when an event is generated by a\n     * <code>Controller<\/code> that this listener is registered with.\n     * @param ce The event generated.\n     */\n    public synchronized void controllerUpdate(ControllerEvent ce)\n    {\n        logger.debug(\"Received a ControllerEvent: \" + ce);\n        Player player = (Player) ce.getSourceController();\n\n        if (player == null)\n        {\n            return;\n        }\n\n        //if configuration is completed and this is a processor\n        //we need to set file format and explicitly call realize().\n        if (ce instanceof ConfigureCompleteEvent)\n        {\n            try\n            {\n                ((Processor)player).setContentDescriptor(\n                        new FileTypeDescriptor(FileTypeDescriptor.WAVE));\n                player.realize();\n            }\n            catch (Exception exc)\n            {\n                logger.error(\"failed to record to file\", exc);\n            }\n        }\n\n        // Get this when the internal players are realized.\n        if (ce instanceof RealizeCompleteEvent)\n        {\n\n            //set the volume as it is not on max by default.\n            //XXX: I am commenting this since apparently it is causing some\n            //problems on windows.\n            //GainControl gc\n            //    = (GainControl)player.getControl(GainControl.class.getName());\n            //if (gc != null)\n            //{\n            //    logger.debug(\"Setting volume to max\");\n            //    gc.setLevel(1);\n            //}\n            //else\n            //    logger.debug(\"Player does not have gain control.\");\n\n\n            logger.debug(\"A player was realized and will be started.\");\n            player.start();\n\n            if (dataSink != null)\n            {\n                try\n                {\n                    logger.info(\"starting recording to file: \"+dataSink);\n                    MediaLocator dest = new MediaLocator(dataSink);\n                    DataSource ds = ((Processor)player).getDataOutput();\n                    DataSink sink = Manager.createDataSink(\n                        ((Processor)player).getDataOutput(), dest);\n                    player.start();\n                    //do we know the output file's duration\n                    RecordInitiator record = new RecordInitiator(sink);\n                    record.start();\n                }\n                catch(Exception e)\n                {\n                    logger.error(\"failed while trying to record to file\",e);\n                }\n            }\n            else\n            {\n                player.start();\n            }\n\n\n            /** @todo video frame is currently handled with very ugly test code\n             * please don't forget to remove */\n            //------------ ugly video test code starts here --------------------\n            java.awt.Component vc = player.getVisualComponent();\n            if(vc != null)\n            {\n                javax.swing.JFrame frame = new javax.swing.JFrame();\n                frame.setTitle(\"SIP Communicator - Video Call\");\n                frame.getContentPane().add(vc);\n                frame.pack();\n                //center\n                java.awt.Dimension frameSize = frame.getSize();\n\n                //ugly resize if too tiny\n                if(frameSize.width < 300)\n                {\n                    frame.setSize(frameSize.width * 2, frameSize.height * 2);\n                    frameSize = frame.getSize();\n                }\n                java.awt.Dimension screenSize\n                    = java.awt.Toolkit.getDefaultToolkit().getScreenSize();\n\n                frame.setLocation((screenSize.width - frameSize.width)/2\n                    ,(screenSize.height - frameSize.height)/2);\n\n                frame.setVisible(true);\n                videoFrames.add(frame);\n            }\n            //------------- ugly video test code ends here ---------------------\n        }\n        if (ce instanceof StartEvent) {\n            logger.debug(\"Received a StartEvent\");\n        }\n        if (ce instanceof ControllerErrorEvent) {\n            logger.error(\n                \"The following error was reported while starting a player\"\n                + ce);\n        }\n        if (ce instanceof ControllerClosedEvent) {\n            logger.debug(\"Received a ControllerClosedEvent\");\n        }\n    }","id":92545,"modified_method":"/**\n     * This method is called when an event is generated by a\n     * <code>Controller<\/code> that this listener is registered with.\n     * @param ce The event generated.\n     */\n    public synchronized void controllerUpdate(ControllerEvent ce)\n    {\n        logger.debug(\"Received a ControllerEvent: \" + ce);\n        Player player = (Player) ce.getSourceController();\n\n        if (player == null)\n        {\n            return;\n        }\n\n        //if configuration is completed and this is a processor\n        //we need to set file format and explicitly call realize().\n        if (ce instanceof ConfigureCompleteEvent)\n        {\n            try\n            {\n                ((Processor)player).setContentDescriptor(\n                        new FileTypeDescriptor(FileTypeDescriptor.WAVE));\n                player.realize();\n            }\n            catch (Exception exc)\n            {\n                logger.error(\"failed to record to file\", exc);\n            }\n        }\n\n        // Get this when the internal players are realized.\n        if (ce instanceof RealizeCompleteEvent)\n        {\n\n            //set the volume as it is not on max by default.\n            //XXX: I am commenting this since apparently it is causing some\n            //problems on windows.\n            //GainControl gc\n            //    = (GainControl)player.getControl(GainControl.class.getName());\n            //if (gc != null)\n            //{\n            //    logger.debug(\"Setting volume to max\");\n            //    gc.setLevel(1);\n            //}\n            //else\n            //    logger.debug(\"Player does not have gain control.\");\n\n\n            logger.debug(\"A player was realized and will be started.\");\n            player.start();\n\n            if (dataSink != null)\n            {\n                try\n                {\n                    logger.info(\"starting recording to file: \"+dataSink);\n                    MediaLocator dest = new MediaLocator(dataSink);\n                    DataSink sink = Manager.createDataSink(\n                        ((Processor)player).getDataOutput(), dest);\n                    player.start();\n                    //do we know the output file's duration\n                    RecordInitiator record = new RecordInitiator(sink);\n                    record.start();\n                }\n                catch(Exception e)\n                {\n                    logger.error(\"failed while trying to record to file\",e);\n                }\n            }\n            else\n            {\n                player.start();\n            }\n\n\n            /** @todo video frame is currently handled with very ugly test code\n             * please don't forget to remove */\n            //------------ ugly video test code starts here --------------------\n            java.awt.Component vc = player.getVisualComponent();\n            if(vc != null)\n            {\n                javax.swing.JFrame frame = new javax.swing.JFrame();\n                frame.setTitle(\"SIP Communicator - Video Call\");\n                frame.getContentPane().add(vc);\n                frame.pack();\n                //center\n                java.awt.Dimension frameSize = frame.getSize();\n\n                //ugly resize if too tiny\n                if(frameSize.width < 300)\n                {\n                    frame.setSize(frameSize.width * 2, frameSize.height * 2);\n                    frameSize = frame.getSize();\n                }\n                java.awt.Dimension screenSize\n                    = java.awt.Toolkit.getDefaultToolkit().getScreenSize();\n\n                frame.setLocation((screenSize.width - frameSize.width)/2\n                    ,(screenSize.height - frameSize.height)/2);\n\n                frame.setVisible(true);\n                videoFrames.add(frame);\n            }\n            //------------- ugly video test code ends here ---------------------\n        }\n        if (ce instanceof StartEvent) {\n            logger.debug(\"Received a StartEvent\");\n        }\n        if (ce instanceof ControllerErrorEvent) {\n            logger.error(\n                \"The following error was reported while starting a player\"\n                + ce);\n        }\n        if (ce instanceof ControllerClosedEvent) {\n            logger.debug(\"Received a ControllerClosedEvent\");\n        }\n    }","commit_id":"2067dddab6f37d193fb1ace4926f78022b7273ec","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Selects a key management type to use in securing based on priority\n     * For now the priorities are equal with the position in the Vector\n     * holding the keymanagement types.\n     * This part should be further developed (by adding a more detailed\n     * priority choosing mechanism in case of addition of other security\n     * providers).\n     *\n     * @param priority the priority of the selected key management type - 0 is top\n     * @return the selected key management type\n     */\n    public KeyProviderAlgorithm selectKeyProviderAlgorithm(int priority)\n    {\n        KeyProviderAlgorithm selectedProvider =\n            (KeyProviderAlgorithm)keySharingAlgorithms.get(priority);\n\n        return selectedProvider;\n    }","id":92546,"modified_method":"/**\n     * Selects a key management type to use in securing based on priority\n     * For now the priorities are equal with the position in the Vector\n     * holding the keymanagement types.\n     * This part should be further developed (by adding a more detailed\n     * priority choosing mechanism in case of addition of other security\n     * providers).\n     *\n     * @param priority the priority of the selected key management type - 0 is top\n     * @return the selected key management type\n     */\n    public KeyProviderAlgorithm selectKeyProviderAlgorithm(int priority)\n    {\n        return keySharingAlgorithms.get(priority);\n    }","commit_id":"2067dddab6f37d193fb1ace4926f78022b7273ec","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stops and closes all streams currently handled by <tt>rtpManager<\/tt>.\n     *\n     * @param rtpManager the rtpManager whose streams we'll be stopping.\n     */\n    private void stopStreaming(RTPManager rtpManager,\n                               String rtpManagerDescription)\n    {\n        Vector sendStreams = rtpManager.getSendStreams();\n        Iterator ssIter = sendStreams.iterator();\n\n        while(ssIter.hasNext())\n        {\n            SendStream stream = (SendStream) ssIter.next();\n            try\n            {\n                stream.getDataSource().stop();\n                stream.stop();\n                stream.close();\n            }\n            catch (IOException ex)\n            {\n                logger.warn(\"Failed to stop stream.\", ex);\n            }\n        }\n\n        Vector receiveStreams = rtpManager.getReceiveStreams();\n        Iterator rsIter = receiveStreams.iterator();\n        while(rsIter.hasNext())\n        {\n            ReceiveStream stream = (ReceiveStream) rsIter.next();\n            try\n            {\n                stream.getDataSource().stop();\n            }\n            catch (IOException ex)\n            {\n                logger.warn(\"Failed to stop stream.\", ex);\n            }\n        }\n\n        //remove targets\n        if (selectedKeyProviderAlgorithm != null\n            /* TODO: Video securing related code\n             * remove the next condition as part of enabling video securing\n             * (see comments in secureStatusChanged method for more info)\n             */\n            && rtpManager.equals(audioRtpManager))\n        {\n            TransformConnector transConnector\n                = (TransformConnector) this.transConnectors.get(rtpManager);\n\n            if (transConnector != null)\n            {\n                ZRTPTransformEngine engine = (ZRTPTransformEngine)transConnector.getEngine();\n\n                engine.sendInfo(ZrtpCodes.MessageSeverity.Info,\n                                EnumSet.of(ZRTPCustomInfoCodes.ZRTPDisabledByCallEnd));\n\n                transConnector.removeTargets();\n            }\n        }\n        else\n        {\n            rtpManager.removeTargets(\"Session ended.\");\n        }\n\n        printFlowStatistics(rtpManager);\n\n        //stop listening\n        rtpManager.removeReceiveStreamListener(this);\n        rtpManager.removeSendStreamListener(this);\n        rtpManager.removeSessionListener(this);\n        rtpManager.dispose();\n    }","id":92547,"modified_method":"/**\n     * Stops and closes all streams currently handled by <tt>rtpManager<\/tt>.\n     * \n     * @param rtpManager the rtpManager whose streams we'll be stopping.\n     * @return <tt>true<\/tt> if there was an actual change in the streaming i.e.\n     *         the streaming wasn't already stopped before this request;\n     *         <tt>false<\/tt>, otherwise\n     */\n    private boolean stopStreaming(RTPManager rtpManager)\n    {\n        boolean stoppedAtLeastOneStream = false;\n        Vector sendStreams = rtpManager.getSendStreams();\n        Iterator ssIter = sendStreams.iterator();\n\n        while(ssIter.hasNext())\n        {\n            SendStream stream = (SendStream) ssIter.next();\n            try\n            {\n                stream.getDataSource().stop();\n                stream.stop();\n                stream.close();\n            }\n            catch (IOException ex)\n            {\n                logger.warn(\"Failed to stop stream.\", ex);\n            }\n            stoppedAtLeastOneStream = true;\n        }\n\n        Vector receiveStreams = rtpManager.getReceiveStreams();\n        Iterator rsIter = receiveStreams.iterator();\n        while(rsIter.hasNext())\n        {\n            ReceiveStream stream = (ReceiveStream) rsIter.next();\n            try\n            {\n                stream.getDataSource().stop();\n            }\n            catch (IOException ex)\n            {\n                logger.warn(\"Failed to stop stream.\", ex);\n            }\n            stoppedAtLeastOneStream = true;\n        }\n\n        //remove targets\n        if (selectedKeyProviderAlgorithm != null\n            /* TODO: Video securing related code\n             * remove the next condition as part of enabling video securing\n             * (see comments in secureStatusChanged method for more info)\n             */\n            && rtpManager.equals(audioRtpManager))\n        {\n            TransformConnector transConnector =\n                this.transConnectors.get(rtpManager);\n\n            if (transConnector != null)\n            {\n                ZRTPTransformEngine engine = (ZRTPTransformEngine)transConnector.getEngine();\n\n                engine.sendInfo(ZrtpCodes.MessageSeverity.Info,\n                                EnumSet.of(ZRTPCustomInfoCodes.ZRTPDisabledByCallEnd));\n\n                transConnector.removeTargets();\n            }\n        }\n        else\n        {\n            rtpManager.removeTargets(\"Session ended.\");\n        }\n\n        printFlowStatistics(rtpManager);\n\n        //stop listening\n        rtpManager.removeReceiveStreamListener(this);\n        rtpManager.removeSendStreamListener(this);\n        rtpManager.removeSessionListener(this);\n        rtpManager.dispose();\n\n        return stoppedAtLeastOneStream;\n    }","commit_id":"2067dddab6f37d193fb1ace4926f78022b7273ec","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * The method for changing security status for a specific RTPManager when\n     * the ZRTP key sharing solution is used.\n     * Called when a new SecureEvent is received.\n     *\n     * @param manager The RTP manager for which the media streams\n     * will be secure or unsecure\n     * @param event The secure status changed event\n     */\n    public void ZRTPChangeStatus(RTPManager manager, SecureEvent event)\n    {\n        int newStatus = event.getEventID();\n        OperationSetSecureTelephony.SecureStatusChangeSource source = event.getSource();\n\n        TransformConnector transConnector =\n            (TransformConnector) this.transConnectors.get(manager);\n\n        ZRTPTransformEngine engine = (ZRTPTransformEngine)transConnector.getEngine();\n\n        // Perform ZRTP engine actions only if triggered by local peer - user commands;\n        // If the remote peer caused the event only general call session security status\n        // is changed (done before event processing)\n        if (source == OperationSetSecureTelephony.\n                        SecureStatusChangeSource.SECURE_STATUS_CHANGE_BY_LOCAL)\n        {\n            if (newStatus == SecureEvent.SECURE_COMMUNICATION)\n            {\n                // Secure the comm after the call begins\n                if (!engine.isStarted())\n                {\n                    logger.trace(\"Normal call securing event processing\");\n\n                    if (!engine.initialize(\"GNUZRTP4J.zid\"))\n                        engine.sendInfo(ZrtpCodes.MessageSeverity.Info,\n                                        EnumSet.of(ZRTPCustomInfoCodes.ZRTPEngineInitFailure));\n                }\n                else\n                {\n                    logger.trace(\"GoSecure call event processing\");\n\n                    // This point isn't reached if GoClear is not enabled\n                    SCCallback cb = (SCCallback)engine.getUserCallback();\n                    cb.setGCGSByPeerFlag(false);\n                    engine.requestGoSecure();\n                }\n            }\n            else\n            {\n                // At this moment this attempts a GoClear request but\n                // fails due to GoClear code disabled (failing doesn't result\n                // in error, only in a warning tooltip set on the button, and\n                // a change of it's internal state to prevent further attempts)\n                // to re-enable GoClear uncomment the specific code parts in ZRTP4J\n                logger.trace(\"GoClear call event processing\");\n\n                SCCallback cb = (SCCallback)engine.getUserCallback();\n                cb.setGCGSByPeerFlag(false);\n                engine.requestGoClear();\n            }\n        }\n    }","id":92548,"modified_method":"/**\n     * The method for changing security status for a specific RTPManager when\n     * the ZRTP key sharing solution is used.\n     * Called when a new SecureEvent is received.\n     *\n     * @param manager The RTP manager for which the media streams\n     * will be secure or unsecure\n     * @param event The secure status changed event\n     */\n    public void ZRTPChangeStatus(RTPManager manager, SecureEvent event)\n    {\n        int newStatus = event.getEventID();\n        OperationSetSecureTelephony.SecureStatusChangeSource source = event.getSource();\n\n        TransformConnector transConnector = this.transConnectors.get(manager);\n\n        ZRTPTransformEngine engine = (ZRTPTransformEngine)transConnector.getEngine();\n\n        // Perform ZRTP engine actions only if triggered by local peer - user commands;\n        // If the remote peer caused the event only general call session security status\n        // is changed (done before event processing)\n        if (source == OperationSetSecureTelephony.\n                        SecureStatusChangeSource.SECURE_STATUS_CHANGE_BY_LOCAL)\n        {\n            if (newStatus == SecureEvent.SECURE_COMMUNICATION)\n            {\n                // Secure the comm after the call begins\n                if (!engine.isStarted())\n                {\n                    logger.trace(\"Normal call securing event processing\");\n\n                    if (!engine.initialize(\"GNUZRTP4J.zid\"))\n                        engine.sendInfo(ZrtpCodes.MessageSeverity.Info,\n                                        EnumSet.of(ZRTPCustomInfoCodes.ZRTPEngineInitFailure));\n                }\n                else\n                {\n                    logger.trace(\"GoSecure call event processing\");\n\n                    // This point isn't reached if GoClear is not enabled\n                    SCCallback cb = (SCCallback)engine.getUserCallback();\n                    cb.setGCGSByPeerFlag(false);\n                    engine.requestGoSecure();\n                }\n            }\n            else\n            {\n                // At this moment this attempts a GoClear request but\n                // fails due to GoClear code disabled (failing doesn't result\n                // in error, only in a warning tooltip set on the button, and\n                // a change of it's internal state to prevent further attempts)\n                // to re-enable GoClear uncomment the specific code parts in ZRTP4J\n                logger.trace(\"GoClear call event processing\");\n\n                SCCallback cb = (SCCallback)engine.getUserCallback();\n                cb.setGCGSByPeerFlag(false);\n                engine.requestGoClear();\n            }\n        }\n    }","commit_id":"2067dddab6f37d193fb1ace4926f78022b7273ec","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Puts the media of this <tt>CallSession<\/tt> on/off hold depending on\n     * the origin of the request.\n     * <p>\n     * For example, a remote request to have this party put off hold cannot\n     * override an earlier local request to put the remote party on hold.\n     * <\/p>\n     *\n     * @param on <tt>true<\/tt> to request the media of this\n     *            <tt>CallSession<\/tt> be put on hold; <tt>false<\/tt>,\n     *            otherwise\n     * @param here <tt>true<\/tt> if the request comes from this side of the\n     *            call; <tt>false<\/tt> if the remote party is the issuer of\n     *            the request i.e. it's the result of a remote offer\n     */\n    public void putOnHold(boolean on, boolean here)\n    {\n        if (on)\n        {\n            onHold |= (here ? ON_HOLD_LOCALLY : ON_HOLD_REMOTELY);\n        }\n        else\n        {\n            onHold &= ~ (here ? ON_HOLD_LOCALLY : ON_HOLD_REMOTELY);\n        }\n\n        /* Put the send on/off hold. */\n        boolean sendOnHold =\n            (0 != (onHold & (ON_HOLD_LOCALLY | ON_HOLD_REMOTELY)));\n        putOnHold(getAudioRtpManager(), sendOnHold);\n        putOnHold(getVideoRtpManager(), sendOnHold);\n\n        /* Put the receive on/off hold. */\n        boolean receiveOnHold = (0 != (onHold & ON_HOLD_LOCALLY));\n        for (Iterator playerIter = players.iterator(); playerIter.hasNext();)\n        {\n            Player player = (Player) playerIter.next();\n\n            if (receiveOnHold)\n                player.stop();\n            else\n                player.start();\n        }\n    }","id":92549,"modified_method":"/**\n     * Puts the media of this <tt>CallSession<\/tt> on/off hold depending on\n     * the origin of the request.\n     * <p>\n     * For example, a remote request to have this party put off hold cannot\n     * override an earlier local request to put the remote party on hold.\n     * <\/p>\n     *\n     * @param on <tt>true<\/tt> to request the media of this\n     *            <tt>CallSession<\/tt> be put on hold; <tt>false<\/tt>,\n     *            otherwise\n     * @param here <tt>true<\/tt> if the request comes from this side of the\n     *            call; <tt>false<\/tt> if the remote party is the issuer of\n     *            the request i.e. it's the result of a remote offer\n     */\n    public void putOnHold(boolean on, boolean here)\n    {\n        if (on)\n        {\n            onHold |= (here ? ON_HOLD_LOCALLY : ON_HOLD_REMOTELY);\n        }\n        else\n        {\n            onHold &= ~ (here ? ON_HOLD_LOCALLY : ON_HOLD_REMOTELY);\n        }\n        \n        applyOnHold();\n    }","commit_id":"2067dddab6f37d193fb1ace4926f78022b7273ec","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an SDP description of this session using the offer descirption\n     * (if not null) for limiting. The intendedDestination parameter, which may\n     * contain the address that the offer is to be sent to, will only be used if\n     * the <tt>offer<\/tt> or its connection parameter are <tt>null<\/tt>. In the\n     * oposite case we are using the address provided in the connection param as\n     * an intended destination.\n     *\n     * @param offer the call participant meant to receive the offer or null if\n     * we are to construct our own offer.\n     * @param intendedDestination the address of the call participant that the\n     * descriptions is to be sent to.\n     * @return a SessionDescription of this CallSession.\n     *\n     * @throws MediaException code INTERNAL_ERROR if we get an SDP exception\n     * while creating and/or parsing the sdp description.\n     */\n    private SessionDescription createSessionDescription(\n                                            SessionDescription offer,\n                                            InetAddress intendedDestination)\n        throws MediaException\n    {\n        try\n        {\n            SessionDescription sessDescr\n                = mediaServCallback.getSdpFactory().createSessionDescription();\n\n            //\"v=0\"\n            Version v = mediaServCallback.getSdpFactory().createVersion(0);\n\n            sessDescr.setVersion(v);\n\n            //we don't yet implement ice so just try to choose a local address\n            //that corresponds to the address provided by the offer or as an\n            //intended destination.\n            NetworkAddressManagerService netAddressManager\n                = MediaActivator.getNetworkAddressManagerService();\n\n            if(offer != null)\n            {\n                Connection c = offer.getConnection();\n                if(c != null)\n                {\n                    try\n                    {\n                        intendedDestination = InetAddress.getByName(c.\n                            getAddress());\n                    }\n                    catch (SdpParseException ex)\n                    {\n                        logger.warn(\"error reading remote sdp. \"\n                                    + c.toString()\n                                    + \" is not a valid connection parameter.\",\n                                    ex);\n                    }\n                    catch (UnknownHostException ex)\n                    {\n                        logger.warn(\"error reading remote sdp. \"\n                                    + c.toString()\n                                    + \" does not contain a valid address.\",\n                                    ex);\n                    }\n                }\n\n                //in case the offer contains a media level connection param, it\n                //needs to override the connection one.\n                Iterator<MediaDescription> mediaDescriptions\n                    = (Iterator<MediaDescription>)offer\n                        .getMediaDescriptions(true).iterator();\n\n                while(mediaDescriptions.hasNext())\n                {\n                    Connection conn = mediaDescriptions.next().getConnection();\n\n                    if(conn == null)\n                        continue;\n\n                    try\n                    {\n                        intendedDestination\n                            = NetworkUtils.getInetAddress(conn.getAddress());\n\n                        break;\n                    }\n                    catch (UnknownHostException e)\n                    {\n                        logger.debug(\"Couldn't determine indtended \"\n                                        +\"destination from address\"\n                                        + conn.getAddress(), e);\n                    }\n\n                }\n            }\n\n            /*\n             * Only allocate ports if this is a call establishing event.\n             * The opposite could happen for example, when issuing a\n             * Request.INVITE that would put a CallParticipant on hold.\n             */\n            if ((audioSessionAddress == null) || (videoSessionAddress == null))\n            {\n                allocateMediaPorts(intendedDestination);\n            }\n\n            InetAddress publicIpAddress = audioPublicAddress.getAddress();\n\n            String addrType\n                = publicIpAddress instanceof Inet6Address\n                ? Connection.IP6\n                : Connection.IP4;\n\n            //spaces in the user name mess everything up.\n            //bug report - Alessandro Melzi\n            Origin o = mediaServCallback.getSdpFactory().createOrigin(\n                call.getProtocolProvider().getAccountID().getUserID()\n                , 0\n                , 0\n                , \"IN\"\n                , addrType\n                , publicIpAddress.getHostAddress());\n\n            sessDescr.setOrigin(o);\n            //c=\n            Connection c = mediaServCallback.getSdpFactory().createConnection(\n                \"IN\"\n                , addrType\n                , publicIpAddress.getHostAddress());\n\n            sessDescr.setConnection(c);\n\n            //\"s=-\"\n            SessionName s\n                = mediaServCallback.getSdpFactory().createSessionName(\"-\");\n            sessDescr.setSessionName(s);\n\n            //\"t=0 0\"\n            TimeDescription t\n                = mediaServCallback.getSdpFactory().createTimeDescription();\n            Vector<TimeDescription> timeDescs = new Vector<TimeDescription>();\n            timeDescs.add(t);\n\n            sessDescr.setTimeDescriptions(timeDescs);\n\n            //media descriptions.\n            Vector offeredMediaDescriptions  = null;\n            if(offer != null)\n                offeredMediaDescriptions = offer.getMediaDescriptions(false);\n\n            logger.debug(\"Will create media descs with: audio public address=\"\n                         + audioPublicAddress\n                         + \" and video public address=\"\n                         + videoPublicAddress);\n\n            Vector mediaDescs\n                = createMediaDescriptions(offeredMediaDescriptions\n                                        , audioPublicAddress\n                                        , videoPublicAddress);\n\n            sessDescr.setMediaDescriptions(mediaDescs);\n\n            if (logger.isTraceEnabled())\n            {\n                logger.trace(\"Generated SDP - \" + sessDescr.toString());\n            }\n\n            return sessDescr;\n        }\n        catch (SdpException exc)\n        {\n            throw new MediaException(\n                \"An SDP exception occurred while generating local \"\n                + \"sdp description\"\n                , MediaException.INTERNAL_ERROR\n                , exc);\n        }\n\n    }","id":92550,"modified_method":"/**\n     * Creates an SDP description of this session using the offer descirption\n     * (if not null) for limiting. The intendedDestination parameter, which may\n     * contain the address that the offer is to be sent to, will only be used if\n     * the <tt>offer<\/tt> or its connection parameter are <tt>null<\/tt>. In the\n     * oposite case we are using the address provided in the connection param as\n     * an intended destination.\n     *\n     * @param offer the call participant meant to receive the offer or null if\n     * we are to construct our own offer.\n     * @param intendedDestination the address of the call participant that the\n     * descriptions is to be sent to.\n     * @return a SessionDescription of this CallSession.\n     *\n     * @throws MediaException code INTERNAL_ERROR if we get an SDP exception\n     * while creating and/or parsing the sdp description.\n     */\n    private SessionDescription createSessionDescription(\n                                            SessionDescription offer,\n                                            InetAddress intendedDestination)\n        throws MediaException\n    {\n        SdpFactory sdpFactory = mediaServCallback.getSdpFactory();\n\n        try\n        {\n            SessionDescription sessDescr =\n                sdpFactory.createSessionDescription();\n\n            //\"v=0\"\n            Version v = sdpFactory.createVersion(0);\n\n            sessDescr.setVersion(v);\n\n            //we don't yet implement ice so just try to choose a local address\n            //that corresponds to the address provided by the offer or as an\n            //intended destination.\n            NetworkAddressManagerService netAddressManager\n                = MediaActivator.getNetworkAddressManagerService();\n\n            if(offer != null)\n            {\n                Connection c = offer.getConnection();\n                if(c != null)\n                {\n                    try\n                    {\n                        intendedDestination = InetAddress.getByName(c.\n                            getAddress());\n                    }\n                    catch (SdpParseException ex)\n                    {\n                        logger.warn(\"error reading remote sdp. \"\n                                    + c.toString()\n                                    + \" is not a valid connection parameter.\",\n                                    ex);\n                    }\n                    catch (UnknownHostException ex)\n                    {\n                        logger.warn(\"error reading remote sdp. \"\n                                    + c.toString()\n                                    + \" does not contain a valid address.\",\n                                    ex);\n                    }\n                }\n\n                //in case the offer contains a media level connection param, it\n                // needs to override the connection one.\n                Iterator<MediaDescription> mediaDescriptions =\n                    offer.getMediaDescriptions(true).iterator();\n\n                while(mediaDescriptions.hasNext())\n                {\n                    Connection conn = mediaDescriptions.next().getConnection();\n\n                    if (conn != null)\n                    {\n                        try\n                        {\n                            intendedDestination =\n                                NetworkUtils.getInetAddress(conn.getAddress());\n                            break;\n                        }\n                        catch (UnknownHostException e)\n                        {\n                            logger.debug(\"Couldn't determine indtended \"\n                                + \"destination from address\"\n                                + conn.getAddress(), e);\n                        }\n                    }\n                }\n            }\n\n            /*\n             * Only allocate ports if this is a call establishing event. The\n             * opposite could happen for example, when issuing a Request.INVITE\n             * that would put a CallParticipant on hold.\n             */\n            boolean allocateMediaPorts = false;\n\n            /*\n             * TODO Should the reinitializing for the purposes of re-INVITE\n             * start the streaming before ACK?\n             */\n            boolean startStreaming = false;\n            if ((audioSessionAddress == null) || (videoSessionAddress == null))\n            {\n                allocateMediaPorts = true;\n            }\n            else\n            {\n                if (((lastIntendedDestination == null) && (intendedDestination != null))\n                    || ((lastIntendedDestination != null) && !lastIntendedDestination\n                        .equals(intendedDestination)))\n                {\n                    startStreaming = stopStreaming();\n                    audioRtpManager = RTPManager.newInstance();\n                    videoRtpManager = RTPManager.newInstance();\n\n                    allocateMediaPorts = true;\n                }\n            }\n            if (allocateMediaPorts)\n            {\n                allocateMediaPorts(intendedDestination);\n                lastIntendedDestination = intendedDestination;\n\n                if (startStreaming)\n                {\n                    startStreaming();\n                    applyOnHold();\n                }\n            }\n\n            InetAddress publicIpAddress = audioPublicAddress.getAddress();\n\n            String addrType\n                = publicIpAddress instanceof Inet6Address\n                ? Connection.IP6\n                : Connection.IP4;\n\n            //spaces in the user name mess everything up.\n            //bug report - Alessandro Melzi\n            Origin o = sdpFactory.createOrigin(\n                call.getProtocolProvider().getAccountID().getUserID()\n                , 0\n                , 0\n                , \"IN\"\n                , addrType\n                , publicIpAddress.getHostAddress());\n\n            sessDescr.setOrigin(o);\n            //c=\n            Connection c = sdpFactory.createConnection(\n                \"IN\"\n                , addrType\n                , publicIpAddress.getHostAddress());\n\n            sessDescr.setConnection(c);\n\n            //\"s=-\"\n            sessDescr.setSessionName(sdpFactory.createSessionName(\"-\"));\n\n            //\"t=0 0\"\n            TimeDescription t = sdpFactory.createTimeDescription();\n            Vector<TimeDescription> timeDescs = new Vector<TimeDescription>();\n            timeDescs.add(t);\n\n            sessDescr.setTimeDescriptions(timeDescs);\n\n            //media descriptions.\n            Vector offeredMediaDescriptions  = null;\n            if(offer != null)\n                offeredMediaDescriptions = offer.getMediaDescriptions(false);\n\n            logger.debug(\"Will create media descs with: audio public address=\"\n                         + audioPublicAddress\n                         + \" and video public address=\"\n                         + videoPublicAddress);\n\n            Vector mediaDescs\n                = createMediaDescriptions(offeredMediaDescriptions\n                                        , audioPublicAddress\n                                        , videoPublicAddress);\n\n            sessDescr.setMediaDescriptions(mediaDescs);\n\n            if (logger.isTraceEnabled())\n            {\n                logger.trace(\"Generated SDP - \" + sessDescr.toString());\n            }\n\n            return sessDescr;\n        }\n        catch (SdpException exc)\n        {\n            throw new MediaException(\n                \"An SDP exception occurred while generating local \"\n                + \"sdp description\"\n                , MediaException.INTERNAL_ERROR\n                , exc);\n        }\n    }","commit_id":"2067dddab6f37d193fb1ace4926f78022b7273ec","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Selects a default key management type to use in securing based\n     * on which the actual implementation for that solution will be started\n     * This part should be further developed (by adding a more detailed\n     * priority choosing mechanism in case of addition of other security\n     * providers).\n     *\n     * @return the default keymanagement type used in securing\n     */\n    public KeyProviderAlgorithm selectDefaultKeyProviderAlgorithm()\n    {\n        KeyProviderAlgorithm defaultProvider =\n            (KeyProviderAlgorithm)keySharingAlgorithms.get(0);\n\n        if (defaultProvider == null)\n        {\n            return new DummyKeyProvider(0);\n        }\n        else\n        {\n            return defaultProvider;\n        }\n    }","id":92551,"modified_method":"/**\n     * Selects a default key management type to use in securing based\n     * on which the actual implementation for that solution will be started\n     * This part should be further developed (by adding a more detailed\n     * priority choosing mechanism in case of addition of other security\n     * providers).\n     *\n     * @return the default keymanagement type used in securing\n     */\n    public KeyProviderAlgorithm selectDefaultKeyProviderAlgorithm()\n    {\n        KeyProviderAlgorithm defaultProvider = keySharingAlgorithms.get(0);\n\n        return (defaultProvider == null) ? new DummyKeyProvider(0)\n            : defaultProvider;\n    }","commit_id":"2067dddab6f37d193fb1ace4926f78022b7273ec","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Extracts the addresses that our interlocutor has sent for receiving media\n     * and adds them as targets to our RTP manager.\n     *\n     * @param globalConnParam the global <tt>Connection<\/tt> (if there was one)\n     * specified by our interlocutor outside any media description.\n     * @param mediaDescriptions a Vector containing all media descriptions sent\n     * by our interlocutor, that we'd use to verify whether connection level\n     * parameters have been specified.\n     *\n     * @throws ParseException if there was a problem with the sdp\n     * @throws MediaException if we simply fail to initialize the remote\n     * addresses or set them as targets on our RTPManagers.\n     */\n    private void initStreamTargets(Connection globalConnParam,\n                                   Vector mediaDescriptions)\n        throws MediaException, ParseException\n    {\n        try\n        {\n            String globalConnectionAddress = null;\n\n            if (globalConnParam != null)\n                  globalConnectionAddress = globalConnParam.getAddress();\n\n            Iterator mediaDescsIter = mediaDescriptions.iterator();\n            while (mediaDescsIter.hasNext())\n            {\n                SessionAddress target = null;\n                MediaDescription mediaDescription\n                    = (MediaDescription) mediaDescsIter.next();\n\n                int port = mediaDescription.getMedia().getMediaPort();\n                String type = mediaDescription.getMedia().getMediaType();\n\n                // If there's a global address, we use it.\n                // If there is no global address, we get the address from\n                // the media Description\n                // Fix by Pablo L. - Telefonica\n                String address;\n                if (globalConnectionAddress != null)\n                {\n                    address = globalConnectionAddress;\n                }\n                else\n                {\n                    address = mediaDescription.getConnection().getAddress();\n                }\n\n                //check if we have a media level address\n                Connection mediaLevelConnection = mediaDescription.\n                    getConnection();\n\n                if (mediaLevelConnection != null)\n                {\n                    address = mediaLevelConnection.getAddress();\n                }\n\n                InetAddress inetAddress = null;\n                try\n                {\n                    inetAddress = InetAddress.getByName(address);\n                }\n                catch (UnknownHostException exc)\n                {\n                    throw new MediaException(\n                        \"Failed to resolve address \" + address\n                        , MediaException.NETWORK_ERROR\n                        , exc);\n                }\n\n                //create the session address for this media type and add it to\n                //the RTPManager.\n                target = new SessionAddress(inetAddress, port);\n\n                /** @todo the following line assumes that we have a single rtp\n                 * manager per media type which is not necessarily true (e.g. we\n                 * may two distinct video streams: 1 for a webcam video and\n                 * another one desktop capture stream) */\n                RTPManager rtpManager = type.equals(\"video\")\n                    ? getVideoRtpManager()\n                    : getAudioRtpManager();\n\n                try\n                {\n                    if (selectedKeyProviderAlgorithm != null\n                        /* TODO: Video securing related code\n                         * remove the next condition as part of enabling video\n                         * securing (see comments in secureStatusChanged method\n                         * for more info)\n                         */\n                         && rtpManager.equals(audioRtpManager))\n                    {\n                        TransformConnector transConnector =\n                            (TransformConnector) this.transConnectors\n                                .get(rtpManager);\n\n                        if (transConnector == null)\n                        {\n                            throw new Exception();\n                        }\n\n                        transConnector.addTarget(target);\n                    }\n                    else\n                    {\n                        rtpManager.addTarget(target);\n                    }\n\n                    logger.trace(\"added target \" + target\n                                 + \" for type \" + type);\n                }\n                catch (Exception exc)\n                {\n                    throw new MediaException(\"Failed to add RTPManager target.\"\n                        , MediaException.INTERNAL_ERROR\n                        , exc);\n                }\n            }\n        }\n        catch(SdpParseException exc)\n        {\n            throw new ParseException(\"Failed to parse SDP data. Error on line \"\n                                     + exc.getLineNumber() + \" \"\n                                     + exc.getMessage()\n                                     , exc.getCharOffset());\n        }\n    }","id":92552,"modified_method":"/**\n     * Extracts the addresses that our interlocutor has sent for receiving media\n     * and adds them as targets to our RTP manager.\n     *\n     * @param globalConnParam the global <tt>Connection<\/tt> (if there was one)\n     * specified by our interlocutor outside any media description.\n     * @param mediaDescriptions a Vector containing all media descriptions sent\n     * by our interlocutor, that we'd use to verify whether connection level\n     * parameters have been specified.\n     *\n     * @throws ParseException if there was a problem with the sdp\n     * @throws MediaException if we simply fail to initialize the remote\n     * addresses or set them as targets on our RTPManagers.\n     */\n    private void initStreamTargets(Connection globalConnParam,\n                                   Vector mediaDescriptions)\n        throws MediaException, ParseException\n    {\n        try\n        {\n            String globalConnectionAddress = null;\n\n            if (globalConnParam != null)\n                  globalConnectionAddress = globalConnParam.getAddress();\n\n            Iterator mediaDescsIter = mediaDescriptions.iterator();\n            while (mediaDescsIter.hasNext())\n            {\n                SessionAddress target = null;\n                MediaDescription mediaDescription\n                    = (MediaDescription) mediaDescsIter.next();\n\n                int port = mediaDescription.getMedia().getMediaPort();\n                String type = mediaDescription.getMedia().getMediaType();\n\n                // If there's a global address, we use it.\n                // If there is no global address, we get the address from\n                // the media Description\n                // Fix by Pablo L. - Telefonica\n                String address;\n                if (globalConnectionAddress != null)\n                {\n                    address = globalConnectionAddress;\n                }\n                else\n                {\n                    address = mediaDescription.getConnection().getAddress();\n                }\n\n                //check if we have a media level address\n                Connection mediaLevelConnection = mediaDescription.\n                    getConnection();\n\n                if (mediaLevelConnection != null)\n                {\n                    address = mediaLevelConnection.getAddress();\n                }\n\n                InetAddress inetAddress = null;\n                try\n                {\n                    inetAddress = InetAddress.getByName(address);\n                }\n                catch (UnknownHostException exc)\n                {\n                    throw new MediaException(\n                        \"Failed to resolve address \" + address\n                        , MediaException.NETWORK_ERROR\n                        , exc);\n                }\n\n                //create the session address for this media type and add it to\n                //the RTPManager.\n                target = new SessionAddress(inetAddress, port);\n\n                /** @todo the following line assumes that we have a single rtp\n                 * manager per media type which is not necessarily true (e.g. we\n                 * may two distinct video streams: 1 for a webcam video and\n                 * another one desktop capture stream) */\n                RTPManager rtpManager = type.equals(\"video\")\n                    ? getVideoRtpManager()\n                    : getAudioRtpManager();\n\n                try\n                {\n                    if (selectedKeyProviderAlgorithm != null\n                        /* TODO: Video securing related code\n                         * remove the next condition as part of enabling video\n                         * securing (see comments in secureStatusChanged method\n                         * for more info)\n                         */\n                         && rtpManager.equals(audioRtpManager))\n                    {\n                        TransformConnector transConnector =\n                            this.transConnectors.get(rtpManager);\n\n                        if (transConnector == null)\n                        {\n                            throw new Exception();\n                        }\n\n                        transConnector.addTarget(target);\n                    }\n                    else\n                    {\n                        rtpManager.addTarget(target);\n                    }\n\n                    logger.trace(\"added target \" + target\n                                 + \" for type \" + type);\n                }\n                catch (Exception exc)\n                {\n                    throw new MediaException(\"Failed to add RTPManager target.\"\n                        , MediaException.INTERNAL_ERROR\n                        , exc);\n                }\n            }\n        }\n        catch(SdpParseException exc)\n        {\n            throw new ParseException(\"Failed to parse SDP data. Error on line \"\n                                     + exc.getLineNumber() + \" \"\n                                     + exc.getMessage()\n                                     , exc.getCharOffset());\n        }\n    }","commit_id":"2067dddab6f37d193fb1ace4926f78022b7273ec","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns an InetAddress instance that represents the localhost, and that\n     * a socket can bind upon or distribute to peers as a contact address.\n     *\n     * @param intendedDestination the destination that we'd like to use the\n     * localhost address with.\n     *\n     * @return an InetAddress instance representing the local host, and that\n     * a socket can bind upon or distribute to peers as a contact address.\n     */\n    public synchronized InetAddress getLocalHost(InetAddress intendedDestination)\n    {\n        //no point in making sure that the localHostFinderSocket is initialized.\n        //better let it through a NullPointerException.\n        InetAddress localHost = null;\n        localHostFinderSocket.connect(intendedDestination\n                                      , this.RANDOM_ADDR_DISC_PORT);\n        localHost = localHostFinderSocket.getLocalAddress();\n        localHostFinderSocket.disconnect();\n        //windows socket implementations return the any address so we need to\n        //find something else here ... InetAddress.getLocalHost seems to work\n        //better on windows so lets hope it'll do the trick.\n        if( localHost.isAnyLocalAddress())\n        {\n            try\n            {\n                //all that's inside the if is an ugly IPv6 hack\n                //(good ol' IPv6 - always causing more problems than it solves.)\n                if (intendedDestination instanceof Inet6Address)\n                {\n                    //return the first globally routable ipv6 address we find\n                    //on the machine (and hope it's a good one)\n                    Enumeration interfaces\n                        = NetworkInterface.getNetworkInterfaces();\n\n                    while (interfaces.hasMoreElements())\n                    {\n                        NetworkInterface iface\n                            = (NetworkInterface)interfaces.nextElement();\n                        Enumeration addresses = iface.getInetAddresses();\n                        while(addresses.hasMoreElements())\n                        {\n                            InetAddress address\n                                = (InetAddress)addresses.nextElement();\n                            if(address instanceof Inet6Address)\n                            {\n                                if(!address.isAnyLocalAddress()\n                                    && !address.isLinkLocalAddress()\n                                    && !address.isSiteLocalAddress()\n                                    && !address.isLoopbackAddress())\n                                {\n                                    return address;\n                                }\n                            }\n                        }\n                    }\n                }\n                else\n                    localHost = InetAddress.getLocalHost();\n                /** @todo test on windows for ipv6 cases */\n            }\n            catch (Exception ex)\n            {\n                //sigh ... ok return 0.0.0.0\n                logger.warn(\"Failed to get localhost \", ex);\n            }\n        }\n\n        return localHost;\n    }","id":92553,"modified_method":"/**\n     * Returns an InetAddress instance that represents the localhost, and that\n     * a socket can bind upon or distribute to peers as a contact address.\n     *\n     * @param intendedDestination the destination that we'd like to use the\n     * localhost address with.\n     *\n     * @return an InetAddress instance representing the local host, and that\n     * a socket can bind upon or distribute to peers as a contact address.\n     */\n    public synchronized InetAddress getLocalHost(InetAddress intendedDestination)\n    {\n        //no point in making sure that the localHostFinderSocket is initialized.\n        //better let it through a NullPointerException.\n        InetAddress localHost = null;\n        localHostFinderSocket.connect(intendedDestination\n                                      , this.RANDOM_ADDR_DISC_PORT);\n        localHost = localHostFinderSocket.getLocalAddress();\n        localHostFinderSocket.disconnect();\n        //windows socket implementations return the any address so we need to\n        //find something else here ... InetAddress.getLocalHost seems to work\n        //better on windows so lets hope it'll do the trick.\n        if( localHost.isAnyLocalAddress())\n        {\n            try\n            {\n                //all that's inside the if is an ugly IPv6 hack\n                //(good ol' IPv6 - always causing more problems than it solves.)\n                if (intendedDestination instanceof Inet6Address)\n                {\n                    //return the first globally routable ipv6 address we find\n                    //on the machine (and hope it's a good one)\n                    Enumeration<NetworkInterface> interfaces\n                        = NetworkInterface.getNetworkInterfaces();\n\n                    while (interfaces.hasMoreElements())\n                    {\n                        NetworkInterface iface = interfaces.nextElement();\n                        Enumeration<InetAddress> addresses =\n                            iface.getInetAddresses();\n                        while(addresses.hasMoreElements())\n                        {\n                            InetAddress address\n                                = addresses.nextElement();\n                            if(address instanceof Inet6Address)\n                            {\n                                if(!address.isAnyLocalAddress()\n                                    && !address.isLinkLocalAddress()\n                                    && !address.isSiteLocalAddress()\n                                    && !address.isLoopbackAddress())\n                                {\n                                    return address;\n                                }\n                            }\n                        }\n                    }\n                }\n                else\n                    localHost = InetAddress.getLocalHost();\n                /** @todo test on windows for ipv6 cases */\n            }\n            catch (Exception ex)\n            {\n                //sigh ... ok return 0.0.0.0\n                logger.warn(\"Failed to get localhost \", ex);\n            }\n        }\n\n        return localHost;\n    }","commit_id":"2067dddab6f37d193fb1ace4926f78022b7273ec","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Return the random number generator instance we should use for\n     * generating session identifiers.  If there is no such generator\n     * currently defined, construct and seed a new one.\n     */\n    protected synchronized Random getRandom() {\n\n        if (this.random == null) {\n            try {\n                Class clazz = Class.forName(randomClass);\n                this.random = (Random) clazz.newInstance();\n                long seed = System.currentTimeMillis();\n                char entropy[] = getEntropy().toCharArray();\n                for (int i = 0; i < entropy.length; i++) {\n                    long update = ((byte) entropy[i]) << ((i % 8) * 8);\n                    seed ^= update;\n                }\n                this.random.setSeed(seed);\n            } catch (Exception e) {\n                this.random = new java.util.Random();\n            }\n        }\n\n        return (this.random);\n\n    }","id":92554,"modified_method":"/**\n     * Return the random number generator instance we should use for\n     * generating session identifiers.  If there is no such generator\n     * currently defined, construct and seed a new one.\n     */\n    protected synchronized Random getRandom() {\n\n        if (this.random == null) {\n            try {\n                Class<?> clazz = Class.forName(randomClass);\n                this.random = (Random) clazz.newInstance();\n                long seed = System.currentTimeMillis();\n                char entropy[] = getEntropy().toCharArray();\n                for (int i = 0; i < entropy.length; i++) {\n                    long update = ((byte) entropy[i]) << ((i % 8) * 8);\n                    seed ^= update;\n                }\n                this.random.setSeed(seed);\n            } catch (Exception e) {\n                this.random = new java.util.Random();\n            }\n        }\n\n        return (this.random);\n\n    }","commit_id":"737b1d497b4125d66ca382aca505241cf0b81705","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Save the original request information into our session.\n     *\n     * @param request The request to be saved\n     * @param session The session to contain the saved information\n     * @throws IOException\n     */\n    protected void saveRequest(Request request, Session session)\n        throws IOException {\n\n        // Create and populate a SavedRequest object for this request\n        SavedRequest saved = new SavedRequest();\n        Cookie cookies[] = request.getCookies();\n        if (cookies != null) {\n            for (int i = 0; i < cookies.length; i++)\n                saved.addCookie(cookies[i]);\n        }\n        Enumeration names = request.getHeaderNames();\n        while (names.hasMoreElements()) {\n            String name = (String) names.nextElement();\n            Enumeration values = request.getHeaders(name);\n            while (values.hasMoreElements()) {\n                String value = (String) values.nextElement();\n                saved.addHeader(name, value);\n            }\n        }\n        Enumeration locales = request.getLocales();\n        while (locales.hasMoreElements()) {\n            Locale locale = (Locale) locales.nextElement();\n            saved.addLocale(locale);\n        }\n\n        if (\"POST\".equalsIgnoreCase(request.getMethod())) {\n            ByteChunk body = new ByteChunk();\n            body.setLimit(request.getConnector().getMaxSavePostSize());\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            InputStream is = request.getInputStream();\n        \n            while ( (bytesRead = is.read(buffer) ) >= 0) {\n                body.append(buffer, 0, bytesRead);\n            }\n            saved.setContentType(request.getContentType());\n            saved.setBody(body);\n        }\n\n        saved.setMethod(request.getMethod());\n        saved.setQueryString(request.getQueryString());\n        saved.setRequestURI(request.getRequestURI());\n\n        // Stash the SavedRequest in our session for later use\n        session.setNote(Constants.FORM_REQUEST_NOTE, saved);\n\n    }","id":92555,"modified_method":"/**\n     * Save the original request information into our session.\n     *\n     * @param request The request to be saved\n     * @param session The session to contain the saved information\n     * @throws IOException\n     */\n    protected void saveRequest(Request request, Session session)\n        throws IOException {\n\n        // Create and populate a SavedRequest object for this request\n        SavedRequest saved = new SavedRequest();\n        Cookie cookies[] = request.getCookies();\n        if (cookies != null) {\n            for (int i = 0; i < cookies.length; i++)\n                saved.addCookie(cookies[i]);\n        }\n        Enumeration<String> names = request.getHeaderNames();\n        while (names.hasMoreElements()) {\n            String name = names.nextElement();\n            Enumeration<String> values = request.getHeaders(name);\n            while (values.hasMoreElements()) {\n                String value = values.nextElement();\n                saved.addHeader(name, value);\n            }\n        }\n        Enumeration<Locale> locales = request.getLocales();\n        while (locales.hasMoreElements()) {\n            Locale locale = locales.nextElement();\n            saved.addLocale(locale);\n        }\n\n        if (\"POST\".equalsIgnoreCase(request.getMethod())) {\n            ByteChunk body = new ByteChunk();\n            body.setLimit(request.getConnector().getMaxSavePostSize());\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            InputStream is = request.getInputStream();\n        \n            while ( (bytesRead = is.read(buffer) ) >= 0) {\n                body.append(buffer, 0, bytesRead);\n            }\n            saved.setContentType(request.getContentType());\n            saved.setBody(body);\n        }\n\n        saved.setMethod(request.getMethod());\n        saved.setQueryString(request.getQueryString());\n        saved.setRequestURI(request.getRequestURI());\n\n        // Stash the SavedRequest in our session for later use\n        session.setNote(Constants.FORM_REQUEST_NOTE, saved);\n\n    }","commit_id":"737b1d497b4125d66ca382aca505241cf0b81705","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Restore the original request from information stored in our session.\n     * If the original request is no longer present (because the session\n     * timed out), return <code>false<\/code>; otherwise, return\n     * <code>true<\/code>.\n     *\n     * @param request The request to be restored\n     * @param session The session containing the saved information\n     */\n    protected boolean restoreRequest(Request request, Session session)\n        throws IOException {\n\n        // Retrieve and remove the SavedRequest object from our session\n        SavedRequest saved = (SavedRequest)\n            session.getNote(Constants.FORM_REQUEST_NOTE);\n        session.removeNote(Constants.FORM_REQUEST_NOTE);\n        session.removeNote(Constants.FORM_PRINCIPAL_NOTE);\n        if (saved == null)\n            return (false);\n\n        // Modify our current request to reflect the original one\n        request.clearCookies();\n        Iterator cookies = saved.getCookies();\n        while (cookies.hasNext()) {\n            request.addCookie((Cookie) cookies.next());\n        }\n\n        MimeHeaders rmh = request.getCoyoteRequest().getMimeHeaders();\n        rmh.recycle();\n        boolean cachable = \"GET\".equalsIgnoreCase(saved.getMethod()) ||\n                           \"HEAD\".equalsIgnoreCase(saved.getMethod());\n        Iterator names = saved.getHeaderNames();\n        while (names.hasNext()) {\n            String name = (String) names.next();\n            // The browser isn't expecting this conditional reposponse now.\n            // Assuming that it can quietly recover from an unexpected 412.\n            // BZ 43687\n            if(!(\"If-Modified-Since\".equalsIgnoreCase(name) ||\n                 (cachable && \"If-None-Match\".equalsIgnoreCase(name)))) {\n                Iterator values = saved.getHeaderValues(name);\n                while (values.hasNext()) {\n                    rmh.addValue(name).setString( (String)values.next() );\n                }\n            }\n        }\n        \n        request.clearLocales();\n        Iterator locales = saved.getLocales();\n        while (locales.hasNext()) {\n            request.addLocale((Locale) locales.next());\n        }\n        \n        request.getCoyoteRequest().getParameters().recycle();\n        request.getCoyoteRequest().getParameters().setQueryStringEncoding(\n                request.getConnector().getURIEncoding());\n\n        if (\"POST\".equalsIgnoreCase(saved.getMethod())) {\n            ByteChunk body = saved.getBody();\n            \n            if (body != null) {\n                request.getCoyoteRequest().action\n                    (ActionCode.ACTION_REQ_SET_BODY_REPLAY, body);\n    \n                // Set content type\n                MessageBytes contentType = MessageBytes.newInstance();\n                \n                //If no content type specified, use default for POST\n                String savedContentType = saved.getContentType();\n                if (savedContentType == null) {\n                    savedContentType = \"application/x-www-form-urlencoded\";\n                }\n\n                contentType.setString(savedContentType);\n                request.getCoyoteRequest().setContentType(contentType);\n            }\n        }\n        request.getCoyoteRequest().method().setString(saved.getMethod());\n\n        request.getCoyoteRequest().queryString().setString\n            (saved.getQueryString());\n\n        request.getCoyoteRequest().requestURI().setString\n            (saved.getRequestURI());\n        return (true);\n\n    }","id":92556,"modified_method":"/**\n     * Restore the original request from information stored in our session.\n     * If the original request is no longer present (because the session\n     * timed out), return <code>false<\/code>; otherwise, return\n     * <code>true<\/code>.\n     *\n     * @param request The request to be restored\n     * @param session The session containing the saved information\n     */\n    protected boolean restoreRequest(Request request, Session session)\n        throws IOException {\n\n        // Retrieve and remove the SavedRequest object from our session\n        SavedRequest saved = (SavedRequest)\n            session.getNote(Constants.FORM_REQUEST_NOTE);\n        session.removeNote(Constants.FORM_REQUEST_NOTE);\n        session.removeNote(Constants.FORM_PRINCIPAL_NOTE);\n        if (saved == null)\n            return (false);\n\n        // Modify our current request to reflect the original one\n        request.clearCookies();\n        Iterator<Cookie> cookies = saved.getCookies();\n        while (cookies.hasNext()) {\n            request.addCookie(cookies.next());\n        }\n\n        MimeHeaders rmh = request.getCoyoteRequest().getMimeHeaders();\n        rmh.recycle();\n        boolean cachable = \"GET\".equalsIgnoreCase(saved.getMethod()) ||\n                           \"HEAD\".equalsIgnoreCase(saved.getMethod());\n        Iterator<String> names = saved.getHeaderNames();\n        while (names.hasNext()) {\n            String name = names.next();\n            // The browser isn't expecting this conditional reposponse now.\n            // Assuming that it can quietly recover from an unexpected 412.\n            // BZ 43687\n            if(!(\"If-Modified-Since\".equalsIgnoreCase(name) ||\n                 (cachable && \"If-None-Match\".equalsIgnoreCase(name)))) {\n                Iterator<String> values = saved.getHeaderValues(name);\n                while (values.hasNext()) {\n                    rmh.addValue(name).setString(values.next());\n                }\n            }\n        }\n        \n        request.clearLocales();\n        Iterator<Locale> locales = saved.getLocales();\n        while (locales.hasNext()) {\n            request.addLocale(locales.next());\n        }\n        \n        request.getCoyoteRequest().getParameters().recycle();\n        request.getCoyoteRequest().getParameters().setQueryStringEncoding(\n                request.getConnector().getURIEncoding());\n\n        if (\"POST\".equalsIgnoreCase(saved.getMethod())) {\n            ByteChunk body = saved.getBody();\n            \n            if (body != null) {\n                request.getCoyoteRequest().action\n                    (ActionCode.ACTION_REQ_SET_BODY_REPLAY, body);\n    \n                // Set content type\n                MessageBytes contentType = MessageBytes.newInstance();\n                \n                //If no content type specified, use default for POST\n                String savedContentType = saved.getContentType();\n                if (savedContentType == null) {\n                    savedContentType = \"application/x-www-form-urlencoded\";\n                }\n\n                contentType.setString(savedContentType);\n                request.getCoyoteRequest().setContentType(contentType);\n            }\n        }\n        request.getCoyoteRequest().method().setString(saved.getMethod());\n\n        request.getCoyoteRequest().queryString().setString\n            (saved.getQueryString());\n\n        request.getCoyoteRequest().requestURI().setString\n            (saved.getRequestURI());\n        return (true);\n\n    }","commit_id":"737b1d497b4125d66ca382aca505241cf0b81705","url":"https://github.com/apache/tomcat"},{"original_method":"public void addHeader(String name, String value) {\n        ArrayList<String> values = (ArrayList<String>) headers.get(name);\n        if (values == null) {\n            values = new ArrayList<String>();\n            headers.put(name, values);\n        }\n        values.add(value);\n    }","id":92557,"modified_method":"public void addHeader(String name, String value) {\n        ArrayList<String> values = headers.get(name);\n        if (values == null) {\n            values = new ArrayList<String>();\n            headers.put(name, values);\n        }\n        values.add(value);\n    }","commit_id":"737b1d497b4125d66ca382aca505241cf0b81705","url":"https://github.com/apache/tomcat"},{"original_method":"public String[] getParameterValues(String name) {\n        return ((String[]) parameters.get(name));\n    }","id":92558,"modified_method":"public String[] getParameterValues(String name) {\n        return parameters.get(name);\n    }","commit_id":"737b1d497b4125d66ca382aca505241cf0b81705","url":"https://github.com/apache/tomcat"},{"original_method":"public Iterator getHeaderValues(String name) {\n        ArrayList values = (ArrayList) headers.get(name);\n        if (values == null)\n            return ((new ArrayList()).iterator());\n        else\n            return (values.iterator());\n    }","id":92559,"modified_method":"public Iterator<String> getHeaderValues(String name) {\n        ArrayList<String> values = headers.get(name);\n        if (values == null)\n            return ((new ArrayList<String>()).iterator());\n        else\n            return (values.iterator());\n    }","commit_id":"737b1d497b4125d66ca382aca505241cf0b81705","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Acknowledge the occurrence of the specified event.\n     *\n     * @param event SessionEvent that has occurred\n     */\n    public void sessionEvent(SessionEvent event) {\n\n        // We only care about session destroyed events\n        if (!Session.SESSION_DESTROYED_EVENT.equals(event.getType())\n                && (!Session.SESSION_PASSIVATED_EVENT.equals(event.getType())))\n            return;\n\n        // Look up the single session id associated with this session (if any)\n        Session session = event.getSession();\n        if (containerLog.isDebugEnabled())\n            containerLog.debug(\"Process session destroyed on \" + session);\n\n        String ssoId = null;\n        synchronized (reverse) {\n            ssoId = (String) reverse.get(session);\n        }\n        if (ssoId == null)\n            return;\n\n        // Was the session destroyed as the result of a timeout?\n        // If so, we'll just remove the expired session from the\n        // SSO.  If the session was logged out, we'll log out\n        // of all session associated with the SSO.\n        if (((session.getMaxInactiveInterval() > 0)\n            && (System.currentTimeMillis() - session.getThisAccessedTimeInternal() >=\n                session.getMaxInactiveInterval() * 1000)) \n            || (Session.SESSION_PASSIVATED_EVENT.equals(event.getType()))) {\n            removeSession(ssoId, session);\n        } else {\n            // The session was logged out.\n            // Deregister this single session id, invalidating \n            // associated sessions\n            deregister(ssoId);\n        }\n\n    }","id":92560,"modified_method":"/**\n     * Acknowledge the occurrence of the specified event.\n     *\n     * @param event SessionEvent that has occurred\n     */\n    public void sessionEvent(SessionEvent event) {\n\n        // We only care about session destroyed events\n        if (!Session.SESSION_DESTROYED_EVENT.equals(event.getType())\n                && (!Session.SESSION_PASSIVATED_EVENT.equals(event.getType())))\n            return;\n\n        // Look up the single session id associated with this session (if any)\n        Session session = event.getSession();\n        if (containerLog.isDebugEnabled())\n            containerLog.debug(\"Process session destroyed on \" + session);\n\n        String ssoId = null;\n        synchronized (reverse) {\n            ssoId = reverse.get(session);\n        }\n        if (ssoId == null)\n            return;\n\n        // Was the session destroyed as the result of a timeout?\n        // If so, we'll just remove the expired session from the\n        // SSO.  If the session was logged out, we'll log out\n        // of all session associated with the SSO.\n        if (((session.getMaxInactiveInterval() > 0)\n            && (System.currentTimeMillis() - session.getThisAccessedTimeInternal() >=\n                session.getMaxInactiveInterval() * 1000)) \n            || (Session.SESSION_PASSIVATED_EVENT.equals(event.getType()))) {\n            removeSession(ssoId, session);\n        } else {\n            // The session was logged out.\n            // Deregister this single session id, invalidating \n            // associated sessions\n            deregister(ssoId);\n        }\n\n    }","commit_id":"737b1d497b4125d66ca382aca505241cf0b81705","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Deregister the specified single sign on identifier, and invalidate\n     * any associated sessions.\n     *\n     * @param ssoId Single sign on identifier to deregister\n     */\n    protected void deregister(String ssoId) {\n\n        if (containerLog.isDebugEnabled())\n            containerLog.debug(\"Deregistering sso id '\" + ssoId + \"'\");\n\n        // Look up and remove the corresponding SingleSignOnEntry\n        SingleSignOnEntry sso = null;\n        synchronized (cache) {\n            sso = (SingleSignOnEntry) cache.remove(ssoId);\n        }\n\n        if (sso == null)\n            return;\n\n        // Expire any associated sessions\n        Session sessions[] = sso.findSessions();\n        for (int i = 0; i < sessions.length; i++) {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(\" Invalidating session \" + sessions[i]);\n            // Remove from reverse cache first to avoid recursion\n            synchronized (reverse) {\n                reverse.remove(sessions[i]);\n            }\n            // Invalidate this session\n            sessions[i].expire();\n        }\n\n        // NOTE:  Clients may still possess the old single sign on cookie,\n        // but it will be removed on the next request since it is no longer\n        // in the cache\n\n    }","id":92561,"modified_method":"/**\n     * Deregister the specified single sign on identifier, and invalidate\n     * any associated sessions.\n     *\n     * @param ssoId Single sign on identifier to deregister\n     */\n    protected void deregister(String ssoId) {\n\n        if (containerLog.isDebugEnabled())\n            containerLog.debug(\"Deregistering sso id '\" + ssoId + \"'\");\n\n        // Look up and remove the corresponding SingleSignOnEntry\n        SingleSignOnEntry sso = null;\n        synchronized (cache) {\n            sso = cache.remove(ssoId);\n        }\n\n        if (sso == null)\n            return;\n\n        // Expire any associated sessions\n        Session sessions[] = sso.findSessions();\n        for (int i = 0; i < sessions.length; i++) {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(\" Invalidating session \" + sessions[i]);\n            // Remove from reverse cache first to avoid recursion\n            synchronized (reverse) {\n                reverse.remove(sessions[i]);\n            }\n            // Invalidate this session\n            sessions[i].expire();\n        }\n\n        // NOTE:  Clients may still possess the old single sign on cookie,\n        // but it will be removed on the next request since it is no longer\n        // in the cache\n\n    }","commit_id":"737b1d497b4125d66ca382aca505241cf0b81705","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Deregister the specified session.  If it is the last session,\n     * then also get rid of the single sign on identifier\n     *\n     * @param ssoId Single sign on identifier\n     * @param session Session to be deregistered\n     */\n    protected void deregister(String ssoId, Session session) {\n\n        synchronized (reverse) {\n            reverse.remove(session);\n        }\n\n        SingleSignOnEntry sso = lookup(ssoId);\n        if ( sso == null )\n            return;\n\n        sso.removeSession( session );\n\n        // see if we are the last session, if so blow away ssoId\n        Session sessions[] = sso.findSessions();\n        if ( sessions == null || sessions.length == 0 ) {\n            synchronized (cache) {\n                sso = (SingleSignOnEntry) cache.remove(ssoId);\n            }\n        }\n\n    }","id":92562,"modified_method":"/**\n     * Deregister the specified session.  If it is the last session,\n     * then also get rid of the single sign on identifier\n     *\n     * @param ssoId Single sign on identifier\n     * @param session Session to be deregistered\n     */\n    protected void deregister(String ssoId, Session session) {\n\n        synchronized (reverse) {\n            reverse.remove(session);\n        }\n\n        SingleSignOnEntry sso = lookup(ssoId);\n        if ( sso == null )\n            return;\n\n        sso.removeSession( session );\n\n        // see if we are the last session, if so blow away ssoId\n        Session sessions[] = sso.findSessions();\n        if ( sessions == null || sessions.length == 0 ) {\n            synchronized (cache) {\n                sso = cache.remove(ssoId);\n            }\n        }\n\n    }","commit_id":"737b1d497b4125d66ca382aca505241cf0b81705","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Look up and return the cached SingleSignOn entry associated with this\n     * sso id value, if there is one; otherwise return <code>null<\/code>.\n     *\n     * @param ssoId Single sign on identifier to look up\n     */\n    protected SingleSignOnEntry lookup(String ssoId) {\n\n        synchronized (cache) {\n            return ((SingleSignOnEntry) cache.get(ssoId));\n        }\n\n    }","id":92563,"modified_method":"/**\n     * Look up and return the cached SingleSignOn entry associated with this\n     * sso id value, if there is one; otherwise return <code>null<\/code>.\n     *\n     * @param ssoId Single sign on identifier to look up\n     */\n    protected SingleSignOnEntry lookup(String ssoId) {\n\n        synchronized (cache) {\n            return cache.get(ssoId);\n        }\n\n    }","commit_id":"737b1d497b4125d66ca382aca505241cf0b81705","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * This method is responsible for handling serviceDeleted events.\n     * \n     * @param event\n     *            The event to process.\n     * \n     */\n    private void serviceDeletedHandler(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // Currently only support SNMP data thresholding.\n        //\n        if (!event.getService().equals(\"SNMP\"))\n            return;\n\n        int nodeId = (int) event.getNodeid();\n        String ipAddr = event.getInterface();\n        String svcName = event.getService();\n\n        // Iterate over the collectable services list and mark any entries\n        // which match the nodeId/ipAddr of the deleted service\n        // for deletion.\n        synchronized (m_thresholdableServices) {\n            ThresholdableService tSvc = null;\n            ListIterator liter = m_thresholdableServices.listIterator();\n            while (liter.hasNext()) {\n                tSvc = (ThresholdableService) liter.next();\n\n                // Only interested in entries with matching nodeId, IP address\n                // and service\n                InetAddress addr = (InetAddress) tSvc.getAddress();\n                if (!(tSvc.getNodeId() == nodeId && addr.getHostName().equals(ipAddr)) && tSvc.getServiceName().equals(svcName))\n                    continue;\n\n                synchronized (tSvc) {\n                    // Retrieve the ThresholderUpdates object associated with\n                    // this ThresholdableService if one exists.\n                    ThresholderUpdates updates = tSvc.getThresholderUpdates();\n\n                    // Now set the update's deletion flag so the next\n                    // time it is selected for execution by the scheduler\n                    // the thresholding will be skipped and the service will not\n                    // be rescheduled.\n                    updates.markForDeletion();\n                }\n\n                // Now safe to remove the collectable service from\n                // the collectable services list\n                liter.remove();\n            }\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"serviceDeletedHandler: processing of serviceDeleted event for \" + nodeId + \"/\" + ipAddr + \"/\" + svcName + \" completed.\");\n    }","id":92564,"modified_method":"/**\n     * This method is responsible for handling serviceDeleted events.\n     * \n     * @param event\n     *            The event to process.\n     * \n     */\n    private void serviceDeletedHandler(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // Currently only support SNMP data thresholding.\n        //\n        if (!event.getService().equals(\"SNMP\"))\n            return;\n\n        int nodeId = (int) event.getNodeid();\n        String ipAddr = event.getInterface();\n        String svcName = event.getService();\n\n        // Iterate over the collectable services list and mark any entries\n        // which match the nodeId/ipAddr of the deleted service\n        // for deletion.\n        synchronized (m_thresholdableServices) {\n            ThresholdableService tSvc = null;\n            ListIterator<ThresholdableService> liter = m_thresholdableServices.listIterator();\n            while (liter.hasNext()) {\n                tSvc = liter.next();\n\n                // Only interested in entries with matching nodeId, IP address\n                // and service\n                InetAddress addr = (InetAddress) tSvc.getAddress();\n                if (!(tSvc.getNodeId() == nodeId && addr.getHostName().equals(ipAddr)) && tSvc.getServiceName().equals(svcName))\n                    continue;\n\n                synchronized (tSvc) {\n                    // Retrieve the ThresholderUpdates object associated with\n                    // this ThresholdableService if one exists.\n                    ThresholderUpdates updates = tSvc.getThresholderUpdates();\n\n                    // Now set the update's deletion flag so the next\n                    // time it is selected for execution by the scheduler\n                    // the thresholding will be skipped and the service will not\n                    // be rescheduled.\n                    updates.markForDeletion();\n                }\n\n                // Now safe to remove the collectable service from\n                // the collectable services list\n                liter.remove();\n            }\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"serviceDeletedHandler: processing of serviceDeleted event for \" + nodeId + \"/\" + ipAddr + \"/\" + svcName + \" completed.\");\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for processing 'interfacReparented' events. An\n     * 'interfaceReparented' event will have old and new nodeId parms associated\n     * with it. All ThresholdableService objects in the service updates map\n     * which match the event's interface address and the SNMP service have a\n     * reparenting update associated with them. When the scheduler next pops one\n     * of these services from an interval queue for thresholding all of the RRDs\n     * associated with the old nodeId are moved under the new nodeId and the\n     * nodeId of the collectable service is updated to reflect the interface's\n     * new parent nodeId.\n     * \n     * @param event\n     *            The event to process.\n     * \n     */\n    private void interfaceReparentedHandler(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n        if (log.isDebugEnabled())\n            log.debug(\"interfaceReparentedHandler:  processing interfaceReparented event for \" + event.getInterface());\n\n        // Verify that the event has an interface associated with it\n        if (event.getInterface() == null)\n            return;\n\n        // Extract the old and new nodeId's from the event parms\n        String oldNodeIdStr = null;\n        String newNodeIdStr = null;\n        Parms parms = event.getParms();\n        if (parms != null) {\n            String parmName = null;\n            Value parmValue = null;\n            String parmContent = null;\n\n            Enumeration parmEnum = parms.enumerateParm();\n            while (parmEnum.hasMoreElements()) {\n                Parm parm = (Parm) parmEnum.nextElement();\n                parmName = parm.getParmName();\n                parmValue = parm.getValue();\n                if (parmValue == null)\n                    continue;\n                else\n                    parmContent = parmValue.getContent();\n\n                // old nodeid\n                if (parmName.equals(EventConstants.PARM_OLD_NODEID)) {\n                    oldNodeIdStr = parmContent;\n                }\n\n                // new nodeid\n                else if (parmName.equals(EventConstants.PARM_NEW_NODEID)) {\n                    newNodeIdStr = parmContent;\n                }\n            }\n        }\n\n        // Only proceed provided we have both an old and a new nodeId\n        //\n        if (oldNodeIdStr == null || newNodeIdStr == null) {\n            log.warn(\"interfaceReparentedHandler: old and new nodeId parms are required, unable to process.\");\n            return;\n        }\n\n        // Iterate over the ThresholdableService objects in the services\n        // list looking for entries which share the same interface\n        // address as the reparented interface. Mark any matching objects\n        // for reparenting.\n        //\n        // The next time the service is scheduled for execution it\n        // will move all of the RRDs associated\n        // with the old nodeId under the new nodeId and update the service's\n        // SnmpMonitor.NodeInfo attribute to reflect the new nodeId. All\n        // subsequent thresholdings will then be updating the appropriate RRDs.\n        //\n        \n        //unused - commented out\n        //boolean isPrimarySnmpInterface = false;\n        synchronized (m_thresholdableServices) {\n            ThresholdableService tSvc = null;\n            Iterator iter = m_thresholdableServices.iterator();\n            while (iter.hasNext()) {\n                tSvc = (ThresholdableService) iter.next();\n\n                InetAddress addr = (InetAddress) tSvc.getAddress();\n                if (addr.getHostAddress().equals(event.getInterface())) {\n                    synchronized (tSvc) {\n                        // Got a match!\n                        if (log.isDebugEnabled())\n                            log.debug(\"interfaceReparentedHandler: got a ThresholdableService match for \" + event.getInterface());\n\n                        // Retrieve the ThresholderUpdates object associated\n                        // with this ThresholdableService.\n                        ThresholderUpdates updates = tSvc.getThresholderUpdates();\n\n                        // Now set the reparenting flag\n                        updates.markForReparenting(oldNodeIdStr, newNodeIdStr);\n                        if (log.isDebugEnabled())\n                            log.debug(\"interfaceReparentedHandler: marking \" + event.getInterface() + \" for reparenting for service SNMP.\");\n                    }\n                }\n            }\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"interfaceReparentedHandler: processing of interfaceReparented event for interface \" + event.getInterface() + \" completed.\");\n    }","id":92565,"modified_method":"/**\n     * This method is responsible for processing 'interfacReparented' events. An\n     * 'interfaceReparented' event will have old and new nodeId parms associated\n     * with it. All ThresholdableService objects in the service updates map\n     * which match the event's interface address and the SNMP service have a\n     * reparenting update associated with them. When the scheduler next pops one\n     * of these services from an interval queue for thresholding all of the RRDs\n     * associated with the old nodeId are moved under the new nodeId and the\n     * nodeId of the collectable service is updated to reflect the interface's\n     * new parent nodeId.\n     * \n     * @param event\n     *            The event to process.\n     * \n     */\n    private void interfaceReparentedHandler(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n        if (log.isDebugEnabled())\n            log.debug(\"interfaceReparentedHandler:  processing interfaceReparented event for \" + event.getInterface());\n\n        // Verify that the event has an interface associated with it\n        if (event.getInterface() == null)\n            return;\n\n        // Extract the old and new nodeId's from the event parms\n        String oldNodeIdStr = null;\n        String newNodeIdStr = null;\n        Parms parms = event.getParms();\n        if (parms != null) {\n            String parmName = null;\n            Value parmValue = null;\n            String parmContent = null;\n\n            Enumeration parmEnum = parms.enumerateParm();\n            while (parmEnum.hasMoreElements()) {\n                Parm parm = (Parm) parmEnum.nextElement();\n                parmName = parm.getParmName();\n                parmValue = parm.getValue();\n                if (parmValue == null)\n                    continue;\n                else\n                    parmContent = parmValue.getContent();\n\n                // old nodeid\n                if (parmName.equals(EventConstants.PARM_OLD_NODEID)) {\n                    oldNodeIdStr = parmContent;\n                }\n\n                // new nodeid\n                else if (parmName.equals(EventConstants.PARM_NEW_NODEID)) {\n                    newNodeIdStr = parmContent;\n                }\n            }\n        }\n\n        // Only proceed provided we have both an old and a new nodeId\n        //\n        if (oldNodeIdStr == null || newNodeIdStr == null) {\n            log.warn(\"interfaceReparentedHandler: old and new nodeId parms are required, unable to process.\");\n            return;\n        }\n\n        // Iterate over the ThresholdableService objects in the services\n        // list looking for entries which share the same interface\n        // address as the reparented interface. Mark any matching objects\n        // for reparenting.\n        //\n        // The next time the service is scheduled for execution it\n        // will move all of the RRDs associated\n        // with the old nodeId under the new nodeId and update the service's\n        // SnmpMonitor.NodeInfo attribute to reflect the new nodeId. All\n        // subsequent thresholdings will then be updating the appropriate RRDs.\n        //\n        \n        //unused - commented out\n        //boolean isPrimarySnmpInterface = false;\n        synchronized (m_thresholdableServices) {\n            ThresholdableService tSvc = null;\n            Iterator<ThresholdableService> iter = m_thresholdableServices.iterator();\n            while (iter.hasNext()) {\n                tSvc = iter.next();\n\n                InetAddress addr = (InetAddress) tSvc.getAddress();\n                if (addr.getHostAddress().equals(event.getInterface())) {\n                    synchronized (tSvc) {\n                        // Got a match!\n                        if (log.isDebugEnabled())\n                            log.debug(\"interfaceReparentedHandler: got a ThresholdableService match for \" + event.getInterface());\n\n                        // Retrieve the ThresholderUpdates object associated\n                        // with this ThresholdableService.\n                        ThresholderUpdates updates = tSvc.getThresholderUpdates();\n\n                        // Now set the reparenting flag\n                        updates.markForReparenting(oldNodeIdStr, newNodeIdStr);\n                        if (log.isDebugEnabled())\n                            log.debug(\"interfaceReparentedHandler: marking \" + event.getInterface() + \" for reparenting for service SNMP.\");\n                    }\n                }\n            }\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"interfaceReparentedHandler: processing of interfaceReparented event for interface \" + event.getInterface() + \" completed.\");\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for handling nodeDeleted events.\n     * \n     * @param event\n     *            The event to process.\n     * \n     */\n    private void nodeDeletedHandler(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        int nodeId = (int) event.getNodeid();\n\n        // Iterate over the collectable service list and mark any entries\n        // which match the deleted nodeId for deletion.\n        synchronized (m_thresholdableServices) {\n            ThresholdableService tSvc = null;\n            ListIterator liter = m_thresholdableServices.listIterator();\n            while (liter.hasNext()) {\n                tSvc = (ThresholdableService) liter.next();\n\n                // Only interested in entries with matching nodeId\n                if (!(tSvc.getNodeId() == nodeId))\n                    continue;\n\n                synchronized (tSvc) {\n                    // Retrieve the ThresholderUpdates object associated\n                    // with this ThresholdableService.\n                    ThresholderUpdates updates = tSvc.getThresholderUpdates();\n\n                    // Now set the update's deletion flag so the next\n                    // time it is selected for execution by the scheduler\n                    // the thresholding will be skipped and the service will not\n                    // be rescheduled.\n                    updates.markForDeletion();\n                }\n\n                // Now safe to remove the collectable service from\n                // the collectable services list\n                liter.remove();\n            }\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"nodeDeletedHandler: processing of nodeDeleted event for nodeid \" + nodeId + \" completed.\");\n    }","id":92566,"modified_method":"/**\n     * This method is responsible for handling nodeDeleted events.\n     * \n     * @param event\n     *            The event to process.\n     * \n     */\n    private void nodeDeletedHandler(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        int nodeId = (int) event.getNodeid();\n\n        // Iterate over the collectable service list and mark any entries\n        // which match the deleted nodeId for deletion.\n        synchronized (m_thresholdableServices) {\n            ThresholdableService tSvc = null;\n            ListIterator<ThresholdableService> liter = m_thresholdableServices.listIterator();\n            while (liter.hasNext()) {\n                tSvc = liter.next();\n\n                // Only interested in entries with matching nodeId\n                if (!(tSvc.getNodeId() == nodeId))\n                    continue;\n\n                synchronized (tSvc) {\n                    // Retrieve the ThresholderUpdates object associated\n                    // with this ThresholdableService.\n                    ThresholderUpdates updates = tSvc.getThresholderUpdates();\n\n                    // Now set the update's deletion flag so the next\n                    // time it is selected for execution by the scheduler\n                    // the thresholding will be skipped and the service will not\n                    // be rescheduled.\n                    updates.markForDeletion();\n                }\n\n                // Now safe to remove the collectable service from\n                // the collectable services list\n                liter.remove();\n            }\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"nodeDeletedHandler: processing of nodeDeleted event for nodeid \" + nodeId + \" completed.\");\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for handling interfaceDeleted events.\n     * \n     * @param event\n     *            The event to process.\n     * \n     */\n    private void interfaceDeletedHandler(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        int nodeId = (int) event.getNodeid();\n        String ipAddr = event.getInterface();\n\n        // Iterate over the collectable services list and mark any entries\n        // which match the deleted nodeId/IP address pair for deletion\n        synchronized (m_thresholdableServices) {\n            ThresholdableService tSvc = null;\n            ListIterator liter = m_thresholdableServices.listIterator();\n            while (liter.hasNext()) {\n                tSvc = (ThresholdableService) liter.next();\n\n                // Only interested in entries with matching nodeId and IP\n                // address\n                InetAddress addr = (InetAddress) tSvc.getAddress();\n                if (!(tSvc.getNodeId() == nodeId && addr.getHostName().equals(ipAddr)))\n                    continue;\n\n                synchronized (tSvc) {\n                    // Retrieve the ThresholderUpdates object associated with\n                    // this ThresholdableService if one exists.\n                    ThresholderUpdates updates = tSvc.getThresholderUpdates();\n\n                    // Now set the update's deletion flag so the next\n                    // time it is selected for execution by the scheduler\n                    // the thresholding will be skipped and the service will not\n                    // be rescheduled.\n                    updates.markForDeletion();\n                }\n\n                // Now safe to remove the collectable service from\n                // the collectable services list\n                liter.remove();\n            }\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"interfaceDeletedHandler: processing of interfaceDeleted event for \" + nodeId + \"/\" + ipAddr + \" completed.\");\n    }","id":92567,"modified_method":"/**\n     * This method is responsible for handling interfaceDeleted events.\n     * \n     * @param event\n     *            The event to process.\n     * \n     */\n    private void interfaceDeletedHandler(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        int nodeId = (int) event.getNodeid();\n        String ipAddr = event.getInterface();\n\n        // Iterate over the collectable services list and mark any entries\n        // which match the deleted nodeId/IP address pair for deletion\n        synchronized (m_thresholdableServices) {\n            ThresholdableService tSvc = null;\n            ListIterator<ThresholdableService> liter = m_thresholdableServices.listIterator();\n            while (liter.hasNext()) {\n                tSvc = liter.next();\n\n                // Only interested in entries with matching nodeId and IP\n                // address\n                InetAddress addr = (InetAddress) tSvc.getAddress();\n                if (!(tSvc.getNodeId() == nodeId && addr.getHostName().equals(ipAddr)))\n                    continue;\n\n                synchronized (tSvc) {\n                    // Retrieve the ThresholderUpdates object associated with\n                    // this ThresholdableService if one exists.\n                    ThresholderUpdates updates = tSvc.getThresholderUpdates();\n\n                    // Now set the update's deletion flag so the next\n                    // time it is selected for execution by the scheduler\n                    // the thresholding will be skipped and the service will not\n                    // be rescheduled.\n                    updates.markForDeletion();\n                }\n\n                // Now safe to remove the collectable service from\n                // the collectable services list\n                liter.remove();\n            }\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"interfaceDeletedHandler: processing of interfaceDeleted event for \" + nodeId + \"/\" + ipAddr + \" completed.\");\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Delete a categorygroup.\n     * \n     * @param groupname\n     *            category group to be removed\n     * \n     * @return true if categorygroup is successfully deleted\n     */\n    public synchronized boolean deleteCategoryGroup(String groupname) {\n        boolean deleted = false;\n\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = (Categorygroup) enumCG.nextElement();\n            if (cg.getName().equals(groupname)) {\n                deleted = m_config.removeCategorygroup(cg);\n\n                // make sure you break from the enumeration\n                break;\n            }\n        }\n\n        return deleted;\n    }","id":92568,"modified_method":"/**\n     * Delete a categorygroup.\n     * \n     * @param groupname\n     *            category group to be removed\n     * \n     * @return true if categorygroup is successfully deleted\n     */\n    public synchronized boolean deleteCategoryGroup(String groupname) {\n        boolean deleted = false;\n\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = enumCG.nextElement();\n            if (cg.getName().equals(groupname)) {\n                deleted = m_config.removeCategorygroup(cg);\n\n                // make sure you break from the enumeration\n                break;\n            }\n        }\n\n        return deleted;\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return the warning value for the specified category.\n     * \n     * @param catlabel\n     *            the label for the category whose warning value is needed\n     * \n     * @return the warning value for the specified category, -1 if category is\n     *         not found\n     */\n    public synchronized double getWarning(String catlabel) {\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = (Categorygroup) enumCG.nextElement();\n\n            // go through the categories\n            Categories cats = cg.getCategories();\n\n            Enumeration<Category> enumCat = cats.enumerateCategory();\n            while (enumCat.hasMoreElements()) {\n                Category cat = (Category) enumCat.nextElement();\n                if (cat.getLabel().equals(catlabel)) {\n                    return cat.getWarning();\n                }\n            }\n        }\n\n        return -1.0;\n    }","id":92569,"modified_method":"/**\n     * Return the warning value for the specified category.\n     * \n     * @param catlabel\n     *            the label for the category whose warning value is needed\n     * \n     * @return the warning value for the specified category, -1 if category is\n     *         not found\n     */\n    public synchronized double getWarning(String catlabel) {\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = enumCG.nextElement();\n\n            // go through the categories\n            Categories cats = cg.getCategories();\n\n            Enumeration<Category> enumCat = cats.enumerateCategory();\n            while (enumCat.hasMoreElements()) {\n                Category cat = enumCat.nextElement();\n                if (cat.getLabel().equals(catlabel)) {\n                    return cat.getWarning();\n                }\n            }\n        }\n\n        return -1.0;\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Delete category from a categorygroup.\n     * \n     * @param groupname\n     *            category group from which category is to be removed\n     * @param catlabel\n     *            label of the category to be deleted\n     * \n     * @return true if category is successfully deleted from the specified\n     *         category group\n     */\n    public synchronized boolean deleteCategory(String groupname, String catlabel) {\n        boolean deleted = false;\n\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = (Categorygroup) enumCG.nextElement();\n            if (cg.getName().equals(groupname)) {\n                // get categories and delete\n                Categories cats = cg.getCategories();\n\n                Enumeration<Category> enumCat = cats.enumerateCategory();\n                while (enumCat.hasMoreElements()) {\n                    Category cat = (Category) enumCat.nextElement();\n                    if (cat.getLabel().equals(catlabel)) {\n                        cats.removeCategory(cat);\n\n                        // make sure you break from the enumeration\n                        deleted = true;\n                        break;\n                    }\n                }\n\n            }\n        }\n\n        return deleted;\n    }","id":92570,"modified_method":"/**\n     * Delete category from a categorygroup.\n     * \n     * @param groupname\n     *            category group from which category is to be removed\n     * @param catlabel\n     *            label of the category to be deleted\n     * \n     * @return true if category is successfully deleted from the specified\n     *         category group\n     */\n    public synchronized boolean deleteCategory(String groupname, String catlabel) {\n        boolean deleted = false;\n\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = enumCG.nextElement();\n            if (cg.getName().equals(groupname)) {\n                // get categories and delete\n                Categories cats = cg.getCategories();\n\n                Enumeration<Category> enumCat = cats.enumerateCategory();\n                while (enumCat.hasMoreElements()) {\n                    Category cat = enumCat.nextElement();\n                    if (cat.getLabel().equals(catlabel)) {\n                        cats.removeCategory(cat);\n\n                        // make sure you break from the enumeration\n                        deleted = true;\n                        break;\n                    }\n                }\n\n            }\n        }\n\n        return deleted;\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Delete category from a categorygroup.\n     * \n     * @param groupname\n     *            category group from which category is to be removed\n     * @param cat\n     *            category to be deleted\n     * \n     * @return true if category is successfully deleted from the specified\n     *         category group\n     */\n    public synchronized boolean deleteCategory(String groupname, Category cat) {\n        boolean deleted = false;\n\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = (Categorygroup) enumCG.nextElement();\n            if (cg.getName().equals(groupname)) {\n                // get categories and delete\n                Categories cats = cg.getCategories();\n                cats.removeCategory(cat);\n\n                deleted = true;\n                break;\n            }\n        }\n\n        return deleted;\n    }","id":92571,"modified_method":"/**\n     * Delete category from a categorygroup.\n     * \n     * @param groupname\n     *            category group from which category is to be removed\n     * @param cat\n     *            category to be deleted\n     * \n     * @return true if category is successfully deleted from the specified\n     *         category group\n     */\n    public synchronized boolean deleteCategory(String groupname, Category cat) {\n        boolean deleted = false;\n\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = enumCG.nextElement();\n            if (cg.getName().equals(groupname)) {\n                // get categories and delete\n                Categories cats = cg.getCategories();\n                cats.removeCategory(cat);\n\n                deleted = true;\n                break;\n            }\n        }\n\n        return deleted;\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Replace category in a categorygroup.\n     * \n     * @param groupname\n     *            category group to which category is to be added\n     * @param cat\n     *            category to be replaced\n     * \n     * @return true if category is successfully replaced in the specified\n     *         category group\n     */\n    public synchronized boolean replaceCategory(String groupname, Category cat) {\n        boolean replaced = false;\n\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = (Categorygroup) enumCG.nextElement();\n            if (cg.getName().equals(groupname)) {\n                String catlabel = cat.getLabel();\n\n                // get categories and replace\n                Categories cats = cg.getCategories();\n\n                int numCats = cats.getCategoryCount();\n                for (int i = 0; i < numCats; i++) {\n                    Category oldCat = cats.getCategory(i);\n                    if (oldCat.getLabel().equals(catlabel)) {\n                        cats.setCategory(i, cat);\n                        replaced = true;\n                        break;\n                    }\n                }\n\n            }\n        }\n\n        return replaced;\n    }","id":92572,"modified_method":"/**\n     * Replace category in a categorygroup.\n     * \n     * @param groupname\n     *            category group to which category is to be added\n     * @param cat\n     *            category to be replaced\n     * \n     * @return true if category is successfully replaced in the specified\n     *         category group\n     */\n    public synchronized boolean replaceCategory(String groupname, Category cat) {\n        boolean replaced = false;\n\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = enumCG.nextElement();\n            if (cg.getName().equals(groupname)) {\n                String catlabel = cat.getLabel();\n\n                // get categories and replace\n                Categories cats = cg.getCategories();\n\n                int numCats = cats.getCategoryCount();\n                for (int i = 0; i < numCats; i++) {\n                    Category oldCat = cats.getCategory(i);\n                    if (oldCat.getLabel().equals(catlabel)) {\n                        cats.setCategory(i, cat);\n                        replaced = true;\n                        break;\n                    }\n                }\n\n            }\n        }\n\n        return replaced;\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Add category to a categorygroup.\n     * \n     * @param groupname\n     *            category group to which category is to be added\n     * @param cat\n     *            category to be added\n     * \n     * @return true if category is successfully added to the specified category\n     *         group\n     */\n    public synchronized boolean addCategory(String groupname, Category cat) {\n        boolean added = false;\n\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = (Categorygroup) enumCG.nextElement();\n            if (cg.getName().equals(groupname)) {\n                // get categories and add\n                Categories cats = cg.getCategories();\n                cats.addCategory(cat);\n\n                added = true;\n                break;\n            }\n        }\n\n        return added;\n    }","id":92573,"modified_method":"/**\n     * Add category to a categorygroup.\n     * \n     * @param groupname\n     *            category group to which category is to be added\n     * @param cat\n     *            category to be added\n     * \n     * @return true if category is successfully added to the specified category\n     *         group\n     */\n    public synchronized boolean addCategory(String groupname, Category cat) {\n        boolean added = false;\n\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = enumCG.nextElement();\n            if (cg.getName().equals(groupname)) {\n                // get categories and add\n                Categories cats = cg.getCategories();\n                cats.addCategory(cat);\n\n                added = true;\n                break;\n            }\n        }\n\n        return added;\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return the category specified by name.\n     * \n     * @return the category specified by name, null if not found\n     */\n    public synchronized Category getCategory(String name) {\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = (Categorygroup) enumCG.nextElement();\n\n            // go through the categories\n            Categories cats = cg.getCategories();\n\n            Enumeration<Category> enumCat = cats.enumerateCategory();\n            while (enumCat.hasMoreElements()) {\n                Category cat = (Category) enumCat.nextElement();\n                if (cat.getLabel().equals(name)) {\n                    return cat;\n                }\n            }\n        }\n\n        return null;\n    }","id":92574,"modified_method":"/**\n     * Return the category specified by name.\n     * \n     * @return the category specified by name, null if not found\n     */\n    public synchronized Category getCategory(String name) {\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = enumCG.nextElement();\n\n            // go through the categories\n            Categories cats = cg.getCategories();\n\n            Enumeration<Category> enumCat = cats.enumerateCategory();\n            while (enumCat.hasMoreElements()) {\n                Category cat = enumCat.nextElement();\n                if (cat.getLabel().equals(name)) {\n                    return cat;\n                }\n            }\n        }\n\n        return null;\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return the normal value for the specified category.\n     * \n     * @param catlabel\n     *            the label for the category whose normal value is needed\n     * \n     * @return the normal value for the specified category, -1 if category is\n     *         not found\n     */\n    public synchronized double getNormal(String catlabel) {\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = (Categorygroup) enumCG.nextElement();\n\n            // go through the categories\n            Categories cats = cg.getCategories();\n\n            Enumeration<Category> enumCat = cats.enumerateCategory();\n            while (enumCat.hasMoreElements()) {\n                Category cat = (Category) enumCat.nextElement();\n                if (cat.getLabel().equals(catlabel)) {\n                    return cat.getNormal();\n                }\n            }\n        }\n\n        return -1.0;\n    }","id":92575,"modified_method":"/**\n     * Return the normal value for the specified category.\n     * \n     * @param catlabel\n     *            the label for the category whose normal value is needed\n     * \n     * @return the normal value for the specified category, -1 if category is\n     *         not found\n     */\n    public synchronized double getNormal(String catlabel) {\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = enumCG.nextElement();\n\n            // go through the categories\n            Categories cats = cg.getCategories();\n\n            Enumeration<Category> enumCat = cats.enumerateCategory();\n            while (enumCat.hasMoreElements()) {\n                Category cat = enumCat.nextElement();\n                if (cat.getLabel().equals(catlabel)) {\n                    return cat.getNormal();\n                }\n            }\n        }\n\n        return -1.0;\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return the effective rule for the specified category. The category rule\n     * ANDed with the rule of the category group that the category belongs to.\n     * \n     * @param catlabel\n     *            the label for the category whose effective rule is needed\n     * \n     * @return the effective rule for the specified category, null if the\n     *         category is not found\n     */\n    public synchronized String getEffectiveRule(String catlabel) {\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = (Categorygroup) enumCG.nextElement();\n\n            // go through the categories\n            Categories cats = cg.getCategories();\n\n            Enumeration<Category> enumCat = cats.enumerateCategory();\n            while (enumCat.hasMoreElements()) {\n                Category cat = (Category) enumCat.nextElement();\n                if (cat.getLabel().equals(catlabel)) {\n                    String catRule = \"(\" + cg.getCommon().getRule() + \") & (\" + cat.getRule() + \")\";\n                    return catRule;\n                }\n            }\n        }\n\n        return null;\n    }","id":92576,"modified_method":"/**\n     * Return the effective rule for the specified category. The category rule\n     * ANDed with the rule of the category group that the category belongs to.\n     * \n     * @param catlabel\n     *            the label for the category whose effective rule is needed\n     * \n     * @return the effective rule for the specified category, null if the\n     *         category is not found\n     */\n    public synchronized String getEffectiveRule(String catlabel) {\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = enumCG.nextElement();\n\n            // go through the categories\n            Categories cats = cg.getCategories();\n\n            Enumeration<Category> enumCat = cats.enumerateCategory();\n            while (enumCat.hasMoreElements()) {\n                Category cat = enumCat.nextElement();\n                if (cat.getLabel().equals(catlabel)) {\n                    String catRule = \"(\" + cg.getCommon().getRule() + \") & (\" + cat.getRule() + \")\";\n                    return catRule;\n                }\n            }\n        }\n\n        return null;\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return the services list for the specified category.\n     * \n     * @param catlabel\n     *            the label for the category whose services list is needed\n     * \n     * @return the services list for the specified category, null if category is\n     *         not found\n     */\n    public synchronized String[] getServices(String catlabel) {\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = (Categorygroup) enumCG.nextElement();\n\n            // go through the categories\n            Categories cats = cg.getCategories();\n\n            Enumeration<Category> enumCat = cats.enumerateCategory();\n            while (enumCat.hasMoreElements()) {\n                Category cat = (Category) enumCat.nextElement();\n                if (cat.getLabel().equals(catlabel)) {\n                    return cat.getService();\n                }\n            }\n        }\n\n        return null;\n    }","id":92577,"modified_method":"/**\n     * Return the services list for the specified category.\n     * \n     * @param catlabel\n     *            the label for the category whose services list is needed\n     * \n     * @return the services list for the specified category, null if category is\n     *         not found\n     */\n    public synchronized String[] getServices(String catlabel) {\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = enumCG.nextElement();\n\n            // go through the categories\n            Categories cats = cg.getCategories();\n\n            Enumeration<Category> enumCat = cats.enumerateCategory();\n            while (enumCat.hasMoreElements()) {\n                Category cat = enumCat.nextElement();\n                if (cat.getLabel().equals(catlabel)) {\n                    return cat.getService();\n                }\n            }\n        }\n\n        return null;\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return the rule for the specified category.\n     * \n     * @param catlabel\n     *            the label for the category whose services list is needed\n     * \n     * @return the rule for the specified category, null if the category is not\n     *         found\n     */\n    public synchronized String getRule(String catlabel) {\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = (Categorygroup) enumCG.nextElement();\n\n            // go through the categories\n            Categories cats = cg.getCategories();\n\n            Enumeration<Category> enumCat = cats.enumerateCategory();\n            while (enumCat.hasMoreElements()) {\n                Category cat = (Category) enumCat.nextElement();\n                if (cat.getLabel().equals(catlabel)) {\n                    return cat.getRule();\n                }\n            }\n        }\n\n        return null;\n    }","id":92578,"modified_method":"/**\n     * Return the rule for the specified category.\n     * \n     * @param catlabel\n     *            the label for the category whose services list is needed\n     * \n     * @return the rule for the specified category, null if the category is not\n     *         found\n     */\n    public synchronized String getRule(String catlabel) {\n        Enumeration<Categorygroup> enumCG = m_config.enumerateCategorygroup();\n        while (enumCG.hasMoreElements()) {\n            Categorygroup cg = enumCG.nextElement();\n\n            // go through the categories\n            Categories cats = cg.getCategories();\n\n            Enumeration<Category> enumCat = cats.enumerateCategory();\n            while (enumCat.hasMoreElements()) {\n                Category cat = enumCat.nextElement();\n                if (cat.getLabel().equals(catlabel)) {\n                    return cat.getRule();\n                }\n            }\n        }\n\n        return null;\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     */\n    public Notification getNotification(final String name) throws IOException, MarshalException, ValidationException {\n        update();\n    \n        return (Notification) getNotifications().get(name);\n    }","id":92579,"modified_method":"/**\n     */\n    public Notification getNotification(final String name) throws IOException, MarshalException, ValidationException {\n        update();\n    \n        return getNotifications().get(name);\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method inserts a row into the notifications table in the database.\n     * This row indicates that the page has been sent out.\n     * @param queueID\n     * @param notification TODO\n     */\n    public void insertNotice(final int notifyId, final Map<String, String> params, final String queueID, final Notification notification) throws SQLException {\n        Connection connection = null;\n        final DBUtils d = new DBUtils(getClass());\n        try {\n            connection = getConnection();\n            d.watch(connection);\n            final PreparedStatement statement = connection.prepareStatement(\"INSERT INTO notifications (\" +\n                    \"textmsg, numericmsg, notifyid, pagetime, nodeid, interfaceid, serviceid, eventid, \" +\n                    \"eventuei, subject, queueID, notifConfigName) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\");\n            d.watch(statement);\n    \n            // notifications textMsg field\n            String textMsg = (String) params.get(NotificationManager.PARAM_TEXT_MSG);\n            if (textMsg != null && textMsg.length() > 4000) {\n                log().warn(\"textmsg too long, it will be truncated\");\n                textMsg = textMsg.substring(0, 4000);\n            }\n            statement.setString(1, textMsg);\n    \n            // notifications numericMsg field\n            String numMsg = (String) params.get(NotificationManager.PARAM_NUM_MSG);\n            if (numMsg != null && numMsg.length() > 256) {\n                log().warn(\"numericmsg too long, it will be truncated\");\n                numMsg = numMsg.substring(0, 256);\n            }\n            statement.setString(2, numMsg);\n    \n            // notifications notifyID field\n            statement.setInt(3, notifyId);\n    \n            // notifications pageTime field\n            statement.setTimestamp(4, new Timestamp((new Date()).getTime()));\n    \n            // notifications nodeID field\n            String node = (String) params.get(NotificationManager.PARAM_NODE);\n            if (node != null && !node.trim().equals(\"\") && !node.toLowerCase().equals(\"null\") && !node.toLowerCase().equals(\"%nodeid%\")) {\n                statement.setInt(5, Integer.parseInt(node));\n            } else {\n                statement.setNull(5, Types.INTEGER);\n            }\n    \n            // notifications interfaceID field\n            String ipaddr = (String) params.get(NotificationManager.PARAM_INTERFACE);\n            if (ipaddr != null && !ipaddr.trim().equals(\"\") && !ipaddr.toLowerCase().equals(\"null\") && !ipaddr.toLowerCase().equals(\"%interface%\")) {\n                statement.setString(6, ipaddr);\n            } else {\n                statement.setString(6, null);\n            }\n    \n            // notifications serviceID field\n            String service = (String) params.get(NotificationManager.PARAM_SERVICE);\n            if (service != null && !service.trim().equals(\"\") && !service.toLowerCase().equals(\"null\") && !service.toLowerCase().equals(\"%service%\")) {\n                statement.setInt(7, getServiceId(service));\n            } else {\n                statement.setNull(7, Types.INTEGER);\n            }\n    \n            // eventID field\n            final String eventID = (String) params.get(\"eventID\");\n            statement.setInt(8, Integer.parseInt(eventID));\n    \n            statement.setString(9, (String) params.get(\"eventUEI\"));\n            \n            // notifications subject field\n            statement.setString(10, (String) params.get(NotificationManager.PARAM_SUBJECT));\n            \n            // the queue this will be sent on\n            statement.setString(11, queueID);\n            \n            statement.setString(12, notification.getName());\n    \n            statement.executeUpdate();\n        } finally {\n            d.cleanUp();\n        }\n    }","id":92580,"modified_method":"/**\n     * This method inserts a row into the notifications table in the database.\n     * This row indicates that the page has been sent out.\n     * @param queueID\n     * @param notification TODO\n     */\n    public void insertNotice(final int notifyId, final Map<String, String> params, final String queueID, final Notification notification) throws SQLException {\n        Connection connection = null;\n        final DBUtils d = new DBUtils(getClass());\n        try {\n            connection = getConnection();\n            d.watch(connection);\n            final PreparedStatement statement = connection.prepareStatement(\"INSERT INTO notifications (\" +\n                    \"textmsg, numericmsg, notifyid, pagetime, nodeid, interfaceid, serviceid, eventid, \" +\n                    \"eventuei, subject, queueID, notifConfigName) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\");\n            d.watch(statement);\n    \n            // notifications textMsg field\n            String textMsg = params.get(NotificationManager.PARAM_TEXT_MSG);\n            if (textMsg != null && textMsg.length() > 4000) {\n                log().warn(\"textmsg too long, it will be truncated\");\n                textMsg = textMsg.substring(0, 4000);\n            }\n            statement.setString(1, textMsg);\n    \n            // notifications numericMsg field\n            String numMsg = params.get(NotificationManager.PARAM_NUM_MSG);\n            if (numMsg != null && numMsg.length() > 256) {\n                log().warn(\"numericmsg too long, it will be truncated\");\n                numMsg = numMsg.substring(0, 256);\n            }\n            statement.setString(2, numMsg);\n    \n            // notifications notifyID field\n            statement.setInt(3, notifyId);\n    \n            // notifications pageTime field\n            statement.setTimestamp(4, new Timestamp((new Date()).getTime()));\n    \n            // notifications nodeID field\n            String node = params.get(NotificationManager.PARAM_NODE);\n            if (node != null && !node.trim().equals(\"\") && !node.toLowerCase().equals(\"null\") && !node.toLowerCase().equals(\"%nodeid%\")) {\n                statement.setInt(5, Integer.parseInt(node));\n            } else {\n                statement.setNull(5, Types.INTEGER);\n            }\n    \n            // notifications interfaceID field\n            String ipaddr = params.get(NotificationManager.PARAM_INTERFACE);\n            if (ipaddr != null && !ipaddr.trim().equals(\"\") && !ipaddr.toLowerCase().equals(\"null\") && !ipaddr.toLowerCase().equals(\"%interface%\")) {\n                statement.setString(6, ipaddr);\n            } else {\n                statement.setString(6, null);\n            }\n    \n            // notifications serviceID field\n            String service = params.get(NotificationManager.PARAM_SERVICE);\n            if (service != null && !service.trim().equals(\"\") && !service.toLowerCase().equals(\"null\") && !service.toLowerCase().equals(\"%service%\")) {\n                statement.setInt(7, getServiceId(service));\n            } else {\n                statement.setNull(7, Types.INTEGER);\n            }\n    \n            // eventID field\n            final String eventID = params.get(\"eventID\");\n            statement.setInt(8, Integer.parseInt(eventID));\n    \n            statement.setString(9, params.get(\"eventUEI\"));\n            \n            // notifications subject field\n            statement.setString(10, params.get(NotificationManager.PARAM_SUBJECT));\n            \n            // the queue this will be sent on\n            statement.setString(11, queueID);\n            \n            statement.setString(12, notification.getName());\n    \n            statement.executeUpdate();\n        } finally {\n            d.cleanUp();\n        }\n    }","commit_id":"1cdf2c436d20d94e4e040142a50d251962cda309","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n   * Appends the metadata and closes the writer.\n   * @param writer The current store writer.\n   * @param fd The file details.\n   * @param isMajor Is a major compaction.\n   * @throws IOException\n   */\n  protected void appendMetadataAndCloseWriter(StoreFile.Writer writer, FileDetails fd,\n      boolean isMajor) throws IOException {\n    writer.appendMetadata(fd.maxSeqId, isMajor);\n    writer.close();\n  }","id":92581,"modified_method":"/**\n   * Creates a writer for a new file in a temporary directory.\n   * @param fd The file details.\n   * @return Writer for a new StoreFile in the tmp dir.\n   * @throws IOException if creation failed\n   */\n  protected Writer createTmpWriter(FileDetails fd, boolean shouldDropBehind) throws IOException {\n    // When all MVCC readpoints are 0, don't write them.\n    // See HBASE-8166, HBASE-12600, and HBASE-13389.\n    return store.createWriterInTmp(fd.maxKeyCount, this.compactionCompression,\n    /* isCompaction = */true,\n    /* includeMVCCReadpoint = */fd.maxMVCCReadpoint > 0,\n    /* includesTags = */fd.maxTagsLength > 0, shouldDropBehind);\n  }","commit_id":"f7d44e929fd2a8dac5f15c50c2eea1d448e92eb7","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  protected List<Path> commitMultiWriter(DateTieredMultiFileWriter writer, FileDetails fd,\n      CompactionRequest request) throws IOException {\n    return writer.commitWriters(fd.maxSeqId, request.isAllFiles());\n  }","id":92582,"modified_method":"@Override\n  protected List<Path> commitWriter(DateTieredMultiFileWriter writer, FileDetails fd,\n      CompactionRequest request) throws IOException {\n    return writer.commitWriters(fd.maxSeqId, request.isAllFiles());\n  }","commit_id":"f7d44e929fd2a8dac5f15c50c2eea1d448e92eb7","url":"https://github.com/apache/hbase"},{"original_method":"public List<Path> compact(final CompactionRequest request, List<Long> lowerBoundaries,\n      ThroughputController throughputController, User user) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Executing compaction with \" + lowerBoundaries.size()\n          + \"windows, lower boundaries: \" + lowerBoundaries);\n    }\n\n    DateTieredMultiFileWriter writer =\n        new DateTieredMultiFileWriter(lowerBoundaries, needEmptyFile(request));\n    return compact(writer, request, new InternalScannerFactory() {\n\n      @Override\n      public ScanType getScanType(CompactionRequest request) {\n        return request.isRetainDeleteMarkers() ? ScanType.COMPACT_RETAIN_DELETES\n            : ScanType.COMPACT_DROP_DELETES;\n      }\n\n      @Override\n      public InternalScanner createScanner(List<StoreFileScanner> scanners, ScanType scanType,\n          FileDetails fd, long smallestReadPoint) throws IOException {\n        return DateTieredCompactor.this.createScanner(store, scanners, scanType, smallestReadPoint,\n          fd.earliestPutTs);\n      }\n    }, throughputController, user);\n  }","id":92583,"modified_method":"public List<Path> compact(final CompactionRequest request, final List<Long> lowerBoundaries,\n      ThroughputController throughputController, User user) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Executing compaction with \" + lowerBoundaries.size()\n          + \"windows, lower boundaries: \" + lowerBoundaries);\n    }\n\n    return compact(request, defaultScannerFactory,\n      new CellSinkFactory<DateTieredMultiFileWriter>() {\n\n        @Override\n        public DateTieredMultiFileWriter createWriter(InternalScanner scanner, FileDetails fd,\n            boolean shouldDropBehind) throws IOException {\n          DateTieredMultiFileWriter writer = new DateTieredMultiFileWriter(lowerBoundaries,\n              needEmptyFile(request));\n          initMultiWriter(writer, scanner, fd, shouldDropBehind);\n          return writer;\n        }\n      }, throughputController, user);\n  }","commit_id":"f7d44e929fd2a8dac5f15c50c2eea1d448e92eb7","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Do a minor/major compaction on an explicit set of storefiles from a Store.\n   */\n  public List<Path> compact(final CompactionRequest request,\n      ThroughputController throughputController, User user) throws IOException {\n    FileDetails fd = getFileDetails(request.getFiles(), request.isAllFiles());\n    this.progress = new CompactionProgress(fd.maxKeyCount);\n\n    // Find the smallest read point across all the Scanners.\n    long smallestReadPoint = getSmallestReadPoint();\n\n    List<StoreFileScanner> scanners;\n    Collection<StoreFile> readersToClose;\n    if (this.conf.getBoolean(\"hbase.regionserver.compaction.private.readers\", true)) {\n      // clone all StoreFiles, so we'll do the compaction on a independent copy of StoreFiles,\n      // HFiles, and their readers\n      readersToClose = new ArrayList<StoreFile>(request.getFiles().size());\n      for (StoreFile f : request.getFiles()) {\n        readersToClose.add(f.cloneForReader());\n      }\n      scanners = createFileScanners(readersToClose, smallestReadPoint,\n          store.throttleCompaction(request.getSize()));\n    } else {\n      readersToClose = Collections.emptyList();\n      scanners = createFileScanners(request.getFiles(), smallestReadPoint,\n          store.throttleCompaction(request.getSize()));\n    }\n\n    StoreFile.Writer writer = null;\n    List<Path> newFiles = new ArrayList<Path>();\n    boolean cleanSeqId = false;\n    IOException e = null;\n    try {\n      InternalScanner scanner = null;\n      try {\n        /* Include deletes, unless we are doing a compaction of all files */\n          ScanType scanType =\n                  request.isRetainDeleteMarkers() ?\n                          ScanType.COMPACT_RETAIN_DELETES :\n                          ScanType.COMPACT_DROP_DELETES;\n        scanner = preCreateCoprocScanner(request, scanType, fd.earliestPutTs, scanners, user);\n        if (scanner == null) {\n          scanner = createScanner(store, scanners, scanType, smallestReadPoint, fd.earliestPutTs);\n        }\n        scanner = postCreateCoprocScanner(request, scanType, scanner, user);\n        if (scanner == null) {\n          // NULL scanner returned from coprocessor hooks means skip normal processing.\n          return newFiles;\n        }\n        // Create the writer even if no kv(Empty store file is also ok),\n        // because we need record the max seq id for the store file, see HBASE-6059\n        if(fd.minSeqIdToKeep > 0) {\n          smallestReadPoint = Math.min(fd.minSeqIdToKeep, smallestReadPoint);\n          cleanSeqId = true;\n        }\n\n\n        writer = createTmpWriter(fd, store.throttleCompaction(request.getSize()));\n        boolean finished = performCompaction(fd, scanner, writer, smallestReadPoint, cleanSeqId,\n          throughputController, request.isAllFiles());\n\n        if (!finished) {\n          writer.close();\n          store.getFileSystem().delete(writer.getPath(), false);\n          writer = null;\n          throw new InterruptedIOException(\"Aborting compaction of store \" + store +\n              \" in region \" + store.getRegionInfo().getRegionNameAsString() +\n              \" because it was interrupted.\");\n         }\n       } finally {\n         if (scanner != null) {\n           scanner.close();\n         }\n      }\n    } catch (IOException ioe) {\n      e = ioe;\n      // Throw the exception\n      throw ioe;\n    }\n    finally {\n      try {\n        if (writer != null) {\n          if (e != null) {\n            writer.close();\n          } else {\n            writer.appendMetadata(fd.maxSeqId, request.isAllFiles());\n            writer.close();\n            newFiles.add(writer.getPath());\n          }\n        }\n      } finally {\n        for (StoreFile f : readersToClose) {\n          try {\n            f.closeReader(true);\n          } catch (IOException ioe) {\n            LOG.warn(\"Exception closing \" + f, ioe);\n          }\n        }\n      }\n    }\n    return newFiles;\n  }","id":92584,"modified_method":"/**\n   * Do a minor/major compaction on an explicit set of storefiles from a Store.\n   */\n  public List<Path> compact(final CompactionRequest request,\n      ThroughputController throughputController, User user) throws IOException {\n    return compact(request, defaultScannerFactory, writerFactory, throughputController, user);\n  }","commit_id":"f7d44e929fd2a8dac5f15c50c2eea1d448e92eb7","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Compact a list of files for testing. Creates a fake {@link CompactionRequest} to pass to\n   * {@link #compact(CompactionRequest, ThroughputController, User)};\n   * @param filesToCompact the files to compact. These are used as the compactionSelection for\n   *          the generated {@link CompactionRequest}.\n   * @param isMajor true to major compact (prune all deletes, max versions, etc)\n   * @return Product of compaction or an empty list if all cells expired or deleted and nothing \\\n   *         made it through the compaction.\n   * @throws IOException\n   */\n  public List<Path> compactForTesting(final Collection<StoreFile> filesToCompact, boolean isMajor)\n      throws IOException {\n    CompactionRequest cr = new CompactionRequest(filesToCompact);\n    cr.setIsMajor(isMajor, isMajor);\n    return this.compact(cr, NoLimitThroughputController.INSTANCE, null);\n  }","id":92585,"modified_method":"/**\n   * Compact a list of files for testing. Creates a fake {@link CompactionRequest} to pass to\n   * {@link #compact(CompactionRequest, ThroughputController, User)};\n   * @param filesToCompact the files to compact. These are used as the compactionSelection for the\n   *          generated {@link CompactionRequest}.\n   * @param isMajor true to major compact (prune all deletes, max versions, etc)\n   * @return Product of compaction or an empty list if all cells expired or deleted and nothing \\\n   *         made it through the compaction.\n   * @throws IOException\n   */\n  public List<Path> compactForTesting(final Collection<StoreFile> filesToCompact, boolean isMajor)\n      throws IOException {\n    CompactionRequest cr = new CompactionRequest(filesToCompact);\n    cr.setIsMajor(isMajor, isMajor);\n    return compact(cr, NoLimitThroughputController.INSTANCE, null);\n  }","commit_id":"f7d44e929fd2a8dac5f15c50c2eea1d448e92eb7","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Performs compaction on a column family with the mob flag enabled.\n   * This is for when the mob threshold size has changed or if the mob\n   * column family mode has been toggled via an alter table statement.\n   * Compacts the files by the following rules.\n   * 1. If the cell has a mob reference tag, the cell's value is the path of the mob file.\n   * <ol>\n   * <li>\n   * If the value size of a cell is larger than the threshold, this cell is regarded as a mob,\n   * directly copy the (with mob tag) cell into the new store file.\n   * <\/li>\n   * <li>\n   * Otherwise, retrieve the mob cell from the mob file, and writes a copy of the cell into\n   * the new store file.\n   * <\/li>\n   * <\/ol>\n   * 2. If the cell doesn't have a reference tag.\n   * <ol>\n   * <li>\n   * If the value size of a cell is larger than the threshold, this cell is regarded as a mob,\n   * write this cell to a mob file, and write the path of this mob file to the store file.\n   * <\/li>\n   * <li>\n   * Otherwise, directly write this cell into the store file.\n   * <\/li>\n   * <\/ol>\n   * In the mob compaction, the {@link MobCompactionStoreScanner} is used as a scanner\n   * which could output the normal cells and delete markers together when required.\n   * After the major compaction on the normal hfiles, we have a guarantee that we have purged all\n   * deleted or old version mob refs, and the delete markers are written to a del file with the\n   * suffix _del. Because of this, it is safe to use the del file in the mob compaction.\n   * The mob compaction doesn't take place in the normal hfiles, it occurs directly in the\n   * mob files. When the small mob files are merged into bigger ones, the del file is added into\n   * the scanner to filter the deleted cells.\n   * @param fd File details\n   * @param scanner Where to read from.\n   * @param writer Where to write to.\n   * @param smallestReadPoint Smallest read point.\n   * @param cleanSeqId When true, remove seqId(used to be mvcc) value which is <= smallestReadPoint\n   * @param throughputController The compaction throughput controller.\n   * @param major Is a major compaction.\n   * @return Whether compaction ended; false if it was interrupted for any reason.\n   */\n  @Override\n  protected boolean performCompaction(FileDetails fd, InternalScanner scanner, CellSink writer,\n      long smallestReadPoint, boolean cleanSeqId,\n      ThroughputController throughputController,  boolean major) throws IOException {\n    if (!(scanner instanceof MobCompactionStoreScanner)) {\n      throw new IllegalArgumentException(\n        \"The scanner should be an instance of MobCompactionStoreScanner\");\n    }\n    MobCompactionStoreScanner compactionScanner = (MobCompactionStoreScanner) scanner;\n    int bytesWritten = 0;\n    // Since scanner.next() can return 'false' but still be delivering data,\n    // we have to use a do/while loop.\n    List<Cell> cells = new ArrayList<Cell>();\n    // Limit to \"hbase.hstore.compaction.kv.max\" (default 10) to avoid OOME\n    int closeCheckInterval = HStore.getCloseCheckInterval();\n    boolean hasMore;\n    Path path = MobUtils.getMobFamilyPath(conf, store.getTableName(), store.getColumnFamilyName());\n    byte[] fileName = null;\n    StoreFile.Writer mobFileWriter = null, delFileWriter = null;\n    long mobCells = 0, deleteMarkersCount = 0;\n    Tag tableNameTag = new ArrayBackedTag(TagType.MOB_TABLE_NAME_TAG_TYPE,\n        store.getTableName().getName());\n    long cellsCountCompactedToMob = 0, cellsCountCompactedFromMob = 0;\n    long cellsSizeCompactedToMob = 0, cellsSizeCompactedFromMob = 0;\n    try {\n      try {\n        // If the mob file writer could not be created, directly write the cell to the store file.\n        mobFileWriter = mobStore.createWriterInTmp(new Date(fd.latestPutTs), fd.maxKeyCount,\n            store.getFamily().getCompression(), store.getRegionInfo().getStartKey());\n        fileName = Bytes.toBytes(mobFileWriter.getPath().getName());\n      } catch (IOException e) {\n        LOG.error(\"Failed to create mob writer, \"\n               + \"we will continue the compaction by writing MOB cells directly in store files\", e);\n      }\n      delFileWriter = mobStore.createDelFileWriterInTmp(new Date(fd.latestPutTs), fd.maxKeyCount,\n          store.getFamily().getCompression(), store.getRegionInfo().getStartKey());\n      ScannerContext scannerContext =\n              ScannerContext.newBuilder().setBatchLimit(compactionKVMax).build();\n      do {\n        hasMore = compactionScanner.next(cells, scannerContext);\n        for (Cell c : cells) {\n          if (compactionScanner.isOutputDeleteMarkers() && CellUtil.isDelete(c)) {\n            delFileWriter.append(c);\n            deleteMarkersCount++;\n          } else if (mobFileWriter == null || c.getTypeByte() != KeyValue.Type.Put.getCode()) {\n            // If the mob file writer is null or the kv type is not put, directly write the cell\n            // to the store file.\n            writer.append(c);\n          } else if (MobUtils.isMobReferenceCell(c)) {\n            if (MobUtils.hasValidMobRefCellValue(c)) {\n              int size = MobUtils.getMobValueLength(c);\n              if (size > mobSizeThreshold) {\n                // If the value size is larger than the threshold, it's regarded as a mob. Since\n                // its value is already in the mob file, directly write this cell to the store file\n                writer.append(c);\n              } else {\n                // If the value is not larger than the threshold, it's not regarded a mob. Retrieve\n                // the mob cell from the mob file, and write it back to the store file.\n                Cell mobCell = mobStore.resolve(c, false);\n                if (mobCell.getValueLength() != 0) {\n                  // put the mob data back to the store file\n                  CellUtil.setSequenceId(mobCell, c.getSequenceId());\n                  writer.append(mobCell);\n                  cellsCountCompactedFromMob++;\n                  cellsSizeCompactedFromMob += mobCell.getValueLength();\n                } else {\n                  // If the value of a file is empty, there might be issues when retrieving,\n                  // directly write the cell to the store file, and leave it to be handled by the\n                  // next compaction.\n                  writer.append(c);\n                }\n              }\n            } else {\n              LOG.warn(\"The value format of the KeyValue \" + c\n                  + \" is wrong, its length is less than \" + Bytes.SIZEOF_INT);\n              writer.append(c);\n            }\n          } else if (c.getValueLength() <= mobSizeThreshold) {\n            //If value size of a cell is not larger than the threshold, directly write to store file\n            writer.append(c);\n          } else {\n            // If the value size of a cell is larger than the threshold, it's regarded as a mob,\n            // write this cell to a mob file, and write the path to the store file.\n            mobCells++;\n            // append the original keyValue in the mob file.\n            mobFileWriter.append(c);\n            KeyValue reference = MobUtils.createMobRefKeyValue(c, fileName, tableNameTag);\n            // write the cell whose value is the path of a mob file to the store file.\n            writer.append(reference);\n            cellsCountCompactedToMob++;\n            cellsSizeCompactedToMob += c.getValueLength();\n          }\n          ++progress.currentCompactedKVs;\n          // check periodically to see if a system stop is requested\n          if (closeCheckInterval > 0) {\n            bytesWritten += KeyValueUtil.length(c);\n            if (bytesWritten > closeCheckInterval) {\n              bytesWritten = 0;\n              if (!store.areWritesEnabled()) {\n                progress.cancel();\n                return false;\n              }\n            }\n          }\n        }\n        cells.clear();\n      } while (hasMore);\n    } finally {\n      if (mobFileWriter != null) {\n        mobFileWriter.appendMetadata(fd.maxSeqId, major, mobCells);\n        mobFileWriter.close();\n      }\n      if (delFileWriter != null) {\n        delFileWriter.appendMetadata(fd.maxSeqId, major, deleteMarkersCount);\n        delFileWriter.close();\n      }\n    }\n    if (mobFileWriter != null) {\n      if (mobCells > 0) {\n        // If the mob file is not empty, commit it.\n        mobStore.commitFile(mobFileWriter.getPath(), path);\n      } else {\n        try {\n          // If the mob file is empty, delete it instead of committing.\n          store.getFileSystem().delete(mobFileWriter.getPath(), true);\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete the temp mob file\", e);\n        }\n      }\n    }\n    if (delFileWriter != null) {\n      if (deleteMarkersCount > 0) {\n        // If the del file is not empty, commit it.\n        // If the commit fails, the compaction is re-performed again.\n        mobStore.commitFile(delFileWriter.getPath(), path);\n      } else {\n        try {\n          // If the del file is empty, delete it instead of committing.\n          store.getFileSystem().delete(delFileWriter.getPath(), true);\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete the temp del file\", e);\n        }\n      }\n    }\n    mobStore.updateCellsCountCompactedFromMob(cellsCountCompactedFromMob);\n    mobStore.updateCellsCountCompactedToMob(cellsCountCompactedToMob);\n    mobStore.updateCellsSizeCompactedFromMob(cellsSizeCompactedFromMob);\n    mobStore.updateCellsSizeCompactedToMob(cellsSizeCompactedToMob);\n    progress.complete();\n    return true;\n  }","id":92586,"modified_method":"/**\n   * Performs compaction on a column family with the mob flag enabled.\n   * This is for when the mob threshold size has changed or if the mob\n   * column family mode has been toggled via an alter table statement.\n   * Compacts the files by the following rules.\n   * 1. If the cell has a mob reference tag, the cell's value is the path of the mob file.\n   * <ol>\n   * <li>\n   * If the value size of a cell is larger than the threshold, this cell is regarded as a mob,\n   * directly copy the (with mob tag) cell into the new store file.\n   * <\/li>\n   * <li>\n   * Otherwise, retrieve the mob cell from the mob file, and writes a copy of the cell into\n   * the new store file.\n   * <\/li>\n   * <\/ol>\n   * 2. If the cell doesn't have a reference tag.\n   * <ol>\n   * <li>\n   * If the value size of a cell is larger than the threshold, this cell is regarded as a mob,\n   * write this cell to a mob file, and write the path of this mob file to the store file.\n   * <\/li>\n   * <li>\n   * Otherwise, directly write this cell into the store file.\n   * <\/li>\n   * <\/ol>\n   * In the mob compaction, the {@link MobCompactionStoreScanner} is used as a scanner\n   * which could output the normal cells and delete markers together when required.\n   * After the major compaction on the normal hfiles, we have a guarantee that we have purged all\n   * deleted or old version mob refs, and the delete markers are written to a del file with the\n   * suffix _del. Because of this, it is safe to use the del file in the mob compaction.\n   * The mob compaction doesn't take place in the normal hfiles, it occurs directly in the\n   * mob files. When the small mob files are merged into bigger ones, the del file is added into\n   * the scanner to filter the deleted cells.\n   * @param fd File details\n   * @param scanner Where to read from.\n   * @param writer Where to write to.\n   * @param smallestReadPoint Smallest read point.\n   * @param cleanSeqId When true, remove seqId(used to be mvcc) value which is <= smallestReadPoint\n   * @param throughputController The compaction throughput controller.\n   * @param major Is a major compaction.\n   * @return Whether compaction ended; false if it was interrupted for any reason.\n   */\n  @Override\n  protected boolean performCompaction(FileDetails fd, InternalScanner scanner, CellSink writer,\n      long smallestReadPoint, boolean cleanSeqId,\n      ThroughputController throughputController,  boolean major) throws IOException {\n    if (!(scanner instanceof MobCompactionStoreScanner)) {\n      throw new IllegalArgumentException(\n        \"The scanner should be an instance of MobCompactionStoreScanner\");\n    }\n    MobCompactionStoreScanner compactionScanner = (MobCompactionStoreScanner) scanner;\n    int bytesWritten = 0;\n    // Since scanner.next() can return 'false' but still be delivering data,\n    // we have to use a do/while loop.\n    List<Cell> cells = new ArrayList<Cell>();\n    // Limit to \"hbase.hstore.compaction.kv.max\" (default 10) to avoid OOME\n    int closeCheckInterval = HStore.getCloseCheckInterval();\n    boolean hasMore;\n    Path path = MobUtils.getMobFamilyPath(conf, store.getTableName(), store.getColumnFamilyName());\n    byte[] fileName = null;\n    Writer mobFileWriter = null, delFileWriter = null;\n    long mobCells = 0, deleteMarkersCount = 0;\n    Tag tableNameTag = new ArrayBackedTag(TagType.MOB_TABLE_NAME_TAG_TYPE,\n        store.getTableName().getName());\n    long cellsCountCompactedToMob = 0, cellsCountCompactedFromMob = 0;\n    long cellsSizeCompactedToMob = 0, cellsSizeCompactedFromMob = 0;\n    try {\n      try {\n        // If the mob file writer could not be created, directly write the cell to the store file.\n        mobFileWriter = mobStore.createWriterInTmp(new Date(fd.latestPutTs), fd.maxKeyCount,\n            store.getFamily().getCompression(), store.getRegionInfo().getStartKey());\n        fileName = Bytes.toBytes(mobFileWriter.getPath().getName());\n      } catch (IOException e) {\n        LOG.error(\"Failed to create mob writer, \"\n               + \"we will continue the compaction by writing MOB cells directly in store files\", e);\n      }\n      delFileWriter = mobStore.createDelFileWriterInTmp(new Date(fd.latestPutTs), fd.maxKeyCount,\n          store.getFamily().getCompression(), store.getRegionInfo().getStartKey());\n      ScannerContext scannerContext =\n              ScannerContext.newBuilder().setBatchLimit(compactionKVMax).build();\n      do {\n        hasMore = compactionScanner.next(cells, scannerContext);\n        for (Cell c : cells) {\n          if (compactionScanner.isOutputDeleteMarkers() && CellUtil.isDelete(c)) {\n            delFileWriter.append(c);\n            deleteMarkersCount++;\n          } else if (mobFileWriter == null || c.getTypeByte() != KeyValue.Type.Put.getCode()) {\n            // If the mob file writer is null or the kv type is not put, directly write the cell\n            // to the store file.\n            writer.append(c);\n          } else if (MobUtils.isMobReferenceCell(c)) {\n            if (MobUtils.hasValidMobRefCellValue(c)) {\n              int size = MobUtils.getMobValueLength(c);\n              if (size > mobSizeThreshold) {\n                // If the value size is larger than the threshold, it's regarded as a mob. Since\n                // its value is already in the mob file, directly write this cell to the store file\n                writer.append(c);\n              } else {\n                // If the value is not larger than the threshold, it's not regarded a mob. Retrieve\n                // the mob cell from the mob file, and write it back to the store file.\n                Cell mobCell = mobStore.resolve(c, false);\n                if (mobCell.getValueLength() != 0) {\n                  // put the mob data back to the store file\n                  CellUtil.setSequenceId(mobCell, c.getSequenceId());\n                  writer.append(mobCell);\n                  cellsCountCompactedFromMob++;\n                  cellsSizeCompactedFromMob += mobCell.getValueLength();\n                } else {\n                  // If the value of a file is empty, there might be issues when retrieving,\n                  // directly write the cell to the store file, and leave it to be handled by the\n                  // next compaction.\n                  writer.append(c);\n                }\n              }\n            } else {\n              LOG.warn(\"The value format of the KeyValue \" + c\n                  + \" is wrong, its length is less than \" + Bytes.SIZEOF_INT);\n              writer.append(c);\n            }\n          } else if (c.getValueLength() <= mobSizeThreshold) {\n            //If value size of a cell is not larger than the threshold, directly write to store file\n            writer.append(c);\n          } else {\n            // If the value size of a cell is larger than the threshold, it's regarded as a mob,\n            // write this cell to a mob file, and write the path to the store file.\n            mobCells++;\n            // append the original keyValue in the mob file.\n            mobFileWriter.append(c);\n            KeyValue reference = MobUtils.createMobRefKeyValue(c, fileName, tableNameTag);\n            // write the cell whose value is the path of a mob file to the store file.\n            writer.append(reference);\n            cellsCountCompactedToMob++;\n            cellsSizeCompactedToMob += c.getValueLength();\n          }\n          ++progress.currentCompactedKVs;\n          // check periodically to see if a system stop is requested\n          if (closeCheckInterval > 0) {\n            bytesWritten += KeyValueUtil.length(c);\n            if (bytesWritten > closeCheckInterval) {\n              bytesWritten = 0;\n              if (!store.areWritesEnabled()) {\n                progress.cancel();\n                return false;\n              }\n            }\n          }\n        }\n        cells.clear();\n      } while (hasMore);\n    } finally {\n      if (mobFileWriter != null) {\n        mobFileWriter.appendMetadata(fd.maxSeqId, major, mobCells);\n        mobFileWriter.close();\n      }\n      if (delFileWriter != null) {\n        delFileWriter.appendMetadata(fd.maxSeqId, major, deleteMarkersCount);\n        delFileWriter.close();\n      }\n    }\n    if (mobFileWriter != null) {\n      if (mobCells > 0) {\n        // If the mob file is not empty, commit it.\n        mobStore.commitFile(mobFileWriter.getPath(), path);\n      } else {\n        try {\n          // If the mob file is empty, delete it instead of committing.\n          store.getFileSystem().delete(mobFileWriter.getPath(), true);\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete the temp mob file\", e);\n        }\n      }\n    }\n    if (delFileWriter != null) {\n      if (deleteMarkersCount > 0) {\n        // If the del file is not empty, commit it.\n        // If the commit fails, the compaction is re-performed again.\n        mobStore.commitFile(delFileWriter.getPath(), path);\n      } else {\n        try {\n          // If the del file is empty, delete it instead of committing.\n          store.getFileSystem().delete(delFileWriter.getPath(), true);\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete the temp del file\", e);\n        }\n      }\n    }\n    mobStore.updateCellsCountCompactedFromMob(cellsCountCompactedFromMob);\n    mobStore.updateCellsCountCompactedToMob(cellsCountCompactedToMob);\n    mobStore.updateCellsSizeCompactedFromMob(cellsSizeCompactedFromMob);\n    mobStore.updateCellsSizeCompactedToMob(cellsSizeCompactedToMob);\n    progress.complete();\n    return true;\n  }","commit_id":"f7d44e929fd2a8dac5f15c50c2eea1d448e92eb7","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  protected List<Path> commitMultiWriter(StripeMultiFileWriter writer, FileDetails fd,\n      CompactionRequest request) throws IOException {\n    List<Path> newFiles = writer.commitWriters(fd.maxSeqId, request.isMajor());\n    assert !newFiles.isEmpty() : \"Should have produced an empty file to preserve metadata.\";\n    return newFiles;\n  }","id":92587,"modified_method":"@Override\n  protected List<Path> commitWriter(StripeMultiFileWriter writer, FileDetails fd,\n      CompactionRequest request) throws IOException {\n    List<Path> newFiles = writer.commitWriters(fd.maxSeqId, request.isMajor());\n    assert !newFiles.isEmpty() : \"Should have produced an empty file to preserve metadata.\";\n    return newFiles;\n  }","commit_id":"f7d44e929fd2a8dac5f15c50c2eea1d448e92eb7","url":"https://github.com/apache/hbase"},{"original_method":"public List<Path> compact(CompactionRequest request, int targetCount, long targetSize,\n      byte[] left, byte[] right, byte[] majorRangeFromRow, byte[] majorRangeToRow,\n      ThroughputController throughputController, User user) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Executing compaction with \" + targetSize + \" target file size, no more than \"\n          + targetCount + \" files, in [\" + Bytes.toString(left) + \"] [\" + Bytes.toString(right)\n          + \"] range\");\n    }\n    StripeMultiFileWriter writer =\n        new StripeMultiFileWriter.SizeMultiWriter(store.getComparator(), targetCount, targetSize,\n            left, right);\n    return compact(writer, request, new StripeInternalScannerFactory(majorRangeFromRow,\n        majorRangeToRow), throughputController, user);\n  }","id":92588,"modified_method":"public List<Path> compact(CompactionRequest request, final int targetCount, final long targetSize,\n      final byte[] left, final byte[] right, byte[] majorRangeFromRow, byte[] majorRangeToRow,\n      ThroughputController throughputController, User user) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n        \"Executing compaction with \" + targetSize + \" target file size, no more than \" + targetCount\n            + \" files, in [\" + Bytes.toString(left) + \"] [\" + Bytes.toString(right) + \"] range\");\n    }\n    return compact(request, new StripeInternalScannerFactory(majorRangeFromRow, majorRangeToRow),\n      new CellSinkFactory<StripeMultiFileWriter>() {\n\n        @Override\n        public StripeMultiFileWriter createWriter(InternalScanner scanner, FileDetails fd,\n            boolean shouldDropBehind) throws IOException {\n          StripeMultiFileWriter writer = new StripeMultiFileWriter.SizeMultiWriter(\n              store.getComparator(), targetCount, targetSize, left, right);\n          initMultiWriter(writer, scanner, fd, shouldDropBehind);\n          return writer;\n        }\n      }, throughputController, user);\n  }","commit_id":"f7d44e929fd2a8dac5f15c50c2eea1d448e92eb7","url":"https://github.com/apache/hbase"},{"original_method":"public List<Path> compact(CompactionRequest request, List<byte[]> targetBoundaries,\n      byte[] majorRangeFromRow, byte[] majorRangeToRow, ThroughputController throughputController,\n      User user) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Executing compaction with \" + targetBoundaries.size() + \" boundaries:\");\n      for (byte[] tb : targetBoundaries) {\n        sb.append(\" [\").append(Bytes.toString(tb)).append(\"]\");\n      }\n      LOG.debug(sb.toString());\n    }\n    StripeMultiFileWriter writer =\n        new StripeMultiFileWriter.BoundaryMultiWriter(store.getComparator(), targetBoundaries,\n            majorRangeFromRow, majorRangeToRow);\n    return compact(writer, request, new StripeInternalScannerFactory(majorRangeFromRow,\n        majorRangeToRow), throughputController, user);\n  }","id":92589,"modified_method":"public List<Path> compact(CompactionRequest request, final List<byte[]> targetBoundaries,\n      final byte[] majorRangeFromRow, final byte[] majorRangeToRow,\n      ThroughputController throughputController, User user) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Executing compaction with \" + targetBoundaries.size() + \" boundaries:\");\n      for (byte[] tb : targetBoundaries) {\n        sb.append(\" [\").append(Bytes.toString(tb)).append(\"]\");\n      }\n      LOG.debug(sb.toString());\n    }\n    return compact(request, new StripeInternalScannerFactory(majorRangeFromRow, majorRangeToRow),\n      new CellSinkFactory<StripeMultiFileWriter>() {\n\n        @Override\n        public StripeMultiFileWriter createWriter(InternalScanner scanner, FileDetails fd,\n            boolean shouldDropBehind) throws IOException {\n          StripeMultiFileWriter writer = new StripeMultiFileWriter.BoundaryMultiWriter(\n              store.getComparator(), targetBoundaries, majorRangeFromRow, majorRangeToRow);\n          initMultiWriter(writer, scanner, fd, shouldDropBehind);\n          return writer;\n        }\n      }, throughputController, user);\n  }","commit_id":"f7d44e929fd2a8dac5f15c50c2eea1d448e92eb7","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public int getTokenStart() {\n    locateToken();\n    return myFlex.getTokenStart();\n  }","id":92590,"modified_method":"@Override\n  public int getTokenStart() {\n    if (myTokenType == null) locateToken();\n    return myFlex.getTokenStart();\n  }","commit_id":"8b0e1b71f00d5639d22c8d5df90e6f4a7d2f19c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getTokenEnd() {\n    locateToken();\n    return myFlex.getTokenEnd();\n  }","id":92591,"modified_method":"@Override\n  public int getTokenEnd() {\n    if (myTokenType == null) locateToken();\n    return myFlex.getTokenEnd();\n  }","commit_id":"8b0e1b71f00d5639d22c8d5df90e6f4a7d2f19c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public IElementType getTokenType() {\n    locateToken();\n    return myTokenType;\n  }","id":92592,"modified_method":"@Override\n  public IElementType getTokenType() {\n    if (myTokenType == null) locateToken();\n    return myTokenType;\n  }","commit_id":"8b0e1b71f00d5639d22c8d5df90e6f4a7d2f19c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getState() {\n    locateToken();\n    return myState;\n  }","id":92593,"modified_method":"@Override\n  public int getState() {\n    if (myTokenType == null) locateToken();\n    return myState;\n  }","commit_id":"8b0e1b71f00d5639d22c8d5df90e6f4a7d2f19c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void advance() {\n    locateToken();\n    myTokenType = null;\n  }","id":92594,"modified_method":"@Override\n  public void advance() {\n    if (myTokenType == null) locateToken();\n    myTokenType = null;\n  }","commit_id":"8b0e1b71f00d5639d22c8d5df90e6f4a7d2f19c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getState(){\n    locateToken();\n    return myState;\n  }","id":92595,"modified_method":"@Override\n  public int getState(){\n    if (myTokenType == null) locateToken();\n    return myState;\n  }","commit_id":"8b0e1b71f00d5639d22c8d5df90e6f4a7d2f19c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getTokenStart(){\n    locateToken();\n    return myTokenStart;\n  }","id":92596,"modified_method":"@Override\n  public int getTokenStart(){\n    if (myTokenType == null) locateToken();\n    return myTokenStart;\n  }","commit_id":"8b0e1b71f00d5639d22c8d5df90e6f4a7d2f19c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getTokenEnd(){\n    locateToken();\n    return super.getTokenStart();\n  }","id":92597,"modified_method":"@Override\n  public int getTokenEnd(){\n    if (myTokenType == null) locateToken();\n    return super.getTokenStart();\n  }","commit_id":"8b0e1b71f00d5639d22c8d5df90e6f4a7d2f19c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public IElementType getTokenType(){\n    locateToken();\n    return myTokenType;\n  }","id":92598,"modified_method":"@Override\n  public IElementType getTokenType(){\n    if (myTokenType == null) locateToken();\n    return myTokenType;\n  }","commit_id":"8b0e1b71f00d5639d22c8d5df90e6f4a7d2f19c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n        final String dialogId = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"dialog\"));\n\n        // Dispatch xxforms-dialog-close event to dialog\n        containingDocument.dispatchEvent(pipelineContext, new XXFormsDialogCloseEvent((XFormsEventTarget) xformsControls.getObjectById(dialogId)));\n    }","id":92599,"modified_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n        final String dialogId = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"dialog\"));\n\n        if (dialogId != null) {\n            // Dispatch xxforms-dialog-close event to dialog\n            containingDocument.dispatchEvent(pipelineContext, new XXFormsDialogCloseEvent((XFormsEventTarget) xformsControls.getObjectById(dialogId)));\n        }\n    }","commit_id":"0f4a1da3ffffd614e4a680a7c149b560cafb0533","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n        final String dialogId = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"dialog\"));\n\n        // Dispatch xxforms-dialog-open event to dialog\n        containingDocument.dispatchEvent(pipelineContext, new XXFormsDialogOpenEvent((XFormsEventTarget) xformsControls.getObjectById(dialogId)));\n    }","id":92600,"modified_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n        final String dialogId = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"dialog\"));\n\n        if (dialogId != null) {\n            // Dispatch xxforms-dialog-open event to dialog\n            containingDocument.dispatchEvent(pipelineContext, new XXFormsDialogOpenEvent((XFormsEventTarget) xformsControls.getObjectById(dialogId)));\n        }\n    }","commit_id":"0f4a1da3ffffd614e4a680a7c149b560cafb0533","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private static XFormsEvent createEvent(String eventName, XFormsEventTarget targetObject, XFormsEventTarget otherTargetObject, boolean allowCustomEvents, boolean bubbles, boolean cancelable,\n                                          String contextString, Element contextElement, Throwable contextThrowable, Element filesElement) {\n\n        // TODO\n        // XFORMS_MODEL_DESTRUCT\n        // XFORMS_RESET\n\n        // TODO: more efficient way to switch!\n\n        if (eventName.equals(XFormsEvents.XFORMS_DOM_ACTIVATE)) {\n            return new XFormsDOMActivateEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_COMPUTE_EXCEPTION)) {\n            return new org.orbeon.oxf.xforms.event.events.XFormsComputeExceptionEvent(targetObject, contextString, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DELETE)) {\n            return new XFormsDeleteEvent(targetObject, contextString);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DESELECT)) {\n            return new XFormsDeselectEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_INSERT)) {\n            return new XFormsInsertEvent(targetObject, contextString);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_ERROR)) {\n            return new XFormsLinkErrorEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_EXCEPTION)) {\n            return new XFormsLinkExceptionEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_REFRESH)) {\n            return new XFormsRefreshEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SELECT)) {\n            return new XFormsSelectEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SUBMIT_ERROR)) {\n            return new XFormsSubmitErrorEvent(targetObject, contextString, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SUBMIT)) {\n            return new XFormsSubmitEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SUBMIT_DONE)) {\n            return new XFormsSubmitDoneEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE)) {\n            return new XXFormsValueChangeWithFocusChangeEvent(targetObject, otherTargetObject, contextString);\n        } else if (eventName.equals(XFormsEvents.XXFORMS_SUBMIT)) {\n            return new XXFormsSubmissionEvent(targetObject, filesElement);\n        } else if (eventName.equals(XFormsEvents.XFORMS_MODEL_CONSTRUCT)) {\n            return new XFormsModelConstructEvent(targetObject);\n//        } else if (eventName.equals(XFormsEvents.XFORMS_MODEL_DESTRUCT)) {\n//            return new XFormsModelDestructEvent(targetObject);\n//        } else if (eventName.equals(XFormsEvents.XFORMS_RESET)) {\n//            return new XFormsResetEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_MODEL_CONSTRUCT_DONE)) {\n            return new XFormsModelConstructDoneEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_READY)) {\n            return new XFormsReadyEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_REBUILD)) {\n            return new XFormsRebuildEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_RECALCULATE)) {\n            return new XFormsRecalculateEvent(targetObject, Boolean.valueOf(contextString).booleanValue());\n        } else if (eventName.equals(XFormsEvents.XFORMS_REVALIDATE)) {\n            return new XFormsRevalidateEvent(targetObject, Boolean.valueOf(contextString).booleanValue());\n        } else if (eventName.equals(XFormsEvents.XFORMS_VALUE_CHANGED)) {\n            return new XFormsValueChangeEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DOM_FOCUS_OUT)) {\n            return new XFormsDOMFocusOutEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DOM_FOCUS_IN)) {\n            return new XFormsDOMFocusInEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_VALID)) {\n            return new XFormsValidEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_INVALID)) {\n            return new XFormsInvalidEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_REQUIRED)) {\n            return new XFormsRequiredEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_OPTIONAL)) {\n            return new XFormsOptionalEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_READWRITE)) {\n            return new XFormsReadwriteEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_READONLY)) {\n            return new XFormsReadonlyEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_ENABLED)) {\n            return new XFormsEnabledEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DISABLED)) {\n            return new XFormsDisabledEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SCROLL_FIRST)) {\n            return new XFormsScrollFirstEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SCROLL_LAST)) {\n            return new XFormsScrollLastEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_EXCEPTION)) {\n            return new XFormsLinkExceptionEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_ERROR)) {\n            return new XFormsLinkErrorEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (allowCustomEvents) {\n            return new XFormsCustomEvent(eventName, targetObject, bubbles, cancelable);\n        } else {\n            throw new OXFException(\"Event factory could not find event with name: \" + eventName);\n        }\n    }","id":92601,"modified_method":"private static XFormsEvent createEvent(String eventName, XFormsEventTarget targetObject, XFormsEventTarget otherTargetObject, boolean allowCustomEvents, boolean bubbles, boolean cancelable,\n                                          String contextString, Element contextElement, Throwable contextThrowable, Element filesElement) {\n\n        // TODO: more efficient way to switch!\n        if (eventName.equals(XFormsEvents.XFORMS_DOM_ACTIVATE)) {\n            return new XFormsDOMActivateEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_COMPUTE_EXCEPTION)) {\n            return new org.orbeon.oxf.xforms.event.events.XFormsComputeExceptionEvent(targetObject, contextString, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DELETE)) {\n            return new XFormsDeleteEvent(targetObject, contextString);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DESELECT)) {\n            return new XFormsDeselectEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_INSERT)) {\n            return new XFormsInsertEvent(targetObject, contextString);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_ERROR)) {\n            return new XFormsLinkErrorEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_EXCEPTION)) {\n            return new XFormsLinkExceptionEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_BINDING_EXCEPTION)) {\n            return new XFormsBindingExceptionEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_REFRESH)) {\n            return new XFormsRefreshEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SELECT)) {\n            return new XFormsSelectEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SUBMIT_ERROR)) {\n            return new XFormsSubmitErrorEvent(targetObject, contextString, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SUBMIT)) {\n            return new XFormsSubmitEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SUBMIT_DONE)) {\n            return new XFormsSubmitDoneEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE)) {\n            return new XXFormsValueChangeWithFocusChangeEvent(targetObject, otherTargetObject, contextString);\n        } else if (eventName.equals(XFormsEvents.XXFORMS_SUBMIT)) {\n            return new XXFormsSubmissionEvent(targetObject, filesElement);\n        } else if (eventName.equals(XFormsEvents.XFORMS_MODEL_CONSTRUCT)) {\n            return new XFormsModelConstructEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_MODEL_DESTRUCT)) {\n            return new XFormsModelDestructEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_RESET)) {\n            return new XFormsResetEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_MODEL_CONSTRUCT_DONE)) {\n            return new XFormsModelConstructDoneEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_READY)) {\n            return new XFormsReadyEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_REBUILD)) {\n            return new XFormsRebuildEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_RECALCULATE)) {\n            return new XFormsRecalculateEvent(targetObject, Boolean.valueOf(contextString).booleanValue());\n        } else if (eventName.equals(XFormsEvents.XFORMS_REVALIDATE)) {\n            return new XFormsRevalidateEvent(targetObject, Boolean.valueOf(contextString).booleanValue());\n        } else if (eventName.equals(XFormsEvents.XFORMS_VALUE_CHANGED)) {\n            return new XFormsValueChangeEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DOM_FOCUS_OUT)) {\n            return new XFormsDOMFocusOutEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DOM_FOCUS_IN)) {\n            return new XFormsDOMFocusInEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_VALID)) {\n            return new XFormsValidEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_INVALID)) {\n            return new XFormsInvalidEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_REQUIRED)) {\n            return new XFormsRequiredEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_OPTIONAL)) {\n            return new XFormsOptionalEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_READWRITE)) {\n            return new XFormsReadwriteEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_READONLY)) {\n            return new XFormsReadonlyEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_ENABLED)) {\n            return new XFormsEnabledEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DISABLED)) {\n            return new XFormsDisabledEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SCROLL_FIRST)) {\n            return new XFormsScrollFirstEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SCROLL_LAST)) {\n            return new XFormsScrollLastEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_EXCEPTION)) {\n            return new XFormsLinkExceptionEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_ERROR)) {\n            return new XFormsLinkErrorEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (allowCustomEvents) {\n            return new XFormsCustomEvent(eventName, targetObject, bubbles, cancelable);\n        } else {\n            throw new OXFException(\"Event factory could not find event with name: \" + eventName);\n        }\n    }","commit_id":"f9c9645f6df65dca42fff2bfdbc794d3bc6a78a9","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void extractSubmissionElement() {\n        if (!submissionElementExtracted) {\n\n            action = submissionElement.attributeValue(\"action\");\n            method = submissionElement.attributeValue(\"method\");\n            version = submissionElement.attributeValue(\"version\");\n\n            if (submissionElement.attributeValue(\"indent\") != null) {\n                indent = Boolean.valueOf(submissionElement.attributeValue(\"indent\")).booleanValue();\n            }\n            mediatype = submissionElement.attributeValue(\"mediatype\");\n            encoding = submissionElement.attributeValue(\"encoding\");\n            if (submissionElement.attributeValue(\"omitxmldeclaration\") != null) {\n                omitxmldeclaration = Boolean.valueOf(submissionElement.attributeValue(\"omit-xml-declaration\")).booleanValue();\n            }\n            if (submissionElement.attributeValue(\"standalone\") != null) {\n                standalone = new Boolean(submissionElement.attributeValue(\"standalone\"));\n            }\n\n            cdatasectionelements = submissionElement.attributeValue(\"cdata-section-elements\");\n            if (submissionElement.attributeValue(\"replace\") != null) {\n                replace = submissionElement.attributeValue(\"replace\");\n            }\n            if (submissionElement.attributeValue(\"separator\") != null) {\n                separator = submissionElement.attributeValue(\"separator\");\n            }\n            includenamespaceprefixes = submissionElement.attributeValue(\"includenamespaceprefixes\");\n\n            submissionElementExtracted = true;\n        }\n    }","id":92602,"modified_method":"private void extractSubmissionElement() {\n        if (!submissionElementExtracted) {\n\n            action = submissionElement.attributeValue(\"action\");\n            method = submissionElement.attributeValue(\"method\");\n            version = submissionElement.attributeValue(\"version\");\n\n            if (submissionElement.attributeValue(\"indent\") != null) {\n                indent = Boolean.valueOf(submissionElement.attributeValue(\"indent\")).booleanValue();\n            }\n            mediatype = submissionElement.attributeValue(\"mediatype\");\n            encoding = submissionElement.attributeValue(\"encoding\");\n            if (submissionElement.attributeValue(\"omitxmldeclaration\") != null) {\n                omitxmldeclaration = Boolean.valueOf(submissionElement.attributeValue(\"omit-xml-declaration\")).booleanValue();\n            }\n            if (submissionElement.attributeValue(\"standalone\") != null) {\n                standalone = new Boolean(submissionElement.attributeValue(\"standalone\"));\n            }\n\n            cdatasectionelements = submissionElement.attributeValue(\"cdata-section-elements\");\n            if (submissionElement.attributeValue(\"replace\") != null) {\n                replace = submissionElement.attributeValue(\"replace\");\n\n                if (replace.equals(\"instance\")) {\n                    replaceInstanceId = submissionElement.attributeValue(\"instance\");\n                }\n            }\n            if (submissionElement.attributeValue(\"separator\") != null) {\n                separator = submissionElement.attributeValue(\"separator\");\n            }\n            includenamespaceprefixes = submissionElement.attributeValue(\"includenamespaceprefixes\");\n\n            submissionElementExtracted = true;\n        }\n    }","commit_id":"f9c9645f6df65dca42fff2bfdbc794d3bc6a78a9","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void performDefaultAction(PipelineContext pipelineContext, XFormsEvent event) {\n        final String eventName = event.getEventName();\n\n        if (XFormsEvents.XFORMS_SUBMIT.equals(eventName) || XFormsEvents.XXFORMS_SUBMIT.equals(eventName)) {\n            // 11.1 The xforms-submit Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            final boolean isDeferredSubmission = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_ALL);\n            final boolean isDeferredSubmissionFirstPass = isDeferredSubmission && XFormsEvents.XFORMS_SUBMIT.equals(eventName);\n            final boolean isDeferredSubmissionSecondPass = isDeferredSubmission && !XFormsEvents.XFORMS_SUBMIT.equals(eventName);\n\n            try {\n                // Make sure submission element info is extracted\n                extractSubmissionElement();\n\n                // Select node based on ref or bind\n                final XFormsControls xformsControls = containingDocument.getXFormsControls();\n                xformsControls.setBinding(pipelineContext, submissionElement); // FIXME: the submission element is not a control...\n\n                final Node currentNode = xformsControls.getCurrentSingleNode();\n\n                if (!(currentNode instanceof Document || currentNode instanceof Element)) {\n                    throw new OXFException(\"xforms:submission: single-node binding must refer to a document node or an element.\");\n                }\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n\n                // Revalidate instance\n                // TODO: we should only revalidate relevant parts\n                containingDocument.dispatchEvent(pipelineContext,  new XFormsRevalidateEvent(model, false));\n\n                final Document initialDocumentToSubmit;\n                if (!isDeferredSubmissionSecondPass) {\n                    // Create document to submit\n                    initialDocumentToSubmit = createDocumentToSubmit(currentNode, currentInstance);\n\n                    // Check that there are no validation errors\n                    final boolean instanceValid = isDocumentValid(initialDocumentToSubmit);\n                    if (!instanceValid) {\n                        LocationSAXContentHandler ch = new LocationSAXContentHandler();\n                        currentInstance.read(ch);\n                        System.out.println(Dom4jUtils.domToString(ch.getDocument()));\n                        throw new OXFException(\"xforms:submission: instance is not valid.\");\n                    }\n                } else {\n                    initialDocumentToSubmit = null;\n                }\n\n                // Deferred submission\n                if (isDeferredSubmissionFirstPass) {\n                    // When replace=\"all\", we wait for the submission of an XXFormsSubmissionEvent from the client\n                    containingDocument.setActiveSubmission(this);\n                    return;\n                }\n\n                // Handle uploaded files if any\n                final Element filesElement = ((XXFormsSubmissionEvent) event).getFilesElement();\n                if (filesElement != null) {\n                    for (Iterator i = filesElement.elements().iterator(); i.hasNext();) {\n                        final Element parameterElement = (Element) i.next();\n                        final String name = parameterElement.element(\"name\").getTextTrim();\n\n                        final Element valueElement = parameterElement.element(\"value\");\n                        final String value = valueElement.getTextTrim();\n                        final String paramValueType = valueElement.attributeValue(XMLConstants.XSI_TYPE_QNAME);//TODO: get actual QName for attribute value\n\n                        final String filename = parameterElement.element(\"filename\").getTextTrim();\n                        final String mediatype = parameterElement.element(\"content-type\").getTextTrim();\n                        final String size = parameterElement.element(\"content-length\").getTextTrim();\n\n                        final XFormsControls.UploadControlInfo uploadControl\n                                = (XFormsControls.UploadControlInfo) containingDocument.getObjectById(pipelineContext, name);\n\n                        // Set value into the instance\n                        xformsControls.setBinding(pipelineContext, uploadControl);\n                        {\n                            final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                            XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, value, paramValueType);\n                        }\n\n                        // Handle filename if any\n                        if (uploadControl.getFilenameElement() != null) {\n                            xformsControls.pushBinding(pipelineContext, uploadControl.getFilenameElement());\n                            final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                            XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, filename, null);\n                            xformsControls.popBinding();\n                        }\n\n                        // Handle mediatype if any\n                        if (uploadControl.getMediatypeElement() != null) {\n                            xformsControls.pushBinding(pipelineContext, uploadControl.getMediatypeElement());\n                            final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                            XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, mediatype, null);\n                            xformsControls.popBinding();\n                        }\n                        \n                        // Handle file size if any\n                        if (uploadControl.getSizeElement() != null) {\n                            xformsControls.pushBinding(pipelineContext, uploadControl.getSizeElement());\n                            final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                            XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, size, null);\n                            xformsControls.popBinding();\n                        }\n                    }\n                }\n\n                final Document documentToSubmit;\n                if (isDeferredSubmissionSecondPass) {\n                    // Create document to submit\n                    documentToSubmit = createDocumentToSubmit(currentNode, currentInstance);\n\n                    // Check that there are no validation errors\n                    final boolean instanceValid = isDocumentValid(documentToSubmit);\n                    if (!instanceValid) {\n                        LocationSAXContentHandler ch = new LocationSAXContentHandler();\n                        currentInstance.read(ch);\n                        System.out.println(Dom4jUtils.domToString(ch.getDocument()));\n                        throw new OXFException(\"xforms:submission: instance is not valid.\");\n                    }\n                } else {\n                    documentToSubmit = initialDocumentToSubmit;\n                }\n\n                // Serialize\n                // To support: application/xml, application/x-www-form-urlencoded, multipart/related, multipart/form-data\n                final byte[] serializedInstance;\n                {\n                    if (method.equals(\"post\") || method.equals(\"put\")) {\n                        try {\n                            final Transformer identity = TransformerUtils.getIdentityTransformer();\n                            TransformerUtils.applyOutputProperties(identity,\n                                    \"xml\", version, null, null, encoding, omitxmldeclaration, standalone, indent, 4);\n\n                            // TODO: use cdata-section-elements\n\n                            final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                            identity.transform(new DocumentSource(documentToSubmit), new StreamResult(os));\n                            serializedInstance = os.toByteArray();\n                        } catch (Exception e) {\n                            throw new OXFException(\"xforms:submission: exception while serializing instance to XML.\", e);\n                        }\n\n                    } else if (method.equals(\"get\")) {\n                        // TODO\n                        throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                    } else if (method.equals(\"multipart-post\")) {\n                        // TODO\n                        throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                    } else if (method.equals(\"form-data-post\")) {\n                        // TODO\n                        throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                    } else if (method.equals(\"urlencoded-post\")) {\n                        throw new OXFException(\"xforms:submission: deprecated submission method requested: \" + method);\n                    } else {\n                        throw new OXFException(\"xforms:submission: invalid submission method requested: \" + method);\n                    }\n                }\n\n                final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n                // Result information\n                int resultCode = 0;\n                String resultMediaType = null;\n                Map resultHeaders = null;\n                InputStream resultInputStream = null;\n\n                HttpURLConnection urlConnection = null;\n                OutputStream os = null;\n                boolean forwarded = false;\n\n                try {\n                    if (action.startsWith(\"/\")) {\n\n                        // TODO\n                        //  && !externalContext.getRequest().getContainerType().equals(\"portlet\")\n\n                        // This is a \"local\" submission, i.e. in the same web application\n                        // The submission can be optimized.\n\n                        // NOTE: It is not possible to use include() with portlets, because it is\n                        // not possible to intercept the response, unlike with servlets. Also, there\n                        // is no concept of forward() with portlets. In the case of portlets, we can\n                        // therefore not optimize.\n\n                        // FIXME: How to deal with absolute paths on the same server, but not in\n                        // the web application? Just use absolute URLs?\n\n                        ExternalContext.RequestDispatcher requestDispatcher = externalContext.getRequestDispatcher(action);\n                        try {\n                            if (method.equals(\"post\") || method.equals(\"put\")) {\n\n                                final ForwardExternalContextRequestWrapper requestAdapter = new ForwardExternalContextRequestWrapper(externalContext.getRequest(),\n                                        action, method.toUpperCase(), (mediatype != null) ? mediatype : \"application/xml\", serializedInstance);\n\n                                if (replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_ALL)) {\n                                    // Just forward the reply\n                                    // TODO: xforms-submit-done must be sent before the body is forwarded\n                                    containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                                    requestDispatcher.forward(requestAdapter, externalContext.getResponse());\n                                    forwarded = true;\n                                } else {\n                                    // We must intercept the reply\n                                    final ResponseAdapter responseAdapter = new ResponseAdapter();\n                                    requestDispatcher.include(requestAdapter, responseAdapter);\n\n                                    // Get response information that needs to be forwarded\n                                    resultCode = responseAdapter.getResponseCode();\n    //                                resultMediaType = NetUtils.getContentTypeMediaType(responseAdapter.getContentType());\n    //                                resultHeaders = responseAdapter.getHeaders();\n                                    resultMediaType = ProcessorUtils.XML_CONTENT_TYPE;\n                                    resultInputStream = responseAdapter.getInputStream();\n                                }\n\n                            } else if (method.equals(\"get\")) {\n                                // TODO\n                                throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                            } else if (method.equals(\"multipart-post\")) {\n                                // TODO\n                                throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                            } else if (method.equals(\"form-data-post\")) {\n                                // TODO\n                                throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                            } else if (method.equals(\"urlencoded-post\")) {\n                                throw new OXFException(\"xforms:submission: deprecated submission method requested: \" + method);\n                            } else {\n                                throw new OXFException(\"xforms:submission: invalid submission method requested: \" + method);\n                            }\n                        } catch (IOException e) {\n                            throw new OXFException(e);\n                        }\n\n                    } else {\n                        // This is a \"remote\" submission, i.e. using an absolute URL, OR a \"local\" submission from a portlet\n\n                        // Compute submission URL\n                        final URL submissionURL;\n                        try {\n                            if (action.startsWith(\"/\")) {\n                                // Case of \"local\" portlet submission\n                                final String requestURL = externalContext.getRequest().getRequestURL();\n                                submissionURL = URLFactory.createURL(requestURL, externalContext.getRequest().getContextPath() + action);\n                            } else if (NetUtils.urlHasProtocol(action)) {\n                                // Case of absolute URL\n                                submissionURL = URLFactory.createURL(action);\n                            } else {\n                                throw new OXFException(\"xforms:submission: invalid action: \" + action);\n//                                final String requestURL = externalContext.getRequest().getRequestURL();\n//\n//                                if (requestURL != null) {\n//                                    submissionURL = URLFactory.createURL(requestURL, action);\n//                                } else {\n//                                    throw new OXFException(\"xforms:submission: cannot resolve relative action: \" + action);\n//                                }\n                            }\n                        } catch (MalformedURLException e) {\n                            throw new OXFException(\"xforms:submission: invalid action: \" + action, e);\n                        }\n\n                        // Perform submission\n                        final String scheme = submissionURL.getProtocol();\n                        if (scheme.equals(\"http\") || scheme.equals(\"https\")) {\n                            // http MUST be supported\n                            // https SHOULD be supported\n\n                            urlConnection = (HttpURLConnection) submissionURL.openConnection();\n\n                            if (method.equals(\"post\") || method.equals(\"put\")) {\n                                urlConnection.setDoInput(true);\n                                urlConnection.setDoOutput(true); // If POST / PUT\n\n                                urlConnection.setRequestMethod(method.toUpperCase());\n                                urlConnection.setRequestProperty(\"content-type\", (mediatype != null) ? mediatype : \"application/xml\");\n\n                                urlConnection.connect();\n\n                                // Submit\n                                os = urlConnection.getOutputStream();\n                                os.write(serializedInstance);\n\n                                // Get response information that needs to be forwarded\n                                resultCode = urlConnection.getResponseCode();\n                                final String contentType = urlConnection.getContentType();\n                                resultMediaType = NetUtils.getContentTypeMediaType(contentType);\n                                resultHeaders = urlConnection.getHeaderFields();\n                                resultInputStream = urlConnection.getInputStream();\n\n                            } else if (method.equals(\"get\")) {\n                                // TODO\n                                throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                            } else if (method.equals(\"multipart-post\")) {\n                                // TODO\n                                throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                            } else if (method.equals(\"form-data-post\")) {\n                                // TODO\n                                throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                            } else if (method.equals(\"urlencoded-post\")) {\n                                throw new OXFException(\"xforms:submission: deprecated submission method requested: \" + method);\n                            } else {\n                                throw new OXFException(\"xforms:submission: invalid submission method requested: \" + method);\n                            }\n                        } else if (scheme.equals(\"file\")) {\n                            // TODO\n                            // SHOULD be supported\n                            // Question: should support oxf: as well?\n                            throw new OXFException(\"xforms:submission: submission URL scheme not yet implemented: \" + scheme);\n                        } else if (scheme.equals(\"mailto\")) {\n                            // TODO\n                            // MAY be supported\n                            throw new OXFException(\"xforms:submission: submission URL scheme not yet implemented: \" + scheme);\n                        } else {\n                            throw new OXFException(\"xforms:submission: submission URL scheme not supported: \" + scheme);\n                        }\n\n                    }\n\n                    if (!forwarded) {\n                        // Handle response\n                        if (resultCode == 200) {\n                            // Sucessful response\n\n                            final boolean hasContent;\n                            {\n                                if (resultInputStream == null) {\n                                    hasContent = false;\n                                } else {\n                                    if (!resultInputStream.markSupported())\n                                        resultInputStream = new BufferedInputStream(resultInputStream);\n\n                                    resultInputStream.mark(1);\n                                    hasContent = resultInputStream.read() != -1;\n                                    resultInputStream.reset();\n                                }\n                            }\n\n                            if (hasContent) {\n                                // There is a body\n\n                                if (replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_ALL)) {\n                                    // When we get here, we are in a mode where we need to send the reply\n                                    // directly to an external context, if any.\n\n                                    // \"the event xforms-submit-done is dispatched\"\n                                    containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n\n                                    final ExternalContext.Response response = externalContext.getResponse();\n\n                                    // Forward headers to response\n                                    if (resultHeaders != null) {\n                                        for (Iterator i = resultHeaders.entrySet().iterator(); i.hasNext();) {\n                                            final Map.Entry currentEntry = (Map.Entry) i.next();\n                                            final String headerName = (String) currentEntry.getKey();\n                                            final List headerValues = (List) currentEntry.getValue();\n\n                                            if (headerName != null && headerValues != null) {\n                                                for (Iterator j = headerValues.iterator(); j.hasNext();) {\n                                                    response.addHeader(headerName, (String) j.next());\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    // Forward content to response\n                                    NetUtils.copyStream(resultInputStream, response.getOutputStream());\n\n                                } else if (replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_INSTANCE)) {\n\n                                    final ByteArrayOutputStream resultByteArrayOutputStream = new ByteArrayOutputStream();\n                                    NetUtils.copyStream(resultInputStream, resultByteArrayOutputStream);\n                                    byte[] submissionResponse = resultByteArrayOutputStream.toByteArray();\n\n                                    if (ProcessorUtils.isXMLContentType(resultMediaType)) {\n                                        // Handling of XML media type\n                                        try {\n                                            final Transformer identity = TransformerUtils.getIdentityTransformer();\n                                            final LocationDocumentResult documentResult = new LocationDocumentResult();\n                                            identity.transform(new StreamSource(new ByteArrayInputStream(submissionResponse)), documentResult);\n                                            final Document resultingInstanceDocument = documentResult.getDocument();\n\n                                            // Set new instance document to replace the one submitted\n                                            currentInstance.setInstanceDocument(resultingInstanceDocument);\n\n                                            // Dispatch events\n                                            containingDocument.dispatchEvent(pipelineContext, new org.orbeon.oxf.xforms.event.events.XFormsModelConstructEvent(model));\n                                            containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                                        } catch (Exception e) {\n                                            throw new OXFException(\"xforms:submission: exception while serializing XML to instance.\", e);\n                                        }\n                                    } else {\n                                        // Other media type\n                                        throw new OXFException(\"Body received with non-XML media type for replace=\\\"instance\\\": \" + resultMediaType);\n                                    }\n                                } else if (replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_NONE)) {\n                                    // Just notify that processing is terminated\n                                    containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                                } else {\n                                    throw new OXFException(\"xforms:submission: invalid replace attribute: \" + replace);\n                                }\n\n                            } else {\n                                // There is no body, notify that processing is terminated\n                                containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                            }\n                        } else if (resultCode == 302 || resultCode == 301) {\n                            // Got a redirect\n\n                            final ExternalContext.Response response = externalContext.getResponse();\n\n                            // Forward headers to response\n                            // TODO: this is duplicated from above\n                            if (resultHeaders != null) {\n                                for (Iterator i = resultHeaders.entrySet().iterator(); i.hasNext();) {\n                                    final Map.Entry currentEntry = (Map.Entry) i.next();\n                                    final String headerName = (String) currentEntry.getKey();\n                                    final List headerValues = (List) currentEntry.getValue();\n\n                                    if (headerName != null && headerValues != null) {\n                                        for (Iterator j = headerValues.iterator(); j.hasNext();) {\n                                            response.addHeader(headerName, (String) j.next());\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Forward redirect\n                            response.setStatus(resultCode);\n\n                        } else {\n                            // Error code received\n                            throw new OXFException(\"Error code received when submitting instance: \" + resultCode);\n                        }\n                    }\n                } finally {\n                    // Clean-up\n                    if (os != null) {\n                        try {\n                            os.close();\n                        } catch (IOException e) {\n                            throw new OXFException(\"Exception while closing output stream for action: \" + action);\n                        }\n                    }\n                    if (resultInputStream != null) {\n                        try {\n                            resultInputStream.close();\n                        } catch (IOException e) {\n                            throw new OXFException(\"Exception while closing input stream for action: \" + action);\n                        }\n                    }\n                    if (urlConnection != null)\n                        urlConnection.disconnect();\n                }\n            } catch (Exception e) {\n                // Any exception will cause an error event to be dispatched\n                containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitErrorEvent(XFormsModelSubmission.this, action, e));\n            }\n\n        }\n    }","id":92603,"modified_method":"public void performDefaultAction(PipelineContext pipelineContext, XFormsEvent event) {\n        final String eventName = event.getEventName();\n\n        if (XFormsEvents.XFORMS_SUBMIT.equals(eventName) || XFormsEvents.XXFORMS_SUBMIT.equals(eventName)) {\n            // 11.1 The xforms-submit Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            try {\n                // Make sure submission element info is extracted\n                extractSubmissionElement();\n\n                final boolean isDeferredSubmission = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_ALL);\n                final boolean isDeferredSubmissionFirstPass = isDeferredSubmission && XFormsEvents.XFORMS_SUBMIT.equals(eventName);\n                final boolean isDeferredSubmissionSecondPass = isDeferredSubmission && !XFormsEvents.XFORMS_SUBMIT.equals(eventName);\n\n                // Select node based on ref or bind\n                final XFormsControls xformsControls = containingDocument.getXFormsControls();\n                xformsControls.setBinding(pipelineContext, submissionElement); // FIXME: the submission element is not a control...\n\n                final Node currentNode = xformsControls.getCurrentSingleNode();\n\n                if (!(currentNode instanceof Document || currentNode instanceof Element)) {\n                    throw new OXFException(\"xforms:submission: single-node binding must refer to a document node or an element.\");\n                }\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n\n                // Revalidate instance\n                // TODO: we should only revalidate relevant parts\n                containingDocument.dispatchEvent(pipelineContext,  new XFormsRevalidateEvent(model, false));\n\n                final Document initialDocumentToSubmit;\n                if (!isDeferredSubmissionSecondPass) {\n                    // Create document to submit\n                    initialDocumentToSubmit = createDocumentToSubmit(currentNode, currentInstance);\n\n                    // Check that there are no validation errors\n                    final boolean instanceValid = isDocumentValid(initialDocumentToSubmit);\n                    if (!instanceValid) {\n                        LocationSAXContentHandler ch = new LocationSAXContentHandler();\n                        currentInstance.read(ch);\n                        System.out.println(Dom4jUtils.domToString(ch.getDocument()));\n                        throw new OXFException(\"xforms:submission: instance is not valid.\");\n                    }\n                } else {\n                    initialDocumentToSubmit = null;\n                }\n\n                // Deferred submission\n                if (isDeferredSubmissionFirstPass) {\n                    // When replace=\"all\", we wait for the submission of an XXFormsSubmissionEvent from the client\n                    containingDocument.setActiveSubmission(this);\n                    return;\n                }\n\n                // Handle uploaded files if any\n                if (isDeferredSubmissionSecondPass) {\n                    final Element filesElement = ((XXFormsSubmissionEvent) event).getFilesElement();\n                    if (filesElement != null) {\n                        for (Iterator i = filesElement.elements().iterator(); i.hasNext();) {\n                            final Element parameterElement = (Element) i.next();\n                            final String name = parameterElement.element(\"name\").getTextTrim();\n\n                            final Element valueElement = parameterElement.element(\"value\");\n                            final String value = valueElement.getTextTrim();\n                            final String paramValueType = valueElement.attributeValue(XMLConstants.XSI_TYPE_QNAME);//TODO: get actual QName for attribute value\n\n                            final String filename = parameterElement.element(\"filename\").getTextTrim();\n                            final String mediatype = parameterElement.element(\"content-type\").getTextTrim();\n                            final String size = parameterElement.element(\"content-length\").getTextTrim();\n\n                            final XFormsControls.UploadControlInfo uploadControl\n                                    = (XFormsControls.UploadControlInfo) containingDocument.getObjectById(pipelineContext, name);\n\n                            // Set value into the instance\n                            xformsControls.setBinding(pipelineContext, uploadControl);\n                            {\n                                final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                                XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, value, paramValueType);\n                            }\n\n                            // Handle filename if any\n                            if (uploadControl.getFilenameElement() != null) {\n                                xformsControls.pushBinding(pipelineContext, uploadControl.getFilenameElement());\n                                final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                                XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, filename, null);\n                                xformsControls.popBinding();\n                            }\n\n                            // Handle mediatype if any\n                            if (uploadControl.getMediatypeElement() != null) {\n                                xformsControls.pushBinding(pipelineContext, uploadControl.getMediatypeElement());\n                                final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                                XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, mediatype, null);\n                                xformsControls.popBinding();\n                            }\n\n                            // Handle file size if any\n                            if (uploadControl.getSizeElement() != null) {\n                                xformsControls.pushBinding(pipelineContext, uploadControl.getSizeElement());\n                                final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                                XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, size, null);\n                                xformsControls.popBinding();\n                            }\n                        }\n                    }\n                }\n\n                final Document documentToSubmit;\n                if (isDeferredSubmissionSecondPass) {\n                    // Create document to submit\n                    documentToSubmit = createDocumentToSubmit(currentNode, currentInstance);\n\n                    // Check that there are no validation errors\n                    final boolean instanceValid = isDocumentValid(documentToSubmit);\n                    if (!instanceValid) {\n                        LocationSAXContentHandler ch = new LocationSAXContentHandler();\n                        currentInstance.read(ch);\n                        System.out.println(Dom4jUtils.domToString(ch.getDocument()));\n                        throw new OXFException(\"xforms:submission: instance is not valid.\");\n                    }\n                } else {\n                    documentToSubmit = initialDocumentToSubmit;\n                }\n\n                // Serialize\n                // To support: application/xml, application/x-www-form-urlencoded, multipart/related, multipart/form-data\n                final byte[] serializedInstance;\n                {\n                    if (method.equals(\"post\") || method.equals(\"put\")) {\n                        try {\n                            final Transformer identity = TransformerUtils.getIdentityTransformer();\n                            TransformerUtils.applyOutputProperties(identity,\n                                    \"xml\", version, null, null, encoding, omitxmldeclaration, standalone, indent, 4);\n\n                            // TODO: use cdata-section-elements\n\n                            final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                            identity.transform(new DocumentSource(documentToSubmit), new StreamResult(os));\n                            serializedInstance = os.toByteArray();\n                        } catch (Exception e) {\n                            throw new OXFException(\"xforms:submission: exception while serializing instance to XML.\", e);\n                        }\n\n                    } else if (method.equals(\"get\")) {\n                        // TODO\n                        throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                    } else if (method.equals(\"multipart-post\")) {\n                        // TODO\n                        throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                    } else if (method.equals(\"form-data-post\")) {\n                        // TODO\n                        throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                    } else if (method.equals(\"urlencoded-post\")) {\n                        throw new OXFException(\"xforms:submission: deprecated submission method requested: \" + method);\n                    } else {\n                        throw new OXFException(\"xforms:submission: invalid submission method requested: \" + method);\n                    }\n                }\n\n                final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n                // Result information\n                int resultCode = 0;\n                String resultMediaType = null;\n                Map resultHeaders = null;\n                InputStream resultInputStream = null;\n\n                HttpURLConnection urlConnection = null;\n                OutputStream os = null;\n                boolean forwarded = false;\n\n                try {\n                    if (action.startsWith(\"/\")) {\n\n                        // TODO\n                        //  && !externalContext.getRequest().getContainerType().equals(\"portlet\")\n\n                        // This is a \"local\" submission, i.e. in the same web application\n                        // The submission can be optimized.\n\n                        // NOTE: It is not possible to use include() with portlets, because it is\n                        // not possible to intercept the response, unlike with servlets. Also, there\n                        // is no concept of forward() with portlets. In the case of portlets, we can\n                        // therefore not optimize.\n\n                        // FIXME: How to deal with absolute paths on the same server, but not in\n                        // the web application? Just use absolute URLs?\n\n                        ExternalContext.RequestDispatcher requestDispatcher = externalContext.getRequestDispatcher(action);\n                        try {\n                            if (method.equals(\"post\") || method.equals(\"put\")) {\n\n                                final ForwardExternalContextRequestWrapper requestAdapter = new ForwardExternalContextRequestWrapper(externalContext.getRequest(),\n                                        action, method.toUpperCase(), (mediatype != null) ? mediatype : \"application/xml\", serializedInstance);\n\n                                if (replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_ALL)) {\n                                    // Just forward the reply\n                                    // TODO: xforms-submit-done must be sent before the body is forwarded\n                                    containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                                    requestDispatcher.forward(requestAdapter, externalContext.getResponse());\n                                    forwarded = true;\n                                } else {\n                                    // We must intercept the reply\n                                    final ResponseAdapter responseAdapter = new ResponseAdapter();\n                                    requestDispatcher.include(requestAdapter, responseAdapter);\n\n                                    // Get response information that needs to be forwarded\n                                    resultCode = responseAdapter.getResponseCode();\n    //                                resultMediaType = NetUtils.getContentTypeMediaType(responseAdapter.getContentType());\n    //                                resultHeaders = responseAdapter.getHeaders();\n                                    resultMediaType = ProcessorUtils.XML_CONTENT_TYPE;\n                                    resultInputStream = responseAdapter.getInputStream();\n                                }\n\n                            } else if (method.equals(\"get\")) {\n                                // TODO\n                                throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                            } else if (method.equals(\"multipart-post\")) {\n                                // TODO\n                                throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                            } else if (method.equals(\"form-data-post\")) {\n                                // TODO\n                                throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                            } else if (method.equals(\"urlencoded-post\")) {\n                                throw new OXFException(\"xforms:submission: deprecated submission method requested: \" + method);\n                            } else {\n                                throw new OXFException(\"xforms:submission: invalid submission method requested: \" + method);\n                            }\n                        } catch (IOException e) {\n                            throw new OXFException(e);\n                        }\n\n                    } else {\n                        // This is a \"remote\" submission, i.e. using an absolute URL, OR a \"local\" submission from a portlet\n\n                        // Compute submission URL\n                        final URL submissionURL;\n                        try {\n                            if (action.startsWith(\"/\")) {\n                                // Case of \"local\" portlet submission\n                                final String requestURL = externalContext.getRequest().getRequestURL();\n                                submissionURL = URLFactory.createURL(requestURL, externalContext.getRequest().getContextPath() + action);\n                            } else if (NetUtils.urlHasProtocol(action)) {\n                                // Case of absolute URL\n                                submissionURL = URLFactory.createURL(action);\n                            } else {\n                                throw new OXFException(\"xforms:submission: invalid action: \" + action);\n//                                final String requestURL = externalContext.getRequest().getRequestURL();\n//\n//                                if (requestURL != null) {\n//                                    submissionURL = URLFactory.createURL(requestURL, action);\n//                                } else {\n//                                    throw new OXFException(\"xforms:submission: cannot resolve relative action: \" + action);\n//                                }\n                            }\n                        } catch (MalformedURLException e) {\n                            throw new OXFException(\"xforms:submission: invalid action: \" + action, e);\n                        }\n\n                        // Perform submission\n                        final String scheme = submissionURL.getProtocol();\n                        if (scheme.equals(\"http\") || scheme.equals(\"https\")) {\n                            // http MUST be supported\n                            // https SHOULD be supported\n\n                            urlConnection = (HttpURLConnection) submissionURL.openConnection();\n\n                            if (method.equals(\"post\") || method.equals(\"put\")) {\n                                urlConnection.setDoInput(true);\n                                urlConnection.setDoOutput(true); // If POST / PUT\n\n                                urlConnection.setRequestMethod(method.toUpperCase());\n                                urlConnection.setRequestProperty(\"content-type\", (mediatype != null) ? mediatype : \"application/xml\");\n\n                                urlConnection.connect();\n\n                                // Submit\n                                os = urlConnection.getOutputStream();\n                                os.write(serializedInstance);\n\n                                // Get response information that needs to be forwarded\n                                resultCode = urlConnection.getResponseCode();\n                                final String contentType = urlConnection.getContentType();\n                                resultMediaType = NetUtils.getContentTypeMediaType(contentType);\n                                resultHeaders = urlConnection.getHeaderFields();\n                                resultInputStream = urlConnection.getInputStream();\n\n                            } else if (method.equals(\"get\")) {\n                                // TODO\n                                throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                            } else if (method.equals(\"multipart-post\")) {\n                                // TODO\n                                throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                            } else if (method.equals(\"form-data-post\")) {\n                                // TODO\n                                throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                            } else if (method.equals(\"urlencoded-post\")) {\n                                throw new OXFException(\"xforms:submission: deprecated submission method requested: \" + method);\n                            } else {\n                                throw new OXFException(\"xforms:submission: invalid submission method requested: \" + method);\n                            }\n                        } else if (scheme.equals(\"file\")) {\n                            // TODO\n                            // SHOULD be supported\n                            // Question: should support oxf: as well?\n                            throw new OXFException(\"xforms:submission: submission URL scheme not yet implemented: \" + scheme);\n                        } else if (scheme.equals(\"mailto\")) {\n                            // TODO\n                            // MAY be supported\n                            throw new OXFException(\"xforms:submission: submission URL scheme not yet implemented: \" + scheme);\n                        } else {\n                            throw new OXFException(\"xforms:submission: submission URL scheme not supported: \" + scheme);\n                        }\n\n                    }\n\n                    if (!forwarded) {\n                        // Handle response\n                        if (resultCode == 200) {\n                            // Sucessful response\n\n                            final boolean hasContent;\n                            {\n                                if (resultInputStream == null) {\n                                    hasContent = false;\n                                } else {\n                                    if (!resultInputStream.markSupported())\n                                        resultInputStream = new BufferedInputStream(resultInputStream);\n\n                                    resultInputStream.mark(1);\n                                    hasContent = resultInputStream.read() != -1;\n                                    resultInputStream.reset();\n                                }\n                            }\n\n                            if (hasContent) {\n                                // There is a body\n\n                                if (replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_ALL)) {\n                                    // When we get here, we are in a mode where we need to send the reply\n                                    // directly to an external context, if any.\n\n                                    // \"the event xforms-submit-done is dispatched\"\n                                    containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n\n                                    final ExternalContext.Response response = externalContext.getResponse();\n\n                                    // Forward headers to response\n                                    if (resultHeaders != null) {\n                                        for (Iterator i = resultHeaders.entrySet().iterator(); i.hasNext();) {\n                                            final Map.Entry currentEntry = (Map.Entry) i.next();\n                                            final String headerName = (String) currentEntry.getKey();\n                                            final List headerValues = (List) currentEntry.getValue();\n\n                                            if (headerName != null && headerValues != null) {\n                                                for (Iterator j = headerValues.iterator(); j.hasNext();) {\n                                                    response.addHeader(headerName, (String) j.next());\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    // Forward content to response\n                                    NetUtils.copyStream(resultInputStream, response.getOutputStream());\n\n                                } else if (replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_INSTANCE)) {\n\n                                    final ByteArrayOutputStream resultByteArrayOutputStream = new ByteArrayOutputStream();\n                                    NetUtils.copyStream(resultInputStream, resultByteArrayOutputStream);\n                                    byte[] submissionResponse = resultByteArrayOutputStream.toByteArray();\n\n                                    if (ProcessorUtils.isXMLContentType(resultMediaType)) {\n                                        // Handling of XML media type\n                                        try {\n                                            final Transformer identity = TransformerUtils.getIdentityTransformer();\n                                            final LocationDocumentResult documentResult = new LocationDocumentResult();\n                                            identity.transform(new StreamSource(new ByteArrayInputStream(submissionResponse)), documentResult);\n                                            final Document resultingInstanceDocument = documentResult.getDocument();\n\n                                            // Set new instance document to replace the one submitted\n                                            final XFormsInstance replaceInstance = (replaceInstanceId == null) ? currentInstance : model.getInstance(replaceInstanceId);\n                                            if (replaceInstance == null) {\n                                                containingDocument.dispatchEvent(pipelineContext, new XFormsBindingExceptionEvent(XFormsModelSubmission.this));\n                                            } else {\n                                                replaceInstance.setInstanceDocument(resultingInstanceDocument);\n\n                                                // Dispatch events\n                                                containingDocument.dispatchEvent(pipelineContext, new org.orbeon.oxf.xforms.event.events.XFormsModelConstructEvent(model));\n                                                containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                                            }\n                                        } catch (Exception e) {\n                                            throw new OXFException(\"xforms:submission: exception while serializing XML to instance.\", e);\n                                        }\n                                    } else {\n                                        // Other media type\n                                        throw new OXFException(\"Body received with non-XML media type for replace=\\\"instance\\\": \" + resultMediaType);\n                                    }\n                                } else if (replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_NONE)) {\n                                    // Just notify that processing is terminated\n                                    containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                                } else {\n                                    throw new OXFException(\"xforms:submission: invalid replace attribute: \" + replace);\n                                }\n\n                            } else {\n                                // There is no body, notify that processing is terminated\n                                containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                            }\n                        } else if (resultCode == 302 || resultCode == 301) {\n                            // Got a redirect\n\n                            final ExternalContext.Response response = externalContext.getResponse();\n\n                            // Forward headers to response\n                            // TODO: this is duplicated from above\n                            if (resultHeaders != null) {\n                                for (Iterator i = resultHeaders.entrySet().iterator(); i.hasNext();) {\n                                    final Map.Entry currentEntry = (Map.Entry) i.next();\n                                    final String headerName = (String) currentEntry.getKey();\n                                    final List headerValues = (List) currentEntry.getValue();\n\n                                    if (headerName != null && headerValues != null) {\n                                        for (Iterator j = headerValues.iterator(); j.hasNext();) {\n                                            response.addHeader(headerName, (String) j.next());\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Forward redirect\n                            response.setStatus(resultCode);\n\n                        } else {\n                            // Error code received\n                            throw new OXFException(\"Error code received when submitting instance: \" + resultCode);\n                        }\n                    }\n                } finally {\n                    // Clean-up\n                    if (os != null) {\n                        try {\n                            os.close();\n                        } catch (IOException e) {\n                            throw new OXFException(\"Exception while closing output stream for action: \" + action);\n                        }\n                    }\n                    if (resultInputStream != null) {\n                        try {\n                            resultInputStream.close();\n                        } catch (IOException e) {\n                            throw new OXFException(\"Exception while closing input stream for action: \" + action);\n                        }\n                    }\n                    if (urlConnection != null)\n                        urlConnection.disconnect();\n                }\n            } catch (Exception e) {\n                // Any exception will cause an error event to be dispatched\n                containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitErrorEvent(XFormsModelSubmission.this, action, e));\n            }\n\n        } else if (XFormsEvents.XFORMS_BINDING_EXCEPTION.equals(eventName)) {\n            // The default action for this event results in the following: Fatal error.\n            throw new OXFException(\"Binding exception.\");\n        }\n    }","commit_id":"f9c9645f6df65dca42fff2bfdbc794d3bc6a78a9","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void rotateLogAndPushToSlaves() throws IOException\n    {\n        if ( slaveList.size() == 0 )\n        {\n            return;\n        }\n        List<HandleSlaveConnection> newList = \n            new CopyOnWriteArrayList<HandleSlaveConnection>();\n        for ( HandleSlaveConnection slave : slaveList )\n        {\n            XaDataSource xaDs = xaDsMgr.getXaDataSource( slave.getXaDsName() );\n            if ( xaDs != null )\n            {\n                long version = xaDs.getCurrentLogVersion();\n                xaDs.rotateLogicalLog();\n                if ( !slave.offerLogToSlave( version ) )\n                {\n                    System.out.println( \"Failed to offer log to slave: \" + slave );\n                }\n                else\n                {\n                    newList.add( slave );\n                }\n            }\n        }\n        slaveList = newList;\n    }","id":92604,"modified_method":"public synchronized void rotateLogAndPushToSlaves() throws IOException\n    {\n        if ( slaveList.size() == 0 )\n        {\n            return;\n        }\n        for ( XaDataSource xaDs : xaDsMgr.getAllRegisteredDataSources() )\n        {\n            xaDs.rotateLogicalLog();\n        }\n        List<HandleSlaveConnection> newList = \n            new CopyOnWriteArrayList<HandleSlaveConnection>();\n        for ( HandleSlaveConnection slave : slaveList )\n        {\n            XaDataSource xaDs = xaDsMgr.getXaDataSource( slave.getXaDsName() );\n            if ( xaDs != null )\n            {\n                long version = xaDs.getCurrentLogVersion() - 1;\n                if ( !slave.offerLogToSlave( version ) )\n                {\n                    System.out.println( \"Failed to offer log to slave: \" + slave );\n                }\n                else\n                {\n                    newList.add( slave );\n                }\n            }\n        }\n        slaveList = newList;\n    }","commit_id":"5169449b352824e09551505ceea72046b8a7624e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void rotateLogAndPushToSlaves() throws IOException\n    {\n        if ( slaveList.size() == 0 )\n        {\n            return;\n        }\n        List<HandleSlaveConnection> newList = \n            new CopyOnWriteArrayList<HandleSlaveConnection>();\n        for ( HandleSlaveConnection slave : slaveList )\n        {\n            XaDataSource xaDs = xaDsMgr.getXaDataSource( slave.getXaDsName() );\n            if ( xaDs != null )\n            {\n                long version = xaDs.getCurrentLogVersion();\n                xaDs.rotateLogicalLog();\n                if ( !slave.offerLogToSlave( version ) )\n                {\n                    System.out.println( \"Failed to offer log to slave: \" + slave );\n                }\n                else\n                {\n                    newList.add( slave );\n                }\n            }\n        }\n        slaveList = newList;\n    }","id":92605,"modified_method":"public synchronized void rotateLogAndPushToSlaves() throws IOException\n    {\n        if ( slaveList.size() == 0 )\n        {\n            return;\n        }\n        for ( XaDataSource xaDs : xaDsMgr.getAllRegisteredDataSources() )\n        {\n            xaDs.rotateLogicalLog();\n        }\n        List<HandleSlaveConnection> newList = \n            new CopyOnWriteArrayList<HandleSlaveConnection>();\n        for ( HandleSlaveConnection slave : slaveList )\n        {\n            XaDataSource xaDs = xaDsMgr.getXaDataSource( slave.getXaDsName() );\n            if ( xaDs != null )\n            {\n                long version = xaDs.getCurrentLogVersion() - 1;\n                if ( !slave.offerLogToSlave( version ) )\n                {\n                    System.out.println( \"Failed to offer log to slave: \" + slave );\n                }\n                else\n                {\n                    newList.add( slave );\n                }\n            }\n        }\n        slaveList = newList;\n    }","commit_id":"f3f0c4162b798ba2df20204fc06d3cda8ce64434","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void rotateLogAndPushToSlaves() throws IOException\n    {\n        if ( slaveList.size() == 0 )\n        {\n            return;\n        }\n        List<HandleSlaveConnection> newList = \n            new CopyOnWriteArrayList<HandleSlaveConnection>();\n        for ( HandleSlaveConnection slave : slaveList )\n        {\n            XaDataSource xaDs = xaDsMgr.getXaDataSource( slave.getXaDsName() );\n            if ( xaDs != null )\n            {\n                long version = xaDs.getCurrentLogVersion();\n                xaDs.rotateLogicalLog();\n                if ( !slave.offerLogToSlave( version ) )\n                {\n                    System.out.println( \"Failed to offer log to slave: \" + slave );\n                }\n                else\n                {\n                    newList.add( slave );\n                }\n            }\n        }\n        slaveList = newList;\n    }","id":92606,"modified_method":"public synchronized void rotateLogAndPushToSlaves() throws IOException\n    {\n        if ( slaveList.size() == 0 )\n        {\n            return;\n        }\n        for ( XaDataSource xaDs : xaDsMgr.getAllRegisteredDataSources() )\n        {\n            xaDs.rotateLogicalLog();\n        }\n        List<HandleSlaveConnection> newList = \n            new CopyOnWriteArrayList<HandleSlaveConnection>();\n        for ( HandleSlaveConnection slave : slaveList )\n        {\n            XaDataSource xaDs = xaDsMgr.getXaDataSource( slave.getXaDsName() );\n            if ( xaDs != null )\n            {\n                long version = xaDs.getCurrentLogVersion() - 1;\n                if ( !slave.offerLogToSlave( version ) )\n                {\n                    System.out.println( \"Failed to offer log to slave: \" + slave );\n                }\n                else\n                {\n                    newList.add( slave );\n                }\n            }\n        }\n        slaveList = newList;\n    }","commit_id":"db7b47c151d68796c44c0f5fc96e6d529f50e50d","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n   * Constructor.\n   * @param d target database\n   * @param it document to add\n   * @param p document(s) path\n   * @param c database context\n   * @param ii input info\n   */\n  public DBAdd(final Data d, final Item it, final String p, final Context c,\n      final InputInfo ii) {\n\n    super(TYPE.DBADD, d, ii);\n    docs.add(it);\n    paths.add(p);\n    ctx = c;\n  }","id":92607,"modified_method":"/**\n   * Constructor.\n   * @param d target database\n   * @param it document to add (IO or ANode instance)\n   * @param c database context\n   * @param ii input info\n   */\n  public DBAdd(final Data d, final NewInput it, final QueryContext c,\n      final InputInfo ii) {\n\n    super(TYPE.DBADD, d, new ArrayList<NewInput>(), c, ii);\n    inputs.add(it);\n    size = inputs.size();\n  }","commit_id":"4006e91086a5748849486b346baf6b945ce65498","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void merge(final BasicOperation o) {\n    final DBAdd a = (DBAdd) o;\n    final Iterator<Item> d = a.docs.iterator();\n    final Iterator<byte[]> p = a.paths.iterator();\n    while(d.hasNext()) {\n      docs.add(d.next());\n      paths.add(p.next());\n    }\n  }","id":92608,"modified_method":"@Override\n  public void merge(final BasicOperation o) {\n    final DBAdd a = (DBAdd) o;\n    final Iterator<NewInput> d = a.inputs.iterator();\n    while(d.hasNext()) inputs.add(d.next());\n  }","commit_id":"4006e91086a5748849486b346baf6b945ce65498","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void prepare(final MemData tmp) throws QueryException {\n    // build data with all documents, to prevent dirty reads\n    md = new MemData(tmp);\n    for(int i = 0; i < docs.size(); i++) {\n      md.insert(md.meta.size, -1, new DataClip(docData(\n          docs.get(i), paths.get(i), ctx, data.meta.name)));\n      // clear entries to recover memory\n      docs.set(i, null);\n      paths.set(i, null);\n      size++;\n    }\n    docs = null;\n    paths = null;\n  }","id":92609,"modified_method":"@Override\n  public void prepare(final MemData tmp) throws QueryException {\n    addDocs(new MemData(tmp), data.meta.name);\n  }","commit_id":"4006e91086a5748849486b346baf6b945ce65498","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public String toString() {\n    return Util.name(this) + '[' + docs.get(0) + ']';\n  }","id":92610,"modified_method":"@Override\n  public String toString() {\n    return Util.name(this) + '[' + inputs + ']';\n  }","commit_id":"4006e91086a5748849486b346baf6b945ce65498","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void prepare(final MemData tmp) throws QueryException {\n    if(inputs == null) return;\n    // build data with all documents, to prevent dirty reads\n    md = new MemData(ctx.context.prop);\n    final long ds = inputs.size();\n    final int ps = paths.size();\n    for(int i = 0; i < ds; i++) {\n      final byte[] path = i < ps ? paths.get(i) : Token.EMPTY;\n      final Data d = docData(inputs.get(i), path, ctx.context, name);\n      md.insert(md.meta.size, -1, new DataClip(d));\n    }\n    // clear entries to recover memory\n    inputs = null;\n  }","id":92611,"modified_method":"@Override\n  public void prepare(final MemData tmp) throws QueryException {\n    if(inputs != null) addDocs(new MemData(qc.context.prop), name);\n  }","commit_id":"4006e91086a5748849486b346baf6b945ce65498","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param ii input info\n   * @param nm name for created database\n   * @param in initial content item\n   * @param pt paths\n   * @param c query context\n   */\n  public DBCreate(final InputInfo ii, final String nm, final ValueBuilder in,\n      final TokenList pt, final QueryContext c) {\n\n    super(TYPE.DBCREATE, null, ii);\n    ctx = c;\n    name = nm;\n    inputs = in;\n    paths = pt;\n  }","id":92612,"modified_method":"/**\n   * Constructor.\n   * @param ii input info\n   * @param nm name for created database\n   * @param in input (ANode and QueryInput references)\n   * @param c query context\n   */\n  public DBCreate(final InputInfo ii, final String nm, final List<NewInput> in,\n      final QueryContext c) {\n\n    super(TYPE.DBCREATE, null, in, c, ii);\n    name = nm;\n  }","commit_id":"4006e91086a5748849486b346baf6b945ce65498","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void apply() throws QueryException {\n    // close data instance in query processor\n    ctx.resource.removeData(name);\n    // check if addressed databases are still pinned\n    if(ctx.context.pinned(name)) BXDB_OPENED.thrw(info, name);\n\n    try {\n      data = CreateDB.create(name, Parser.emptyParser(ctx.context.prop), ctx.context);\n    } catch(final IOException ex) {\n      UPDBOPTERR.thrw(info, ex);\n    }\n    ctx.resource.addData(data);\n\n    // add initial documents\n    if(md != null) {\n      if(!data.startUpdate()) BXDB_OPENED.thrw(null, data.meta.name);\n      data.insert(data.meta.size, -1, new DataClip(md));\n      try {\n        Optimize.optimize(data, null);\n      } catch(final IOException ex) {\n        data.finishUpdate();\n        UPDBOPTERR.thrw(info, ex);\n      }\n    }\n  }","id":92613,"modified_method":"@Override\n  public void apply() throws QueryException {\n    // close data instance in query processor\n    qc.resource.removeData(name);\n    // check if addressed databases are still pinned\n    if(qc.context.pinned(name)) BXDB_OPENED.thrw(info, name);\n\n    try {\n      data = CreateDB.create(name, Parser.emptyParser(qc.context.prop), qc.context);\n    } catch(final IOException ex) {\n      UPDBOPTERR.thrw(info, ex);\n    }\n    qc.resource.addData(data);\n\n    // add initial documents\n    if(md != null) {\n      if(!data.startUpdate()) BXDB_OPENED.thrw(null, data.meta.name);\n      data.insert(data.meta.size, -1, new DataClip(md));\n      try {\n        Optimize.optimize(data, null);\n      } catch(final IOException ex) {\n        data.finishUpdate();\n        UPDBOPTERR.thrw(info, ex);\n      }\n    }\n  }","commit_id":"4006e91086a5748849486b346baf6b945ce65498","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void apply() throws QueryException {\n    for(final byte[] path : map) {\n      try {\n        final IOFile file = data.meta.binary(string(path));\n        if(file == null) UPDBPUTERR.thrw(info, path);\n        file.dir().md();\n        file.write(map.get(path).input(info));\n      } catch(final IOException ex) {\n        Util.debug(ex);\n        UPDBPUTERR.thrw(info, path);\n      }\n    }\n  }","id":92614,"modified_method":"@Override\n  public void apply() throws QueryException {\n    for(final byte[] path : map) {\n      try {\n        final IOFile file = data.meta.binary(string(path));\n        if(file == null) UPDBPUTERR.thrw(info, path);\n        file.dir().md();\n        final Object item = map.get(path);\n        file.write(item instanceof Item ? ((Item) item).input(info) :\n          ((QueryInput) item).io.inputStream());\n      } catch(final IOException ex) {\n        Util.debug(ex);\n        UPDBPUTERR.thrw(info, path);\n      }\n    }\n  }","commit_id":"4006e91086a5748849486b346baf6b945ce65498","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param d data\n   * @param path target path\n   * @param it item to be stored\n   * @param ii input info\n   */\n  public DBStore(final Data d, final String path, final Item it, final InputInfo ii) {\n    super(TYPE.DBSTORE, d, ii);\n    map.add(token(path), it);\n  }","id":92615,"modified_method":"/**\n   * Constructor.\n   * @param d data\n   * @param path target path\n   * @param it item to be stored\n   * @param ii input info\n   */\n  public DBStore(final Data d, final String path, final Object it, final InputInfo ii) {\n    super(TYPE.DBSTORE, d, ii);\n    map.add(token(path), it);\n  }","commit_id":"4006e91086a5748849486b346baf6b945ce65498","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs the add function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item add(final QueryContext ctx) throws QueryException {\r\n    final Data data = checkWrite(data(0, ctx), ctx);\r\n    final Item it = checkItem(expr[1], ctx);\r\n    final String path = expr.length < 3 ? \"\" : path(2, ctx);\r\n\r\n    ctx.updates.add(new DBAdd(data, it, path, ctx.context, info), ctx);\r\n    return null;\r\n  }","id":92616,"modified_method":"/**\r\n   * Performs the add function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item add(final QueryContext ctx) throws QueryException {\r\n    final Data data = checkWrite(data(0, ctx), ctx);\r\n    final byte[] path = expr.length < 3 ? Token.EMPTY : token(path(2, ctx));\r\n    final NewInput input = checkInput(checkItem(expr[1], ctx), path);\r\n    ctx.updates.add(new DBAdd(data, input, ctx, info), ctx);\r\n    return null;\r\n  }","commit_id":"4006e91086a5748849486b346baf6b945ce65498","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs the replace function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item replace(final QueryContext ctx) throws QueryException {\r\n    final Data data = checkWrite(data(0, ctx), ctx);\r\n    final String path = path(1, ctx);\r\n    final Item doc = checkItem(expr[2], ctx);\r\n\r\n    // remove old documents\r\n    final Resources res = data.resources;\r\n    final IntList pre = res.docs(path, true);\r\n    for(int p = 0; p < pre.size(); p++) {\r\n      ctx.updates.add(new DeleteNode(pre.get(p), data, info), ctx);\r\n    }\r\n\r\n    // delete binary resources\r\n    final IOFile bin = data.inMemory() ? null : data.meta.binary(path);\r\n    if(bin != null) {\r\n      if(bin.exists()) {\r\n        if(bin.isDir()) BXDB_SINGLE.thrw(info);\r\n        ctx.updates.add(new DBStore(data, path, doc, info), ctx);\r\n      } else {\r\n        ctx.updates.add(new DBAdd(data, doc, path, ctx.context, info), ctx);\r\n      }\r\n    }\r\n    return null;\r\n  }","id":92617,"modified_method":"/**\r\n   * Performs the replace function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item replace(final QueryContext ctx) throws QueryException {\r\n    final Data data = checkWrite(data(0, ctx), ctx);\r\n    final String path = path(1, ctx);\r\n    final NewInput input = checkInput(checkItem(expr[2], ctx), token(path));\r\n\r\n    // remove old documents\r\n    final Resources res = data.resources;\r\n    final IntList pre = res.docs(path, true);\r\n    for(int p = 0; p < pre.size(); p++) {\r\n      ctx.updates.add(new DeleteNode(pre.get(p), data, info), ctx);\r\n    }\r\n\r\n    // delete binary resources\r\n    final IOFile bin = data.inMemory() ? null : data.meta.binary(path);\r\n    if(bin != null) {\r\n      if(bin.exists()) {\r\n        if(bin.isDir()) BXDB_SINGLE.thrw(info);\r\n        ctx.updates.add(new DBStore(data, path, input, info), ctx);\r\n      } else {\r\n        ctx.updates.add(new DBAdd(data, input, ctx, info), ctx);\r\n      }\r\n    }\r\n    return null;\r\n  }","commit_id":"4006e91086a5748849486b346baf6b945ce65498","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs the create function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item create(final QueryContext ctx) throws QueryException {\r\n    final String name = string(checkStr(expr[0], ctx));\r\n    if(!MetaData.validName(name, false)) BXDB_NAME.thrw(info, name);\r\n\r\n    final ValueBuilder inputs = new ValueBuilder();\r\n    final TokenList paths = new TokenList();\r\n    if(expr.length > 1) {\r\n      final Iter ir = ctx.iter(expr[1]);\r\n      for(Item it; (it = ir.next()) != null;) inputs.add(it);\r\n    }\r\n    if(expr.length > 2) {\r\n      final Iter ir = ctx.iter(expr[2]);\r\n      for(Item it; (it = ir.next()) != null;) {\r\n        final String path = string(checkStr(it, ctx));\r\n        final String norm = MetaData.normPath(path);\r\n        if(norm == null) RESINV.thrw(info, path);\r\n        paths.add(norm);\r\n      }\r\n    }\r\n    final long is = inputs.size();\r\n    final int ps = paths.size();\r\n    if(ps != 0 && is != ps) BXDB_CREATEARGS.thrw(info, is, ps);\r\n\r\n    ctx.updates.add(new DBCreate(info, name, inputs, paths, ctx), ctx);\r\n    return null;\r\n  }","id":92618,"modified_method":"/**\r\n   * Performs the create function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item create(final QueryContext ctx) throws QueryException {\r\n    final String name = string(checkStr(expr[0], ctx));\r\n    if(!MetaData.validName(name, false)) BXDB_NAME.thrw(info, name);\r\n\r\n    final TokenList paths = new TokenList();\r\n    if(expr.length > 2) {\r\n      final Iter ir = ctx.iter(expr[2]);\r\n      for(Item it; (it = ir.next()) != null;) {\r\n        final String path = string(checkStr(it, ctx));\r\n        final String norm = MetaData.normPath(path);\r\n        if(norm == null) RESINV.thrw(info, path);\r\n        paths.add(norm);\r\n      }\r\n    }\r\n\r\n    final int ps = paths.size();\r\n    final List<NewInput> inputs = new ArrayList<NewInput>(ps);\r\n    if(expr.length > 1) {\r\n      final Value val = ctx.value(expr[1]);\r\n      // number of specified inputs and paths must be identical\r\n      final long is = val.size();\r\n      if(ps != 0 && is != ps) BXDB_CREATEARGS.thrw(info, is, ps);\r\n\r\n      for(int i = 0; i < is; i++) {\r\n        final byte[] path = i < ps ? paths.get(i) : Token.EMPTY;\r\n        inputs.add(checkInput(val.itemAt(i), path));\r\n      }\r\n    }\r\n\r\n    ctx.updates.add(new DBCreate(info, name, inputs, ctx), ctx);\r\n    return null;\r\n  }","commit_id":"4006e91086a5748849486b346baf6b945ce65498","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Performs the store function.\n   * @param qc query context\n   * @return {@code null}\n   * @throws QueryException query exception\n   */\n  private Item store(final QueryContext qc) throws QueryException {\n    final Data data = checkData(qc);\n    final String path = path(1, qc);\n    if(data.inMemory()) throw BXDB_MEM.get(info, data.meta.name);\n    final IOFile file = data.meta.binary(path);\n    if(file == null || file.isDir()) throw RESINV.get(info, path);\n\n    final Item it = checkItem(exprs[2], qc);\n    qc.resources.updates().add(new DBStore(data, path, it, info), qc);\n    return null;\n  }","id":92619,"modified_method":"/**\n   * Performs the store function.\n   * @param qc query context\n   * @return {@code null}\n   * @throws QueryException query exception\n   */\n  private Item store(final QueryContext qc) throws QueryException {\n    final Data data = checkData(qc);\n    final String path = path(1, qc);\n    final Item item = checkItem(exprs[2], qc);\n\n    if(data.inMemory()) throw BXDB_MEM.get(info, data.meta.name);\n    final IOFile file = data.meta.binary(path);\n    if(file == null || file.isDir()) throw RESINV.get(info, path);\n\n    qc.resources.updates().add(new DBStore(data, path, item, info), qc);\n    return null;\n  }","commit_id":"5479c2833d85181186f1552a43ba9d7d68b1a46c","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Performs the replace function.\n   * @param qc query context\n   * @return {@code null}\n   * @throws QueryException query exception\n   */\n  private Item replace(final QueryContext qc) throws QueryException {\n    final Data data = checkData(qc);\n    final String path = path(1, qc);\n    final NewInput input = checkInput(checkItem(exprs[2], qc), token(path));\n    final Options opts = checkOptions(3, Q_OPTIONS, new Options(), qc);\n\n    // remove old documents\n    final Resources res = data.resources;\n    final IntList pre = res.docs(path, true);\n    final Updates updates = qc.resources.updates();\n    for(int p = 0; p < pre.size(); p++) {\n      updates.add(new DeleteNode(pre.get(p), data, info), qc);\n    }\n\n    // delete binary resources\n    final IOFile bin = data.inMemory() ? null : data.meta.binary(path);\n    if(bin != null) {\n      if(bin.exists()) {\n        if(bin.isDir()) throw BXDB_DIR.get(info, path);\n        updates.add(new DBStore(data, path, input, info), qc);\n      } else {\n        updates.add(new DBAdd(data, input, opts, qc, info), qc);\n      }\n    }\n    return null;\n  }","id":92620,"modified_method":"/**\n   * Performs the replace function.\n   * @param qc query context\n   * @return {@code null}\n   * @throws QueryException query exception\n   */\n  private Item replace(final QueryContext qc) throws QueryException {\n    final Data data = checkData(qc);\n    final String path = path(1, qc);\n    final Item item = checkItem(exprs[2], qc);\n    final Options opts = checkOptions(3, Q_OPTIONS, new Options(), qc);\n\n    // remove old documents\n    final Resources res = data.resources;\n    final IntList pre = res.docs(path, true);\n    final Updates updates = qc.resources.updates();\n    for(int p = 0; p < pre.size(); p++) {\n      updates.add(new DeleteNode(pre.get(p), data, info), qc);\n    }\n\n    // delete binary resources\n    final IOFile bin = data.inMemory() ? null : data.meta.binary(path);\n    if(bin != null) {\n      if(bin.exists() || item instanceof Bin) {\n        if(bin.isDir()) throw BXDB_DIR.get(info, path);\n        updates.add(new DBStore(data, path, item, info), qc);\n      } else {\n        updates.add(new DBAdd(data, checkInput(item, token(path)), opts, qc, info), qc);\n      }\n    }\n    return null;\n  }","commit_id":"5479c2833d85181186f1552a43ba9d7d68b1a46c","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n    public Iterable<String> getCompletionProposals(UIContext context, InputComponent input, String value) {\n        List<String> answer = new ArrayList<String>();\n        // find the version of Apache Camel we use\n\n        // need to find camel-core so we known the camel version\n        Dependency core = CamelProjectHelper.findCamelCoreDependency(project);\n        if (core == null) {\n            return null;\n        }\n\n        // find all available component names\n        CamelComponentCatalog catalog = new DefaultCamelComponentCatalog();\n        List<String> names = catalog.findComponentNames();\n\n        // filter non matching names first\n        List<String> filtered = new ArrayList<String>();\n        for (String name : names) {\n            if (value == null || name.startsWith(value)) {\n                filtered.add(name);\n            }\n        }\n\n        // filter names which are already on the classpath\n        for (String name : filtered) {\n            String json = catalog.componentJSonSchema(name);\n            String[] artifactAndVersion = findArtifactIdAndVersion(json);\n\n            // skip if we already have the dependency\n            boolean already = CamelProjectHelper.hasDependency(project, \"org.apache.camel\", artifactAndVersion[0], artifactAndVersion[1]);\n\n            if (!already) {\n                answer.add(name);\n            }\n        }\n\n        return answer;\n    }","id":92621,"modified_method":"@Override\n    public Iterable<String> getCompletionProposals(UIContext context, InputComponent input, String value) {\n        List<String> answer = new ArrayList<String>();\n        // find the version of Apache Camel we use\n\n        // need to find camel-core so we known the camel version\n        Dependency core = CamelProjectHelper.findCamelCoreDependency(project);\n        if (core == null) {\n            return null;\n        }\n\n        // find all available component names\n        CamelComponentCatalog catalog = new DefaultCamelComponentCatalog();\n        List<String> names = catalog.findComponentNames();\n\n        // filter non matching names first\n        List<String> filtered = new ArrayList<String>();\n        for (String name : names) {\n            if (value == null || name.startsWith(value)) {\n                filtered.add(name);\n            }\n        }\n\n        // filter names which are already on the classpath\n        for (String name : filtered) {\n            String json = catalog.componentJSonSchema(name);\n            String[] artifactAndVersion = findArtifactIdAndVersion(json);\n\n            // skip if we already have the dependency\n            boolean already = false;\n            if (artifactAndVersion != null) {\n                already = CamelProjectHelper.hasDependency(project, \"org.apache.camel\", artifactAndVersion[0], artifactAndVersion[1]);\n            }\n            if (!already) {\n                answer.add(name);\n            }\n        }\n\n        return answer;\n    }","commit_id":"7a972c8f9e1c17c971a7bdb49e5964e4733408bb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private static String[] findArtifactIdAndVersion(String json) {\n        // filter by version and find the artifact id\n        String artifactId = null;\n        String version = null;\n\n        List<Map<String, String>> data = JSonSchemaHelper.parseJsonSchema(\"component\", json, false);\n        for (Map<String, String> row : data) {\n            if (row.get(\"artifactId\") != null) {\n                artifactId = row.get(\"artifactId\");\n            }\n            if (row.get(\"version\") != null) {\n                version = row.get(\"version\");\n            }\n        }\n\n        return new String[]{artifactId, version};\n    }","id":92622,"modified_method":"private static String[] findArtifactIdAndVersion(String json) {\n        // filter by version and find the artifact id\n        String artifactId = null;\n        String version = null;\n\n        List<Map<String, String>> data = JSonSchemaHelper.parseJsonSchema(\"component\", json, false);\n        for (Map<String, String> row : data) {\n            if (row.get(\"artifactId\") != null) {\n                artifactId = row.get(\"artifactId\");\n            }\n            if (row.get(\"version\") != null) {\n                version = row.get(\"version\");\n            }\n        }\n\n        if (artifactId != null && version != null) {\n            return new String[]{artifactId, version};\n        } else {\n            return null;\n        }\n    }","commit_id":"7a972c8f9e1c17c971a7bdb49e5964e4733408bb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Iterable<String> getCompletionProposals(UIContext context, InputComponent input, String value) {\n        List<String> answer = new ArrayList<String>();\n        // find the version of Apache Camel we use\n\n        // need to find camel-core so we known the camel version\n        Dependency core = CamelProjectHelper.findCamelCoreDependency(project);\n        if (core == null) {\n            return null;\n        }\n\n        // find all available dataformat names\n        CamelComponentCatalog catalog = new DefaultCamelComponentCatalog();\n        List<String> names = catalog.findDataFormatNames();\n\n        // filter non matching names first\n        List<String> filtered = new ArrayList<String>();\n        for (String name : names) {\n            if (value == null || name.startsWith(value)) {\n                filtered.add(name);\n            }\n        }\n\n        // filter names which are already on the classpath\n        for (String name : filtered) {\n            String json = catalog.dataFormatJSonSchema(name);\n            String[] artifactAndVersion = findArtifactIdAndVersion(json);\n\n            // skip if we already have the dependency\n            boolean already = CamelProjectHelper.hasDependency(project, \"org.apache.camel\", artifactAndVersion[0], artifactAndVersion[1]);\n\n            if (!already) {\n                answer.add(name);\n            }\n        }\n\n        return answer;\n    }","id":92623,"modified_method":"@Override\n    public Iterable<String> getCompletionProposals(UIContext context, InputComponent input, String value) {\n        List<String> answer = new ArrayList<String>();\n        // find the version of Apache Camel we use\n\n        // need to find camel-core so we known the camel version\n        Dependency core = CamelProjectHelper.findCamelCoreDependency(project);\n        if (core == null) {\n            return null;\n        }\n\n        // find all available dataformat names\n        CamelComponentCatalog catalog = new DefaultCamelComponentCatalog();\n        List<String> names = catalog.findDataFormatNames();\n\n        // filter non matching names first\n        List<String> filtered = new ArrayList<String>();\n        for (String name : names) {\n            if (value == null || name.startsWith(value)) {\n                filtered.add(name);\n            }\n        }\n\n        // filter names which are already on the classpath\n        for (String name : filtered) {\n            String json = catalog.dataFormatJSonSchema(name);\n            String[] artifactAndVersion = findArtifactIdAndVersion(json);\n\n            // skip if we already have the dependency\n            boolean already = false;\n            if (artifactAndVersion != null) {\n                already = CamelProjectHelper.hasDependency(project, \"org.apache.camel\", artifactAndVersion[0], artifactAndVersion[1]);\n            }\n            if (!already) {\n                answer.add(name);\n            }\n        }\n\n        return answer;\n    }","commit_id":"7a972c8f9e1c17c971a7bdb49e5964e4733408bb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private static String[] findArtifactIdAndVersion(String json) {\n        // filter by version and find the artifact id\n        String artifactId = null;\n        String version = null;\n\n        List<Map<String, String>> data = JSonSchemaHelper.parseJsonSchema(\"dataformat\", json, false);\n        for (Map<String, String> row : data) {\n            if (row.get(\"artifactId\") != null) {\n                artifactId = row.get(\"artifactId\");\n            }\n            if (row.get(\"version\") != null) {\n                version = row.get(\"version\");\n            }\n        }\n\n        return new String[]{artifactId, version};\n    }","id":92624,"modified_method":"private static String[] findArtifactIdAndVersion(String json) {\n        // filter by version and find the artifact id\n        String artifactId = null;\n        String version = null;\n\n        List<Map<String, String>> data = JSonSchemaHelper.parseJsonSchema(\"dataformat\", json, false);\n        for (Map<String, String> row : data) {\n            if (row.get(\"artifactId\") != null) {\n                artifactId = row.get(\"artifactId\");\n            }\n            if (row.get(\"version\") != null) {\n                version = row.get(\"version\");\n            }\n        }\n\n        if (artifactId != null && version != null) {\n            return new String[]{artifactId, version};\n        } else {\n            return null;\n        }\n    }","commit_id":"7a972c8f9e1c17c971a7bdb49e5964e4733408bb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Iterable<String> getCompletionProposals(UIContext context, InputComponent input, String value) {\n        List<String> answer = new ArrayList<String>();\n        // find the version of Apache Camel we use\n\n        // need to find camel-core so we known the camel version\n        Dependency core = CamelProjectHelper.findCamelCoreDependency(project);\n        if (core == null) {\n            return null;\n        }\n\n        // find all available language names\n        CamelComponentCatalog catalog = new DefaultCamelComponentCatalog();\n        List<String> names = catalog.findLanguageNames();\n\n        // filter non matching names first\n        List<String> filtered = new ArrayList<String>();\n        for (String name : names) {\n            if (value == null || name.startsWith(value)) {\n                filtered.add(name);\n            }\n        }\n\n        // filter names which are already on the classpath\n        for (String name : filtered) {\n            String json = catalog.languageJSonSchema(name);\n            String[] artifactAndVersion = findArtifactIdAndVersion(json);\n\n            // skip if we already have the dependency\n            boolean already = CamelProjectHelper.hasDependency(project, \"org.apache.camel\", artifactAndVersion[0], artifactAndVersion[1]);\n\n            if (!already) {\n                answer.add(name);\n            }\n        }\n\n        return answer;\n    }","id":92625,"modified_method":"@Override\n    public Iterable<String> getCompletionProposals(UIContext context, InputComponent input, String value) {\n        List<String> answer = new ArrayList<String>();\n        // find the version of Apache Camel we use\n\n        // need to find camel-core so we known the camel version\n        Dependency core = CamelProjectHelper.findCamelCoreDependency(project);\n        if (core == null) {\n            return null;\n        }\n\n        // find all available language names\n        CamelComponentCatalog catalog = new DefaultCamelComponentCatalog();\n        List<String> names = catalog.findLanguageNames();\n\n        // filter non matching names first\n        List<String> filtered = new ArrayList<String>();\n        for (String name : names) {\n            if (value == null || name.startsWith(value)) {\n                filtered.add(name);\n            }\n        }\n\n        // filter names which are already on the classpath\n        for (String name : filtered) {\n            String json = catalog.languageJSonSchema(name);\n            String[] artifactAndVersion = findArtifactIdAndVersion(json);\n\n            // skip if we already have the dependency\n            boolean already = false;\n            if (artifactAndVersion != null) {\n                already = CamelProjectHelper.hasDependency(project, \"org.apache.camel\", artifactAndVersion[0], artifactAndVersion[1]);\n            }\n            if (!already) {\n                answer.add(name);\n            }\n        }\n\n        return answer;\n    }","commit_id":"7a972c8f9e1c17c971a7bdb49e5964e4733408bb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private static String[] findArtifactIdAndVersion(String json) {\n        // filter by version and find the artifact id\n        String artifactId = null;\n        String version = null;\n\n        List<Map<String, String>> data = JSonSchemaHelper.parseJsonSchema(\"language\", json, false);\n        for (Map<String, String> row : data) {\n            if (row.get(\"artifactId\") != null) {\n                artifactId = row.get(\"artifactId\");\n            }\n            if (row.get(\"version\") != null) {\n                version = row.get(\"version\");\n            }\n        }\n\n        return new String[]{artifactId, version};\n    }","id":92626,"modified_method":"private static String[] findArtifactIdAndVersion(String json) {\n        // filter by version and find the artifact id\n        String artifactId = null;\n        String version = null;\n\n        List<Map<String, String>> data = JSonSchemaHelper.parseJsonSchema(\"language\", json, false);\n        for (Map<String, String> row : data) {\n            if (row.get(\"artifactId\") != null) {\n                artifactId = row.get(\"artifactId\");\n            }\n            if (row.get(\"version\") != null) {\n                version = row.get(\"version\");\n            }\n        }\n\n        if (artifactId != null && version != null) {\n            return new String[]{artifactId, version};\n        } else {\n            return null;\n        }\n    }","commit_id":"7a972c8f9e1c17c971a7bdb49e5964e4733408bb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n  public void processIntention(PsiElement element)\n    throws IncorrectOperationException {\n    final PsiMethodCallExpression call = (PsiMethodCallExpression)element;\n    final PsiReferenceExpression methodExpression =\n      call.getMethodExpression();\n    @NonNls final String fromMethodName =\n      methodExpression.getReferenceName();\n    @NonNls final String toMethodName;\n    if (\"assertTrue\".equals(fromMethodName)) {\n      toMethodName = \"assertFalse\";\n    }\n    else {\n      toMethodName = \"assertTrue\";\n    }\n    final StringBuilder newCall = new StringBuilder();\n    final PsiElement qualifier = methodExpression.getQualifier();\n    if (qualifier == null) {\n      final PsiMethod containingMethod =\n        PsiTreeUtil.getParentOfType(call, PsiMethod.class);\n      if (containingMethod != null &&\n          AnnotationUtil.isAnnotated(containingMethod, \"org.junit.Test\", true)) {\n        if (ImportUtils.nameCanBeStaticallyImported(\n          \"org.junit.Assert\", toMethodName, element)) {\n          ImportUtils.addStaticImport(\"org.junit.Assert\", toMethodName, element);\n        }\n        else {\n          newCall.append(\"org.junit.Assert.\");\n        }\n      }\n    }\n    else {\n      newCall.append(qualifier.getText());\n      newCall.append('.');\n    }\n    newCall.append(toMethodName);\n    newCall.append('(');\n    final PsiExpressionList argumentList = call.getArgumentList();\n    final PsiExpression[] args = argumentList.getExpressions();\n    if (args.length == 1) {\n      newCall.append(BoolUtils.getNegatedExpressionText(args[0]));\n    }\n    else {\n      newCall.append(BoolUtils.getNegatedExpressionText(args[1]));\n    }\n    newCall.append(')');\n    replaceExpression(newCall.toString(), call);\n  }","id":92627,"modified_method":"@Override\n  public void processIntention(@NotNull PsiElement element) {\n    final PsiMethodCallExpression call = (PsiMethodCallExpression)element;\n    final PsiReferenceExpression methodExpression = call.getMethodExpression();\n    @NonNls final String fromMethodName = methodExpression.getReferenceName();\n    @NonNls final String toMethodName;\n    if (\"assertTrue\".equals(fromMethodName)) {\n      toMethodName = \"assertFalse\";\n    }\n    else {\n      toMethodName = \"assertTrue\";\n    }\n    @NonNls final StringBuilder newCall = new StringBuilder();\n    final PsiElement qualifier = methodExpression.getQualifier();\n    if (qualifier == null) {\n      final PsiMethod containingMethod = PsiTreeUtil.getParentOfType(call, PsiMethod.class);\n      if (containingMethod != null && AnnotationUtil.isAnnotated(containingMethod, \"org.junit.Test\", true)) {\n        if (!ImportUtils.addStaticImport(\"org.junit.Assert\", toMethodName, element)) {\n          newCall.append(\"org.junit.Assert.\");\n        }\n      }\n    }\n    else {\n      newCall.append(qualifier.getText()).append('.');\n    }\n    newCall.append(toMethodName).append('(');\n    final PsiExpressionList argumentList = call.getArgumentList();\n    final PsiExpression[] args = argumentList.getExpressions();\n    if (args.length == 1) {\n      newCall.append(BoolUtils.getNegatedExpressionText(args[0]));\n    }\n    else {\n      newCall.append(BoolUtils.getNegatedExpressionText(args[1]));\n    }\n    newCall.append(')');\n    replaceExpression(newCall.toString(), call);\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof PsiJavaCodeReferenceElement)) {\n      return false;\n    }\n    final PsiJavaCodeReferenceElement referenceElement =\n      (PsiJavaCodeReferenceElement)element;\n    if (!referenceElement.isQualified()) {\n      return false;\n    }\n    final PsiElement parent = referenceElement.getParent();\n    if (parent instanceof PsiMethodCallExpression ||\n        parent instanceof PsiAssignmentExpression ||\n        parent instanceof PsiVariable) {\n      return false;\n    }\n    if (PsiTreeUtil.getParentOfType(element, PsiImportStatementBase.class,\n                                    PsiPackageStatement.class, JavaCodeFragment.class) != null) {\n      return false;\n    }\n    final PsiElement qualifier = referenceElement.getQualifier();\n    if (!(qualifier instanceof PsiJavaCodeReferenceElement)) {\n      return false;\n    }\n    final PsiJavaCodeReferenceElement qualifierReferenceElement =\n      (PsiJavaCodeReferenceElement)qualifier;\n    final PsiElement resolved = qualifierReferenceElement.resolve();\n    if (!(resolved instanceof PsiPackage)) {\n      if (!(resolved instanceof PsiClass)) {\n        return false;\n      }\n      final Project project = element.getProject();\n      final CodeStyleSettings codeStyleSettings =\n        CodeStyleSettingsManager.getSettings(project);\n      if (!codeStyleSettings.INSERT_INNER_CLASS_IMPORTS) {\n        return false;\n      }\n    }\n    final PsiElement target = referenceElement.resolve();\n    if (!(target instanceof PsiClass)) {\n      return false;\n    }\n    final PsiClass aClass = (PsiClass)target;\n    final String fqName = aClass.getQualifiedName();\n    if (fqName == null) {\n      return false;\n    }\n    final PsiJavaFile javaFile =\n      PsiTreeUtil.getParentOfType(referenceElement, PsiJavaFile.class);\n    return javaFile != null &&\n           ImportUtils.nameCanBeImported(fqName, javaFile);\n  }","id":92628,"modified_method":"public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof PsiJavaCodeReferenceElement)) {\n      return false;\n    }\n    final PsiJavaCodeReferenceElement referenceElement = (PsiJavaCodeReferenceElement)element;\n    if (!referenceElement.isQualified()) {\n      return false;\n    }\n    final PsiElement parent = referenceElement.getParent();\n    if (parent instanceof PsiMethodCallExpression || parent instanceof PsiAssignmentExpression || parent instanceof PsiVariable) {\n      return false;\n    }\n    if (PsiTreeUtil.getParentOfType(element, PsiImportStatementBase.class, PsiPackageStatement.class, JavaCodeFragment.class) != null) {\n      return false;\n    }\n    final PsiElement qualifier = referenceElement.getQualifier();\n    if (!(qualifier instanceof PsiJavaCodeReferenceElement)) {\n      return false;\n    }\n    final PsiJavaCodeReferenceElement qualifierReferenceElement = (PsiJavaCodeReferenceElement)qualifier;\n    final PsiElement resolved = qualifierReferenceElement.resolve();\n    if (!(resolved instanceof PsiPackage)) {\n      if (!(resolved instanceof PsiClass)) {\n        return false;\n      }\n      final Project project = element.getProject();\n      final CodeStyleSettings codeStyleSettings = CodeStyleSettingsManager.getSettings(project);\n      if (!codeStyleSettings.INSERT_INNER_CLASS_IMPORTS) {\n        return false;\n      }\n    }\n    final PsiElement target = referenceElement.resolve();\n    if (!(target instanceof PsiClass)) {\n      return false;\n    }\n    final PsiClass aClass = (PsiClass)target;\n    final String fqName = aClass.getQualifiedName();\n    if (fqName == null) {\n      return false;\n    }\n    return ImportUtils.nameCanBeImported(fqName, element);\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param strict if strict is true this method checks if the conflicting\n   *               class which is imported is actually used in the file. If it isn't the\n   *               on demand import can be overridden with an exact import for the fqName\n   *               without breaking stuff.\n   */\n  private static boolean hasOnDemandImportConflict(@NotNull String fqName,\n                                                   @NotNull PsiJavaFile file,\n                                                   boolean strict) {\n    final PsiImportList imports = file.getImportList();\n    if (imports == null) {\n      return false;\n    }\n    final PsiImportStatement[] importStatements =\n      imports.getImportStatements();\n    final String shortName = ClassUtil.extractClassName(fqName);\n    final String packageName = ClassUtil.extractPackageName(fqName);\n    for (final PsiImportStatement importStatement : importStatements) {\n      if (!importStatement.isOnDemand()) {\n        continue;\n      }\n      final PsiJavaCodeReferenceElement importReference =\n        importStatement.getImportReference();\n      if (importReference == null) {\n        continue;\n      }\n      final String packageText = importReference.getText();\n      if (packageText.equals(packageName)) {\n        continue;\n      }\n      final PsiElement element = importReference.resolve();\n      if (element == null || !(element instanceof PsiPackage)) {\n        continue;\n      }\n      final PsiPackage aPackage = (PsiPackage)element;\n      final PsiClass[] classes = aPackage.getClasses();\n      for (final PsiClass aClass : classes) {\n        final String className = aClass.getName();\n        if (!shortName.equals(className)) {\n          continue;\n        }\n        if (!strict) {\n          return true;\n        }\n        final String qualifiedClassName = aClass.getQualifiedName();\n        final ClassReferenceVisitor visitor =\n          new ClassReferenceVisitor(qualifiedClassName);\n        file.accept(visitor);\n        return visitor.isReferenceFound();\n      }\n    }\n    return hasJavaLangImportConflict(fqName, file);\n  }","id":92629,"modified_method":"/**\n   * @param strict if strict is true this method checks if the conflicting\n   *               class which is imported is actually used in the file. If it isn't the\n   *               on demand import can be overridden with an exact import for the fqName\n   *               without breaking stuff.\n   */\n  private static boolean hasOnDemandImportConflict(@NotNull String fqName, @NotNull PsiJavaFile file, boolean strict) {\n    final PsiImportList imports = file.getImportList();\n    if (imports == null) {\n      return false;\n    }\n    final PsiImportStatement[] importStatements = imports.getImportStatements();\n    final String shortName = ClassUtil.extractClassName(fqName);\n    final String packageName = ClassUtil.extractPackageName(fqName);\n    for (final PsiImportStatement importStatement : importStatements) {\n      if (!importStatement.isOnDemand()) {\n        continue;\n      }\n      final PsiJavaCodeReferenceElement importReference = importStatement.getImportReference();\n      if (importReference == null) {\n        continue;\n      }\n      final String packageText = importReference.getText();\n      if (packageText.equals(packageName)) {\n        continue;\n      }\n      final PsiElement element = importReference.resolve();\n      if (element == null || !(element instanceof PsiPackage)) {\n        continue;\n      }\n      final PsiPackage aPackage = (PsiPackage)element;\n      final PsiClass[] classes = aPackage.getClasses();\n      for (final PsiClass aClass : classes) {\n        final String className = aClass.getName();\n        if (!shortName.equals(className)) {\n          continue;\n        }\n        if (!strict) {\n          return true;\n        }\n        final String qualifiedClassName = aClass.getQualifiedName();\n        if (qualifiedClassName == null || fqName.equals(qualifiedClassName)) {\n          continue;\n        }\n        return containsReferenceToConflictingClass(file, qualifiedClassName);\n      }\n    }\n    return hasJavaLangImportConflict(fqName, file);\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void addImportIfNeeded(PsiJavaFile file, PsiClass aClass) {\n    final PsiFile containingFile = aClass.getContainingFile();\n    if (file.equals(containingFile)) {\n      return;\n    }\n    final String qualifiedName = aClass.getQualifiedName();\n    if (qualifiedName == null) {\n      return;\n    }\n    final PsiImportList importList = file.getImportList();\n    if (importList == null) {\n      return;\n    }\n    final String containingPackageName = file.getPackageName();\n    @NonNls final String packageName =\n      ClassUtil.extractPackageName(qualifiedName);\n    if (containingPackageName.equals(packageName) ||\n        importList.findSingleClassImportStatement(qualifiedName) !=\n        null) {\n      return;\n    }\n    if (importList.findOnDemandImportStatement(packageName) != null &&\n        !hasDefaultImportConflict(qualifiedName, file) &&\n        !hasOnDemandImportConflict(qualifiedName, file)) {\n      return;\n    }\n    final Project project = importList.getProject();\n    final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n    final PsiElementFactory elementFactory =\n      psiFacade.getElementFactory();\n    final PsiImportStatement importStatement =\n      elementFactory.createImportStatement(aClass);\n    importList.add(importStatement);\n  }","id":92630,"modified_method":"public static void addImportIfNeeded(@NotNull PsiClass aClass, @NotNull PsiElement context) {\n    final PsiFile file = context.getContainingFile();\n    if (!(file instanceof PsiJavaFile)) {\n      return;\n    }\n    final PsiJavaFile javaFile = (PsiJavaFile)file;\n    final PsiClass outerClass = aClass.getContainingClass();\n    if (outerClass == null) {\n      if (PsiTreeUtil.isAncestor(javaFile, aClass, true)) {\n        return;\n      }\n    }\n    else {\n      if (PsiTreeUtil.isAncestor(outerClass, context, true) &&\n          !PsiTreeUtil.isAncestor(outerClass.getModifierList(), context, true)) {\n        return;\n      }\n    }\n    final String qualifiedName = aClass.getQualifiedName();\n    if (qualifiedName == null) {\n      return;\n    }\n    final PsiImportList importList = javaFile.getImportList();\n    if (importList == null) {\n      return;\n    }\n    final String containingPackageName = javaFile.getPackageName();\n    @NonNls final String packageName = ClassUtil.extractPackageName(qualifiedName);\n    if (containingPackageName.equals(packageName) || importList.findSingleClassImportStatement(qualifiedName) != null) {\n      return;\n    }\n    if (importList.findOnDemandImportStatement(packageName) != null &&\n        !hasDefaultImportConflict(qualifiedName, javaFile) && !hasOnDemandImportConflict(qualifiedName, javaFile)) {\n      return;\n    }\n    final Project project = importList.getProject();\n    final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n    final PsiElementFactory elementFactory = psiFacade.getElementFactory();\n    final PsiImportStatement importStatement = elementFactory.createImportStatement(aClass);\n    importList.add(importStatement);\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isStaticallyImported(@NotNull PsiMember member,\n                                             @NotNull PsiElement context) {\n    final PsiClass memberClass = member.getContainingClass();\n    if (memberClass == null) {\n      return false;\n    }\n    final PsiClass containingClass =\n      PsiTreeUtil.getParentOfType(context, PsiClass.class);\n    if (InheritanceUtil.isCorrectDescendant(containingClass, memberClass,\n                                            true)) {\n      return false;\n    }\n    final PsiFile psiFile = context.getContainingFile();\n    if (!(psiFile instanceof PsiJavaFile)) {\n      return false;\n    }\n    final PsiJavaFile javaFile = (PsiJavaFile)psiFile;\n    final PsiImportList importList = javaFile.getImportList();\n    if (importList == null) {\n      return false;\n    }\n    final String memberName = member.getName();\n    final PsiImportStatementBase existingImportStatement =\n      importList.findSingleImportStatement(memberName);\n    if (existingImportStatement != null &&\n        existingImportStatement instanceof PsiImportStaticStatement) {\n      return true;\n    }\n    final String memberClassName = memberClass.getQualifiedName();\n    final PsiImportStaticStatement onDemandImportStatement =\n      findOnDemandImportStaticStatement(importList,\n                                        memberClassName);\n    if (onDemandImportStatement != null) {\n      if (!hasOnDemandImportStaticConflict(memberClassName,\n                                           memberName, context)) {\n        return true;\n      }\n    }\n    return false;\n  }","id":92631,"modified_method":"public static boolean isStaticallyImported(@NotNull PsiMember member, @NotNull PsiElement context) {\n    final PsiClass memberClass = member.getContainingClass();\n    if (memberClass == null) {\n      return false;\n    }\n    final PsiClass containingClass = PsiTreeUtil.getParentOfType(context, PsiClass.class);\n    if (InheritanceUtil.isInheritorOrSelf(containingClass, memberClass, true)) {\n      return false;\n    }\n    final PsiFile psiFile = context.getContainingFile();\n    if (!(psiFile instanceof PsiJavaFile)) {\n      return false;\n    }\n    final PsiJavaFile javaFile = (PsiJavaFile)psiFile;\n    final PsiImportList importList = javaFile.getImportList();\n    if (importList == null) {\n      return false;\n    }\n    final String memberName = member.getName();\n    if (memberName == null) {\n      return false;\n    }\n    final PsiImportStatementBase existingImportStatement = importList.findSingleImportStatement(memberName);\n    if (existingImportStatement instanceof PsiImportStaticStatement) {\n      final PsiClass importClass = ((PsiImportStaticStatement)existingImportStatement).resolveTargetClass();\n      if (InheritanceUtil.isInheritorOrSelf(importClass, memberClass, true)) {\n        return true;\n      }\n    }\n    final String memberClassName = memberClass.getQualifiedName();\n    if (memberClassName == null) {\n      return false;\n    }\n    final PsiImportStaticStatement onDemandImportStatement = findOnDemandImportStaticStatement(importList, memberClassName);\n    if (onDemandImportStatement != null) {\n      if (!hasOnDemandImportStaticConflict(memberClassName, memberName, context)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void addStaticImport(\n    @NotNull String qualifierClass, @NotNull String memberName,\n    @NotNull PsiElement context)\n    throws IncorrectOperationException {\n    final PsiClass containingClass =\n      PsiTreeUtil.getParentOfType(context, PsiClass.class);\n    if (isSubclass(containingClass, qualifierClass)) {\n      return;\n    }\n    final PsiFile psiFile = context.getContainingFile();\n    if (!(psiFile instanceof PsiJavaFile)) {\n      return;\n    }\n    final PsiJavaFile javaFile = (PsiJavaFile)psiFile;\n    final PsiImportList importList = javaFile.getImportList();\n    if (importList == null) {\n      return;\n    }\n    final PsiImportStatementBase existingImportStatement =\n      importList.findSingleImportStatement(memberName);\n    if (existingImportStatement != null) {\n      return;\n    }\n    final PsiImportStaticStatement onDemandImportStatement =\n      findOnDemandImportStaticStatement(importList, qualifierClass);\n    if (onDemandImportStatement != null &&\n        !hasOnDemandImportStaticConflict(qualifierClass, memberName,\n                                         context)) {\n      return;\n    }\n    final Project project = context.getProject();\n    final GlobalSearchScope scope = context.getResolveScope();\n    final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n    final PsiClass aClass = psiFacade.findClass(qualifierClass, scope);\n    if (aClass == null) {\n      return;\n    }\n    final String qualifiedName = aClass.getQualifiedName();\n    if (qualifiedName == null) {\n      return;\n    }\n    final List<PsiImportStaticStatement> imports =\n      getMatchingImports(importList, qualifiedName);\n    final CodeStyleSettings codeStyleSettings =\n      CodeStyleSettingsManager.getSettings(project);\n    final PsiElementFactory elementFactory = psiFacade.getElementFactory();\n    if (imports.size() <\n        codeStyleSettings.NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND) {\n      importList.add(elementFactory.createImportStaticStatement(aClass,\n                                                                memberName));\n    }\n    else {\n      for (PsiImportStaticStatement importStatement : imports) {\n        importStatement.delete();\n      }\n      importList.add(\n        elementFactory.createImportStaticStatement(aClass, \"*\"));\n    }\n  }","id":92632,"modified_method":"public static boolean addStaticImport(@NotNull String qualifierClass, @NonNls @NotNull String memberName, @NotNull PsiElement context) {\n    if (!nameCanBeStaticallyImported(qualifierClass, memberName, context)) {\n      return false;\n    }\n    final PsiClass containingClass = PsiTreeUtil.getParentOfType(context, PsiClass.class);\n    if (InheritanceUtil.isInheritor(containingClass, qualifierClass)) {\n      return true;\n    }\n    final PsiFile psiFile = context.getContainingFile();\n    if (!(psiFile instanceof PsiJavaFile)) {\n      return false;\n    }\n    final PsiJavaFile javaFile = (PsiJavaFile)psiFile;\n    final PsiImportList importList = javaFile.getImportList();\n    if (importList == null) {\n      return false;\n    }\n    final PsiImportStatementBase existingImportStatement = importList.findSingleImportStatement(memberName);\n    if (existingImportStatement != null) {\n      return false;\n    }\n    final PsiImportStaticStatement onDemandImportStatement = findOnDemandImportStaticStatement(importList, qualifierClass);\n    if (onDemandImportStatement != null && !hasOnDemandImportStaticConflict(qualifierClass, memberName, context)) {\n      return true;\n    }\n    final Project project = context.getProject();\n    final GlobalSearchScope scope = context.getResolveScope();\n    final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n    final PsiClass aClass = psiFacade.findClass(qualifierClass, scope);\n    if (aClass == null) {\n      return false;\n    }\n    final String qualifiedName = aClass.getQualifiedName();\n    if (qualifiedName == null) {\n      return false;\n    }\n    final List<PsiImportStaticStatement> imports = getMatchingImports(importList, qualifiedName);\n    final CodeStyleSettings codeStyleSettings = CodeStyleSettingsManager.getSettings(project);\n    final PsiElementFactory elementFactory = psiFacade.getElementFactory();\n    if (imports.size() < codeStyleSettings.NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND) {\n      importList.add(elementFactory.createImportStaticStatement(aClass, memberName));\n    }\n    else {\n      for (PsiImportStaticStatement importStatement : imports) {\n        importStatement.delete();\n      }\n      importList.add(elementFactory.createImportStaticStatement(aClass, \"*\"));\n    }\n    return true;\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean nameCanBeImported(@NotNull String fqName,\n                                          @NotNull PsiElement context) {\n    final PsiClass containingClass =\n      PsiTreeUtil.getParentOfType(context, PsiClass.class);\n    if (containingClass != null) {\n      if (fqName.equals(containingClass.getQualifiedName())) {\n        return true;\n      }\n      final String shortName = ClassUtil.extractClassName(fqName);\n      final PsiClass[] innerClasses =\n        containingClass.getAllInnerClasses();\n      for (PsiClass innerClass : innerClasses) {\n        if (innerClass.hasModifierProperty(PsiModifier.PRIVATE)) {\n          continue;\n        }\n        if (innerClass.hasModifierProperty(PsiModifier.PACKAGE_LOCAL)) {\n          if (!inSamePackage(innerClass, containingClass)) {\n            continue;\n          }\n        }\n        final String className = innerClass.getName();\n        if (shortName.equals(className)) {\n          return false;\n        }\n      }\n    }\n    final PsiJavaFile file =\n      PsiTreeUtil.getParentOfType(context, PsiJavaFile.class, false);\n    if (file == null) {\n      return false;\n    }\n    if (hasExactImportConflict(fqName, file)) {\n      return false;\n    }\n    if (hasOnDemandImportConflict(fqName, file, true)) {\n      return false;\n    }\n    if (containsConflictingClass(fqName, file)) {\n      return false;\n    }\n    return !containsConflictingClassName(fqName, file);\n  }","id":92633,"modified_method":"public static boolean nameCanBeImported(@NotNull String fqName, @NotNull PsiElement context) {\n    final PsiClass containingClass = PsiTreeUtil.getParentOfType(context, PsiClass.class);\n    if (containingClass != null) {\n      if (fqName.equals(containingClass.getQualifiedName())) {\n        return true;\n      }\n      final String shortName = ClassUtil.extractClassName(fqName);\n      final PsiClass[] innerClasses = containingClass.getAllInnerClasses();\n      for (PsiClass innerClass : innerClasses) {\n        if (innerClass.hasModifierProperty(PsiModifier.PRIVATE)) {\n          continue;\n        }\n        if (innerClass.hasModifierProperty(PsiModifier.PACKAGE_LOCAL)) {\n          if (!inSamePackage(innerClass, containingClass)) {\n            continue;\n          }\n        }\n        final String className = innerClass.getName();\n        if (shortName.equals(className)) {\n          return false;\n        }\n      }\n      PsiField field = containingClass.findFieldByName(shortName, false);\n      if (field != null) {\n        return false;\n      }\n      field = containingClass.findFieldByName(shortName, true);\n      if (field != null && PsiUtil.isAccessible(field, containingClass, null)) {\n        return false;\n      }\n    }\n    final PsiJavaFile file = PsiTreeUtil.getParentOfType(context, PsiJavaFile.class);\n    if (file == null) {\n      return false;\n    }\n    if (hasExactImportConflict(fqName, file)) {\n      return false;\n    }\n    if (hasOnDemandImportConflict(fqName, file, true)) {\n      return false;\n    }\n    if (containsReferenceToConflictingClass(file, fqName)) {\n      return false;\n    }\n    if (containsConflictingClass(fqName, file)) {\n      return false;\n    }\n    return !containsConflictingClassName(fqName, file);\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean containsConflictingClass(String fqName,\n                                                  PsiJavaFile file) {\n    final PsiClass[] classes = file.getClasses();\n    for (PsiClass aClass : classes) {\n      if (containsConflictingInnerClass(fqName, aClass)) {\n        return true;\n      }\n    }\n    //return false;\n    final ClassReferenceVisitor visitor =\n      new ClassReferenceVisitor(fqName);\n    file.accept(visitor);\n    return visitor.isReferenceFound();\n  }","id":92634,"modified_method":"private static boolean containsConflictingClass(String fqName, PsiJavaFile file) {\n    final PsiClass[] classes = file.getClasses();\n    for (PsiClass aClass : classes) {\n      if (containsConflictingInnerClass(fqName, aClass)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean hasExactImportConflict(String fqName,\n                                                PsiJavaFile file) {\n    final PsiImportList imports = file.getImportList();\n    if (imports == null) {\n      return false;\n    }\n    final PsiImportStatement[] importStatements =\n      imports.getImportStatements();\n    final int lastDotIndex = fqName.lastIndexOf((int)'.');\n    final String shortName = fqName.substring(lastDotIndex + 1);\n    final String dottedShortName = '.' + shortName;\n    for (final PsiImportStatement importStatement : importStatements) {\n      if (importStatement.isOnDemand()) {\n        continue;\n      }\n      final String importName = importStatement.getQualifiedName();\n      if (importName == null) {\n        return false;\n      }\n      if (!importName.equals(fqName)) {\n        if (importName.endsWith(dottedShortName)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":92635,"modified_method":"private static boolean hasExactImportConflict(String fqName, PsiJavaFile file) {\n    final PsiImportList imports = file.getImportList();\n    if (imports == null) {\n      return false;\n    }\n    final PsiImportStatement[] importStatements = imports.getImportStatements();\n    final int lastDotIndex = fqName.lastIndexOf((int)'.');\n    final String shortName = fqName.substring(lastDotIndex + 1);\n    final String dottedShortName = '.' + shortName;\n    for (final PsiImportStatement importStatement : importStatements) {\n      if (importStatement.isOnDemand()) {\n        continue;\n      }\n      final String importName = importStatement.getQualifiedName();\n      if (importName == null) {\n        return false;\n      }\n      if (!importName.equals(fqName) && importName.endsWith(dottedShortName)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * ImportUtils currently checks all inner classes, even those that are\n   * contained in inner classes themselves, because it doesn't know the\n   * location of the original fully qualified reference. It should really only\n   * check if the containing class of the fully qualified reference has any\n   * conflicting inner classes.\n   */\n  private static boolean containsConflictingInnerClass(String fqName,\n                                                       PsiClass aClass) {\n    final String shortName = ClassUtil.extractClassName(fqName);\n    if (shortName.equals(aClass.getName())) {\n      if (!fqName.equals(aClass.getQualifiedName())) {\n        return true;\n      }\n    }\n    final PsiClass[] classes = aClass.getInnerClasses();\n    for (PsiClass innerClass : classes) {\n      if (containsConflictingInnerClass(fqName, innerClass)) {\n        return true;\n      }\n    }\n    return false;\n  }","id":92636,"modified_method":"/**\n   * ImportUtils currently checks all inner classes, even those that are\n   * contained in inner classes themselves, because it doesn't know the\n   * location of the original fully qualified reference. It should really only\n   * check if the containing class of the fully qualified reference has any\n   * conflicting inner classes.\n   */\n  private static boolean containsConflictingInnerClass(String fqName, PsiClass aClass) {\n    final String shortName = ClassUtil.extractClassName(fqName);\n    if (shortName.equals(aClass.getName()) && !fqName.equals(aClass.getQualifiedName())) {\n      return true;\n    }\n    final PsiClass[] classes = aClass.getInnerClasses();\n    for (PsiClass innerClass : classes) {\n      if (containsConflictingInnerClass(fqName, innerClass)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean hasOnDemandImportStaticConflict(\n    String fqName, String memberName, PsiElement context,\n    boolean strict) {\n    final PsiFile file = context.getContainingFile();\n    if (!(file instanceof PsiJavaFile)) {\n      return false;\n    }\n    final PsiJavaFile javaFile = (PsiJavaFile)file;\n    final PsiImportList importList = javaFile.getImportList();\n    if (importList == null) {\n      return false;\n    }\n    final PsiImportStaticStatement[] importStaticStatements =\n      importList.getImportStaticStatements();\n    for (PsiImportStaticStatement importStaticStatement :\n      importStaticStatements) {\n      if (!importStaticStatement.isOnDemand()) {\n        continue;\n      }\n      final PsiClass targetClass =\n        importStaticStatement.resolveTargetClass();\n      if (targetClass == null) {\n        continue;\n      }\n      final String name = targetClass.getQualifiedName();\n      if (fqName.equals(name)) {\n        continue;\n      }\n      final PsiField field = targetClass.findFieldByName(memberName, true);\n      if (field != null) {\n        if (!strict || memberReferenced(field, javaFile)) {\n          return true;\n        }\n      }\n      final PsiMethod[] methods =\n        targetClass.findMethodsByName(memberName, true);\n      if (methods.length > 0) {\n        if (!strict || membersReferenced(methods, javaFile)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":92637,"modified_method":"private static boolean hasOnDemandImportStaticConflict(String fqName, String memberName, PsiElement context, boolean strict) {\n    final PsiFile file = context.getContainingFile();\n    if (!(file instanceof PsiJavaFile)) {\n      return false;\n    }\n    final PsiJavaFile javaFile = (PsiJavaFile)file;\n    final PsiImportList importList = javaFile.getImportList();\n    if (importList == null) {\n      return false;\n    }\n    final PsiImportStaticStatement[] importStaticStatements = importList.getImportStaticStatements();\n    for (PsiImportStaticStatement importStaticStatement : importStaticStatements) {\n      if (!importStaticStatement.isOnDemand()) {\n        continue;\n      }\n      final PsiClass targetClass = importStaticStatement.resolveTargetClass();\n      if (targetClass == null) {\n        continue;\n      }\n      final String name = targetClass.getQualifiedName();\n      if (fqName.equals(name)) {\n        continue;\n      }\n      final PsiField field = targetClass.findFieldByName(memberName, true);\n      if (field != null && (!strict || memberReferenced(field, javaFile))) {\n        return true;\n      }\n      final PsiMethod[] methods = targetClass.findMethodsByName(memberName, true);\n      if (methods.length > 0 && (!strict || membersReferenced(methods, javaFile))) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean hasJavaLangImportConflict(String fqName,\n                                                  PsiJavaFile file) {\n    final String shortName = ClassUtil.extractClassName(fqName);\n    final String packageName = ClassUtil.extractPackageName(fqName);\n    if (\"java.lang\".equals(packageName)) {\n      return false;\n    }\n    final Project project = file.getProject();\n    final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n    final PsiPackage javaLangPackage =\n      psiFacade.findPackage(\"java.lang\");\n    if (javaLangPackage == null) {\n      return false;\n    }\n    final PsiClass[] classes = javaLangPackage.getClasses();\n    for (final PsiClass aClass : classes) {\n      final String className = aClass.getName();\n      if (shortName.equals(className)) {\n        return true;\n      }\n    }\n    return false;\n  }","id":92638,"modified_method":"public static boolean hasJavaLangImportConflict(String fqName, PsiJavaFile file) {\n    final String shortName = ClassUtil.extractClassName(fqName);\n    @NonNls final String packageName = ClassUtil.extractPackageName(fqName);\n    if (\"java.lang\".equals(packageName)) {\n      return false;\n    }\n    final Project project = file.getProject();\n    final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n    final PsiPackage javaLangPackage = psiFacade.findPackage(\"java.lang\");\n    if (javaLangPackage == null) {\n      return false;\n    }\n    final PsiClass[] classes = javaLangPackage.getClasses();\n    for (final PsiClass aClass : classes) {\n      final String className = aClass.getName();\n      if (shortName.equals(className)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean nameCanBeStaticallyImported(\n    @NotNull String fqName, @NotNull String memberName,\n    @NotNull PsiElement context) {\n    final PsiClass containingClass =\n      PsiTreeUtil.getParentOfType(context, PsiClass.class);\n    if (containingClass == null) {\n      return false;\n    }\n    if (isSubclass(containingClass, fqName)) {\n      return true;\n    }\n    final PsiField field =\n      containingClass.findFieldByName(memberName, true);\n    if (field != null) {\n      return false;\n    }\n    final PsiMethod[] methods =\n      containingClass.findMethodsByName(memberName, true);\n    if (methods.length > 0) {\n      return false;\n    }\n    return !hasOnDemandImportStaticConflict(fqName, memberName, context, true) &&\n           !hasExactImportStaticConflict(fqName, memberName, context);\n  }","id":92639,"modified_method":"private static boolean nameCanBeStaticallyImported(@NotNull String fqName, @NotNull String memberName, @NotNull PsiElement context) {\n    final PsiClass containingClass = PsiTreeUtil.getParentOfType(context, PsiClass.class);\n    if (containingClass == null) {\n      return false;\n    }\n    if (InheritanceUtil.isInheritor(containingClass, fqName)) {\n      return true;\n    }\n    final PsiField field = containingClass.findFieldByName(memberName, true);\n    if (field != null) {\n      return false;\n    }\n    final PsiMethod[] methods = containingClass.findMethodsByName(memberName, true);\n    if (methods.length > 0) {\n      return false;\n    }\n    return !hasOnDemandImportStaticConflict(fqName, memberName, context, true) &&\n           !hasExactImportStaticConflict(fqName, memberName, context);\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processIntention(PsiElement element)\n    throws IncorrectOperationException {\n    final PsiMethodCallExpression call =\n      (PsiMethodCallExpression)element;\n    final PsiReferenceExpression expression = call.getMethodExpression();\n    final PsiExpressionList argumentList = call.getArgumentList();\n    final PsiExpression[] args = argumentList.getExpressions();\n    final String assertString;\n    final String actualArgumentText;\n    if (args.length == 2) {\n      @NonNls final String argText = args[0].getText();\n      final PsiExpression otherArg;\n      if (\"true\".equals(argText) ||\n          \"false\".equals(argText) ||\n          \"null\".equals(argText)) {\n        otherArg = args[1];\n      }\n      else {\n        otherArg = args[0];\n      }\n      actualArgumentText = otherArg.getText();\n      assertString = getAssertString(argText);\n    }\n    else {\n      @NonNls final String argText = args[1].getText();\n      final PsiExpression otherArg;\n      if (\"true\".equals(argText) ||\n          \"false\".equals(argText) ||\n          \"null\".equals(argText)) {\n        otherArg = args[2];\n      }\n      else {\n        otherArg = args[1];\n      }\n      actualArgumentText = args[0].getText() + \", \" + otherArg.getText();\n      assertString = getAssertString(argText);\n    }\n    final PsiElement qualifier = expression.getQualifier();\n    final StringBuilder newExpression = new StringBuilder();\n    if (qualifier == null) {\n      final PsiMethod containingMethod =\n        PsiTreeUtil.getParentOfType(call, PsiMethod.class);\n      if (containingMethod != null &&\n          AnnotationUtil.isAnnotated(containingMethod, \"org.junit.Test\", true)) {\n        if (ImportUtils.nameCanBeStaticallyImported(\n          \"org.junit.Assert\", assertString, element)) {\n          ImportUtils.addStaticImport(\"org.junit.Assert\", assertString, element);\n        }\n        else {\n          newExpression.append(\"org.junit.Assert.\");\n        }\n      }\n    }\n    else {\n      newExpression.append(qualifier.getText());\n      newExpression.append('.');\n    }\n    newExpression.append(assertString);\n    newExpression.append('(');\n    newExpression.append(actualArgumentText);\n    newExpression.append(')');\n    replaceExpression(newExpression.toString(), call);\n  }","id":92640,"modified_method":"@Override\n  public void processIntention(@NotNull PsiElement element) {\n    final PsiMethodCallExpression call = (PsiMethodCallExpression)element;\n    final PsiReferenceExpression expression = call.getMethodExpression();\n    final PsiExpressionList argumentList = call.getArgumentList();\n    final PsiExpression[] args = argumentList.getExpressions();\n    final String assertString;\n    final String actualArgumentText;\n    if (args.length == 2) {\n      @NonNls final String argText = args[0].getText();\n      final PsiExpression otherArg;\n      if (\"true\".equals(argText) || \"false\".equals(argText) || \"null\".equals(argText)) {\n        otherArg = args[1];\n      }\n      else {\n        otherArg = args[0];\n      }\n      actualArgumentText = otherArg.getText();\n      assertString = getAssertString(argText);\n    }\n    else {\n      @NonNls final String argText = args[1].getText();\n      final PsiExpression otherArg;\n      if (\"true\".equals(argText) || \"false\".equals(argText) || \"null\".equals(argText)) {\n        otherArg = args[2];\n      }\n      else {\n        otherArg = args[1];\n      }\n      actualArgumentText = args[0].getText() + \", \" + otherArg.getText();\n      assertString = getAssertString(argText);\n    }\n    final PsiElement qualifier = expression.getQualifier();\n    @NonNls final StringBuilder newExpression = new StringBuilder();\n    if (qualifier == null) {\n      final PsiMethod containingMethod = PsiTreeUtil.getParentOfType(call, PsiMethod.class);\n      if (containingMethod != null && AnnotationUtil.isAnnotated(containingMethod, \"org.junit.Test\", true)) {\n        if (!ImportUtils.addStaticImport(\"org.junit.Assert\", assertString, element)) {\n          newExpression.append(\"org.junit.Assert.\");\n        }\n      }\n    }\n    else {\n      newExpression.append(qualifier.getText()).append('.');\n    }\n    newExpression.append(assertString).append('(').append(actualArgumentText).append(')');\n    replaceExpression(newExpression.toString(), call);\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processIntention(@NotNull PsiElement element)\n    throws IncorrectOperationException {\n    final PsiMethodCallExpression call = (PsiMethodCallExpression)element;\n    final PsiReferenceExpression methodExpression = call.getMethodExpression();\n    @NonNls final String methodName = methodExpression.getReferenceName();\n    if (methodName == null) {\n      return;\n    }\n    final StringBuilder newExpression = new StringBuilder();\n    final PsiElement qualifier = methodExpression.getQualifier();\n    if (qualifier == null) {\n      final PsiMethod containingMethod =\n        PsiTreeUtil.getParentOfType(call, PsiMethod.class);\n      if (containingMethod != null &&\n          AnnotationUtil.isAnnotated(containingMethod, \"org.junit.Test\", true)) {\n        if (ImportUtils.nameCanBeStaticallyImported(\n          \"org.junit.Assert\", \"assertEquals\", element)) {\n          ImportUtils.addStaticImport(\"org.junit.Assert\", \"assertEquals\", element);\n        }\n        else {\n          newExpression.append(\"org.junit.Assert.\");\n        }\n      }\n    }\n    else {\n      newExpression.append(qualifier.getText());\n      newExpression.append('.');\n    }\n    newExpression.append(\"assertEquals(\");\n    final String postfix = methodName.substring(\"assert\".length());\n    final String literal = postfix.toLowerCase();\n    final PsiExpressionList argumentList = call.getArgumentList();\n    final PsiExpression[] arguments = argumentList.getExpressions();\n    if (arguments.length > 1) {\n      newExpression.append(arguments[0].getText());\n      newExpression.append(\", \");\n    }\n    final PsiExpression lastArgument = arguments[arguments.length - 1];\n    if (lastArgument instanceof PsiBinaryExpression) {\n      final PsiBinaryExpression binaryExpression =\n        (PsiBinaryExpression)lastArgument;\n      final IElementType tokenType =\n        binaryExpression.getOperationTokenType();\n      if ((\"assertTrue\".equals(methodName) &&\n           JavaTokenType.EQEQ.equals(tokenType)) ||\n          (\"assertFalse\".equals(methodName) &&\n           JavaTokenType.NE.equals(tokenType))) {\n        final PsiExpression lhs = binaryExpression.getLOperand();\n        newExpression.append(lhs.getText());\n        newExpression.append(\", \");\n        final PsiExpression rhs = binaryExpression.getROperand();\n        if (rhs != null) {\n          newExpression.append(rhs.getText());\n        }\n      }\n      else {\n        newExpression.append(literal);\n        newExpression.append(\", \");\n        newExpression.append(lastArgument.getText());\n      }\n    }\n    else {\n      newExpression.append(literal);\n      newExpression.append(\", \");\n      newExpression.append(lastArgument.getText());\n    }\n    newExpression.append(')');\n    replaceExpression(newExpression.toString(), call);\n  }","id":92641,"modified_method":"@Override\n  public void processIntention(@NotNull PsiElement element) {\n    final PsiMethodCallExpression call = (PsiMethodCallExpression)element;\n    final PsiReferenceExpression methodExpression = call.getMethodExpression();\n    @NonNls final String methodName = methodExpression.getReferenceName();\n    if (methodName == null) {\n      return;\n    }\n    @NonNls final StringBuilder newExpression = new StringBuilder();\n    final PsiElement qualifier = methodExpression.getQualifier();\n    if (qualifier == null) {\n      final PsiMethod containingMethod = PsiTreeUtil.getParentOfType(call, PsiMethod.class);\n      if (containingMethod != null && AnnotationUtil.isAnnotated(containingMethod, \"org.junit.Test\", true)) {\n        if (!ImportUtils.addStaticImport(\"org.junit.Assert\", \"assertEquals\", element)) {\n          newExpression.append(\"org.junit.Assert.\");\n        }\n      }\n    }\n    else {\n      newExpression.append(qualifier.getText());\n      newExpression.append('.');\n    }\n    newExpression.append(\"assertEquals(\");\n    final String postfix = methodName.substring(\"assert\".length());\n    final String literal = postfix.toLowerCase();\n    final PsiExpressionList argumentList = call.getArgumentList();\n    final PsiExpression[] arguments = argumentList.getExpressions();\n    if (arguments.length > 1) {\n      newExpression.append(arguments[0].getText()).append(\", \");\n    }\n    final PsiExpression lastArgument = arguments[arguments.length - 1];\n    if (lastArgument instanceof PsiBinaryExpression) {\n      final PsiBinaryExpression binaryExpression = (PsiBinaryExpression)lastArgument;\n      final IElementType tokenType = binaryExpression.getOperationTokenType();\n      if ((\"assertTrue\".equals(methodName) && JavaTokenType.EQEQ.equals(tokenType)) ||\n          (\"assertFalse\".equals(methodName) && JavaTokenType.NE.equals(tokenType))) {\n        final PsiExpression lhs = binaryExpression.getLOperand();\n        newExpression.append(lhs.getText()).append(\", \");\n        final PsiExpression rhs = binaryExpression.getROperand();\n        if (rhs != null) {\n          newExpression.append(rhs.getText());\n        }\n      }\n      else {\n        newExpression.append(literal).append(\", \").append(lastArgument.getText());\n      }\n    }\n    else {\n      newExpression.append(literal).append(\", \").append(lastArgument.getText());\n    }\n    newExpression.append(')');\n    replaceExpression(newExpression.toString(), call);\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processIntention(@NotNull PsiElement element)\n    throws IncorrectOperationException {\n    PsiJavaCodeReferenceElement reference =\n      (PsiJavaCodeReferenceElement)element;\n    PsiElement target = reference.resolve();\n    if (!(target instanceof PsiClass)) {\n      PsiElement parent = reference.getParent();\n      while (parent instanceof PsiJavaCodeReferenceElement) {\n        reference = (PsiJavaCodeReferenceElement)parent;\n        target = reference.resolve();\n        if (target instanceof PsiClass) {\n          break;\n        }\n        parent = parent.getParent();\n      }\n    }\n    if (!(target instanceof PsiClass)) {\n      return;\n    }\n    final PsiClass aClass = (PsiClass)target;\n    final String qualifiedName = aClass.getQualifiedName();\n    if (qualifiedName == null) {\n      return;\n    }\n    final PsiJavaFile file =\n      PsiTreeUtil.getParentOfType(reference, PsiJavaFile.class);\n    if (file == null) {\n      return;\n    }\n    if (!ImportUtils.nameCanBeImported(qualifiedName, file)) {\n      return;\n    }\n    ImportUtils.addImportIfNeeded(file, aClass);\n    final String fullyQualifiedText = reference.getText();\n    final QualificationRemover qualificationRemover =\n      new QualificationRemover(fullyQualifiedText);\n    file.accept(qualificationRemover);\n    final Collection<PsiJavaCodeReferenceElement> shortenedElements =\n      qualificationRemover.getShortenedElements();\n    final int elementCount = shortenedElements.size();\n    final String text;\n    if (elementCount == 1) {\n      text = IntentionPowerPackBundle.message(\n        \"1.fully.qualified.name.status.bar.escape.highlighting.message\");\n    }\n    else {\n      text = IntentionPowerPackBundle.message(\n        \"multiple.fully.qualified.names.status.bar.escape.highlighting.message\",\n        Integer.valueOf(elementCount));\n    }\n    HighlightUtil.highlightElements(shortenedElements, text);\n  }","id":92642,"modified_method":"@Override\n  public void processIntention(@NotNull PsiElement element) {\n    PsiJavaCodeReferenceElement reference = (PsiJavaCodeReferenceElement)element;\n    PsiElement target = reference.resolve();\n    if (!(target instanceof PsiClass)) {\n      PsiElement parent = reference.getParent();\n      while (parent instanceof PsiJavaCodeReferenceElement) {\n        reference = (PsiJavaCodeReferenceElement)parent;\n        target = reference.resolve();\n        if (target instanceof PsiClass) {\n          break;\n        }\n        parent = parent.getParent();\n      }\n    }\n    if (!(target instanceof PsiClass)) {\n      return;\n    }\n    final PsiClass aClass = (PsiClass)target;\n    final String qualifiedName = aClass.getQualifiedName();\n    if (qualifiedName == null) {\n      return;\n    }\n    final PsiJavaFile file =\n      PsiTreeUtil.getParentOfType(reference, PsiJavaFile.class);\n    if (file == null) {\n      return;\n    }\n    ImportUtils.addImportIfNeeded(aClass, reference);\n    final String fullyQualifiedText = reference.getText();\n    final QualificationRemover qualificationRemover = new QualificationRemover(fullyQualifiedText);\n    file.accept(qualificationRemover);\n    final Collection<PsiJavaCodeReferenceElement> shortenedElements = qualificationRemover.getShortenedElements();\n    final int elementCount = shortenedElements.size();\n    final String text;\n    if (elementCount == 1) {\n      text = IntentionPowerPackBundle.message(\n        \"1.fully.qualified.name.status.bar.escape.highlighting.message\");\n    }\n    else {\n      text = IntentionPowerPackBundle.message(\n        \"multiple.fully.qualified.names.status.bar.escape.highlighting.message\",\n        Integer.valueOf(elementCount));\n    }\n    HighlightUtil.highlightElements(shortenedElements, text);\n  }","commit_id":"1d3c3ef6b552bdf2422c8e56f1e486e7463dc1ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void persistProjectUsages(@NotNull Project project) {\n      try {\n        final Set<UsageDescriptor> projectUsages = getProjectUsages(project);\n        persistProjectUsages(project, projectUsages);\n      }\n      catch (CollectUsagesException e) {\n        LOG.info(e);\n      }\n    }","id":92643,"modified_method":"public void persistProjectUsages(@NotNull Project project) {\n    try {\n      persistProjectUsages(project, getProjectUsages(project));\n    }\n    catch (CollectUsagesException e) {\n      LOG.info(e);\n    }\n  }","commit_id":"80c8b76f90956d74360ecfba5f8e12997aaf3bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public Set<UsageDescriptor> getApplicationUsages(@NotNull final ApplicationStatisticsPersistence persistence) {\n        final Map<String, Integer> result = new HashMap<String, Integer>();\n\n        for (Set<UsageDescriptor> usageDescriptors : persistence.getApplicationData(getGroupId()).values()) {\n            for (UsageDescriptor usageDescriptor : usageDescriptors) {\n                final String key = usageDescriptor.getKey();\n                final Integer count = result.get(key);\n                result.put(key, count == null ? 1 : count.intValue() + 1);\n            }\n        }\n\n        return ContainerUtil.map2Set(result.entrySet(), new Function<Map.Entry<String, Integer>, UsageDescriptor>() {\n            @Override\n            public UsageDescriptor fun(Map.Entry<String, Integer> entry) {\n                return new UsageDescriptor(entry.getKey(), entry.getValue());\n            }\n        });\n    }","id":92644,"modified_method":"@NotNull\n  public Set<UsageDescriptor> getApplicationUsages(@NotNull ApplicationStatisticsPersistence persistence) {\n    Map<String, Integer> result = new THashMap<String, Integer>();\n    for (Set<UsageDescriptor> usageDescriptors : persistence.getApplicationData(getGroupId()).values()) {\n      for (UsageDescriptor usageDescriptor : usageDescriptors) {\n        final String key = usageDescriptor.getKey();\n        final Integer count = result.get(key);\n        result.put(key, count == null ? 1 : count.intValue() + 1);\n      }\n    }\n\n    return ContainerUtil.map2Set(result.entrySet(), new Function<Map.Entry<String, Integer>, UsageDescriptor>() {\n      @Override\n      public UsageDescriptor fun(Map.Entry<String, Integer> entry) {\n        return new UsageDescriptor(entry.getKey(), entry.getValue());\n      }\n    });\n  }","commit_id":"80c8b76f90956d74360ecfba5f8e12997aaf3bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    @NotNull\n    public Set<UsageDescriptor> getUsages(@Nullable Project project) throws CollectUsagesException {\n        if (project != null) {\n          final Set<UsageDescriptor> projectUsages = getProjectUsages(project);\n          persistProjectUsages(project, projectUsages);\n        }\n\n        return getApplicationUsages();\n    }","id":92645,"modified_method":"@Override\n  @NotNull\n  public Set<UsageDescriptor> getUsages(@Nullable Project project) throws CollectUsagesException {\n    if (project != null) {\n      persistProjectUsages(project, getProjectUsages(project));\n    }\n    return getApplicationUsages();\n  }","commit_id":"80c8b76f90956d74360ecfba5f8e12997aaf3bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void persistUsages(@NotNull GroupDescriptor groupDescriptor, @NotNull Project project, @NotNull Set<UsageDescriptor> usageDescriptors) {\n      if (!myApplicationData.containsKey(groupDescriptor)) {\n          myApplicationData.put(groupDescriptor, new HashMap<String, Set<UsageDescriptor>>());\n      }\n      myApplicationData.get(groupDescriptor).put(project.getName(), usageDescriptors);\n  }","id":92646,"modified_method":"public void persistUsages(@NotNull GroupDescriptor groupDescriptor, @NotNull Project project, @NotNull Set<UsageDescriptor> usageDescriptors) {\n    if (!myApplicationData.containsKey(groupDescriptor)) {\n      myApplicationData.put(groupDescriptor, new THashMap<String, Set<UsageDescriptor>>());\n    }\n    myApplicationData.get(groupDescriptor).put(project.getName(), usageDescriptors);\n  }","commit_id":"80c8b76f90956d74360ecfba5f8e12997aaf3bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Map<String, Set<UsageDescriptor>> getApplicationData(@NotNull GroupDescriptor groupDescriptor) {\n      if (!myApplicationData.containsKey(groupDescriptor)) {\n          myApplicationData.put(groupDescriptor, new HashMap<String, Set<UsageDescriptor>>());\n      }\n      return myApplicationData.get(groupDescriptor);\n  }","id":92647,"modified_method":"@NotNull\n  public Map<String, Set<UsageDescriptor>> getApplicationData(@NotNull GroupDescriptor groupDescriptor) {\n    if (!myApplicationData.containsKey(groupDescriptor)) {\n      myApplicationData.put(groupDescriptor, new THashMap<String, Set<UsageDescriptor>>());\n    }\n    return myApplicationData.get(groupDescriptor);\n  }","commit_id":"80c8b76f90956d74360ecfba5f8e12997aaf3bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void loadState(final Element element) {\n    List groups = element.getChildren(GROUP_TAG);\n\n    for (Object group : groups) {\n      Element groupElement = (Element)group;\n      String groupName = groupElement.getAttributeValue(GROUP_NAME_ATTR);\n\n      final GroupDescriptor groupDescriptor = GroupDescriptor.create(groupName);\n\n      List projectsList = groupElement.getChildren(PROJECT_TAG);\n      for (Object project : projectsList) {\n        Element projectElement = (Element)project;\n        String projectId = projectElement.getAttributeValue(PROJECT_ID_ATTR);\n        String frameworks = projectElement.getAttributeValue(VALUES_ATTR);\n        if (!StringUtil.isEmptyOrSpaces(projectId) && !StringUtil.isEmptyOrSpaces(frameworks)) {\n          Set<UsageDescriptor> frameworkDescriptors = new HashSet<UsageDescriptor>();\n          for (String key : StringUtil.split(frameworks, TOKENIZER)) {\n            final UsageDescriptor descriptor = getUsageDescriptor(key);\n            if (descriptor != null) frameworkDescriptors.add(descriptor);\n          }\n          getApplicationData(groupDescriptor).put(projectId, frameworkDescriptors);\n        }\n      }\n    }\n  }","id":92648,"modified_method":"@Override\n  public void loadState(Element element) {\n    for (Element groupElement : element.getChildren(GROUP_TAG)) {\n      GroupDescriptor groupDescriptor = GroupDescriptor.create(groupElement.getAttributeValue(GROUP_NAME_ATTR));\n      List<Element> projectsList = groupElement.getChildren(PROJECT_TAG);\n      for (Element projectElement : projectsList) {\n        String projectId = projectElement.getAttributeValue(PROJECT_ID_ATTR);\n        String frameworks = projectElement.getAttributeValue(VALUES_ATTR);\n        if (!StringUtil.isEmptyOrSpaces(projectId) && !StringUtil.isEmptyOrSpaces(frameworks)) {\n          Set<UsageDescriptor> frameworkDescriptors = new THashSet<UsageDescriptor>();\n          for (String key : StringUtil.split(frameworks, TOKENIZER)) {\n            UsageDescriptor descriptor = getUsageDescriptor(key);\n            if (descriptor != null) {\n              frameworkDescriptors.add(descriptor);\n            }\n          }\n          getApplicationData(groupDescriptor).put(projectId, frameworkDescriptors);\n        }\n      }\n    }\n  }","commit_id":"80c8b76f90956d74360ecfba5f8e12997aaf3bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void initComponent() {\n    onAppClosing();\n    onProjectClosing();\n  }","id":92649,"modified_method":"@Override\n  public void initComponent() {\n    ApplicationManager.getApplication().getMessageBus().connect().subscribe(AppLifecycleListener.TOPIC, new AppLifecycleListener.Adapter() {\n      @Override\n      public void appClosing() {\n        for (Project project : ProjectManager.getInstance().getOpenProjects()) {\n          doPersistProjectUsages(project);\n        }\n        persistOnClosing = false;\n      }\n    });\n\n    ProjectManager.getInstance().addProjectManagerListener(new ProjectManagerAdapter() {\n      @Override\n      public void projectClosing(Project project) {\n        if (persistOnClosing && project != null) {\n          doPersistProjectUsages(project);\n        }\n      }\n    });\n  }","commit_id":"80c8b76f90956d74360ecfba5f8e12997aaf3bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doPersistProjectUsages(@NotNull Project project) {\n    if (DumbService.isDumb(project)) return;\n    for (UsagesCollector usagesCollector : Extensions.getExtensions(UsagesCollector.EP_NAME)) {\n      if (usagesCollector instanceof AbstractApplicationUsagesCollector) {\n        ((AbstractApplicationUsagesCollector)usagesCollector).persistProjectUsages(project);\n      }\n    }\n  }","id":92650,"modified_method":"private static void doPersistProjectUsages(@NotNull Project project) {\n    if (!project.isInitialized() || DumbService.isDumb(project)) {\n      return;\n    }\n\n    for (UsagesCollector usagesCollector : Extensions.getExtensions(UsagesCollector.EP_NAME)) {\n      if (usagesCollector instanceof AbstractApplicationUsagesCollector) {\n        ((AbstractApplicationUsagesCollector)usagesCollector).persistProjectUsages(project);\n      }\n    }\n  }","commit_id":"80c8b76f90956d74360ecfba5f8e12997aaf3bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public IdeSettingsDescriptor[] getSettingDescriptors() {\n    if (myDescriptors == null) {\n      final URL url = createVersionsUrl();\n      if (url == null) return new IdeSettingsDescriptor[0];\n      final IdeSettingsDescriptors descriptors = deserialize(url);\n      myDescriptors = descriptors == null ? new IdeSettingsDescriptor[0] : descriptors.getDescriptors();\n    }\n    return myDescriptors;\n  }","id":92651,"modified_method":"@NotNull\n  public IdeSettingsDescriptor[] getSettingDescriptors() {\n    if (myDescriptors == null) {\n      URL url = createVersionsUrl();\n      if (url == null) {\n        return new IdeSettingsDescriptor[0];\n      }\n      IdeSettingsDescriptors descriptors = deserialize(url);\n      myDescriptors = descriptors == null ? new IdeSettingsDescriptor[0] : descriptors.getDescriptors();\n    }\n    return myDescriptors;\n  }","commit_id":"80c8b76f90956d74360ecfba5f8e12997aaf3bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static IdeSettingsDescriptors deserialize(@Nullable URL url) {\n    if (url == null) return null;\n\n    IdeSettingsDescriptors ideSettingsDescriptor = null;\n    try {\n      ideSettingsDescriptor = XmlSerializer.deserialize(url, IdeSettingsDescriptors.class);\n    }\n    catch (XmlSerializationException e) {\n      final Throwable cause = e.getCause();\n      if (!(cause instanceof IOException)) {\n        LOG.error(e);\n      }\n    }\n    return ideSettingsDescriptor;\n  }","id":92652,"modified_method":"@Nullable\n  private static IdeSettingsDescriptors deserialize(@Nullable URL url) {\n    if (url == null) return null;\n\n    IdeSettingsDescriptors ideSettingsDescriptor = null;\n    try {\n      ideSettingsDescriptor = XmlSerializer.deserialize(url, IdeSettingsDescriptors.class);\n    }\n    catch (XmlSerializationException e) {\n      Throwable cause = e.getCause();\n      if (!(cause instanceof IOException)) {\n        LOG.error(e);\n      }\n    }\n    return ideSettingsDescriptor;\n  }","commit_id":"80c8b76f90956d74360ecfba5f8e12997aaf3bb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void persistProjectUsages(@NotNull Project project) {\n        persistProjectUsages(project, getProjectUsages(project));\n    }","id":92653,"modified_method":"public void persistProjectUsages(@NotNull Project project) {\n      try {\n        final Set<UsageDescriptor> projectUsages = getProjectUsages(project);\n        persistProjectUsages(project, projectUsages);\n      }\n      catch (CollectUsagesException e) {\n        LOG.info(e);\n      }\n    }","commit_id":"9764aff7b148f9de33586409b1b3b287f668a95f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public Set<UsageDescriptor> getUsages(@Nullable Project project) {\n        if (project != null) {\n            persistProjectUsages(project, getProjectUsages(project));\n        }\n\n        return getApplicationUsages();\n    }","id":92654,"modified_method":"@NotNull\n    public Set<UsageDescriptor> getUsages(@Nullable Project project) throws CollectUsagesException {\n        if (project != null) {\n          final Set<UsageDescriptor> projectUsages = getProjectUsages(project);\n          persistProjectUsages(project, projectUsages);\n        }\n\n        return getApplicationUsages();\n    }","commit_id":"9764aff7b148f9de33586409b1b3b287f668a95f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Set<UsageDescriptor> getProjectUsages(@NotNull final Project project) {\n    final Set<FileType> usedFileTypes = new HashSet<FileType>();\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        if (!project.isDisposed()) {\n          final FileType[] registeredFileTypes = FileTypeManager.getInstance().getRegisteredFileTypes();\n          for (final FileType fileType : registeredFileTypes) {\n            FileBasedIndex.getInstance().processValues(\n              FileTypeIndex.NAME,\n              fileType,\n              null,\n              new FileBasedIndex.ValueProcessor<Void>() {\n                @Override\n                public boolean process(VirtualFile file, Void value) {\n                  usedFileTypes.add(fileType);\n                  return false;\n                }\n              }, GlobalSearchScope.projectScope(project));\n          }\n          usedFileTypes.add(UnknownFileType.INSTANCE);\n        }\n      }\n    });\n    return ContainerUtil.map2Set(usedFileTypes, new NotNullFunction<FileType, UsageDescriptor>() {\n      @NotNull\n      @Override\n      public UsageDescriptor fun(FileType fileType) {\n        return new UsageDescriptor(fileType.getName(), 1);\n      }\n    });\n  }","id":92655,"modified_method":"@NotNull\n  @Override\n  public Set<UsageDescriptor> getProjectUsages(@NotNull final Project project) throws CollectUsagesException {\n    final Set<FileType> usedFileTypes = new HashSet<FileType>();\n    final FileTypeManager fileTypeManager = FileTypeManager.getInstance();\n    if (fileTypeManager == null) {\n      throw new CollectUsagesException(\"Cannot get instance of FileTypeManager\");\n    }\n    final FileType[] registeredFileTypes = fileTypeManager.getRegisteredFileTypes();\n    for (final FileType fileType : registeredFileTypes) {\n      if (project.isDisposed()) {\n        throw new CollectUsagesException(\"Project is disposed\");\n      }\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          FileBasedIndex.getInstance().processValues(\n            FileTypeIndex.NAME,\n            fileType,\n            null,\n            new FileBasedIndex.ValueProcessor<Void>() {\n              @Override\n              public boolean process(VirtualFile file, Void value) {\n                usedFileTypes.add(fileType);\n                return false;\n              }\n            }, GlobalSearchScope.projectScope(project));\n        }\n      });\n    }\n    usedFileTypes.add(UnknownFileType.INSTANCE);\n    return ContainerUtil.map2Set(usedFileTypes, new NotNullFunction<FileType, UsageDescriptor>() {\n      @NotNull\n      @Override\n      public UsageDescriptor fun(FileType fileType) {\n        return new UsageDescriptor(fileType.getName(), 1);\n      }\n    });\n  }","commit_id":"9764aff7b148f9de33586409b1b3b287f668a95f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public static Map<GroupDescriptor, Set<UsageDescriptor>> getAllUsages(@Nullable Project project, @NotNull Set<String> disabledGroups) {\n        Map<GroupDescriptor, Set<UsageDescriptor>> usageDescriptors = new LinkedHashMap<GroupDescriptor, Set<UsageDescriptor>>();\n\n        for (UsagesCollector usagesCollector : Extensions.getExtensions(UsagesCollector.EP_NAME)) {\n            final GroupDescriptor groupDescriptor = usagesCollector.getGroupId();\n\n            if (!disabledGroups.contains(groupDescriptor.getId())) {\n                usageDescriptors.put(groupDescriptor, usagesCollector.getUsages(project));\n            }\n        }\n\n        return usageDescriptors;\n    }","id":92656,"modified_method":"@NotNull\n    public static Map<GroupDescriptor, Set<UsageDescriptor>> getAllUsages(@Nullable Project project, @NotNull Set<String> disabledGroups) {\n        Map<GroupDescriptor, Set<UsageDescriptor>> usageDescriptors = new LinkedHashMap<GroupDescriptor, Set<UsageDescriptor>>();\n\n        for (UsagesCollector usagesCollector : Extensions.getExtensions(UsagesCollector.EP_NAME)) {\n            final GroupDescriptor groupDescriptor = usagesCollector.getGroupId();\n\n            if (!disabledGroups.contains(groupDescriptor.getId())) {\n              try {\n                final Set<UsageDescriptor> usages = usagesCollector.getUsages(project);\n                usageDescriptors.put(groupDescriptor, usages);\n              }\n              catch (CollectUsagesException e) {\n                LOG.info(e);\n              }\n            }\n        }\n\n        return usageDescriptors;\n    }","commit_id":"9764aff7b148f9de33586409b1b3b287f668a95f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void addUserSkeletonsRoot(@NotNull SdkModificator sdkModificator) {\n    final VirtualFile root = LocalFileSystem.getInstance().refreshAndFindFileByPath(getUserSkeletonsPath());\n    sdkModificator.addRoot(root, OrderRootType.CLASSES);\n  }","id":92657,"modified_method":"public static void addUserSkeletonsRoot(@NotNull SdkModificator sdkModificator) {\n    final VirtualFile root = LocalFileSystem.getInstance().refreshAndFindFileByPath(getUserSkeletonsPath());\n    if (root != null) {\n      sdkModificator.addRoot(root, OrderRootType.CLASSES);\n    }\n  }","commit_id":"8c0b8a300b9b83a850f1c1f97ba404b112701b41","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static String getUserSkeletonsPath() {\n    if (ApplicationManager.getApplication().isInternal()) {\n      return StringUtil.join(new String[] {PathManager.getHomePath(), \"python\", \"skeletons\", \"user-skeletons\"}, File.separator);\n    }\n    // TODO: Copy user skeletons to this path\n    return PathManager.getSystemPath() + File.separator + \"user-skeletons\";\n  }","id":92658,"modified_method":"@NotNull\n  public static String getUserSkeletonsPath() {\n    if (ApplicationManager.getApplication().isInternal()) {\n      return StringUtil.join(new String[] {PathManager.getHomePath(), \"python\", \"helpers\", \"user-skeletons\"}, File.separator);\n    }\n    // TODO: Add the possibility to put skeletons into PathManager.getSystemPath() + \"/user-skeletons\"\n    return PythonHelpersLocator.getHelperPath(\"user-skeletons\");\n  }","commit_id":"8c0b8a300b9b83a850f1c1f97ba404b112701b41","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Document loadModelDocument(byte[] bytes) {\n    Document document = null;\n    try {\n      document = JDOMUtil.loadDocument(new ByteArrayInputStream(bytes));\n    } catch (JDOMException e) {\n      LOG.error(e);\n    } catch (IOException e) {\n      LOG.error(e);\n    }\n    return document;\n  }","id":92659,"modified_method":"@NotNull\n  private static Document loadModelDocument(@NotNull byte[] bytes) {\n    Document document;\n    try {\n      document = JDOMUtil.loadDocument(new ByteArrayInputStream(bytes));\n    } catch (JDOMException e) {\n      throw new RuntimeException(e);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return document;\n  }","commit_id":"41bfa303a52702c17e0346fe078b022353428652","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static Document loadModelDocument(File file) {\n    Document document = null;\n    try {\n      document = JDOMUtil.loadDocument(file);\n    } catch (JDOMException e) {\n      LOG.error(e);\n    } catch (IOException e) {\n      LOG.error(e);\n    }\n    return document;\n  }","id":92660,"modified_method":"@NotNull\n  private static Document loadModelDocument(@NotNull File file) {\n    Document document;\n    try {\n      document = JDOMUtil.loadDocument(file);\n    } catch (JDOMException e) {\n      throw new RuntimeException(e);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return document;\n  }","commit_id":"41bfa303a52702c17e0346fe078b022353428652","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SModel readModel(File file) {\n    LOG.debug(\"ModelPersistence readModel from :\" + file.getAbsolutePath());\n\n    // the model FQ name ...\n    String fileName = file.getName();\n    int index = fileName.indexOf('.');\n    String rawModelName = (index >= 0) ? fileName.substring(0, index) : fileName;\n    String modelName = rawModelName;\n    int index1 = rawModelName.indexOf(\"@\");\n    String modelStereotype = \"\";\n    if (index1 >= 0) {\n      modelName = rawModelName.substring(0, index1);\n      modelStereotype = rawModelName.substring(index1 + 1);\n    }\n\n\n    Document document = loadModelDocument(file);\n\n    if (document == null) {\n      LOG.debug(\"Couldn't load model file:\" + file.getAbsolutePath());\n      return null;\n    }\n\n    return readModel(document, modelName, modelStereotype);\n  }","id":92661,"modified_method":"@NotNull\n  public static SModel readModel(@NotNull File file) {\n    LOG.debug(\"ModelPersistence readModel from :\" + file.getAbsolutePath());\n\n    // the model FQ name ...\n    String fileName = file.getName();\n    int index = fileName.indexOf('.');\n    String rawModelName = (index >= 0) ? fileName.substring(0, index) : fileName;\n    String modelName = rawModelName;\n    int index1 = rawModelName.indexOf(\"@\");\n    String modelStereotype = \"\";\n    if (index1 >= 0) {\n      modelName = rawModelName.substring(0, index1);\n      modelStereotype = rawModelName.substring(index1 + 1);\n    }\n\n    Document document = loadModelDocument(file);\n\n    return readModel(document, modelName, modelStereotype);\n  }","commit_id":"41bfa303a52702c17e0346fe078b022353428652","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SModel readModel(Document document, String modelName, String stereotype) {\n    Element rootElement = document.getRootElement();\n\n    String modelLongName = rootElement.getAttributeValue(NAME);\n\n    if (modelLongName == null) {//back compatibility\n      String modelNamespace = rootElement.getAttributeValue(NAMESPACE, \"\");\n      modelLongName = NameUtil.longNameFromNamespaceAndShortName(modelNamespace, modelName);\n    } else {\n      String shortName = NameUtil.shortNameFromLongName(modelLongName);\n      LOG.assertLog(shortName.equals(modelName));\n    }\n\n    SModel model = new SModel(new SModelUID(modelLongName, stereotype));\n\n    model.setLoading(true);\n    try {\n      Element maxImportIndex = rootElement.getChild(MAX_IMPORT_INDEX);\n      if (maxImportIndex == null) maxImportIndex = rootElement.getChild(\"maxReferenceID\"); // old manner\n      model.setMaxImportIndex(readIntAttributeValue(maxImportIndex, VALUE));\n    } catch (Throwable e) {\n      LOG.error(e);\n    }\n\n    // languages\n    List languages = rootElement.getChildren(LANGUAGE);\n    for (Object language : languages) {\n      Element element = (Element) language;\n      String languageNamespace = element.getAttributeValue(NAMESPACE);\n      model.addLanguage(languageNamespace);\n    }\n\n    // imports\n    List imports = rootElement.getChildren(IMPORT_ELEMENT);\n    for (Object anImport : imports) {\n      Element element = (Element) anImport;\n      String indexValue = element.getAttributeValue(MODEL_IMPORT_INDEX, element.getAttributeValue(\"referenceID\"));\n      int importIndex = Integer.parseInt(indexValue);\n      String importedModelUIDString = element.getAttributeValue(MODEL_UID);\n      if (importedModelUIDString == null) {\n        // read in old manner...\n        String importedModelFQName = NameUtil.longNameFromNamespaceAndShortName(element.getAttributeValue(NAMESPACE),\n                element.getAttributeValue(NAME));\n        String importedModelStereotype = element.getAttributeValue(STEREOTYPE, \"\");\n        importedModelUIDString = new SModelUID(importedModelFQName, importedModelStereotype).toString();\n      }\n      if (importedModelUIDString == null) {\n        LOG.error(\"Error loading import element for index \" + importIndex + \" in \" + model.getUID());\n        continue;\n      }\n      if (importIndex > model.getMaxImportIndex()) {\n        LOG.warning(\"Import element \" + importIndex + \":\" + importedModelUIDString + \" greater then max import index (\" + model.getMaxImportIndex() + \") in \" + model.getUID());\n        model.setMaxImportIndex(importIndex);\n      }\n\n      SModelUID importedModelUID = SModelUID.fromString(importedModelUIDString);\n      model.addImportElement(importedModelUID, importIndex);\n    }\n\n    ArrayList<ReferencePersister> referenceDescriptors = new ArrayList<ReferencePersister>();\n    List children = rootElement.getChildren(NODE);\n    for (Object child : children) {\n      Element element = (Element) child;\n      SNode snode = readNode(element, model, referenceDescriptors, false);\n      model.addRoot(snode);\n    }\n\n    for (ReferencePersister referencePersister : referenceDescriptors) {\n      referencePersister.createReferenceInModel(model);\n    }\n\n    model.setLoading(false);\n    return model;\n  }","id":92662,"modified_method":"@NotNull\n  public static SModel readModel(\n          @NotNull Document document,\n          @NotNull String modelName,\n          @NotNull String stereotype) {\n    Element rootElement = document.getRootElement();\n\n    String modelLongName = rootElement.getAttributeValue(NAME);\n\n    if (modelLongName == null) {//back compatibility\n      String modelNamespace = rootElement.getAttributeValue(NAMESPACE, \"\");\n      modelLongName = NameUtil.longNameFromNamespaceAndShortName(modelNamespace, modelName);\n    } else {\n      String shortName = NameUtil.shortNameFromLongName(modelLongName);\n      LOG.assertLog(shortName.equals(modelName));\n    }\n\n    SModel model = new SModel(new SModelUID(modelLongName, stereotype));\n\n    model.setLoading(true);\n    try {\n      Element maxImportIndex = rootElement.getChild(MAX_IMPORT_INDEX);\n      if (maxImportIndex == null) maxImportIndex = rootElement.getChild(\"maxReferenceID\"); // old manner\n      model.setMaxImportIndex(readIntAttributeValue(maxImportIndex, VALUE));\n    } catch (Throwable e) {\n      LOG.error(e);\n    }\n\n    // languages\n    List languages = rootElement.getChildren(LANGUAGE);\n    for (Object language : languages) {\n      Element element = (Element) language;\n      String languageNamespace = element.getAttributeValue(NAMESPACE);\n      model.addLanguage(languageNamespace);\n    }\n\n    // imports\n    List imports = rootElement.getChildren(IMPORT_ELEMENT);\n    for (Object anImport : imports) {\n      Element element = (Element) anImport;\n      String indexValue = element.getAttributeValue(MODEL_IMPORT_INDEX, element.getAttributeValue(\"referenceID\"));\n      int importIndex = Integer.parseInt(indexValue);\n      String importedModelUIDString = element.getAttributeValue(MODEL_UID);\n      if (importedModelUIDString == null) {\n        // read in old manner...\n        String importedModelFQName = NameUtil.longNameFromNamespaceAndShortName(element.getAttributeValue(NAMESPACE),\n                element.getAttributeValue(NAME));\n        String importedModelStereotype = element.getAttributeValue(STEREOTYPE, \"\");\n        importedModelUIDString = new SModelUID(importedModelFQName, importedModelStereotype).toString();\n      }\n      if (importedModelUIDString == null) {\n        LOG.error(\"Error loading import element for index \" + importIndex + \" in \" + model.getUID());\n        continue;\n      }\n      if (importIndex > model.getMaxImportIndex()) {\n        LOG.warning(\"Import element \" + importIndex + \":\" + importedModelUIDString + \" greater then max import index (\" + model.getMaxImportIndex() + \") in \" + model.getUID());\n        model.setMaxImportIndex(importIndex);\n      }\n\n      SModelUID importedModelUID = SModelUID.fromString(importedModelUIDString);\n      model.addImportElement(importedModelUID, importIndex);\n    }\n\n    ArrayList<ReferencePersister> referenceDescriptors = new ArrayList<ReferencePersister>();\n    List children = rootElement.getChildren(NODE);\n    for (Object child : children) {\n      Element element = (Element) child;\n      SNode snode = readNode(element, model, referenceDescriptors, false);\n      if (snode != null) {\n        model.addRoot(snode);\n      }\n    }\n\n    for (ReferencePersister referencePersister : referenceDescriptors) {\n      referencePersister.createReferenceInModel(model);\n    }\n\n    model.setLoading(false);\n    return model;\n  }","commit_id":"41bfa303a52702c17e0346fe078b022353428652","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean addOrderEntries(OrderRootType orderRootType, ProjectRootType projectRootType, Sdk sdk, SdkModificator toModificator){\n    boolean wasSmthAdded = false;\n    final String[] entries = sdk.getRootProvider().getUrls(orderRootType);\n    for (String entry : entries) {\n      VirtualFile virtualFile = VirtualFileManager.getInstance().findFileByUrl(entry);\n      toModificator.addRoot(virtualFile, projectRootType);\n      wasSmthAdded = true;\n    }\n    return wasSmthAdded;\n  }","id":92663,"modified_method":"private static boolean addOrderEntries(OrderRootType orderRootType, ProjectRootType projectRootType, Sdk sdk, SdkModificator toModificator){\n    boolean wasSmthAdded = false;\n    final String[] entries = sdk.getRootProvider().getUrls(orderRootType);\n    for (String entry : entries) {\n      VirtualFile virtualFile = VirtualFileManager.getInstance().findFileByUrl(entry);\n      if (virtualFile != null) {\n        toModificator.addRoot(virtualFile, projectRootType);\n      }\n      wasSmthAdded = true;\n    }\n    return wasSmthAdded;\n  }","commit_id":"d2ade4c0105e17544dea4e4cc2063f7f43e076d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected Sdk getTestProjectSdk() {\n    // add JDK annotations\n    Sdk sdk = super.getTestProjectSdk();\n    SdkModificator sdkModificator = sdk.getSdkModificator();\n    VirtualFile root = LocalFileSystem.getInstance().findFileByPath(PathManager.getHomePath() + \"/jdkAnnotations\");\n    sdkModificator.addRoot(root, AnnotationOrderRootType.getInstance());\n    sdkModificator.commitChanges();\n\n    return sdk;\n  }","id":92664,"modified_method":"@Override\n  protected Sdk getTestProjectSdk() {\n    // add JDK annotations\n    Sdk sdk = super.getTestProjectSdk();\n    SdkModificator sdkModificator = sdk.getSdkModificator();\n    VirtualFile root = LocalFileSystem.getInstance().findFileByPath(PathManager.getHomePath() + \"/jdkAnnotations\");\n    if (root != null) {\n      sdkModificator.addRoot(root, AnnotationOrderRootType.getInstance());\n      sdkModificator.commitChanges();\n    }\n\n    return sdk;\n  }","commit_id":"a0d5486a9287382e1f57be6f7ded831dd96bca82","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void configureModulesLibraryDependencies(@NotNull Map<GradleModule, Module> moduleMappings,\n                                                          @NotNull final Map<GradleLibrary, Library> libraryMappings,\n                                                          @NotNull GradleProject gradleProject) {\n    for (GradleModule gradleModule : gradleProject.getModules()) {\n      Module intellijModule = moduleMappings.get(gradleModule);\n      if (intellijModule == null) {\n        GradleLog.LOG.warn(String.format(\n          \"Can't find intellij module for the gradle module '%s'. Registered mappings: %s\", gradleModule, moduleMappings\n        ));\n        continue;\n      }\n      ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(intellijModule);\n      final ModifiableRootModel moduleRootModel = moduleRootManager.getModifiableModel();\n      GradleEntityVisitor visitor = new GradleEntityVisitorAdapter() {\n        @Override\n        public void visit(@NotNull GradleLibraryDependency dependency) {\n          GradleLibrary gradleLibrary = dependency.getLibrary();\n          Library intellijLibrary = libraryMappings.get(gradleLibrary);\n          if (intellijLibrary == null) {\n            GradleLog.LOG.warn(String.format(\n              \"Can't find registered intellij library for gradle library '%s'. Registered mappings: %s\", gradleLibrary, libraryMappings\n            ));\n            return;\n          }\n          LibraryOrderEntry orderEntry = moduleRootModel.addLibraryEntry(intellijLibrary);\n          orderEntry.setExported(dependency.isExported());\n          orderEntry.setScope(dependency.getScope());\n        }\n      };\n      try {\n        for (GradleDependency dependency : gradleModule.getDependencies()) {\n          dependency.invite(visitor);\n        }\n      }\n      finally {\n        moduleRootModel.commit();\n      }\n    }\n  }","id":92665,"modified_method":"private static Collection<ModifiableRootModel> configureModulesLibraryDependencies(\n    @NotNull Map<GradleModule, Module> moduleMappings,\n    @NotNull final Map<GradleLibrary, Library> libraryMappings,\n    @NotNull GradleProject gradleProject)\n  {\n    List<ModifiableRootModel> result = new ArrayList<ModifiableRootModel>();\n    for (GradleModule gradleModule : gradleProject.getModules()) {\n      Module intellijModule = moduleMappings.get(gradleModule);\n      if (intellijModule == null) {\n        GradleLog.LOG.warn(String.format(\n          \"Can't find intellij module for the gradle module '%s'. Registered mappings: %s\", gradleModule, moduleMappings\n        ));\n        continue;\n      }\n      ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(intellijModule);\n      final ModifiableRootModel moduleRootModel = moduleRootManager.getModifiableModel();\n      result.add(moduleRootModel);\n      GradleEntityVisitor visitor = new GradleEntityVisitorAdapter() {\n        @Override\n        public void visit(@NotNull GradleLibraryDependency dependency) {\n          GradleLibrary gradleLibrary = dependency.getLibrary();\n          Library intellijLibrary = libraryMappings.get(gradleLibrary);\n          if (intellijLibrary == null) {\n            GradleLog.LOG.warn(String.format(\n              \"Can't find registered intellij library for gradle library '%s'. Registered mappings: %s\", gradleLibrary, libraryMappings\n            ));\n            return;\n          }\n          LibraryOrderEntry orderEntry = moduleRootModel.addLibraryEntry(intellijLibrary);\n          orderEntry.setExported(dependency.isExported());\n          orderEntry.setScope(dependency.getScope());\n        }\n      };\n      for (GradleDependency dependency : gradleModule.getDependencies()) {\n        dependency.invite(visitor);\n      }\n    }\n    return result;\n  }","commit_id":"e60a0b00edfc3ea0dee0f800b444dac6f7460a56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doSetupLibraries(@NotNull Map<GradleModule, Module> moduleMappings,\n                                       @NotNull GradleProject gradleProject,\n                                       @NotNull Project intellijProject)\n  {\n    Application application = ApplicationManager.getApplication();\n    application.assertWriteAccessAllowed();\n    \n    Map<GradleLibrary, Library> libraryMappings = registerProjectLibraries(gradleProject, intellijProject);\n    if (libraryMappings == null) {\n      return;\n    }\n\n    configureModulesLibraryDependencies(moduleMappings, libraryMappings, gradleProject);\n  }","id":92666,"modified_method":"private static void doSetupLibraries(@NotNull Map<GradleModule, Module> moduleMappings,\n                                       @NotNull GradleProject gradleProject,\n                                       @NotNull Project intellijProject)\n  {\n    Application application = ApplicationManager.getApplication();\n    application.assertWriteAccessAllowed();\n\n    LibraryTable projectLibraryTable = ProjectLibraryTable.getInstance(intellijProject);\n    if (projectLibraryTable == null) {\n      GradleLog.LOG.warn(\n        \"Can't resolve external dependencies of the target gradle project (\" + intellijProject + \"). Reason: project \"\n        + \"library table is undefined\"\n      );\n      return;\n    }\n    LibraryTable.ModifiableModel model = projectLibraryTable.getModifiableModel();\n    List<ModifiableRootModel> modelsToCommit = new ArrayList<ModifiableRootModel>();\n    try {\n      Map<GradleLibrary, Library> libraryMappings = registerProjectLibraries(gradleProject, model);\n      if (libraryMappings == null) {\n        return;\n      }\n\n      modelsToCommit.addAll(configureModulesLibraryDependencies(moduleMappings, libraryMappings, gradleProject));\n    }\n    finally {\n      model.commit();\n      ProjectRootManager projectRootManager = ProjectRootManager.getInstance(intellijProject);\n      ModifiableRootModel[] modelsAsArray = modelsToCommit.toArray(new ModifiableRootModel[modelsToCommit.size()]);\n      projectRootManager.multiCommit(modelsAsArray);\n    }\n  }","commit_id":"e60a0b00edfc3ea0dee0f800b444dac6f7460a56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void registerPath(@NotNull GradleLibrary gradleLibrary, @NotNull Library.ModifiableModel model) {\n    for (LibraryPathType pathType : LibraryPathType.values()) {\n      String path = gradleLibrary.getPath(pathType);\n      if (path != null) {\n        model.addRoot(toVfsUrl(path), pathType.getRootType());\n      }\n    }\n  }","id":92667,"modified_method":"private static void registerPath(@NotNull GradleLibrary gradleLibrary, @NotNull Library.ModifiableModel model) {\n    for (LibraryPathType pathType : LibraryPathType.values()) {\n      String path = gradleLibrary.getPath(pathType);\n      if (path != null) {\n        VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByIoFile(new File(path));\n        if (virtualFile == null) {\n          GradleLog.LOG.warn(String.format(\"Can't find %s of the library '%s' at path '%s'\", pathType, gradleLibrary.getName(), path));\n          continue;\n        }\n        VirtualFile jarRoot = JarFileSystem.getInstance().getJarRootForLocalFile(virtualFile);\n        if (jarRoot == null) {\n          GradleLog.LOG.warn(String.format(\n            \"Can't parse contents of the jar file at path '%s' for the library '%s''\", path, gradleLibrary.getName()\n          ));\n          continue;\n        }\n        model.addRoot(jarRoot, pathType.getRootType());\n      }\n    }\n  }","commit_id":"e60a0b00edfc3ea0dee0f800b444dac6f7460a56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Map<GradleModule, Module> importModules(@NotNull final Iterable<GradleModule> modules, \n                                                 @NotNull final ModifiableModuleModel model,\n                                                 @NotNull final Project intellijProject,\n                                                 @NotNull final String gradleProjectPath)\n  {\n    final Map<GradleModule, Module> result = new HashMap<GradleModule, Module>();\n    UIUtil.invokeAndWaitIfNeeded(new Runnable() {\n      @Override\n      public void run() {\n        Application application = ApplicationManager.getApplication();\n        AccessToken writeLock = application.acquireWriteActionLock(getClass());\n        try {\n          try {\n            Map<GradleModule, Module> moduleMappings = doImportModules(modules, model);\n            result.putAll(moduleMappings);\n            myAlarm.cancelAllRequests();\n            myAlarm.addRequest(\n              new SetupExternalLibrariesTask(moduleMappings, gradleProjectPath, intellijProject),\n              PROJECT_INITIALISATION_DELAY_MS\n            );\n          }\n          finally {\n            model.commit();\n          }\n        }\n        finally {\n          writeLock.finish();\n        }\n      }\n    });\n    return result;\n  }","id":92668,"modified_method":"public Map<GradleModule, Module> importModules(@NotNull final Iterable<GradleModule> modules, \n                                                 @NotNull final ModifiableModuleModel model,\n                                                 @NotNull final Project intellijProject,\n                                                 @NotNull final String gradleProjectPath)\n  {\n    final Map<GradleModule, Module> result = new HashMap<GradleModule, Module>();\n    UIUtil.invokeAndWaitIfNeeded(new Runnable() {\n      @Override\n      public void run() {\n        Application application = ApplicationManager.getApplication();\n        AccessToken writeLock = application.acquireWriteActionLock(getClass());\n        try {\n          final List<ModifiableRootModel> rootModels = new ArrayList<ModifiableRootModel>();\n          try {\n            Map<GradleModule, Module> moduleMappings = doImportModules(modules, model, rootModels);\n            result.putAll(moduleMappings);\n            myAlarm.cancelAllRequests();\n            myAlarm.addRequest(\n              new SetupExternalLibrariesTask(moduleMappings, gradleProjectPath, intellijProject),\n              PROJECT_INITIALISATION_DELAY_MS\n            );\n          }\n          finally {\n            ProjectRootManager projectRootManager = ProjectRootManager.getInstance(intellijProject);\n            ModifiableRootModel[] modelsAsArray = rootModels.toArray(new ModifiableRootModel[rootModels.size()]);\n            projectRootManager.multiCommit(model, modelsAsArray);\n          }\n        }\n        finally {\n          writeLock.finish();\n        }\n      }\n    });\n    return result;\n  }","commit_id":"e60a0b00edfc3ea0dee0f800b444dac6f7460a56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Registers {@link GradleProject#getLibraries() libraries} of the given gradle project at the intellij project.\n   * \n   * @param gradleProject    target gradle project being imported\n   * @param intellijProject  intellij representation of the given gradle project\n   * @return                 mapping between libraries of the given gradle and intellij projects\n   */\n  @Nullable\n  private static Map<GradleLibrary, Library> registerProjectLibraries(GradleProject gradleProject, Project intellijProject) {\n    LibraryTable projectLibraryTable = ProjectLibraryTable.getInstance(intellijProject);\n    if (projectLibraryTable == null) {\n      GradleLog.LOG.warn(\n        \"Can't resolve external dependencies of the target gradle project (\" + intellijProject + \"). Reason: project \"\n        + \"library table is undefined\"\n      );\n      return null;\n    }\n    Map<GradleLibrary, Library> libraryMappings = new HashMap<GradleLibrary, Library>();\n    for (GradleLibrary gradleLibrary : gradleProject.getLibraries()) {\n      Library intellijLibrary = projectLibraryTable.createLibrary(gradleLibrary.getName());\n      libraryMappings.put(gradleLibrary, intellijLibrary);\n      Library.ModifiableModel model = intellijLibrary.getModifiableModel();\n      try {\n        registerPath(gradleLibrary, model);\n      }\n      finally {\n        model.commit();\n      }\n    }\n    return libraryMappings;\n  }","id":92669,"modified_method":"/**\n   * Registers {@link GradleProject#getLibraries() libraries} of the given gradle project at the intellij project.\n   * \n   * @param gradleProject    target gradle project being imported\n   * @param librariesModel   model that manages project libraries\n   * @return                 mapping between libraries of the given gradle and intellij projects\n   */\n  @Nullable\n  private static Map<GradleLibrary, Library> registerProjectLibraries(@NotNull GradleProject gradleProject,\n                                                                      @NotNull LibraryTable.ModifiableModel librariesModel)\n  {\n    // Clean existing libraries (if any).\n    for (Library library : librariesModel.getLibraries()) {\n      librariesModel.removeLibrary(library);\n    }\n    \n    Map<GradleLibrary, Library> libraryMappings = new HashMap<GradleLibrary, Library>();\n    for (GradleLibrary gradleLibrary : gradleProject.getLibraries()) {\n      Library intellijLibrary = librariesModel.createLibrary(gradleLibrary.getName());\n      libraryMappings.put(gradleLibrary, intellijLibrary);\n      Library.ModifiableModel model = intellijLibrary.getModifiableModel();\n      try {\n        registerPath(gradleLibrary, model);\n      }\n      finally {\n        model.commit();\n      }\n    }\n    return libraryMappings;\n  }","commit_id":"e60a0b00edfc3ea0dee0f800b444dac6f7460a56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Actual implementation of {@link #importModules(Iterable, Project, ModifiableModuleModel, String)}. Insists on all arguments to\n   * be ready to use.\n   *  \n   * @param modules  modules to import\n   * @param model    modules model\n   * @return         mappings between the given gradle modules and corresponding intellij modules\n   */\n  @NotNull\n  @SuppressWarnings(\"MethodMayBeStatic\")\n  private Map<GradleModule, Module> doImportModules(@NotNull Iterable<GradleModule> modules, @NotNull ModifiableModuleModel model) {\n    Map<GradleModule, Module> result = new HashMap<GradleModule, Module>();\n    for (GradleModule moduleToImport : modules) {\n      Module createdModule = createModule(moduleToImport, model);\n      result.put(moduleToImport, createdModule);\n    }\n    for (GradleModule moduleToImport : modules) {\n      configureModule(moduleToImport, result);\n    }\n    return result;\n  }","id":92670,"modified_method":"/**\n   * Actual implementation of {@link #importModules(Iterable, Project, ModifiableModuleModel, String)}. Insists on all arguments to\n   * be ready to use.\n   *  \n   * @param modules     modules to import\n   * @param model       modules model\n   * @param rootModels  holder for the module root modules. Is expected to be populated during the current method processing\n   * @return            mappings between the given gradle modules and corresponding intellij modules\n   */\n  @NotNull\n  @SuppressWarnings(\"MethodMayBeStatic\")\n  private Map<GradleModule, Module> doImportModules(@NotNull Iterable<GradleModule> modules,\n                                                    @NotNull ModifiableModuleModel model,\n                                                    @NotNull List<ModifiableRootModel> rootModels)\n  {\n    Map<GradleModule, Module> result = new HashMap<GradleModule, Module>();\n    for (GradleModule moduleToImport : modules) {\n      Module createdModule = createModule(moduleToImport, model);\n      result.put(moduleToImport, createdModule);\n    }\n    for (GradleModule moduleToImport : modules) {\n      ModifiableRootModel rootModel = configureModule(moduleToImport, result);\n      rootModels.add(rootModel);\n    }\n    return result;\n  }","commit_id":"e60a0b00edfc3ea0dee0f800b444dac6f7460a56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Resolves (downloads if necessary) external libraries necessary for the gradle project located at the given path and configures\n   * them for the corresponding intellij project.\n   * <p/>\n   * <b>Note:<\/b> is assumed to be executed under write action.\n   * \n   * @param moduleMappings     gradle-intellij module mappings\n   * @param intellijProject    intellij project for the target gradle project\n   * @param gradleProjectPath  file system path to the target gradle project\n   */\n  private static void setupLibraries(@NotNull final Map<GradleModule, Module> moduleMappings,\n                                     @NotNull final Project intellijProject,\n                                     @NotNull final String gradleProjectPath)\n  {\n    final GradleApiFacadeManager manager = ServiceManager.getService(GradleApiFacadeManager.class);\n    \n    Runnable edtAction = new Runnable() {\n      @Override\n      public void run() {\n        final Ref<GradleProject> gradleProjectRef = new Ref<GradleProject>();\n        //ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n        ProgressManager.getInstance().run(\n          new Task.Backgroundable(intellijProject, GradleBundle.message(\"gradle.library.resolve.progress.text\"), false) {\n            @Override\n            public void run(@NotNull ProgressIndicator indicator) {\n              indicator.setIndeterminate(true);\n              try {\n                GradleProjectResolver resolver = manager.getFacade().getResolver();\n                gradleProjectRef.set(resolver.resolveProjectInfo(gradleProjectPath, true));\n              }\n              catch (Exception e) {\n                GradleLog.LOG.warn(\"Can't resolve external dependencies of the target gradle project (\" + gradleProjectPath + \")\", e);\n              } \n            }\n        });\n\n        final GradleProject gradleProject = gradleProjectRef.get();\n        if (gradleProject == null) {\n          return;\n        }\n        \n        Application application = ApplicationManager.getApplication();\n        AccessToken writeLock = application.acquireWriteActionLock(getClass());\n        try {\n          doSetupLibraries(moduleMappings, gradleProject, intellijProject);\n        }\n        finally {\n          writeLock.finish();\n        }\n      }\n    };\n    UIUtil.invokeLaterIfNeeded(edtAction);\n  }","id":92671,"modified_method":"/**\n   * Resolves (downloads if necessary) external libraries necessary for the gradle project located at the given path and configures\n   * them for the corresponding intellij project.\n   * <p/>\n   * <b>Note:<\/b> is assumed to be executed under write action.\n   * \n   * @param moduleMappings     gradle-intellij module mappings\n   * @param intellijProject    intellij project for the target gradle project\n   * @param gradleProjectPath  file system path to the target gradle project\n   */\n  private static void setupLibraries(@NotNull final Map<GradleModule, Module> moduleMappings,\n                                     @NotNull final Project intellijProject,\n                                     @NotNull final String gradleProjectPath)\n  {\n    final GradleApiFacadeManager manager = ServiceManager.getService(GradleApiFacadeManager.class);\n    final Ref<GradleProject> gradleProjectRef = new Ref<GradleProject>();\n    \n    final Runnable setupExternalDependenciesTask = new Runnable() {\n      @Override\n      public void run() {\n        final GradleProject gradleProject = gradleProjectRef.get();\n        if (gradleProject == null) {\n          return;\n        }\n\n        Application application = ApplicationManager.getApplication();\n        AccessToken writeLock = application.acquireWriteActionLock(getClass());\n        try {\n          doSetupLibraries(moduleMappings, gradleProject, intellijProject);\n        }\n        finally {\n          writeLock.finish();\n        } \n      }\n    };\n    \n    Runnable resolveDependenciesTask = new Runnable() {\n      @Override\n      public void run() {\n        ProgressManager.getInstance().run(\n          new Task.Backgroundable(intellijProject, GradleBundle.message(\"gradle.library.resolve.progress.text\"), false) {\n            @Override\n            public void run(@NotNull ProgressIndicator indicator) {\n              indicator.setIndeterminate(true);\n              try {\n                GradleProjectResolver resolver = manager.getFacade().getResolver();\n                GradleProject projectWithResolvedLibraries = resolver.resolveProjectInfo(gradleProjectPath, true);\n                gradleProjectRef.set(projectWithResolvedLibraries);\n                UIUtil.invokeLaterIfNeeded(setupExternalDependenciesTask);\n              }\n              catch (Exception e) {\n                GradleLog.LOG.warn(\"Can't resolve external dependencies of the target gradle project (\" + gradleProjectPath + \")\", e);\n              }\n            }\n          }); \n      }\n    };\n    \n    UIUtil.invokeLaterIfNeeded(resolveDependenciesTask);\n  }","commit_id":"e60a0b00edfc3ea0dee0f800b444dac6f7460a56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Applies module settings received from the gradle api (encapsulate at the given {@link GradleModule} object) to the\n   * target intellij module (retrieved from the given module mappings).\n   * \n   * @param module   target gradle module which corresponding intellij module should be configured\n   * @param modules  gradle module to intellij modules mappings. Is assumed to have a value for the given gradle modules used as a key\n   */\n  private static void configureModule(@NotNull GradleModule module, @NotNull Map<GradleModule, Module> modules) {\n    Application application = ApplicationManager.getApplication();\n    application.assertWriteAccessAllowed();\n    \n    ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(modules.get(module));\n    ModifiableRootModel rootModel = moduleRootManager.getModifiableModel();\n    try {\n      configureModule(module, rootModel, modules);\n    }\n    finally {\n      rootModel.commit();\n    }\n  }","id":92672,"modified_method":"/**\n   * Applies module settings received from the gradle api (encapsulate at the given {@link GradleModule} object) to the\n   * target intellij module (retrieved from the given module mappings).\n   * \n   * @param module   target gradle module which corresponding intellij module should be configured\n   * @param modules  gradle module to intellij modules mappings. Is assumed to have a value for the given gradle modules used as a key\n   * @return         module roots model used during configuration\n   */\n  @NotNull\n  private static ModifiableRootModel configureModule(@NotNull GradleModule module, @NotNull Map<GradleModule, Module> modules) {\n    Application application = ApplicationManager.getApplication();\n    application.assertWriteAccessAllowed();\n    \n    ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(modules.get(module));\n    ModifiableRootModel rootModel = moduleRootManager.getModifiableModel();\n    configureModule(module, rootModel, modules);\n    return rootModel;\n  }","commit_id":"e60a0b00edfc3ea0dee0f800b444dac6f7460a56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Contains actual logic of {@link #configureModule(GradleModule, Map)}.\n   * \n   * @param module   target module settings holder\n   * @param model    intellij module setting manager\n   * @param modules  modules mappings\n   */\n  private static void configureModule(@NotNull GradleModule module, @NotNull final ModifiableRootModel model,\n                                      @NotNull final Map<GradleModule, Module> modules)\n  {\n    // Ensure that dependencies are clear.\n    for (OrderEntry orderEntry : model.getOrderEntries()) {\n      model.removeOrderEntry(orderEntry);\n    }\n    \n    // Configure SDK.\n    model.inheritSdk();\n\n    // Compile output.\n    CompilerModuleExtension compilerExtension = model.getModuleExtension(CompilerModuleExtension.class);\n    compilerExtension.inheritCompilerOutputPath(module.isInheritProjectCompileOutputPath());\n    if (!module.isInheritProjectCompileOutputPath()) {\n      compilerExtension.setCompilerOutputPath(module.getCompileOutputPath(SourceType.SOURCE));\n      compilerExtension.setCompilerOutputPathForTests(module.getCompileOutputPath(SourceType.TEST));\n    }\n    \n    // Content roots.\n    for (GradleContentRoot contentRoot : module.getContentRoots()) {\n      ContentEntry contentEntry = model.addContentEntry(toVfsUrl(contentRoot.getRootPath()));\n      for (String path : contentRoot.getPaths(SourceType.SOURCE)) {\n        contentEntry.addSourceFolder(toVfsUrl(path), false);\n      }\n      for (String path : contentRoot.getPaths(SourceType.TEST)) {\n        contentEntry.addSourceFolder(toVfsUrl(path), true);\n      }\n      for (String path : contentRoot.getPaths(SourceType.EXCLUDED)) {\n        contentEntry.addExcludeFolder(toVfsUrl(path));\n      }\n    }\n    \n    // Module dependencies.\n    for (GradleDependency dependency : module.getDependencies()) {\n      dependency.invite(new GradleEntityVisitorAdapter() {\n        @Override\n        public void visit(@NotNull GradleModuleDependency dependency) {\n          ModuleOrderEntry orderEntry = model.addModuleOrderEntry(modules.get(dependency.getModule()));\n          orderEntry.setExported(dependency.isExported());\n          orderEntry.setScope(dependency.getScope());\n        }\n      });\n    }\n  }","id":92673,"modified_method":"/**\n   * Contains actual logic of {@link #configureModule(GradleModule, Map)}.\n   * \n   * @param module   target module settings holder\n   * @param model    intellij module setting manager\n   * @param modules  modules mappings\n   */\n  private static void configureModule(@NotNull GradleModule module, @NotNull final ModifiableRootModel model,\n                                      @NotNull final Map<GradleModule, Module> modules)\n  {\n    // Ensure that dependencies are clear.\n    final Object key = new Object();\n    final Object dummy = new Object();\n    RootPolicy<Object> policy = new RootPolicy<Object>() {\n      @Override\n      public Object visitModuleSourceOrderEntry(ModuleSourceOrderEntry moduleSourceOrderEntry, Object value) {\n        return key;\n      }\n    };\n    for (OrderEntry orderEntry : model.getOrderEntries()) {\n      // Don't remove 'module source' order entry (configured automatically on module creation).\n      if (key != orderEntry.accept(policy, dummy)) {\n        model.removeOrderEntry(orderEntry);\n      }\n    }\n    \n    // Configure SDK.\n    model.inheritSdk();\n\n    // Compile output.\n    CompilerModuleExtension compilerExtension = model.getModuleExtension(CompilerModuleExtension.class);\n    compilerExtension.inheritCompilerOutputPath(module.isInheritProjectCompileOutputPath());\n    if (!module.isInheritProjectCompileOutputPath()) {\n      compilerExtension.setCompilerOutputPath(module.getCompileOutputPath(SourceType.SOURCE));\n      compilerExtension.setCompilerOutputPathForTests(module.getCompileOutputPath(SourceType.TEST));\n    }\n    \n    // Content roots.\n    for (GradleContentRoot contentRoot : module.getContentRoots()) {\n      ContentEntry contentEntry = model.addContentEntry(toVfsUrl(contentRoot.getRootPath()));\n      for (String path : contentRoot.getPaths(SourceType.SOURCE)) {\n        contentEntry.addSourceFolder(toVfsUrl(path), false);\n      }\n      for (String path : contentRoot.getPaths(SourceType.TEST)) {\n        contentEntry.addSourceFolder(toVfsUrl(path), true);\n      }\n      for (String path : contentRoot.getPaths(SourceType.EXCLUDED)) {\n        contentEntry.addExcludeFolder(toVfsUrl(path));\n      }\n    }\n    \n    // Module dependencies.\n    for (GradleDependency dependency : module.getDependencies()) {\n      dependency.invite(new GradleEntityVisitorAdapter() {\n        @Override\n        public void visit(@NotNull GradleModuleDependency dependency) {\n          ModuleOrderEntry orderEntry = model.addModuleOrderEntry(modules.get(dependency.getModule()));\n          orderEntry.setExported(dependency.isExported());\n          orderEntry.setScope(dependency.getScope());\n        }\n      });\n    }\n  }","commit_id":"e60a0b00edfc3ea0dee0f800b444dac6f7460a56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testNativePathSerialization() {\n    LibraryTable table = LibraryTablesRegistrar.getInstance().getLibraryTable(myProject);\n    Library library = table.createLibrary(\"native\");\n    Library.ModifiableModel model = library.getModifiableModel();\n    model.addRoot(\"file://native-lib-root\", NativeLibraryOrderRootType.getInstance());\n    commit(model);\n\n    Element element = serialize(library);\n    PlatformTestUtil.assertElementEquals(\n      \"<root><library name=\\\"native\\\"><CLASSES /><JAVADOC />\" +\n      \"<NATIVE><root url=\\\"file://native-lib-root\\\" /><\/NATIVE>\" +\n      \"<SOURCES /><\/library><\/root>\",\n      element);\n  }","id":92674,"modified_method":"public void testNativePathSerialization() {\n    LibraryTable table = getLibraryTable();\n    Library library = table.createLibrary(\"native\");\n    Library.ModifiableModel model = library.getModifiableModel();\n    model.addRoot(\"file://native-lib-root\", NativeLibraryOrderRootType.getInstance());\n    commit(model);\n\n    Element element = serialize(library);\n    PlatformTestUtil.assertElementEquals(\n      \"<root><library name=\\\"native\\\"><CLASSES /><JAVADOC />\" +\n      \"<NATIVE><root url=\\\"file://native-lib-root\\\" /><\/NATIVE>\" +\n      \"<SOURCES /><\/library><\/root>\",\n      element);\n  }","commit_id":"c4ec3609ce9d8a67813a652698badad6e501c84f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testJarDirectoriesSerialization() {\n    LibraryTable table = LibraryTablesRegistrar.getInstance().getLibraryTable(myProject);\n    Library library = table.createLibrary(\"jarDirs\");\n    Library.ModifiableModel model = library.getModifiableModel();\n    model.addJarDirectory(\"file://jar-dir\", false, OrderRootType.CLASSES);\n    model.addJarDirectory(\"file://jar-dir-src\", false, OrderRootType.SOURCES);\n    commit(model);\n\n    Element element = serialize(library);\n    PlatformTestUtil.assertElementEquals(\"<root>\\n\" +\n                                         \"  <library name=\\\"jarDirs\\\">\\n\" +\n                                         \"    <CLASSES>\\n\" +\n                                         \"      <root url=\\\"file://jar-dir\\\" />\\n\" +\n                                         \"    <\/CLASSES>\\n\" +\n                                         \"    <JAVADOC />\\n\" +\n                                         \"    <SOURCES>\\n\" +\n                                         \"      <root url=\\\"file://jar-dir-src\\\" />\\n\" +\n                                         \"    <\/SOURCES>\\n\" +\n                                         \"    <jarDirectory url=\\\"file://jar-dir\\\" recursive=\\\"false\\\" />\\n\" +\n                                         \"    <jarDirectory url=\\\"file://jar-dir-src\\\" recursive=\\\"false\\\" type=\\\"SOURCES\\\" />\\n\" +\n                                         \"  <\/library>\\n\" +\n                                         \"<\/root>\" , element);\n  }","id":92675,"modified_method":"public void testJarDirectoriesSerialization() {\n    LibraryTable table = getLibraryTable();\n    Library library = table.createLibrary(\"jarDirs\");\n    Library.ModifiableModel model = library.getModifiableModel();\n    model.addJarDirectory(\"file://jar-dir\", false, OrderRootType.CLASSES);\n    model.addJarDirectory(\"file://jar-dir-src\", false, OrderRootType.SOURCES);\n    commit(model);\n\n    Element element = serialize(library);\n    PlatformTestUtil.assertElementEquals(\"<root>\\n\" +\n                                         \"  <library name=\\\"jarDirs\\\">\\n\" +\n                                         \"    <CLASSES>\\n\" +\n                                         \"      <root url=\\\"file://jar-dir\\\" />\\n\" +\n                                         \"    <\/CLASSES>\\n\" +\n                                         \"    <JAVADOC />\\n\" +\n                                         \"    <SOURCES>\\n\" +\n                                         \"      <root url=\\\"file://jar-dir-src\\\" />\\n\" +\n                                         \"    <\/SOURCES>\\n\" +\n                                         \"    <jarDirectory url=\\\"file://jar-dir\\\" recursive=\\\"false\\\" />\\n\" +\n                                         \"    <jarDirectory url=\\\"file://jar-dir-src\\\" recursive=\\\"false\\\" type=\\\"SOURCES\\\" />\\n\" +\n                                         \"  <\/library>\\n\" +\n                                         \"<\/root>\" , element);\n  }","commit_id":"c4ec3609ce9d8a67813a652698badad6e501c84f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Library createLibrary(final String name, final VirtualFile classesRoot, final VirtualFile sourceRoot) {\n    final Library library = LibraryTablesRegistrar.getInstance().getLibraryTable(myProject).createLibrary(name);\n    final Library.ModifiableModel model = library.getModifiableModel();\n    model.addRoot(classesRoot, OrderRootType.CLASSES);\n    if (sourceRoot != null) {\n      model.addRoot(sourceRoot, OrderRootType.SOURCES);\n    }\n    model.commit();\n    return library;\n  }","id":92676,"modified_method":"protected Library createLibrary(final String name, final @Nullable VirtualFile classesRoot, final @Nullable VirtualFile sourceRoot) {\n    final Library library = LibraryTablesRegistrar.getInstance().getLibraryTable(myProject).createLibrary(name);\n    final Library.ModifiableModel model = library.getModifiableModel();\n    if (classesRoot != null) {\n      model.addRoot(classesRoot, OrderRootType.CLASSES);\n    }\n    if (sourceRoot != null) {\n      model.addRoot(sourceRoot, OrderRootType.SOURCES);\n    }\n    model.commit();\n    return library;\n  }","commit_id":"c4ec3609ce9d8a67813a652698badad6e501c84f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static DefaultLibraryLocalComponentMetaData newResolvedLibraryMetadata(\n        LibraryBinaryIdentifier componentId,\n        Map<UsageKind, TaskDependency> buildDependencies,\n        Map<UsageKind, Iterable<DependencySpec>> dependencies,\n        String defaultProject) {\n        DefaultLibraryLocalComponentMetaData metadata = newDefaultLibraryLocalComponentMetadata(componentId, buildDependencies);\n        for (Map.Entry<UsageKind, Iterable<DependencySpec>> entry : dependencies.entrySet()) {\n            addDependenciesToMetadata(metadata, defaultProject, entry.getValue(), entry.getKey());\n        }\n        return metadata;\n    }","id":92677,"modified_method":"public static DefaultLibraryLocalComponentMetaData newResolvedLibraryMetadata(\n        LibraryBinaryIdentifier componentId,\n        Map<UsageKind, TaskDependency> buildDependencies,\n        Map<UsageKind, Iterable<DependencySpec>> dependencies,\n        String defaultProject) {\n        DefaultLibraryLocalComponentMetaData metadata = newDefaultLibraryLocalComponentMetadata(componentId, buildDependencies);\n        addDependenciesToMetaData(dependencies, metadata, defaultProject);\n        return metadata;\n    }","commit_id":"fb7a6d82c3cc7a2ddc10f13cb6ae0f8e01133ece","url":"https://github.com/gradle/gradle"},{"original_method":"private void setDependenciesOf(JUnitTestSuiteBinarySpec binary, DependencySpecContainer dependencies) {\n            ((WithDependencies) binary).setDependencies(Lists.newArrayList(dependencies.getDependencies()));\n        }","id":92678,"modified_method":"private void setDependenciesOf(JUnitTestSuiteBinarySpec binary, DependencySpecContainer dependencies) {\n            binary.setDependencies(Lists.newArrayList(dependencies.getDependencies()));\n        }","commit_id":"fb7a6d82c3cc7a2ddc10f13cb6ae0f8e01133ece","url":"https://github.com/gradle/gradle"},{"original_method":"private JavaSourceTransformTaskConfig(ModelSchemaStore schemaStore, List<PlatformJavaCompileConfig> platformJavaConfigurers) {\n                this.schemaStore = schemaStore;\n                this.platformJavaConfigurers = platformJavaConfigurers;\n            }","id":92679,"modified_method":"private JavaSourceTransformTaskConfig(ModelSchemaStore schemaStore) {\n                this.schemaStore = schemaStore;\n            }","commit_id":"fb7a6d82c3cc7a2ddc10f13cb6ae0f8e01133ece","url":"https://github.com/gradle/gradle"},{"original_method":"public void configureTask(Task task, BinarySpec binary, LanguageSourceSet sourceSet, ServiceRegistry serviceRegistry) {\n                PlatformJavaCompile compile = (PlatformJavaCompile) task;\n                JavaSourceSet javaSourceSet = (JavaSourceSet) sourceSet;\n                JvmAssembly assembly = ((WithJvmAssembly) binary).getAssembly();\n                assembly.builtBy(compile);\n\n                compile.setDescription(String.format(\"Compiles %s.\", javaSourceSet));\n                compile.setDestinationDir(conventionalCompilationOutputDirFor(assembly));\n                compile.setDependencyCacheDir(new File(compile.getProject().getBuildDir(), \"jvm-dep-cache\"));\n                compile.dependsOn(javaSourceSet);\n                compile.setSource(javaSourceSet.getSource());\n\n                JavaPlatform targetPlatform = assembly.getTargetPlatform();\n                String targetCompatibility = targetPlatform.getTargetCompatibility().toString();\n                compile.setPlatform(targetPlatform);\n                compile.setToolChain(assembly.getToolChain());\n                compile.setTargetCompatibility(targetCompatibility);\n                compile.setSourceCompatibility(targetCompatibility);\n\n                SourceSetDependencyResolvingClasspath classpath = classpathFor(binary, javaSourceSet, serviceRegistry, schemaStore);\n                compile.setClasspath(classpath);\n\n                for (PlatformJavaCompileConfig configurer : platformJavaConfigurers) {\n                    configurer.configureJavaCompile(binary, javaSourceSet, compile);\n                }\n            }","id":92680,"modified_method":"public void configureTask(Task task, BinarySpec binary, LanguageSourceSet sourceSet, ServiceRegistry serviceRegistry) {\n                PlatformJavaCompile compile = (PlatformJavaCompile) task;\n                JavaSourceSet javaSourceSet = (JavaSourceSet) sourceSet;\n                JvmAssembly assembly = ((WithJvmAssembly) binary).getAssembly();\n                assembly.builtBy(compile);\n\n                compile.setDescription(String.format(\"Compiles %s.\", javaSourceSet));\n                compile.setDestinationDir(conventionalCompilationOutputDirFor(assembly));\n                compile.setDependencyCacheDir(new File(compile.getProject().getBuildDir(), \"jvm-dep-cache\"));\n                compile.dependsOn(javaSourceSet);\n                compile.setSource(javaSourceSet.getSource());\n\n                JavaPlatform targetPlatform = assembly.getTargetPlatform();\n                String targetCompatibility = targetPlatform.getTargetCompatibility().toString();\n                compile.setPlatform(targetPlatform);\n                compile.setToolChain(assembly.getToolChain());\n                compile.setTargetCompatibility(targetCompatibility);\n                compile.setSourceCompatibility(targetCompatibility);\n\n                SourceSetDependencyResolvingClasspath classpath = classpathFor(binary, javaSourceSet, serviceRegistry, schemaStore);\n                compile.setClasspath(classpath);\n\n            }","commit_id":"fb7a6d82c3cc7a2ddc10f13cb6ae0f8e01133ece","url":"https://github.com/gradle/gradle"},{"original_method":"public Java(ModelSchemaStore schemaStore) {\n            this.config = new JavaSourceTransformTaskConfig(schemaStore, platformJavaConfigurers);\n        }","id":92681,"modified_method":"public Java(ModelSchemaStore schemaStore) {\n            this.config = new JavaSourceTransformTaskConfig(schemaStore);\n        }","commit_id":"fb7a6d82c3cc7a2ddc10f13cb6ae0f8e01133ece","url":"https://github.com/gradle/gradle"},{"original_method":"private static void populateUsageMetadata(UsageKind usage,\n                                              Object buildDependency,\n                                              Iterable<DependencySpec> dependencies,\n                                              EnumMap<UsageKind, Iterable<DependencySpec>> dependenciesPerUsage,\n                                              EnumMap<UsageKind, TaskDependency> buildDependenciesPerUsage) {\n        DefaultTaskDependency buildDependencies = new DefaultTaskDependency();\n        buildDependencies.add(buildDependency);\n        dependenciesPerUsage.put(usage, dependencies);\n        buildDependenciesPerUsage.put(usage, buildDependencies);\n    }","id":92682,"modified_method":"private static void configureUsageMetadata(UsageKind usage,\n                                               Object buildDependency,\n                                               Iterable<DependencySpec> dependencies,\n                                               EnumMap<UsageKind, Iterable<DependencySpec>> dependenciesPerUsage,\n                                               EnumMap<UsageKind, TaskDependency> buildDependenciesPerUsage) {\n        Iterable<DependencySpec> dependencySpecs = dependenciesPerUsage.get(usage);\n        dependenciesPerUsage.put(usage, Iterables.concat(dependencies, dependencySpecs));\n        if (buildDependency !=null) {\n            DefaultTaskDependency buildDependencies = (DefaultTaskDependency) buildDependenciesPerUsage.get(usage);\n            buildDependencies.add(buildDependency);\n        }\n    }","commit_id":"fb7a6d82c3cc7a2ddc10f13cb6ae0f8e01133ece","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public DefaultLibraryLocalComponentMetaData createLocalComponentMetaData(BinarySpec selectedBinary, String projectPath) {\n        if (selectedBinary instanceof JarBinarySpecInternal) {\n            JarBinarySpecInternal jarBinarySpec = (JarBinarySpecInternal) selectedBinary;\n            return createJarBinarySpecLocalComponentMetaData(projectPath, jarBinarySpec);\n        } else if (selectedBinary instanceof WithJvmAssembly) {\n            // a local component that provides a JVM assembly\n            JvmAssembly assembly = ((WithJvmAssembly) selectedBinary).getAssembly();\n            return createJvmAssemblyLocalComponentMetaData((JvmBinarySpecInternal) selectedBinary, projectPath, assembly);\n        }\n        return null;\n    }","id":92683,"modified_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public DefaultLibraryLocalComponentMetaData createLocalComponentMetaData(BinarySpec selectedBinary, String projectPath, boolean toAssembly) {\n        EnumMap<UsageKind, Iterable<DependencySpec>> dependenciesPerUsage = new EnumMap<UsageKind, Iterable<DependencySpec>>(UsageKind.class);\n        EnumMap<UsageKind, TaskDependency> buildDependenciesPerUsage = new EnumMap<UsageKind, TaskDependency>(UsageKind.class);\n        EnumMap<UsageKind, List<PublishArtifact>> artifacts = new EnumMap<UsageKind, List<PublishArtifact>>(UsageKind.class);\n        initializeUsages(dependenciesPerUsage, buildDependenciesPerUsage, artifacts);\n        if (selectedBinary instanceof JarBinarySpecInternal) {\n            JarBinarySpecInternal jarBinarySpec = (JarBinarySpecInternal) selectedBinary;\n            createJarBinarySpecLocalComponentMetaData(artifacts, jarBinarySpec, dependenciesPerUsage, buildDependenciesPerUsage, toAssembly);\n        }\n        if (selectedBinary instanceof WithJvmAssembly) {\n            // a local component that provides a JVM assembly\n            JvmAssembly assembly = ((WithJvmAssembly) selectedBinary).getAssembly();\n            createJvmAssemblyLocalComponentMetaData(artifacts, assembly, dependenciesPerUsage, buildDependenciesPerUsage, toAssembly);\n        }\n        return createResolvedMetaData((BinarySpecInternal) selectedBinary, projectPath, dependenciesPerUsage, buildDependenciesPerUsage, artifacts);\n    }","commit_id":"fb7a6d82c3cc7a2ddc10f13cb6ae0f8e01133ece","url":"https://github.com/gradle/gradle"},{"original_method":"private static <T extends JvmTestSuiteBinarySpec> void createJvmTestSuiteBinary(final ModelMap<BinarySpec> testBinaries,\n                                                                                    Class<T> testSuiteBinaryClass,\n                                                                                    JvmTestSuiteSpec testSuite,\n                                                                                    final JvmBinarySpec testedBinary,\n                                                                                    final JavaToolChainRegistry toolChains,\n                                                                                    PlatformResolvers platformResolver,\n                                                                                    final ServiceRegistry serviceRegistry,\n                                                                                    final ModelSchemaStore modelSchemaStore,\n                                                                                    final Action<? super T> configureAction) {\n\n        final List<JavaPlatform> javaPlatforms = resolvePlatforms(platformResolver);\n        final JavaPlatform platform = javaPlatforms.get(0);\n        final BinaryNamingScheme namingScheme = namingSchemeFor(testSuite, testedBinary, javaPlatforms, platform);\n\n        testBinaries.create(namingScheme.getBinaryName(), testSuiteBinaryClass, new Action<T>() {\n            @Override\n            public void execute(T binary) {\n                JvmTestSuiteBinarySpecInternal testBinary = (JvmTestSuiteBinarySpecInternal) binary;\n                testBinary.setNamingScheme(namingScheme);\n                testBinary.setTargetPlatform(platform);\n                testBinary.setToolChain(toolChains.getForPlatform(platform));\n                testBinary.setTestedBinary(testedBinary);\n                injectDependencyResolutionServices(testBinary);\n                configureAction.execute(binary);\n            }\n\n            private void injectDependencyResolutionServices(JvmTestSuiteBinarySpecInternal testBinary) {\n                ArtifactDependencyResolver dependencyResolver = serviceRegistry.get(ArtifactDependencyResolver.class);\n                RepositoryHandler repositories = serviceRegistry.get(RepositoryHandler.class);\n                List<ResolutionAwareRepository> resolutionAwareRepositories = CollectionUtils.collect(repositories, Transformers.cast(ResolutionAwareRepository.class));\n                testBinary.setArtifactDependencyResolver(dependencyResolver);\n                testBinary.setRepositories(resolutionAwareRepositories);\n                testBinary.setModelSchemaStore(modelSchemaStore);\n            }\n        });\n    }","id":92684,"modified_method":"private static <T extends JvmTestSuiteBinarySpec> void createJvmTestSuiteBinary(final ModelMap<BinarySpec> testBinaries,\n                                                                                    Class<T> testSuiteBinaryClass,\n                                                                                    final JvmTestSuiteSpec testSuite,\n                                                                                    final JvmBinarySpec testedBinary,\n                                                                                    final JavaToolChainRegistry toolChains,\n                                                                                    PlatformResolvers platformResolver,\n                                                                                    final ServiceRegistry serviceRegistry,\n                                                                                    final ModelSchemaStore modelSchemaStore,\n                                                                                    final Action<? super T> configureAction) {\n\n        final List<JavaPlatform> javaPlatforms = resolvePlatforms(platformResolver);\n        final JavaPlatform platform = javaPlatforms.get(0);\n        final BinaryNamingScheme namingScheme = namingSchemeFor(testSuite, testedBinary, javaPlatforms, platform);\n\n        testBinaries.create(namingScheme.getBinaryName(), testSuiteBinaryClass, new Action<T>() {\n            @Override\n            public void execute(T binary) {\n                JvmTestSuiteBinarySpecInternal testBinary = (JvmTestSuiteBinarySpecInternal) binary;\n                testBinary.setNamingScheme(namingScheme);\n                testBinary.setTargetPlatform(platform);\n                testBinary.setToolChain(toolChains.getForPlatform(platform));\n                testBinary.setTestedBinary(testedBinary);\n                injectDependencyResolutionServices(testBinary);\n                configureAction.execute(binary);\n                configureCompileClasspath(testBinary);\n            }\n\n            private void injectDependencyResolutionServices(JvmTestSuiteBinarySpecInternal testBinary) {\n                ArtifactDependencyResolver dependencyResolver = serviceRegistry.get(ArtifactDependencyResolver.class);\n                RepositoryHandler repositories = serviceRegistry.get(RepositoryHandler.class);\n                List<ResolutionAwareRepository> resolutionAwareRepositories = CollectionUtils.collect(repositories, Transformers.cast(ResolutionAwareRepository.class));\n                testBinary.setArtifactDependencyResolver(dependencyResolver);\n                testBinary.setRepositories(resolutionAwareRepositories);\n                testBinary.setModelSchemaStore(modelSchemaStore);\n            }\n\n            private void configureCompileClasspath(JvmTestSuiteBinarySpecInternal testSuiteBinary) {\n                Collection<DependencySpec> dependencies = testSuiteBinary.getDependencies();\n                if (testedBinary != null) {\n                    BinarySpecInternal binary = (BinarySpecInternal) testedBinary;\n                    LibraryBinaryIdentifier id = binary.getId();\n                    dependencies.add(DefaultLibraryBinaryDependencySpec.of(id));\n                    if (testedBinary instanceof JarBinarySpecInternal) {\n                        dependencies.addAll(((JarBinarySpecInternal) testedBinary).getApiDependencies());\n                    }\n                }\n            }\n\n        });\n    }","commit_id":"fb7a6d82c3cc7a2ddc10f13cb6ae0f8e01133ece","url":"https://github.com/gradle/gradle"},{"original_method":"private void selectSpecificVariant(BuildableComponentIdResolveResult result, ComponentSpec selectedLibrary, String selectorProjectPath, String variant) {\n        Collection<BinarySpec> allBinaries = selectedLibrary.getBinaries().values();\n        for (BinarySpec binarySpec : allBinaries) {\n            BinarySpecInternal binary = (BinarySpecInternal) binarySpec;\n            LibraryBinaryIdentifier id = binary.getId();\n            if (Objects.equal(variant, id.getVariant())) {\n                LocalComponentMetaData metaData = libraryMetaDataAdapter.createLocalComponentMetaData(binary, selectorProjectPath);\n                result.resolved(metaData);\n            }\n        }\n    }","id":92685,"modified_method":"private void selectSpecificVariant(BuildableComponentIdResolveResult result, ComponentSpec selectedLibrary, String selectorProjectPath, String variant) {\n        Collection<BinarySpec> allBinaries = selectedLibrary.getBinaries().values();\n        for (BinarySpec binarySpec : allBinaries) {\n            BinarySpecInternal binary = (BinarySpecInternal) binarySpec;\n            LibraryBinaryIdentifier id = binary.getId();\n            if (Objects.equal(variant, id.getVariant())) {\n                // TODO:Cedric This is not quite right. We assume that if we are asking for a specific binary, then we resolve to the assembly instead\n                // of the jar, but it should be somehow parametrized\n                LocalComponentMetaData metaData = libraryMetaDataAdapter.createLocalComponentMetaData(binary, selectorProjectPath, true);\n                result.resolved(metaData);\n            }\n        }\n    }","commit_id":"fb7a6d82c3cc7a2ddc10f13cb6ae0f8e01133ece","url":"https://github.com/gradle/gradle"},{"original_method":"private void selectBinaryVariant(BuildableComponentIdResolveResult result, ComponentSpec selectedLibrary, LibraryComponentSelector selector, String selectorProjectPath, String libraryName) {\n        Collection<BinarySpec> allBinaries = selectedLibrary.getBinaries().values();\n        Collection<? extends BinarySpec> compatibleBinaries = matcher.filterBinaries(variantsMetaData, allBinaries);\n        if (!allBinaries.isEmpty() && compatibleBinaries.isEmpty()) {\n            // no compatible variant found\n            result.failed(new ModuleVersionResolveException(selector, errorMessageBuilder.noCompatibleVariantErrorMessage(libraryName, allBinaries)));\n        } else if (compatibleBinaries.size() > 1) {\n            result.failed(new ModuleVersionResolveException(selector, errorMessageBuilder.multipleCompatibleVariantsErrorMessage(libraryName, compatibleBinaries)));\n        } else {\n            BinarySpec selectedBinary = compatibleBinaries.iterator().next();\n            LocalComponentMetaData metaData = libraryMetaDataAdapter.createLocalComponentMetaData(selectedBinary, selectorProjectPath);\n            result.resolved(metaData);\n        }\n    }","id":92686,"modified_method":"private void selectBinaryVariant(BuildableComponentIdResolveResult result, ComponentSpec selectedLibrary, LibraryComponentSelector selector, String selectorProjectPath, String libraryName) {\n        Collection<BinarySpec> allBinaries = selectedLibrary.getBinaries().values();\n        Collection<? extends BinarySpec> compatibleBinaries = matcher.filterBinaries(variantsMetaData, allBinaries);\n        if (!allBinaries.isEmpty() && compatibleBinaries.isEmpty()) {\n            // no compatible variant found\n            result.failed(new ModuleVersionResolveException(selector, errorMessageBuilder.noCompatibleVariantErrorMessage(libraryName, allBinaries)));\n        } else if (compatibleBinaries.size() > 1) {\n            result.failed(new ModuleVersionResolveException(selector, errorMessageBuilder.multipleCompatibleVariantsErrorMessage(libraryName, compatibleBinaries)));\n        } else {\n            BinarySpec selectedBinary = compatibleBinaries.iterator().next();\n            LocalComponentMetaData metaData = libraryMetaDataAdapter.createLocalComponentMetaData(selectedBinary, selectorProjectPath, false);\n            result.resolved(metaData);\n        }\n    }","commit_id":"fb7a6d82c3cc7a2ddc10f13cb6ae0f8e01133ece","url":"https://github.com/gradle/gradle"},{"original_method":"protected Map<String, AggregationBuilder> getFacets(QueryBuilder query, HashMap<String, FilterBuilder> filters) {\n    Map<String, AggregationBuilder> aggregations = new HashMap<String, AggregationBuilder>();\n\n    BoolFilterBuilder langFacetFilter = FilterBuilders.boolFilter();// .must(FilterBuilders.queryFilter(query));\n    for (Map.Entry<String, FilterBuilder> filter : filters.entrySet()) {\n      if (StringUtils.equals(filter.getKey(), RuleNormalizer.RuleField.LANGUAGE.field())) {\n        langFacetFilter.must(filter.getValue());\n      }\n    }\n    /* the Lang facet */\n    aggregations.put(FACET_LANGUAGES + \"global\",\n      AggregationBuilders\n        .global(FACET_LANGUAGES)\n        .subAggregation(\n          AggregationBuilders\n            .filter(FACET_LANGUAGES + \"_filter\")\n            .filter(langFacetFilter)\n            .subAggregation(\n              AggregationBuilders.terms(FACET_LANGUAGES)\n                .field(RuleNormalizer.RuleField.LANGUAGE.field())\n                .order(Terms.Order.count(false))\n                .size(10)\n                .minDocCount(1))));\n\n    BoolFilterBuilder tagsFacetFilter = FilterBuilders.boolFilter();// .must(FilterBuilders.queryFilter(query));\n    for (Map.Entry<String, FilterBuilder> filter : filters.entrySet()) {\n      if (StringUtils.equals(filter.getKey(), RuleNormalizer.RuleField._TAGS.field())) {\n        tagsFacetFilter.must(filter.getValue());\n      }\n    }\n    /* the Tag facet */\n    aggregations.put(FACET_TAGS + \"global\",\n      AggregationBuilders\n        .global(FACET_TAGS)\n        .subAggregation(\n          AggregationBuilders\n            .filter(FACET_TAGS + \"_filter\")\n            .filter(tagsFacetFilter)\n            .subAggregation(\n              AggregationBuilders.terms(FACET_TAGS)\n                .field(RuleNormalizer.RuleField._TAGS.field())\n                .order(Terms.Order.count(false))\n                .size(10)\n                .minDocCount(1))));\n\n    BoolFilterBuilder repositoriesFacetFilter = FilterBuilders.boolFilter();// .must(FilterBuilders.queryFilter(query));\n    for (Map.Entry<String, FilterBuilder> filter : filters.entrySet()) {\n      if (StringUtils.equals(filter.getKey(), RuleNormalizer.RuleField.REPOSITORY.field())) {\n        repositoriesFacetFilter.must(filter.getValue());\n      }\n    }\n    /* the Repo facet */\n    aggregations.put(FACET_REPOSITORIES + \"global\",\n      AggregationBuilders\n        .global(FACET_REPOSITORIES)\n        .subAggregation(\n          AggregationBuilders\n            .filter(FACET_REPOSITORIES + \"_filter\")\n            .filter(repositoriesFacetFilter)\n            .subAggregation(\n              AggregationBuilders.terms(FACET_REPOSITORIES)\n                .field(RuleNormalizer.RuleField.REPOSITORY.field())\n                .order(Terms.Order.count(false))\n                .size(10)\n                .minDocCount(1))));\n\n    return aggregations;\n\n  }","id":92687,"modified_method":"protected Map<String, AggregationBuilder> getFacets(QueryBuilder query, HashMap<String, FilterBuilder> filters) {\n    Map<String, AggregationBuilder> aggregations = new HashMap<String, AggregationBuilder>();\n\n    BoolFilterBuilder langFacetFilter = FilterBuilders.boolFilter().must(FilterBuilders.queryFilter(query));\n    for (Map.Entry<String, FilterBuilder> filter : filters.entrySet()) {\n      if (!StringUtils.equals(filter.getKey(), RuleNormalizer.RuleField.LANGUAGE.field())) {\n        langFacetFilter.must(filter.getValue());\n      }\n    }\n    /* the Lang facet */\n    aggregations.put(FACET_LANGUAGES + \"global\",\n      AggregationBuilders\n        .global(FACET_LANGUAGES)\n        .subAggregation(\n          AggregationBuilders\n            .filter(FACET_LANGUAGES + \"_filter\")\n            .filter(langFacetFilter)\n            .subAggregation(\n              AggregationBuilders.terms(FACET_LANGUAGES)\n                .field(RuleNormalizer.RuleField.LANGUAGE.field())\n                .order(Terms.Order.count(false))\n                .size(10)\n                .minDocCount(1))));\n\n    BoolFilterBuilder tagsFacetFilter = FilterBuilders.boolFilter().must(FilterBuilders.queryFilter(query));\n    for (Map.Entry<String, FilterBuilder> filter : filters.entrySet()) {\n      if (!StringUtils.equals(filter.getKey(), RuleNormalizer.RuleField._TAGS.field())) {\n        tagsFacetFilter.must(filter.getValue());\n      }\n    }\n    /* the Tag facet */\n    aggregations.put(FACET_TAGS + \"global\",\n      AggregationBuilders\n        .global(FACET_TAGS)\n        .subAggregation(\n          AggregationBuilders\n            .filter(FACET_TAGS + \"_filter\")\n            .filter(tagsFacetFilter)\n            .subAggregation(\n              AggregationBuilders.terms(FACET_TAGS)\n                .field(RuleNormalizer.RuleField._TAGS.field())\n                .order(Terms.Order.count(false))\n                .size(10)\n                .minDocCount(1))));\n\n    BoolFilterBuilder repositoriesFacetFilter = FilterBuilders.boolFilter().must(FilterBuilders.queryFilter(query));\n    for (Map.Entry<String, FilterBuilder> filter : filters.entrySet()) {\n      if (!StringUtils.equals(filter.getKey(), RuleNormalizer.RuleField.REPOSITORY.field())) {\n        repositoriesFacetFilter.must(filter.getValue());\n      }\n    }\n    /* the Repo facet */\n    aggregations.put(FACET_REPOSITORIES + \"global\",\n      AggregationBuilders\n        .global(FACET_REPOSITORIES)\n        .subAggregation(\n          AggregationBuilders\n            .filter(FACET_REPOSITORIES + \"_filter\")\n            .filter(repositoriesFacetFilter)\n            .subAggregation(\n              AggregationBuilders.terms(FACET_REPOSITORIES)\n                .field(RuleNormalizer.RuleField.REPOSITORY.field())\n                .order(Terms.Order.count(false))\n                .size(10)\n                .minDocCount(1))));\n\n    return aggregations;\n\n  }","commit_id":"6e8a241fbd106d6647cf0658937829a7912528ec","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected Map<String, AggregationBuilder> getFacets(QueryBuilder query, HashMap<String, FilterBuilder> filters) {\n    Map<String, AggregationBuilder> aggregations = new HashMap<String, AggregationBuilder>();\n\n    BoolFilterBuilder langFacetFilter = FilterBuilders.boolFilter();// .must(FilterBuilders.queryFilter(query));\n    for (Map.Entry<String, FilterBuilder> filter : filters.entrySet()) {\n      if (filter.getKey() != RuleNormalizer.RuleField.LANGUAGE.field()) {\n        langFacetFilter.must(filter.getValue());\n      }\n    }\n    /* the Lang facet */\n    aggregations.put(FACET_LANGUAGES + \"global\",\n      AggregationBuilders\n        .global(FACET_LANGUAGES)\n        .subAggregation(\n          AggregationBuilders\n            .filter(FACET_LANGUAGES + \"_filter\")\n            .filter(langFacetFilter)\n            .subAggregation(\n              AggregationBuilders.terms(FACET_LANGUAGES)\n                .field(RuleNormalizer.RuleField.LANGUAGE.field())\n                .order(Terms.Order.count(false))\n                .size(10)\n                .minDocCount(1))));\n\n    BoolFilterBuilder tagsFacetFilter = FilterBuilders.boolFilter();// .must(FilterBuilders.queryFilter(query));\n    for (Map.Entry<String, FilterBuilder> filter : filters.entrySet()) {\n      if (filter.getKey() != RuleNormalizer.RuleField._TAGS.field()) {\n        tagsFacetFilter.must(filter.getValue());\n      }\n    }\n    /* the Tag facet */\n    aggregations.put(FACET_TAGS + \"global\",\n      AggregationBuilders\n        .global(FACET_TAGS)\n        .subAggregation(\n          AggregationBuilders\n            .filter(FACET_TAGS + \"_filter\")\n            .filter(tagsFacetFilter)\n            .subAggregation(\n              AggregationBuilders.terms(FACET_TAGS)\n                .field(RuleNormalizer.RuleField._TAGS.field())\n                .order(Terms.Order.count(false))\n                .size(10)\n                .minDocCount(1))));\n\n    BoolFilterBuilder repositoriesFacetFilter = FilterBuilders.boolFilter();// .must(FilterBuilders.queryFilter(query));\n    for (Map.Entry<String, FilterBuilder> filter : filters.entrySet()) {\n      if (filter.getKey() != RuleNormalizer.RuleField.REPOSITORY.field()) {\n        repositoriesFacetFilter.must(filter.getValue());\n      }\n    }\n    /* the Repo facet */\n    aggregations.put(FACET_REPOSITORIES + \"global\",\n      AggregationBuilders\n        .global(FACET_REPOSITORIES)\n        .subAggregation(\n          AggregationBuilders\n            .filter(FACET_REPOSITORIES + \"_filter\")\n            .filter(repositoriesFacetFilter)\n            .subAggregation(\n              AggregationBuilders.terms(FACET_REPOSITORIES)\n                .field(RuleNormalizer.RuleField.REPOSITORY.field())\n                .order(Terms.Order.count(false))\n                .size(10)\n                .minDocCount(1))));\n\n    return aggregations;\n\n  }","id":92688,"modified_method":"protected Map<String, AggregationBuilder> getFacets(QueryBuilder query, HashMap<String, FilterBuilder> filters) {\n    Map<String, AggregationBuilder> aggregations = new HashMap<String, AggregationBuilder>();\n\n    BoolFilterBuilder langFacetFilter = FilterBuilders.boolFilter().must(FilterBuilders.queryFilter(query));\n    for (Map.Entry<String, FilterBuilder> filter : filters.entrySet()) {\n      if (filter.getKey() != RuleNormalizer.RuleField.LANGUAGE.field()) {\n        langFacetFilter.must(filter.getValue());\n      }\n    }\n    /* the Lang facet */\n    aggregations.put(FACET_LANGUAGES + \"global\",\n      AggregationBuilders\n        .global(FACET_LANGUAGES)\n        .subAggregation(\n          AggregationBuilders\n            .filter(FACET_LANGUAGES + \"_filter\")\n            .filter(langFacetFilter)\n            .subAggregation(\n              AggregationBuilders.terms(FACET_LANGUAGES)\n                .field(RuleNormalizer.RuleField.LANGUAGE.field())\n                .order(Terms.Order.count(false))\n                .size(10)\n                .minDocCount(1))));\n\n    BoolFilterBuilder tagsFacetFilter = FilterBuilders.boolFilter().must(FilterBuilders.queryFilter(query));\n    for (Map.Entry<String, FilterBuilder> filter : filters.entrySet()) {\n      if (filter.getKey() != RuleNormalizer.RuleField._TAGS.field()) {\n        tagsFacetFilter.must(filter.getValue());\n      }\n    }\n    /* the Tag facet */\n    aggregations.put(FACET_TAGS + \"global\",\n      AggregationBuilders\n        .global(FACET_TAGS)\n        .subAggregation(\n          AggregationBuilders\n            .filter(FACET_TAGS + \"_filter\")\n            .filter(tagsFacetFilter)\n            .subAggregation(\n              AggregationBuilders.terms(FACET_TAGS)\n                .field(RuleNormalizer.RuleField._TAGS.field())\n                .order(Terms.Order.count(false))\n                .size(10)\n                .minDocCount(1))));\n\n    BoolFilterBuilder repositoriesFacetFilter = FilterBuilders.boolFilter().must(FilterBuilders.queryFilter(query));\n    for (Map.Entry<String, FilterBuilder> filter : filters.entrySet()) {\n      if (filter.getKey() != RuleNormalizer.RuleField.REPOSITORY.field()) {\n        repositoriesFacetFilter.must(filter.getValue());\n      }\n    }\n    /* the Repo facet */\n    aggregations.put(FACET_REPOSITORIES + \"global\",\n      AggregationBuilders\n        .global(FACET_REPOSITORIES)\n        .subAggregation(\n          AggregationBuilders\n            .filter(FACET_REPOSITORIES + \"_filter\")\n            .filter(repositoriesFacetFilter)\n            .subAggregation(\n              AggregationBuilders.terms(FACET_REPOSITORIES)\n                .field(RuleNormalizer.RuleField.REPOSITORY.field())\n                .order(Terms.Order.count(false))\n                .size(10)\n                .minDocCount(1))));\n\n    return aggregations;\n\n  }","commit_id":"e604855a2fe3effdb814ec019459d420b932b79a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void global_facet_on_repositories_and_tags() {\n    dao.insert(dbSession, RuleTesting.newDto(RuleKey.of(\"php\", \"S001\"))\n      .setSystemTags(ImmutableSet.of(\"sysTag\")))\n      .setTags(ImmutableSet.<String>of());\n    dao.insert(dbSession, RuleTesting.newDto(RuleKey.of(\"php\", \"S002\"))\n      .setSystemTags(ImmutableSet.<String>of()))\n      .setTags(ImmutableSet.of(\"tag1\"));\n    dao.insert(dbSession, RuleTesting.newDto(RuleKey.of(\"javascript\", \"S002\"))\n      .setTags(ImmutableSet.of(\"tag1\", \"tag2\")))\n      .setSystemTags(ImmutableSet.<String>of());\n    dbSession.commit();\n\n    // should not have any facet!\n    RuleQuery query = new RuleQuery();\n    Result result = index.search(query, new QueryOptions().setFacet(false));\n    assertThat(result.getFacets()).isEmpty();\n\n    // Repositories Facet is preset\n    result = index.search(query, new QueryOptions().setFacet(true));\n    assertThat(result.getFacets()).isNotNull();\n    assertThat(result.getFacets()).hasSize(3);\n\n    // Verify the value of a given facet\n    Collection<FacetValue> repoFacets = result.getFacetValues(\"repositories\");\n    assertThat(repoFacets).hasSize(2);\n    assertThat(Iterables.get(repoFacets, 0).getKey()).isEqualTo(\"php\");\n    assertThat(Iterables.get(repoFacets, 0).getValue()).isEqualTo(2);\n    assertThat(Iterables.get(repoFacets, 1).getKey()).isEqualTo(\"javascript\");\n    assertThat(Iterables.get(repoFacets, 1).getValue()).isEqualTo(1);\n\n    // Check that tag facet has both Tags and SystemTags values\n    Collection<FacetValue> tagFacet = result.getFacetValues(\"tags\");\n    assertThat(tagFacet).hasSize(3);\n    assertThat(Iterables.get(tagFacet, 0).getKey()).isEqualTo(\"tag1\");\n    assertThat(Iterables.get(tagFacet, 0).getValue()).isEqualTo(2);\n  }","id":92689,"modified_method":"@Test\n  public void global_facet_on_repositories_and_tags() {\n    dao.insert(dbSession, RuleTesting.newDto(RuleKey.of(\"php\", \"S001\"))\n      .setSystemTags(ImmutableSet.of(\"sysTag\")))\n      .setTags(ImmutableSet.<String>of());\n    dao.insert(dbSession, RuleTesting.newDto(RuleKey.of(\"php\", \"S002\"))\n      .setSystemTags(ImmutableSet.<String>of()))\n      .setTags(ImmutableSet.of(\"tag1\"));\n    dao.insert(dbSession, RuleTesting.newDto(RuleKey.of(\"javascript\", \"S002\"))\n      .setTags(ImmutableSet.of(\"tag1\", \"tag2\")))\n      .setSystemTags(ImmutableSet.<String>of());\n    dbSession.commit();\n\n    // should not have any facet!\n    RuleQuery query = new RuleQuery();\n    Result result = index.search(query, new QueryOptions().setFacet(false));\n    assertThat(result.getFacets()).isEmpty();\n\n    // should not have any facet on non matching query!\n    result = index.search(new RuleQuery().setQueryText(\"aeiou\"), new QueryOptions().setFacet(true));\n    assertThat(result.getFacets()).isEmpty();\n\n    // Repositories Facet is preset\n    result = index.search(query, new QueryOptions().setFacet(true));\n    assertThat(result.getFacets()).isNotNull();\n    assertThat(result.getFacets()).hasSize(3);\n\n    // Verify the value of a given facet\n    Collection<FacetValue> repoFacets = result.getFacetValues(\"repositories\");\n    assertThat(repoFacets).hasSize(2);\n    assertThat(Iterables.get(repoFacets, 0).getKey()).isEqualTo(\"php\");\n    assertThat(Iterables.get(repoFacets, 0).getValue()).isEqualTo(2);\n    assertThat(Iterables.get(repoFacets, 1).getKey()).isEqualTo(\"javascript\");\n    assertThat(Iterables.get(repoFacets, 1).getValue()).isEqualTo(1);\n\n    // Check that tag facet has both Tags and SystemTags values\n    Collection<FacetValue> tagFacet = result.getFacetValues(\"tags\");\n    assertThat(tagFacet).hasSize(3);\n    assertThat(Iterables.get(tagFacet, 0).getKey()).isEqualTo(\"tag1\");\n    assertThat(Iterables.get(tagFacet, 0).getValue()).isEqualTo(2);\n  }","commit_id":"e604855a2fe3effdb814ec019459d420b932b79a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"ClassPathNotation, e.g. gradleApi().\");\n    }","id":92690,"modified_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"ClassPathNotation\").example(\"gradleApi()\");\n    }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"FileCollections, e.g. files('some.jar', 'someOther.jar').\");\n    }","id":92691,"modified_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"FileCollections\").example(\"files('some.jar', 'someOther.jar')\");\n    }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"Maps, e.g. [group: 'org.gradle', name: 'gradle-core', version: '1.0'].\");\n    }","id":92692,"modified_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"Maps\").example(\"[group: 'org.gradle', name: 'gradle-core', version: '1.0']\");\n    }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"Projects, e.g. project(':some:project:path').\");\n    }","id":92693,"modified_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"Projects\").example(\"project(':some:project:path')\");\n    }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"Non-empty String or CharSequence value, e.g. 'some-lib' or 'org.libs:some-lib'.\");\n    }","id":92694,"modified_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"Non-empty String or CharSequence value\").example(\"'some-lib' or 'org.libs:some-lib'\");\n    }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"String or CharSequence values, e.g. 'org.gradle:gradle-core:1.0'.\");\n    }","id":92695,"modified_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"String or CharSequence values\").example(\"'org.gradle:gradle-core:1.0'\");\n    }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"Maps with 'group' and/or 'module', e.g. [group: 'com.google.collections', module: 'google-collections'].\");\n    }","id":92696,"modified_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"Maps with 'group' and/or 'module'\").example(\"[group: 'com.google.collections', module: 'google-collections']\");\n    }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"A String or CharSequence path, e.g 'src/main/java' or '/usr/include'\");\n        visitor.candidate(\"A String or CharSequence URI, e.g 'file:/usr/include'\");\n        visitor.candidate(\"A File instance.\");\n        visitor.candidate(\"A URI or URL instance.\");\n    }","id":92697,"modified_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"A String or CharSequence path\").example(\"'src/main/java' or '/usr/include'\");\n        visitor.candidate(\"A String or CharSequence URI\").example(\"'file:/usr/include'\");\n        visitor.candidate(\"A File instance.\");\n        visitor.candidate(\"A URI or URL instance.\");\n    }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Maps containing a 'source' entry, e.g. [source: '/path/to/file', extension: 'zip'].\");\n        }","id":92698,"modified_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Maps containing a 'source' entry\").example(\"[source: '/path/to/file', extension: 'zip']\");\n        }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Instances of AbstractArchiveTask e.g. jar\");\n        }","id":92699,"modified_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Instances of AbstractArchiveTask\").example(\"jar\");\n        }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Maps containing a 'source' entry, e.g. [source: '/path/to/file', extension: 'zip'].\");\n        }","id":92700,"modified_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Maps containing a 'source' entry\").example(\"[source: '/path/to/file', extension: 'zip']\");\n        }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"String describing the module in 'group:name' format, for example: 'org.gradle:gradle-core'.\");\n    }","id":92701,"modified_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"String describing the module in 'group:name' format\").example(\"'org.gradle:gradle-core'.\");\n    }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Maps, e.g. [group: 'org.gradle', name:'gradle-core', version: '1.0'].\");\n        }","id":92702,"modified_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Maps\").example(\"[group: 'org.gradle', name:'gradle-core', version: '1.0']\");\n        }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"String or CharSequence values, e.g. 'org.gradle:gradle-core:1.0'.\");\n        }","id":92703,"modified_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"String or CharSequence values\").example(\"'org.gradle:gradle-core:1.0'\");\n        }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Map with mandatory 'library' and optional 'project' and 'linkage' keys, e.g. [project: ':someProj', library: 'mylib', linkage: 'static']\");\n        }","id":92704,"modified_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Map with mandatory 'library' and optional 'project' and 'linkage' keys\").example(\"[project: ':someProj', library: 'mylib', linkage: 'static']\");\n        }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"String or CharSequence instances e.g. 'some/path'\");\n        visitor.candidate(\"Boolean values e.g. true, Boolean.TRUE\");\n        visitor.candidate(\"Number values e.g. 42, 3.14\");\n        visitor.candidate(\"A File instance\");\n        visitor.candidate(\"A Closure that returns any supported value.\");\n        visitor.candidate(\"A Callable that returns any supported value.\");\n    }","id":92705,"modified_method":"@Override\n    public void describe(DiagnosticsVisitor visitor) {\n        visitor.candidate(\"String or CharSequence instances\").example(\"'some/path'\");\n        visitor.candidate(\"Boolean values\").example(\"true\").example(\"Boolean.TRUE\");\n        visitor.candidate(\"Number values\").example(\"42\").example(\"3.14\");\n        visitor.candidate(\"A File instance\");\n        visitor.candidate(\"A Closure that returns any supported value.\");\n        visitor.candidate(\"A Callable that returns any supported value.\");\n    }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Map defining the platform versions, e.g. [play: '2.3.7', scala:'2.11.4', java: '1.6'].\");\n        }","id":92706,"modified_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Map defining the platform versions\").example(\"[play: '2.3.7', scala:'2.11.4', java: '1.6']\");\n        }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"The name of a Play platform, e.g. 'play-2.3.7'.\");\n        }","id":92707,"modified_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"The name of a Play platform\").example(\"'play-2.3.7'.\");\n        }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Map with mandatory 'path' and optional 'configuration' key, e.g. [path: ':someProj', configuration: 'someConf']\");\n        }","id":92708,"modified_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Map with mandatory 'path' and optional 'configuration' key\").example(\"[path: ':someProj', configuration: 'someConf']\");\n        }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Instances of AbstractArchiveTask, e.g. jar.\");\n        }","id":92709,"modified_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"Instances of AbstractArchiveTask\").example(\"jar.\");\n        }","commit_id":"db3f8a31a30eb1c2e42e6722eabf7b0c9be7cddc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected void writeAdditionalKeyboardShortcuts() throws IOException {\n        writeKeyboardShortcut('p', \"index.html\");\n        writeKeyboardShortcut('a', \"#attributes\");\n        writeKeyboardShortcut('m', \"#methods\");\n        writeKeyboardShortcut('c', \"#classes\");\n        writeKeyboardShortcut('i', \"#interfaces\");\n    }","id":92710,"modified_method":"@Override\n    protected void writeAdditionalKeyboardShortcuts() throws IOException {\n        writeKeyboardShortcut('p', \"index.html\");\n        if (!attributes.isEmpty()) {\n            writeKeyboardShortcut('a', \"#attributes\");\n        } \n        if (!methods.isEmpty()) {\n            writeKeyboardShortcut('m', \"#methods\");\n        }\n        if (!classes.isEmpty()) {\n            writeKeyboardShortcut('c', \"#classes\");\n        }\n        if (!interfaces.isEmpty()) {\n            writeKeyboardShortcut('i', \"#interfaces\");\n        }\n    }","commit_id":"85dcf49b370b0293dda1761c7ebebee915b79933","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public int hashCode() {\n        int result;\n        long temp;\n        result = a1 != null ? Arrays.hashCode(a1) : 0;\n        result = 31 * result + (a2 != null ? Arrays.deepHashCode(a2) : 0);\n        result = 31 * result + (a3 != null ? Arrays.hashCode(a3) : 0);\n        result = 31 * result + (a4 != null ? Arrays.deepHashCode(a4) : 0);\n        result = 31 * result + (a5 != null ? Arrays.hashCode(a5) : 0);\n        result = 31 * result + (a6 != null ? Arrays.deepHashCode(a6) : 0);\n        result = 31 * result + (int) a7;\n        result = 31 * result + (int) a8;\n        result = 31 * result + a9;\n        result = 31 * result + (int) (a10 ^ (a10 >>> 32));\n        result = 31 * result + (a11 != +0.0f ? Float.floatToIntBits(a11) : 0);\n        temp = Double.doubleToLongBits(a12);\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        result = 31 * result + (a13 != null ? a13.hashCode() : 0);\n        result = 31 * result + (a14 != null ? a14.hashCode() : 0);\n        return result;\n    }","id":92711,"modified_method":"@Override\n    public int hashCode() {\n        int result;\n        long temp;\n        result = Arrays.hashCode(a1);\n        result = 31 * result + Arrays.deepHashCode(a2);\n        result = 31 * result + Arrays.hashCode(a3);\n        result = 31 * result + Arrays.deepHashCode(a4);\n        result = 31 * result + Arrays.hashCode(a5);\n        result = 31 * result + Arrays.deepHashCode(a6);\n        result = 31 * result + (int) a7;\n        result = 31 * result + (int) a8;\n        result = 31 * result + a9;\n        result = 31 * result + (int) (a10 ^ (a10 >>> 32));\n        result = 31 * result + (a11 != +0.0f ? Float.floatToIntBits(a11) : 0);\n        temp = Double.doubleToLongBits(a12);\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        result = 31 * result + (a13 != null ? a13.hashCode() : 0);\n        result = 31 * result + (a14 != null ? a14.hashCode() : 0);\n        return result;\n    }","commit_id":"1b70e296eb13a1109a8560347f6a4e7acf9151eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public int hashCode() {\n        int result;\n        long temp;\n        result = getA1() != null ? Arrays.hashCode(getA1()) : 0;\n        result = 31 * result + (getA2() != null ? Arrays.deepHashCode(getA2()) : 0);\n        result = 31 * result + (getA3() != null ? Arrays.hashCode(getA3()) : 0);\n        result = 31 * result + (getA4() != null ? Arrays.deepHashCode(getA4()) : 0);\n        result = 31 * result + (getA5() != null ? Arrays.hashCode(getA5()) : 0);\n        result = 31 * result + (getA6() != null ? Arrays.deepHashCode(getA6()) : 0);\n        result = 31 * result + (int) getA7();\n        result = 31 * result + (int) getA8();\n        result = 31 * result + getA9();\n        result = 31 * result + (int) (getA10() ^ (getA10() >>> 32));\n        result = 31 * result + (getA11() != +0.0f ? Float.floatToIntBits(getA11()) : 0);\n        temp = Double.doubleToLongBits(getA12());\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        result = 31 * result + (a13 != null ? a13.hashCode() : 0);\n        result = 31 * result + (a14 != null ? a14.hashCode() : 0);\n        return result;\n    }","id":92712,"modified_method":"@Override\n    public int hashCode() {\n        int result;\n        long temp;\n        result = Arrays.hashCode(getA1());\n        result = 31 * result + Arrays.deepHashCode(getA2());\n        result = 31 * result + Arrays.hashCode(getA3());\n        result = 31 * result + Arrays.deepHashCode(getA4());\n        result = 31 * result + Arrays.hashCode(getA5());\n        result = 31 * result + Arrays.deepHashCode(getA6());\n        result = 31 * result + (int) getA7();\n        result = 31 * result + (int) getA8();\n        result = 31 * result + getA9();\n        result = 31 * result + (int) (getA10() ^ (getA10() >>> 32));\n        result = 31 * result + (getA11() != +0.0f ? Float.floatToIntBits(getA11()) : 0);\n        temp = Double.doubleToLongBits(getA12());\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        result = 31 * result + (a13 != null ? a13.hashCode() : 0);\n        result = 31 * result + (a14 != null ? a14.hashCode() : 0);\n        return result;\n    }","commit_id":"1b70e296eb13a1109a8560347f6a4e7acf9151eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int hashCode() {\n        int result = myOs != null ? Arrays.hashCode(myOs) : 0;\n        result = 31 * result + (myIIs != null ? Arrays.deepHashCode(myIIs) : 0);\n        result = 31 * result + (myIs != null ? Arrays.hashCode(myIs) : 0);\n        return result;\n    }","id":92713,"modified_method":"public int hashCode() {\n        int result = Arrays.hashCode(myOs);\n        result = 31 * result + Arrays.deepHashCode(myIIs);\n        result = 31 * result + Arrays.hashCode(myIs);\n        return result;\n    }","commit_id":"1b70e296eb13a1109a8560347f6a4e7acf9151eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IvyArtifact addArtifact(Object source) {\n        IvyArtifact artifact = ivyArtifactParser.parseNotation(source);\n        add(artifact);\n        return artifact;\n    }","id":92714,"modified_method":"public IvyArtifact artifact(Object source) {\n        IvyArtifact artifact = ivyArtifactParser.parseNotation(source);\n        add(artifact);\n        return artifact;\n    }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"public String getDisplayName() {\n            return \"Ivy artifacts\";\n        }","id":92715,"modified_method":"public String getDisplayName() {\n            return String.format(\"artifacts for \" + configurationName + \" configuration\");\n        }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"public IvyArtifact addArtifact(Object source, Action<? super IvyArtifact> config) {\n        IvyArtifact artifact = addArtifact(source);\n        config.execute(artifact);\n        return artifact;\n    }","id":92716,"modified_method":"public IvyArtifact artifact(Object source, Action<? super IvyArtifact> config) {\n        IvyArtifact artifact = artifact(source);\n        config.execute(artifact);\n        return artifact;\n    }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultIvyArtifactSet(NotationParser<IvyArtifact> ivyArtifactParser) {\n        super(IvyArtifact.class);\n        this.ivyArtifactParser = ivyArtifactParser;\n    }","id":92717,"modified_method":"public DefaultIvyArtifactSet(String configurationName, NotationParser<IvyArtifact> ivyArtifactParser) {\n        super(IvyArtifact.class);\n        this.configurationName = configurationName;\n        this.ivyArtifactParser = ivyArtifactParser;\n    }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultIvyConfiguration(String name, NotationParser<IvyArtifact> ivyArtifactNotationParser) {\n        this.name = name;\n        this.artifacts = new DefaultIvyArtifactSet(ivyArtifactNotationParser);\n    }","id":92718,"modified_method":"public DefaultIvyConfiguration(String name, NotationParser<IvyArtifact> ivyArtifactNotationParser, Instantiator instantiator) {\n        this.name = name;\n        this.artifacts = instantiator.newInstance(DefaultIvyArtifactSet.class, name, ivyArtifactNotationParser);\n    }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"public IvyArtifact artifact(Object source) {\n        return artifacts.addArtifact(source);\n    }","id":92719,"modified_method":"public IvyArtifact artifact(Object source) {\n        return artifacts.artifact(source);\n    }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"public IvyArtifact artifact(Object source, Action<? super IvyArtifact> config) {\n        return artifacts.addArtifact(source, config);\n    }","id":92720,"modified_method":"public IvyArtifact artifact(Object source, Action<? super IvyArtifact> config) {\n        return artifacts.artifact(source, config);\n    }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected IvyConfiguration doCreate(String name) {\n        return getInstantiator().newInstance(DefaultIvyConfiguration.class, name, ivyArtifactNotationParser);\n    }","id":92721,"modified_method":"@Override\n    protected IvyConfiguration doCreate(String name) {\n        return getInstantiator().newInstance(DefaultIvyConfiguration.class, name, ivyArtifactNotationParser, getInstantiator());\n    }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"public IvyArtifact parseNotation(Object notation) throws UnsupportedNotationException {\n            File file = toProjectFile(notation);\n            return parseFile(file);\n        }","id":92722,"modified_method":"public IvyArtifact parseNotation(Object notation) throws UnsupportedNotationException {\n            File file = fileResolver.resolve(notation);\n            return parseFile(file);\n        }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"public IvyArtifactNotationParser(Instantiator instantiator, String version, Project project) {\n        this.instantiator = instantiator;\n        this.version = version;\n        FileNotationParser fileNotationParser = new FileNotationParser(project);\n        NotationParserBuilder<IvyArtifact> parserBuilder = new NotationParserBuilder<IvyArtifact>()\n                .resultingType(IvyArtifact.class)\n                .parser(new ArchiveTaskNotationParser())\n                .parser(new PublishArtifactNotationParser())\n                .parser(new FileMapNotationParser(fileNotationParser))\n                .parser(fileNotationParser);\n        delegate = parserBuilder.toComposite();\n    }","id":92723,"modified_method":"public IvyArtifactNotationParser(Instantiator instantiator, String version, FileResolver fileResolver) {\n        this.instantiator = instantiator;\n        this.version = version;\n        FileNotationParser fileNotationParser = new FileNotationParser(fileResolver);\n        ArchiveTaskNotationParser archiveTaskNotationParser = new ArchiveTaskNotationParser();\n        PublishArtifactNotationParser publishArtifactNotationParser = new PublishArtifactNotationParser();\n\n        NotationParser<IvyArtifact> sourceNotationParser = new NotationParserBuilder<IvyArtifact>()\n                .resultingType(IvyArtifact.class)\n                .parser(archiveTaskNotationParser)\n                .parser(publishArtifactNotationParser)\n                .parser(fileNotationParser)\n                .toComposite();\n\n        IvyArtifactMapNotationParser ivyArtifactMapNotationParser = new IvyArtifactMapNotationParser(sourceNotationParser, fileNotationParser);\n\n        NotationParserBuilder<IvyArtifact> parserBuilder = new NotationParserBuilder<IvyArtifact>()\n                .resultingType(IvyArtifact.class)\n                .parser(archiveTaskNotationParser)\n                .parser(publishArtifactNotationParser)\n                .parser(ivyArtifactMapNotationParser)\n                .parser(fileNotationParser);\n\n        delegate = parserBuilder.toComposite();\n    }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"private File toProjectFile(Object notation) {\n            try {\n                return project.file(notation);\n            } catch (Exception e) {\n                throw new UnsupportedNotationException(notation);\n            }\n        }","id":92724,"modified_method":"private FileNotationParser(FileResolver fileResolver) {\n            this.fileResolver = fileResolver;\n        }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"public Publication create(String name) {\n            Module module = dependencyMetaDataProvider.getModule();\n            NotationParser<IvyArtifact> notationParser = new IvyArtifactNotationParser(instantiator, module.getVersion(), project);\n            return instantiator.newInstance(\n                    DefaultIvyPublication.class,\n                    name, instantiator, module, notationParser\n            );\n\n        }","id":92725,"modified_method":"public Publication create(String name) {\n            Module module = dependencyMetaDataProvider.getModule();\n            NotationParser<IvyArtifact> notationParser = new IvyArtifactNotationParser(instantiator, module.getVersion(), fileResolver);\n            return instantiator.newInstance(\n                    DefaultIvyPublication.class,\n                    name, instantiator, module, notationParser\n            );\n\n        }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"private IvyPublicationFactory(DependencyMetaDataProvider dependencyMetaDataProvider, Instantiator instantiator, Project project) {\n            this.dependencyMetaDataProvider = dependencyMetaDataProvider;\n            this.instantiator = instantiator;\n            this.project = project;\n        }","id":92726,"modified_method":"private IvyPublicationFactory(DependencyMetaDataProvider dependencyMetaDataProvider, Instantiator instantiator, FileResolver fileResolver) {\n            this.dependencyMetaDataProvider = dependencyMetaDataProvider;\n            this.instantiator = instantiator;\n            this.fileResolver = fileResolver;\n        }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(final Project project) {\n        project.getPlugins().apply(PublishingPlugin.class);\n\n        // Create the default publication\n        final PublishingExtension extension = project.getExtensions().getByType(PublishingExtension.class);\n\n        final PublicationContainerInternal publicationContainer = (PublicationContainerInternal) extension.getPublications();\n        publicationContainer.registerFactory(IvyPublication.class, new IvyPublicationFactory(dependencyMetaDataProvider, instantiator, project));\n\n        TaskContainer tasks = project.getTasks();\n\n        // Create generate descriptor tasks\n        IvyPublicationDynamicDescriptorGenerationTaskCreator descriptorGenerationTaskCreator = new IvyPublicationDynamicDescriptorGenerationTaskCreator(project);\n        descriptorGenerationTaskCreator.monitor(extension.getPublications());\n\n        // Create publish tasks automatically for any Ivy publication and repository combinations\n        Task publishLifecycleTask = tasks.getByName(PublishingPlugin.PUBLISH_LIFECYCLE_TASK_NAME);\n        IvyPublishDynamicTaskCreator publishTaskCreator = new IvyPublishDynamicTaskCreator(tasks, publishLifecycleTask);\n        publishTaskCreator.monitor(extension.getPublications(), extension.getRepositories());\n    }","id":92727,"modified_method":"public void apply(final Project project) {\n        project.getPlugins().apply(PublishingPlugin.class);\n\n        // Create the default publication\n        final PublishingExtension extension = project.getExtensions().getByType(PublishingExtension.class);\n\n        final PublicationContainerInternal publicationContainer = (PublicationContainerInternal) extension.getPublications();\n        publicationContainer.registerFactory(IvyPublication.class, new IvyPublicationFactory(dependencyMetaDataProvider, instantiator, ((ProjectInternal) project).getFileResolver()));\n\n        TaskContainer tasks = project.getTasks();\n\n        // Create generate descriptor tasks\n        IvyPublicationDynamicDescriptorGenerationTaskCreator descriptorGenerationTaskCreator = new IvyPublicationDynamicDescriptorGenerationTaskCreator(project);\n        descriptorGenerationTaskCreator.monitor(extension.getPublications());\n\n        // Create publish tasks automatically for any Ivy publication and repository combinations\n        Task publishLifecycleTask = tasks.getByName(PublishingPlugin.PUBLISH_LIFECYCLE_TASK_NAME);\n        IvyPublishDynamicTaskCreator publishTaskCreator = new IvyPublishDynamicTaskCreator(tasks, publishLifecycleTask);\n        publishTaskCreator.monitor(extension.getPublications(), extension.getRepositories());\n    }","commit_id":"30921d44990631216a13949544d2487bf0e32d8c","url":"https://github.com/gradle/gradle"},{"original_method":"public MavenArtifactNotationParser(Instantiator instantiator, Module module, Project project) {\n        this.instantiator = instantiator;\n        this.module = module;\n        FileNotationParser fileNotationParser = new FileNotationParser(project);\n        NotationParserBuilder<MavenArtifact> parserBuilder = new NotationParserBuilder<MavenArtifact>()\n                .resultingType(MavenArtifact.class)\n                .parser(new ArchiveTaskNotationParser())\n                .parser(new PublishArtifactNotationParser())\n                .parser(new FileMapNotationParser(fileNotationParser))\n                .parser(fileNotationParser);\n        delegate = parserBuilder.toComposite();\n    }","id":92728,"modified_method":"public MavenArtifactNotationParser(Instantiator instantiator, Module module, Project project) {\n        this.instantiator = instantiator;\n        this.module = module;\n        FileNotationParser fileNotationParser = new FileNotationParser(project);\n        ArchiveTaskNotationParser archiveTaskNotationParser = new ArchiveTaskNotationParser();\n        PublishArtifactNotationParser publishArtifactNotationParser = new PublishArtifactNotationParser();\n\n        NotationParser<MavenArtifact> sourceNotationParser = new NotationParserBuilder<MavenArtifact>()\n                .resultingType(MavenArtifact.class)\n                .parser(archiveTaskNotationParser)\n                .parser(publishArtifactNotationParser)\n                .parser(fileNotationParser)\n                .toComposite();\n\n        MavenArtifactMapNotationParser mavenArtifactMapNotationParser = new MavenArtifactMapNotationParser(sourceNotationParser, fileNotationParser);\n\n        NotationParserBuilder<MavenArtifact> parserBuilder = new NotationParserBuilder<MavenArtifact>()\n                .resultingType(MavenArtifact.class)\n                .parser(archiveTaskNotationParser)\n                .parser(publishArtifactNotationParser)\n                .parser(mavenArtifactMapNotationParser)\n                .parser(fileNotationParser);\n\n        delegate = parserBuilder.toComposite();\n    }","commit_id":"e9c5b01f8e81d6c89564b08df5a0b4ea99c80ba4","url":"https://github.com/gradle/gradle"},{"original_method":"void addOnPeriod(Issue issue, int periodIndex) {\n      array[periodIndex].add(issue);\n    }","id":92729,"modified_method":"void addOnPeriod(DefaultIssue issue, int periodIndex) {\n      array[periodIndex].add(issue);\n    }","commit_id":"08f6ba94574e741aa85acf5cca0b1b612f28c27e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void add(Counter counter) {\n      unresolved += counter.unresolved;\n      open += counter.open;\n      reopened += counter.reopened;\n      confirmed += counter.confirmed;\n      falsePositives += counter.falsePositives;\n      severityBag.addAll(counter.severityBag);\n    }","id":92730,"modified_method":"void add(Counter counter) {\n      unresolved += counter.unresolved;\n      open += counter.open;\n      reopened += counter.reopened;\n      confirmed += counter.confirmed;\n      falsePositives += counter.falsePositives;\n      severityBag.addAll(counter.severityBag);\n      typeBag.addAll(counter.typeBag);\n    }","commit_id":"08f6ba94574e741aa85acf5cca0b1b612f28c27e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void addMeasuresByPeriod(Component component) {\n    if (!periodsHolder.getPeriods().isEmpty()) {\n      Double[] unresolvedVariations = new Double[PeriodsHolder.MAX_NUMBER_OF_PERIODS];\n      for (Period period : periodsHolder.getPeriods()) {\n        unresolvedVariations[period.getIndex() - 1] = new Double(currentCounters.counterForPeriod(period.getIndex()).unresolved);\n      }\n      measureRepository.add(component, metricRepository.getByKey(NEW_VIOLATIONS_KEY), Measure.newMeasureBuilder()\n        .setVariations(new MeasureVariations(unresolvedVariations))\n        .createNoValue());\n\n      for (Map.Entry<String, String> entry : SEVERITY_TO_NEW_METRIC_KEY.entrySet()) {\n        String severity = entry.getKey();\n        String metricKey = entry.getValue();\n        Double[] variations = new Double[PeriodsHolder.MAX_NUMBER_OF_PERIODS];\n        for (Period period : periodsHolder.getPeriods()) {\n          Multiset<String> bag = currentCounters.counterForPeriod(period.getIndex()).severityBag;\n          variations[period.getIndex() - 1] = new Double(bag.count(severity));\n        }\n        Metric metric = metricRepository.getByKey(metricKey);\n        measureRepository.add(component, metric, Measure.newMeasureBuilder()\n          .setVariations(new MeasureVariations(variations))\n          .createNoValue());\n      }\n    }\n  }","id":92731,"modified_method":"private void addMeasuresByPeriod(Component component) {\n    if (!periodsHolder.getPeriods().isEmpty()) {\n      Double[] unresolvedVariations = new Double[PeriodsHolder.MAX_NUMBER_OF_PERIODS];\n      for (Period period : periodsHolder.getPeriods()) {\n        unresolvedVariations[period.getIndex() - 1] = new Double(currentCounters.counterForPeriod(period.getIndex()).unresolved);\n      }\n      measureRepository.add(component, metricRepository.getByKey(NEW_VIOLATIONS_KEY), Measure.newMeasureBuilder()\n        .setVariations(new MeasureVariations(unresolvedVariations))\n        .createNoValue());\n\n      for (Map.Entry<String, String> entry : SEVERITY_TO_NEW_METRIC_KEY.entrySet()) {\n        String severity = entry.getKey();\n        String metricKey = entry.getValue();\n        Double[] variations = new Double[PeriodsHolder.MAX_NUMBER_OF_PERIODS];\n        for (Period period : periodsHolder.getPeriods()) {\n          Multiset<String> bag = currentCounters.counterForPeriod(period.getIndex()).severityBag;\n          variations[period.getIndex() - 1] = (double) bag.count(severity);\n        }\n        Metric metric = metricRepository.getByKey(metricKey);\n        measureRepository.add(component, metric, Measure.newMeasureBuilder()\n          .setVariations(new MeasureVariations(variations))\n          .createNoValue());\n      }\n\n      // waiting for Java 8 lambda in order to factor this loop with the previous one\n      // (see call currentCounters.counterForPeriod(period.getIndex()).xxx with xxx as severityBag or typeBag)\n      for (Map.Entry<IssueType, String> entry : TYPE_TO_NEW_METRIC_KEY.entrySet()) {\n        IssueType type = entry.getKey();\n        String metricKey = entry.getValue();\n        Double[] variations = new Double[PeriodsHolder.MAX_NUMBER_OF_PERIODS];\n        for (Period period : periodsHolder.getPeriods()) {\n          Multiset<IssueType> bag = currentCounters.counterForPeriod(period.getIndex()).typeBag;\n          variations[period.getIndex() - 1] = (double) bag.count(type);\n        }\n        Metric metric = metricRepository.getByKey(metricKey);\n        measureRepository.add(component, metric, Measure.newMeasureBuilder()\n          .setVariations(new MeasureVariations(variations))\n          .createNoValue());\n      }\n    }\n  }","commit_id":"08f6ba94574e741aa85acf5cca0b1b612f28c27e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void add(Issue issue) {\n      if (issue.resolution() == null) {\n        unresolved++;\n        severityBag.add(issue.severity());\n      } else if (Issue.RESOLUTION_FALSE_POSITIVE.equals(issue.resolution())) {\n        falsePositives++;\n      }\n      switch (issue.status()) {\n        case STATUS_OPEN:\n          open++;\n          break;\n        case STATUS_REOPENED:\n          reopened++;\n          break;\n        case STATUS_CONFIRMED:\n          confirmed++;\n          break;\n        default:\n          // Other statuses are ignored\n      }\n    }","id":92732,"modified_method":"void add(DefaultIssue issue) {\n      if (issue.resolution() == null) {\n        unresolved++;\n        typeBag.add(issue.type());\n        severityBag.add(issue.severity());\n      } else if (Issue.RESOLUTION_FALSE_POSITIVE.equals(issue.resolution())) {\n        falsePositives++;\n      }\n      switch (issue.status()) {\n        case STATUS_OPEN:\n          open++;\n          break;\n        case STATUS_REOPENED:\n          reopened++;\n          break;\n        case STATUS_CONFIRMED:\n          confirmed++;\n          break;\n        default:\n          // Other statuses are ignored\n      }\n    }","commit_id":"08f6ba94574e741aa85acf5cca0b1b612f28c27e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void add(Issue issue) {\n      array[0].add(issue);\n    }","id":92733,"modified_method":"void add(DefaultIssue issue) {\n      array[0].add(issue);\n    }","commit_id":"08f6ba94574e741aa85acf5cca0b1b612f28c27e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void afterComponent(Component component) {\n    addMeasuresByStatus(component);\n    addMeasuresBySeverity(component);\n    addMeasuresByPeriod(component);\n    currentCounters = null;\n  }","id":92734,"modified_method":"@Override\n  public void afterComponent(Component component) {\n    addMeasuresBySeverity(component);\n    addMeasuresByStatus(component);\n    addMeasuresByType(component);\n    addMeasuresByPeriod(component);\n    currentCounters = null;\n  }","commit_id":"08f6ba94574e741aa85acf5cca0b1b612f28c27e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void count_new_issues() {\n    Period period = newPeriod(3, 1500000000000L);\n    periodsHolder.setPeriods(period);\n\n    underTest.beforeComponent(FILE1);\n    // created before -> existing issues\n    underTest.onIssue(FILE1, createIssueAt(null, STATUS_OPEN, BLOCKER, period.getSnapshotDate() - 1000000L));\n    // created during the first analysis starting the period -> existing issues\n    underTest.onIssue(FILE1, createIssueAt(null, STATUS_OPEN, BLOCKER, period.getSnapshotDate()));\n    // created after -> new issues\n    underTest.onIssue(FILE1, createIssueAt(null, STATUS_OPEN, CRITICAL, period.getSnapshotDate() + 100000L));\n    underTest.onIssue(FILE1, createIssueAt(RESOLUTION_FIXED, STATUS_CLOSED, MAJOR, period.getSnapshotDate() + 200000L));\n    underTest.afterComponent(FILE1);\n\n    underTest.beforeComponent(FILE2);\n    underTest.afterComponent(FILE2);\n\n    underTest.beforeComponent(PROJECT);\n    underTest.afterComponent(PROJECT);\n\n    assertVariation(FILE1, NEW_ISSUES_METRIC, period.getIndex(), 1);\n    assertVariation(FILE1, NEW_CRITICAL_ISSUES_METRIC, period.getIndex(), 1);\n    assertVariation(FILE1, NEW_BLOCKER_ISSUES_METRIC, period.getIndex(), 0);\n    assertVariation(FILE1, NEW_MAJOR_ISSUES_METRIC, period.getIndex(), 0);\n\n    assertVariation(PROJECT, NEW_ISSUES_METRIC, period.getIndex(), 1);\n    assertVariation(PROJECT, NEW_CRITICAL_ISSUES_METRIC, period.getIndex(), 1);\n    assertVariation(PROJECT, NEW_BLOCKER_ISSUES_METRIC, period.getIndex(), 0);\n    assertVariation(PROJECT, NEW_MAJOR_ISSUES_METRIC, period.getIndex(), 0);\n  }","id":92735,"modified_method":"@Test\n  public void count_new_issues() {\n    Period period = newPeriod(3, 1500000000000L);\n    periodsHolder.setPeriods(period);\n\n    underTest.beforeComponent(FILE1);\n    // created before -> existing issues (so ignored)\n    underTest.onIssue(FILE1, createIssueAt(null, STATUS_OPEN, BLOCKER, period.getSnapshotDate() - 1000000L).setType(IssueType.CODE_SMELL));\n    // created during the first analysis starting the period -> existing issues (so ignored)\n    underTest.onIssue(FILE1, createIssueAt(null, STATUS_OPEN, BLOCKER, period.getSnapshotDate()).setType(IssueType.BUG));\n    // created after -> 3 new issues but 1 is closed\n    underTest.onIssue(FILE1, createIssueAt(null, STATUS_OPEN, CRITICAL, period.getSnapshotDate() + 100000L).setType(IssueType.CODE_SMELL));\n    underTest.onIssue(FILE1, createIssueAt(null, STATUS_OPEN, CRITICAL, period.getSnapshotDate() + 100000L).setType(IssueType.BUG));\n    underTest.onIssue(FILE1, createIssueAt(RESOLUTION_FIXED, STATUS_CLOSED, MAJOR, period.getSnapshotDate() + 200000L).setType(IssueType.BUG));\n    underTest.afterComponent(FILE1);\n\n    underTest.beforeComponent(FILE2);\n    underTest.afterComponent(FILE2);\n\n    underTest.beforeComponent(PROJECT);\n    underTest.afterComponent(PROJECT);\n\n    assertVariation(FILE1, NEW_ISSUES_METRIC, period.getIndex(), 2);\n    assertVariation(FILE1, NEW_CRITICAL_ISSUES_METRIC, period.getIndex(), 2);\n    assertVariation(FILE1, NEW_BLOCKER_ISSUES_METRIC, period.getIndex(), 0);\n    assertVariation(FILE1, NEW_MAJOR_ISSUES_METRIC, period.getIndex(), 0);\n    assertVariation(FILE1, NEW_CODE_SMELLS_METRIC, period.getIndex(), 1);\n    assertVariation(FILE1, NEW_BUGS_METRIC, period.getIndex(), 1);\n    assertVariation(FILE1, NEW_VULNERABILITIES_METRIC, period.getIndex(), 0);\n\n    assertVariation(PROJECT, NEW_ISSUES_METRIC, period.getIndex(), 2);\n    assertVariation(PROJECT, NEW_CRITICAL_ISSUES_METRIC, period.getIndex(), 2);\n    assertVariation(PROJECT, NEW_BLOCKER_ISSUES_METRIC, period.getIndex(), 0);\n    assertVariation(PROJECT, NEW_MAJOR_ISSUES_METRIC, period.getIndex(), 0);\n    assertVariation(PROJECT, NEW_CODE_SMELLS_METRIC, period.getIndex(), 1);\n    assertVariation(PROJECT, NEW_BUGS_METRIC, period.getIndex(), 1);\n    assertVariation(PROJECT, NEW_VULNERABILITIES_METRIC, period.getIndex(), 0);\n  }","commit_id":"08f6ba94574e741aa85acf5cca0b1b612f28c27e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static DefaultIssue createIssueAt(@Nullable String resolution, String status, String severity, long creationDate) {\n    return new DefaultIssue()\n      .setResolution(resolution).setStatus(status)\n      .setSeverity(severity).setRuleKey(RuleTesting.XOO_X1)\n      .setCreationDate(new Date(creationDate));\n  }","id":92736,"modified_method":"private static DefaultIssue createIssueAt(@Nullable String resolution, String status, String severity, long creationDate) {\n    return new DefaultIssue()\n      .setResolution(resolution).setStatus(status)\n      .setSeverity(severity).setRuleKey(RuleTesting.XOO_X1)\n      .setType(IssueType.CODE_SMELL)\n      .setCreationDate(new Date(creationDate));\n  }","commit_id":"08f6ba94574e741aa85acf5cca0b1b612f28c27e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static DefaultIssue createIssue(@Nullable String resolution, String status, String severity) {\n    return new DefaultIssue()\n      .setResolution(resolution).setStatus(status)\n      .setSeverity(severity).setRuleKey(RuleTesting.XOO_X1)\n      .setCreationDate(new Date());\n  }","id":92737,"modified_method":"private static DefaultIssue createIssue(@Nullable String resolution, String status, String severity) {\n    return new DefaultIssue()\n      .setResolution(resolution).setStatus(status)\n      .setSeverity(severity).setRuleKey(RuleTesting.XOO_X1)\n      .setType(IssueType.CODE_SMELL)\n      .setCreationDate(new Date());\n  }","commit_id":"08f6ba94574e741aa85acf5cca0b1b612f28c27e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void test_evolution_of_number_of_rows_when_scanning_two_times_the_same_project() {\n    Date today = new Date();\n    Date yesterday = DateUtils.addDays(today, -1);\n\n    scan(PROJECT_SAMPLE_PATH, DateFormatUtils.ISO_DATE_FORMAT.format(yesterday));\n\n    // count components\n    collector.checkThat(\"Wrong number of projects\", count(\"projects where qualifier in ('TRK','BRC')\"), equalTo(7));\n    collector.checkThat(\"Wrong number of directories\", count(\"projects where qualifier in ('DIR')\"), equalTo(4));\n    collector.checkThat(\"Wrong number of files\", count(\"projects where qualifier in ('FIL')\"), equalTo(4));\n    collector.checkThat(\"Wrong number of unit test files\", count(\"projects where qualifier in ('UTS')\"), equalTo(0));\n\n    int measuresOnTrk = 37;\n    int measuresOnBrc = 174;\n    int measuresOnDir = 109;\n    int measuresOnFil = 61;\n\n    // count measures \n    assertMeasuresCountForQualifier(\"TRK\", measuresOnTrk);\n    assertMeasuresCountForQualifier(\"BRC\", measuresOnBrc);\n    assertMeasuresCountForQualifier(\"DIR\", measuresOnDir);\n    assertMeasuresCountForQualifier(\"FIL\", measuresOnFil);\n\n    // No new_* metrics measure should be recorded the first time\n    collector.checkThat(\n      \"Wrong number of measure of new_ metrics\",\n      count(\"project_measures, metrics where metrics.id = project_measures.metric_id and metrics.name like 'new_%'\"),\n      equalTo(0));\n\n    int expectedMeasures = measuresOnTrk + measuresOnBrc + measuresOnDir + measuresOnFil;\n    collector.checkThat(\"Wrong number of measures\", count(\"project_measures\"), equalTo(expectedMeasures));\n    collector.checkThat(\"Wrong number of measure data\", count(\"project_measures where measure_data is not null\"), equalTo(0));\n\n    // count other tables that are constant between 2 scans\n    int expectedIssues = 52;\n\n    collector.checkThat(\"Wrong number of issues\", count(\"issues\"), equalTo(expectedIssues));\n\n    // must be a different date, else a single snapshot is kept per day\n    scan(PROJECT_SAMPLE_PATH, DateFormatUtils.ISO_DATE_FORMAT.format(today));\n\n    int newMeasuresOnTrk = 43;\n    int newMeasuresOnBrc = 214;\n    int newMeasuresOnDir = 32;\n    int newMeasuresOnFil = 0;\n\n    assertMeasuresCountForQualifier(\"TRK\", measuresOnTrk + newMeasuresOnTrk);\n    assertMeasuresCountForQualifier(\"BRC\", measuresOnBrc + newMeasuresOnBrc);\n    assertMeasuresCountForQualifier(\"DIR\", measuresOnDir + newMeasuresOnDir);\n    assertMeasuresCountForQualifier(\"FIL\", measuresOnFil + newMeasuresOnFil);\n\n    // Measures on new_* metrics should be recorded\n    collector.checkThat(\n      \"Wrong number of measure of new_ metrics\",\n      count(\"project_measures, metrics where metrics.id = project_measures.metric_id and metrics.name like 'new_%'\"),\n      equalTo(88));\n\n    // added measures relate to project and new_* metrics\n    expectedMeasures += newMeasuresOnTrk + newMeasuresOnBrc + newMeasuresOnDir + newMeasuresOnFil;\n    collector.checkThat(\"Wrong number of measures after second analysis\", count(\"project_measures\"), equalTo(expectedMeasures));\n    collector.checkThat(\"Wrong number of measure data\", count(\"project_measures where measure_data is not null\"), equalTo(0));\n    collector.checkThat(\"Wrong number of issues\", count(\"issues\"), equalTo(expectedIssues));\n  }","id":92738,"modified_method":"@Test\n  public void test_evolution_of_number_of_rows_when_scanning_two_times_the_same_project() {\n    Date today = new Date();\n    Date yesterday = DateUtils.addDays(today, -1);\n\n    scan(PROJECT_SAMPLE_PATH, DateFormatUtils.ISO_DATE_FORMAT.format(yesterday));\n\n    // count components\n    collector.checkThat(\"Wrong number of projects\", count(\"projects where qualifier in ('TRK','BRC')\"), equalTo(7));\n    collector.checkThat(\"Wrong number of directories\", count(\"projects where qualifier in ('DIR')\"), equalTo(4));\n    collector.checkThat(\"Wrong number of files\", count(\"projects where qualifier in ('FIL')\"), equalTo(4));\n    collector.checkThat(\"Wrong number of unit test files\", count(\"projects where qualifier in ('UTS')\"), equalTo(0));\n\n    int measuresOnTrk = 40;\n    int measuresOnBrc = 192;\n    int measuresOnDir = 121;\n    int measuresOnFil = 65;\n\n    // count measures \n    assertMeasuresCountForQualifier(\"TRK\", measuresOnTrk);\n    assertMeasuresCountForQualifier(\"BRC\", measuresOnBrc);\n    assertMeasuresCountForQualifier(\"DIR\", measuresOnDir);\n    assertMeasuresCountForQualifier(\"FIL\", measuresOnFil);\n\n    // No new_* metrics measure should be recorded the first time\n    collector.checkThat(\n      \"Wrong number of measure of new_ metrics\",\n      count(\"project_measures, metrics where metrics.id = project_measures.metric_id and metrics.name like 'new_%'\"),\n      equalTo(0));\n\n    int expectedMeasures = measuresOnTrk + measuresOnBrc + measuresOnDir + measuresOnFil;\n    collector.checkThat(\"Wrong number of measures\", count(\"project_measures\"), equalTo(expectedMeasures));\n    collector.checkThat(\"Wrong number of measure data\", count(\"project_measures where measure_data is not null\"), equalTo(0));\n\n    // count other tables that are constant between 2 scans\n    int expectedIssues = 52;\n\n    collector.checkThat(\"Wrong number of issues\", count(\"issues\"), equalTo(expectedIssues));\n\n    // must be a different date, else a single snapshot is kept per day\n    scan(PROJECT_SAMPLE_PATH, DateFormatUtils.ISO_DATE_FORMAT.format(today));\n\n    int newMeasuresOnTrk = 49;\n    int newMeasuresOnBrc = 250;\n    int newMeasuresOnDir = 44;\n    int newMeasuresOnFil = 0;\n\n    assertMeasuresCountForQualifier(\"TRK\", measuresOnTrk + newMeasuresOnTrk);\n    assertMeasuresCountForQualifier(\"BRC\", measuresOnBrc + newMeasuresOnBrc);\n    assertMeasuresCountForQualifier(\"DIR\", measuresOnDir + newMeasuresOnDir);\n    assertMeasuresCountForQualifier(\"FIL\", measuresOnFil + newMeasuresOnFil);\n\n    // Measures on new_* metrics should be recorded\n    collector.checkThat(\n      \"Wrong number of measure of new_ metrics\",\n      count(\"project_measures, metrics where metrics.id = project_measures.metric_id and metrics.name like 'new_%'\"),\n      equalTo(121));\n\n    // added measures relate to project and new_* metrics\n    expectedMeasures += newMeasuresOnTrk + newMeasuresOnBrc + newMeasuresOnDir + newMeasuresOnFil;\n    collector.checkThat(\"Wrong number of measures after second analysis\", count(\"project_measures\"), equalTo(expectedMeasures));\n    collector.checkThat(\"Wrong number of measure data\", count(\"project_measures where measure_data is not null\"), equalTo(0));\n    collector.checkThat(\"Wrong number of issues\", count(\"issues\"), equalTo(expectedIssues));\n  }","commit_id":"08f6ba94574e741aa85acf5cca0b1b612f28c27e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Retrieves users from external LDAP server.\n   *\n   * @return set of user names\n   */\n  private Set<String> getExternalLdapUserNames() {\n    final Set<String> users = new HashSet<String>();\n    final LdapTemplate ldapTemplate = loadLdapTemplate();\n    final EqualsFilter equalsFilter = new EqualsFilter(\"objectClass\",\n        ldapServerProperties.getUserObjectClass());\n    String baseDn = ldapServerProperties.getUserBase();\n    if (baseDn == null) {\n      baseDn = ldapServerProperties.getBaseDN();\n    }\n    ldapTemplate.search(baseDn, equalsFilter.encode(), new AttributesMapper() {\n\n      public Object mapFromAttributes(Attributes attributes)\n          throws NamingException {\n        users.add(attributes.get(ldapServerProperties.getUsernameAttribute())\n            .get().toString().toLowerCase());\n        return null;\n      }\n    });\n    return users;\n  }","id":92739,"modified_method":"/**\n   * Retrieves users from external LDAP server.\n   *\n   * @return set of user names\n   */\n  private Set<String> getExternalLdapUserNames() {\n    final Set<String> users = new HashSet<String>();\n    final LdapTemplate ldapTemplate = loadLdapTemplate();\n    final EqualsFilter equalsFilter = new EqualsFilter(\"objectClass\",\n        ldapServerProperties.getUserObjectClass());\n    String baseDn = ldapServerProperties.getBaseDN();\n    ldapTemplate.search(baseDn, equalsFilter.encode(), new AttributesMapper() {\n\n      public Object mapFromAttributes(Attributes attributes)\n          throws NamingException {\n        users.add(attributes.get(ldapServerProperties.getUsernameAttribute())\n            .get().toString().toLowerCase());\n        return null;\n      }\n    });\n    return users;\n  }","commit_id":"bba2806f76d98a139e83736fd08b72fae0ab27c1","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Retrieves groups from external LDAP server.\n   *\n   * @return set of user names\n   */\n  private Set<String> getExternalLdapGroupNames() {\n    final Set<String> groups = new HashSet<String>();\n    final LdapTemplate ldapTemplate = loadLdapTemplate();\n    final EqualsFilter equalsFilter = new EqualsFilter(\"objectClass\",\n        ldapServerProperties.getGroupObjectClass());\n    String baseDn = ldapServerProperties.getGroupBase();\n    if (baseDn == null) {\n      baseDn = ldapServerProperties.getBaseDN();\n    }\n    ldapTemplate.search(baseDn, equalsFilter.encode(), new AttributesMapper() {\n\n      public Object mapFromAttributes(Attributes attributes)\n          throws NamingException {\n        groups.add(attributes.get(ldapServerProperties.getGroupNamingAttr())\n            .get().toString().toLowerCase());\n        return null;\n      }\n    });\n    return groups;\n  }","id":92740,"modified_method":"/**\n   * Retrieves groups from external LDAP server.\n   *\n   * @return set of user names\n   */\n  private Set<String> getExternalLdapGroupNames() {\n    final Set<String> groups = new HashSet<String>();\n    final LdapTemplate ldapTemplate = loadLdapTemplate();\n    final EqualsFilter equalsFilter = new EqualsFilter(\"objectClass\",\n        ldapServerProperties.getGroupObjectClass());\n    String baseDn = ldapServerProperties.getBaseDN();\n    ldapTemplate.search(baseDn, equalsFilter.encode(), new AttributesMapper() {\n\n      public Object mapFromAttributes(Attributes attributes)\n          throws NamingException {\n        groups.add(attributes.get(ldapServerProperties.getGroupNamingAttr())\n            .get().toString().toLowerCase());\n        return null;\n      }\n    });\n    return groups;\n  }","commit_id":"bba2806f76d98a139e83736fd08b72fae0ab27c1","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Retrieves members of the specified group from external LDAP server.\n   *\n   * @param groupName group name\n   * @return set of group names\n   */\n  private Set<String> getExternalLdapGroupMembers(String groupName) {\n    final Set<String> members = new HashSet<String>();\n    final LdapTemplate ldapTemplate = loadLdapTemplate();\n    final AndFilter andFilter = new AndFilter();\n    andFilter.and(new EqualsFilter(\"objectClass\", ldapServerProperties.getGroupObjectClass()));\n    andFilter.and(new EqualsFilter(ldapServerProperties.getGroupNamingAttr(), groupName));\n    String baseDn = ldapServerProperties.getGroupBase();\n    if (baseDn == null) {\n      baseDn = ldapServerProperties.getBaseDN();\n    }\n    ldapTemplate.search(baseDn, andFilter.encode(), new ContextMapper() {\n\n      public Object mapFromContext(Object ctx) {\n        final DirContextAdapter adapter  = (DirContextAdapter) ctx;\n        for (String uniqueMember: adapter.getStringAttributes(ldapServerProperties.getGroupMembershipAttr())) {\n          final DirContextAdapter userAdapter = (DirContextAdapter) ldapTemplate.lookup(uniqueMember);\n          members.add(userAdapter.getStringAttribute(ldapServerProperties.getUsernameAttribute()).toLowerCase());\n        }\n        return null;\n      }\n    });\n    return members;\n  }","id":92741,"modified_method":"/**\n   * Retrieves members of the specified group from external LDAP server.\n   *\n   * @param groupName group name\n   * @return set of group names\n   */\n  private Set<String> getExternalLdapGroupMembers(String groupName) {\n    final Set<String> members = new HashSet<String>();\n    final LdapTemplate ldapTemplate = loadLdapTemplate();\n    final AndFilter andFilter = new AndFilter();\n    andFilter.and(new EqualsFilter(\"objectClass\", ldapServerProperties.getGroupObjectClass()));\n    andFilter.and(new EqualsFilter(ldapServerProperties.getGroupNamingAttr(), groupName));\n    String baseDn = ldapServerProperties.getBaseDN();\n    ldapTemplate.search(baseDn, andFilter.encode(), new ContextMapper() {\n\n      public Object mapFromContext(Object ctx) {\n        final DirContextAdapter adapter  = (DirContextAdapter) ctx;\n        for (String uniqueMember: adapter.getStringAttributes(ldapServerProperties.getGroupMembershipAttr())) {\n          final DirContextAdapter userAdapter = (DirContextAdapter) ldapTemplate.lookup(uniqueMember);\n          members.add(userAdapter.getStringAttribute(ldapServerProperties.getUsernameAttribute()).toLowerCase());\n        }\n        return null;\n      }\n    });\n    return members;\n  }","commit_id":"bba2806f76d98a139e83736fd08b72fae0ab27c1","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Check if LDAP is enabled in server properties.\n   *\n   * @return true if enabled\n   */\n  public boolean isLdapEnabled() {\n    try {\n      final LdapTemplate ldapTemplate = loadLdapTemplate();\n      ldapTemplate.search(ldapServerProperties.getBaseDN(),\n          \"(objectclass=person)\", new AttributesMapper() {\n\n            public Object mapFromAttributes(Attributes attributes)\n                throws NamingException {\n              return attributes.get(\"uid\").get();\n            }\n          });\n      return true;\n    } catch (Exception ex) {\n      LOG.error(\"Could not connect to LDAP server\", ex);\n      return false;\n    }\n  }","id":92742,"modified_method":"/**\n   * Check if LDAP is enabled in server properties.\n   *\n   * @return true if enabled\n   */\n  public boolean isLdapEnabled() {\n    try {\n      final LdapTemplate ldapTemplate = loadLdapTemplate();\n      ldapTemplate.search(ldapServerProperties.getBaseDN(),\n          \"(objectclass=person)\", new AttributesMapper() {\n\n            public Object mapFromAttributes(Attributes attributes)\n                throws NamingException {\n              return \"\";\n            }\n          });\n      return true;\n    } catch (Exception ex) {\n      LOG.error(\"Could not connect to LDAP server\", ex);\n      return false;\n    }\n  }","commit_id":"bba2806f76d98a139e83736fd08b72fae0ab27c1","url":"https://github.com/apache/ambari"},{"original_method":"public boolean send(NodeClientCore core, RequestScheduler sched, final ClientContext context, final ChosenBlock req) {\n\t\t\t// Ignore keyNum, key, since we're only sending one block.\n\t\t\tClientKeyBlock b;\n\t\t\tfinal ClientKey key;\n\t\t\tClientKey k = null;\n\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Starting request\");\n\t\t\tBlockItem block = (BlockItem) req.token;\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tb = innerEncode(context.random, block.uri, block.copyBucket, block.isMetadata, block.compressionCodec, block.sourceLength, compressorDescriptor, block.pre1254, block.cryptoAlgorithm, block.cryptoKey);\n\t\t\t\t} catch (CHKEncodeException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (SSKEncodeException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (InsertException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (InvalidCompressionCodecException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t}\n\t\t\t\tif (b==null) {\n\t\t\t\t\tLogger.error(this, \"Asked to send empty block\", new Exception(\"error\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tkey = b.getClientKey();\n\t\t\t\tk = key;\n\t\t\t\tif(block.persistent) {\n\t\t\t\t\treq.setGeneratedKey(key);\n\t\t\t\t} else if(!req.localRequestOnly) {\n\t\t\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\torig.onEncode(key, null, context);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, \"Got URI\");\n\n\t\t\t\t}\n\t\t\t\tif(req.localRequestOnly)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcore.node.store(b, false, req.canWriteClientCache, true, false);\n\t\t\t\t\t} catch (KeyCollisionException e) {\n\t\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.COLLISION);\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcore.realPut(b, req.canWriteClientCache, req.forkOnCacheable, Node.PREFER_INSERT_DEFAULT, Node.IGNORE_LOW_BACKOFF_DEFAULT);\n\t\t\t} catch (LowLevelPutException e) {\n\t\t\t\tif(e.code == LowLevelPutException.COLLISION) {\n\t\t\t\t\t// Collision\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClientSSKBlock collided = (ClientSSKBlock) core.node.fetch((ClientSSK)k, true, true, req.canWriteClientCache);\n\t\t\t\t\t\tbyte[] data = collided.memoryDecode(true);\n\t\t\t\t\t\tbyte[] inserting = BucketTools.toByteArray(block.copyBucket);\n\t\t\t\t\t\tif(collided.isMetadata() == block.isMetadata && collided.getCompressionCodec() == block.compressionCodec && Arrays.equals(data, inserting)) {\n\t\t\t\t\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Collided with identical data\");\n\t\t\t\t\t\t\tif(!block.persistent)\n\t\t\t\t\t\t\t\torig.onEncode(k, null, context);\n\t\t\t\t\t\t\treq.onInsertSuccess(context);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (KeyVerifyException e1) {\n\t\t\t\t\t\tLogger.error(this, \"Caught \"+e1+\" when checking collision!\", e1);\n\t\t\t\t\t} catch (KeyDecodeException e1) {\n\t\t\t\t\t\tLogger.error(this, \"Caught \"+e1+\" when checking collision!\", e1);\n\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\tLogger.error(this, \"Caught \"+e1+\" when checking collision!\", e1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treq.onFailure(e, context);\n\t\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Request failed for \"+e);\n\t\t\t\treturn true;\n\t\t\t} finally {\n\t\t\t\tblock.copyBucket.free();\n\t\t\t}\n\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Request succeeded\");\n\t\t\tif(req.localRequestOnly) {\n\t\t\t\t// Must run on-thread or we will have exploding threads.\n\t\t\t\t// Plus must run before onInsertSuccess().\n\t\t\t\tif(!block.persistent)\n\t\t\t\t\torig.onEncode(key, null, context);\n\t\t\t\treq.onInsertSuccess(context);\n\t\t\t} else if(!block.persistent) {\n\t\t\t\t// Must run after onEncode.\n\t\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t// Make absolutely sure even if we run the two jobs out of order.\n\t\t\t\t\t\t// Overhead for double-checking should be very low.\n\t\t\t\t\t\torig.onEncode(key, null, context);\n\t\t\t\t\t\treq.onInsertSuccess(context);\n\t\t\t\t\t}\n\n\t\t\t\t}, \"Succeeded\");\n\t\t\t} else {\n\t\t\t\treq.onInsertSuccess(context);\n\t\t\t}\n\t\t\treturn true;\n\t\t}","id":92743,"modified_method":"public boolean send(NodeClientCore core, RequestScheduler sched, final ClientContext context, final ChosenBlock req) {\n\t\t\t// Ignore keyNum, key, since we're only sending one block.\n\t\t\tClientKeyBlock b;\n\t\t\tfinal ClientKey key;\n\t\t\tClientKey k = null;\n\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Starting request\");\n\t\t\tBlockItem block = (BlockItem) req.token;\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tb = innerEncode(context.random, block.uri, block.copyBucket, block.isMetadata, block.compressionCodec, block.sourceLength, compressorDescriptor, block.pre1254, block.cryptoAlgorithm, block.cryptoKey);\n\t\t\t\t} catch (CHKEncodeException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (SSKEncodeException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (InsertException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (InvalidCompressionCodecException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t}\n\t\t\t\tif (b==null) {\n\t\t\t\t\tLogger.error(this, \"Asked to send empty block\", new Exception(\"error\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tkey = b.getClientKey();\n\t\t\t\tk = key;\n\t\t\t\tif(block.persistent) {\n\t\t\t\t\treq.setGeneratedKey(key);\n\t\t\t\t} else if(!req.localRequestOnly) {\n\t\t\t\t\torig.onEncode(key, null, context);\n\t\t\t\t}\n\t\t\t\tif(req.localRequestOnly)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcore.node.store(b, false, req.canWriteClientCache, true, false);\n\t\t\t\t\t} catch (KeyCollisionException e) {\n\t\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.COLLISION);\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcore.realPut(b, req.canWriteClientCache, req.forkOnCacheable, Node.PREFER_INSERT_DEFAULT, Node.IGNORE_LOW_BACKOFF_DEFAULT);\n\t\t\t} catch (LowLevelPutException e) {\n\t\t\t\tif(e.code == LowLevelPutException.COLLISION) {\n\t\t\t\t\t// Collision\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClientSSKBlock collided = (ClientSSKBlock) core.node.fetch((ClientSSK)k, true, true, req.canWriteClientCache);\n\t\t\t\t\t\tbyte[] data = collided.memoryDecode(true);\n\t\t\t\t\t\tbyte[] inserting = BucketTools.toByteArray(block.copyBucket);\n\t\t\t\t\t\tif(collided.isMetadata() == block.isMetadata && collided.getCompressionCodec() == block.compressionCodec && Arrays.equals(data, inserting)) {\n\t\t\t\t\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Collided with identical data\");\n\t\t\t\t\t\t\tif(!block.persistent)\n\t\t\t\t\t\t\t\torig.onEncode(k, null, context);\n\t\t\t\t\t\t\treq.onInsertSuccess(context);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (KeyVerifyException e1) {\n\t\t\t\t\t\tLogger.error(this, \"Caught \"+e1+\" when checking collision!\", e1);\n\t\t\t\t\t} catch (KeyDecodeException e1) {\n\t\t\t\t\t\tLogger.error(this, \"Caught \"+e1+\" when checking collision!\", e1);\n\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\tLogger.error(this, \"Caught \"+e1+\" when checking collision!\", e1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treq.onFailure(e, context);\n\t\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Request failed for \"+e);\n\t\t\t\treturn true;\n\t\t\t} finally {\n\t\t\t\tblock.copyBucket.free();\n\t\t\t}\n\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Request succeeded\");\n\t\t\tif(req.localRequestOnly) {\n\t\t\t\t// Must run on-thread or we will have exploding threads.\n\t\t\t\t// Plus must run before onInsertSuccess().\n\t\t\t\tif(!block.persistent)\n\t\t\t\t\torig.onEncode(key, null, context);\n\t\t\t\treq.onInsertSuccess(context);\n\t\t\t} else if(!block.persistent) {\n\t\t\t\t// Must run after onEncode.\n\t\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t// Make absolutely sure even if we run the two jobs out of order.\n\t\t\t\t\t\t// Overhead for double-checking should be very low.\n\t\t\t\t\t\torig.onEncode(key, null, context);\n\t\t\t\t\t\treq.onInsertSuccess(context);\n\t\t\t\t\t}\n\n\t\t\t\t}, \"Succeeded\");\n\t\t\t} else {\n\t\t\t\treq.onInsertSuccess(context);\n\t\t\t}\n\t\t\treturn true;\n\t\t}","commit_id":"f5dc0dcecf4b0bb8ab24da1d8470ee8ec775b61c","url":"https://github.com/freenet/fred"},{"original_method":"protected void onEncode(ClientKey key, ObjectContainer container, ClientContext context) {\n\t\tsynchronized(this) {\n\t\t\tif(finished) return;\n\t\t\tif(resultingURI != null) return;\n\t\t\tresultingURI = key.getURI();\n\t\t}\n\t\tif(persistent) {\n\t\t\tcontainer.store(this);\n\t\t\tcontainer.activate(cb, 1);\n\t\t}\n\t\tcb.onEncode(key, this, container, context);\n\t\tif(persistent)\n\t\t\tcontainer.deactivate(cb, 1);\n\t}","id":92744,"modified_method":"protected void onEncode(final ClientKey key, ObjectContainer container, final ClientContext context) {\n\t\tsynchronized(this) {\n\t\t\tif(finished) return;\n\t\t\tif(resultingURI != null) return;\n\t\t\tresultingURI = key.getURI();\n\t\t}\n\t\tif(persistent) {\n\t\t\tcontainer.store(this);\n\t\t\tcontainer.activate(cb, 1);\n\t\t}\n\t\tif(!persistent) {\n\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\t\t\t\t\n\t\t\t\tpublic void run() {\n\t\t\t\t\tcb.onEncode(key, SingleBlockInserter.this, null, context);\n\t\t\t\t}\n\t\t\t}, \"Got URI\");\n\t\t} else {\n\t\t\tcb.onEncode(key, this, container, context);\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.deactivate(cb, 1);\n\t}","commit_id":"f5dc0dcecf4b0bb8ab24da1d8470ee8ec775b61c","url":"https://github.com/freenet/fred"},{"original_method":"public boolean send(NodeClientCore core, RequestScheduler sched, final ClientContext context, final ChosenBlock req) {\n\t\t\t\t// Ignore keyNum, key, since we're only sending one block.\n\t\t\tfinal int num;\n\t\t\tfinal ClientCHK key;\n\t\t\t\ttry {\n\t\t\t\t\tBlockItem block = (BlockItem) req.token;\n\t\t\t\t\tif(SplitFileInserterSegment.logMINOR) Logger.minor(this, \"Starting request: block number \"+block.blockNum);\n\t\t\t\t\tClientCHKBlock b;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tb = encodeBucket(block.copyBucket, compressorDescriptor, block.cryptoAlgorithm, block.cryptoKey);\n\t\t\t\t\t} catch (CHKEncodeException e) {\n\t\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage()+\" for \"+block.copyBucket, e);\n\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage()+\" for \"+block.copyBucket, e);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage()+\" for \"+block.copyBucket, e);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tblock.copyBucket.free();\n\t\t\t\t\t}\n\t\t\t\t\tif (b==null) {\n\t\t\t\t\t\tLogger.error(this, \"Asked to send empty block\", new Exception(\"error\"));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tkey = b.getClientKey();\n\t\t\t\t\tnum = block.blockNum;\n\t\t\t\t\tif(block.persistent) {\n\t\t\t\t\t\treq.setGeneratedKey(key);\n\t\t\t\t\t} else if(!req.localRequestOnly) {\n\t\t\t\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\n\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\tseg.onEncode(num, key, null, context);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}, \"Got URI\");\n\n\t\t\t\t\t}\n\t\t\t\t\tif(req.localRequestOnly)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcore.node.store(b, false, req.canWriteClientCache, true, false);\n\t\t\t\t\t\t} catch (KeyCollisionException e) {\n\t\t\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.COLLISION);\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tcore.realPut(b, req.canWriteClientCache, req.forkOnCacheable, Node.PREFER_INSERT_DEFAULT, Node.IGNORE_LOW_BACKOFF_DEFAULT);\n\t\t\t\t} catch (LowLevelPutException e) {\n\t\t\t\t\treq.onFailure(e, context);\n\t\t\t\t\tif(SplitFileInserterSegment.logMINOR) Logger.minor(this, \"Request failed for \"+e);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif(SplitFileInserterSegment.logMINOR) Logger.minor(this, \"Request succeeded\");\n\t\t\t\tif(req.localRequestOnly) {\n\t\t\t\t\t// Must run on-thread or we will have exploding threads.\n\t\t\t\t\t// Plus must run before onInsertSuccess().\n\t\t\t\t\tseg.onEncode(num, key, null, context);\n\t\t\t\t\treq.onInsertSuccess(context);\n\t\t\t\t} else {\n\t\t\t\t\t// Must run after onEncode.\n\t\t\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\treq.onInsertSuccess(context);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, \"Succeeded\");\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}","id":92745,"modified_method":"public boolean send(NodeClientCore core, RequestScheduler sched, final ClientContext context, final ChosenBlock req) {\n\t\t\t\t// Ignore keyNum, key, since we're only sending one block.\n\t\t\tfinal int num;\n\t\t\tfinal ClientCHK key;\n\t\t\tBlockItem block = (BlockItem) req.token;\n\t\t\t\ttry {\n\t\t\t\t\tif(SplitFileInserterSegment.logMINOR) Logger.minor(this, \"Starting request: block number \"+block.blockNum);\n\t\t\t\t\tClientCHKBlock b;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tb = encodeBucket(block.copyBucket, compressorDescriptor, block.cryptoAlgorithm, block.cryptoKey);\n\t\t\t\t\t} catch (CHKEncodeException e) {\n\t\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage()+\" for \"+block.copyBucket, e);\n\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage()+\" for \"+block.copyBucket, e);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage()+\" for \"+block.copyBucket, e);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tblock.copyBucket.free();\n\t\t\t\t\t}\n\t\t\t\t\tif (b==null) {\n\t\t\t\t\t\tLogger.error(this, \"Asked to send empty block\", new Exception(\"error\"));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tkey = b.getClientKey();\n\t\t\t\t\tnum = block.blockNum;\n\t\t\t\t\tif(block.persistent) {\n\t\t\t\t\t\treq.setGeneratedKey(key);\n\t\t\t\t\t} else if(!req.localRequestOnly) {\n\t\t\t\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\n\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\tseg.onEncode(num, key, null, context);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}, \"Got URI\");\n\n\t\t\t\t\t}\n\t\t\t\t\tif(req.localRequestOnly)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcore.node.store(b, false, req.canWriteClientCache, true, false);\n\t\t\t\t\t\t} catch (KeyCollisionException e) {\n\t\t\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.COLLISION);\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tcore.realPut(b, req.canWriteClientCache, req.forkOnCacheable, Node.PREFER_INSERT_DEFAULT, Node.IGNORE_LOW_BACKOFF_DEFAULT);\n\t\t\t\t} catch (LowLevelPutException e) {\n\t\t\t\t\treq.onFailure(e, context);\n\t\t\t\t\tif(SplitFileInserterSegment.logMINOR) Logger.minor(this, \"Request failed for \"+e);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif(SplitFileInserterSegment.logMINOR) Logger.minor(this, \"Request succeeded\");\n\t\t\t\tif(req.localRequestOnly) {\n\t\t\t\t\t// Must run on-thread or we will have exploding threads.\n\t\t\t\t\t// Plus must run before onInsertSuccess().\n\t\t\t\t\tif(!block.persistent)\n\t\t\t\t\t\tseg.onEncode(num, key, null, context);\n\t\t\t\t\treq.onInsertSuccess(context);\n\t\t\t\t} else if(!block.persistent) {\n\t\t\t\t\t// Must run after onEncode.\n\t\t\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\treq.onInsertSuccess(context);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, \"Succeeded\");\n\t\t\t\t} else {\n\t\t\t\t\treq.onInsertSuccess(context);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}","commit_id":"b032dc865f2a03c951d3c76e60da7cc751adca4f","url":"https://github.com/freenet/fred"},{"original_method":"public boolean send(NodeClientCore core, RequestScheduler sched, final ClientContext context, final ChosenBlock req) {\n\t\t\t// Ignore keyNum, key, since we're only sending one block.\n\t\t\tClientKeyBlock b;\n\t\t\tfinal ClientKey key;\n\t\t\tClientKey k = null;\n\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Starting request\");\n\t\t\tBlockItem block = (BlockItem) req.token;\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tb = innerEncode(context.random, block.uri, block.copyBucket, block.isMetadata, block.compressionCodec, block.sourceLength, compressorDescriptor, block.pre1254, block.cryptoAlgorithm, block.cryptoKey);\n\t\t\t\t} catch (CHKEncodeException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (SSKEncodeException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (InsertException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (InvalidCompressionCodecException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t}\n\t\t\t\tif (b==null) {\n\t\t\t\t\tLogger.error(this, \"Asked to send empty block\", new Exception(\"error\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tkey = b.getClientKey();\n\t\t\t\tk = key;\n\t\t\t\tif(block.persistent) {\n\t\t\t\t\treq.setGeneratedKey(key);\n\t\t\t\t} else if(!req.localRequestOnly) {\n\t\t\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\torig.onEncode(key, null, context);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, \"Got URI\");\n\n\t\t\t\t}\n\t\t\t\tif(req.localRequestOnly)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcore.node.store(b, false, req.canWriteClientCache, true, false);\n\t\t\t\t\t} catch (KeyCollisionException e) {\n\t\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.COLLISION);\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcore.realPut(b, req.canWriteClientCache, req.forkOnCacheable, Node.PREFER_INSERT_DEFAULT, Node.IGNORE_LOW_BACKOFF_DEFAULT);\n\t\t\t} catch (LowLevelPutException e) {\n\t\t\t\tif(e.code == LowLevelPutException.COLLISION) {\n\t\t\t\t\t// Collision\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClientSSKBlock collided = (ClientSSKBlock) core.node.fetch((ClientSSK)k, true, true, req.canWriteClientCache);\n\t\t\t\t\t\tbyte[] data = collided.memoryDecode(true);\n\t\t\t\t\t\tbyte[] inserting = BucketTools.toByteArray(block.copyBucket);\n\t\t\t\t\t\tif(collided.isMetadata() == block.isMetadata && collided.getCompressionCodec() == block.compressionCodec && Arrays.equals(data, inserting)) {\n\t\t\t\t\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Collided with identical data\");\n\t\t\t\t\t\t\tif(!block.persistent)\n\t\t\t\t\t\t\t\torig.onEncode(k, null, context);\n\t\t\t\t\t\t\treq.onInsertSuccess(context);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (KeyVerifyException e1) {\n\t\t\t\t\t\tLogger.error(this, \"Caught \"+e1+\" when checking collision!\", e1);\n\t\t\t\t\t} catch (KeyDecodeException e1) {\n\t\t\t\t\t\tLogger.error(this, \"Caught \"+e1+\" when checking collision!\", e1);\n\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\tLogger.error(this, \"Caught \"+e1+\" when checking collision!\", e1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treq.onFailure(e, context);\n\t\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Request failed for \"+e);\n\t\t\t\treturn true;\n\t\t\t} finally {\n\t\t\t\tblock.copyBucket.free();\n\t\t\t}\n\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Request succeeded\");\n\t\t\tif(req.localRequestOnly) {\n\t\t\t\t// Must run on-thread or we will have exploding threads.\n\t\t\t\t// Plus must run before onInsertSuccess().\n\t\t\t\tif(!block.persistent)\n\t\t\t\t\torig.onEncode(key, null, context);\n\t\t\t\treq.onInsertSuccess(context);\n\t\t\t} else if(!block.persistent) {\n\t\t\t\t// Must run after onEncode.\n\t\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t// Make absolutely sure even if we run the two jobs out of order.\n\t\t\t\t\t\t// Overhead for double-checking should be very low.\n\t\t\t\t\t\torig.onEncode(key, null, context);\n\t\t\t\t\t\treq.onInsertSuccess(context);\n\t\t\t\t\t}\n\n\t\t\t\t}, \"Succeeded\");\n\t\t\t} else {\n\t\t\t\treq.onInsertSuccess(context);\n\t\t\t}\n\t\t\treturn true;\n\t\t}","id":92746,"modified_method":"public boolean send(NodeClientCore core, RequestScheduler sched, final ClientContext context, final ChosenBlock req) {\n\t\t\t// Ignore keyNum, key, since we're only sending one block.\n\t\t\tClientKeyBlock b;\n\t\t\tfinal ClientKey key;\n\t\t\tClientKey k = null;\n\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Starting request\");\n\t\t\tBlockItem block = (BlockItem) req.token;\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tb = innerEncode(context.random, block.uri, block.copyBucket, block.isMetadata, block.compressionCodec, block.sourceLength, compressorDescriptor, block.pre1254, block.cryptoAlgorithm, block.cryptoKey);\n\t\t\t\t} catch (CHKEncodeException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (SSKEncodeException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (InsertException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t} catch (InvalidCompressionCodecException e) {\n\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.INTERNAL_ERROR, e.toString() + \":\" + e.getMessage(), e);\n\t\t\t\t}\n\t\t\t\tif (b==null) {\n\t\t\t\t\tLogger.error(this, \"Asked to send empty block\", new Exception(\"error\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tkey = b.getClientKey();\n\t\t\t\tk = key;\n\t\t\t\tif(block.persistent) {\n\t\t\t\t\treq.setGeneratedKey(key);\n\t\t\t\t} else if(!req.localRequestOnly) {\n\t\t\t\t\torig.onEncode(key, null, context);\n\t\t\t\t}\n\t\t\t\tif(req.localRequestOnly)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcore.node.store(b, false, req.canWriteClientCache, true, false);\n\t\t\t\t\t} catch (KeyCollisionException e) {\n\t\t\t\t\t\tthrow new LowLevelPutException(LowLevelPutException.COLLISION);\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcore.realPut(b, req.canWriteClientCache, req.forkOnCacheable, Node.PREFER_INSERT_DEFAULT, Node.IGNORE_LOW_BACKOFF_DEFAULT);\n\t\t\t} catch (LowLevelPutException e) {\n\t\t\t\tif(e.code == LowLevelPutException.COLLISION) {\n\t\t\t\t\t// Collision\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClientSSKBlock collided = (ClientSSKBlock) core.node.fetch((ClientSSK)k, true, true, req.canWriteClientCache);\n\t\t\t\t\t\tbyte[] data = collided.memoryDecode(true);\n\t\t\t\t\t\tbyte[] inserting = BucketTools.toByteArray(block.copyBucket);\n\t\t\t\t\t\tif(collided.isMetadata() == block.isMetadata && collided.getCompressionCodec() == block.compressionCodec && Arrays.equals(data, inserting)) {\n\t\t\t\t\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Collided with identical data\");\n\t\t\t\t\t\t\tif(!block.persistent)\n\t\t\t\t\t\t\t\torig.onEncode(k, null, context);\n\t\t\t\t\t\t\treq.onInsertSuccess(context);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (KeyVerifyException e1) {\n\t\t\t\t\t\tLogger.error(this, \"Caught \"+e1+\" when checking collision!\", e1);\n\t\t\t\t\t} catch (KeyDecodeException e1) {\n\t\t\t\t\t\tLogger.error(this, \"Caught \"+e1+\" when checking collision!\", e1);\n\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\tLogger.error(this, \"Caught \"+e1+\" when checking collision!\", e1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treq.onFailure(e, context);\n\t\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Request failed for \"+e);\n\t\t\t\treturn true;\n\t\t\t} finally {\n\t\t\t\tblock.copyBucket.free();\n\t\t\t}\n\t\t\tif(SingleBlockInserter.logMINOR) Logger.minor(this, \"Request succeeded\");\n\t\t\tif(req.localRequestOnly) {\n\t\t\t\t// Must run on-thread or we will have exploding threads.\n\t\t\t\t// Plus must run before onInsertSuccess().\n\t\t\t\tif(!block.persistent)\n\t\t\t\t\torig.onEncode(key, null, context);\n\t\t\t\treq.onInsertSuccess(context);\n\t\t\t} else if(!block.persistent) {\n\t\t\t\t// Must run after onEncode.\n\t\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t// Make absolutely sure even if we run the two jobs out of order.\n\t\t\t\t\t\t// Overhead for double-checking should be very low.\n\t\t\t\t\t\torig.onEncode(key, null, context);\n\t\t\t\t\t\treq.onInsertSuccess(context);\n\t\t\t\t\t}\n\n\t\t\t\t}, \"Succeeded\");\n\t\t\t} else {\n\t\t\t\treq.onInsertSuccess(context);\n\t\t\t}\n\t\t\treturn true;\n\t\t}","commit_id":"a4ae97d026eeb28d456e8557b60f83bfae1c081d","url":"https://github.com/freenet/fred"},{"original_method":"protected void onEncode(ClientKey key, ObjectContainer container, ClientContext context) {\n\t\tsynchronized(this) {\n\t\t\tif(finished) return;\n\t\t\tif(resultingURI != null) return;\n\t\t\tresultingURI = key.getURI();\n\t\t}\n\t\tif(persistent) {\n\t\t\tcontainer.store(this);\n\t\t\tcontainer.activate(cb, 1);\n\t\t}\n\t\tcb.onEncode(key, this, container, context);\n\t\tif(persistent)\n\t\t\tcontainer.deactivate(cb, 1);\n\t}","id":92747,"modified_method":"protected void onEncode(final ClientKey key, ObjectContainer container, final ClientContext context) {\n\t\tsynchronized(this) {\n\t\t\tif(finished) return;\n\t\t\tif(resultingURI != null) return;\n\t\t\tresultingURI = key.getURI();\n\t\t}\n\t\tif(persistent) {\n\t\t\tcontainer.store(this);\n\t\t\tcontainer.activate(cb, 1);\n\t\t}\n\t\tif(!persistent) {\n\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\t\t\t\t\n\t\t\t\tpublic void run() {\n\t\t\t\t\tcb.onEncode(key, SingleBlockInserter.this, null, context);\n\t\t\t\t}\n\t\t\t}, \"Got URI\");\n\t\t} else {\n\t\t\tcb.onEncode(key, this, container, context);\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.deactivate(cb, 1);\n\t}","commit_id":"a4ae97d026eeb28d456e8557b60f83bfae1c081d","url":"https://github.com/freenet/fred"},{"original_method":"public void writeTokenStorageToStream(DataOutputStream os)\n    throws IOException {\n    os.write(TOKEN_STORAGE_MAGIC);\n    os.write(TOKEN_STORAGE_VERSION);\n    write(os);\n  }","id":92748,"modified_method":"public void writeTokenStorageToStream(DataOutputStream os)\n      throws IOException {\n    os.write(TOKEN_STORAGE_MAGIC);\n    os.write(TOKEN_STORAGE_VERSION);\n    writeProto(os);\n  }","commit_id":"2753185a010e70f8d9539f42151c79177781122d","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Convenience method for reading a token storage file directly from a \n   * datainputstream\n   */\n  public void readTokenStorageStream(DataInputStream in) throws IOException {\n    byte[] magic = new byte[TOKEN_STORAGE_MAGIC.length];\n    in.readFully(magic);\n    if (!Arrays.equals(magic, TOKEN_STORAGE_MAGIC)) {\n      throw new IOException(\"Bad header found in token storage.\");\n    }\n    byte version = in.readByte();\n    if (version != TOKEN_STORAGE_VERSION) {\n      throw new IOException(\"Unknown version \" + version + \n                            \" in token storage.\");\n    }\n    readFields(in);\n  }","id":92749,"modified_method":"/**\n   * Convenience method for reading a token from a DataInputStream.\n   */\n  public void readTokenStorageStream(DataInputStream in) throws IOException {\n    byte[] magic = new byte[TOKEN_STORAGE_MAGIC.length];\n    in.readFully(magic);\n    if (!Arrays.equals(magic, TOKEN_STORAGE_MAGIC)) {\n      throw new IOException(\"Bad header found in token storage.\");\n    }\n    byte version = in.readByte();\n    if (version != TOKEN_STORAGE_VERSION &&\n        version != OLD_TOKEN_STORAGE_VERSION) {\n      throw new IOException(\"Unknown version \" + version +\n                            \" in token storage.\");\n    }\n    if (version == OLD_TOKEN_STORAGE_VERSION) {\n      readFields(in);\n    } else if (version == TOKEN_STORAGE_VERSION) {\n      readProto(in);\n    }\n  }","commit_id":"2753185a010e70f8d9539f42151c79177781122d","url":"https://github.com/apache/hadoop"},{"original_method":"@VisibleForTesting\n  static void saveDelegationToken(Configuration conf, FileSystem fs,\n                                  final String renewer, final Path tokenFile)\n          throws IOException {\n    Token<?> token = fs.getDelegationToken(renewer);\n    if (null != token) {\n      Credentials cred = new Credentials();\n      cred.addToken(token.getService(), token);\n      cred.writeTokenStorageFile(tokenFile, conf);\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Fetched token \" + fs.getUri() + \" for \" +\n            token.getService() + \" into \" + tokenFile);\n      }\n    } else {\n      System.err.println(\"ERROR: Failed to fetch token from \" + fs.getUri());\n    }\n  }","id":92750,"modified_method":"@VisibleForTesting\n  static void saveDelegationToken(Configuration conf, FileSystem fs,\n                                  final String renewer, final Path tokenFile)\n          throws IOException {\n    Token<?> token = fs.getDelegationToken(renewer);\n    if (null != token) {\n      Credentials cred = new Credentials();\n      cred.addToken(token.getService(), token);\n      // dtutil is replacing this tool; preserve legacy functionality\n      cred.writeLegacyTokenStorageFile(tokenFile, conf);\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Fetched token \" + fs.getUri() + \" for \" +\n            token.getService() + \" into \" + tokenFile);\n      }\n    } else {\n      System.err.println(\"ERROR: Failed to fetch token from \" + fs.getUri());\n    }\n  }","commit_id":"2753185a010e70f8d9539f42151c79177781122d","url":"https://github.com/apache/hadoop"},{"original_method":"public void process() throws IOException {\n      \n      // We can not access any meta region if they have not already been assigned\n      // and scanned.\n\n      metaScanner.waitForMetaScan();\n      \n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"region closed: \" + regionInfo.regionName);\n      }\n\n      // Mark the Region as unavailable in the appropriate meta table\n\n      Text metaRegionName;\n      HRegionInterface server;\n      if (rootRegion) {\n        metaRegionName = HGlobals.rootRegionInfo.regionName;\n        waitForRootRegion();            // Make sure root region available\n        server = client.getHRegionConnection(rootRegionLocation);\n        \n      } else {\n        MetaRegion r = null;\n        if(knownMetaRegions.containsKey(regionInfo.regionName)) {\n          r = knownMetaRegions.get(regionInfo.regionName);\n          \n        } else {\n          r = knownMetaRegions.get(\n              knownMetaRegions.headMap(regionInfo.regionName).lastKey());\n        }\n        metaRegionName = r.regionName;\n        server = client.getHRegionConnection(r.server);\n      }\n      long lockid = server.startUpdate(metaRegionName, clientId, regionInfo.regionName);\n      server.delete(metaRegionName, clientId, lockid, COL_SERVER);\n      server.delete(metaRegionName, clientId, lockid, COL_STARTCODE);\n      server.commit(metaRegionName, clientId, lockid);\n      \n      if(reassignRegion) {\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"reassign region: \" + regionInfo.regionName);\n        }\n        \n        unassignedRegions.put(regionInfo.regionName, regionInfo);\n        assignAttempts.put(regionInfo.regionName, 0L);\n      }\n    }","id":92751,"modified_method":"public void process() throws IOException {\n      for(int tries = 0; tries < numRetries; tries ++) {\n\n        // We can not access any meta region if they have not already been assigned\n        // and scanned.\n\n        metaScanner.waitForMetaScan();\n\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"region closed: \" + regionInfo.regionName);\n        }\n\n        // Mark the Region as unavailable in the appropriate meta table\n\n        Text metaRegionName;\n        HRegionInterface server;\n        if (rootRegion) {\n          metaRegionName = HGlobals.rootRegionInfo.regionName;\n          waitForRootRegion();            // Make sure root region available\n          server = client.getHRegionConnection(rootRegionLocation);\n\n        } else {\n          MetaRegion r = null;\n          if(knownMetaRegions.containsKey(regionInfo.regionName)) {\n            r = knownMetaRegions.get(regionInfo.regionName);\n\n          } else {\n            r = knownMetaRegions.get(\n                knownMetaRegions.headMap(regionInfo.regionName).lastKey());\n          }\n          metaRegionName = r.regionName;\n          server = client.getHRegionConnection(r.server);\n        }\n\n        try {\n          long lockid = server.startUpdate(metaRegionName, clientId, regionInfo.regionName);\n          server.delete(metaRegionName, clientId, lockid, COL_SERVER);\n          server.delete(metaRegionName, clientId, lockid, COL_STARTCODE);\n          server.commit(metaRegionName, clientId, lockid);\n          break;\n\n        } catch(NotServingRegionException e) {\n          if(tries == numRetries - 1) {\n            throw e;\n          }\n          continue;\n        }\n      }\n\n      if(reassignRegion) {\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"reassign region: \" + regionInfo.regionName);\n        }\n        \n        unassignedRegions.put(regionInfo.regionName, regionInfo);\n        assignAttempts.put(regionInfo.regionName, 0L);\n      }\n    }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"public void process() throws IOException {\n\n      // We can not access any meta region if they have not already been assigned\n      // and scanned.\n\n      metaScanner.waitForMetaScan();\n      \n      if(LOG.isDebugEnabled()) {\n        LOG.debug(regionName + \" open on \"\n            + new String(serverAddress.get(), UTF8_ENCODING));\n      }\n\n      // Register the newly-available Region's location.\n\n      Text metaRegionName;\n      HRegionInterface server;\n      if(rootRegion) {\n        metaRegionName = HGlobals.rootRegionInfo.regionName;\n        waitForRootRegion();            // Make sure root region available\n        server = client.getHRegionConnection(rootRegionLocation);\n        \n      } else {\n        MetaRegion r = null;\n        if(knownMetaRegions.containsKey(regionName)) {\n          r = knownMetaRegions.get(regionName);\n          \n        } else {\n          r = knownMetaRegions.get(\n              knownMetaRegions.headMap(regionName).lastKey());\n        }\n        metaRegionName = r.regionName;\n        server = client.getHRegionConnection(r.server);\n      }\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"updating row \" + regionName + \" in table \" + metaRegionName);\n      }\n      long lockid = server.startUpdate(metaRegionName, clientId, regionName);\n      server.put(metaRegionName, clientId, lockid, COL_SERVER, serverAddress);\n      server.put(metaRegionName, clientId, lockid, COL_STARTCODE, startCode);\n      server.commit(metaRegionName, clientId, lockid);\n    }","id":92752,"modified_method":"public void process() throws IOException {\n      for(int tries = 0; tries < numRetries; tries ++) {\n\n        // We can not access any meta region if they have not already been assigned\n        // and scanned.\n\n        metaScanner.waitForMetaScan();\n\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(regionName + \" open on \"\n              + new String(serverAddress.get(), UTF8_ENCODING));\n        }\n\n        // Register the newly-available Region's location.\n\n        Text metaRegionName;\n        HRegionInterface server;\n        if(rootRegion) {\n          metaRegionName = HGlobals.rootRegionInfo.regionName;\n          waitForRootRegion();            // Make sure root region available\n          server = client.getHRegionConnection(rootRegionLocation);\n\n        } else {\n          MetaRegion r = null;\n          if(knownMetaRegions.containsKey(regionName)) {\n            r = knownMetaRegions.get(regionName);\n\n          } else {\n            r = knownMetaRegions.get(\n                knownMetaRegions.headMap(regionName).lastKey());\n          }\n          metaRegionName = r.regionName;\n          server = client.getHRegionConnection(r.server);\n        }\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"updating row \" + regionName + \" in table \" + metaRegionName);\n        }\n        try {\n          long lockid = server.startUpdate(metaRegionName, clientId, regionName);\n          server.put(metaRegionName, clientId, lockid, COL_SERVER, serverAddress);\n          server.put(metaRegionName, clientId, lockid, COL_STARTCODE, startCode);\n          server.commit(metaRegionName, clientId, lockid);\n          break;\n          \n        } catch(NotServingRegionException e) {\n          if(tries == numRetries - 1) {\n            throw e;\n          }\n        }\n      }\n    }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Build the HMaster\n   * @param dir         - base directory\n   * @param address     - server address and port number\n   * @param conf        - configuration\n   * \n   * @throws IOException\n   */\n  public HMaster(Path dir, HServerAddress address, Configuration conf)\n  throws IOException {\n    this.closed = true;\n    this.dir = dir;\n    this.conf = conf;\n    this.fs = FileSystem.get(conf);\n    this.rand = new Random();\n\n    // Make sure the root directory exists!\n    \n    if(! fs.exists(dir)) {\n      fs.mkdirs(dir);\n    }\n\n    Path rootRegionDir =\n      HStoreFile.getHRegionDir(dir, HGlobals.rootRegionInfo.regionName);\n    if(! fs.exists(rootRegionDir)) {\n      LOG.info(\"bootstrap: creating ROOT and first META regions\");\n      try {\n        HRegion root = createNewHRegion(HGlobals.rootTableDesc, 0L);\n        HRegion meta = createNewHRegion(HGlobals.metaTableDesc, 1L);\n      \n        addTableToMeta(root, meta);\n        \n        root.close();\n        meta.close();\n        \n      } catch(IOException e) {\n        e.printStackTrace();\n      }\n    }\n\n    this.threadWakeFrequency = conf.getLong(THREAD_WAKE_FREQUENCY, 10 * 1000);\n    this.maxRegionOpenTime = conf.getLong(\"hbase.hbasemaster.maxregionopen\", 30 * 1000);\n    this.msgQueue = new Vector<PendingOperation>();\n    this.serverLeases = new Leases(\n        conf.getLong(\"hbase.master.lease.period\", 30 * 1000), \n        conf.getLong(\"hbase.master.lease.thread.wakefrequency\", 15 * 1000));\n    \n    this.server = RPC.getServer(this, address.getBindAddress(),\n        address.getPort(), conf.getInt(\"hbase.regionserver.handler.count\", 10),\n        false, conf);\n\n    //  The rpc-server port can be ephemeral... ensure we have the correct info\n    \n    this.address = new HServerAddress(server.getListenerAddress());\n    conf.set(MASTER_ADDRESS, address.toString());\n    \n    this.client = new HClient(conf);\n    \n    this.metaRescanInterval\n      = conf.getLong(\"hbase.master.meta.thread.rescanfrequency\", 60 * 1000);\n\n    // The root region\n    \n    this.rootRegionLocation = null;\n    this.rootScanned = false;\n    this.rootScanner = new RootScanner();\n    this.rootScannerThread = new Thread(rootScanner, \"HMaster.rootScanner\");\n    \n    // Scans the meta table\n\n    this.numMetaRegions = 0;\n    this.metaRegionsToScan = new Vector<MetaRegion>();\n    \n    this.knownMetaRegions = \n      Collections.synchronizedSortedMap(new TreeMap<Text, MetaRegion>());\n    \n    this.allMetaRegionsScanned = false;\n\n    this.metaScanner = new MetaScanner();\n    this.metaScannerThread = new Thread(metaScanner, \"HMaster.metaScanner\");\n\n    this.unassignedRegions = \n      Collections.synchronizedSortedMap(new TreeMap<Text, HRegionInfo>());\n    \n    this.unassignedRegions.put(HGlobals.rootRegionInfo.regionName, HGlobals.rootRegionInfo);\n    \n    this.assignAttempts = \n      Collections.synchronizedSortedMap(new TreeMap<Text, Long>());\n    \n    this.assignAttempts.put(HGlobals.rootRegionInfo.regionName, 0L);\n\n    this.killList = \n      Collections.synchronizedSortedMap(\n          new TreeMap<String, TreeMap<Text, HRegionInfo>>());\n    \n    // We're almost open for business\n    \n    this.closed = false;\n    \n    LOG.info(\"HMaster initialized on \" + address.toString());\n  }","id":92753,"modified_method":"/** \n   * Build the HMaster\n   * @param dir         - base directory\n   * @param address     - server address and port number\n   * @param conf        - configuration\n   * \n   * @throws IOException\n   */\n  public HMaster(Path dir, HServerAddress address, Configuration conf)\n  throws IOException {\n    this.closed = true;\n    this.dir = dir;\n    this.conf = conf;\n    this.fs = FileSystem.get(conf);\n    this.rand = new Random();\n\n    // Make sure the root directory exists!\n    \n    if(! fs.exists(dir)) {\n      fs.mkdirs(dir);\n    }\n\n    Path rootRegionDir =\n      HStoreFile.getHRegionDir(dir, HGlobals.rootRegionInfo.regionName);\n    LOG.info(\"Root region dir: \" + rootRegionDir.toString());\n    if(! fs.exists(rootRegionDir)) {\n      LOG.info(\"bootstrap: creating ROOT and first META regions\");\n      try {\n        HRegion root = createNewHRegion(HGlobals.rootTableDesc, 0L);\n        HRegion meta = createNewHRegion(HGlobals.metaTableDesc, 1L);\n      \n        addTableToMeta(root, meta);\n        \n        root.close();\n        meta.close();\n        \n      } catch(IOException e) {\n        LOG.error(e);\n      }\n    }\n\n    this.threadWakeFrequency = conf.getLong(THREAD_WAKE_FREQUENCY, 10 * 1000);\n    this.numRetries =  conf.getInt(\"hbase.client.retries.number\", 2);\n    this.maxRegionOpenTime = conf.getLong(\"hbase.hbasemaster.maxregionopen\", 30 * 1000);\n    this.msgQueue = new Vector<PendingOperation>();\n    this.serverLeases = new Leases(\n        conf.getLong(\"hbase.master.lease.period\", 30 * 1000), \n        conf.getLong(\"hbase.master.lease.thread.wakefrequency\", 15 * 1000));\n    \n    this.server = RPC.getServer(this, address.getBindAddress(),\n        address.getPort(), conf.getInt(\"hbase.regionserver.handler.count\", 10),\n        false, conf);\n\n    //  The rpc-server port can be ephemeral... ensure we have the correct info\n    \n    this.address = new HServerAddress(server.getListenerAddress());\n    conf.set(MASTER_ADDRESS, address.toString());\n    \n    this.client = new HClient(conf);\n    \n    this.metaRescanInterval\n      = conf.getLong(\"hbase.master.meta.thread.rescanfrequency\", 60 * 1000);\n\n    // The root region\n    \n    this.rootRegionLocation = null;\n    this.rootScanned = false;\n    this.rootScanner = new RootScanner();\n    this.rootScannerThread = new Thread(rootScanner, \"HMaster.rootScanner\");\n    \n    // Scans the meta table\n\n    this.numMetaRegions = 0;\n    this.metaRegionsToScan = new Vector<MetaRegion>();\n    \n    this.knownMetaRegions = \n      Collections.synchronizedSortedMap(new TreeMap<Text, MetaRegion>());\n    \n    this.allMetaRegionsScanned = false;\n\n    this.metaScanner = new MetaScanner();\n    this.metaScannerThread = new Thread(metaScanner, \"HMaster.metaScanner\");\n\n    this.unassignedRegions = \n      Collections.synchronizedSortedMap(new TreeMap<Text, HRegionInfo>());\n    \n    this.unassignedRegions.put(HGlobals.rootRegionInfo.regionName, HGlobals.rootRegionInfo);\n    \n    this.assignAttempts = \n      Collections.synchronizedSortedMap(new TreeMap<Text, Long>());\n    \n    this.assignAttempts.put(HGlobals.rootRegionInfo.regionName, 0L);\n\n    this.killList = \n      Collections.synchronizedSortedMap(\n          new TreeMap<String, TreeMap<Text, HRegionInfo>>());\n    \n    // We're almost open for business\n    \n    this.closed = false;\n    \n    LOG.info(\"HMaster initialized on \" + address.toString());\n  }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"public void process() throws IOException {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"server shutdown: \" + deadServer);\n      }\n\n      // Scan the ROOT region\n      \n      waitForRootRegion();      // Wait until the root region is available\n      HRegionInterface server = client.getHRegionConnection(rootRegionLocation);\n      long scannerId = \n        server.openScanner(HGlobals.rootRegionInfo.regionName, columns, startRow);\n      \n      scanMetaRegion(server, scannerId, HGlobals.rootRegionInfo.regionName);\n\n      // We can not scan every meta region if they have not already been assigned\n      // and scanned.\n\n      metaScanner.waitForMetaScan();\n      \n      for(Iterator<MetaRegion> i = knownMetaRegions.values().iterator();\n          i.hasNext(); ) {\n        \n        MetaRegion r = i.next();\n\n        server = client.getHRegionConnection(r.server);\n        scannerId = server.openScanner(r.regionName, columns, startRow);\n        scanMetaRegion(server, scannerId, r.regionName);\n      }\n    }","id":92754,"modified_method":"public void process() throws IOException {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"server shutdown: \" + deadServer);\n      }\n\n      // Scan the ROOT region\n\n      HRegionInterface server = null;\n      long scannerId = -1L;\n      for(int tries = 0; tries < numRetries; tries ++) {\n        waitForRootRegion();      // Wait until the root region is available\n        server = client.getHRegionConnection(rootRegionLocation);\n        scannerId = -1L;\n        \n        try {\n          scannerId = server.openScanner(HGlobals.rootRegionInfo.regionName, columns, startRow);\n          scanMetaRegion(server, scannerId, HGlobals.rootRegionInfo.regionName);\n          break;\n          \n        } catch(NotServingRegionException e) {\n          if(tries == numRetries - 1) {\n            throw e;\n          }\n        }\n      }\n\n      // We can not scan every meta region if they have not already been assigned\n      // and scanned.\n\n      for(int tries = 0; tries < numRetries; tries ++) {\n        try {\n          metaScanner.waitForMetaScan();\n      \n          for(Iterator<MetaRegion> i = knownMetaRegions.values().iterator();\n              i.hasNext(); ) {\n          \n            server = null;\n            scannerId = -1L;\n            MetaRegion r = i.next();\n\n            server = client.getHRegionConnection(r.server);\n          \n            scannerId = server.openScanner(r.regionName, columns, startRow);\n            scanMetaRegion(server, scannerId, r.regionName);\n            \n          }\n          break;\n            \n        } catch(NotServingRegionException e) {\n          if(tries == numRetries - 1) {\n            throw e;\n          }\n        }\n      }\n    }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"public void run() {\n    Thread.currentThread().setName(\"HMaster\");\n    try { \n      // Start things up\n      this.rootScannerThread.start();\n      this.metaScannerThread.start();\n\n      // Start the server last so everything else is running before we start\n      // receiving requests\n      this.server.start();\n    } catch(IOException e) {\n      // Something happened during startup. Shut things down.\n      this.closed = true;\n      e.printStackTrace();\n    }\n\n    // Main processing loop\n    for(PendingOperation op = null; !closed; ) {\n      synchronized(msgQueue) {\n        while(msgQueue.size() == 0 && !closed) {\n          try {\n            msgQueue.wait(threadWakeFrequency);\n          } catch(InterruptedException iex) {\n          }\n        }\n        if(closed) {\n          continue;\n        }\n        op = msgQueue.remove(msgQueue.size()-1);\n      }\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Processing \" + op.toString());\n        }\n        op.process();\n      } catch(Exception ex) {\n        msgQueue.insertElementAt(op, 0);\n      }\n    }\n\n    /*\n     * Clean up and close up shop\n     */\n\n    // Wake other threads so they notice the close\n\n    synchronized(rootScannerLock) {\n      rootScannerThread.interrupt();\n    }\n    synchronized(metaScannerLock) {\n      metaScannerThread.interrupt();\n    }\n    server.stop();                              // Stop server\n    serverLeases.close();                       // Turn off the lease monitor\n    \n    // Join up with all threads\n    \n    try {\n      // Wait for the root scanner to finish.\n      rootScannerThread.join();\n    } catch(Exception iex) {\n      // Print if ever there is an interrupt (Just for kicks. Remove if it\n      // ever happens).\n      iex.printStackTrace();\n    }\n    try {\n      // Join the thread till it finishes.\n      metaScannerThread.join();\n    } catch(Exception iex) {\n      // Print if ever there is an interrupt (Just for kicks. Remove if it\n      // ever happens).\n      iex.printStackTrace();\n    }\n    try {\n      // Join until its finished.  TODO: Maybe do in parallel in its own thread\n      // as is done in TaskTracker if its taking a long time to go down.\n      server.join();\n    } catch(InterruptedException iex) {\n      // Print if ever there is an interrupt (Just for kicks. Remove if it\n      // ever happens).\n      iex.printStackTrace();\n    }\n    \n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"HMaster main thread exiting\");\n    }\n  }","id":92755,"modified_method":"public void run() {\n    Thread.currentThread().setName(\"HMaster\");\n    try { \n      // Start things up\n      this.rootScannerThread.start();\n      this.metaScannerThread.start();\n\n      // Start the server last so everything else is running before we start\n      // receiving requests\n      this.server.start();\n    } catch(IOException e) {\n      // Something happened during startup. Shut things down.\n      this.closed = true;\n      LOG.error(e);\n    }\n\n    // Main processing loop\n    for(PendingOperation op = null; !closed; ) {\n      synchronized(msgQueue) {\n        while(msgQueue.size() == 0 && !closed) {\n          try {\n            msgQueue.wait(threadWakeFrequency);\n          } catch(InterruptedException iex) {\n          }\n        }\n        if(closed) {\n          continue;\n        }\n        op = msgQueue.remove(msgQueue.size()-1);\n      }\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Processing \" + op.toString());\n        }\n        op.process();\n      } catch(Exception ex) {\n        msgQueue.insertElementAt(op, 0);\n      }\n    }\n\n    /*\n     * Clean up and close up shop\n     */\n\n    // Wake other threads so they notice the close\n\n    synchronized(rootScannerLock) {\n      rootScannerThread.interrupt();\n    }\n    synchronized(metaScannerLock) {\n      metaScannerThread.interrupt();\n    }\n    server.stop();                              // Stop server\n    serverLeases.close();                       // Turn off the lease monitor\n    \n    // Join up with all threads\n    \n    try {\n      // Wait for the root scanner to finish.\n      rootScannerThread.join();\n    } catch(Exception iex) {\n      // Print if ever there is an interrupt (Just for kicks. Remove if it\n      // ever happens).\n      LOG.warn(iex);\n    }\n    try {\n      // Join the thread till it finishes.\n      metaScannerThread.join();\n    } catch(Exception iex) {\n      // Print if ever there is an interrupt (Just for kicks. Remove if it\n      // ever happens).\n      LOG.warn(iex);\n    }\n    try {\n      // Join until its finished.  TODO: Maybe do in parallel in its own thread\n      // as is done in TaskTracker if its taking a long time to go down.\n      server.join();\n    } catch(InterruptedException iex) {\n      // Print if ever there is an interrupt (Just for kicks. Remove if it\n      // ever happens).\n      LOG.warn(iex);\n    }\n    \n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"HMaster main thread exiting\");\n    }\n  }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"public PendingOpenReport(HServerInfo info, Text regionName) {\n      if(regionName.find(HGlobals.metaTableDesc.getName().toString()) == 0) {\n        \n        // The region which just came on-line is a META region.\n        // We need to look in the ROOT region for its information.\n        \n        this.rootRegion = true;\n        \n      } else {\n        \n        // Just an ordinary region. Look for it in the META table.\n        \n        this.rootRegion = false;\n      }\n      this.regionName = regionName;\n      \n      try {\n        this.serverAddress = new BytesWritable(\n            info.getServerAddress().toString().getBytes(UTF8_ENCODING));\n        \n        this.startCode = new BytesWritable(\n            String.valueOf(info.getStartCode()).getBytes(UTF8_ENCODING));\n        \n      } catch(UnsupportedEncodingException e) {\n        e.printStackTrace();\n      }\n\n    }","id":92756,"modified_method":"public PendingOpenReport(HServerInfo info, Text regionName) {\n      if(regionName.find(HGlobals.metaTableDesc.getName().toString()) == 0) {\n        \n        // The region which just came on-line is a META region.\n        // We need to look in the ROOT region for its information.\n        \n        this.rootRegion = true;\n        \n      } else {\n        \n        // Just an ordinary region. Look for it in the META table.\n        \n        this.rootRegion = false;\n      }\n      this.regionName = regionName;\n      \n      try {\n        this.serverAddress = new BytesWritable(\n            info.getServerAddress().toString().getBytes(UTF8_ENCODING));\n        \n        this.startCode = new BytesWritable(\n            String.valueOf(info.getStartCode()).getBytes(UTF8_ENCODING));\n        \n      } catch(UnsupportedEncodingException e) {\n        LOG.error(e);\n      }\n\n    }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"public void run() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Running ROOT scanner\");\n      }\n      try {\n        while(!closed) {\n          // rootRegionLocation will be filled in when we get an 'open region'\n          // regionServerReport message from the HRegionServer that has been\n          // allocated the ROOT region below.  If we get back false, then\n          // HMaster has closed.\n          if (waitForRootRegionOrClose()) {\n            continue;\n          }\n          synchronized(rootScannerLock) { // Don't interrupt us while we're working\n            rootScanned = false;\n            // Make a MetaRegion instance for ROOT region to pass scanRegion.\n            MetaRegion mr = new MetaRegion();\n            mr.regionName = HGlobals.rootRegionInfo.regionName;\n            mr.server = HMaster.this.rootRegionLocation;\n            mr.startKey = null;\n            if (scanRegion(mr)) {\n              numMetaRegions += 1;\n            }\n            rootScanned = true;\n          }\n          try {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"RootScanner going to sleep\");\n            }\n            Thread.sleep(metaRescanInterval);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"RootScanner woke up\");\n            }\n          } catch(InterruptedException e) {\n            // Catch and go around again. If interrupt, its spurious or we're\n            // being shutdown.  Go back up to the while test.\n          }\n        }\n      } catch(IOException e) {\n        e.printStackTrace();\n        closed = true;\n      }\n      LOG.debug(\"ROOT scanner exiting\");\n    }","id":92757,"modified_method":"public void run() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Running ROOT scanner\");\n      }\n      try {\n        while(!closed) {\n          // rootRegionLocation will be filled in when we get an 'open region'\n          // regionServerReport message from the HRegionServer that has been\n          // allocated the ROOT region below.  If we get back false, then\n          // HMaster has closed.\n          if (waitForRootRegionOrClose()) {\n            continue;\n          }\n          synchronized(rootScannerLock) { // Don't interrupt us while we're working\n            rootScanned = false;\n            // Make a MetaRegion instance for ROOT region to pass scanRegion.\n            MetaRegion mr = new MetaRegion();\n            mr.regionName = HGlobals.rootRegionInfo.regionName;\n            mr.server = HMaster.this.rootRegionLocation;\n            mr.startKey = null;\n            if (scanRegion(mr)) {\n              numMetaRegions += 1;\n            }\n            rootScanned = true;\n          }\n          try {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"RootScanner going to sleep\");\n            }\n            Thread.sleep(metaRescanInterval);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"RootScanner woke up\");\n            }\n          } catch(InterruptedException e) {\n            // Catch and go around again. If interrupt, its spurious or we're\n            // being shutdown.  Go back up to the while test.\n          }\n        }\n      } catch(IOException e) {\n        LOG.error(e);\n        closed = true;\n      }\n      LOG.debug(\"ROOT scanner exiting\");\n    }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"public void createTable(HTableDescriptor desc) throws IOException {\n    if (!isMasterRunning()) {\n      throw new IllegalStateException(MASTER_NOT_RUNNING);\n    }\n    HRegionInfo newRegion = new HRegionInfo(rand.nextLong(), desc, null, null);\n    \n    // We can not access any meta region if they have not already been assigned\n    // and scanned.\n\n    metaScanner.waitForMetaScan();\n    \n    // 1. Check to see if table already exists\n\n    MetaRegion m = null;\n    if(knownMetaRegions.containsKey(newRegion.regionName)) {\n      m = knownMetaRegions.get(newRegion.regionName);\n      \n    } else {\n      m = knownMetaRegions.get(\n          knownMetaRegions.headMap(newRegion.regionName).lastKey());\n    }\n    Text metaRegionName = m.regionName;\n    HRegionInterface server = client.getHRegionConnection(m.server);\n\n\n    BytesWritable bytes = server.get(metaRegionName, desc.getName(), COL_REGIONINFO);\n    if(bytes != null && bytes.getSize() != 0) {\n      byte[] infoBytes = bytes.get();\n      DataInputBuffer inbuf = new DataInputBuffer();\n      inbuf.reset(infoBytes, infoBytes.length);\n      HRegionInfo info = new HRegionInfo();\n      info.readFields(inbuf);\n      if(info.tableDesc.getName().compareTo(desc.getName()) == 0) {\n        throw new IOException(\"table already exists\");\n      }\n    }\n    \n    // 2. Create the HRegion\n    \n    HRegion r = createNewHRegion(desc, newRegion.regionId);\n    \n    // 3. Insert into meta\n    \n    HRegionInfo info = r.getRegionInfo();\n    Text regionName = r.getRegionName();\n    ByteArrayOutputStream byteValue = new ByteArrayOutputStream();\n    DataOutputStream s = new DataOutputStream(byteValue);\n    info.write(s);\n\n    long clientId = rand.nextLong();\n    long lockid = server.startUpdate(metaRegionName, clientId, regionName);\n    server.put(metaRegionName, clientId, lockid, COL_REGIONINFO, \n        new BytesWritable(byteValue.toByteArray()));\n    server.commit(metaRegionName, clientId, lockid);\n    \n    // 4. Close the new region to flush it to disk\n    \n    r.close();\n    \n    // 5. Get it assigned to a server\n    \n    unassignedRegions.put(regionName, info);\n    assignAttempts.put(regionName, 0L);\n    \n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"created table \" + desc.getName());\n    }\n  }","id":92758,"modified_method":"public void createTable(HTableDescriptor desc) throws IOException {\n    if (!isMasterRunning()) {\n      throw new IllegalStateException(MASTER_NOT_RUNNING);\n    }\n    HRegionInfo newRegion = new HRegionInfo(rand.nextLong(), desc, null, null);\n\n    for(int tries = 0; tries < numRetries; tries++) {\n      try {\n        // We can not access any meta region if they have not already been assigned\n        // and scanned.\n\n        metaScanner.waitForMetaScan();\n\n        // 1. Check to see if table already exists\n\n        MetaRegion m = null;\n        if(knownMetaRegions.containsKey(newRegion.regionName)) {\n          m = knownMetaRegions.get(newRegion.regionName);\n\n        } else {\n          m = knownMetaRegions.get(\n              knownMetaRegions.headMap(newRegion.regionName).lastKey());\n        }\n        Text metaRegionName = m.regionName;\n        HRegionInterface server = client.getHRegionConnection(m.server);\n\n\n        BytesWritable bytes = server.get(metaRegionName, desc.getName(), COL_REGIONINFO);\n        if(bytes != null && bytes.getSize() != 0) {\n          byte[] infoBytes = bytes.get();\n          DataInputBuffer inbuf = new DataInputBuffer();\n          inbuf.reset(infoBytes, infoBytes.length);\n          HRegionInfo info = new HRegionInfo();\n          info.readFields(inbuf);\n          if(info.tableDesc.getName().compareTo(desc.getName()) == 0) {\n            throw new IOException(\"table already exists\");\n          }\n        }\n\n        // 2. Create the HRegion\n\n        HRegion r = createNewHRegion(desc, newRegion.regionId);\n\n        // 3. Insert into meta\n\n        HRegionInfo info = r.getRegionInfo();\n        Text regionName = r.getRegionName();\n        ByteArrayOutputStream byteValue = new ByteArrayOutputStream();\n        DataOutputStream s = new DataOutputStream(byteValue);\n        info.write(s);\n\n        long clientId = rand.nextLong();\n        long lockid = server.startUpdate(metaRegionName, clientId, regionName);\n        server.put(metaRegionName, clientId, lockid, COL_REGIONINFO, \n            new BytesWritable(byteValue.toByteArray()));\n        server.commit(metaRegionName, clientId, lockid);\n\n        // 4. Close the new region to flush it to disk\n\n        r.close();\n\n        // 5. Get it assigned to a server\n\n        unassignedRegions.put(regionName, info);\n        assignAttempts.put(regionName, 0L);\n        break;\n\n      } catch(NotServingRegionException e) {\n        if(tries == numRetries - 1) {\n          throw e;\n        }\n      }\n    }\n    \n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"created table \" + desc.getName());\n    }\n  }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"public void run() {\n      while (!closed) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Running META scanner\");\n        }\n        MetaRegion region = null;\n        while (region == null && !closed) {\n          synchronized (metaRegionsToScan) {\n            if (metaRegionsToScan.size() != 0) {\n              region = metaRegionsToScan.remove(0);\n            }\n            if (region == null) {\n              try {\n                if (LOG.isDebugEnabled()) {\n                  LOG.debug(\"MetaScanner going into wait\");\n                }\n                metaRegionsToScan.wait();\n                if (LOG.isDebugEnabled()) {\n                  LOG.debug(\"MetaScanner woke up\");\n                }\n              } catch (InterruptedException e) {\n                // Catch and go around again.  We've been woken because there\n                // are new meta regions available or because we are being\n                // shut down.\n              }\n            }\n          }\n        }\n        if (closed) {\n          continue;\n        }\n        try {\n          synchronized(metaScannerLock) { // Don't interrupt us while we're working\n            scanRegion(region);\n            knownMetaRegions.put(region.startKey, region);\n            if (rootScanned && knownMetaRegions.size() == numMetaRegions) {\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"all meta regions scanned\");\n              }\n              allMetaRegionsScanned = true;\n              metaRegionsScanned();\n            }\n          }\n\n          do {\n            try {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sleep for meta rescan interval\");\n              }\n              Thread.sleep(metaRescanInterval);\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sleep for meta rescan interval\");\n              }\n            } catch(InterruptedException ex) {\n              // Catch and go around again.\n            }\n            if(!allMetaRegionsScanned         // A meta region must have split\n                || closed) {                  // We're shutting down\n              break;\n            }\n\n            // Rescan the known meta regions every so often\n\n            synchronized(metaScannerLock) { // Don't interrupt us while we're working\n              Vector<MetaRegion> v = new Vector<MetaRegion>();\n              v.addAll(knownMetaRegions.values());\n              for(Iterator<MetaRegion> i = v.iterator(); i.hasNext(); ) {\n                scanRegion(i.next());\n              }\n            }\n          } while(true);\n\n        } catch(IOException e) {\n          e.printStackTrace();\n          closed = true;\n        }\n      }\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"META scanner exiting\");\n      }\n    }","id":92759,"modified_method":"public void run() {\n      while (!closed) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Running META scanner\");\n        }\n        MetaRegion region = null;\n        while (region == null && !closed) {\n          synchronized (metaRegionsToScan) {\n            if (metaRegionsToScan.size() != 0) {\n              region = metaRegionsToScan.remove(0);\n            }\n            if (region == null) {\n              try {\n                if (LOG.isDebugEnabled()) {\n                  LOG.debug(\"MetaScanner going into wait\");\n                }\n                metaRegionsToScan.wait();\n                if (LOG.isDebugEnabled()) {\n                  LOG.debug(\"MetaScanner woke up\");\n                }\n              } catch (InterruptedException e) {\n                // Catch and go around again.  We've been woken because there\n                // are new meta regions available or because we are being\n                // shut down.\n              }\n            }\n          }\n        }\n        if (closed) {\n          continue;\n        }\n        try {\n          synchronized(metaScannerLock) { // Don't interrupt us while we're working\n            scanRegion(region);\n            knownMetaRegions.put(region.startKey, region);\n            if (rootScanned && knownMetaRegions.size() == numMetaRegions) {\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"all meta regions scanned\");\n              }\n              allMetaRegionsScanned = true;\n              metaRegionsScanned();\n            }\n          }\n\n          do {\n            try {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sleep for meta rescan interval\");\n              }\n              Thread.sleep(metaRescanInterval);\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sleep for meta rescan interval\");\n              }\n            } catch(InterruptedException ex) {\n              // Catch and go around again.\n            }\n            if(!allMetaRegionsScanned         // A meta region must have split\n                || closed) {                  // We're shutting down\n              break;\n            }\n\n            // Rescan the known meta regions every so often\n\n            synchronized(metaScannerLock) { // Don't interrupt us while we're working\n              Vector<MetaRegion> v = new Vector<MetaRegion>();\n              v.addAll(knownMetaRegions.values());\n              for(Iterator<MetaRegion> i = v.iterator(); i.hasNext(); ) {\n                scanRegion(i.next());\n              }\n            }\n          } while(true);\n\n        } catch(IOException e) {\n          LOG.error(e);\n          closed = true;\n        }\n      }\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"META scanner exiting\");\n      }\n    }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"protected boolean scanRegion(final MetaRegion region)\n    throws IOException {\n      boolean scannedRegion = false;\n      HRegionInterface server = null;\n      long scannerId = -1L;\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"scanning meta region \" + region.regionName);\n      }\n\n      try {\n        server = client.getHRegionConnection(region.server);\n        scannerId = server.openScanner(region.regionName, METACOLUMNS, FIRST_ROW);\n\n        DataInputBuffer inbuf = new DataInputBuffer();\n        while (true) {\n          TreeMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n          HStoreKey key = new HStoreKey();\n\n          LabelledData[] values = server.next(scannerId, key);\n\n          if (values.length == 0) {\n            break;\n          }\n\n          for (int i = 0; i < values.length; i++) {\n            results.put(values[i].getLabel(), values[i].getData().get());\n          }\n\n          HRegionInfo info = getRegionInfo(COL_REGIONINFO, results, inbuf);\n          String serverName = getServerName(COL_SERVER, results);\n          long startCode = getStartCode(COL_STARTCODE, results);\n\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"row: \" + info.toString() + \", server: \" + serverName\n                + \", startCode: \" + startCode);\n          }\n\n          // Note Region has been assigned.\n          checkAssigned(info, serverName, startCode);\n\n          scannedRegion = true;\n        }\n      } finally {\n        try {\n          if (scannerId != -1L) {\n            server.close(scannerId);\n          }\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        scannerId = -1L;\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"scan of meta region \" + region.regionName + \" complete\");\n      }\n      return scannedRegion;\n    }","id":92760,"modified_method":"protected boolean scanRegion(final MetaRegion region)\n    throws IOException {\n      boolean scannedRegion = false;\n      HRegionInterface server = null;\n      long scannerId = -1L;\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"scanning meta region \" + region.regionName);\n      }\n\n      try {\n        server = client.getHRegionConnection(region.server);\n        scannerId = server.openScanner(region.regionName, METACOLUMNS, FIRST_ROW);\n\n        DataInputBuffer inbuf = new DataInputBuffer();\n        while (true) {\n          TreeMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n          HStoreKey key = new HStoreKey();\n\n          LabelledData[] values = server.next(scannerId, key);\n\n          if (values.length == 0) {\n            break;\n          }\n\n          for (int i = 0; i < values.length; i++) {\n            results.put(values[i].getLabel(), values[i].getData().get());\n          }\n\n          HRegionInfo info = getRegionInfo(COL_REGIONINFO, results, inbuf);\n          String serverName = getServerName(COL_SERVER, results);\n          long startCode = getStartCode(COL_STARTCODE, results);\n\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"row: \" + info.toString() + \", server: \" + serverName\n                + \", startCode: \" + startCode);\n          }\n\n          // Note Region has been assigned.\n          checkAssigned(info, serverName, startCode);\n\n          scannedRegion = true;\n        }\n      } finally {\n        try {\n          if (scannerId != -1L) {\n            server.close(scannerId);\n          }\n        } catch (IOException e) {\n          LOG.error(e);\n        }\n        scannerId = -1L;\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"scan of meta region \" + region.regionName + \" complete\");\n      }\n      return scannedRegion;\n    }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"private void scanMetaRegion(HRegionInterface server, long scannerId,\n        Text regionName) throws IOException {\n\n      Vector<HStoreKey> toDoList = new Vector<HStoreKey>();\n      TreeMap<Text, HRegionInfo> regions = new TreeMap<Text, HRegionInfo>();\n\n      DataInputBuffer inbuf = new DataInputBuffer();\n      try {\n        LabelledData[] values = null;\n\n        while(true) {\n          HStoreKey key = new HStoreKey();\n          values = server.next(scannerId, key);\n          if(values.length == 0) {\n            break;\n          }\n\n          TreeMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n          for(int i = 0; i < values.length; i++) {\n            results.put(values[i].getLabel(), values[i].getData().get());\n          }\n          \n          byte[] bytes = results.get(COL_SERVER); \n          String serverName = null;\n          if(bytes == null || bytes.length == 0) {\n            // No server\n            continue;\n          }\n          serverName = new String(bytes, UTF8_ENCODING);\n\n          if(deadServer.compareTo(serverName) != 0) {\n            // This isn't the server you're looking for - move along\n            continue;\n          }\n\n          bytes = results.get(COL_STARTCODE);\n          if(bytes == null || bytes.length == 0) {\n            // No start code\n            continue;\n          }\n          long startCode = Long.valueOf(new String(bytes, UTF8_ENCODING));\n\n          if(oldStartCode != startCode) {\n            // Close but no cigar\n            continue;\n          }\n\n          // Bingo! Found it.\n\n          bytes = results.get(COL_REGIONINFO);\n          if(bytes == null || bytes.length == 0) {\n            throw new IOException(\"no value for \" + COL_REGIONINFO);\n          }\n          inbuf.reset(bytes, bytes.length);\n          HRegionInfo info = new HRegionInfo();\n          info.readFields(inbuf);\n\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(serverName + \" was serving \" + info.regionName);\n          }\n          \n          // Add to our to do lists\n\n          toDoList.add(key);\n          regions.put(info.regionName, info);\n        }\n\n      } finally {\n        if(scannerId != -1L) {\n          try {\n            server.close(scannerId);\n            \n          } catch(IOException e) {\n            e.printStackTrace();\n            \n          }\n        }\n        scannerId = -1L;\n      }\n\n      // Remove server from root/meta entries\n\n      for(int i = 0; i < toDoList.size(); i++) {\n        long lockid = server.startUpdate(regionName, clientId, toDoList.get(i).getRow());\n        server.delete(regionName, clientId, lockid, COL_SERVER);\n        server.delete(regionName, clientId, lockid, COL_STARTCODE);\n        server.commit(regionName, clientId, lockid);\n      }\n\n      // Put all the regions we found on the unassigned region list\n\n      for(Iterator<Map.Entry<Text, HRegionInfo>> i = regions.entrySet().iterator();\n          i.hasNext(); ) {\n\n        Map.Entry<Text, HRegionInfo> e = i.next();\n        Text region = e.getKey();\n        HRegionInfo regionInfo = e.getValue();\n\n        unassignedRegions.put(region, regionInfo);\n        assignAttempts.put(region, 0L);\n      }\n    }","id":92761,"modified_method":"private void scanMetaRegion(HRegionInterface server, long scannerId,\n        Text regionName) throws IOException {\n\n      Vector<HStoreKey> toDoList = new Vector<HStoreKey>();\n      TreeMap<Text, HRegionInfo> regions = new TreeMap<Text, HRegionInfo>();\n\n      DataInputBuffer inbuf = new DataInputBuffer();\n      try {\n        while(true) {\n          LabelledData[] values = null;\n          \n          HStoreKey key = new HStoreKey();\n          try {\n            values = server.next(scannerId, key);\n            \n          } catch(NotServingRegionException e) {\n            throw e;\n            \n          } catch(IOException e) {\n            LOG.error(e);\n            break;\n          }\n          \n          if(values == null || values.length == 0) {\n            break;\n          }\n\n          TreeMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n          for(int i = 0; i < values.length; i++) {\n            results.put(values[i].getLabel(), values[i].getData().get());\n          }\n          \n          byte[] bytes = results.get(COL_SERVER); \n          String serverName = null;\n          if(bytes == null || bytes.length == 0) {\n            // No server\n            continue;\n          }\n          try {\n            serverName = new String(bytes, UTF8_ENCODING);\n            \n          } catch(UnsupportedEncodingException e) {\n            LOG.error(e);\n            break;\n          }\n\n          if(deadServer.compareTo(serverName) != 0) {\n            // This isn't the server you're looking for - move along\n            continue;\n          }\n\n          bytes = results.get(COL_STARTCODE);\n          if(bytes == null || bytes.length == 0) {\n            // No start code\n            continue;\n          }\n          long startCode = -1L;\n          \n          try {\n            startCode = Long.valueOf(new String(bytes, UTF8_ENCODING));\n\n          } catch(UnsupportedEncodingException e) {\n            LOG.error(e);\n            break;\n          }\n\n          if(oldStartCode != startCode) {\n            // Close but no cigar\n            continue;\n          }\n\n          // Bingo! Found it.\n\n          bytes = results.get(COL_REGIONINFO);\n          if(bytes == null || bytes.length == 0) {\n            throw new IOException(\"no value for \" + COL_REGIONINFO);\n          }\n          inbuf.reset(bytes, bytes.length);\n          HRegionInfo info = new HRegionInfo();\n          \n          try {\n            info.readFields(inbuf);\n            \n          } catch(IOException e) {\n            LOG.error(e);\n            break;\n          }\n\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(serverName + \" was serving \" + info.regionName);\n          }\n          \n          // Add to our to do lists\n\n          toDoList.add(key);\n          regions.put(info.regionName, info);\n        }\n\n      } finally {\n        if(scannerId != -1L) {\n          try {\n            server.close(scannerId);\n            \n          } catch(IOException e) {\n            LOG.error(e);\n            \n          }\n        }\n        scannerId = -1L;\n      }\n\n      // Remove server from root/meta entries\n\n      for(int i = 0; i < toDoList.size(); i++) {\n        long lockid = server.startUpdate(regionName, clientId, toDoList.get(i).getRow());\n        server.delete(regionName, clientId, lockid, COL_SERVER);\n        server.delete(regionName, clientId, lockid, COL_STARTCODE);\n        server.commit(regionName, clientId, lockid);\n      }\n\n      // Put all the regions we found on the unassigned region list\n\n      for(Iterator<Map.Entry<Text, HRegionInfo>> i = regions.entrySet().iterator();\n          i.hasNext(); ) {\n\n        Map.Entry<Text, HRegionInfo> e = i.next();\n        Text region = e.getKey();\n        HRegionInfo regionInfo = e.getValue();\n\n        unassignedRegions.put(region, regionInfo);\n        assignAttempts.put(region, 0L);\n      }\n    }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"public void deleteTable(Text tableName) throws IOException {\n    if (!isMasterRunning()) {\n      throw new IllegalStateException(MASTER_NOT_RUNNING);\n    }\n    \n    // We can not access any meta region if they have not already been assigned\n    // and scanned.\n\n    metaScanner.waitForMetaScan();\n    \n    Text firstMetaRegion = null;\n    if(knownMetaRegions.size() == 1) {\n      firstMetaRegion = knownMetaRegions.firstKey();\n      \n    } else if(knownMetaRegions.containsKey(tableName)) {\n      firstMetaRegion = tableName;\n      \n    } else {\n      firstMetaRegion = knownMetaRegions.headMap(tableName).lastKey();\n    }\n\n    synchronized(metaScannerLock) {     // Prevent meta scanner from running\n      for(Iterator<MetaRegion> it =\n          knownMetaRegions.tailMap(firstMetaRegion).values().iterator();\n          it.hasNext(); ) {\n\n        // Find all the regions that make up this table\n\n        MetaRegion m = it.next();\n        HRegionInterface server = client.getHRegionConnection(m.server);\n\n        // Rows in the meta table we will need to delete\n\n        Vector<Text> rowsToDelete = new Vector<Text>();\n\n        // Regions that are being served. We will get the HRegionServers\n        // to delete them for us, but we don't tell them that until after\n        // we are done scanning to prevent lock contention\n\n        TreeMap<String, TreeMap<Text, HRegionInfo>> localKillList =\n          new TreeMap<String, TreeMap<Text, HRegionInfo>>();\n\n        // Regions that are not being served. We will have to delete\n        // them ourselves\n\n        TreeSet<Text> unservedRegions = new TreeSet<Text>();\n\n        long scannerId = -1L;\n        try {\n          scannerId = server.openScanner(m.regionName, METACOLUMNS, tableName);\n\n\n          DataInputBuffer inbuf = new DataInputBuffer();\n          byte[] bytes;\n          while(true) {\n            LabelledData[] values = null;\n            HStoreKey key = new HStoreKey();\n            values = server.next(scannerId, key);\n            if(values == null || values.length == 0) {\n              break;\n            }\n            TreeMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n            for(int i = 0; i < values.length; i++) {\n              bytes = new byte[values[i].getData().getSize()];\n              System.arraycopy(values[i].getData().get(), 0, bytes, 0, bytes.length);\n              results.put(values[i].getLabel(), bytes);\n            }\n            bytes = results.get(COL_REGIONINFO);\n            if(bytes == null || bytes.length == 0) {\n              break;\n            }\n            inbuf.reset(bytes, bytes.length);\n            HRegionInfo info = new HRegionInfo();\n            info.readFields(inbuf);\n\n            if(info.tableDesc.getName().compareTo(tableName) > 0) {\n              break;                      // Beyond any more entries for this table\n            }\n\n            rowsToDelete.add(info.regionName);\n\n            // Is it being served?\n\n            bytes = results.get(COL_SERVER);\n            if(bytes != null && bytes.length != 0) {\n              String serverName = new String(bytes, UTF8_ENCODING);\n\n              bytes = results.get(COL_STARTCODE);\n              if(bytes != null && bytes.length != 0) {\n                long startCode = Long.valueOf(new String(bytes, UTF8_ENCODING));\n\n                HServerInfo s = serversToServerInfo.get(serverName);\n                if(s != null && s.getStartCode() == startCode) {\n\n                  // It is being served.\n                  // Tell the server to stop it and not report back.\n\n                  TreeMap<Text, HRegionInfo> regionsToKill =\n                    localKillList.get(serverName);\n\n                  if(regionsToKill == null) {\n                    regionsToKill = new TreeMap<Text, HRegionInfo>();\n                  }\n                  regionsToKill.put(info.regionName, info);\n                  localKillList.put(serverName, regionsToKill);\n                  continue;\n                }\n              }\n            }\n            \n            // Region is not currently being served.\n            // Prevent it from getting assigned and add it to the list of\n            // regions we need to delete here.\n            \n            unassignedRegions.remove(info.regionName);\n            assignAttempts.remove(info.regionName);\n            unservedRegions.add(info.regionName);\n          }\n          \n        } catch(IOException e) {\n          e.printStackTrace();\n\n        } finally {\n          if(scannerId != -1L) {\n            try {\n              server.close(scannerId);\n\n            } catch(IOException e) {\n              e.printStackTrace();\n\n            }\n          }\n          scannerId = -1L;\n        }\n\n        // Wipe the existence of the regions out of the meta table\n        \n        for(Iterator<Text> row = rowsToDelete.iterator(); row.hasNext(); ) {\n          Text rowName = row.next();\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"deleting columns in row: \" + rowName);\n          }\n          long lockid = -1L;\n          long clientId = rand.nextLong();\n          try {\n            lockid = server.startUpdate(m.regionName, clientId, rowName);\n            server.delete(m.regionName, clientId, lockid, COL_REGIONINFO);\n            server.delete(m.regionName, clientId, lockid, COL_SERVER);\n            server.delete(m.regionName, clientId, lockid, COL_STARTCODE);\n            server.commit(m.regionName, clientId, lockid);\n            lockid = -1L;\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"deleted columns in row: \" + rowName);\n            }\n\n          } catch(Exception e) {\n            if(lockid != -1L) {\n              server.abort(m.regionName, clientId, lockid);\n            }\n            LOG.error(\"columns deletion failed in row: \" + rowName);\n            LOG.error(e);\n          }\n        }\n        \n        // Notify region servers that some regions need to be closed and deleted\n        \n        if(localKillList.size() != 0) {\n          killList.putAll(localKillList);\n        }\n\n        // Delete any regions that are not being served\n        \n        for(Iterator<Text> i = unservedRegions.iterator(); i.hasNext(); ) {\n          Text regionName = i.next();\n          try {\n            HRegion.deleteRegion(fs, dir, regionName);\n            \n          } catch(IOException e) {\n            LOG.error(\"failed to delete region \" + regionName);\n            LOG.error(e);\n          }\n        }\n      }\n    }\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"deleted table: \" + tableName);\n    }\n  }","id":92762,"modified_method":"public void deleteTable(Text tableName) throws IOException {\n    if (!isMasterRunning()) {\n      throw new IllegalStateException(MASTER_NOT_RUNNING);\n    }\n\n    for(int tries = 0; tries < numRetries; tries++) {\n      try {\n        // We can not access any meta region if they have not already been\n        // assigned and scanned.\n\n        metaScanner.waitForMetaScan();\n\n        Text firstMetaRegion = null;\n        if(knownMetaRegions.size() == 1) {\n          firstMetaRegion = knownMetaRegions.firstKey();\n\n        } else if(knownMetaRegions.containsKey(tableName)) {\n          firstMetaRegion = tableName;\n\n        } else {\n          firstMetaRegion = knownMetaRegions.headMap(tableName).lastKey();\n        }\n\n        synchronized(metaScannerLock) {     // Prevent meta scanner from running\n          for(Iterator<MetaRegion> it =\n              knownMetaRegions.tailMap(firstMetaRegion).values().iterator();\n              it.hasNext(); ) {\n\n            // Find all the regions that make up this table\n\n            MetaRegion m = it.next();\n            HRegionInterface server = client.getHRegionConnection(m.server);\n\n            // Rows in the meta table we will need to delete\n\n            Vector<Text> rowsToDelete = new Vector<Text>();\n\n            // Regions that are being served. We will get the HRegionServers\n            // to delete them for us, but we don't tell them that until after\n            // we are done scanning to prevent lock contention\n\n            TreeMap<String, TreeMap<Text, HRegionInfo>> localKillList =\n              new TreeMap<String, TreeMap<Text, HRegionInfo>>();\n\n            // Regions that are not being served. We will have to delete\n            // them ourselves\n\n            TreeSet<Text> unservedRegions = new TreeSet<Text>();\n\n            long scannerId = -1L;\n            try {\n              scannerId = server.openScanner(m.regionName, METACOLUMNS, tableName);\n\n              DataInputBuffer inbuf = new DataInputBuffer();\n              byte[] bytes;\n              while(true) {\n                LabelledData[] values = null;\n                HStoreKey key = new HStoreKey();\n                values = server.next(scannerId, key);\n                if(values == null || values.length == 0) {\n                  break;\n                }\n                TreeMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n                for(int i = 0; i < values.length; i++) {\n                  bytes = new byte[values[i].getData().getSize()];\n                  System.arraycopy(values[i].getData().get(), 0, bytes, 0, bytes.length);\n                  results.put(values[i].getLabel(), bytes);\n                }\n                bytes = results.get(COL_REGIONINFO);\n                if(bytes == null || bytes.length == 0) {\n                  break;\n                }\n                inbuf.reset(bytes, bytes.length);\n                HRegionInfo info = new HRegionInfo();\n                info.readFields(inbuf);\n\n                if(info.tableDesc.getName().compareTo(tableName) > 0) {\n                  break;               // Beyond any more entries for this table\n                }\n\n                rowsToDelete.add(info.regionName);\n\n                // Is it being served?\n\n                bytes = results.get(COL_SERVER);\n                if(bytes != null && bytes.length != 0) {\n                  String serverName = new String(bytes, UTF8_ENCODING);\n\n                  bytes = results.get(COL_STARTCODE);\n                  if(bytes != null && bytes.length != 0) {\n                    long startCode = Long.valueOf(new String(bytes, UTF8_ENCODING));\n\n                    HServerInfo s = serversToServerInfo.get(serverName);\n                    if(s != null && s.getStartCode() == startCode) {\n\n                      // It is being served.\n                      // Tell the server to stop it and not report back.\n\n                      TreeMap<Text, HRegionInfo> regionsToKill =\n                        localKillList.get(serverName);\n\n                      if(regionsToKill == null) {\n                        regionsToKill = new TreeMap<Text, HRegionInfo>();\n                      }\n                      regionsToKill.put(info.regionName, info);\n                      localKillList.put(serverName, regionsToKill);\n                      continue;\n                    }\n                  }\n                }\n\n                // Region is not currently being served.\n                // Prevent it from getting assigned and add it to the list of\n                // regions we need to delete here.\n\n                unassignedRegions.remove(info.regionName);\n                assignAttempts.remove(info.regionName);\n                unservedRegions.add(info.regionName);\n              }\n\n            } finally {\n              if(scannerId != -1L) {\n                try {\n                  server.close(scannerId);\n\n                } catch(IOException e) {\n                  LOG.error(e);\n                }\n              }\n              scannerId = -1L;\n            }\n\n            // Wipe the existence of the regions out of the meta table\n\n            for(Iterator<Text> row = rowsToDelete.iterator(); row.hasNext(); ) {\n              Text rowName = row.next();\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"deleting columns in row: \" + rowName);\n              }\n              long lockid = -1L;\n              long clientId = rand.nextLong();\n              try {\n                lockid = server.startUpdate(m.regionName, clientId, rowName);\n                server.delete(m.regionName, clientId, lockid, COL_REGIONINFO);\n                server.delete(m.regionName, clientId, lockid, COL_SERVER);\n                server.delete(m.regionName, clientId, lockid, COL_STARTCODE);\n                server.commit(m.regionName, clientId, lockid);\n                lockid = -1L;\n                if(LOG.isDebugEnabled()) {\n                  LOG.debug(\"deleted columns in row: \" + rowName);\n                }\n\n              } catch(IOException e) {\n                if(lockid != -1L) {\n                  server.abort(m.regionName, clientId, lockid);\n                }\n                LOG.error(\"columns deletion failed in row: \" + rowName);\n                LOG.error(e);\n                throw e;\n              }\n            }\n\n            // Notify region servers that some regions need to be closed and deleted\n\n            if(localKillList.size() != 0) {\n              killList.putAll(localKillList);\n            }\n\n            // Delete any regions that are not being served\n\n            for(Iterator<Text> i = unservedRegions.iterator(); i.hasNext(); ) {\n              Text regionName = i.next();\n              try {\n                HRegion.deleteRegion(fs, dir, regionName);\n\n              } catch(IOException e) {\n                LOG.error(\"failed to delete region \" + regionName);\n                LOG.error(e);\n                throw e;\n              }\n            }\n          }\n        }\n      } catch(NotServingRegionException e) {\n        if(tries == numRetries - 1) {\n          throw e;\n        }\n        continue;\n\n      } catch(IOException e) {\n        LOG.error(e);\n        throw e;\n      }\n      break;\n    }\n\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"deleted table: \" + tableName);\n    }\n  }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * The HRegionServer sticks in this loop until closed. It repeatedly checks\n   * in with the HMaster, sending heartbeats & reports, and receiving HRegion \n   * load/unload instructions.\n   */\n  public void run() {\n    while(! stopRequested) {\n      long lastMsg = 0;\n      long waitTime;\n\n      // Let the master know we're here\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Telling master we are up\");\n        }\n        \n        hbaseMaster.regionServerStartup(info);\n        \n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Done telling master we are up\");\n        }\n      } catch(IOException e) {\n        waitTime = stopRequested ? 0\n            : msgInterval - (System.currentTimeMillis() - lastMsg);\n        \n        if(waitTime > 0) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Sleep\");\n          }\n          synchronized(this) {\n            try {\n              Thread.sleep(waitTime);\n            } catch(InterruptedException iex) {\n            }\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Wake\");\n          }\n        }\n        continue;\n      }\n      \n      // Now ask master what it wants us to do and tell it what we have done.\n      while (!stopRequested) {\n        if ((System.currentTimeMillis() - lastMsg) >= msgInterval) {\n\n          HMsg outboundArray[] = null;\n          synchronized(outboundMsgs) {\n            outboundArray = outboundMsgs.toArray(new HMsg[outboundMsgs.size()]);\n            outboundMsgs.clear();\n          }\n\n          try {\n            HMsg msgs[] = hbaseMaster.regionServerReport(info, outboundArray);\n            lastMsg = System.currentTimeMillis();\n\n            // Queue up the HMaster's instruction stream for processing\n\n            synchronized(toDo) {\n              boolean restart = false;\n              for(int i = 0; i < msgs.length && !stopRequested && !restart; i++) {\n                switch(msgs[i].getMsg()) {\n                \n                case HMsg.MSG_CALL_SERVER_STARTUP:\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Got call server startup message\");\n                  }\n                  toDo.clear();\n                  closeAllRegions();\n                  restart = true;\n                  break;\n                \n                case HMsg.MSG_REGIONSERVER_STOP:\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Got regionserver stop message\");\n                  }\n                  toDo.clear();\n                  closeAllRegions();\n                  stopRequested = true;\n                  break;\n                  \n                default:\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Got default message\");\n                  }\n                  toDo.add(msgs[i]);\n                }\n              }\n              \n              if(toDo.size() > 0) {\n                if (LOG.isDebugEnabled()) {\n                  LOG.debug(\"notify on todo\");\n                }\n                toDo.notifyAll();\n              }\n              if(restart || stopRequested) {\n                break;\n              }\n            }\n\n          } catch(IOException e) {\n            LOG.error(e);\n          }\n        }\n\n        waitTime = stopRequested ? 0\n            : msgInterval - (System.currentTimeMillis() - lastMsg);\n        if (waitTime > 0) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Sleep\");\n          }\n          synchronized(this) {\n            try {\n              Thread.sleep(waitTime);\n            } catch(InterruptedException iex) {\n            }\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Wake\");\n          }\n        }\n      }\n    }\n    try {\n      LOG.info(\"stopping server at: \" + info.getServerAddress().toString());\n\n      // Send interrupts to wake up threads if sleeping so they notice shutdown.\n\n      synchronized(logRollerLock) {\n        this.logRollerThread.interrupt();\n      }\n      \n      synchronized(cacheFlusherLock) {\n        this.cacheFlusherThread.interrupt();\n      }\n      \n      synchronized(splitOrCompactLock) {\n        this.splitOrCompactCheckerThread.interrupt();\n      }\n      \n      this.worker.stop();\n      this.server.stop();\n\n      closeAllRegions();\n      log.close();\n      leases.close();\n      join();\n      \n    } catch(IOException e) {\n      e.printStackTrace();\n    }\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"main thread exiting\");\n    }\n  }","id":92763,"modified_method":"/**\n   * The HRegionServer sticks in this loop until closed. It repeatedly checks\n   * in with the HMaster, sending heartbeats & reports, and receiving HRegion \n   * load/unload instructions.\n   */\n  public void run() {\n    while(! stopRequested) {\n      long lastMsg = 0;\n      long waitTime;\n\n      // Let the master know we're here\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Telling master we are up\");\n        }\n        \n        hbaseMaster.regionServerStartup(info);\n        \n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Done telling master we are up\");\n        }\n      } catch(IOException e) {\n        waitTime = stopRequested ? 0\n            : msgInterval - (System.currentTimeMillis() - lastMsg);\n        \n        if(waitTime > 0) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Sleep\");\n          }\n          synchronized(this) {\n            try {\n              Thread.sleep(waitTime);\n            } catch(InterruptedException iex) {\n            }\n          }\n        }\n        continue;\n      }\n      \n      // Now ask master what it wants us to do and tell it what we have done.\n      while (!stopRequested) {\n        if ((System.currentTimeMillis() - lastMsg) >= msgInterval) {\n\n          HMsg outboundArray[] = null;\n          synchronized(outboundMsgs) {\n            outboundArray = outboundMsgs.toArray(new HMsg[outboundMsgs.size()]);\n            outboundMsgs.clear();\n          }\n\n          try {\n            HMsg msgs[] = hbaseMaster.regionServerReport(info, outboundArray);\n            lastMsg = System.currentTimeMillis();\n\n            // Queue up the HMaster's instruction stream for processing\n\n            synchronized(toDo) {\n              boolean restart = false;\n              for(int i = 0; i < msgs.length && !stopRequested && !restart; i++) {\n                switch(msgs[i].getMsg()) {\n                \n                case HMsg.MSG_CALL_SERVER_STARTUP:\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Got call server startup message\");\n                  }\n                  toDo.clear();\n                  closeAllRegions();\n                  restart = true;\n                  break;\n                \n                case HMsg.MSG_REGIONSERVER_STOP:\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Got regionserver stop message\");\n                  }\n                  toDo.clear();\n                  closeAllRegions();\n                  stopRequested = true;\n                  break;\n                  \n                default:\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Got default message\");\n                  }\n                  toDo.add(msgs[i]);\n                }\n              }\n              \n              if(toDo.size() > 0) {\n                if (LOG.isDebugEnabled()) {\n                  LOG.debug(\"notify on todo\");\n                }\n                toDo.notifyAll();\n              }\n              if(restart || stopRequested) {\n                break;\n              }\n            }\n\n          } catch(IOException e) {\n            LOG.error(e);\n          }\n        }\n\n        waitTime = stopRequested ? 0\n            : msgInterval - (System.currentTimeMillis() - lastMsg);\n        if (waitTime > 0) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Sleep\");\n          }\n          synchronized(this) {\n            try {\n              Thread.sleep(waitTime);\n            } catch(InterruptedException iex) {\n            }\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Wake\");\n          }\n        }\n      }\n    }\n    try {\n      LOG.info(\"stopping server at: \" + info.getServerAddress().toString());\n\n      // Send interrupts to wake up threads if sleeping so they notice shutdown.\n\n      synchronized(logRollerLock) {\n        this.logRollerThread.interrupt();\n      }\n      \n      synchronized(cacheFlusherLock) {\n        this.cacheFlusherThread.interrupt();\n      }\n      \n      synchronized(splitOrCompactLock) {\n        this.splitOrCompactCheckerThread.interrupt();\n      }\n      \n      this.worker.stop();\n      this.server.stop();\n\n      closeAllRegions();\n      log.close();\n      leases.close();\n      join();\n      \n    } catch(IOException e) {\n      LOG.error(e);\n    }\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"main thread exiting\");\n    }\n  }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"public void run() {\n      while(! stopRequested) {\n        long startTime = System.currentTimeMillis();\n\n        synchronized(cacheFlusherLock) {\n\n          // Grab a list of items to flush\n\n          Vector<HRegion> toFlush = new Vector<HRegion>();\n          lock.readLock().lock();\n          try {\n            toFlush.addAll(regions.values());\n          } finally {\n            lock.readLock().unlock();\n          }\n\n          // Flush them, if necessary\n\n          for(Iterator<HRegion> it = toFlush.iterator(); it.hasNext(); ) {\n            HRegion cur = it.next();\n            \n            if(cur.isClosed()) {                // Skip if closed\n              continue;\n            }\n\n            try {\n              cur.optionallyFlush();\n\n            } catch(IOException iex) {\n              iex.printStackTrace();\n            }\n          }\n        }\n        \n        // Sleep\n        long waitTime = stopRequested ? 0\n            : threadWakeFrequency - (System.currentTimeMillis() - startTime);\n        \n        if(waitTime > 0) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Sleep cacheFlusher\");\n          }\n          try {\n            Thread.sleep(waitTime);\n          } catch(InterruptedException iex) {\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Wake cacheFlusher\");\n          }\n        }\n      }\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"cacheFlusher exiting\");\n      }\n    }","id":92764,"modified_method":"public void run() {\n      while(! stopRequested) {\n        long startTime = System.currentTimeMillis();\n\n        synchronized(cacheFlusherLock) {\n\n          // Grab a list of items to flush\n\n          Vector<HRegion> toFlush = new Vector<HRegion>();\n          lock.readLock().lock();\n          try {\n            toFlush.addAll(regions.values());\n          } finally {\n            lock.readLock().unlock();\n          }\n\n          // Flush them, if necessary\n\n          for(Iterator<HRegion> it = toFlush.iterator(); it.hasNext(); ) {\n            HRegion cur = it.next();\n            \n            if(cur.isClosed()) {                // Skip if closed\n              continue;\n            }\n\n            try {\n              cur.optionallyFlush();\n\n            } catch(IOException iex) {\n              LOG.error(iex);\n            }\n          }\n        }\n        \n        // Sleep\n        long waitTime = stopRequested ? 0\n            : threadWakeFrequency - (System.currentTimeMillis() - startTime);\n        \n        if(waitTime > 0) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Sleep cacheFlusher\");\n          }\n          try {\n            Thread.sleep(waitTime);\n          } catch(InterruptedException iex) {\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Wake cacheFlusher\");\n          }\n        }\n      }\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"cacheFlusher exiting\");\n      }\n    }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"public void run() {\n      for(HMsg msg = null; !stopRequested; ) {\n        synchronized(toDo) {\n          while(toDo.size() == 0 && !stopRequested) {\n            try {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Wait on todo\");\n              }\n              toDo.wait();\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Wake on todo\");\n              }\n            } catch(InterruptedException e) {\n            }\n          }\n          if(stopRequested) {\n            continue;\n          }\n          msg = toDo.remove(0);\n        }\n        \n        try {\n          switch(msg.getMsg()) {\n\n          case HMsg.MSG_REGION_OPEN:                    // Open a region\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_REGION_OPEN\");\n            }\n            openRegion(msg.getRegionInfo());\n            break;\n\n          case HMsg.MSG_REGION_CLOSE:                   // Close a region\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_REGION_CLOSE\");\n            }\n            closeRegion(msg.getRegionInfo(), true);\n            break;\n\n          case HMsg.MSG_REGION_MERGE:                   // Merge two regions\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_REGION_MERGE\");\n            }\n            //TODO ???\n            throw new IOException(\"TODO: need to figure out merge\");\n            //break;\n\n          case HMsg.MSG_CALL_SERVER_STARTUP:            // Close regions, restart\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_CALL_SERVER_STARTUP\");\n            }\n            closeAllRegions();\n            continue;\n\n          case HMsg.MSG_REGIONSERVER_STOP:              // Go away\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_REGIONSERVER_STOP\");\n            }\n            stopRequested = true;\n            continue;\n\n          case HMsg.MSG_REGION_CLOSE_WITHOUT_REPORT:    // Close a region, don't reply\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_REGION_CLOSE_WITHOUT_REPORT\");\n            }\n            closeRegion(msg.getRegionInfo(), false);\n            break;\n\n          case HMsg.MSG_REGION_CLOSE_AND_DELETE:\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_REGION_CLOSE_AND_DELETE\");\n            }\n            closeAndDeleteRegion(msg.getRegionInfo());\n            break;\n\n          default:\n            throw new IOException(\"Impossible state during msg processing.  Instruction: \" + msg);\n          }\n        } catch(IOException e) {\n          e.printStackTrace();\n        }\n      }\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"worker thread exiting\");\n      }\n    }","id":92765,"modified_method":"public void run() {\n      for(HMsg msg = null; !stopRequested; ) {\n        synchronized(toDo) {\n          while(toDo.size() == 0 && !stopRequested) {\n            try {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Wait on todo\");\n              }\n              toDo.wait();\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Wake on todo\");\n              }\n            } catch(InterruptedException e) {\n            }\n          }\n          if(stopRequested) {\n            continue;\n          }\n          msg = toDo.remove(0);\n        }\n        \n        try {\n          switch(msg.getMsg()) {\n\n          case HMsg.MSG_REGION_OPEN:                    // Open a region\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_REGION_OPEN\");\n            }\n            openRegion(msg.getRegionInfo());\n            break;\n\n          case HMsg.MSG_REGION_CLOSE:                   // Close a region\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_REGION_CLOSE\");\n            }\n            closeRegion(msg.getRegionInfo(), true);\n            break;\n\n          case HMsg.MSG_REGION_MERGE:                   // Merge two regions\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_REGION_MERGE\");\n            }\n            //TODO ???\n            throw new IOException(\"TODO: need to figure out merge\");\n            //break;\n\n          case HMsg.MSG_CALL_SERVER_STARTUP:            // Close regions, restart\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_CALL_SERVER_STARTUP\");\n            }\n            closeAllRegions();\n            continue;\n\n          case HMsg.MSG_REGIONSERVER_STOP:              // Go away\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_REGIONSERVER_STOP\");\n            }\n            stopRequested = true;\n            continue;\n\n          case HMsg.MSG_REGION_CLOSE_WITHOUT_REPORT:    // Close a region, don't reply\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_REGION_CLOSE_WITHOUT_REPORT\");\n            }\n            closeRegion(msg.getRegionInfo(), false);\n            break;\n\n          case HMsg.MSG_REGION_CLOSE_AND_DELETE:\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"MSG_REGION_CLOSE_AND_DELETE\");\n            }\n            closeAndDeleteRegion(msg.getRegionInfo());\n            break;\n\n          default:\n            throw new IOException(\"Impossible state during msg processing.  Instruction: \" + msg);\n          }\n        } catch(IOException e) {\n          LOG.error(e);\n        }\n      }\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"worker thread exiting\");\n      }\n    }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"/** Start a scanner for a given HRegion. */\n  public long openScanner(Text regionName, Text[] cols, Text firstRow)\n      throws IOException {\n\n    HRegion r = getRegion(regionName);\n    long scannerId = -1L;\n    try {\n      HInternalScannerInterface s = r.getScanner(cols, firstRow);\n      scannerId = rand.nextLong();\n      Text scannerName = new Text(String.valueOf(scannerId));\n      synchronized(scanners) {\n        scanners.put(scannerName, s);\n      }\n      leases.createLease(scannerName, scannerName, new ScannerListener(scannerName));\n    \n    } catch(IOException e) {\n      e.printStackTrace();\n      throw e;\n    }\n    return scannerId;\n  }","id":92766,"modified_method":"/** Start a scanner for a given HRegion. */\n  public long openScanner(Text regionName, Text[] cols, Text firstRow)\n      throws IOException {\n\n    HRegion r = getRegion(regionName);\n    long scannerId = -1L;\n    try {\n      HInternalScannerInterface s = r.getScanner(cols, firstRow);\n      scannerId = rand.nextLong();\n      Text scannerName = new Text(String.valueOf(scannerId));\n      synchronized(scanners) {\n        scanners.put(scannerName, s);\n      }\n      leases.createLease(scannerName, scannerName, new ScannerListener(scannerName));\n    \n    } catch(IOException e) {\n      LOG.error(e);\n      throw e;\n    }\n    return scannerId;\n  }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"public void run() {\n      while(! stopRequested) {\n        long startTime = System.currentTimeMillis();\n\n        synchronized(splitOrCompactLock) { // Don't interrupt us while we're working\n\n          // Grab a list of regions to check\n\n          Vector<HRegion> regionsToCheck = new Vector<HRegion>();\n          lock.readLock().lock();\n          try {\n            regionsToCheck.addAll(regions.values());\n          } finally {\n            lock.readLock().unlock();\n          }\n\n          try {\n            for(Iterator<HRegion>it = regionsToCheck.iterator(); it.hasNext(); ) {\n              HRegion cur = it.next();\n              \n              if(cur.isClosed()) {\n                continue;                               // Skip if closed\n              }\n              \n              if(cur.needsCompaction()) {\n                \n                // The best time to split a region is right after it has been compacted\n                \n                if(cur.compactStores()) {\n                  Text midKey = new Text();\n                  if(cur.needsSplit(midKey)) {\n                    Text oldRegion = cur.getRegionName();\n\n                    LOG.info(\"splitting region: \" + oldRegion);\n\n                    HRegion[] newRegions = cur.closeAndSplit(midKey, this);\n\n                    // When a region is split, the META table needs to updated if we're\n                    // splitting a 'normal' region, and the ROOT table needs to be\n                    // updated if we are splitting a META region.\n\n                    if(LOG.isDebugEnabled()) {\n                      LOG.debug(\"region split complete. updating meta\");\n                    }\n\n                    Text tableToUpdate =\n                      (oldRegion.find(META_TABLE_NAME.toString()) == 0) ?\n                          ROOT_TABLE_NAME : META_TABLE_NAME;\n\n                    client.openTable(tableToUpdate);\n                    long lockid = client.startUpdate(oldRegion);\n                    client.delete(lockid, COL_REGIONINFO);\n                    client.delete(lockid, COL_SERVER);\n                    client.delete(lockid, COL_STARTCODE);\n                    client.commit(lockid);\n\n                    for(int i = 0; i < newRegions.length; i++) {\n                      ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n                      DataOutputStream out = new DataOutputStream(bytes);\n                      newRegions[i].getRegionInfo().write(out);\n\n                      lockid = client.startUpdate(newRegions[i].getRegionName());\n                      client.put(lockid, COL_REGIONINFO, bytes.toByteArray());\n                      client.put(lockid, COL_SERVER, \n                          info.getServerAddress().toString().getBytes(UTF8_ENCODING));\n                      client.put(lockid, COL_STARTCODE, \n                          String.valueOf(info.getStartCode()).getBytes(UTF8_ENCODING));\n                      client.commit(lockid);\n                    }\n                    \n                    // Now tell the master about the new regions\n\n                    if(LOG.isDebugEnabled()) {\n                      LOG.debug(\"reporting region split to master\");\n                    }\n\n                    reportSplit(newRegions[0].getRegionInfo(), newRegions[1].getRegionInfo());\n\n                    LOG.info(\"region split successful. old region=\" + oldRegion\n                        + \", new regions: \" + newRegions[0].getRegionName() + \", \"\n                        + newRegions[1].getRegionName());\n\n                    // Finally, start serving the new regions\n                    \n                    lock.writeLock().lock();\n                    try {\n                      regions.put(newRegions[0].getRegionName(), newRegions[0]);\n                      regions.put(newRegions[1].getRegionName(), newRegions[1]);\n                    } finally {\n                      lock.writeLock().unlock();\n                    }\n                  }\n                }\n              }\n            }\n          } catch(IOException e) {\n            //TODO: What happens if this fails? Are we toast?\n            LOG.error(e);\n          }\n        }\n        \n        // Sleep\n        long waitTime = stopRequested ? 0\n            : splitOrCompactCheckFrequency - (System.currentTimeMillis() - startTime);\n        if (waitTime > 0) {\n          try {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Sleep splitOrCompactChecker\");\n            }\n            Thread.sleep(waitTime);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Wake splitOrCompactChecker\");\n            }\n          } catch(InterruptedException iex) {\n          }\n        }\n      }\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"splitOrCompactChecker exiting\");\n      }\n    }","id":92767,"modified_method":"public void run() {\n      while(! stopRequested) {\n        long startTime = System.currentTimeMillis();\n\n        synchronized(splitOrCompactLock) { // Don't interrupt us while we're working\n\n          // Grab a list of regions to check\n\n          Vector<HRegion> regionsToCheck = new Vector<HRegion>();\n          lock.readLock().lock();\n          try {\n            regionsToCheck.addAll(regions.values());\n          } finally {\n            lock.readLock().unlock();\n          }\n\n          try {\n            for(Iterator<HRegion>it = regionsToCheck.iterator(); it.hasNext(); ) {\n              HRegion cur = it.next();\n\n              if(cur.isClosed()) {\n                continue;                               // Skip if closed\n              }\n\n              if(cur.needsCompaction()) {\n\n                // The best time to split a region is right after it has been compacted\n\n                if(cur.compactStores()) {\n                  Text midKey = new Text();\n                  if(cur.needsSplit(midKey)) {\n                    Text oldRegion = cur.getRegionName();\n\n                    LOG.info(\"splitting region: \" + oldRegion);\n\n                    HRegion[] newRegions = cur.closeAndSplit(midKey, this);\n\n                    // When a region is split, the META table needs to updated if we're\n                    // splitting a 'normal' region, and the ROOT table needs to be\n                    // updated if we are splitting a META region.\n\n                    if(LOG.isDebugEnabled()) {\n                      LOG.debug(\"region split complete. updating meta\");\n                    }\n\n                    Text tableToUpdate =\n                      (oldRegion.find(META_TABLE_NAME.toString()) == 0) ?\n                          ROOT_TABLE_NAME : META_TABLE_NAME;\n\n                    for(int tries = 0; tries < numRetries; tries++) {\n                      try {\n                        client.openTable(tableToUpdate);\n                        long lockid = client.startUpdate(oldRegion);\n                        client.delete(lockid, COL_REGIONINFO);\n                        client.delete(lockid, COL_SERVER);\n                        client.delete(lockid, COL_STARTCODE);\n                        client.commit(lockid);\n\n                        for(int i = 0; i < newRegions.length; i++) {\n                          ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n                          DataOutputStream out = new DataOutputStream(bytes);\n                          newRegions[i].getRegionInfo().write(out);\n\n                          lockid = client.startUpdate(newRegions[i].getRegionName());\n                          client.put(lockid, COL_REGIONINFO, bytes.toByteArray());\n                          client.put(lockid, COL_SERVER, \n                              info.getServerAddress().toString().getBytes(UTF8_ENCODING));\n                          client.put(lockid, COL_STARTCODE, \n                              String.valueOf(info.getStartCode()).getBytes(UTF8_ENCODING));\n                          client.commit(lockid);\n                        }\n\n                        // Now tell the master about the new regions\n\n                        if(LOG.isDebugEnabled()) {\n                          LOG.debug(\"reporting region split to master\");\n                        }\n\n                        reportSplit(newRegions[0].getRegionInfo(), newRegions[1].getRegionInfo());\n\n                        LOG.info(\"region split successful. old region=\" + oldRegion\n                            + \", new regions: \" + newRegions[0].getRegionName() + \", \"\n                            + newRegions[1].getRegionName());\n\n                        // Finally, start serving the new regions\n\n                        lock.writeLock().lock();\n                        try {\n                          regions.put(newRegions[0].getRegionName(), newRegions[0]);\n                          regions.put(newRegions[1].getRegionName(), newRegions[1]);\n                        } finally {\n                          lock.writeLock().unlock();\n                        }\n\n                      } catch(NotServingRegionException e) {\n                        if(tries == numRetries - 1) {\n                          throw e;\n                        }\n                        continue;\n                      }\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          } catch(IOException e) {\n            //TODO: What happens if this fails? Are we toast?\n            LOG.error(e);\n          }\n        }\n\n        // Sleep\n        long waitTime = stopRequested ? 0\n            : splitOrCompactCheckFrequency - (System.currentTimeMillis() - startTime);\n        if (waitTime > 0) {\n          try {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Sleep splitOrCompactChecker\");\n            }\n            Thread.sleep(waitTime);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Wake splitOrCompactChecker\");\n            }\n          } catch(InterruptedException iex) {\n          }\n        }\n      }\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"splitOrCompactChecker exiting\");\n      }\n    }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"public void leaseExpired() {\n      try {\n        localRegion.abort(localLockId);\n        \n      } catch(IOException iex) {\n        iex.printStackTrace();\n      }\n    }","id":92768,"modified_method":"public void leaseExpired() {\n      try {\n        localRegion.abort(localLockId);\n        \n      } catch(IOException iex) {\n        LOG.error(iex);\n      }\n    }","commit_id":"e3e22fe37eae6b22ba80ae24dfc7a219a119d92a","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Convenience method for reading a token storage file directly from a \n   * datainputstream\n   */\n  public void readTokenStorageStream(DataInputStream in) throws IOException {\n    byte[] magic = new byte[TOKEN_STORAGE_MAGIC.length];\n    in.readFully(magic);\n    if (!Arrays.equals(magic, TOKEN_STORAGE_MAGIC)) {\n      throw new IOException(\"Bad header found in token storage.\");\n    }\n    byte version = in.readByte();\n    if (version != TOKEN_STORAGE_VERSION) {\n      throw new IOException(\"Unknown version \" + version + \n                            \" in token storage.\");\n    }\n    readFields(in);\n  }","id":92769,"modified_method":"/**\n   * Convenience method for reading a token from a DataInputStream.\n   */\n  public void readTokenStorageStream(DataInputStream in) throws IOException {\n    byte[] magic = new byte[TOKEN_STORAGE_MAGIC.length];\n    in.readFully(magic);\n    if (!Arrays.equals(magic, TOKEN_STORAGE_MAGIC)) {\n      throw new IOException(\"Bad header found in token storage.\");\n    }\n    byte version = in.readByte();\n    if (version != TOKEN_STORAGE_VERSION &&\n        version != OLD_TOKEN_STORAGE_VERSION) {\n      throw new IOException(\"Unknown version \" + version +\n                            \" in token storage.\");\n    }\n    if (version == OLD_TOKEN_STORAGE_VERSION) {\n      readFields(in);\n    } else if (version == TOKEN_STORAGE_VERSION) {\n      readProtos(in);\n    }\n  }","commit_id":"4838b735f0d472765f402fe6b1c8b6ce85b9fbf1","url":"https://github.com/apache/hadoop"},{"original_method":"public void writeTokenStorageToStream(DataOutputStream os)\n    throws IOException {\n    os.write(TOKEN_STORAGE_MAGIC);\n    os.write(TOKEN_STORAGE_VERSION);\n    write(os);\n  }","id":92770,"modified_method":"public void writeTokenStorageToStream(DataOutputStream os)\n      throws IOException {\n    os.write(TOKEN_STORAGE_MAGIC);\n    os.write(TOKEN_STORAGE_VERSION);\n    writeProto(os);\n  }","commit_id":"4838b735f0d472765f402fe6b1c8b6ce85b9fbf1","url":"https://github.com/apache/hadoop"},{"original_method":"@VisibleForTesting\n  static void saveDelegationToken(Configuration conf, FileSystem fs,\n                                  final String renewer, final Path tokenFile)\n          throws IOException {\n    Token<?> token = fs.getDelegationToken(renewer);\n    if (null != token) {\n      Credentials cred = new Credentials();\n      cred.addToken(token.getService(), token);\n      cred.writeTokenStorageFile(tokenFile, conf);\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Fetched token \" + fs.getUri() + \" for \" +\n            token.getService() + \" into \" + tokenFile);\n      }\n    } else {\n      System.err.println(\"ERROR: Failed to fetch token from \" + fs.getUri());\n    }\n  }","id":92771,"modified_method":"@VisibleForTesting\n  static void saveDelegationToken(Configuration conf, FileSystem fs,\n                                  final String renewer, final Path tokenFile)\n          throws IOException {\n    Token<?> token = fs.getDelegationToken(renewer);\n    if (null != token) {\n      Credentials cred = new Credentials();\n      cred.addToken(token.getService(), token);\n      // dtutil is replacing this tool; preserve legacy functionality\n      cred.writeLegacyTokenStorageFile(tokenFile, conf);\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Fetched token \" + fs.getUri() + \" for \" +\n            token.getService() + \" into \" + tokenFile);\n      }\n    } else {\n      System.err.println(\"ERROR: Failed to fetch token from \" + fs.getUri());\n    }\n  }","commit_id":"4838b735f0d472765f402fe6b1c8b6ce85b9fbf1","url":"https://github.com/apache/hadoop"},{"original_method":"public CX0Chunk(long [] ls, int [] xs, int[] id, int len2, int len) {super(ls,xs,id,len2, len,0);}","id":92772,"modified_method":"protected CX0Chunk(int len, int nzs, byte [] buf){super(len,nzs,0,buf);}","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override protected double atd_impl(int idx) { return at8_impl(idx); }","id":92773,"modified_method":"@Override protected final double atd_impl(int idx) { return at8_impl(idx); }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override protected long at8_impl(int idx) {return getId(findOffset(idx)) == idx?1:0;}","id":92774,"modified_method":"@Override protected final long at8_impl(int idx) {return getId(findOffset(idx)) == idx?1:0;}","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"protected final double getFValue(int off){\n    if(_elsz == 8) return UDP.get8d(_mem, off + _idsz);\n    throw H2O.unimpl();\n  }","id":92775,"modified_method":"protected final double getFValue(int off){\n    if(_valsz == 8) return UDP.get8d(_mem, off + _ridsz);\n    throw H2O.unimpl();\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override NewChunk inflate_impl(NewChunk nc) {\n    final int len = sparseLen();\n    nc._len2 = _len;\n    nc._len = sparseLen();\n    nc._ds = MemoryManager.malloc8d(nc._len);\n    nc._id = MemoryManager.malloc4 (len);\n    int off = OFF;\n    for( int i = 0; i < len; ++i, off += _idsz + _elsz) {\n      nc._id[i] = getId(off);\n      nc._ds[i] = getFValue(off);\n    }\n    return nc;\n  }","id":92776,"modified_method":"@Override NewChunk inflate_impl(NewChunk nc) {\n    final int len = sparseLen();\n    nc._len2 = _len;\n    nc._len = sparseLen();\n    nc._ds = MemoryManager.malloc8d(nc._len);\n    nc._id = MemoryManager.malloc4 (len);\n    int off = OFF;\n    for( int i = 0; i < len; ++i, off += _ridsz + _valsz) {\n      nc._id[i] = getId(off);\n      nc._ds[i] = getFValue(off);\n    }\n    return nc;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public CXDChunk(int len, int nzs, int [] ids, double [] ds){\n    super(len,ids.length,8);\n    assert 2 == _idsz || _idsz == 4;\n    int off = OFF;\n    final int inc = _idsz + _elsz;\n    for(int i = 0; i < nzs; ++i, off += inc){\n      if(_idsz == 2) {\n        UDP.set2 (_mem,off,(short)ids[i]);\n        UDP.set8d(_mem,off + 2, ds[i]);\n      } else {\n        assert _elsz == 4;\n        UDP.set4 (_mem, off, ids[i]);\n        UDP.set8d(_mem, off + 4, ds[i]);\n      }\n    }\n  }","id":92777,"modified_method":"protected CXDChunk(int len, int nzs, int valsz, byte [] buf){super(len,nzs,valsz,buf);}","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private final int getOff(int n){return OFF + (_idsz+_elsz)*n;}","id":92778,"modified_method":"private final int getOff(int n){return OFF + (_ridsz + _valsz)*n;}","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override protected long at8_impl(int idx) {\n    int off = findOffset(idx);\n    if(getId(off) != idx)return 0;\n    long v = getIValue(off);\n    if( v== NAS[_elsz_log-1])throw new IllegalArgumentException(\"at8 but value is missing\");\n    return v;\n  }","id":92779,"modified_method":"@Override protected long at8_impl(int idx) {\n    int off = findOffset(idx);\n    if(getId(off) != idx)return 0;\n    long v = getIValue(off);\n    if( v== NAS[_valsz_log -1])throw new IllegalArgumentException(\"at8 but value is missing\");\n    return v;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"protected final int getId(int off){\n    return _idsz == 2\n      ?UDP.get2(_mem,off)&0xFFFF\n      :UDP.get4(_mem,off);\n  }","id":92780,"modified_method":"protected final int getId(int off){\n    return _ridsz == 2\n      ?UDP.get2(_mem,off)&0xFFFF\n      :UDP.get4(_mem,off);\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public Chunk read(AutoBuffer bb) {\n    _mem   = bb.bufClose();\n    _start = -1;\n    _len = UDP.get4(_mem,0);\n    _idsz = _mem[4];\n    _elsz = _mem[5];\n    int x = _elsz;\n    int log = 0;\n    while(x > 1){\n      x = x >>> 1;\n      ++log;\n    }\n    _elsz_log = log;\n    return this;\n  }","id":92781,"modified_method":"@Override public Chunk read(AutoBuffer bb) {\n    _mem   = bb.bufClose();\n    _start = -1;\n    _len = UDP.get4(_mem,0);\n    _ridsz = _mem[4];\n    _valsz = _mem[5];\n    int x = _valsz;\n    int log = 0;\n    while(x > 1){\n      x = x >>> 1;\n      ++log;\n    }\n    _valsz_log = log;\n    return this;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override NewChunk inflate_impl(NewChunk nc) {\n    final int len = sparseLen();\n    nc._len2 = _len;\n    nc._len = sparseLen();\n    nc._ls = MemoryManager.malloc8 (len);\n    nc._xs = MemoryManager.malloc4 (len);\n    nc._id = MemoryManager.malloc4 (len);\n    int off = OFF;\n    for( int i = 0; i < len; ++i, off += _idsz + _elsz) {\n      nc._id[i] = getId(off);\n      long v = getIValue(off);\n      if(v == NAS[_elsz_log-1]){\n        nc._ls[i] = Long.MAX_VALUE;\n        nc._xs[i] = Integer.MIN_VALUE;\n      } else nc._ls[i] = v;\n    }\n    return nc;\n  }","id":92782,"modified_method":"@Override NewChunk inflate_impl(NewChunk nc) {\n    final int len = sparseLen();\n    nc._len2 = _len;\n    nc._len = sparseLen();\n    nc._ls = MemoryManager.malloc8 (len);\n    nc._xs = MemoryManager.malloc4 (len);\n    nc._id = MemoryManager.malloc4 (len);\n    int off = OFF;\n    for( int i = 0; i < len; ++i, off += _ridsz + _valsz) {\n      nc._id[i] = getId(off);\n      long v = getIValue(off);\n      if(v == NAS[_valsz_log -1]){\n        nc._ls[i] = Long.MAX_VALUE;\n        nc._xs[i] = Integer.MIN_VALUE;\n      } else nc._ls[i] = v;\n    }\n    return nc;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override protected boolean isNA_impl( int i ) {\n    int off = findOffset(i);\n    if(getId(off) != i)return false;\n    return getIValue(off) == NAS[_elsz_log-1];\n  }","id":92783,"modified_method":"@Override protected boolean isNA_impl( int i ) {\n    int off = findOffset(i);\n    if(getId(off) != i)return false;\n    return getIValue(off) == NAS[_valsz_log -1];\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"protected final long getIValue(int off){\n    switch(_elsz){\n      case 1: return _mem[off+_idsz];\n      case 2: return UDP.get2(_mem, off + _idsz);\n      case 4: return UDP.get4(_mem, off + _idsz);\n      case 8: return UDP.get8(_mem, off + _idsz);\n      default: throw H2O.unimpl();\n   } \n  }","id":92784,"modified_method":"protected final long getIValue(int off){\n    switch(_valsz){\n      case 1: return _mem[off+ _ridsz];\n      case 2: return UDP.get2(_mem, off + _ridsz);\n      case 4: return UDP.get4(_mem, off + _ridsz);\n      case 8: return UDP.get8(_mem, off + _ridsz);\n      default: throw H2O.unimpl();\n   } \n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override protected double atd_impl(int idx) {\n    int off = findOffset(idx);\n    if(getId(off) != idx)return 0;\n    long v =  getIValue(off);\n    return (v == NAS[_elsz_log-1])?Double.NaN:v;\n  }","id":92785,"modified_method":"@Override protected double atd_impl(int idx) {\n    int off = findOffset(idx);\n    if(getId(off) != idx)return 0;\n    long v =  getIValue(off);\n    return (v == NAS[_valsz_log -1])?Double.NaN:v;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public final int sparseLen(){return (_mem.length - OFF) / (_elsz + _idsz);}","id":92786,"modified_method":"@Override public final int sparseLen(){return (_mem.length - OFF) / (_valsz + _ridsz);}","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public int skipCnt(int rid){\n    int off = _lastOff;\n    int currentId = getId(off);\n    if(rid != currentId) off = findOffset(rid);\n    if(off < _mem.length - _idsz - _elsz)\n      return getId(off + _idsz + _elsz) - rid;\n    return 0;\n  }","id":92787,"modified_method":"public int skipCnt(int rid){\n    int off = _lastOff;\n    int currentId = getId(off);\n    if(rid != currentId) off = findOffset(rid);\n    if(off < _mem.length - _ridsz - _valsz)\n      return getId(off + _ridsz + _valsz) - rid;\n    return 0;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public final int nonzeros(int [] arr){\n    int len = sparseLen();\n    int off = OFF;\n    final int inc = _elsz + 2;\n    for(int i = 0; i < len; ++i, off += inc) arr[i] = UDP.get2(_mem, off)&0xFFFF;\n    return len;\n  }","id":92788,"modified_method":"@Override public final int nonzeros(int [] arr){\n    int len = sparseLen();\n    int off = OFF;\n    final int inc = _valsz + 2;\n    for(int i = 0; i < len; ++i, off += inc) arr[i] = UDP.get2(_mem, off)&0xFFFF;\n    return len;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"protected CXIChunk(int len, int nzs, int esz){\n    _len = len;\n    _elsz = esz;\n    int x = _elsz, log = 0;\n    while(x > 1){\n      x = x >> 1;\n      ++log;\n    }\n    _elsz_log = log;\n    assert (_elsz == 0 || _elsz == 1 || _elsz == 2 || _elsz == 4 || _elsz == 8);\n    _idsz = (len >= 65535)?4:2;\n    byte[] buf = MemoryManager.malloc1((nzs)*(_idsz+esz)+OFF); // 2 bytes row, 2 bytes val\n    UDP.set4(buf,0,len);\n    byte b = (byte)_idsz;\n    buf[4] = b;\n    buf[5] = (byte)_elsz;\n    _mem = buf;\n  }","id":92789,"modified_method":"protected CXIChunk(int len, int nzs, int valsz, byte [] buf){\n    assert (valsz == 0 || valsz == 1 || valsz == 2 || valsz == 4 || valsz == 8);\n    _len = len;\n    int log = 0;\n    while((1 << log) < valsz)++log;\n    assert valsz == 0 || (1 << log) == valsz;\n    _valsz = valsz;\n    _valsz_log = log;\n\n    _ridsz = (len >= 65535)?4:2;\n    UDP.set4(buf,0,len);\n    byte b = (byte) _ridsz;\n    buf[4] = b;\n    buf[5] = (byte) _valsz;\n    _mem = buf;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"protected final int findOffset(int idx) {\n    if(idx >= _len)throw new IndexOutOfBoundsException();\n    final byte [] mem = _mem;\n    int sparseLen = sparseLen();\n    if(sparseLen == 0)return 0;\n    final int off = _lastOff;\n    int lastIdx = getId(off);\n    // check the last accessed elem\n    if( idx == lastIdx ) return off;\n    if(idx > lastIdx){\n      // check the next one\n      final int nextOff = off + _idsz + _elsz;\n      if(nextOff < mem.length){\n        int nextId =  getId(nextOff);\n        if(idx < nextId)return off;\n        if(idx == nextId){\n          _lastOff = nextOff;\n          return nextOff;\n        }\n      }\n    }\n    // no match so far, do binary search\n    int lo=0, hi = sparseLen;\n    while( lo+1 != hi ) {\n      int mid = (hi+lo)>>>1;\n      if( idx < getId(getOff(mid))) hi = mid;\n      else          lo = mid;\n    }\n    int y =  getOff(lo);\n    _lastOff = y;\n    return y;\n  }","id":92790,"modified_method":"protected final int findOffset(int idx) {\n    if(idx >= _len)throw new IndexOutOfBoundsException();\n    final byte [] mem = _mem;\n    int sparseLen = sparseLen();\n    if(sparseLen == 0)return 0;\n    final int off = _lastOff;\n    int lastIdx = getId(off);\n    // check the last accessed elem\n    if( idx == lastIdx ) return off;\n    if(idx > lastIdx){\n      // check the next one\n      final int nextOff = off + _ridsz + _valsz;\n      if(nextOff < mem.length){\n        int nextId =  getId(nextOff);\n        if(idx < nextId)return off;\n        if(idx == nextId){\n          _lastOff = nextOff;\n          return nextOff;\n        }\n      }\n    }\n    // no match so far, do binary search\n    int lo=0, hi = sparseLen;\n    while( lo+1 != hi ) {\n      int mid = (hi+lo)>>>1;\n      if( idx < getId(getOff(mid))) hi = mid;\n      else          lo = mid;\n    }\n    int y =  getOff(lo);\n    _lastOff = y;\n    return y;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public boolean isNa(){\n      long v = getIValue(off);\n      return (v == NAS[_elsz_log-1]);\n    }","id":92791,"modified_method":"public boolean isNa(){\n      long v = getIValue(off);\n      return (v == NAS[_valsz_log -1]);\n    }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public long asLong(){\n      long v = getIValue(off);\n      if(v == NAS[(_elsz >>> 1) - 1]) throw new IllegalArgumentException(\"at8 but value is missing\");\n      return v;\n    }","id":92792,"modified_method":"public long asLong(){\n      long v = getIValue(off);\n      if(v == NAS[(_valsz >>> 1) - 1]) throw new IllegalArgumentException(\"at8 but value is missing\");\n      return v;\n    }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public double asDouble(){\n      long v = getIValue(off);\n      return (v == NAS[_elsz_log-1])?Double.NaN:v;\n    }","id":92793,"modified_method":"public double asDouble(){\n      long v = getIValue(off);\n      return (v == NAS[_valsz_log -1])?Double.NaN:v;\n    }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public Iterator<Value> values(){\n    final Value val = new Value();\n    return new Iterator<Value>(){\n      @Override public boolean hasNext(){return val.off != _mem.length - (_idsz + _elsz);}\n      @Override public Value next(){\n        val.off += (_idsz + _elsz);\n        return val;\n      }\n      @Override public void remove(){throw new UnsupportedOperationException();}\n    };\n  }","id":92794,"modified_method":"public Iterator<Value> values(){\n    final Value val = new Value();\n    return new Iterator<Value>(){\n      @Override public boolean hasNext(){return val.off != _mem.length - (_ridsz + _valsz);}\n      @Override public Value next(){\n        val.off += (_ridsz + _valsz);\n        return val;\n      }\n      @Override public void remove(){throw new UnsupportedOperationException();}\n    };\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public boolean set_impl(int i, double d) {\n    if( _ls != null ) {         // Flip to using doubles\n      if( _len2 != _len ) throw H2O.unimpl();\n      double ds[] = MemoryManager.malloc8d(_len);\n      for( int j = 0; j<_len; j++ )\n        ds[j] = (isNA(j) || isEnum(j)) ? Double.NaN : _ls[j]*Math.pow(10,_xs[j]);\n      _ds = ds;  _ls = null;  _xs = null;\n    }\n    _ds[i]=d;\n    return true;\n  }","id":92795,"modified_method":"@Override public boolean set_impl(int i, double d) {\n    if(_ds == null){\n      assert _len == 0 || _ls != null;\n      switch_to_doubles();\n    }\n    if(_len != _len2){ // sparse?\n      int idx = Arrays.binarySearch(_id,0,_len,i);\n      if(idx >= 0)i = idx;\n      else cancel_sparse(); // for now don't bother setting the sparse value\n    }\n    while(i >= _len2) append2slowd();\n    _ds[i] = d;\n    return true;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override boolean setNA_impl(int i) {\n    if( isNA(i) ) return true;\n    if( _len2 != _len ) throw H2O.unimpl();\n    if( _ls != null ) { _ls[i] = 0; _xs[i] = Integer.MIN_VALUE; }\n    if( _ds != null ) { _ds[i] = Double.NaN; }\n    return true;\n  }","id":92796,"modified_method":"@Override boolean setNA_impl(int i) {\n    if( isNA_impl(i) ) return true;\n    if(_len != _len2){\n      int idx = Arrays.binarySearch(_id,0,_len,i);\n      if(idx >= 0) i = idx;\n      else cancel_sparse(); // todo - do not necessarily cancel sparse here\n    }\n    return setNA_impl2(i);\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"protected final boolean isEnum(int idx) {\n    return _ls!=null && _xs[idx]==Integer.MIN_VALUE+1;\n  }","id":92797,"modified_method":"protected final boolean isEnum(int idx) {\n    if(_id == null)return isEnum2(idx);\n    int j = Arrays.binarySearch(_id,0,_len,idx);\n    if(j < 0)return false;\n    return isEnum2(j);\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public double atd_impl( int i ) {\n    if( _len2 != _len ) throw H2O.unimpl();\n    if( _ds == null ) return at8_impl(i);\n    assert _xs==null; return _ds[i];\n  }","id":92798,"modified_method":"@Override public double atd_impl( int i ) {\n    if( _len2 != _len ) {\n      int idx = Arrays.binarySearch(_id,0,_len,i);\n      if(idx >= 0) i = idx;\n      else return 0;\n    }\n    if( _ds == null ) return at8_impl(i);\n    assert _xs==null; return _ds[i];\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private byte[] bufX( long bias, int scale, int off, int log ) {\n    if( _len2 != _len ) cancel_sparse();\n    byte[] bs = new byte[(_len2<<log)+off];\n    for( int i=0; i<_len; i++ ) {\n      if( isNA(i) ) {\n        switch( log ) {\n          case 0:          bs [i    +off] = (byte)(C1Chunk._NA); break;\n          case 1: UDP.set2(bs,(i<<1)+off,   (short)C2Chunk._NA); break;\n          case 2: UDP.set4(bs,(i<<2)+off,     (int)C4Chunk._NA); break;\n          case 3: UDP.set8(bs,(i<<3)+off,          C8Chunk._NA); break;\n          default: H2O.fail();\n        }\n      } else {\n        int x = (_xs[i]==Integer.MIN_VALUE+1 ? 0 : _xs[i])-scale;\n        long le = x >= 0\n            ? _ls[i]*DParseTask.pow10i( x)\n            : _ls[i]/DParseTask.pow10i(-x);\n        le -= bias;\n        switch( log ) {\n        case 0:          bs [i    +off] = (byte)le ; break;\n        case 1: UDP.set2(bs,(i<<1)+off,  (short)le); break;\n        case 2: UDP.set4(bs,(i<<2)+off,    (int)le); break;\n        case 3: UDP.set8(bs,(i<<3)+off,         le); break;\n        default: H2O.fail();\n        }\n      }\n    }\n    return bs;\n  }","id":92799,"modified_method":"private byte[] bufX( long bias, int scale, int off, int log ) {\n    byte[] bs = new byte[(_len2<<log)+off];\n    int j = 0;\n    for( int i=0; i<_len2; i++ ) {\n      long le = -bias;\n      if(_id == null || _id[j] == i){\n        if( isNA2(j) ) {\n          le = NAS[log];\n        } else {\n          int x = (_xs[j]==Integer.MIN_VALUE+1 ? 0 : _xs[j])-scale;\n          le += x >= 0\n              ? _ls[j]*DParseTask.pow10i( x)\n              : _ls[j]/DParseTask.pow10i(-x);\n        }\n        ++j;\n      }\n      switch( log ) {\n        case 0:          bs [i    +off] = (byte)le ; break;\n        case 1: UDP.set2(bs,(i<<1)+off,  (short)le); break;\n        case 2: UDP.set4(bs,(i<<2)+off,    (int)le); break;\n        case 3: UDP.set8(bs,(i<<3)+off,         le); break;\n        default: H2O.fail();\n      }\n    }\n    assert j == _len:\"j = \" + j + \", len = \" + _len + \", len2 = \" + _len2 + \", id[j] = \" + _id[j];\n    return bs;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override boolean set_impl(int i, long l) {\n    if( _ds != null ) throw H2O.unimpl();\n    if( _len2 != _len ) throw H2O.unimpl();\n    _ls[i]=l; _xs[i]=0;\n    return true;\n  }","id":92800,"modified_method":"@Override boolean set_impl(int i, long l) {\n    if( _ds   != null ) return set_impl(i,(double)l);\n    if(_len != _len2){ // sparse?\n      int idx = Arrays.binarySearch(_id,0,_len,i);\n      if(idx >= 0)i = idx;\n      else cancel_sparse(); // for now don't bother setting the sparse value\n    }\n    _ls[i]=l; _xs[i]=0;\n    return true;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void append2slowd( ) {\n    if( _len > Vec.CHUNK_SZ )\n      throw new ArrayIndexOutOfBoundsException(_len);\n    assert _ls==null && _len2==_len;\n    _ds = _ds==null ? MemoryManager.malloc8d(4) : MemoryManager.arrayCopyOf(_ds,_len<<1);\n  }","id":92801,"modified_method":"private void append2slowd( ) {\n    if( _len > Vec.CHUNK_SZ )\n      throw new ArrayIndexOutOfBoundsException(_len);\n    assert _ls==null;\n    boolean sparse = _id != null ||_ds == null;\n    _ds = _ds==null ? MemoryManager.malloc8d(4) : MemoryManager.arrayCopyOf(_ds,_len<<1);\n    if(sparse)\n      _id = _id==null ? MemoryManager.malloc4(4) : MemoryManager.arrayCopyOf(_id,_len<<1);\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void cancel_sparse() {\n    long ls[] = MemoryManager.malloc8(_len2+1);\n    for( int i=0; i<_len; i++ ) // Inflate ls to hold values\n      ls[_xs[i]] = _ls[i];\n    _ls = ls;\n    _xs = MemoryManager.malloc4(_len2+1);\n    _len = _len2;           // Not compressed now!\n  }","id":92802,"modified_method":"protected void cancel_sparse(){\n    if(_len != _len2){\n      if(_ds == null){\n        int []  xs = MemoryManager.malloc4(_len2);\n        long [] ls = MemoryManager.malloc8(_len2);\n        for(int i = 0; i < _len; ++i){\n          xs[_id[i]] = _xs[i];\n          ls[_id[i]] = _ls[i];\n        }\n        _xs = xs;\n        _ls = ls;\n      } else {\n        double [] ds = MemoryManager.malloc8d(_len2);\n        for(int i = 0; i < _len; ++i) ds[_id[i]] = _ds[i];\n        _ds = ds;\n      }\n      _id = null;\n      _len = _len2;\n    }\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public long   at8_impl( int i ) {\n    if( _len2 != _len ) throw H2O.unimpl();\n    if( _ls == null ) return (long)_ds[i];\n    return _ls[i]*DParseTask.pow10i(_xs[i]);\n  }","id":92803,"modified_method":"@Override public long   at8_impl( int i ) {\n    if( _len2 != _len ) {\n      int idx = Arrays.binarySearch(_id,0,_len,i);\n      if(idx >= 0) i = idx;\n      else return 0;\n    }\n    if( _ls == null ) return (long)_ds[i];\n    return _ls[i]*DParseTask.pow10i(_xs[i]);\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void addNum(double d) {\n    if( _ds==null||_len >= _ds.length ) append2slowd();\n    _ds[_len++] = d;  _len2++;\n  }","id":92804,"modified_method":"public void addNum(double d) {\n    if( _ds==null||_len >= _ds.length ) append2slowd();\n    _ds[_len] = d;\n    if(_id != null && d != 0) {\n      _id[_len] = _len2;\n      ++_len;\n    }\n    ++_len2;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void addr( NewChunk nc ) {\n    long  [] tmpl = _ls; _ls = nc._ls; nc._ls = tmpl;\n    int   [] tmpi = _xs; _xs = nc._xs; nc._xs = tmpi;\n    double[] tmpd = _ds; _ds = nc._ds; nc._ds = tmpd;\n    int      tmp  = _len; _len=nc._len; nc._len=tmp;\n    _len2=_len;\n    add(nc);\n  }","id":92805,"modified_method":"public void addr( NewChunk nc ) {\n    long  [] tmpl = _ls; _ls = nc._ls; nc._ls = tmpl;\n    int   [] tmpi = _xs; _xs = nc._xs; nc._xs = tmpi;\n             tmpi = _id; _id = nc._id; nc._id = tmpi;\n    double[] tmpd = _ds; _ds = nc._ds; nc._ds = tmpd;\n    int      tmp  = _len; _len=nc._len; nc._len=tmp;\n    _len2=_len;\n    add(nc);\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void append2slow( ) {\n    if( _len > Vec.CHUNK_SZ )\n      throw new ArrayIndexOutOfBoundsException(_len);\n    assert _ds==null;\n    if( _len2 == _len ) { // Check for sparse-ness now & then\n      int nzcnt=0;\n      for( int i=0; i<_len; i++ ) {\n        if( _ls[i]!=0 ) nzcnt++;\n        if( _xs[i]!=0 ) { nzcnt = Vec.CHUNK_SZ; break; } // Only non-specials sparse\n      }\n      if( _len >= 32 && nzcnt*8 <= _len ) { // Heuristic for sparseness\n        _len=0;\n        for( int i=0; i<_len2; i++ )\n          if( _ls[i] != 0 ) {\n            _xs[_len  ] = i;    // Row number in xs\n            _ls[_len++] = _ls[i]; // Sparse value in ls\n          }\n        return;                 // Compressed, so lots of room now\n      }\n    }\n    _xs = _ls==null ? MemoryManager.malloc4(4) : MemoryManager.arrayCopyOf(_xs,_len<<1);\n    _ls = _ls==null ? MemoryManager.malloc8(4) : MemoryManager.arrayCopyOf(_ls,_len<<1);\n  }","id":92806,"modified_method":"private void append2slow( ) {\n    if( _len > Vec.CHUNK_SZ )\n      throw new ArrayIndexOutOfBoundsException(_len);\n    assert _ds==null;\n    if(_ls == null){\n      _ls = MemoryManager.malloc8(4);\n      _xs = MemoryManager.malloc4(4);\n      _id = MemoryManager.malloc4(4);\n    } else {\n      _ls = MemoryManager.arrayCopyOf(_ls,_len<<1);\n      _xs = MemoryManager.arrayCopyOf(_xs,_len<<1);\n      if(_id != null)\n        _id = MemoryManager.arrayCopyOf(_id,_len<<1);\n    }\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public boolean isNA_impl( int i ) {\n    if( _len2 != _len ) throw H2O.unimpl();\n    return isNA(i);\n  }","id":92807,"modified_method":"@Override public boolean isNA_impl( int i ) {\n    if( _len2 != _len ) {\n      int idx = Arrays.binarySearch(_id,0,_len,i);\n      if(idx >= 0) i = idx;\n      else return false;\n    }\n    return isNA2(i);\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void add( NewChunk nc ) {\n    if( nc._len == 0 ) return;\n    if( _ds != null ) throw H2O.unimpl();\n    while( _len+nc._len >= _xs.length )\n      _xs = MemoryManager.arrayCopyOf(_xs,_xs.length<<1);\n    _ls = MemoryManager.arrayCopyOf(_ls,_xs.length);\n    System.arraycopy(nc._ls,0,_ls,_len,nc._len);\n    System.arraycopy(nc._xs,0,_xs,_len,nc._len);\n    _len2= (_len += nc._len);\n    nc._ls = null;  nc._xs = null;  nc._len = nc._len2 = 0;\n  }","id":92808,"modified_method":"public void add( NewChunk nc ) {\n    if( nc._len == 0 ) return;\n    if(nc.sparse() != sparse()){ // for now, just make it dense\n      cancel_sparse();\n      nc.cancel_sparse();\n    }\n    if( _ds != null ) throw H2O.unimpl();\n    while( _len+nc._len >= _xs.length )\n      _xs = MemoryManager.arrayCopyOf(_xs,_xs.length<<1);\n    _ls = MemoryManager.arrayCopyOf(_ls,_xs.length);\n    if(_id != null)\n      _id = MemoryManager.arrayCopyOf(_id,_xs.length);\n    System.arraycopy(nc._ls,0,_ls,_len,nc._len);\n    System.arraycopy(nc._xs,0,_xs,_len,nc._len);\n    if(nc._id != null)\n      System.arraycopy(nc._id,0,_id,_len,nc._len);\n    for(int i = _len; i < _len + nc._len; ++i) _id[i] += _len2;\n    _len += nc._len;\n    _len2 += nc._len2;\n    nc._ls = null;  nc._xs = null; nc._id = null; nc._len = nc._len2 = 0;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private Chunk chunkD() {\n    assert _len2==_len;\n    final byte [] bs = MemoryManager.malloc1(_len*8);\n    for(int i = 0; i < _len; ++i)\n      UDP.set8d(bs, 8*i, _ds != null?_ds[i]:(isNA(i)||isEnum(i))?Double.NaN:_ls[i]*DParseTask.pow10(_xs[i]));\n    return new C8DChunk(bs);\n  }","id":92809,"modified_method":"private Chunk chunkD() {\n    final byte [] bs = MemoryManager.malloc1(_len2*8);\n    int j = 0;\n    for(int i = 0; i < _len2; ++i){\n      double d = 0;\n      if(_id == null || _id[j] == i){\n        d = _ds != null?_ds[j]:(isNA2(j)||isEnum(j))?Double.NaN:_ls[j]*DParseTask.pow10(_xs[j]);\n        ++j;\n      }\n      UDP.set8d(bs, 8*i, d);\n    }\n    assert j == _len:\"j = \" + j + \", _len = \" + _len;\n    return new C8DChunk(bs);\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"Chunk compress() {\n    // Check for basic mode info: all missing or all strings or mixed stuff\n    byte mode = type();\n    if( mode==AppendableVec.NA ) // ALL NAs, nothing to do\n      return new C0DChunk(Double.NaN,_len);\n    boolean rerun=false;\n    for( int i=0; i<_len; i++ )\n      if( mode==AppendableVec.ENUM   && !isEnum(i) ||\n          mode==AppendableVec.NUMBER &&  isEnum(i) )\n        { setNA_impl(i); rerun = true; }  // Smack any mismatched string/numbers\n    if( rerun ) { _naCnt = -1;  type(); } // Re-run rollups after dropping all numbers/enums\n\n    // If the data was set8 as doubles, we do a quick check to see if it's\n    // plain longs.  If not, we give up and use doubles.\n    if( _ds != null ) {\n      int i=0;\n      for( ; i<_len; i++ ) // Attempt to inject all doubles into longs\n        if( !Double.isNaN(_ds[i]) && (double)(long)_ds[i] != _ds[i] ) break;\n      if( i<_len ) return chunkD();\n      _ls = new long[_ds.length]; // Else flip to longs\n      _xs = new int [_ds.length];\n      for( i=0; i<_len; i++ )   // Inject all doubles into longs\n        if( Double.isNaN(_ds[i]) ) _xs[i] = Integer.MIN_VALUE;\n        else                       _ls[i] = (long)_ds[i];\n      _ds = null;\n    }\n\n    // IF (_len2 > _len) THEN Sparse\n    // Check for compressed *during appends*.  Here we know:\n    // - No specials; _xs[]==0.\n    // - No floats; _ds==null\n    // - NZ length in _len, actual length in _len2.\n    // - Huge ratio between _len2 and _len, and we do NOT want to inflate to\n    //   the larger size; we need to keep it all small all the time.\n    // - Rows in _xs\n\n    // Data in some fixed-point format, not doubles\n    // See if we can sanely normalize all the data to the same fixed-point.\n    int  xmin = Integer.MAX_VALUE;   // min exponent found\n    long lemin= 0, lemax=lemin; // min/max at xmin fixed-point\n    boolean overflow=false;\n    boolean floatOverflow = false;\n    boolean first = true;\n    double min = _len2==_len ?  Double.MAX_VALUE : 0;\n    double max = _len2==_len ? -Double.MAX_VALUE : 0;\n    int p10iLength = DParseTask.powers10i.length;\n\n    for( int i=0; i<_len; i++ ) {\n      if( isNA(i) ) continue;\n      long l = _ls[i];\n      int  x = _xs[i];\n      if( x==Integer.MIN_VALUE+1 || _len2 != _len ) x=0; // Replace enum flag with no scaling\n      assert l!=0 || x==0;      // Exponent of zero is always zero\n      // Compute per-chunk min/max\n      double d = l*DParseTask.pow10(x);\n      if( d < min ) min = d;\n      if( d > max ) max = d;\n      long t;                   // Remove extra scaling\n      while( l!=0 && (t=l/10)*10==l ) { l=t; x++; }\n      floatOverflow = Math.abs(l) > MAX_FLOAT_MANTISSA;\n      if( first ) {\n        first = false;\n        xmin = x;\n        lemin = lemax = l;\n        continue;\n      }\n      // Track largest/smallest values at xmin scale.  Note overflow.\n      if( x < xmin ) {\n        if( overflow || (overflow = ((xmin-x) >=p10iLength)) ) continue;\n        lemin *= DParseTask.pow10i(xmin-x);\n        lemax *= DParseTask.pow10i(xmin-x);\n        xmin = x;               // Smaller xmin\n      }\n      // *this* value, as a long scaled at the smallest scale\n      if( overflow || (overflow = ((x-xmin) >=p10iLength)) ) continue;\n      long le = l*DParseTask.pow10i(x-xmin);\n      if( le < lemin ) lemin=le;\n      if( le > lemax ) lemax=le;\n    }\n\n    if(_len2 != _len){ // sparse? compare xmin/lemin/lemax with 0\n      lemin = Math.min(0, lemin);\n      lemax = Math.max(0, lemax);\n    }\n\n    // Constant column?\n    if( _naCnt==0 && min==max ) {\n      return ((long)min  == min)\n          ? new C0LChunk((long)min,_len2)\n          : new C0DChunk(      min,_len2);\n    }\n\n    // Boolean column?\n    if (max == 1 && min == 0 && xmin == 0 && !overflow) {\n      if( _nzCnt*32 < _len2 && _naCnt==0 && _len2 < 65535 && xmin == 0 ) // Very sparse? (and not too big?)\n        if( _len2 == _len ) return new CX0Chunk(_ls,_len2,_nzCnt); // Dense  constructor\n        else                return new CX0Chunk(_xs,_len2,_len  ); // Sparse constructor\n      int bpv = _strCnt+_naCnt > 0 ? 2 : 1;   // Bit-vector\n      byte[] cbuf = bufB(bpv);\n      return new CBSChunk(cbuf, cbuf[0], cbuf[1]);\n    }\n\n    final boolean fpoint = xmin < 0 || min < Long.MIN_VALUE || max > Long.MAX_VALUE;\n\n    // Result column must hold floats?\n    // Highly sparse but not a bitvector or constant?\n    if( !fpoint && (_nzCnt+_naCnt)*8 < _len2 && _len2 < 65535 && xmin==0 && // (and not too big?)\n        lemin > Short.MIN_VALUE && lemax <= Short.MAX_VALUE ) // Only handling unbiased shorts here\n      if( _len2==_len ) return new CX2Chunk(_ls,_xs,_len2,_nzCnt,_naCnt);  // Sparse byte chunk\n      else              return new CX2Chunk(_ls,_xs,_len2,_len);\n\n    // Exponent scaling: replacing numbers like 1.3 with 13e-1.  '13' fits in a\n    // byte and we scale the column by 0.1.  A set of numbers like\n    // {1.2,23,0.34} then is normalized to always be represented with 2 digits\n    // to the right: {1.20,23.00,0.34} and we scale by 100: {120,2300,34}.\n    // This set fits in a 2-byte short.\n\n    // We use exponent-scaling for bytes & shorts only; it's uncommon (and not\n    // worth it) for larger numbers.  We need to get the exponents to be\n    // uniform, so we scale up the largest lmax by the largest scale we need\n    // and if that fits in a byte/short - then it's worth compressing.  Other\n    // wise we just flip to a float or double representation.\n    if( overflow || (fpoint && floatOverflow) || -35 > xmin || xmin > 35 )\n      return chunkD();\n    if( fpoint ) {\n      if((int)lemin == lemin && (int)lemax == lemax){\n        if(lemax-lemin < 255 && (int)lemin == lemin ) // Fits in scaled biased byte?\n          return new C1SChunk( bufX(lemin,xmin,C1SChunk.OFF,0),(int)lemin,DParseTask.pow10(xmin));\n        if(lemax-lemin < 65535 ) { // we use signed 2B short, add -32k to the bias!\n          long bias = 32767 + lemin;\n          return new C2SChunk( bufX(bias,xmin,C2SChunk.OFF,1),(int)bias,DParseTask.pow10(xmin));\n        }\n        if(lemax - lemin < Integer.MAX_VALUE)\n          return new C4SChunk(bufX(lemin, xmin,C4SChunk.OFF,2),(int)lemin,DParseTask.pow10(xmin));\n      }\n      return chunkD();\n    } // else an integer column\n    // Compress column into a byte\n    if(xmin == 0 &&  0<=lemin && lemax <= 255 && ((_naCnt + _strCnt)==0) )\n      return new C1NChunk( bufX(0,0,C1NChunk.OFF,0));\n    if(lemin < Integer.MIN_VALUE)return new C8Chunk( bufX(0,0,0,3));\n    if( lemax-lemin < 255 ) {         // Span fits in a byte?\n      if(0 <= min && max < 255 )      // Span fits in an unbiased byte?\n        return new C1Chunk( bufX(0,0,C1Chunk.OFF,0));\n      return new C1SChunk( bufX(lemin,xmin,C1SChunk.OFF,0),(int)lemin,DParseTask.pow10i(xmin));\n    }\n\n    // Compress column into a short\n    if( lemax-lemin < 65535 ) {               // Span fits in a biased short?\n      if( xmin == 0 && Short.MIN_VALUE < lemin && lemax <= Short.MAX_VALUE ) // Span fits in an unbiased short?\n        return new C2Chunk( bufX(0,0,C2Chunk.OFF,1));\n      int bias = (int)(lemin-(Short.MIN_VALUE+1));\n      return new C2SChunk( bufX(bias,xmin,C2SChunk.OFF,1),bias,DParseTask.pow10i(xmin));\n    }\n    // Compress column into ints\n    if( Integer.MIN_VALUE < min && max <= Integer.MAX_VALUE )\n      return new C4Chunk( bufX(0,0,0,2));\n    return new C8Chunk( bufX(0,0,0,3));\n  }","id":92810,"modified_method":"Chunk compress() {\n    // Check for basic mode info: all missing or all strings or mixed stuff\n    byte mode = type();\n    if( mode==AppendableVec.NA ) // ALL NAs, nothing to do\n      return new C0DChunk(Double.NaN,_len);\n    boolean rerun=false;\n    if(mode == AppendableVec.ENUM){\n      for( int i=0; i<_len; i++ )\n        if(isEnum2(i))\n          _xs[i] = 0;\n        else if(!isNA2(i)){\n          setNA_impl2(i);\n          ++_naCnt;\n        }\n        // Smack any mismatched string/numbers\n    } else if(mode == AppendableVec.NUMBER){\n      for( int i=0; i<_len; i++ )\n        if(isEnum2(i)) {\n          setNA_impl2(i);\n          rerun = true;\n        }\n    }\n    if( rerun ) { _naCnt = -1;  type(); } // Re-run rollups after dropping all numbers/enums\n\n    // If the data was set8 as doubles, we do a quick check to see if it's\n    // plain longs.  If not, we give up and use doubles.\n    if( _ds != null ) {\n      int i=0;\n      for( ; i<_len; i++ ) // Attempt to inject all doubles into longs\n        if( !Double.isNaN(_ds[i]) && (double)(long)_ds[i] != _ds[i] ) break;\n      if( i<_len )\n        return chunkD();\n      _ls = new long[_ds.length]; // Else flip to longs\n      _xs = new int [_ds.length];\n      for( i=0; i<_len; i++ )   // Inject all doubles into longs\n        if( Double.isNaN(_ds[i]) ){_xs[i] = Integer.MIN_VALUE;_ls[i] = 0;}\n        else                       _ls[i] = (long)_ds[i];\n      _ds = null;\n    }\n\n    // IF (_len2 > _len) THEN Sparse\n    // Check for compressed *during appends*.  Here we know:\n    // - No specials; _xs[]==0.\n    // - No floats; _ds==null\n    // - NZ length in _len, actual length in _len2.\n    // - Huge ratio between _len2 and _len, and we do NOT want to inflate to\n    //   the larger size; we need to keep it all small all the time.\n    // - Rows in _xs\n\n    // Data in some fixed-point format, not doubles\n    // See if we can sanely normalize all the data to the same fixed-point.\n    int  xmin = Integer.MAX_VALUE;   // min exponent found\n    long lemin= 0, lemax=lemin; // min/max at xmin fixed-point\n    boolean overflow=false;\n    boolean floatOverflow = false;\n    boolean first = true;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int p10iLength = DParseTask.powers10i.length;\n\n    for( int i=0; i<_len; i++ ) {\n      if( isNA2(i) ) continue;\n      long l = _ls[i];\n      int  x = _xs[i];\n      assert x != Integer.MIN_VALUE:\"l = \" + l + \", x = \" + x;\n      if( x==Integer.MIN_VALUE+1) x=0; // Replace enum flag with no scaling\n      assert l!=0 || x==0:\"l == 0 while x = \" + x + \" ls = \" + Arrays.toString(_ls);      // Exponent of zero is always zero\n      // Compute per-chunk min/max\n      double d = l*DParseTask.pow10(x);\n      if( d < min ) min = d;\n      if( d > max ) max = d;\n      long t;                   // Remove extra scaling\n      while( l!=0 && (t=l/10)*10==l ) { l=t; x++; }\n      floatOverflow = Math.abs(l) > MAX_FLOAT_MANTISSA;\n      if( first ) {\n        first = false;\n        xmin = x;\n        lemin = lemax = l;\n        continue;\n      }\n      // Track largest/smallest values at xmin scale.  Note overflow.\n      if( x < xmin ) {\n        if( overflow || (overflow = ((xmin-x) >=p10iLength)) ) continue;\n        lemin *= DParseTask.pow10i(xmin-x);\n        lemax *= DParseTask.pow10i(xmin-x);\n        xmin = x;               // Smaller xmin\n      }\n      // *this* value, as a long scaled at the smallest scale\n      if( overflow || (overflow = ((x-xmin) >=p10iLength)) ) continue;\n      long le = l*DParseTask.pow10i(x-xmin);\n      if( le < lemin ) lemin=le;\n      if( le > lemax ) lemax=le;\n    }\n\n    if(_len2 != _len){ // sparse? compare xmin/lemin/lemax with 0\n      lemin = Math.min(0, lemin);\n      lemax = Math.max(0, lemax);\n      min = Math.min(min,0);\n      max = Math.max(max,0);\n    }\n\n    // Constant column?\n    if( _naCnt==0 && min==max ) {\n      return ((long)min  == min)\n          ? new C0LChunk((long)min,_len2)\n          : new C0DChunk(      min,_len2);\n    }\n\n    // Boolean column?\n    if (max == 1 && min == 0 && xmin == 0 && !overflow) {\n      if( _nzCnt*32 < _len2) { // Very sparse?\n        if(_len2 == _len)set_sparse(_nzCnt);\n        return  _naCnt==0\n          ?new CX0Chunk(_len2,_len,bufS(0))// No NAs, can store as sparse bitvector\n          :new CXIChunk(_len2,_len,1,bufS(1)); // have NAs, store as sparse 1byte values\n      }\n\n      int bpv = _strCnt+_naCnt > 0 ? 2 : 1;   // Bit-vector\n      byte[] cbuf = bufB(bpv);\n      return new CBSChunk(cbuf, cbuf[0], cbuf[1]);\n    }\n\n    final boolean fpoint = xmin < 0 || min < Long.MIN_VALUE || max > Long.MAX_VALUE;\n\n    // sparse? treat as sparse iff we have at least 32x more zeros than nonzeros\n    if(_len2 > (_nzCnt + _naCnt) << 5){\n      set_sparse(_nzCnt + _naCnt);\n      assert _id != null && _id.length >= (_nzCnt + _naCnt);\n      if(fpoint) return new CXDChunk(_len2,_len,8,bufD(8));\n      int sz = 8;\n      if(Short.MIN_VALUE <= min && max <= Short.MAX_VALUE)sz = 2;\n      else if(Integer.MIN_VALUE <= min && max <= Integer.MAX_VALUE)sz = 4;\n      return new CXIChunk(_len2,_len,sz,bufS(sz));\n    }\n    // Exponent scaling: replacing numbers like 1.3 with 13e-1.  '13' fits in a\n    // byte and we scale the column by 0.1.  A set of numbers like\n    // {1.2,23,0.34} then is normalized to always be represented with 2 digits\n    // to the right: {1.20,23.00,0.34} and we scale by 100: {120,2300,34}.\n    // This set fits in a 2-byte short.\n\n    // We use exponent-scaling for bytes & shorts only; it's uncommon (and not\n    // worth it) for larger numbers.  We need to get the exponents to be\n    // uniform, so we scale up the largest lmax by the largest scale we need\n    // and if that fits in a byte/short - then it's worth compressing.  Other\n    // wise we just flip to a float or double representation.\n    if( overflow || (fpoint && floatOverflow) || -35 > xmin || xmin > 35 )\n      return chunkD();\n    if( fpoint ) {\n      if((int)lemin == lemin && (int)lemax == lemax){\n        if(lemax-lemin < 255 && (int)lemin == lemin ) // Fits in scaled biased byte?\n          return new C1SChunk( bufX(lemin,xmin,C1SChunk.OFF,0),(int)lemin,DParseTask.pow10(xmin));\n        if(lemax-lemin < 65535 ) { // we use signed 2B short, add -32k to the bias!\n          long bias = 32767 + lemin;\n          return new C2SChunk( bufX(bias,xmin,C2SChunk.OFF,1),(int)bias,DParseTask.pow10(xmin));\n        }\n        if(lemax - lemin < Integer.MAX_VALUE)\n          return new C4SChunk(bufX(lemin, xmin,C4SChunk.OFF,2),(int)lemin,DParseTask.pow10(xmin));\n      }\n      return chunkD();\n    } // else an integer column\n    // Compress column into a byte\n    if(xmin == 0 &&  0<=lemin && lemax <= 255 && ((_naCnt + _strCnt)==0) )\n      return new C1NChunk( bufX(0,0,C1NChunk.OFF,0));\n    if(lemin < Integer.MIN_VALUE)return new C8Chunk( bufX(0,0,0,3));\n    if( lemax-lemin < 255 ) {         // Span fits in a byte?\n      if(0 <= min && max < 255 )      // Span fits in an unbiased byte?\n        return new C1Chunk( bufX(0,0,C1Chunk.OFF,0));\n      return new C1SChunk( bufX(lemin,xmin,C1SChunk.OFF,0),(int)lemin,DParseTask.pow10i(xmin));\n    }\n\n    // Compress column into a short\n    if( lemax-lemin < 65535 ) {               // Span fits in a biased short?\n      if( xmin == 0 && Short.MIN_VALUE < lemin && lemax <= Short.MAX_VALUE ) // Span fits in an unbiased short?\n        return new C2Chunk( bufX(0,0,C2Chunk.OFF,1));\n      int bias = (int)(lemin-(Short.MIN_VALUE+1));\n      return new C2SChunk( bufX(bias,xmin,C2SChunk.OFF,1),bias,DParseTask.pow10i(xmin));\n    }\n    // Compress column into ints\n    if( Integer.MIN_VALUE < min && max <= Integer.MAX_VALUE )\n      return new C4Chunk( bufX(0,0,0,2));\n    return new C8Chunk( bufX(0,0,0,3));\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public NewChunk( Chunk C ) {\n    this(C._vec,C._vec.elem2ChunkIdx(C._start));\n    _len = _len2 = C._len;\n  }","id":92811,"modified_method":"public NewChunk( Chunk C ) {\n    this(C._vec, C._vec.elem2ChunkIdx(C._start));\n    _len2 = C._len;\n    _len = C.sparseLen();\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private byte[] bufB(int bpv) {\n    assert bpv == 1 || bpv == 2 : \"Only bit vectors with/without NA are supported\";\n    final int off = CBSChunk.OFF;\n    int clen  = off + CBSChunk.clen(_len2, bpv);\n    byte bs[] = new byte[clen];\n    // Save the gap = number of unfilled bits and bpv value\n    bs[0] = (byte) (((_len2*bpv)&7)==0 ? 0 : (8-((_len2*bpv)&7)));\n    bs[1] = (byte) bpv;\n\n    if( _len2 != _len ) {       // Sparse bitvector?\n      assert bpv==1;            // No NAs\n      for (int i=0; i<_len; i++) {\n        int row = _xs[i];\n        bs[(row>>3)+off] = CBSChunk.write1b(bs[(row>>3)+off],(byte)1,row&7);\n      }\n      return bs;\n    }\n\n    // Dense bitvector\n    int  boff = 0;\n    byte b    = 0;\n    int  idx  = CBSChunk.OFF;\n    for (int i=0; i<_len; i++) {\n      if( bpv==1 ) {\n        assert !isNA(i);\n        b = CBSChunk.write1b(b, (byte)_ls[i], boff);\n      } else {\n        byte val = isNA(i) ? CBSChunk._NA : (byte)_ls[i];\n        b = CBSChunk.write2b(b, val, boff);\n      }\n      boff += bpv;\n      if (boff>8-bpv) { bs[idx] = b; boff = 0; b = 0; idx++; }\n    }\n    assert bs[0] == (byte) (boff == 0 ? 0 : 8-boff);\n    // Flush last byte\n    if (boff>0) bs[idx++] = b;\n    return bs;\n  }","id":92812,"modified_method":"private byte[] bufB(int bpv) {\n    assert bpv == 1 || bpv == 2 : \"Only bit vectors with/without NA are supported\";\n    final int off = CBSChunk.OFF;\n    int clen  = off + CBSChunk.clen(_len2, bpv);\n    byte bs[] = new byte[clen];\n    // Save the gap = number of unfilled bits and bpv value\n    bs[0] = (byte) (((_len2*bpv)&7)==0 ? 0 : (8-((_len2*bpv)&7)));\n    bs[1] = (byte) bpv;\n\n    // Dense bitvector\n    int  boff = 0;\n    byte b    = 0;\n    int  idx  = CBSChunk.OFF;\n    int j = 0;\n    for (int i=0; i<_len2; i++) {\n      byte val = 0;\n      if(_id == null || _id[j] == i) {\n        assert bpv == 2 || !isNA2(j);\n        val = (byte)(isNA2(j)?CBSChunk._NA:_ls[j]);\n        ++j;\n      }\n      if( bpv==1 )\n        b = CBSChunk.write1b(b, val, boff);\n      else\n        b = CBSChunk.write2b(b, val, boff);\n      boff += bpv;\n      if (boff>8-bpv) { assert boff == 8; bs[idx] = b; boff = 0; b = 0; idx++; }\n    }\n    assert bs[0] == (byte) (boff == 0 ? 0 : 8-boff):\"b[0] = \" + bs[0] + \", boff = \" + boff + \", bpv = \" + bpv;\n    // Flush last byte\n    if (boff>0) bs[idx++] = b;\n    return bs;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"protected final boolean isNA(int idx) {\n    return (_ds == null) ? (_ls[idx] == 0 && _xs[idx] == Integer.MIN_VALUE) : Double.isNaN(_ds[idx]);\n  }","id":92813,"modified_method":"protected final boolean isNA2(int idx) {\n    return (_ds == null) ? (_ls[idx] == 0 && _xs[idx] == Integer.MIN_VALUE) : Double.isNaN(_ds[idx]);\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"void append2( long l, int x ) {\n    if( _ls==null||_len >= _ls.length ) append2slow();\n    if( _len2 != _len ) {         // Sparse?\n      if( x!=0 ) cancel_sparse(); // NA?  Give it up!\n      else if( l==0 ) { _len2++; return; } // Just One More Zero\n      else x = _len2;             // NZ: set the row over the xs field\n    }\n    _ls[_len  ] = l;\n    _xs[_len++] = x;  _len2++;\n  }","id":92814,"modified_method":"void append2( long l, int x ) {\n    if( _ls==null||_len >= _ls.length ) append2slow();\n    if(_id == null){\n      _ls[_len] = l;\n      _xs[_len] = x;\n      _len++;\n    } else if(l != 0 || x != 0){\n      _ls[_len] = l;\n      _id[_len] = _len2;\n      _xs[_len] = x;\n      _len++;\n    }\n    _len2++;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public byte type() {\n    if( _naCnt == -1 ) {        // No rollups yet?\n      int nas=0, ss=0, nzs=0;\n      if( _ds != null ) {\n        assert _ls==null && _xs==null;\n        for( double d : _ds ) if( Double.isNaN(d) ) nas++; else if( d!=0 ) nzs++;\n      } else {\n        assert _ds==null;\n        if( _ls != null )\n          for( int i=0; i<_len; i++ )\n            if( isNA(i) ) nas++;\n            else {\n              if( isEnum(i)   ) ss++;\n              if( _ls[i] != 0 ) nzs++;\n            }\n      }\n      _nzCnt=nzs;  _strCnt=ss;  _naCnt=nas;\n    }\n    // Now run heuristic for type\n    if(_naCnt == _len2)          // All NAs ==> NA Chunk\n      return AppendableVec.NA;\n    if(_strCnt > 0 && _strCnt + _naCnt == _len2)\n      return AppendableVec.ENUM; // All are Strings+NAs ==> Enum Chunk\n    // Larger of time & numbers\n    int timCnt=0; for( int t : _timCnt ) timCnt+=t;\n    int nums = _len2-_naCnt-timCnt;\n    return timCnt >= nums ? AppendableVec.TIME : AppendableVec.NUMBER;\n  }","id":92815,"modified_method":"public byte type() {\n    if( _naCnt == -1 ) {        // No rollups yet?\n      int nas=0, ss=0, nzs=0;\n      if( _ds != null ) {\n        assert _ls==null && _xs==null;\n        for( double d : _ds ) if( Double.isNaN(d) ) nas++; else if( d!=0 ) nzs++;\n      } else {\n        assert _ds==null;\n        if( _ls != null )\n          for( int i=0; i<_len; i++ )\n            if( isNA2(i) ) nas++;\n            else {\n              if( isEnum2(i)   ) ss++;\n              if( _ls[i] != 0 ) nzs++;\n            }\n      }\n      _nzCnt=nzs;  _strCnt=ss;  _naCnt=nas;\n    }\n    // Now run heuristic for type\n    if(_naCnt == _len2)          // All NAs ==> NA Chunk\n      return AppendableVec.NA;\n    if(_strCnt > 0 && _strCnt + _naCnt == _len2)\n      return AppendableVec.ENUM; // All are Strings+NAs ==> Enum Chunk\n    // Larger of time & numbers\n    int timCnt=0; for( int t : _timCnt ) timCnt+=t;\n    int nums = _len2-_naCnt-timCnt;\n    return timCnt >= nums ? AppendableVec.TIME : AppendableVec.NUMBER;\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void testImpl( long[] ls, int[] xs, Class C, boolean hasFloat ) {\n    AppendableVec av = new AppendableVec(Vec.newKey());\n    NewChunk nv = new NewChunk(av,0);\n    nv._ls = ls;\n    nv._xs = xs;\n    nv._len= nv._len2 = ls.length;\n    Chunk bv = nv.compress();\n    bv._vec = av.close(new Futures());\n    // Compression returns the expected compressed-type:\n    assertTrue( \"Found chunk class \"+bv.getClass()+\" but expected \"+C, C.isInstance(bv) );\n    assertEquals( hasFloat, bv.hasFloat() );\n    // Also, we can decompress correctly\n    for( int i=0; i<ls.length; i++ )\n      assertEquals(ls[i]*DParseTask.pow10(xs[i]), bv.at0(i), bv.at0(i)*EPSILON);\n    UKV.remove(av._key);\n  }","id":92816,"modified_method":"private void testImpl( long[] ls, int[] xs, Class C, boolean hasFloat ) {\n    int [] id = new int[xs.length];\n    for(int i = 0; i < xs.length; ++i)id[i] = i;\n    testImpl(ls,xs,id,C,hasFloat);\n  }","commit_id":"20e5525dec11a90236412b06efd2f7b86aa8affe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void visit(CollectionSetVisitor visitor) {\n        visitor.visitCollectionSet(this);\n        \n        for (Iterator iter = getResources().iterator(); iter.hasNext();) {\n            CollectionResource resource = (CollectionResource) iter.next();\n            resource.visit(visitor);\n        }\n        \n        visitor.completeCollectionSet(this);\n    }","id":92817,"modified_method":"public void visit(CollectionSetVisitor visitor) {\n        visitor.visitCollectionSet(this);\n        \n        for (CollectionResource resource : getResources()) {\n            resource.visit(visitor);\n        }\n        \n        visitor.completeCollectionSet(this);\n    }","commit_id":"c1fc1d8620791f4d979a16934360b7ee383440ab","url":"https://github.com/OpenNMS/opennms"},{"original_method":"CollectionTracker getTracker() {\n        List<Collectable> trackers = new ArrayList<Collectable>(3);\n       \n        if (getIfNumber() != null) {\n        \ttrackers.add(getIfNumber());\n        }\n        if (getNodeCollector() != null) {\n        \ttrackers.add(getNodeCollector());\n        }\n        if (getIfCollector() != null) {\n        \ttrackers.add(getIfCollector());\n        }\n       \n        return new AggregateTracker(trackers);\n    }","id":92818,"modified_method":"CollectionTracker getTracker() {\n        List<Collectable> trackers = new ArrayList<Collectable>(4);\n       \n        if (getIfNumber() != null) {\n        \ttrackers.add(getIfNumber());\n        }\n        if (getSysUpTime() != null) {\n            trackers.add(getSysUpTime());\n        }\n        if (getNodeCollector() != null) {\n        \ttrackers.add(getNodeCollector());\n        }\n        if (getIfCollector() != null) {\n        \ttrackers.add(getIfCollector());\n        }\n       \n        return new AggregateTracker(trackers);\n    }","commit_id":"c1fc1d8620791f4d979a16934360b7ee383440ab","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void logIfCounts() {\n        CollectionAgent agent = getCollectionAgent();\n        log().debug(\"collect: nodeId: \" + agent.getNodeId()\n                + \" interface: \" + agent.getHostAddress()\n                + \" ifCount: \" + getIfNumber().getIfNumber() \n                + \" savedIfCount: \" + agent.getSavedIfCount());\n    }","id":92819,"modified_method":"private void logIfCounts() {\n        CollectionAgent agent = getCollectionAgent();\n        log().debug(\"collect: nodeId: \" + agent.getNodeId()\n                + \" interface: \" + agent.getHostAddress()\n                + \" ifCount: \" + getIfNumber().getIntValue() \n                + \" savedIfCount: \" + agent.getSavedIfCount());\n    }","commit_id":"c1fc1d8620791f4d979a16934360b7ee383440ab","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean rescanNeeded() {\n        \n        final RescanNeeded rescanNeeded = new RescanNeeded();\n        visit(new ResourceVisitor() {\n        \n            public void visitResource(CollectionResource resource) {\n                log().debug(\"rescanNeeded: Visiting resource \" + resource);\n                if (resource.rescanNeeded()) {\n                    log().debug(\"Sending rescan event for \"+getCollectionAgent()+\" because resource \"+resource+\" indicated it was needed\");\n                    rescanNeeded.rescanIndicated();\n                }\n            }\n            \n        });\n            \n        checkForNewInterfaces(rescanNeeded);\n        \n        return rescanNeeded.rescanIsNeeded();\n    }","id":92820,"modified_method":"public boolean rescanNeeded() {\n        \n        final RescanNeeded rescanNeeded = new RescanNeeded();\n        visit(new ResourceVisitor() {\n        \n            public void visitResource(CollectionResource resource) {\n                log().debug(\"rescanNeeded: Visiting resource \" + resource);\n                if (resource.rescanNeeded()) {\n                    log().debug(\"Sending rescan event for \"+getCollectionAgent()+\" because resource \"+resource+\" indicated it was needed\");\n                    rescanNeeded.rescanIndicated();\n                }\n            }\n            \n        });\n            \n        checkForNewInterfaces(rescanNeeded);\n        checkForSystemRestart(rescanNeeded);\n\n        return rescanNeeded.rescanIsNeeded();\n    }","commit_id":"c1fc1d8620791f4d979a16934360b7ee383440ab","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void checkForNewInterfaces(SnmpCollectionSet.RescanNeeded rescanNeeded) {\n        if (!hasInterfaceDataToCollect()) return;\n        \n        logIfCounts();\n    \n        if (ifCountHasChanged(getCollectionAgent())) {\n            log().info(\"Sending rescan event because the number of interfaces on primary SNMP \"\n            + \"interface \" + getCollectionAgent().getHostAddress()\n            + \" has changed, generating 'ForceRescan' event.\");\n            rescanNeeded.rescanIndicated();\n        }\n    \n        getCollectionAgent().setSavedIfCount(getIfNumber().getIfNumber());\n    }","id":92821,"modified_method":"void checkForNewInterfaces(SnmpCollectionSet.RescanNeeded rescanNeeded) {\n        if (!hasInterfaceDataToCollect()) return;\n        \n        logIfCounts();\n    \n        if (getIfNumber().isChanged(getCollectionAgent().getSavedIfCount())) {\n            log().info(\"Sending rescan event because the number of interfaces on primary SNMP \"\n            + \"interface \" + getCollectionAgent().getHostAddress()\n            + \" has changed, generating 'ForceRescan' event.\");\n            rescanNeeded.rescanIndicated();\n        }\n    \n        getCollectionAgent().setSavedIfCount(getIfNumber().getIntValue());\n    }","commit_id":"c1fc1d8620791f4d979a16934360b7ee383440ab","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SnmpCollectionSet.IfNumberTracker createIfNumberTracker() {\n        SnmpCollectionSet.IfNumberTracker ifNumber = null;\n        if (hasInterfaceDataToCollect()) {\n            ifNumber = new SnmpCollectionSet.IfNumberTracker();\n        }\n        return ifNumber;\n    }","id":92822,"modified_method":"private IfNumberTracker createIfNumberTracker() {\n        IfNumberTracker ifNumber = null;\n        if (hasInterfaceDataToCollect()) {\n            ifNumber = new IfNumberTracker();\n        }\n        return ifNumber;\n    }","commit_id":"c1fc1d8620791f4d979a16934360b7ee383440ab","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String toString() {\n    \tStringBuffer buffer = new StringBuffer();\n\n    \tbuffer.append(\"CollectionAgent: \");\n    \tbuffer.append(m_agent);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"OnmsSnmpCollection: \");\n    \tbuffer.append(m_snmpCollection);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"SnmpIfCollector: \");\n    \tbuffer.append(m_ifCollector);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"IfNumberTracker: \");\n    \tbuffer.append(m_ifNumber);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"SnmpNodeCollector: \");\n    \tbuffer.append(m_nodeCollector);\n    \tbuffer.append(\"\\n\");\n    \t\n    \treturn buffer.toString();\n    }","id":92823,"modified_method":"public String toString() {\n    \tStringBuffer buffer = new StringBuffer();\n\n    \tbuffer.append(\"CollectionAgent: \");\n    \tbuffer.append(m_agent);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"OnmsSnmpCollection: \");\n    \tbuffer.append(m_snmpCollection);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"SnmpIfCollector: \");\n    \tbuffer.append(m_ifCollector);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"IfNumberTracker: \");\n    \tbuffer.append(m_ifNumber);\n    \tbuffer.append(\"\\n\");\n    \t\n        buffer.append(\"SysUpTimeTracker: \");\n        buffer.append(m_sysUpTime);\n        buffer.append(\"\\n\");\n        \n    \tbuffer.append(\"SnmpNodeCollector: \");\n    \tbuffer.append(m_nodeCollector);\n    \tbuffer.append(\"\\n\");\n    \t\n    \treturn buffer.toString();\n    }","commit_id":"c1fc1d8620791f4d979a16934360b7ee383440ab","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SnmpCollectionSet.IfNumberTracker createIfNumberTracker() {\n        SnmpCollectionSet.IfNumberTracker ifNumber = null;\n        if (hasInterfaceDataToCollect()) {\n            ifNumber = new SnmpCollectionSet.IfNumberTracker();\n        }\n        return ifNumber;\n    }","id":92824,"modified_method":"private IfNumberTracker createIfNumberTracker() {\n        IfNumberTracker ifNumber = null;\n        if (hasInterfaceDataToCollect()) {\n            ifNumber = new IfNumberTracker();\n        }\n        return ifNumber;\n    }","commit_id":"ca567f18d8f6b6b94fd22ed1ef5fcb2256ca186e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void checkForNewInterfaces(SnmpCollectionSet.RescanNeeded rescanNeeded) {\n        if (!hasInterfaceDataToCollect()) return;\n        \n        logIfCounts();\n    \n        if (ifCountHasChanged(getCollectionAgent())) {\n            log().info(\"Sending rescan event because the number of interfaces on primary SNMP \"\n            + \"interface \" + getCollectionAgent().getHostAddress()\n            + \" has changed, generating 'ForceRescan' event.\");\n            rescanNeeded.rescanIndicated();\n        }\n    \n        getCollectionAgent().setSavedIfCount(getIfNumber().getIfNumber());\n    }","id":92825,"modified_method":"void checkForNewInterfaces(SnmpCollectionSet.RescanNeeded rescanNeeded) {\n        if (!hasInterfaceDataToCollect()) return;\n        \n        logIfCounts();\n    \n        if (getIfNumber().isChanged(getCollectionAgent().getSavedIfCount())) {\n            log().info(\"Sending rescan event because the number of interfaces on primary SNMP \"\n            + \"interface \" + getCollectionAgent().getHostAddress()\n            + \" has changed, generating 'ForceRescan' event.\");\n            rescanNeeded.rescanIndicated();\n        }\n    \n        getCollectionAgent().setSavedIfCount(getIfNumber().getIntValue());\n    }","commit_id":"ca567f18d8f6b6b94fd22ed1ef5fcb2256ca186e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String toString() {\n    \tStringBuffer buffer = new StringBuffer();\n\n    \tbuffer.append(\"CollectionAgent: \");\n    \tbuffer.append(m_agent);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"OnmsSnmpCollection: \");\n    \tbuffer.append(m_snmpCollection);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"SnmpIfCollector: \");\n    \tbuffer.append(m_ifCollector);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"IfNumberTracker: \");\n    \tbuffer.append(m_ifNumber);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"SnmpNodeCollector: \");\n    \tbuffer.append(m_nodeCollector);\n    \tbuffer.append(\"\\n\");\n    \t\n    \treturn buffer.toString();\n    }","id":92826,"modified_method":"public String toString() {\n    \tStringBuffer buffer = new StringBuffer();\n\n    \tbuffer.append(\"CollectionAgent: \");\n    \tbuffer.append(m_agent);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"OnmsSnmpCollection: \");\n    \tbuffer.append(m_snmpCollection);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"SnmpIfCollector: \");\n    \tbuffer.append(m_ifCollector);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"IfNumberTracker: \");\n    \tbuffer.append(m_ifNumber);\n    \tbuffer.append(\"\\n\");\n    \t\n        buffer.append(\"SysUpTimeTracker: \");\n        buffer.append(m_sysUpTime);\n        buffer.append(\"\\n\");\n        \n    \tbuffer.append(\"SnmpNodeCollector: \");\n    \tbuffer.append(m_nodeCollector);\n    \tbuffer.append(\"\\n\");\n    \t\n    \treturn buffer.toString();\n    }","commit_id":"ca567f18d8f6b6b94fd22ed1ef5fcb2256ca186e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"CollectionTracker getTracker() {\n        List<Collectable> trackers = new ArrayList<Collectable>(3);\n       \n        if (getIfNumber() != null) {\n        \ttrackers.add(getIfNumber());\n        }\n        if (getNodeCollector() != null) {\n        \ttrackers.add(getNodeCollector());\n        }\n        if (getIfCollector() != null) {\n        \ttrackers.add(getIfCollector());\n        }\n       \n        return new AggregateTracker(trackers);\n    }","id":92827,"modified_method":"CollectionTracker getTracker() {\n        List<Collectable> trackers = new ArrayList<Collectable>(4);\n       \n        if (getIfNumber() != null) {\n        \ttrackers.add(getIfNumber());\n        }\n        if (getSysUpTime() != null) {\n            trackers.add(getSysUpTime());\n        }\n        if (getNodeCollector() != null) {\n        \ttrackers.add(getNodeCollector());\n        }\n        if (getIfCollector() != null) {\n        \ttrackers.add(getIfCollector());\n        }\n       \n        return new AggregateTracker(trackers);\n    }","commit_id":"ca567f18d8f6b6b94fd22ed1ef5fcb2256ca186e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean rescanNeeded() {\n        \n        final RescanNeeded rescanNeeded = new RescanNeeded();\n        visit(new ResourceVisitor() {\n        \n            public void visitResource(CollectionResource resource) {\n                log().debug(\"rescanNeeded: Visiting resource \" + resource);\n                if (resource.rescanNeeded()) {\n                    log().debug(\"Sending rescan event for \"+getCollectionAgent()+\" because resource \"+resource+\" indicated it was needed\");\n                    rescanNeeded.rescanIndicated();\n                }\n            }\n            \n        });\n            \n        checkForNewInterfaces(rescanNeeded);\n        \n        return rescanNeeded.rescanIsNeeded();\n    }","id":92828,"modified_method":"public boolean rescanNeeded() {\n        \n        final RescanNeeded rescanNeeded = new RescanNeeded();\n        visit(new ResourceVisitor() {\n        \n            public void visitResource(CollectionResource resource) {\n                log().debug(\"rescanNeeded: Visiting resource \" + resource);\n                if (resource.rescanNeeded()) {\n                    log().debug(\"Sending rescan event for \"+getCollectionAgent()+\" because resource \"+resource+\" indicated it was needed\");\n                    rescanNeeded.rescanIndicated();\n                }\n            }\n            \n        });\n            \n        checkForNewInterfaces(rescanNeeded);\n        checkForSystemRestart(rescanNeeded);\n\n        return rescanNeeded.rescanIsNeeded();\n    }","commit_id":"ca567f18d8f6b6b94fd22ed1ef5fcb2256ca186e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void visit(CollectionSetVisitor visitor) {\n        visitor.visitCollectionSet(this);\n        \n        for (Iterator iter = getResources().iterator(); iter.hasNext();) {\n            CollectionResource resource = (CollectionResource) iter.next();\n            resource.visit(visitor);\n        }\n        \n        visitor.completeCollectionSet(this);\n    }","id":92829,"modified_method":"public void visit(CollectionSetVisitor visitor) {\n        visitor.visitCollectionSet(this);\n        \n        for (CollectionResource resource : getResources()) {\n            resource.visit(visitor);\n        }\n        \n        visitor.completeCollectionSet(this);\n    }","commit_id":"ca567f18d8f6b6b94fd22ed1ef5fcb2256ca186e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void logIfCounts() {\n        CollectionAgent agent = getCollectionAgent();\n        log().debug(\"collect: nodeId: \" + agent.getNodeId()\n                + \" interface: \" + agent.getHostAddress()\n                + \" ifCount: \" + getIfNumber().getIfNumber() \n                + \" savedIfCount: \" + agent.getSavedIfCount());\n    }","id":92830,"modified_method":"private void logIfCounts() {\n        CollectionAgent agent = getCollectionAgent();\n        log().debug(\"collect: nodeId: \" + agent.getNodeId()\n                + \" interface: \" + agent.getHostAddress()\n                + \" ifCount: \" + getIfNumber().getIntValue() \n                + \" savedIfCount: \" + agent.getSavedIfCount());\n    }","commit_id":"ca567f18d8f6b6b94fd22ed1ef5fcb2256ca186e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SnmpCollectionSet.IfNumberTracker createIfNumberTracker() {\n        SnmpCollectionSet.IfNumberTracker ifNumber = null;\n        if (hasInterfaceDataToCollect()) {\n            ifNumber = new SnmpCollectionSet.IfNumberTracker();\n        }\n        return ifNumber;\n    }","id":92831,"modified_method":"private IfNumberTracker createIfNumberTracker() {\n        IfNumberTracker ifNumber = null;\n        if (hasInterfaceDataToCollect()) {\n            ifNumber = new IfNumberTracker();\n        }\n        return ifNumber;\n    }","commit_id":"e953e6d1a8c8aaa6919a5bf668f297c19f8ded0a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void checkForNewInterfaces(SnmpCollectionSet.RescanNeeded rescanNeeded) {\n        if (!hasInterfaceDataToCollect()) return;\n        \n        logIfCounts();\n    \n        if (ifCountHasChanged(getCollectionAgent())) {\n            log().info(\"Sending rescan event because the number of interfaces on primary SNMP \"\n            + \"interface \" + getCollectionAgent().getHostAddress()\n            + \" has changed, generating 'ForceRescan' event.\");\n            rescanNeeded.rescanIndicated();\n        }\n    \n        getCollectionAgent().setSavedIfCount(getIfNumber().getIfNumber());\n    }","id":92832,"modified_method":"void checkForNewInterfaces(SnmpCollectionSet.RescanNeeded rescanNeeded) {\n        if (!hasInterfaceDataToCollect()) return;\n        \n        logIfCounts();\n    \n        if (getIfNumber().isChanged(getCollectionAgent().getSavedIfCount())) {\n            log().info(\"Sending rescan event because the number of interfaces on primary SNMP \"\n            + \"interface \" + getCollectionAgent().getHostAddress()\n            + \" has changed, generating 'ForceRescan' event.\");\n            rescanNeeded.rescanIndicated();\n        }\n    \n        getCollectionAgent().setSavedIfCount(getIfNumber().getIntValue());\n    }","commit_id":"e953e6d1a8c8aaa6919a5bf668f297c19f8ded0a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String toString() {\n    \tStringBuffer buffer = new StringBuffer();\n\n    \tbuffer.append(\"CollectionAgent: \");\n    \tbuffer.append(m_agent);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"OnmsSnmpCollection: \");\n    \tbuffer.append(m_snmpCollection);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"SnmpIfCollector: \");\n    \tbuffer.append(m_ifCollector);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"IfNumberTracker: \");\n    \tbuffer.append(m_ifNumber);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"SnmpNodeCollector: \");\n    \tbuffer.append(m_nodeCollector);\n    \tbuffer.append(\"\\n\");\n    \t\n    \treturn buffer.toString();\n    }","id":92833,"modified_method":"public String toString() {\n    \tStringBuffer buffer = new StringBuffer();\n\n    \tbuffer.append(\"CollectionAgent: \");\n    \tbuffer.append(m_agent);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"OnmsSnmpCollection: \");\n    \tbuffer.append(m_snmpCollection);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"SnmpIfCollector: \");\n    \tbuffer.append(m_ifCollector);\n    \tbuffer.append(\"\\n\");\n    \t\n    \tbuffer.append(\"IfNumberTracker: \");\n    \tbuffer.append(m_ifNumber);\n    \tbuffer.append(\"\\n\");\n    \t\n        buffer.append(\"SysUpTimeTracker: \");\n        buffer.append(m_sysUpTime);\n        buffer.append(\"\\n\");\n        \n    \tbuffer.append(\"SnmpNodeCollector: \");\n    \tbuffer.append(m_nodeCollector);\n    \tbuffer.append(\"\\n\");\n    \t\n    \treturn buffer.toString();\n    }","commit_id":"e953e6d1a8c8aaa6919a5bf668f297c19f8ded0a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"CollectionTracker getTracker() {\n        List<Collectable> trackers = new ArrayList<Collectable>(3);\n       \n        if (getIfNumber() != null) {\n        \ttrackers.add(getIfNumber());\n        }\n        if (getNodeCollector() != null) {\n        \ttrackers.add(getNodeCollector());\n        }\n        if (getIfCollector() != null) {\n        \ttrackers.add(getIfCollector());\n        }\n       \n        return new AggregateTracker(trackers);\n    }","id":92834,"modified_method":"CollectionTracker getTracker() {\n        List<Collectable> trackers = new ArrayList<Collectable>(4);\n       \n        if (getIfNumber() != null) {\n        \ttrackers.add(getIfNumber());\n        }\n        if (getSysUpTime() != null) {\n            trackers.add(getSysUpTime());\n        }\n        if (getNodeCollector() != null) {\n        \ttrackers.add(getNodeCollector());\n        }\n        if (getIfCollector() != null) {\n        \ttrackers.add(getIfCollector());\n        }\n       \n        return new AggregateTracker(trackers);\n    }","commit_id":"e953e6d1a8c8aaa6919a5bf668f297c19f8ded0a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean rescanNeeded() {\n        \n        final RescanNeeded rescanNeeded = new RescanNeeded();\n        visit(new ResourceVisitor() {\n        \n            public void visitResource(CollectionResource resource) {\n                log().debug(\"rescanNeeded: Visiting resource \" + resource);\n                if (resource.rescanNeeded()) {\n                    log().debug(\"Sending rescan event for \"+getCollectionAgent()+\" because resource \"+resource+\" indicated it was needed\");\n                    rescanNeeded.rescanIndicated();\n                }\n            }\n            \n        });\n            \n        checkForNewInterfaces(rescanNeeded);\n        \n        return rescanNeeded.rescanIsNeeded();\n    }","id":92835,"modified_method":"public boolean rescanNeeded() {\n        \n        final RescanNeeded rescanNeeded = new RescanNeeded();\n        visit(new ResourceVisitor() {\n        \n            public void visitResource(CollectionResource resource) {\n                log().debug(\"rescanNeeded: Visiting resource \" + resource);\n                if (resource.rescanNeeded()) {\n                    log().debug(\"Sending rescan event for \"+getCollectionAgent()+\" because resource \"+resource+\" indicated it was needed\");\n                    rescanNeeded.rescanIndicated();\n                }\n            }\n            \n        });\n            \n        checkForNewInterfaces(rescanNeeded);\n        checkForSystemRestart(rescanNeeded);\n\n        return rescanNeeded.rescanIsNeeded();\n    }","commit_id":"e953e6d1a8c8aaa6919a5bf668f297c19f8ded0a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void visit(CollectionSetVisitor visitor) {\n        visitor.visitCollectionSet(this);\n        \n        for (Iterator iter = getResources().iterator(); iter.hasNext();) {\n            CollectionResource resource = (CollectionResource) iter.next();\n            resource.visit(visitor);\n        }\n        \n        visitor.completeCollectionSet(this);\n    }","id":92836,"modified_method":"public void visit(CollectionSetVisitor visitor) {\n        visitor.visitCollectionSet(this);\n        \n        for (CollectionResource resource : getResources()) {\n            resource.visit(visitor);\n        }\n        \n        visitor.completeCollectionSet(this);\n    }","commit_id":"e953e6d1a8c8aaa6919a5bf668f297c19f8ded0a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void logIfCounts() {\n        CollectionAgent agent = getCollectionAgent();\n        log().debug(\"collect: nodeId: \" + agent.getNodeId()\n                + \" interface: \" + agent.getHostAddress()\n                + \" ifCount: \" + getIfNumber().getIfNumber() \n                + \" savedIfCount: \" + agent.getSavedIfCount());\n    }","id":92837,"modified_method":"private void logIfCounts() {\n        CollectionAgent agent = getCollectionAgent();\n        log().debug(\"collect: nodeId: \" + agent.getNodeId()\n                + \" interface: \" + agent.getHostAddress()\n                + \" ifCount: \" + getIfNumber().getIntValue() \n                + \" savedIfCount: \" + agent.getSavedIfCount());\n    }","commit_id":"e953e6d1a8c8aaa6919a5bf668f297c19f8ded0a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void dispose() {\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        while (!myComponents.isEmpty()) {\n          dispose(myComponents.pop());\n        }\n      }\n    });\n  }","id":92838,"modified_method":"public void dispose() {\n    if (myComponents == null) {\n      return;\n    }\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        while (!myComponents.isEmpty()) {\n          dispose(myComponents.pop());\n        }\n      }\n    });\n  }","commit_id":"b880faee3d6a28baeb6b81caeb93497124851c96","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void disposeMPS() {\n    MPSBaseLanguage.getInstance().dispose();\n    MPSGenerator.getInstance().dispose();\n    MPSTypesystem.getInstance().dispose();\n    MPSPersistence.getInstance().dispose();\n    MPSCore.getInstance().dispose();\n  }","id":92839,"modified_method":"private void disposeMPS() {\n    MPSBaseLanguage.getInstance().dispose();\n    MPSGenerator.getInstance().dispose();\n    MPSTypesystem.getInstance().dispose();\n    myMPSPersistence.dispose();\n    myMPSCore.dispose();\n    myMPSPersistence = null;\n    myMPSCore = null;\n  }","commit_id":"b880faee3d6a28baeb6b81caeb93497124851c96","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initMPS() {\n    MPSCore.getInstance().init();\n    MPSPersistence.getInstance().init();\n    MPSTypesystem.getInstance().init();\n    MPSGenerator.getInstance().init();\n    MPSBaseLanguage.getInstance().init();\n  }","id":92840,"modified_method":"private void initMPS() {\n    myMPSCore = new MPSCore();\n    myMPSCore.init();\n    myMPSPersistence = new MPSPersistence();\n    myMPSPersistence.init();\n    MPSTypesystem.getInstance().init();\n    MPSGenerator.getInstance().init();\n    MPSBaseLanguage.getInstance().init();\n  }","commit_id":"b880faee3d6a28baeb6b81caeb93497124851c96","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Method generated by IntelliJ IDEA GUI Designer\n   * >>> IMPORTANT!! <<<\n   * DO NOT edit this method OR call it in your code!\n   *\n   * @noinspection ALL\n   */\n  private void $$$setupUI$$$() {\n    myPanel = new JPanel();\n    myPanel.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));\n    final JPanel panel1 = new JPanel();\n    panel1.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(3, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel1, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null,\n        0, false));\n    panel1.setBorder(\n        BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Bugtracker login settings\", TitledBorder.LEFT, TitledBorder.DEFAULT_POSITION));\n    final com.intellij.uiDesigner.core.Spacer spacer1 = new com.intellij.uiDesigner.core.Spacer();\n    panel1.add(spacer1, new com.intellij.uiDesigner.core.GridConstraints(1, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0,\n        false));\n    myLoginPanel = new JPanel();\n    myLoginPanel.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(3, 2, new Insets(0, 5, 0, 0), -1, -1));\n    panel1.add(myLoginPanel, new com.intellij.uiDesigner.core.GridConstraints(2, 0, 1, 2, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null,\n        0, false));\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Username:\");\n    myLoginPanel.add(label1, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myUsername = new JTextField();\n    myUsername.setEnabled(false);\n    myLoginPanel.add(myUsername, new com.intellij.uiDesigner.core.GridConstraints(0, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label2 = new JLabel();\n    label2.setText(\"Password:\");\n    myLoginPanel.add(label2, new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myPassword = new JPasswordField();\n    myPassword.setEnabled(false);\n    myLoginPanel.add(myPassword, new com.intellij.uiDesigner.core.GridConstraints(1, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    myTestLoginButton = new JButton();\n    myTestLoginButton.setEnabled(false);\n    myTestLoginButton.setText(\"Test Login\");\n    myLoginPanel.add(myTestLoginButton, new com.intellij.uiDesigner.core.GridConstraints(2, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_EAST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myRegisteredRadio = new JRadioButton();\n    myRegisteredRadio.setText(\"Registered user\");\n    panel1.add(myRegisteredRadio, new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myAnonymousRadio = new JRadioButton();\n    myAnonymousRadio.setSelected(true);\n    myAnonymousRadio.setText(\"Anonymous\");\n    panel1.add(myAnonymousRadio, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final com.intellij.uiDesigner.core.Spacer spacer2 = new com.intellij.uiDesigner.core.Spacer();\n    panel1.add(spacer2, new com.intellij.uiDesigner.core.GridConstraints(0, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0,\n        false));\n    final JPanel panel2 = new JPanel();\n    panel2.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(8, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel2, new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, null, null,\n        null, 0, false));\n    panel2.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Issue properties\"));\n    final JLabel label3 = new JLabel();\n    label3.setText(\"Description (what did you do,what happened instead of expected behavior):\");\n    panel2.add(label3, new com.intellij.uiDesigner.core.GridConstraints(2, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final com.intellij.uiDesigner.core.Spacer spacer3 = new com.intellij.uiDesigner.core.Spacer();\n    panel2.add(spacer3, new com.intellij.uiDesigner.core.GridConstraints(2, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0,\n        false));\n    final JScrollPane scrollPane1 = new JScrollPane();\n    panel2.add(scrollPane1, new com.intellij.uiDesigner.core.GridConstraints(3, 0, 1, 2, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, null,\n        new Dimension(0, 37), null, 0, false));\n    myDescription = new JTextArea();\n    myDescription.setEditable(true);\n    myDescription.setText(\"\");\n    scrollPane1.setViewportView(myDescription);\n    myTitleField = new JTextField();\n    panel2.add(myTitleField, new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 2, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label4 = new JLabel();\n    label4.setText(\"Title:\");\n    panel2.add(label4, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final com.intellij.uiDesigner.core.Spacer spacer4 = new com.intellij.uiDesigner.core.Spacer();\n    panel2.add(spacer4, new com.intellij.uiDesigner.core.GridConstraints(0, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0,\n        false));\n    final com.intellij.uiDesigner.core.Spacer spacer5 = new com.intellij.uiDesigner.core.Spacer();\n    panel2.add(spacer5, new com.intellij.uiDesigner.core.GridConstraints(4, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0,\n        false));\n    myHiddenCheckBox = new JCheckBox();\n    myHiddenCheckBox.setText(\"Visible only to MPS developers\");\n    myHiddenCheckBox.setToolTipText(\"Select this if you want this bug report will be visible only to you and MPS developers \");\n    panel2.add(myHiddenCheckBox, new com.intellij.uiDesigner.core.GridConstraints(7, 0, 1, 2, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myExceptionContainer = new JPanel();\n    myExceptionContainer.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(2, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myExceptionContainer.setEnabled(true);\n    panel2.add(myExceptionContainer, new com.intellij.uiDesigner.core.GridConstraints(6, 0, 1, 2, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null,\n        0, false));\n    final JLabel label5 = new JLabel();\n    label5.setText(\"Exception:\");\n    myExceptionContainer.add(label5, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final com.intellij.uiDesigner.core.Spacer spacer6 = new com.intellij.uiDesigner.core.Spacer();\n    myExceptionContainer.add(spacer6, new com.intellij.uiDesigner.core.GridConstraints(0, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0,\n        false));\n    final JScrollPane scrollPane2 = new JScrollPane();\n    myExceptionContainer.add(scrollPane2,\n        new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 2, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n            com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH,\n            com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW,\n            com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, null,\n            new Dimension(0, 220), null, 0, false)\n    );\n    myException = new JTextArea();\n    myException.setEditable(false);\n    scrollPane2.setViewportView(myException);\n    ButtonGroup buttonGroup;\n    buttonGroup = new ButtonGroup();\n    buttonGroup.add(myRegisteredRadio);\n    buttonGroup.add(myAnonymousRadio);\n  }","id":92841,"modified_method":"/**\n   * Method generated by IntelliJ IDEA GUI Designer\n   * >>> IMPORTANT!! <<<\n   * DO NOT edit this method OR call it in your code!\n   *\n   * @noinspection ALL\n   */\n  private void $$$setupUI$$$() {\n    myPanel = new JPanel();\n    myPanel.setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));\n    final JPanel panel1 = new JPanel();\n    panel1.setLayout(new GridLayoutManager(3, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    panel1.setBorder(\n        BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Bugtracker login settings\", TitledBorder.LEFT, TitledBorder.DEFAULT_POSITION));\n    final Spacer spacer1 = new Spacer();\n    panel1.add(spacer1,\n        new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null,\n            null, 0, false));\n    myLoginPanel = new JPanel();\n    myLoginPanel.setLayout(new GridLayoutManager(3, 2, new Insets(0, 5, 0, 0), -1, -1));\n    panel1.add(myLoginPanel, new GridConstraints(2, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Username:\");\n    myLoginPanel.add(label1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,\n        GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myUsername = new JTextField();\n    myUsername.setEnabled(false);\n    myLoginPanel.add(myUsername,\n        new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW,\n            GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label2 = new JLabel();\n    label2.setText(\"Password:\");\n    myLoginPanel.add(label2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,\n        GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myPassword = new JPasswordField();\n    myPassword.setEnabled(false);\n    myLoginPanel.add(myPassword,\n        new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW,\n            GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    myTestLoginButton = new JButton();\n    myTestLoginButton.setEnabled(false);\n    myTestLoginButton.setText(\"Test Login\");\n    myLoginPanel.add(myTestLoginButton, new GridConstraints(2, 1, 1, 1, GridConstraints.ANCHOR_EAST, GridConstraints.FILL_NONE,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myRegisteredRadio = new JRadioButton();\n    myRegisteredRadio.setText(\"Registered user\");\n    panel1.add(myRegisteredRadio, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myAnonymousRadio = new JRadioButton();\n    myAnonymousRadio.setSelected(true);\n    myAnonymousRadio.setText(\"Anonymous\");\n    panel1.add(myAnonymousRadio, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer2 = new Spacer();\n    panel1.add(spacer2,\n        new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null,\n            null, 0, false));\n    final JPanel panel2 = new JPanel();\n    panel2.setLayout(new GridLayoutManager(8, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));\n    panel2.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Issue properties\"));\n    final JLabel label3 = new JLabel();\n    label3.setText(\"Description (what did you do,what happened instead of expected behavior):\");\n    panel2.add(label3, new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,\n        GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer3 = new Spacer();\n    panel2.add(spacer3,\n        new GridConstraints(2, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null,\n            null, 0, false));\n    final JScrollPane scrollPane1 = new JScrollPane();\n    panel2.add(scrollPane1, new GridConstraints(3, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, new Dimension(0, 37), null, 0, false));\n    myDescription = new JTextArea();\n    myDescription.setEditable(true);\n    myDescription.setText(\"\");\n    scrollPane1.setViewportView(myDescription);\n    myTitleField = new JTextField();\n    panel2.add(myTitleField, new GridConstraints(1, 0, 1, 2, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW,\n        GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label4 = new JLabel();\n    label4.setText(\"Title:\");\n    panel2.add(label4, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,\n        GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer4 = new Spacer();\n    panel2.add(spacer4,\n        new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null,\n            null, 0, false));\n    final Spacer spacer5 = new Spacer();\n    panel2.add(spacer5,\n        new GridConstraints(4, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null,\n            null, 0, false));\n    myHiddenCheckBox = new JCheckBox();\n    myHiddenCheckBox.setText(\"Visible only to MPS developers\");\n    myHiddenCheckBox.setToolTipText(\"Select this if you want this bug report will be visible only to you and MPS developers \");\n    panel2.add(myHiddenCheckBox, new GridConstraints(7, 0, 1, 2, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myExceptionContainer = new JPanel();\n    myExceptionContainer.setLayout(new GridLayoutManager(2, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myExceptionContainer.setEnabled(true);\n    panel2.add(myExceptionContainer, new GridConstraints(6, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    final JLabel label5 = new JLabel();\n    label5.setText(\"Exception:\");\n    myExceptionContainer.add(label5, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,\n        GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer6 = new Spacer();\n    myExceptionContainer.add(spacer6,\n        new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null,\n            null, 0, false));\n    final JScrollPane scrollPane2 = new JScrollPane();\n    myExceptionContainer.add(scrollPane2, new GridConstraints(1, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, new Dimension(0, 220), null, 0, false));\n    myException = new JTextArea();\n    myException.setEditable(false);\n    scrollPane2.setViewportView(myException);\n    ButtonGroup buttonGroup;\n    buttonGroup = new ButtonGroup();\n    buttonGroup.add(myRegisteredRadio);\n    buttonGroup.add(myAnonymousRadio);\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void convert(Map<String, String> map, Boolean stripImplementation) {\n    MPSCore.getInstance().init();\n    MPSPersistence.getInstance().init();\n    RuntimeFlags.setMergeDriverMode(true);\n    PersistenceRegistry.getInstance().setModelEnvironmentInfo(new LightModelEnvironmentInfoImpl());\n    System.setProperty(\"mps.playRefactorings\", \"false\");\n    try {\n      for (Map.Entry<String, String> entry : map.entrySet()) {\n        convertModelToBinary(entry.getKey(), entry.getValue(), stripImplementation);\n      }\n    } catch (IOException ex) {\n      throw new RuntimeException(ex);\n    } finally {\n      PersistenceRegistry.getInstance().setModelEnvironmentInfo(null);\n      MPSPersistence.getInstance().dispose();\n      MPSCore.getInstance().dispose();\n    }\n  }","id":92842,"modified_method":"public void convert(Map<String, String> map, Boolean stripImplementation) {\n    final MPSCore mpsCore = new MPSCore();\n    mpsCore.init();\n    final MPSPersistence mpsPersistence = new MPSPersistence();\n    mpsPersistence.init();\n    RuntimeFlags.setMergeDriverMode(true);\n    PersistenceRegistry.getInstance().setModelEnvironmentInfo(new LightModelEnvironmentInfoImpl());\n    System.setProperty(\"mps.playRefactorings\", \"false\");\n    try {\n      for (Map.Entry<String, String> entry : map.entrySet()) {\n        convertModelToBinary(entry.getKey(), entry.getValue(), stripImplementation);\n      }\n    } catch (IOException ex) {\n      throw new RuntimeException(ex);\n    } finally {\n      PersistenceRegistry.getInstance().setModelEnvironmentInfo(null);\n      mpsPersistence.dispose();\n      mpsCore.dispose();\n    }\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"@BeforeClass\n  public static void init() {\n    assertNull(PersistenceFacade.getInstance());\n    MPSCore.getInstance().init();\n  }","id":92843,"modified_method":"@BeforeClass\n  public static void init() {\n    assertNull(PersistenceFacade.getInstance());\n    ourMPSCore = new MPSCore();\n    ourMPSCore.init();\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"@AfterClass\n  public static void dispose() {\n    assertNotNull(PersistenceFacade.getInstance());\n    MPSCore.getInstance().dispose();\n    assertNull(PersistenceFacade.getInstance());\n  }","id":92844,"modified_method":"@AfterClass\n  public static void dispose() {\n    assertNotNull(PersistenceFacade.getInstance());\n    ourMPSCore.dispose();\n    ourMPSCore = null;\n    assertNull(PersistenceFacade.getInstance());\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void main(String[] args) throws JDOMException, IOException {\n    assertNull(PersistenceFacade.getInstance());\n    MPSCore.getInstance().init();\n\n    generateGenSourcesIml();\n    generateCompilerXmlFile();\n  }","id":92845,"modified_method":"public static void main(String[] args) throws JDOMException, IOException {\n    assertNull(PersistenceFacade.getInstance());\n    final MPSCore mpsCore = new MPSCore();\n    mpsCore.init();\n\n    generateGenSourcesIml();\n    generateCompilerXmlFile();\n\n    mpsCore.dispose();\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static MPSCore getInstance() {\n    return ourInstance;\n  }","id":92846,"modified_method":"/**\n   * @deprecated MPSCore instance is kept by initialization code (which activates the environment)\n   * and should not be accessed unless initialization code passes it anywhere\n   * @return new, not initialized instance\n   */\n  @Deprecated\n  @ToRemove(version = 3.2)\n  public static MPSCore getInstance() {\n    return new MPSCore();\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"private MPSCore() {\n\n  }","id":92847,"modified_method":"public MPSCore() {\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void initComponent() {\n    // setup undo\n    UndoHelper.getInstance().setUndoHandler(new WorkbenchUndoHandler());\n\n    // setup model access\n    ModelAccess.setInstance(new WorkbenchModelAccess());\n\n    // setup MPS.Core\n    MPSCore.getInstance().init();\n    MPSPersistence.getInstance().init();\n    MPSTypesystem.getInstance().init();\n    MPSGenerator.getInstance().init();\n    MPSFindUsages.getInstance().init();\n\n    // setup BaseLanguage\n    MPSBaseLanguage.getInstance().init();\n  }","id":92848,"modified_method":"@Override\n  public void initComponent() {\n    // setup undo\n    UndoHelper.getInstance().setUndoHandler(new WorkbenchUndoHandler());\n\n    // setup model access\n    ModelAccess.setInstance(new WorkbenchModelAccess());\n\n    // setup MPS.Core\n    myMPSCore = new MPSCore();\n    myMPSCore.init();\n    myMPSPersistence = new MPSPersistence();\n    myMPSPersistence.init();\n    MPSTypesystem.getInstance().init();\n    MPSGenerator.getInstance().init();\n    MPSFindUsages.getInstance().init();\n\n    // setup BaseLanguage\n    MPSBaseLanguage.getInstance().init();\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void disposeComponent() {\n    // set IoFileSystem\n    if (FileSystem.getInstance().getFileSystemProvider() instanceof IdeaFileSystemProvider) {\n      ((IdeaFileSystemProvider) FileSystem.getInstance().getFileSystemProvider()).dispose();\n      FileSystem.getInstance().setFileSystemProvider(new IoFileSystemProvider());\n    }\n\n    // dispose BaseLanguage\n    MPSBaseLanguage.getInstance().dispose();\n\n    // dispose Core\n    MPSFindUsages.getInstance().dispose();\n    MPSGenerator.getInstance().dispose();\n    MPSTypesystem.getInstance().dispose();\n    MPSPersistence.getInstance().dispose();\n    MPSCore.getInstance().dispose();\n\n    // cleanup\n    ModelAccess.instance().dispose();\n  }","id":92849,"modified_method":"@Override\n  public void disposeComponent() {\n    // set IoFileSystem\n    if (FileSystem.getInstance().getFileSystemProvider() instanceof IdeaFileSystemProvider) {\n      ((IdeaFileSystemProvider) FileSystem.getInstance().getFileSystemProvider()).dispose();\n      FileSystem.getInstance().setFileSystemProvider(new IoFileSystemProvider());\n    }\n\n    // dispose BaseLanguage\n    MPSBaseLanguage.getInstance().dispose();\n\n    // dispose Core\n    MPSFindUsages.getInstance().dispose();\n    MPSGenerator.getInstance().dispose();\n    MPSTypesystem.getInstance().dispose();\n    myMPSPersistence.dispose();\n    myMPSPersistence = null;\n    myMPSCore.dispose();\n    myMPSCore = null;\n\n    // cleanup\n    ModelAccess.instance().dispose();\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"private MPSPersistence() {\n  }","id":92850,"modified_method":"public MPSPersistence() {\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static MPSPersistence getInstance() {\n    return ourInstance;\n  }","id":92851,"modified_method":"/**\n   * @deprecated Platform initialization code shall keep reference to the instance, if needed\n   * @return new, not initialized instance\n   */\n  @Deprecated\n  public static MPSPersistence getInstance() {\n    return new MPSPersistence();\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void main(String[] args) {\n    byte[] conflictStart = CONFLICT_START.getBytes();\n    byte[] conflictEnd = CONFLICT_END.getBytes();\n    byte[] conflictSeparator = CONFLICT_SEPARATOR.getBytes();\n    if (args.length < 5) {\n      System.err.println(\"Usage <merger> <filetype> --<vcs> <base> <current> <other> \");\n      System.exit(2);\n    }\n    String filetype = args[0];\n    if (NO_FILETYPE.equals(filetype)) {\n      filetype = null;\n    }\n    File baseFile = new File(args[2]);\n    File currentFile = new File(args[3]);\n    File otherFile = new File(args[4]);\n    boolean overwrite = false;\n    if (SVN_OPTION.equals(args[1])) {\n      if (args.length >= 8) {\n        conflictStart = (CONFLICT_START + \" \" + args[6]).getBytes();\n        conflictEnd = (CONFLICT_END + \" \" + args[7]).getBytes();\n      }\n    } else if (GIT_OPTION.equals(args[1])) {\n      overwrite = true;\n    } else {\n      System.exit(2);\n      return;\n    }\n    configureLog4j();\n    MPSCore.getInstance().init();\n    MPSPersistence.getInstance().init();\n\n    String systemPath = new File(System.getProperty(LOG_PROPERTY)).getParentFile().getParentFile().getAbsolutePath();\n    MergeDriverBackupUtil.setMergeBackupDirPath(systemPath + File.separator + \"merge-backup\");\n    File[] files = {baseFile, currentFile, otherFile};\n    AbstractContentMerger merger = selectMerger(filetype, files);\n    if (merger == null) {\n      merger = (SVN_OPTION.equals(args[1]) ? new TextMerger() : new SimpleMerger());\n    }\n\n    boolean convertCRLF = GIT_OPTION.equals(args[1]) && !(hasCRLF(Sequence.fromIterable(Sequence.fromArray(files)).findFirst(new IWhereFilter<File>() {\n      public boolean accept(File f) {\n        return f != null;\n      }\n    })));\n    int status = FileMerger.mergeFiles(merger, baseFile, currentFile, otherFile, conflictStart, conflictEnd, conflictSeparator, overwrite, convertCRLF);\n    System.exit(status);\n  }","id":92852,"modified_method":"public static void main(String[] args) {\n    byte[] conflictStart = CONFLICT_START.getBytes();\n    byte[] conflictEnd = CONFLICT_END.getBytes();\n    byte[] conflictSeparator = CONFLICT_SEPARATOR.getBytes();\n    if (args.length < 5) {\n      System.err.println(\"Usage <merger> <filetype> --<vcs> <base> <current> <other> \");\n      System.exit(2);\n    }\n    String filetype = args[0];\n    if (NO_FILETYPE.equals(filetype)) {\n      filetype = null;\n    }\n    File baseFile = new File(args[2]);\n    File currentFile = new File(args[3]);\n    File otherFile = new File(args[4]);\n    boolean overwrite = false;\n    if (SVN_OPTION.equals(args[1])) {\n      if (args.length >= 8) {\n        conflictStart = (CONFLICT_START + \" \" + args[6]).getBytes();\n        conflictEnd = (CONFLICT_END + \" \" + args[7]).getBytes();\n      }\n    } else if (GIT_OPTION.equals(args[1])) {\n      overwrite = true;\n    } else {\n      System.exit(2);\n      return;\n    }\n    configureLog4j();\n    final MPSCore mpsCore = new MPSCore();\n    mpsCore.init();\n    final MPSPersistence mpsPersistence = new MPSPersistence();\n    mpsPersistence.init();\n\n    String systemPath = new File(System.getProperty(LOG_PROPERTY)).getParentFile().getParentFile().getAbsolutePath();\n    MergeDriverBackupUtil.setMergeBackupDirPath(systemPath + File.separator + \"merge-backup\");\n    File[] files = {baseFile, currentFile, otherFile};\n    AbstractContentMerger merger = selectMerger(filetype, files);\n    if (merger == null) {\n      merger = (SVN_OPTION.equals(args[1]) ? new TextMerger() : new SimpleMerger());\n    }\n\n    boolean convertCRLF = GIT_OPTION.equals(args[1]) && !(hasCRLF(Sequence.fromIterable(Sequence.fromArray(files)).findFirst(new IWhereFilter<File>() {\n      public boolean accept(File f) {\n        return f != null;\n      }\n    })));\n    int status = FileMerger.mergeFiles(merger, baseFile, currentFile, otherFile, conflictStart, conflictEnd, conflictSeparator, overwrite, convertCRLF);\n    mpsPersistence.dispose();\n    mpsCore.dispose();\n    System.exit(status);\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MpsEnvironment(EnvironmentConfig config) {\n    this.config = config;\n\n    // todo: if creationg of environment fails? is it publication before we need it? \n    ActiveEnvironment.activateEnvironment(this);\n\n    // todo: plugins, libs \n\n    BasicConfigurator.configure(new ConsoleAppender(new SimpleLayout()));\n    Logger.getRootLogger().setLevel(Level.INFO);\n\n    MpsPlatform.init();\n    // todo: =( \n    RuntimeFlags.setTestMode(true);\n    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());\n\n    try {\n      EnvironmentUtils.setSystemProperties(false);\n      EnvironmentUtils.setPluginPath();\n    } catch (Exception ex) {\n      throw new RuntimeException(ex);\n    }\n\n    Map<String, String> macros = MapSequence.fromMap(new HashMap<String, String>());\n    for (String name : MapSequence.fromMap(config.macros()).keySet()) {\n      MapSequence.fromMap(macros).put(name, MapSequence.fromMap(config.macros()).get(name).getAbsolutePath());\n    }\n    macroProvider = EnvironmentUtils.createMapMacrosProvider(macros);\n    PathMacros.getInstance().addMacrosProvider(macroProvider);\n\n    libContributors = SetSequence.fromSetWithValues(new HashSet<LibraryContributor>(), createLibContributors(config));\n    for (LibraryContributor libContributor : Sequence.fromIterable(libContributors)) {\n      LibraryInitializer.getInstance().addContributor(libContributor);\n    }\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        LibraryInitializer.getInstance().update();\n      }\n    });\n  }","id":92853,"modified_method":"public MpsEnvironment(EnvironmentConfig config) {\n    this.config = config;\n\n    // todo: if creationg of environment fails? is it publication before we need it? \n    ActiveEnvironment.activateEnvironment(this);\n\n    // todo: plugins, libs \n\n    BasicConfigurator.configure(new ConsoleAppender(new SimpleLayout()));\n    Logger.getRootLogger().setLevel(Level.INFO);\n\n    myPlatformLoader = new MpsPlatform();\n    myPlatformLoader.init();\n    // todo: =( \n    RuntimeFlags.setTestMode(true);\n    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());\n\n    try {\n      EnvironmentUtils.setSystemProperties(false);\n      EnvironmentUtils.setPluginPath();\n    } catch (Exception ex) {\n      throw new RuntimeException(ex);\n    }\n\n    Map<String, String> macros = MapSequence.fromMap(new HashMap<String, String>());\n    for (String name : MapSequence.fromMap(config.macros()).keySet()) {\n      MapSequence.fromMap(macros).put(name, MapSequence.fromMap(config.macros()).get(name).getAbsolutePath());\n    }\n    macroProvider = EnvironmentUtils.createMapMacrosProvider(macros);\n    PathMacros.getInstance().addMacrosProvider(macroProvider);\n\n    libContributors = SetSequence.fromSetWithValues(new HashSet<LibraryContributor>(), createLibContributors(config));\n    for (LibraryContributor libContributor : Sequence.fromIterable(libContributors)) {\n      LibraryInitializer.getInstance().addContributor(libContributor);\n    }\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        LibraryInitializer.getInstance().update();\n      }\n    });\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void disposeEnvironment() {\n    ModelAccess.instance().flushEventQueue();\n\n    for (Project project : SetSequence.fromSetWithValues(new HashSet<Project>(), openedProjects)) {\n      disposeProject(project);\n    }\n\n    PathMacros.getInstance().removeMacrosProvider(macroProvider);\n    for (LibraryContributor libContributor : Sequence.fromIterable(libContributors)) {\n      LibraryInitializer.getInstance().removeContributor(libContributor);\n    }\n\n    MpsPlatform.dispose();\n\n    ActiveEnvironment.deactivateEnvironment(this);\n  }","id":92854,"modified_method":"public void disposeEnvironment() {\n    ModelAccess.instance().flushEventQueue();\n\n    for (Project project : SetSequence.fromSetWithValues(new HashSet<Project>(), openedProjects)) {\n      disposeProject(project);\n    }\n\n    PathMacros.getInstance().removeMacrosProvider(macroProvider);\n    for (LibraryContributor libContributor : Sequence.fromIterable(libContributors)) {\n      LibraryInitializer.getInstance().removeContributor(libContributor);\n    }\n\n    myPlatformLoader.dispose();\n    myPlatformLoader = null;\n\n    ActiveEnvironment.deactivateEnvironment(this);\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void init() {\n    MPSCore.getInstance().init();\n    MPSPersistence.getInstance().init();\n    MPSTypesystem.getInstance().init();\n    MPSGenerator.getInstance().init();\n    MPSBaseLanguage.getInstance().init();\n  }","id":92855,"modified_method":"public void init() {\n    myMPSCore = new MPSCore();\n    myMPSCore.init();\n    myMPSPersistence = new MPSPersistence();\n    myMPSPersistence.init();\n    MPSTypesystem.getInstance().init();\n    MPSGenerator.getInstance().init();\n    MPSBaseLanguage.getInstance().init();\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void dispose() {\n    MPSBaseLanguage.getInstance().dispose();\n    MPSGenerator.getInstance().dispose();\n    MPSTypesystem.getInstance().dispose();\n    MPSPersistence.getInstance().dispose();\n    MPSCore.getInstance().dispose();\n  }","id":92856,"modified_method":"public void dispose() {\n    MPSBaseLanguage.getInstance().dispose();\n    MPSGenerator.getInstance().dispose();\n    MPSTypesystem.getInstance().dispose();\n    myMPSPersistence.dispose();\n    myMPSPersistence = null;\n    myMPSCore.dispose();\n    myMPSCore = null;\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"private MpsPlatform() {\n  }","id":92857,"modified_method":"public MpsPlatform() {\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Method generated by IntelliJ IDEA GUI Designer\n   * >>> IMPORTANT!! <<<\n   * DO NOT edit this method OR call it in your code!\n   *\n   * @noinspection ALL\n   */\n  private void $$$setupUI$$$() {\n    myWholePanel = new JPanel();\n    myWholePanel.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(1, 2, new Insets(0, 0, 0, 0), -1, -1));\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Project format:\");\n    myWholePanel.add(label1, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myStorageFormatCombo = new JComboBox();\n    myWholePanel.add(myStorageFormatCombo,\n        new com.intellij.uiDesigner.core.GridConstraints(0, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n            com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL,\n            com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n            com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false)\n    );\n  }","id":92858,"modified_method":"/**\n   * Method generated by IntelliJ IDEA GUI Designer\n   * >>> IMPORTANT!! <<<\n   * DO NOT edit this method OR call it in your code!\n   *\n   * @noinspection ALL\n   */\n  private void $$$setupUI$$$() {\n    myWholePanel = new JPanel();\n    myWholePanel.setLayout(new GridLayoutManager(1, 2, new Insets(0, 0, 0, 0), -1, -1));\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Project format:\");\n    myWholePanel.add(label1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,\n        GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myStorageFormatCombo = new JComboBox();\n    myWholePanel.add(myStorageFormatCombo, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n  }","commit_id":"797893e6327b16dcbf0e9faa46c120b545333b42","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void disposeMPS() {\n    MPSBaseLanguage.getInstance().dispose();\n    MPSGenerator.getInstance().dispose();\n    MPSTypesystem.getInstance().dispose();\n    myMPSPersistence.dispose();\n    myMPSCore.dispose();\n    myMPSPersistence = null;\n    myMPSCore = null;\n  }","id":92859,"modified_method":"private void disposeMPS() {\n    myMPSBaseLanguage.dispose();\n    myMPSBaseLanguage = null;\n\n    myMPSGenerator.dispose();\n    myMPSTypesystem.dispose();\n    myMPSPersistence.dispose();\n    myMPSCore.dispose();\n    myMPSGenerator = null;\n    myMPSTypesystem = null;\n    myMPSPersistence = null;\n    myMPSCore = null;\n  }","commit_id":"750b3af3eb6ea4e60b40b982a1b413879abddf97","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initMPS() {\n    myMPSCore = new MPSCore();\n    myMPSCore.init();\n    myMPSPersistence = new MPSPersistence();\n    myMPSPersistence.init();\n    MPSTypesystem.getInstance().init();\n    MPSGenerator.getInstance().init();\n    MPSBaseLanguage.getInstance().init();\n  }","id":92860,"modified_method":"private void initMPS() {\n    myMPSCore = new MPSCore();\n    myMPSPersistence = new MPSPersistence();\n    myMPSTypesystem = new MPSTypesystem();\n    myMPSGenerator = new MPSGenerator();\n    myMPSCore.init();\n    myMPSPersistence.init();\n    myMPSTypesystem.init();\n    myMPSGenerator.init();\n\n    myMPSBaseLanguage = new MPSBaseLanguage();\n    myMPSBaseLanguage.init();\n  }","commit_id":"750b3af3eb6ea4e60b40b982a1b413879abddf97","url":"https://github.com/JetBrains/MPS"},{"original_method":"private MPSBaseLanguage() {\n  }","id":92861,"modified_method":"public MPSBaseLanguage() {\n  }","commit_id":"750b3af3eb6ea4e60b40b982a1b413879abddf97","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void disposeComponent() {\n    // dispose BaseLanguage\n    MPSBaseLanguage.getInstance().dispose();\n\n    // dispose Core\n    MPSFindUsages.getInstance().dispose();\n    MPSGenerator.getInstance().dispose();\n    MPSTypesystem.getInstance().dispose();\n    myMPSPersistence.dispose();\n    myMPSPersistence = null;\n    myMPSCore.dispose();\n    myMPSCore = null;\n\n    // cleanup\n    ModelAccess.instance().dispose();\n  }","id":92862,"modified_method":"@Override\n  public void disposeComponent() {\n    // dispose BaseLanguage\n    myMPSBaseLanguage.dispose();\n    myMPSBaseLanguage = null;\n\n    // dispose Core\n    myMPSFindUsages.dispose();\n    myMPSGenerator.dispose();\n    myMPSTypesystem.dispose();\n    myMPSPersistence.dispose();\n    myMPSCore.dispose();\n    myMPSFindUsages = null;\n    myMPSGenerator = null;\n    myMPSTypesystem = null;\n    myMPSPersistence = null;\n    myMPSCore = null;\n\n    // cleanup\n    ModelAccess.instance().dispose();\n  }","commit_id":"750b3af3eb6ea4e60b40b982a1b413879abddf97","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void initComponent() {\n    // setup undo\n    UndoHelper.getInstance().setUndoHandler(new WorkbenchUndoHandler());\n\n    // setup model access\n    ModelAccess.setInstance(new WorkbenchModelAccess());\n\n    // setup MPS.Core\n    myMPSCore = new MPSCore();\n    myMPSCore.init();\n    myMPSPersistence = new MPSPersistence();\n    myMPSPersistence.init();\n    MPSTypesystem.getInstance().init();\n    MPSGenerator.getInstance().init();\n    MPSFindUsages.getInstance().init();\n\n    // setup BaseLanguage\n    MPSBaseLanguage.getInstance().init();\n  }","id":92863,"modified_method":"@Override\n  public void initComponent() {\n    // setup undo\n    UndoHelper.getInstance().setUndoHandler(new WorkbenchUndoHandler());\n\n    // setup model access\n    ModelAccess.setInstance(new WorkbenchModelAccess());\n\n    // setup MPS.Core\n    myMPSCore = new MPSCore();\n    myMPSPersistence = new MPSPersistence();\n    myMPSTypesystem = new MPSTypesystem();\n    myMPSGenerator = new MPSGenerator();\n    myMPSFindUsages = new MPSFindUsages();\n    myMPSCore.init();\n    myMPSPersistence.init();\n    myMPSTypesystem.init();\n    myMPSGenerator.init();\n    myMPSFindUsages.init();\n\n    // setup BaseLanguage\n    myMPSBaseLanguage = new MPSBaseLanguage();\n    myMPSBaseLanguage.init();\n  }","commit_id":"750b3af3eb6ea4e60b40b982a1b413879abddf97","url":"https://github.com/JetBrains/MPS"},{"original_method":"private MPSFindUsages() {\n  }","id":92864,"modified_method":"public MPSFindUsages() {\n  }","commit_id":"750b3af3eb6ea4e60b40b982a1b413879abddf97","url":"https://github.com/JetBrains/MPS"},{"original_method":"private MPSGenerator() {\n  }","id":92865,"modified_method":"public MPSGenerator() {\n  }","commit_id":"750b3af3eb6ea4e60b40b982a1b413879abddf97","url":"https://github.com/JetBrains/MPS"},{"original_method":"private MPSTypesystem() {\n  }","id":92866,"modified_method":"public MPSTypesystem() {\n  }","commit_id":"750b3af3eb6ea4e60b40b982a1b413879abddf97","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void dispose() {\n    MPSBaseLanguage.getInstance().dispose();\n    MPSGenerator.getInstance().dispose();\n    MPSTypesystem.getInstance().dispose();\n    myMPSPersistence.dispose();\n    myMPSPersistence = null;\n    myMPSCore.dispose();\n    myMPSCore = null;\n  }","id":92867,"modified_method":"public void dispose() {\n    myMPSBaseLanguage.dispose();\n    myMPSGenerator.dispose();\n    myMPSTypesystem.dispose();\n    myMPSPersistence.dispose();\n    myMPSCore.dispose();\n    myMPSBaseLanguage = null;\n    myMPSGenerator = null;\n    myMPSTypesystem = null;\n    myMPSPersistence = null;\n    myMPSCore = null;\n  }","commit_id":"750b3af3eb6ea4e60b40b982a1b413879abddf97","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void init() {\n    myMPSCore = new MPSCore();\n    myMPSCore.init();\n    myMPSPersistence = new MPSPersistence();\n    myMPSPersistence.init();\n    MPSTypesystem.getInstance().init();\n    MPSGenerator.getInstance().init();\n    MPSBaseLanguage.getInstance().init();\n  }","id":92868,"modified_method":"public void init() {\n    myMPSCore = new MPSCore();\n    myMPSPersistence = new MPSPersistence();\n    myMPSTypesystem = new MPSTypesystem();\n    myMPSGenerator = new MPSGenerator();\n    myMPSBaseLanguage = new MPSBaseLanguage();\n    myMPSCore.init();\n    myMPSPersistence.init();\n    myMPSTypesystem.init();\n    myMPSGenerator.init();\n    myMPSBaseLanguage.init();\n  }","commit_id":"750b3af3eb6ea4e60b40b982a1b413879abddf97","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected ResourceBundle getResourceBundle(Locale locale) {\n\t\ttry {\n\t\t\treturn ResourceBundleUtil.getBundle(\n\t\t\t\tgetResourceBundleBaseName(_clazz), locale, _clazz);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn ResourceBundleUtil.getBundle(\n\t\t\t\tgetResourceBundleBaseName(_clazz), locale,\n\t\t\t\tPortalClassLoaderUtil.getClassLoader());\n\t\t}\n\t}","id":92869,"modified_method":"protected ResourceBundle getResourceBundle(Locale locale) {\n\t\tResourceBundle portalResourceBundle = ResourceBundleUtil.getBundle(\n\t\t\t\"content.Language\", locale, PortalClassLoaderUtil.getClassLoader());\n\n\t\treturn new AggregateResourceBundle(\n\t\t\tportalResourceBundle,\n\t\t\tResourceBundleUtil.getBundle(\n\t\t\t\t\"content.Language\", locale, getClass()));\n\t}","commit_id":"863608a6afdce3acca83f0cbb0275b13f9f63dee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * Gets the ResourceBundle for the given user interface language.\n   */\n  private static ResourceBundle getMessageBundle(final Language lang) {\n    try {\n      return ResourceBundle.getBundle(\n          \"de.danielnaber.languagetool.MessagesBundle\", lang.getLocale());\n    } catch (final MissingResourceException e) {\n      return ResourceBundle.getBundle(\n          \"de.danielnaber.languagetool.MessagesBundle\", Locale.ENGLISH);\n    }\n  }","id":92870,"modified_method":"/**\n   * Gets the ResourceBundle for the given user interface language.\n   */\n  private static ResourceBundle getMessageBundle(final Language lang) {\n    try {\n      final ResourceBundle bundle = ResourceBundle.getBundle(\"de.danielnaber.languagetool.MessagesBundle\", \n              lang.getLocale());\n      final ResourceBundle fallbackBundle = ResourceBundle.getBundle(\n          \"de.danielnaber.languagetool.MessagesBundle\", Locale.ENGLISH);\n      return new ResourceBundleWithFallback(bundle, fallbackBundle);\n    } catch (final MissingResourceException e) {\n      return ResourceBundle.getBundle(\n          \"de.danielnaber.languagetool.MessagesBundle\", Locale.ENGLISH);\n    }\n  }","commit_id":"7f73e7ce46fd0caad760d9f61e75a9211468d2ab","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * Gets the ResourceBundle for the default language of the user's system.\n   */\n  public static ResourceBundle getMessageBundle() {\n    try {\n      return ResourceBundle\n          .getBundle(\"de.danielnaber.languagetool.MessagesBundle\");\n    } catch (final MissingResourceException e) {\n      return ResourceBundle.getBundle(\n          \"de.danielnaber.languagetool.MessagesBundle\", Locale.ENGLISH);\n    }\n  }","id":92871,"modified_method":"/**\n   * Gets the ResourceBundle for the default language of the user's system.\n   */\n  public static ResourceBundle getMessageBundle() {\n    try {\n      final ResourceBundle bundle = ResourceBundle.getBundle(\"de.danielnaber.languagetool.MessagesBundle\");\n      final ResourceBundle fallbackBundle = ResourceBundle.getBundle(\n          \"de.danielnaber.languagetool.MessagesBundle\", Locale.ENGLISH);\n      return new ResourceBundleWithFallback(bundle, fallbackBundle);\n    } catch (final MissingResourceException e) {\n      return ResourceBundle.getBundle(\n          \"de.danielnaber.languagetool.MessagesBundle\", Locale.ENGLISH);\n    }\n  }","commit_id":"7f73e7ce46fd0caad760d9f61e75a9211468d2ab","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private boolean checkSuper(XMethod m, HashSet<XMethod> others) {\n\t\tif (m.isStatic()) return false;\n\t\tif (m.getName().equals(\"<init>\") || m.getName().equals(\"<clinit>\")) return false;\n\t\tfor (XMethod m2 : others) {\n\t\t\ttry {\n\t\t\t\tif (confusingMethodNames(m, m2)\n\t\t\t\t\t\t&& Repository.instanceOf(m.getClassName(), m2.getClassName())) {\n\t\t\t\t\tWarningPropertySet<NamingProperty> propertySet = new WarningPropertySet<NamingProperty>();\n\t\t\t\t\t\n\t\t\t\t\tint priority = HIGH_PRIORITY;\n\t\t\t\t\tboolean intentional = false;\n\t\t\t\t\ttry {\n\t\t\t\t\tJavaClass clazz = Repository.lookupClass(m.getClassName());\n\t\t\t\t\tif (definedIn(clazz, m2)) {\n\t\t\t\t\t\tintentional = true;\n\t\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t\t\t}\n\t\t\t\t\tfor(JavaClass i : clazz.getAllInterfaces()) \n\t\t\t\t\t\tif (definedIn(i, m))  {\n\t\t\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t\t\t\t\tintentional = true;\n\t\t\t\t\t\t}\n\t\t\t\t\tfor(JavaClass s : clazz.getSuperClasses()) \n\t\t\t\t\t\tif (definedIn(s, m)) {\n\t\t\t\t\t\t\tintentional = true;\n\t\t\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tXFactory xFactory = AnalysisContext.currentXFactory();\n\t\t\t\t\tif (!intentional && AnalysisContext.currentXFactory().isCalled(m)) \n\t\t\t\t\t\tpropertySet.addProperty(NamingProperty.METHOD_IS_CALLED);\n\t\t\t\t\telse if (xFactory.getDeprecated().contains(m) || xFactory.getDeprecated().contains(m2)) \n\t\t\t\t\t\tpropertySet.addProperty(NamingProperty.METHOD_IS_DEPRECATED);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tpriority = propertySet.computePriority(priority);\n\t\t\t\t\t\n\t\t\t\t\tif (!m.getName().equals(m2.getName()) && m.getName().equalsIgnoreCase(m2.getName())) {\n\t\t\t\t\tString pattern = intentional  ?  \"NM_VERY_CONFUSING_INTENTIONAL\" : \"NM_VERY_CONFUSING\";\n\t\t\t\t\t\n\t\t\t\t\tBugInstance bug = new BugInstance(this, pattern, priority)\n\t\t\t\t\t.addClass(m.getClassName())\n\t\t\t\t\t.addMethod(m)\n\t\t\t\t\t.addClass(m2.getClassName())\n\t\t\t\t\t.addMethod(m2);\n\t\t\t\t\tpropertySet.decorateBugInstance(bug);\n\t\t\t\t\tbugReporter.reportBug(bug);\n\t\t\t\t\t}\n\t\t\t\t\tif (!m.getSignature().equals(m2.getSignature()) \n\t\t\t\t\t\t\t&& removePackageNamesFromSignature(m.getSignature()).equals(\n\t\t\t\t\t\t\t\t\tremovePackageNamesFromSignature(m2.getSignature()))) {\n\t\t\t\t\t\tString pattern = intentional  ?  \"NM_WRONG_PACKAGE_INTENTIONAL\" : \"NM_WRONG_PACKAGE\";\n\t\t\t\t\t\t\n\t\t\t\t\t\tIterator<String> s = new SignatureParser(m.getSignature()).parameterSignatureIterator();\n\t\t\t\t\t\tIterator<String> s2 = new SignatureParser(m2.getSignature()).parameterSignatureIterator();\n\t\t\t\t\t\twhile (s.hasNext()) {\n\t\t\t\t\t\t\tString p = s.next();\n\t\t\t\t\t\t\tString p2 = s2.next();\n\t\t\t\t\t\t\tif (!p.equals(p2)) {\n\t\t\t\t\t\t\t\tBugInstance bug = new BugInstance(this, pattern, priority)\n\t\t\t\t\t\t\t\t.addClass(m.getClassName())\n\t\t\t\t\t\t\t\t.addMethod(m)\n\t\t\t\t\t\t\t\t.addClass(m2.getClassName())\n\t\t\t\t\t\t\t\t.addMethod(m2)\n\t\t\t\t\t\t\t\t.addFoundAndExpectedType(p, p2);\n\t\t\t\t\t\t\t\tpropertySet.decorateBugInstance(bug);\n\t\t\t\t\t\t\t\tbugReporter.reportBug(bug\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// \n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":92872,"modified_method":"private boolean checkSuper(XMethod m, HashSet<XMethod> others) {\n\t\tif (m.isStatic()) return false;\n\t\tif (m.getName().equals(\"<init>\") || m.getName().equals(\"<clinit>\")) return false;\n\t\tfor (XMethod m2 : others) {\n\t\t\ttry {\n\t\t\t\tif (confusingMethodNames(m, m2)\n\t\t\t\t\t\t&& Repository.instanceOf(m.getClassName(), m2.getClassName())) {\n\t\t\t\t\tWarningPropertySet<NamingProperty> propertySet = new WarningPropertySet<NamingProperty>();\n\t\t\t\t\t\n\t\t\t\t\tint priority = HIGH_PRIORITY;\n\t\t\t\t\tXMethod m3 = null;\n\t\t\t\t\ttry {\n\t\t\t\t\tJavaClass clazz = Repository.lookupClass(m.getClassName());\n\t\t\t\t\tif ((m3 = definedIn(clazz, m2)) == null) {\n\t\t\t\t\t\t // the method we don't override is also defined in our class\n\t\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t\t\t}\n\t\t\t\t\tif (m3 == null) for(JavaClass s : clazz.getSuperClasses()) \n\t\t\t\t\t\tif ((m3 = definedIn(s, m)) != null) {\n\t\t\t\t\t\t\t// the method we define is also defined in our superclass\n\t\t\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (false && m3 == null) for(JavaClass i : clazz.getAllInterfaces()) \n\t\t\t\t\t\tif ((m3 = definedIn(i, m)) != null)  {\n\t\t\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t\t\t\t\t// the method we define is also defined in an interface\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tXFactory xFactory = AnalysisContext.currentXFactory();\n\t\t\t\t\tif (m3 == null && AnalysisContext.currentXFactory().isCalled(m)) \n\t\t\t\t\t\tpropertySet.addProperty(NamingProperty.METHOD_IS_CALLED);\n\t\t\t\t\telse if (xFactory.getDeprecated().contains(m) || xFactory.getDeprecated().contains(m2)) \n\t\t\t\t\t\tpropertySet.addProperty(NamingProperty.METHOD_IS_DEPRECATED);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tpriority = propertySet.computePriority(priority);\n\t\t\t\t\t\n\t\t\t\t\tif (!m.getName().equals(m2.getName()) && m.getName().equalsIgnoreCase(m2.getName())) {\n\t\t\t\t\tString pattern = m3 != null  ?  \"NM_VERY_CONFUSING_INTENTIONAL\" : \"NM_VERY_CONFUSING\";\n\t\t\t\t\t\n\t\t\t\t\tBugInstance bug = new BugInstance(this, pattern, priority)\n\t\t\t\t\t.addClass(m.getClassName())\n\t\t\t\t\t.addMethod(m)\n\t\t\t\t\t.addClass(m2.getClassName())\n\t\t\t\t\t.addMethod(m2);\n\t\t\t\t\tif (m3 != null) bug.addMethod(m3);\n\t\t\t\t\tpropertySet.decorateBugInstance(bug);\n\t\t\t\t\tbugReporter.reportBug(bug);\n\t\t\t\t\t}\n\t\t\t\t\tif (!m.getSignature().equals(m2.getSignature()) \n\t\t\t\t\t\t\t&& removePackageNamesFromSignature(m.getSignature()).equals(\n\t\t\t\t\t\t\t\t\tremovePackageNamesFromSignature(m2.getSignature()))) {\n\t\t\t\t\t\tString pattern = m3 != null  ?  \"NM_WRONG_PACKAGE_INTENTIONAL\" : \"NM_WRONG_PACKAGE\";\n\t\t\t\t\t\t\n\t\t\t\t\t\tIterator<String> s = new SignatureParser(m.getSignature()).parameterSignatureIterator();\n\t\t\t\t\t\tIterator<String> s2 = new SignatureParser(m2.getSignature()).parameterSignatureIterator();\n\t\t\t\t\t\twhile (s.hasNext()) {\n\t\t\t\t\t\t\tString p = s.next();\n\t\t\t\t\t\t\tString p2 = s2.next();\n\t\t\t\t\t\t\tif (!p.equals(p2)) {\n\t\t\t\t\t\t\t\tBugInstance bug = new BugInstance(this, pattern, priority)\n\t\t\t\t\t\t\t\t.addClass(m.getClassName())\n\t\t\t\t\t\t\t\t.addMethod(m)\n\t\t\t\t\t\t\t\t.addClass(m2.getClassName())\n\t\t\t\t\t\t\t\t.addMethod(m2)\n\t\t\t\t\t\t\t\t.addFoundAndExpectedType(p, p2);\n\t\t\t\t\t\t\t\tif (m3 != null) bug.addMethod(m3);\n\t\t\t\t\t\t\t\tpropertySet.decorateBugInstance(bug);\n\t\t\t\t\t\t\t\tbugReporter.reportBug(bug\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// \n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"3aa6217bcaeaebd55472ad9d12e426a0854bf9bb","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\t\t public void visitJavaClass(JavaClass obj) {\n\t\tif (obj.isInterface()) return;\n\t\tString name = obj.getClassName();\n\t\tif (!visited.add(name)) return;\n\t\ttry {\n\t\t\tJavaClass supers[] = Repository.getSuperClasses(obj);\n\t\t\tfor (JavaClass aSuper : supers) {\n\t\t\t\tvisitJavaClass(aSuper);\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\t// ignore it\n\t\t}\n\t\tsuper.visitJavaClass(obj);\n\t}","id":92873,"modified_method":"@Override\n\t\t public void visitJavaClass(JavaClass obj) {\n\t\tString name = obj.getClassName();\n\t\tif (!visited.add(name)) return;\n\t\tString superClassName = obj.getSuperclassName();\n\t\tif (sameBaseName(superClassName, name)) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, \n\t\t\t\t\t\"NM_SAME_SIMPLE_NAME_AS_SUPERCLASS\", \n\t\t\t\t\tHIGH_PRIORITY ).addClass(this).addClass(superClassName));\n\t\t}\n\t\tfor(String interfaceName : obj.getInterfaceNames())\n\t\tif (sameBaseName(interfaceName, name)) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, \n\t\t\t\t\t\"NM_SAME_SIMPLE_NAME_AS_INTERFACE\", \n\t\t\t\t\tNORMAL_PRIORITY ).addClass(this).addClass(interfaceName));\n\t\t}\n\t\tif (obj.isInterface()) return;\n\n\n\t\ttry {\n\t\t\tJavaClass supers[] = Repository.getSuperClasses(obj);\n\t\t\tfor (JavaClass aSuper : supers) {\n\t\t\t\tvisitJavaClass(aSuper);\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\t// ignore it\n\t\t}\n\t\tsuper.visitJavaClass(obj);\n\t}","commit_id":"3aa6217bcaeaebd55472ad9d12e426a0854bf9bb","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static boolean definedIn(JavaClass clazz, XMethod m) {\n\t\tfor(Method m2 : clazz.getMethods()) \n\t\t\tif (m.getName().equals(m2.getName()) && m.getSignature().equals(m2.getSignature()) && m.isStatic() == m2.isStatic()) return true;\n\t\treturn false;\n\t}","id":92874,"modified_method":"public static @CheckForNull XMethod definedIn(JavaClass clazz, XMethod m) {\n\t\tfor(Method m2 : clazz.getMethods()) \n\t\t\tif (m.getName().equals(m2.getName()) && m.getSignature().equals(m2.getSignature()) && m.isStatic() == m2.isStatic()) \n\t\t\t\treturn XFactory.createXMethod(clazz, m2);\n\t\treturn null;\n\t}","commit_id":"3aa6217bcaeaebd55472ad9d12e426a0854bf9bb","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static void markStrangeSymbols(@NotNull PsiElement psiElement, @NotNull AnnotationHolder holder) {\n    TextRange textRange = psiElement.getTextRange();\n    String text = psiElement.getText();\n    for (int i = 0; i < text.length(); i++) {\n      if (text.charAt(i) == '\\t') {\n        int offset = textRange.getStartOffset() + i;\n        holder.createErrorAnnotation(new TextRange(offset, offset + 1), \"Tab character is not allowed\");\n      }\n    }\n  }","id":92875,"modified_method":"private static void markStrangeSymbols(@NotNull PsiElement psiElement, @NotNull AnnotationHolder holder) {\n    TextRange textRange = psiElement.getTextRange();\n    int startOffset = textRange.getStartOffset();\n    String text = psiElement.getText();\n    int specialCharactersStartOffset = -1;\n    int specialCharactersEndOffset = -1;\n    for (int i = 0; i < text.length(); i++) {\n      char ch = text.charAt(i);\n      if (ch == '\\t') {\n        int offset = startOffset + i;\n        holder.createErrorAnnotation(new TextRange(offset, offset + 1), \"Tab character is not allowed\");\n      }\n      else if (ch > 127) {\n        if (specialCharactersStartOffset == -1) {\n          specialCharactersStartOffset = startOffset + i;\n        }\n        specialCharactersEndOffset = startOffset + i;\n      }\n      if (specialCharactersEndOffset != -1 && specialCharactersEndOffset != startOffset + i) {\n        holder.createErrorAnnotation(new TextRange(specialCharactersStartOffset, specialCharactersEndOffset + 1), \"Special characters are not allowed\");\n        specialCharactersStartOffset = -1;\n        specialCharactersEndOffset = -1;\n      }\n    }\n    if (specialCharactersStartOffset != -1) {\n      holder.createErrorAnnotation(new TextRange(specialCharactersStartOffset, specialCharactersEndOffset + 1), \"Special characters are not allowed\");\n    }\n  }","commit_id":"08ced6ded88727f42ba246241b13d2b63dca33b1","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private Pair<CompletionContext, PsiElement> insertDummyIdentifier(final CompletionContext context, final FileCopyPatcher patcher) {\n    PsiFile oldFileCopy = createFileCopy(context.file);\n    PsiFile hostFile = InjectedLanguageUtil.getTopLevelFile(oldFileCopy);\n    boolean wasInjected = hostFile != oldFileCopy;\n    Project project = hostFile.getProject();\n    InjectedLanguageManager injectedLanguageManager = InjectedLanguageManager.getInstance(project);\n    // is null in tests\n    int hostStartOffset = injectedLanguageManager == null\n                          ? context.getStartOffset()\n                          : injectedLanguageManager.injectedToHost(oldFileCopy, context.getStartOffset());\n\n    Document document = oldFileCopy.getViewProvider().getDocument();\n    assert document != null;\n    patcher.patchFileCopy(oldFileCopy, document, context.getOffsetMap());\n    PsiDocumentManager.getInstance(project).commitDocument(document);\n    PsiFile fileCopy = InjectedLanguageUtil.findInjectedPsiNoCommit(hostFile, hostStartOffset);\n    if (fileCopy == null) {\n      PsiElement elementAfterCommit = findElementAt(hostFile, hostStartOffset);\n      if (wasInjected) {\n        LOG.error(\"No injected fragmnent found at offset \" + hostStartOffset + \" in the patched file copy, found: \" + elementAfterCommit);\n      }\n      fileCopy = elementAfterCommit == null ? oldFileCopy : elementAfterCommit.getContainingFile();\n    }\n\n    if (oldFileCopy != fileCopy && !wasInjected) {\n      // newly inserted identifier can well end up in the injected language region\n      Editor oldEditor = context.editor;\n      Editor editor = EditorFactory.getInstance().createEditor(document, project);\n      Editor newEditor = InjectedLanguageUtil.getEditorForInjectedLanguageNoCommit(editor, hostFile, context.getStartOffset());\n      if (newEditor instanceof EditorWindow) {\n        EditorWindow injectedEditor = (EditorWindow)newEditor;\n        PsiFile injectedFile = injectedEditor.getInjectedFile();\n        final OffsetMap map = new OffsetMap(newEditor.getDocument());\n        final OffsetMap oldMap = context.getOffsetMap();\n        for (final OffsetKey key : oldMap.keySet()) {\n          map.addOffset(key, injectedEditor.logicalPositionToOffset(injectedEditor.hostToInjected(oldEditor.offsetToLogicalPosition(oldMap.getOffset(key)))));\n        }\n        CompletionContext newContext = new CompletionContext(context.project, injectedEditor, injectedFile, map);\n        PsiElement element = findElementAt(injectedFile, newContext.getStartOffset());\n        if (element == null) {\n          final String allDoc = hostFile.getViewProvider().getDocument().getText();\n          String docText = allDoc.substring(Math.max(0, context.getStartOffset() - 10), Math.min(allDoc.length(), context.getStartOffset() + 10));\n\n          LOG.error(\"offset \" + newContext.getStartOffset() + \" at:\\n\" + \"text=\\\"\" + injectedFile.getText() + \"\\\"\\n\" + \"instance=\" +\n                    injectedFile + \"\\n\" + \"patcher=\" + patcher + \"\\n\" + \"docText=\" + docText);\n        }\n        EditorFactory.getInstance().releaseEditor(editor);\n        return Pair.create(newContext, element);\n      }\n      EditorFactory.getInstance().releaseEditor(editor);\n    }\n    PsiElement element = findElementAt(fileCopy, context.getStartOffset());\n    if (element == null) {\n      LOG.error(\"offset \" + context.getStartOffset() + \" at:\\ntext=\\\"\" + fileCopy.getText() + \"\\\"\\ninstance=\" + fileCopy);\n    }\n    return Pair.create(context, element);\n  }","id":92876,"modified_method":"private Pair<CompletionContext, PsiElement> insertDummyIdentifier(final CompletionContext context, final FileCopyPatcher patcher) {\n    PsiFile oldFileCopy = createFileCopy(context.file);\n    PsiFile hostFile = InjectedLanguageUtil.getTopLevelFile(oldFileCopy);\n    boolean wasInjected = hostFile != oldFileCopy;\n    Project project = hostFile.getProject();\n    InjectedLanguageManager injectedLanguageManager = InjectedLanguageManager.getInstance(project);\n    // is null in tests\n    int hostStartOffset = injectedLanguageManager == null\n                          ? context.getStartOffset()\n                          : injectedLanguageManager.injectedToHost(oldFileCopy, context.getStartOffset());\n\n    Document document = oldFileCopy.getViewProvider().getDocument();\n    assert document != null;\n    patcher.patchFileCopy(oldFileCopy, document, context.getOffsetMap());\n    PsiDocumentManager.getInstance(project).commitDocument(document);\n    PsiFile fileCopy = InjectedLanguageUtil.findInjectedPsiNoCommit(hostFile, hostStartOffset);\n    if (fileCopy == null) {\n      PsiElement elementAfterCommit = findElementAt(hostFile, hostStartOffset);\n      if (wasInjected) {\n        LOG.error(\"No injected fragmnent found at offset \" + hostStartOffset + \" in the patched file copy, found: \" + elementAfterCommit);\n      }\n      fileCopy = elementAfterCommit == null ? oldFileCopy : elementAfterCommit.getContainingFile();\n    }\n\n    if (oldFileCopy != fileCopy && !wasInjected) {\n      // newly inserted identifier can well end up in the injected language region\n      Editor oldEditor = context.editor;\n      Editor editor = EditorFactory.getInstance().createEditor(document, project);\n      Editor newEditor = InjectedLanguageUtil.getEditorForInjectedLanguageNoCommit(editor, hostFile, context.getStartOffset());\n      if (newEditor instanceof EditorWindow) {\n        EditorWindow injectedEditor = (EditorWindow)newEditor;\n        PsiFile injectedFile = injectedEditor.getInjectedFile();\n        final OffsetMap map = new OffsetMap(newEditor.getDocument());\n        final OffsetMap oldMap = context.getOffsetMap();\n        for (final OffsetKey key : oldMap.keySet()) {\n          map.addOffset(key, injectedEditor.logicalPositionToOffset(injectedEditor.hostToInjected(oldEditor.offsetToLogicalPosition(oldMap.getOffset(key)))));\n        }\n        CompletionContext newContext = new CompletionContext(context.project, injectedEditor, injectedFile, map);\n        int injectedOffset = newContext.getStartOffset();\n        PsiElement element = findElementAt(injectedFile, injectedOffset);\n\n        int toHost = injectedLanguageManager == null ? hostStartOffset : injectedLanguageManager.injectedToHost(injectedFile, injectedOffset);\n        // maybe injected fragment is ended before hostStartOffset\n        if (element != null && toHost == hostStartOffset) {\n          EditorFactory.getInstance().releaseEditor(editor);\n          return Pair.create(newContext, element);\n        }\n        else {\n          PsiElement elementAfterCommit = findElementAt(hostFile, hostStartOffset);\n          fileCopy = elementAfterCommit == null ? oldFileCopy : elementAfterCommit.getContainingFile();\n        }\n      }\n      EditorFactory.getInstance().releaseEditor(editor);\n    }\n    PsiElement element = findElementAt(fileCopy, context.getStartOffset());\n    if (element == null) {\n      LOG.error(\"offset \" + context.getStartOffset() + \" at:\\ntext=\\\"\" + fileCopy.getText() + \"\\\"\\ninstance=\" + fileCopy);\n    }\n    return Pair.create(context, element);\n  }","commit_id":"7f9e2a18ecc9092729cb91a8a4fe4561117aabfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void ensureLayout(@NotNull EditorView view, BidiRun run, int line) {\n      if (isReal()) {\n        view.getTextLayoutCache().onChunkAccess(this);\n      }\n      if (fragments != null) return;\n      fragments = new ArrayList<>();\n      int lineStartOffset = view.getEditor().getDocument().getLineStartOffset(line);\n      int start = lineStartOffset + startOffset;\n      int end = lineStartOffset + endOffset;\n      IterationState it = new IterationState(view.getEditor(), start, end, false, false, true, false, false);\n      FontPreferences fontPreferences = view.getEditor().getColorsScheme().getFontPreferences();\n      char[] chars = CharArrayUtil.fromSequence(view.getEditor().getDocument().getImmutableCharSequence(), start, end);\n      while (!it.atEnd()) {\n        addFragments(run, this, chars, it.getStartOffset() - start, it.getEndOffset() - start,\n                     it.getMergedAttributes().getFontType(), fontPreferences, view.getFontRenderContext(), view.getTabFragment());\n        it.advance();\n      }\n      view.getSizeManager().textLayoutPerformed(start, end);\n      assert !fragments.isEmpty();\n    }","id":92877,"modified_method":"private void ensureLayout(@NotNull EditorView view, BidiRun run, int line) {\n      if (isReal()) {\n        view.getTextLayoutCache().onChunkAccess(this);\n      }\n      if (fragments != null) return;\n      fragments = new ArrayList<>();\n      int lineStartOffset = view.getEditor().getDocument().getLineStartOffset(line);\n      int start = lineStartOffset + startOffset;\n      int end = lineStartOffset + endOffset;\n      IterationState it = new IterationState(view.getEditor(), start, end, false, false, true, false, false);\n      FontPreferences fontPreferences = view.getEditor().getColorsScheme().getFontPreferences();\n      char[] chars = CharArrayUtil.fromSequence(view.getEditor().getDocument().getImmutableCharSequence(), start, end);\n      int currentFontType = 0;\n      int currentStart = start;\n      while (!it.atEnd()) {\n        int fontType = it.getMergedAttributes().getFontType();\n        if (fontType != currentFontType) {\n          int tokenStart = it.getStartOffset();\n          if (tokenStart > currentStart) {\n            addFragments(run, this, chars, currentStart - start, tokenStart - start,\n                         currentFontType, fontPreferences, view.getFontRenderContext(), view.getTabFragment());\n          }\n          currentStart = tokenStart;\n          currentFontType = fontType;\n        }\n        it.advance();\n      }\n      if (end > currentStart) {\n        addFragments(run, this, chars, currentStart - start, end - start,\n                     currentFontType, fontPreferences, view.getFontRenderContext(), view.getTabFragment());\n      }\n      view.getSizeManager().textLayoutPerformed(start, end);\n      assert !fragments.isEmpty();\n    }","commit_id":"1865990de2ee0f1e596140a0e244b0fc668e7a3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static FoldRegion addCollapsedFoldRegion(final int startOffset, final int endOffset, final String placeholder) {\n    FoldRegion region = addFoldRegion(startOffset, endOffset, placeholder);\n    toggleFoldRegionState(getFoldRegion(startOffset), false);\n    return region;\n  }","id":92878,"modified_method":"protected static FoldRegion addCollapsedFoldRegion(final int startOffset, final int endOffset, final String placeholder) {\n    FoldRegion region = addFoldRegion(startOffset, endOffset, placeholder);\n    toggleFoldRegionState(region, false);\n    return region;\n  }","commit_id":"6f65c99230282b8e343021040caca8b6410d394b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void collapseFoldRegion(FoldRegion region) {\n    assertIsDispatchThreadForEditor();\n    if (!region.isExpanded()) return;\n\n    if (!myIsBatchFoldingProcessing) {\n      LOG.error(\"Fold regions must be collapsed or expanded inside batchFoldProcessing() only.\");\n    }\n\n    List<Caret> carets = myEditor.getCaretModel().getAllCarets();\n    for (Caret caret : carets) {\n      LogicalPosition caretPosition = caret.getLogicalPosition();\n      int caretOffset = myEditor.logicalPositionToOffset(caretPosition);\n      \n      if (FoldRegionsTree.contains(region, caretOffset)) {\n        if (myDoNotCollapseCaret) return;\n      }\n    }\n    for (Caret caret : carets) {\n      LogicalPosition caretPosition = caret.getLogicalPosition();\n      int caretOffset = myEditor.logicalPositionToOffset(caretPosition);\n      \n      if (FoldRegionsTree.contains(region, caretOffset)) {\n        if (caret.getUserData(SAVED_CARET_POSITION) == null) {\n          caret.putUserData(SAVED_CARET_POSITION, caretPosition.withoutVisualPositionInfo());\n        }\n      }\n    }\n\n    myFoldRegionsProcessed = true;\n    ((FoldRegionImpl) region).setExpandedInternal(false);\n    notifyListenersOnFoldRegionStateChange(region);\n  }","id":92879,"modified_method":"public void collapseFoldRegion(FoldRegion region) {\n    assertIsDispatchThreadForEditor();\n    if (!region.isExpanded()) return;\n\n    if (!myIsBatchFoldingProcessing) {\n      LOG.error(\"Fold regions must be collapsed or expanded inside batchFoldProcessing() only.\");\n    }\n\n    List<Caret> carets = myEditor.getCaretModel().getAllCarets();\n    for (Caret caret : carets) {\n      int caretOffset = caret.getOffset();\n      \n      if (FoldRegionsTree.contains(region, caretOffset)) {\n        if (myDoNotCollapseCaret) return;\n      }\n    }\n    for (Caret caret : carets) {\n      int caretOffset = caret.getOffset();\n      \n      if (FoldRegionsTree.contains(region, caretOffset)) {\n        if (caret.getUserData(SAVED_CARET_OFFSET) == null) {\n          caret.putUserData(SAVED_CARET_OFFSET, caretOffset);\n        }\n      }\n    }\n\n    myFoldRegionsProcessed = true;\n    ((FoldRegionImpl) region).setExpandedInternal(false);\n    notifyListenersOnFoldRegionStateChange(region);\n  }","commit_id":"6f65c99230282b8e343021040caca8b6410d394b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void flushCaretPosition() {\n    for (Caret caret : myEditor.getCaretModel().getAllCarets()) {\n      caret.putUserData(SAVED_CARET_POSITION, null);\n    }\n  }","id":92880,"modified_method":"public void flushCaretPosition() {\n    for (Caret caret : myEditor.getCaretModel().getAllCarets()) {\n      caret.putUserData(SAVED_CARET_OFFSET, null);\n    }\n  }","commit_id":"6f65c99230282b8e343021040caca8b6410d394b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void expandFoldRegion(FoldRegion region) {\n    assertIsDispatchThreadForEditor();\n    if (region.isExpanded() || region.shouldNeverExpand()) return;\n\n    if (!myIsBatchFoldingProcessing) {\n      LOG.error(\"Fold regions must be collapsed or expanded inside batchFoldProcessing() only.\");\n    }\n\n    for (Caret caret : myEditor.getCaretModel().getAllCarets()) {\n      LogicalPosition savedPosition = caret.getUserData(SAVED_CARET_POSITION);\n      if (savedPosition != null) {\n        int savedOffset = myEditor.logicalPositionToOffset(savedPosition);\n\n        FoldRegion[] allCollapsed = myFoldTree.fetchCollapsedAt(savedOffset);\n        if (allCollapsed.length == 1 && allCollapsed[0] == region) {\n          caret.moveToLogicalPosition(savedPosition);\n        }\n      }\n    }\n\n    myFoldRegionsProcessed = true;\n    ((FoldRegionImpl) region).setExpandedInternal(true);\n    notifyListenersOnFoldRegionStateChange(region);\n  }","id":92881,"modified_method":"public void expandFoldRegion(FoldRegion region) {\n    assertIsDispatchThreadForEditor();\n    if (region.isExpanded() || region.shouldNeverExpand()) return;\n\n    if (!myIsBatchFoldingProcessing) {\n      LOG.error(\"Fold regions must be collapsed or expanded inside batchFoldProcessing() only.\");\n    }\n\n    for (Caret caret : myEditor.getCaretModel().getAllCarets()) {\n      Integer savedOffset = caret.getUserData(SAVED_CARET_OFFSET);\n      if (savedOffset != null) {\n        FoldRegion[] allCollapsed = myFoldTree.fetchCollapsedAt(savedOffset);\n        if (allCollapsed.length == 1 && allCollapsed[0] == region) {\n          myCaretsToMove.add(caret);\n        }\n      }\n    }\n\n    myFoldRegionsProcessed = true;\n    ((FoldRegionImpl) region).setExpandedInternal(true);\n    notifyListenersOnFoldRegionStateChange(region);\n  }","commit_id":"6f65c99230282b8e343021040caca8b6410d394b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void notifyBatchFoldingProcessingDone(final boolean moveCaretFromCollapsedRegion) {\n    rebuild();\n\n    for (FoldingListener listener : myListeners) {\n      listener.onFoldProcessingEnd();\n    }\n\n    myEditor.updateCaretCursor();\n    myEditor.recalculateSizeAndRepaint();\n    myEditor.getGutterComponentEx().updateSize();\n    myEditor.getGutterComponentEx().repaint();\n\n    for (Caret caret : myEditor.getCaretModel().getAllCarets()) {\n      // There is a possible case that caret position is already visual position aware. But visual position depends on number of folded\n      // logical lines as well, hence, we can't be sure that target logical position defines correct visual position because fold\n      // regions have just changed. Hence, we use 'raw' logical position instead.\n      LogicalPosition caretPosition = caret.getLogicalPosition().withoutVisualPositionInfo();\n      int caretOffset = myEditor.logicalPositionToOffset(caretPosition);\n      int selectionStart = caret.getSelectionStart();\n      int selectionEnd = caret.getSelectionEnd();\n\n      LogicalPosition positionToUse = null;\n      int offsetToUse = -1;\n\n      FoldRegion collapsed = myFoldTree.fetchOutermost(caretOffset);\n      LogicalPosition savedPosition = caret.getUserData(SAVED_CARET_POSITION);\n      if (savedPosition != null) {\n        int savedOffset = myEditor.logicalPositionToOffset(savedPosition);\n        FoldRegion collapsedAtSaved = myFoldTree.fetchOutermost(savedOffset);\n        if (collapsedAtSaved == null) {\n          positionToUse = savedPosition;\n        }\n        else {\n          offsetToUse = collapsedAtSaved.getStartOffset();\n        }\n      }\n\n      if (collapsed != null && positionToUse == null) {\n        positionToUse = myEditor.offsetToLogicalPosition(collapsed.getStartOffset());\n      }\n\n      if (moveCaretFromCollapsedRegion && caret.isUpToDate()) {\n        if (offsetToUse >= 0) {\n          caret.moveToOffset(offsetToUse);\n        }\n        else if (positionToUse != null) {\n          caret.moveToLogicalPosition(positionToUse);\n        }\n        else {\n          caret.moveToLogicalPosition(caretPosition);\n        }\n      }\n\n      caret.putUserData(SAVED_CARET_POSITION, savedPosition);\n\n      if (isOffsetInsideCollapsedRegion(selectionStart) || isOffsetInsideCollapsedRegion(selectionEnd)) {\n        caret.removeSelection();\n      } else if (selectionStart < myEditor.getDocument().getTextLength()) {\n        caret.setSelection(selectionStart, selectionEnd);\n      }\n    }\n\n    if (mySavedCaretShift > 0) {\n      final ScrollingModel scrollingModel = myEditor.getScrollingModel();\n      scrollingModel.disableAnimation();\n      scrollingModel.scrollVertically(myEditor.visibleLineToY(myEditor.getCaretModel().getVisualPosition().line) - mySavedCaretShift);\n      scrollingModel.enableAnimation();\n    }\n  }","id":92882,"modified_method":"private void notifyBatchFoldingProcessingDone(final boolean moveCaretFromCollapsedRegion) {\n    rebuild();\n\n    for (FoldingListener listener : myListeners) {\n      listener.onFoldProcessingEnd();\n    }\n\n    myEditor.updateCaretCursor();\n    myEditor.recalculateSizeAndRepaint();\n    myEditor.getGutterComponentEx().updateSize();\n    myEditor.getGutterComponentEx().repaint();\n\n    for (Caret caret : myCaretsToMove) {\n      Integer savedOffset = caret.getUserData(SAVED_CARET_OFFSET);\n      if (savedOffset != null) {\n        caret.moveToOffset(savedOffset);\n      }\n    }\n    myCaretsToMove.clear();\n    \n    for (Caret caret : myEditor.getCaretModel().getAllCarets()) {\n      // There is a possible case that caret position is already visual position aware. But visual position depends on number of folded\n      // logical lines as well, hence, we can't be sure that target logical position defines correct visual position because fold\n      // regions have just changed. Hence, we use 'raw' logical position instead.\n      LogicalPosition caretPosition = caret.getLogicalPosition().withoutVisualPositionInfo();\n      int caretOffset = myEditor.logicalPositionToOffset(caretPosition);\n      int selectionStart = caret.getSelectionStart();\n      int selectionEnd = caret.getSelectionEnd();\n\n      int offsetToUse = -1;\n\n      FoldRegion collapsed = myFoldTree.fetchOutermost(caretOffset);\n      Integer savedOffset = caret.getUserData(SAVED_CARET_OFFSET);\n      if (savedOffset != null) {\n        FoldRegion collapsedAtSaved = myFoldTree.fetchOutermost(savedOffset);\n        offsetToUse = collapsedAtSaved == null ? savedOffset : collapsedAtSaved.getStartOffset();\n      }\n\n      if (collapsed != null && offsetToUse < 0) {\n        offsetToUse = collapsed.getStartOffset();\n      }\n\n      if (moveCaretFromCollapsedRegion && caret.isUpToDate()) {\n        if (offsetToUse >= 0) {\n          caret.moveToOffset(offsetToUse);\n        }\n        else {\n          caret.moveToLogicalPosition(caretPosition);\n        }\n      }\n\n      caret.putUserData(SAVED_CARET_OFFSET, savedOffset);\n\n      if (isOffsetInsideCollapsedRegion(selectionStart) || isOffsetInsideCollapsedRegion(selectionEnd)) {\n        caret.removeSelection();\n      } else if (selectionStart < myEditor.getDocument().getTextLength()) {\n        caret.setSelection(selectionStart, selectionEnd);\n      }\n    }\n\n    if (mySavedCaretShift > 0) {\n      final ScrollingModel scrollingModel = myEditor.getScrollingModel();\n      scrollingModel.disableAnimation();\n      scrollingModel.scrollVertically(myEditor.visibleLineToY(myEditor.getCaretModel().getVisualPosition().line) - mySavedCaretShift);\n      scrollingModel.enableAnimation();\n    }\n  }","commit_id":"6f65c99230282b8e343021040caca8b6410d394b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void collapseFoldRegion(FoldRegion region) {\n    assertIsDispatchThreadForEditor();\n    if (!region.isExpanded()) return;\n\n    if (!myIsBatchFoldingProcessing) {\n      LOG.error(\"Fold regions must be collapsed or expanded inside batchFoldProcessing() only.\");\n    }\n\n    List<Caret> carets = myEditor.getCaretModel().getAllCarets();\n    for (Caret caret : carets) {\n      int caretOffset = caret.getOffset();\n      \n      if (FoldRegionsTree.contains(region, caretOffset)) {\n        if (myDoNotCollapseCaret) return;\n      }\n    }\n    for (Caret caret : carets) {\n      int caretOffset = caret.getOffset();\n      \n      if (FoldRegionsTree.contains(region, caretOffset)) {\n        if (caret.getUserData(SAVED_CARET_OFFSET) == null) {\n          caret.putUserData(SAVED_CARET_OFFSET, caretOffset);\n        }\n      }\n    }\n\n    myFoldRegionsProcessed = true;\n    ((FoldRegionImpl) region).setExpandedInternal(false);\n    notifyListenersOnFoldRegionStateChange(region);\n  }","id":92883,"modified_method":"public void collapseFoldRegion(FoldRegion region) {\n    assertIsDispatchThreadForEditor();\n    if (!region.isExpanded()) return;\n\n    if (!myIsBatchFoldingProcessing) {\n      LOG.error(\"Fold regions must be collapsed or expanded inside batchFoldProcessing() only.\");\n    }\n\n    List<Caret> carets = myEditor.getCaretModel().getAllCarets();\n    for (Caret caret : carets) {\n      LogicalPosition caretPosition = caret.getLogicalPosition();\n      int caretOffset = myEditor.logicalPositionToOffset(caretPosition);\n      \n      if (FoldRegionsTree.contains(region, caretOffset)) {\n        if (myDoNotCollapseCaret) return;\n      }\n    }\n    for (Caret caret : carets) {\n      LogicalPosition caretPosition = caret.getLogicalPosition();\n      int caretOffset = myEditor.logicalPositionToOffset(caretPosition);\n      \n      if (FoldRegionsTree.contains(region, caretOffset)) {\n        if (caret.getUserData(SAVED_CARET_POSITION) == null) {\n          caret.putUserData(SAVED_CARET_POSITION, caretPosition.withoutVisualPositionInfo());\n        }\n      }\n    }\n\n    myFoldRegionsProcessed = true;\n    ((FoldRegionImpl) region).setExpandedInternal(false);\n    notifyListenersOnFoldRegionStateChange(region);\n  }","commit_id":"9ddd3515ee5f9c280f25d22549c9b91cca5873cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void notifyBatchFoldingProcessingDone(final boolean moveCaretFromCollapsedRegion) {\n    rebuild();\n\n    for (FoldingListener listener : myListeners) {\n      listener.onFoldProcessingEnd();\n    }\n\n    myEditor.updateCaretCursor();\n    myEditor.recalculateSizeAndRepaint();\n    myEditor.getGutterComponentEx().updateSize();\n    myEditor.getGutterComponentEx().repaint();\n\n    for (Caret caret : myCaretsToMove) {\n      Integer savedOffset = caret.getUserData(SAVED_CARET_OFFSET);\n      if (savedOffset != null) {\n        caret.moveToOffset(savedOffset);\n      }\n    }\n    myCaretsToMove.clear();\n    \n    for (Caret caret : myEditor.getCaretModel().getAllCarets()) {\n      // There is a possible case that caret position is already visual position aware. But visual position depends on number of folded\n      // logical lines as well, hence, we can't be sure that target logical position defines correct visual position because fold\n      // regions have just changed. Hence, we use 'raw' logical position instead.\n      LogicalPosition caretPosition = caret.getLogicalPosition().withoutVisualPositionInfo();\n      int caretOffset = myEditor.logicalPositionToOffset(caretPosition);\n      int selectionStart = caret.getSelectionStart();\n      int selectionEnd = caret.getSelectionEnd();\n\n      int offsetToUse = -1;\n\n      FoldRegion collapsed = myFoldTree.fetchOutermost(caretOffset);\n      Integer savedOffset = caret.getUserData(SAVED_CARET_OFFSET);\n      if (savedOffset != null) {\n        FoldRegion collapsedAtSaved = myFoldTree.fetchOutermost(savedOffset);\n        offsetToUse = collapsedAtSaved == null ? savedOffset : collapsedAtSaved.getStartOffset();\n      }\n\n      if (collapsed != null && offsetToUse < 0) {\n        offsetToUse = collapsed.getStartOffset();\n      }\n\n      if (moveCaretFromCollapsedRegion && caret.isUpToDate()) {\n        if (offsetToUse >= 0) {\n          caret.moveToOffset(offsetToUse);\n        }\n        else {\n          caret.moveToLogicalPosition(caretPosition);\n        }\n      }\n\n      caret.putUserData(SAVED_CARET_OFFSET, savedOffset);\n\n      if (isOffsetInsideCollapsedRegion(selectionStart) || isOffsetInsideCollapsedRegion(selectionEnd)) {\n        caret.removeSelection();\n      } else if (selectionStart < myEditor.getDocument().getTextLength()) {\n        caret.setSelection(selectionStart, selectionEnd);\n      }\n    }\n\n    if (mySavedCaretShift > 0) {\n      final ScrollingModel scrollingModel = myEditor.getScrollingModel();\n      scrollingModel.disableAnimation();\n      scrollingModel.scrollVertically(myEditor.visibleLineToY(myEditor.getCaretModel().getVisualPosition().line) - mySavedCaretShift);\n      scrollingModel.enableAnimation();\n    }\n  }","id":92884,"modified_method":"private void notifyBatchFoldingProcessingDone(final boolean moveCaretFromCollapsedRegion) {\n    rebuild();\n\n    for (FoldingListener listener : myListeners) {\n      listener.onFoldProcessingEnd();\n    }\n\n    myEditor.updateCaretCursor();\n    myEditor.recalculateSizeAndRepaint();\n    myEditor.getGutterComponentEx().updateSize();\n    myEditor.getGutterComponentEx().repaint();\n\n    for (Caret caret : myEditor.getCaretModel().getAllCarets()) {\n      // There is a possible case that caret position is already visual position aware. But visual position depends on number of folded\n      // logical lines as well, hence, we can't be sure that target logical position defines correct visual position because fold\n      // regions have just changed. Hence, we use 'raw' logical position instead.\n      LogicalPosition caretPosition = caret.getLogicalPosition().withoutVisualPositionInfo();\n      int caretOffset = myEditor.logicalPositionToOffset(caretPosition);\n      int selectionStart = caret.getSelectionStart();\n      int selectionEnd = caret.getSelectionEnd();\n\n      LogicalPosition positionToUse = null;\n      int offsetToUse = -1;\n\n      FoldRegion collapsed = myFoldTree.fetchOutermost(caretOffset);\n      LogicalPosition savedPosition = caret.getUserData(SAVED_CARET_POSITION);\n      boolean markedForUpdate = caret.getUserData(MARK_FOR_UPDATE) != null;\n      \n      if (savedPosition != null) {\n        int savedOffset = myEditor.logicalPositionToOffset(savedPosition);\n        FoldRegion collapsedAtSaved = myFoldTree.fetchOutermost(savedOffset);\n        if (collapsedAtSaved == null) {\n          positionToUse = savedPosition;\n        }\n        else {\n          offsetToUse = collapsedAtSaved.getStartOffset();\n        }\n      }\n\n      if (collapsed != null && positionToUse == null) {\n        positionToUse = myEditor.offsetToLogicalPosition(collapsed.getStartOffset());\n      }\n\n      if ((markedForUpdate || moveCaretFromCollapsedRegion) && caret.isUpToDate()) {\n        if (offsetToUse >= 0) {\n          caret.moveToOffset(offsetToUse);\n        }\n        else if (positionToUse != null) {\n          caret.moveToLogicalPosition(positionToUse);\n        }\n        else {\n          caret.moveToLogicalPosition(caretPosition);\n        }\n      }\n\n      caret.putUserData(SAVED_CARET_POSITION, savedPosition);\n      caret.putUserData(MARK_FOR_UPDATE, null);\n\n      if (isOffsetInsideCollapsedRegion(selectionStart) || isOffsetInsideCollapsedRegion(selectionEnd)) {\n        caret.removeSelection();\n      } else if (selectionStart < myEditor.getDocument().getTextLength()) {\n        caret.setSelection(selectionStart, selectionEnd);\n      }\n    }\n\n    if (mySavedCaretShift > 0) {\n      final ScrollingModel scrollingModel = myEditor.getScrollingModel();\n      scrollingModel.disableAnimation();\n      scrollingModel.scrollVertically(myEditor.visibleLineToY(myEditor.getCaretModel().getVisualPosition().line) - mySavedCaretShift);\n      scrollingModel.enableAnimation();\n    }\n  }","commit_id":"9ddd3515ee5f9c280f25d22549c9b91cca5873cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void flushCaretPosition() {\n    for (Caret caret : myEditor.getCaretModel().getAllCarets()) {\n      caret.putUserData(SAVED_CARET_OFFSET, null);\n    }\n  }","id":92885,"modified_method":"public void flushCaretPosition() {\n    for (Caret caret : myEditor.getCaretModel().getAllCarets()) {\n      caret.putUserData(SAVED_CARET_POSITION, null);\n    }\n  }","commit_id":"9ddd3515ee5f9c280f25d22549c9b91cca5873cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void expandFoldRegion(FoldRegion region) {\n    assertIsDispatchThreadForEditor();\n    if (region.isExpanded() || region.shouldNeverExpand()) return;\n\n    if (!myIsBatchFoldingProcessing) {\n      LOG.error(\"Fold regions must be collapsed or expanded inside batchFoldProcessing() only.\");\n    }\n\n    for (Caret caret : myEditor.getCaretModel().getAllCarets()) {\n      Integer savedOffset = caret.getUserData(SAVED_CARET_OFFSET);\n      if (savedOffset != null) {\n        FoldRegion[] allCollapsed = myFoldTree.fetchCollapsedAt(savedOffset);\n        if (allCollapsed.length == 1 && allCollapsed[0] == region) {\n          myCaretsToMove.add(caret);\n        }\n      }\n    }\n\n    myFoldRegionsProcessed = true;\n    ((FoldRegionImpl) region).setExpandedInternal(true);\n    notifyListenersOnFoldRegionStateChange(region);\n  }","id":92886,"modified_method":"public void expandFoldRegion(FoldRegion region) {\n    assertIsDispatchThreadForEditor();\n    if (region.isExpanded() || region.shouldNeverExpand()) return;\n\n    if (!myIsBatchFoldingProcessing) {\n      LOG.error(\"Fold regions must be collapsed or expanded inside batchFoldProcessing() only.\");\n    }\n\n    for (Caret caret : myEditor.getCaretModel().getAllCarets()) {\n      LogicalPosition savedPosition = caret.getUserData(SAVED_CARET_POSITION);\n      if (savedPosition != null) {\n        int savedOffset = myEditor.logicalPositionToOffset(savedPosition);\n\n        FoldRegion[] allCollapsed = myFoldTree.fetchCollapsedAt(savedOffset);\n        if (allCollapsed.length == 1 && allCollapsed[0] == region) {\n          caret.putUserData(MARK_FOR_UPDATE, Boolean.TRUE);\n        }\n      }\n    }\n\n    myFoldRegionsProcessed = true;\n    ((FoldRegionImpl) region).setExpandedInternal(true);\n    notifyListenersOnFoldRegionStateChange(region);\n  }","commit_id":"9ddd3515ee5f9c280f25d22549c9b91cca5873cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void getNoteView(final AudioVideoNotesPlugin.Recording recording, View view,\n\t\t\t\t\t\t\t\t   final Context ctx) {\n\t\tString name = recording.getName(ctx);\n\t\tTextView nameText = ((TextView) view.findViewById(R.id.name));\n\t\tnameText.setText(name);\n\t\t((TextView) view.findViewById(R.id.descr)).setText(recording.getDescription(ctx));\n\n\t\tImageView icon = (ImageView) view.findViewById(R.id.icon);\n\t\tif (recording.isAudio()) {\n\t\t\ticon.setImageResource(R.drawable.ic_type_audio);\n\t\t} else if (recording.isVideo()) {\n\t\t\ticon.setImageResource(R.drawable.ic_type_video);\n\t\t} else {\n\t\t\ticon.setImageResource(R.drawable.ic_type_img);\n\t\t}\n\n\t}","id":92887,"modified_method":"public static Drawable getNoteView(final AudioVideoNotesPlugin.Recording recording, View view,\n\t\t\t\t\t\t\t\t   final Context ctx) {\n\t\tString name = recording.getName(ctx);\n\t\tTextView nameText = ((TextView) view.findViewById(R.id.name));\n\t\tnameText.setText(name);\n\t\t((TextView) view.findViewById(R.id.descr)).setText(recording.getDescription(ctx));\n\n\t\tImageView icon = (ImageView) view.findViewById(R.id.icon);\n\t\tDrawable iconDrawable;\n\t\tif (recording.isAudio()) {\n\t\t\ticonDrawable = ctx.getResources().getDrawable(R.drawable.ic_type_audio);\n\t\t} else if (recording.isVideo()) {\n\t\t\ticonDrawable = ctx.getResources().getDrawable(R.drawable.ic_type_audio);\n\t\t} else {\n\t\t\ticonDrawable = ctx.getResources().getDrawable(R.drawable.ic_type_audio);\n\t\t}\n\t\ticon.setImageDrawable(iconDrawable);\n\t\treturn iconDrawable;\n\t}","commit_id":"bf73d4cc49f615c963a12dfd0c7ead50b67bd50d","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void setupNotes() {\n\t\tView mainView = getView();\n\t\tif (plugin == null){\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t}\n\n\t\tList<AudioVideoNotesPlugin.Recording> notes = new ArrayList<AudioVideoNotesPlugin.Recording>(plugin.getAllRecordings());\n\t\tif (notes.size() == 0){\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t} else {\n\t\t\tmainView.setVisibility(View.VISIBLE);\n\t\t}\n\n\t\tLinearLayout notesLayout = (LinearLayout) mainView.findViewById(R.id.notes);\n\t\tnotesLayout.removeAllViews();\n\t\tif (notes.size() > 3){\n\t\t\twhile (notes.size() != 3){\n\t\t\t\tnotes.remove(3);\n\t\t\t}\n\t\t}\n\n\t\tfor (final AudioVideoNotesPlugin.Recording recording : notes){\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView view = inflater.inflate(R.layout.note, null, false);\n\n\t\t\tgetNoteView(recording, view, getActivity());\n\t\t\tview.setBackgroundColor(Color.TRANSPARENT);\n\t\t\tview.findViewById(R.id.play).setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tplugin.playRecording(getActivity(), recording);\n\t\t\t\t}\n\t\t\t});\n\t\t\tview.findViewById(R.id.options).setVisibility(View.GONE);\n\t\t\tview.findViewById(R.id.divider).setVisibility(View.VISIBLE);\n\t\t\tview.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tgetMyApplication().getSettings().setMapLocationToShow(recording.getLatitude(), recording.getLongitude(), 15, \n\t\t\t\t\t\t\tnew PointDescription(recording.getSearchHistoryType(),\n\t\t\t\t\t\t\trecording.getName(getActivity())), true,\n\t\t\t\t\t\t\trecording); //$NON-NLS-1$\n\t\t\t\t\tMapActivity.launchMapActivityMoveToTop(getActivity());\n\t\t\t\t}\n\t\t\t});\n\t\t\tnotesLayout.addView(view);\n\t\t}\n\t}","id":92888,"modified_method":"public void setupNotes() {\n\t\tView mainView = getView();\n\t\tif (plugin == null){\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t}\n\n\t\tList<AudioVideoNotesPlugin.Recording> notes = new ArrayList<AudioVideoNotesPlugin.Recording>(plugin.getAllRecordings());\n\t\tif (notes.size() == 0){\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t} else {\n\t\t\tmainView.setVisibility(View.VISIBLE);\n\t\t}\n\n\t\tLinearLayout notesLayout = (LinearLayout) mainView.findViewById(R.id.notes);\n\t\tnotesLayout.removeAllViews();\n\t\tif (notes.size() > 3){\n\t\t\twhile (notes.size() != 3){\n\t\t\t\tnotes.remove(3);\n\t\t\t}\n\t\t}\n\n\t\tfor (final AudioVideoNotesPlugin.Recording recording : notes){\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView view = inflater.inflate(R.layout.note, null, false);\n\n\t\t\tDrawable icon =getNoteView(recording, view, getActivity());\n\t\t\ticon.setColorFilter(getResources().getColor(R.color.color_distance), PorterDuff.Mode.MULTIPLY);\n\t\t\tview.setBackgroundColor(Color.TRANSPARENT);\n\t\t\tview.findViewById(R.id.play).setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tplugin.playRecording(getActivity(), recording);\n\t\t\t\t}\n\t\t\t});\n\t\t\tview.findViewById(R.id.options).setVisibility(View.GONE);\n\t\t\tview.findViewById(R.id.divider).setVisibility(View.VISIBLE);\n\t\t\tview.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tgetMyApplication().getSettings().setMapLocationToShow(recording.getLatitude(), recording.getLongitude(), 15, \n\t\t\t\t\t\t\tnew PointDescription(recording.getSearchHistoryType(),\n\t\t\t\t\t\t\trecording.getName(getActivity())), true,\n\t\t\t\t\t\t\trecording); //$NON-NLS-1$\n\t\t\t\t\tMapActivity.launchMapActivityMoveToTop(getActivity());\n\t\t\t\t}\n\t\t\t});\n\t\t\tnotesLayout.addView(view);\n\t\t}\n\t}","commit_id":"bf73d4cc49f615c963a12dfd0c7ead50b67bd50d","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t\tpublic View getView(final int position, View convertView, ViewGroup parent) {\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView row = convertView;\n\t\t\tif (row == null) {\n\t\t\t\trow = inflater.inflate(R.layout.note, parent, false);\n\t\t\t}\n\n\t\t\tfinal AudioVideoNotesPlugin.Recording recording = getItem(position);\n\t\t\tDashAudioVideoNotesFragment.getNoteView(recording, row, getActivity());\n\t\t\trow.findViewById(R.id.play).setVisibility(View.GONE);\n\t\t\tImageButton options = (ImageButton) row.findViewById(R.id.options);\n\t\t\toptions.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\topenPopUpMenu(v, recording);\n\t\t\t\t}\n\t\t\t});\n\t\t\trow.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tshowOnMap(recording);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn row;\n\t\t}","id":92889,"modified_method":"@Override\n\t\tpublic View getView(final int position, View convertView, ViewGroup parent) {\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView row = convertView;\n\t\t\tif (row == null) {\n\t\t\t\trow = inflater.inflate(R.layout.note, parent, false);\n\t\t\t}\n\n\t\t\tfinal AudioVideoNotesPlugin.Recording recording = getItem(position);\n\t\t\tDrawable icon = DashAudioVideoNotesFragment.getNoteView(recording, row, getActivity());\n\t\t\ticon.setColorFilter(getResources().getColor(R.color.color_distance), Mode.MULTIPLY);\n\t\t\trow.findViewById(R.id.play).setVisibility(View.GONE);\n\t\t\tImageButton options = (ImageButton) row.findViewById(R.id.options);\n\t\t\toptions.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\topenPopUpMenu(v, recording);\n\t\t\t\t}\n\t\t\t});\n\t\t\trow.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tshowOnMap(recording);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn row;\n\t\t}","commit_id":"bf73d4cc49f615c963a12dfd0c7ead50b67bd50d","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public String getDefautColor() {\n\t\treturn \"grey\";\n\t}","id":92890,"modified_method":"public String getDefautColor() {\n\t\treturn \"192,192,192\"; // grey\n\t}","commit_id":"c142870fe6dcee34fb63b814823889130d44804e","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void run() {\n\t\tIXtextDocument document = editor.getDocument();\n\t\tISelection selection = editor.getSelectionProvider().getSelection();\n\t\tif (selection instanceof TextSelection) {\n\t\t\tTextSelection textSelection = (TextSelection) selection;\n\t\t\tif (textSelection.getLength()==0) {\n\t\t\t\tIRegion region = BracketMatchingUnitOfWork.match(document, bracketMatcher, textSelection.getOffset());\n\t\t\t\teditor.selectAndReveal(region.getOffset()+region.getLength(),0);\n\t\t\t}\n\t\t}\n\t}","id":92891,"modified_method":"@Override\n\tpublic void run() {\n\t\tIXtextDocument document = editor.getDocument();\n\t\tISelection selection = editor.getSelectionProvider().getSelection();\n\t\tif (selection instanceof TextSelection) {\n\t\t\tTextSelection textSelection = (TextSelection) selection;\n\t\t\tif (textSelection.getLength()==0) {\n\t\t\t\tIRegion region = BracketMatchingUnitOfWork.match(document, bracketMatcher, textSelection.getOffset());\n\t\t\t\tif (region != null)\n\t\t\t\t\teditor.selectAndReveal(region.getOffset()+region.getLength(),0);\n\t\t\t}\n\t\t}\n\t}","commit_id":"c142870fe6dcee34fb63b814823889130d44804e","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void selectAndReveal(final int selectionStart, final int selectionLength, final int revealStart, final int revealLength) {\n\t\tif (expectJavaSelection) {\n\t\t\t// TODO: use trace information for that purpose as soon as it's available\n//\t\t\tfinal ITextRegion[] fixedSelection = new ITextRegion[] { ITextRegion.EMPTY_REGION }; \n//\t\t\tfinal ITextRegion[] fixedReveal = new ITextRegion[] { ITextRegion.EMPTY_REGION }; \n//\t\t\tgetDocument().readOnly(new IUnitOfWork.Void<XtextResource>() {\n//\t\t\t\t@Override\n//\t\t\t\tpublic void process(XtextResource resource) throws Exception {\n//\t\t\t\t\tif (resource != null) {\n//\t\t\t\t\t\tIJavaElement root = JavaCore.create(javaResource);\n//\t\t\t\t\t\tif (root != null) {\n//\t\t\t\t\t\t\tICompilationUnit compilationUnit = (ICompilationUnit) root.getAncestor(IJavaElement.COMPILATION_UNIT);\n//\t\t\t\t\t\t\tif (compilationUnit != null) {\n//\t\t\t\t\t\t\t\tfixedSelection[0] = mergeSelectionOfDerivedMembers(resource, compilationUnit, selectionStart, selectionLength);\n//\t\t\t\t\t\t\t\tfixedReveal[0] = mergeSelectionOfDerivedMembers(resource, compilationUnit, revealStart, revealLength);\n//\t\t\t\t\t\t\t}\t\t\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t});\n\t\t\tITraceToSource traceToSource = traceInformation.getTraceToSource((IStorage) javaResource);\n\t\t\tILocationInResource bestSelection = traceToSource.getBestAssociatedLocation(new TextRegion(selectionStart, selectionLength));\n\t\t\tILocationInResource bestReveal = traceToSource.getBestAssociatedLocation(new TextRegion(revealStart, revealLength));\n\t\t\tITextRegion fixedSelection = bestSelection.getRange();\n\t\t\tITextRegion fixedReveal = bestReveal.getRange();\n\t\t\texpectJavaSelection = false;\n\t\t\tsuper.selectAndReveal(fixedSelection.getOffset(), fixedSelection.getLength(), fixedReveal.getOffset(), fixedReveal.getLength());\n\t\t} else {\n\t\t\tsuper.selectAndReveal(selectionStart, selectionLength, revealStart, revealLength);\n\t\t}\n\t}","id":92892,"modified_method":"@Override\n\tprotected void selectAndReveal(final int selectionStart, final int selectionLength, final int revealStart, final int revealLength) {\n\t\tif (expectJavaSelection) {\n\t\t\tITraceToSource traceToSource = traceInformation.getTraceToSource((IStorage) javaResource);\n\t\t\tif (traceToSource != null) {\n\t\t\t\tILocationInResource bestSelection = traceToSource.getBestAssociatedLocation(new TextRegion(selectionStart, selectionLength));\n\t\t\t\tif (bestSelection != null) {\n\t\t\t\t\tILocationInResource bestReveal = bestSelection;\n\t\t\t\t\tif (selectionStart != revealStart || selectionLength != revealLength) {\n\t\t\t\t\t\tbestReveal = traceToSource.getBestAssociatedLocation(new TextRegion(revealStart, revealLength));\n\t\t\t\t\t\tif (bestReveal == null) {\n\t\t\t\t\t\t\tbestReveal = bestSelection;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tITextRegion fixedSelection = bestSelection.getRange();\n\t\t\t\t\tif (fixedSelection != null) {\n\t\t\t\t\t\tITextRegion fixedReveal = bestReveal.getRange();\n\t\t\t\t\t\tif (fixedReveal == null) {\n\t\t\t\t\t\t\tfixedReveal = fixedSelection;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpectJavaSelection = false;\n\t\t\t\t\t\tsuper.selectAndReveal(fixedSelection.getOffset(), fixedSelection.getLength(), fixedReveal.getOffset(), fixedReveal.getLength());\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsuper.selectAndReveal(selectionStart, selectionLength, revealStart, revealLength);\n\t}","commit_id":"b36a118b5306aa13ebe1b4f0c75c57da1c0666ff","url":"https://github.com/eclipse/xtext"},{"original_method":"public String getDefautColor() {\n\t\treturn \"grey\";\n\t}","id":92893,"modified_method":"public String getDefautColor() {\n\t\treturn \"192,192,192\"; // grey\n\t}","commit_id":"fdebd907c78c1f667920115e2501f5278cb62e10","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void run() {\n\t\tIXtextDocument document = editor.getDocument();\n\t\tISelection selection = editor.getSelectionProvider().getSelection();\n\t\tif (selection instanceof TextSelection) {\n\t\t\tTextSelection textSelection = (TextSelection) selection;\n\t\t\tif (textSelection.getLength()==0) {\n\t\t\t\tIRegion region = BracketMatchingUnitOfWork.match(document, bracketMatcher, textSelection.getOffset());\n\t\t\t\teditor.selectAndReveal(region.getOffset()+region.getLength(),0);\n\t\t\t}\n\t\t}\n\t}","id":92894,"modified_method":"@Override\n\tpublic void run() {\n\t\tIXtextDocument document = editor.getDocument();\n\t\tISelection selection = editor.getSelectionProvider().getSelection();\n\t\tif (selection instanceof TextSelection) {\n\t\t\tTextSelection textSelection = (TextSelection) selection;\n\t\t\tif (textSelection.getLength()==0) {\n\t\t\t\tIRegion region = BracketMatchingUnitOfWork.match(document, bracketMatcher, textSelection.getOffset());\n\t\t\t\tif (region != null)\n\t\t\t\t\teditor.selectAndReveal(region.getOffset()+region.getLength(),0);\n\t\t\t}\n\t\t}\n\t}","commit_id":"fdebd907c78c1f667920115e2501f5278cb62e10","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void configure(IBracketPairAcceptor acceptor) {\n\t\tList<Pair<Keyword,Keyword>> pairs2 = grammarAccess.findKeywordPairs(\"(\", \")\");\n\t\tfor (Pair<Keyword, Keyword> pair : pairs2) {\n\t\t\tacceptor.accept(pair.getFirst(), pair.getSecond());\n\t\t}\n\t\tacceptor.accept(grammarAccess.getParserRuleAccess().getColonKeyword_3(), grammarAccess.getParserRuleAccess().getSemicolonKeyword_5());\n\t}","id":92895,"modified_method":"@Override\n\tpublic void configure(IBracketPairAcceptor acceptor) {\n\t\tsuper.configure(acceptor);\n\t\tacceptor.accept(grammarAccess.getParserRuleAccess().getColonKeyword_3(), grammarAccess.getParserRuleAccess().getSemicolonKeyword_5());\n\t\tacceptor.accept(grammarAccess.getTerminalRuleAccess().getColonKeyword_3(), grammarAccess.getTerminalRuleAccess().getSemicolonKeyword_5());\n\t\tacceptor.accept(grammarAccess.getEnumRuleAccess().getColonKeyword_3(), grammarAccess.getEnumRuleAccess().getSemicolonKeyword_5());\n\t}","commit_id":"fdebd907c78c1f667920115e2501f5278cb62e10","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  protected int getFeatures() {\n    int features = super.getFeatures() | TIME_MANAGEMENT;\n    if (myApiVersion == null || myApiVersion.getType() != JiraRemoteApi.ApiType.REST_2_0) {\n      return features & ~NATIVE_SEARCH & ~STATE_UPDATING & ~TIME_MANAGEMENT;\n    }\n    return features;\n  }","id":92896,"modified_method":"@Override\n  protected int getFeatures() {\n    int features = super.getFeatures() | TIME_MANAGEMENT;\n    if (myApiVersion == null || myApiVersion.getType() == JiraRemoteApi.ApiType.SOAP) {\n      return features & ~NATIVE_SEARCH & ~STATE_UPDATING & ~TIME_MANAGEMENT;\n    }\n    return features;\n  }","commit_id":"3d017bc53144808fb6780e3c05819722316295c8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Task[] getIssues(@Nullable String query, int max, long since) throws Exception {\n    ensureApiVersionDiscovered();\n    String jqlQuery = mySearchQuery;\n    if (StringUtil.isNotEmpty(mySearchQuery) && StringUtil.isNotEmpty(query)) {\n      jqlQuery = String.format(\"summary ~ '%s' and \", query) + mySearchQuery;\n    }\n    else if (StringUtil.isNotEmpty(query)) {\n      jqlQuery = String.format(\"summary ~ '%s'\", query);\n    }\n    return ArrayUtil.toObjectArray(myApiVersion.findTasks(jqlQuery, max), Task.class);\n  }","id":92897,"modified_method":"public Task[] getIssues(@Nullable String query, int max, long since) throws Exception {\n    ensureApiVersionDiscovered();\n    String resultQuery = query;\n    if (isJqlSupported()) {\n      if (StringUtil.isNotEmpty(mySearchQuery) && StringUtil.isNotEmpty(query)) {\n        resultQuery = String.format(\"summary ~ '%s' and \", query) + mySearchQuery;\n      }\n      else if (StringUtil.isNotEmpty(query)) {\n        resultQuery = String.format(\"summary ~ '%s'\", query);\n      } else {\n        resultQuery = mySearchQuery;\n      }\n    }\n    return ArrayUtil.toObjectArray(myApiVersion.findTasks(resultQuery, max), Task.class);\n  }","commit_id":"3d017bc53144808fb6780e3c05819722316295c8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public JiraRemoteApi discoverApiVersion() throws Exception {\n    String responseBody;\n    GetMethod method = new GetMethod(getRestUrl(\"serverInfo\"));\n    try {\n      responseBody = executeMethod(method);\n    }\n    catch (Exception e) {\n      // probably JIRA version prior 4.2\n      // without isRequestSent() getStatusCode() might throw NPE, if connection was refused\n      if (method.isRequestSent() && method.getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n        return new JiraSoapApi(this);\n      }\n      else {\n        throw e;\n      }\n    }\n    JsonObject object = GSON.fromJson(responseBody, JsonObject.class);\n    // when JIRA 4.x support will be dropped 'versionNumber' array in response\n    // may be used instead version string parsing\n    JiraRestApi restApi = JiraRestApi.fromJiraVersion(object.get(\"version\").getAsString(), this);\n    if (restApi == null) {\n      throw new Exception(TaskBundle.message(\"jira.failure.no.REST\"));\n    }\n    return restApi;\n    //return new JiraSoapApi(this);\n  }","id":92898,"modified_method":"@NotNull\n  public JiraRemoteApi discoverApiVersion() throws Exception {\n    if (DEBUG_SOAP) {\n      return new JiraSoapApi(this);\n    }\n\n    String responseBody;\n    GetMethod method = new GetMethod(getRestUrl(\"serverInfo\"));\n    try {\n      responseBody = executeMethod(method);\n    }\n    catch (Exception e) {\n      // probably JIRA version prior 4.2\n      // without isRequestSent() getStatusCode() might throw NPE, if connection was refused\n      if (method.isRequestSent() && method.getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n        return new JiraSoapApi(this);\n      }\n      else {\n        throw e;\n      }\n    }\n    JsonObject object = GSON.fromJson(responseBody, JsonObject.class);\n    // when JIRA 4.x support will be dropped 'versionNumber' array in response\n    // may be used instead version string parsing\n    JiraRestApi restApi = JiraRestApi.fromJiraVersion(object.get(\"version\").getAsString(), this);\n    if (restApi == null) {\n      throw new Exception(TaskBundle.message(\"jira.failure.no.REST\"));\n    }\n    return restApi;\n  }","commit_id":"3d017bc53144808fb6780e3c05819722316295c8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void ensureApiVersionDiscovered() throws Exception {\n    if (myApiVersion == null) {\n      myApiVersion = discoverApiVersion();\n    }\n  }","id":92899,"modified_method":"private void ensureApiVersionDiscovered() throws Exception {\n    if (myApiVersion == null || DEBUG_SOAP) {\n      myApiVersion = discoverApiVersion();\n    }\n  }","commit_id":"3d017bc53144808fb6780e3c05819722316295c8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void enableJqlSearchIfSupported() {\n    mySearchQueryField.setEnabled(myRepository.isSupported(TaskRepository.NATIVE_SEARCH));\n  }","id":92900,"modified_method":"private void enableJqlSearchIfSupported() {\n    mySearchQueryField.setEnabled(myRepository.isJqlSupported());\n  }","commit_id":"3d017bc53144808fb6780e3c05819722316295c8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public List<Task> findTasks(String query, int max) throws Exception {\n    StringBuilder url = new StringBuilder(myRepository.getUrl());\n    url.append(\"/sr/jira.issueviews:searchrequest-xml/temp/SearchRequest.xml?\");\n    url.append(\"tempMax=\").append(max);\n    url.append(\"&assignee=\").append(TaskUtil.encodeUrl(myRepository.getUsername()));\n    url.append(\"&reset=true\");\n    url.append(\"&sorter/field=updated\");\n    url.append(\"&sorter/order=DESC\");\n    url.append(\"&pager/start=0\");\n    return processRSS(url.toString(), login());\n  }","id":92901,"modified_method":"@NotNull\n  @Override\n  public List<Task> findTasks(String query, int max) throws Exception {\n\n    // Unfortunately, both SOAP and XML-RPC interfaces of JIRA don't allow fetching *all* tasks from server, but\n    // only filtered by some search term (see http://stackoverflow.com/questions/764282/how-can-jira-soap-api-not-have-this-method).\n    // JQL was added in SOAP only since JIRA 4.0 (see method JiraSoapService#getIssuesFromJqlSearch() at\n    // https://docs.atlassian.com/software/jira/docs/api/rpc-jira-plugin/latest/index.html?com/atlassian/jira/rpc/soap/JiraSoapService.html)\n    // So due to this limitation and the need to support these old versions of bug tracker (3.0, 4.2) we need the following ugly and hacky\n    // solution with extracting issues from RSS feed.\n\n    GetMethod method = new GetMethod(myRepository.getUrl() + RSS_SEARCH_PATH);\n    method.setQueryString(new NameValuePair[] {\n      new NameValuePair(\"tempMax\", String.valueOf(max)),\n      new NameValuePair(\"assignee\", TaskUtil.encodeUrl(myRepository.getUsername())),\n      new NameValuePair(\"reset\", \"true\"),\n      new NameValuePair(\"sorter/field\", \"updated\"),\n      new NameValuePair(\"sorter/order\", \"DESC\"),\n      new NameValuePair(\"pager/start\", \"0\")\n    });\n    return processRSS(method);\n  }","commit_id":"3d017bc53144808fb6780e3c05819722316295c8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setTaskState(Task task, TaskState state) throws Exception {\n    throw new Exception(\"Task state cannot be updated in JIRA versions prior 4.2.\");\n  }","id":92902,"modified_method":"@Override\n  public void setTaskState(Task task, TaskState state) throws Exception {\n    throw new Exception(TaskBundle.message(\"jira.failure.no.state.update\"));\n  }","commit_id":"3d017bc53144808fb6780e3c05819722316295c8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public Task findTask(String key) throws Exception {\n    try {\n      StringBuilder url = new StringBuilder(myRepository.getUrl());\n      url.append(\"/si/jira.issueviews:issue-xml/\");\n      url.append(key).append('/').append(key).append(\".xml\");\n\n      List<Task> tasks = processRSS(url.toString(), login());\n      return tasks.isEmpty() ? null : tasks.get(0);\n    }\n    catch (Exception e) {\n      LOG.warn(\"Cannot get issue \" + key + \": \" + e.getMessage());\n      return null;\n    }\n  }","id":92903,"modified_method":"@Nullable\n  @Override\n  public Task findTask(String key) throws Exception {\n    try {\n      List<Task> tasks = processRSS(new GetMethod(myRepository.getUrl() + RSS_ISSUE_PATH + key + '/' + key + \".xml\"));\n      return tasks.isEmpty() ? null : tasks.get(0);\n    }\n    catch (Exception e) {\n      LOG.warn(\"Cannot get issue \" + key + \": \" + e.getMessage());\n      return null;\n    }\n  }","commit_id":"3d017bc53144808fb6780e3c05819722316295c8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void updateTimeSpend(LocalTask task, String timeSpent, String comment) throws Exception {\n    throw new Exception(\"Time spent cannot be updated in JIRA versions prior 4.2.\");\n  }","id":92904,"modified_method":"@Override\n  public void updateTimeSpend(LocalTask task, String timeSpent, String comment) throws Exception {\n    throw new Exception(TaskBundle.message(\"jira.failure.no.time.spent\"));\n  }","commit_id":"3d017bc53144808fb6780e3c05819722316295c8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected MuleMessage doSend(MuleEvent event) throws Exception\n    {        \n        HttpMethod httpMethod = getMethod(event);\n        connector.setupClientAuthorization(event, httpMethod, client, endpoint);\n        \n        httpMethod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, new MuleHttpMethodRetryHandler());\n\n        Object body = null;\n        boolean releaseConn = false;\n        try\n        {   \n            httpMethod = execute(event, httpMethod);\n\n            DefaultExceptionPayload ep = null;\n            if (httpMethod.getStatusCode() >= ERROR_STATUS_CODE_RANGE_START)\n            {\n                ep = new DefaultExceptionPayload(new DispatchException(event.getMessage(), event.getEndpoint(),\n                    new Exception(\"Http call returned a status of: \" + httpMethod.getStatusCode() + \" \"\n                                  + httpMethod.getStatusText())));\n            }\n            \n            InputStream is = httpMethod.getResponseBodyAsStream();\n            if (is == null)\n            {\n                body = StringUtils.EMPTY;\n                releaseConn = true;\n            }            \n            else\n            {\n                is = new ReleasingInputStream(is, httpMethod);\n                body = is;\n            }\n            \n            Header[] headers = httpMethod.getResponseHeaders();\n            HttpMessageAdapter adapter = new HttpMessageAdapter(new Object[]{body, headers});\n\n            String status = String.valueOf(httpMethod.getStatusCode());\n\n            adapter.setProperty(HttpConnector.HTTP_STATUS_PROPERTY, status);\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Http response is: \" + status);\n            }\n            \n            MuleMessage m = new DefaultMuleMessage(adapter);\n          \n            m.setExceptionPayload(ep);\n            return m;\n        }\n        catch (Exception e)\n        {\n            releaseConn = true;\n            if (e instanceof DispatchException)\n            {\n                throw (DispatchException) e;\n            }\n            \n            throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n        }\n        finally\n        {\n            if (releaseConn) \n            {\n                httpMethod.releaseConnection();\n            }\n        }\n    }","id":92905,"modified_method":"protected MuleMessage doSend(MuleEvent event) throws Exception\n    {        \n        HttpMethod httpMethod = getMethod(event);\n        connector.setupClientAuthorization(event, httpMethod, client, endpoint);\n        \n        httpMethod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, new MuleHttpMethodRetryHandler());\n\n        Object body = null;\n        boolean releaseConn = false;\n        try\n        {   \n            httpMethod = execute(event, httpMethod);\n\n            DefaultExceptionPayload ep = null;\n            if (httpMethod.getStatusCode() >= ERROR_STATUS_CODE_RANGE_START)\n            {\n                ep = new DefaultExceptionPayload(new DispatchException(event.getMessage(), event.getEndpoint(),\n                    new HttpResponseException(httpMethod.getStatusText(), httpMethod.getStatusCode())));\n            }\n            \n            InputStream is = httpMethod.getResponseBodyAsStream();\n            if (is == null)\n            {\n                body = StringUtils.EMPTY;\n                releaseConn = true;\n            }            \n            else\n            {\n                is = new ReleasingInputStream(is, httpMethod);\n                body = is;\n            }\n            \n            Header[] headers = httpMethod.getResponseHeaders();\n            HttpMessageAdapter adapter = new HttpMessageAdapter(new Object[]{body, headers});\n\n            String status = String.valueOf(httpMethod.getStatusCode());\n\n            adapter.setProperty(HttpConnector.HTTP_STATUS_PROPERTY, status);\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Http response is: \" + status);\n            }\n            \n            MuleMessage m = new DefaultMuleMessage(adapter);\n          \n            m.setExceptionPayload(ep);\n            return m;\n        }\n        catch (Exception e)\n        {\n            releaseConn = true;\n            if (e instanceof DispatchException)\n            {\n                throw (DispatchException) e;\n            }\n            \n            throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n        }\n        finally\n        {\n            if (releaseConn) \n            {\n                httpMethod.releaseConnection();\n            }\n        }\n    }","commit_id":"ce09c5f9b377e4e477428f125e81876d4b29c74f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void addDynamicSetting(String... settings) {\n        clusterDynamicSettings.addDynamicSettings(settings);\n    }","id":92906,"modified_method":"public void addDynamicSettings(String... settings) {\n        clusterDynamicSettings.addDynamicSettings(settings);\n    }","commit_id":"3a534c64e5c07499b855cc79e4824460dcc12449","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public synchronized void addDynamicSettings(String... settings) {\n        HashSet<String> updatedSettings = new HashSet<String>(dynamicSettings);\n        updatedSettings.addAll(Arrays.asList(settings));\n        dynamicSettings = ImmutableSet.copyOf(updatedSettings);\n    }","id":92907,"modified_method":"public synchronized void addDynamicSettings(String... settings) {\n        MapBuilder<String, Validator> updatedSettings = MapBuilder.newMapBuilder(dynamicSettings);\n        for (String setting : settings) {\n            updatedSettings.put(setting, Validator.EmptyValidator.INSTANCE);\n        }\n        dynamicSettings = updatedSettings.immutableMap();\n    }","commit_id":"3a534c64e5c07499b855cc79e4824460dcc12449","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public boolean hasDynamicSetting(String key) {\n        for (String dynamicSetting : dynamicSettings) {\n            if (Regex.simpleMatch(dynamicSetting, key)) {\n                return true;\n            }\n        }\n        return false;\n    }","id":92908,"modified_method":"public boolean hasDynamicSetting(String key) {\n        for (String dynamicSetting : dynamicSettings.keySet()) {\n            if (Regex.simpleMatch(dynamicSetting, key)) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"3a534c64e5c07499b855cc79e4824460dcc12449","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void addDynamicSetting(String... settings) {\n        indexDynamicSettings.addDynamicSettings(settings);\n    }","id":92909,"modified_method":"public void addDynamicSettings(String... settings) {\n        indexDynamicSettings.addDynamicSettings(settings);\n    }","commit_id":"3a534c64e5c07499b855cc79e4824460dcc12449","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public IndexDynamicSettingsModule() {\n        indexDynamicSettings = new DynamicSettings();\n        indexDynamicSettings.addDynamicSettings(\n                AbstractIndexStore.INDEX_STORE_THROTTLE_MAX_BYTES_PER_SEC,\n                AbstractIndexStore.INDEX_STORE_THROTTLE_TYPE,\n                FilterAllocationDecider.INDEX_ROUTING_REQUIRE_GROUP + \"*\",\n                FilterAllocationDecider.INDEX_ROUTING_INCLUDE_GROUP + \"*\",\n                FilterAllocationDecider.INDEX_ROUTING_EXCLUDE_GROUP + \"*\",\n                FsTranslog.INDEX_TRANSLOG_FS_TYPE,\n                FsTranslog.INDEX_TRANSLOG_FS_BUFFER_SIZE,\n                FsTranslog.INDEX_TRANSLOG_FS_TRANSIENT_BUFFER_SIZE,\n                IndexMetaData.SETTING_NUMBER_OF_REPLICAS,\n                IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS,\n                IndexMetaData.SETTING_READ_ONLY,\n                IndexMetaData.SETTING_BLOCKS_READ,\n                IndexMetaData.SETTING_BLOCKS_WRITE,\n                IndexMetaData.SETTING_BLOCKS_METADATA,\n                IndexShardGatewayService.INDEX_GATEWAY_SNAPSHOT_INTERVAL,\n                IndicesTTLService.INDEX_TTL_DISABLE_PURGE,\n                InternalIndexShard.INDEX_REFRESH_INTERVAL,\n                LocalGatewayAllocator.INDEX_RECOVERY_INITIAL_SHARDS,\n                LogByteSizeMergePolicyProvider.INDEX_MERGE_POLICY_MIN_MERGE_SIZE,\n                LogByteSizeMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGE_SIZE,\n                LogByteSizeMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGE_DOCS,\n                LogByteSizeMergePolicyProvider.INDEX_MERGE_POLICY_MERGE_FACTOR,\n                LogByteSizeMergePolicyProvider.INDEX_COMPOUND_FORMAT,\n                LogDocMergePolicyProvider.INDEX_MERGE_POLICY_MIN_MERGE_DOCS,\n                LogDocMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGE_DOCS,\n                LogDocMergePolicyProvider.INDEX_MERGE_POLICY_MERGE_FACTOR,\n                LogDocMergePolicyProvider.INDEX_COMPOUND_FORMAT,\n                RobinEngine.INDEX_TERM_INDEX_INTERVAL,\n                RobinEngine.INDEX_TERM_INDEX_DIVISOR,\n                RobinEngine.INDEX_INDEX_CONCURRENCY,\n                RobinEngine.INDEX_GC_DELETES,\n                RobinEngine.INDEX_CODEC,\n                RobinEngine.INDEX_FAIL_ON_MERGE_FAILURE,\n                ShardSlowLogIndexingService.INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_WARN,\n                ShardSlowLogIndexingService.INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_INFO,\n                ShardSlowLogIndexingService.INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_DEBUG,\n                ShardSlowLogIndexingService.INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_TRACE,\n                ShardSlowLogIndexingService.INDEX_INDEXING_SLOWLOG_REFORMAT,\n                ShardSlowLogIndexingService.INDEX_INDEXING_SLOWLOG_LEVEL,\n                ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_QUERY_WARN,\n                ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_QUERY_INFO,\n                ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_QUERY_DEBUG,\n                ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_QUERY_TRACE,\n                ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_FETCH_WARN,\n                ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_FETCH_INFO,\n                ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_FETCH_DEBUG,\n                ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_FETCH_TRACE,\n                ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_REFORMAT,\n                ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_LEVEL,\n                ShardsLimitAllocationDecider.INDEX_TOTAL_SHARDS_PER_NODE,\n                TieredMergePolicyProvider.INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED,\n                TieredMergePolicyProvider.INDEX_MERGE_POLICY_FLOOR_SEGMENT,\n                TieredMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE,\n                TieredMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT,\n                TieredMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT,\n                TieredMergePolicyProvider.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER,\n                TieredMergePolicyProvider.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT,\n                TieredMergePolicyProvider.INDEX_COMPOUND_FORMAT,\n                TranslogService.INDEX_TRANSLOG_FLUSH_THRESHOLD_OPS,\n                TranslogService.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE,\n                TranslogService.INDEX_TRANSLOG_FLUSH_THRESHOLD_PERIOD,\n                TranslogService.INDEX_TRANSLOG_DISABLE_FLUSH);\n    }","id":92910,"modified_method":"public IndexDynamicSettingsModule() {\n        indexDynamicSettings = new DynamicSettings();\n        indexDynamicSettings.addDynamicSetting(AbstractIndexStore.INDEX_STORE_THROTTLE_MAX_BYTES_PER_SEC);\n        indexDynamicSettings.addDynamicSetting(AbstractIndexStore.INDEX_STORE_THROTTLE_TYPE);\n        indexDynamicSettings.addDynamicSetting(FilterAllocationDecider.INDEX_ROUTING_REQUIRE_GROUP + \"*\");\n        indexDynamicSettings.addDynamicSetting(FilterAllocationDecider.INDEX_ROUTING_INCLUDE_GROUP + \"*\");\n        indexDynamicSettings.addDynamicSetting(FilterAllocationDecider.INDEX_ROUTING_EXCLUDE_GROUP + \"*\");\n        indexDynamicSettings.addDynamicSetting(FsTranslog.INDEX_TRANSLOG_FS_TYPE);\n        indexDynamicSettings.addDynamicSetting(FsTranslog.INDEX_TRANSLOG_FS_BUFFER_SIZE);\n        indexDynamicSettings.addDynamicSetting(FsTranslog.INDEX_TRANSLOG_FS_TRANSIENT_BUFFER_SIZE);\n        indexDynamicSettings.addDynamicSetting(IndexMetaData.SETTING_NUMBER_OF_REPLICAS);\n        indexDynamicSettings.addDynamicSetting(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS);\n        indexDynamicSettings.addDynamicSetting(IndexMetaData.SETTING_READ_ONLY);\n        indexDynamicSettings.addDynamicSetting(IndexMetaData.SETTING_BLOCKS_READ);\n        indexDynamicSettings.addDynamicSetting(IndexMetaData.SETTING_BLOCKS_WRITE);\n        indexDynamicSettings.addDynamicSetting(IndexMetaData.SETTING_BLOCKS_METADATA);\n        indexDynamicSettings.addDynamicSetting(IndexShardGatewayService.INDEX_GATEWAY_SNAPSHOT_INTERVAL);\n        indexDynamicSettings.addDynamicSetting(IndicesTTLService.INDEX_TTL_DISABLE_PURGE);\n        indexDynamicSettings.addDynamicSetting(InternalIndexShard.INDEX_REFRESH_INTERVAL, Validator.TimeValueValidator.INSTANCE);\n        indexDynamicSettings.addDynamicSetting(LocalGatewayAllocator.INDEX_RECOVERY_INITIAL_SHARDS);\n        indexDynamicSettings.addDynamicSetting(LogByteSizeMergePolicyProvider.INDEX_MERGE_POLICY_MIN_MERGE_SIZE);\n        indexDynamicSettings.addDynamicSetting(LogByteSizeMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGE_SIZE);\n        indexDynamicSettings.addDynamicSetting(LogByteSizeMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGE_DOCS);\n        indexDynamicSettings.addDynamicSetting(LogByteSizeMergePolicyProvider.INDEX_MERGE_POLICY_MERGE_FACTOR);\n        indexDynamicSettings.addDynamicSetting(LogByteSizeMergePolicyProvider.INDEX_COMPOUND_FORMAT);\n        indexDynamicSettings.addDynamicSetting(LogDocMergePolicyProvider.INDEX_MERGE_POLICY_MIN_MERGE_DOCS);\n        indexDynamicSettings.addDynamicSetting(LogDocMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGE_DOCS);\n        indexDynamicSettings.addDynamicSetting(LogDocMergePolicyProvider.INDEX_MERGE_POLICY_MERGE_FACTOR);\n        indexDynamicSettings.addDynamicSetting(LogDocMergePolicyProvider.INDEX_COMPOUND_FORMAT);\n        indexDynamicSettings.addDynamicSetting(RobinEngine.INDEX_TERM_INDEX_INTERVAL);\n        indexDynamicSettings.addDynamicSetting(RobinEngine.INDEX_TERM_INDEX_DIVISOR);\n        indexDynamicSettings.addDynamicSetting(RobinEngine.INDEX_INDEX_CONCURRENCY);\n        indexDynamicSettings.addDynamicSetting(RobinEngine.INDEX_GC_DELETES);\n        indexDynamicSettings.addDynamicSetting(RobinEngine.INDEX_CODEC);\n        indexDynamicSettings.addDynamicSetting(RobinEngine.INDEX_FAIL_ON_MERGE_FAILURE);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogIndexingService.INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_WARN);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogIndexingService.INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_INFO);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogIndexingService.INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_DEBUG);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogIndexingService.INDEX_INDEXING_SLOWLOG_THRESHOLD_INDEX_TRACE);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogIndexingService.INDEX_INDEXING_SLOWLOG_REFORMAT);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogIndexingService.INDEX_INDEXING_SLOWLOG_LEVEL);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_QUERY_WARN);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_QUERY_INFO);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_QUERY_DEBUG);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_QUERY_TRACE);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_FETCH_WARN);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_FETCH_INFO);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_FETCH_DEBUG);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_THRESHOLD_FETCH_TRACE);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_REFORMAT);\n        indexDynamicSettings.addDynamicSetting(ShardSlowLogSearchService.INDEX_SEARCH_SLOWLOG_LEVEL);\n        indexDynamicSettings.addDynamicSetting(ShardsLimitAllocationDecider.INDEX_TOTAL_SHARDS_PER_NODE);\n        indexDynamicSettings.addDynamicSetting(TieredMergePolicyProvider.INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED);\n        indexDynamicSettings.addDynamicSetting(TieredMergePolicyProvider.INDEX_MERGE_POLICY_FLOOR_SEGMENT);\n        indexDynamicSettings.addDynamicSetting(TieredMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE);\n        indexDynamicSettings.addDynamicSetting(TieredMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT);\n        indexDynamicSettings.addDynamicSetting(TieredMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT);\n        indexDynamicSettings.addDynamicSetting(TieredMergePolicyProvider.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER);\n        indexDynamicSettings.addDynamicSetting(TieredMergePolicyProvider.INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT);\n        indexDynamicSettings.addDynamicSetting(TieredMergePolicyProvider.INDEX_COMPOUND_FORMAT);\n        indexDynamicSettings.addDynamicSetting(TranslogService.INDEX_TRANSLOG_FLUSH_THRESHOLD_OPS);\n        indexDynamicSettings.addDynamicSetting(TranslogService.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE);\n        indexDynamicSettings.addDynamicSetting(TranslogService.INDEX_TRANSLOG_FLUSH_THRESHOLD_PERIOD);\n        indexDynamicSettings.addDynamicSetting(TranslogService.INDEX_TRANSLOG_DISABLE_FLUSH);\n    }","commit_id":"3a534c64e5c07499b855cc79e4824460dcc12449","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void updateSettings(final Settings pSettings, final String[] indices, final Listener listener) {\n        ImmutableSettings.Builder updatedSettingsBuilder = ImmutableSettings.settingsBuilder();\n        for (Map.Entry<String, String> entry : pSettings.getAsMap().entrySet()) {\n            if (entry.getKey().equals(\"index\")) {\n                continue;\n            }\n            if (!entry.getKey().startsWith(\"index.\")) {\n                updatedSettingsBuilder.put(\"index.\" + entry.getKey(), entry.getValue());\n            } else {\n                updatedSettingsBuilder.put(entry.getKey(), entry.getValue());\n            }\n        }\n        // never allow to change the number of shards\n        for (String key : updatedSettingsBuilder.internalMap().keySet()) {\n            if (key.equals(IndexMetaData.SETTING_NUMBER_OF_SHARDS)) {\n                listener.onFailure(new ElasticSearchIllegalArgumentException(\"can't change the number of shards for an index\"));\n                return;\n            }\n        }\n\n        final Settings closeSettings = updatedSettingsBuilder.build();\n\n        final Set<String> removedSettings = Sets.newHashSet();\n        for (String key : updatedSettingsBuilder.internalMap().keySet()) {\n            if (!dynamicSettings.hasDynamicSetting(key)) {\n                removedSettings.add(key);\n            }\n        }\n        if (!removedSettings.isEmpty()) {\n            for (String removedSetting : removedSettings) {\n                updatedSettingsBuilder.remove(removedSetting);\n            }\n        }\n        final Settings openSettings = updatedSettingsBuilder.build();\n\n        clusterService.submitStateUpdateTask(\"update-settings\", Priority.URGENT, new ProcessedClusterStateUpdateTask() {\n            @Override\n            public ClusterState execute(ClusterState currentState) {\n                try {\n                    String[] actualIndices = currentState.metaData().concreteIndices(indices);\n                    RoutingTable.Builder routingTableBuilder = RoutingTable.builder().routingTable(currentState.routingTable());\n                    MetaData.Builder metaDataBuilder = MetaData.newMetaDataBuilder().metaData(currentState.metaData());\n\n                    // allow to change any settings to a close index, and only allow dynamic settings to be changed\n                    // on an open index\n                    Set<String> openIndices = Sets.newHashSet();\n                    Set<String> closeIndices = Sets.newHashSet();\n                    for (String index : actualIndices) {\n                        if (currentState.metaData().index(index).state() == IndexMetaData.State.OPEN) {\n                            openIndices.add(index);\n                        } else {\n                            closeIndices.add(index);\n                        }\n                    }\n\n                    if (!removedSettings.isEmpty() && !openIndices.isEmpty()) {\n                        listener.onFailure(new ElasticSearchIllegalArgumentException(String.format(\n                                \"Can't update non dynamic settings[%s] for open indices[%s]\",\n                                removedSettings,\n                                openIndices\n                        )));\n                        return currentState;\n                    }\n\n                    int updatedNumberOfReplicas = openSettings.getAsInt(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, -1);\n                    if (updatedNumberOfReplicas != -1) {\n                        routingTableBuilder.updateNumberOfReplicas(updatedNumberOfReplicas, actualIndices);\n                        metaDataBuilder.updateNumberOfReplicas(updatedNumberOfReplicas, actualIndices);\n                        logger.info(\"updating number_of_replicas to [{}] for indices {}\", updatedNumberOfReplicas, actualIndices);\n                    }\n\n                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n                    Boolean updatedReadOnly = openSettings.getAsBoolean(IndexMetaData.SETTING_READ_ONLY, null);\n                    if (updatedReadOnly != null) {\n                        for (String index : actualIndices) {\n                            if (updatedReadOnly) {\n                                blocks.addIndexBlock(index, IndexMetaData.INDEX_READ_ONLY_BLOCK);\n                            } else {\n                                blocks.removeIndexBlock(index, IndexMetaData.INDEX_READ_ONLY_BLOCK);\n                            }\n                        }\n                    }\n                    Boolean updateMetaDataBlock = openSettings.getAsBoolean(IndexMetaData.SETTING_BLOCKS_METADATA, null);\n                    if (updateMetaDataBlock != null) {\n                        for (String index : actualIndices) {\n                            if (updateMetaDataBlock) {\n                                blocks.addIndexBlock(index, IndexMetaData.INDEX_METADATA_BLOCK);\n                            } else {\n                                blocks.removeIndexBlock(index, IndexMetaData.INDEX_METADATA_BLOCK);\n                            }\n                        }\n                    }\n\n                    Boolean updateWriteBlock = openSettings.getAsBoolean(IndexMetaData.SETTING_BLOCKS_WRITE, null);\n                    if (updateWriteBlock != null) {\n                        for (String index : actualIndices) {\n                            if (updateWriteBlock) {\n                                blocks.addIndexBlock(index, IndexMetaData.INDEX_WRITE_BLOCK);\n                            } else {\n                                blocks.removeIndexBlock(index, IndexMetaData.INDEX_WRITE_BLOCK);\n                            }\n                        }\n                    }\n\n                    Boolean updateReadBlock = openSettings.getAsBoolean(IndexMetaData.SETTING_BLOCKS_READ, null);\n                    if (updateReadBlock != null) {\n                        for (String index : actualIndices) {\n                            if (updateReadBlock) {\n                                blocks.addIndexBlock(index, IndexMetaData.INDEX_READ_BLOCK);\n                            } else {\n                                blocks.removeIndexBlock(index, IndexMetaData.INDEX_READ_BLOCK);\n                            }\n                        }\n                    }\n\n                    if (!openIndices.isEmpty()) {\n                        String[] indices = openIndices.toArray(new String[openIndices.size()]);\n                        metaDataBuilder.updateSettings(openSettings, indices);\n                    }\n\n                    if (!closeIndices.isEmpty()) {\n                        String[] indices = closeIndices.toArray(new String[closeIndices.size()]);\n                        metaDataBuilder.updateSettings(closeSettings, indices);\n                    }\n\n\n                    ClusterState updatedState = ClusterState.builder().state(currentState).metaData(metaDataBuilder).routingTable(routingTableBuilder).blocks(blocks).build();\n\n                    // now, reroute in case things change that require it (like number of replicas)\n                    RoutingAllocation.Result routingResult = allocationService.reroute(updatedState);\n                    updatedState = newClusterStateBuilder().state(updatedState).routingResult(routingResult).build();\n\n                    return updatedState;\n                } catch (Exception e) {\n                    listener.onFailure(e);\n                    return currentState;\n                }\n            }\n\n            @Override\n            public void clusterStateProcessed(ClusterState clusterState) {\n                listener.onSuccess();\n            }\n        });\n    }","id":92911,"modified_method":"public void updateSettings(final Settings pSettings, final String[] indices, final Listener listener) {\n        ImmutableSettings.Builder updatedSettingsBuilder = ImmutableSettings.settingsBuilder();\n        for (Map.Entry<String, String> entry : pSettings.getAsMap().entrySet()) {\n            if (entry.getKey().equals(\"index\")) {\n                continue;\n            }\n            if (!entry.getKey().startsWith(\"index.\")) {\n                updatedSettingsBuilder.put(\"index.\" + entry.getKey(), entry.getValue());\n            } else {\n                updatedSettingsBuilder.put(entry.getKey(), entry.getValue());\n            }\n        }\n        // never allow to change the number of shards\n        for (String key : updatedSettingsBuilder.internalMap().keySet()) {\n            if (key.equals(IndexMetaData.SETTING_NUMBER_OF_SHARDS)) {\n                listener.onFailure(new ElasticSearchIllegalArgumentException(\"can't change the number of shards for an index\"));\n                return;\n            }\n        }\n\n        final Settings closeSettings = updatedSettingsBuilder.build();\n\n        final Set<String> removedSettings = Sets.newHashSet();\n        final Set<String> errors = Sets.newHashSet();\n        for (Map.Entry<String, String> setting : updatedSettingsBuilder.internalMap().entrySet()) {\n            if (!dynamicSettings.hasDynamicSetting(setting.getKey())) {\n                removedSettings.add(setting.getKey());\n            } else {\n                String error = dynamicSettings.validateDynamicSetting(setting.getKey(), setting.getValue());\n                if (error != null) {\n                    errors.add(\"[\" + setting.getKey() + \"] - \" + error);\n                }\n            }\n        }\n\n        if (!errors.isEmpty()) {\n            listener.onFailure(new ElasticSearchIllegalArgumentException(\"can't process the settings: \" + errors.toString()));\n            return;\n        }\n\n        if (!removedSettings.isEmpty()) {\n            for (String removedSetting : removedSettings) {\n                updatedSettingsBuilder.remove(removedSetting);\n            }\n        }\n        final Settings openSettings = updatedSettingsBuilder.build();\n\n        clusterService.submitStateUpdateTask(\"update-settings\", Priority.URGENT, new ProcessedClusterStateUpdateTask() {\n            @Override\n            public ClusterState execute(ClusterState currentState) {\n                try {\n                    String[] actualIndices = currentState.metaData().concreteIndices(indices);\n                    RoutingTable.Builder routingTableBuilder = RoutingTable.builder().routingTable(currentState.routingTable());\n                    MetaData.Builder metaDataBuilder = MetaData.newMetaDataBuilder().metaData(currentState.metaData());\n\n                    // allow to change any settings to a close index, and only allow dynamic settings to be changed\n                    // on an open index\n                    Set<String> openIndices = Sets.newHashSet();\n                    Set<String> closeIndices = Sets.newHashSet();\n                    for (String index : actualIndices) {\n                        if (currentState.metaData().index(index).state() == IndexMetaData.State.OPEN) {\n                            openIndices.add(index);\n                        } else {\n                            closeIndices.add(index);\n                        }\n                    }\n\n                    if (!removedSettings.isEmpty() && !openIndices.isEmpty()) {\n                        listener.onFailure(new ElasticSearchIllegalArgumentException(String.format(\n                                \"Can't update non dynamic settings[%s] for open indices[%s]\",\n                                removedSettings,\n                                openIndices\n                        )));\n                        return currentState;\n                    }\n\n                    int updatedNumberOfReplicas = openSettings.getAsInt(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, -1);\n                    if (updatedNumberOfReplicas != -1) {\n                        routingTableBuilder.updateNumberOfReplicas(updatedNumberOfReplicas, actualIndices);\n                        metaDataBuilder.updateNumberOfReplicas(updatedNumberOfReplicas, actualIndices);\n                        logger.info(\"updating number_of_replicas to [{}] for indices {}\", updatedNumberOfReplicas, actualIndices);\n                    }\n\n                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n                    Boolean updatedReadOnly = openSettings.getAsBoolean(IndexMetaData.SETTING_READ_ONLY, null);\n                    if (updatedReadOnly != null) {\n                        for (String index : actualIndices) {\n                            if (updatedReadOnly) {\n                                blocks.addIndexBlock(index, IndexMetaData.INDEX_READ_ONLY_BLOCK);\n                            } else {\n                                blocks.removeIndexBlock(index, IndexMetaData.INDEX_READ_ONLY_BLOCK);\n                            }\n                        }\n                    }\n                    Boolean updateMetaDataBlock = openSettings.getAsBoolean(IndexMetaData.SETTING_BLOCKS_METADATA, null);\n                    if (updateMetaDataBlock != null) {\n                        for (String index : actualIndices) {\n                            if (updateMetaDataBlock) {\n                                blocks.addIndexBlock(index, IndexMetaData.INDEX_METADATA_BLOCK);\n                            } else {\n                                blocks.removeIndexBlock(index, IndexMetaData.INDEX_METADATA_BLOCK);\n                            }\n                        }\n                    }\n\n                    Boolean updateWriteBlock = openSettings.getAsBoolean(IndexMetaData.SETTING_BLOCKS_WRITE, null);\n                    if (updateWriteBlock != null) {\n                        for (String index : actualIndices) {\n                            if (updateWriteBlock) {\n                                blocks.addIndexBlock(index, IndexMetaData.INDEX_WRITE_BLOCK);\n                            } else {\n                                blocks.removeIndexBlock(index, IndexMetaData.INDEX_WRITE_BLOCK);\n                            }\n                        }\n                    }\n\n                    Boolean updateReadBlock = openSettings.getAsBoolean(IndexMetaData.SETTING_BLOCKS_READ, null);\n                    if (updateReadBlock != null) {\n                        for (String index : actualIndices) {\n                            if (updateReadBlock) {\n                                blocks.addIndexBlock(index, IndexMetaData.INDEX_READ_BLOCK);\n                            } else {\n                                blocks.removeIndexBlock(index, IndexMetaData.INDEX_READ_BLOCK);\n                            }\n                        }\n                    }\n\n                    if (!openIndices.isEmpty()) {\n                        String[] indices = openIndices.toArray(new String[openIndices.size()]);\n                        metaDataBuilder.updateSettings(openSettings, indices);\n                    }\n\n                    if (!closeIndices.isEmpty()) {\n                        String[] indices = closeIndices.toArray(new String[closeIndices.size()]);\n                        metaDataBuilder.updateSettings(closeSettings, indices);\n                    }\n\n\n                    ClusterState updatedState = ClusterState.builder().state(currentState).metaData(metaDataBuilder).routingTable(routingTableBuilder).blocks(blocks).build();\n\n                    // now, reroute in case things change that require it (like number of replicas)\n                    RoutingAllocation.Result routingResult = allocationService.reroute(updatedState);\n                    updatedState = newClusterStateBuilder().state(updatedState).routingResult(routingResult).build();\n\n                    return updatedState;\n                } catch (Exception e) {\n                    listener.onFailure(e);\n                    return currentState;\n                }\n            }\n\n            @Override\n            public void clusterStateProcessed(ClusterState clusterState) {\n                listener.onSuccess();\n            }\n        });\n    }","commit_id":"3a534c64e5c07499b855cc79e4824460dcc12449","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected ClusterUpdateSettingsResponse masterOperation(final ClusterUpdateSettingsRequest request, ClusterState state) throws ElasticSearchException {\n        final AtomicReference<Throwable> failureRef = new AtomicReference<Throwable>();\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        clusterService.submitStateUpdateTask(\"cluster_update_settings\", Priority.URGENT, new ProcessedClusterStateUpdateTask() {\n            @Override\n            public ClusterState execute(ClusterState currentState) {\n                try {\n                    boolean changed = false;\n                    ImmutableSettings.Builder transientSettings = ImmutableSettings.settingsBuilder();\n                    transientSettings.put(currentState.metaData().transientSettings());\n                    for (Map.Entry<String, String> entry : request.transientSettings().getAsMap().entrySet()) {\n                        if (dynamicSettings.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith(\"logger.\")) {\n                            transientSettings.put(entry.getKey(), entry.getValue());\n                            changed = true;\n                        } else {\n                            logger.warn(\"ignoring transient setting [{}], not dynamically updateable\", entry.getKey());\n                        }\n                    }\n\n                    ImmutableSettings.Builder persistentSettings = ImmutableSettings.settingsBuilder();\n                    persistentSettings.put(currentState.metaData().persistentSettings());\n                    for (Map.Entry<String, String> entry : request.persistentSettings().getAsMap().entrySet()) {\n                        if (dynamicSettings.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith(\"logger.\")) {\n                            changed = true;\n                            persistentSettings.put(entry.getKey(), entry.getValue());\n                        } else {\n                            logger.warn(\"ignoring persistent setting [{}], not dynamically updateable\", entry.getKey());\n                        }\n                    }\n\n                    if (!changed) {\n                        latch.countDown();\n                        return currentState;\n                    }\n\n                    MetaData.Builder metaData = MetaData.builder().metaData(currentState.metaData())\n                            .persistentSettings(persistentSettings.build())\n                            .transientSettings(transientSettings.build());\n\n                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n                    boolean updatedReadOnly = metaData.persistentSettings().getAsBoolean(MetaData.SETTING_READ_ONLY, false) || metaData.transientSettings().getAsBoolean(MetaData.SETTING_READ_ONLY, false);\n                    if (updatedReadOnly) {\n                        blocks.addGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK);\n                    } else {\n                        blocks.removeGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK);\n                    }\n\n                    return ClusterState.builder().state(currentState).metaData(metaData).blocks(blocks).build();\n                } catch (Exception e) {\n                    latch.countDown();\n                    logger.warn(\"failed to update cluster settings\", e);\n                    return currentState;\n                } finally {\n                    // we don't release the latch here, only after we rerouted\n                }\n            }\n\n            @Override\n            public void clusterStateProcessed(ClusterState clusterState) {\n                // now, reroute\n                clusterService.submitStateUpdateTask(\"reroute_after_cluster_update_settings\", Priority.URGENT, new ClusterStateUpdateTask() {\n                    @Override\n                    public ClusterState execute(ClusterState currentState) {\n                        try {\n                            // now, reroute in case things change that require it (like number of replicas)\n                            RoutingAllocation.Result routingResult = allocationService.reroute(currentState);\n                            return newClusterStateBuilder().state(currentState).routingResult(routingResult).build();\n                        } finally {\n                            latch.countDown();\n                        }\n                    }\n                });\n            }\n        });\n\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            failureRef.set(e);\n        }\n\n        if (failureRef.get() != null) {\n            if (failureRef.get() instanceof ElasticSearchException) {\n                throw (ElasticSearchException) failureRef.get();\n            } else {\n                throw new ElasticSearchException(failureRef.get().getMessage(), failureRef.get());\n            }\n        }\n\n        return new ClusterUpdateSettingsResponse();\n    }","id":92912,"modified_method":"@Override\n    protected ClusterUpdateSettingsResponse masterOperation(final ClusterUpdateSettingsRequest request, ClusterState state) throws ElasticSearchException {\n        final AtomicReference<Throwable> failureRef = new AtomicReference<Throwable>();\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        clusterService.submitStateUpdateTask(\"cluster_update_settings\", Priority.URGENT, new ProcessedClusterStateUpdateTask() {\n            @Override\n            public ClusterState execute(ClusterState currentState) {\n                try {\n                    boolean changed = false;\n                    ImmutableSettings.Builder transientSettings = ImmutableSettings.settingsBuilder();\n                    transientSettings.put(currentState.metaData().transientSettings());\n                    for (Map.Entry<String, String> entry : request.transientSettings().getAsMap().entrySet()) {\n                        if (dynamicSettings.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith(\"logger.\")) {\n                            String error = dynamicSettings.validateDynamicSetting(entry.getKey(), entry.getValue());\n                            if (error == null) {\n                                transientSettings.put(entry.getKey(), entry.getValue());\n                                changed = true;\n                            } else {\n                                logger.warn(\"ignoring transient setting [{}], [{}]\", entry.getKey(), error);\n                            }\n                        } else {\n                            logger.warn(\"ignoring transient setting [{}], not dynamically updateable\", entry.getKey());\n                        }\n                    }\n\n                    ImmutableSettings.Builder persistentSettings = ImmutableSettings.settingsBuilder();\n                    persistentSettings.put(currentState.metaData().persistentSettings());\n                    for (Map.Entry<String, String> entry : request.persistentSettings().getAsMap().entrySet()) {\n                        if (dynamicSettings.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith(\"logger.\")) {\n                            String error = dynamicSettings.validateDynamicSetting(entry.getKey(), entry.getValue());\n                            if (error == null) {\n                                persistentSettings.put(entry.getKey(), entry.getValue());\n                                changed = true;\n                            } else {\n                                logger.warn(\"ignoring persistent setting [{}], [{}]\", entry.getKey(), error);\n                            }\n                        } else {\n                            logger.warn(\"ignoring persistent setting [{}], not dynamically updateable\", entry.getKey());\n                        }\n                    }\n\n                    if (!changed) {\n                        latch.countDown();\n                        return currentState;\n                    }\n\n                    MetaData.Builder metaData = MetaData.builder().metaData(currentState.metaData())\n                            .persistentSettings(persistentSettings.build())\n                            .transientSettings(transientSettings.build());\n\n                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n                    boolean updatedReadOnly = metaData.persistentSettings().getAsBoolean(MetaData.SETTING_READ_ONLY, false) || metaData.transientSettings().getAsBoolean(MetaData.SETTING_READ_ONLY, false);\n                    if (updatedReadOnly) {\n                        blocks.addGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK);\n                    } else {\n                        blocks.removeGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK);\n                    }\n\n                    return ClusterState.builder().state(currentState).metaData(metaData).blocks(blocks).build();\n                } catch (Exception e) {\n                    latch.countDown();\n                    logger.warn(\"failed to update cluster settings\", e);\n                    return currentState;\n                } finally {\n                    // we don't release the latch here, only after we rerouted\n                }\n            }\n\n            @Override\n            public void clusterStateProcessed(ClusterState clusterState) {\n                // now, reroute\n                clusterService.submitStateUpdateTask(\"reroute_after_cluster_update_settings\", Priority.URGENT, new ClusterStateUpdateTask() {\n                    @Override\n                    public ClusterState execute(ClusterState currentState) {\n                        try {\n                            // now, reroute in case things change that require it (like number of replicas)\n                            RoutingAllocation.Result routingResult = allocationService.reroute(currentState);\n                            return newClusterStateBuilder().state(currentState).routingResult(routingResult).build();\n                        } finally {\n                            latch.countDown();\n                        }\n                    }\n                });\n            }\n        });\n\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            failureRef.set(e);\n        }\n\n        if (failureRef.get() != null) {\n            if (failureRef.get() instanceof ElasticSearchException) {\n                throw (ElasticSearchException) failureRef.get();\n            } else {\n                throw new ElasticSearchException(failureRef.get().getMessage(), failureRef.get());\n            }\n        }\n\n        return new ClusterUpdateSettingsResponse();\n    }","commit_id":"3a534c64e5c07499b855cc79e4824460dcc12449","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static void createResources(Project project, Task task, VirtualFile taskDir) {\n    Map<String, TaskFile> files = task.getTaskFiles();\n    for (Map.Entry<String, TaskFile> entry : files.entrySet()) {\n      String name = entry.getKey();\n      VirtualFile child = taskDir.findChild(name);\n      if (child == null) {\n        continue;\n      }\n      Document patternDocument = StudyUtils.getPatternDocument(entry.getValue(), name);\n      Document document = FileDocumentManager.getInstance().getDocument(child);\n      if (document == null || patternDocument == null) {\n        return;\n      }\n      DocumentUtil.writeInRunUndoTransparentAction(() -> {\n        patternDocument.replaceString(0, patternDocument.getTextLength(), document.getCharsSequence());\n        FileDocumentManager.getInstance().saveDocument(patternDocument);\n      });\n      TaskFile target = new TaskFile();\n      TaskFile.copy(entry.getValue(), target);\n      for (AnswerPlaceholder placeholder : target.getAnswerPlaceholders()) {\n        placeholder.setUseLength(false);\n      }\n      EduUtils.createStudentDocument(project, target, child, patternDocument);\n    }\n  }","id":92913,"modified_method":"public static void createResources(Project project, Task task, VirtualFile taskDir) {\n    Map<String, TaskFile> files = task.getTaskFiles();\n    for (Map.Entry<String, TaskFile> entry : files.entrySet()) {\n      String name = entry.getKey();\n      VirtualFile child = taskDir.findChild(name);\n      if (child == null) {\n        continue;\n      }\n      Document patternDocument = StudyUtils.getPatternDocument(entry.getValue(), name);\n      Document document = FileDocumentManager.getInstance().getDocument(child);\n      if (document == null || patternDocument == null) {\n        LOG.info(\"pattern file for \" +  child.getPath() + \" not found\");\n        continue;\n      }\n      DocumentUtil.writeInRunUndoTransparentAction(() -> {\n        patternDocument.replaceString(0, patternDocument.getTextLength(), document.getCharsSequence());\n        FileDocumentManager.getInstance().saveDocument(patternDocument);\n      });\n      TaskFile target = new TaskFile();\n      TaskFile.copy(entry.getValue(), target);\n      for (AnswerPlaceholder placeholder : target.getAnswerPlaceholders()) {\n        placeholder.setUseLength(false);\n      }\n      EduUtils.createStudentDocument(project, target, child, patternDocument);\n    }\n  }","commit_id":"2193e9465a579fc663c862bbd4571be10c8b4dee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private String getFirstTaskFilePath() {\n    String firstTaskFileName = StudyUtils.getFirst(myTask.getTaskFiles().keySet());\n    String taskDirPath = FileUtil.toSystemDependentName(myTaskDir.getPath());\n    return myTaskDir.findChild(EduNames.SRC) != null ?\n           FileUtil.join(taskDirPath, EduNames.SRC, firstTaskFileName) :\n           FileUtil.join(taskDirPath, firstTaskFileName);\n  }","id":92914,"modified_method":"@Nullable\n  private String getFirstTaskFilePath() {\n    for (Map.Entry<String, TaskFile> entry : myTask.getTaskFiles().entrySet()) {\n      String path = getTaskFilePath(entry.getKey());\n      if (!entry.getValue().getAnswerPlaceholders().isEmpty()) {\n        return path;\n      }\n      VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(path);\n      if (virtualFile == null) {\n        continue;\n      }\n      if (TextEditorProvider.isTextFile(virtualFile)) {\n        return path;\n      }\n    }\n    return null;\n  }","commit_id":"2193e9465a579fc663c862bbd4571be10c8b4dee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void buildCommandLineParameters(GeneralCommandLine commandLine) {\n    ParamsGroup group = commandLine.getParametersList().getParamsGroup(GROUP_SCRIPT);\n    assert group != null;\n\n    Project project = myRunConfiguration.getProject();\n    Course course = StudyTaskManager.getInstance(project).getCourse();\n    assert course != null;\n\n    group.addParameter(myRunConfiguration.getPathToTest());\n    group.addParameter(new File(course.getCourseDirectory()).getPath());\n\n    group.addParameter(getFirstTaskFilePath());\n  }","id":92915,"modified_method":"@Override\n  protected void buildCommandLineParameters(GeneralCommandLine commandLine) {\n    ParamsGroup group = commandLine.getParametersList().getParamsGroup(GROUP_SCRIPT);\n    assert group != null;\n\n    Project project = myRunConfiguration.getProject();\n    Course course = StudyTaskManager.getInstance(project).getCourse();\n    assert course != null;\n\n    group.addParameter(myRunConfiguration.getPathToTest());\n    group.addParameter(new File(course.getCourseDirectory()).getPath());\n\n    String path = getFirstTaskFilePath();\n    if (path != null) {\n      group.addParameter(path);\n    }\n  }","commit_id":"2193e9465a579fc663c862bbd4571be10c8b4dee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Merge this AddressBook with AddressBook other, writing messages about new\n     * addresses or conflicts to log. Addresses in AddressBook other that are\n     * not in this AddressBook are added to this AddressBook. In case of a\n     * conflict, addresses in this AddressBook take precedence\n     * \n     * @param other\n     *            An AddressBook to merge with.\n     * @param overwrite True to overwrite\n     * @param log\n     *            The log to write messages about new addresses or conflicts to.\n     */\n    public void merge(AddressBook other, boolean overwrite, Log log) {\n        Iterator otherIter = other.addresses.keySet().iterator();\n\n        while (otherIter.hasNext()) {\n            String otherKey = (String) otherIter.next();\n            String otherValue = (String) other.addresses.get(otherKey);\n\n            if (valid(otherKey, otherValue)) {\n                if (this.addresses.containsKey(otherKey) && !overwrite) {\n                    if (!this.addresses.get(otherKey).equals(otherValue)\n                            && log != null) {\n                        log.append(\"Conflict for \" + otherKey + \" from \"\n                                + other.location\n                                + \". Destination in remote address book is \"\n                                + otherValue);\n                    }\n                } else if (!this.addresses.containsKey(otherKey)\n                            || !this.addresses.get(otherKey).equals(otherValue)) {\n                    this.addresses.put(otherKey, otherValue);\n                    this.modified = true;\n                    if (log != null) {\n                        log.append(\"New address \" + otherKey\n                            + \" added to address book. From: \" + other.location);\n                    }\n                }\n            }\n        }\n    }","id":92916,"modified_method":"/**\n     * Merge this AddressBook with AddressBook other, writing messages about new\n     * addresses or conflicts to log. Addresses in AddressBook other that are\n     * not in this AddressBook are added to this AddressBook. In case of a\n     * conflict, addresses in this AddressBook take precedence\n     * \n     * @param other\n     *            An AddressBook to merge with.\n     * @param overwrite True to overwrite\n     * @param log\n     *            The log to write messages about new addresses or conflicts to.\n     */\n    public void merge(AddressBook other, boolean overwrite, Log log) {\n        for (Map.Entry<String, String> entry : other.addresses.entrySet()) {\n            String otherKey = entry.getKey();\n            String otherValue = entry.getValue();\n\n            if (valid(otherKey, otherValue)) {\n                if (this.addresses.containsKey(otherKey) && !overwrite) {\n                    if (!this.addresses.get(otherKey).equals(otherValue)\n                            && log != null) {\n                        log.append(\"Conflict for \" + otherKey + \" from \"\n                                + other.location\n                                + \". Destination in remote address book is \"\n                                + otherValue);\n                    }\n                } else if (!this.addresses.containsKey(otherKey)\n                            || !this.addresses.get(otherKey).equals(otherValue)) {\n                    this.addresses.put(otherKey, otherValue);\n                    this.modified = true;\n                    if (log != null) {\n                        log.append(\"New address \" + otherKey\n                            + \" added to address book. From: \" + other.location);\n                    }\n                }\n            }\n        }\n    }","commit_id":"f4e92572ebc540421731478ff12c63d42f7d9e4c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Update the router and published address books using remote data from the\n     * subscribed address books listed in subscriptions.\n     * \n     * @param master\n     *            The master AddressBook. This address book is never\n     *            overwritten, so it is safe for the user to write to.\n     * @param router\n     *            The router AddressBook. This is the address book read by\n     *            client applications.\n     * @param published\n     *            The published AddressBook. This address book is published on\n     *            the user's eepsite so that others may subscribe to it.\n     * @param subscriptions\n     *            A SubscriptionList listing the remote address books to update\n     *            from.\n     * @param log\n     *            The log to write changes and conflicts to.\n     */\n    public void update(AddressBook master, AddressBook router,\n            File published, SubscriptionList subscriptions, Log log) {\n        router.merge(master, true, null);\n        Iterator iter = subscriptions.iterator();\n        while (iter.hasNext()) {\n            // yes, the EepGet fetch() is done in next()\n            router.merge((AddressBook) iter.next(), false, log);\n        }\n        router.write();\n        if (published != null)\n            router.write(published);\n        subscriptions.write();\n    }","id":92917,"modified_method":"/**\n     * Update the router and published address books using remote data from the\n     * subscribed address books listed in subscriptions.\n     * \n     * @param master\n     *            The master AddressBook. This address book is never\n     *            overwritten, so it is safe for the user to write to.\n     * @param router\n     *            The router AddressBook. This is the address book read by\n     *            client applications.\n     * @param published\n     *            The published AddressBook. This address book is published on\n     *            the user's eepsite so that others may subscribe to it.\n     * @param subscriptions\n     *            A SubscriptionList listing the remote address books to update\n     *            from.\n     * @param log\n     *            The log to write changes and conflicts to.\n     */\n    public void update(AddressBook master, AddressBook router,\n            File published, SubscriptionList subscriptions, Log log) {\n        router.merge(master, true, null);\n        Iterator<AddressBook> iter = subscriptions.iterator();\n        while (iter.hasNext()) {\n            // yes, the EepGet fetch() is done in next()\n            router.merge(iter.next(), false, log);\n        }\n        router.write();\n        if (published != null)\n            router.write(published);\n        subscriptions.write();\n    }","commit_id":"f4e92572ebc540421731478ff12c63d42f7d9e4c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n        public Integer getHash() {\n            if (hash == null) {\n                hash = calculatePreCheckHash(fileTreeElements);\n            }\n            return hash;\n        }","id":92918,"modified_method":"@Override\n        public Integer getHash() {\n            if (hash == null) {\n                hash = calculatePreCheckHash(visitedTrees);\n            }\n            return hash;\n        }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public FileCollectionSnapshot snapshot(final FileCollectionSnapshot.PreCheck preCheck) {\n        if (preCheck.getFileTreeElements().isEmpty() && preCheck.getMissingFiles().isEmpty()) {\n            return emptySnapshot();\n        }\n\n        final Map<String, IncrementalFileSnapshot> snapshots = new HashMap<String, IncrementalFileSnapshot>();\n\n        cacheAccess.useCache(\"Create file snapshot\", new Runnable() {\n            public void run() {\n                for (FileTreeElement fileDetails : preCheck.getFileTreeElements()) {\n                    String absolutePath = getInternedAbsolutePath(fileDetails.getFile());\n                    if (!snapshots.containsKey(absolutePath)) {\n                        if (fileDetails.isDirectory()) {\n                            snapshots.put(absolutePath, DirSnapshot.getInstance());\n                        } else {\n                            snapshots.put(absolutePath, new FileHashSnapshot(snapshotter.snapshot(fileDetails).getHash(), fileDetails.getLastModified()));\n                        }\n                    }\n                }\n                for (File missingFile : preCheck.getMissingFiles()) {\n                    String absolutePath = getInternedAbsolutePath(missingFile);\n                    if (!snapshots.containsKey(absolutePath)) {\n                        snapshots.put(absolutePath, MissingFileSnapshot.getInstance());\n                    }\n                }\n            }\n        });\n\n        return new FileCollectionSnapshotImpl(snapshots);\n    }","id":92919,"modified_method":"public FileCollectionSnapshot snapshot(final FileCollectionSnapshot.PreCheck preCheck) {\n        if (preCheck.isEmpty()) {\n            return emptySnapshot();\n        }\n\n        final List<TreeSnapshot> treeSnapshots = new ArrayList<TreeSnapshot>();\n        cacheAccess.useCache(\"Create file snapshot\", new Runnable() {\n            public void run() {\n                final List<VisitedTree> nonShareableTrees = new ArrayList<VisitedTree>();\n                for (VisitedTree tree : preCheck.getVisitedTrees()) {\n                    if (tree.isShareable()) {\n                        treeSnapshots.add(tree.maybeCreateSnapshot(snapshotter, stringInterner));\n                    } else {\n                        nonShareableTrees.add(tree);\n                    }\n                }\n                if (!nonShareableTrees.isEmpty() || !preCheck.getMissingFiles().isEmpty()) {\n                    VisitedTree nonShareableTree = createJoinedTree(nonShareableTrees, preCheck.getMissingFiles());\n                    treeSnapshots.add(nonShareableTree.maybeCreateSnapshot(snapshotter, stringInterner));\n                }\n            }\n        });\n        return new FileCollectionSnapshotImpl(treeSnapshots);\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"abstract protected void visitFiles(FileCollection input, List<FileTreeElement> fileTreeElements, List<File> missingFiles, boolean allowReuse);","id":92920,"modified_method":"abstract protected void visitFiles(FileCollection input, List<VisitedTree> visitedTrees, List<File> missingFiles, boolean allowReuse);","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public FileCollectionSnapshot.PreCheck preCheck(final FileCollection files, final boolean allowReuse) {\n        return new DefaultFileCollectionSnapshotPreCheck(files, allowReuse);\n    }","id":92921,"modified_method":"private Integer calculatePreCheckHash(Collection<VisitedTree> visitedTrees) {\n        Collection<FileTreeElement> fileTreeElements = new ArrayList<FileTreeElement>();\n        for (VisitedTree tree : visitedTrees) {\n            fileTreeElements.addAll(tree.getEntries());\n        }\n        return FileTreeElementHasher.calculateHashForFileMetadata(fileTreeElements);\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultFileCollectionSnapshotPreCheck(FileCollection files, boolean allowReuse) {\n            this.files = files;\n            fileTreeElements = Lists.newLinkedList();\n            missingFiles = Lists.newArrayList();\n            visitFiles(files, fileTreeElements, missingFiles, allowReuse);\n        }","id":92922,"modified_method":"public DefaultFileCollectionSnapshotPreCheck(FileCollection files, boolean allowReuse) {\n            this.files = files;\n            visitedTrees = Lists.newLinkedList();\n            missingFiles = Lists.newArrayList();\n            visitFiles(files, visitedTrees, missingFiles, allowReuse);\n        }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public void remove(Long id) {\n        cache.remove(id);\n    }","id":92923,"modified_method":"public void remove(Long id) {\n        cache.remove(id);\n        treeSnapshotRepository.removeTreeSnapshotUsage(id);\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public CacheBackedFileSnapshotRepository(TaskArtifactStateCacheAccess cacheAccess, Serializer<FileCollectionSnapshot> serializer, IdGenerator<Long> idGenerator) {\n        this.idGenerator = idGenerator;\n        cache = cacheAccess.createCache(\"fileSnapshots\", Long.class, serializer);\n    }","id":92924,"modified_method":"public CacheBackedFileSnapshotRepository(TaskArtifactStateCacheAccess cacheAccess, Serializer<FileCollectionSnapshot> serializer, IdGenerator<Long> idGenerator, TreeSnapshotRepository treeSnapshotRepository) {\n        this.idGenerator = idGenerator;\n        this.treeSnapshotRepository = treeSnapshotRepository;\n        cache = cacheAccess.createCache(\"fileSnapshots\", Long.class, serializer);\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public Long add(FileCollectionSnapshot snapshot) {\n        Long id = idGenerator.generateId();\n        cache.put(id, snapshot);\n        return id;\n    }","id":92925,"modified_method":"public Long add(FileCollectionSnapshot snapshot) {\n        Long id = idGenerator.generateId();\n        cache.put(id, snapshot);\n        treeSnapshotRepository.addTreeSnapshotUsage(snapshot, id);\n        return id;\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public void clearCache() {\n        cachedTrees.clear();\n    }","id":92926,"modified_method":"public void clearCache() {\n        cachedTrees.invalidateAll();\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"private Collection<FileTreeElement> doVisitTree(FileTreeInternal fileTree) {\n        final ImmutableList.Builder<FileTreeElement> fileTreeElements = ImmutableList.builder();\n        fileTree.visitTreeOrBackingFile(new FileVisitor() {\n            @Override\n            public void visitDir(FileVisitDetails dirDetails) {\n                fileTreeElements.add(dirDetails);\n            }\n\n            @Override\n            public void visitFile(FileVisitDetails fileDetails) {\n                fileTreeElements.add(fileDetails);\n            }\n        });\n        return fileTreeElements.build();\n    }","id":92927,"modified_method":"private VisitedTree doVisitTree(FileTreeInternal fileTree, boolean shareable) {\n        final ImmutableList.Builder<FileTreeElement> fileTreeElements = ImmutableList.builder();\n        fileTree.visitTreeOrBackingFile(new FileVisitor() {\n            @Override\n            public void visitDir(FileVisitDetails dirDetails) {\n                fileTreeElements.add(dirDetails);\n            }\n\n            @Override\n            public void visitFile(FileVisitDetails fileDetails) {\n                fileTreeElements.add(fileDetails);\n            }\n        });\n        return new DefaultVisitedTree(fileTreeElements.build(), shareable, nextId.incrementAndGet(), null);\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public Collection<FileTreeElement> visitTreeForSnapshotting(FileTreeInternal fileTree, boolean allowReuse) {\n        if (isDirectoryFileTree(fileTree)) {\n            DirectoryFileTree directoryFileTree = DirectoryFileTree.class.cast(((FileTreeAdapter) fileTree).getTree());\n            if (isEligibleForCaching(directoryFileTree)) {\n                final String absolutePath = directoryFileTree.getDir().getAbsolutePath();\n                Collection<FileTreeElement> cachedTree = allowReuse ? cachedTrees.get(absolutePath) : null;\n                if (cachedTree != null) {\n                    recordCacheHit(directoryFileTree);\n                    return cachedTree;\n                } else {\n                    recordCacheMiss(directoryFileTree, allowReuse);\n                    cachedTree = doVisitTree(fileTree);\n                    cachedTrees.put(absolutePath, cachedTree);\n                    return cachedTree;\n                }\n            }\n        }\n        return doVisitTree(fileTree);\n    }","id":92928,"modified_method":"public VisitedTree visitTreeForSnapshotting(FileTreeInternal fileTree, boolean allowReuse) {\n        if (isDirectoryFileTree(fileTree)) {\n            DirectoryFileTree directoryFileTree = DirectoryFileTree.class.cast(((FileTreeAdapter) fileTree).getTree());\n            if (isEligibleForCaching(directoryFileTree)) {\n                final String absolutePath = directoryFileTree.getDir().getAbsolutePath();\n                VisitedTree cachedTree = allowReuse ? cachedTrees.getIfPresent(absolutePath) : null;\n                if (cachedTree != null) {\n                    recordCacheHit(directoryFileTree);\n                    return cachedTree;\n                } else {\n                    recordCacheMiss(directoryFileTree, allowReuse);\n                    cachedTree = doVisitTree(fileTree, true);\n                    cachedTrees.put(absolutePath, cachedTree);\n                    return cachedTree;\n                }\n            }\n        }\n        return doVisitTree(fileTree, false);\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultFileCollectionSnapshotter(FileSnapshotter snapshotter, TaskArtifactStateCacheAccess cacheAccess, StringInterner stringInterner, FileResolver fileResolver, CachingTreeVisitor treeVisitor) {\n        super(snapshotter, cacheAccess, stringInterner, fileResolver);\n        this.treeVisitor = treeVisitor;\n    }","id":92929,"modified_method":"public DefaultFileCollectionSnapshotter(FileSnapshotter snapshotter, TaskArtifactStateCacheAccess cacheAccess, StringInterner stringInterner, FileResolver fileResolver, CachingTreeVisitor treeVisitor, TreeSnapshotRepository treeSnapshotRepository) {\n        super(snapshotter, cacheAccess, stringInterner, fileResolver);\n        this.treeVisitor = treeVisitor;\n        this.treeSnapshotRepository = treeSnapshotRepository;\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected void visitFiles(FileCollection input, final List<FileTreeElement> fileTreeElements, final List<File> missingFiles, boolean allowReuse) {\n        DefaultFileCollectionResolveContext context = new DefaultFileCollectionResolveContext(fileResolver);\n        context.add(input);\n        List<FileTreeInternal> fileTrees = context.resolveAsFileTrees();\n\n        for (FileTreeInternal fileTree : fileTrees) {\n            fileTreeElements.addAll(treeVisitor.visitTreeForSnapshotting(fileTree, allowReuse));\n        }\n    }","id":92930,"modified_method":"@Override\n    protected void visitFiles(FileCollection input, final List<VisitedTree> visitedTrees, final List<File> missingFiles, boolean allowReuse) {\n        DefaultFileCollectionResolveContext context = new DefaultFileCollectionResolveContext(fileResolver);\n        context.add(input);\n        List<FileTreeInternal> fileTrees = context.resolveAsFileTrees();\n\n        for (FileTreeInternal fileTree : fileTrees) {\n            visitedTrees.add(treeVisitor.visitTreeForSnapshotting(fileTree, allowReuse));\n        }\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public void write(Encoder encoder, FileCollectionSnapshotImpl value) throws Exception {\n        encoder.writeSmallInt(value.snapshots.size());\n        for (String key : value.snapshots.keySet()) {\n            encoder.writeString(key);\n            IncrementalFileSnapshot incrementalFileSnapshot = value.snapshots.get(key);\n            if (incrementalFileSnapshot instanceof DirSnapshot) {\n                encoder.writeByte((byte) 1);\n            } else if (incrementalFileSnapshot instanceof MissingFileSnapshot) {\n                encoder.writeByte((byte) 2);\n            } else if (incrementalFileSnapshot instanceof FileHashSnapshot) {\n                encoder.writeByte((byte) 3);\n                hashValueSerializer.write(encoder, ((FileHashSnapshot) incrementalFileSnapshot).hash);\n            }\n        }\n    }","id":92931,"modified_method":"public void write(Encoder encoder, FileCollectionSnapshotImpl value) throws Exception {\n        final List<TreeSnapshot> treeSnapshots = value.treeSnapshots;\n        if (treeSnapshots != null) {\n            TreeSnapshot nonShared = null;\n            for (TreeSnapshot snapshot : treeSnapshots) {\n                if (!snapshot.isShareable()) {\n                    if (nonShared != null) {\n                        throw new RuntimeException(\"Multiple non-shared snapshots aren't supported.\");\n                    }\n                    nonShared = snapshot;\n                }\n            }\n            encoder.writeSmallInt(treeSnapshots.size() - ((nonShared != null) ? 1 : 0));\n            for (TreeSnapshot snapshot : treeSnapshots) {\n                if (snapshot.isShareable()) {\n                    encoder.writeLong(treeSnapshotRepository.maybeStoreTreeSnapshot(snapshot));\n                }\n            }\n            if (nonShared != null) {\n                TreeSnapshotSerializer.writeTreeSnapshot(nonShared, encoder, incrementalFileSnapshotSerializer);\n            } else {\n                encoder.writeSmallInt(0);\n            }\n        } else {\n            encoder.writeSmallInt(0);\n            encoder.writeSmallInt(value.snapshots.size());\n            for (Map.Entry<String, IncrementalFileSnapshot> entry : value.snapshots.entrySet()) {\n                encoder.writeString(entry.getKey());\n                incrementalFileSnapshotSerializer.write(encoder, entry.getValue());\n            }\n        }\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public FileCollectionSnapshotImpl read(Decoder decoder) throws Exception {\n        Map<String, IncrementalFileSnapshot> snapshots = new HashMap<String, IncrementalFileSnapshot>();\n        FileCollectionSnapshotImpl snapshot = new FileCollectionSnapshotImpl(snapshots);\n        int snapshotsCount = decoder.readSmallInt();\n        for (int i = 0; i < snapshotsCount; i++) {\n            String key = stringInterner.intern(decoder.readString());\n            byte fileSnapshotKind = decoder.readByte();\n            if (fileSnapshotKind == 1) {\n                snapshots.put(key, DirSnapshot.getInstance());\n            } else if (fileSnapshotKind == 2) {\n                snapshots.put(key, MissingFileSnapshot.getInstance());\n            } else if (fileSnapshotKind == 3) {\n                snapshots.put(key, new FileHashSnapshot(hashValueSerializer.read(decoder)));\n            } else {\n                throw new RuntimeException(\"Unable to read serialized file collection snapshot. Unrecognized value found in the data stream.\");\n            }\n        }\n        return snapshot;\n    }","id":92932,"modified_method":"public FileCollectionSnapshotImpl read(Decoder decoder) throws Exception {\n        List<TreeSnapshot> treeSnapshots = new ArrayList<TreeSnapshot>();\n        int sharedTreeCount = decoder.readSmallInt();\n        for (int i = 0; i < sharedTreeCount; i++) {\n            long treeId = decoder.readLong();\n            treeSnapshots.add(treeSnapshotRepository.getTreeSnapshot(treeId));\n        }\n        TreeSnapshot nonShared = TreeSnapshotSerializer.readStoredTreeSnapshot(-1, decoder, incrementalFileSnapshotSerializer, stringInterner);\n        if (!nonShared.getFileSnapshots().isEmpty()) {\n            treeSnapshots.add(nonShared);\n        }\n        return new FileCollectionSnapshotImpl(treeSnapshots);\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultFileSnapshotterSerializer(StringInterner stringInterner) {\n        this.stringInterner = stringInterner;\n    }","id":92933,"modified_method":"public DefaultFileSnapshotterSerializer(StringInterner stringInterner, TreeSnapshotRepository treeSnapshotRepository) {\n        this.stringInterner = stringInterner;\n        this.treeSnapshotRepository = treeSnapshotRepository;\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultTaskArtifactStateRepository(TaskHistoryRepository taskHistoryRepository, Instantiator instantiator,\n                                              FileCollectionSnapshotter outputFilesSnapshotter, FileCollectionSnapshotter inputFilesSnapshotter,\n                                              FileCollectionSnapshotter discoveredInputsSnapshotter, FileCollectionFactory fileCollectionFactory) {\n        this.taskHistoryRepository = taskHistoryRepository;\n        this.instantiator = instantiator;\n        this.outputFilesSnapshotter = outputFilesSnapshotter;\n        this.inputFilesSnapshotter = inputFilesSnapshotter;\n        this.discoveredInputsSnapshotter = discoveredInputsSnapshotter;\n        this.fileCollectionFactory = fileCollectionFactory;\n    }","id":92934,"modified_method":"public DefaultTaskArtifactStateRepository(TaskHistoryRepository taskHistoryRepository, Instantiator instantiator,\n                                              OutputFilesCollectionSnapshotter outputFilesSnapshotter, FileCollectionSnapshotter inputFilesSnapshotter,\n                                              FileCollectionSnapshotter discoveredInputsSnapshotter, FileCollectionFactory fileCollectionFactory) {\n        this.taskHistoryRepository = taskHistoryRepository;\n        this.instantiator = instantiator;\n        this.outputFilesSnapshotter = outputFilesSnapshotter;\n        this.inputFilesSnapshotter = inputFilesSnapshotter;\n        this.discoveredInputsSnapshotter = discoveredInputsSnapshotter;\n        this.fileCollectionFactory = fileCollectionFactory;\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public ChangeIterator<String> iterateContentChangesSince(FileCollectionSnapshot oldSnapshot, final Set<ChangeFilter> filters) {\n        FileCollectionSnapshotImpl oldSnapshotImpl = (FileCollectionSnapshotImpl) oldSnapshot;\n        final Map<String, IncrementalFileSnapshot> otherSnapshots = new HashMap<String, IncrementalFileSnapshot>(oldSnapshotImpl.snapshots);\n        final Iterator<String> currentFiles = snapshots.keySet().iterator();\n        final boolean includeAdded = !filters.contains(ChangeFilter.IgnoreAddedFiles);\n\n        return new ChangeIterator<String>() {\n            private Iterator<String> removedFiles;\n\n            public boolean next(ChangeListener<String> listener) {\n                while (currentFiles.hasNext()) {\n                    String currentFile = currentFiles.next();\n                    IncrementalFileSnapshot otherFile = otherSnapshots.remove(currentFile);\n                    if (otherFile == null) {\n                        if (includeAdded) {\n                            listener.added(currentFile);\n                            return true;\n                        }\n                    } else if (!snapshots.get(currentFile).isContentUpToDate(otherFile)) {\n                        listener.changed(currentFile);\n                        return true;\n                    }\n                }\n\n                // Create a single iterator to use for all of the removed files\n                if (removedFiles == null) {\n                    removedFiles = otherSnapshots.keySet().iterator();\n                }\n\n                if (removedFiles.hasNext()) {\n                    listener.removed(removedFiles.next());\n                    return true;\n                }\n\n                return false;\n            }\n        };\n    }","id":92935,"modified_method":"@Override\n    public ChangeIterator<String> iterateContentChangesSince(FileCollectionSnapshot oldSnapshot, final Set<ChangeFilter> filters) {\n        final Map<String, IncrementalFileSnapshot> otherSnapshots = new HashMap<String, IncrementalFileSnapshot>(oldSnapshot.getSnapshots());\n        final Iterator<String> currentFiles = snapshots.keySet().iterator();\n        final boolean includeAdded = !filters.contains(ChangeFilter.IgnoreAddedFiles);\n\n        return new ChangeIterator<String>() {\n            private Iterator<String> removedFiles;\n\n            public boolean next(ChangeListener<String> listener) {\n                while (currentFiles.hasNext()) {\n                    String currentFile = currentFiles.next();\n                    IncrementalFileSnapshot otherFile = otherSnapshots.remove(currentFile);\n                    if (otherFile == null) {\n                        if (includeAdded) {\n                            listener.added(currentFile);\n                            return true;\n                        }\n                    } else if (!snapshots.get(currentFile).isContentUpToDate(otherFile)) {\n                        listener.changed(currentFile);\n                        return true;\n                    }\n                }\n\n                // Create a single iterator to use for all of the removed files\n                if (removedFiles == null) {\n                    removedFiles = otherSnapshots.keySet().iterator();\n                }\n\n                if (removedFiles.hasNext()) {\n                    listener.removed(removedFiles.next());\n                    return true;\n                }\n\n                return false;\n            }\n        };\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public FileCollectionSnapshotImpl(Map<String, IncrementalFileSnapshot> snapshots) {\n        this.snapshots = snapshots;\n    }","id":92936,"modified_method":"public FileCollectionSnapshotImpl(Map<String, IncrementalFileSnapshot> snapshots) {\n        this.snapshots = snapshots;\n        this.treeSnapshots = null;\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"private int scaleCacheSize(int referenceValue, int granularity) {\n        if (referenceValue < granularity) {\n            throw new IllegalArgumentException(\"reference value must be larger than granularity\");\n        }\n        return (int) ((double) referenceValue * sizingRatio) / granularity * granularity;\n    }","id":92937,"modified_method":"public int scaleCacheSize(int referenceValue, int granularity) {\n        if (referenceValue < granularity) {\n            throw new IllegalArgumentException(\"reference value must be larger than granularity\");\n        }\n        return (int) ((double) referenceValue * sizingRatio) / granularity * granularity;\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected void visitFiles(FileCollection input, final List<FileTreeElement> fileTreeElements, final List<File> missingFiles, boolean allowReuse) {\n        for (File file : input.getFiles()) {\n            if (file.exists()) {\n                fileTreeElements.add(new DefaultFileVisitDetails(file, fileSystem, fileSystem));\n            } else {\n                missingFiles.add(file);\n            }\n        }\n    }","id":92938,"modified_method":"@Override\n    protected void visitFiles(FileCollection input, List<VisitedTree> visitedTrees, List<File> missingFiles, boolean allowReuse) {\n        final List<FileTreeElement> fileTreeElements = new ArrayList<FileTreeElement>();\n        for (File file : input.getFiles()) {\n            if (file.exists()) {\n                fileTreeElements.add(new DefaultFileVisitDetails(file, fileSystem, fileSystem));\n            } else {\n                missingFiles.add(file);\n            }\n        }\n        visitedTrees.add(new DefaultVisitedTree(ImmutableList.<FileTreeElement>copyOf(fileTreeElements), false, -1, null));\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public OutputFilesSnapshot snapshot(FileCollectionSnapshot.PreCheck preCheck) {\n        return new OutputFilesSnapshot(((OutputFilesSnapshotPreCheck) preCheck).getRoots(), snapshotter.snapshot(preCheck));\n    }","id":92939,"modified_method":"@Override\n    public FileCollectionSnapshot snapshot(FileCollectionSnapshot.PreCheck preCheck) {\n        return new OutputFilesSnapshot(getRoots(preCheck.getFiles()), snapshotter.snapshot(preCheck));\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public FileCollectionSnapshot.PreCheck preCheck(FileCollection files, boolean allowReuse) {\n        Set<String> roots = new LinkedHashSet<String>();\n        for (File file : files.getFiles()) {\n            roots.add(stringInterner.intern(file.getAbsolutePath()));\n        }\n        return new OutputFilesSnapshotPreCheck(snapshotter.preCheck(files, allowReuse), roots);\n    }","id":92940,"modified_method":"@Override\n    public FileCollectionSnapshot.PreCheck preCheck(FileCollection files, boolean allowReuse) {\n        return snapshotter.preCheck(files, allowReuse);\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void saveCurrent() {\n        FileCollectionSnapshot lastExecutionOutputFiles;\n        if (previousExecution == null || previousExecution.getOutputFilesSnapshot() == null) {\n            lastExecutionOutputFiles = outputFilesSnapshotter.emptySnapshot();\n        } else {\n            lastExecutionOutputFiles = previousExecution.getOutputFilesSnapshot();\n        }\n        FileCollectionSnapshot newOutputFiles = lastExecutionOutputFiles.updateFrom(outputFilesBefore);\n        FileCollectionSnapshot.PreCheck outputFilesAfterPreCheck = createSnapshotPreCheck(outputFilesSnapshotter, task.getOutputs().getFiles());\n        FileCollectionSnapshot outputFilesAfter = createSnapshot(outputFilesSnapshotter, outputFilesAfterPreCheck);\n        currentExecution.setOutputFilesSnapshot(outputFilesAfter.applyAllChangesSince(outputFilesBefore, newOutputFiles));\n        currentExecution.setOutputFilesHash(outputFilesAfterPreCheck.getHash());\n    }","id":92941,"modified_method":"@Override\n    public void saveCurrent() {\n        FileCollectionSnapshot lastExecutionOutputFiles;\n        if (previousExecution == null || previousExecution.getOutputFilesSnapshot() == null) {\n            lastExecutionOutputFiles = outputFilesSnapshotter.emptySnapshot();\n        } else {\n            lastExecutionOutputFiles = previousExecution.getOutputFilesSnapshot();\n        }\n\n        FileCollectionSnapshot.PreCheck outputFilesAfterPreCheck = createSnapshotPreCheck(outputFilesSnapshotter, task.getOutputs().getFiles());\n        FileCollectionSnapshot outputFilesAfter = createSnapshot(outputFilesSnapshotter, outputFilesAfterPreCheck);\n        currentExecution.setOutputFilesSnapshot(outputFilesSnapshotter.createOutputSnapshot(lastExecutionOutputFiles, outputFilesBefore, outputFilesAfter, task.getOutputs().getFiles()));\n        currentExecution.setOutputFilesHash(outputFilesAfterPreCheck.getHash());\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public OutputFilesTaskStateChanges(TaskExecution previousExecution, TaskExecution currentExecution, TaskInternal task, FileCollectionSnapshotter outputFilesSnapshotter) {\n        super(task.getName());\n        this.previousExecution = previousExecution;\n        this.currentExecution = currentExecution;\n        this.task = task;\n        this.outputFilesSnapshotter = outputFilesSnapshotter;\n        outputFilesBeforePreCheck = createSnapshotPreCheck(outputFilesSnapshotter, task.getOutputs().getFiles());\n        this.noChanges = previousExecution != null && previousExecution.getOutputFilesHash() != null && previousExecution.getOutputFilesHash().equals(outputFilesBeforePreCheck.getHash());\n    }","id":92942,"modified_method":"public OutputFilesTaskStateChanges(TaskExecution previousExecution, TaskExecution currentExecution, TaskInternal task, OutputFilesCollectionSnapshotter outputFilesSnapshotter) {\n        super(task.getName());\n        this.previousExecution = previousExecution;\n        this.currentExecution = currentExecution;\n        this.task = task;\n        this.outputFilesSnapshotter = outputFilesSnapshotter;\n        outputFilesBeforePreCheck = createSnapshotPreCheck(outputFilesSnapshotter, task.getOutputs().getFiles());\n        this.noChanges = previousExecution != null && previousExecution.getOutputFilesHash() != null && previousExecution.getOutputFilesHash().equals(outputFilesBeforePreCheck.getHash());\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"TaskArtifactStateRepository createTaskArtifactStateRepository(Instantiator instantiator, TaskArtifactStateCacheAccess cacheAccess, StartParameter startParameter, FileSnapshotter fileSnapshotter,\n                                                                  StringInterner stringInterner, FileResolver fileResolver, FileSystem fileSystem, FileCollectionFactory fileCollectionFactory, CachingTreeVisitor treeVisitor) {\n        FileCollectionSnapshotter fileCollectionSnapshotter = new DefaultFileCollectionSnapshotter(fileSnapshotter, cacheAccess, stringInterner, fileResolver, treeVisitor);\n        FileCollectionSnapshotter discoveredFileCollectionSnapshotter = new MinimalFileSetSnapshotter(fileSnapshotter, cacheAccess, stringInterner, fileResolver, fileSystem);\n\n        FileCollectionSnapshotter outputFilesSnapshotter = new OutputFilesCollectionSnapshotter(fileCollectionSnapshotter, stringInterner);\n\n        SerializerRegistry serializerRegistry = new DefaultSerializerRegistry();\n        fileCollectionSnapshotter.registerSerializers(serializerRegistry);\n        outputFilesSnapshotter.registerSerializers(serializerRegistry);\n        discoveredFileCollectionSnapshotter.registerSerializers(serializerRegistry);\n\n        TaskHistoryRepository taskHistoryRepository = new CacheBackedTaskHistoryRepository(cacheAccess,\n            new CacheBackedFileSnapshotRepository(cacheAccess,\n                serializerRegistry.build(FileCollectionSnapshot.class),\n                new RandomLongIdGenerator()),\n            stringInterner);\n\n        return new ShortCircuitTaskArtifactStateRepository(\n            startParameter,\n            instantiator,\n            new DefaultTaskArtifactStateRepository(\n                taskHistoryRepository,\n                instantiator,\n                outputFilesSnapshotter,\n                fileCollectionSnapshotter,\n                discoveredFileCollectionSnapshotter,\n                fileCollectionFactory\n            )\n        );\n    }","id":92943,"modified_method":"TaskArtifactStateRepository createTaskArtifactStateRepository(Instantiator instantiator, TaskArtifactStateCacheAccess cacheAccess, StartParameter startParameter, FileSnapshotter fileSnapshotter,\n                                                                  StringInterner stringInterner, FileResolver fileResolver, FileSystem fileSystem, FileCollectionFactory fileCollectionFactory, CachingTreeVisitor treeVisitor, TreeSnapshotRepository treeSnapshotRepository) {\n        FileCollectionSnapshotter fileCollectionSnapshotter = new DefaultFileCollectionSnapshotter(fileSnapshotter, cacheAccess, stringInterner, fileResolver, treeVisitor, treeSnapshotRepository);\n        FileCollectionSnapshotter discoveredFileCollectionSnapshotter = new MinimalFileSetSnapshotter(fileSnapshotter, cacheAccess, stringInterner, fileResolver, fileSystem);\n\n        OutputFilesCollectionSnapshotter outputFilesSnapshotter = new OutputFilesCollectionSnapshotter(fileCollectionSnapshotter, stringInterner);\n\n        SerializerRegistry serializerRegistry = new DefaultSerializerRegistry();\n        fileCollectionSnapshotter.registerSerializers(serializerRegistry);\n        outputFilesSnapshotter.registerSerializers(serializerRegistry);\n        discoveredFileCollectionSnapshotter.registerSerializers(serializerRegistry);\n\n        TaskHistoryRepository taskHistoryRepository = new CacheBackedTaskHistoryRepository(cacheAccess,\n            new CacheBackedFileSnapshotRepository(cacheAccess,\n                serializerRegistry.build(FileCollectionSnapshot.class),\n                new RandomLongIdGenerator(),\n                treeSnapshotRepository),\n            stringInterner);\n\n        return new ShortCircuitTaskArtifactStateRepository(\n            startParameter,\n            instantiator,\n            new DefaultTaskArtifactStateRepository(\n                taskHistoryRepository,\n                instantiator,\n                outputFilesSnapshotter,\n                fileCollectionSnapshotter,\n                discoveredFileCollectionSnapshotter,\n                fileCollectionFactory\n            )\n        );\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public TaskUpToDateState(TaskInternal task, TaskHistoryRepository.History history,\n                             FileCollectionSnapshotter outputFilesSnapshotter, FileCollectionSnapshotter inputFilesSnapshotter,\n                             FileCollectionSnapshotter discoveredInputsSnapshotter, FileCollectionFactory fileCollectionFactory) {\n        TaskExecution thisExecution = history.getCurrentExecution();\n        TaskExecution lastExecution = history.getPreviousExecution();\n\n        TaskStateChanges noHistoryState = new NoHistoryTaskStateChanges(lastExecution);\n        TaskStateChanges taskTypeState = new TaskTypeTaskStateChanges(lastExecution, thisExecution, task);\n        TaskStateChanges inputPropertiesState = new InputPropertiesTaskStateChanges(lastExecution, thisExecution, task);\n\n        // Capture outputs state\n        TaskStateChanges outputFileChanges = caching(new OutputFilesTaskStateChanges(lastExecution, thisExecution, task, outputFilesSnapshotter));\n\n        // Capture inputs state\n        this.directInputFileChanges = new InputFilesTaskStateChanges(lastExecution, thisExecution, task, inputFilesSnapshotter);\n        this.inputFileChanges = caching(directInputFileChanges);\n\n        // Capture discovered inputs state from previous execution\n        DiscoveredInputsTaskStateChanges discoveredChanges = new DiscoveredInputsTaskStateChanges(lastExecution, thisExecution, discoveredInputsSnapshotter, fileCollectionFactory, task);\n        this.discoveredInputsListener = discoveredChanges;\n        TaskStateChanges discoveredInputFilesChanges = caching(discoveredChanges);\n\n        allTaskChanges = new SummaryTaskStateChanges(MAX_OUT_OF_DATE_MESSAGES, noHistoryState, taskTypeState, inputPropertiesState, outputFileChanges, inputFileChanges, discoveredInputFilesChanges);\n        rebuildChanges = new SummaryTaskStateChanges(1, noHistoryState, taskTypeState, inputPropertiesState, outputFileChanges);\n    }","id":92944,"modified_method":"public TaskUpToDateState(TaskInternal task, TaskHistoryRepository.History history,\n                             OutputFilesCollectionSnapshotter outputFilesSnapshotter, FileCollectionSnapshotter inputFilesSnapshotter,\n                             FileCollectionSnapshotter discoveredInputsSnapshotter, FileCollectionFactory fileCollectionFactory) {\n        TaskExecution thisExecution = history.getCurrentExecution();\n        TaskExecution lastExecution = history.getPreviousExecution();\n\n        TaskStateChanges noHistoryState = new NoHistoryTaskStateChanges(lastExecution);\n        TaskStateChanges taskTypeState = new TaskTypeTaskStateChanges(lastExecution, thisExecution, task);\n        TaskStateChanges inputPropertiesState = new InputPropertiesTaskStateChanges(lastExecution, thisExecution, task);\n\n        // Capture outputs state\n        TaskStateChanges outputFileChanges = caching(new OutputFilesTaskStateChanges(lastExecution, thisExecution, task, outputFilesSnapshotter));\n\n        // Capture inputs state\n        this.directInputFileChanges = new InputFilesTaskStateChanges(lastExecution, thisExecution, task, inputFilesSnapshotter);\n        this.inputFileChanges = caching(directInputFileChanges);\n\n        // Capture discovered inputs state from previous execution\n        DiscoveredInputsTaskStateChanges discoveredChanges = new DiscoveredInputsTaskStateChanges(lastExecution, thisExecution, discoveredInputsSnapshotter, fileCollectionFactory, task);\n        this.discoveredInputsListener = discoveredChanges;\n        TaskStateChanges discoveredInputFilesChanges = caching(discoveredChanges);\n\n        allTaskChanges = new SummaryTaskStateChanges(MAX_OUT_OF_DATE_MESSAGES, noHistoryState, taskTypeState, inputPropertiesState, outputFileChanges, inputFileChanges, discoveredInputFilesChanges);\n        rebuildChanges = new SummaryTaskStateChanges(1, noHistoryState, taskTypeState, inputPropertiesState, outputFileChanges);\n    }","commit_id":"03a2e5c498a676edb9f3f221db272d1967448e9f","url":"https://github.com/gradle/gradle"},{"original_method":"protected Result executeJava(UIExecutionContext context, Map<Object, Object> attributeMap) throws Exception {\n        String camelComponentName = mandatoryAttributeValue(attributeMap, \"componentName\");\n        String endpointInstanceName = mandatoryAttributeValue(attributeMap, \"instanceName\");\n        String routeBuilder = mandatoryAttributeValue(attributeMap, \"routeBuilder\");\n\n        Project project = getSelectedProject(context);\n        JavaSourceFacet facet = project.getFacet(JavaSourceFacet.class);\n\n        // does the project already have camel?\n        Dependency core = CamelProjectHelper.findCamelCoreDependency(project);\n        if (core == null) {\n            return Results.fail(\"The project does not include camel-core\");\n        }\n\n        // lets find the camel component class\n        CamelComponentDetails details = new CamelComponentDetails();\n        Result result = loadCamelComponentDetails(camelComponentName, details);\n        if (result != null) {\n            return result;\n        }\n        // and make sure its dependency is added\n        result = ensureCamelArtifactIdAdded(project, details, dependencyInstaller);\n        if (result != null) {\n            return result;\n        }\n\n        // collect all the options that was set\n        Map<String, String> options = new HashMap<String, String>();\n        for (InputComponent input : allInputs) {\n            String key = input.getName();\n            // only use the value if a value was set (and the value is not the same as the default value)\n            if (input.hasValue()) {\n                String value = input.getValue().toString();\n                if (value != null) {\n                    // do not add the value if it match the default value\n                    boolean matchDefault = isDefaultValue(camelComponentName, key, value);\n                    if (!matchDefault) {\n                        options.put(key, value);\n                    }\n                }\n            } else if (input.isRequired() && input.hasDefaultValue()) {\n                // if its required then we need to grab the value\n                String value = input.getValue().toString();\n                if (value != null) {\n                    options.put(key, value);\n                }\n            }\n        }\n\n        CamelCatalog catalog = new DefaultCamelCatalog();\n        String uri = catalog.asEndpointUri(camelComponentName, options, false);\n        if (uri == null) {\n            return Results.fail(\"Cannot create endpoint uri\");\n        }\n\n        JavaResource existing = facet.getJavaResource(routeBuilder);\n        if (existing == null || !existing.exists()) {\n            return Results.fail(\"RouteBuilder \" + routeBuilder + \" does not exist\");\n        }\n\n        JavaClassSource clazz = existing.getJavaType();\n\n        // add the endpoint as a field\n        // special for CDI as we use different set of annotations\n        boolean updated = true;\n        boolean cdi = findCamelArtifactDependency(project, \"camel-cdi\") != null;\n\n        FieldSource field = clazz.getField(endpointInstanceName);\n        AnnotationSource annotation;\n        if (field == null) {\n            field = clazz.addField();\n            field.setName(endpointInstanceName);\n            field.setType(\"org.apache.camel.Endpoint\");\n            field.setPrivate();\n            updated = false;\n        }\n        if (cdi) {\n            annotation = field.getAnnotation(\"org.apache.camel.cdi.Uri\");\n            if (annotation == null) {\n                if (!field.hasAnnotation(\"javax.inject.Inject\")) {\n                    field.addAnnotation(\"javax.inject.Inject\");\n                }\n                annotation = field.addAnnotation(\"org.apache.camel.cdi.Uri\");\n            }\n        } else {\n            annotation = field.getAnnotation(\"org.apache.camel.EndpointInject\");\n        }\n        annotation.removeAllValues();\n        annotation.setStringValue(uri);\n\n        // make sure to import what we use\n        clazz.addImport(\"org.apache.camel.Endpoint\");\n        if (cdi) {\n            clazz.addImport(\"javax.inject.Inject\");\n            clazz.addImport(\"org.apache.camel.cdi.Uri\");\n        } else {\n            clazz.addImport(\"org.apache.camel.EndpointInject\");\n        }\n\n        facet.saveJavaSource(clazz);\n\n        if (updated) {\n            return Results.success(\"Updated endpoint \" + endpointInstanceName + \" in \" + routeBuilder);\n        } else {\n            return Results.success(\"Added endpoint \" + endpointInstanceName + \" in \" + routeBuilder);\n        }\n    }","id":92945,"modified_method":"protected Result executeJava(UIExecutionContext context, Map<Object, Object> attributeMap) throws Exception {\n        String camelComponentName = mandatoryAttributeValue(attributeMap, \"componentName\");\n        String endpointInstanceName = optionalAttributeValue(attributeMap, \"instanceName\");\n        String routeBuilder = mandatoryAttributeValue(attributeMap, \"routeBuilder\");\n\n        Project project = getSelectedProject(context);\n        JavaSourceFacet facet = project.getFacet(JavaSourceFacet.class);\n\n        // does the project already have camel?\n        Dependency core = CamelProjectHelper.findCamelCoreDependency(project);\n        if (core == null) {\n            return Results.fail(\"The project does not include camel-core\");\n        }\n\n        // lets find the camel component class\n        CamelComponentDetails details = new CamelComponentDetails();\n        Result result = loadCamelComponentDetails(camelComponentName, details);\n        if (result != null) {\n            return result;\n        }\n        // and make sure its dependency is added\n        result = ensureCamelArtifactIdAdded(project, details, dependencyInstaller);\n        if (result != null) {\n            return result;\n        }\n\n        // collect all the options that was set\n        Map<String, String> options = new HashMap<String, String>();\n        for (InputComponent input : allInputs) {\n            String key = input.getName();\n            // only use the value if a value was set (and the value is not the same as the default value)\n            if (input.hasValue()) {\n                String value = input.getValue().toString();\n                if (value != null) {\n                    // do not add the value if it match the default value\n                    boolean matchDefault = isDefaultValue(camelComponentName, key, value);\n                    if (!matchDefault) {\n                        options.put(key, value);\n                    }\n                }\n            } else if (input.isRequired() && input.hasDefaultValue()) {\n                // if its required then we need to grab the value\n                String value = input.getValue().toString();\n                if (value != null) {\n                    options.put(key, value);\n                }\n            }\n        }\n\n        CamelCatalog catalog = new DefaultCamelCatalog();\n        String uri = catalog.asEndpointUri(camelComponentName, options, false);\n        if (uri == null) {\n            return Results.fail(\"Cannot create endpoint uri\");\n        }\n\n        JavaResource existing = facet.getJavaResource(routeBuilder);\n        if (existing == null || !existing.exists()) {\n            return Results.fail(\"RouteBuilder \" + routeBuilder + \" does not exist\");\n        }\n\n        JavaClassSource clazz = existing.getJavaType();\n\n        boolean updated = true;\n\n        if (endpointInstanceName != null) {\n            // add the endpoint as a field\n            // special for CDI as we use different set of annotations\n            FieldSource field = clazz.getField(endpointInstanceName);\n            AnnotationSource annotation;\n            if (field == null) {\n                field = clazz.addField();\n                field.setName(endpointInstanceName);\n                field.setType(\"org.apache.camel.Endpoint\");\n                field.setPrivate();\n                updated = false;\n            }\n            boolean cdi = findCamelArtifactDependency(project, \"camel-cdi\") != null;\n            if (cdi) {\n                annotation = field.getAnnotation(\"org.apache.camel.cdi.Uri\");\n                if (annotation == null) {\n                    if (!field.hasAnnotation(\"javax.inject.Inject\")) {\n                        field.addAnnotation(\"javax.inject.Inject\");\n                    }\n                    annotation = field.addAnnotation(\"org.apache.camel.cdi.Uri\");\n                }\n            } else {\n                annotation = field.getAnnotation(\"org.apache.camel.EndpointInject\");\n            }\n            annotation.removeAllValues();\n            annotation.setStringValue(uri);\n\n            // make sure to import what we use\n            clazz.addImport(\"org.apache.camel.Endpoint\");\n            if (cdi) {\n                clazz.addImport(\"javax.inject.Inject\");\n                clazz.addImport(\"org.apache.camel.cdi.Uri\");\n            } else {\n                clazz.addImport(\"org.apache.camel.EndpointInject\");\n            }\n\n            facet.saveJavaSource(clazz);\n\n            if (updated) {\n                return Results.success(\"Updated endpoint \" + endpointInstanceName + \" in \" + routeBuilder);\n            } else {\n                return Results.success(\"Added endpoint \" + endpointInstanceName + \" in \" + routeBuilder);\n            }\n\n        } else {\n            MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);\n            if (method != null) {\n                String endpointUrl = mandatoryAttributeValue(attributeMap, \"endpointUri\");\n                String body = method.getBody();\n                // wonder if we should have better way, than a replaceFirst?\n                String find = Pattern.quote(endpointUrl);\n                body = body.replaceFirst(find, uri);\n                method.setBody(body);\n\n                facet.saveJavaSource(clazz);\n\n                return Results.success(\"Updated endpoint \" + endpointUrl + \" -> \" + uri + \" in \" + routeBuilder);\n            }\n        }\n\n        return Results.fail(\"Cannot update endpoint\");\n    }","commit_id":"aa611469d5ea148193e3469cb113f15919557c62","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public void visit(VisitContext visitContext, JavaResource resource) {\n        try {\n            JavaClassSource clazz = resource.getJavaType();\n\n            // must be a route builder class\n            String superType = clazz.getSuperType();\n            if (superType != null && !RouteBuilder.class.getName().equals(superType)) {\n                return;\n            }\n\n            // look for fields\n            for (FieldSource<JavaClassSource> field : clazz.getFields()) {\n\n                // is the field annotated with a Camel endpoint\n                String uri = null;\n                for (Annotation ann : field.getAnnotations()) {\n                    if (\"org.apache.camel.EndpointInject\".equals(ann.getQualifiedName())) {\n                        uri = ann.getStringValue();\n                    } else if (\"org.apache.camel.cdi.Uri\".equals(ann.getQualifiedName())) {\n                        uri = ann.getStringValue();\n                    }\n                }\n\n                if (uri != null) {\n                    // we only want the relative dir name from the\n                    String baseDir = facet.getSourceDirectory().getFullyQualifiedName();\n                    String fileName = resource.getFullyQualifiedName();\n                    if (fileName.startsWith(baseDir)) {\n                        fileName = fileName.substring(baseDir.length() + 1);\n                    }\n                    String id = field.getName();\n\n                    CamelEndpointDetails detail = new CamelEndpointDetails();\n                    detail.setResource(resource);\n                    detail.setFileName(fileName);\n                    detail.setEndpointInstance(id);\n                    detail.setEndpointUri(uri);\n                    detail.setEndpointComponentName(endpointComponentName(uri));\n                    endpoints.add(detail);\n                }\n            }\n\n            // look for endpoints in the configure method\n            MethodSource<JavaClassSource> method = clazz.getMethod(\"configure\");\n            // must be public void configure()\n            if (method != null && method.isPublic() && method.getParameters().isEmpty() && method.getReturnType().isType(\"void\")) {\n                List<String> uris = CamelJavaParserHelper.parseCamelUris(method);\n                for (String uri : uris) {\n                    String baseDir = facet.getSourceDirectory().getFullyQualifiedName();\n                    String fileName = resource.getFullyQualifiedName();\n                    if (fileName.startsWith(baseDir)) {\n                        fileName = fileName.substring(baseDir.length() + 1);\n                    }\n\n                    CamelEndpointDetails detail = new CamelEndpointDetails();\n                    detail.setResource(resource);\n                    detail.setFileName(fileName);\n                    detail.setEndpointInstance(null);\n                    detail.setEndpointUri(uri);\n                    detail.setEndpointComponentName(endpointComponentName(uri));\n                    endpoints.add(detail);\n                }\n            }\n        } catch (Throwable e) {\n            // ignore\n        }\n\n    }","id":92946,"modified_method":"@Override\n    public void visit(VisitContext visitContext, JavaResource resource) {\n        try {\n            JavaClassSource clazz = resource.getJavaType();\n\n            // must be a route builder class\n            String superType = clazz.getSuperType();\n            if (superType != null && !RouteBuilder.class.getName().equals(superType)) {\n                return;\n            }\n\n            // look for fields\n            for (FieldSource<JavaClassSource> field : clazz.getFields()) {\n\n                // is the field annotated with a Camel endpoint\n                String uri = null;\n                for (Annotation ann : field.getAnnotations()) {\n                    if (\"org.apache.camel.EndpointInject\".equals(ann.getQualifiedName())) {\n                        uri = ann.getStringValue();\n                    } else if (\"org.apache.camel.cdi.Uri\".equals(ann.getQualifiedName())) {\n                        uri = ann.getStringValue();\n                    }\n                }\n\n                if (uri != null) {\n                    // we only want the relative dir name from the\n                    String baseDir = facet.getSourceDirectory().getFullyQualifiedName();\n                    String fileName = resource.getFullyQualifiedName();\n                    if (fileName.startsWith(baseDir)) {\n                        fileName = fileName.substring(baseDir.length() + 1);\n                    }\n                    String id = field.getName();\n\n                    CamelEndpointDetails detail = new CamelEndpointDetails();\n                    detail.setResource(resource);\n                    detail.setFileName(fileName);\n                    detail.setEndpointInstance(id);\n                    detail.setEndpointUri(uri);\n                    detail.setEndpointComponentName(endpointComponentName(uri));\n                    endpoints.add(detail);\n                }\n            }\n\n            // look for endpoints in the configure method\n            MethodSource<JavaClassSource> method = CamelJavaParserHelper.findConfigureMethod(clazz);\n            if (method != null) {\n                List<String> uris = CamelJavaParserHelper.parseCamelUris(method);\n                for (String uri : uris) {\n                    String baseDir = facet.getSourceDirectory().getFullyQualifiedName();\n                    String fileName = resource.getFullyQualifiedName();\n                    if (fileName.startsWith(baseDir)) {\n                        fileName = fileName.substring(baseDir.length() + 1);\n                    }\n\n                    CamelEndpointDetails detail = new CamelEndpointDetails();\n                    detail.setResource(resource);\n                    detail.setFileName(fileName);\n                    detail.setEndpointInstance(null);\n                    detail.setEndpointUri(uri);\n                    detail.setEndpointComponentName(endpointComponentName(uri));\n                    endpoints.add(detail);\n                }\n            }\n        } catch (Throwable e) {\n            // ignore\n        }\n\n    }","commit_id":"aa611469d5ea148193e3469cb113f15919557c62","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public GrReferenceExpression bindToElementViaStaticImport(@NotNull PsiClass qualifierClass) {\n    if (getQualifier() != null) {\n      throw new IncorrectOperationException(\"Reference has qualifier\");\n    }\n\n    if (StringUtil.isEmpty(getReferenceName())) {\n      throw new IncorrectOperationException(\"Reference has empty name\");\n    }\n    final PsiFile file = getContainingFile();\n    if (file instanceof GroovyFile) {\n      final GrImportStatement statement = GroovyPsiElementFactory.getInstance(getProject())\n        .createImportStatementFromText(\"import static \" + qualifierClass.getQualifiedName() + \".\" + getReferenceName());\n      ((GroovyFile)file).addImport(statement);\n    }\n    return this;\n  }","id":92947,"modified_method":"public GrReferenceExpression bindToElementViaStaticImport(@NotNull PsiMember member) {\n    if (getQualifier() != null) {\n      throw new IncorrectOperationException(\"Reference has qualifier\");\n    }\n\n    if (StringUtil.isEmpty(getReferenceName())) {\n      throw new IncorrectOperationException(\"Reference has empty name\");\n    }\n\n    PsiClass containingClass = member.getContainingClass();\n    if (containingClass==null) {\n      throw new IncorrectOperationException(\"Member has no containing class\");\n    }\n    final PsiFile file = getContainingFile();\n    if (file instanceof GroovyFile) {\n      GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(getProject());\n      String text = \"import static \" + containingClass.getQualifiedName() + \".\" + member.getName();\n      final GrImportStatement statement = factory.createImportStatementFromText(text);\n      ((GroovyFile)file).addImport(statement);\n    }\n    return this;\n  }","commit_id":"a993bfebebd7e717062e4862cba9591eb7459ca5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void restoreReferences(ReferenceTransferableData.ReferenceData[] referenceData,\n                                   GrReferenceElement[] refs) {\n    for (int i = 0; i < refs.length; i++) {\n      GrReferenceElement reference = refs[i];\n      if (reference == null) continue;\n      try {\n        PsiManager manager = reference.getManager();\n        ReferenceTransferableData.ReferenceData refData = referenceData[i];\n        PsiClass refClass = JavaPsiFacade.getInstance(manager.getProject()).findClass(refData.qClassName, reference.getResolveScope());\n        if (refClass != null) {\n          if (refData.staticMemberName == null) {\n            reference.bindToElement(refClass);\n          }\n          else {\n            LOG.assertTrue(reference instanceof GrReferenceExpression);\n            ((GrReferenceExpression)reference).bindToElementViaStaticImport(refClass);\n          }\n        }\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n    }\n  }","id":92948,"modified_method":"protected void restoreReferences(ReferenceTransferableData.ReferenceData[] referenceData,\n                                   GrReferenceElement[] refs) {\n    for (int i = 0; i < refs.length; i++) {\n      GrReferenceElement reference = refs[i];\n      if (reference == null) continue;\n      try {\n        PsiManager manager = reference.getManager();\n        ReferenceTransferableData.ReferenceData refData = referenceData[i];\n        PsiClass refClass = JavaPsiFacade.getInstance(manager.getProject()).findClass(refData.qClassName, reference.getResolveScope());\n        if (refClass != null) {\n          if (refData.staticMemberName == null) {\n            reference.bindToElement(refClass);\n          }\n          else {\n            LOG.assertTrue(reference instanceof GrReferenceExpression);\n            PsiMethod[] members = refClass.findMethodsByName(refData.staticMemberName, true);\n            if (members.length == 0) return;\n            ((GrReferenceExpression)reference).bindToElementViaStaticImport(members[0]);\n          }\n        }\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n    }\n  }","commit_id":"a993bfebebd7e717062e4862cba9591eb7459ca5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doImport(final PsiMethod toImport) {\n    CommandProcessor.getInstance().executeCommand(toImport.getProject(), new Runnable() {\n      public void run() {\n        AccessToken accessToken = WriteAction.start();\n\n        try {\n          try {\n            GrMethodCall element = myMethodCall.getElement();\n            if (element != null) {\n              getMethodExpression(element).bindToElementViaStaticImport(toImport.getContainingClass());\n            }\n          }\n          catch (IncorrectOperationException e) {\n            LOG.error(e);\n          }\n        }\n        finally {\n          accessToken.finish();\n        }\n      }\n    }, getText(), this);\n\n  }","id":92949,"modified_method":"private void doImport(final PsiMethod toImport) {\n    CommandProcessor.getInstance().executeCommand(toImport.getProject(), new Runnable() {\n      public void run() {\n        AccessToken accessToken = WriteAction.start();\n\n        try {\n          try {\n            GrMethodCall element = myMethodCall.getElement();\n            if (element != null) {\n              getMethodExpression(element).bindToElementViaStaticImport(toImport);\n            }\n          }\n          catch (IncorrectOperationException e) {\n            LOG.error(e);\n          }\n        }\n        finally {\n          accessToken.finish();\n        }\n      }\n    }, getText(), this);\n\n  }","commit_id":"a993bfebebd7e717062e4862cba9591eb7459ca5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public Change perform(IProgressMonitor progress) throws CoreException\n    {   \n        sigil.getBundle().getBundleInfo().removeChild(oldExport);\n        sigil.getBundle().getBundleInfo().addExport(newExport);\n        \n        sigil.save(progress);\n        \n        return new ExportPackageChange(sigil, newExport, oldExport);\n    }","id":92950,"modified_method":"@Override\n    public Change perform(IProgressMonitor progress) throws CoreException\n    {   \n        if (oldExport != null) {\n            sigil.getBundle().getBundleInfo().removeChild(oldExport);\n        }\n        \n        if (newExport != null) {\n            sigil.getBundle().getBundleInfo().addExport(newExport);\n        }\n        \n        sigil.save(progress);\n        \n        return new ExportPackageChange(sigil, newExport, oldExport);\n    }","commit_id":"902205184fa2e5788c7008c90205195e42e5a414","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public Change perform(IProgressMonitor progress) throws CoreException\n    {\n        sigil.getBundle().getBundleInfo().removeImport(oldImport);\n        sigil.getBundle().getBundleInfo().addImport(newImport);\n        \n        sigil.save(progress);\n        \n        return new ImportPackageChange(sigil, newImport, oldImport);\n    }","id":92951,"modified_method":"@Override\n    public Change perform(IProgressMonitor progress) throws CoreException\n    {\n        if (oldImport!=null) {\n            sigil.getBundle().getBundleInfo().removeImport(oldImport);\n        }\n        \n        if (newImport != null) {\n            sigil.getBundle().getBundleInfo().addImport(newImport);\n        }\n        \n        sigil.save(progress);\n        \n        return new ImportPackageChange(sigil, newImport, oldImport);\n    }","commit_id":"902205184fa2e5788c7008c90205195e42e5a414","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public RefactoringStatus checkConditions(IProgressMonitor pm,\n        CheckConditionsContext context) throws OperationCanceledException\n    {   \n        RefactoringStatus status = new RefactoringStatus();\n        \n        try\n        {\n            ISigilProjectModel sigil = SigilCore.create(packageFragment.getJavaProject().getProject());\n            final String packageName = packageFragment.getElementName();\n            \n            SigilCore.log(\"Rename checkConditions \" + packageName);\n            \n            final IPackageExport[] found = new IPackageExport[1];\n            sigil.visit(new IModelWalker()\n            {            \n                public boolean visit(IModelElement element)\n                {\n                    if (element instanceof IPackageExport) {\n                        IPackageExport pe = (IPackageExport) element;\n                        if (pe.getPackageName().equals(packageName)) {\n                            found[0] = pe;\n                        }\n                    }\n                    return found[0] == null;\n                }\n            });\n            \n            if (found[0] != null) {\n                // record change to check if out of sync...\n                touch(context, sigil);\n                            \n                status = RefactoringStatus.createWarningStatus(\"Package \" + packageName + \" is exported. Renaming this package may effect bundles outside of this workspace\");\n                SigilCore.log(\"Export Package \" + packageName + \" renamed to \" + getArguments().getNewName());\n\n                IPackageExport oldExport = found[0];\n                IPackageExport newExport = ModelElementFactory.getInstance().newModelElement(IPackageExport.class);\n                newExport.setPackageName(getArguments().getNewName());\n                newExport.setVersion(oldExport.getVersion());\n\n                changes.add(new ExportPackageChange(sigil, oldExport, newExport));                    \n\n                for ( ISigilProjectModel other : SigilCore.getRoot().getProjects() ) {\n                    if ( !sigil.equals(other) ) {\n                        // record change to check if out of sync...\n                        touch(context, other);\n                    }\n                    changes.add(createImportChange(status, other, oldExport, newExport));\n                }\n            }\n        }\n        catch (CoreException e)\n        {\n            SigilCore.warn(\"Failed to create export package refactor\", e);\n            throw new OperationCanceledException(\"Failed to create export package refactor\");\n        }\n        \n        return status;\n    }","id":92952,"modified_method":"@Override\n    public RefactoringStatus checkConditions(IProgressMonitor pm,\n        CheckConditionsContext context) throws OperationCanceledException\n    {   \n        RefactoringStatus status = new RefactoringStatus();\n        \n        if (getArguments().getUpdateReferences()) {\n            try\n            {\n                ISigilProjectModel sigil = SigilCore.create(packageFragment.getJavaProject().getProject());\n                final String packageName = packageFragment.getElementName();\n                \n                SigilCore.log(\"Rename checkConditions \" + packageName);\n                \n                IPackageExport oldExport = ModelHelper.findExport(sigil, packageName);\n                \n                if (oldExport != null) {\n                    // record change to check if out of sync...\n                    touch(context, sigil);\n                                \n                    status = RefactoringStatus.createWarningStatus(\"Package \" + packageName + \" is exported. Renaming this package may effect bundles outside of this workspace\");\n                    SigilCore.log(\"Export Package \" + packageName + \" renamed to \" + getArguments().getNewName());\n    \n                    IPackageExport newExport = ModelElementFactory.getInstance().newModelElement(IPackageExport.class);\n                    newExport.setPackageName(getArguments().getNewName());\n                    newExport.setVersion(oldExport.getVersion());\n    \n                    changes.add(new ExportPackageChange(sigil, oldExport, newExport));                    \n    \n                    for ( ISigilProjectModel other : SigilCore.getRoot().getProjects() ) {\n                        if ( !sigil.equals(other) ) {\n                            // record change to check if out of sync...\n                            touch(context, other);\n                        }\n                        changes.add(createImportChange(status, other, oldExport, newExport));\n                    }\n                }\n            }\n            catch (CoreException e)\n            {\n                SigilCore.warn(\"Failed to create export package refactor\", e);\n                throw new OperationCanceledException(\"Failed to create export package refactor\");\n            }\n        }        \n        return status;\n    }","commit_id":"902205184fa2e5788c7008c90205195e42e5a414","url":"https://github.com/apache/felix"},{"original_method":"/** The implementation of all public get methods.\n\t * In other words, all public <code>get<\/code> methods will prepare\n\t * an empty map and invoke this method to retrieve the media.\n\t * It is designed to allow applications to customize the creation of \n\t * the dialog, such as adding more parameters.\n\t * @since 5.0.11\n\t */\n\tprotected static Media[] get(Map<String, Object> params,\n\tString message, String title, int max, int maxsize, boolean alwaysNative) {\n\t\tfinal Execution exec = Executions.getCurrent();\n\t\tparams.put(\"message\", message == null ?\n\t\t\tMessages.get(MZul.UPLOAD_MESSAGE): message);\n\t\tparams.put(\"title\", title == null ?\n\t\t\tMessages.get(MZul.UPLOAD_TITLE): title);\n\t\tparams.put(\"max\", new Integer(max == 0 ? 1 : max > 1000 ? 1000: max < -1000 ? -1000 : max));\n\t\tparams.put(\"native\", Boolean.valueOf(alwaysNative));\n\t\tparams.put(\"maxsize\", String.valueOf(maxsize));\n\t\t\n\t\tfinal FileuploadDlg dlg = (FileuploadDlg)\n\t\t\texec.createComponents(_templ, null, params);\n\t\ttry {\n\t\t\tdlg.doModal();\n\t\t} catch (Throwable ex) {\n\t\t\ttry {\n\t\t\t\tdlg.detach();\n\t\t\t} catch (Throwable ex2) {\n\t\t\t\tlog.warningBriefly(\"Failed to detach when recovering from an error\", ex2);\n\t\t\t}\n\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t}\n\t\treturn dlg.getResult();\n\t}","id":92953,"modified_method":"/** The implementation of all public get methods.\n\t * In other words, all public <code>get<\/code> methods will prepare\n\t * an empty map and invoke this method to retrieve the media.\n\t * It is designed to allow applications to customize the creation of \n\t * the dialog, such as adding more parameters.\n\t * @since 5.0.11\n\t */\n\tprotected static Media[] get(Map<String, Object> params,\n\tString message, String title, int max, int maxsize, boolean alwaysNative) {\n\t\treturn get(params, message, title, max, maxsize, alwaysNative, null);\n\t}","commit_id":"c4dba39d42b0e7f311fb679c76188176af3dfc8f","url":"https://github.com/zkoss/zk"},{"original_method":"public void onClose(Event evt) {\n\t\tif (evt.getData() == null)\n\t\t\t_result.clear();\n\t\telse {\n\t\t\tfinal Desktop desktop = Executions.getCurrent().getDesktop();\n\t\t\tfinal Configuration config = desktop .getWebApp().getConfiguration();\n\t\t\tif (!config.isEventThreadEnabled())\n\t\t\t\tEvents.postEvent(new UploadEvent(Events.ON_UPLOAD, (Component)desktop.getAttribute(ATTR_FILEUPLOAD_TARGET), getResult()));\n\t\t}\n\t\tdetach();\n\t}","id":92954,"modified_method":"public void onClose(Event evt) {\n\t\tif (evt.getData() == null)\n\t\t\t_result.clear();\n\t\telse {\n\t\t\tfinal Desktop desktop = Executions.getCurrent().getDesktop();\n\t\t\tfinal Configuration config = desktop .getWebApp().getConfiguration();\n\t\t\tif (!config.isEventThreadEnabled()) {\n\t\t\t\tif (_listener != null)\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_listener.onEvent(new UploadEvent(Events.ON_UPLOAD, null, getResult()));\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tthrow new UiException(e);\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tEvents.postEvent(new UploadEvent(Events.ON_UPLOAD, (Component)desktop.getAttribute(ATTR_FILEUPLOAD_TARGET), getResult()));\n\t\t\t}\n\t\t}\n\t\tdetach();\n\t}","commit_id":"c4dba39d42b0e7f311fb679c76188176af3dfc8f","url":"https://github.com/zkoss/zk"},{"original_method":"public Map<String, String> getEntitiesForContext(String gradebookUid) {\n\t\tMap<String, String> rv = new HashMap<String, String>();\n\t\tList<Assignment> assignments = gbs.getAssignments(gradebookUid);\n\t\tfor (Assignment asn : assignments) {\n\t\t\tString assignmentName = asn.getName();\n\t\t\tString assignmentPoints = asn.getPoints().toString();\n\t\t\trv.put(\"/gradebook/\"+ gradebookUid + \"/\" + assignmentName + \"/\" + assignmentPoints, assignmentName + \" (\" + assignmentPoints + \" points)\");\n\t\t}\n\t\treturn rv;\n\t}","id":92955,"modified_method":"public Map<String, String> getEntitiesForContext(String gradebookUid) {\n\t\tMap<String, String> rv = new HashMap<String, String>();\n\t\tList<Assignment> assignments = gbs.getAssignments(gradebookUid);\n\t\tfor (Assignment asn : assignments) {\n\t\t\tString assignmentName = asn.getName();\n\t\t\tString assignmentPoints = asn.getPoints().toString();\n\t\t\tboolean isReleasedToStudents = asn.isReleased();\n\t\t\tboolean isUsedInGradeCalculation = asn.isCounted();\n\t\t\tDate dueDate = asn.getDueDate();\n\t\t\tlong dueDateMillis = 0;\n\t\t\tif (dueDate != null) dueDateMillis = dueDate.getTime();\n\t\t\t// event resource of the form: /gradebook/[gradebook id]/[assignment name]/[points possible]/[due date millis]/[is released]/[is included in course grade]/[has authz]\n\t\t\trv.put(\"/gradebook/\"+ gradebookUid + \"/\" + assignmentName + \"/\" + assignmentPoints + \"/\" + dueDateMillis + \"/\" + isReleasedToStudents + \"/\" + isUsedInGradeCalculation , assignmentName + \" (\" + assignmentPoints + \" points)\");\n\t\t}\n\t\treturn rv;\n\t}","commit_id":"e860dc366cbbecf42add44eb259023f984815c3c","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * @see org.sakaiproject.service.gradebook.shared.GradebookService#updateExternalAssessmentScore(java.lang.String, java.lang.String, java.lang.String, Double)\n\t */\n\tpublic void updateExternalAssessmentScore(final String gradebookUid, final String externalId,\n\t\t\tfinal String studentUid, final Double points) throws GradebookNotFoundException, AssessmentNotFoundException {\n\n        final Assignment asn = getExternalAssignment(gradebookUid, externalId);\n\n        if(asn == null) {\n            throw new AssessmentNotFoundException(\"There is no assessment id=\" + externalId + \" in gradebook uid=\" + gradebookUid);\n        }\n\n        if (logData.isDebugEnabled()) logData.debug(\"BEGIN: Update 1 score for gradebookUid=\" + gradebookUid + \", external assessment=\" + externalId + \" from \" + asn.getExternalAppName());\n\n        HibernateCallback hc = new HibernateCallback() {\n            public Object doInHibernate(Session session) throws HibernateException {\n                Date now = new Date();\n\n                AssignmentGradeRecord agr = getAssignmentGradeRecord(asn, studentUid, session);\n\n                // Try to reduce data contention by only updating when the\n                // score has actually changed.\n                Double oldPointsEarned = (agr == null) ? null : agr.getPointsEarned();\n                if ( ((points != null) && (!points.equals(oldPointsEarned))) ||\n\t\t\t\t\t((points == null) && (oldPointsEarned != null)) ) {\n\t\t\t\t\tif (agr == null) {\n\t\t\t\t\t\tagr = new AssignmentGradeRecord(asn, studentUid, points);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tagr.setPointsEarned(points);\n\t\t\t\t\t}\n\n\t\t\t\t\tagr.setDateRecorded(now);\n\t\t\t\t\tagr.setGraderId(getUserUid());\n\t\t\t\t\tif (log.isDebugEnabled()) log.debug(\"About to save AssignmentGradeRecord id=\" + agr.getId() + \", version=\" + agr.getVersion() + \", studenttId=\" + agr.getStudentId() + \", pointsEarned=\" + agr.getPointsEarned());\n\t\t\t\t\tsession.saveOrUpdate(agr);\n\n\t\t\t\t\t// Sync database.\n\t\t\t\t\tsession.flush();\n\t\t\t\t\tsession.clear();\n\t\t\t\t} else {\n\t\t\t\t\tif(log.isDebugEnabled()) log.debug(\"Ignoring updateExternalAssessmentScore, since the new points value is the same as the old\");\n\t\t\t\t}\n                return null;\n            }\n        };\n        getHibernateTemplate().execute(hc);\n        eventTrackingService.postEvent(\"gradebook.updateItemScore\",\"/gradebook/\"+gradebookUid+\"/\"+asn.getName()+\"/\"+studentUid+\"/\"+points+\"/student\");\n        if (logData.isDebugEnabled()) logData.debug(\"END: Update 1 score for gradebookUid=\" + gradebookUid + \", external assessment=\" + externalId + \" from \" + asn.getExternalAppName());\n\t\tif (log.isDebugEnabled()) log.debug(\"External assessment score updated in gradebookUid=\" + gradebookUid + \", externalId=\" + externalId + \" by userUid=\" + getUserUid() + \", new score=\" + points);\n\t}","id":92956,"modified_method":"/**\n\t * @see org.sakaiproject.service.gradebook.shared.GradebookService#updateExternalAssessmentScore(java.lang.String, java.lang.String, java.lang.String, Double)\n\t */\n\tpublic void updateExternalAssessmentScore(final String gradebookUid, final String externalId,\n\t\t\tfinal String studentUid, final Double points) throws GradebookNotFoundException, AssessmentNotFoundException {\n\n        final Assignment asn = getExternalAssignment(gradebookUid, externalId);\n\n        if(asn == null) {\n            throw new AssessmentNotFoundException(\"There is no assessment id=\" + externalId + \" in gradebook uid=\" + gradebookUid);\n        }\n\n        if (logData.isDebugEnabled()) logData.debug(\"BEGIN: Update 1 score for gradebookUid=\" + gradebookUid + \", external assessment=\" + externalId + \" from \" + asn.getExternalAppName());\n\n        HibernateCallback hc = new HibernateCallback() {\n            public Object doInHibernate(Session session) throws HibernateException {\n                Date now = new Date();\n\n                AssignmentGradeRecord agr = getAssignmentGradeRecord(asn, studentUid, session);\n\n                // Try to reduce data contention by only updating when the\n                // score has actually changed.\n                Double oldPointsEarned = (agr == null) ? null : agr.getPointsEarned();\n                if ( ((points != null) && (!points.equals(oldPointsEarned))) ||\n\t\t\t\t\t((points == null) && (oldPointsEarned != null)) ) {\n\t\t\t\t\tif (agr == null) {\n\t\t\t\t\t\tagr = new AssignmentGradeRecord(asn, studentUid, points);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tagr.setPointsEarned(points);\n\t\t\t\t\t}\n\n\t\t\t\t\tagr.setDateRecorded(now);\n\t\t\t\t\tagr.setGraderId(getUserUid());\n\t\t\t\t\tif (log.isDebugEnabled()) log.debug(\"About to save AssignmentGradeRecord id=\" + agr.getId() + \", version=\" + agr.getVersion() + \", studenttId=\" + agr.getStudentId() + \", pointsEarned=\" + agr.getPointsEarned());\n\t\t\t\t\tsession.saveOrUpdate(agr);\n\n\t\t\t\t\t// Sync database.\n\t\t\t\t\tsession.flush();\n\t\t\t\t\tsession.clear();\n\t\t\t\t} else {\n\t\t\t\t\tif(log.isDebugEnabled()) log.debug(\"Ignoring updateExternalAssessmentScore, since the new points value is the same as the old\");\n\t\t\t\t}\n                return null;\n            }\n        };\n        getHibernateTemplate().execute(hc);\n        if (eventTrackingService != null) {\n            eventTrackingService.postEvent(\"gradebook.updateItemScore\",\"/gradebook/\"+gradebookUid+\"/\"+asn.getName()+\"/\"+studentUid+\"/\"+points+\"/student\");\n        }\n        if (logData.isDebugEnabled()) logData.debug(\"END: Update 1 score for gradebookUid=\" + gradebookUid + \", external assessment=\" + externalId + \" from \" + asn.getExternalAppName());\n\t\tif (log.isDebugEnabled()) log.debug(\"External assessment score updated in gradebookUid=\" + gradebookUid + \", externalId=\" + externalId + \" by userUid=\" + getUserUid() + \", new score=\" + points);\n\t}","commit_id":"e860dc366cbbecf42add44eb259023f984815c3c","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Create a new session.\n     * @return\n     * @throws RepositoryException\n     */\n    protected Session createSession()\n    throws RepositoryException {\n        return this.repository.loginAdministrative(null);\n    }","id":92957,"modified_method":"/**\n     * Create a new session.\n     * @return\n     * @throws RepositoryException\n     */\n    protected Session createSession()\n    throws RepositoryException {\n        final SlingRepository repo = this.repository;\n        if ( repo == null ) {\n            throw new RepositoryException(\"Repository is currently not available.\");\n        }\n        return repo.loginAdministrative(null);\n    }","commit_id":"383f9ffb8eb91b1c99c30c22edd97bbeb272b15d","url":"https://github.com/apache/sling"},{"original_method":"protected void runInBackground() {\n        while ( this.running ) {\n            // so let's wait/get the next job from the queue\n            EventInfo info = null;\n            try {\n                info = this.queue.take();\n            } catch (InterruptedException e) {\n                // we ignore this\n                this.ignoreException(e);\n            }\n            if ( info != null && this.running ) {\n                if ( info.event != null ) {\n                    try {\n                        this.writeEvent(info.event);\n                    } catch (Exception e) {\n                        this.logger.error(\"Exception during writing the event to the repository.\", e);\n                    }\n                } else if ( info.nodePath != null) {\n                    try {\n                        final Node eventNode = (Node) this.session.getItem(info.nodePath);\n                        this.eventAdmin.postEvent(this.readEvent(eventNode));\n                    } catch (Exception ex) {\n                        this.logger.error(\"Exception during reading the event from the repository.\", ex);\n                    }\n                }\n            }\n        }\n    }","id":92958,"modified_method":"protected void runInBackground() {\n        while ( this.running ) {\n            // so let's wait/get the next job from the queue\n            EventInfo info = null;\n            try {\n                info = this.queue.take();\n            } catch (InterruptedException e) {\n                // we ignore this\n                this.ignoreException(e);\n            }\n            if ( info != null && this.running ) {\n                if ( info.event != null ) {\n                    try {\n                        this.writeEvent(info.event);\n                    } catch (Exception e) {\n                        this.logger.error(\"Exception during writing the event to the repository.\", e);\n                    }\n                } else if ( info.nodePath != null) {\n                    try {\n                        final Node eventNode = (Node) this.session.getItem(info.nodePath);\n                        final EventAdmin localEA = this.eventAdmin;\n                        if ( localEA != null ) {\n                            localEA.postEvent(this.readEvent(eventNode));\n                        } else {\n                            this.logger.error(\"Unable to post event as no event admin is available.\");\n                        }\n                    } catch (Exception ex) {\n                        this.logger.error(\"Exception during reading the event from the repository.\", ex);\n                    }\n                }\n            }\n        }\n    }","commit_id":"383f9ffb8eb91b1c99c30c22edd97bbeb272b15d","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Process a job and unlock the node in the repository.\n     * @param event The original event.\n     * @param eventNode The node in the repository where the job is stored.\n     */\n    protected void processJob(Event event, Node eventNode, String lockToken)  {\n        final boolean parallelProcessing = event.getProperty(EventUtil.PROPERTY_JOB_PARALLEL) != null;\n        boolean unlock = true;\n        try {\n            final Event jobEvent = this.getJobEvent(event, eventNode, lockToken);\n            eventNode.setProperty(EventHelper.NODE_PROPERTY_PROCESSOR, this.applicationId);\n            eventNode.save();\n            this.eventAdmin.sendEvent(jobEvent);\n            // do not unlock if sending was successful\n            unlock = false;\n        } catch (RepositoryException re) {\n            // if an exception occurs, we just log\n            this.logger.error(\"Exception during job processing.\", re);\n        } finally {\n            if ( unlock ) {\n                if ( !parallelProcessing ) {\n                    synchronized ( this ) {\n                        this.isProcessing = false;\n                    }\n                }\n                // unlock node\n                try {\n                    eventNode.unlock();\n                } catch (RepositoryException e) {\n                    // if unlock fails, we silently ignore this\n                    this.ignoreException(e);\n                }\n            }\n        }\n    }","id":92959,"modified_method":"/**\n     * Process a job and unlock the node in the repository.\n     * @param event The original event.\n     * @param eventNode The node in the repository where the job is stored.\n     */\n    protected void processJob(Event event, Node eventNode, String lockToken)  {\n        final boolean parallelProcessing = event.getProperty(EventUtil.PROPERTY_JOB_PARALLEL) != null;\n        boolean unlock = true;\n        try {\n            final Event jobEvent = this.getJobEvent(event, eventNode, lockToken);\n            eventNode.setProperty(EventHelper.NODE_PROPERTY_PROCESSOR, this.applicationId);\n            eventNode.save();\n            final EventAdmin localEA = this.eventAdmin;\n            if ( localEA != null ) {\n                localEA.sendEvent(jobEvent);\n                // do not unlock if sending was successful\n                unlock = false;\n            } else {\n                this.logger.error(\"Job event can't be sent as no event admin is available.\");\n            }\n        } catch (RepositoryException re) {\n            // if an exception occurs, we just log\n            this.logger.error(\"Exception during job processing.\", re);\n        } finally {\n            if ( unlock ) {\n                if ( !parallelProcessing ) {\n                    synchronized ( this ) {\n                        this.isProcessing = false;\n                    }\n                }\n                // unlock node\n                try {\n                    eventNode.unlock();\n                } catch (RepositoryException e) {\n                    // if unlock fails, we silently ignore this\n                    this.ignoreException(e);\n                }\n            }\n        }\n    }","commit_id":"383f9ffb8eb91b1c99c30c22edd97bbeb272b15d","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Process the event.\n     * If a scheduler is available, a job is scheduled or stopped.\n     * @param event The incomming event.\n     * @return\n     */\n    protected boolean processEvent(final Event event, final ScheduleInfo scheduleInfo) {\n        if ( this.scheduler != null ) {\n            // is this a stop event?\n            if ( scheduleInfo.isStopEvent() ) {\n                if ( this.logger.isDebugEnabled() ) {\n                    this.logger.debug(\"Stopping timed event \" + event.getProperty(EventUtil.PROPERTY_TIMED_EVENT_TOPIC) + \"(\" + scheduleInfo.jobId + \")\");\n                }\n                try {\n                    this.scheduler.removeJob(scheduleInfo.jobId);\n                } catch (NoSuchElementException nsee) {\n                    // this can happen if the job is scheduled on another node\n                    // so we can just ignore this\n                }\n                return true;\n            }\n            // we ignore remote job events\n            if ( !EventUtil.isLocal(event) ) {\n                return true;\n            }\n\n            // Create configuration for scheduled job\n            final Map<String, Serializable> config = new HashMap<String, Serializable>();\n            // copy properties\n            final Hashtable<String, Object> properties = new Hashtable<String, Object>();\n            config.put(JOB_TOPIC, (String)event.getProperty(EventUtil.PROPERTY_TIMED_EVENT_TOPIC));\n            final String[] names = event.getPropertyNames();\n            if ( names != null ) {\n                for(int i=0; i<names.length; i++) {\n                    properties.put(names[i], event.getProperty(names[i]));\n                }\n            }\n            config.put(JOB_CONFIG, properties);\n            config.put(JOB_SCHEDULE_INFO, scheduleInfo);\n\n            try {\n                if ( scheduleInfo.expression != null ) {\n                    if ( this.logger.isDebugEnabled() ) {\n                        this.logger.debug(\"Adding timed event \" + config.get(JOB_TOPIC) + \"(\" + scheduleInfo.jobId + \")\" + \" with cron expression \" + scheduleInfo.expression);\n                    }\n                    this.scheduler.addJob(scheduleInfo.jobId, this, config, scheduleInfo.expression, false);\n                } else if ( scheduleInfo.period != null ) {\n                    if ( this.logger.isDebugEnabled() ) {\n                        this.logger.debug(\"Adding timed event \" + config.get(JOB_TOPIC) + \"(\" + scheduleInfo.jobId + \")\" + \" with period \" + scheduleInfo.period);\n                    }\n                    this.scheduler.addPeriodicJob(scheduleInfo.jobId, this, config, scheduleInfo.period, false);\n                } else {\n                    // then it must be date\n                    if ( this.logger.isDebugEnabled() ) {\n                        this.logger.debug(\"Adding timed event \" + config.get(JOB_TOPIC) + \"(\" + scheduleInfo.jobId + \")\" + \" with date \" + scheduleInfo.date);\n                    }\n                    this.scheduler.fireJobAt(scheduleInfo.jobId, this, config, scheduleInfo.date);\n                }\n                return true;\n            } catch (Exception e) {\n                this.ignoreException(e);\n            }\n        } else {\n            this.logger.error(\"No scheduler available to start timed event \" + event);\n        }\n        return false;\n    }","id":92960,"modified_method":"/**\n     * Process the event.\n     * If a scheduler is available, a job is scheduled or stopped.\n     * @param event The incomming event.\n     * @return\n     */\n    protected boolean processEvent(final Event event, final ScheduleInfo scheduleInfo) {\n        final Scheduler localScheduler = this.scheduler;\n        if ( localScheduler != null ) {\n            // is this a stop event?\n            if ( scheduleInfo.isStopEvent() ) {\n                if ( this.logger.isDebugEnabled() ) {\n                    this.logger.debug(\"Stopping timed event \" + event.getProperty(EventUtil.PROPERTY_TIMED_EVENT_TOPIC) + \"(\" + scheduleInfo.jobId + \")\");\n                }\n                try {\n                    localScheduler.removeJob(scheduleInfo.jobId);\n                } catch (NoSuchElementException nsee) {\n                    // this can happen if the job is scheduled on another node\n                    // so we can just ignore this\n                }\n                return true;\n            }\n            // we ignore remote job events\n            if ( !EventUtil.isLocal(event) ) {\n                return true;\n            }\n\n            // Create configuration for scheduled job\n            final Map<String, Serializable> config = new HashMap<String, Serializable>();\n            // copy properties\n            final Hashtable<String, Object> properties = new Hashtable<String, Object>();\n            config.put(JOB_TOPIC, (String)event.getProperty(EventUtil.PROPERTY_TIMED_EVENT_TOPIC));\n            final String[] names = event.getPropertyNames();\n            if ( names != null ) {\n                for(int i=0; i<names.length; i++) {\n                    properties.put(names[i], event.getProperty(names[i]));\n                }\n            }\n            config.put(JOB_CONFIG, properties);\n            config.put(JOB_SCHEDULE_INFO, scheduleInfo);\n\n            try {\n                if ( scheduleInfo.expression != null ) {\n                    if ( this.logger.isDebugEnabled() ) {\n                        this.logger.debug(\"Adding timed event \" + config.get(JOB_TOPIC) + \"(\" + scheduleInfo.jobId + \")\" + \" with cron expression \" + scheduleInfo.expression);\n                    }\n                    localScheduler.addJob(scheduleInfo.jobId, this, config, scheduleInfo.expression, false);\n                } else if ( scheduleInfo.period != null ) {\n                    if ( this.logger.isDebugEnabled() ) {\n                        this.logger.debug(\"Adding timed event \" + config.get(JOB_TOPIC) + \"(\" + scheduleInfo.jobId + \")\" + \" with period \" + scheduleInfo.period);\n                    }\n                    localScheduler.addPeriodicJob(scheduleInfo.jobId, this, config, scheduleInfo.period, false);\n                } else {\n                    // then it must be date\n                    if ( this.logger.isDebugEnabled() ) {\n                        this.logger.debug(\"Adding timed event \" + config.get(JOB_TOPIC) + \"(\" + scheduleInfo.jobId + \")\" + \" with date \" + scheduleInfo.date);\n                    }\n                    localScheduler.fireJobAt(scheduleInfo.jobId, this, config, scheduleInfo.date);\n                }\n                return true;\n            } catch (Exception e) {\n                this.ignoreException(e);\n            }\n        } else {\n            this.logger.error(\"No scheduler available to start timed event \" + event);\n        }\n        return false;\n    }","commit_id":"383f9ffb8eb91b1c99c30c22edd97bbeb272b15d","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.scheduler.Job#execute(org.apache.sling.scheduler.JobContext)\n     */\n    public void execute(JobContext context) {\n        // as we are called periodically as well, we have to check the configuration first\n        if ( context.getConfiguration() == null ) {\n            // period call, just invoke run\n            this.run();\n            return;\n        }\n\n        final String topic = (String) context.getConfiguration().get(JOB_TOPIC);\n        @SuppressWarnings(\"unchecked\")\n        final Dictionary<Object, Object> properties = (Dictionary<Object, Object>) context.getConfiguration().get(JOB_CONFIG);\n        if ( this.eventAdmin != null ) {\n            try {\n                this.eventAdmin.postEvent(new Event(topic, properties));\n            } catch (IllegalArgumentException iae) {\n                this.logger.error(\"Scheduled event has illegal topic: \" + topic, iae);\n            }\n        } else {\n            this.logger.warn(\"Unable to send timed event as no event admin service is available.\");\n        }\n        final ScheduleInfo info = (ScheduleInfo) context.getConfiguration().get(JOB_SCHEDULE_INFO);\n        // is this job scheduled for a specific date?\n        if ( info.date != null ) {\n            // we can remove it from the repository\n            // we create an own session here\n            Session s = null;\n            try {\n                s = this.createSession();\n                final Session mySession = s;\n                final Node parentNode = (Node)s.getItem(this.repositoryPath);\n                new Locked() {\n\n                    protected Object run(Node node) throws RepositoryException {\n                        final Node eventNode = queryJob(mySession, info.jobId);\n                        if ( eventNode != null ) {\n                            try {\n                                eventNode.remove();\n                                parentNode.save();\n                            } catch (RepositoryException re) {\n                                // we ignore the exception if removing fails\n                                ignoreException(re);\n                            }\n                        }\n                        return null;\n                    }\n                }.with(parentNode, false);\n            } catch (RepositoryException re) {\n                this.logger.error(\"Unable to create a session.\", re);\n            } catch (InterruptedException e) {\n                 // This should never happen from the lock, so we ignore it\n                 this.ignoreException(e);\n            } finally {\n                if ( s != null ) {\n                    s.logout();\n                }\n            }\n        }\n    }","id":92961,"modified_method":"/**\n     * @see org.apache.sling.scheduler.Job#execute(org.apache.sling.scheduler.JobContext)\n     */\n    public void execute(JobContext context) {\n        // as we are called periodically as well, we have to check the configuration first\n        if ( context.getConfiguration() == null ) {\n            // period call, just invoke run\n            this.run();\n            return;\n        }\n\n        final String topic = (String) context.getConfiguration().get(JOB_TOPIC);\n        @SuppressWarnings(\"unchecked\")\n        final Dictionary<Object, Object> properties = (Dictionary<Object, Object>) context.getConfiguration().get(JOB_CONFIG);\n        final EventAdmin ea = this.eventAdmin;\n        if ( ea != null ) {\n            try {\n                ea.postEvent(new Event(topic, properties));\n            } catch (IllegalArgumentException iae) {\n                this.logger.error(\"Scheduled event has illegal topic: \" + topic, iae);\n            }\n        } else {\n            this.logger.warn(\"Unable to send timed event as no event admin service is available.\");\n        }\n        final ScheduleInfo info = (ScheduleInfo) context.getConfiguration().get(JOB_SCHEDULE_INFO);\n        // is this job scheduled for a specific date?\n        if ( info.date != null ) {\n            // we can remove it from the repository\n            // we create an own session here\n            Session s = null;\n            try {\n                s = this.createSession();\n                final Session mySession = s;\n                final Node parentNode = (Node)s.getItem(this.repositoryPath);\n                new Locked() {\n\n                    protected Object run(Node node) throws RepositoryException {\n                        final Node eventNode = queryJob(mySession, info.jobId);\n                        if ( eventNode != null ) {\n                            try {\n                                eventNode.remove();\n                                parentNode.save();\n                            } catch (RepositoryException re) {\n                                // we ignore the exception if removing fails\n                                ignoreException(re);\n                            }\n                        }\n                        return null;\n                    }\n                }.with(parentNode, false);\n            } catch (RepositoryException re) {\n                this.logger.error(\"Unable to create a session.\", re);\n            } catch (InterruptedException e) {\n                 // This should never happen from the lock, so we ignore it\n                 this.ignoreException(e);\n            } finally {\n                if ( s != null ) {\n                    s.logout();\n                }\n            }\n        }\n    }","commit_id":"383f9ffb8eb91b1c99c30c22edd97bbeb272b15d","url":"https://github.com/apache/sling"},{"original_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link Textbox#service},\n\t * it also handles onOpen and onSelect.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_OPEN)) {\n\t\t\tOpenEvent evt = OpenEvent.getOpenEvent(request);\n\t\t\t_open = evt.isOpen();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_SELECT)) {\n\t\t\tfinal Set<Comboitem> prevSelectedItems = new LinkedHashSet<Comboitem>();\n\t\t\tComboitem prevSeld = (Comboitem) request.getDesktop().getComponentByUuidIfAny((String)request.getData().get(\"prevSeld\"));\n\t\t\t// ZK-2089: should skip when selected item is null \n\t\t\tif (prevSeld != null)\n\t\t\t\tprevSelectedItems.add(prevSeld);\n\t\t\tSelectEvent<Comboitem, Object> evt = SelectEvent.getSelectEvent(request, \n\t\t\t\t\tnew SelectEvent.SelectedObjectHandler<Comboitem>() {\n\t\t\t\tpublic Set<Object> getObjects(Set<Comboitem> items) {\n\t\t\t\t\tif (items == null || items.isEmpty() || _model == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tSet<Object> objs = new LinkedHashSet<Object>();\n\t\t\t\t\tfor (Comboitem i : items)\n\t\t\t\t\t\tobjs.add(_model.getElementAt(i.getIndex()));\n\t\t\t\t\treturn objs;\n\t\t\t\t}\n\n\t\t\t\tpublic Set<Comboitem> getPreviousSelectedItems() {\n\t\t\t\t\treturn prevSelectedItems;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// in single selection, getPreviousSelectedItems() is same as getPreviousSelectedItems()\n\t\t\t\tpublic Set<Comboitem> getUnselectedItems() {\n\t\t\t\t\treturn getPreviousSelectedItems();\n\t\t\t\t}\n\n\t\t\t\tpublic Set<Object> getPreviousSelectedObjects() {\n\t\t\t\t\tSet<Comboitem> items = getPreviousSelectedItems();\n\t\t\t\t\tif (_model == null || items.size() < 1)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\telse {\n\t\t\t\t\t\tSet<Object> s = new LinkedHashSet<Object>();\n\t\t\t\t\t\ts.add(_model.getElementAt(((Comboitem)items.iterator().next()).getIndex()));\n\t\t\t\t\t\treturn s;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// in single selection, getUnselectedObjects() is same as getPreviousSelectedObjects()\n\t\t\t\tpublic Set<Object> getUnselectedObjects() {\n\t\t\t\t\treturn getPreviousSelectedObjects();\n\t\t\t\t}\n\t\t\t});\n\t\t\tSet<Comboitem> selItems = evt.getSelectedItems();\n\t\t\t_selItem = selItems != null && !selItems.isEmpty() ? (Comboitem)selItems.iterator().next(): null;\n\n            //ZK-1987: Combobox item selection rely items label string\n            String newVal = \"\";\n            final Object oldVal = _value;\n            if (_selItem != null) {\n                newVal = _selItem.getLabel();\n                setValueDirectly(newVal);\n            }\n\t\t\t_lastCkVal = getValue();\n\t\t\tsyncSelectionToModel();\n            // For backward compatible, fire onChange before onSelect\n            Events.postEvent(new InputEvent(Events.ON_CHANGE, this, newVal, oldVal));\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_CHANGE)) {\n\t\t\tsuper.service(request, everError);\n\t\t\t// Bug ZK-1492: synchronize the input value to selection\n\t\t\t syncValueToSelection();\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","id":92962,"modified_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link Textbox#service},\n\t * it also handles onOpen and onSelect.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_OPEN)) {\n\t\t\tOpenEvent evt = OpenEvent.getOpenEvent(request);\n\t\t\t_open = evt.isOpen();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_SELECT)) {\n\t\t\tfinal Set<Comboitem> prevSelectedItems = new LinkedHashSet<Comboitem>();\n\t\t\tComboitem prevSeld = (Comboitem) request.getDesktop().getComponentByUuidIfAny((String)request.getData().get(\"prevSeld\"));\n\t\t\t// ZK-2089: should skip when selected item is null \n\t\t\tif (prevSeld != null)\n\t\t\t\tprevSelectedItems.add(prevSeld);\n\t\t\tSelectEvent<Comboitem, Object> evt = SelectEvent.getSelectEvent(request, \n\t\t\t\t\tnew SelectEvent.SelectedObjectHandler<Comboitem>() {\n\t\t\t\tpublic Set<Object> getObjects(Set<Comboitem> items) {\n\t\t\t\t\tif (items == null || items.isEmpty() || _model == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tSet<Object> objs = new LinkedHashSet<Object>();\n\t\t\t\t\tfor (Comboitem i : items)\n\t\t\t\t\t\tobjs.add(_model.getElementAt(i.getIndex()));\n\t\t\t\t\treturn objs;\n\t\t\t\t}\n\n\t\t\t\tpublic Set<Comboitem> getPreviousSelectedItems() {\n\t\t\t\t\treturn prevSelectedItems;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// in single selection, getPreviousSelectedItems() is same as getPreviousSelectedItems()\n\t\t\t\tpublic Set<Comboitem> getUnselectedItems() {\n\t\t\t\t\treturn getPreviousSelectedItems();\n\t\t\t\t}\n\n\t\t\t\tpublic Set<Object> getPreviousSelectedObjects() {\n\t\t\t\t\tSet<Comboitem> items = getPreviousSelectedItems();\n\t\t\t\t\tif (_model == null || items.size() < 1)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\telse {\n\t\t\t\t\t\tSet<Object> s = new LinkedHashSet<Object>();\n\t\t\t\t\t\ts.add(_model.getElementAt(((Comboitem)items.iterator().next()).getIndex()));\n\t\t\t\t\t\treturn s;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// in single selection, getUnselectedObjects() is same as getPreviousSelectedObjects()\n\t\t\t\tpublic Set<Object> getUnselectedObjects() {\n\t\t\t\t\treturn getPreviousSelectedObjects();\n\t\t\t\t}\n\t\t\t});\n\t\t\tComboitem oldSel = _selItem;\n\t\t\tSet<Comboitem> selItems = evt.getSelectedItems();\n\t\t\t_selItem = selItems != null && !selItems.isEmpty() ? (Comboitem)selItems.iterator().next(): null;\n\t\t\t_lastCkVal = getValue(); //onChange is sent before onSelect\n\n\t\t\tsyncSelectionToModel();\n\t\t\t//ZK-1987: Combobox item selection rely items label string\n\t\t\tString val = _lastCkVal;\n\t\t\tif (oldSel != null && !oldSel.equals(_selItem) && oldSel.getLabel().equals(val))\n\t\t\t\tEvents.postEvent(new InputEvent(Events.ON_CHANGE, this, val, val));\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_CHANGE)) {\n\t\t\tsuper.service(request, everError);\n\t\t\t// Bug ZK-1492: synchronize the input value to selection\n\t\t\t syncValueToSelection();\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","commit_id":"e81cb4996cc1418de8e2f393fcbfe02c46d65df3","url":"https://github.com/zkoss/zk"},{"original_method":"/** Post event to the non-stub ancestor. */\n\t/*package*/ void postToNonStubAncestor(StubEvent event) {\n\t\tComponent target = event.getTarget();\n\t\tfor (; target != null && (target instanceof Native\n\t\t|| target instanceof StubComponent); target = target.getParent())\n\t\t\t;\n\t\tEvents.postEvent(new StubEvent(event, target));\n\t}","id":92963,"modified_method":"/** Post event to the non-stub ancestor. */\n\t/*package*/ void postToNonStubAncestor(StubEvent event) {\n\t\tComponent target = event.getTarget();\n\t\tfor (; target != null && (target instanceof Native\n\t\t|| target instanceof StubComponent); target = target.getParent())\n\t\t\t;\n\t\tif (target != null)\n\t\t\tEvents.postEvent(new StubEvent(event, target));\n\t}","commit_id":"e23db4e8964af94025709c86823aba5d0ff9f490","url":"https://github.com/zkoss/zk"},{"original_method":"@Before\n  public void setUp() {\n    myBuilder = new ArrangementRuleEditingModelBuilder();\n    myRoot = new DefaultMutableTreeNode();\n    myTree = new Tree(myRoot);\n    myTree.expandPath(new TreePath(myRoot));\n    myRowMappings = new TIntObjectHashMap<ArrangementRuleEditingModelImpl>();\n    myGrouper = new JavaRearranger();\n  }","id":92964,"modified_method":"@Before\n  public void setUp() {\n    myBuilder = new ArrangementRuleEditingModelBuilder();\n    myRoot = new ArrangementTreeNode(null);\n    myTree = new Tree(myRoot);\n    myTree.expandPath(new TreePath(myRoot));\n    myRowMappings = new TIntObjectHashMap<ArrangementRuleEditingModelImpl>();\n    myGrouper = new JavaRearranger();\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param uiParentNode UI tree node which should hold UI nodes created for representing given settings node;\n   *                     <code>null<\/code> as an indication that we want to create a standalone nodes hierarchy\n   * @param settingsNode settings node which should be represented at the UI tree denoted by the given UI tree node\n   * @return             pair {@code (bottom-most leaf node created; number of rows created)}\n   */\n  @NotNull\n  public static Pair<DefaultMutableTreeNode, Integer> map(@Nullable DefaultMutableTreeNode uiParentNode,\n                                                          @NotNull HierarchicalArrangementSettingsNode settingsNode)\n  {\n    DefaultMutableTreeNode uiNode = null;\n    int rowsCreated = 0;\n    if (uiParentNode != null) {\n      for (int i = uiParentNode.getChildCount() - 1; i >= 0; i--) {\n        DefaultMutableTreeNode child = (DefaultMutableTreeNode)uiParentNode.getChildAt(i);\n        if (settingsNode.getCurrent().equals(child.getUserObject())) {\n          uiNode = child;\n          break;\n        }\n      }\n    }\n    if (uiNode == null) {\n      uiNode = new DefaultMutableTreeNode(settingsNode.getCurrent());\n      if (uiParentNode != null) {\n        uiParentNode.add(uiNode);\n      }\n      rowsCreated++;\n    }\n    DefaultMutableTreeNode leaf = uiNode;\n    HierarchicalArrangementSettingsNode childSettingsNode = settingsNode.getChild();\n    if (childSettingsNode != null) {\n      Pair<DefaultMutableTreeNode, Integer> pair = map(uiNode, childSettingsNode);\n      leaf = pair.first;\n      rowsCreated += pair.second;\n    }\n    return Pair.create(leaf, rowsCreated);\n  }","id":92965,"modified_method":"/**\n   * @param uiParentNode UI tree node which should hold UI nodes created for representing given settings node;\n   *                     <code>null<\/code> as an indication that we want to create a standalone nodes hierarchy\n   * @param settingsNode settings node which should be represented at the UI tree denoted by the given UI tree node\n   * @return             pair {@code (bottom-most leaf node created; number of rows created)}\n   */\n  @NotNull\n  public static Pair<ArrangementTreeNode, Integer> map(@Nullable ArrangementTreeNode uiParentNode,\n                                                       @NotNull HierarchicalArrangementSettingsNode settingsNode)\n  {\n    ArrangementTreeNode uiNode = null;\n    int rowsCreated = 0;\n    if (uiParentNode != null) {\n      for (int i = uiParentNode.getChildCount() - 1; i >= 0; i--) {\n        ArrangementTreeNode child = uiParentNode.getChildAt(i);\n        if (settingsNode.getCurrent().equals(child.getUserObject())) {\n          uiNode = child;\n          break;\n        }\n      }\n    }\n    if (uiNode == null) {\n      uiNode = new ArrangementTreeNode(settingsNode.getCurrent());\n      if (uiParentNode != null) {\n        uiParentNode.add(uiNode);\n      }\n      rowsCreated++;\n    }\n    ArrangementTreeNode leaf = uiNode;\n    HierarchicalArrangementSettingsNode childSettingsNode = settingsNode.getChild();\n    if (childSettingsNode != null) {\n      Pair<ArrangementTreeNode, Integer> pair = map(uiNode, childSettingsNode);\n      leaf = pair.first;\n      rowsCreated += pair.second;\n    }\n    return Pair.create(leaf, rowsCreated);\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Inserts given child to the given parent re-using existing nodes under the parent sub-hierarchy if possible (two nodes are\n   * considered equals if their {@link DefaultMutableTreeNode#getUserObject() user objects} are equal.\n   * <p/>\n   * Example:\n   * <pre>\n   *   parent:  0         to-insert: 2     \n   *            |_1                  |_3   \n   *            |_2                    |_6 \n   *            | |_3                      \n   *            |   |_4                    \n   *            |_5                        \n   *   -------------------------------------------------------------------------------------------------\n   *  | index:  |       0             |       1             |       2             |       3             |\n   *  |-------------------------------------------------------------------------------------------------\n   *  | result: |       0             |       0             |       0             |       0             |\n   *  |         |       |_2           |       |_1           |       |_1           |       |_1           |\n   *  |         |       | |_3         |       |_2           |       |_2           |       |_2           |\n   *  |         |       |   |_6       |       | |_3         |       | |_3         |       | |_3         |\n   *  |         |       |_1           |       |   |_6       |       |   |_4       |       |   |_4       |\n   *  |         |       |_2           |       |   |_4       |       |   |_6       |       |_5           |\n   *  |         |       | |_3         |       |_5           |       |_5           |       |_2           |\n   *  |         |       |   |_4       |                     |                     |         |_3         |\n   *  |         |       |_5           |                     |                     |           |_6       |\n   * <\/pre>\n   * <p/>\n   * \n   * @param parent     parent node to insert into\n   * @param index      insertion index to use for the given parent node\n   * @param child      node to insert to the given parent node at the given insertion index\n   * @param treeModel  model which should hold UI nodes\n   * @return           <code>true<\/code> if given child node has been merged to the existing node; <code>false<\/code> otherwise\n   */\n  public static boolean insert(@NotNull final DefaultMutableTreeNode parent,\n                               final int index,\n                               @NotNull final DefaultMutableTreeNode child,\n                               @NotNull DefaultTreeModel treeModel)\n  {\n    if (parent.getChildCount() < index) {\n      treeModel.insertNodeInto(child, parent, parent.getChildCount());\n      return false;\n    }\n\n    if (child.getChildCount() <= 0) {\n      // Don't merge the last child.\n      treeModel.insertNodeInto(child, parent, index);\n    }\n\n    boolean anchorAbove = false;\n    DefaultMutableTreeNode mergeCandidate = null;\n    if (index > 0) {\n      mergeCandidate = (DefaultMutableTreeNode)parent.getChildAt(index - 1);\n      if (!userDataEqual(mergeCandidate.getUserObject(), child.getUserObject())) {\n        mergeCandidate = null;\n      }\n    }\n\n    if (index < parent.getChildCount()) {\n      DefaultMutableTreeNode n = (DefaultMutableTreeNode)parent.getChildAt(index);\n      if (userDataEqual(n.getUserObject(), child.getUserObject())) {\n        mergeCandidate = n;\n        anchorAbove = true;\n      }\n    }\n\n    if (mergeCandidate == null) {\n      treeModel.insertNodeInto(child, parent, index);\n      return false;\n    }\n\n    for (int i = 0, limit = child.getChildCount(); i < limit; i++) {\n      insert(mergeCandidate, anchorAbove ? 0 : mergeCandidate.getChildCount(), (DefaultMutableTreeNode)child.getChildAt(0), treeModel);\n    }\n    return true;\n  }","id":92966,"modified_method":"/**\n   * Inserts given child to the given parent re-using existing nodes under the parent sub-hierarchy if possible.\n   * <p/>\n   * Example:\n   * <pre>\n   *   parent:  0         to-insert: 2     \n   *            |_1                  |_3   \n   *            |_2                    |_6 \n   *            | |_3                      \n   *            |   |_4                    \n   *            |_5                        \n   *   -------------------------------------------------------------------------------------------------\n   *  | index:  |       0             |       1             |       2             |       3             |\n   *  |-------------------------------------------------------------------------------------------------\n   *  | result: |       0             |       0             |       0             |       0             |\n   *  |         |       |_2           |       |_1           |       |_1           |       |_1           |\n   *  |         |       | |_3         |       |_2           |       |_2           |       |_2           |\n   *  |         |       |   |_6       |       | |_3         |       | |_3         |       | |_3         |\n   *  |         |       |_1           |       |   |_6       |       |   |_4       |       |   |_4       |\n   *  |         |       |_2           |       |   |_4       |       |   |_6       |       |_5           |\n   *  |         |       | |_3         |       |_5           |       |_5           |       |_2           |\n   *  |         |       |   |_4       |                     |                     |         |_3         |\n   *  |         |       |_5           |                     |                     |           |_6       |\n   * <\/pre>\n   * <p/>\n   * \n   * @param parent     parent node to insert into\n   * @param index      insertion index to use for the given parent node\n   * @param child      node to insert to the given parent node at the given insertion index\n   * @param treeModel  model which should hold UI nodes\n   * @return           <code>true<\/code> if given child node has been merged to the existing node; <code>false<\/code> otherwise\n   */\n  public static boolean insert(@NotNull final ArrangementTreeNode parent,\n                               final int index,\n                               @NotNull final ArrangementTreeNode child,\n                               @NotNull DefaultTreeModel treeModel)\n  {\n    if (parent.getChildCount() < index) {\n      treeModel.insertNodeInto(child, parent, parent.getChildCount());\n      return false;\n    }\n\n    if (child.getChildCount() <= 0) {\n      // Don't merge the last child.\n      treeModel.insertNodeInto(child, parent, index);\n    }\n\n    boolean anchorAbove = false;\n    ArrangementTreeNode mergeCandidate = null;\n    if (index > 0) {\n      mergeCandidate = parent.getChildAt(index - 1);\n      if (!mergeCandidate.equals(child)) {\n        mergeCandidate = null;\n      }\n    }\n\n    if (index < parent.getChildCount()) {\n      ArrangementTreeNode n = parent.getChildAt(index);\n      if (n.equals(child)) {\n        mergeCandidate = n;\n        anchorAbove = true;\n      }\n    }\n\n    if (mergeCandidate == null) {\n      treeModel.insertNodeInto(child, parent, index);\n      return false;\n    }\n\n    for (int i = 0, limit = child.getChildCount(); i < limit; i++) {\n      insert(mergeCandidate, anchorAbove ? 0 : mergeCandidate.getChildCount(), child.getChildAt(0), treeModel);\n    }\n    return true;\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Processes hierarchy denoted by the given node assuming that every node there contains information about its initial row\n   * (see {@link #markRows(DefaultMutableTreeNode)}).\n   * <p/>\n   * Collects all row changes and returns them. All row information is dropped from the nodes during the current method processing.\n   * \n   * @param node  reference to the target nodes hierarchy\n   * @return      collection of row changes at the form {@code 'old row -> new row'}\n   */\n  @NotNull\n  private static TIntIntHashMap collectRowChangesAndUnmark(@NotNull DefaultMutableTreeNode node) {\n    @NotNull TIntIntHashMap changes = new TIntIntHashMap();\n    DefaultMutableTreeNode root = getRoot(node);\n    int row = 0;\n    Stack<DefaultMutableTreeNode> nodes = new Stack<DefaultMutableTreeNode>();\n    nodes.push(root);\n    while (!nodes.isEmpty()) {\n      DefaultMutableTreeNode n = nodes.pop();\n      Object userObject = n.getUserObject();\n      if (userObject instanceof RowInfo) {\n        RowInfo rowInfo = (RowInfo)userObject;\n        if (rowInfo.row != row) {\n          changes.put(rowInfo.row, row);\n        }\n        n.setUserObject(rowInfo.userObject);\n      }\n      row++;\n      for (int i = n.getChildCount() - 1; i >= 0; i--) {\n        nodes.push((DefaultMutableTreeNode)n.getChildAt(i));\n      }\n    }\n    return changes;\n  }","id":92967,"modified_method":"/**\n   * Processes hierarchy denoted by the given node assuming that every node there contains information about its initial row\n   * (see {@link #markRows(ArrangementTreeNode)}).\n   * <p/>\n   * Collects all row changes and returns them. All row information is dropped from the nodes during the current method processing.\n   * \n   * @param node  reference to the target nodes hierarchy\n   * @return      collection of row changes at the form {@code 'old row -> new row'}\n   */\n  @NotNull\n  private static TIntIntHashMap collectRowChangesAndUnmark(@NotNull ArrangementTreeNode node) {\n    @NotNull TIntIntHashMap changes = new TIntIntHashMap();\n    ArrangementTreeNode root = getRoot(node);\n    int row = 0;\n    Stack<ArrangementTreeNode> nodes = new Stack<ArrangementTreeNode>();\n    nodes.push(root);\n    while (!nodes.isEmpty()) {\n      ArrangementTreeNode n = nodes.pop();\n      if (n.isRowSet() && n.getRow() != row) {\n        changes.put(n.getRow(), row);\n      }\n      n.resetRow();\n      row++;\n      for (int i = n.getChildCount() - 1; i >= 0; i--) {\n        nodes.push(n.getChildAt(i));\n      }\n    }\n    return changes;\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Utility method which helps to replace node sub-hierarchy identified by the given start and end nodes (inclusive) by\n   * a sub-hierarchy which is denoted by the given root. \n   * \n   * @param from         indicates start of the node sub-hierarchy to be replaced (inclusive)\n   * @param to           indicates end of the node sub-hierarchy to be replaced (inclusive)\n   * @param replacement  root of the node sub-hierarchy which should replace the one identified by the given 'start' and 'end' nodes\n   * @param treeModel    model which should hold ui nodes\n   * @return             collection of row changes at the form {@code 'old row -> new row'}\n   */\n  @SuppressWarnings(\"AssignmentToForLoopParameter\")\n  @NotNull\n  public static TIntIntHashMap replace(@NotNull DefaultMutableTreeNode from,\n                                       @NotNull DefaultMutableTreeNode to,\n                                       @NotNull DefaultMutableTreeNode replacement,\n                                       @NotNull DefaultTreeModel treeModel)\n  {\n    markRows(from);\n    if (from == to) {\n      DefaultMutableTreeNode parent = (DefaultMutableTreeNode)from.getParent();\n      int index = parent.getIndex(from);\n      treeModel.removeNodeFromParent(from);\n      treeModel.insertNodeInto(replacement, parent, index);\n      return collectRowChangesAndUnmark(parent);\n    }\n\n    // The algorithm looks as follows:\n    //   1. Cut sub-hierarchy which belongs to the given 'from' root and is located below the 'to -> from' path;\n    //   2. Remove 'to -> from' sub-hierarchy' by going bottom-up and stopping as soon as a current node has a child over than one\n    //      from the sub-hierarchy to remove;\n    //   3. Add 'replacement' sub-hierarchy starting after the 'from' index at its parent;\n    //   4. Add sub-hierarchy cut at the 1) starting after the 'replacement' sub-hierarchy index;\n    // Example:\n    //   Initial:\n    //      0\n    //      |_1\n    //        |_2\n    //        | |_3\n    //        | |_4\n    //        | |_5\n    //        |\n    //        |_6\n    //   Let's say we want to replace the sub-hierarchy '1 -> 2 -> 4' by the sub-hierarchy '1 -> 4'. The algorithm in action:\n    //     1. Cut bottom sub-hierarchy:\n    //         Current:      Cut:\n    //           0            1\n    //           |_1          |_2\n    //             |_2        | |_5\n    //               |_3      |\n    //               |_4      |_6\n    //\n    //     2. Remove target sub-hierarchy:\n    //         Current:  \n    //           0       \n    //           |_1     \n    //             |_2    <-- stop at this node because it has a child node '3' which doesn't belong to the '1 -> 2 -> 4'\n    //               |_3 \n    //     3. Add 'replacement' sub-hierarchy:\n    //         Current:  \n    //           0       \n    //           |_1    <-- re-use this node for '1 -> 4' addition\n    //             |_2    \n    //             | |_3\n    //             |\n    //             |_4\n    //     4. Add 'bottom' sub-hierarchy:\n    //         Current:  \n    //           0       \n    //           |_1    <-- re-use this node either for '1 -> 2 -> 5' or '1 -> 6' addition\n    //             |_2  \n    //             | |_3\n    //             |\n    //             |_4\n    //             |\n    //             |_2\n    //             | |_5\n    //             |\n    //             |_6\n    //\n    // Note: we need to have a notion of 'equal nodes' for node re-usage. It's provided by comparing node user objects.\n\n    final DefaultMutableTreeNode root = (DefaultMutableTreeNode)from.getParent();\n\n    //region Cut bottom sub-hierarchy\n    DefaultMutableTreeNode cutHierarchy = null;\n    for (DefaultMutableTreeNode current = to; current != root; current = (DefaultMutableTreeNode)current.getParent()) {\n      DefaultMutableTreeNode parent = (DefaultMutableTreeNode)current.getParent();\n      int i = parent.getIndex(current);\n      int childCount = parent.getChildCount();\n      if (i >= childCount - 1) {\n        continue;\n      }\n      DefaultMutableTreeNode parentCopy = new DefaultMutableTreeNode(\n        childCount > 0 ? extractUserObject(parent.getUserObject()) : parent.getUserObject()\n      );\n      if (cutHierarchy != null) {\n        parentCopy.add(cutHierarchy);\n      }\n      for (int j = i + 1; j < childCount; j++) {\n        DefaultMutableTreeNode child = (DefaultMutableTreeNode)parent.getChildAt(j);\n        treeModel.removeNodeFromParent(child);\n        // Unwrap node's data.\n        child.setUserObject(child.getChildCount() > 0 ? extractUserObject(child.getUserObject()) : child.getUserObject());\n        parentCopy.add(child);\n      }\n      cutHierarchy = parentCopy;\n    }\n    //endregion\n    \n    int insertionIndex = root.getIndex(from) + 1; \n    \n    //region Remove target sub-hierarchy\n    for (DefaultMutableTreeNode current = to; current != root;) {\n      DefaultMutableTreeNode parent = (DefaultMutableTreeNode)current.getParent();\n      treeModel.removeNodeFromParent(current);\n      current = parent;\n      if (current != to) {\n        current.setUserObject(extractUserObject(current.getUserObject()));\n      }\n      if (parent.getChildCount() > 0) {\n        break;\n      }\n    }\n    //endregion\n\n    //region Insert nodes.\n    boolean merged = insert(root, insertionIndex, replacement, treeModel);\n    if (cutHierarchy != null) {\n      insert(root, insertionIndex + (merged ? 0 : 1), cutHierarchy, treeModel);\n    }\n    //endregion\n    \n    return collectRowChangesAndUnmark(root);\n  }","id":92968,"modified_method":"/**\n   * Utility method which helps to replace node sub-hierarchy identified by the given start and end nodes (inclusive) by\n   * a sub-hierarchy which is denoted by the given root. \n   * \n   * @param from         indicates start of the node sub-hierarchy to be replaced (inclusive)\n   * @param to           indicates end of the node sub-hierarchy to be replaced (inclusive)\n   * @param replacement  root of the node sub-hierarchy which should replace the one identified by the given 'start' and 'end' nodes\n   * @param treeModel    model which should hold ui nodes\n   * @return             collection of row changes at the form {@code 'old row -> new row'}\n   */\n  @SuppressWarnings(\"AssignmentToForLoopParameter\")\n  @NotNull\n  public static TIntIntHashMap replace(@NotNull ArrangementTreeNode from,\n                                       @NotNull ArrangementTreeNode to,\n                                       @NotNull ArrangementTreeNode replacement,\n                                       @NotNull DefaultTreeModel treeModel)\n  {\n    markRows(from);\n    if (from == to) {\n      ArrangementTreeNode parent = from.getParent();\n      int index = parent.getIndex(from);\n      treeModel.removeNodeFromParent(from);\n      treeModel.insertNodeInto(replacement, parent, index);\n      return collectRowChangesAndUnmark(parent);\n    }\n\n    // The algorithm looks as follows:\n    //   1. Cut sub-hierarchy which belongs to the given 'from' root and is located below the 'to -> from' path;\n    //   2. Remove 'to -> from' sub-hierarchy' by going bottom-up and stopping as soon as a current node has a child over than one\n    //      from the sub-hierarchy to remove;\n    //   3. Add 'replacement' sub-hierarchy starting after the 'from' index at its parent;\n    //   4. Add sub-hierarchy cut at the 1) starting after the 'replacement' sub-hierarchy index;\n    // Example:\n    //   Initial:\n    //      0\n    //      |_1\n    //        |_2\n    //        | |_3\n    //        | |_4\n    //        | |_5\n    //        |\n    //        |_6\n    //   Let's say we want to replace the sub-hierarchy '1 -> 2 -> 4' by the sub-hierarchy '1 -> 4'. The algorithm in action:\n    //     1. Cut bottom sub-hierarchy:\n    //         Current:      Cut:\n    //           0            1\n    //           |_1          |_2\n    //             |_2        | |_5\n    //               |_3      |\n    //               |_4      |_6\n    //\n    //     2. Remove target sub-hierarchy:\n    //         Current:  \n    //           0       \n    //           |_1     \n    //             |_2    <-- stop at this node because it has a child node '3' which doesn't belong to the '1 -> 2 -> 4'\n    //               |_3 \n    //     3. Add 'replacement' sub-hierarchy:\n    //         Current:  \n    //           0       \n    //           |_1    <-- re-use this node for '1 -> 4' addition\n    //             |_2    \n    //             | |_3\n    //             |\n    //             |_4\n    //     4. Add 'bottom' sub-hierarchy:\n    //         Current:  \n    //           0       \n    //           |_1    <-- re-use this node either for '1 -> 2 -> 5' or '1 -> 6' addition\n    //             |_2  \n    //             | |_3\n    //             |\n    //             |_4\n    //             |\n    //             |_2\n    //             | |_5\n    //             |\n    //             |_6\n    //\n    // Note: we need to have a notion of 'equal nodes' for node re-usage. It's provided by comparing node user objects.\n\n    final ArrangementTreeNode root = from.getParent();\n\n    //region Cut bottom sub-hierarchy\n    ArrangementTreeNode cutHierarchy = null;\n    for (ArrangementTreeNode current = to; current != root; current = current.getParent()) {\n      ArrangementTreeNode parent = current.getParent();\n      int i = parent.getIndex(current);\n      int childCount = parent.getChildCount();\n      if (i >= childCount - 1) {\n        continue;\n      }\n      ArrangementTreeNode parentCopy = parent.copy();\n      if (parent.getChildCount() > 0) {\n        parentCopy.resetRow();\n      }\n      if (cutHierarchy != null) {\n        parentCopy.add(cutHierarchy);\n      }\n      for (int j = i + 1; j < childCount; j++) {\n        ArrangementTreeNode child = parent.getChildAt(j);\n        treeModel.removeNodeFromParent(child);\n        parentCopy.add(child);\n      }\n      cutHierarchy = parentCopy;\n    }\n    //endregion\n    \n    int insertionIndex = root.getIndex(from) + 1; \n    \n    //region Remove target sub-hierarchy\n    for (ArrangementTreeNode current = to; current != root;) {\n      ArrangementTreeNode parent = current.getParent();\n      treeModel.removeNodeFromParent(current);\n      current = parent;\n      if (parent.getChildCount() > 0) {\n        break;\n      }\n    }\n    //endregion\n\n    //region Insert nodes.\n    boolean merged = insert(root, insertionIndex, replacement, treeModel);\n    if (cutHierarchy != null) {\n      insert(root, insertionIndex + (merged ? 0 : 1), cutHierarchy, treeModel);\n    }\n    //endregion\n    \n    return collectRowChangesAndUnmark(root);\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static TreeNode getLastBefore(@NotNull TreeNode start, @NotNull TreeNode stop) throws IllegalArgumentException {\n    TreeNode result = start;\n    for (TreeNode n = start.getParent(); n != stop; n = n.getParent()) {\n      if (n == null) {\n        throw new IllegalArgumentException(String.format(\n          \"Non-crossing paths detected - start: %s, stop: %s\", new TreePath(start), new TreePath(stop)\n        ));\n      }\n      result = n;\n    }\n    return result;\n  }","id":92969,"modified_method":"@NotNull\n  public static ArrangementTreeNode getLastBefore(@NotNull ArrangementTreeNode start, @NotNull ArrangementTreeNode stop)\n    throws IllegalArgumentException\n  {\n    ArrangementTreeNode result = start;\n    for (ArrangementTreeNode n = start.getParent(); n != stop; n = n.getParent()) {\n      if (n == null) {\n        throw new IllegalArgumentException(String.format(\n          \"Non-crossing paths detected - start: %s, stop: %s\", new TreePath(start), new TreePath(stop)\n        ));\n      }\n      result = n;\n    }\n    return result;\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Does the following:\n   * <pre>\n   * <ol>\n   *   <li>\n   *     {@link HierarchicalArrangementSettingsNode Groups} given {@link ArrangementSettingsNode settings} using\n   *     the given {@link ArrangementSettingsGrouper#group(ArrangementSettingsNode) strategy};\n   *   <\/li>\n   *   <li>\n   *     Build {@link DefaultMutableTreeNode tree nodes} for the {@link HierarchicalArrangementSettingsNode groiping-aware nodes}\n   *     and register them within the target tree structure (denoted by the given settings root element);\n   *   <\/li>\n   *   <li>\n   *     Build necessary {@link ArrangementRuleEditingModel editing models} and store them at the given container (a key is a node row);\n   *   <\/li>\n   * <\/ol>\n   * <\/pre>\n   *\n   * @param setting     target settings to process\n   * @param tree        UI tree which shows arrangement matcher rules\n   * @param root        UI tree settings root to use (may be not the same as the tree root)\n   * @param grouper     strategy that knows how to\n   *                    {@link ArrangementStandardSettingsRepresentationAware#getDisplayValue(ArrangementModifier) group} setting\n   *                    nodes for UI representation\n   * @param rowMappings container to hold built {@link ArrangementRuleEditingModel editing models} (UI tree row numbers are used as keys)\n   */\n  @SuppressWarnings(\"MethodMayBeStatic\")\n  public void build(@NotNull ArrangementSettingsNode setting,\n                    @NotNull JTree tree,\n                    @NotNull DefaultMutableTreeNode root,\n                    @NotNull ArrangementSettingsGrouper grouper,\n                    @NotNull TIntObjectHashMap<ArrangementRuleEditingModelImpl> rowMappings)\n  {\n    int initialInsertRow = 0;\n    \n    // Count rows before the settings root.\n    for (TreeNode n = root.getParent(); n != null; n = n.getParent()) {\n      for (int i = n.getChildCount() - 1; i >= 0; i--) {\n        TreeNode child = n.getChildAt(i);\n        if (child != root) {\n          initialInsertRow += calculateRowsCount(child);\n        }\n      }\n      initialInsertRow++;\n    }\n    \n    // Count root width.\n    initialInsertRow += calculateRowsCount(root);\n    if (!tree.isRootVisible()) {\n      initialInsertRow--;\n    }\n\n    HierarchicalArrangementSettingsNode grouped = grouper.group(setting);\n    DefaultTreeModel treeModel = (DefaultTreeModel)tree.getModel();\n    Pair<DefaultMutableTreeNode, Integer> pair = ArrangementConfigUtil.map(root, grouped);\n    DefaultMutableTreeNode topMostNode = (DefaultMutableTreeNode)ArrangementConfigUtil.getLastBefore(pair.first, root);\n    int row = initialInsertRow + pair.second - 1;\n    ArrangementRuleEditingModelImpl model = new ArrangementRuleEditingModelImpl(\n      treeModel,\n      setting,\n      topMostNode,\n      pair.first,\n      grouper,\n      rowMappings,\n      row,\n      tree.isRootVisible() ? 0 : -1\n    );\n    rowMappings.put(row, model);\n  }","id":92970,"modified_method":"/**\n   * Does the following:\n   * <pre>\n   * <ol>\n   *   <li>\n   *     {@link HierarchicalArrangementSettingsNode Groups} given {@link ArrangementSettingsNode settings} using\n   *     the given {@link ArrangementSettingsGrouper#group(ArrangementSettingsNode) strategy};\n   *   <\/li>\n   *   <li>\n   *     Build {@link DefaultMutableTreeNode tree nodes} for the {@link HierarchicalArrangementSettingsNode groiping-aware nodes}\n   *     and register them within the target tree structure (denoted by the given settings root element);\n   *   <\/li>\n   *   <li>\n   *     Build necessary {@link ArrangementRuleEditingModel editing models} and store them at the given container (a key is a node row);\n   *   <\/li>\n   * <\/ol>\n   * <\/pre>\n   *\n   * @param setting     target settings to process\n   * @param tree        UI tree which shows arrangement matcher rules\n   * @param root        UI tree settings root to use (may be not the same as the tree root)\n   * @param grouper     strategy that knows how to\n   *                    {@link ArrangementStandardSettingsRepresentationAware#getDisplayValue(ArrangementModifier) group} setting\n   *                    nodes for UI representation\n   * @param rowMappings container to hold built {@link ArrangementRuleEditingModel editing models} (UI tree row numbers are used as keys)\n   */\n  @SuppressWarnings(\"MethodMayBeStatic\")\n  public void build(@NotNull ArrangementSettingsNode setting,\n                    @NotNull JTree tree,\n                    @NotNull ArrangementTreeNode root,\n                    @NotNull ArrangementSettingsGrouper grouper,\n                    @NotNull TIntObjectHashMap<ArrangementRuleEditingModelImpl> rowMappings)\n  {\n    int initialInsertRow = 0;\n    \n    // Count rows before the settings root.\n    for (TreeNode n = root.getParent(); n != null; n = n.getParent()) {\n      for (int i = n.getChildCount() - 1; i >= 0; i--) {\n        TreeNode child = n.getChildAt(i);\n        if (child != root) {\n          initialInsertRow += calculateRowsCount(child);\n        }\n      }\n      initialInsertRow++;\n    }\n    \n    // Count root width.\n    initialInsertRow += calculateRowsCount(root);\n    if (!tree.isRootVisible()) {\n      initialInsertRow--;\n    }\n\n    HierarchicalArrangementSettingsNode grouped = grouper.group(setting);\n    DefaultTreeModel treeModel = (DefaultTreeModel)tree.getModel();\n    Pair<ArrangementTreeNode, Integer> pair = ArrangementConfigUtil.map(root, grouped);\n    ArrangementTreeNode topMostNode = ArrangementConfigUtil.getLastBefore(pair.first, root);\n    int row = initialInsertRow + pair.second - 1;\n    ArrangementRuleEditingModelImpl model = new ArrangementRuleEditingModelImpl(\n      treeModel,\n      setting,\n      topMostNode,\n      pair.first,\n      grouper,\n      rowMappings,\n      row,\n      tree.isRootVisible() ? 0 : -1\n    );\n    rowMappings.put(row, model);\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void addToExistingLayer() {\n    myBuilder.build(and(atom(PUBLIC), atom(STATIC), atom(FIELD)), myTree, myRoot, myGrouper, myRowMappings);\n    myBuilder.build(and(atom(PRIVATE), atom(FIELD)), myTree, myRoot, myGrouper, myRowMappings);\n    \n    checkRows(2, 3);\n\n    DefaultMutableTreeNode fieldUiNode = (DefaultMutableTreeNode)myRoot.getFirstChild();\n    assertNotNull(fieldUiNode);\n    assertEquals(atom(FIELD), fieldUiNode.getUserObject());\n\n    DefaultMutableTreeNode publicStaticUiNode = (DefaultMutableTreeNode)fieldUiNode.getFirstChild();\n    assertNotNull(publicStaticUiNode);\n    assertEquals(and(atom(PUBLIC), atom(STATIC)), publicStaticUiNode.getUserObject());\n\n    DefaultMutableTreeNode privateUiNode = (DefaultMutableTreeNode)fieldUiNode.getLastChild();\n    assertNotNull(privateUiNode);\n    assertEquals(atom(PRIVATE), privateUiNode.getUserObject());\n  }","id":92971,"modified_method":"public void addToExistingLayer() {\n    myBuilder.build(and(atom(PUBLIC), atom(STATIC), atom(FIELD)), myTree, myRoot, myGrouper, myRowMappings);\n    myBuilder.build(and(atom(PRIVATE), atom(FIELD)), myTree, myRoot, myGrouper, myRowMappings);\n    \n    checkRows(2, 3);\n\n    ArrangementTreeNode fieldUiNode = myRoot.getFirstChild();\n    assertNotNull(fieldUiNode);\n    assertEquals(atom(FIELD), fieldUiNode.getBackingSetting());\n\n    ArrangementTreeNode publicStaticUiNode = fieldUiNode.getFirstChild();\n    assertNotNull(publicStaticUiNode);\n    assertEquals(and(atom(PUBLIC), atom(STATIC)), publicStaticUiNode.getBackingSetting());\n\n    ArrangementTreeNode privateUiNode = fieldUiNode.getLastChild();\n    assertNotNull(privateUiNode);\n    assertEquals(atom(PRIVATE), privateUiNode.getBackingSetting());\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void splitIntoTwoLayers() {\n    ArrangementSettingsNode settingsNode = and(atom(FIELD), atom(PUBLIC), atom(STATIC));\n    myBuilder.build(settingsNode, myTree, myRoot, myGrouper, myRowMappings);\n    \n    checkRows(2);\n    \n    DefaultMutableTreeNode fieldUiNode = (DefaultMutableTreeNode)myRoot.getFirstChild();\n    assertNotNull(fieldUiNode);\n    assertEquals(atom(FIELD), fieldUiNode.getUserObject());\n\n    DefaultMutableTreeNode modifiersUiNode = (DefaultMutableTreeNode)fieldUiNode.getFirstChild();\n    assertNotNull(modifiersUiNode);\n    assertEquals(and(atom(PUBLIC), atom(STATIC)), modifiersUiNode.getUserObject());\n  }","id":92972,"modified_method":"@Test\n  public void splitIntoTwoLayers() {\n    ArrangementSettingsNode settingsNode = and(atom(FIELD), atom(PUBLIC), atom(STATIC));\n    myBuilder.build(settingsNode, myTree, myRoot, myGrouper, myRowMappings);\n    \n    checkRows(2);\n\n    ArrangementTreeNode fieldUiNode = myRoot.getFirstChild();\n    assertNotNull(fieldUiNode);\n    assertEquals(atom(FIELD), fieldUiNode.getBackingSetting());\n\n    ArrangementTreeNode modifiersUiNode = fieldUiNode.getFirstChild();\n    assertNotNull(modifiersUiNode);\n    assertEquals(and(atom(PUBLIC), atom(STATIC)), modifiersUiNode.getBackingSetting());\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void mapToTheSameLayer() {\n    ArrangementSettingsNode settingsNode = and(atom(PUBLIC), atom(STATIC));\n    myBuilder.build(settingsNode, myTree, myRoot, myGrouper, myRowMappings);\n    checkRows(1);\n    ArrangementRuleEditingModel model = myRowMappings.get(1);\n    assertTrue(model.hasCondition(PUBLIC));\n    assertTrue(model.hasCondition(STATIC));\n    assertFalse(model.hasCondition(PRIVATE));\n    assertEquals(1, myRoot.getChildCount());\n    assertEquals(settingsNode, ((DefaultMutableTreeNode)myRoot.getFirstChild()).getUserObject());\n  }","id":92973,"modified_method":"@Test\n  public void mapToTheSameLayer() {\n    ArrangementSettingsNode settingsNode = and(atom(PUBLIC), atom(STATIC));\n    myBuilder.build(settingsNode, myTree, myRoot, myGrouper, myRowMappings);\n    checkRows(1);\n    ArrangementRuleEditingModel model = myRowMappings.get(1);\n    assertTrue(model.hasCondition(PUBLIC));\n    assertTrue(model.hasCondition(STATIC));\n    assertFalse(model.hasCondition(PRIVATE));\n    assertEquals(1, myRoot.getChildCount());\n    assertEquals(settingsNode, myRoot.getFirstChild().getBackingSetting());\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public DefaultMutableTreeNode getTopMost() {\n    return myTopMost;\n  }","id":92974,"modified_method":"@NotNull\n  public ArrangementTreeNode getTopMost() {\n    return myTopMost;\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void applyNewSetting(@NotNull ArrangementSettingsNode newNode) {\n    mySettingsNode = newNode;\n    HierarchicalArrangementSettingsNode grouped = myGrouper.group(newNode);\n    int newDepth = ArrangementConfigUtil.getDepth(grouped);\n    int oldDepth = ArrangementConfigUtil.distance(myTopMost, myBottomMost);\n    if (oldDepth == newDepth) {\n      myBottomMost.setUserObject(ArrangementConfigUtil.getLast(grouped).getCurrent());\n      return;\n    }\n\n    Pair<DefaultMutableTreeNode, Integer> replacement = ArrangementConfigUtil.map(null, grouped);\n    DefaultMutableTreeNode newBottom = replacement.first;\n    DefaultMutableTreeNode newTop = ArrangementConfigUtil.getRoot(newBottom);\n    final TIntIntHashMap rowChanges = ArrangementConfigUtil.replace(myTopMost, myBottomMost, newTop, myTreeModel);\n    myTopMost = newTop;\n    myBottomMost = newBottom;\n\n    final TIntObjectHashMap<ArrangementRuleEditingModelImpl> newMappings = new TIntObjectHashMap<ArrangementRuleEditingModelImpl>();\n\n    // Update model mappings.\n    myRowMappings.forEachEntry(new TIntObjectProcedure<ArrangementRuleEditingModelImpl>() {\n      @Override\n      public boolean execute(int row, ArrangementRuleEditingModelImpl model) {\n        if (row == myRow) {\n          return true;\n        }\n        if (rowChanges.containsKey(row - myRowShift)) {\n          newMappings.put(rowChanges.get(row - myRowShift) + myRowShift, model);\n        }\n        else {\n          newMappings.put(row, model);\n        }\n        model.refreshTreeNodes();\n        return true;\n      }\n    });\n    myRow = ArrangementConfigUtil.getRow(myBottomMost) + myRowShift;\n    newMappings.put(myRow, this);\n\n    myRowMappings.clear();\n    newMappings.forEachEntry(new TIntObjectProcedure<ArrangementRuleEditingModelImpl>() {\n      @Override\n      public boolean execute(int row, ArrangementRuleEditingModelImpl model) {\n        myRowMappings.put(row, model);\n        return true;\n      }\n    });\n  }","id":92975,"modified_method":"private void applyNewSetting(@NotNull ArrangementSettingsNode newNode) {\n    mySettingsNode = newNode;\n    HierarchicalArrangementSettingsNode grouped = myGrouper.group(newNode);\n    int newDepth = ArrangementConfigUtil.getDepth(grouped);\n    int oldDepth = ArrangementConfigUtil.distance(myTopMost, myBottomMost);\n    if (oldDepth == newDepth) {\n      myBottomMost.setSettings(ArrangementConfigUtil.getLast(grouped).getCurrent());\n      return;\n    }\n\n    Pair<ArrangementTreeNode, Integer> replacement = ArrangementConfigUtil.map(null, grouped);\n    ArrangementTreeNode newBottom = replacement.first;\n    ArrangementTreeNode newTop = ArrangementConfigUtil.getRoot(newBottom);\n    final TIntIntHashMap rowChanges = ArrangementConfigUtil.replace(myTopMost, myBottomMost, newTop, myTreeModel);\n    myTopMost = newTop;\n    myBottomMost = newBottom;\n\n    final TIntObjectHashMap<ArrangementRuleEditingModelImpl> newMappings = new TIntObjectHashMap<ArrangementRuleEditingModelImpl>();\n\n    // Update model mappings.\n    myRowMappings.forEachEntry(new TIntObjectProcedure<ArrangementRuleEditingModelImpl>() {\n      @Override\n      public boolean execute(int row, ArrangementRuleEditingModelImpl model) {\n        if (row == myRow) {\n          return true;\n        }\n        if (rowChanges.containsKey(row - myRowShift)) {\n          newMappings.put(rowChanges.get(row - myRowShift) + myRowShift, model);\n        }\n        else {\n          newMappings.put(row, model);\n        }\n        model.refreshTreeNodes();\n        return true;\n      }\n    });\n    myRow = ArrangementConfigUtil.getRow(myBottomMost) + myRowShift;\n    newMappings.put(myRow, this);\n\n    myRowMappings.clear();\n    newMappings.forEachEntry(new TIntObjectProcedure<ArrangementRuleEditingModelImpl>() {\n      @Override\n      public boolean execute(int row, ArrangementRuleEditingModelImpl model) {\n        myRowMappings.put(row, model);\n        return true;\n      }\n    });\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Creates new <code>ArrangementRuleEditingModelImpl<\/code> object.\n   *\n   * @param model      tree model which holds target ui nodes. Basically, we need to perform ui nodes modification via it in order\n   *                   to generate corresponding events automatically\n   * @param node       backing settings node\n   * @param topMost    there is a possible case that a single settings node is shown in more than one visual line\n *                     ({@link HierarchicalArrangementSettingsNode}). This argument is the top-most UI node used for the\n *                     settings node representation\n   * @param bottomMost bottom-most UI node used for the given settings node representation \n   * @param grouper    strategy that encapsulates information on how settings node should be displayed\n   * @param mappings   {@code 'row -> model'} mappings\n   * @param row        row number for which current model is registered at the given model mappings\n   * @param shift      specifies a shift to be applied to the node rows on model modification. Primary intention is to handle\n   */\n  public ArrangementRuleEditingModelImpl(@NotNull DefaultTreeModel model,\n                                         @NotNull ArrangementSettingsNode node,\n                                         @NotNull DefaultMutableTreeNode topMost,\n                                         @NotNull DefaultMutableTreeNode bottomMost,\n                                         @NotNull ArrangementSettingsGrouper grouper,\n                                         @NotNull TIntObjectHashMap<ArrangementRuleEditingModelImpl> mappings,\n                                         int row,\n                                         int shift)\n  {\n    myTreeModel = model;\n    mySettingsNode = node;\n    myTopMost = topMost;\n    myBottomMost = bottomMost;\n    myGrouper = grouper;\n    myRowMappings = mappings;\n    myRow = row;\n    myRowShift = shift;\n    refreshConditions();\n  }","id":92976,"modified_method":"/**\n   * Creates new <code>ArrangementRuleEditingModelImpl<\/code> object.\n   *\n   * @param model      tree model which holds target ui nodes. Basically, we need to perform ui nodes modification via it in order\n   *                   to generate corresponding events automatically\n   * @param node       backing settings node\n   * @param topMost    there is a possible case that a single settings node is shown in more than one visual line\n   *                     ({@link HierarchicalArrangementSettingsNode}). This argument is the top-most UI node used for the\n   *                     settings node representation\n   * @param bottomMost bottom-most UI node used for the given settings node representation \n   * @param grouper    strategy that encapsulates information on how settings node should be displayed\n   * @param mappings   {@code 'row -> model'} mappings\n   * @param row        row number for which current model is registered at the given model mappings\n   * @param shift      specifies a shift to be applied to the node rows on model modification. Primary intention is to handle\n   */\n  public ArrangementRuleEditingModelImpl(@NotNull DefaultTreeModel model,\n                                         @NotNull ArrangementSettingsNode node,\n                                         @NotNull ArrangementTreeNode topMost,\n                                         @NotNull ArrangementTreeNode bottomMost,\n                                         @NotNull ArrangementSettingsGrouper grouper,\n                                         @NotNull TIntObjectHashMap<ArrangementRuleEditingModelImpl> mappings,\n                                         int row,\n                                         int shift)\n  {\n    myTreeModel = model;\n    mySettingsNode = node;\n    myTopMost = topMost;\n    myBottomMost = bottomMost;\n    myGrouper = grouper;\n    myRowMappings = mappings;\n    myRow = row;\n    myRowShift = shift;\n    refreshConditions();\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * There is a possible case that tree nodes referenced by the current model become out of date due to a tree modification.\n   * <p/>\n   * This method asks the model to refresh its tree nodes if necessary.\n   */\n  public void refreshTreeNodes() {\n    for (DefaultMutableTreeNode node = myBottomMost; node != null; node = (DefaultMutableTreeNode)node.getParent()) {\n      if (node == myTopMost) {\n        // No refresh is necessary.\n        return;\n      }\n      else if (myTopMost.getUserObject().equals(node.getUserObject())) {\n        myTopMost = node;\n        return;\n      }\n    }\n    assert false;\n  }","id":92977,"modified_method":"/**\n   * There is a possible case that tree nodes referenced by the current model become out of date due to a tree modification.\n   * <p/>\n   * This method asks the model to refresh its tree nodes if necessary.\n   */\n  public void refreshTreeNodes() {\n    for (ArrangementTreeNode node = myBottomMost; node != null; node = node.getParent()) {\n      if (node == myTopMost) {\n        // No refresh is necessary.\n        return;\n      }\n      else if (myTopMost.getUserObject().equals(node.getUserObject())) {\n        myTopMost = node;\n        return;\n      }\n    }\n    assert false;\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public DefaultMutableTreeNode getBottomMost() {\n    return myBottomMost;\n  }","id":92978,"modified_method":"@NotNull\n  public ArrangementTreeNode getBottomMost() {\n    return myBottomMost;\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void removeLastRowConditionFromMultiChildrenParent() {\n    configure(and(atom(FIELD), atom(PUBLIC)));\n    configure(and(atom(FIELD), atom(STATIC)));\n\n    ArrangementRuleEditingModel siblingModel = myRowMappings.get(2);\n    assertNotNull(siblingModel);\n    \n    ArrangementRuleEditingModel modelToChange = myRowMappings.get(3);\n    assertNotNull(modelToChange);\n    assertEquals(2, myRowMappings.size());\n\n    modelToChange.removeAndCondition(atom(STATIC));\n\n    assertEquals(2, myRowMappings.size());\n    assertSame(siblingModel, myRowMappings.get(2));\n    assertEquals(and(atom(FIELD), atom(PUBLIC)), siblingModel.getSettingsNode());\n\n    assertSame(modelToChange, myRowMappings.get(3));\n    assertEquals(atom(FIELD), modelToChange.getSettingsNode());\n\n    DefaultMutableTreeNode compositeFieldNode = (DefaultMutableTreeNode)myRoot.getFirstChild();\n    assertNotNull(compositeFieldNode);\n    assertEquals(atom(FIELD), compositeFieldNode.getUserObject());\n\n    DefaultMutableTreeNode publicNode = (DefaultMutableTreeNode)compositeFieldNode.getFirstChild();\n    assertNotNull(publicNode);\n    assertEquals(atom(PUBLIC), publicNode.getUserObject());\n\n    DefaultMutableTreeNode atomFieldNode = compositeFieldNode.getNextSibling();\n    assertNotNull(atomFieldNode);\n    assertEquals(atom(FIELD), atomFieldNode.getUserObject());\n\n    checkTreeNodesConsistency();\n  }","id":92979,"modified_method":"public void removeLastRowConditionFromMultiChildrenParent() {\n    configure(and(atom(FIELD), atom(PUBLIC)));\n    configure(and(atom(FIELD), atom(STATIC)));\n\n    ArrangementRuleEditingModel siblingModel = myRowMappings.get(2);\n    assertNotNull(siblingModel);\n    \n    ArrangementRuleEditingModel modelToChange = myRowMappings.get(3);\n    assertNotNull(modelToChange);\n    assertEquals(2, myRowMappings.size());\n\n    modelToChange.removeAndCondition(atom(STATIC));\n\n    assertEquals(2, myRowMappings.size());\n    assertSame(siblingModel, myRowMappings.get(2));\n    assertEquals(and(atom(FIELD), atom(PUBLIC)), siblingModel.getSettingsNode());\n\n    assertSame(modelToChange, myRowMappings.get(3));\n    assertEquals(atom(FIELD), modelToChange.getSettingsNode());\n\n    ArrangementTreeNode compositeFieldNode = myRoot.getFirstChild();\n    assertNotNull(compositeFieldNode);\n    assertEquals(atom(FIELD), compositeFieldNode.getBackingSetting());\n\n    ArrangementTreeNode publicNode = compositeFieldNode.getFirstChild();\n    assertNotNull(publicNode);\n    assertEquals(atom(PUBLIC), publicNode.getUserObject());\n\n    ArrangementTreeNode atomFieldNode = compositeFieldNode.getNextSibling();\n    assertNotNull(atomFieldNode);\n    assertEquals(atom(FIELD), atomFieldNode.getBackingSetting());\n\n    checkTreeNodesConsistency();\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void removeAndKeepAllLevels() {\n    configure(and(atom(FIELD), atom(PUBLIC), atom(STATIC)));\n    ArrangementRuleEditingModel model = myRowMappings.get(2);\n    assertNotNull(model);\n    assertEquals(1, myRowMappings.size());\n    \n    model.removeAndCondition(atom(PUBLIC));\n\n    assertEquals(1, myRowMappings.size());\n    assertSame(model, myRowMappings.get(2));\n    assertEquals(and(atom(FIELD), atom(STATIC)), model.getSettingsNode());\n\n    DefaultMutableTreeNode fieldNode = (DefaultMutableTreeNode)myRoot.getFirstChild();\n    assertNotNull(fieldNode);\n    assertEquals(atom(FIELD), fieldNode.getUserObject());\n\n    DefaultMutableTreeNode modifiersNode = fieldNode.getFirstLeaf();\n    assertNotNull(modifiersNode);\n    assertEquals(atom(STATIC), modifiersNode.getUserObject());\n  }","id":92980,"modified_method":"@Test\n  public void removeAndKeepAllLevels() {\n    configure(and(atom(FIELD), atom(PUBLIC), atom(STATIC)));\n    ArrangementRuleEditingModel model = myRowMappings.get(2);\n    assertNotNull(model);\n    assertEquals(1, myRowMappings.size());\n    \n    model.removeAndCondition(atom(PUBLIC));\n\n    assertEquals(1, myRowMappings.size());\n    assertSame(model, myRowMappings.get(2));\n    assertEquals(and(atom(FIELD), atom(STATIC)), model.getSettingsNode());\n\n    ArrangementTreeNode fieldNode = myRoot.getFirstChild();\n    assertNotNull(fieldNode);\n    assertEquals(atom(FIELD), fieldNode.getBackingSetting());\n\n    ArrangementTreeNode modifiersNode = fieldNode.getFirstChild();\n    assertNotNull(modifiersNode);\n    assertEquals(atom(STATIC), modifiersNode.getBackingSetting());\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void buildNewSingleLevel() {\n    configure(atom(PUBLIC));\n    ArrangementRuleEditingModel model = myRowMappings.get(1);\n    assertNotNull(model);\n    assertEquals(1, myRowMappings.size());\n    \n    model.addAndCondition(atom(FIELD));\n\n    assertEquals(1, myRowMappings.size());\n    assertSame(model, myRowMappings.get(2));\n    assertEquals(and(atom(FIELD), atom(PUBLIC)), model.getSettingsNode());\n\n    DefaultMutableTreeNode fieldNode = (DefaultMutableTreeNode)myRoot.getFirstChild();\n    assertNotNull(fieldNode);\n    assertEquals(atom(FIELD), fieldNode.getUserObject());\n\n    DefaultMutableTreeNode publicNode = fieldNode.getFirstLeaf();\n    assertNotNull(publicNode);\n    assertEquals(atom(PUBLIC), publicNode.getUserObject());\n  }","id":92981,"modified_method":"@Test\n  public void buildNewSingleLevel() {\n    configure(atom(PUBLIC));\n    ArrangementRuleEditingModel model = myRowMappings.get(1);\n    assertNotNull(model);\n    assertEquals(1, myRowMappings.size());\n    \n    model.addAndCondition(atom(FIELD));\n\n    assertEquals(1, myRowMappings.size());\n    assertSame(model, myRowMappings.get(2));\n    assertEquals(and(atom(FIELD), atom(PUBLIC)), model.getSettingsNode());\n\n    ArrangementTreeNode fieldNode = myRoot.getFirstChild();\n    assertNotNull(fieldNode);\n    assertEquals(atom(FIELD), fieldNode.getBackingSetting());\n\n    ArrangementTreeNode publicNode = fieldNode.getFirstChild();\n    assertNotNull(publicNode);\n    assertEquals(atom(PUBLIC), publicNode.getBackingSetting());\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkTreeNodesConsistency() {\n    final Ref<DefaultMutableTreeNode> rootRef = new Ref<DefaultMutableTreeNode>();\n    myRowMappings.forEachValue(new TObjectProcedure<ArrangementRuleEditingModelImpl>() {\n      @Override\n      public boolean execute(ArrangementRuleEditingModelImpl model) {\n        DefaultMutableTreeNode root = ArrangementConfigUtil.getRoot(model.getTopMost());\n        assertSame(root, ArrangementConfigUtil.getRoot(model.getBottomMost()));\n\n        if (rootRef.get() == null) {\n          rootRef.set(root);\n        }\n        else {\n          assertSame(rootRef.get(), root);\n        }\n        return true;\n      }\n    });\n  }","id":92982,"modified_method":"private void checkTreeNodesConsistency() {\n    final Ref<DefaultMutableTreeNode> rootRef = new Ref<DefaultMutableTreeNode>();\n    myRowMappings.forEachValue(new TObjectProcedure<ArrangementRuleEditingModelImpl>() {\n      @Override\n      public boolean execute(ArrangementRuleEditingModelImpl model) {\n        ArrangementTreeNode root = ArrangementConfigUtil.getRoot(model.getTopMost());\n        assertSame(root, ArrangementConfigUtil.getRoot(model.getBottomMost()));\n\n        if (rootRef.get() == null) {\n          rootRef.set(root);\n        }\n        else {\n          assertSame(rootRef.get(), root);\n        }\n        return true;\n      }\n    });\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void removeLastRowCondition() {\n    configure(and(atom(FIELD), atom(PUBLIC)));\n    ArrangementRuleEditingModel model = myRowMappings.get(2);\n    assertNotNull(model);\n    assertEquals(1, myRowMappings.size());\n\n    model.removeAndCondition(atom(PUBLIC));\n\n    assertEquals(1, myRowMappings.size());\n    assertSame(model, myRowMappings.get(1));\n    assertEquals(atom(FIELD), model.getSettingsNode());\n\n    DefaultMutableTreeNode fieldNode = (DefaultMutableTreeNode)myRoot.getFirstChild();\n    assertNotNull(fieldNode);\n    assertEquals(atom(FIELD), fieldNode.getUserObject());\n    \n    assertEquals(0, fieldNode.getChildCount());\n  }","id":92983,"modified_method":"@Test\n  public void removeLastRowCondition() {\n    configure(and(atom(FIELD), atom(PUBLIC)));\n    ArrangementRuleEditingModel model = myRowMappings.get(2);\n    assertNotNull(model);\n    assertEquals(1, myRowMappings.size());\n\n    model.removeAndCondition(atom(PUBLIC));\n\n    assertEquals(1, myRowMappings.size());\n    assertSame(model, myRowMappings.get(1));\n    assertEquals(atom(FIELD), model.getSettingsNode());\n\n    ArrangementTreeNode fieldNode = myRoot.getFirstChild();\n    assertNotNull(fieldNode);\n    assertEquals(atom(FIELD), fieldNode.getBackingSetting());\n    \n    assertEquals(0, fieldNode.getChildCount());\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void removeFirstRowConditionFromMultiChildrenParent() {\n    configure(and(atom(FIELD), atom(PUBLIC)));\n    configure(and(atom(FIELD), atom(STATIC)));\n    \n    ArrangementRuleEditingModel modelToChange = myRowMappings.get(2);\n    assertNotNull(modelToChange);\n    \n    ArrangementRuleEditingModel siblingModel = myRowMappings.get(3);\n    assertNotNull(siblingModel);\n    assertEquals(2, myRowMappings.size());\n    \n    modelToChange.removeAndCondition(atom(PUBLIC));\n    \n    assertEquals(2, myRowMappings.size());\n    assertSame(modelToChange, myRowMappings.get(1));\n    assertEquals(atom(FIELD), modelToChange.getSettingsNode());\n    \n    assertSame(siblingModel, myRowMappings.get(3));\n    assertEquals(and(atom(FIELD), atom(STATIC)), siblingModel.getSettingsNode());\n    \n    DefaultMutableTreeNode atomFieldNode = (DefaultMutableTreeNode)myRoot.getFirstChild();\n    assertNotNull(atomFieldNode);\n    assertEquals(atom(FIELD), atomFieldNode.getUserObject());\n    \n    DefaultMutableTreeNode layeredFieldNode = atomFieldNode.getNextSibling();\n    assertNotNull(atomFieldNode);\n    assertEquals(atom(FIELD), atomFieldNode.getUserObject());\n    \n    DefaultMutableTreeNode staticNode = (DefaultMutableTreeNode)layeredFieldNode.getFirstChild();\n    assertNotNull(staticNode);\n    assertEquals(atom(STATIC), staticNode.getUserObject());\n    \n    checkTreeNodesConsistency();\n  }","id":92984,"modified_method":"public void removeFirstRowConditionFromMultiChildrenParent() {\n    configure(and(atom(FIELD), atom(PUBLIC)));\n    configure(and(atom(FIELD), atom(STATIC)));\n    \n    ArrangementRuleEditingModel modelToChange = myRowMappings.get(2);\n    assertNotNull(modelToChange);\n    \n    ArrangementRuleEditingModel siblingModel = myRowMappings.get(3);\n    assertNotNull(siblingModel);\n    assertEquals(2, myRowMappings.size());\n    \n    modelToChange.removeAndCondition(atom(PUBLIC));\n    \n    assertEquals(2, myRowMappings.size());\n    assertSame(modelToChange, myRowMappings.get(1));\n    assertEquals(atom(FIELD), modelToChange.getSettingsNode());\n    \n    assertSame(siblingModel, myRowMappings.get(3));\n    assertEquals(and(atom(FIELD), atom(STATIC)), siblingModel.getSettingsNode());\n\n    ArrangementTreeNode atomFieldNode = myRoot.getFirstChild();\n    assertNotNull(atomFieldNode);\n    assertEquals(atom(FIELD), atomFieldNode.getBackingSetting());\n\n    ArrangementTreeNode layeredFieldNode = atomFieldNode.getNextSibling();\n    assertNotNull(atomFieldNode);\n    assertEquals(atom(FIELD), atomFieldNode.getBackingSetting());\n\n    ArrangementTreeNode staticNode = layeredFieldNode.getFirstChild();\n    assertNotNull(staticNode);\n    assertEquals(atom(STATIC), staticNode.getBackingSetting());\n    \n    checkTreeNodesConsistency();\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void addConditionToSameNestedLevel() {\n    configure(and(atom(FIELD), atom(PUBLIC)));\n    ArrangementRuleEditingModel model = myRowMappings.get(2);\n    assertNotNull(model);\n    assertEquals(1, myRowMappings.size());\n    \n    model.addAndCondition(atom(STATIC));\n\n    assertEquals(1, myRowMappings.size());\n    assertSame(model, myRowMappings.get(2));\n    assertEquals(and(atom(FIELD), atom(PUBLIC), atom(STATIC)), model.getSettingsNode());\n\n    DefaultMutableTreeNode fieldNode = (DefaultMutableTreeNode)myRoot.getFirstChild();\n    assertNotNull(fieldNode);\n    assertEquals(atom(FIELD), fieldNode.getUserObject());\n\n    DefaultMutableTreeNode modifiersNode = fieldNode.getFirstLeaf();\n    assertNotNull(modifiersNode);\n    assertEquals(and(atom(PUBLIC), atom(STATIC)), modifiersNode.getUserObject());\n  }","id":92985,"modified_method":"@Test\n  public void addConditionToSameNestedLevel() {\n    configure(and(atom(FIELD), atom(PUBLIC)));\n    ArrangementRuleEditingModel model = myRowMappings.get(2);\n    assertNotNull(model);\n    assertEquals(1, myRowMappings.size());\n    \n    model.addAndCondition(atom(STATIC));\n\n    assertEquals(1, myRowMappings.size());\n    assertSame(model, myRowMappings.get(2));\n    assertEquals(and(atom(FIELD), atom(PUBLIC), atom(STATIC)), model.getSettingsNode());\n\n    ArrangementTreeNode fieldNode = myRoot.getFirstChild();\n    assertNotNull(fieldNode);\n    assertEquals(atom(FIELD), fieldNode.getBackingSetting());\n\n    ArrangementTreeNode modifiersNode = fieldNode.getFirstChild();\n    assertNotNull(modifiersNode);\n    assertEquals(and(atom(PUBLIC), atom(STATIC)), modifiersNode.getBackingSetting());\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void addConditionToSameLevel() {\n    configure(atom(PUBLIC));\n    ArrangementRuleEditingModel model = myRowMappings.get(1);\n    assertNotNull(model);\n    model.addAndCondition(atom(STATIC));\n\n    DefaultMutableTreeNode child = (DefaultMutableTreeNode)myRoot.getFirstChild();\n    assertNotNull(child);\n    ArrangementSettingsNode expectedSettingsNode = and(atom(PUBLIC), atom(STATIC));\n    assertEquals(expectedSettingsNode, child.getUserObject());\n    assertEquals(expectedSettingsNode, model.getSettingsNode());\n  }","id":92986,"modified_method":"@Test\n  public void addConditionToSameLevel() {\n    configure(atom(PUBLIC));\n    ArrangementRuleEditingModel model = myRowMappings.get(1);\n    assertNotNull(model);\n    model.addAndCondition(atom(STATIC));\n\n    ArrangementTreeNode child = myRoot.getFirstChild();\n    assertNotNull(child);\n    ArrangementSettingsNode expectedSettingsNode = and(atom(PUBLIC), atom(STATIC));\n    assertEquals(expectedSettingsNode, child.getBackingSetting());\n    assertEquals(expectedSettingsNode, model.getSettingsNode());\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ArrangementRuleTree(@NotNull ArrangementSettingsGrouper grouper, @NotNull ArrangementNodeDisplayManager displayManager) {\n    myFactory = new ArrangementNodeComponentFactory(displayManager);\n    DefaultMutableTreeNode root = new DefaultMutableTreeNode();\n    myTreeModel = new DefaultTreeModel(root);\n    myTree = new Tree(myTreeModel) {\n      @Override\n      protected void setExpandedState(TreePath path, boolean state) {\n        // Don't allow node collapse\n        if (state) {\n          super.setExpandedState(path, state);\n        }\n      }\n\n      @Override\n      protected boolean isAlwaysPaintRowBackground() {\n        return false;\n      }\n\n      @Override\n      protected void processMouseEvent(MouseEvent e) {\n        // JTree selects a node on mouse click at the same row (even outside the node bounds). We don't want to support\n        // such selection because selected nodes are highlighted at the rule tree, so, it produces a 'blink' effect.\n        mySkipSelectionChange = e.getClickCount() > 0 && getNodeComponentAt(e.getLocationOnScreen()) == null;\n        try {\n          super.processMouseEvent(e);\n          if (mySkipSelectionChange) {\n            notifySelectionListeners(null);\n          }\n        }\n        finally {\n          mySkipSelectionChange = false;\n        }\n      }\n    };\n    myTree.setSelectionModel(mySelectionModel);\n    myTree.setRootVisible(false);\n    mySelectionModel.addTreeSelectionListener(new TreeSelectionListener() {\n      @Override\n      public void valueChanged(TreeSelectionEvent e) {\n        setSelection(e.getOldLeadSelectionPath(), false);\n        setSelection(e.getNewLeadSelectionPath(), true);\n      }\n    });\n    myTree.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        onMouseClicked(e);\n      }\n    });\n    \n    List<ArrangementSettingsNode> rules = new ArrayList<ArrangementSettingsNode>();\n    rules.add(new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND)\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.TYPE, ArrangementEntryType.FIELD))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PUBLIC))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.STATIC))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.FINAL)));\n    rules.add(new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND)\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.TYPE, ArrangementEntryType.FIELD))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PRIVATE)));\n    rules.add(new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND)\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.TYPE, ArrangementEntryType.METHOD))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PUBLIC)));\n    rules.add(new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND)\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.TYPE, ArrangementEntryType.METHOD))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PRIVATE)));\n    map(root, rules, grouper);\n\n    expandAll(myTree, new TreePath(root));\n    myTree.setShowsRootHandles(false);\n    myTree.setCellRenderer(new MyCellRenderer());\n  }","id":92987,"modified_method":"public ArrangementRuleTree(@NotNull ArrangementSettingsGrouper grouper, @NotNull ArrangementNodeDisplayManager displayManager) {\n    myFactory = new ArrangementNodeComponentFactory(displayManager);\n    ArrangementTreeNode root = new ArrangementTreeNode(null);\n    myTreeModel = new DefaultTreeModel(root);\n    myTree = new Tree(myTreeModel) {\n      @Override\n      protected void setExpandedState(TreePath path, boolean state) {\n        // Don't allow node collapse\n        if (state) {\n          super.setExpandedState(path, state);\n        }\n      }\n\n      @Override\n      protected boolean isAlwaysPaintRowBackground() {\n        return false;\n      }\n\n      @Override\n      protected void processMouseEvent(MouseEvent e) {\n        // JTree selects a node on mouse click at the same row (even outside the node bounds). We don't want to support\n        // such selection because selected nodes are highlighted at the rule tree, so, it produces a 'blink' effect.\n        mySkipSelectionChange = e.getClickCount() > 0 && getNodeComponentAt(e.getLocationOnScreen()) == null;\n        try {\n          super.processMouseEvent(e);\n          if (mySkipSelectionChange) {\n            notifySelectionListeners(null);\n          }\n        }\n        finally {\n          mySkipSelectionChange = false;\n        }\n      }\n    };\n    myTree.setSelectionModel(mySelectionModel);\n    myTree.setRootVisible(false);\n    mySelectionModel.addTreeSelectionListener(new TreeSelectionListener() {\n      @Override\n      public void valueChanged(TreeSelectionEvent e) {\n        setSelection(e.getOldLeadSelectionPath(), false);\n        setSelection(e.getNewLeadSelectionPath(), true);\n      }\n    });\n    myTree.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        onMouseClicked(e);\n      }\n    });\n    \n    List<ArrangementSettingsNode> rules = new ArrayList<ArrangementSettingsNode>();\n    rules.add(new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND)\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.TYPE, ArrangementEntryType.FIELD))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PUBLIC))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.STATIC))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.FINAL)));\n    rules.add(new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND)\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.TYPE, ArrangementEntryType.FIELD))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PRIVATE)));\n    rules.add(new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND)\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.TYPE, ArrangementEntryType.METHOD))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PUBLIC)));\n    rules.add(new ArrangementSettingsCompositeNode(ArrangementSettingsCompositeNode.Operator.AND)\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.TYPE, ArrangementEntryType.METHOD))\n                .addOperand(new ArrangementSettingsAtomNode(ArrangementSettingType.MODIFIER, ArrangementModifier.PRIVATE)));\n    map(root, rules, grouper);\n\n    expandAll(myTree, new TreePath(root));\n    myTree.setShowsRootHandles(false);\n    myTree.setCellRenderer(new MyCellRenderer());\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void map(@NotNull DefaultMutableTreeNode root,\n                   @NotNull List<ArrangementSettingsNode> settings,\n                   @NotNull ArrangementSettingsGrouper grouper)\n  {\n    ArrangementRuleEditingModelBuilder builder = new ArrangementRuleEditingModelBuilder();\n    for (ArrangementSettingsNode setting : settings) {\n      builder.build(setting, myTree, root, grouper, myModels);\n    }\n    myModels.forEachValue(new TObjectProcedure<ArrangementRuleEditingModelImpl>() {\n      @Override\n      public boolean execute(ArrangementRuleEditingModelImpl model) {\n        model.addListener(myModelChangeListener); \n        return true;\n      }\n    });\n  }","id":92988,"modified_method":"private void map(@NotNull ArrangementTreeNode root,\n                   @NotNull List<ArrangementSettingsNode> settings,\n                   @NotNull ArrangementSettingsGrouper grouper)\n  {\n    ArrangementRuleEditingModelBuilder builder = new ArrangementRuleEditingModelBuilder();\n    for (ArrangementSettingsNode setting : settings) {\n      builder.build(setting, myTree, root, grouper, myModels);\n    }\n    myModels.forEachValue(new TObjectProcedure<ArrangementRuleEditingModelImpl>() {\n      @Override\n      public boolean execute(ArrangementRuleEditingModelImpl model) {\n        model.addListener(myModelChangeListener); \n        return true;\n      }\n    });\n  }","commit_id":"3a97ab097022c77aff8505f9088862c7377729a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static ResultMessage processStatement(CQLStatement statement,\n                                                  QueryState queryState,\n                                                  QueryOptions options)\n    throws RequestExecutionException, RequestValidationException\n    {\n        logger.trace(\"Process {} @CL.{}\", statement, options.getConsistency());\n        ClientState clientState = queryState.getClientState();\n        statement.checkAccess(clientState);\n        statement.validate(clientState);\n\n        ResultMessage result = statement.execute(queryState, options);\n        return result == null ? new ResultMessage.Void() : result;\n    }","id":92989,"modified_method":"private static ResultMessage processStatement(CQLStatement statement,\n                                                  QueryState queryState,\n                                                  QueryOptions options)\n    throws RequestExecutionException, RequestValidationException\n    {\n        logger.trace(\"Process {} @CL.{}\", statement, options.getConsistency());\n        ClientState clientState = queryState.getClientState();\n        statement.checkAccess(clientState);\n        statement.validate(clientState);\n\n        ResultMessage result = statement.execute(queryState, options);\n        return result == null ? new ResultMessage.Void() : result;\n    }","commit_id":"42b91d4453a3f7ac698c9a871c5d75fcbf8a578f","url":"https://github.com/apache/cassandra"},{"original_method":"public ResultMessage processPrepared(CQLStatement statement, QueryState queryState, QueryOptions options)\n    throws RequestExecutionException, RequestValidationException\n    {\n        List<ByteBuffer> variables = options.getValues();\n        // Check to see if there are any bound variables to verify\n        if (!(variables.isEmpty() && (statement.getBoundTerms() == 0)))\n        {\n            if (variables.size() != statement.getBoundTerms())\n                throw new InvalidRequestException(String.format(\"there were %d markers(?) in CQL but %d bound variables\",\n                                                                statement.getBoundTerms(),\n                                                                variables.size()));\n\n            // at this point there is a match in count between markers and variables that is non-zero\n\n            if (logger.isTraceEnabled())\n                for (int i = 0; i < variables.size(); i++)\n                    logger.trace(\"[{}] '{}'\", i+1, variables.get(i));\n        }\n\n        return processStatement(statement, queryState, options);\n    }","id":92990,"modified_method":"public ResultMessage processPrepared(CQLStatement statement, QueryState queryState, QueryOptions options)\n    throws RequestExecutionException, RequestValidationException\n    {\n        List<ByteBuffer> variables = options.getValues();\n        // Check to see if there are any bound variables to verify\n        if (!(variables.isEmpty() && (statement.getBoundTerms() == 0)))\n        {\n            if (variables.size() != statement.getBoundTerms())\n                throw new InvalidRequestException(String.format(\"there were %d markers(?) in CQL but %d bound variables\",\n                                                                statement.getBoundTerms(),\n                                                                variables.size()));\n\n            // at this point there is a match in count between markers and variables that is non-zero\n\n            if (logger.isTraceEnabled())\n                for (int i = 0; i < variables.size(); i++)\n                    logger.trace(\"[{}] '{}'\", i+1, variables.get(i));\n        }\n\n        metrics.executedPrepared.inc();\n        return processStatement(statement, queryState, options);\n    }","commit_id":"42b91d4453a3f7ac698c9a871c5d75fcbf8a578f","url":"https://github.com/apache/cassandra"},{"original_method":"private static ResultMessage.Prepared storePreparedStatement(String queryString, String keyspace, ParsedStatement.Prepared prepared, boolean forThrift)\n    throws InvalidRequestException\n    {\n        // Concatenate the current keyspace so we don't mix prepared statements between keyspace (#5352).\n        // (if the keyspace is null, queryString has to have a fully-qualified keyspace so it's fine.\n        String toHash = keyspace == null ? queryString : keyspace + queryString;\n        long statementSize = measure(prepared.statement);\n        // don't execute the statement if it's bigger than the allowed threshold\n        if (statementSize > MAX_CACHE_PREPARED_MEMORY)\n            throw new InvalidRequestException(String.format(\"Prepared statement of size %d bytes is larger than allowed maximum of %d bytes.\",\n                                                            statementSize,\n                                                            MAX_CACHE_PREPARED_MEMORY));\n\n        if (forThrift)\n        {\n            int statementId = toHash.hashCode();\n            thriftPreparedStatements.put(statementId, prepared.statement);\n            logger.trace(String.format(\"Stored prepared statement #%d with %d bind markers\",\n                                       statementId,\n                                       prepared.statement.getBoundTerms()));\n            return ResultMessage.Prepared.forThrift(statementId, prepared.boundNames);\n        }\n        else\n        {\n            MD5Digest statementId = MD5Digest.compute(toHash);\n            preparedStatements.put(statementId, prepared);\n            logger.trace(String.format(\"Stored prepared statement %s with %d bind markers\",\n                                       statementId,\n                                       prepared.statement.getBoundTerms()));\n            return new ResultMessage.Prepared(statementId, prepared);\n        }\n    }","id":92991,"modified_method":"private static ResultMessage.Prepared storePreparedStatement(String queryString, String keyspace, ParsedStatement.Prepared prepared, boolean forThrift)\n    throws InvalidRequestException\n    {\n        // Concatenate the current keyspace so we don't mix prepared statements between keyspace (#5352).\n        // (if the keyspace is null, queryString has to have a fully-qualified keyspace so it's fine.\n        String toHash = keyspace == null ? queryString : keyspace + queryString;\n        long statementSize = measure(prepared.statement);\n        // don't execute the statement if it's bigger than the allowed threshold\n        if (statementSize > MAX_CACHE_PREPARED_MEMORY)\n            throw new InvalidRequestException(String.format(\"Prepared statement of size %d bytes is larger than allowed maximum of %d bytes.\",\n                                                            statementSize,\n                                                            MAX_CACHE_PREPARED_MEMORY));\n        try\n        {\n            if (forThrift)\n            {\n                int statementId = toHash.hashCode();\n                thriftPreparedStatements.put(statementId, prepared.statement);\n                logger.trace(\"Stored prepared statement #{} with {} bind markers\",\n                        statementId,\n                        prepared.statement.getBoundTerms());\n                return ResultMessage.Prepared.forThrift(statementId, prepared.boundNames);\n            } else\n            {\n                MD5Digest statementId = MD5Digest.compute(toHash);\n                preparedStatements.put(statementId, prepared);\n                logger.trace(\"Stored prepared statement #{} with {} bind markers\",\n                        statementId,\n                        prepared.statement.getBoundTerms());\n                return new ResultMessage.Prepared(statementId, prepared);\n            }\n        } finally\n        {\n            metrics.activePreparedStatements.inc();\n        }\n    }","commit_id":"42b91d4453a3f7ac698c9a871c5d75fcbf8a578f","url":"https://github.com/apache/cassandra"},{"original_method":"public ResultMessage process(String queryString, QueryState queryState, QueryOptions options)\n    throws RequestExecutionException, RequestValidationException\n    {\n        ParsedStatement.Prepared p = getStatement(queryString, queryState.getClientState());\n        options.prepare(p.boundNames);\n        CQLStatement prepared = p.statement;\n        if (prepared.getBoundTerms() != options.getValues().size())\n            throw new InvalidRequestException(\"Invalid amount of bind variables\");\n\n        return processStatement(prepared, queryState, options);\n    }","id":92992,"modified_method":"public ResultMessage process(String queryString, QueryState queryState, QueryOptions options)\n    throws RequestExecutionException, RequestValidationException\n    {\n        ParsedStatement.Prepared p = getStatement(queryString, queryState.getClientState());\n        options.prepare(p.boundNames);\n        CQLStatement prepared = p.statement;\n        if (prepared.getBoundTerms() != options.getValues().size())\n            throw new InvalidRequestException(\"Invalid amount of bind variables\");\n\n        if (!queryState.getClientState().isInternal)\n            metrics.executedUnprepared.inc();\n\n        return processStatement(prepared, queryState, options);\n    }","commit_id":"42b91d4453a3f7ac698c9a871c5d75fcbf8a578f","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Resource initialization.\n     */\n    @Override\n    public void initialize() throws InitializationException\n    {\n        logger = Logger.getLogger(this.getClass().getName());\n\n        objectFactory = new ObjectFactory();\n\n        logger.log(\n                Level.FINE,\n                String.format(\"Resource %s initialized. Serving user: '%s'\\n\", getClass().getName(),\n                        Utils.getXWikiUser(componentManager)));\n    }","id":92993,"modified_method":"/**\n     * Resource initialization.\n     */\n    @Override\n    public void initialize() throws InitializationException\n    {\n        logger = java.util.logging.Logger.getLogger(this.getClass().getName());\n\n        objectFactory = new ObjectFactory();\n\n        this.slf4Jlogger.trace(\"Resource {} initialized. Serving user: '{}'\\n\", getClass().getName(),\n            Utils.getXWikiUser(componentManager));\n    }","commit_id":"d1d90a638d93790195705dd275df15f39ee64dcb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private boolean removePeer(PeerNode pn) {\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Removing \" + pn);\n\t\tboolean isInPeers = false;\n\t\tsynchronized(this) {\n\t\t\tfor(int i = 0; i < myPeers.length; i++) {\n\t\t\t\tif(myPeers[i] == pn)\n\t\t\t\t\tisInPeers = true;\n\t\t\t}\n\t\t\tif(pn instanceof DarknetPeerNode)\n\t\t\t\t((DarknetPeerNode) pn).removeExtraPeerDataDir();\n\t\t\tif(isInPeers) {\n\t\t\t\tint peerNodeStatus = pn.getPeerNodeStatus();\n\t\t\t\tif(pn.recordStatus())\n\t\t\t\t\tremovePeerNodeStatus(peerNodeStatus, pn, !isInPeers);\n\t\t\t\tString peerNodePreviousRoutingBackoffReason = pn.getPreviousBackoffReason();\n\t\t\t\tif(peerNodePreviousRoutingBackoffReason != null)\n\t\t\t\t\tremovePeerNodeRoutingBackoffReason(peerNodePreviousRoutingBackoffReason, pn);\n\n\t\t\t\t// removing from connectedPeers\n\t\t\t\tArrayList<PeerNode> a = new ArrayList<PeerNode>();\n\t\t\t\tfor(PeerNode mp : myPeers) {\n\t\t\t\t\tif((mp != pn) && mp.isConnected() && mp.isRealConnection())\n\t\t\t\t\t\ta.add(mp);\n\t\t\t\t}\n\n\t\t\t\tPeerNode[] newConnectedPeers = new PeerNode[a.size()];\n\t\t\t\tnewConnectedPeers = a.toArray(newConnectedPeers);\n\t\t\t\tconnectedPeers = newConnectedPeers;\n\n\t\t\t\t// removing from myPeers\n\t\t\t\tPeerNode[] newMyPeers = new PeerNode[myPeers.length - 1];\n\t\t\t\tint positionInNewArray = 0;\n\t\t\t\tfor(PeerNode mp : myPeers) {\n\t\t\t\t\tif(mp != pn) {\n\t\t\t\t\t\tnewMyPeers[positionInNewArray] = mp;\n\t\t\t\t\t\tpositionInNewArray++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmyPeers = newMyPeers;\n\n\t\t\t\tLogger.normal(this, \"Removed \" + pn);\n\t\t\t}\n\t\t}\n\t\tpn.onRemove();\n\t\tif(isInPeers)\n\t\t\tupdatePMUserAlert();\n\t\tnotifyPeerStatusChangeListeners();\n\t\treturn true;\n\t}","id":92994,"modified_method":"private boolean removePeer(PeerNode pn) {\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Removing \" + pn);\n\t\tboolean isInPeers = false;\n\t\tsynchronized(this) {\n\t\t\tfor(int i = 0; i < myPeers.length; i++) {\n\t\t\t\tif(myPeers[i] == pn)\n\t\t\t\t\tisInPeers = true;\n\t\t\t}\n\t\t\tif(pn instanceof DarknetPeerNode)\n\t\t\t\t((DarknetPeerNode) pn).removeExtraPeerDataDir();\n\t\t\tif(isInPeers) {\n\t\t\t\tint peerNodeStatus = pn.getPeerNodeStatus();\n\t\t\t\tif(pn.recordStatus())\n\t\t\t\t\tremovePeerNodeStatus(peerNodeStatus, pn, !isInPeers);\n\t\t\t\tString peerNodePreviousRoutingBackoffReason = pn.getPreviousBackoffReason();\n\t\t\t\tif(peerNodePreviousRoutingBackoffReason != null)\n\t\t\t\t\tremovePeerNodeRoutingBackoffReason(peerNodePreviousRoutingBackoffReason, pn);\n\n\t\t\t\t// removing from connectedPeers\n\t\t\t\tArrayList<PeerNode> a = new ArrayList<PeerNode>();\n\t\t\t\tfor(PeerNode mp : myPeers) {\n\t\t\t\t\tif((mp != pn) && mp.isConnected() && mp.isRealConnection())\n\t\t\t\t\t\ta.add(mp);\n\t\t\t\t}\n\n\t\t\t\tPeerNode[] newConnectedPeers = new PeerNode[a.size()];\n\t\t\t\tnewConnectedPeers = a.toArray(newConnectedPeers);\n\t\t\t\tconnectedPeers = newConnectedPeers;\n\n\t\t\t\t// removing from myPeers\n\t\t\t\tPeerNode[] newMyPeers = new PeerNode[myPeers.length - 1];\n\t\t\t\tint positionInNewArray = 0;\n\t\t\t\tfor(PeerNode mp : myPeers) {\n\t\t\t\t\tif(mp != pn) {\n\t\t\t\t\t\tnewMyPeers[positionInNewArray] = mp;\n\t\t\t\t\t\tpositionInNewArray++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmyPeers = newMyPeers;\n\n\t\t\t\tLogger.normal(this, \"Removed \" + pn);\n\t\t\t}\n\t\t}\n\t\tpn.onRemove();\n\t\tif(isInPeers && !pn.isSeed())\n\t\t\tupdatePMUserAlert();\n\t\tnotifyPeerStatusChangeListeners();\n\t\treturn true;\n\t}","commit_id":"8afde0d5036f7f7d1fb44d76bd88013e2922830a","url":"https://github.com/freenet/fred"},{"original_method":"public void addConnectedPeer(PeerNode pn) {\n\t\tif(!pn.isRealConnection()) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Not a real connection: \" + pn);\n\t\t\treturn;\n\t\t}\n\t\tif(!pn.isConnected()) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Not connected: \" + pn);\n\t\t\treturn;\n\t\t}\n\t\tlong now = System.currentTimeMillis();\n\t\tsynchronized(this) {\n\t\t\tif(timeFirstAnyConnections == 0)\n\t\t\t\ttimeFirstAnyConnections = now;\n\t\t\tfor(int i = 0; i < connectedPeers.length; i++) {\n\t\t\t\tif(connectedPeers[i] == pn) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Already connected: \" + pn);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean inMyPeers = false;\n\t\t\tfor(int i = 0; i < myPeers.length; i++) {\n\t\t\t\tif(myPeers[i] == pn) {\n\t\t\t\t\tinMyPeers = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!inMyPeers) {\n\t\t\t\tLogger.error(this, \"Connecting to \" + pn + \" but not in peers!\");\n\t\t\t\taddPeer(pn);\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Connecting: \" + pn);\n\t\t\tPeerNode[] newConnectedPeers = new PeerNode[connectedPeers.length + 1];\n\t\t\tSystem.arraycopy(connectedPeers, 0, newConnectedPeers, 0, connectedPeers.length);\n\t\t\tnewConnectedPeers[connectedPeers.length] = pn;\n\t\t\tconnectedPeers = newConnectedPeers;\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Connected peers: \" + connectedPeers.length);\n\t\t}\n\t\tupdatePMUserAlert();\n\t\tnode.lm.announceLocChange();\n\t}","id":92995,"modified_method":"public void addConnectedPeer(PeerNode pn) {\n\t\tif(!pn.isRealConnection()) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Not a real connection: \" + pn);\n\t\t\treturn;\n\t\t}\n\t\tif(!pn.isConnected()) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Not connected: \" + pn);\n\t\t\treturn;\n\t\t}\n\t\tlong now = System.currentTimeMillis();\n\t\tsynchronized(this) {\n\t\t\tif(timeFirstAnyConnections == 0)\n\t\t\t\ttimeFirstAnyConnections = now;\n\t\t\tfor(int i = 0; i < connectedPeers.length; i++) {\n\t\t\t\tif(connectedPeers[i] == pn) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Already connected: \" + pn);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean inMyPeers = false;\n\t\t\tfor(int i = 0; i < myPeers.length; i++) {\n\t\t\t\tif(myPeers[i] == pn) {\n\t\t\t\t\tinMyPeers = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!inMyPeers) {\n\t\t\t\tLogger.error(this, \"Connecting to \" + pn + \" but not in peers!\");\n\t\t\t\taddPeer(pn);\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Connecting: \" + pn);\n\t\t\tPeerNode[] newConnectedPeers = new PeerNode[connectedPeers.length + 1];\n\t\t\tSystem.arraycopy(connectedPeers, 0, newConnectedPeers, 0, connectedPeers.length);\n\t\t\tnewConnectedPeers[connectedPeers.length] = pn;\n\t\t\tconnectedPeers = newConnectedPeers;\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Connected peers: \" + connectedPeers.length);\n\t\t}\n\t\tif(!pn.isSeed())\n                    updatePMUserAlert();\n\t\tnode.lm.announceLocChange();\n\t}","commit_id":"8afde0d5036f7f7d1fb44d76bd88013e2922830a","url":"https://github.com/freenet/fred"},{"original_method":"public boolean disconnected(PeerNode pn) {\n\t\tsynchronized(this) {\n\t\t\tboolean isInPeers = false;\n\t\t\tfor(int i = 0; i < connectedPeers.length; i++) {\n\t\t\t\tif(connectedPeers[i] == pn)\n\t\t\t\t\tisInPeers = true;\n\t\t\t}\n\t\t\tif(!isInPeers)\n\t\t\t\treturn false;\n\t\t\t// removing from connectedPeers\n\t\t\tArrayList<PeerNode> a = new ArrayList<PeerNode>();\n\t\t\tfor(PeerNode mp : myPeers) {\n\t\t\t\tif((mp != pn) && mp.isRoutable())\n\t\t\t\t\ta.add(mp);\n\t\t\t}\n\t\t\tPeerNode[] newConnectedPeers = new PeerNode[a.size()];\n\t\t\tnewConnectedPeers = a.toArray(newConnectedPeers);\n\t\t\tconnectedPeers = newConnectedPeers;\n\t\t}\n\t\tupdatePMUserAlert();\n\t\tnode.lm.announceLocChange();\n\t\treturn true;\n\t}","id":92996,"modified_method":"public boolean disconnected(PeerNode pn) {\n\t\tsynchronized(this) {\n\t\t\tboolean isInPeers = false;\n\t\t\tfor(int i = 0; i < connectedPeers.length; i++) {\n\t\t\t\tif(connectedPeers[i] == pn)\n\t\t\t\t\tisInPeers = true;\n\t\t\t}\n\t\t\tif(!isInPeers)\n\t\t\t\treturn false;\n\t\t\t// removing from connectedPeers\n\t\t\tArrayList<PeerNode> a = new ArrayList<PeerNode>();\n\t\t\tfor(PeerNode mp : myPeers) {\n\t\t\t\tif((mp != pn) && mp.isRoutable())\n\t\t\t\t\ta.add(mp);\n\t\t\t}\n\t\t\tPeerNode[] newConnectedPeers = new PeerNode[a.size()];\n\t\t\tnewConnectedPeers = a.toArray(newConnectedPeers);\n\t\t\tconnectedPeers = newConnectedPeers;\n\t\t}\n                if(!pn.isSeed())\n                    updatePMUserAlert();\n\t\tnode.lm.announceLocChange();\n\t\treturn true;\n\t}","commit_id":"8afde0d5036f7f7d1fb44d76bd88013e2922830a","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Add a peer.\n\t * @param pn The node to add to the routing table.\n\t * @param ignoreOpennet If true, don't check for opennet peers. If false, check for opennet peers and if so,\n\t * if opennet is enabled auto-add them to the opennet LRU, otherwise fail.\n\t * @param reactivate If true, re-enable the peer if it is in state DISCONNECTING before re-adding it.\n\t * @return True if the node was successfully added. False if it was already present, or if we tried to add\n\t * an opennet peer when opennet was disabled.\n\t */\n\tboolean addPeer(PeerNode pn, boolean ignoreOpennet, boolean reactivate) {\n\t\tassert (pn != null);\n\t\tif(reactivate)\n\t\t\tpn.forceCancelDisconnecting();\n\t\tsynchronized(this) {\n\t\t\tfor(int i = 0; i < myPeers.length; i++) {\n\t\t\t\tif(myPeers[i].equals(pn)) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Can't add peer \" + pn + \" because already have \" + myPeers[i], new Exception(\"debug\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPeerNode[] newMyPeers = new PeerNode[myPeers.length + 1];\n\t\t\tSystem.arraycopy(myPeers, 0, newMyPeers, 0, myPeers.length);\n\t\t\tnewMyPeers[myPeers.length] = pn;\n\t\t\tmyPeers = newMyPeers;\n\t\t\tLogger.normal(this, \"Added \" + pn);\n\t\t}\n\t\tif(pn.recordStatus())\n\t\t\taddPeerNodeStatus(pn.getPeerNodeStatus(), pn, false);\n\t\tpn.setPeerNodeStatus(System.currentTimeMillis());\n\t\tupdatePMUserAlert();\n\t\tif((!ignoreOpennet) && pn instanceof OpennetPeerNode) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet != null)\n\t\t\t\topennet.forceAddPeer(pn, true);\n\t\t\telse {\n\t\t\t\tLogger.error(this, \"Adding opennet peer when no opennet enabled!!!: \" + pn + \" - removing...\");\n\t\t\t\tremovePeer(pn);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tnotifyPeerStatusChangeListeners();\n\t\treturn true;\n\t}","id":92997,"modified_method":"/**\n\t * Add a peer.\n\t * @param pn The node to add to the routing table.\n\t * @param ignoreOpennet If true, don't check for opennet peers. If false, check for opennet peers and if so,\n\t * if opennet is enabled auto-add them to the opennet LRU, otherwise fail.\n\t * @param reactivate If true, re-enable the peer if it is in state DISCONNECTING before re-adding it.\n\t * @return True if the node was successfully added. False if it was already present, or if we tried to add\n\t * an opennet peer when opennet was disabled.\n\t */\n\tboolean addPeer(PeerNode pn, boolean ignoreOpennet, boolean reactivate) {\n\t\tassert (pn != null);\n\t\tif(reactivate)\n\t\t\tpn.forceCancelDisconnecting();\n\t\tsynchronized(this) {\n\t\t\tfor(int i = 0; i < myPeers.length; i++) {\n\t\t\t\tif(myPeers[i].equals(pn)) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Can't add peer \" + pn + \" because already have \" + myPeers[i], new Exception(\"debug\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPeerNode[] newMyPeers = new PeerNode[myPeers.length + 1];\n\t\t\tSystem.arraycopy(myPeers, 0, newMyPeers, 0, myPeers.length);\n\t\t\tnewMyPeers[myPeers.length] = pn;\n\t\t\tmyPeers = newMyPeers;\n\t\t\tLogger.normal(this, \"Added \" + pn);\n\t\t}\n\t\tif(pn.recordStatus())\n\t\t\taddPeerNodeStatus(pn.getPeerNodeStatus(), pn, false);\n\t\tpn.setPeerNodeStatus(System.currentTimeMillis());\n\t\tif(!pn.isSeed())\n                    updatePMUserAlert();\n\t\tif((!ignoreOpennet) && pn instanceof OpennetPeerNode) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet != null)\n\t\t\t\topennet.forceAddPeer(pn, true);\n\t\t\telse {\n\t\t\t\tLogger.error(this, \"Adding opennet peer when no opennet enabled!!!: \" + pn + \" - removing...\");\n\t\t\t\tremovePeer(pn);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tnotifyPeerStatusChangeListeners();\n\t\treturn true;\n\t}","commit_id":"8afde0d5036f7f7d1fb44d76bd88013e2922830a","url":"https://github.com/freenet/fred"},{"original_method":"private void writePeersInner() {\n\t\tString darknet = null;\n\t\tString opennet = null;\n\t\tString oldOpennetPeers = null;\n\t\tString oldOpennetPeersFilename = null;\n\t\t\n\t\tsynchronized(writePeersSync) {\n\t\t\tif(darkFilename != null)\n\t\t\t\tdarknet = getDarknetPeersString();\n\t\t\tOpennetManager om = node.getOpennet();\n\t\t\tif(om != null) {\n\t\t\t\tif(openFilename != null)\n\t\t\t\t\topennet = getOpennetPeersString();\n\t\t\t\toldOpennetPeersFilename = om.getOldPeersFilename();\n\t\t\t\toldOpennetPeers = getOldOpennetPeersString(om);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsynchronized(writePeerFileSync) {\n\t\t\tif(darknet != null)\n\t\t\t\twritePeersInner(darkFilename, darknet);\n\t\t\tif(oldOpennetPeers != null) {\n\t\t\t\tif(opennet != null)\n\t\t\t\t\twritePeersInner(openFilename, opennet);\n\t\t\t\twritePeersInner(oldOpennetPeersFilename, oldOpennetPeers);\n\t\t\t}\n\t\t}\n\t}","id":92998,"modified_method":"private void writePeersInner() {\n\t\tString darknet = null;\n\t\tString opennet = null;\n\t\tString oldOpennetPeers = null;\n\n\t\t\n\t\tsynchronized(writePeersSync) {\n\t\t\tif(darkFilename != null)\n\t\t\t\tdarknet = getDarknetPeersString();\n\t\t\tOpennetManager om = node.getOpennet();\n\t\t\tif(om != null) {\n\t\t\t\tif(openFilename != null)\n\t\t\t\t\topennet = getOpennetPeersString();\n\t\t\t\toldOpennetPeersFilename = om.getOldPeersFilename();\n\t\t\t\toldOpennetPeers = getOldOpennetPeersString(om);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsynchronized(writePeerFileSync) {\n\t\t\tif(darknet != null)\n\t\t\t\twritePeersInner(darkFilename, darknet);\n\t\t\tif(oldOpennetPeers != null) {\n\t\t\t\tif(opennet != null)\n\t\t\t\t\twritePeersInner(openFilename, opennet);\n\t\t\t\twritePeersInner(oldOpennetPeersFilename, oldOpennetPeers);\n\t\t\t}\n\t\t}\n\t}","commit_id":"8afde0d5036f7f7d1fb44d76bd88013e2922830a","url":"https://github.com/freenet/fred"},{"original_method":"ManagedProcess(final ProcessManagerMaster master, final String processName, final List<String> command, final Map<String, String> env, final String workingDirectory) {\n        this.master = master;\n        this.processName = processName;\n        this.command = command;\n        this.env = env;\n        this.workingDirectory = workingDirectory;\n    }","id":92999,"modified_method":"ManagedProcess(final ProcessManagerMaster master, final String processName, final List<String> command, final Map<String, String> env, final String workingDirectory) {\n        this.master = master;\n        this.processName = processName;\n        this.command = command;\n        this.env = env;\n        this.workingDirectory = workingDirectory;\n        this.log = Logger.getLogger(\"org.jboss.process.\" + processName);\n    }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"}]