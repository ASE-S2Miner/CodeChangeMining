[{"original_method":"public boolean isEntityReadOnly(EOEntity e) {\n        return _entityContext.valueForKey(\"readOnly\")==D2WModel.One || e.isReadOnly() || D2WUtils.readOnlyEntityNames(_entityContext).containsObject(e.name());\n      }","id":29000,"modified_method":"public boolean isEntityReadOnly(EOEntity e) {\n        return ERXValueUtilities.booleanValue(_entityContext.valueForKey(\"readOnly\")) || e.isReadOnly() || D2WUtils.readOnlyEntityNames(_entityContext).containsObject(e.name());\n      }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent newObjectAction() {\n        WOComponent nextPage=null;\n        EOEntity entity=EOModelGroup.defaultGroup().entityNamed(_manipulatedEntityName);\n        EOClassDescription aClassDesc=entity.classDescriptionForInstances();\n        if (isEntityReadOnly(entity)) {\n            ErrorPageInterface api=D2W.factory().errorPage(session());\n            api.setMessage(\"<b>You can not create new instances of \"+_manipulatedEntityName+\"<\/b><br><br>It is read-only.\");\n            api.setNextPage(context().page());\n            nextPage=(WOComponent)api;\n        } else {\n            EOEditingContext peerContext=ERXExtensions.newEditingContext(session().defaultEditingContext().parentObjectStore());\n            EOEnterpriseObject aNewEO=(EOEnterpriseObject)aClassDesc.createInstanceWithEditingContext(peerContext, null);\n            peerContext.insertObject(aNewEO);\n            try {\n                if (_manipulatedEntityName.equals(\"TestItem\")) {\n                    epi=(EditPageInterface)D2W.factory().pageForConfigurationNamed(\"EditNewTestItem\",session());\n\n                    EOEnterpriseObject localUser=EOUtilities.localInstanceOfObject(aNewEO.editingContext(),\n                                                                                   ((Session)session()).getUser());\n                    aNewEO.addObjectToBothSidesOfRelationshipWithKey(localUser,\"owner\");                    \n                    }else if (_manipulatedEntityName.equals(\"Bug\")) {\n                        epi=(EditPageInterface)D2W.factory().pageForConfigurationNamed(\"EditNewBug\",session());\n                        EOEnterpriseObject localUser=EOUtilities.localInstanceOfObject(aNewEO.editingContext(),\n                                                                                       ((Session)session()).getUser());\n                        aNewEO.addObjectToBothSidesOfRelationshipWithKey(localUser,\"originator\");\n                    }else if (_manipulatedEntityName.equals(\"Requirement\")) {\n                            epi=(EditPageInterface)D2W.factory().pageForConfigurationNamed(\"EditNewRequirement\",session());\n                            EOEnterpriseObject localUser=EOUtilities.localInstanceOfObject(aNewEO.editingContext(),\n                                                                                           ((Session)session()).getUser());\n                            aNewEO.addObjectToBothSidesOfRelationshipWithKey(localUser,\"originator\"); }\n                    else\n                    epi=D2W.factory().editPageForEntityNamed(_manipulatedEntityName, session());\n                    epi.setObject(aNewEO);\n                    epi.setNextPage(context().page());\n                    nextPage=(WOComponent)epi;\n            } catch (IllegalArgumentException e) {\n                ErrorPageInterface epf=D2W.factory().errorPage(session());\n                epf.setMessage(e.toString());\n                epf.setNextPage(context().page());\n                nextPage=(WOComponent)epf;\n            }\n        }\n        return nextPage;\n    }","id":29001,"modified_method":"public WOComponent newObjectAction() {\n        WOComponent nextPage=null;\n        EOEntity entity=EOModelGroup.defaultGroup().entityNamed(_manipulatedEntityName);\n        EOClassDescription aClassDesc=entity.classDescriptionForInstances();\n        if (isEntityReadOnly(entity)) {\n            ErrorPageInterface api=D2W.factory().errorPage(session());\n            api.setMessage(\"<b>You can not create new instances of \"+_manipulatedEntityName+\"<\/b><br><br>It is read-only.\");\n            api.setNextPage(context().page());\n            nextPage=(WOComponent)api;\n        } else {\n            EOEditingContext peerContext=ERXExtensions.newEditingContext(session().defaultEditingContext().parentObjectStore());\n            peerContext.lock();\n            try {\n                EOEnterpriseObject aNewEO=(EOEnterpriseObject)aClassDesc.createInstanceWithEditingContext(peerContext, null);\n                peerContext.insertObject(aNewEO);\n                if (_manipulatedEntityName.equals(\"TestItem\")) {\n                    epi=(EditPageInterface)D2W.factory().pageForConfigurationNamed(\"EditNewTestItem\",session());\n\n                    EOEnterpriseObject localUser=EOUtilities.localInstanceOfObject(aNewEO.editingContext(), ((Session)session()).getUser());\n                    aNewEO.addObjectToBothSidesOfRelationshipWithKey(localUser,\"owner\");\n                } else if (_manipulatedEntityName.equals(\"Bug\")) {\n                    epi=(EditPageInterface)D2W.factory().pageForConfigurationNamed(\"EditNewBug\",session());\n                    EOEnterpriseObject localUser=EOUtilities.localInstanceOfObject(aNewEO.editingContext(), ((Session)session()).getUser());\n                    aNewEO.addObjectToBothSidesOfRelationshipWithKey(localUser,\"originator\");\n                } else if (_manipulatedEntityName.equals(\"Requirement\")) {\n                    epi=(EditPageInterface)D2W.factory().pageForConfigurationNamed(\"EditNewRequirement\",session());\n                    EOEnterpriseObject localUser=EOUtilities.localInstanceOfObject(aNewEO.editingContext(), ((Session)session()).getUser());\n                    aNewEO.addObjectToBothSidesOfRelationshipWithKey(localUser,\"originator\");\n                } else {\n                    epi=D2W.factory().editPageForEntityNamed(_manipulatedEntityName, session());\n                }\n                epi.setObject(aNewEO);\n                epi.setNextPage(context().page());\n                nextPage=(WOComponent)epi;\n            } catch (IllegalArgumentException e) {\n                ErrorPageInterface epf=D2W.factory().errorPage(session());\n                epf.setMessage(e.toString());\n                epf.setNextPage(context().page());\n                nextPage=(WOComponent)epf;\n            } finally {\n                peerContext.unlock();\n            }\n        }\n        return nextPage;\n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSArray directtowebfiles(){\n        if(_directtowebfiles == null){\n            _directtowebfiles = Framework.frameworkClazz().orderedFrameworks(ec);\n        }\n        return _directtowebfiles;\n    }","id":29002,"modified_method":"public NSArray directtowebfiles(){\n        if(_directtowebfiles == null){\n            _directtowebfiles = Framework.clazz.orderedFrameworks(ec);\n        }\n        return _directtowebfiles;\n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Session() {\n        super();\n        /* ** Put your per-session initialization code here ** */\n        ERXExtensions.setDefaultDelegate(defaultEditingContext());\n        //defaultEditingContext().setTimestamp();\n    }","id":29003,"modified_method":"public Session() {\n        super();\n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void  setDefaultEditingContext(EOEditingContext newEc) {\n        super.setDefaultEditingContext(newEc);\n        log.debug(\"Set default EditingContext: \" + newEc.getClass().getName());\n    }","id":29004,"modified_method":"public void  setDefaultEditingContext(EOEditingContext newEc) {\n        super.setDefaultEditingContext(newEc);\n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static Map oagisMessageHandler(DispatchContext ctx, Map context) {\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        InputStream in = (InputStream) context.get(\"inputStream\");\n        List errorList = FastList.newInstance();\n        \n        Document doc = null;\n        String xmlText = null;\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(in, \"UTF-8\"));\n            StringBuffer xmlTextBuf = new StringBuffer();\n            String currentLine = null;\n            while ((currentLine = br.readLine()) != null) {\n                xmlTextBuf.append(currentLine);\n                xmlTextBuf.append('\\n');\n            }\n            xmlText = xmlTextBuf.toString();\n            \n            // DEJ20070804 adding this temporarily for debugging, should be changed to verbose at some point in the future\n            Debug.logWarning(\"Received OAGIS XML message, here is the text: \\n\" + xmlText, module);\n\n            ByteArrayInputStream bis = new ByteArrayInputStream(xmlText.getBytes(\"UTF-8\"));\n            doc = UtilXml.readXmlDocument(bis, true, \"OagisMessage\");\n        } catch (SAXException e) {\n            String errMsg = \"XML Error parsing the Received Message [\" + e.toString() + \"]; The text received we could not parse is: [\" + xmlText + \"]\";\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SAXException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (ParserConfigurationException e) {\n            String errMsg = \"Parser Configuration Error parsing the Received Message: \" + e.toString();\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ParserConfigurationException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (IOException e) {\n            String errMsg = \"IO Error parsing the Received Message: \" + e.toString();\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IOException\"));\n            Debug.logError(e, errMsg, module);\n        }\n\n        if (UtilValidate.isNotEmpty(errorList)) {\n            return ServiceUtil.returnError(\"Unable to parse received message\");\n        }\n\n        Element rootElement = doc.getDocumentElement();\n        rootElement.normalize();\n        Element controlAreaElement = UtilXml.firstChildElement(rootElement, \"os:CNTROLAREA\");\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"os:BSR\");\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\");\n        \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"os:SENDER\");\n        String logicalId = UtilXml.childElementValue(senderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(senderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(senderElement, \"of:TASK\");\n        String referenceId = UtilXml.childElementValue(senderElement, \"of:REFERENCEID\");\n        \n        if (UtilValidate.isEmpty(bsrVerb) || UtilValidate.isEmpty(bsrNoun)) {\n            return ServiceUtil.returnError(\"Was able to receive and parse the XML message, but BSR->NOUN [\" + bsrNoun + \"] and/or BSR->VERB [\" + bsrVerb + \"] are empty\");\n        }\n        \n        GenericValue oagisMessageInfo = null;\n        try {\n            oagisMessageInfo = delegator.findByPrimaryKey(\"OagisMessageInfo\", UtilMisc.toMap(\"logicalId\", logicalId, \"component\", component, \"task\", task, \"referenceId\", referenceId));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error Getting Entity OagisMessageInfo: \"+e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        Map subServiceResult = FastMap.newInstance();\n        if (UtilValidate.isEmpty(oagisMessageInfo)) {\n            if (bsrVerb.equalsIgnoreCase(\"CONFIRM\") && bsrNoun.equalsIgnoreCase(\"BOD\")) {\n                try {\n                    subServiceResult = dispatcher.runSync(\"receiveConfirmBod\", UtilMisc.toMap(\"document\",doc));\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service receiveConfirmBod: \"+e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"SHOW\") && bsrNoun.equalsIgnoreCase(\"SHIPMENT\")) {\n                try {\n                    subServiceResult = dispatcher.runSync(\"showShipment\", UtilMisc.toMap(\"document\",doc));\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service showShipment: \"+e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"SYNC\") && bsrNoun.equalsIgnoreCase(\"INVENTORY\")) {\n                try {\n                    subServiceResult = dispatcher.runSync(\"syncInventory\", UtilMisc.toMap(\"document\",doc));\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service syncInventory: \"+e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"ACKNOWLEDGE\") && bsrNoun.equalsIgnoreCase(\"DELIVERY\")) {\n                Element dataAreaElement = UtilXml.firstChildElement(rootElement, \"ns:DATAAREA\");\n                Element ackDeliveryElement = UtilXml.firstChildElement(dataAreaElement, \"ns:ACKNOWLEDGE_DELIVERY\");\n                Element receiptlnElement = UtilXml.firstChildElement(ackDeliveryElement, \"ns:RECEIPTLN\");\n                Element docRefElement = UtilXml.firstChildElement(receiptlnElement, \"os:DOCUMNTREF\");\n                String docType = UtilXml.childElementValue(docRefElement, \"of:DOCTYPE\");\n                if (\"PO\".equals(docType)){\n                    try {\n                        subServiceResult = dispatcher.runSync(\"receivePoAcknowledge\", UtilMisc.toMap(\"document\",doc));\n                    } catch (GenericServiceException e) {\n                        String errMsg = \"Error running service receivePoAcknowledge: \"+e.toString();\n                        errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                        Debug.logError(e, errMsg, module);\n                    }\n                } else if (\"RMA\".equals(docType)) {\n                    try {\n                        subServiceResult = dispatcher.runSync(\"receiveRmaAcknowledge\", UtilMisc.toMap(\"document\",doc));\n                    } catch (GenericServiceException e) {\n                        String errMsg = \"Error running service receiveRmaAcknowledge: \"+e.toString();\n                        errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                        Debug.logError(e, errMsg, module);\n                    }\n                } else {\n                    return ServiceUtil.returnError(\"For Acknowledge Delivery message could not determine if it is for a PO or RMA. DOCTYPE from message is \" + docType);\n                }\n            } else {\n                String errMsg = \"Unknown Message Received\";\n                Debug.logError(errMsg, module);\n                return ServiceUtil.returnError(errMsg);\n            }\n        } else {\n            String errMsg = \"Message has been already received\";\n            Debug.logError(errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        }\n        \n        Map result = ServiceUtil.returnSuccess();\n        result.putAll(subServiceResult);\n        result.put(\"contentType\", \"text/plain\");\n\n        List errorMapList = (List) subServiceResult.get(\"errorMapList\");\n        if (UtilValidate.isNotEmpty(errorList)) {\n            Iterator errListItr = errorList.iterator();\n            while (errListItr.hasNext()) {\n                Map errorMap = (Map) errListItr.next();\n                errorMapList.add(UtilMisc.toMap(\"description\", errorMap.get(\"description\"), \"reasonCode\", errorMap.get(\"reasonCode\")));\n            }\n            result.put(\"errorMapList\", errorMapList);\n        }\n        \n        return result;\n    }","id":29005,"modified_method":"public static Map oagisMessageHandler(DispatchContext ctx, Map context) {\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        InputStream in = (InputStream) context.get(\"inputStream\");\n        List errorList = FastList.newInstance();\n        \n        Document doc = null;\n        String xmlText = null;\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(in, \"UTF-8\"));\n            StringBuffer xmlTextBuf = new StringBuffer();\n            String currentLine = null;\n            while ((currentLine = br.readLine()) != null) {\n                xmlTextBuf.append(currentLine);\n                xmlTextBuf.append('\\n');\n            }\n            xmlText = xmlTextBuf.toString();\n            \n            // DEJ20070804 adding this temporarily for debugging, should be changed to verbose at some point in the future\n            Debug.logWarning(\"Received OAGIS XML message, here is the text: \\n\" + xmlText, module);\n\n            ByteArrayInputStream bis = new ByteArrayInputStream(xmlText.getBytes(\"UTF-8\"));\n            doc = UtilXml.readXmlDocument(bis, true, \"OagisMessage\");\n        } catch (SAXException e) {\n            String errMsg = \"XML Error parsing the Received Message [\" + e.toString() + \"]; The text received we could not parse is: [\" + xmlText + \"]\";\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SAXException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (ParserConfigurationException e) {\n            String errMsg = \"Parser Configuration Error parsing the Received Message: \" + e.toString();\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ParserConfigurationException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (IOException e) {\n            String errMsg = \"IO Error parsing the Received Message: \" + e.toString();\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IOException\"));\n            Debug.logError(e, errMsg, module);\n        }\n\n        if (UtilValidate.isNotEmpty(errorList)) {\n            return ServiceUtil.returnError(\"Unable to parse received message\");\n        }\n\n        Element rootElement = doc.getDocumentElement();\n        rootElement.normalize();\n        Element controlAreaElement = UtilXml.firstChildElement(rootElement, \"os:CNTROLAREA\");\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"os:BSR\");\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\");\n        \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"os:SENDER\");\n        String logicalId = UtilXml.childElementValue(senderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(senderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(senderElement, \"of:TASK\");\n        String referenceId = UtilXml.childElementValue(senderElement, \"of:REFERENCEID\");\n        \n        if (UtilValidate.isEmpty(bsrVerb) || UtilValidate.isEmpty(bsrNoun)) {\n            return ServiceUtil.returnError(\"Was able to receive and parse the XML message, but BSR->NOUN [\" + bsrNoun + \"] and/or BSR->VERB [\" + bsrVerb + \"] are empty\");\n        }\n        \n        GenericValue oagisMessageInfo = null;\n        try {\n            oagisMessageInfo = delegator.findByPrimaryKey(\"OagisMessageInfo\", UtilMisc.toMap(\"logicalId\", logicalId, \"component\", component, \"task\", task, \"referenceId\", referenceId));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error Getting Entity OagisMessageInfo: \"+e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        Map subServiceResult = FastMap.newInstance();\n        if (UtilValidate.isEmpty(oagisMessageInfo)) {\n            if (bsrVerb.equalsIgnoreCase(\"CONFIRM\") && bsrNoun.equalsIgnoreCase(\"BOD\")) {\n                try {\n                    subServiceResult = dispatcher.runSync(\"receiveConfirmBod\", UtilMisc.toMap(\"document\",doc));\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service receiveConfirmBod: \"+e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"SHOW\") && bsrNoun.equalsIgnoreCase(\"SHIPMENT\")) {\n                try {\n                    //subServiceResult = dispatcher.runSync(\"showShipment\", UtilMisc.toMap(\"document\",doc));\n                    // DEJ20070808 changed to run asynchronously and persisted so that if it fails it will retry\n                    dispatcher.runAsync(\"showShipment\", UtilMisc.toMap(\"document\",doc), true);\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service showShipment: \"+e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"SYNC\") && bsrNoun.equalsIgnoreCase(\"INVENTORY\")) {\n                try {\n                    subServiceResult = dispatcher.runSync(\"syncInventory\", UtilMisc.toMap(\"document\",doc));\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service syncInventory: \"+e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"ACKNOWLEDGE\") && bsrNoun.equalsIgnoreCase(\"DELIVERY\")) {\n                Element dataAreaElement = UtilXml.firstChildElement(rootElement, \"ns:DATAAREA\");\n                Element ackDeliveryElement = UtilXml.firstChildElement(dataAreaElement, \"ns:ACKNOWLEDGE_DELIVERY\");\n                Element receiptlnElement = UtilXml.firstChildElement(ackDeliveryElement, \"ns:RECEIPTLN\");\n                Element docRefElement = UtilXml.firstChildElement(receiptlnElement, \"os:DOCUMNTREF\");\n                String docType = UtilXml.childElementValue(docRefElement, \"of:DOCTYPE\");\n                if (\"PO\".equals(docType)){\n                    try {\n                        subServiceResult = dispatcher.runSync(\"receivePoAcknowledge\", UtilMisc.toMap(\"document\",doc));\n                    } catch (GenericServiceException e) {\n                        String errMsg = \"Error running service receivePoAcknowledge: \"+e.toString();\n                        errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                        Debug.logError(e, errMsg, module);\n                    }\n                } else if (\"RMA\".equals(docType)) {\n                    try {\n                        subServiceResult = dispatcher.runSync(\"receiveRmaAcknowledge\", UtilMisc.toMap(\"document\",doc));\n                    } catch (GenericServiceException e) {\n                        String errMsg = \"Error running service receiveRmaAcknowledge: \"+e.toString();\n                        errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                        Debug.logError(e, errMsg, module);\n                    }\n                } else {\n                    return ServiceUtil.returnError(\"For Acknowledge Delivery message could not determine if it is for a PO or RMA. DOCTYPE from message is \" + docType);\n                }\n            } else {\n                String errMsg = \"Unknown Message Received\";\n                Debug.logError(errMsg, module);\n                return ServiceUtil.returnError(errMsg);\n            }\n        } else {\n            String errMsg = \"Message has been already received\";\n            Debug.logError(errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        }\n        \n        Map result = ServiceUtil.returnSuccess();\n        result.putAll(subServiceResult);\n        result.put(\"contentType\", \"text/plain\");\n\n        List errorMapList = (List) subServiceResult.get(\"errorMapList\");\n        if (UtilValidate.isNotEmpty(errorList)) {\n            Iterator errListItr = errorList.iterator();\n            while (errListItr.hasNext()) {\n                Map errorMap = (Map) errListItr.next();\n                errorMapList.add(UtilMisc.toMap(\"description\", errorMap.get(\"description\"), \"reasonCode\", errorMap.get(\"reasonCode\")));\n            }\n            result.put(\"errorMapList\", errorMapList);\n        }\n        \n        return result;\n    }","commit_id":"62e4a93a48cbd004524a8fb7b91881d81cf89aee","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map showShipment(DispatchContext ctx, Map context) {\n        Document doc = (Document) context.get(\"document\");\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n        List errorMapList = FastList.newInstance();\n            \n        GenericValue userLogin =null; \n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));    \n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin with userLoginId system: \"+e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n                    \n        Element showShipmentElement = doc.getDocumentElement();\n        showShipmentElement.normalize();\n          \n        Element controlAreaElement = UtilXml.firstChildElement(showShipmentElement, \"os:CNTROLAREA\"); // os\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"os:BSR\"); // os\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\"); // of\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\"); // of\n        String bsrRevision = UtilXml.childElementValue(bsrElement, \"of:REVISION\"); // of\n        Map oagisMsgInfoCtx = UtilMisc.toMap(\"bsrVerb\", bsrVerb, \"bsrNoun\", bsrNoun, \"bsrRevision\", bsrRevision);\n            \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"os:SENDER\"); // os\n        String logicalId = UtilXml.childElementValue(senderElement, \"of:LOGICALID\"); // of\n        String component = UtilXml.childElementValue(senderElement, \"of:COMPONENT\"); // of\n        String task = UtilXml.childElementValue(senderElement, \"of:TASK\"); // of\n        String referenceId = UtilXml.childElementValue(senderElement, \"of:REFERENCEID\"); // of\n        String confirmation = UtilXml.childElementValue(senderElement, \"of:CONFIRMATION\"); // of\n        String authId = UtilXml.childElementValue(senderElement, \"of:AUTHID\"); // of\n\n        String sentDate = UtilXml.childElementValue(controlAreaElement, \"os:DATETIMEISO\");\n        Timestamp sentTimestamp = OagisServices.parseIsoDateString(sentDate, errorMapList);\n        \n        Element dataAreaElement = UtilXml.firstChildElement(showShipmentElement, \"ns:DATAAREA\"); // n\n        Element daShowShipmentElement = UtilXml.firstChildElement(dataAreaElement, \"ns:SHOW_SHIPMENT\"); // n\n        Element shipmentElement = UtilXml.firstChildElement(daShowShipmentElement, \"ns:SHIPMENT\"); // n                               \n        String shipmentId = UtilXml.childElementValue(shipmentElement, \"of:DOCUMENTID\"); // of           \n\n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n\n        oagisMsgInfoCtx.put(\"logicalId\", logicalId);\n        oagisMsgInfoCtx.put(\"component\", component);\n        oagisMsgInfoCtx.put(\"task\", task);\n        oagisMsgInfoCtx.put(\"referenceId\", referenceId);\n        oagisMsgInfoCtx.put(\"confirmation\", confirmation);\n        oagisMsgInfoCtx.put(\"authId\", authId);\n        oagisMsgInfoCtx.put(\"outgoingMessage\", \"N\");\n        oagisMsgInfoCtx.put(\"receivedDate\", nowTimestamp);\n        oagisMsgInfoCtx.put(\"sentDate\", sentTimestamp);\n        oagisMsgInfoCtx.put(\"shipmentId\", shipmentId);\n        oagisMsgInfoCtx.put(\"userLogin\", userLogin);\n        oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                oagisMsgInfoCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        \n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n            /* running async for better error handling\n            if (ServiceUtil.isError(oagisMsgInfoResult)){\n                String errMsg = ServiceUtil.getErrorMessage(oagisMsgInfoResult);\n                // errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageInfoServiceError\"));\n                Debug.logError(errMsg, module);\n            }\n            */\n        } catch (GenericServiceException e){\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+e.toString();\n            // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n           \n        GenericValue shipment = null;\n        try {\n            shipment = delegator.findByPrimaryKey(\"Shipment\", UtilMisc.toMap(\"shipmentId\", shipmentId));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error getting Shipment from database: \"+ e.toString();\n            Debug.logInfo(e, errMsg, module);\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n        }\n        \n        if (shipment == null) {\n            String errMsg = \"Could not find Shipment id ID [\" + shipmentId + \"]\";\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ShipmentIdNotValid\"));\n        }\n        \n        if (errorMapList.size() > 0) {\n            result.putAll(ServiceUtil.returnError(\"Errors found getting shipment information for incoming Show Shipment message\"));\n            result.put(\"errorMapList\", errorMapList);\n            return result;\n        }\n\n        String shipGroupSeqId = shipment.getString(\"primaryShipGroupSeqId\");                \n        String originFacilityId = shipment.getString(\"originFacilityId\");                              \n        \n        List shipUnitElementList = UtilXml.childElementList(daShowShipmentElement, \"ns:SHIPUNIT\"); // n\n        if(UtilValidate.isNotEmpty(shipUnitElementList)) {\n            Element shipUnitElement = (Element)shipUnitElementList.get(0);\n            String trackingNum = UtilXml.childElementValue(shipUnitElement, \"of:TRACKINGID\"); // of\n            String carrierCode = UtilXml.childElementValue(shipUnitElement, \"of:CARRIER\"); // of\n            if(UtilValidate.isNotEmpty(carrierCode)){\n                String carrierPartyId = null;\n                if( carrierCode.startsWith(\"F\") || carrierCode.startsWith(\"f\")) {                \n                    carrierPartyId = \"FEDEX\";                                           \n                } else if(carrierCode.startsWith(\"U\")|| carrierCode.startsWith(\"u\")) {\n                    carrierPartyId = \"UPS\";                                            \n                }\n                try {\n                    Map resultMap = dispatcher.runSync(\"updateShipmentRouteSegment\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"shipmentRouteSegmentId\", \"00001\", \"carrierPartyId\", carrierPartyId, \"trackingIdNumber\", trackingNum, \"userLogin\", userLogin));                        \n                    if (ServiceUtil.isError(resultMap)){\n                        String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"updateShipmentRouteSegmentError\"));\n                        Debug.logError(errMsg, module);\n                    }\n                }catch (GenericServiceException e) {\n                    Debug.logInfo(e, module);\n                    String errMsg = \"Error executing updateShipmentRouteSegment Service: \"+e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                }\n            }\n            \n            Iterator shipUnitElementItr = shipUnitElementList.iterator();\n            while(shipUnitElementItr.hasNext()) {                 \n                shipUnitElement = (Element) shipUnitElementItr.next();\n                String shipmentPackageSeqId = UtilXml.childElementValue(shipUnitElement, \"of:SHPUNITSEQ\"); // of\n                List invItemElementList = UtilXml.childElementList(shipUnitElement, \"ns:INVITEM\"); //n\n                if(UtilValidate.isNotEmpty(invItemElementList)) {\n                    Iterator invItemElementItr = invItemElementList.iterator();\n                    while(invItemElementItr.hasNext()) {                 \n                        Element invItemElement = (Element) invItemElementItr.next();\n                        String productId = UtilXml.childElementValue(invItemElement, \"of:ITEM\"); // of\n                        \n                        try {\n                            Element quantityElement = UtilXml.firstChildElement(invItemElement, \"os:QUANTITY\"); // os\n                            String quantityValueStr = UtilXml.childElementValue(quantityElement, \"of:VALUE\"); // os\n                            // TODO: <of:NUMOFDEC>0<\/of:NUMOFDEC> should always be 0, but might want to add code to check\n                            Integer messageQuantity = Integer.valueOf(quantityValueStr);\n\n                            GenericValue shipmentItem = EntityUtil.getFirst(delegator.findByAnd(\"ShipmentItem\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"productId\",productId)));                    \n                            String shipmentItemSeqId = shipmentItem.getString(\"shipmentItemSeqId\");                      \n                            GenericValue orderShipment = EntityUtil.getFirst(delegator.findByAnd(\"OrderShipment\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"shipmentItemSeqId\", shipmentItemSeqId)));                    \n                            String orderId = orderShipment.getString(\"orderId\");                \n                            String orderItemSeqId = orderShipment.getString(\"orderItemSeqId\");                \n                            GenericValue product = delegator.findByPrimaryKey(\"Product\",UtilMisc.toMap(\"productId\",productId));                    \n                            String requireInventory = product.getString(\"requireInventory\");                    \n                            if (requireInventory == null) {\n                                requireInventory = \"N\";\n                            }\n                            \n                            // TODO and NOTE: could there be more than one reservation record for a given shipment item? for example if there wasn't enough quantity in one inventory item and reservations on two were needed? yes\n                            List orderItemShipGrpInvReservationList = delegator.findByAnd(\"OrderItemShipGrpInvRes\", UtilMisc.toMap(\"orderId\", orderId, \"orderItemSeqId\", orderItemSeqId,\"shipGroupSeqId\",shipGroupSeqId));\n                            \n                            // find the total quantity for all reservations\n                            int totalReserved = 0;\n                            Iterator orderItemShipGrpInvReservationCountIter = orderItemShipGrpInvReservationList.iterator();\n                            while (orderItemShipGrpInvReservationCountIter.hasNext()) {\n                                GenericValue orderItemShipGrpInvReservation = (GenericValue) orderItemShipGrpInvReservationCountIter.next();\n                                if (orderItemShipGrpInvReservation.getDouble(\"quantity\") != null) {\n                                    totalReserved += orderItemShipGrpInvReservation.getDouble(\"quantity\").doubleValue();\n                                }\n                            }\n\n                            List serialNumberList = FastList.newInstance();\n                            List invDetailElementList = UtilXml.childElementList(invItemElement, \"ns:INVDETAIL\"); //n\n                            Iterator invDetailElementItr = invDetailElementList.iterator();\n                            while(invDetailElementItr.hasNext()) {\n                                Element invDetailElement = (Element) invDetailElementItr.next();\n                                String serialNumber = UtilXml.childElementValue(invDetailElement, \"of:SERIALNUM\"); // os\n                                if (UtilValidate.isNotEmpty(serialNumber)) {\n                                    serialNumberList.add(serialNumber);\n                                }\n                            }\n\n                            // do some validations\n                            boolean continueLoop = false;\n                            if(UtilValidate.isNotEmpty(serialNumberList)) {\n                                if (messageQuantity.intValue() != serialNumberList.size()) {\n                                    String errMsg = \"Not enough serial numbers [\" + serialNumberList.size() + \"] for the quantity [\" + messageQuantity.intValue() + \"].\";\n                                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SerialNumbersMissing\"));\n                                    Debug.logInfo(errMsg, module);\n                                    continueLoop = true;\n                                }\n                            } \n                            if ((int) totalReserved != messageQuantity.intValue()) {\n                                String errMsg = \"Not enough serial numbers [\" + serialNumberList.size() + \"] for the quantity [\" + messageQuantity.intValue() + \"].\";\n                                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SerialNumbersMissing\"));\n                                Debug.logInfo(errMsg, module);\n                                continueLoop = true;\n                            }\n                            \n                            if (continueLoop) {\n                                continue;\n                            }\n                            \n                            Iterator serialNumberIter = serialNumberList.iterator();\n                            Iterator orderItemShipGrpInvReservationIter = orderItemShipGrpInvReservationList.iterator();\n                            while (orderItemShipGrpInvReservationIter.hasNext()) {\n                                GenericValue orderItemShipGrpInvReservation = (GenericValue) orderItemShipGrpInvReservationIter.next();\n                                int currentResQuantity = orderItemShipGrpInvReservation.getDouble(\"quantity\").intValue();\n                                \n                                Map isitspastCtx = UtilMisc.toMap(\"orderId\", orderId, \"shipGroupSeqId\", shipGroupSeqId, \"orderItemSeqId\", orderItemSeqId);                \n                                isitspastCtx.put(\"productId\", productId);\n                                isitspastCtx.put(\"reservedDatetime\", orderItemShipGrpInvReservation.get(\"reservedDatetime\"));\n                                isitspastCtx.put(\"requireInventory\", requireInventory);\n                                isitspastCtx.put(\"reserveOrderEnumId\", orderItemShipGrpInvReservation.get(\"reserveOrderEnumId\"));\n                                isitspastCtx.put(\"sequenceId\", orderItemShipGrpInvReservation.get(\"sequenceId\"));\n                                isitspastCtx.put(\"originFacilityId\", originFacilityId);\n                                isitspastCtx.put(\"userLogin\", userLogin);            \n                                isitspastCtx.put(\"trackingNum\", trackingNum);\n                                isitspastCtx.put(\"inventoryItemId\", orderItemShipGrpInvReservation.get(\"inventoryItemId\"));                \n                                isitspastCtx.put(\"shipmentId\", shipmentId);      \n                                isitspastCtx.put(\"shipmentPackageSeqId\", shipmentPackageSeqId);\n                                isitspastCtx.put(\"promisedDatetime\", orderItemShipGrpInvReservation.get(\"promisedDatetime\"));\n                                \n                                if(UtilValidate.isNotEmpty(serialNumberList)) {\n                                    for (int i = 0; i < currentResQuantity; i++) {\n                                        String serialNumber = (String) serialNumberIter.next();\n                                        isitspastCtx.put(\"serialNumber\", serialNumber);\n                                        isitspastCtx.put(\"quantity\", new Double (1));\n                                        isitspastCtx.put(\"inventoryItemId\", orderItemShipGrpInvReservation.get(\"inventoryItemId\"));\n                                        isitspastCtx.remove(\"itemIssuanceId\");                            \n                                        try {\n                                            Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                            if (ServiceUtil.isError(resultMap)){\n                                                String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                                Debug.logError(errMsg, module);\n                                            }\n                                        } catch(GenericServiceException e) {\n                                            Debug.logInfo(e, module);\n                                            String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                        }\n                                    }\n                                } else {\n                                    try {\n                                        //TODO: I think this else part is for NON Serialized Inv item. So it will be different service that we need to call here.\n                                        isitspastCtx.put(\"quantity\", new Double(currentResQuantity));\n                                        Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                        if (ServiceUtil.isError(resultMap)){\n                                            String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                            Debug.logError(errMsg, module);\n                                        }\n                                    } catch(GenericServiceException e) {\n                                        Debug.logInfo(e, module);\n                                        String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                    }            \n                                }\n                            }\n                            \n                        } catch (NumberFormatException e) {\n                            String errMsg = \"Error in format for number: \" + e.toString();\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"NumberFormatException\"));\n                            Debug.logInfo(e, errMsg, module);\n                        } catch (GenericEntityException e) {\n                            String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \" + e.toString();\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n                            Debug.logInfo(e, errMsg, module);\n                        }\n                    }\n                }\n            }\n            try {\n                Map resultMap = dispatcher.runSync(\"setShipmentStatusPackedAndShipped\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"userLogin\", userLogin));               \n                if (ServiceUtil.isError(resultMap)){\n                    String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SetShipmentStatusPackedAndShippedError\"));\n                    Debug.logError(errMsg, module);\n                }\n            } catch(GenericServiceException e) {\n                Debug.logInfo(e, module);\n                String errMsg = \"Error executing setShipmentStatusPackedAndShipped Service: \" + e.toString();\n                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            }   \n        }  \n        \n        if (errorMapList.size() > 0) {\n            // DEJ20070807 what was this next line commented out? if there are errors we want to return an error so this will roll back \n            result.putAll(ServiceUtil.returnError(\"Errors found processing message\"));\n            result.put(\"errorMapList\", errorMapList);\n            return result;\n        } else {\n            oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_PROC_SUCCESS\");\n            try {\n                dispatcher.runSync(\"updateOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                Debug.logError(e, errMsg, module);\n            }\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","id":29006,"modified_method":"public static Map showShipment(DispatchContext ctx, Map context) {\n        Document doc = (Document) context.get(\"document\");\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n        List errorMapList = FastList.newInstance();\n            \n        GenericValue userLogin =null; \n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));    \n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin with userLoginId system: \"+e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n                    \n        Element showShipmentElement = doc.getDocumentElement();\n        showShipmentElement.normalize();\n          \n        Element controlAreaElement = UtilXml.firstChildElement(showShipmentElement, \"os:CNTROLAREA\"); // os\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"os:BSR\"); // os\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\"); // of\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\"); // of\n        String bsrRevision = UtilXml.childElementValue(bsrElement, \"of:REVISION\"); // of\n        Map oagisMsgInfoCtx = UtilMisc.toMap(\"bsrVerb\", bsrVerb, \"bsrNoun\", bsrNoun, \"bsrRevision\", bsrRevision);\n            \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"os:SENDER\"); // os\n        String logicalId = UtilXml.childElementValue(senderElement, \"of:LOGICALID\"); // of\n        String component = UtilXml.childElementValue(senderElement, \"of:COMPONENT\"); // of\n        String task = UtilXml.childElementValue(senderElement, \"of:TASK\"); // of\n        String referenceId = UtilXml.childElementValue(senderElement, \"of:REFERENCEID\"); // of\n        String confirmation = UtilXml.childElementValue(senderElement, \"of:CONFIRMATION\"); // of\n        String authId = UtilXml.childElementValue(senderElement, \"of:AUTHID\"); // of\n\n        String sentDate = UtilXml.childElementValue(controlAreaElement, \"os:DATETIMEISO\");\n        Timestamp sentTimestamp = OagisServices.parseIsoDateString(sentDate, errorMapList);\n        \n        Element dataAreaElement = UtilXml.firstChildElement(showShipmentElement, \"ns:DATAAREA\"); // n\n        Element daShowShipmentElement = UtilXml.firstChildElement(dataAreaElement, \"ns:SHOW_SHIPMENT\"); // n\n        Element shipmentElement = UtilXml.firstChildElement(daShowShipmentElement, \"ns:SHIPMENT\"); // n                               \n        String shipmentId = UtilXml.childElementValue(shipmentElement, \"of:DOCUMENTID\"); // of           \n\n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n\n        oagisMsgInfoCtx.put(\"logicalId\", logicalId);\n        oagisMsgInfoCtx.put(\"component\", component);\n        oagisMsgInfoCtx.put(\"task\", task);\n        oagisMsgInfoCtx.put(\"referenceId\", referenceId);\n        oagisMsgInfoCtx.put(\"confirmation\", confirmation);\n        oagisMsgInfoCtx.put(\"authId\", authId);\n        oagisMsgInfoCtx.put(\"outgoingMessage\", \"N\");\n        oagisMsgInfoCtx.put(\"receivedDate\", nowTimestamp);\n        oagisMsgInfoCtx.put(\"sentDate\", sentTimestamp);\n        oagisMsgInfoCtx.put(\"shipmentId\", shipmentId);\n        oagisMsgInfoCtx.put(\"userLogin\", userLogin);\n        oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                oagisMsgInfoCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        \n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n            /* running async for better error handling\n            if (ServiceUtil.isError(oagisMsgInfoResult)){\n                String errMsg = ServiceUtil.getErrorMessage(oagisMsgInfoResult);\n                // errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageInfoServiceError\"));\n                Debug.logError(errMsg, module);\n            }\n            */\n        } catch (GenericServiceException e){\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+e.toString();\n            // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n           \n        GenericValue shipment = null;\n        try {\n            shipment = delegator.findByPrimaryKey(\"Shipment\", UtilMisc.toMap(\"shipmentId\", shipmentId));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error getting Shipment from database: \"+ e.toString();\n            Debug.logInfo(e, errMsg, module);\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n        }\n        \n        if (shipment == null) {\n            String errMsg = \"Could not find Shipment id ID [\" + shipmentId + \"]\";\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ShipmentIdNotValid\"));\n        }\n        \n        if (errorMapList.size() > 0) {\n            result.putAll(ServiceUtil.returnError(\"Errors found getting shipment information for incoming Show Shipment message\"));\n            result.put(\"errorMapList\", errorMapList);\n            return result;\n        }\n\n        String shipGroupSeqId = shipment.getString(\"primaryShipGroupSeqId\");                \n        String originFacilityId = shipment.getString(\"originFacilityId\");                              \n        \n        List shipUnitElementList = UtilXml.childElementList(daShowShipmentElement, \"ns:SHIPUNIT\"); // n\n        if(UtilValidate.isNotEmpty(shipUnitElementList)) {\n            Element shipUnitElement = (Element)shipUnitElementList.get(0);\n            String trackingNum = UtilXml.childElementValue(shipUnitElement, \"of:TRACKINGID\"); // of\n            String carrierCode = UtilXml.childElementValue(shipUnitElement, \"of:CARRIER\"); // of\n            if(UtilValidate.isNotEmpty(carrierCode)){\n                String carrierPartyId = null;\n                if( carrierCode.startsWith(\"F\") || carrierCode.startsWith(\"f\")) {                \n                    carrierPartyId = \"FEDEX\";                                           \n                } else if(carrierCode.startsWith(\"U\")|| carrierCode.startsWith(\"u\")) {\n                    carrierPartyId = \"UPS\";                                            \n                }\n                try {\n                    Map resultMap = dispatcher.runSync(\"updateShipmentRouteSegment\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"shipmentRouteSegmentId\", \"00001\", \"carrierPartyId\", carrierPartyId, \"trackingIdNumber\", trackingNum, \"userLogin\", userLogin));                        \n                    if (ServiceUtil.isError(resultMap)){\n                        String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"updateShipmentRouteSegmentError\"));\n                        Debug.logError(errMsg, module);\n                    }\n                }catch (GenericServiceException e) {\n                    Debug.logInfo(e, module);\n                    String errMsg = \"Error executing updateShipmentRouteSegment Service: \"+e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                }\n            }\n            \n            Iterator shipUnitElementItr = shipUnitElementList.iterator();\n            while(shipUnitElementItr.hasNext()) {                 \n                shipUnitElement = (Element) shipUnitElementItr.next();\n                String shipmentPackageSeqId = UtilXml.childElementValue(shipUnitElement, \"of:SHPUNITSEQ\"); // of\n                List invItemElementList = UtilXml.childElementList(shipUnitElement, \"ns:INVITEM\"); //n\n                if(UtilValidate.isNotEmpty(invItemElementList)) {\n                    // sort the INVITEM elements by ITEM so that all shipments are processed in the same order, avoids deadlocking problems we've seen with concurrently processed orders\n                    List invitemMapList = FastList.newInstance();\n                    Iterator invItemElementIter = invItemElementList.iterator();\n                    while(invItemElementIter.hasNext()) {                 \n                        Element invItemElement = (Element) invItemElementIter.next();\n                        String productId = UtilXml.childElementValue(invItemElement, \"of:ITEM\"); // of\n                        Map invitemMap = FastMap.newInstance();\n                        invitemMap.put(\"productId\", productId);\n                        invitemMap.put(\"invItemElement\", invItemElement);\n                        invitemMapList.add(invitemMap);\n                    }\n                    UtilMisc.sortMaps(invitemMapList, UtilMisc.toList(\"productId\"));\n                    \n                    Iterator invitemMapIter = invitemMapList.iterator();\n                    while(invitemMapIter.hasNext()) {\n                        Map invitemMap = (Map) invitemMapIter.next();\n                        Element invItemElement = (Element) invitemMap.get(\"invItemElement\");\n                        String productId = UtilXml.childElementValue(invItemElement, \"of:ITEM\"); // of\n                        \n                        try {\n                            Element quantityElement = UtilXml.firstChildElement(invItemElement, \"os:QUANTITY\"); // os\n                            String quantityValueStr = UtilXml.childElementValue(quantityElement, \"of:VALUE\"); // os\n                            // TODO: <of:NUMOFDEC>0<\/of:NUMOFDEC> should always be 0, but might want to add code to check\n                            Integer messageQuantity = Integer.valueOf(quantityValueStr);\n\n                            GenericValue shipmentItem = EntityUtil.getFirst(delegator.findByAnd(\"ShipmentItem\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"productId\",productId)));                    \n                            String shipmentItemSeqId = shipmentItem.getString(\"shipmentItemSeqId\");                      \n                            GenericValue orderShipment = EntityUtil.getFirst(delegator.findByAnd(\"OrderShipment\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"shipmentItemSeqId\", shipmentItemSeqId)));                    \n                            String orderId = orderShipment.getString(\"orderId\");                \n                            String orderItemSeqId = orderShipment.getString(\"orderItemSeqId\");                \n                            GenericValue product = delegator.findByPrimaryKey(\"Product\",UtilMisc.toMap(\"productId\",productId));                    \n                            String requireInventory = product.getString(\"requireInventory\");                    \n                            if (requireInventory == null) {\n                                requireInventory = \"N\";\n                            }\n                            \n                            // TODO and NOTE: could there be more than one reservation record for a given shipment item? for example if there wasn't enough quantity in one inventory item and reservations on two were needed? yes\n                            List orderItemShipGrpInvReservationList = delegator.findByAnd(\"OrderItemShipGrpInvRes\", UtilMisc.toMap(\"orderId\", orderId, \"orderItemSeqId\", orderItemSeqId,\"shipGroupSeqId\",shipGroupSeqId));\n                            \n                            // find the total quantity for all reservations\n                            int totalReserved = 0;\n                            Iterator orderItemShipGrpInvReservationCountIter = orderItemShipGrpInvReservationList.iterator();\n                            while (orderItemShipGrpInvReservationCountIter.hasNext()) {\n                                GenericValue orderItemShipGrpInvReservation = (GenericValue) orderItemShipGrpInvReservationCountIter.next();\n                                if (orderItemShipGrpInvReservation.getDouble(\"quantity\") != null) {\n                                    totalReserved += orderItemShipGrpInvReservation.getDouble(\"quantity\").doubleValue();\n                                }\n                            }\n\n                            List serialNumberList = FastList.newInstance();\n                            List invDetailElementList = UtilXml.childElementList(invItemElement, \"ns:INVDETAIL\"); //n\n                            Iterator invDetailElementItr = invDetailElementList.iterator();\n                            while(invDetailElementItr.hasNext()) {\n                                Element invDetailElement = (Element) invDetailElementItr.next();\n                                String serialNumber = UtilXml.childElementValue(invDetailElement, \"of:SERIALNUM\"); // os\n                                if (UtilValidate.isNotEmpty(serialNumber)) {\n                                    serialNumberList.add(serialNumber);\n                                }\n                            }\n\n                            // do some validations\n                            boolean continueLoop = false;\n                            if(UtilValidate.isNotEmpty(serialNumberList)) {\n                                if (messageQuantity.intValue() != serialNumberList.size()) {\n                                    String errMsg = \"Not enough serial numbers [\" + serialNumberList.size() + \"] for the quantity [\" + messageQuantity.intValue() + \"].\";\n                                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SerialNumbersMissing\"));\n                                    Debug.logInfo(errMsg, module);\n                                    continueLoop = true;\n                                }\n                            } \n                            if ((int) totalReserved != messageQuantity.intValue()) {\n                                String errMsg = \"Not enough serial numbers [\" + serialNumberList.size() + \"] for the quantity [\" + messageQuantity.intValue() + \"].\";\n                                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SerialNumbersMissing\"));\n                                Debug.logInfo(errMsg, module);\n                                continueLoop = true;\n                            }\n                            \n                            if (continueLoop) {\n                                continue;\n                            }\n                            \n                            Iterator serialNumberIter = serialNumberList.iterator();\n                            Iterator orderItemShipGrpInvReservationIter = orderItemShipGrpInvReservationList.iterator();\n                            while (orderItemShipGrpInvReservationIter.hasNext()) {\n                                GenericValue orderItemShipGrpInvReservation = (GenericValue) orderItemShipGrpInvReservationIter.next();\n                                int currentResQuantity = orderItemShipGrpInvReservation.getDouble(\"quantity\").intValue();\n                                \n                                Map isitspastCtx = UtilMisc.toMap(\"orderId\", orderId, \"shipGroupSeqId\", shipGroupSeqId, \"orderItemSeqId\", orderItemSeqId);                \n                                isitspastCtx.put(\"productId\", productId);\n                                isitspastCtx.put(\"reservedDatetime\", orderItemShipGrpInvReservation.get(\"reservedDatetime\"));\n                                isitspastCtx.put(\"requireInventory\", requireInventory);\n                                isitspastCtx.put(\"reserveOrderEnumId\", orderItemShipGrpInvReservation.get(\"reserveOrderEnumId\"));\n                                isitspastCtx.put(\"sequenceId\", orderItemShipGrpInvReservation.get(\"sequenceId\"));\n                                isitspastCtx.put(\"originFacilityId\", originFacilityId);\n                                isitspastCtx.put(\"userLogin\", userLogin);            \n                                isitspastCtx.put(\"trackingNum\", trackingNum);\n                                isitspastCtx.put(\"inventoryItemId\", orderItemShipGrpInvReservation.get(\"inventoryItemId\"));                \n                                isitspastCtx.put(\"shipmentId\", shipmentId);      \n                                isitspastCtx.put(\"shipmentPackageSeqId\", shipmentPackageSeqId);\n                                isitspastCtx.put(\"promisedDatetime\", orderItemShipGrpInvReservation.get(\"promisedDatetime\"));\n                                \n                                if(UtilValidate.isNotEmpty(serialNumberList)) {\n                                    for (int i = 0; i < currentResQuantity; i++) {\n                                        String serialNumber = (String) serialNumberIter.next();\n                                        isitspastCtx.put(\"serialNumber\", serialNumber);\n                                        isitspastCtx.put(\"quantity\", new Double (1));\n                                        isitspastCtx.put(\"inventoryItemId\", orderItemShipGrpInvReservation.get(\"inventoryItemId\"));\n                                        isitspastCtx.remove(\"itemIssuanceId\");                            \n                                        try {\n                                            Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                            if (ServiceUtil.isError(resultMap)){\n                                                String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                                Debug.logError(errMsg, module);\n                                            }\n                                        } catch(GenericServiceException e) {\n                                            Debug.logInfo(e, module);\n                                            String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                        }\n                                    }\n                                } else {\n                                    try {\n                                        //TODO: I think this else part is for NON Serialized Inv item. So it will be different service that we need to call here.\n                                        isitspastCtx.put(\"quantity\", new Double(currentResQuantity));\n                                        Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                        if (ServiceUtil.isError(resultMap)){\n                                            String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                            Debug.logError(errMsg, module);\n                                        }\n                                    } catch(GenericServiceException e) {\n                                        Debug.logInfo(e, module);\n                                        String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                    }            \n                                }\n                            }\n                            \n                        } catch (NumberFormatException e) {\n                            String errMsg = \"Error in format for number: \" + e.toString();\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"NumberFormatException\"));\n                            Debug.logInfo(e, errMsg, module);\n                        } catch (GenericEntityException e) {\n                            String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \" + e.toString();\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n                            Debug.logInfo(e, errMsg, module);\n                        }\n                    }\n                }\n            }\n            try {\n                Map resultMap = dispatcher.runSync(\"setShipmentStatusPackedAndShipped\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"userLogin\", userLogin));               \n                if (ServiceUtil.isError(resultMap)){\n                    String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SetShipmentStatusPackedAndShippedError\"));\n                    Debug.logError(errMsg, module);\n                }\n            } catch(GenericServiceException e) {\n                Debug.logInfo(e, module);\n                String errMsg = \"Error executing setShipmentStatusPackedAndShipped Service: \" + e.toString();\n                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            }   \n        }  \n        \n        if (errorMapList.size() > 0) {\n            // DEJ20070807 what was this next line commented out? if there are errors we want to return an error so this will roll back \n            result.putAll(ServiceUtil.returnError(\"Errors found processing message\"));\n            result.put(\"errorMapList\", errorMapList);\n            return result;\n        } else {\n            oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_PROC_SUCCESS\");\n            try {\n                dispatcher.runSync(\"updateOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                Debug.logError(e, errMsg, module);\n            }\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","commit_id":"62e4a93a48cbd004524a8fb7b91881d81cf89aee","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map oagisMessageHandler(DispatchContext ctx, Map context) {\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        InputStream in = (InputStream) context.get(\"inputStream\");\n        List errorList = FastList.newInstance();\n        \n        Document doc = null;\n        String xmlText = null;\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(in, \"UTF-8\"));\n            StringBuffer xmlTextBuf = new StringBuffer();\n            String currentLine = null;\n            while ((currentLine = br.readLine()) != null) {\n                xmlTextBuf.append(currentLine);\n                xmlTextBuf.append('\\n');\n            }\n            xmlText = xmlTextBuf.toString();\n            \n            // DEJ20070804 adding this temporarily for debugging, should be changed to verbose at some point in the future\n            Debug.logWarning(\"Received OAGIS XML message, here is the text: \\n\" + xmlText, module);\n\n            ByteArrayInputStream bis = new ByteArrayInputStream(xmlText.getBytes(\"UTF-8\"));\n            doc = UtilXml.readXmlDocument(bis, true, \"OagisMessage\");\n        } catch (SAXException e) {\n            String errMsg = \"XML Error parsing the Received Message [\" + e.toString() + \"]; The text received we could not parse is: [\" + xmlText + \"]\";\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SAXException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (ParserConfigurationException e) {\n            String errMsg = \"Parser Configuration Error parsing the Received Message: \" + e.toString();\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ParserConfigurationException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (IOException e) {\n            String errMsg = \"IO Error parsing the Received Message: \" + e.toString();\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IOException\"));\n            Debug.logError(e, errMsg, module);\n        }\n\n        if (UtilValidate.isNotEmpty(errorList)) {\n            return ServiceUtil.returnError(\"Unable to parse received message\");\n        }\n\n        Element rootElement = doc.getDocumentElement();\n        rootElement.normalize();\n        Element controlAreaElement = UtilXml.firstChildElement(rootElement, \"os:CNTROLAREA\");\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"os:BSR\");\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\");\n        \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"os:SENDER\");\n        String logicalId = UtilXml.childElementValue(senderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(senderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(senderElement, \"of:TASK\");\n        String referenceId = UtilXml.childElementValue(senderElement, \"of:REFERENCEID\");\n        \n        if (UtilValidate.isEmpty(bsrVerb) || UtilValidate.isEmpty(bsrNoun)) {\n            return ServiceUtil.returnError(\"Was able to receive and parse the XML message, but BSR->NOUN [\" + bsrNoun + \"] and/or BSR->VERB [\" + bsrVerb + \"] are empty\");\n        }\n        \n        GenericValue oagisMessageInfo = null;\n        try {\n            oagisMessageInfo = delegator.findByPrimaryKey(\"OagisMessageInfo\", UtilMisc.toMap(\"logicalId\", logicalId, \"component\", component, \"task\", task, \"referenceId\", referenceId));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error Getting Entity OagisMessageInfo: \"+e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        Map subServiceResult = FastMap.newInstance();\n        if (UtilValidate.isEmpty(oagisMessageInfo)) {\n            if (bsrVerb.equalsIgnoreCase(\"CONFIRM\") && bsrNoun.equalsIgnoreCase(\"BOD\")) {\n                try {\n                    subServiceResult = dispatcher.runSync(\"receiveConfirmBod\", UtilMisc.toMap(\"document\",doc));\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service receiveConfirmBod: \"+e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"SHOW\") && bsrNoun.equalsIgnoreCase(\"SHIPMENT\")) {\n                try {\n                    //subServiceResult = dispatcher.runSync(\"showShipment\", UtilMisc.toMap(\"document\",doc));\n                    // DEJ20070808 changed to run asynchronously and persisted so that if it fails it will retry\n                    dispatcher.runAsync(\"showShipment\", UtilMisc.toMap(\"document\",doc), true);\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service showShipment: \"+e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"SYNC\") && bsrNoun.equalsIgnoreCase(\"INVENTORY\")) {\n                try {\n                    subServiceResult = dispatcher.runSync(\"syncInventory\", UtilMisc.toMap(\"document\",doc));\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service syncInventory: \"+e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"ACKNOWLEDGE\") && bsrNoun.equalsIgnoreCase(\"DELIVERY\")) {\n                Element dataAreaElement = UtilXml.firstChildElement(rootElement, \"ns:DATAAREA\");\n                Element ackDeliveryElement = UtilXml.firstChildElement(dataAreaElement, \"ns:ACKNOWLEDGE_DELIVERY\");\n                Element receiptlnElement = UtilXml.firstChildElement(ackDeliveryElement, \"ns:RECEIPTLN\");\n                Element docRefElement = UtilXml.firstChildElement(receiptlnElement, \"os:DOCUMNTREF\");\n                String docType = UtilXml.childElementValue(docRefElement, \"of:DOCTYPE\");\n                if (\"PO\".equals(docType)){\n                    try {\n                        subServiceResult = dispatcher.runSync(\"receivePoAcknowledge\", UtilMisc.toMap(\"document\",doc));\n                    } catch (GenericServiceException e) {\n                        String errMsg = \"Error running service receivePoAcknowledge: \"+e.toString();\n                        errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                        Debug.logError(e, errMsg, module);\n                    }\n                } else if (\"RMA\".equals(docType)) {\n                    try {\n                        subServiceResult = dispatcher.runSync(\"receiveRmaAcknowledge\", UtilMisc.toMap(\"document\",doc));\n                    } catch (GenericServiceException e) {\n                        String errMsg = \"Error running service receiveRmaAcknowledge: \"+e.toString();\n                        errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                        Debug.logError(e, errMsg, module);\n                    }\n                } else {\n                    return ServiceUtil.returnError(\"For Acknowledge Delivery message could not determine if it is for a PO or RMA. DOCTYPE from message is \" + docType);\n                }\n            } else {\n                String errMsg = \"Unknown Message Received\";\n                Debug.logError(errMsg, module);\n                return ServiceUtil.returnError(errMsg);\n            }\n        } else {\n            String errMsg = \"Message has been already received\";\n            Debug.logError(errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        }\n        \n        Map result = ServiceUtil.returnSuccess();\n        result.putAll(subServiceResult);\n        result.put(\"contentType\", \"text/plain\");\n\n        List errorMapList = (List) subServiceResult.get(\"errorMapList\");\n        if (UtilValidate.isNotEmpty(errorList)) {\n            Iterator errListItr = errorList.iterator();\n            while (errListItr.hasNext()) {\n                Map errorMap = (Map) errListItr.next();\n                errorMapList.add(UtilMisc.toMap(\"description\", errorMap.get(\"description\"), \"reasonCode\", errorMap.get(\"reasonCode\")));\n            }\n            result.put(\"errorMapList\", errorMapList);\n        }\n        \n        return result;\n    }","id":29007,"modified_method":"public static Map oagisMessageHandler(DispatchContext ctx, Map context) {\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        InputStream in = (InputStream) context.get(\"inputStream\");\n        List errorList = FastList.newInstance();\n        \n        Document doc = null;\n        String xmlText = null;\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(in, \"UTF-8\"));\n            StringBuffer xmlTextBuf = new StringBuffer();\n            String currentLine = null;\n            while ((currentLine = br.readLine()) != null) {\n                xmlTextBuf.append(currentLine);\n                xmlTextBuf.append('\\n');\n            }\n            xmlText = xmlTextBuf.toString();\n            \n            // DEJ20070804 adding this temporarily for debugging, should be changed to verbose at some point in the future\n            Debug.logWarning(\"Received OAGIS XML message, here is the text: \\n\" + xmlText, module);\n\n            ByteArrayInputStream bis = new ByteArrayInputStream(xmlText.getBytes(\"UTF-8\"));\n            doc = UtilXml.readXmlDocument(bis, true, \"OagisMessage\");\n        } catch (SAXException e) {\n            String errMsg = \"XML Error parsing the Received Message [\" + e.toString() + \"]; The text received we could not parse is: [\" + xmlText + \"]\";\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SAXException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (ParserConfigurationException e) {\n            String errMsg = \"Parser Configuration Error parsing the Received Message: \" + e.toString();\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ParserConfigurationException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (IOException e) {\n            String errMsg = \"IO Error parsing the Received Message: \" + e.toString();\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IOException\"));\n            Debug.logError(e, errMsg, module);\n        }\n\n        if (UtilValidate.isNotEmpty(errorList)) {\n            return ServiceUtil.returnError(\"Unable to parse received message\");\n        }\n\n        Element rootElement = doc.getDocumentElement();\n        rootElement.normalize();\n        Element controlAreaElement = UtilXml.firstChildElement(rootElement, \"os:CNTROLAREA\");\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"os:BSR\");\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\");\n        \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"os:SENDER\");\n        String logicalId = UtilXml.childElementValue(senderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(senderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(senderElement, \"of:TASK\");\n        String referenceId = UtilXml.childElementValue(senderElement, \"of:REFERENCEID\");\n        \n        if (UtilValidate.isEmpty(bsrVerb) || UtilValidate.isEmpty(bsrNoun)) {\n            return ServiceUtil.returnError(\"Was able to receive and parse the XML message, but BSR->NOUN [\" + bsrNoun + \"] and/or BSR->VERB [\" + bsrVerb + \"] are empty\");\n        }\n        \n        GenericValue oagisMessageInfo = null;\n        try {\n            oagisMessageInfo = delegator.findByPrimaryKey(\"OagisMessageInfo\", UtilMisc.toMap(\"logicalId\", logicalId, \"component\", component, \"task\", task, \"referenceId\", referenceId));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error Getting Entity OagisMessageInfo: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        Map subServiceResult = FastMap.newInstance();\n        if (UtilValidate.isEmpty(oagisMessageInfo)) {\n            if (bsrVerb.equalsIgnoreCase(\"CONFIRM\") && bsrNoun.equalsIgnoreCase(\"BOD\")) {\n                try {\n                    subServiceResult = dispatcher.runSync(\"receiveConfirmBod\", UtilMisc.toMap(\"document\", doc));\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service receiveConfirmBod: \" + e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"SHOW\") && bsrNoun.equalsIgnoreCase(\"SHIPMENT\")) {\n                try {\n                    //subServiceResult = dispatcher.runSync(\"showShipment\", UtilMisc.toMap(\"document\", doc));\n                    // DEJ20070808 changed to run asynchronously and persisted so that if it fails it will retry; for transaction deadlock and other reasons\n                    dispatcher.runAsync(\"showShipment\", UtilMisc.toMap(\"document\", doc), true);\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service showShipment: \" + e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"SYNC\") && bsrNoun.equalsIgnoreCase(\"INVENTORY\")) {\n                try {\n                    //subServiceResult = dispatcher.runSync(\"syncInventory\", UtilMisc.toMap(\"document\", doc));\n                    // DEJ20070808 changed to run asynchronously and persisted so that if it fails it will retry; for transaction deadlock and other reasons\n                    dispatcher.runAsync(\"syncInventory\", UtilMisc.toMap(\"document\", doc), true);\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service syncInventory: \" + e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"ACKNOWLEDGE\") && bsrNoun.equalsIgnoreCase(\"DELIVERY\")) {\n                Element dataAreaElement = UtilXml.firstChildElement(rootElement, \"ns:DATAAREA\");\n                Element ackDeliveryElement = UtilXml.firstChildElement(dataAreaElement, \"ns:ACKNOWLEDGE_DELIVERY\");\n                Element receiptlnElement = UtilXml.firstChildElement(ackDeliveryElement, \"ns:RECEIPTLN\");\n                Element docRefElement = UtilXml.firstChildElement(receiptlnElement, \"os:DOCUMNTREF\");\n                String docType = UtilXml.childElementValue(docRefElement, \"of:DOCTYPE\");\n                if (\"PO\".equals(docType)){\n                    try {\n                        //subServiceResult = dispatcher.runSync(\"receivePoAcknowledge\", UtilMisc.toMap(\"document\", doc));\n                        dispatcher.runAsync(\"receivePoAcknowledge\", UtilMisc.toMap(\"document\", doc), true);\n                    } catch (GenericServiceException e) {\n                        String errMsg = \"Error running service receivePoAcknowledge: \" + e.toString();\n                        errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                        Debug.logError(e, errMsg, module);\n                    }\n                } else if (\"RMA\".equals(docType)) {\n                    try {\n                        //subServiceResult = dispatcher.runSync(\"receiveRmaAcknowledge\", UtilMisc.toMap(\"document\", doc));\n                        dispatcher.runAsync(\"receiveRmaAcknowledge\", UtilMisc.toMap(\"document\", doc), true);\n                    } catch (GenericServiceException e) {\n                        String errMsg = \"Error running service receiveRmaAcknowledge: \" + e.toString();\n                        errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                        Debug.logError(e, errMsg, module);\n                    }\n                } else {\n                    return ServiceUtil.returnError(\"For Acknowledge Delivery message could not determine if it is for a PO or RMA. DOCTYPE from message is \" + docType);\n                }\n            } else {\n                String errMsg = \"Unknown Message Received\";\n                Debug.logError(errMsg, module);\n                return ServiceUtil.returnError(errMsg);\n            }\n        } else {\n            String errMsg = \"Message has been already received\";\n            Debug.logError(errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        }\n        \n        Map result = ServiceUtil.returnSuccess();\n        result.putAll(subServiceResult);\n        result.put(\"contentType\", \"text/plain\");\n\n        List errorMapList = (List) subServiceResult.get(\"errorMapList\");\n        if (UtilValidate.isNotEmpty(errorList)) {\n            Iterator errListItr = errorList.iterator();\n            while (errListItr.hasNext()) {\n                Map errorMap = (Map) errListItr.next();\n                errorMapList.add(UtilMisc.toMap(\"description\", errorMap.get(\"description\"), \"reasonCode\", errorMap.get(\"reasonCode\")));\n            }\n            result.put(\"errorMapList\", errorMapList);\n        }\n        \n        return result;\n    }","commit_id":"266d64a708ffc47c8e7a3796e2b1eeff8d1810bc","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map oagisProcessShipment(DispatchContext ctx, Map context) {\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        String orderId = (String) context.get(\"orderId\");\n        \n        String sendToUrl = (String) context.get(\"sendToUrl\");\n        if (UtilValidate.isEmpty(sendToUrl)) {\n            sendToUrl = UtilProperties.getPropertyValue(\"oagis.properties\", \"url.send.processShipment\");\n        }\n        \n        String saveToFilename = (String) context.get(\"saveToFilename\");\n        if (UtilValidate.isEmpty(saveToFilename)) {\n            String saveToFilenameBase = UtilProperties.getPropertyValue(\"oagis.properties\", \"test.save.outgoing.filename.base\", \"\");\n            if (UtilValidate.isNotEmpty(saveToFilenameBase)) {\n                saveToFilename = saveToFilenameBase + \"ProcessShipment\" + orderId + \".xml\";\n            }\n        }\n        String saveToDirectory = (String) context.get(\"saveToDirectory\");\n        if (UtilValidate.isEmpty(saveToDirectory)) {\n            saveToDirectory = UtilProperties.getPropertyValue(\"oagis.properties\", \"test.save.outgoing.directory\");\n        }\n        \n        OutputStream out = (OutputStream) context.get(\"outputStream\");\n        \n        if (Debug.infoOn()) Debug.logInfo(\"Call to oagisProcessShipment for orderId [\" + orderId + \"], sendToUrl=[\" + sendToUrl + \"], saveToDirectory=[\" + saveToDirectory + \"], saveToFilename=[\" + saveToFilename + \"]\", module);\n        \n        Map result = ServiceUtil.returnSuccess();\n        MapStack bodyParameters =  MapStack.create();\n\n        // the userLogin passed in will usually be the customer, so don't use it; use the system user instead\n        GenericValue userLogin = null;\n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));\n        } catch (GenericEntityException e) {\n            Debug.logError(e, \"Error getting userLogin\", module);\n        }\n        \n        // check payment authorization\n        Map serviceContext = FastMap.newInstance();\n        serviceContext.put(\"orderId\", orderId);\n        serviceContext.put(\"userLogin\", userLogin);\n        serviceContext.put(\"reAuth\", new Boolean(\"true\"));\n        Map authResult = null;\n        try {\n            authResult = dispatcher.runSync(\"authOrderPayments\", serviceContext);\n            if (!authResult.get(\"processResult\").equals(\"APPROVED\")) {\n                return ServiceUtil.returnError(\"No valid payment available, cannot process Shipment\");            \n            }\n        } catch (GenericServiceException e) {\n            String errMsg = \"Error authorizing payment: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        }\n        GenericValue orderHeader = null;\n        GenericValue orderItemShipGroup = null;\n        try {\n            orderHeader = delegator.findByPrimaryKey(\"OrderHeader\", UtilMisc.toMap(\"orderId\", orderId));\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (orderHeader != null) {\n            String orderStatusId = orderHeader.getString(\"statusId\");\n            if (orderStatusId.equals(\"ORDER_APPROVED\")) {\n                String logicalId = UtilProperties.getPropertyValue(\"oagis.properties\", \"CNTROLAREA.SENDER.LOGICALID\");\n                bodyParameters.put(\"logicalId\", logicalId);\n                Map comiCtx = UtilMisc.toMap(\"logicalId\", logicalId);\n                \n                String authId = UtilProperties.getPropertyValue(\"oagis.properties\", \"CNTROLAREA.SENDER.AUTHID\");\n                bodyParameters.put(\"authId\", authId);\n                comiCtx.put(\"authId\", authId);\n    \n                String referenceId = delegator.getNextSeqId(\"OagisMessageInfo\");\n                bodyParameters.put(\"referenceId\", referenceId);\n                comiCtx.put(\"referenceId\", referenceId);\n                    \n                DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSS'Z'Z\");\n                Timestamp timestamp = UtilDateTime.nowTimestamp();\n                String sentDate = dateFormat.format(timestamp);\n                bodyParameters.put(\"sentDate\", sentDate);\n                comiCtx.put(\"sentDate\", timestamp);\n\n                // prepare map to Create Oagis Message Info\n                comiCtx.put(\"processingStatusId\", \"OAGMP_TRIGGERED\");\n                comiCtx.put(\"component\", \"INVENTORY\");\n                comiCtx.put(\"task\", \"SHIPREQUES\"); // Actual value of task is \"SHIPREQUEST\" which is more than 10 char\n                comiCtx.put(\"outgoingMessage\", \"Y\");\n                comiCtx.put(\"confirmation\", \"1\");\n                comiCtx.put(\"bsrVerb\", \"PROCESS\");\n                comiCtx.put(\"bsrNoun\", \"SHIPMENT\");\n                comiCtx.put(\"bsrRevision\", \"001\");\n                comiCtx.put(\"orderId\", orderId);\n                comiCtx.put(\"userLogin\", userLogin);\n                try {\n                    dispatcher.runSync(\"createOagisMessageInfo\", comiCtx, 60, true);\n                } catch (GenericServiceException e){\n                    String errMsg = UtilProperties.getMessage(ServiceUtil.resource, \"OagisErrorInCreatingDataForOagisMessageInfoEntity\", (Locale) context.get(\"locale\"));\n                    Debug.logError(e, errMsg, module);\n                }\n                if (Debug.infoOn()) Debug.logInfo(\"Saved OagisMessageInfo for oagisProcessShipment message for orderId [\" + orderId + \"]\", module);\n\n                String shipmentId = null;\n                try {\n                    // check to see if there is already a Shipment for this order\n                    EntityCondition findShipmentCondition = new EntityConditionList(UtilMisc.toList(\n                            new EntityExpr(\"primaryOrderId\", EntityOperator.EQUALS, orderId),\n                            new EntityExpr(\"statusId\", EntityOperator.NOT_EQUAL, \"SHIPMENT_CANCELLED\")\n                            ), EntityOperator.AND);\n                    List shipmentList = delegator.findByCondition(\"Shipment\", findShipmentCondition, null, null);\n                    GenericValue shipment = EntityUtil.getFirst(shipmentList);\n                    \n                    if (shipment != null) {\n                        // if picked, packed, shipped, delivered then complain, no reason to process the shipment!\n                        String statusId = shipment.getString(\"statusId\");\n                        if (\"SHIPMENT_PICKED\".equals(statusId) || \"SHIPMENT_PACKED\".equals(statusId) || \"SHIPMENT_SHIPPED\".equals(statusId) || \"SHIPMENT_DELIVERED\".equals(statusId)) {\n                            return ServiceUtil.returnError(\"Not sending Process Shipment message because found Shipment that is already being processed, is in status [\" + statusId + \"]\");\n                        }\n                        shipmentId = shipment.getString(\"shipmentId\");\n                    } else {\n                        Map cospResult= dispatcher.runSync(\"createOrderShipmentPlan\", UtilMisc.toMap(\"orderId\", orderId, \"userLogin\", userLogin));\n                        shipmentId = (String) cospResult.get(\"shipmentId\");\n                        shipment = delegator.findByPrimaryKey(\"Shipment\", UtilMisc.toMap(\"shipmentId\", shipmentId));\n                    }\n                    \n                    bodyParameters.put(\"shipment\", shipment);\n                    OrderReadHelper orderReadHelper = new OrderReadHelper(orderHeader);\n                    if(orderReadHelper.hasShippingAddress()) {\n                        GenericValue  address = EntityUtil.getFirst(orderReadHelper.getShippingLocations());\n                        bodyParameters.put(\"address\", address);\n                    }\n                    String emailString = orderReadHelper.getOrderEmailString();\n                    bodyParameters.put(\"emailString\", emailString);\n                    String contactMechId = shipment.getString(\"destinationTelecomNumberId\");\n                    GenericValue telecomNumber = delegator.findByPrimaryKey(\"TelecomNumber\", UtilMisc.toMap(\"contactMechId\", contactMechId));\n                    bodyParameters.put(\"telecomNumber\", telecomNumber);\n                    List shipmentItems = delegator.findByAnd(\"ShipmentItem\", UtilMisc.toMap(\"shipmentId\", shipmentId));\n                    bodyParameters.put(\"shipmentItems\", shipmentItems);\n                    orderItemShipGroup = EntityUtil.getFirst(delegator.findByAnd(\"OrderItemShipGroup\", UtilMisc.toMap(\"orderId\", orderId)));\n                    bodyParameters.put(\"orderItemShipGroup\", orderItemShipGroup);\n                    Set correspondingPoIdSet = FastSet.newInstance();\n                    List orderItems = delegator.findByAnd(\"OrderItem\", UtilMisc.toMap(\"orderId\", orderId));\n                    Iterator oiIter = orderItems.iterator();\n                    while (oiIter.hasNext()) {\n                        GenericValue orderItem = (GenericValue) oiIter.next();\n                        String correspondingPoId = orderItem.getString(\"correspondingPoId\");\n                        if (correspondingPoId != null) {\n                            correspondingPoIdSet.add(correspondingPoId);\n                        }\n                    }\n                    bodyParameters.put(\"correspondingPoIdSet\", correspondingPoIdSet);\n                    if (orderHeader.get(\"externalId\") != null) {\n                        Set externalIdSet = FastSet.newInstance();\n                        externalIdSet.add(orderHeader.getString(\"externalId\"));\n                        bodyParameters.put(\"externalIdSet\", externalIdSet);\n                    }\n                    // Check if order was a return replacement order (associated with return)\n                    GenericValue returnItemResponse = EntityUtil.getFirst(delegator.findByAnd(\"ReturnItemResponse\", UtilMisc.toMap(\"replacementOrderId\", orderId)));\n                    if (returnItemResponse != null) {\n                        bodyParameters.put(\"shipnotes\", \"RETURNLABEL\");\n                        \n                        // Get the associated return Id (replaceReturnId)\n                        String returnItemResponseId = returnItemResponse.getString(\"returnItemResponseId\");\n                        GenericValue returnItem = EntityUtil.getFirst(delegator.findByAnd(\"ReturnItem\", UtilMisc.toMap(\"returnItemResponseId\", returnItemResponseId)));\n                        bodyParameters.put(\"replacementReturnId\", returnItem.getString(\"returnId\"));\n                    }\n                    // tracking shipper account, other Party info\n                    String partyId = shipment.getString(\"partyIdTo\");\n                    bodyParameters.put(\"partyNameView\", delegator.findByPrimaryKey(\"PartyNameView\", UtilMisc.toMap(\"partyId\", partyId)));\n                    List partyCarrierAccounts = delegator.findByAnd(\"PartyCarrierAccount\", UtilMisc.toMap(\"partyId\", partyId));\n                    partyCarrierAccounts = EntityUtil.filterByDate(partyCarrierAccounts);\n                    if (partyCarrierAccounts != null) {\n                        Iterator pcaIter = partyCarrierAccounts.iterator();\n                        while (pcaIter.hasNext()) {\n                            GenericValue partyCarrierAccount = (GenericValue) pcaIter.next();\n                            String carrierPartyId = partyCarrierAccount.getString(\"carrierPartyId\");\n                            if (carrierPartyId.equals(orderItemShipGroup.getString(\"carrierPartyId\"))) {\n                                String accountNumber = partyCarrierAccount.getString(\"accountNumber\");\n                                bodyParameters.put(\"shipperId\", accountNumber);\n                            }\n                        }\n                    }\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error preparing data for OAGIS Process Shipment message: \" + e.toString();\n                    Debug.logError(e, errMsg, module);\n                    return ServiceUtil.returnError(errMsg);\n                } catch (GenericEntityException e) {\n                    String errMsg = \"Error preparing data for OAGIS Process Shipment message: \" + e.toString();\n                    Debug.logError(e, errMsg, module);\n                    return ServiceUtil.returnError(errMsg);\n                }\n                \n                bodyParameters.put(\"shipmentId\", shipmentId);\n                bodyParameters.put(\"orderId\", orderId);\n                bodyParameters.put(\"userLogin\", userLogin);\n\n                \n                String bodyScreenUri = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Template.ProcessShipment\");\n\n                String outText = null;\n                try {\n                    Writer writer = new StringWriter();\n                    ScreenRenderer screens = new ScreenRenderer(writer, bodyParameters, htmlScreenRenderer);\n                    screens.render(bodyScreenUri);\n                    writer.close();\n                    outText = writer.toString();\n                } catch (Exception e) {\n                    String errMsg = \"Error rendering message: \" + e.toString();\n                    Debug.logError(e, errMsg, module);\n                    return ServiceUtil.returnError(errMsg);\n                }\n                if (Debug.infoOn()) Debug.logInfo(\"Finished rendering oagisProcessShipment message for orderId [\" + orderId + \"]\", module);\n\n                comiCtx.put(\"processingStatusId\", \"OAGMP_OGEN_SUCCESS\");\n                comiCtx.put(\"shipmentId\", shipmentId);\n                if (OagisServices.debugSaveXmlOut) {\n                    comiCtx.put(\"fullMessageXml\", outText);\n                }\n                try {\n                    dispatcher.runSync(\"updateOagisMessageInfo\", comiCtx, 60, true);\n                } catch (GenericServiceException e){\n                    String errMsg = UtilProperties.getMessage(ServiceUtil.resource, \"OagisErrorInCreatingDataForOagisMessageInfoEntity\", (Locale) context.get(\"locale\"));\n                    Debug.logError(e, errMsg, module);\n                }\n                \n                Map sendMessageReturn = OagisServices.sendMessageText(outText, out, sendToUrl, saveToDirectory, saveToFilename);\n                if (sendMessageReturn != null) {\n                    return sendMessageReturn;\n                }\n                if (Debug.infoOn()) Debug.logInfo(\"Message send done for oagisProcessShipment for orderId [\" + orderId + \"], sendToUrl=[\" + sendToUrl + \"], saveToDirectory=[\" + saveToDirectory + \"], saveToFilename=[\" + saveToFilename + \"]\", module);\n\n                comiCtx.put(\"processingStatusId\", \"OAGMP_SENT\");\n                try {\n                    dispatcher.runSync(\"updateOagisMessageInfo\", comiCtx, 60, true);\n                } catch (GenericServiceException e){\n                    String errMsg = UtilProperties.getMessage(ServiceUtil.resource, \"OagisErrorInCreatingDataForOagisMessageInfoEntity\", (Locale) context.get(\"locale\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            }\n        }\n        return result;\n    }","id":29008,"modified_method":"public static Map oagisProcessShipment(DispatchContext ctx, Map context) {\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        String orderId = (String) context.get(\"orderId\");\n        \n        String sendToUrl = (String) context.get(\"sendToUrl\");\n        if (UtilValidate.isEmpty(sendToUrl)) {\n            sendToUrl = UtilProperties.getPropertyValue(\"oagis.properties\", \"url.send.processShipment\");\n        }\n        \n        String saveToFilename = (String) context.get(\"saveToFilename\");\n        if (UtilValidate.isEmpty(saveToFilename)) {\n            String saveToFilenameBase = UtilProperties.getPropertyValue(\"oagis.properties\", \"test.save.outgoing.filename.base\", \"\");\n            if (UtilValidate.isNotEmpty(saveToFilenameBase)) {\n                saveToFilename = saveToFilenameBase + \"ProcessShipment\" + orderId + \".xml\";\n            }\n        }\n        String saveToDirectory = (String) context.get(\"saveToDirectory\");\n        if (UtilValidate.isEmpty(saveToDirectory)) {\n            saveToDirectory = UtilProperties.getPropertyValue(\"oagis.properties\", \"test.save.outgoing.directory\");\n        }\n        \n        OutputStream out = (OutputStream) context.get(\"outputStream\");\n        \n        if (Debug.infoOn()) Debug.logInfo(\"Call to oagisProcessShipment for orderId [\" + orderId + \"], sendToUrl=[\" + sendToUrl + \"], saveToDirectory=[\" + saveToDirectory + \"], saveToFilename=[\" + saveToFilename + \"]\", module);\n        \n        Map result = ServiceUtil.returnSuccess();\n        MapStack bodyParameters =  MapStack.create();\n\n        // the userLogin passed in will usually be the customer, so don't use it; use the system user instead\n        GenericValue userLogin = null;\n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));\n        } catch (GenericEntityException e) {\n            Debug.logError(e, \"Error getting userLogin\", module);\n        }\n        \n        // check payment authorization\n        Map serviceContext = FastMap.newInstance();\n        serviceContext.put(\"orderId\", orderId);\n        serviceContext.put(\"userLogin\", userLogin);\n        serviceContext.put(\"reAuth\", new Boolean(\"true\"));\n        Map authResult = null;\n        try {\n            authResult = dispatcher.runSync(\"authOrderPayments\", serviceContext);\n            if (!authResult.get(\"processResult\").equals(\"APPROVED\")) {\n                return ServiceUtil.returnError(\"No valid payment available, cannot process Shipment\");            \n            }\n        } catch (GenericServiceException e) {\n            String errMsg = \"Error authorizing payment: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        }\n        GenericValue orderHeader = null;\n        GenericValue orderItemShipGroup = null;\n        try {\n            orderHeader = delegator.findByPrimaryKey(\"OrderHeader\", UtilMisc.toMap(\"orderId\", orderId));\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (orderHeader != null) {\n            String orderStatusId = orderHeader.getString(\"statusId\");\n            if (orderStatusId.equals(\"ORDER_APPROVED\")) {\n                // first check some things...\n                OrderReadHelper orderReadHelper = new OrderReadHelper(orderHeader);\n                try {\n                    // before doing or saving anything see if any OrderItems are Products with isPhysical=Y\n                    if (!orderReadHelper.hasPhysicalProductItems()) {\n                        // no need to process shipment, return success\n                        return ServiceUtil.returnSuccess();\n                    }\n                } catch (GenericEntityException e) {\n                    String errMsg = \"Error checking order: \" + e.toString();\n                    Debug.logError(e, errMsg, module);\n                    return ServiceUtil.returnError(errMsg);\n                }\n                if (!orderReadHelper.hasShippingAddress()) {\n                    return ServiceUtil.returnError(\"Cannot send Process Shipment for order [\" + orderId + \"], it has no shipping address.\");\n                }\n\n\n                String logicalId = UtilProperties.getPropertyValue(\"oagis.properties\", \"CNTROLAREA.SENDER.LOGICALID\");\n                bodyParameters.put(\"logicalId\", logicalId);\n                Map comiCtx = UtilMisc.toMap(\"logicalId\", logicalId);\n                \n                String authId = UtilProperties.getPropertyValue(\"oagis.properties\", \"CNTROLAREA.SENDER.AUTHID\");\n                bodyParameters.put(\"authId\", authId);\n                comiCtx.put(\"authId\", authId);\n    \n                String referenceId = delegator.getNextSeqId(\"OagisMessageInfo\");\n                bodyParameters.put(\"referenceId\", referenceId);\n                comiCtx.put(\"referenceId\", referenceId);\n                    \n                Timestamp timestamp = UtilDateTime.nowTimestamp();\n                String sentDate = OagisServices.isoDateFormat.format(timestamp);\n                bodyParameters.put(\"sentDate\", sentDate);\n                comiCtx.put(\"sentDate\", timestamp);\n                \n                // prepare map to Create Oagis Message Info\n                comiCtx.put(\"processingStatusId\", \"OAGMP_TRIGGERED\");\n                comiCtx.put(\"component\", \"INVENTORY\");\n                comiCtx.put(\"task\", \"SHIPREQUES\"); // Actual value of task is \"SHIPREQUEST\" which is more than 10 char\n                comiCtx.put(\"outgoingMessage\", \"Y\");\n                comiCtx.put(\"confirmation\", \"1\");\n                comiCtx.put(\"bsrVerb\", \"PROCESS\");\n                comiCtx.put(\"bsrNoun\", \"SHIPMENT\");\n                comiCtx.put(\"bsrRevision\", \"001\");\n                comiCtx.put(\"orderId\", orderId);\n                comiCtx.put(\"userLogin\", userLogin);\n                try {\n                    dispatcher.runSync(\"createOagisMessageInfo\", comiCtx, 60, true);\n                } catch (GenericServiceException e){\n                    String errMsg = UtilProperties.getMessage(ServiceUtil.resource, \"OagisErrorInCreatingDataForOagisMessageInfoEntity\", (Locale) context.get(\"locale\"));\n                    Debug.logError(e, errMsg, module);\n                }\n                if (Debug.infoOn()) Debug.logInfo(\"Saved OagisMessageInfo for oagisProcessShipment message for orderId [\" + orderId + \"]\", module);\n\n                String shipmentId = null;\n                try {\n                    // check to see if there is already a Shipment for this order\n                    EntityCondition findShipmentCondition = new EntityConditionList(UtilMisc.toList(\n                            new EntityExpr(\"primaryOrderId\", EntityOperator.EQUALS, orderId),\n                            new EntityExpr(\"statusId\", EntityOperator.NOT_EQUAL, \"SHIPMENT_CANCELLED\")\n                            ), EntityOperator.AND);\n                    List shipmentList = delegator.findByCondition(\"Shipment\", findShipmentCondition, null, null);\n                    GenericValue shipment = EntityUtil.getFirst(shipmentList);\n                    \n                    if (shipment != null) {\n                        // if picked, packed, shipped, delivered then complain, no reason to process the shipment!\n                        String statusId = shipment.getString(\"statusId\");\n                        if (\"SHIPMENT_PICKED\".equals(statusId) || \"SHIPMENT_PACKED\".equals(statusId) || \"SHIPMENT_SHIPPED\".equals(statusId) || \"SHIPMENT_DELIVERED\".equals(statusId)) {\n                            return ServiceUtil.returnError(\"Not sending Process Shipment message because found Shipment that is already being processed, is in status [\" + statusId + \"]\");\n                        }\n                        shipmentId = shipment.getString(\"shipmentId\");\n                    } else {\n                        Map cospResult= dispatcher.runSync(\"createOrderShipmentPlan\", UtilMisc.toMap(\"orderId\", orderId, \"userLogin\", userLogin));\n                        shipmentId = (String) cospResult.get(\"shipmentId\");\n                        shipment = delegator.findByPrimaryKey(\"Shipment\", UtilMisc.toMap(\"shipmentId\", shipmentId));\n                    }\n                    \n                    bodyParameters.put(\"shipment\", shipment);\n                    List shipmentItems = delegator.findByAnd(\"ShipmentItem\", UtilMisc.toMap(\"shipmentId\", shipmentId));\n                    bodyParameters.put(\"shipmentItems\", shipmentItems);\n\n                    GenericValue  address = EntityUtil.getFirst(orderReadHelper.getShippingLocations());\n                    bodyParameters.put(\"address\", address);\n                    String emailString = orderReadHelper.getOrderEmailString();\n                    bodyParameters.put(\"emailString\", emailString);\n                    String contactMechId = shipment.getString(\"destinationTelecomNumberId\");\n                    GenericValue telecomNumber = delegator.findByPrimaryKey(\"TelecomNumber\", UtilMisc.toMap(\"contactMechId\", contactMechId));\n                    bodyParameters.put(\"telecomNumber\", telecomNumber);\n                    \n                    orderItemShipGroup = EntityUtil.getFirst(delegator.findByAnd(\"OrderItemShipGroup\", UtilMisc.toMap(\"orderId\", orderId)));\n                    bodyParameters.put(\"orderItemShipGroup\", orderItemShipGroup);\n                    Set correspondingPoIdSet = FastSet.newInstance();\n\n                    List orderItems = orderReadHelper.getOrderItems();\n                    Iterator oiIter = orderItems.iterator();\n                    while (oiIter.hasNext()) {\n                        GenericValue orderItem = (GenericValue) oiIter.next();\n                        String correspondingPoId = orderItem.getString(\"correspondingPoId\");\n                        if (correspondingPoId != null) {\n                            correspondingPoIdSet.add(correspondingPoId);\n                        }\n                    }\n                    bodyParameters.put(\"correspondingPoIdSet\", correspondingPoIdSet);\n                    if (orderHeader.get(\"externalId\") != null) {\n                        Set externalIdSet = FastSet.newInstance();\n                        externalIdSet.add(orderHeader.getString(\"externalId\"));\n                        bodyParameters.put(\"externalIdSet\", externalIdSet);\n                    }\n                    // Check if order was a return replacement order (associated with return)\n                    GenericValue returnItemResponse = EntityUtil.getFirst(delegator.findByAnd(\"ReturnItemResponse\", UtilMisc.toMap(\"replacementOrderId\", orderId)));\n                    if (returnItemResponse != null) {\n                        bodyParameters.put(\"shipnotes\", \"RETURNLABEL\");\n                        \n                        // Get the associated return Id (replaceReturnId)\n                        String returnItemResponseId = returnItemResponse.getString(\"returnItemResponseId\");\n                        GenericValue returnItem = EntityUtil.getFirst(delegator.findByAnd(\"ReturnItem\", UtilMisc.toMap(\"returnItemResponseId\", returnItemResponseId)));\n                        bodyParameters.put(\"replacementReturnId\", returnItem.getString(\"returnId\"));\n                    }\n                    // tracking shipper account, other Party info\n                    String partyId = shipment.getString(\"partyIdTo\");\n                    bodyParameters.put(\"partyNameView\", delegator.findByPrimaryKey(\"PartyNameView\", UtilMisc.toMap(\"partyId\", partyId)));\n                    List partyCarrierAccounts = delegator.findByAnd(\"PartyCarrierAccount\", UtilMisc.toMap(\"partyId\", partyId));\n                    partyCarrierAccounts = EntityUtil.filterByDate(partyCarrierAccounts);\n                    if (partyCarrierAccounts != null) {\n                        Iterator pcaIter = partyCarrierAccounts.iterator();\n                        while (pcaIter.hasNext()) {\n                            GenericValue partyCarrierAccount = (GenericValue) pcaIter.next();\n                            String carrierPartyId = partyCarrierAccount.getString(\"carrierPartyId\");\n                            if (carrierPartyId.equals(orderItemShipGroup.getString(\"carrierPartyId\"))) {\n                                String accountNumber = partyCarrierAccount.getString(\"accountNumber\");\n                                bodyParameters.put(\"shipperId\", accountNumber);\n                            }\n                        }\n                    }\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error preparing data for OAGIS Process Shipment message: \" + e.toString();\n                    Debug.logError(e, errMsg, module);\n                    return ServiceUtil.returnError(errMsg);\n                } catch (GenericEntityException e) {\n                    String errMsg = \"Error preparing data for OAGIS Process Shipment message: \" + e.toString();\n                    Debug.logError(e, errMsg, module);\n                    return ServiceUtil.returnError(errMsg);\n                }\n                \n                bodyParameters.put(\"shipmentId\", shipmentId);\n                bodyParameters.put(\"orderId\", orderId);\n                bodyParameters.put(\"userLogin\", userLogin);\n\n                \n                String bodyScreenUri = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Template.ProcessShipment\");\n\n                String outText = null;\n                try {\n                    Writer writer = new StringWriter();\n                    ScreenRenderer screens = new ScreenRenderer(writer, bodyParameters, htmlScreenRenderer);\n                    screens.render(bodyScreenUri);\n                    writer.close();\n                    outText = writer.toString();\n                } catch (Exception e) {\n                    String errMsg = \"Error rendering message: \" + e.toString();\n                    Debug.logError(e, errMsg, module);\n                    return ServiceUtil.returnError(errMsg);\n                }\n                if (Debug.infoOn()) Debug.logInfo(\"Finished rendering oagisProcessShipment message for orderId [\" + orderId + \"]\", module);\n\n                comiCtx.put(\"processingStatusId\", \"OAGMP_OGEN_SUCCESS\");\n                comiCtx.put(\"shipmentId\", shipmentId);\n                if (OagisServices.debugSaveXmlOut) {\n                    comiCtx.put(\"fullMessageXml\", outText);\n                }\n                try {\n                    dispatcher.runSync(\"updateOagisMessageInfo\", comiCtx, 60, true);\n                } catch (GenericServiceException e){\n                    String errMsg = UtilProperties.getMessage(ServiceUtil.resource, \"OagisErrorInCreatingDataForOagisMessageInfoEntity\", (Locale) context.get(\"locale\"));\n                    Debug.logError(e, errMsg, module);\n                }\n                \n                Map sendMessageReturn = OagisServices.sendMessageText(outText, out, sendToUrl, saveToDirectory, saveToFilename);\n                if (sendMessageReturn != null) {\n                    return sendMessageReturn;\n                }\n                if (Debug.infoOn()) Debug.logInfo(\"Message send done for oagisProcessShipment for orderId [\" + orderId + \"], sendToUrl=[\" + sendToUrl + \"], saveToDirectory=[\" + saveToDirectory + \"], saveToFilename=[\" + saveToFilename + \"]\", module);\n\n                comiCtx.put(\"processingStatusId\", \"OAGMP_SENT\");\n                try {\n                    dispatcher.runSync(\"updateOagisMessageInfo\", comiCtx, 60, true);\n                } catch (GenericServiceException e){\n                    String errMsg = UtilProperties.getMessage(ServiceUtil.resource, \"OagisErrorInCreatingDataForOagisMessageInfoEntity\", (Locale) context.get(\"locale\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            }\n        }\n        return result;\n    }","commit_id":"266d64a708ffc47c8e7a3796e2b1eeff8d1810bc","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map receivePoAcknowledge(DispatchContext ctx, Map context) {\n        Document doc = (Document) context.get(\"document\");\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        List errorMapList = FastList.newInstance();\n        Map comiCtx = FastMap.newInstance();\n\n        GenericValue userLogin = null;\n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error Getting UserLogin: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        // parse the message \n        Element receivePoElement = doc.getDocumentElement();\n        receivePoElement.normalize();\n        Element docCtrlAreaElement = UtilXml.firstChildElement(receivePoElement, \"os:CNTROLAREA\");\n            \n        Element docSenderElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:SENDER\");\n        Element docBsrElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:BSR\");\n\n        String bsrVerb = UtilXml.childElementValue(docBsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(docBsrElement, \"of:NOUN\");\n        String bsrRevision = UtilXml.childElementValue(docBsrElement, \"of:REVISION\");\n        \n        String logicalId = UtilXml.childElementValue(docSenderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(docSenderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(docSenderElement, \"of:TASK\"); // This field should be Not more then 10 char long\n        String referenceId = UtilXml.childElementValue(docSenderElement, \"of:REFERENCEID\");\n        String confirmation = UtilXml.childElementValue(docSenderElement, \"of:CONFIRMATION\");\n        String authId = UtilXml.childElementValue(docSenderElement, \"of:AUTHID\");\n\n        String sentDate = UtilXml.childElementValue(docCtrlAreaElement, \"os:DATETIMEISO\");\n        Timestamp sentTimestamp = OagisServices.parseIsoDateString(sentDate, errorMapList);\n        \n        Timestamp timestamp = UtilDateTime.nowTimestamp();\n        comiCtx.put(\"logicalId\", logicalId);\n        comiCtx.put(\"authId\", authId);\n        comiCtx.put(\"referenceId\", referenceId);\n        comiCtx.put(\"receivedDate\", timestamp);\n        comiCtx.put(\"sentDate\", sentTimestamp);\n        comiCtx.put(\"component\", component);\n        comiCtx.put(\"task\", task);  \n        comiCtx.put(\"outgoingMessage\", \"N\");\n        comiCtx.put(\"confirmation\", confirmation);\n        comiCtx.put(\"bsrVerb\", bsrVerb);\n        comiCtx.put(\"bsrNoun\", bsrNoun);\n        comiCtx.put(\"bsrRevision\", bsrRevision);\n        comiCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        comiCtx.put(\"userLogin\", userLogin);\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                comiCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", comiCtx, 60, true);\n        } catch (GenericServiceException e) {\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n\n        Element dataAreaElement = UtilXml.firstChildElement(receivePoElement, \"ns:DATAAREA\");\n        Element acknowledgeDeliveryElement = UtilXml.firstChildElement(dataAreaElement, \"ns:ACKNOWLEDGE_DELIVERY\");\n\n        String facilityId = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Warehouse.PoReceiptFacilityId\");\n        String productId = null;\n        // get RECEIPTLN elements from message\n        List acknowledgeElementList = UtilXml.childElementList(acknowledgeDeliveryElement, \"ns:RECEIPTLN\");\n        if (UtilValidate.isNotEmpty(acknowledgeElementList)) {\n            Iterator acknowledgeElementIter = acknowledgeElementList.iterator();\n            while (acknowledgeElementIter.hasNext()) {\n                Map ripCtx = FastMap.newInstance();\n                Element receiptLnElement = (Element) acknowledgeElementIter.next();\n                Element qtyElement = UtilXml.firstChildElement(receiptLnElement, \"os:QUANTITY\");\n                \n                String itemQtyStr = UtilXml.childElementValue(qtyElement, \"of:VALUE\");\n                double itemQty = Double.parseDouble(itemQtyStr);\n                String sign = UtilXml.childElementValue(qtyElement, \"of:SIGN\");\n                \n                productId = UtilXml.childElementValue(receiptLnElement, \"of:ITEM\");\n                \n                Element documentRefElement = UtilXml.firstChildElement(receiptLnElement, \"os:DOCUMNTREF\");\n                String orderId = UtilXml.childElementValue(documentRefElement, \"of:DOCUMENTID\");\n                String orderTypeId = UtilXml.childElementValue(documentRefElement, \"of:DOCTYPE\");\n                if(orderTypeId.equals(\"PO\")) {\n                    orderTypeId = \"PURCHASE_ORDER\";\n                }\n                \n                String datetimeReceived = UtilXml.childElementValue(receiptLnElement, \"os:DATETIMEISO\");\n                Timestamp timestampItemReceived = OagisServices.parseIsoDateString(datetimeReceived, errorMapList);\n                ripCtx.put(\"datetimeReceived\", timestampItemReceived);\n                // Check reference to PO number, if exists\n                GenericValue orderHeader = null;\n                if(orderId != null) {\n                    try {\n                        List toStore = FastList.newInstance();\n                        orderHeader = delegator.findByPrimaryKey(\"OrderHeader\", UtilMisc.toMap(\"orderId\", orderId));\n                        if (orderHeader != null) {\n                            // Case : update the record \n                            ripCtx.put(\"orderId\", orderId);\n                            comiCtx.put(\"orderId\", orderId);\n                            GenericValue orderItem = delegator.makeValue(\"OrderItem\", UtilMisc.toMap(\"orderId\", orderId, \"productId\",productId,\"quantity\",new Double(itemQtyStr)));\n                            delegator.setNextSubSeqId(orderItem,\"orderItemSeqId\", 5, 1);\n                            delegator.create(orderItem);\n                            ripCtx.put(\"orderItemSeqId\", orderItem.get(\"orderItemSeqId\"));\n                        } else { \n                            // Case : New record entry when PO not exists in the Database\n                            orderHeader =  delegator.makeValue(\"OrderHeader\", UtilMisc.toMap(\"orderId\", orderId, \"orderTypeId\",orderTypeId , \n                                    \"orderDate\", timestampItemReceived, \"statusId\", \"ORDER_CREATED\", \"entryDate\", UtilDateTime.nowTimestamp(),\n                                    \"productStoreId\", UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Warehouse.SyncInventoryProductStoreId\",\"9001\")));\n                            toStore.add(orderHeader);\n                            GenericValue orderItem = delegator.makeValue(\"OrderItem\", UtilMisc.toMap(\"orderId\", orderId , \n                                    \"orderItemSeqId\", UtilFormatOut.formatPaddedNumber(1L, 5) ,\n                                    \"productId\",productId ,\"quantity\",new Double(itemQtyStr) ));\n                            toStore.add(orderItem);\n                            delegator.storeAll(toStore);\n                        }\n                    } catch (GenericEntityException e) {\n                        String errMsg = \"Error Getting OrderHeader: \" + e.toString();\n                        errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                        Debug.logError(e, errMsg, module);\n                    }\n                }\n                // get inventory item status\n                String invItemStatus = UtilXml.childElementValue(receiptLnElement, \"of:DISPOSITN\");\n                if (invItemStatus.equals(\"ReceivedTOAvailable\") || invItemStatus.equals(\"NotAvailableTOAvailable\")) {\n                    ripCtx.put(\"statusId\",\"INV_AVAILABLE\");    \n                } else if (invItemStatus.equals(\"ReceivedTONotAvailable\") || invItemStatus.equals(\"AvailableTONotAvailable\") ) {\n                    ripCtx.put(\"statusId\",\"INV_ON_HOLD\");\n                }\n                ripCtx.put(\"inventoryItemTypeId\", \"NON_SERIAL_INV_ITEM\");\n                ripCtx.put(\"productId\", productId);\n                ripCtx.put(\"facilityId\",facilityId);\n                ripCtx.put(\"userLogin\", userLogin);\n\n                // sign handling for items\n                double quantityAccepted = 0.0;\n                double quantityRejected = 0.0;\n                if (sign.equals(\"+\")) {\n                    quantityAccepted = itemQty;\n                    quantityRejected= 0.0;\n                } else {\n                    quantityRejected = itemQty;\n                    quantityAccepted = 0.0;\n                }\n                ripCtx.put(\"quantityAccepted\", new Double(quantityAccepted));\n                ripCtx.put(\"quantityRejected\", new Double(quantityRejected));\n                try {\n                    Map ripResult = dispatcher.runSync(\"receiveInventoryProduct\", ripCtx);\n                    if (ServiceUtil.isError(ripResult)) {\n                        String errMsg = ServiceUtil.getErrorMessage(ripResult);\n                        errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"ReceiveInventoryServiceError\", \"description\", errMsg));\n                    }\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service receiveInventoryProduct: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericServiceException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }    \n            }\n        }\n        \n        comiCtx.put(\"processingStatusId\", \"OAGMP_PROC_SUCCESS\");\n        try {\n            dispatcher.runSync(\"updateOagisMessageInfo\", comiCtx, 60, true);\n        } catch (GenericServiceException e) {\n            String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n\n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n        \n        if (errorMapList.size() > 0) {\n            result.put(\"errorMapList\", errorMapList);\n            String errMsg = \"Error Processing Received Messages\";\n            result.putAll(ServiceUtil.returnError(errMsg));\n            return result;\n        }\n        result.putAll(ServiceUtil.returnSuccess(\"Action Performed Successfully\"));\n        return result;\n    }","id":29009,"modified_method":"public static Map receivePoAcknowledge(DispatchContext ctx, Map context) {\n        Document doc = (Document) context.get(\"document\");\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        List errorMapList = FastList.newInstance();\n        Map comiCtx = FastMap.newInstance();\n\n        GenericValue userLogin = null;\n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error Getting UserLogin: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        // parse the message \n        Element receivePoElement = doc.getDocumentElement();\n        receivePoElement.normalize();\n        Element docCtrlAreaElement = UtilXml.firstChildElement(receivePoElement, \"os:CNTROLAREA\");\n            \n        Element docSenderElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:SENDER\");\n        Element docBsrElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:BSR\");\n\n        String bsrVerb = UtilXml.childElementValue(docBsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(docBsrElement, \"of:NOUN\");\n        String bsrRevision = UtilXml.childElementValue(docBsrElement, \"of:REVISION\");\n        \n        String logicalId = UtilXml.childElementValue(docSenderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(docSenderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(docSenderElement, \"of:TASK\"); // This field should be Not more then 10 char long\n        String referenceId = UtilXml.childElementValue(docSenderElement, \"of:REFERENCEID\");\n        String confirmation = UtilXml.childElementValue(docSenderElement, \"of:CONFIRMATION\");\n        String authId = UtilXml.childElementValue(docSenderElement, \"of:AUTHID\");\n\n        String sentDate = UtilXml.childElementValue(docCtrlAreaElement, \"os:DATETIMEISO\");\n        Timestamp sentTimestamp = OagisServices.parseIsoDateString(sentDate, errorMapList);\n        \n        Timestamp timestamp = UtilDateTime.nowTimestamp();\n        comiCtx.put(\"logicalId\", logicalId);\n        comiCtx.put(\"authId\", authId);\n        comiCtx.put(\"referenceId\", referenceId);\n        comiCtx.put(\"receivedDate\", timestamp);\n        comiCtx.put(\"sentDate\", sentTimestamp);\n        comiCtx.put(\"component\", component);\n        comiCtx.put(\"task\", task);  \n        comiCtx.put(\"outgoingMessage\", \"N\");\n        comiCtx.put(\"confirmation\", confirmation);\n        comiCtx.put(\"bsrVerb\", bsrVerb);\n        comiCtx.put(\"bsrNoun\", bsrNoun);\n        comiCtx.put(\"bsrRevision\", bsrRevision);\n        comiCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        comiCtx.put(\"userLogin\", userLogin);\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                comiCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", comiCtx, 60, true);\n        } catch (GenericServiceException e) {\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n\n        Element dataAreaElement = UtilXml.firstChildElement(receivePoElement, \"ns:DATAAREA\");\n        Element acknowledgeDeliveryElement = UtilXml.firstChildElement(dataAreaElement, \"ns:ACKNOWLEDGE_DELIVERY\");\n\n        String facilityId = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Warehouse.PoReceiptFacilityId\");\n        String productId = null;\n        String orderId = null;\n        // get RECEIPTLN elements from message\n        List acknowledgeElementList = UtilXml.childElementList(acknowledgeDeliveryElement, \"ns:RECEIPTLN\");\n        if (UtilValidate.isNotEmpty(acknowledgeElementList)) {\n            Iterator acknowledgeElementIter = acknowledgeElementList.iterator();\n            while (acknowledgeElementIter.hasNext()) {\n                Map ripCtx = FastMap.newInstance();\n                Element receiptLnElement = (Element) acknowledgeElementIter.next();\n                Element qtyElement = UtilXml.firstChildElement(receiptLnElement, \"os:QUANTITY\");\n                \n                String itemQtyStr = UtilXml.childElementValue(qtyElement, \"of:VALUE\");\n                double itemQty = Double.parseDouble(itemQtyStr);\n                String sign = UtilXml.childElementValue(qtyElement, \"of:SIGN\");\n                \n                productId = UtilXml.childElementValue(receiptLnElement, \"of:ITEM\");\n                \n                Element documentRefElement = UtilXml.firstChildElement(receiptLnElement, \"os:DOCUMNTREF\");\n                orderId = UtilXml.childElementValue(documentRefElement, \"of:DOCUMENTID\");\n                String orderTypeId = UtilXml.childElementValue(documentRefElement, \"of:DOCTYPE\");\n                if(orderTypeId.equals(\"PO\")) {\n                    orderTypeId = \"PURCHASE_ORDER\";\n                }\n                \n                String datetimeReceived = UtilXml.childElementValue(receiptLnElement, \"os:DATETIMEISO\");\n                Timestamp timestampItemReceived = OagisServices.parseIsoDateString(datetimeReceived, errorMapList);\n                ripCtx.put(\"datetimeReceived\", timestampItemReceived);\n                // Check reference to PO number, if exists\n                GenericValue orderHeader = null;\n                if (orderId != null) {\n                    try {\n                        List toStore = FastList.newInstance();\n                        orderHeader = delegator.findByPrimaryKey(\"OrderHeader\", UtilMisc.toMap(\"orderId\", orderId));\n                        if (orderHeader != null) {\n                            // Case : update the record \n                            ripCtx.put(\"orderId\", orderId);\n                            comiCtx.put(\"orderId\", orderId);\n                            GenericValue orderItem = delegator.makeValue(\"OrderItem\", UtilMisc.toMap(\"orderId\", orderId, \"productId\",productId,\"quantity\",new Double(itemQtyStr)));\n                            delegator.setNextSubSeqId(orderItem,\"orderItemSeqId\", 5, 1);\n                            delegator.create(orderItem);\n                            ripCtx.put(\"orderItemSeqId\", orderItem.get(\"orderItemSeqId\"));\n                        } else { \n                            // Case : New record entry when PO not exists in the Database\n                            orderHeader =  delegator.makeValue(\"OrderHeader\", UtilMisc.toMap(\"orderId\", orderId, \"orderTypeId\",orderTypeId , \n                                    \"orderDate\", timestampItemReceived, \"statusId\", \"ORDER_CREATED\", \"entryDate\", UtilDateTime.nowTimestamp(),\n                                    \"productStoreId\", UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Warehouse.SyncInventoryProductStoreId\",\"9001\")));\n                            toStore.add(orderHeader);\n                            GenericValue orderItem = delegator.makeValue(\"OrderItem\", UtilMisc.toMap(\"orderId\", orderId , \n                                    \"orderItemSeqId\", UtilFormatOut.formatPaddedNumber(1L, 5) ,\n                                    \"productId\",productId ,\"quantity\",new Double(itemQtyStr) ));\n                            toStore.add(orderItem);\n                            delegator.storeAll(toStore);\n                        }\n                    } catch (GenericEntityException e) {\n                        String errMsg = \"Error Getting OrderHeader: \" + e.toString();\n                        errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                        Debug.logError(e, errMsg, module);\n                    }\n                }\n                // get inventory item status\n                String invItemStatus = UtilXml.childElementValue(receiptLnElement, \"of:DISPOSITN\");\n                if (invItemStatus.equals(\"ReceivedTOAvailable\") || invItemStatus.equals(\"NotAvailableTOAvailable\")) {\n                    ripCtx.put(\"statusId\",\"INV_AVAILABLE\");    \n                } else if (invItemStatus.equals(\"ReceivedTONotAvailable\") || invItemStatus.equals(\"AvailableTONotAvailable\") ) {\n                    ripCtx.put(\"statusId\",\"INV_ON_HOLD\");\n                }\n                ripCtx.put(\"inventoryItemTypeId\", \"NON_SERIAL_INV_ITEM\");\n                ripCtx.put(\"productId\", productId);\n                ripCtx.put(\"facilityId\",facilityId);\n                ripCtx.put(\"userLogin\", userLogin);\n\n                // sign handling for items\n                double quantityAccepted = 0.0;\n                double quantityRejected = 0.0;\n                if (sign.equals(\"+\")) {\n                    quantityAccepted = itemQty;\n                    quantityRejected= 0.0;\n                } else {\n                    quantityRejected = itemQty;\n                    quantityAccepted = 0.0;\n                }\n                ripCtx.put(\"quantityAccepted\", new Double(quantityAccepted));\n                ripCtx.put(\"quantityRejected\", new Double(quantityRejected));\n                try {\n                    Map ripResult = dispatcher.runSync(\"receiveInventoryProduct\", ripCtx);\n                    if (ServiceUtil.isError(ripResult)) {\n                        String errMsg = ServiceUtil.getErrorMessage(ripResult);\n                        errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"ReceiveInventoryServiceError\", \"description\", errMsg));\n                    }\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service receiveInventoryProduct: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericServiceException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }    \n            }\n        }\n\n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n\n        if (errorMapList.size() > 0) {\n            // call services createOagisMsgErrInfosFromErrMapList and for incoming messages oagisSendConfirmBod\n            Map saveErrorMapListCtx = FastMap.newInstance();\n            saveErrorMapListCtx.put(\"logicalId\", logicalId);\n            saveErrorMapListCtx.put(\"component\", component);\n            saveErrorMapListCtx.put(\"task\", task);\n            saveErrorMapListCtx.put(\"referenceId\", referenceId);\n            saveErrorMapListCtx.put(\"errorMapList\", errorMapList);\n            try {\n                dispatcher.runSync(\"createOagisMsgErrInfosFromErrMapList\", saveErrorMapListCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n            }\n\n            try {\n                Map sendConfirmBodCtx = FastMap.newInstance();\n                sendConfirmBodCtx.putAll(saveErrorMapListCtx);\n                // NOTE: this is different for each service, should be shipmentId or returnId or PO orderId or etc\n                sendConfirmBodCtx.put(\"origRefId\", orderId);\n\n                // run async because this will send a message back to the other server and may take some time, and/or fail\n                dispatcher.runAsync(\"oagisSendConfirmBod\", sendConfirmBodCtx, null, true, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n            }\n            \n            // DEJ20070807 what was this next line commented out? if there are errors we want to return an error so this will roll back \n            result.putAll(ServiceUtil.returnError(\"Errors found processing message; information saved and return error sent back\"));\n            return result;\n        } else {\n            comiCtx.put(\"processingStatusId\", \"OAGMP_PROC_SUCCESS\");\n            try {\n                dispatcher.runSync(\"updateOagisMessageInfo\", comiCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                Debug.logError(e, errMsg, module);\n            }\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","commit_id":"f66389a0d041a1838260c31371049da583dfbc0c","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map receiveRmaAcknowledge(DispatchContext ctx, Map context) {\n        Document doc = (Document) context.get(\"document\");\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        List errorMapList = FastList.newInstance();\n        \n        GenericValue userLogin = null;\n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error Getting UserLogin: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n\n        // parse the message\n        Element receiveRmaElement = doc.getDocumentElement();\n        receiveRmaElement.normalize();\n        Element docCtrlAreaElement = UtilXml.firstChildElement(receiveRmaElement, \"os:CNTROLAREA\");\n        Element docSenderElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:SENDER\");\n        Element docBsrElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:BSR\");\n            \n        String bsrVerb = UtilXml.childElementValue(docBsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(docBsrElement, \"of:NOUN\");\n        String bsrRevision = UtilXml.childElementValue(docBsrElement, \"of:REVISION\");\n            \n        String logicalId = UtilXml.childElementValue(docSenderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(docSenderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(docSenderElement, \"of:TASK\");\n        String referenceId = UtilXml.childElementValue(docSenderElement, \"of:REFERENCEID\");\n        String confirmation = UtilXml.childElementValue(docSenderElement, \"of:CONFIRMATION\");\n        String authId = UtilXml.childElementValue(docSenderElement, \"of:AUTHID\");\n            \n        String sentDate = UtilXml.childElementValue(docCtrlAreaElement, \"os:DATETIMEISO\");\n        Timestamp sentTimestamp = OagisServices.parseIsoDateString(sentDate, errorMapList);\n\n        Element dataAreaElement = UtilXml.firstChildElement(receiveRmaElement, \"ns:DATAAREA\");\n        Element acknowledgeDeliveryElement = UtilXml.firstChildElement(dataAreaElement, \"ns:ACKNOWLEDGE_DELIVERY\");\n        \n        String inventoryItemTypeId = null;\n        String returnId = null;\n        String facilityId = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Warehouse.PoReceiptFacilityId\");\n        String locationSeqId = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Warehouse.ReturnReceiptLocationSeqId\");\n        \n        Timestamp timestamp = UtilDateTime.nowTimestamp();\n        Map comiCtx = FastMap.newInstance();\n        comiCtx.put(\"logicalId\", logicalId);\n        comiCtx.put(\"authId\", authId);\n        comiCtx.put(\"referenceId\", referenceId);\n        comiCtx.put(\"receivedDate\", timestamp);\n        comiCtx.put(\"sentDate\", sentTimestamp);\n        comiCtx.put(\"component\", component);\n        comiCtx.put(\"task\", task);  \n        comiCtx.put(\"outgoingMessage\", \"N\");\n        comiCtx.put(\"confirmation\", confirmation);\n        comiCtx.put(\"bsrVerb\", bsrVerb);\n        comiCtx.put(\"bsrNoun\", bsrNoun);\n        comiCtx.put(\"bsrRevision\", bsrRevision);\n        comiCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        comiCtx.put(\"userLogin\", userLogin);\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                comiCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", comiCtx, 60, true);\n        } catch (GenericServiceException e) {\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        String statusId = null;\n        List invItemIds = FastList.newInstance();\n        // get RECEIPTLN elements from message\n        List acknowledgeElementList = UtilXml.childElementList(acknowledgeDeliveryElement, \"ns:RECEIPTLN\");\n        if (UtilValidate.isNotEmpty(acknowledgeElementList)) {\n            Iterator acknowledgeElementIter = acknowledgeElementList.iterator();\n            while (acknowledgeElementIter.hasNext()) {\n                Map ripCtx = FastMap.newInstance();\n                Element receiptLnElement = (Element) acknowledgeElementIter.next();\n                Element qtyElement = UtilXml.firstChildElement(receiptLnElement, \"os:QUANTITY\");\n\n                String itemQtyStr = UtilXml.childElementValue(qtyElement, \"of:VALUE\");\n                double itemQty = Double.parseDouble(itemQtyStr);\n                String sign = UtilXml.childElementValue(qtyElement, \"of:SIGN\");\n\n                String productId = UtilXml.childElementValue(receiptLnElement, \"of:ITEM\");\n                if ( productId == null ) {\n                    String errMsg = \"productId not available in Message\" ;\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"ParseException\", \"description\", errMsg));\n                    Debug.logError(errMsg, module);\n                }\n                Element documentRefElement = UtilXml.firstChildElement(receiptLnElement, \"os:DOCUMNTREF\");\n                returnId = UtilXml.childElementValue(documentRefElement, \"of:DOCUMENTID\");\n                ripCtx.put(\"returnId\", returnId);\n\n                String returnHeaderTypeId = UtilXml.childElementValue(documentRefElement, \"of:DOCTYPE\");\n                if(returnHeaderTypeId.equals(\"RMA\")) {\n                    returnHeaderTypeId = \"CUSTOMER_RETURN\";\n                }\n                String returnItemSeqId = UtilXml.childElementValue(documentRefElement, \"of:LINENUM\");\n                String datetimeReceived = UtilXml.childElementValue(receiptLnElement, \"os:DATETIMEISO\");\n                Timestamp timestampItemReceived = OagisServices.parseIsoDateString(datetimeReceived, errorMapList);\n                ripCtx.put(\"datetimeReceived\", timestampItemReceived);\n\n                GenericValue returnHeader = null;\n                try {\n                    returnHeader = delegator.findByPrimaryKey(\"ReturnHeader\", UtilMisc.toMap(\"returnId\", returnId));\n                } catch  (GenericEntityException e) {\n                    String errMsg = \"Error Getting ReturnHeader: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }\n\n                if (UtilValidate.isNotEmpty(returnHeader)) {\n                    //getting ReturnHeader status\n                    statusId = returnHeader.get(\"statusId\").toString();\n                    \n                    // getting inventory item status\n                    String invItemStatusId = null;\n                    String invItemStatus = UtilXml.childElementValue(receiptLnElement, \"of:DISPOSITN\");\n                    if ( invItemStatus.equals(\"ReceivedTOAvailable\") || invItemStatus.equals(\"NotAvailableTOAvailable\")) {\n                        invItemStatusId = \"INV_AVAILABLE\";\n                    } else if ( invItemStatus.equals(\"ReceivedTONotAvailable\") || invItemStatus.equals(\"AvailableTONotAvailable\") ) {\n                        invItemStatusId = \"INV_ON_HOLD\";\n                    }\n                    ripCtx.put(\"statusId\", invItemStatusId);\n                    // geting the serial number(s)\n                    String serialNumber = null;\n                    List serialNumsList = FastList.newInstance();\n                    List invDetailList = UtilXml.childElementList(receiptLnElement, \"ns:INVDETAIL\");\n                    if (UtilValidate.isNotEmpty(invDetailList)) {\n                        inventoryItemTypeId = \"SERIALIZED_INV_ITEM\";\n                        ripCtx.put(\"inventoryItemTypeId\", inventoryItemTypeId);\n                        for (Iterator j = invDetailList.iterator(); j.hasNext();) {\n                            Element invDetailElement = (Element) j.next();\n                            serialNumber = UtilXml.childElementValue(invDetailElement, \"of:SERIALNUM\");\n                            if (UtilValidate.isNotEmpty(serialNumber)) {\n                                serialNumsList.add(serialNumber);\n                            }\n                        }\n                            \n                        /* DEJ20070711 Commenting this out because it shouldn't happen, ie more likely the ITEM element will be filled \n                         * than INVDETAIL->SERIALNUM, and this isn't a reliable way to look it up (may be more than 1 record for a given \n                         * serialNumber for different products \n                         // this is a Serialized Inventory Item. If the productId from the message is not valid then lets read it from InventoryItem in Ofbiz database.\n                         if (productId == null || \"\".equals(productId)) {\n                         try {\n                             GenericValue inventoryItem = EntityUtil.getFirst(delegator.findByAnd(\"InventoryItem\", UtilMisc.toMap(\"serialNumber\", serialNumber)));\n                             if (inventoryItem !=null) {\n                                 productId = inventoryItem.getString(\"productId\");\n                             }\n                         } catch (GenericEntityException e){\n                             String errMsg = \"Error Getting Entity InventoryItem\";\n                             Debug.logError(e, errMsg, module);\n                        } */\n                    } else {\n                        inventoryItemTypeId = \"NON_SERIAL_INV_ITEM\";\n                        ripCtx.put(\"inventoryItemTypeId\", inventoryItemTypeId);\n                    }\n                        \n                    //do some validations\n                    boolean continueLoop = false;\n                    Integer messageQuantity = Integer.valueOf(itemQtyStr);\n                    if(UtilValidate.isNotEmpty(serialNumsList)) {\n                        if (messageQuantity.intValue() != serialNumsList.size()) {\n                            String errMsg = \"Not enough serial numbers [\" + serialNumsList.size() + \"] for the quantity [\" + messageQuantity.intValue() + \"].\";\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SerialNumbersMissing\"));\n                            Debug.logInfo(errMsg, module);\n                            continueLoop = true;\n                        }\n                    }\n                      \n                    if (continueLoop) {\n                        continue;\n                    }\n                      \n                    ripCtx.put(\"facilityId\",facilityId);\n                    ripCtx.put(\"locationSeqId\", locationSeqId);\n                    ripCtx.put(\"userLogin\", userLogin);\n\n                    // sign handling for items\n                    double quantityAccepted = 0.0;\n                    double quantityRejected = 0.0;\n                    if (sign.equals(\"+\")) {\n                        quantityAccepted = itemQty;\n                        quantityRejected= 0.0;\n                    } else {\n                        quantityRejected = itemQty;\n                        quantityAccepted = 0.0;\n                    }\n                    if (quantityAccepted > 0) {\n                        if (serialNumsList.size() > 0) {\n                            Iterator serialNumIter = serialNumsList.iterator();\n                            while (serialNumIter.hasNext()) {\n                                String serialNum = (String) serialNumIter.next();\n                                GenericValue inventoryItem = null;\n                                try {\n                                    inventoryItem = EntityUtil.getFirst(delegator.findByAnd(\"InventoryItem\", UtilMisc.toMap(\"serialNumber\", serialNum)));\n                                } catch (GenericEntityException e) {\n                                    String errMsg = \"Error Getting Entity InventoryItem\";\n                                    Debug.logError(e, errMsg, module);\n                                }\n                                if (inventoryItem != null) {\n                                    Map updateInvItmMap = FastMap.newInstance();\n                                    updateInvItmMap.put( \"inventoryItemId\" , inventoryItem.getString(\"inventoryItemId\"));\n                                    updateInvItmMap.put( \"userLogin\" , userLogin);\n                                    updateInvItmMap.put( \"statusId\",invItemStatusId);\n                                    String inventoryItemProductId = inventoryItem.getString(\"productId\");\n                                    if(!inventoryItemProductId.equals(productId)) {\n                                        updateInvItmMap.put( \"productId\",productId);\n                                    }\n                                    try {\n                                        Map test = dispatcher.runSync(\"updateInventoryItem\", updateInvItmMap);\n                                    } catch (GenericServiceException e) {\n                                        String errMsg = \"Error running service updateInventoryItem: \" + e.toString();\n                                        errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericServiceException\", \"description\", errMsg));\n                                        Debug.logError(e, errMsg, module);\n                                    }\n                                    invItemIds.add(UtilMisc.toMap(\"inventoryItemId\", inventoryItem.getString(\"inventoryItemId\")));\n                                    \n                                } else {\n                                    //clone the context as it may be changed in the call\n                                    Map localRipCtx = FastMap.newInstance();\n                                    localRipCtx.putAll(ripCtx);\n                                    localRipCtx.put(\"quantityAccepted\", new Double(1.0));\n                                    // always set this to 0, if needed we'll handle the rejected quantity separately\n                                    localRipCtx.put(\"quantityRejected\", new Double(0.0));\n                                    localRipCtx.put(\"serialNumber\", serialNum);\n                                    localRipCtx.put(\"productId\", productId);\n                                    localRipCtx.put(\"returnItemSeqId\", returnItemSeqId);\n                                    runReceiveInventoryProduct( localRipCtx , errorMapList , dispatcher, invItemIds);\n                                }\n                            }\n                        } else {\n                            // no serial numbers, just receive the quantity\n                            // clone the context as it may be changted in the call\n                            Map localRipCtx = FastMap.newInstance();\n                            localRipCtx.putAll(ripCtx);\n                            localRipCtx.put(\"quantityAccepted\", new Double(quantityAccepted));\n                            // always set this to 0, if needed we'll handle the rejected quantity separately\n                            localRipCtx.put(\"quantityRejected\", new Double(0.0));\n                            localRipCtx.put(\"productId\", productId);\n                            localRipCtx.put(\"returnItemSeqId\", returnItemSeqId);\n                            runReceiveInventoryProduct( localRipCtx , errorMapList , dispatcher, invItemIds);\n                        }\n                    } else {\n                        // TODOLATER: need to run service receiveInventoryProduct and updateInventoryItem when quantityRejected > 0\n                        // NOTE DEJ20070711 this shouldn't happen for current needs, so save for later\n                    }\n                } else {\n                    String errMsg = \"ReturnId Not Valid: Id not present in Database\";\n                    Debug.logError(errMsg, module);\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                }\n            }\n            \n            if (UtilValidate.isNotEmpty(statusId) && statusId.equals(\"RETURN_ACCEPTED\")) {\n                statusId = \"RETURN_COMPLETED\";\n                try {\n                    dispatcher.runSync(\"updateReturnHeader\", UtilMisc.toMap(\"statusId\", statusId, \"returnId\", returnId, \"userLogin\", userLogin));\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error Storing the value: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }\n            }\n            \n        }\n\n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n        if (errorMapList.size() > 0) {\n            result.put(\"errorMapList\", errorMapList);\n            String errMsg = \"Error Processing Received Messages\";\n            result.putAll(ServiceUtil.returnError(errMsg));\n            return result;\n        } else {\n            comiCtx.put(\"returnId\", returnId);\n            comiCtx.put(\"processingStatusId\", \"OAGMP_PROC_SUCCESS\");\n            try {\n                dispatcher.runSync(\"updateOagisMessageInfo\", comiCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n            }\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Action Performed Successfully\"));\n        result.put(\"inventoryItemIdList\", invItemIds);\n        return result;\n    }","id":29010,"modified_method":"public static Map receiveRmaAcknowledge(DispatchContext ctx, Map context) {\n        Document doc = (Document) context.get(\"document\");\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        List errorMapList = FastList.newInstance();\n        \n        GenericValue userLogin = null;\n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error Getting UserLogin: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n\n        // parse the message\n        Element receiveRmaElement = doc.getDocumentElement();\n        receiveRmaElement.normalize();\n        Element docCtrlAreaElement = UtilXml.firstChildElement(receiveRmaElement, \"os:CNTROLAREA\");\n        Element docSenderElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:SENDER\");\n        Element docBsrElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:BSR\");\n            \n        String bsrVerb = UtilXml.childElementValue(docBsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(docBsrElement, \"of:NOUN\");\n        String bsrRevision = UtilXml.childElementValue(docBsrElement, \"of:REVISION\");\n            \n        String logicalId = UtilXml.childElementValue(docSenderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(docSenderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(docSenderElement, \"of:TASK\");\n        String referenceId = UtilXml.childElementValue(docSenderElement, \"of:REFERENCEID\");\n        String confirmation = UtilXml.childElementValue(docSenderElement, \"of:CONFIRMATION\");\n        String authId = UtilXml.childElementValue(docSenderElement, \"of:AUTHID\");\n            \n        String sentDate = UtilXml.childElementValue(docCtrlAreaElement, \"os:DATETIMEISO\");\n        Timestamp sentTimestamp = OagisServices.parseIsoDateString(sentDate, errorMapList);\n\n        Element dataAreaElement = UtilXml.firstChildElement(receiveRmaElement, \"ns:DATAAREA\");\n        Element acknowledgeDeliveryElement = UtilXml.firstChildElement(dataAreaElement, \"ns:ACKNOWLEDGE_DELIVERY\");\n        \n        String inventoryItemTypeId = null;\n        String returnId = null;\n        String facilityId = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Warehouse.PoReceiptFacilityId\");\n        String locationSeqId = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Warehouse.ReturnReceiptLocationSeqId\");\n        \n        Timestamp timestamp = UtilDateTime.nowTimestamp();\n        Map comiCtx = FastMap.newInstance();\n        comiCtx.put(\"logicalId\", logicalId);\n        comiCtx.put(\"authId\", authId);\n        comiCtx.put(\"referenceId\", referenceId);\n        comiCtx.put(\"receivedDate\", timestamp);\n        comiCtx.put(\"sentDate\", sentTimestamp);\n        comiCtx.put(\"component\", component);\n        comiCtx.put(\"task\", task);  \n        comiCtx.put(\"outgoingMessage\", \"N\");\n        comiCtx.put(\"confirmation\", confirmation);\n        comiCtx.put(\"bsrVerb\", bsrVerb);\n        comiCtx.put(\"bsrNoun\", bsrNoun);\n        comiCtx.put(\"bsrRevision\", bsrRevision);\n        comiCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        comiCtx.put(\"userLogin\", userLogin);\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                comiCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", comiCtx, 60, true);\n        } catch (GenericServiceException e) {\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        String statusId = null;\n        List invItemIds = FastList.newInstance();\n        // get RECEIPTLN elements from message\n        List acknowledgeElementList = UtilXml.childElementList(acknowledgeDeliveryElement, \"ns:RECEIPTLN\");\n        if (UtilValidate.isNotEmpty(acknowledgeElementList)) {\n            Iterator acknowledgeElementIter = acknowledgeElementList.iterator();\n            while (acknowledgeElementIter.hasNext()) {\n                Map ripCtx = FastMap.newInstance();\n                Element receiptLnElement = (Element) acknowledgeElementIter.next();\n                Element qtyElement = UtilXml.firstChildElement(receiptLnElement, \"os:QUANTITY\");\n\n                String itemQtyStr = UtilXml.childElementValue(qtyElement, \"of:VALUE\");\n                double itemQty = Double.parseDouble(itemQtyStr);\n                String sign = UtilXml.childElementValue(qtyElement, \"of:SIGN\");\n\n                String productId = UtilXml.childElementValue(receiptLnElement, \"of:ITEM\");\n                if (productId == null) {\n                    String errMsg = \"productId not available in Message\" ;\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"ParseException\", \"description\", errMsg));\n                    Debug.logError(errMsg, module);\n                }\n                Element documentRefElement = UtilXml.firstChildElement(receiptLnElement, \"os:DOCUMNTREF\");\n                returnId = UtilXml.childElementValue(documentRefElement, \"of:DOCUMENTID\");\n                ripCtx.put(\"returnId\", returnId);\n\n                String returnHeaderTypeId = UtilXml.childElementValue(documentRefElement, \"of:DOCTYPE\");\n                if(returnHeaderTypeId.equals(\"RMA\")) {\n                    returnHeaderTypeId = \"CUSTOMER_RETURN\";\n                }\n                String returnItemSeqId = UtilXml.childElementValue(documentRefElement, \"of:LINENUM\");\n                String datetimeReceived = UtilXml.childElementValue(receiptLnElement, \"os:DATETIMEISO\");\n                Timestamp timestampItemReceived = OagisServices.parseIsoDateString(datetimeReceived, errorMapList);\n                ripCtx.put(\"datetimeReceived\", timestampItemReceived);\n\n                GenericValue returnHeader = null;\n                try {\n                    returnHeader = delegator.findByPrimaryKey(\"ReturnHeader\", UtilMisc.toMap(\"returnId\", returnId));\n                } catch  (GenericEntityException e) {\n                    String errMsg = \"Error Getting ReturnHeader: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }\n\n                if (UtilValidate.isNotEmpty(returnHeader)) {\n                    //getting ReturnHeader status\n                    statusId = returnHeader.get(\"statusId\").toString();\n                    \n                    // getting inventory item status\n                    String invItemStatusId = null;\n                    String invItemStatus = UtilXml.childElementValue(receiptLnElement, \"of:DISPOSITN\");\n                    if ( invItemStatus.equals(\"ReceivedTOAvailable\") || invItemStatus.equals(\"NotAvailableTOAvailable\")) {\n                        invItemStatusId = \"INV_AVAILABLE\";\n                    } else if ( invItemStatus.equals(\"ReceivedTONotAvailable\") || invItemStatus.equals(\"AvailableTONotAvailable\") ) {\n                        invItemStatusId = \"INV_ON_HOLD\";\n                    }\n                    ripCtx.put(\"statusId\", invItemStatusId);\n                    // geting the serial number(s)\n                    String serialNumber = null;\n                    List serialNumsList = FastList.newInstance();\n                    List invDetailList = UtilXml.childElementList(receiptLnElement, \"ns:INVDETAIL\");\n                    if (UtilValidate.isNotEmpty(invDetailList)) {\n                        inventoryItemTypeId = \"SERIALIZED_INV_ITEM\";\n                        ripCtx.put(\"inventoryItemTypeId\", inventoryItemTypeId);\n                        for (Iterator j = invDetailList.iterator(); j.hasNext();) {\n                            Element invDetailElement = (Element) j.next();\n                            serialNumber = UtilXml.childElementValue(invDetailElement, \"of:SERIALNUM\");\n                            if (UtilValidate.isNotEmpty(serialNumber)) {\n                                serialNumsList.add(serialNumber);\n                            }\n                        }\n                            \n                        /* DEJ20070711 Commenting this out because it shouldn't happen, ie more likely the ITEM element will be filled \n                         * than INVDETAIL->SERIALNUM, and this isn't a reliable way to look it up (may be more than 1 record for a given \n                         * serialNumber for different products \n                         // this is a Serialized Inventory Item. If the productId from the message is not valid then lets read it from InventoryItem in Ofbiz database.\n                         if (productId == null || \"\".equals(productId)) {\n                         try {\n                             GenericValue inventoryItem = EntityUtil.getFirst(delegator.findByAnd(\"InventoryItem\", UtilMisc.toMap(\"serialNumber\", serialNumber)));\n                             if (inventoryItem !=null) {\n                                 productId = inventoryItem.getString(\"productId\");\n                             }\n                         } catch (GenericEntityException e){\n                             String errMsg = \"Error Getting Entity InventoryItem\";\n                             Debug.logError(e, errMsg, module);\n                        } */\n                    } else {\n                        inventoryItemTypeId = \"NON_SERIAL_INV_ITEM\";\n                        ripCtx.put(\"inventoryItemTypeId\", inventoryItemTypeId);\n                    }\n                        \n                    //do some validations\n                    boolean continueLoop = false;\n                    Integer messageQuantity = Integer.valueOf(itemQtyStr);\n                    if(UtilValidate.isNotEmpty(serialNumsList)) {\n                        if (messageQuantity.intValue() != serialNumsList.size()) {\n                            String errMsg = \"Not enough serial numbers [\" + serialNumsList.size() + \"] for the quantity [\" + messageQuantity.intValue() + \"].\";\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SerialNumbersMissing\"));\n                            Debug.logInfo(errMsg, module);\n                            continueLoop = true;\n                        }\n                    }\n                      \n                    if (continueLoop) {\n                        continue;\n                    }\n                      \n                    ripCtx.put(\"facilityId\",facilityId);\n                    ripCtx.put(\"locationSeqId\", locationSeqId);\n                    ripCtx.put(\"userLogin\", userLogin);\n\n                    // sign handling for items\n                    double quantityAccepted = 0.0;\n                    double quantityRejected = 0.0;\n                    if (sign.equals(\"+\")) {\n                        quantityAccepted = itemQty;\n                        quantityRejected= 0.0;\n                    } else {\n                        quantityRejected = itemQty;\n                        quantityAccepted = 0.0;\n                    }\n                    if (quantityAccepted > 0) {\n                        if (serialNumsList.size() > 0) {\n                            Iterator serialNumIter = serialNumsList.iterator();\n                            while (serialNumIter.hasNext()) {\n                                String serialNum = (String) serialNumIter.next();\n                                GenericValue inventoryItem = null;\n                                try {\n                                    inventoryItem = EntityUtil.getFirst(delegator.findByAnd(\"InventoryItem\", UtilMisc.toMap(\"serialNumber\", serialNum)));\n                                } catch (GenericEntityException e) {\n                                    String errMsg = \"Error Getting Entity InventoryItem\";\n                                    Debug.logError(e, errMsg, module);\n                                }\n                                if (inventoryItem != null) {\n                                    Map updateInvItmMap = FastMap.newInstance();\n                                    updateInvItmMap.put( \"inventoryItemId\" , inventoryItem.getString(\"inventoryItemId\"));\n                                    updateInvItmMap.put( \"userLogin\" , userLogin);\n                                    updateInvItmMap.put( \"statusId\",invItemStatusId);\n                                    String inventoryItemProductId = inventoryItem.getString(\"productId\");\n                                    if(!inventoryItemProductId.equals(productId)) {\n                                        updateInvItmMap.put( \"productId\",productId);\n                                    }\n                                    try {\n                                        Map test = dispatcher.runSync(\"updateInventoryItem\", updateInvItmMap);\n                                    } catch (GenericServiceException e) {\n                                        String errMsg = \"Error running service updateInventoryItem: \" + e.toString();\n                                        errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericServiceException\", \"description\", errMsg));\n                                        Debug.logError(e, errMsg, module);\n                                    }\n                                    invItemIds.add(UtilMisc.toMap(\"inventoryItemId\", inventoryItem.getString(\"inventoryItemId\")));\n                                    \n                                } else {\n                                    //clone the context as it may be changed in the call\n                                    Map localRipCtx = FastMap.newInstance();\n                                    localRipCtx.putAll(ripCtx);\n                                    localRipCtx.put(\"quantityAccepted\", new Double(1.0));\n                                    // always set this to 0, if needed we'll handle the rejected quantity separately\n                                    localRipCtx.put(\"quantityRejected\", new Double(0.0));\n                                    localRipCtx.put(\"serialNumber\", serialNum);\n                                    localRipCtx.put(\"productId\", productId);\n                                    localRipCtx.put(\"returnItemSeqId\", returnItemSeqId);\n                                    runReceiveInventoryProduct( localRipCtx , errorMapList , dispatcher, invItemIds);\n                                }\n                            }\n                        } else {\n                            // no serial numbers, just receive the quantity\n                            // clone the context as it may be changted in the call\n                            Map localRipCtx = FastMap.newInstance();\n                            localRipCtx.putAll(ripCtx);\n                            localRipCtx.put(\"quantityAccepted\", new Double(quantityAccepted));\n                            // always set this to 0, if needed we'll handle the rejected quantity separately\n                            localRipCtx.put(\"quantityRejected\", new Double(0.0));\n                            localRipCtx.put(\"productId\", productId);\n                            localRipCtx.put(\"returnItemSeqId\", returnItemSeqId);\n                            runReceiveInventoryProduct( localRipCtx , errorMapList , dispatcher, invItemIds);\n                        }\n                    } else {\n                        // TODOLATER: need to run service receiveInventoryProduct and updateInventoryItem when quantityRejected > 0\n                        // NOTE DEJ20070711 this shouldn't happen for current needs, so save for later\n                    }\n                } else {\n                    String errMsg = \"ReturnId Not Valid: Id not present in Database\";\n                    Debug.logError(errMsg, module);\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                }\n            }\n            \n            if (UtilValidate.isNotEmpty(statusId) && statusId.equals(\"RETURN_ACCEPTED\")) {\n                statusId = \"RETURN_COMPLETED\";\n                try {\n                    dispatcher.runSync(\"updateReturnHeader\", UtilMisc.toMap(\"statusId\", statusId, \"returnId\", returnId, \"userLogin\", userLogin));\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error Storing the value: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }\n            }\n            \n        }\n\n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n\n        if (errorMapList.size() > 0) {\n            // call services createOagisMsgErrInfosFromErrMapList and for incoming messages oagisSendConfirmBod\n            Map saveErrorMapListCtx = FastMap.newInstance();\n            saveErrorMapListCtx.put(\"logicalId\", logicalId);\n            saveErrorMapListCtx.put(\"component\", component);\n            saveErrorMapListCtx.put(\"task\", task);\n            saveErrorMapListCtx.put(\"referenceId\", referenceId);\n            saveErrorMapListCtx.put(\"errorMapList\", errorMapList);\n            try {\n                dispatcher.runSync(\"createOagisMsgErrInfosFromErrMapList\", saveErrorMapListCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n            }\n\n            try {\n                Map sendConfirmBodCtx = FastMap.newInstance();\n                sendConfirmBodCtx.putAll(saveErrorMapListCtx);\n                // NOTE: this is different for each service, should be shipmentId or returnId or PO orderId or etc\n                sendConfirmBodCtx.put(\"origRefId\", returnId);\n\n                // run async because this will send a message back to the other server and may take some time, and/or fail\n                dispatcher.runAsync(\"oagisSendConfirmBod\", sendConfirmBodCtx, null, true, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n            }\n            \n            // DEJ20070807 what was this next line commented out? if there are errors we want to return an error so this will roll back \n            result.putAll(ServiceUtil.returnError(\"Errors found processing message; information saved and return error sent back\"));\n            return result;\n        } else {\n            comiCtx.put(\"processingStatusId\", \"OAGMP_PROC_SUCCESS\");\n            try {\n                dispatcher.runSync(\"updateOagisMessageInfo\", comiCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                Debug.logError(e, errMsg, module);\n            }\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        result.put(\"inventoryItemIdList\", invItemIds);\n        return result;\n    }","commit_id":"f66389a0d041a1838260c31371049da583dfbc0c","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map syncInventory(DispatchContext ctx, Map context) {\n        Document doc = (Document) context.get(\"document\");\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        Locale locale = (Locale) context.get(\"locale\");\n        List errorMapList = FastList.newInstance();\n        List inventoryMapList = FastList.newInstance();\n        \n        GenericValue userLogin = null;\n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));\n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n\n        String facilityId = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Warehouse.SyncInventoryFacilityId\");\n        \n        Element syncInventoryRootElement = doc.getDocumentElement();\n        syncInventoryRootElement.normalize();\n        Element docCtrlAreaElement = UtilXml.firstChildElement(syncInventoryRootElement, \"os:CNTROLAREA\");\n        Element docBsrElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:BSR\");\n        Element docSenderElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:SENDER\");\n        \n        String bsrVerb = UtilXml.childElementValue(docBsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(docBsrElement, \"of:NOUN\");\n        String bsrRevision = UtilXml.childElementValue(docBsrElement, \"of:REVISION\");\n\n        \n        String logicalId = UtilXml.childElementValue(docSenderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(docSenderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(docSenderElement, \"of:TASK\");\n        String referenceId = UtilXml.childElementValue(docSenderElement, \"of:REFERENCEID\");\n        String confirmation = UtilXml.childElementValue(docSenderElement, \"of:CONFIRMATION\");\n        String authId = UtilXml.childElementValue(docSenderElement, \"of:AUTHID\");\n        \n        // create oagis message info\n        Map comiCtx= FastMap.newInstance();\n        comiCtx.put(\"logicalId\", logicalId);\n        comiCtx.put(\"component\", component);\n        comiCtx.put(\"task\", task);\n        comiCtx.put(\"referenceId\", referenceId);\n        comiCtx.put(\"confirmation\", confirmation);\n        comiCtx.put(\"authId\", authId);\n        comiCtx.put(\"bsrVerb\", bsrVerb);\n        comiCtx.put(\"bsrNoun\", bsrNoun);\n        comiCtx.put(\"bsrRevision\", bsrRevision);\n        comiCtx.put(\"receivedDate\", UtilDateTime.nowTimestamp());\n        comiCtx.put(\"outgoingMessage\", \"N\");\n        comiCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        comiCtx.put(\"userLogin\", userLogin);\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                comiCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", comiCtx, 60, true);\n        } catch (GenericServiceException e) {\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n\n        // data area elements\n        List dataAreaList = UtilXml.childElementList(syncInventoryRootElement, \"ns:DATAAREA\");\n        if (UtilValidate.isNotEmpty(dataAreaList)) {\n            Iterator dataAreaIter = dataAreaList.iterator();\n            while (dataAreaIter.hasNext()) {\n                Element dataAreaElement = (Element) dataAreaIter.next();\n                Element syncInventoryElement = UtilXml.firstChildElement(dataAreaElement, \"ns:SYNC_INVENTORY\");\n                Element inventoryElement = UtilXml.firstChildElement(syncInventoryElement, \"ns:INVENTORY\");\n\n                Element quantityElement = UtilXml.firstChildElement(inventoryElement, \"os:QUANTITY\");\n                \n                String itemQtyStr = UtilXml.childElementValue(quantityElement, \"of:VALUE\");\n                double itemQty = Double.parseDouble(itemQtyStr);\n                /* TODO sign denoted whether quantity is accepted(+) or rejected(-), which plays role in receiving inventory\n                 * In this message will it serve any purpose, since it is not handled.\n                 */\n                String sign = UtilXml.childElementValue(quantityElement, \"of:SIGN\");\n                // TODO: Not used now, Later we may need it\n                //String uom = UtilXml.childElementValue(quantityElement, \"of:UOM\");\n                String productId = UtilXml.childElementValue(inventoryElement, \"of:ITEM\");\n                String itemStatus = UtilXml.childElementValue(inventoryElement, \"of:ITEMSTATUS\");\n                \n                // if anything but \"NOTAVAILABLE\" set to available\n                boolean isAvailable = !\"NOTAVAILABLE\".equals(itemStatus);\n                String statusId = \"INV_AVAILABLE\";\n                if (!isAvailable) {\n                    statusId = \"INV_ON_HOLD\"; \n                }\n                \n                String snapshotDateStr = UtilXml.childElementValue(inventoryElement, \"os:DATETIMEISO\");  \n                //Parse this into a valid Timestamp Object\n                Timestamp snapshotDate = OagisServices.parseIsoDateString(snapshotDateStr, errorMapList);\n                \n                // get quantity on hand diff   \n                double quantityOnHandTotal = 0.0;\n                \n                // only if looking for available inventory find the non-serialized QOH total\n                if (isAvailable) {\n                    EntityCondition condition = new EntityConditionList(UtilMisc.toList(\n                            new EntityExpr(\"effectiveDate\", EntityOperator.LESS_THAN_EQUAL_TO, snapshotDate), \n                            new EntityExpr(\"productId\", EntityOperator.EQUALS, productId),\n                            new EntityExpr(\"inventoryItemTypeId\", EntityOperator.EQUALS, \"NON_SERIAL_INV_ITEM\"),\n                            new EntityExpr(\"facilityId\", EntityOperator.EQUALS, facilityId)), EntityOperator.AND);\n                    try {\n                        List invItemAndDetails = delegator.findByCondition(\"InventoryItemDetailForSum\", condition, UtilMisc.toList(\"quantityOnHandSum\"), null);\n                        Iterator invItemAndDetailIter = invItemAndDetails.iterator();\n                        while (invItemAndDetailIter.hasNext()) {\n                            GenericValue inventoryItemDetailForSum = (GenericValue) invItemAndDetailIter.next();\n                            quantityOnHandTotal += inventoryItemDetailForSum.getDouble(\"quantityOnHandSum\").doubleValue();\n                        }\n                    } catch (GenericEntityException e) {\n                        String errMsg = \"Error Getting Inventory Item And Detail: \" + e.toString();\n                        errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                        Debug.logError(e, errMsg, module);\n                    }\n                }\n\n                // now regardless of AVAILABLE or NOTAVAILABLE check serialized inventory, just use the corresponding statusId as set above\n                EntityCondition serInvCondition = new EntityConditionList(UtilMisc.toList(\n                        new EntityExpr(\"statusDatetime\", EntityOperator.LESS_THAN_EQUAL_TO, snapshotDate),\n                        new EntityExpr(new EntityExpr(\"statusEndDatetime\", EntityOperator.GREATER_THAN, snapshotDate), EntityOperator.OR, new EntityExpr(\"statusEndDatetime\", EntityOperator.EQUALS, null)),\n                        new EntityExpr(\"productId\", EntityOperator.EQUALS, productId),\n                        new EntityExpr(\"statusId\", EntityOperator.EQUALS, statusId),\n                        new EntityExpr(\"inventoryItemTypeId\", EntityOperator.EQUALS, \"SERIALIZED_INV_ITEM\"),\n                        new EntityExpr(\"facilityId\", EntityOperator.EQUALS, facilityId)), EntityOperator.AND);\n                try {\n                    long invItemQuantCount = delegator.findCountByCondition(\"InventoryItemStatusForCount\", serInvCondition, null);\n                    quantityOnHandTotal += invItemQuantCount;\n                } catch (GenericEntityException e) {\n                    String errMsg = \"Error Getting Inventory Item by Status Count: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }\n                \n                // check for mismatch in quantity\n                if (itemQty != quantityOnHandTotal) {\n                    double quantityDiff = Math.abs((itemQty - quantityOnHandTotal));\n                    inventoryMapList.add(UtilMisc.toMap(\"productId\", productId, \"statusId\", statusId, \"quantityOnHandTotal\", String.valueOf(quantityOnHandTotal), \"quantityFromMessage\", itemQtyStr, \"quantityDiff\", String.valueOf(quantityDiff), \"timestamp\", snapshotDate));\n                }\n            }\n        }\n        // send mail if mismatch(s) found\n        if (inventoryMapList.size() > 0) {\n            // prepare information to send mail\n            Map sendMap = FastMap.newInstance();\n\n            String sendToEmail = UtilProperties.getPropertyValue(\"oagis.properties\", \"oagis.notification.email.sendTo\");\n    \n            /* DEJ20070802 changed to get email address from properties file, should be way easier to manage\n            // get facility email address\n            List facilityContactMechs = null;\n            GenericValue contactMech = null;\n            try {\n                facilityContactMechs = delegator.findByAnd(\"FacilityContactMech\", UtilMisc.toMap(\"facilityId\", facilityId));    \n            } catch (GenericEntityException e) {\n                String errMsg = \"Error Getting FacilityContactMech: \" + e.toString();\n                errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                Debug.logError(e, errMsg, module);\n            }\n\n            Iterator fcmIter  = facilityContactMechs.iterator();\n            while(fcmIter.hasNext()) {\n                GenericValue facilityContactMech = (GenericValue) fcmIter.next();\n                String contactMechId = facilityContactMech.getString(\"contactMechId\");\n                try {\n                    contactMech = delegator.findByPrimaryKey(\"ContactMech\", UtilMisc.toMap(\"contactMechId\", contactMechId));\n                } catch (GenericEntityException e) {\n                    String errMsg = \"Error Getting ContactMech: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }\n                String contactMechTypeId = contactMech.getString(\"contactMechTypeId\");\n                if (contactMechTypeId.equals(\"EMAIL_ADDRESS\")) {\n                    String emailString = contactMech.getString(\"infoString\");\n                    sendMap.put(\"sendTo\", emailString);\n                }\n            }\n            */\n            \n            if (UtilValidate.isNotEmpty(sendToEmail)) {\n                String productStoreId = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Warehouse.SyncInventoryProductStoreId\");\n                GenericValue productStoreEmail = null;\n                try {\n                    productStoreEmail = delegator.findByPrimaryKey(\"ProductStoreEmailSetting\", UtilMisc.toMap(\"productStoreId\", productStoreId, \"emailType\", \"PRDS_OAGIS_CONFIRM\"));\n                } catch (GenericEntityException e) {\n                    String errMsg = \"Error Getting Entity ProductStoreEmailSetting: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }\n                if (productStoreEmail != null) {\n                    String bodyScreenLocation = productStoreEmail.getString(\"bodyScreenLocation\");\n                    sendMap.put(\"bodyScreenUri\", bodyScreenLocation);\n                } else {\n                    sendMap.put(\"bodyScreenUri\", \"component://oagis/widget/EmailOagisMessageScreens.xml#InventoryMismatchNotice\");\n                }\n                if (locale == null) {\n                    locale = Locale.getDefault();\n                }\n\n                sendMap.put(\"sendTo\", sendToEmail);\n                \n                sendMap.put(\"subject\", productStoreEmail.getString(\"subject\"));\n                sendMap.put(\"sendFrom\", productStoreEmail.getString(\"fromAddress\"));\n                sendMap.put(\"sendCc\", productStoreEmail.getString(\"ccAddress\"));\n                sendMap.put(\"sendBcc\", productStoreEmail.getString(\"bccAddress\"));\n                sendMap.put(\"contentType\", productStoreEmail.getString(\"contentType\"));\n                \n                Map bodyParameters = UtilMisc.toMap(\"inventoryMapList\", inventoryMapList, \"locale\", locale);\n                sendMap.put(\"bodyParameters\", bodyParameters);\n                sendMap.put(\"userLogin\", userLogin);\n                \n                // send the notification\n                try {\n                    // run async so it will happen in the background AND so errors in sending won't mess this up\n                    dispatcher.runAsync(\"sendMailFromScreen\", sendMap, true);\n                } catch(Exception e) {\n                    String errMsg = \"Error Running Service sendMailFromScreen: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericServiceException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else {\n                // no send to email address, just log to file\n                Debug.logImportant(\"No sendTo email address found in process syncInventory service: inventoryMapList: \" + inventoryMapList, module);\n            }\n        }\n        \n        comiCtx.put(\"processingStatusId\", \"OAGMP_PROC_SUCCESS\");\n        try {\n            dispatcher.runSync(\"updateOagisMessageInfo\", comiCtx, 60, true);\n        } catch (GenericServiceException e) {\n            String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n\n        // check error list if there is any \n        if (errorMapList.size() > 0) {\n            result.put(\"errorMapList\", errorMapList);\n            String errMsg = \"Error Processing Received Messages\";\n            result.putAll(ServiceUtil.returnError(errMsg));\n            return result;\n        }\n        result.putAll(ServiceUtil.returnSuccess(\"Action Performed Successfully\"));\n        return result;\n    }","id":29011,"modified_method":"public static Map syncInventory(DispatchContext ctx, Map context) {\n        Document doc = (Document) context.get(\"document\");\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        Locale locale = (Locale) context.get(\"locale\");\n        List errorMapList = FastList.newInstance();\n        List inventoryMapList = FastList.newInstance();\n        \n        GenericValue userLogin = null;\n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));\n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n\n        String facilityId = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Warehouse.SyncInventoryFacilityId\");\n        \n        Element syncInventoryRootElement = doc.getDocumentElement();\n        syncInventoryRootElement.normalize();\n        Element docCtrlAreaElement = UtilXml.firstChildElement(syncInventoryRootElement, \"os:CNTROLAREA\");\n        Element docBsrElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:BSR\");\n        Element docSenderElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:SENDER\");\n        \n        String bsrVerb = UtilXml.childElementValue(docBsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(docBsrElement, \"of:NOUN\");\n        String bsrRevision = UtilXml.childElementValue(docBsrElement, \"of:REVISION\");\n\n        \n        String logicalId = UtilXml.childElementValue(docSenderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(docSenderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(docSenderElement, \"of:TASK\");\n        String referenceId = UtilXml.childElementValue(docSenderElement, \"of:REFERENCEID\");\n        String confirmation = UtilXml.childElementValue(docSenderElement, \"of:CONFIRMATION\");\n        String authId = UtilXml.childElementValue(docSenderElement, \"of:AUTHID\");\n        \n        // create oagis message info\n        Map comiCtx = FastMap.newInstance();\n        comiCtx.put(\"logicalId\", logicalId);\n        comiCtx.put(\"component\", component);\n        comiCtx.put(\"task\", task);\n        comiCtx.put(\"referenceId\", referenceId);\n        comiCtx.put(\"confirmation\", confirmation);\n        comiCtx.put(\"authId\", authId);\n        comiCtx.put(\"bsrVerb\", bsrVerb);\n        comiCtx.put(\"bsrNoun\", bsrNoun);\n        comiCtx.put(\"bsrRevision\", bsrRevision);\n        comiCtx.put(\"receivedDate\", UtilDateTime.nowTimestamp());\n        comiCtx.put(\"outgoingMessage\", \"N\");\n        comiCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        comiCtx.put(\"userLogin\", userLogin);\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                comiCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", comiCtx, 60, true);\n        } catch (GenericServiceException e) {\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n\n        // data area elements\n        List dataAreaList = UtilXml.childElementList(syncInventoryRootElement, \"ns:DATAAREA\");\n        if (UtilValidate.isNotEmpty(dataAreaList)) {\n            Iterator dataAreaIter = dataAreaList.iterator();\n            while (dataAreaIter.hasNext()) {\n                Element dataAreaElement = (Element) dataAreaIter.next();\n                Element syncInventoryElement = UtilXml.firstChildElement(dataAreaElement, \"ns:SYNC_INVENTORY\");\n                Element inventoryElement = UtilXml.firstChildElement(syncInventoryElement, \"ns:INVENTORY\");\n\n                Element quantityElement = UtilXml.firstChildElement(inventoryElement, \"os:QUANTITY\");\n                \n                String itemQtyStr = UtilXml.childElementValue(quantityElement, \"of:VALUE\");\n                double itemQty = Double.parseDouble(itemQtyStr);\n                /* TODO sign denoted whether quantity is accepted(+) or rejected(-), which plays role in receiving inventory\n                 * In this message will it serve any purpose, since it is not handled.\n                 */\n                String sign = UtilXml.childElementValue(quantityElement, \"of:SIGN\");\n                // TODO: Not used now, Later we may need it\n                //String uom = UtilXml.childElementValue(quantityElement, \"of:UOM\");\n                String productId = UtilXml.childElementValue(inventoryElement, \"of:ITEM\");\n                String itemStatus = UtilXml.childElementValue(inventoryElement, \"of:ITEMSTATUS\");\n                \n                // if anything but \"NOTAVAILABLE\" set to available\n                boolean isAvailable = !\"NOTAVAILABLE\".equals(itemStatus);\n                String statusId = \"INV_AVAILABLE\";\n                if (!isAvailable) {\n                    statusId = \"INV_ON_HOLD\"; \n                }\n                \n                String snapshotDateStr = UtilXml.childElementValue(inventoryElement, \"os:DATETIMEISO\");  \n                //Parse this into a valid Timestamp Object\n                Timestamp snapshotDate = OagisServices.parseIsoDateString(snapshotDateStr, errorMapList);\n                \n                // get quantity on hand diff   \n                double quantityOnHandTotal = 0.0;\n                \n                // only if looking for available inventory find the non-serialized QOH total\n                if (isAvailable) {\n                    EntityCondition condition = new EntityConditionList(UtilMisc.toList(\n                            new EntityExpr(\"effectiveDate\", EntityOperator.LESS_THAN_EQUAL_TO, snapshotDate), \n                            new EntityExpr(\"productId\", EntityOperator.EQUALS, productId),\n                            new EntityExpr(\"inventoryItemTypeId\", EntityOperator.EQUALS, \"NON_SERIAL_INV_ITEM\"),\n                            new EntityExpr(\"facilityId\", EntityOperator.EQUALS, facilityId)), EntityOperator.AND);\n                    try {\n                        List invItemAndDetails = delegator.findByCondition(\"InventoryItemDetailForSum\", condition, UtilMisc.toList(\"quantityOnHandSum\"), null);\n                        Iterator invItemAndDetailIter = invItemAndDetails.iterator();\n                        while (invItemAndDetailIter.hasNext()) {\n                            GenericValue inventoryItemDetailForSum = (GenericValue) invItemAndDetailIter.next();\n                            quantityOnHandTotal += inventoryItemDetailForSum.getDouble(\"quantityOnHandSum\").doubleValue();\n                        }\n                    } catch (GenericEntityException e) {\n                        String errMsg = \"Error Getting Inventory Item And Detail: \" + e.toString();\n                        errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                        Debug.logError(e, errMsg, module);\n                    }\n                }\n\n                // now regardless of AVAILABLE or NOTAVAILABLE check serialized inventory, just use the corresponding statusId as set above\n                EntityCondition serInvCondition = new EntityConditionList(UtilMisc.toList(\n                        new EntityExpr(\"statusDatetime\", EntityOperator.LESS_THAN_EQUAL_TO, snapshotDate),\n                        new EntityExpr(new EntityExpr(\"statusEndDatetime\", EntityOperator.GREATER_THAN, snapshotDate), EntityOperator.OR, new EntityExpr(\"statusEndDatetime\", EntityOperator.EQUALS, null)),\n                        new EntityExpr(\"productId\", EntityOperator.EQUALS, productId),\n                        new EntityExpr(\"statusId\", EntityOperator.EQUALS, statusId),\n                        new EntityExpr(\"inventoryItemTypeId\", EntityOperator.EQUALS, \"SERIALIZED_INV_ITEM\"),\n                        new EntityExpr(\"facilityId\", EntityOperator.EQUALS, facilityId)), EntityOperator.AND);\n                try {\n                    long invItemQuantCount = delegator.findCountByCondition(\"InventoryItemStatusForCount\", serInvCondition, null);\n                    quantityOnHandTotal += invItemQuantCount;\n                } catch (GenericEntityException e) {\n                    String errMsg = \"Error Getting Inventory Item by Status Count: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }\n                \n                // check for mismatch in quantity\n                if (itemQty != quantityOnHandTotal) {\n                    double quantityDiff = Math.abs((itemQty - quantityOnHandTotal));\n                    inventoryMapList.add(UtilMisc.toMap(\"productId\", productId, \"statusId\", statusId, \"quantityOnHandTotal\", String.valueOf(quantityOnHandTotal), \"quantityFromMessage\", itemQtyStr, \"quantityDiff\", String.valueOf(quantityDiff), \"timestamp\", snapshotDate));\n                }\n            }\n        }\n        // send mail if mismatch(s) found\n        if (inventoryMapList.size() > 0) {\n            // prepare information to send mail\n            Map sendMap = FastMap.newInstance();\n\n            String sendToEmail = UtilProperties.getPropertyValue(\"oagis.properties\", \"oagis.notification.email.sendTo\");\n    \n            /* DEJ20070802 changed to get email address from properties file, should be way easier to manage\n            // get facility email address\n            List facilityContactMechs = null;\n            GenericValue contactMech = null;\n            try {\n                facilityContactMechs = delegator.findByAnd(\"FacilityContactMech\", UtilMisc.toMap(\"facilityId\", facilityId));    \n            } catch (GenericEntityException e) {\n                String errMsg = \"Error Getting FacilityContactMech: \" + e.toString();\n                errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                Debug.logError(e, errMsg, module);\n            }\n\n            Iterator fcmIter  = facilityContactMechs.iterator();\n            while(fcmIter.hasNext()) {\n                GenericValue facilityContactMech = (GenericValue) fcmIter.next();\n                String contactMechId = facilityContactMech.getString(\"contactMechId\");\n                try {\n                    contactMech = delegator.findByPrimaryKey(\"ContactMech\", UtilMisc.toMap(\"contactMechId\", contactMechId));\n                } catch (GenericEntityException e) {\n                    String errMsg = \"Error Getting ContactMech: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }\n                String contactMechTypeId = contactMech.getString(\"contactMechTypeId\");\n                if (contactMechTypeId.equals(\"EMAIL_ADDRESS\")) {\n                    String emailString = contactMech.getString(\"infoString\");\n                    sendMap.put(\"sendTo\", emailString);\n                }\n            }\n            */\n            \n            if (UtilValidate.isNotEmpty(sendToEmail)) {\n                String productStoreId = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Warehouse.SyncInventoryProductStoreId\");\n                GenericValue productStoreEmail = null;\n                try {\n                    productStoreEmail = delegator.findByPrimaryKey(\"ProductStoreEmailSetting\", UtilMisc.toMap(\"productStoreId\", productStoreId, \"emailType\", \"PRDS_OAGIS_CONFIRM\"));\n                } catch (GenericEntityException e) {\n                    String errMsg = \"Error Getting Entity ProductStoreEmailSetting: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericEntityException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }\n                if (productStoreEmail != null) {\n                    String bodyScreenLocation = productStoreEmail.getString(\"bodyScreenLocation\");\n                    sendMap.put(\"bodyScreenUri\", bodyScreenLocation);\n                } else {\n                    sendMap.put(\"bodyScreenUri\", \"component://oagis/widget/EmailOagisMessageScreens.xml#InventoryMismatchNotice\");\n                }\n                if (locale == null) {\n                    locale = Locale.getDefault();\n                }\n\n                sendMap.put(\"sendTo\", sendToEmail);\n                \n                sendMap.put(\"subject\", productStoreEmail.getString(\"subject\"));\n                sendMap.put(\"sendFrom\", productStoreEmail.getString(\"fromAddress\"));\n                sendMap.put(\"sendCc\", productStoreEmail.getString(\"ccAddress\"));\n                sendMap.put(\"sendBcc\", productStoreEmail.getString(\"bccAddress\"));\n                sendMap.put(\"contentType\", productStoreEmail.getString(\"contentType\"));\n                \n                Map bodyParameters = UtilMisc.toMap(\"inventoryMapList\", inventoryMapList, \"locale\", locale);\n                sendMap.put(\"bodyParameters\", bodyParameters);\n                sendMap.put(\"userLogin\", userLogin);\n                \n                // send the notification\n                try {\n                    // run async so it will happen in the background AND so errors in sending won't mess this up\n                    dispatcher.runAsync(\"sendMailFromScreen\", sendMap, true);\n                } catch(Exception e) {\n                    String errMsg = \"Error Running Service sendMailFromScreen: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"reasonCode\", \"GenericServiceException\", \"description\", errMsg));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else {\n                // no send to email address, just log to file\n                Debug.logImportant(\"No sendTo email address found in process syncInventory service: inventoryMapList: \" + inventoryMapList, module);\n            }\n        }\n        \n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n\n        if (errorMapList.size() > 0) {\n            // call services createOagisMsgErrInfosFromErrMapList and for incoming messages oagisSendConfirmBod\n            Map saveErrorMapListCtx = FastMap.newInstance();\n            saveErrorMapListCtx.put(\"logicalId\", logicalId);\n            saveErrorMapListCtx.put(\"component\", component);\n            saveErrorMapListCtx.put(\"task\", task);\n            saveErrorMapListCtx.put(\"referenceId\", referenceId);\n            saveErrorMapListCtx.put(\"errorMapList\", errorMapList);\n            try {\n                dispatcher.runSync(\"createOagisMsgErrInfosFromErrMapList\", saveErrorMapListCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n            }\n\n            try {\n                Map sendConfirmBodCtx = FastMap.newInstance();\n                sendConfirmBodCtx.putAll(saveErrorMapListCtx);\n                // NOTE: this is different for each service, should be shipmentId or returnId or PO orderId or etc\n                // for sync inventory no such ID: sendConfirmBodCtx.put(\"origRefId\", shipmentId);\n\n                // run async because this will send a message back to the other server and may take some time, and/or fail\n                dispatcher.runAsync(\"oagisSendConfirmBod\", sendConfirmBodCtx, null, true, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n            }\n            \n            // DEJ20070807 what was this next line commented out? if there are errors we want to return an error so this will roll back \n            result.putAll(ServiceUtil.returnError(\"Errors found processing message; information saved and return error sent back\"));\n            return result;\n        } else {\n            comiCtx.put(\"processingStatusId\", \"OAGMP_PROC_SUCCESS\");\n            try {\n                dispatcher.runSync(\"updateOagisMessageInfo\", comiCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                Debug.logError(e, errMsg, module);\n            }\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","commit_id":"f66389a0d041a1838260c31371049da583dfbc0c","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map receiveConfirmBod(DispatchContext ctx, Map context) {\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        Document doc = (Document) context.get(\"document\");\n        List errorMapList = FastList.newInstance();\n        \n        GenericValue userLogin = null; \n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\",UtilMisc.toMap(\"userLoginId\", \"system\"));\n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin with userLoginId 'system':\" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        Element confirmBodElement = doc.getDocumentElement();\n        confirmBodElement.normalize();\n        Element docCtrlAreaElement = UtilXml.firstChildElement(confirmBodElement, \"os:CNTROLAREA\");\n        Element bsrElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:BSR\");\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\");\n        String bsrRevision = UtilXml.childElementValue(bsrElement, \"of:REVISION\");\n            \n        Element docSenderElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:SENDER\");\n        String logicalId = UtilXml.childElementValue(docSenderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(docSenderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(docSenderElement, \"of:TASK\");\n        String referenceId = UtilXml.childElementValue(docSenderElement, \"of:REFERENCEID\");\n        String confirmation = UtilXml.childElementValue(docSenderElement, \"of:CONFIRMATION\");\n        //String language = UtilXml.childElementValue(docSenderElement, \"of:LANGUAGE\");\n        //String codepage = UtilXml.childElementValue(docSenderElement, \"of:CODEPAGE\");\n        String authId = UtilXml.childElementValue(docSenderElement, \"of:AUTHID\");\n\n        String sentDate = UtilXml.childElementValue(docCtrlAreaElement, \"os:DATETIMEISO\");\n        Timestamp sentTimestamp = OagisServices.parseIsoDateString(sentDate, errorMapList);\n        \n        Element dataAreaElement = UtilXml.firstChildElement(confirmBodElement, \"ns:DATAAREA\");\n        Element dataAreaConfirmBodElement = UtilXml.firstChildElement(dataAreaElement, \"ns:CONFIRM_BOD\");\n        Element dataAreaConfirmElement = UtilXml.firstChildElement(dataAreaConfirmBodElement, \"ns:CONFIRM\");\n        Element dataAreaCtrlElement = UtilXml.firstChildElement(dataAreaConfirmElement, \"os:CNTROLAREA\");\n        Element dataAreaSenderElement = UtilXml.firstChildElement(dataAreaCtrlElement, \"os:SENDER\");\n        String dataAreaLogicalId = UtilXml.childElementValue(dataAreaSenderElement, \"of:LOGICALID\");\n        String dataAreaComponent = UtilXml.childElementValue(dataAreaSenderElement, \"of:COMPONENT\");\n        String dataAreaTask = UtilXml.childElementValue(dataAreaSenderElement, \"of:TASK\");\n        String dataAreaReferenceId = UtilXml.childElementValue(dataAreaSenderElement, \"of:REFERENCEID\");\n        String dataAreaDate = UtilXml.childElementValue(dataAreaCtrlElement, \"os:DATETIMEISO\");\n        String origRef = UtilXml.childElementValue(dataAreaConfirmElement, \"of:ORIGREF\");\n          \n        Timestamp receivedTimestamp = UtilDateTime.nowTimestamp();\n        \n        Map oagisMsgInfoCtx = FastMap.newInstance();\n        oagisMsgInfoCtx.put(\"logicalId\", logicalId);\n        oagisMsgInfoCtx.put(\"component\", component);\n        oagisMsgInfoCtx.put(\"task\", task);\n        oagisMsgInfoCtx.put(\"referenceId\", referenceId);\n        oagisMsgInfoCtx.put(\"authId\", authId);\n        oagisMsgInfoCtx.put(\"receivedDate\", receivedTimestamp);\n        oagisMsgInfoCtx.put(\"sentDate\", sentTimestamp);\n        oagisMsgInfoCtx.put(\"confirmation\", confirmation);\n        oagisMsgInfoCtx.put(\"bsrVerb\", bsrVerb);\n        oagisMsgInfoCtx.put(\"bsrNoun\", bsrNoun);\n        oagisMsgInfoCtx.put(\"bsrRevision\", bsrRevision);\n        oagisMsgInfoCtx.put(\"outgoingMessage\", \"N\");\n        oagisMsgInfoCtx.put(\"origRef\", origRef);\n        oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        oagisMsgInfoCtx.put(\"userLogin\", userLogin);\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                oagisMsgInfoCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n            /* running async for better error handling\n            if (ServiceUtil.isError(oagisMsgInfoResult)){\n                String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+ServiceUtil.getErrorMessage(oagisMsgInfoResult);\n                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageInfoServiceError\"));\n                Debug.logError(errMsg, module);\n            }\n            */\n        } catch (GenericServiceException e){\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \" + e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n\n        Map originalOagisMsgCtx = FastMap.newInstance();\n        originalOagisMsgCtx.put(\"logicalId\", dataAreaLogicalId);\n        originalOagisMsgCtx.put(\"component\", dataAreaComponent);\n        originalOagisMsgCtx.put(\"task\", dataAreaTask);\n        originalOagisMsgCtx.put(\"referenceId\", dataAreaReferenceId);\n          \n        GenericValue originalOagisMsgInfo = null;\n        try {\n            originalOagisMsgInfo = delegator.findByPrimaryKey(\"OagisMessageInfo\", originalOagisMsgCtx);\n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting Entity OagisMessageInfo: \" + e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n            Debug.logError(e, errMsg, module);\n        }\n        \n        originalOagisMsgCtx.put(\"userLogin\", userLogin);\n        \n        List dataAreaConfirmMsgList = UtilXml.childElementList(dataAreaConfirmElement, \"ns:CONFIRMMSG\");\n        Iterator dataAreaConfirmMsgListItr = dataAreaConfirmMsgList.iterator();\n        if (originalOagisMsgInfo != null) {\n            while (dataAreaConfirmMsgListItr.hasNext()) {\n                Element dataAreaConfirmMsgElement = (Element) dataAreaConfirmMsgListItr.next();\n                String description = UtilXml.childElementValue(dataAreaConfirmMsgElement, \"of:DESCRIPTN\");\n                String reasonCode = UtilXml.childElementValue(dataAreaConfirmMsgElement, \"of:REASONCODE\");\n                \n                // TODO: should we attach these to the Confirm BOD message instead of the original, and then have the Confirm BOD record point to the original record? this was is fine for now \n                originalOagisMsgCtx.put(\"reasonCode\", reasonCode);\n                originalOagisMsgCtx.put(\"description\", description);\n            \n                try {\n                    Map oagisMsgErrorInfoResult = dispatcher.runSync(\"createOagisMessageErrorInfo\", originalOagisMsgCtx);\n                    if (ServiceUtil.isError(oagisMsgErrorInfoResult)){\n                        String errMsg = \"Error creating OagisMessageErrorInfo: \"+ServiceUtil.getErrorMessage(oagisMsgErrorInfoResult);\n                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageErrorInfoServiceError\"));\n                        Debug.logError(errMsg, module);\n                    }\n                } catch (GenericServiceException e){\n                    String errMsg = \"Error creating OagisMessageErrorInfo: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            }\n        } else {\n            String errMsg = \"No such message with an error was found; Not creating OagisMessageErrorInfo; ID info: \" + originalOagisMsgCtx;\n            Debug.logWarning(errMsg, module);\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"OriginalOagisMessageInfoNotFoundError\"));\n        }\n        \n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n        \n        if (errorMapList.size() > 0) {\n            String errMsg = \"Error Processing Received Message\";\n            result.put(\"errorMapList\", errorMapList);\n            //result.putAll(ServiceUtil.returnError(errMsg));\n            return result;\n        }\n        \n        oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_PROC_SUCCESS\");\n        try {\n            dispatcher.runSync(\"updateOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n        } catch (GenericServiceException e){\n            String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","id":29012,"modified_method":"public static Map receiveConfirmBod(DispatchContext ctx, Map context) {\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        Document doc = (Document) context.get(\"document\");\n        List errorMapList = FastList.newInstance();\n        \n        GenericValue userLogin = null; \n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\",UtilMisc.toMap(\"userLoginId\", \"system\"));\n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin with userLoginId 'system':\" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        Element confirmBodElement = doc.getDocumentElement();\n        confirmBodElement.normalize();\n        Element docCtrlAreaElement = UtilXml.firstChildElement(confirmBodElement, \"os:CNTROLAREA\");\n        Element bsrElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:BSR\");\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\");\n        String bsrRevision = UtilXml.childElementValue(bsrElement, \"of:REVISION\");\n            \n        Element docSenderElement = UtilXml.firstChildElement(docCtrlAreaElement, \"os:SENDER\");\n        String logicalId = UtilXml.childElementValue(docSenderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(docSenderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(docSenderElement, \"of:TASK\");\n        String referenceId = UtilXml.childElementValue(docSenderElement, \"of:REFERENCEID\");\n        String confirmation = UtilXml.childElementValue(docSenderElement, \"of:CONFIRMATION\");\n        //String language = UtilXml.childElementValue(docSenderElement, \"of:LANGUAGE\");\n        //String codepage = UtilXml.childElementValue(docSenderElement, \"of:CODEPAGE\");\n        String authId = UtilXml.childElementValue(docSenderElement, \"of:AUTHID\");\n\n        String sentDate = UtilXml.childElementValue(docCtrlAreaElement, \"os:DATETIMEISO\");\n        Timestamp sentTimestamp = OagisServices.parseIsoDateString(sentDate, errorMapList);\n        \n        Element dataAreaElement = UtilXml.firstChildElement(confirmBodElement, \"ns:DATAAREA\");\n        Element dataAreaConfirmBodElement = UtilXml.firstChildElement(dataAreaElement, \"ns:CONFIRM_BOD\");\n        Element dataAreaConfirmElement = UtilXml.firstChildElement(dataAreaConfirmBodElement, \"ns:CONFIRM\");\n        Element dataAreaCtrlElement = UtilXml.firstChildElement(dataAreaConfirmElement, \"os:CNTROLAREA\");\n        Element dataAreaSenderElement = UtilXml.firstChildElement(dataAreaCtrlElement, \"os:SENDER\");\n        String dataAreaLogicalId = UtilXml.childElementValue(dataAreaSenderElement, \"of:LOGICALID\");\n        String dataAreaComponent = UtilXml.childElementValue(dataAreaSenderElement, \"of:COMPONENT\");\n        String dataAreaTask = UtilXml.childElementValue(dataAreaSenderElement, \"of:TASK\");\n        String dataAreaReferenceId = UtilXml.childElementValue(dataAreaSenderElement, \"of:REFERENCEID\");\n        String dataAreaDate = UtilXml.childElementValue(dataAreaCtrlElement, \"os:DATETIMEISO\");\n        String origRef = UtilXml.childElementValue(dataAreaConfirmElement, \"of:ORIGREF\");\n          \n        Timestamp receivedTimestamp = UtilDateTime.nowTimestamp();\n        \n        Map oagisMsgInfoCtx = FastMap.newInstance();\n        oagisMsgInfoCtx.put(\"logicalId\", logicalId);\n        oagisMsgInfoCtx.put(\"component\", component);\n        oagisMsgInfoCtx.put(\"task\", task);\n        oagisMsgInfoCtx.put(\"referenceId\", referenceId);\n        oagisMsgInfoCtx.put(\"authId\", authId);\n        oagisMsgInfoCtx.put(\"receivedDate\", receivedTimestamp);\n        oagisMsgInfoCtx.put(\"sentDate\", sentTimestamp);\n        oagisMsgInfoCtx.put(\"confirmation\", confirmation);\n        oagisMsgInfoCtx.put(\"bsrVerb\", bsrVerb);\n        oagisMsgInfoCtx.put(\"bsrNoun\", bsrNoun);\n        oagisMsgInfoCtx.put(\"bsrRevision\", bsrRevision);\n        oagisMsgInfoCtx.put(\"outgoingMessage\", \"N\");\n        oagisMsgInfoCtx.put(\"origRef\", origRef);\n        oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        oagisMsgInfoCtx.put(\"userLogin\", userLogin);\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                oagisMsgInfoCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n            /* running async for better error handling\n            if (ServiceUtil.isError(oagisMsgInfoResult)){\n                String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+ServiceUtil.getErrorMessage(oagisMsgInfoResult);\n                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageInfoServiceError\"));\n                Debug.logError(errMsg, module);\n            }\n            */\n        } catch (GenericServiceException e){\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \" + e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n\n        Map originalOagisMsgCtx = FastMap.newInstance();\n        originalOagisMsgCtx.put(\"logicalId\", dataAreaLogicalId);\n        originalOagisMsgCtx.put(\"component\", dataAreaComponent);\n        originalOagisMsgCtx.put(\"task\", dataAreaTask);\n        originalOagisMsgCtx.put(\"referenceId\", dataAreaReferenceId);\n          \n        GenericValue originalOagisMsgInfo = null;\n        try {\n            originalOagisMsgInfo = delegator.findByPrimaryKey(\"OagisMessageInfo\", originalOagisMsgCtx);\n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting Entity OagisMessageInfo: \" + e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n            Debug.logError(e, errMsg, module);\n        }\n        \n        originalOagisMsgCtx.put(\"userLogin\", userLogin);\n        \n        List dataAreaConfirmMsgList = UtilXml.childElementList(dataAreaConfirmElement, \"ns:CONFIRMMSG\");\n        Iterator dataAreaConfirmMsgListItr = dataAreaConfirmMsgList.iterator();\n        if (originalOagisMsgInfo != null) {\n            while (dataAreaConfirmMsgListItr.hasNext()) {\n                Element dataAreaConfirmMsgElement = (Element) dataAreaConfirmMsgListItr.next();\n                String description = UtilXml.childElementValue(dataAreaConfirmMsgElement, \"of:DESCRIPTN\");\n                String reasonCode = UtilXml.childElementValue(dataAreaConfirmMsgElement, \"of:REASONCODE\");\n                \n                // TODO: should we attach these to the Confirm BOD message instead of the original, and then have the Confirm BOD record point to the original record? this was is fine for now \n                originalOagisMsgCtx.put(\"reasonCode\", reasonCode);\n                originalOagisMsgCtx.put(\"description\", description);\n            \n                try {\n                    Map oagisMsgErrorInfoResult = dispatcher.runSync(\"createOagisMessageErrorInfo\", originalOagisMsgCtx);\n                    if (ServiceUtil.isError(oagisMsgErrorInfoResult)){\n                        String errMsg = \"Error creating OagisMessageErrorInfo: \"+ServiceUtil.getErrorMessage(oagisMsgErrorInfoResult);\n                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageErrorInfoServiceError\"));\n                        Debug.logError(errMsg, module);\n                    }\n                } catch (GenericServiceException e){\n                    String errMsg = \"Error creating OagisMessageErrorInfo: \" + e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            }\n        } else {\n            String errMsg = \"No such message with an error was found; Not creating OagisMessageErrorInfo; ID info: \" + originalOagisMsgCtx;\n            Debug.logWarning(errMsg, module);\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"OriginalOagisMessageInfoNotFoundError\"));\n        }\n        \n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n\n        if (errorMapList.size() > 0) {\n            // call services createOagisMsgErrInfosFromErrMapList and for incoming messages oagisSendConfirmBod\n            Map saveErrorMapListCtx = FastMap.newInstance();\n            saveErrorMapListCtx.put(\"logicalId\", logicalId);\n            saveErrorMapListCtx.put(\"component\", component);\n            saveErrorMapListCtx.put(\"task\", task);\n            saveErrorMapListCtx.put(\"referenceId\", referenceId);\n            saveErrorMapListCtx.put(\"errorMapList\", errorMapList);\n            try {\n                dispatcher.runSync(\"createOagisMsgErrInfosFromErrMapList\", saveErrorMapListCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n            }\n\n            \n            // TODO and NOTE DEJ20070813: should we really send back a Confirm BOD if there is an error with the Confirm BOD they send us? probably so... will do for now...\n            try {\n                Map sendConfirmBodCtx = FastMap.newInstance();\n                sendConfirmBodCtx.putAll(saveErrorMapListCtx);\n                // NOTE: this is different for each service, should be shipmentId or returnId or PO orderId or etc\n                // no such thing for confirm bod: sendConfirmBodCtx.put(\"origRefId\", shipmentId);\n\n                // run async because this will send a message back to the other server and may take some time, and/or fail\n                dispatcher.runAsync(\"oagisSendConfirmBod\", sendConfirmBodCtx, null, true, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n            }\n            \n            // DEJ20070807 what was this next line commented out? if there are errors we want to return an error so this will roll back \n            result.putAll(ServiceUtil.returnError(\"Errors found processing message; information saved and return error sent back\"));\n            return result;\n        } else {\n            oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_PROC_SUCCESS\");\n            try {\n                dispatcher.runSync(\"updateOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                Debug.logError(e, errMsg, module);\n            }\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","commit_id":"f66389a0d041a1838260c31371049da583dfbc0c","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map oagisMessageHandler(DispatchContext ctx, Map context) {\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        InputStream in = (InputStream) context.get(\"inputStream\");\n        List errorList = FastList.newInstance();\n        \n        Document doc = null;\n        String xmlText = null;\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(in, \"UTF-8\"));\n            StringBuffer xmlTextBuf = new StringBuffer();\n            String currentLine = null;\n            while ((currentLine = br.readLine()) != null) {\n                xmlTextBuf.append(currentLine);\n                xmlTextBuf.append('\\n');\n            }\n            xmlText = xmlTextBuf.toString();\n            \n            // DEJ20070804 adding this temporarily for debugging, should be changed to verbose at some point in the future\n            Debug.logWarning(\"Received OAGIS XML message, here is the text: \\n\" + xmlText, module);\n\n            ByteArrayInputStream bis = new ByteArrayInputStream(xmlText.getBytes(\"UTF-8\"));\n            doc = UtilXml.readXmlDocument(bis, true, \"OagisMessage\");\n        } catch (SAXException e) {\n            String errMsg = \"XML Error parsing the Received Message [\" + e.toString() + \"]; The text received we could not parse is: [\" + xmlText + \"]\";\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SAXException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (ParserConfigurationException e) {\n            String errMsg = \"Parser Configuration Error parsing the Received Message: \" + e.toString();\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ParserConfigurationException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (IOException e) {\n            String errMsg = \"IO Error parsing the Received Message: \" + e.toString();\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IOException\"));\n            Debug.logError(e, errMsg, module);\n        }\n\n        if (UtilValidate.isNotEmpty(errorList)) {\n            return ServiceUtil.returnError(\"Unable to parse received message\");\n        }\n\n        Element rootElement = doc.getDocumentElement();\n        rootElement.normalize();\n        Element controlAreaElement = UtilXml.firstChildElement(rootElement, \"os:CNTROLAREA\");\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"os:BSR\");\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\");\n        \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"os:SENDER\");\n        String logicalId = UtilXml.childElementValue(senderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(senderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(senderElement, \"of:TASK\");\n        String referenceId = UtilXml.childElementValue(senderElement, \"of:REFERENCEID\");\n        \n        if (UtilValidate.isEmpty(bsrVerb) || UtilValidate.isEmpty(bsrNoun)) {\n            return ServiceUtil.returnError(\"Was able to receive and parse the XML message, but BSR->NOUN [\" + bsrNoun + \"] and/or BSR->VERB [\" + bsrVerb + \"] are empty\");\n        }\n        \n        GenericValue oagisMessageInfo = null;\n        try {\n            oagisMessageInfo = delegator.findByPrimaryKey(\"OagisMessageInfo\", UtilMisc.toMap(\"logicalId\", logicalId, \"component\", component, \"task\", task, \"referenceId\", referenceId));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error Getting Entity OagisMessageInfo: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        Map subServiceResult = FastMap.newInstance();\n        if (UtilValidate.isEmpty(oagisMessageInfo)) {\n            if (bsrVerb.equalsIgnoreCase(\"CONFIRM\") && bsrNoun.equalsIgnoreCase(\"BOD\")) {\n                try {\n                    subServiceResult = dispatcher.runSync(\"receiveConfirmBod\", UtilMisc.toMap(\"document\", doc));\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service receiveConfirmBod: \" + e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"SHOW\") && bsrNoun.equalsIgnoreCase(\"SHIPMENT\")) {\n                try {\n                    //subServiceResult = dispatcher.runSync(\"showShipment\", UtilMisc.toMap(\"document\", doc));\n                    // DEJ20070808 changed to run asynchronously and persisted so that if it fails it will retry; for transaction deadlock and other reasons\n                    dispatcher.runAsync(\"showShipment\", UtilMisc.toMap(\"document\", doc), true);\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service showShipment: \" + e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"SYNC\") && bsrNoun.equalsIgnoreCase(\"INVENTORY\")) {\n                try {\n                    //subServiceResult = dispatcher.runSync(\"syncInventory\", UtilMisc.toMap(\"document\", doc));\n                    // DEJ20070808 changed to run asynchronously and persisted so that if it fails it will retry; for transaction deadlock and other reasons\n                    dispatcher.runAsync(\"syncInventory\", UtilMisc.toMap(\"document\", doc), true);\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service syncInventory: \" + e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"ACKNOWLEDGE\") && bsrNoun.equalsIgnoreCase(\"DELIVERY\")) {\n                Element dataAreaElement = UtilXml.firstChildElement(rootElement, \"ns:DATAAREA\");\n                Element ackDeliveryElement = UtilXml.firstChildElement(dataAreaElement, \"ns:ACKNOWLEDGE_DELIVERY\");\n                Element receiptlnElement = UtilXml.firstChildElement(ackDeliveryElement, \"ns:RECEIPTLN\");\n                Element docRefElement = UtilXml.firstChildElement(receiptlnElement, \"os:DOCUMNTREF\");\n                String docType = UtilXml.childElementValue(docRefElement, \"of:DOCTYPE\");\n                if (\"PO\".equals(docType)){\n                    try {\n                        //subServiceResult = dispatcher.runSync(\"receivePoAcknowledge\", UtilMisc.toMap(\"document\", doc));\n                        dispatcher.runAsync(\"receivePoAcknowledge\", UtilMisc.toMap(\"document\", doc), true);\n                    } catch (GenericServiceException e) {\n                        String errMsg = \"Error running service receivePoAcknowledge: \" + e.toString();\n                        errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                        Debug.logError(e, errMsg, module);\n                    }\n                } else if (\"RMA\".equals(docType)) {\n                    try {\n                        //subServiceResult = dispatcher.runSync(\"receiveRmaAcknowledge\", UtilMisc.toMap(\"document\", doc));\n                        dispatcher.runAsync(\"receiveRmaAcknowledge\", UtilMisc.toMap(\"document\", doc), true);\n                    } catch (GenericServiceException e) {\n                        String errMsg = \"Error running service receiveRmaAcknowledge: \" + e.toString();\n                        errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                        Debug.logError(e, errMsg, module);\n                    }\n                } else {\n                    return ServiceUtil.returnError(\"For Acknowledge Delivery message could not determine if it is for a PO or RMA. DOCTYPE from message is \" + docType);\n                }\n            } else {\n                String errMsg = \"Unknown Message Received\";\n                Debug.logError(errMsg, module);\n                return ServiceUtil.returnError(errMsg);\n            }\n        } else {\n            String errMsg = \"Message has been already received\";\n            Debug.logError(errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        }\n        \n        Map result = ServiceUtil.returnSuccess();\n        result.putAll(subServiceResult);\n        result.put(\"contentType\", \"text/plain\");\n\n        List errorMapList = (List) subServiceResult.get(\"errorMapList\");\n        if (UtilValidate.isNotEmpty(errorList)) {\n            Iterator errListItr = errorList.iterator();\n            while (errListItr.hasNext()) {\n                Map errorMap = (Map) errListItr.next();\n                errorMapList.add(UtilMisc.toMap(\"description\", errorMap.get(\"description\"), \"reasonCode\", errorMap.get(\"reasonCode\")));\n            }\n            result.put(\"errorMapList\", errorMapList);\n        }\n        \n        return result;\n    }","id":29013,"modified_method":"public static Map oagisMessageHandler(DispatchContext ctx, Map context) {\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        InputStream in = (InputStream) context.get(\"inputStream\");\n        List errorList = FastList.newInstance();\n        \n        Document doc = null;\n        String xmlText = null;\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(in, \"UTF-8\"));\n            StringBuffer xmlTextBuf = new StringBuffer();\n            String currentLine = null;\n            while ((currentLine = br.readLine()) != null) {\n                xmlTextBuf.append(currentLine);\n                xmlTextBuf.append('\\n');\n            }\n            xmlText = xmlTextBuf.toString();\n            \n            // DEJ20070804 adding this temporarily for debugging, should be changed to verbose at some point in the future\n            Debug.logWarning(\"Received OAGIS XML message, here is the text: \\n\" + xmlText, module);\n\n            ByteArrayInputStream bis = new ByteArrayInputStream(xmlText.getBytes(\"UTF-8\"));\n            doc = UtilXml.readXmlDocument(bis, true, \"OagisMessage\");\n        } catch (SAXException e) {\n            String errMsg = \"XML Error parsing the Received Message [\" + e.toString() + \"]; The text received we could not parse is: [\" + xmlText + \"]\";\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SAXException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (ParserConfigurationException e) {\n            String errMsg = \"Parser Configuration Error parsing the Received Message: \" + e.toString();\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ParserConfigurationException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (IOException e) {\n            String errMsg = \"IO Error parsing the Received Message: \" + e.toString();\n            errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IOException\"));\n            Debug.logError(e, errMsg, module);\n        }\n\n        if (UtilValidate.isNotEmpty(errorList)) {\n            return ServiceUtil.returnError(\"Unable to parse received message\");\n        }\n\n        Element rootElement = doc.getDocumentElement();\n        rootElement.normalize();\n        Element controlAreaElement = UtilXml.firstChildElement(rootElement, \"os:CNTROLAREA\");\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"os:BSR\");\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\");\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\");\n        \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"os:SENDER\");\n        String logicalId = UtilXml.childElementValue(senderElement, \"of:LOGICALID\");\n        String component = UtilXml.childElementValue(senderElement, \"of:COMPONENT\");\n        String task = UtilXml.childElementValue(senderElement, \"of:TASK\");\n        String referenceId = UtilXml.childElementValue(senderElement, \"of:REFERENCEID\");\n        \n        if (UtilValidate.isEmpty(bsrVerb) || UtilValidate.isEmpty(bsrNoun)) {\n            return ServiceUtil.returnError(\"Was able to receive and parse the XML message, but BSR->NOUN [\" + bsrNoun + \"] and/or BSR->VERB [\" + bsrVerb + \"] are empty\");\n        }\n        \n        GenericValue oagisMessageInfo = null;\n        try {\n            oagisMessageInfo = delegator.findByPrimaryKey(\"OagisMessageInfo\", UtilMisc.toMap(\"logicalId\", logicalId, \"component\", component, \"task\", task, \"referenceId\", referenceId));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error Getting Entity OagisMessageInfo: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        // call async, no additional results to return: Map subServiceResult = FastMap.newInstance();\n        if (UtilValidate.isEmpty(oagisMessageInfo)) {\n            if (bsrVerb.equalsIgnoreCase(\"CONFIRM\") && bsrNoun.equalsIgnoreCase(\"BOD\")) {\n                try {\n                    // subServiceResult = dispatcher.runSync(\"receiveConfirmBod\", UtilMisc.toMap(\"document\", doc));\n                    dispatcher.runAsync(\"receiveConfirmBod\", UtilMisc.toMap(\"document\", doc), true);\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service receiveConfirmBod: \" + e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"SHOW\") && bsrNoun.equalsIgnoreCase(\"SHIPMENT\")) {\n                try {\n                    //subServiceResult = dispatcher.runSync(\"showShipment\", UtilMisc.toMap(\"document\", doc));\n                    // DEJ20070808 changed to run asynchronously and persisted so that if it fails it will retry; for transaction deadlock and other reasons\n                    dispatcher.runAsync(\"showShipment\", UtilMisc.toMap(\"document\", doc), true);\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service showShipment: \" + e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"SYNC\") && bsrNoun.equalsIgnoreCase(\"INVENTORY\")) {\n                try {\n                    //subServiceResult = dispatcher.runSync(\"syncInventory\", UtilMisc.toMap(\"document\", doc));\n                    // DEJ20070808 changed to run asynchronously and persisted so that if it fails it will retry; for transaction deadlock and other reasons\n                    dispatcher.runAsync(\"syncInventory\", UtilMisc.toMap(\"document\", doc), true);\n                } catch (GenericServiceException e) {\n                    String errMsg = \"Error running service syncInventory: \" + e.toString();\n                    errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            } else if (bsrVerb.equalsIgnoreCase(\"ACKNOWLEDGE\") && bsrNoun.equalsIgnoreCase(\"DELIVERY\")) {\n                Element dataAreaElement = UtilXml.firstChildElement(rootElement, \"ns:DATAAREA\");\n                Element ackDeliveryElement = UtilXml.firstChildElement(dataAreaElement, \"ns:ACKNOWLEDGE_DELIVERY\");\n                Element receiptlnElement = UtilXml.firstChildElement(ackDeliveryElement, \"ns:RECEIPTLN\");\n                Element docRefElement = UtilXml.firstChildElement(receiptlnElement, \"os:DOCUMNTREF\");\n                String docType = UtilXml.childElementValue(docRefElement, \"of:DOCTYPE\");\n                if (\"PO\".equals(docType)){\n                    try {\n                        //subServiceResult = dispatcher.runSync(\"receivePoAcknowledge\", UtilMisc.toMap(\"document\", doc));\n                        dispatcher.runAsync(\"receivePoAcknowledge\", UtilMisc.toMap(\"document\", doc), true);\n                    } catch (GenericServiceException e) {\n                        String errMsg = \"Error running service receivePoAcknowledge: \" + e.toString();\n                        errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                        Debug.logError(e, errMsg, module);\n                    }\n                } else if (\"RMA\".equals(docType)) {\n                    try {\n                        //subServiceResult = dispatcher.runSync(\"receiveRmaAcknowledge\", UtilMisc.toMap(\"document\", doc));\n                        dispatcher.runAsync(\"receiveRmaAcknowledge\", UtilMisc.toMap(\"document\", doc), true);\n                    } catch (GenericServiceException e) {\n                        String errMsg = \"Error running service receiveRmaAcknowledge: \" + e.toString();\n                        errorList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                        Debug.logError(e, errMsg, module);\n                    }\n                } else {\n                    return ServiceUtil.returnError(\"For Acknowledge Delivery message could not determine if it is for a PO or RMA. DOCTYPE from message is \" + docType);\n                }\n            } else {\n                String errMsg = \"Unknown Message Received\";\n                Debug.logError(errMsg, module);\n                return ServiceUtil.returnError(errMsg);\n            }\n        } else {\n            String errMsg = \"Message has been already received\";\n            Debug.logError(errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        }\n        \n        Map result = ServiceUtil.returnSuccess();\n        result.put(\"contentType\", \"text/plain\");\n\n        /* no sub-service error processing to be done here, all handled in the sub-services:\n        result.putAll(subServiceResult);\n        List errorMapList = (List) subServiceResult.get(\"errorMapList\");\n        if (UtilValidate.isNotEmpty(errorList)) {\n            Iterator errListItr = errorList.iterator();\n            while (errListItr.hasNext()) {\n                Map errorMap = (Map) errListItr.next();\n                errorMapList.add(UtilMisc.toMap(\"description\", errorMap.get(\"description\"), \"reasonCode\", errorMap.get(\"reasonCode\")));\n            }\n            result.put(\"errorMapList\", errorMapList);\n        }\n        */\n        \n        return result;\n    }","commit_id":"f66389a0d041a1838260c31371049da583dfbc0c","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map showShipment(DispatchContext ctx, Map context) {\n        Document doc = (Document) context.get(\"document\");\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n        List errorMapList = FastList.newInstance();\n            \n        GenericValue userLogin = null; \n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));    \n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin with userLoginId system: \"+e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n                    \n        Element showShipmentElement = doc.getDocumentElement();\n        showShipmentElement.normalize();\n          \n        Element controlAreaElement = UtilXml.firstChildElement(showShipmentElement, \"os:CNTROLAREA\"); // os\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"os:BSR\"); // os\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\"); // of\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\"); // of\n        String bsrRevision = UtilXml.childElementValue(bsrElement, \"of:REVISION\"); // of\n        Map oagisMsgInfoCtx = UtilMisc.toMap(\"bsrVerb\", bsrVerb, \"bsrNoun\", bsrNoun, \"bsrRevision\", bsrRevision);\n            \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"os:SENDER\"); // os\n        String logicalId = UtilXml.childElementValue(senderElement, \"of:LOGICALID\"); // of\n        String component = UtilXml.childElementValue(senderElement, \"of:COMPONENT\"); // of\n        String task = UtilXml.childElementValue(senderElement, \"of:TASK\"); // of\n        String referenceId = UtilXml.childElementValue(senderElement, \"of:REFERENCEID\"); // of\n        String confirmation = UtilXml.childElementValue(senderElement, \"of:CONFIRMATION\"); // of\n        String authId = UtilXml.childElementValue(senderElement, \"of:AUTHID\"); // of\n\n        String sentDate = UtilXml.childElementValue(controlAreaElement, \"os:DATETIMEISO\");\n        Timestamp sentTimestamp = OagisServices.parseIsoDateString(sentDate, errorMapList);\n        \n        Element dataAreaElement = UtilXml.firstChildElement(showShipmentElement, \"ns:DATAAREA\"); // n\n        Element daShowShipmentElement = UtilXml.firstChildElement(dataAreaElement, \"ns:SHOW_SHIPMENT\"); // n\n        Element shipmentElement = UtilXml.firstChildElement(daShowShipmentElement, \"ns:SHIPMENT\"); // n                               \n        String shipmentId = UtilXml.childElementValue(shipmentElement, \"of:DOCUMENTID\"); // of           \n\n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n\n        oagisMsgInfoCtx.put(\"logicalId\", logicalId);\n        oagisMsgInfoCtx.put(\"component\", component);\n        oagisMsgInfoCtx.put(\"task\", task);\n        oagisMsgInfoCtx.put(\"referenceId\", referenceId);\n        oagisMsgInfoCtx.put(\"confirmation\", confirmation);\n        oagisMsgInfoCtx.put(\"authId\", authId);\n        oagisMsgInfoCtx.put(\"outgoingMessage\", \"N\");\n        oagisMsgInfoCtx.put(\"receivedDate\", nowTimestamp);\n        oagisMsgInfoCtx.put(\"sentDate\", sentTimestamp);\n        oagisMsgInfoCtx.put(\"shipmentId\", shipmentId);\n        oagisMsgInfoCtx.put(\"userLogin\", userLogin);\n        oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                oagisMsgInfoCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        \n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n            /* running async for better error handling\n            if (ServiceUtil.isError(oagisMsgInfoResult)){\n                String errMsg = ServiceUtil.getErrorMessage(oagisMsgInfoResult);\n                // errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageInfoServiceError\"));\n                Debug.logError(errMsg, module);\n            }\n            */\n        } catch (GenericServiceException e){\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+e.toString();\n            // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n           \n        GenericValue shipment = null;\n        try {\n            shipment = delegator.findByPrimaryKey(\"Shipment\", UtilMisc.toMap(\"shipmentId\", shipmentId));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error getting Shipment from database: \"+ e.toString();\n            Debug.logInfo(e, errMsg, module);\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n        }\n        \n        if (shipment == null) {\n            String errMsg = \"Could not find Shipment id ID [\" + shipmentId + \"]\";\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ShipmentIdNotValid\"));\n        }\n        \n        if (errorMapList.size() > 0) {\n            result.putAll(ServiceUtil.returnError(\"Errors found getting shipment information for incoming Show Shipment message; here is the first: \" + errorMapList.get(0)));\n            result.put(\"errorMapList\", errorMapList);\n            return result;\n        }\n\n        String shipGroupSeqId = shipment.getString(\"primaryShipGroupSeqId\");                \n        String originFacilityId = shipment.getString(\"originFacilityId\");                              \n        \n        List shipUnitElementList = UtilXml.childElementList(daShowShipmentElement, \"ns:SHIPUNIT\"); // n\n        if(UtilValidate.isNotEmpty(shipUnitElementList)) {\n            Element shipUnitElement = (Element)shipUnitElementList.get(0);\n            String trackingNum = UtilXml.childElementValue(shipUnitElement, \"of:TRACKINGID\"); // of\n            String carrierCode = UtilXml.childElementValue(shipUnitElement, \"of:CARRIER\"); // of\n            if(UtilValidate.isNotEmpty(carrierCode)){\n                String carrierPartyId = null;\n                if( carrierCode.startsWith(\"F\") || carrierCode.startsWith(\"f\")) {                \n                    carrierPartyId = \"FEDEX\";                                           \n                } else if(carrierCode.startsWith(\"U\")|| carrierCode.startsWith(\"u\")) {\n                    carrierPartyId = \"UPS\";                                            \n                }\n                try {\n                    Map resultMap = dispatcher.runSync(\"updateShipmentRouteSegment\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"shipmentRouteSegmentId\", \"00001\", \"carrierPartyId\", carrierPartyId, \"trackingIdNumber\", trackingNum, \"userLogin\", userLogin));                        \n                    if (ServiceUtil.isError(resultMap)){\n                        String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"updateShipmentRouteSegmentError\"));\n                        Debug.logError(errMsg, module);\n                    }\n                }catch (GenericServiceException e) {\n                    Debug.logInfo(e, module);\n                    String errMsg = \"Error executing updateShipmentRouteSegment Service: \"+e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                }\n            }\n            \n            Iterator shipUnitElementItr = shipUnitElementList.iterator();\n            while(shipUnitElementItr.hasNext()) {                 \n                shipUnitElement = (Element) shipUnitElementItr.next();\n                String shipmentPackageSeqId = UtilXml.childElementValue(shipUnitElement, \"of:SHPUNITSEQ\"); // of\n                List invItemElementList = UtilXml.childElementList(shipUnitElement, \"ns:INVITEM\"); //n\n                if(UtilValidate.isNotEmpty(invItemElementList)) {\n                    // sort the INVITEM elements by ITEM so that all shipments are processed in the same order, avoids deadlocking problems we've seen with concurrently processed orders\n                    List invitemMapList = FastList.newInstance();\n                    Iterator invItemElementIter = invItemElementList.iterator();\n                    while(invItemElementIter.hasNext()) {                 \n                        Element invItemElement = (Element) invItemElementIter.next();\n                        String productId = UtilXml.childElementValue(invItemElement, \"of:ITEM\"); // of\n                        Map invitemMap = FastMap.newInstance();\n                        invitemMap.put(\"productId\", productId);\n                        invitemMap.put(\"invItemElement\", invItemElement);\n                        invitemMapList.add(invitemMap);\n                    }\n                    UtilMisc.sortMaps(invitemMapList, UtilMisc.toList(\"productId\"));\n                    \n                    Iterator invitemMapIter = invitemMapList.iterator();\n                    while(invitemMapIter.hasNext()) {\n                        Map invitemMap = (Map) invitemMapIter.next();\n                        Element invItemElement = (Element) invitemMap.get(\"invItemElement\");\n                        String productId = UtilXml.childElementValue(invItemElement, \"of:ITEM\"); // of\n                        \n                        try {\n                            Element quantityElement = UtilXml.firstChildElement(invItemElement, \"os:QUANTITY\"); // os\n                            String quantityValueStr = UtilXml.childElementValue(quantityElement, \"of:VALUE\"); // os\n                            // TODO: <of:NUMOFDEC>0<\/of:NUMOFDEC> should always be 0, but might want to add code to check\n                            Integer messageQuantity = Integer.valueOf(quantityValueStr);\n\n                            GenericValue shipmentItem = EntityUtil.getFirst(delegator.findByAnd(\"ShipmentItem\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"productId\",productId)));                    \n                            String shipmentItemSeqId = shipmentItem.getString(\"shipmentItemSeqId\");                      \n                            GenericValue orderShipment = EntityUtil.getFirst(delegator.findByAnd(\"OrderShipment\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"shipmentItemSeqId\", shipmentItemSeqId)));                    \n                            String orderId = orderShipment.getString(\"orderId\");                \n                            String orderItemSeqId = orderShipment.getString(\"orderItemSeqId\");                \n                            GenericValue product = delegator.findByPrimaryKey(\"Product\",UtilMisc.toMap(\"productId\",productId));                    \n                            String requireInventory = product.getString(\"requireInventory\");                    \n                            if (requireInventory == null) {\n                                requireInventory = \"N\";\n                            }\n                            \n                            // TODO and NOTE: could there be more than one reservation record for a given shipment item? for example if there wasn't enough quantity in one inventory item and reservations on two were needed? yes\n                            List orderItemShipGrpInvReservationList = delegator.findByAnd(\"OrderItemShipGrpInvRes\", UtilMisc.toMap(\"orderId\", orderId, \"orderItemSeqId\", orderItemSeqId,\"shipGroupSeqId\",shipGroupSeqId));\n                            \n                            // find the total quantity for all reservations\n                            int totalReserved = 0;\n                            Iterator orderItemShipGrpInvReservationCountIter = orderItemShipGrpInvReservationList.iterator();\n                            while (orderItemShipGrpInvReservationCountIter.hasNext()) {\n                                GenericValue orderItemShipGrpInvReservation = (GenericValue) orderItemShipGrpInvReservationCountIter.next();\n                                if (orderItemShipGrpInvReservation.getDouble(\"quantity\") != null) {\n                                    totalReserved += orderItemShipGrpInvReservation.getDouble(\"quantity\").doubleValue();\n                                }\n                            }\n\n                            List serialNumberList = FastList.newInstance();\n                            List invDetailElementList = UtilXml.childElementList(invItemElement, \"ns:INVDETAIL\"); //n\n                            Iterator invDetailElementItr = invDetailElementList.iterator();\n                            while(invDetailElementItr.hasNext()) {\n                                Element invDetailElement = (Element) invDetailElementItr.next();\n                                String serialNumber = UtilXml.childElementValue(invDetailElement, \"of:SERIALNUM\"); // os\n                                if (UtilValidate.isNotEmpty(serialNumber)) {\n                                    serialNumberList.add(serialNumber);\n                                }\n                            }\n\n                            // do some validations\n                            boolean continueLoop = false;\n                            if(UtilValidate.isNotEmpty(serialNumberList)) {\n                                if (messageQuantity.intValue() != serialNumberList.size()) {\n                                    String errMsg = \"Not enough serial numbers [\" + serialNumberList.size() + \"] for the quantity [\" + messageQuantity.intValue() + \"].\";\n                                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SerialNumbersMissing\"));\n                                    Debug.logInfo(errMsg, module);\n                                    continueLoop = true;\n                                }\n                            } \n                            if ((int) totalReserved != messageQuantity.intValue()) {\n                                String errMsg = \"Not enough serial numbers [\" + serialNumberList.size() + \"] for the quantity [\" + messageQuantity.intValue() + \"].\";\n                                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SerialNumbersMissing\"));\n                                Debug.logInfo(errMsg, module);\n                                continueLoop = true;\n                            }\n                            \n                            if (continueLoop) {\n                                continue;\n                            }\n                            \n                            Iterator serialNumberIter = serialNumberList.iterator();\n                            Iterator orderItemShipGrpInvReservationIter = orderItemShipGrpInvReservationList.iterator();\n                            while (orderItemShipGrpInvReservationIter.hasNext()) {\n                                GenericValue orderItemShipGrpInvReservation = (GenericValue) orderItemShipGrpInvReservationIter.next();\n                                int currentResQuantity = orderItemShipGrpInvReservation.getDouble(\"quantity\").intValue();\n                                \n                                Map isitspastCtx = UtilMisc.toMap(\"orderId\", orderId, \"shipGroupSeqId\", shipGroupSeqId, \"orderItemSeqId\", orderItemSeqId);                \n                                isitspastCtx.put(\"productId\", productId);\n                                isitspastCtx.put(\"reservedDatetime\", orderItemShipGrpInvReservation.get(\"reservedDatetime\"));\n                                isitspastCtx.put(\"requireInventory\", requireInventory);\n                                isitspastCtx.put(\"reserveOrderEnumId\", orderItemShipGrpInvReservation.get(\"reserveOrderEnumId\"));\n                                isitspastCtx.put(\"sequenceId\", orderItemShipGrpInvReservation.get(\"sequenceId\"));\n                                isitspastCtx.put(\"originFacilityId\", originFacilityId);\n                                isitspastCtx.put(\"userLogin\", userLogin);            \n                                isitspastCtx.put(\"trackingNum\", trackingNum);\n                                isitspastCtx.put(\"inventoryItemId\", orderItemShipGrpInvReservation.get(\"inventoryItemId\"));                \n                                isitspastCtx.put(\"shipmentId\", shipmentId);      \n                                isitspastCtx.put(\"shipmentPackageSeqId\", shipmentPackageSeqId);\n                                isitspastCtx.put(\"promisedDatetime\", orderItemShipGrpInvReservation.get(\"promisedDatetime\"));\n                                \n                                if(UtilValidate.isNotEmpty(serialNumberList)) {\n                                    for (int i = 0; i < currentResQuantity; i++) {\n                                        String serialNumber = (String) serialNumberIter.next();\n                                        isitspastCtx.put(\"serialNumber\", serialNumber);\n                                        isitspastCtx.put(\"quantity\", new Double (1));\n                                        isitspastCtx.put(\"inventoryItemId\", orderItemShipGrpInvReservation.get(\"inventoryItemId\"));\n                                        isitspastCtx.remove(\"itemIssuanceId\");                            \n                                        try {\n                                            Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                            if (ServiceUtil.isError(resultMap)){\n                                                String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                                Debug.logError(errMsg, module);\n                                            }\n                                        } catch(GenericServiceException e) {\n                                            Debug.logInfo(e, module);\n                                            String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                        }\n                                    }\n                                } else {\n                                    try {\n                                        //TODO: I think this else part is for NON Serialized Inv item. So it will be different service that we need to call here.\n                                        isitspastCtx.put(\"quantity\", new Double(currentResQuantity));\n                                        Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                        if (ServiceUtil.isError(resultMap)){\n                                            String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                            Debug.logError(errMsg, module);\n                                        }\n                                    } catch(GenericServiceException e) {\n                                        Debug.logInfo(e, module);\n                                        String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                    }            \n                                }\n                            }\n                            \n                        } catch (NumberFormatException e) {\n                            String errMsg = \"Error in format for number: \" + e.toString();\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"NumberFormatException\"));\n                            Debug.logInfo(e, errMsg, module);\n                        } catch (GenericEntityException e) {\n                            String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \" + e.toString();\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n                            Debug.logInfo(e, errMsg, module);\n                        }\n                    }\n                }\n            }\n            try {\n                Map resultMap = dispatcher.runSync(\"setShipmentStatusPackedAndShipped\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"userLogin\", userLogin));               \n                if (ServiceUtil.isError(resultMap)){\n                    String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SetShipmentStatusPackedAndShippedError\"));\n                    Debug.logError(errMsg, module);\n                }\n            } catch(GenericServiceException e) {\n                Debug.logInfo(e, module);\n                String errMsg = \"Error executing setShipmentStatusPackedAndShipped Service: \" + e.toString();\n                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            }   \n        }  \n        \n        if (errorMapList.size() > 0) {\n            // DEJ20070807 what was this next line commented out? if there are errors we want to return an error so this will roll back \n            result.putAll(ServiceUtil.returnError(\"Errors found processing message\"));\n            result.put(\"errorMapList\", errorMapList);\n            return result;\n        } else {\n            oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_PROC_SUCCESS\");\n            try {\n                dispatcher.runSync(\"updateOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                Debug.logError(e, errMsg, module);\n            }\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","id":29014,"modified_method":"public static Map showShipment(DispatchContext ctx, Map context) {\n        Document doc = (Document) context.get(\"document\");\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n        List errorMapList = FastList.newInstance();\n            \n        GenericValue userLogin = null; \n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));    \n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin with userLoginId system: \"+e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n                    \n        Element showShipmentElement = doc.getDocumentElement();\n        showShipmentElement.normalize();\n          \n        Element controlAreaElement = UtilXml.firstChildElement(showShipmentElement, \"os:CNTROLAREA\"); // os\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"os:BSR\"); // os\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\"); // of\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\"); // of\n        String bsrRevision = UtilXml.childElementValue(bsrElement, \"of:REVISION\"); // of\n        Map oagisMsgInfoCtx = UtilMisc.toMap(\"bsrVerb\", bsrVerb, \"bsrNoun\", bsrNoun, \"bsrRevision\", bsrRevision);\n            \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"os:SENDER\"); // os\n        String logicalId = UtilXml.childElementValue(senderElement, \"of:LOGICALID\"); // of\n        String component = UtilXml.childElementValue(senderElement, \"of:COMPONENT\"); // of\n        String task = UtilXml.childElementValue(senderElement, \"of:TASK\"); // of\n        String referenceId = UtilXml.childElementValue(senderElement, \"of:REFERENCEID\"); // of\n        String confirmation = UtilXml.childElementValue(senderElement, \"of:CONFIRMATION\"); // of\n        String authId = UtilXml.childElementValue(senderElement, \"of:AUTHID\"); // of\n\n        String sentDate = UtilXml.childElementValue(controlAreaElement, \"os:DATETIMEISO\");\n        Timestamp sentTimestamp = OagisServices.parseIsoDateString(sentDate, errorMapList);\n        \n        Element dataAreaElement = UtilXml.firstChildElement(showShipmentElement, \"ns:DATAAREA\"); // n\n        Element daShowShipmentElement = UtilXml.firstChildElement(dataAreaElement, \"ns:SHOW_SHIPMENT\"); // n\n        Element shipmentElement = UtilXml.firstChildElement(daShowShipmentElement, \"ns:SHIPMENT\"); // n                               \n        String shipmentId = UtilXml.childElementValue(shipmentElement, \"of:DOCUMENTID\"); // of           \n\n        oagisMsgInfoCtx.put(\"logicalId\", logicalId);\n        oagisMsgInfoCtx.put(\"component\", component);\n        oagisMsgInfoCtx.put(\"task\", task);\n        oagisMsgInfoCtx.put(\"referenceId\", referenceId);\n        oagisMsgInfoCtx.put(\"confirmation\", confirmation);\n        oagisMsgInfoCtx.put(\"authId\", authId);\n        oagisMsgInfoCtx.put(\"outgoingMessage\", \"N\");\n        oagisMsgInfoCtx.put(\"receivedDate\", nowTimestamp);\n        oagisMsgInfoCtx.put(\"sentDate\", sentTimestamp);\n        oagisMsgInfoCtx.put(\"shipmentId\", shipmentId);\n        oagisMsgInfoCtx.put(\"userLogin\", userLogin);\n        oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                oagisMsgInfoCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        \n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n            /* running async for better error handling\n            if (ServiceUtil.isError(oagisMsgInfoResult)){\n                String errMsg = ServiceUtil.getErrorMessage(oagisMsgInfoResult);\n                // errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageInfoServiceError\"));\n                Debug.logError(errMsg, module);\n            }\n            */\n        } catch (GenericServiceException e){\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+e.toString();\n            // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n           \n        GenericValue shipment = null;\n        try {\n            shipment = delegator.findByPrimaryKey(\"Shipment\", UtilMisc.toMap(\"shipmentId\", shipmentId));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error getting Shipment from database: \"+ e.toString();\n            Debug.logInfo(e, errMsg, module);\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n        }\n        \n        if (shipment == null) {\n            String errMsg = \"Could not find Shipment id ID [\" + shipmentId + \"]\";\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ShipmentIdNotValid\"));\n        }\n        \n        String shipGroupSeqId = shipment.getString(\"primaryShipGroupSeqId\");                \n        String originFacilityId = shipment.getString(\"originFacilityId\");                              \n        \n        List shipUnitElementList = UtilXml.childElementList(daShowShipmentElement, \"ns:SHIPUNIT\"); // n\n        if(errorMapList.size() == 0 && UtilValidate.isNotEmpty(shipUnitElementList)) {\n            Element shipUnitElement = (Element)shipUnitElementList.get(0);\n            String trackingNum = UtilXml.childElementValue(shipUnitElement, \"of:TRACKINGID\"); // of\n            String carrierCode = UtilXml.childElementValue(shipUnitElement, \"of:CARRIER\"); // of\n            if(UtilValidate.isNotEmpty(carrierCode)){\n                String carrierPartyId = null;\n                if( carrierCode.startsWith(\"F\") || carrierCode.startsWith(\"f\")) {                \n                    carrierPartyId = \"FEDEX\";                                           \n                } else if(carrierCode.startsWith(\"U\")|| carrierCode.startsWith(\"u\")) {\n                    carrierPartyId = \"UPS\";                                            \n                }\n                try {\n                    Map resultMap = dispatcher.runSync(\"updateShipmentRouteSegment\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"shipmentRouteSegmentId\", \"00001\", \"carrierPartyId\", carrierPartyId, \"trackingIdNumber\", trackingNum, \"userLogin\", userLogin));                        \n                    if (ServiceUtil.isError(resultMap)){\n                        String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"updateShipmentRouteSegmentError\"));\n                        Debug.logError(errMsg, module);\n                    }\n                }catch (GenericServiceException e) {\n                    Debug.logInfo(e, module);\n                    String errMsg = \"Error executing updateShipmentRouteSegment Service: \"+e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                }\n            }\n            \n            Iterator shipUnitElementItr = shipUnitElementList.iterator();\n            while(shipUnitElementItr.hasNext()) {                 \n                shipUnitElement = (Element) shipUnitElementItr.next();\n                String shipmentPackageSeqId = UtilXml.childElementValue(shipUnitElement, \"of:SHPUNITSEQ\"); // of\n                List invItemElementList = UtilXml.childElementList(shipUnitElement, \"ns:INVITEM\"); //n\n                if(UtilValidate.isNotEmpty(invItemElementList)) {\n                    // sort the INVITEM elements by ITEM so that all shipments are processed in the same order, avoids deadlocking problems we've seen with concurrently processed orders\n                    List invitemMapList = FastList.newInstance();\n                    Iterator invItemElementIter = invItemElementList.iterator();\n                    while(invItemElementIter.hasNext()) {                 \n                        Element invItemElement = (Element) invItemElementIter.next();\n                        String productId = UtilXml.childElementValue(invItemElement, \"of:ITEM\"); // of\n                        Map invitemMap = FastMap.newInstance();\n                        invitemMap.put(\"productId\", productId);\n                        invitemMap.put(\"invItemElement\", invItemElement);\n                        invitemMapList.add(invitemMap);\n                    }\n                    UtilMisc.sortMaps(invitemMapList, UtilMisc.toList(\"productId\"));\n                    \n                    Iterator invitemMapIter = invitemMapList.iterator();\n                    while(invitemMapIter.hasNext()) {\n                        Map invitemMap = (Map) invitemMapIter.next();\n                        Element invItemElement = (Element) invitemMap.get(\"invItemElement\");\n                        String productId = UtilXml.childElementValue(invItemElement, \"of:ITEM\"); // of\n                        \n                        try {\n                            Element quantityElement = UtilXml.firstChildElement(invItemElement, \"os:QUANTITY\"); // os\n                            String quantityValueStr = UtilXml.childElementValue(quantityElement, \"of:VALUE\"); // os\n                            // TODO: <of:NUMOFDEC>0<\/of:NUMOFDEC> should always be 0, but might want to add code to check\n                            Integer messageQuantity = Integer.valueOf(quantityValueStr);\n\n                            GenericValue shipmentItem = EntityUtil.getFirst(delegator.findByAnd(\"ShipmentItem\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"productId\",productId)));                    \n                            String shipmentItemSeqId = shipmentItem.getString(\"shipmentItemSeqId\");                      \n                            GenericValue orderShipment = EntityUtil.getFirst(delegator.findByAnd(\"OrderShipment\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"shipmentItemSeqId\", shipmentItemSeqId)));                    \n                            String orderId = orderShipment.getString(\"orderId\");                \n                            String orderItemSeqId = orderShipment.getString(\"orderItemSeqId\");                \n                            GenericValue product = delegator.findByPrimaryKey(\"Product\",UtilMisc.toMap(\"productId\",productId));                    \n                            String requireInventory = product.getString(\"requireInventory\");                    \n                            if (requireInventory == null) {\n                                requireInventory = \"N\";\n                            }\n                            \n                            // NOTE: there could be more than one reservation record for a given shipment item? for example if there wasn't enough quantity in one inventory item and reservations on two were needed\n                            List orderItemShipGrpInvReservationList = delegator.findByAnd(\"OrderItemShipGrpInvRes\", UtilMisc.toMap(\"orderId\", orderId, \"orderItemSeqId\", orderItemSeqId,\"shipGroupSeqId\",shipGroupSeqId));\n                            \n                            // find the total quantity for all reservations\n                            int totalReserved = 0;\n                            Iterator orderItemShipGrpInvReservationCountIter = orderItemShipGrpInvReservationList.iterator();\n                            while (orderItemShipGrpInvReservationCountIter.hasNext()) {\n                                GenericValue orderItemShipGrpInvReservation = (GenericValue) orderItemShipGrpInvReservationCountIter.next();\n                                if (orderItemShipGrpInvReservation.getDouble(\"quantity\") != null) {\n                                    totalReserved += orderItemShipGrpInvReservation.getDouble(\"quantity\").doubleValue();\n                                }\n                            }\n\n                            List serialNumberList = FastList.newInstance();\n                            List invDetailElementList = UtilXml.childElementList(invItemElement, \"ns:INVDETAIL\"); //n\n                            Iterator invDetailElementItr = invDetailElementList.iterator();\n                            while(invDetailElementItr.hasNext()) {\n                                Element invDetailElement = (Element) invDetailElementItr.next();\n                                String serialNumber = UtilXml.childElementValue(invDetailElement, \"of:SERIALNUM\"); // os\n                                if (UtilValidate.isNotEmpty(serialNumber)) {\n                                    serialNumberList.add(serialNumber);\n                                }\n                            }\n\n                            // do some validations\n                            boolean continueLoop = false;\n                            if(UtilValidate.isNotEmpty(serialNumberList)) {\n                                if (messageQuantity.intValue() != serialNumberList.size()) {\n                                    String errMsg = \"Not enough serial numbers [\" + serialNumberList.size() + \"] for the quantity [\" + messageQuantity.intValue() + \"].\";\n                                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SerialNumbersMissing\"));\n                                    Debug.logInfo(errMsg, module);\n                                    continueLoop = true;\n                                }\n                            } \n                            if ((int) totalReserved != messageQuantity.intValue()) {\n                                String errMsg = \"Not enough serial numbers [\" + serialNumberList.size() + \"] for the quantity [\" + messageQuantity.intValue() + \"].\";\n                                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SerialNumbersMissing\"));\n                                Debug.logInfo(errMsg, module);\n                                continueLoop = true;\n                            }\n                            \n                            // TODO: if serialNumber does not exist in database add an error message\n                            \n                            if (continueLoop) {\n                                continue;\n                            }\n                            \n                            Iterator serialNumberIter = serialNumberList.iterator();\n                            Iterator orderItemShipGrpInvReservationIter = orderItemShipGrpInvReservationList.iterator();\n                            while (orderItemShipGrpInvReservationIter.hasNext()) {\n                                GenericValue orderItemShipGrpInvReservation = (GenericValue) orderItemShipGrpInvReservationIter.next();\n                                int currentResQuantity = orderItemShipGrpInvReservation.getDouble(\"quantity\").intValue();\n                                \n                                Map isitspastCtx = UtilMisc.toMap(\"orderId\", orderId, \"shipGroupSeqId\", shipGroupSeqId, \"orderItemSeqId\", orderItemSeqId);                \n                                isitspastCtx.put(\"productId\", productId);\n                                isitspastCtx.put(\"reservedDatetime\", orderItemShipGrpInvReservation.get(\"reservedDatetime\"));\n                                isitspastCtx.put(\"requireInventory\", requireInventory);\n                                isitspastCtx.put(\"reserveOrderEnumId\", orderItemShipGrpInvReservation.get(\"reserveOrderEnumId\"));\n                                isitspastCtx.put(\"sequenceId\", orderItemShipGrpInvReservation.get(\"sequenceId\"));\n                                isitspastCtx.put(\"originFacilityId\", originFacilityId);\n                                isitspastCtx.put(\"userLogin\", userLogin);            \n                                isitspastCtx.put(\"trackingNum\", trackingNum);\n                                isitspastCtx.put(\"inventoryItemId\", orderItemShipGrpInvReservation.get(\"inventoryItemId\"));                \n                                isitspastCtx.put(\"shipmentId\", shipmentId);      \n                                isitspastCtx.put(\"shipmentPackageSeqId\", shipmentPackageSeqId);\n                                isitspastCtx.put(\"promisedDatetime\", orderItemShipGrpInvReservation.get(\"promisedDatetime\"));\n                                \n                                if(UtilValidate.isNotEmpty(serialNumberList)) {\n                                    for (int i = 0; i < currentResQuantity; i++) {\n                                        String serialNumber = (String) serialNumberIter.next();\n                                        isitspastCtx.put(\"serialNumber\", serialNumber);\n                                        isitspastCtx.put(\"quantity\", new Double (1));\n                                        isitspastCtx.put(\"inventoryItemId\", orderItemShipGrpInvReservation.get(\"inventoryItemId\"));\n                                        isitspastCtx.remove(\"itemIssuanceId\");                            \n                                        try {\n                                            Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                            if (ServiceUtil.isError(resultMap)){\n                                                String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                                Debug.logError(errMsg, module);\n                                            }\n                                        } catch(GenericServiceException e) {\n                                            Debug.logInfo(e, module);\n                                            String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                        }\n                                    }\n                                } else {\n                                    try {\n                                        //TODO: I think this else part is for NON Serialized Inv item. So it will be different service that we need to call here.\n                                        isitspastCtx.put(\"quantity\", new Double(currentResQuantity));\n                                        Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                        if (ServiceUtil.isError(resultMap)){\n                                            String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                            Debug.logError(errMsg, module);\n                                        }\n                                    } catch(GenericServiceException e) {\n                                        Debug.logInfo(e, module);\n                                        String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                    }            \n                                }\n                            }\n                        } catch (NumberFormatException e) {\n                            String errMsg = \"Error in format for number: \" + e.toString();\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"NumberFormatException\"));\n                            Debug.logInfo(e, errMsg, module);\n                        } catch (GenericEntityException e) {\n                            String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \" + e.toString();\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n                            Debug.logInfo(e, errMsg, module);\n                        }\n                    }\n                }\n            }\n            try {\n                Map resultMap = dispatcher.runSync(\"setShipmentStatusPackedAndShipped\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"userLogin\", userLogin));               \n                if (ServiceUtil.isError(resultMap)){\n                    String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SetShipmentStatusPackedAndShippedError\"));\n                    Debug.logError(errMsg, module);\n                }\n            } catch(GenericServiceException e) {\n                Debug.logInfo(e, module);\n                String errMsg = \"Error executing setShipmentStatusPackedAndShipped Service: \" + e.toString();\n                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            }   \n        }  \n        \n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n\n        if (errorMapList.size() > 0) {\n            // call services createOagisMsgErrInfosFromErrMapList and for incoming messages oagisSendConfirmBod\n            Map saveErrorMapListCtx = FastMap.newInstance();\n            saveErrorMapListCtx.put(\"logicalId\", logicalId);\n            saveErrorMapListCtx.put(\"component\", component);\n            saveErrorMapListCtx.put(\"task\", task);\n            saveErrorMapListCtx.put(\"referenceId\", referenceId);\n            saveErrorMapListCtx.put(\"errorMapList\", errorMapList);\n            try {\n                dispatcher.runSync(\"createOagisMsgErrInfosFromErrMapList\", saveErrorMapListCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n            }\n\n            try {\n                Map sendConfirmBodCtx = FastMap.newInstance();\n                sendConfirmBodCtx.putAll(saveErrorMapListCtx);\n                // NOTE: this is different for each service, should be shipmentId or returnId or PO orderId or etc\n                sendConfirmBodCtx.put(\"origRefId\", shipmentId);\n\n                // run async because this will send a message back to the other server and may take some time, and/or fail\n                dispatcher.runAsync(\"oagisSendConfirmBod\", sendConfirmBodCtx, null, true, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n            }\n            \n            // DEJ20070807 what was this next line commented out? if there are errors we want to return an error so this will roll back \n            result.putAll(ServiceUtil.returnError(\"Errors found processing message; information saved and return error sent back\"));\n            return result;\n        } else {\n            oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_PROC_SUCCESS\");\n            try {\n                dispatcher.runSync(\"updateOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n            } catch (GenericServiceException e){\n                String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n                // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                Debug.logError(e, errMsg, module);\n            }\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","commit_id":"f66389a0d041a1838260c31371049da583dfbc0c","url":"https://github.com/apache/ofbiz"},{"original_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    Frame dst = stk.track(asts[1].exec(env)).getFrame();\n\n    // Sanity check src vs dst\n    Frame src = stk.track(asts[2].exec(env)).getFrame();\n    if( dst.numCols() != src.numCols() )\n      throw new IllegalArgumentException(\"Source and destination frames must have the same count and type of columns\");\n    Vec[] dvecs = dst.vecs();\n    Vec[] svecs = src.vecs();\n    for( int col=0; col<dvecs.length; col++ )\n      if( dvecs[col].get_type() != svecs[col].get_type() )\n        throw new IllegalArgumentException(\"Columns must be the same type; column \"+col+\", \\'\"+dst._names[col]+\"\\', is of type \"+dvecs[col].get_type_str()+\" and the source is \"+svecs[col].get_type_str());\n\n\n    // Sanity check rows vs src and dst\n    long[] rows = null;\n    if( asts[3] instanceof ASTNumList ) {\n      double[] drows = ((ASTNumList)asts[3]).expand();\n      rows = new long[drows.length];\n      for( int i=0; i<drows.length; i++ )\n        rows[i] = (long)drows[i];\n    } else if( (asts[3] instanceof ASTNum) ) {\n      rows = new long[]{(long)(((ASTNum)asts[2])._d.getNum())};\n    } else \n      throw new IllegalArgumentException(\"Requires a number-list as the last argument, but found a \"+asts[3].getClass());\n    if( rows[rows.length-1] >= dst.numRows() ) \n      throw new IllegalArgumentException(\"Row must be an integer from 0 to \"+(dst.numRows()-1));\n    if( src.numRows() != rows.length )\n      throw new IllegalArgumentException(\"Requires same count of rows in the number-list (\"+rows.length+\") as in the source (\"+src.numRows()+\")\");\n\n    // Handle fast small case\n    if( rows.length==1 ) {\n      replace_row(dvecs,rows[0],svecs,0);\n      return new ValFrame(dst);\n    }\n    \n    // Handle large case\n    throw water.H2O.unimpl();\n  }","id":29015,"modified_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    Frame dst = stk.track(asts[1].exec(env)).getFrame();\n    Vec[] dvecs = dst.vecs();\n\n    // Sanity check rows vs dst.  To simplify logic, jam the 1 row case in as a ASTNumList\n    ASTNumList nlist;\n    if( asts[3] instanceof ASTNumList ) {\n      nlist = (ASTNumList)asts[3];\n    } else if( (asts[3] instanceof ASTNum) ) {\n      nlist = new ASTNumList(asts[2].exec(env).getNum());\n    } else throw new IllegalArgumentException(\"Requires a number-list as the last argument, but found a \"+asts[3].getClass());\n    if( !(0 <= nlist.min() && nlist.max() <= dst.numRows()) )\n      throw new IllegalArgumentException(\"Row must be an integer from 0 to \"+(dst.numRows()-1));\n    long nrows = nlist.cnt();\n\n    // Sanity check src vs dst.\n    Val vsrc = stk.track(asts[2].exec(env));\n    if( vsrc.isFrame() ) {      // Frame vs Frame \n      Frame src = vsrc.getFrame();\n      if( dst.numCols() != src.numCols() )\n        throw new IllegalArgumentException(\"Source and destination frames must have the same count and type of columns\");\n      Vec[] svecs = src.vecs();\n      for( int col=0; col<dvecs.length; col++ )\n        if( dvecs[col].get_type() != svecs[col].get_type() )\n          throw new IllegalArgumentException(\"Columns must be the same type; column \"+col+\", \\'\"+dst._names[col]+\"\\', is of type \"+dvecs[col].get_type_str()+\" and the source is \"+svecs[col].get_type_str());\n      if( src.numRows() != nrows )\n        throw new IllegalArgumentException(\"Requires same count of rows in the number-list (\"+nrows+\") as in the source (\"+src.numRows()+\")\");\n\n      // Frame fill\n      // Handle fast small case\n      if( nrows==1 ) {\n        replace_row(dvecs,(long)nlist.expand()[0],svecs,0);\n        return new ValFrame(dst);\n      }\n      // Handle large case\n      throw water.H2O.unimpl();\n    \n    } else if( vsrc.isNum() ) { // Frame vs Bare number\n      final double d = vsrc.getNum();\n      // Number fill\n      // Handle fast small case\n      if( nrows==1 ) {\n        replace_row(dvecs,(long)nlist.expand()[0],d);\n        return new ValFrame(dst);\n      }\n\n      // Handle large case\n      final ASTNumList nums = nlist;\n      new MRTask(){\n        @Override public void map(Chunk[] cs) {\n          long start = cs[0].start();\n          long end   = start + cs[0]._len;\n          double min = nums.min(), max = nums.max()-1; // exclusive max to inclusive max when stride == 1\n          //     [ start, ...,  end ]     the chunk\n          //1 []                          nums out left:  nums.max() < start\n          //2                         []  nums out rite:  nums.min() > end\n          //3 [ nums ]                    nums run left:  nums.min() < start && nums.max() <= end\n          //4          [ nums ]           nums run in  :  start <= nums.min() && nums.max() <= end\n          //5                   [ nums ]  nums run rite:  start <= nums.min() && end < nums.max()\n          if( !(max<start || min>end) ) {   // not situation 1 or 2 above\n            int startOffset = (int) (min > start ? min : start);  // situation 4 and 5 => min > start;\n            for(int i=startOffset;i<cs[0]._len;++i)\n              if( nums.has(start+i) )\n                for(int c=0;c<cs.length;++c)\n                  cs[c].set(i,d);\n          }\n        }\n      }.doAll(dst);\n      return new ValFrame(dst);\n    }\n\n    throw new IllegalArgumentException(\"Source must be a Frame or Number, but found a \"+vsrc.getClass());\n  }","commit_id":"76f342f2e83c8db9ac6b43dc5354b55b74a5eebe","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override Val apply( Env env, AST asts[] ) {\n    try (Env.StackHelp stk = env.stk()) {\n        Val left = stk.track(asts[1].exec(env));\n        Val rite = stk.track(asts[2].exec(env));\n        return prim_apply(left,rite);\n      }\n  }","id":29016,"modified_method":"@Override Val apply( Env env, AST asts[] ) {\n    try (Env.StackHelp stk = env.stk()) {\n        Val left = stk.track(asts[1].exec(env));\n        Val rite = stk.track(asts[2].exec(env));\n        return stk.returning(prim_apply(left,rite));\n      }\n  }","commit_id":"25aa8802684b85af067a2455d9b176ae90941af9","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override Val apply( Env env, AST asts[] ) {\n    try (Env.StackHelp stk = env.stk()) {\n        Val vfr  = stk.track(asts[1].exec(env));\n        Frame fr = vfr.getFrame();\n        Frame fr2 = new Frame();\n        if( asts[2] instanceof ASTNumList ) {\n          // Work down the list of columns, picking out the keepers\n          for( double dcol : ((ASTNumList)asts[2]).expand() ) {\n            int col = (int)dcol;\n            if( col!=dcol || col < 0 || col >= fr.numCols() ) \n              throw new IllegalArgumentException(\"Column must be an integer from 0 to \"+(fr.numCols()-1));\n            fr2.add(fr.names()[col],fr.vecs()[col]);\n          }\n        } else if( (asts[2] instanceof ASTNum) ) {\n          int col = (int)(((ASTNum)asts[2])._d.getNum());\n          fr2.add(fr.names()[col],fr.vecs()[col]);\n        } else\n          throw new IllegalArgumentException(\"Column slicing requires a number-list as the last argument, but found a \"+asts[2].getClass());\n\n        return stk.returning(new ValFrame(fr2));\n      }\n  }","id":29017,"modified_method":"@Override Val apply( Env env, AST asts[] ) {\n    try (Env.StackHelp stk = env.stk()) {\n        Frame fr = stk.track(asts[1].exec(env)).getFrame();\n        Frame fr2 = new Frame();\n        if( asts[2] instanceof ASTNumList ) {\n          // Work down the list of columns, picking out the keepers\n          for( double dcol : ((ASTNumList)asts[2]).expand() ) {\n            int col = (int)dcol;\n            if( col!=dcol || col < 0 || col >= fr.numCols() ) \n              throw new IllegalArgumentException(\"Column must be an integer from 0 to \"+(fr.numCols()-1));\n            fr2.add(fr.names()[col],fr.vecs()[col]);\n          }\n        } else if( (asts[2] instanceof ASTNum) ) {\n          int col = (int)(((ASTNum)asts[2])._d.getNum());\n          fr2.add(fr.names()[col],fr.vecs()[col]);\n        } else\n          throw new IllegalArgumentException(\"Column slicing requires a number-list as the last argument, but found a \"+asts[2].getClass());\n\n        return stk.returning(new ValFrame(fr2));\n      }\n  }","commit_id":"25aa8802684b85af067a2455d9b176ae90941af9","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override Val apply( Env env, AST asts[] ) {\n    try (Env.StackHelp stk = env.stk()) {\n        Val vfr  = stk.track(asts[1].exec(env));\n        Frame fr = vfr.getFrame();\n        long[] rows = null;\n        if( asts[2] instanceof ASTNumList ) {\n          double[] drows = ((ASTNumList)asts[2]).expand();\n          rows = new long[drows.length];\n          for( int i=0; i<drows.length; i++ ) {\n            long row = (long)drows[i];\n            if( row!=drows[i] || row < 0 || row >= fr.numRows() ) \n              throw new IllegalArgumentException(\"Row must be an integer from 0 to \"+(fr.numRows()-1));\n            rows[i] = row;\n          }\n        } else if( (asts[2] instanceof ASTNum) ) {\n          rows = new long[]{(long)(((ASTNum)asts[2])._d.getNum())};\n        } else \n          throw new IllegalArgumentException(\"Row slicing requires a number-list as the last argument, but found a \"+asts[2].getClass());\n        return stk.returning(new ValFrame(fr.deepSlice(rows,null)));\n      }\n  }","id":29018,"modified_method":"@Override Val apply( Env env, AST asts[] ) {\n    try (Env.StackHelp stk = env.stk()) {\n        Frame fr = stk.track(asts[1].exec(env)).getFrame();\n        long[] rows = null;\n        if( asts[2] instanceof ASTNumList ) {\n          double[] drows = ((ASTNumList)asts[2]).expand();\n          rows = new long[drows.length];\n          for( int i=0; i<drows.length; i++ ) {\n            long row = (long)drows[i];\n            if( row!=drows[i] || row < 0 || row >= fr.numRows() ) \n              throw new IllegalArgumentException(\"Row must be an integer from 0 to \"+(fr.numRows()-1));\n            rows[i] = row;\n          }\n        } else if( (asts[2] instanceof ASTNum) ) {\n          rows = new long[]{(long)(((ASTNum)asts[2])._d.getNum())};\n        } else \n          throw new IllegalArgumentException(\"Row slicing requires a number-list as the last argument, but found a \"+asts[2].getClass());\n        return stk.returning(new ValFrame(fr.deepSlice(rows,null)));\n      }\n  }","commit_id":"25aa8802684b85af067a2455d9b176ae90941af9","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public ValFrame returning( ValFrame fr ) {\n      assert _ret_fr == null;\n      _ret_fr = fr._fr;\n      return fr;\n    }","id":29019,"modified_method":"public <V extends Val> V returning( V fr ) {\n      if( fr instanceof ValFrame )\n        _ret_fr = ((ValFrame)fr)._fr;\n      return fr;\n    }","commit_id":"25aa8802684b85af067a2455d9b176ae90941af9","url":"https://github.com/h2oai/h2o-3"},{"original_method":"char peek() { return _str.charAt(_x); }","id":29020,"modified_method":"char peek() { return _x < _str.length() ? _str.charAt(_x) : ' '; }","commit_id":"25aa8802684b85af067a2455d9b176ae90941af9","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public RapidsSchema exec(int version, RapidsSchema rapids) {\n    if( rapids == null ) return null;\n    if( rapids.ast == null || rapids.ast.equals(\"\") ) return rapids;\n    Val val;\n    try {\n      // No locking, no synchronization - since any local locking is NOT a\n      // cluster-wide lock locking, which just provides the illusion of safety\n      // but not the actuality.\n      val = water.currents.Exec.exec(rapids.ast);\n    } catch( IllegalArgumentException e ) {\n      throw e;\n    } catch( Throwable e ) {\n      Log.err(e);\n      throw e;\n    }\n\n    switch( val.type() ) {\n    case Val.NUM:  return new RapidsScalarV3(val.getNum());\n    case Val.STR:  return new RapidsStringV3(val.getStr());\n    case Val.FUN:  return new RapidsFunctionV3(val.getFun().toString());\n    case Val.FRM:\n      Frame fr = val.getFrame();\n      if( rapids.id==null ) {\n        fr.delete();\n        throw new IllegalArgumentException(\"Missing the result key 'id' for the returned frame\");\n      }\n      Key k = Key.make(rapids.id);\n      DKV.put(fr=new Frame(k,fr._names,fr.vecs()));\n      return new RapidsFrameV3(fr); // Return the Frame key, not the entire frame\n    default:  throw H2O.fail();\n    }\n  }","id":29021,"modified_method":"public RapidsSchema exec(int version, RapidsSchema rapids) {\n    if( rapids == null ) return null;\n    if( rapids.ast == null || rapids.ast.equals(\"\") ) return rapids;\n    Val val;\n    try {\n      // No locking, no synchronization - since any local locking is NOT a\n      // cluster-wide lock locking, which just provides the illusion of safety\n      // but not the actuality.\n      val = water.currents.Exec.exec(rapids.ast);\n    } catch( IllegalArgumentException e ) {\n      throw e;\n    } catch( Throwable e ) {\n      Log.err(e);\n      throw e;\n    }\n\n    switch( val.type() ) {\n    case Val.NUM:  return new RapidsScalarV3(val.getNum());\n    case Val.STR:  return new RapidsStringV3(val.getStr());\n    case Val.FUN:  return new RapidsFunctionV3(val.getFun().toString());\n    case Val.FRM:\n      Frame fr = val.getFrame();\n      if( rapids.id==null ) {\n        fr.delete();\n        throw new IllegalArgumentException(\"Missing the result key 'id' for the returned frame\");\n      }\n      Key k = Key.make(rapids.id);\n      // Smart delete any prior top-level result\n      Iced i = DKV.getGet(k);\n      if( i instanceof Lockable) ((Lockable)i).delete();\n      else if( i instanceof Keyed ) ((Keyed)i).remove();\n      else if( i != null ) throw new IllegalArgumentException(\"Attempting to overright an unexpected key\");\n      // Install new top-level result\n      DKV.put(fr=new Frame(k,fr._names,fr.vecs()));\n      return new RapidsFrameV3(fr); // Return the Frame key, not the entire frame\n    default:  throw H2O.fail();\n    }\n  }","commit_id":"25aa8802684b85af067a2455d9b176ae90941af9","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n     * @see org.apache.sling.api.request.RequestParameter#getString()\n     */\n    public String getString() {\n        // only apply encoding in the case of a form field\n        if (this.isFormField()) {\n            return this.getEncodedString();\n        }\n\n        return this.delegatee.getString();\n    }","id":29022,"modified_method":"/**\n     * @see org.apache.sling.api.request.RequestParameter#getString()\n     */\n    public String getString() {\n        // only apply encoding in the case of a form field\n        if (this.isFormField()) {\n            if (this.cachedValue == null) {\n                // try explicit encoding if available\n                byte[] data = get();\n                String encoding = getEncoding();\n                if (encoding != null) {\n                    try {\n                        this.cachedValue = new String(data, encoding);\n                    } catch (UnsupportedEncodingException uee) {\n                        // don't care, fall back to platform default\n                    }\n                }\n\n                // if there is no encoding, or an illegal encoding,\n                // use platform default\n                if (cachedValue == null) {\n                    cachedValue = new String(data);\n                }\n            }\n\n            return this.cachedValue;\n        }\n\n        return this.delegatee.getString();\n    }","commit_id":"d511a8671fbb760f77faa28aee3f1f6637436746","url":"https://github.com/apache/sling"},{"original_method":"private void getContainerParameters(ParameterMap parameters) {\n\n        final Map<?, ?> pMap = getServletRequest().getParameterMap();\n        for (Map.Entry<?, ?> entry : pMap.entrySet()) {\n\n            final String name = (String) entry.getKey();\n            final String[] values = (String[]) entry.getValue();\n\n            for (int i = 0; i < values.length; i++) {\n                final EncodedRequestParameter rp = new EncodedRequestParameter(\n                    Util.ENCODING_DEFAULT);\n                try {\n                    rp.setContent(values[i].getBytes(Util.ENCODING_DEFAULT));\n                } catch (UnsupportedEncodingException ue) {\n                    throw new Error(\n                        \"Unexpected UnsupportedEncodingException for encoding=\"\n                            + Util.ENCODING_DEFAULT);\n                }\n                parameters.addParameter(name, rp);\n            }\n\n        }\n    }","id":29023,"modified_method":"private void getContainerParameters(ParameterMap parameters) {\n\n        final Map<?, ?> pMap = getServletRequest().getParameterMap();\n        for (Map.Entry<?, ?> entry : pMap.entrySet()) {\n\n            final String name = (String) entry.getKey();\n            final String[] values = (String[]) entry.getValue();\n\n            for (int i = 0; i < values.length; i++) {\n                parameters.addParameter(name, new ContainerRequestParameter(\n                    values[i], Util.ENCODING_DEFAULT));\n            }\n\n        }\n    }","commit_id":"d511a8671fbb760f77faa28aee3f1f6637436746","url":"https://github.com/apache/sling"},{"original_method":"static void fixEncoding(ParameterMap parameterMap) {\n        // default the encoding to ISO-8859-1 (aka direct, 1:1 encoding)\n        String formEncoding = ENCODING_DIRECT;\n\n        // check whether a FormEncoding parameter overwrites this default\n        RequestParameter[] feParm = parameterMap.get(PARAMETER_FORMENCODING);\n        if (feParm != null) {\n            // get and check form encoding\n            byte[] rawEncoding = feParm[0].get();\n            formEncoding = toIdentityEncodedString(rawEncoding);\n\n            // check for the existence of the encoding\n            try {\n                \"\".getBytes(formEncoding);\n            } catch (UnsupportedEncodingException e) {\n                // log.warn(\"HttpMulitpartPost: Character encoding {0} is not \"\n                // + \"supported, using default {1}\", formEncodingParam,\n                // DEFAULT_ENCODING);\n                formEncoding = ENCODING_DIRECT;\n            }\n        }\n\n        // map for rename parameters due to encoding fixes\n        Map<String, String> renameMap = new HashMap<String, String>();\n\n        // convert the map of lists to a map of arrays\n        for (Map.Entry<String, RequestParameter[]> paramEntry : parameterMap.entrySet()) {\n            RequestParameter[] params = paramEntry.getValue();\n            String parName = null;\n            for (int i = 0; i < params.length; i++) {\n                if (params[i] instanceof AbstractEncodedParameter) {\n                    AbstractEncodedParameter param = (AbstractEncodedParameter) params[i];\n\n                    // fix encoding if different\n                    if (param.getEncoding() == null) {\n                        param.setEncoding(formEncoding);\n\n                        // prepare the parameter for renaming\n                        try {\n                            if (parName == null) {\n                                parName = paramEntry.getKey();\n                                String name = URLDecoder.decode(parName,\n                                    formEncoding);\n                                renameMap.put(paramEntry.getKey(), name);\n                            }\n                        } catch (UnsupportedEncodingException uee) {\n                            // unexpected, as the encoding has been checked !\n                        }\n                    }\n                }\n            }\n        }\n\n        // apply mappings of deinternationalized names\n        if (!renameMap.isEmpty()) {\n            for (Map.Entry<String, String> entry : renameMap.entrySet()) {\n                parameterMap.renameParameter(entry.getKey(), entry.getValue());\n            }\n        }\n    }","id":29024,"modified_method":"static void fixEncoding(ParameterMap parameterMap) {\n        // default the encoding to ISO-8859-1 (aka direct, 1:1 encoding)\n        String formEncoding = ENCODING_DIRECT;\n\n        // check whether a FormEncoding parameter overwrites this default\n        RequestParameter[] feParm = parameterMap.get(PARAMETER_FORMENCODING);\n        if (feParm != null) {\n            // get and check form encoding\n            byte[] rawEncoding = feParm[0].get();\n            formEncoding = toIdentityEncodedString(rawEncoding);\n\n            // check for the existence of the encoding\n            try {\n                \"\".getBytes(formEncoding);\n            } catch (UnsupportedEncodingException e) {\n                // log.warn(\"HttpMulitpartPost: Character encoding {0} is not \"\n                // + \"supported, using default {1}\", formEncodingParam,\n                // DEFAULT_ENCODING);\n                formEncoding = ENCODING_DIRECT;\n            }\n        }\n\n        // map for rename parameters due to encoding fixes\n        Map<String, String> renameMap = new HashMap<String, String>();\n\n        // convert the map of lists to a map of arrays\n        for (Map.Entry<String, RequestParameter[]> paramEntry : parameterMap.entrySet()) {\n            RequestParameter[] params = paramEntry.getValue();\n            String parName = null;\n            for (int i = 0; i < params.length; i++) {\n                if (params[i] instanceof AbstractRequestParameter) {\n                    AbstractRequestParameter param = (AbstractRequestParameter) params[i];\n\n                    // fix encoding if different\n                    if (param.getEncoding() == null) {\n                        param.setEncoding(formEncoding);\n\n                        // prepare the parameter for renaming\n                        try {\n                            if (parName == null) {\n                                parName = paramEntry.getKey();\n                                String name = URLDecoder.decode(parName,\n                                    formEncoding);\n                                renameMap.put(paramEntry.getKey(), name);\n                            }\n                        } catch (UnsupportedEncodingException uee) {\n                            // unexpected, as the encoding has been checked !\n                        }\n                    }\n                }\n            }\n        }\n\n        // apply mappings of deinternationalized names\n        if (!renameMap.isEmpty()) {\n            for (Map.Entry<String, String> entry : renameMap.entrySet()) {\n                parameterMap.renameParameter(entry.getKey(), entry.getValue());\n            }\n        }\n    }","commit_id":"d511a8671fbb760f77faa28aee3f1f6637436746","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.http.HttpServletRequest#getParameter(String)\n     */\n    public String getUploadedFileName(String name) {\n        if (!isFormDataParsed) {\n            return null;\n        }\n\n        Object o = params.get(name);\n        if (o == null) {\n            return null;\n        }\n\n        FileItem item = getFileItem(o);\n        if (item.isFormField()) {\n            return null;\n        }\n\n        // Get filename from FileItem\n        String itemName = item.getName();\n        if (itemName == null) {\n            return null;\n        }\n\n        // return Filename only\n        return FilenameUtils.getName(itemName);\n    }","id":29025,"modified_method":"/**\n     * @see javax.servlet.http.HttpServletRequest#getParameter(String)\n     */\n    public String getUploadedFileName(String name) {\n        if (!isFormDataParsed) {\n            return null;\n        }\n\n        Object o = params.get(name);\n        if (o == null) {\n            return null;\n        }\n\n        FileItem item = getFileItem(o);\n        if (item==null || item.isFormField()) {\n            return null;\n        }\n\n        // Get filename from FileItem\n        String itemName = item.getName();\n        if (itemName == null) {\n            return null;\n        }\n\n        // return Filename only\n        return FilenameUtils.getName(itemName);\n    }","commit_id":"cd2bc54bfc7cef5bba29a5b34eedac716d061ec2","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * @see javax.servlet.http.HttpServletRequest#getParameter(String)\n     */\n    public File getFileUploadParam(String name) {\n        if (!isFormDataParsed) {\n            return null;\n        }\n\n        Object o = params.get(name);\n        if (o == null) {\n            return null;\n        }\n\n        FileItem item = getFileItem(o);\n        if (item.isFormField()) {\n            return null;\n        }\n\n        return ((DiskFileItem) item).getStoreLocation();\n    }","id":29026,"modified_method":"/**\n     * @see javax.servlet.http.HttpServletRequest#getParameter(String)\n     */\n    public File getFileUploadParam(String name) {\n        if (!isFormDataParsed) {\n            return null;\n        }\n\n        Object o = params.get(name);\n        if (o == null) {\n            return null;\n        }\n\n        FileItem item = getFileItem(o);\n        if (item==null || item.isFormField()) {\n            return null;\n        }\n\n        return ((DiskFileItem) item).getStoreLocation();\n    }","commit_id":"cd2bc54bfc7cef5bba29a5b34eedac716d061ec2","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Get file item\n     * \n     * @param obj List or Fileitem\n     * @return First Fileitem in list or Fileitem.\n     */\n    private FileItem getFileItem(Object obj) {\n        if (obj instanceof List) {\n            return (FileItem) ((List) obj).get(0);\n        } else {\n            return (FileItem) obj;\n        }\n    }","id":29027,"modified_method":"/**\n     *  Convert object to FileItem, get FirstItem from list, or null\n     * if object or object in list is not a FileItem\n     * \n     * @param obj List or Fileitem\n     * @return First Fileitem in list or Fileitem.\n     */\n    private FileItem getFileItem(Object obj) {\n\n        if (obj instanceof List) {\n\n            // Cast\n            List list = (List) obj;\n\n            // Return first FileItem object if present\n            for(Object listObject : list) {\n                if(listObject instanceof FileItem){\n                    return (FileItem) listObject;\n                }\n            }           \n\n        } else if(obj instanceof FileItem){\n            // Cast and return\n             return (FileItem) obj;         \n        }\n\n        // object did not represent a List of FileItem's or FileItem.\n        return null;\n\n    }","commit_id":"cd2bc54bfc7cef5bba29a5b34eedac716d061ec2","url":"https://github.com/eXist-db/exist"},{"original_method":"private Statement createConstructorStatementMapSpecial(FieldNode fNode) {\n        final FieldExpression fieldExpr = new FieldExpression(fNode);\n        Expression initExpr = fNode.getInitialValueExpression();\n        if (initExpr == null) initExpr = ConstantExpression.NULL;\n        Expression args = findArg(fNode.getName());\n        return new IfStatement(\n                equalsNullExpr(args),\n                new IfStatement(\n                        equalsNullExpr(initExpr),\n                        new IfStatement(\n                                equalsNullExpr(new VariableExpression(\"args\")),\n                                new EmptyStatement(),\n                                assignStatement(fieldExpr, cloneCollectionExpr(new VariableExpression(\"args\")))\n                        ),\n                        assignStatement(fieldExpr, cloneCollectionExpr(initExpr))),\n                assignStatement(fieldExpr, cloneCollectionExpr(args)));\n    }","id":29028,"modified_method":"private Statement createConstructorStatementMapSpecial(FieldNode fNode) {\n        final FieldExpression fieldExpr = new FieldExpression(fNode);\n        Expression initExpr = fNode.getInitialValueExpression();\n        if (initExpr == null) initExpr = ConstantExpression.NULL;\n        Expression namedArgs = findArg(fNode.getName());\n        Expression baseArgs = new VariableExpression(\"args\");\n        return new IfStatement(\n                equalsNullExpr(baseArgs),\n                new IfStatement(\n                        equalsNullExpr(initExpr),\n                        new EmptyStatement(),\n                        assignStatement(fieldExpr, cloneCollectionExpr(initExpr))),\n                new IfStatement(\n                        equalsNullExpr(namedArgs),\n                        new IfStatement(\n                                isTrueExpr(new MethodCallExpression(baseArgs, \"containsKey\", new ConstantExpression(fNode.getName()))),\n                                assignStatement(fieldExpr, namedArgs),\n                                assignStatement(fieldExpr, cloneCollectionExpr(baseArgs))),\n                        new IfStatement(\n                                isOneExpr(new MethodCallExpression(baseArgs, \"size\", MethodCallExpression.NO_ARGUMENTS)),\n                                assignStatement(fieldExpr, cloneCollectionExpr(namedArgs)),\n                                assignStatement(fieldExpr, cloneCollectionExpr(baseArgs)))\n                )\n        );\n    }","commit_id":"a613a08b824e985988979949243492c379119959","url":"https://github.com/apache/groovy"},{"original_method":"private Statement createConstructorStatementCollection(FieldNode fNode) {\n        final Expression fieldExpr = new VariableExpression(fNode);\n        Expression initExpr = fNode.getInitialValueExpression();\n        if (initExpr == null) initExpr = ConstantExpression.NULL;\n        Expression collection = findArg(fNode.getName());\n        return new IfStatement(\n                equalsNullExpr(collection),\n                new IfStatement(\n                        equalsNullExpr(initExpr),\n                        new EmptyStatement(),\n                        assignStatement(fieldExpr, cloneCollectionExpr(initExpr))),\n                assignStatement(fieldExpr, cloneCollectionExpr(collection)));\n    }","id":29029,"modified_method":"private Statement createConstructorStatementCollection(FieldNode fNode) {\n        final Expression fieldExpr = new VariableExpression(fNode);\n        Expression initExpr = fNode.getInitialValueExpression();\n        if (initExpr == null) initExpr = ConstantExpression.NULL;\n        Expression collection = findArg(fNode.getName());\n        return new IfStatement(\n                equalsNullExpr(collection),\n                new IfStatement(\n                        equalsNullExpr(initExpr),\n                        new EmptyStatement(),\n                        assignStatement(fieldExpr, cloneCollectionExpr(initExpr))),\n                new IfStatement(\n                    isInstanceOf(collection, CLONEABLE_TYPE),\n                    assignStatement(fieldExpr, cloneCollectionExpr(cloneArrayOrCloneableExpr(collection))),\n                    assignStatement(fieldExpr, cloneCollectionExpr(collection))));\n    }","commit_id":"4ea1ddd66b03fda308fc402af9e1707510d7a0e5","url":"https://github.com/apache/groovy"},{"original_method":"private Statement createConstructorStatement(ClassNode cNode, PropertyNode pNode) {\n        FieldNode fNode = pNode.getField();\n        final ClassNode fieldType = fNode.getType();\n        Statement statement = null;\n        if (fieldType.isArray() || fieldType.implementsInterface(CLONEABLE_TYPE)) {\n            statement = createConstructorStatementArrayOrCloneable(fNode);\n        } else if (fieldType.isDerivedFrom(DATE_TYPE)) {\n            statement = createConstructorStatementDate(fNode);\n        } else if (isOrImplements(fieldType, COLLECTION_TYPE) || isOrImplements(fieldType, MAP_TYPE)) {\n            statement = createConstructorStatementCollection(fNode);\n        } else if (isKnownImmutable(fieldType)) {\n            statement = createConstructorStatementDefault(fNode);\n        } else if (fieldType.isResolved()) {\n            addError(createErrorMessage(cNode.getName(), fNode.getName(), fieldType.getName(), \"compiling\"), fNode);\n        } else {\n            statement = createConstructorStatementGuarded(cNode, fNode);\n        }\n        return statement;\n    }","id":29030,"modified_method":"private Statement createConstructorStatement(ClassNode cNode, PropertyNode pNode) {\n        FieldNode fNode = pNode.getField();\n        final ClassNode fieldType = fNode.getType();\n        Statement statement = null;\n        if (fieldType.isArray() || fieldType.implementsInterface(CLONEABLE_TYPE)) {\n            statement = createConstructorStatementArrayOrCloneable(fNode);\n        } else if (fieldType.isDerivedFrom(DATE_TYPE)) {\n            statement = createConstructorStatementDate(fNode);\n        } else if (isOrImplements(fieldType, COLLECTION_TYPE) || fieldType.isDerivedFrom(COLLECTION_TYPE) || isOrImplements(fieldType, MAP_TYPE) || fieldType.isDerivedFrom(MAP_TYPE)) {\n            statement = createConstructorStatementCollection(fNode);\n        } else if (isKnownImmutable(fieldType)) {\n            statement = createConstructorStatementDefault(fNode);\n        } else if (fieldType.isResolved()) {\n            addError(createErrorMessage(cNode.getName(), fNode.getName(), fieldType.getName(), \"compiling\"), fNode);\n        } else {\n            statement = createConstructorStatementGuarded(cNode, fNode);\n        }\n        return statement;\n    }","commit_id":"4ea1ddd66b03fda308fc402af9e1707510d7a0e5","url":"https://github.com/apache/groovy"},{"original_method":"private static Statement calculateHashStatements(ClassNode cNode, Expression hash, boolean includeFields, boolean callSuper, List<String> excludes, List<String> includes) {\r\n        final List<PropertyNode> pList = getInstanceProperties(cNode);\r\n        final List<FieldNode> fList = new ArrayList<FieldNode>();\r\n        if (includeFields) {\r\n            fList.addAll(getInstanceNonPropertyFields(cNode));\r\n        }\r\n        final BlockStatement body = new BlockStatement();\r\n        // def _result = HashCodeHelper.initHash()\r\n        final Expression result = new VariableExpression(\"_result\");\r\n        final Expression init = new StaticMethodCallExpression(HASHUTIL_TYPE, \"initHash\", MethodCallExpression.NO_ARGUMENTS);\r\n        body.addStatement(new ExpressionStatement(new DeclarationExpression(result, ASSIGN, init)));\r\n\r\n        for (PropertyNode pNode : pList) {\r\n            if (shouldSkip(pNode.getName(), excludes, includes)) continue;\r\n            // _result = HashCodeHelper.updateHash(_result, getProperty())\r\n            String getterName = \"get\" + Verifier.capitalize(pNode.getName());\r\n            Expression getter = new MethodCallExpression(VariableExpression.THIS_EXPRESSION, getterName, MethodCallExpression.NO_ARGUMENTS);\r\n            final Expression args = new TupleExpression(result, getter);\r\n            final Expression current = new StaticMethodCallExpression(HASHUTIL_TYPE, \"updateHash\", args);\r\n            body.addStatement(assignStatement(result, current));\r\n\r\n        }\r\n        for (FieldNode fNode : fList) {\r\n            if (shouldSkip(fNode.getName(), excludes, includes)) continue;\r\n            // _result = HashCodeHelper.updateHash(_result, field)\r\n            final Expression fieldExpr = new VariableExpression(fNode);\r\n            final Expression args = new TupleExpression(result, fieldExpr);\r\n            final Expression current = new StaticMethodCallExpression(HASHUTIL_TYPE, \"updateHash\", args);\r\n            body.addStatement(assignStatement(result, current));\r\n        }\r\n        if (callSuper) {\r\n            // _result = HashCodeHelper.updateHash(_result, super.hashCode())\r\n            final Expression args = new TupleExpression(result, new MethodCallExpression(VariableExpression.SUPER_EXPRESSION, \"hashCode\", MethodCallExpression.NO_ARGUMENTS));\r\n            final Expression current = new StaticMethodCallExpression(HASHUTIL_TYPE, \"updateHash\", args);\r\n            body.addStatement(assignStatement(result, current));\r\n        }\r\n        // $hash$code = _result\r\n        if (hash != null) {\r\n            body.addStatement(assignStatement(hash, result));\r\n        } else {\r\n            body.addStatement(new ReturnStatement(result));\r\n        }\r\n        return body;\r\n    }","id":29031,"modified_method":"private static Statement calculateHashStatements(ClassNode cNode, Expression hash, boolean includeFields, boolean callSuper, List<String> excludes, List<String> includes) {\r\n        final List<PropertyNode> pList = getInstanceProperties(cNode);\r\n        final List<FieldNode> fList = new ArrayList<FieldNode>();\r\n        if (includeFields) {\r\n            fList.addAll(getInstanceNonPropertyFields(cNode));\r\n        }\r\n        final BlockStatement body = new BlockStatement();\r\n        // def _result = HashCodeHelper.initHash()\r\n        final Expression result = new VariableExpression(\"_result\");\r\n        final Expression init = new StaticMethodCallExpression(HASHUTIL_TYPE, \"initHash\", MethodCallExpression.NO_ARGUMENTS);\r\n        body.addStatement(new ExpressionStatement(new DeclarationExpression(result, ASSIGN, init)));\r\n\r\n        for (PropertyNode pNode : pList) {\r\n            if (shouldSkip(pNode.getName(), excludes, includes)) continue;\r\n            // _result = HashCodeHelper.updateHash(_result, getProperty()) // plus self-reference checking\r\n            String getterName = \"get\" + Verifier.capitalize(pNode.getName());\r\n            Expression getter = new MethodCallExpression(VariableExpression.THIS_EXPRESSION, getterName, MethodCallExpression.NO_ARGUMENTS);\r\n            final Expression args = new TupleExpression(result, getter);\r\n            final Expression current = new StaticMethodCallExpression(HASHUTIL_TYPE, \"updateHash\", args);\r\n            body.addStatement(new IfStatement(identicalExpr(getter, new VariableExpression(\"this\")),\r\n                    EmptyStatement.INSTANCE,\r\n                    assignStatement(result, current)));\r\n\r\n        }\r\n        for (FieldNode fNode : fList) {\r\n            if (shouldSkip(fNode.getName(), excludes, includes)) continue;\r\n            // _result = HashCodeHelper.updateHash(_result, field) // plus self-reference checking\r\n            final Expression fieldExpr = new VariableExpression(fNode);\r\n            final Expression args = new TupleExpression(result, fieldExpr);\r\n            final Expression current = new StaticMethodCallExpression(HASHUTIL_TYPE, \"updateHash\", args);\r\n            body.addStatement(new IfStatement(identicalExpr(fieldExpr, new VariableExpression(\"this\")),\r\n                    EmptyStatement.INSTANCE,\r\n                    assignStatement(result, current)));\r\n        }\r\n        if (callSuper) {\r\n            // _result = HashCodeHelper.updateHash(_result, super.hashCode())\r\n            final Expression args = new TupleExpression(result, new MethodCallExpression(VariableExpression.SUPER_EXPRESSION, \"hashCode\", MethodCallExpression.NO_ARGUMENTS));\r\n            final Expression current = new StaticMethodCallExpression(HASHUTIL_TYPE, \"updateHash\", args);\r\n            body.addStatement(assignStatement(result, current));\r\n        }\r\n        // $hash$code = _result\r\n        if (hash != null) {\r\n            body.addStatement(assignStatement(hash, result));\r\n        } else {\r\n            body.addStatement(new ReturnStatement(result));\r\n        }\r\n        return body;\r\n    }","commit_id":"fc1822f61a80452f09d086d3461cf0a70539ae2a","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Add a new assignment definition to the gradebook\n     * @param assignment\n\t * @return id of the newly created assignment or null if there were any errors\n     */\n    public Long addAssignment(Assignment assignment) {\n\t\t\n    \tGradebook gradebook = getGradebook();\n        \n    \tif(gradebook != null) {\n            String gradebookId = gradebook.getUid();\n            return this.gradebookService.addAssignment(gradebookId, assignment);\n            \n            //TODO wrap this so we can catch any runtime exceptions\n        }\n\t\treturn null;\n    }","id":29032,"modified_method":"/**\n     * Add a new assignment definition to the gradebook\n     * @param assignment\n\t * @return id of the newly created assignment or null if there were any errors\n     */\n    public Long addAssignment(Assignment assignment) {\n\t\t\n    \tGradebook gradebook = getGradebook();\n        \n    \tif(gradebook != null) {\n            String gradebookId = gradebook.getUid();\n\n            Long assignmentId = this.gradebookService.addAssignment(gradebookId, assignment);\n\n            // Force the assignment to sit at the end of the list\n            if (assignment.getSortOrder() == null) {\n                List<Assignment> allAssignments = this.gradebookService.getAssignments(gradebookId);\n                int nextSortOrder = allAssignments.size();\n                for (Assignment anotherAssignment : allAssignments) {\n                    if (anotherAssignment.getSortOrder() != null && anotherAssignment.getSortOrder() >= nextSortOrder) {\n                        nextSortOrder = anotherAssignment.getSortOrder() + 1;\n                    }\n                }\n                updateAssignmentOrder(assignmentId, nextSortOrder);\n            }\n\n            return assignmentId;\n            \n            //TODO wrap this so we can catch any runtime exceptions\n        }\n\t\treturn null;\n    }","commit_id":"5dd7c37c8ae62acd7e3c7691960ae1f439ad91b3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n    public void onInitialize() {\n        super.onInitialize();\n\n        //unpack model\n        final ImportWizardModel importWizardModel = this.model.getObject();\n\n        final List<ProcessedGradeItem> itemsToCreate = importWizardModel.getItemsToCreate();\n        final List<ProcessedGradeItem> itemsToUpdate = importWizardModel.getItemsToUpdate();\n        final List<Assignment> assignmentsToCreate = importWizardModel.getAssignmentsToCreate();\n\n        Form<?> form = new Form(\"form\")\n        {\n            @Override\n            protected void onSubmit()\n            {\n                boolean errors = false;\n                //Create new GB items\n                for (Assignment assignment : assignmentsToCreate) {\n                    businessService.addAssignment(assignment);\n                }\n\n                List<ProcessedGradeItem> itemsToSave = new ArrayList<ProcessedGradeItem>();\n                itemsToSave.addAll(itemsToUpdate);\n                itemsToSave.addAll(itemsToCreate);\n                for (ProcessedGradeItem processedGradeItem : itemsToSave) {\n                    LOG.debug(\"Looping through items to save\");\n                    for (ProcessedGradeItemDetail processedGradeItemDetail : processedGradeItem.getProcessedGradeItemDetails()) {\n                        LOG.debug(\"Looping through detail items to save\");\n                        GradeSaveResponse saved = businessService.saveGrade(processedGradeItem.getItemId(), processedGradeItemDetail.getStudentUuid(),\n                                processedGradeItemDetail.getGrade(), processedGradeItemDetail.getComment());\n\n                        if (saved == GradeSaveResponse.NO_CHANGE) {\n                            //Check for changed comments\n                            String currentComment = businessService.getAssignmentGradeComment(processedGradeItem.getItemId(),\n                                    processedGradeItemDetail.getStudentUuid());\n\n                            currentComment = StringUtils.trimToNull(currentComment);\n                            String newComment = StringUtils.trimToNull(processedGradeItemDetail.getComment());\n                            if (!StringUtils.equals(currentComment, newComment)) {\n                                boolean success = businessService.updateAssignmentGradeComment(processedGradeItem.getItemId(),\n                                        processedGradeItemDetail.getStudentUuid(), newComment);\n                                LOG.info(\"Saving comment: \" + success + \", \" + processedGradeItem.getItemId() + \", \" + processedGradeItemDetail.getStudentEid() + \", \" +\n                                        processedGradeItemDetail.getComment());\n                                if (!success) {\n                                    errors = true;\n                                }\n                            }\n                        } else if (saved != GradeSaveResponse.OK) {\n                            //Anything other than OK is bad\n                            errors = true;\n                        }\n                        LOG.info(\"Saving grade: \" + saved + \", \" + processedGradeItem.getItemId() + \", \" + processedGradeItemDetail.getStudentEid() + \", \" +\n                                processedGradeItemDetail.getGrade() + \", \" + processedGradeItemDetail.getComment());\n                    }\n                }\n\n                if (!errors) {\n                    getSession().info(getString(\"importExport.confirmation.success\"));\n                    setResponsePage(new GradebookPage());\n                } else {\n                    getSession().error(getString(\"importExport.confirmation.failure\"));\n                }\n            }\n        };\n        add(form);\n\n        Button backButton = new Button(\"backbutton\") {\n            @Override\n            public void onSubmit() {\n                LOG.debug(\"Clicking back button...\");\n                Component newPanel = null;\n                if (assignmentsToCreate.size() > 0)\n                    newPanel = new CreateGradeItemStep(panelId, Model.of(importWizardModel));\n                else\n                    newPanel = new GradeItemImportSelectionStep(panelId, Model.of(importWizardModel));\n                newPanel.setOutputMarkupId(true);\n                GradeImportConfirmationStep.this.replaceWith(newPanel);\n\n\n            }\n        };\n        backButton.setDefaultFormProcessing(false);\n        form.add(backButton);\n\n        form.add(new Button(\"finishbutton\"));\n\n        final boolean hasItemsToUpdate = !itemsToUpdate.isEmpty();\n        WebMarkupContainer gradesUpdateContainer = new WebMarkupContainer (\"grades_update_container\") {\n            public boolean isVisible() { return hasItemsToUpdate; }\n        };\n        add(gradesUpdateContainer);\n\n        if (hasItemsToUpdate) {\n            ListView<ProcessedGradeItem> updateList = makeListView(\"grades_update\", itemsToUpdate);\n\n            updateList.setReuseItems(true);\n            gradesUpdateContainer.add(updateList);\n        }\n\n        final boolean hasItemsToCreate = !itemsToCreate.isEmpty();\n        WebMarkupContainer gradesCreateContainer = new WebMarkupContainer (\"grades_create_container\") {\n            public boolean isVisible() { return hasItemsToCreate; }\n        };\n        add(gradesCreateContainer);\n\n        if (hasItemsToCreate) {\n            ListView<ProcessedGradeItem> createList = makeListView(\"grades_create\", itemsToCreate);\n\n            createList.setReuseItems(true);\n            gradesCreateContainer.add(createList);\n        }\n    }","id":29033,"modified_method":"@Override\n    public void onInitialize() {\n        super.onInitialize();\n\n        //unpack model\n        final ImportWizardModel importWizardModel = this.model.getObject();\n\n        final List<ProcessedGradeItem> itemsToCreate = importWizardModel.getItemsToCreate();\n        final List<ProcessedGradeItem> itemsToUpdate = importWizardModel.getItemsToUpdate();\n        final List<Assignment> assignmentsToCreate = importWizardModel.getAssignmentsToCreate();\n\n        Form<?> form = new Form(\"form\")\n        {\n            @Override\n            protected void onSubmit()\n            {\n                boolean errors = false;\n                Map<String, Long> assignmentMap = new HashMap<>();\n                //Create new GB items\n                for (Assignment assignment : assignmentsToCreate) {\n                    Long assignmentId = businessService.addAssignment(assignment);\n                    assignmentMap.put(assignment.getName(), assignmentId);\n                }\n\n                List<ProcessedGradeItem> itemsToSave = new ArrayList<ProcessedGradeItem>();\n                itemsToSave.addAll(itemsToUpdate);\n                itemsToSave.addAll(itemsToCreate);\n                for (ProcessedGradeItem processedGradeItem : itemsToSave) {\n                    LOG.debug(\"Looping through items to save\");\n                    for (ProcessedGradeItemDetail processedGradeItemDetail : processedGradeItem.getProcessedGradeItemDetails()) {\n                        LOG.debug(\"Looping through detail items to save\");\n                        Long assignmentId = processedGradeItem.getItemId();\n                        if (assignmentId == null) {\n                            //Should be a newly created gn item\n                            assignmentId = assignmentMap.get(processedGradeItem.getItemTitle());\n                        }\n                        GradeSaveResponse saved = businessService.saveGrade(assignmentId, processedGradeItemDetail.getStudentUuid(),\n                                processedGradeItemDetail.getGrade(), processedGradeItemDetail.getComment());\n\n                        if (saved == GradeSaveResponse.NO_CHANGE) {\n                            //Check for changed comments\n                            String currentComment = businessService.getAssignmentGradeComment(assignmentId,\n                                    processedGradeItemDetail.getStudentUuid());\n\n                            currentComment = StringUtils.trimToNull(currentComment);\n                            String newComment = StringUtils.trimToNull(processedGradeItemDetail.getComment());\n                            if (!StringUtils.equals(currentComment, newComment)) {\n                                boolean success = businessService.updateAssignmentGradeComment(assignmentId,\n                                        processedGradeItemDetail.getStudentUuid(), newComment);\n                                LOG.info(\"Saving comment: \" + success + \", \" + assignmentId + \", \" + processedGradeItemDetail.getStudentEid() + \", \" +\n                                        processedGradeItemDetail.getComment());\n                                if (!success) {\n                                    errors = true;\n                                }\n                            }\n                        } else if (saved != GradeSaveResponse.OK) {\n                            //Anything other than OK is bad\n                            errors = true;\n                        }\n                        LOG.info(\"Saving grade: \" + saved + \", \" + assignmentId + \", \" + processedGradeItemDetail.getStudentEid() + \", \" +\n                                processedGradeItemDetail.getGrade() + \", \" + processedGradeItemDetail.getComment());\n                    }\n                }\n\n                if (!errors) {\n                    getSession().info(getString(\"importExport.confirmation.success\"));\n                    setResponsePage(new GradebookPage());\n                } else {\n                    getSession().error(getString(\"importExport.confirmation.failure\"));\n                }\n            }\n        };\n        add(form);\n\n        Button backButton = new Button(\"backbutton\") {\n            @Override\n            public void onSubmit() {\n                LOG.debug(\"Clicking back button...\");\n                Component newPanel = null;\n                if (assignmentsToCreate.size() > 0)\n                    newPanel = new CreateGradeItemStep(panelId, Model.of(importWizardModel));\n                else\n                    newPanel = new GradeItemImportSelectionStep(panelId, Model.of(importWizardModel));\n                newPanel.setOutputMarkupId(true);\n                GradeImportConfirmationStep.this.replaceWith(newPanel);\n\n\n            }\n        };\n        backButton.setDefaultFormProcessing(false);\n        form.add(backButton);\n\n        form.add(new Button(\"finishbutton\"));\n\n        final boolean hasItemsToUpdate = !itemsToUpdate.isEmpty();\n        WebMarkupContainer gradesUpdateContainer = new WebMarkupContainer (\"grades_update_container\") {\n            public boolean isVisible() { return hasItemsToUpdate; }\n        };\n        add(gradesUpdateContainer);\n\n        if (hasItemsToUpdate) {\n            ListView<ProcessedGradeItem> updateList = makeListView(\"grades_update\", itemsToUpdate);\n\n            updateList.setReuseItems(true);\n            gradesUpdateContainer.add(updateList);\n        }\n\n        final boolean hasItemsToCreate = !itemsToCreate.isEmpty();\n        WebMarkupContainer gradesCreateContainer = new WebMarkupContainer (\"grades_create_container\") {\n            public boolean isVisible() { return hasItemsToCreate; }\n        };\n        add(gradesCreateContainer);\n\n        if (hasItemsToCreate) {\n            ListView<ProcessedGradeItem> createList = makeListView(\"grades_create\", itemsToCreate);\n\n            createList.setReuseItems(true);\n            gradesCreateContainer.add(createList);\n        }\n    }","commit_id":"12a7cce64cb27b5a40920ee479c8d40688168e56","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Add a new assignment definition to the gradebook\n     * @param assignment\n     */\n    public void addAssignment(Assignment assignment) {\n        Gradebook gradebook = getGradebook();\n        if(gradebook != null) {\n            String gradebookId = gradebook.getUid();\n            this.gradebookService.addAssignment(gradebookId, assignment);\n            \n            //TODO wrap this so we can catch any runtime exceptions\n        }\n    }","id":29034,"modified_method":"/**\n     * Add a new assignment definition to the gradebook\n     * @param assignment\n\t * @return id of the newly created assignment\n     */\n    public Long addAssignment(Assignment assignment) {\n        Long id = null;\n\t\tGradebook gradebook = getGradebook();\n        if(gradebook != null) {\n            String gradebookId = gradebook.getUid();\n            id = this.gradebookService.addAssignment(gradebookId, assignment);\n            \n            //TODO wrap this so we can catch any runtime exceptions\n        }\n\t\treturn id;\n    }","commit_id":"12a7cce64cb27b5a40920ee479c8d40688168e56","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Add a new assignment definition to the gradebook\n     * @param assignment\n\t * @return id of the newly created assignment\n     */\n    public Long addAssignment(Assignment assignment) {\n        Long id = null;\n\t\tGradebook gradebook = getGradebook();\n        if(gradebook != null) {\n            String gradebookId = gradebook.getUid();\n            id = this.gradebookService.addAssignment(gradebookId, assignment);\n            \n            //TODO wrap this so we can catch any runtime exceptions\n        }\n\t\treturn id;\n    }","id":29035,"modified_method":"/**\n     * Add a new assignment definition to the gradebook\n     * @param assignment\n\t * @return id of the newly created assignment or null if there were any errors\n     */\n    public Long addAssignment(Assignment assignment) {\n\t\t\n    \tGradebook gradebook = getGradebook();\n        \n    \tif(gradebook != null) {\n            String gradebookId = gradebook.getUid();\n            return this.gradebookService.addAssignment(gradebookId, assignment);\n            \n            //TODO wrap this so we can catch any runtime exceptions\n        }\n\t\treturn null;\n    }","commit_id":"2065faaaecd6cb398c7557e3b31b358b3ca9bfdb","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void buildscript(Closure configureClosure) {\n        ((Project) getScriptTarget()).buildscript(configureClosure);\n    }","id":29036,"modified_method":"public void buildscript(Closure configureClosure) {\n        getScriptTarget().buildscript(configureClosure);\n    }","commit_id":"8cdfdeaff5a18d24389a4bbcce77f8421a28e837","url":"https://github.com/gradle/gradle"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public void apply(Map options) {\n        ((Project) getScriptTarget()).apply(options);\n    }","id":29037,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public void apply(Map options) {\n        getScriptTarget().apply(options);\n    }","commit_id":"8cdfdeaff5a18d24389a4bbcce77f8421a28e837","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(Closure closure) {\n        ((Project) getScriptTarget()).apply(closure);\n    }","id":29038,"modified_method":"public void apply(Closure closure) {\n        getScriptTarget().apply(closure);\n    }","commit_id":"8cdfdeaff5a18d24389a4bbcce77f8421a28e837","url":"https://github.com/gradle/gradle"},{"original_method":"public LoggingManager getLogging() {\n        return ((Project) getScriptTarget()).getLogging();\n    }","id":29039,"modified_method":"public LoggingManager getLogging() {\n        return getScriptTarget().getLogging();\n    }","commit_id":"8cdfdeaff5a18d24389a4bbcce77f8421a28e837","url":"https://github.com/gradle/gradle"},{"original_method":"public StandardOutputCapture getStandardOutputCapture() {\n        return ((ProjectInternal) getScriptTarget()).getStandardOutputCapture();\n    }","id":29040,"modified_method":"public StandardOutputCapture getStandardOutputCapture() {\n        return getScriptTarget().getStandardOutputCapture();\n    }","commit_id":"8cdfdeaff5a18d24389a4bbcce77f8421a28e837","url":"https://github.com/gradle/gradle"},{"original_method":"public Logger getLogger() {\n        return ((Project) getScriptTarget()).getLogger();\n    }","id":29041,"modified_method":"public Logger getLogger() {\n        return getScriptTarget().getLogger();\n    }","commit_id":"8cdfdeaff5a18d24389a4bbcce77f8421a28e837","url":"https://github.com/gradle/gradle"},{"original_method":"public ScriptHandler getBuildscript() {\n        return ((Project) getScriptTarget()).getBuildscript();\n    }","id":29042,"modified_method":"public ScriptHandler getBuildscript() {\n        return getScriptTarget().getBuildscript();\n    }","commit_id":"8cdfdeaff5a18d24389a4bbcce77f8421a28e837","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Initializes the accounts table.\n     */\n    private void tableInit() {\n        \n        accountsTable.setRowHeight(22);\n        accountsTable.setSelectionMode(\n                ListSelectionModel.SINGLE_INTERVAL_SELECTION);\n        \n        tableModel.addColumn(Messages.getString(\"protocol\"));\n        tableModel.addColumn(Messages.getString(\"account\"));\n                \n        Iterator i = mainFrame.getProtocolProviders();\n        \n        while(i.hasNext()) {\n            ProtocolProviderService pps \n                = (ProtocolProviderService)i.next();\n            \n            String pName = pps.getProtocolName();\n            JLabel protocolLabel = new JLabel();\n            protocolLabel.setText(pName);\n            protocolLabel.setIcon(\n                    new ImageIcon(Constants.getProtocolIcon(pName)));\n            \n            tableModel.addRow(new Object[]{protocolLabel,\n                    pps.getAccountID().getAccountUserID()});\n        }\n        \n        accountsTable.setShowHorizontalLines(false);\n        accountsTable.setShowVerticalLines(false);\n        accountsTable.setModel(tableModel);\n        \n        accountsTable.getColumnModel().getColumn(0)\n            .setCellRenderer(new LabelTableCellRenderer());\n        accountsTable.getColumnModel().getColumn(1)\n            .setCellRenderer(new LabelTableCellRenderer());\n        \n        this.tablePane.getViewport().add(accountsTable);\n    }","id":29043,"modified_method":"/**\n     * Initializes the accounts table.\n     */\n    private void tableInit() {\n        \n        accountsTable.setRowHeight(22);\n        accountsTable.setSelectionMode(\n                ListSelectionModel.SINGLE_SELECTION);\n        accountsTable.setSelectionModel(new DefaultListSelectionModel());    \n        accountsTable.setShowHorizontalLines(false);\n        accountsTable.setShowVerticalLines(false);\n        accountsTable.setModel(tableModel);\n        \n        tableModel.addColumn(\"id\");\n        tableModel.addColumn(Messages.getString(\"protocol\"));\n        tableModel.addColumn(Messages.getString(\"account\"));\n                \n        TableColumnModel columnModel = accountsTable.getColumnModel(); \n        columnModel.removeColumn(columnModel.getColumn(0));\n        columnModel.getColumn(0)\n            .setCellRenderer(new LabelTableCellRenderer());\n        columnModel.getColumn(1)\n            .setCellRenderer(new LabelTableCellRenderer());\n        \n        this.tablePane.getViewport().add(accountsTable);\n    }","commit_id":"26d26106a2f0c5631a8948647fb2f6436206d81b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the icon of this configuration form.\n     * @return the icon of this configuration form.\n     */\n    public Icon getIcon() {\n        return new ImageIcon(ImageLoader\n                .getImage(ImageLoader.QUICK_MENU_ADD_ICON));\n    }","id":29044,"modified_method":"/**\n     * Returns the icon of this configuration form.\n     * @return the icon of this configuration form.\n     */\n    public byte[] getIcon() {\n        return ImageLoader.getImageInBytes(\n                ImageLoader.QUICK_MENU_ADD_ICON);        \n    }","commit_id":"26d26106a2f0c5631a8948647fb2f6436206d81b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>AccountsConfigurationForm<\/tt>.\n     * \n     * @param mainFrame the main application window\n     */\n    public AccountsConfigurationForm(MainFrame mainFrame) {\n        super(new BorderLayout());\n    \n        this.mainFrame = mainFrame;\n        \n        this.tableInit();\n        \n        this.buttonsPanelInit();\n        \n        this.add(tablePane, BorderLayout.CENTER);\n        this.add(rightPanel, BorderLayout.EAST);\n    }","id":29045,"modified_method":"/**\n     * Creates an instance of <tt>AccountsConfigurationForm<\/tt>.\n     * \n     * @param mainFrame the main application window\n     */\n    public AccountsConfigurationForm(MainFrame mainFrame) {\n        super(new BorderLayout());\n    \n        this.mainFrame = mainFrame;\n        \n        GuiActivator.bundleContext.addServiceListener(this);\n        \n        this.tableInit();\n        \n        this.buttonsPanelInit();\n        \n        this.add(tablePane, BorderLayout.CENTER);\n        this.add(rightPanel, BorderLayout.EAST);\n    }","commit_id":"26d26106a2f0c5631a8948647fb2f6436206d81b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the form of this configuration form.\n     * @return the form of this configuration form.\n     */\n    public Component getForm() {\n        return this;\n    }","id":29046,"modified_method":"/**\n     * Returns the form of this configuration form.\n     * @return the form of this configuration form.\n     */\n    public Object getForm() {\n        return this;\n    }","commit_id":"26d26106a2f0c5631a8948647fb2f6436206d81b","url":"https://github.com/jitsi/jitsi"},{"original_method":"public Component getForm() {\n        return this;\n    }","id":29047,"modified_method":"public Object getForm() {\n        return this;\n    }","commit_id":"26d26106a2f0c5631a8948647fb2f6436206d81b","url":"https://github.com/jitsi/jitsi"},{"original_method":"public Icon getIcon() {\n        return new ImageIcon(ImageLoader\n                .getImage(ImageLoader.QUICK_MENU_SEARCH_ICON));\n    }","id":29048,"modified_method":"public byte[] getIcon() {\n        return ImageLoader.getImageInBytes(ImageLoader.QUICK_MENU_SEARCH_ICON);\n    }","commit_id":"26d26106a2f0c5631a8948647fb2f6436206d81b","url":"https://github.com/jitsi/jitsi"},{"original_method":"public Icon getIcon() {\n        return new ImageIcon(ImageLoader\n                .getImage(ImageLoader.QUICK_MENU_CONFIGURE_ICON));\n    }","id":29049,"modified_method":"public byte[] getIcon() {\n        return ImageLoader.getImageInBytes(\n                ImageLoader.QUICK_MENU_CONFIGURE_ICON);\n    }","commit_id":"26d26106a2f0c5631a8948647fb2f6436206d81b","url":"https://github.com/jitsi/jitsi"},{"original_method":"public Component getForm() {\n        return this;\n    }","id":29050,"modified_method":"public Object getForm() {\n        return this;\n    }","commit_id":"26d26106a2f0c5631a8948647fb2f6436206d81b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Called when this bundle is started.\n     *\n     * @param context The execution context of the bundle being started.\n     * @throws Exception If\n     */\n    public void start(BundleContext bundleContext) throws Exception {\n\n        GuiActivator.bundleContext = bundleContext;\n        \n        MainFrame mainFrame = communicatorMain.getMainFrame();\n        \n        this.loginManager = new LoginManager();\n        \n        this.loginManager.setMainFrame(mainFrame);\n\n        try {\n            ServiceReference clistReference = bundleContext\n                .getServiceReference(MetaContactListService.class.getName());\n\n            MetaContactListService contactListService \n                = (MetaContactListService) bundleContext\n                    .getService(clistReference);\n\n            mainFrame.setContactList(contactListService);\n            \n            logger.logEntry();\n\n            //Create the ui service\n            this.uiService = new UIServiceImpl(mainFrame);\n\n            logger.info(\"UI Service...[  STARTED ]\");\n\n            bundleContext.registerService(UIService.class.getName(),\n                    this.uiService, null);\n\n            logger.info(\"UI Service ...[REGISTERED]\");\n\n            /*\n             * TO BE UNCOMMENTED when the welcome window is removed.\n             * this.uiService.setVisible(true);\n             * SwingUtilities.invokeLater(new RunLogin()); \n             */\n\n            WelcomeWindow welcomeWindow = new WelcomeWindow(communicatorMain,\n                    loginManager, bundleContext);\n\n            welcomeWindow.showWindow();\n        } finally {\n            logger.logExit();\n        }\n    }","id":29051,"modified_method":"/**\n     * Called when this bundle is started.\n     *\n     * @param context The execution context of the bundle being started.\n     */\n    public void start(BundleContext bundleContext) throws Exception {\n\n        GuiActivator.bundleContext = bundleContext;\n        \n        MainFrame mainFrame = communicatorMain.getMainFrame();\n        \n        this.loginManager = new LoginManager(mainFrame);\n\n        try {\n            ServiceReference clistReference = bundleContext\n                .getServiceReference(MetaContactListService.class.getName());\n\n            MetaContactListService contactListService \n                = (MetaContactListService) bundleContext\n                    .getService(clistReference);\n\n            mainFrame.setContactList(contactListService);\n            \n            logger.logEntry();\n\n            //Create the ui service\n            this.uiService = new UIServiceImpl(mainFrame);\n\n            logger.info(\"UI Service...[  STARTED ]\");\n\n            bundleContext.registerService(UIService.class.getName(),\n                    this.uiService, null);\n\n            logger.info(\"UI Service ...[REGISTERED]\");\n\n            /*\n             * TO BE UNCOMMENTED when the welcome window is removed.\n             * this.uiService.setVisible(true);\n             * SwingUtilities.invokeLater(new RunLogin()); \n             */\n\n            WelcomeWindow welcomeWindow = new WelcomeWindow(communicatorMain,\n                    loginManager, bundleContext);\n\n            welcomeWindow.showWindow();\n        } finally {\n            logger.logExit();\n        }\n    }","commit_id":"26d26106a2f0c5631a8948647fb2f6436206d81b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>UIServiceImpl<\/tt>.\n     * @param mainFrame The main application window.\n     */\n    public UIServiceImpl(MainFrame mainFrame) {\n        this.mainFrame = mainFrame;\n        this.contactList = mainFrame.getTabbedPane().getContactListPanel();\n        \n        this.popupDialog = new PopupDialogImpl(mainFrame);\n        this.wizardContainer = new AccountRegWizardContainerImpl();\n        \n        this.exportedDialogs.put(UIService.DIALOG_CONFIGURATION, \n                new ConfigurationFrame(mainFrame));\n    }","id":29052,"modified_method":"/**\n     * Creates an instance of <tt>UIServiceImpl<\/tt>.\n     * @param mainFrame The main application window.\n     */\n    public UIServiceImpl(MainFrame mainFrame) {\n        this.mainFrame = mainFrame;\n        this.contactList = mainFrame.getTabbedPane().getContactListPanel();\n        \n        this.popupDialog = new PopupDialogImpl(mainFrame);\n        this.wizardContainer = new AccountRegWizardContainerImpl();\n        \n        this.configurationFrame = new ConfigurationDialogImpl(mainFrame); \n        this.exportedDialogs.put(UIService.DIALOG_CONFIGURATION, \n                configurationFrame);\n    }","commit_id":"26d26106a2f0c5631a8948647fb2f6436206d81b","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void performDefaultAction(final PipelineContext pipelineContext, XFormsEvent event) {\n        final String eventName = event.getEventName();\n        if (XFormsEvents.XFORMS_MODEL_CONSTRUCT.equals(eventName)) {\n            // 4.2.1 The xforms-model-construct Event\n            // Bubbles: Yes / Cancelable: No / Context Info: None\n\n            final Element modelElement = modelDocument.getRootElement();\n\n            // 1. All XML Schemas loaded (throws xforms-link-exception)\n\n            // TODO: support multiple schemas\n            // TODO: support inline schemas\n            // Get schema URI\n            loadSchemasIfNeeded(pipelineContext);\n            // TODO: throw exception event\n\n            // 2. Create XPath data model from instance (inline or external) (throws xforms-link-exception)\n            //    Instance may not be specified.\n\n//            if (instances == null) {\n            if (instances == null) {\n                instances = Arrays.asList(new XFormsInstance[instanceIds.size()]);\n                instancesMap = new HashMap(instanceIds.size());\n            }\n            {\n                // Build initial instance documents\n                final List instanceContainers = modelElement.elements(new QName(\"instance\", XFormsConstants.XFORMS_NAMESPACE));\n                final XFormsStaticState staticState = containingDocument.getStaticState();\n                final Map staticStateInstancesMap = staticState.isInitialized() ? staticState.getInstancesMap() : null;\n                if (instanceContainers.size() > 0) {\n                    // Iterate through all instances\n                    int instancePosition = 0;\n                    for (Iterator i = instanceContainers.iterator(); i.hasNext(); instancePosition++) {\n\n                        final Element instanceContainerElement = (Element) i.next();\n                        final boolean isReadonlyHint = \"true\".equals(instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_READONLY_ATTRIBUTE_QNAME));\n\n                        // Skip processing in case somebody has already set this particular instance\n                        if (instances.get(instancePosition) != null)\n                            continue;\n\n                        final String srcAttribute = instanceContainerElement.attributeValue(\"src\");\n                        final LocationData locationData = (LocationData) instanceContainerElement.getData();\n\n                        final String instanceId;\n                        {\n                            // NOTE: There has to be an id, except for the legacy engine\n                            final String idAttribute = instanceContainerElement.attributeValue(\"id\");\n                            instanceId = (idAttribute != null) ? idAttribute : \"\";\n                        }\n\n                        if (staticStateInstancesMap != null) {\n                            final XFormsInstance staticStateInstance = (XFormsInstance) staticStateInstancesMap.get(instanceId);\n                            if (staticStateInstance != null) {\n                                // The instance is already available in the static state, just use it\n\n                                if (XFormsServer.logger.isDebugEnabled())\n                                    XFormsServer.logger.debug(\"XForms - using instance from static state: \" + staticStateInstance.getEffectiveId());\n\n                                setInstance(staticStateInstance);\n                                continue;\n                            }\n                        }\n\n                        final Object instanceDocument;// Document or DocumentInfo\n                        final String instanceSourceURI;\n                        final String xxformsUsername;\n                        final String xxformsPassword;\n                        if (srcAttribute == null) {\n                            // Inline instance\n                            final List children = instanceContainerElement.elements();\n                            if (children == null || children.size() != 1) {\n                                final Throwable throwable = new ValidationException(\"xforms:instance element must contain exactly one child element\", locationData);\n                                containingDocument.dispatchEvent(pipelineContext, new XFormsLinkExceptionEvent(XFormsModel.this, null, instanceContainerElement, throwable));\n                                break;\n                            }\n                            if (!isReadonlyHint) {\n                                instanceDocument = Dom4jUtils.createDocumentCopyParentNamespaces((Element) children.get(0));\n                            } else {\n                                instanceDocument = TransformerUtils.dom4jToTinyTree(Dom4jUtils.createDocumentCopyParentNamespaces((Element) children.get(0)));\n                            }\n                            instanceSourceURI = null;\n                            xxformsUsername = null;\n                            xxformsPassword = null;\n                        } else if (!srcAttribute.trim().equals(\"\")) {\n\n                            // External instance\n                            final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n                            // NOTE: Optimizing with include() for servlets doesn't allow detecting errors caused by\n                            // the included resource, so we don't allow this for now. Furthermore, we are forced to\n                            // \"optimize\" for portlet access.\n\n//                            final boolean optimize = !NetUtils.urlHasProtocol(srcAttribute)\n//                               && (externalContext.getRequest().getContainerType().equals(\"portlet\")\n//                                    || (externalContext.getRequest().getContainerType().equals(\"servlet\")\n//                                        && XFormsUtils.isOptimizeLocalInstanceLoads()));\n\n                            final boolean optimizeForPortlets = !NetUtils.urlHasProtocol(srcAttribute)\n                                                        && externalContext.getRequest().getContainerType().equals(\"portlet\");\n\n                            final XFormsModelSubmission.ConnectionResult connectionResult;\n                            if (optimizeForPortlets) {\n                                // Use optimized local mode\n                                final URI resolvedURI = XFormsUtils.resolveXMLBase(instanceContainerElement, srcAttribute);\n                                connectionResult = XFormsSubmissionUtils.doOptimized(pipelineContext, externalContext, null, \"get\", resolvedURI.toString(), null, false, null, null);\n\n                                instanceSourceURI = resolvedURI.toString();\n                                xxformsUsername = null;\n                                xxformsPassword = null;\n\n                                try {\n                                    // Handle connection errors\n                                    if (connectionResult.resultCode != 200) {\n                                        final ValidationException validationException = new ValidationException(\"Got invalid return code while loading instance: \" + srcAttribute + \", \" + connectionResult.resultCode, locationData);\n                                        dispatchXFormsLinkExceptionEvent(pipelineContext, connectionResult, srcAttribute, validationException, instanceContainerElement, locationData);\n                                        break;\n                                    }\n\n                                    // Read result as XML\n                                    if (!isReadonlyHint) {\n                                        instanceDocument = TransformerUtils.readDom4j(connectionResult.getResultInputStream(), connectionResult.resourceURI);\n                                    } else {\n                                        instanceDocument = TransformerUtils.readTinyTree(connectionResult.getResultInputStream(), connectionResult.resourceURI);\n                                    }\n                                } catch (Exception e) {\n                                    final ValidationException validationException = new ValidationException(e, locationData);\n                                    dispatchXFormsLinkExceptionEvent(pipelineContext, connectionResult, srcAttribute, validationException, instanceContainerElement, locationData);\n                                    break;\n                                } finally {\n                                    // Clean-up\n                                    if (connectionResult != null)\n                                        connectionResult.close();\n                                }\n\n                            } else {\n                                // Connect using external protocol\n\n                                // Extension: username and password\n                                // NOTE: Those don't use AVTs for now, because XPath expressions in those could access\n                                // instances that haven't been loaded yet.\n                                xxformsUsername = instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_USERNAME_QNAME);\n                                xxformsPassword = instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_PASSWORD_QNAME);\n\n                                final String resolvedURL = XFormsUtils.resolveURL(containingDocument, pipelineContext, instanceContainerElement, false, srcAttribute);\n\n                                final long startTime = XFormsServer.logger.isDebugEnabled() ? System.currentTimeMillis() : 0;\n                                if (containingDocument.getURIResolver() == null) {\n                                    // We connect directly\n\n                                    connectionResult = XFormsSubmissionUtils.doRegular(externalContext,\n                                            \"get\", resolvedURL, xxformsUsername, xxformsPassword, null, null, null);\n\n                                    try {\n                                        // Handle connection errors\n                                        if (connectionResult.resultCode != 200) {\n                                            final ValidationException validationException = new ValidationException(\"Got invalid return code while loading instance: \" + srcAttribute + \", \" + connectionResult.resultCode, locationData);\n                                            dispatchXFormsLinkExceptionEvent(pipelineContext, connectionResult, srcAttribute, validationException, instanceContainerElement, locationData);\n                                            break;\n                                        }\n\n                                        // Read result as XML\n                                        if (!isReadonlyHint) {\n                                            instanceDocument = TransformerUtils.readDom4j(connectionResult.getResultInputStream(), connectionResult.resourceURI);\n                                        } else {\n                                            instanceDocument = TransformerUtils.readTinyTree(connectionResult.getResultInputStream(), connectionResult.resourceURI);\n                                        }\n                                    } catch (Exception e) {\n                                        dispatchXFormsLinkExceptionEvent(pipelineContext, connectionResult, srcAttribute, e, instanceContainerElement, locationData);\n                                        break;\n                                    } finally {\n                                        // Clean-up\n                                        if (connectionResult != null)\n                                            connectionResult.close();\n                                    }\n\n                                    instanceSourceURI = connectionResult.resourceURI;\n\n                                } else {\n                                    // Optimized case that uses the provided resolver\n                                    final String inputName = ProcessorImpl.getProcessorInputSchemeInputName(resolvedURL);\n                                    final String urlString;\n                                    if (inputName != null) {\n                                        // URL is input:*, keep it as is\n                                        urlString = resolvedURL;\n                                    } else {\n                                        // URL is regular URL, make sure it is absolute\n                                        final URL finalURL = XFormsSubmissionUtils.createAbsoluteURL(resolvedURL, null, externalContext);\n                                        urlString = finalURL.toExternalForm();\n                                    }\n\n                                    if (XFormsServer.logger.isDebugEnabled())\n                                        XFormsServer.logger.debug(\"XForms - getting document from resolver for: \" + urlString);\n\n                                    try {\n                                        if (!isReadonlyHint) {\n                                            instanceDocument = containingDocument.getURIResolver().readURLAsDocument(urlString, xxformsUsername, xxformsPassword);\n                                        } else {\n                                            instanceDocument = containingDocument.getURIResolver().readURLAsDocumentInfo(urlString, xxformsUsername, xxformsPassword);\n                                        }\n                                        instanceSourceURI = urlString;\n                                    } catch (Exception e) {\n                                        final ValidationException validationException = new ValidationException(e, new ExtendedLocationData(new LocationData(urlString, -1, -1),\n                                                \"reading external instance\", instanceContainerElement));\n                                        dispatchXFormsLinkExceptionEvent(pipelineContext, new XFormsModelSubmission.ConnectionResult(urlString), srcAttribute, validationException, instanceContainerElement, locationData);\n                                        break;\n                                    }\n\n                                    if (XFormsServer.logger.isDebugEnabled()) {\n                                        final long submissionTime = System.currentTimeMillis() - startTime;\n                                        XFormsServer.logger.debug(\"XForms - instance loading time (including handling returned body): \" + submissionTime);\n                                    }\n                                }\n                            }\n                        } else {\n                            // Got a blank src attribute, just dispatch xforms-link-exception\n                            final Throwable throwable = new ValidationException(\"Invalid blank URL specified for instance: \" + instanceId, locationData);\n                            containingDocument.dispatchEvent(pipelineContext, new XFormsLinkExceptionEvent(XFormsModel.this, srcAttribute, instanceContainerElement, throwable));\n                            break;\n                        }\n                        // Set instance and associated information if everything went well\n                        final XFormsInstance newInstance = setInstanceDocument(instanceDocument, modelId, instanceId, instanceSourceURI, xxformsUsername, xxformsPassword);\n\n                        // Update static state with instances when needed\n                        if (!staticState.isInitialized()) {\n                            final boolean modelHasReset = false;// TODO: containingDocument[0].hasReset(modelId) or xformsEngineStaticState.hasReset(modelId);\n                            if (newInstance instanceof SharedXFormsInstance) {\n                                if (XFormsServer.logger.isDebugEnabled())\n                                    XFormsServer.logger.debug(\"XForms - adding read-only instance to static state: \" + instanceId);\n                                staticState.addInstance((SharedXFormsInstance) newInstance);\n                            } else if (modelHasReset) {\n                                if (XFormsServer.logger.isDebugEnabled())\n                                    XFormsServer.logger.debug(\"XForms - adding reset instance to static state: \" + instanceId);\n                                staticState.addInstance(newInstance.createSharedInstance());\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Call special listener to update instance\n            if (instanceConstructListener != null) {\n                int position = 0;\n                for (Iterator i = getInstances().iterator(); i.hasNext(); position++) {\n                    instanceConstructListener.updateInstance(position, (XFormsInstance) i.next());\n                }\n            }\n\n            // 3. P3P (N/A)\n\n            // 4. Instance data is constructed. Evaluate binds:\n            //    a. Evaluate nodeset\n            //    b. Apply model item properties on nodes\n            //    c. Throws xforms-binding-exception if the node has already model item property with same name\n            // TODO: a, b, c xxx\n\n            // 5. xforms-rebuild, xforms-recalculate, xforms-revalidate\n            doRebuild(pipelineContext);\n            doRecalculate(pipelineContext);\n            doRevalidate(pipelineContext);\n\n            synchronizeInstanceDataEventState();\n\n        } else if (XFormsEvents.XFORMS_MODEL_CONSTRUCT_DONE.equals(eventName)) {\n            // 4.2.2 The xforms-model-construct-done Event\n            // Bubbles: Yes / Cancelable: No / Context Info: None\n\n            // TODO: implicit lazy instance construction\n\n        } else if (XFormsEvents.XFORMS_REBUILD.equals(eventName)) {\n            // 4.3.7 The xforms-rebuild Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRebuild(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_RECALCULATE.equals(eventName)) {\n            // 4.3.6 The xforms-recalculate Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRecalculate(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_REVALIDATE.equals(eventName)) {\n            // 4.3.5 The xforms-revalidate Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRevalidate(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_REFRESH.equals(eventName)) {\n            // 4.3.4 The xforms-refresh Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRefresh(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_RESET.equals(eventName)) {\n            // 4.3.8 The xforms-reset Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            // TODO\n            // \"The instance data is reset to the tree structure and values it had immediately\n            // after having processed the xforms-ready event.\"\n\n            // \"Then, the events xforms-rebuild, xforms-recalculate, xforms-revalidate and\n            // xforms-refresh are dispatched to the model element in sequence.\"\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(XFormsModel.this));\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(XFormsModel.this));\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(XFormsModel.this));\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(XFormsModel.this));\n\n        } else if (XFormsEvents.XFORMS_COMPUTE_EXCEPTION.equals(eventName) || XFormsEvents.XFORMS_LINK_EXCEPTION.equals(eventName)) {\n            // 4.5.4 The xforms-compute-exception Event\n            // Bubbles: Yes / Cancelable: No / Context Info: Implementation-specific error string.\n            // The default action for this event results in the following: Fatal error.\n\n            // 4.5.2 The xforms-link-exception Event\n            // Bubbles: Yes / Cancelable: No / Context Info: The URI that failed to load (xsd:anyURI)\n            // The default action for this event results in the following: Fatal error.\n\n            final XFormsExceptionEvent exceptionEvent = (XFormsExceptionEvent) event;\n            final Throwable throwable = exceptionEvent.getThrowable();\n            if (throwable instanceof RuntimeException)\n                throw (RuntimeException) throwable;\n            else\n                throw new ValidationException(\"Received fatal error event: \" + eventName, throwable, (LocationData) modelDocument.getRootElement().getData());\n        }\n    }","id":29053,"modified_method":"public void performDefaultAction(final PipelineContext pipelineContext, XFormsEvent event) {\n        final String eventName = event.getEventName();\n        if (XFormsEvents.XFORMS_MODEL_CONSTRUCT.equals(eventName)) {\n            // 4.2.1 The xforms-model-construct Event\n            // Bubbles: Yes / Cancelable: No / Context Info: None\n\n            final Element modelElement = modelDocument.getRootElement();\n\n            // 1. All XML Schemas loaded (throws xforms-link-exception)\n\n            // TODO: support multiple schemas\n            // TODO: support inline schemas\n            // Get schema URI\n            loadSchemasIfNeeded(pipelineContext);\n            // TODO: throw exception event\n\n            // 2. Create XPath data model from instance (inline or external) (throws xforms-link-exception)\n            //    Instance may not be specified.\n\n//            if (instances == null) {\n            if (instances == null) {\n                instances = Arrays.asList(new XFormsInstance[instanceIds.size()]);\n                instancesMap = new HashMap(instanceIds.size());\n            }\n            {\n                // Build initial instance documents\n                final List instanceContainers = modelElement.elements(new QName(\"instance\", XFormsConstants.XFORMS_NAMESPACE));\n                final XFormsStaticState staticState = containingDocument.getStaticState();\n                final Map staticStateInstancesMap = (staticState != null && staticState.isInitialized()) ? staticState.getInstancesMap() : null;\n                if (instanceContainers.size() > 0) {\n                    // Iterate through all instances\n                    int instancePosition = 0;\n                    for (Iterator i = instanceContainers.iterator(); i.hasNext(); instancePosition++) {\n\n                        final Element instanceContainerElement = (Element) i.next();\n                        final boolean isReadonlyHint = \"true\".equals(instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_READONLY_ATTRIBUTE_QNAME));\n\n                        // Skip processing in case somebody has already set this particular instance\n                        if (instances.get(instancePosition) != null)\n                            continue;\n\n                        final String srcAttribute = instanceContainerElement.attributeValue(\"src\");\n                        final LocationData locationData = (LocationData) instanceContainerElement.getData();\n\n                        final String instanceId;\n                        {\n                            // NOTE: There has to be an id, except for the legacy engine\n                            final String idAttribute = instanceContainerElement.attributeValue(\"id\");\n                            instanceId = (idAttribute != null) ? idAttribute : \"\";\n                        }\n\n                        if (staticStateInstancesMap != null) {\n                            final XFormsInstance staticStateInstance = (XFormsInstance) staticStateInstancesMap.get(instanceId);\n                            if (staticStateInstance != null) {\n                                // The instance is already available in the static state, just use it\n\n                                if (XFormsServer.logger.isDebugEnabled())\n                                    XFormsServer.logger.debug(\"XForms - using instance from static state: \" + staticStateInstance.getEffectiveId());\n\n                                setInstance(staticStateInstance);\n                                continue;\n                            }\n                        }\n\n                        final Object instanceDocument;// Document or DocumentInfo\n                        final String instanceSourceURI;\n                        final String xxformsUsername;\n                        final String xxformsPassword;\n                        if (srcAttribute == null) {\n                            // Inline instance\n                            final List children = instanceContainerElement.elements();\n                            if (children == null || children.size() != 1) {\n                                final Throwable throwable = new ValidationException(\"xforms:instance element must contain exactly one child element\", locationData);\n                                containingDocument.dispatchEvent(pipelineContext, new XFormsLinkExceptionEvent(XFormsModel.this, null, instanceContainerElement, throwable));\n                                break;\n                            }\n                            if (!isReadonlyHint) {\n                                instanceDocument = Dom4jUtils.createDocumentCopyParentNamespaces((Element) children.get(0));\n                            } else {\n                                instanceDocument = TransformerUtils.dom4jToTinyTree(Dom4jUtils.createDocumentCopyParentNamespaces((Element) children.get(0)));\n                            }\n                            instanceSourceURI = null;\n                            xxformsUsername = null;\n                            xxformsPassword = null;\n                        } else if (!srcAttribute.trim().equals(\"\")) {\n\n                            // External instance\n                            final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n                            // NOTE: Optimizing with include() for servlets doesn't allow detecting errors caused by\n                            // the included resource, so we don't allow this for now. Furthermore, we are forced to\n                            // \"optimize\" for portlet access.\n\n//                            final boolean optimize = !NetUtils.urlHasProtocol(srcAttribute)\n//                               && (externalContext.getRequest().getContainerType().equals(\"portlet\")\n//                                    || (externalContext.getRequest().getContainerType().equals(\"servlet\")\n//                                        && XFormsUtils.isOptimizeLocalInstanceLoads()));\n\n                            final boolean optimizeForPortlets = !NetUtils.urlHasProtocol(srcAttribute)\n                                                        && externalContext.getRequest().getContainerType().equals(\"portlet\");\n\n                            final XFormsModelSubmission.ConnectionResult connectionResult;\n                            if (optimizeForPortlets) {\n                                // Use optimized local mode\n                                final URI resolvedURI = XFormsUtils.resolveXMLBase(instanceContainerElement, srcAttribute);\n                                connectionResult = XFormsSubmissionUtils.doOptimized(pipelineContext, externalContext, null, \"get\", resolvedURI.toString(), null, false, null, null);\n\n                                instanceSourceURI = resolvedURI.toString();\n                                xxformsUsername = null;\n                                xxformsPassword = null;\n\n                                try {\n                                    // Handle connection errors\n                                    if (connectionResult.resultCode != 200) {\n                                        final ValidationException validationException = new ValidationException(\"Got invalid return code while loading instance: \" + srcAttribute + \", \" + connectionResult.resultCode, locationData);\n                                        dispatchXFormsLinkExceptionEvent(pipelineContext, connectionResult, srcAttribute, validationException, instanceContainerElement, locationData);\n                                        break;\n                                    }\n\n                                    // Read result as XML\n                                    if (!isReadonlyHint) {\n                                        instanceDocument = TransformerUtils.readDom4j(connectionResult.getResultInputStream(), connectionResult.resourceURI);\n                                    } else {\n                                        instanceDocument = TransformerUtils.readTinyTree(connectionResult.getResultInputStream(), connectionResult.resourceURI);\n                                    }\n                                } catch (Exception e) {\n                                    final ValidationException validationException = new ValidationException(e, locationData);\n                                    dispatchXFormsLinkExceptionEvent(pipelineContext, connectionResult, srcAttribute, validationException, instanceContainerElement, locationData);\n                                    break;\n                                } finally {\n                                    // Clean-up\n                                    if (connectionResult != null)\n                                        connectionResult.close();\n                                }\n\n                            } else {\n                                // Connect using external protocol\n\n                                // Extension: username and password\n                                // NOTE: Those don't use AVTs for now, because XPath expressions in those could access\n                                // instances that haven't been loaded yet.\n                                xxformsUsername = instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_USERNAME_QNAME);\n                                xxformsPassword = instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_PASSWORD_QNAME);\n\n                                final String resolvedURL = XFormsUtils.resolveURL(containingDocument, pipelineContext, instanceContainerElement, false, srcAttribute);\n\n                                final long startTime = XFormsServer.logger.isDebugEnabled() ? System.currentTimeMillis() : 0;\n                                if (containingDocument.getURIResolver() == null) {\n                                    // We connect directly\n\n                                    connectionResult = XFormsSubmissionUtils.doRegular(externalContext,\n                                            \"get\", resolvedURL, xxformsUsername, xxformsPassword, null, null, null);\n\n                                    try {\n                                        // Handle connection errors\n                                        if (connectionResult.resultCode != 200) {\n                                            final ValidationException validationException = new ValidationException(\"Got invalid return code while loading instance: \" + srcAttribute + \", \" + connectionResult.resultCode, locationData);\n                                            dispatchXFormsLinkExceptionEvent(pipelineContext, connectionResult, srcAttribute, validationException, instanceContainerElement, locationData);\n                                            break;\n                                        }\n\n                                        // Read result as XML\n                                        if (!isReadonlyHint) {\n                                            instanceDocument = TransformerUtils.readDom4j(connectionResult.getResultInputStream(), connectionResult.resourceURI);\n                                        } else {\n                                            instanceDocument = TransformerUtils.readTinyTree(connectionResult.getResultInputStream(), connectionResult.resourceURI);\n                                        }\n                                    } catch (Exception e) {\n                                        dispatchXFormsLinkExceptionEvent(pipelineContext, connectionResult, srcAttribute, e, instanceContainerElement, locationData);\n                                        break;\n                                    } finally {\n                                        // Clean-up\n                                        if (connectionResult != null)\n                                            connectionResult.close();\n                                    }\n\n                                    instanceSourceURI = connectionResult.resourceURI;\n\n                                } else {\n                                    // Optimized case that uses the provided resolver\n                                    final String inputName = ProcessorImpl.getProcessorInputSchemeInputName(resolvedURL);\n                                    final String urlString;\n                                    if (inputName != null) {\n                                        // URL is input:*, keep it as is\n                                        urlString = resolvedURL;\n                                    } else {\n                                        // URL is regular URL, make sure it is absolute\n                                        final URL finalURL = XFormsSubmissionUtils.createAbsoluteURL(resolvedURL, null, externalContext);\n                                        urlString = finalURL.toExternalForm();\n                                    }\n\n                                    if (XFormsServer.logger.isDebugEnabled())\n                                        XFormsServer.logger.debug(\"XForms - getting document from resolver for: \" + urlString);\n\n                                    try {\n                                        if (!isReadonlyHint) {\n                                            instanceDocument = containingDocument.getURIResolver().readURLAsDocument(urlString, xxformsUsername, xxformsPassword);\n                                        } else {\n                                            instanceDocument = containingDocument.getURIResolver().readURLAsDocumentInfo(urlString, xxformsUsername, xxformsPassword);\n                                        }\n                                        instanceSourceURI = urlString;\n                                    } catch (Exception e) {\n                                        final ValidationException validationException = new ValidationException(e, new ExtendedLocationData(new LocationData(urlString, -1, -1),\n                                                \"reading external instance\", instanceContainerElement));\n                                        dispatchXFormsLinkExceptionEvent(pipelineContext, new XFormsModelSubmission.ConnectionResult(urlString), srcAttribute, validationException, instanceContainerElement, locationData);\n                                        break;\n                                    }\n\n                                    if (XFormsServer.logger.isDebugEnabled()) {\n                                        final long submissionTime = System.currentTimeMillis() - startTime;\n                                        XFormsServer.logger.debug(\"XForms - instance loading time (including handling returned body): \" + submissionTime);\n                                    }\n                                }\n                            }\n                        } else {\n                            // Got a blank src attribute, just dispatch xforms-link-exception\n                            final Throwable throwable = new ValidationException(\"Invalid blank URL specified for instance: \" + instanceId, locationData);\n                            containingDocument.dispatchEvent(pipelineContext, new XFormsLinkExceptionEvent(XFormsModel.this, srcAttribute, instanceContainerElement, throwable));\n                            break;\n                        }\n                        // Set instance and associated information if everything went well\n                        final XFormsInstance newInstance = setInstanceDocument(instanceDocument, modelId, instanceId, instanceSourceURI, xxformsUsername, xxformsPassword);\n\n                        // Update static state with instances when needed\n                        if (staticState != null && !staticState.isInitialized()) {\n                            final boolean modelHasReset = false;// TODO: containingDocument[0].hasReset(modelId) or xformsEngineStaticState.hasReset(modelId);\n                            if (newInstance instanceof SharedXFormsInstance) {\n                                if (XFormsServer.logger.isDebugEnabled())\n                                    XFormsServer.logger.debug(\"XForms - adding read-only instance to static state: \" + instanceId);\n                                staticState.addInstance((SharedXFormsInstance) newInstance);\n                            } else if (modelHasReset) {\n                                if (XFormsServer.logger.isDebugEnabled())\n                                    XFormsServer.logger.debug(\"XForms - adding reset instance to static state: \" + instanceId);\n                                staticState.addInstance(newInstance.createSharedInstance());\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Call special listener to update instance\n            if (instanceConstructListener != null) {\n                int position = 0;\n                for (Iterator i = getInstances().iterator(); i.hasNext(); position++) {\n                    instanceConstructListener.updateInstance(position, (XFormsInstance) i.next());\n                }\n            }\n\n            // 3. P3P (N/A)\n\n            // 4. Instance data is constructed. Evaluate binds:\n            //    a. Evaluate nodeset\n            //    b. Apply model item properties on nodes\n            //    c. Throws xforms-binding-exception if the node has already model item property with same name\n            // TODO: a, b, c xxx\n\n            // 5. xforms-rebuild, xforms-recalculate, xforms-revalidate\n            doRebuild(pipelineContext);\n            doRecalculate(pipelineContext);\n            doRevalidate(pipelineContext);\n\n            synchronizeInstanceDataEventState();\n\n        } else if (XFormsEvents.XFORMS_MODEL_CONSTRUCT_DONE.equals(eventName)) {\n            // 4.2.2 The xforms-model-construct-done Event\n            // Bubbles: Yes / Cancelable: No / Context Info: None\n\n            // TODO: implicit lazy instance construction\n\n        } else if (XFormsEvents.XFORMS_REBUILD.equals(eventName)) {\n            // 4.3.7 The xforms-rebuild Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRebuild(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_RECALCULATE.equals(eventName)) {\n            // 4.3.6 The xforms-recalculate Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRecalculate(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_REVALIDATE.equals(eventName)) {\n            // 4.3.5 The xforms-revalidate Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRevalidate(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_REFRESH.equals(eventName)) {\n            // 4.3.4 The xforms-refresh Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRefresh(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_RESET.equals(eventName)) {\n            // 4.3.8 The xforms-reset Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            // TODO\n            // \"The instance data is reset to the tree structure and values it had immediately\n            // after having processed the xforms-ready event.\"\n\n            // \"Then, the events xforms-rebuild, xforms-recalculate, xforms-revalidate and\n            // xforms-refresh are dispatched to the model element in sequence.\"\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(XFormsModel.this));\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(XFormsModel.this));\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(XFormsModel.this));\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(XFormsModel.this));\n\n        } else if (XFormsEvents.XFORMS_COMPUTE_EXCEPTION.equals(eventName) || XFormsEvents.XFORMS_LINK_EXCEPTION.equals(eventName)) {\n            // 4.5.4 The xforms-compute-exception Event\n            // Bubbles: Yes / Cancelable: No / Context Info: Implementation-specific error string.\n            // The default action for this event results in the following: Fatal error.\n\n            // 4.5.2 The xforms-link-exception Event\n            // Bubbles: Yes / Cancelable: No / Context Info: The URI that failed to load (xsd:anyURI)\n            // The default action for this event results in the following: Fatal error.\n\n            final XFormsExceptionEvent exceptionEvent = (XFormsExceptionEvent) event;\n            final Throwable throwable = exceptionEvent.getThrowable();\n            if (throwable instanceof RuntimeException)\n                throw (RuntimeException) throwable;\n            else\n                throw new ValidationException(\"Received fatal error event: \" + eventName, throwable, (LocationData) modelDocument.getRootElement().getData());\n        }\n    }","commit_id":"d1ca8471e2f1d03d433660804de3a634f54765e4","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static int countInitializedTools(Profile foo) {\n    int i = 0;\n    List<ScopeToolState> tools = ((InspectionProfileImpl)foo).getAllTools();\n    for (ScopeToolState tool : tools) {\n      InspectionProfileEntry entry = tool.getTool();\n      assertTrue(entry instanceof InspectionToolWrapper);\n      if (entry.isInitialized()) i++;\n    }\n    return i;\n  }","id":29054,"modified_method":"public static int countInitializedTools(Profile foo) {\n    int i = 0;\n    List<ScopeToolState> tools = ((InspectionProfileImpl)foo).getAllTools();\n    for (ScopeToolState tool : tools) {\n      InspectionProfileEntry entry = tool.getTool();\n      assertTrue(entry instanceof InspectionToolWrapper);\n      if (entry.isInitialized() && ((InspectionToolWrapper)entry).hasXmlMapping()) {\n        i++;\n      }\n    }\n    return i;\n  }","commit_id":"89d0175cc4e4a375c3946fa64825b8d352bf85b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object get(String name) {\n        boolean isAlreadyConfiguring = _configuring.get();\n        _configuring.set(true);\n        try {\n            if (_delegate.hasProperty(name)) {\n                return _delegate.getProperty(name);\n            }\n\n            // try the owner\n            try {\n                return _owner.getProperty(name);\n            } catch (groovy.lang.MissingPropertyException e) {\n                // Ignore\n            }\n\n            if (!isAlreadyConfiguring) {\n                _configure(name, EMPTY_PARAMS);\n            }\n\n            // try the delegate again\n            return _delegate.getProperty(name);\n        } finally {\n            _configuring.set(isAlreadyConfiguring);\n        }\n    }","id":29055,"modified_method":"public Object get(String name) {\n        boolean isAlreadyConfiguring = _configuring.get();\n        _configuring.set(true);\n        try {\n            MissingPropertyException failure;\n            try {\n                return _delegate.getProperty(name);\n            } catch (MissingPropertyException e) {\n                failure = e;\n            }\n\n            // try the owner\n            try {\n                return _owner.getProperty(name);\n            } catch (MissingPropertyException e) {\n                // Ignore\n            }\n\n            if (isAlreadyConfiguring) {\n                throw failure;\n            }\n\n            return _configure(name, EMPTY_PARAMS);\n        } finally {\n            _configuring.set(isAlreadyConfiguring);\n        }\n    }","commit_id":"780476dc478402c8d160940462c27d2e27435c5c","url":"https://github.com/gradle/gradle"},{"original_method":"protected void _configure(String name, Object[] params) {\n        // do nothing\n    }","id":29056,"modified_method":"protected Object _configure(String name, Object[] params) {\n        // do nothing\n        return null;\n    }","commit_id":"780476dc478402c8d160940462c27d2e27435c5c","url":"https://github.com/gradle/gradle"},{"original_method":"protected boolean _isConfigureMethod(String name, Object[] params) {\n        return params.length == 1 && params[0] instanceof Closure;\n    }","id":29057,"modified_method":"protected boolean _isConfigureMethod(String name, Object[] params) {\n        return false;\n    }","commit_id":"780476dc478402c8d160940462c27d2e27435c5c","url":"https://github.com/gradle/gradle"},{"original_method":"public Object invokeMethod(String name, Object paramsObj) {\n        Object[] params = (Object[])paramsObj;\n\n        boolean isAlreadyConfiguring = _configuring.get();\n        _configuring.set(true);\n        try {\n            if (_delegate.hasMethod(name, params)) {\n                return _delegate.invokeMethod(name, params);\n            }\n\n            // try the owner\n            try {\n                return _owner.invokeMethod(name, params);\n            } catch (groovy.lang.MissingMethodException e) {\n                // ignore\n            }\n\n            if (!isAlreadyConfiguring && _isConfigureMethod(name, params)) {\n                _configure(name, params);\n            }\n\n            return _delegate.invokeMethod(name, params);\n        } finally {\n            _configuring.set(isAlreadyConfiguring);\n        }\n    }","id":29058,"modified_method":"public Object invokeMethod(String name, Object paramsObj) {\n        Object[] params = (Object[])paramsObj;\n\n        boolean isAlreadyConfiguring = _configuring.get();\n        _configuring.set(true);\n        try {\n            MissingMethodException failure;\n            try {\n                return _delegate.invokeMethod(name, params);\n            } catch (groovy.lang.MissingMethodException e) {\n                failure = e;\n            }\n\n            // try the owner\n            try {\n                return _owner.invokeMethod(name, params);\n            } catch (groovy.lang.MissingMethodException e) {\n                // ignore\n            }\n\n            if (isAlreadyConfiguring || !_isConfigureMethod(name, params)) {\n                throw failure;\n            }\n\n            return _configure(name, params);\n        } finally {\n            _configuring.set(isAlreadyConfiguring);\n        }\n    }","commit_id":"780476dc478402c8d160940462c27d2e27435c5c","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected void _configure(String name, Object[] params) {\n        _container.create(name);\n    }","id":29059,"modified_method":"@Override\n    protected Object _configure(String name, Object[] params) {\n        if (params.length == 0) {\n            return _container.create(name);\n        }\n        return _container.create(name, (Closure) params[0]);\n    }","commit_id":"780476dc478402c8d160940462c27d2e27435c5c","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    protected void _configure(String name, Object[] params) {\n        if (params.length > 0 && params[0] instanceof Class) {\n            _container.create(name, (Class) params[0]);\n        } else {\n            _container.create(name);\n        }\n    }","id":29060,"modified_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    protected Object _configure(String name, Object[] params) {\n        if (params.length == 0) {\n            return _container.create(name);\n        } else if (params.length == 1 && params[0] instanceof Closure) {\n            return _container.create(name, (Closure) params[0]);\n        } else if (params.length == 1 && params[0] instanceof Class) {\n            return _container.create(name, (Class) params[0]);\n        } else {\n            return _container.create(name, (Class) params[0], new ClosureBackedAction((Closure) params[1]));\n        }\n    }","commit_id":"780476dc478402c8d160940462c27d2e27435c5c","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected boolean _isConfigureMethod(String name, Object[] params) {\n        return super._isConfigureMethod(name, params)\n                || params.length == 1 && params[0] instanceof Class\n                || params.length == 2 && params[0] instanceof Class && params[1] instanceof Closure;\n    }","id":29061,"modified_method":"@Override\n    protected boolean _isConfigureMethod(String name, Object[] params) {\n        return params.length == 1 && params[0] instanceof Closure\n                || params.length == 1 && params[0] instanceof Class\n                || params.length == 2 && params[0] instanceof Class && params[1] instanceof Closure;\n    }","commit_id":"780476dc478402c8d160940462c27d2e27435c5c","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Create an EventHandlerProxy.\n     *\n     * @param context The handler context\n     * @param reference Reference to the EventHandler\n     */\n    public EventHandlerProxy(final EventHandlerTracker.HandlerContext context,\n                    final ServiceReference reference)\n    {\n        this.handlerContext = context;\n        this.reference = reference;\n    }","id":29062,"modified_method":"/**\n     * Create an EventHandlerProxy.\n     *\n     * @param context The handler context\n     * @param reference Reference to the EventHandler\n     */\n    public EventHandlerProxy(final EventHandlerTracker.HandlerContext context,\n                    final ServiceReference<EventHandler> reference)\n    {\n        this.handlerContext = context;\n        this.reference = reference;\n    }","commit_id":"6915158d2bab749fbb61cd9bddfa054769172ec8","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Get the event handler.\n     */\n    private synchronized EventHandler obtain() {\n        if (this.handler == null)\n        {\n            try\n            {\n                this.handler = (EventHandler)this.handlerContext.bundleContext.getService(this.reference);\n                if ( this.handler != null )\n                {\n                    this.checkTimeout(this.handler.getClass().getName());\n                }\n            }\n            catch (final IllegalStateException ignore)\n            {\n                // event handler might be stopped - ignore\n            }\n        }\n        return this.handler;\n    }","id":29063,"modified_method":"/**\n     * Get the event handler.\n     */\n    private synchronized EventHandler obtain() {\n        if (this.handler == null)\n        {\n            try\n            {\n                this.handler = this.handlerContext.bundleContext.getService(this.reference);\n                if ( this.handler != null )\n                {\n                    this.checkTimeout(this.handler.getClass().getName());\n                }\n            }\n            catch (final IllegalStateException ignore)\n            {\n                // event handler might be stopped - ignore\n            }\n        }\n        return this.handler;\n    }","commit_id":"6915158d2bab749fbb61cd9bddfa054769172ec8","url":"https://github.com/apache/felix"},{"original_method":"/**\n\t * @see org.osgi.util.tracker.ServiceTracker#removedService(org.osgi.framework.ServiceReference, java.lang.Object)\n\t */\n\t@Override\n    public void removedService(final ServiceReference reference, final EventHandlerProxy proxy) {\n        this.remove(proxy);\n        proxy.dispose();\n\t}","id":29064,"modified_method":"/**\n\t * @see org.osgi.util.tracker.ServiceTracker#removedService(org.osgi.framework.ServiceReference, java.lang.Object)\n\t */\n\t@Override\n    public void removedService(final ServiceReference<EventHandler> reference, final EventHandlerProxy proxy) {\n        this.remove(proxy);\n        proxy.dispose();\n\t}","commit_id":"6915158d2bab749fbb61cd9bddfa054769172ec8","url":"https://github.com/apache/felix"},{"original_method":"/**\n\t * Get all handlers for this event\n\t *\n\t * @param event The event topic\n\t * @return All handlers for the event\n\t */\n\tpublic Collection<EventHandlerProxy> getHandlers(final Event event) {\n\t    final String topic = event.getTopic();\n\n\t\tfinal Set<EventHandlerProxy> handlers = new HashSet<EventHandlerProxy>();\n\n\t\t// Add all handlers matching everything\n\t\tfor(final EventHandlerProxy p : this.matchingAllEvents)\n\t\t{\n\t\t    if ( p.canDeliver(event) )\n\t\t    {\n\t\t        handlers.add(p);\n\t\t    }\n\t\t}\n\n\t\t// Now check for prefix matches\n\t\tif ( !this.matchingPrefixTopic.isEmpty() )\n\t\t{\n\t\t    int pos = topic.lastIndexOf('/');\n\t\t\twhile (pos != -1)\n\t\t\t{\n\t\t\t    final String prefix = topic.substring(0, pos);\n\t\t\t\tList<EventHandlerProxy> proxies = this.matchingPrefixTopic.get(prefix);\n\t\t\t\tif (proxies != null)\n\t\t\t\t{\n\t\t\t        for(final EventHandlerProxy p : proxies)\n\t\t\t        {\n\t\t\t            if ( p.canDeliver(event) )\n\t\t\t            {\n\t\t\t                handlers.add(p);\n\t\t\t            }\n\t\t\t        }\n\t\t\t\t}\n\n\t\t\t\tpos = prefix.lastIndexOf('/');\n\t\t\t}\n\t\t}\n\n\t\t// Add the handlers for matching topic names\n\t\tList<EventHandlerProxy> proxies = this.matchingTopic.get(topic);\n\t\tif (proxies != null)\n\t\t{\n            for(final EventHandlerProxy p : proxies)\n            {\n                if ( p.canDeliver(event) )\n                {\n                    handlers.add(p);\n                }\n            }\n\t\t}\n\n\t\treturn handlers;\n\t}","id":29065,"modified_method":"/**\n\t * Get all handlers for this event\n\t *\n\t * @param event The event topic\n\t * @return All handlers for the event\n\t */\n\tpublic Collection<EventHandlerProxy> getHandlers(final Event event) {\n\t    final String topic = event.getTopic();\n\n\t\tfinal Set<EventHandlerProxy> handlers = new HashSet<EventHandlerProxy>();\n\n\t\t// Add all handlers matching everything\n        this.checkHandlerAndAdd(handlers, this.matchingAllEvents, event);\n\n\t\t// Now check for prefix matches\n\t\tif ( !this.matchingPrefixTopic.isEmpty() )\n\t\t{\n\t\t    int pos = topic.lastIndexOf('/');\n\t\t\twhile (pos != -1)\n\t\t\t{\n\t\t\t    final String prefix = topic.substring(0, pos);\n\t\t        this.checkHandlerAndAdd(handlers, this.matchingPrefixTopic.get(prefix), event);\n\n\t\t\t\tpos = prefix.lastIndexOf('/');\n\t\t\t}\n\t\t}\n\n\t\t// Add the handlers for matching topic names\n\t\tthis.checkHandlerAndAdd(handlers, this.matchingTopic.get(topic), event);\n\n\t\treturn handlers;\n\t}","commit_id":"6915158d2bab749fbb61cd9bddfa054769172ec8","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Check the topics of the event handler and remove it from the\n     * corresponding collections.\n     * We always create new collections - while this is \"expensive\"\n     * it allows us to read from them unsynced\n     */\n\tprivate synchronized void remove(final EventHandlerProxy proxy) {\n        final String[] topics = proxy.getTopics();\n        if ( topics == null )\n        {\n            final List<EventHandlerProxy> newMatchingAllEvents = new ArrayList<EventHandlerProxy>(this.matchingAllEvents);\n            newMatchingAllEvents.remove(proxy);\n            this.matchingAllEvents = newMatchingAllEvents;\n        } else {\n            Map<String, List<EventHandlerProxy>> newMatchingTopic = null;\n            Map<String, List<EventHandlerProxy>> newMatchingPrefixTopic = null;\n            for(int i = 0; i < topics.length; i++) {\n                final String topic = topics[i];\n\n                if ( topic.endsWith(\"/*\") )\n                {\n                    // prefix topic: we remove the /*\n                    if ( newMatchingPrefixTopic == null )\n                    {\n                        newMatchingPrefixTopic = new HashMap<String, List<EventHandlerProxy>>(this.matchingPrefixTopic);\n                    }\n\n                    final String prefix = topic.substring(0, topic.length() - 2);\n                    this.updateMap(newMatchingPrefixTopic, prefix, proxy, false);\n                }\n                else\n                {\n                    // exact match\n                    if ( newMatchingTopic == null )\n                    {\n                        newMatchingTopic = new HashMap<String, List<EventHandlerProxy>>(this.matchingTopic);\n                    }\n\n                    this.updateMap(newMatchingTopic, topic, proxy, false);\n                }\n            }\n            if ( newMatchingTopic != null )\n            {\n                this.matchingTopic = newMatchingTopic;\n            }\n            if ( newMatchingPrefixTopic != null )\n            {\n                this.matchingPrefixTopic = newMatchingPrefixTopic;\n            }\n        }\n\t}","id":29066,"modified_method":"/**\n     * Check the topics of the event handler and remove it from the\n     * corresponding collections.\n     */\n\tprivate synchronized void remove(final EventHandlerProxy proxy) {\n        final String[] topics = proxy.getTopics();\n        if ( topics == null )\n        {\n            this.matchingAllEvents.remove(proxy);\n        } else {\n            for(int i = 0; i < topics.length; i++) {\n                final String topic = topics[i];\n\n                if ( topic.endsWith(\"/*\") )\n                {\n                    // prefix topic: we remove the /*\n                    final String prefix = topic.substring(0, topic.length() - 2);\n                    this.updateMap(this.matchingPrefixTopic, prefix, proxy, false);\n                }\n                else\n                {\n                    // exact match\n                    this.updateMap(this.matchingTopic, topic, proxy, false);\n                }\n            }\n        }\n\t}","commit_id":"6915158d2bab749fbb61cd9bddfa054769172ec8","url":"https://github.com/apache/felix"},{"original_method":"public EventHandlerTracker(final BundleContext context) {\n\t\tsuper(context, EventHandler.class.getName(), null);\n\n\t\t// we start with empty collections\n\t\tthis.matchingAllEvents = new ArrayList<EventHandlerProxy>();\n\t\tthis.matchingTopic = new HashMap<String, List<EventHandlerProxy>>();\n\t\tthis.matchingPrefixTopic = new HashMap<String, List<EventHandlerProxy>>();\n\t}","id":29067,"modified_method":"public EventHandlerTracker(final BundleContext context) {\n\t\tsuper(context, EventHandler.class.getName(), null);\n\n\t\t// we start with empty collections\n\t\tthis.matchingAllEvents = new CopyOnWriteArrayList<EventHandlerProxy>();\n\t\tthis.matchingTopic = new ConcurrentHashMap<String, List<EventHandlerProxy>>();\n\t\tthis.matchingPrefixTopic = new ConcurrentHashMap<String, List<EventHandlerProxy>>();\n\t}","commit_id":"6915158d2bab749fbb61cd9bddfa054769172ec8","url":"https://github.com/apache/felix"},{"original_method":"/**\n\t * @see org.osgi.util.tracker.ServiceTracker#modifiedService(org.osgi.framework.ServiceReference, java.lang.Object)\n\t */\n\t@Override\n    public void modifiedService(final ServiceReference reference, final EventHandlerProxy proxy) {\n\t    this.remove(proxy);\n\t    if ( proxy.update() ) {\n            this.put(proxy);\n\t    }\n\t}","id":29068,"modified_method":"/**\n\t * @see org.osgi.util.tracker.ServiceTracker#modifiedService(org.osgi.framework.ServiceReference, java.lang.Object)\n\t */\n\t@Override\n    public void modifiedService(final ServiceReference<EventHandler> reference, final EventHandlerProxy proxy) {\n\t    this.remove(proxy);\n\t    if ( proxy.update() ) {\n            this.put(proxy);\n\t    }\n\t}","commit_id":"6915158d2bab749fbb61cd9bddfa054769172ec8","url":"https://github.com/apache/felix"},{"original_method":"private void updateMap(final Map<String, List<EventHandlerProxy>> proxyListMap, final String key, final EventHandlerProxy proxy, final boolean add) {\n        List<EventHandlerProxy> proxies = proxyListMap.get(key);\n        if (proxies == null) {\n            if ( !add )\n            {\n                return;\n            }\n            proxies = new ArrayList<EventHandlerProxy>();\n        } else {\n            proxies = new ArrayList<EventHandlerProxy>(proxies);\n        }\n        if ( add )\n        {\n            proxies.add(proxy);\n        }\n        else\n        {\n            proxies.remove(proxy);\n        }\n        if ( proxies.size() == 0 )\n        {\n            proxyListMap.remove(key);\n        }\n        else\n        {\n            proxyListMap.put(key, proxies);\n        }\n\t}","id":29069,"modified_method":"private void updateMap(final Map<String, List<EventHandlerProxy>> proxyListMap, final String key, final EventHandlerProxy proxy, final boolean add) {\n        List<EventHandlerProxy> proxies = proxyListMap.get(key);\n        if (proxies == null)\n        {\n            if ( !add )\n            {\n                return;\n            }\n            proxies = new CopyOnWriteArrayList<EventHandlerProxy>();\n            proxyListMap.put(key, proxies);\n        }\n\n        if ( add )\n        {\n            proxies.add(proxy);\n        }\n        else\n        {\n            proxies.remove(proxy);\n            if ( proxies.size() == 0 )\n            {\n                proxyListMap.remove(key);\n            }\n        }\n\t}","commit_id":"6915158d2bab749fbb61cd9bddfa054769172ec8","url":"https://github.com/apache/felix"},{"original_method":"/**\n\t * Check the topics of the event handler and put it into the\n\t * corresponding collections.\n\t * We always create new collections - while this is \"expensive\"\n\t * it allows us to read from them unsynced\n\t */\n\tprivate synchronized void put(final EventHandlerProxy proxy) {\n\t\tfinal String[] topics = proxy.getTopics();\n\t\tif ( topics == null )\n\t\t{\n\t\t    final List<EventHandlerProxy> newMatchingAllEvents = new ArrayList<EventHandlerProxy>(this.matchingAllEvents);\n\t\t    newMatchingAllEvents.add(proxy);\n\t\t    this.matchingAllEvents = newMatchingAllEvents;\n\t\t}\n\t\telse\n\t\t{\n\t\t    Map<String, List<EventHandlerProxy>> newMatchingTopic = null;\n\t\t    Map<String, List<EventHandlerProxy>> newMatchingPrefixTopic = null;\n    \t\tfor(int i = 0; i < topics.length; i++) {\n    \t\t\tfinal String topic = topics[i];\n\n    \t\t\tif ( topic.endsWith(\"/*\") )\n    \t\t\t{\n                    // prefix topic: we remove the /*\n    \t\t\t    if ( newMatchingPrefixTopic == null )\n    \t\t\t    {\n    \t\t\t        newMatchingPrefixTopic = new HashMap<String, List<EventHandlerProxy>>(this.matchingPrefixTopic);\n    \t\t\t    }\n\n    \t\t\t\tfinal String prefix = topic.substring(0, topic.length() - 2);\n                    this.updateMap(newMatchingPrefixTopic, prefix, proxy, true);\n    \t\t\t}\n    \t\t\telse\n    \t\t\t{\n    \t\t\t    // exact match\n                    if ( newMatchingTopic == null )\n                    {\n                        newMatchingTopic = new HashMap<String, List<EventHandlerProxy>>(this.matchingTopic);\n                    }\n\n                    this.updateMap(newMatchingTopic, topic, proxy, true);\n    \t\t\t}\n    \t\t}\n    \t\tif ( newMatchingTopic != null )\n    \t\t{\n    \t\t    this.matchingTopic = newMatchingTopic;\n    \t\t}\n    \t\tif ( newMatchingPrefixTopic != null )\n    \t\t{\n    \t\t    this.matchingPrefixTopic = newMatchingPrefixTopic;\n    \t\t}\n\t\t}\n\t}","id":29070,"modified_method":"/**\n\t * Check the topics of the event handler and put it into the\n\t * corresponding collections.\n\t */\n\tprivate synchronized void put(final EventHandlerProxy proxy) {\n\t\tfinal String[] topics = proxy.getTopics();\n\t\tif ( topics == null )\n\t\t{\n\t\t    this.matchingAllEvents.add(proxy);\n\t\t}\n\t\telse\n\t\t{\n    \t\tfor(int i = 0; i < topics.length; i++) {\n    \t\t\tfinal String topic = topics[i];\n\n    \t\t\tif ( topic.endsWith(\"/*\") )\n    \t\t\t{\n                    // prefix topic: we remove the /*\n    \t\t\t\tfinal String prefix = topic.substring(0, topic.length() - 2);\n                    this.updateMap(this.matchingPrefixTopic, prefix, proxy, true);\n    \t\t\t}\n    \t\t\telse\n    \t\t\t{\n    \t\t\t    // exact match\n                    this.updateMap(this.matchingTopic, topic, proxy, true);\n    \t\t\t}\n    \t\t}\n\t\t}\n\t}","commit_id":"6915158d2bab749fbb61cd9bddfa054769172ec8","url":"https://github.com/apache/felix"},{"original_method":"/**\n\t * @see org.osgi.util.tracker.ServiceTracker#addingService(org.osgi.framework.ServiceReference)\n\t */\n\t@Override\n    public EventHandlerProxy addingService(final ServiceReference reference) {\n\t\tfinal EventHandlerProxy proxy = new EventHandlerProxy(this.handlerContext, reference);\n\t\tif ( proxy.update() ) {\n\t\t\tthis.put(proxy);\n\t\t}\n\t\treturn proxy;\n\t}","id":29071,"modified_method":"/**\n\t * @see org.osgi.util.tracker.ServiceTracker#addingService(org.osgi.framework.ServiceReference)\n\t */\n\t@Override\n    public EventHandlerProxy addingService(final ServiceReference<EventHandler> reference) {\n\t\tfinal EventHandlerProxy proxy = new EventHandlerProxy(this.handlerContext, reference);\n\t\tif ( proxy.update() ) {\n\t\t\tthis.put(proxy);\n\t\t}\n\t\treturn proxy;\n\t}","commit_id":"6915158d2bab749fbb61cd9bddfa054769172ec8","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public boolean cleanupAccount(AccountVO account, long callerUserId, Account caller) {\n        long accountId = account.getId();\n        boolean accountCleanupNeeded = false;\n\n        try {\n            //cleanup the users from the account\n            List<UserVO> users = _userDao.listByAccount(accountId);\n            for (UserVO user : users) {\n                if (!_userDao.remove(user.getId())) {\n                    s_logger.error(\"Unable to delete user: \" + user + \" as a part of account \" + account + \" cleanup\");\n                    accountCleanupNeeded = true;\n                }\n            }\n\n            //delete the account from project accounts\n            _projectAccountDao.removeAccountFromProjects(accountId);\n\n            // delete all vm groups belonging to accont\n            List<InstanceGroupVO> groups = _vmGroupDao.listByAccountId(accountId);\n            for (InstanceGroupVO group : groups) {\n                if (!_vmMgr.deleteVmGroup(group.getId())) {\n                    s_logger.error(\"Unable to delete group: \" + group.getId());\n                    accountCleanupNeeded = true;\n                }\n            }\n\n            // Delete the snapshots dir for the account. Have to do this before destroying the VMs.\n            boolean success = _snapMgr.deleteSnapshotDirsForAccount(accountId);\n            if (success) {\n                s_logger.debug(\"Successfully deleted snapshots directories for all volumes under account \" + accountId + \" across all zones\");\n            }\n\n            // clean up templates\n            List<VMTemplateVO> userTemplates = _templateDao.listByAccountId(accountId);\n            boolean allTemplatesDeleted = true;\n            for (VMTemplateVO template : userTemplates) {\n                if (template.getRemoved() == null) {\n                    try {\n                        allTemplatesDeleted = _tmpltMgr.delete(callerUserId, template.getId(), null);\n                    } catch (Exception e) {\n                        s_logger.warn(\"Failed to delete template while removing account: \" + template.getName() + \" due to: \", e);\n                        allTemplatesDeleted = false;\n                    }\n                }\n            }\n\n            if (!allTemplatesDeleted) {\n                s_logger.warn(\"Failed to delete templates while removing account id=\" + accountId);\n                accountCleanupNeeded = true;\n            }\n\n            // Destroy the account's VMs\n            List<UserVmVO> vms = _userVmDao.listByAccountId(accountId);\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Expunging # of vms (accountId=\" + accountId + \"): \" + vms.size());\n            }\n\n            // no need to catch exception at this place as expunging vm should pass in order to perform further cleanup\n            for (UserVmVO vm : vms) {\n                if (!_vmMgr.expunge(vm, callerUserId, caller)) {\n                    s_logger.error(\"Unable to expunge vm: \" + vm.getId());\n                    accountCleanupNeeded = true;\n                }\n            }\n\n            // Mark the account's volumes as destroyed\n            List<VolumeVO> volumes = _volumeDao.findDetachedByAccount(accountId);\n            for (VolumeVO volume : volumes) {\n                if (!volume.getState().equals(Volume.State.Destroy)) {\n                    try {\n                        this.volumeMgr.deleteVolume(volume.getId(), caller);\n                    } catch (Exception ex) {\n                        s_logger.warn(\"Failed to cleanup volumes as a part of account id=\" + accountId + \" cleanup due to Exception: \", ex);\n                        accountCleanupNeeded = true;\n                    }\n                }\n            }\n\n            // delete remote access vpns and associated users\n            List<RemoteAccessVpnVO> remoteAccessVpns = _remoteAccessVpnDao.findByAccount(accountId);\n            List<VpnUserVO> vpnUsers = _vpnUser.listByAccount(accountId);\n\n            for (VpnUserVO vpnUser : vpnUsers) {\n                _remoteAccessVpnMgr.removeVpnUser(accountId, vpnUser.getUsername(), caller);\n            }\n\n            try {\n                for (RemoteAccessVpnVO vpn : remoteAccessVpns) {\n                    _remoteAccessVpnMgr.destroyRemoteAccessVpn(vpn.getServerAddressId(), caller);\n                }\n            } catch (ResourceUnavailableException ex) {\n                s_logger.warn(\"Failed to cleanup remote access vpn resources as a part of account id=\" + accountId + \" cleanup due to Exception: \", ex);\n                accountCleanupNeeded = true;\n            }\n\n            // Cleanup security groups\n            int numRemoved = _securityGroupDao.removeByAccountId(accountId);\n            s_logger.info(\"deleteAccount: Deleted \" + numRemoved + \" network groups for account \" + accountId);\n\n            // Delete all the networks\n            boolean networksDeleted = true;\n            s_logger.debug(\"Deleting networks for account \" + account.getId());\n            List<NetworkVO> networks = _networkDao.listByOwner(accountId);\n            if (networks != null) {\n                for (NetworkVO network : networks) {\n\n                    ReservationContext context = new ReservationContextImpl(null, null, getActiveUser(callerUserId), caller);\n\n                    if (!_networkMgr.destroyNetwork(network.getId(), context)) {\n                        s_logger.warn(\"Unable to destroy network \" + network + \" as a part of account id=\" + accountId + \" cleanup.\");\n                        accountCleanupNeeded = true;\n                        networksDeleted = false;\n                    } else {\n                        s_logger.debug(\"Network \" + network.getId() + \" successfully deleted as a part of account id=\" + accountId + \" cleanup.\");\n                    }\n                }\n            }\n\n            //Delete all VPCs\n            boolean vpcsDeleted = true;\n            s_logger.debug(\"Deleting vpcs for account \" + account.getId());\n            List<? extends Vpc> vpcs = _vpcMgr.getVpcsForAccount(account.getId());\n            for (Vpc vpc : vpcs) {\n\n                if (!_vpcMgr.destroyVpc(vpc, caller, callerUserId)) {\n                    s_logger.warn(\"Unable to destroy VPC \" + vpc + \" as a part of account id=\" + accountId + \" cleanup.\");\n                    accountCleanupNeeded = true;\n                    vpcsDeleted = false;\n                } else {\n                    s_logger.debug(\"VPC \" + vpc.getId() + \" successfully deleted as a part of account id=\" + accountId + \" cleanup.\");\n                }\n            }\n\n            if (vpcsDeleted) {\n                // release ip addresses belonging to the account\n                List<? extends IpAddress> ipsToRelease = _ipAddressDao.listByAccount(accountId);\n                for (IpAddress ip : ipsToRelease) {\n                    s_logger.debug(\"Releasing ip \" + ip + \" as a part of account id=\" + accountId + \" cleanup\");\n                    if (!_networkMgr.disassociatePublicIpAddress(ip.getId(), callerUserId, caller)) {\n                    s_logger.warn(\"Failed to release ip address \" + ip + \" as a part of account id=\" + accountId + \" clenaup\");\n                    accountCleanupNeeded = true;\n                    }\n                }\n            }\n\n            // Delete Site 2 Site VPN customer gateway\n            s_logger.debug(\"Deleting site-to-site VPN customer gateways for account \" + accountId);\n            if (!_vpnMgr.deleteCustomerGatewayByAccount(accountId)) {\n                s_logger.warn(\"Fail to delete site-to-site VPN customer gateways for account \" + accountId);\n            }\n\n            // Delete autoscale resources if any\n            try {\n                _autoscaleMgr.cleanUpAutoScaleResources(accountId);\n            } catch (CloudRuntimeException ex) {\n                s_logger.warn(\"Failed to cleanup AutoScale resources as a part of account id=\" + accountId + \" cleanup due to exception:\", ex);\n                accountCleanupNeeded = true;\n            }\n\n            // delete account specific Virtual vlans (belong to system Public Network) - only when networks are cleaned\n            // up successfully\n            if (networksDeleted) {\n                if (!_configMgr.deleteAccountSpecificVirtualRanges(accountId)) {\n                    accountCleanupNeeded = true;\n                } else {\n                    s_logger.debug(\"Account specific Virtual IP ranges \" + \" are successfully deleted as a part of account id=\" + accountId + \" cleanup.\");\n                }\n            }\n\n            return true;\n        } catch (Exception ex) {\n            s_logger.warn(\"Failed to cleanup account \" + account + \" due to \", ex);\n            accountCleanupNeeded = true;\n            return true;\n        } finally {\n            s_logger.info(\"Cleanup for account \" + account.getId() + (accountCleanupNeeded ? \" is needed.\" : \" is not needed.\"));\n            if (accountCleanupNeeded) {\n                _accountDao.markForCleanup(accountId);\n            } else {\n                account.setNeedsCleanup(false);\n                _accountDao.update(accountId, account);\n            }\n        }\n    }","id":29072,"modified_method":"@Override\n    public boolean cleanupAccount(AccountVO account, long callerUserId, Account caller) {\n        long accountId = account.getId();\n        boolean accountCleanupNeeded = false;\n\n        try {\n            //cleanup the users from the account\n            List<UserVO> users = _userDao.listByAccount(accountId);\n            for (UserVO user : users) {\n                if (!_userDao.remove(user.getId())) {\n                    s_logger.error(\"Unable to delete user: \" + user + \" as a part of account \" + account + \" cleanup\");\n                    accountCleanupNeeded = true;\n                }\n            }\n\n            //delete the account from project accounts\n            _projectAccountDao.removeAccountFromProjects(accountId);\n\n            // delete all vm groups belonging to accont\n            List<InstanceGroupVO> groups = _vmGroupDao.listByAccountId(accountId);\n            for (InstanceGroupVO group : groups) {\n                if (!_vmMgr.deleteVmGroup(group.getId())) {\n                    s_logger.error(\"Unable to delete group: \" + group.getId());\n                    accountCleanupNeeded = true;\n                }\n            }\n\n            // Delete the snapshots dir for the account. Have to do this before destroying the VMs.\n            boolean success = _snapMgr.deleteSnapshotDirsForAccount(accountId);\n            if (success) {\n                s_logger.debug(\"Successfully deleted snapshots directories for all volumes under account \" + accountId + \" across all zones\");\n            }\n\n            // clean up templates\n            List<VMTemplateVO> userTemplates = _templateDao.listByAccountId(accountId);\n            boolean allTemplatesDeleted = true;\n            for (VMTemplateVO template : userTemplates) {\n                if (template.getRemoved() == null) {\n                    try {\n                        allTemplatesDeleted = _tmpltMgr.delete(callerUserId, template.getId(), null);\n                    } catch (Exception e) {\n                        s_logger.warn(\"Failed to delete template while removing account: \" + template.getName() + \" due to: \", e);\n                        allTemplatesDeleted = false;\n                    }\n                }\n            }\n\n            if (!allTemplatesDeleted) {\n                s_logger.warn(\"Failed to delete templates while removing account id=\" + accountId);\n                accountCleanupNeeded = true;\n            }\n\n            // Destroy the account's VMs\n            List<UserVmVO> vms = _userVmDao.listByAccountId(accountId);\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Expunging # of vms (accountId=\" + accountId + \"): \" + vms.size());\n            }\n\n            // no need to catch exception at this place as expunging vm should pass in order to perform further cleanup\n            for (UserVmVO vm : vms) {\n                if (!_vmMgr.expunge(vm, callerUserId, caller)) {\n                    s_logger.error(\"Unable to expunge vm: \" + vm.getId());\n                    accountCleanupNeeded = true;\n                }\n            }\n\n            // Mark the account's volumes as destroyed\n            List<VolumeVO> volumes = _volumeDao.findDetachedByAccount(accountId);\n            for (VolumeVO volume : volumes) {\n                if (!volume.getState().equals(Volume.State.Destroy)) {\n                    try {\n                        this.volumeMgr.deleteVolume(volume.getId(), caller);\n                    } catch (Exception ex) {\n                        s_logger.warn(\"Failed to cleanup volumes as a part of account id=\" + accountId + \" cleanup due to Exception: \", ex);\n                        accountCleanupNeeded = true;\n                    }\n                }\n            }\n\n            // delete remote access vpns and associated users\n            List<RemoteAccessVpnVO> remoteAccessVpns = _remoteAccessVpnDao.findByAccount(accountId);\n            List<VpnUserVO> vpnUsers = _vpnUser.listByAccount(accountId);\n\n            for (VpnUserVO vpnUser : vpnUsers) {\n                _remoteAccessVpnMgr.removeVpnUser(accountId, vpnUser.getUsername(), caller);\n            }\n\n            try {\n                for (RemoteAccessVpnVO vpn : remoteAccessVpns) {\n                    _remoteAccessVpnMgr.destroyRemoteAccessVpn(vpn.getServerAddressId(), caller);\n                }\n            } catch (ResourceUnavailableException ex) {\n                s_logger.warn(\"Failed to cleanup remote access vpn resources as a part of account id=\" + accountId + \" cleanup due to Exception: \", ex);\n                accountCleanupNeeded = true;\n            }\n\n            // Cleanup security groups\n            int numRemoved = _securityGroupDao.removeByAccountId(accountId);\n            s_logger.info(\"deleteAccount: Deleted \" + numRemoved + \" network groups for account \" + accountId);\n\n            // Cleanup affinity groups\n            int numAGRemoved = _affinityGroupDao.removeByAccountId(accountId);\n            s_logger.info(\"deleteAccount: Deleted \" + numAGRemoved + \" affinity groups for account \" + accountId);\n\n            // Delete all the networks\n            boolean networksDeleted = true;\n            s_logger.debug(\"Deleting networks for account \" + account.getId());\n            List<NetworkVO> networks = _networkDao.listByOwner(accountId);\n            if (networks != null) {\n                for (NetworkVO network : networks) {\n\n                    ReservationContext context = new ReservationContextImpl(null, null, getActiveUser(callerUserId), caller);\n\n                    if (!_networkMgr.destroyNetwork(network.getId(), context)) {\n                        s_logger.warn(\"Unable to destroy network \" + network + \" as a part of account id=\" + accountId + \" cleanup.\");\n                        accountCleanupNeeded = true;\n                        networksDeleted = false;\n                    } else {\n                        s_logger.debug(\"Network \" + network.getId() + \" successfully deleted as a part of account id=\" + accountId + \" cleanup.\");\n                    }\n                }\n            }\n\n            //Delete all VPCs\n            boolean vpcsDeleted = true;\n            s_logger.debug(\"Deleting vpcs for account \" + account.getId());\n            List<? extends Vpc> vpcs = _vpcMgr.getVpcsForAccount(account.getId());\n            for (Vpc vpc : vpcs) {\n\n                if (!_vpcMgr.destroyVpc(vpc, caller, callerUserId)) {\n                    s_logger.warn(\"Unable to destroy VPC \" + vpc + \" as a part of account id=\" + accountId + \" cleanup.\");\n                    accountCleanupNeeded = true;\n                    vpcsDeleted = false;\n                } else {\n                    s_logger.debug(\"VPC \" + vpc.getId() + \" successfully deleted as a part of account id=\" + accountId + \" cleanup.\");\n                }\n            }\n\n            if (vpcsDeleted) {\n                // release ip addresses belonging to the account\n                List<? extends IpAddress> ipsToRelease = _ipAddressDao.listByAccount(accountId);\n                for (IpAddress ip : ipsToRelease) {\n                    s_logger.debug(\"Releasing ip \" + ip + \" as a part of account id=\" + accountId + \" cleanup\");\n                    if (!_networkMgr.disassociatePublicIpAddress(ip.getId(), callerUserId, caller)) {\n                    s_logger.warn(\"Failed to release ip address \" + ip + \" as a part of account id=\" + accountId + \" clenaup\");\n                    accountCleanupNeeded = true;\n                    }\n                }\n            }\n\n            // Delete Site 2 Site VPN customer gateway\n            s_logger.debug(\"Deleting site-to-site VPN customer gateways for account \" + accountId);\n            if (!_vpnMgr.deleteCustomerGatewayByAccount(accountId)) {\n                s_logger.warn(\"Fail to delete site-to-site VPN customer gateways for account \" + accountId);\n            }\n\n            // Delete autoscale resources if any\n            try {\n                _autoscaleMgr.cleanUpAutoScaleResources(accountId);\n            } catch (CloudRuntimeException ex) {\n                s_logger.warn(\"Failed to cleanup AutoScale resources as a part of account id=\" + accountId + \" cleanup due to exception:\", ex);\n                accountCleanupNeeded = true;\n            }\n\n            // delete account specific Virtual vlans (belong to system Public Network) - only when networks are cleaned\n            // up successfully\n            if (networksDeleted) {\n                if (!_configMgr.deleteAccountSpecificVirtualRanges(accountId)) {\n                    accountCleanupNeeded = true;\n                } else {\n                    s_logger.debug(\"Account specific Virtual IP ranges \" + \" are successfully deleted as a part of account id=\" + accountId + \" cleanup.\");\n                }\n            }\n\n            return true;\n        } catch (Exception ex) {\n            s_logger.warn(\"Failed to cleanup account \" + account + \" due to \", ex);\n            accountCleanupNeeded = true;\n            return true;\n        } finally {\n            s_logger.info(\"Cleanup for account \" + account.getId() + (accountCleanupNeeded ? \" is needed.\" : \" is not needed.\"));\n            if (accountCleanupNeeded) {\n                _accountDao.markForCleanup(accountId);\n            } else {\n                account.setNeedsCleanup(false);\n                _accountDao.update(accountId, account);\n            }\n        }\n    }","commit_id":"0b3850c14f9f3420d92bf6eb3477959b8f28e4ad","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\r\n    public boolean configure(final String name, final Map<String, Object> params) throws ConfigurationException {\r\n        _name = name;\r\n        return true;\r\n    }","id":29073,"modified_method":"@Override\r\n    public boolean configure(final String name, final Map<String, Object> params) throws ConfigurationException {\r\n        _name = name;\r\n        VirtualMachine.State.getStateMachine().registerListener(this);\r\n        return true;\r\n    }","commit_id":"0b3850c14f9f3420d92bf6eb3477959b8f28e4ad","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\r\n    public UserVm updateVMAffinityGroups(Long vmId, List<Long> affinityGroupIds) {\r\n        // Verify input parameters\r\n        UserVmVO vmInstance = _userVmDao.findById(vmId);\r\n        if (vmInstance == null) {\r\n            throw new InvalidParameterValueException(\"unable to find a virtual machine with id \" + vmId);\r\n        }\r\n\r\n        // Check that the VM is stopped\r\n        if (!vmInstance.getState().equals(State.Stopped)) {\r\n            s_logger.warn(\"Unable to update affinity groups of the virtual machine \" + vmInstance.toString()\r\n                    + \" in state \" + vmInstance.getState());\r\n            throw new InvalidParameterValueException(\"Unable update affinity groups of the virtual machine \"\r\n                    + vmInstance.toString() + \" \" + \"in state \" + vmInstance.getState()\r\n                    + \"; make sure the virtual machine is stopped and not in an error state before updating.\");\r\n        }\r\n\r\n        // check that the affinity groups exist\r\n        for (Long affinityGroupId : affinityGroupIds) {\r\n            AffinityGroupVO ag = _affinityGroupDao.findById(affinityGroupId);\r\n            if (ag == null) {\r\n                throw new InvalidParameterValueException(\"Unable to find affinity group by id \" + affinityGroupId);\r\n            }\r\n        }\r\n        if (affinityGroupIds != null && !affinityGroupIds.isEmpty()) {\r\n            _affinityGroupVMMapDao.updateMap(vmId, affinityGroupIds);\r\n        }\r\n        // APIResponseHelper will pull out the updated affinitygroups.\r\n        return vmInstance;\r\n\r\n    }","id":29074,"modified_method":"@Override\r\n    public UserVm updateVMAffinityGroups(Long vmId, List<Long> affinityGroupIds) {\r\n        // Verify input parameters\r\n        UserVmVO vmInstance = _userVmDao.findById(vmId);\r\n        if (vmInstance == null) {\r\n            throw new InvalidParameterValueException(\"unable to find a virtual machine with id \" + vmId);\r\n        }\r\n\r\n        // Check that the VM is stopped\r\n        if (!vmInstance.getState().equals(State.Stopped)) {\r\n            s_logger.warn(\"Unable to update affinity groups of the virtual machine \" + vmInstance.toString()\r\n                    + \" in state \" + vmInstance.getState());\r\n            throw new InvalidParameterValueException(\"Unable update affinity groups of the virtual machine \"\r\n                    + vmInstance.toString() + \" \" + \"in state \" + vmInstance.getState()\r\n                    + \"; make sure the virtual machine is stopped and not in an error state before updating.\");\r\n        }\r\n\r\n        // check that the affinity groups exist\r\n        for (Long affinityGroupId : affinityGroupIds) {\r\n            AffinityGroupVO ag = _affinityGroupDao.findById(affinityGroupId);\r\n            if (ag == null) {\r\n                throw new InvalidParameterValueException(\"Unable to find affinity group by id \" + affinityGroupId);\r\n            }\r\n        }\r\n        _affinityGroupVMMapDao.updateMap(vmId, affinityGroupIds);\r\n        // APIResponseHelper will pull out the updated affinitygroups.\r\n        return vmInstance;\r\n\r\n    }","commit_id":"0b3850c14f9f3420d92bf6eb3477959b8f28e4ad","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean isAuthenticated(HttpSession session) {\n        if (session == null) return false;\n        Object value = session.getAttribute(getAuthenticationKey());\n        return value != null && Boolean.TRUE.equals(value);\n    }","id":29075,"modified_method":"@Override\n    public boolean isAuthenticated(HttpSession session) {\n        if (session == null) return false;\n        Object value = session.getAttribute(getAuthenticationKey());\n        return Strings.isNonBlank(Strings.toString(value));\n    }","commit_id":"0793f3b4e46e28f2259aea84779efce452154431","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected boolean handleLogout(HttpServletRequest request) {\n        if (\"/logout\".equals(request.getRequestURI()) || \"/v1/logout\".equals(request.getRequestURI())) {\n            log.info(\"REST logging {} out of session {}\",\n                    request.getSession().getAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE), request.getSession().getId());\n            provider.logout(request.getSession());\n            request.getSession().removeAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE);\n            request.getSession().removeAttribute(REMOTE_ADDRESS_SESSION_ATTRIBUTE);\n            request.getSession().invalidate();\n            return true;\n        }\n        return false;\n    }","id":29076,"modified_method":"protected void logout(HttpServletRequest request) {\n        log.info(\"REST logging {} out of session {}\",\n                request.getSession().getAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE), request.getSession().getId());\n        provider.logout(request.getSession());\n        request.getSession().removeAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE);\n        request.getSession().removeAttribute(REMOTE_ADDRESS_SESSION_ATTRIBUTE);\n        request.getSession().invalidate();\n    }","commit_id":"0793f3b4e46e28f2259aea84779efce452154431","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n\n        if (provider == null) {\n            log.warn(\"No security provider available: disallowing web access to brooklyn\");\n            httpResponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n            return;\n        }\n\n        if (handleLogout(httpRequest) || !authenticate(httpRequest)) {\n            httpResponse.setHeader(\"WWW-Authenticate\", \"Basic realm=\\\"brooklyn\\\"\");\n            httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return;\n        }\n\n        String uri = httpRequest.getRequestURI();\n        String uid = RequestTaggingFilter.getTag();\n        String user = Strings.toString(httpRequest.getSession().getAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE));\n        try {\n            WebEntitlementContext entitlementContext = new WebEntitlementContext(user, httpRequest.getRemoteAddr(), uri, uid);\n            if (originalRequest.get() == null) {\n                // initial filter application\n                originalRequest.set(uri);\n            } else {\n                // this filter is being applied *again*, probably due to forwarding (e.g. from '/' to '/index.html')\n                // clear the entitlement context before setting to avoid warnings\n                Entitlements.clearEntitlementContext();\n            }\n            Entitlements.setEntitlementContext(entitlementContext);\n\n            chain.doFilter(request, response);\n\n        } catch (Throwable e) {\n            if (!response.isCommitted()) {\n                httpResponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            }\n        } finally {\n            originalRequest.remove();\n            Entitlements.clearEntitlementContext();\n        }\n\n    }","id":29077,"modified_method":"@Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n        String uri = httpRequest.getRequestURI();\n        String uid = RequestTaggingFilter.getTag();\n        String user = Strings.toString(httpRequest.getSession().getAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE));\n\n        if (provider == null) {\n            log.warn(\"No security provider available: disallowing web access to brooklyn\");\n            httpResponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n            return;\n        }\n\n        if (originalRequest.get() != null) {\n            // clear the entitlement context before setting to avoid warnings\n            Entitlements.clearEntitlementContext();\n        } else {\n            originalRequest.set(uri);\n        }\n\n        boolean authenticated = provider.isAuthenticated(httpRequest.getSession());\n        if (\"/logout\".equals(uri) || \"/v1/logout\".equals(uri)) {\n            httpResponse.setHeader(\"WWW-Authenticate\", \"Basic realm=\\\"brooklyn\\\"\");\n            if (authenticated && httpRequest.getSession().getAttributeNames().hasMoreElements()) {\n                logout(httpRequest);\n                httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            } else {\n                RequestDispatcher dispatcher = httpRequest.getRequestDispatcher(\"/\");\n                dispatcher.forward(httpRequest, httpResponse);\n            }\n            return;\n        }\n\n        if (!(httpRequest.getSession().getAttributeNames().hasMoreElements() && provider.isAuthenticated(httpRequest.getSession())) ||\n                \"/logout\".equals(originalRequest.get())) {\n            authenticated = authenticate(httpRequest);\n        }\n\n        if (!authenticated) {\n            httpResponse.setHeader(\"WWW-Authenticate\", \"Basic realm=\\\"brooklyn\\\"\");\n            httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return;\n        }\n\n        try {\n            WebEntitlementContext entitlementContext = new WebEntitlementContext(user, httpRequest.getRemoteAddr(), uri, uid);\n            Entitlements.setEntitlementContext(entitlementContext);\n\n            chain.doFilter(request, response);\n        } catch (Throwable e) {\n            if (!response.isCommitted()) {\n                httpResponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            }\n        } finally {\n            originalRequest.remove();\n            Entitlements.clearEntitlementContext();\n        }\n    }","commit_id":"0793f3b4e46e28f2259aea84779efce452154431","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public boolean logout(HttpSession session) { \n        return getDelegate().logout(session);\n    }","id":29078,"modified_method":"@Override\n    public boolean logout(HttpSession session) { \n        boolean logout = getDelegate().logout(session);\n        if (logout) {\n            session.removeAttribute(getModificationCountKey());\n        }\n        return logout;\n    }","commit_id":"0793f3b4e46e28f2259aea84779efce452154431","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public boolean isAuthenticated(HttpSession session) {\n        Object modCountWhenFirstAuthenticated = session.getAttribute(getModificationCountKey());\n        boolean authenticated = getDelegate().isAuthenticated(session) &&\n                modCountWhenFirstAuthenticated != null && ((Long) modCount.get()).equals(modCountWhenFirstAuthenticated);\n        if (authenticated) {\n            session.setAttribute(getModificationCountKey(), modCount.get());\n        }\n        return authenticated;\n    }","id":29079,"modified_method":"@Override\n    public boolean isAuthenticated(HttpSession session) {\n        if (session == null) return false;\n        Object modCountWhenFirstAuthenticated = session.getAttribute(getModificationCountKey());\n        boolean authenticated = getDelegate().isAuthenticated(session) &&\n                Long.valueOf(modCount.get()).equals(modCountWhenFirstAuthenticated);\n        return authenticated;\n    }","commit_id":"0793f3b4e46e28f2259aea84779efce452154431","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public boolean authenticate(HttpSession session, String user, String password) {\n        boolean authenticated = getDelegate().authenticate(session, user, password);\n        if (log.isTraceEnabled() && authenticated) {\n            log.trace(\"User {} authenticated with provider {}\", user, getDelegate());\n        } else if (!authenticated && log.isDebugEnabled()) {\n            log.debug(\"Failed authentication for user {} with provider {}\", user, getDelegate());\n        }\n        return authenticated;\n    }","id":29080,"modified_method":"@Override\n    public boolean authenticate(HttpSession session, String user, String password) {\n        boolean authenticated = getDelegate().authenticate(session, user, password);\n        if (authenticated) {\n            session.setAttribute(getModificationCountKey(), modCount.get());\n        }\n        if (log.isTraceEnabled() && authenticated) {\n            log.trace(\"User {} authenticated with provider {}\", user, getDelegate());\n        } else if (!authenticated && log.isDebugEnabled()) {\n            log.debug(\"Failed authentication for user {} with provider {}\", user, getDelegate());\n        }\n        return authenticated;\n    }","commit_id":"0793f3b4e46e28f2259aea84779efce452154431","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected void executeRender(Method method) throws Exception {\n\t\tboolean calledProcessAction = GetterUtil.getBoolean(\n\t\t\t(String)request.getAttribute(CALLED_PROCESS_ACTION));\n\n\t\tif (!calledProcessAction) {\n\t\t\tif (method != null) {\n\t\t\t\tmethod.invoke(this);\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNull(viewPath)) {\n\t\t\tviewPath = actionPath;\n\t\t}\n\n\t\tString includePath = buildIncludePath(viewPath);\n\n\t\tPortletRequestDispatcher portletRequestDispatcher =\n\t\t\tportletContext.getRequestDispatcher(includePath);\n\n\t\tif (portletRequestDispatcher == null) {\n\t\t\tlog.error(includePath + \" is not a valid include\");\n\t\t}\n\t\telse {\n\t\t\tportletRequestDispatcher.include(portletRequest, portletResponse);\n\t\t}\n\n\t\tBoolean touch = (Boolean)portletContext.getAttribute(\n\t\t\tTOUCH + portlet.getRootPortletId());\n\n\t\tif (touch != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString touchPath =\n\t\t\t\"/WEB-INF/jsp/\" + portlet.getFriendlyURLMapping() +\n\t\t\t\t\"/views/touch.jsp\";\n\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(\n\t\t\t\t\"Touch \" + portlet.getRootPortletId() + \" by including \" +\n\t\t\t\t\ttouchPath);\n\t\t}\n\n\t\tportletContext.setAttribute(\n\t\t\tTOUCH + portlet.getRootPortletId(), Boolean.FALSE);\n\n\t\tportletRequestDispatcher = portletContext.getRequestDispatcher(\n\t\t\ttouchPath);\n\n\t\tif (portletRequestDispatcher != null) {\n\t\t\tportletRequestDispatcher.include(portletRequest, portletResponse);\n\t\t}\n\t}","id":29081,"modified_method":"protected void executeRender(Method method) throws Exception {\n\t\tboolean calledProcessAction = GetterUtil.getBoolean(\n\t\t\t(String)request.getAttribute(CALLED_PROCESS_ACTION));\n\n\t\tif (!calledProcessAction) {\n\t\t\tif (method != null) {\n\t\t\t\tmethod.invoke(this);\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNull(viewPath)) {\n\t\t\tviewPath = actionPath;\n\t\t}\n\n\t\tif (Validator.isNotNull(format)) {\n\t\t\tif (format.equals(\"json\")) {\n\t\t\t\trenderResponse.setContentType(ContentTypes.APPLICATION_JSON);\n\t\t\t}\n\n\t\t\tHttpServletResponse response = PortalUtil.getHttpServletResponse(\n\t\t\t\trenderResponse);\n\n\t\t\tServletResponseUtil.write(response, _data);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString includePath = buildIncludePath(viewPath);\n\n\t\tPortletRequestDispatcher portletRequestDispatcher =\n\t\t\tportletContext.getRequestDispatcher(includePath);\n\n\t\tif (portletRequestDispatcher == null) {\n\t\t\tlog.error(includePath + \" is not a valid include\");\n\t\t}\n\t\telse {\n\t\t\tportletRequestDispatcher.include(portletRequest, portletResponse);\n\t\t}\n\n\t\tBoolean touch = (Boolean)portletContext.getAttribute(\n\t\t\tTOUCH + portlet.getRootPortletId());\n\n\t\tif (touch != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString touchPath =\n\t\t\t\"/WEB-INF/jsp/\" + portlet.getFriendlyURLMapping() +\n\t\t\t\t\"/views/touch.jsp\";\n\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(\n\t\t\t\t\"Touch \" + portlet.getRootPortletId() + \" by including \" +\n\t\t\t\t\ttouchPath);\n\t\t}\n\n\t\tportletContext.setAttribute(\n\t\t\tTOUCH + portlet.getRootPortletId(), Boolean.FALSE);\n\n\t\tportletRequestDispatcher = portletContext.getRequestDispatcher(\n\t\t\ttouchPath);\n\n\t\tif (portletRequestDispatcher != null) {\n\t\t\tportletRequestDispatcher.include(portletRequest, portletResponse);\n\t\t}\n\t}","commit_id":"a5b21fc9415ceefe03f2f74e7cf58853891d4d4d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void setJSONData(BaseModel baseModel) throws Exception {\n\t\trequest.setAttribute(\"data\", toJSONObject(baseModel));\n\t}","id":29082,"modified_method":"protected void setJSONData(BaseModel baseModel) throws Exception {\n\t\t_data = String.valueOf(toJSONObject(baseModel));\n\t}","commit_id":"a5b21fc9415ceefe03f2f74e7cf58853891d4d4d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String buildIncludePath(String viewPath) {\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(\"/WEB-INF/jsp/\");\n\t\tsb.append(portlet.getFriendlyURLMapping());\n\t\tsb.append(\"/views/\");\n\n\t\tif (Validator.isNotNull(format)) {\n\t\t\tsb.append(\"format.jsp\");\n\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tif (viewPath.equals(_VIEW_PATH_ERROR)) {\n\t\t\tsb.append(\"error.jsp\");\n\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tsb = new StringBundler(new String[] {sb.toString()}, 4);\n\n\t\tsb.append(controllerPath);\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(viewPath);\n\t\tsb.append(\".jsp\");\n\n\t\treturn sb.toString();\n\t}","id":29083,"modified_method":"protected String buildIncludePath(String viewPath) {\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(\"/WEB-INF/jsp/\");\n\t\tsb.append(portlet.getFriendlyURLMapping());\n\t\tsb.append(\"/views/\");\n\n\t\tif (viewPath.equals(_VIEW_PATH_ERROR)) {\n\t\t\tsb.append(\"error.jsp\");\n\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tsb = new StringBundler(new String[] {sb.toString()}, 4);\n\n\t\tsb.append(controllerPath);\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(viewPath);\n\t\tsb.append(\".jsp\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"a5b21fc9415ceefe03f2f74e7cf58853891d4d4d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void setJSONData(Document[] documents) throws Exception {\n\t\tJSONObject jsonData = JSONFactoryUtil.createJSONObject();\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (Document document : documents) {\n\t\t\tjsonArray.put(toJSONObject(document));\n\t\t}\n\n\t\tjsonData.put(controllerPath, jsonArray);\n\n\t\trequest.setAttribute(\"data\", jsonData);\n\t}","id":29084,"modified_method":"protected void setJSONData(Document[] documents) throws Exception {\n\t\tJSONObject jsonData = JSONFactoryUtil.createJSONObject();\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (Document document : documents) {\n\t\t\tjsonArray.put(toJSONObject(document));\n\t\t}\n\n\t\tjsonData.put(controllerPath, jsonArray);\n\n\t\t_data = jsonData.toString();\n\t}","commit_id":"a5b21fc9415ceefe03f2f74e7cf58853891d4d4d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void setJSONData(List<BaseModel<?>> baseModels) throws Exception {\n\t\tJSONObject jsonData = JSONFactoryUtil.createJSONObject();\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (BaseModel baseModel : baseModels) {\n\t\t\tjsonArray.put(toJSONObject(baseModel));\n\t\t}\n\n\t\tjsonData.put(controllerPath, jsonArray);\n\n\t\trequest.setAttribute(\"data\", jsonData);\n\t}","id":29085,"modified_method":"protected void setJSONData(List<BaseModel<?>> baseModels) throws Exception {\n\t\tJSONObject jsonData = JSONFactoryUtil.createJSONObject();\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (BaseModel baseModel : baseModels) {\n\t\t\tjsonArray.put(toJSONObject(baseModel));\n\t\t}\n\n\t\tjsonData.put(controllerPath, jsonArray);\n\n\t\t_data = jsonData.toString();\n\t}","commit_id":"a5b21fc9415ceefe03f2f74e7cf58853891d4d4d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void setJSONData(Document document) throws Exception {\n\t\trequest.setAttribute(\"data\", toJSONObject(document));\n\t}","id":29086,"modified_method":"protected void setJSONData(Document document) throws Exception {\n\t\t_data = String.valueOf(toJSONObject(document));\n\t}","commit_id":"a5b21fc9415ceefe03f2f74e7cf58853891d4d4d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n    public void appendFrame(ByteBuffer payload, boolean isLast) throws IOException\n    {\n        // No decoders for Partial messages per JSR-356 (PFD1 spec)\n\n        // Supported Partial<> Type #1: ByteBuffer\n        if (msgWrapper.isMessageType(ByteBuffer.class))\n        {\n            partialHandler.onMessage(payload.slice(),isLast);\n            return;\n        }\n\n        // Supported Partial<> Type #2: byte[]\n        if (msgWrapper.isMessageType(byte[].class))\n        {\n            partialHandler.onMessage(BufferUtil.toArray(payload),isLast);\n            return;\n        }\n\n        StringBuilder err = new StringBuilder();\n        err.append(msgWrapper.getHandler().getClass());\n        err.append(\" does not implement an expected \");\n        err.append(MessageHandler.Partial.class.getName());\n        err.append(\" of type \");\n        err.append(ByteBuffer.class.getName());\n        err.append(\" or byte[]\");\n        throw new IllegalStateException(err.toString());\n    }","id":29087,"modified_method":"@Override\n    public void appendFrame(ByteBuffer payload, boolean isLast) throws IOException\n    {\n        // No decoders for Partial messages per JSR-356 (PFD1 spec)\n\n        // Supported Partial<> Type #1: ByteBuffer\n        if (msgWrapper.isMessageType(ByteBuffer.class))\n        {\n            partialHandler.onMessage(payload==null?ByteBuffer.allocate(0):\n                payload.slice(),isLast);\n            return;\n        }\n\n        // Supported Partial<> Type #2: byte[]\n        if (msgWrapper.isMessageType(byte[].class))\n        {\n            partialHandler.onMessage(payload==null?new byte[0]:\n                BufferUtil.toArray(payload),isLast);\n            return;\n        }\n\n        StringBuilder err = new StringBuilder();\n        err.append(msgWrapper.getHandler().getClass());\n        err.append(\" does not implement an expected \");\n        err.append(MessageHandler.Partial.class.getName());\n        err.append(\" of type \");\n        err.append(ByteBuffer.class.getName());\n        err.append(\" or byte[]\");\n        throw new IllegalStateException(err.toString());\n    }","commit_id":"3630f623d89254c0777bf7174481645c8521b951","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void appendFrame(ByteBuffer payload, boolean isLast) throws IOException\n    {\n        // No decoders for Partial messages per JSR-356 (PFD1 spec)\n\n        // Supported Partial<> Type #1: ByteBuffer\n        if (msgWrapper.isMessageType(ByteBuffer.class))\n        {\n            partialHandler.onMessage(payload.slice(),isLast);\n            return;\n        }\n\n        // Supported Partial<> Type #2: byte[]\n        if (msgWrapper.isMessageType(byte[].class))\n        {\n            partialHandler.onMessage(BufferUtil.toArray(payload),isLast);\n            return;\n        }\n\n        StringBuilder err = new StringBuilder();\n        err.append(msgWrapper.getHandler().getClass());\n        err.append(\" does not implement an expected \");\n        err.append(MessageHandler.Partial.class.getName());\n        err.append(\" of type \");\n        err.append(ByteBuffer.class.getName());\n        err.append(\" or byte[]\");\n        throw new IllegalStateException(err.toString());\n    }","id":29088,"modified_method":"@Override\n    public void appendFrame(ByteBuffer payload, boolean isLast) throws IOException\n    {\n        // No decoders for Partial messages per JSR-356 (PFD1 spec)\n\n        // Supported Partial<> Type #1: ByteBuffer\n        if (msgWrapper.isMessageType(ByteBuffer.class))\n        {\n            partialHandler.onMessage(payload==null?ByteBuffer.allocate(0):\n                payload.slice(),isLast);\n            return;\n        }\n\n        // Supported Partial<> Type #2: byte[]\n        if (msgWrapper.isMessageType(byte[].class))\n        {\n            partialHandler.onMessage(payload==null?new byte[0]:\n                BufferUtil.toArray(payload),isLast);\n            return;\n        }\n\n        StringBuilder err = new StringBuilder();\n        err.append(msgWrapper.getHandler().getClass());\n        err.append(\" does not implement an expected \");\n        err.append(MessageHandler.Partial.class.getName());\n        err.append(\" of type \");\n        err.append(ByteBuffer.class.getName());\n        err.append(\" or byte[]\");\n        throw new IllegalStateException(err.toString());\n    }","commit_id":"beccc5ee8020e2fa361923b055071e01f271f0d1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public synchronized void createSegment(\n            UUID segmentId, byte[] data, int offset, int length,\n            Collection<UUID> referencedSegmentIds,\n            Map<String, RecordId> strings, Map<Template, RecordId> templates) {\n        int size = 8 + 4 + 4 + 16 + 16 * referencedSegmentIds.size() + length;\n\n        prepare(size);\n\n        rw.put(createTarHeader(segmentId.toString(), size));\n\n        rw.putLong(SEGMENT_MAGIC);\n        rw.putInt(length);\n        rw.putInt(referencedSegmentIds.size());\n        rw.putLong(segmentId.getMostSignificantBits());\n        rw.putLong(segmentId.getLeastSignificantBits());\n        for (UUID referencedSegmentId : referencedSegmentIds) {\n            rw.putLong(referencedSegmentId.getMostSignificantBits());\n            rw.putLong(referencedSegmentId.getLeastSignificantBits());\n        }\n\n        ro.position(rw.position());\n        rw.put(data, offset, length);\n        ro.limit(rw.position());\n        ByteBuffer buffer = ro.slice();\n        ro.limit(rw.limit());\n\n        int n = rw.position() % SEGMENT_SIZE;\n        if (n > 0) {\n            rw.put(PADDING_BYTES, 0, SEGMENT_SIZE - n);\n        }\n\n        Segment segment = new Segment(\n                this, segmentId, buffer,\n                referencedSegmentIds, strings, templates);\n        checkState(segments.put(segmentId, segment) == null);\n    }","id":29089,"modified_method":"@Override\n    public synchronized void createSegment(\n            UUID segmentId, byte[] data, int offset, int length,\n            Collection<UUID> referencedSegmentIds,\n            Map<String, RecordId> strings, Map<Template, RecordId> templates) {\n        int size = 8 + 4 + 4 + 16 + 16 * referencedSegmentIds.size() + length;\n\n        MappedByteBuffer rw = prepare(size);\n\n        rw.put(createTarHeader(segmentId.toString(), size));\n        rw.putLong(SEGMENT_MAGIC);\n        int position = rw.position();\n\n        rw.putInt(length);\n        rw.putInt(referencedSegmentIds.size());\n        rw.putLong(segmentId.getMostSignificantBits());\n        rw.putLong(segmentId.getLeastSignificantBits());\n        for (UUID referencedSegmentId : referencedSegmentIds) {\n            rw.putLong(referencedSegmentId.getMostSignificantBits());\n            rw.putLong(referencedSegmentId.getLeastSignificantBits());\n        }\n\n        ByteBuffer ro = rw.asReadOnlyBuffer();\n        ro.limit(ro.position() + length);\n        ro = ro.slice();\n\n        rw.put(data, offset, length);\n\n        int n = rw.position() % SEGMENT_SIZE;\n        if (n > 0) {\n            rw.put(PADDING_BYTES, 0, SEGMENT_SIZE - n);\n        }\n\n        SegmentReference previous = references.put(\n                segmentId, new SegmentReference(segmentId, rw, position));\n        checkState(previous == null);\n\n        segments.put(segmentId, new Segment(\n                this, segmentId, ro, referencedSegmentIds, strings, templates));\n    }","commit_id":"e7669bfba7395a67df5be327a1b4d65ac19a43b0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Segment readSegment(UUID id) {\n        Segment segment = segments.get(id);\n        if (segment != null) {\n            return segment;\n        } else {\n            throw new IllegalArgumentException(\"Segment not found: \" + id);\n        }\n    }","id":29090,"modified_method":"@Override\n    public synchronized Segment readSegment(final UUID id) {\n        try {\n            return segments.get(id, new Callable<Segment>() {\n                @Override\n                public Segment call() throws Exception {\n                    SegmentReference reference = references.get(id);\n                    checkState(reference != null);\n                    return reference.getSegment();\n                }\n            });\n        } catch (ExecutionException e) {\n            throw new RuntimeException(\"Failed to load segment \" + id, e);\n        }\n    }","commit_id":"e7669bfba7395a67df5be327a1b4d65ac19a43b0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"synchronized void writeJournals() {\n        int size = 8 + 4;\n        for (String name : journals.keySet()) {\n            size += 4 + name.getBytes(UTF_8).length + 16 + 4;\n        }\n\n        prepare(size);\n\n        rw.put(createTarHeader(JOURNALS_UUID, size));\n\n        rw.putLong(JOURNAL_MAGIC);\n        rw.putInt(journals.size());\n        for (Map.Entry<String, Journal> entry : journals.entrySet()) {\n            byte[] name = entry.getKey().getBytes(UTF_8);\n            rw.putInt(name.length);\n            rw.put(name);\n            RecordId head = entry.getValue().getHead();\n            rw.putLong(head.getSegmentId().getMostSignificantBits());\n            rw.putLong(head.getSegmentId().getLeastSignificantBits());\n            rw.putInt(head.getOffset());\n        }\n\n        int n = rw.position() % SEGMENT_SIZE;\n        if (n > 0) {\n            rw.put(PADDING_BYTES, 0, SEGMENT_SIZE - n);\n        }\n    }","id":29091,"modified_method":"synchronized void writeJournals() {\n        int size = 8 + 4;\n        for (String name : journals.keySet()) {\n            size += 4 + name.getBytes(UTF_8).length + 16 + 4;\n        }\n\n        MappedByteBuffer rw = prepare(size);\n\n        rw.put(createTarHeader(JOURNALS_UUID, size));\n\n        rw.putLong(JOURNAL_MAGIC);\n        rw.putInt(journals.size());\n        for (Map.Entry<String, Journal> entry : journals.entrySet()) {\n            byte[] name = entry.getKey().getBytes(UTF_8);\n            rw.putInt(name.length);\n            rw.put(name);\n            RecordId head = entry.getValue().getHead();\n            rw.putLong(head.getSegmentId().getMostSignificantBits());\n            rw.putLong(head.getSegmentId().getLeastSignificantBits());\n            rw.putInt(head.getOffset());\n        }\n\n        int n = rw.position() % SEGMENT_SIZE;\n        if (n > 0) {\n            rw.put(PADDING_BYTES, 0, SEGMENT_SIZE - n);\n        }\n    }","commit_id":"e7669bfba7395a67df5be327a1b4d65ac19a43b0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void close() {\n        rw.force();\n\n        segments.clear();\n        rw = null;\n        ro = null;\n\n        System.gc();\n    }","id":29092,"modified_method":"public synchronized void close() {\n        if (!files.isEmpty()) {\n            files.getLast().force();\n        }\n        files.clear();\n        references.clear();\n        segments.invalidateAll();\n        segments.cleanUp();\n        System.gc();\n    }","commit_id":"e7669bfba7395a67df5be327a1b4d65ac19a43b0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public FileStore(File directory, NodeState root) throws IOException {\n        // http://www.oracle.com/technetwork/java/hotspotfaq-138619.html#64bit_detection\n        if (\"32\".equals(System.getProperty(\"sun.arch.data.model\"))) {\n            log.warn(\"TarMK will only work with small repositories\"\n                    + \" in a 32 bit JVM. Consider switching to a 64 bit JVM.\");\n        }\n\n        checkNotNull(directory).mkdirs();\n        this.directory = directory;\n        this.index = 0;\n        while (loadSegments()) {\n            this.index++;\n        }\n\n        if (!journals.containsKey(\"root\")) {\n            NodeBuilder builder = EMPTY_NODE.builder();\n            builder.setChildNode(\"root\", root);\n            journals.put(\"root\", new FileJournal(this, builder.getNodeState()));\n        }\n    }","id":29093,"modified_method":"public FileStore(File directory, NodeState root) throws IOException {\n        // http://www.oracle.com/technetwork/java/hotspotfaq-138619.html#64bit_detection\n        if (\"32\".equals(System.getProperty(\"sun.arch.data.model\"))) {\n            log.warn(\"TarMK will only work with small repositories\"\n                    + \" in a 32 bit JVM. Consider switching to a 64 bit JVM.\");\n        }\n\n        checkNotNull(directory).mkdirs();\n        this.directory = directory;\n\n        for (int i = 0; true; i++) {\n            String name = String.format(FILE_NAME_FORMAT, i);\n            File file = new File(directory, name);\n            if (file.isFile()) {\n                RandomAccessFile f = new RandomAccessFile(file, \"rw\");\n                try {\n                    files.add(f.getChannel().map(READ_WRITE, 0, FILE_SIZE));\n                } finally {\n                    f.close();\n                }\n            } else {\n                break;\n            }\n        }\n\n        for (MappedByteBuffer file : files) {\n            loadSegments(file);\n        }\n\n        if (!journals.containsKey(\"root\")) {\n            NodeBuilder builder = EMPTY_NODE.builder();\n            builder.setChildNode(\"root\", root);\n            journals.put(\"root\", new FileJournal(this, builder.getNodeState()));\n        }\n    }","commit_id":"e7669bfba7395a67df5be327a1b4d65ac19a43b0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void prepare(int size) {\n        int segments = (size + SEGMENT_SIZE - 1) / SEGMENT_SIZE;\n        if ((1 + segments + 2) * SEGMENT_SIZE > rw.remaining()) {\n            if (rw.remaining() >= 3 * SEGMENT_SIZE) {\n                // Add a padding entry to avoid problems during reopening\n                rw.put(createTarHeader(\n                        PADDING_UUID,\n                        rw.remaining() - 3 * SEGMENT_SIZE));\n                if (rw.remaining() > 2 * SEGMENT_SIZE) {\n                    rw.putLong(PADDING_MAGIC);\n                    rw.put(PADDING_BYTES, 0, SEGMENT_SIZE - 8);\n                }\n            }\n            while (rw.remaining() > 0) {\n                rw.put(PADDING_BYTES);\n            }\n            rw.force();\n\n            String name = String.format(FILE_NAME_FORMAT, ++index);\n            File file = new File(directory, name);\n            try {\n                RandomAccessFile f = new RandomAccessFile(file, \"rw\");\n                try {\n                    rw = f.getChannel().map(READ_WRITE, 0, FILE_SIZE);\n                    ro = rw.asReadOnlyBuffer();\n                } finally {\n                    f.close();\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(\"Unable to create a new segment\", e);\n            }\n        }\n    }","id":29094,"modified_method":"private synchronized MappedByteBuffer prepare(int size) {\n        if (!files.isEmpty()) {\n            MappedByteBuffer last = files.getLast();\n\n            // Check if there's still enough room in the last open file\n            int segments = (size + SEGMENT_SIZE - 1) / SEGMENT_SIZE;\n            if ((1 + segments + 2) * SEGMENT_SIZE <= last.remaining()) {\n                return last;\n            }\n\n            // No more room, so finish the last file with padding as needed\n            if (last.remaining() >= 3 * SEGMENT_SIZE) {\n                // Add a padding entry to avoid problems during reopening\n                last.put(createTarHeader(\n                        PADDING_UUID,\n                        last.remaining() - 3 * SEGMENT_SIZE));\n                if (last.remaining() > 2 * SEGMENT_SIZE) {\n                    last.putLong(PADDING_MAGIC);\n                    last.put(PADDING_BYTES, 0, SEGMENT_SIZE - 8);\n                }\n            }\n            while (last.remaining() > 0) {\n                last.put(PADDING_BYTES);\n            }\n            last.force();\n        }\n\n        // Need to start a new file\n        try {\n            String name = String.format(FILE_NAME_FORMAT, files.size());\n            File file = new File(directory, name);\n            RandomAccessFile f = new RandomAccessFile(file, \"rw\");\n            try {\n                MappedByteBuffer buffer =\n                        f.getChannel().map(READ_WRITE, 0, FILE_SIZE);\n                files.add(buffer);\n                return buffer;\n            } finally {\n                f.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unable to create a new segment\", e);\n        }\n    }","commit_id":"e7669bfba7395a67df5be327a1b4d65ac19a43b0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void deleteSegment(UUID segmentId) {\n        if (segments.remove(segmentId) == null) {\n            throw new IllegalStateException(\"Missing segment: \" + segmentId);\n        }\n    }","id":29095,"modified_method":"@Override\n    public synchronized void deleteSegment(UUID segmentId) {\n        if (references.remove(segmentId) == null) {\n            throw new IllegalStateException(\"Missing segment: \" + segmentId);\n        }\n        segments.invalidate(segmentId);\n    }","commit_id":"e7669bfba7395a67df5be327a1b4d65ac19a43b0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n   * Since calling one of the send methods multiple times logs a warning, upon transaction failures this\n   * method is called to allow setting the failure response without an additional warning.\n   */\n  public void setTransactionFailureResponse(Throwable t) {\n    Throwable rootCause = Throwables.getRootCause(t);\n    ByteBuffer buffer = Charsets.UTF_8.encode(\"Exception occurred while handling request: \"\n                                                + Throwables.getStackTraceAsString(rootCause));\n\n    bufferedResponse = new BufferedResponse(HttpResponseStatus.INTERNAL_SERVER_ERROR.getCode(),\n                                            ChannelBuffers.wrappedBuffer(buffer),\n                                            \"text/plain; charset=\" + Charsets.UTF_8.name(), null);\n  }","id":29096,"modified_method":"/**\n   * Since calling one of the send methods multiple times logs a warning, upon transaction failures this\n   * method is called to allow setting the failure response without an additional warning.\n   */\n  public void setTransactionFailureResponse(Throwable t) {\n    LOG.error(\"Exception occurred while handling request:\", t);\n    @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n    ByteBuffer buffer = Charsets.UTF_8.encode(\"Exception occurred while handling request: \"\n                                                + Throwables.getRootCause(t).getMessage());\n\n    bufferedResponse = new BufferedResponse(HttpResponseStatus.INTERNAL_SERVER_ERROR.getCode(),\n                                            ChannelBuffers.wrappedBuffer(buffer),\n                                            \"text/plain; charset=\" + Charsets.UTF_8.name(), null);\n  }","commit_id":"7b5d73d54f09d63b57ed76a0fa0d4eba1e5bd72e","url":"https://github.com/caskdata/cdap"},{"original_method":"private void reportTransitiveResolutionError( MavenProject project,\n                                      String scope,\n                                      AbstractArtifactResolutionException cause )\n    {\n        StringWriter writer = new StringWriter();\n\n        writer.write( NEWLINE );\n        writer.write( \"Transitive dependency resolution for scope: \" );\n        writer.write( scope );\n        writer.write( \" has failed for your project.\" );\n\n        writer.write( NEWLINE );\n        writer.write( NEWLINE );\n        writer.write( NEWLINE );\n        writer.write( NEWLINE );\n        writer.write( \"Error message: \" );\n        writer.write( cause.getMessage() );\n        writer.write( NEWLINE );\n        writer.write( \"Root error message: \" );\n        writer.write( getRootCause( cause ).getMessage() );\n\n        writeProjectCoordinate( project, writer );\n        addTips( CoreErrorTips.getDependencyArtifactResolutionTips( project, scope, cause ),\n                 writer );\n\n        registerBuildError( cause, writer.toString(), cause.getCause() );\n    }","id":29097,"modified_method":"private void reportTransitiveResolutionError( MavenProject project,\n                                      String scope,\n                                      AbstractArtifactResolutionException cause )\n    {\n        StringWriter writer = new StringWriter();\n\n        writer.write( NEWLINE );\n        writer.write( \"Transitive dependency resolution for scope: \" );\n        writer.write( scope );\n        writer.write( \" has failed for your project.\" );\n\n        writer.write( NEWLINE );\n        writer.write( NEWLINE );\n        writer.write( NEWLINE );\n        writer.write( NEWLINE );\n        writer.write( \"Error message: \" );\n        writer.write( cause.getMessage() );\n\n        Throwable root = getRootCause( cause );\n        if ( root != cause )\n        {\n            writer.write( NEWLINE );\n            writer.write( \"Root error message: \" );\n            writer.write( root.getMessage() );\n        }\n\n        writeProjectCoordinate( project, writer );\n        addTips( CoreErrorTips.getDependencyArtifactResolutionTips( project, scope, cause ),\n                 writer );\n\n        registerBuildError( cause, writer.toString(), cause.getCause() );\n    }","commit_id":"e86a507c5d90771d8321732fc2e7e9255ed9ae07","url":"https://github.com/apache/maven"},{"original_method":"public static String attachmentsToString(Throwable t) {\n    //noinspection ThrowableResultOfMethodCallIgnored\n    Throwable rootCause = ExceptionUtil.getRootCause(t);\n    if (rootCause instanceof ExceptionWithAttachments) {\n      return \"\\nAttachments:\" + StringUtil.join(((ExceptionWithAttachments)rootCause).getAttachments(),\n                                                new Function<Attachment, String>() {\n                                                  @Override\n                                                  public String fun(Attachment attachment) {\n                                                    return attachment.getPath() + \"\\n\" + attachment.getDisplayText();\n                                                  }\n                                                },\n                                                \"\\n----\\n\");\n    }\n    return \"\";\n  }","id":29098,"modified_method":"public static String attachmentsToString(@Nullable Throwable t) {\n    //noinspection ThrowableResultOfMethodCallIgnored\n    Throwable rootCause = t == null ? null : ExceptionUtil.getRootCause(t);\n    if (rootCause instanceof ExceptionWithAttachments) {\n      return \"\\nAttachments:\" + StringUtil.join(((ExceptionWithAttachments)rootCause).getAttachments(),\n                                                new Function<Attachment, String>() {\n                                                  @Override\n                                                  public String fun(Attachment attachment) {\n                                                    return attachment.getPath() + \"\\n\" + attachment.getDisplayText();\n                                                  }\n                                                },\n                                                \"\\n----\\n\");\n    }\n    return \"\";\n  }","commit_id":"956a51036d2a5a87f6fbe3c4a81cca18df362405","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected MethodNode addClassUnderTestMethod(ClassNode classNode, ClassExpression targetClass, String type) {\n\n        String methodName = \"setup\" + type + \"UnderTest\";\n        String fieldName = GrailsNameUtils.getPropertyName(type);\n\n        if(classNode.getField(fieldName) == null) {\n            classNode.addField(fieldName, Modifier.PRIVATE, targetClass.getType(),null);\n        }\n\n\n        MethodNode methodNode = classNode.getMethod(methodName,GrailsArtefactClassInjector.ZERO_PARAMETERS);\n\n        if(methodNode == null) {\n            BlockStatement methodBody = new BlockStatement();\n            VariableExpression fieldExpression = new VariableExpression(fieldName);\n            addMockCollaborator(type, targetClass, methodBody);\n            BinaryExpression testTargetAssignment = new BinaryExpression(fieldExpression, ASSIGN, new ConstructorCallExpression(targetClass.getType(), GrailsArtefactClassInjector.ZERO_ARGS));\n            methodBody.addStatement(new ExpressionStatement(testTargetAssignment));\n            methodNode = new MethodNode(methodName, Modifier.PUBLIC, ClassHelper.VOID_TYPE, GrailsArtefactClassInjector.ZERO_PARAMETERS,null, methodBody);\n            methodNode.addAnnotation(BEFORE_ANNOTATION);\n\n            classNode.addMethod(methodNode);\n        }\n\n\n        return methodNode;\n    }","id":29099,"modified_method":"protected MethodNode addClassUnderTestMethod(ClassNode classNode, ClassExpression targetClass, String type) {\n\n        String methodName = \"setup\" + type + \"UnderTest\";\n        String fieldName = GrailsNameUtils.getPropertyName(type);\n\n        if(classNode.getField(fieldName) == null) {\n            classNode.addField(fieldName, Modifier.PRIVATE, targetClass.getType(),null);\n        }\n\n\n        MethodNode methodNode = classNode.getMethod(methodName,GrailsArtefactClassInjector.ZERO_PARAMETERS);\n\n        if(methodNode == null) {\n            BlockStatement methodBody = new BlockStatement();\n            VariableExpression fieldExpression = new VariableExpression(fieldName);\n            addMockCollaborator(type, targetClass, methodBody);\n            BinaryExpression testTargetAssignment = new BinaryExpression(fieldExpression, ASSIGN, new ConstructorCallExpression(targetClass.getType(), GrailsArtefactClassInjector.ZERO_ARGS));\n            methodBody.addStatement(new ExpressionStatement(testTargetAssignment));\n            methodNode = new MethodNode(methodName, Modifier.PUBLIC, ClassHelper.VOID_TYPE, GrailsArtefactClassInjector.ZERO_PARAMETERS,null, methodBody);\n            methodNode.addAnnotation(BEFORE_ANNOTATION);\n            methodNode.addAnnotation(MIXIN_METHOD_ANNOTATION);\n            classNode.addMethod(methodNode);\n        }\n\n\n        return methodNode;\n    }","commit_id":"0be8583495b9f787e89a2a59e1dd65b2ae1aa1d1","url":"https://github.com/grails/grails-core"},{"original_method":"private void addMockCollaboratorToSetup(ClassNode classNode, ClassExpression targetClassExpression, String artefactType) {\n\n        BlockStatement methodBody;\n        if(isJunit3Test(classNode)) {\n            methodBody= getJunit3Setup(classNode);\n        }\n        else {\n            methodBody= getJunit4Setup(classNode);\n        }\n\n        addMockCollaborator(artefactType, targetClassExpression,methodBody);\n    }","id":29100,"modified_method":"private void addMockCollaboratorToSetup(ClassNode classNode, ClassExpression targetClassExpression, String artefactType) {\n\n        BlockStatement methodBody;\n        if(isJunit3Test(classNode)) {\n            methodBody= getJunit3Setup(classNode);\n            addMockCollaborator(artefactType, targetClassExpression,methodBody);\n        }\n        else {\n            addToJunit4BeforeMethods(classNode, artefactType, targetClassExpression);\n        }\n\n    }","commit_id":"0be8583495b9f787e89a2a59e1dd65b2ae1aa1d1","url":"https://github.com/grails/grails-core"},{"original_method":"private BlockStatement getJunit4Setup(ClassNode classNode) {\n        MethodNode setupMethod = classNode.getMethod(SET_UP_METHOD, GrailsArtefactClassInjector.ZERO_PARAMETERS);\n        if(setupMethod == null) {\n            setupMethod = new MethodNode(SET_UP_METHOD,Modifier.PUBLIC,ClassHelper.VOID_TYPE,GrailsArtefactClassInjector.ZERO_PARAMETERS,null,new BlockStatement());\n            classNode.addMethod(setupMethod);\n        }\n        if(setupMethod.getAnnotations(BEFORE_CLASS_NODE).size() == 0) {\n            setupMethod.addAnnotation(BEFORE_ANNOTATION);\n        }\n        return getOrCreateMethodBody(classNode, setupMethod, SET_UP_METHOD);\n\n    }","id":29101,"modified_method":"private BlockStatement getJunit4Setup(ClassNode classNode) {\n        MethodNode setupMethod = classNode.getMethod(SET_UP_METHOD, GrailsArtefactClassInjector.ZERO_PARAMETERS);\n        if(setupMethod == null) {\n            setupMethod = new MethodNode(SET_UP_METHOD,Modifier.PUBLIC,ClassHelper.VOID_TYPE,GrailsArtefactClassInjector.ZERO_PARAMETERS,null,new BlockStatement());\n            setupMethod.addAnnotation(MIXIN_METHOD_ANNOTATION);\n            classNode.addMethod(setupMethod);\n        }\n        if(setupMethod.getAnnotations(BEFORE_CLASS_NODE).size() == 0) {\n            setupMethod.addAnnotation(BEFORE_ANNOTATION);\n        }\n        return getOrCreateMethodBody(classNode, setupMethod, SET_UP_METHOD);\n\n    }","commit_id":"0be8583495b9f787e89a2a59e1dd65b2ae1aa1d1","url":"https://github.com/grails/grails-core"},{"original_method":"public void weaveMixinsIntoClass(ClassNode classNode, ListExpression values) {\n        if(values != null) {\n            boolean isJunit3 = isJunit3Test(classNode);\n            List<MethodNode> beforeMethods = null;\n            List<MethodNode> afterMethods = null;\n            if (isJunit3) {\n                beforeMethods = new ArrayList<MethodNode>();\n                afterMethods = new ArrayList<MethodNode>();\n            }\n            for (Expression current : values.getExpressions()) {\n                if(current instanceof ClassExpression) {\n                    ClassExpression ce = (ClassExpression) current;\n\n                    ClassNode mixinClassNode = ce.getType();\n\n                    final String fieldName = '$' + GrailsNameUtils.getPropertyName(mixinClassNode.getName());\n\n                    GrailsASTUtils.addFieldIfNonExistent(classNode, mixinClassNode, fieldName);\n                    VariableExpression fieldReference = new VariableExpression(fieldName);\n\n\n\n                    while (!mixinClassNode.getName().equals(OBJECT_CLASS)) {\n                        final List<MethodNode> mixinMethods = mixinClassNode.getMethods();\n\n                        int beforeClassMethodCount = 0;\n                        int afterClassMethodCount = 0;\n                        for (MethodNode mixinMethod : mixinMethods) {\n                            if(isCandidateMethod(mixinMethod) && !hasDeclaredMethod(classNode, mixinMethod)) {\n                                if(mixinMethod.isStatic()) {\n                                    GrailsASTUtils.addDelegateStaticMethod(classNode, mixinMethod);\n                                }\n                                else {\n                                    GrailsASTUtils.addDelegateInstanceMethod(classNode,fieldReference, mixinMethod, false);\n                                }\n                                if(isJunit3) {\n\n                                    if(hasAnnotation(mixinMethod, Before.class)) {\n                                        beforeMethods.add(mixinMethod);\n                                    }\n                                    if(hasAnnotation(mixinMethod, BeforeClass.class)) {\n                                        beforeMethods.add(beforeClassMethodCount++, mixinMethod);\n                                    }\n                                    if(hasAnnotation(mixinMethod, After.class)) {\n                                        afterMethods.add(mixinMethod);\n                                    }\n                                    if(hasAnnotation(mixinMethod, AfterClass.class)) {\n                                        afterMethods.add(afterClassMethodCount++, mixinMethod);\n                                    }\n                                }\n                            }\n                        }\n\n                        mixinClassNode = mixinClassNode.getSuperClass();\n                    }\n\n\n                }\n            }\n            if(isJunit3) {\n                addMethodCallsToMethod(classNode, SET_UP_METHOD, beforeMethods);\n                addMethodCallsToMethod(classNode, TEAR_DOWN_METHOD, afterMethods);\n            }\n        }\n    }","id":29102,"modified_method":"public void weaveMixinsIntoClass(ClassNode classNode, ListExpression values) {\n        if(values != null) {\n            boolean isJunit3 = isJunit3Test(classNode);\n            List<MethodNode> beforeMethods = null;\n            List<MethodNode> afterMethods = null;\n            if (isJunit3) {\n                beforeMethods = new ArrayList<MethodNode>();\n                afterMethods = new ArrayList<MethodNode>();\n            }\n            for (Expression current : values.getExpressions()) {\n                if(current instanceof ClassExpression) {\n                    ClassExpression ce = (ClassExpression) current;\n\n                    ClassNode mixinClassNode = ce.getType();\n\n                    final String fieldName = '$' + GrailsNameUtils.getPropertyName(mixinClassNode.getName());\n\n                    GrailsASTUtils.addFieldIfNonExistent(classNode, mixinClassNode, fieldName);\n                    VariableExpression fieldReference = new VariableExpression(fieldName);\n\n\n\n                    while (!mixinClassNode.getName().equals(OBJECT_CLASS)) {\n                        final List<MethodNode> mixinMethods = mixinClassNode.getMethods();\n\n                        int beforeClassMethodCount = 0;\n                        int afterClassMethodCount = 0;\n                        for (MethodNode mixinMethod : mixinMethods) {\n                            if(isCandidateMethod(mixinMethod) && !hasDeclaredMethod(classNode, mixinMethod)) {\n                                if(mixinMethod.isStatic()) {\n                                    MethodNode methodNode = GrailsASTUtils.addDelegateStaticMethod(classNode, mixinMethod);\n                                    if(methodNode != null) {\n                                        methodNode.addAnnotation(MIXIN_METHOD_ANNOTATION);\n                                    }\n\n                                }\n                                else {\n                                    MethodNode methodNode = GrailsASTUtils.addDelegateInstanceMethod(classNode, fieldReference, mixinMethod, false);\n                                    if(methodNode != null) {\n                                        methodNode.addAnnotation(MIXIN_METHOD_ANNOTATION);\n                                    }\n                                }\n                                if(isJunit3) {\n\n                                    if(hasAnnotation(mixinMethod, Before.class)) {\n                                        beforeMethods.add(mixinMethod);\n                                    }\n                                    if(hasAnnotation(mixinMethod, BeforeClass.class)) {\n                                        beforeMethods.add(beforeClassMethodCount++, mixinMethod);\n                                    }\n                                    if(hasAnnotation(mixinMethod, After.class)) {\n                                        afterMethods.add(mixinMethod);\n                                    }\n                                    if(hasAnnotation(mixinMethod, AfterClass.class)) {\n                                        afterMethods.add(afterClassMethodCount++, mixinMethod);\n                                    }\n                                }\n                            }\n                        }\n\n                        mixinClassNode = mixinClassNode.getSuperClass();\n                    }\n\n\n                }\n            }\n            if(isJunit3) {\n                addMethodCallsToMethod(classNode, SET_UP_METHOD, beforeMethods);\n                addMethodCallsToMethod(classNode, TEAR_DOWN_METHOD, afterMethods);\n            }\n        }\n    }","commit_id":"0be8583495b9f787e89a2a59e1dd65b2ae1aa1d1","url":"https://github.com/grails/grails-core"},{"original_method":"private boolean hasDeclaredMethod(ClassNode classNode, MethodNode mixinMethod) {\n        return classNode.hasDeclaredMethod(mixinMethod.getName(), mixinMethod.getParameters());\n    }","id":29103,"modified_method":"protected boolean hasDeclaredMethod(ClassNode classNode, MethodNode mixinMethod) {\n        return classNode.hasDeclaredMethod(mixinMethod.getName(), mixinMethod.getParameters());\n    }","commit_id":"0be8583495b9f787e89a2a59e1dd65b2ae1aa1d1","url":"https://github.com/grails/grails-core"},{"original_method":"private boolean hasAnnotation(MethodNode mixinMethod, Class beforeClass) {\n        return !mixinMethod.getAnnotations(new ClassNode(beforeClass)).isEmpty();\n    }","id":29104,"modified_method":"protected boolean hasAnnotation(MethodNode mixinMethod, Class beforeClass) {\n        return !mixinMethod.getAnnotations(new ClassNode(beforeClass)).isEmpty();\n    }","commit_id":"0be8583495b9f787e89a2a59e1dd65b2ae1aa1d1","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * <p>\n     * Loads the properties in the system property file associated with the\n     * framework installation into <tt>System.setProperty()<\/tt>. These properties\n     * are not directly used by the framework in anyway. By default, the system\n     * property file is located in the <tt>conf/<\/tt> directory of the Felix\n     * installation directory and is called \"<tt>system.properties<\/tt>\". The\n     * installation directory of Felix is assumed to be the parent directory of\n     * the <tt>felix.jar<\/tt> file as found on the system class path property.\n     * The precise file from which to load system properties can be set by\n     * initializing the \"<tt>felix.system.properties<\/tt>\" system property to an\n     * arbitrary URL.\n     * <\/p>\n     */\n    private void loadSystemProperties() {\n        // The system properties file is either specified by a system\n        // property or it is in the same directory as the Felix JAR file.\n        // Try to load it from one of these places.\n\n        // See if the property URL was specified as a property.\n        URL propURL = null;\n        try {\n            File file = new File(new File(karafBase, \"etc\"), SYSTEM_PROPERTIES_FILE_NAME);\n            propURL = file.toURL();\n        }\n        catch (MalformedURLException ex) {\n            System.err.print(\"Main: \" + ex);\n            return;\n        }\n\n        // Read the properties file.\n        Properties props = new Properties();\n        InputStream is = null;\n        try {\n            is = propURL.openConnection().getInputStream();\n            props.load(is);\n            is.close();\n        }\n        catch (FileNotFoundException ex) {\n            // Ignore file not found.\n        }\n        catch (Exception ex) {\n            System.err.println(\n                    \"Main: Error loading system properties from \" + propURL);\n            System.err.println(\"Main: \" + ex);\n            try {\n                if (is != null) is.close();\n            }\n            catch (IOException ex2) {\n                // Nothing we can do.\n            }\n            return;\n        }\n\n        // Perform variable substitution on specified properties.\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String name = (String) e.nextElement();\n            System.setProperty(name,\n                    substVars(props.getProperty(name), name, null, null));\n        }\n    }","id":29105,"modified_method":"/**\n     * <p>\n     * Loads the properties in the system property file associated with the\n     * framework installation into <tt>System.setProperty()<\/tt>. These properties\n     * are not directly used by the framework in anyway. By default, the system\n     * property file is located in the <tt>conf/<\/tt> directory of the Felix\n     * installation directory and is called \"<tt>system.properties<\/tt>\". The\n     * installation directory of Felix is assumed to be the parent directory of\n     * the <tt>felix.jar<\/tt> file as found on the system class path property.\n     * The precise file from which to load system properties can be set by\n     * initializing the \"<tt>felix.system.properties<\/tt>\" system property to an\n     * arbitrary URL.\n     * <\/p>\n     */\n    private void loadSystemProperties() {\n        // The system properties file is either specified by a system\n        // property or it is in the same directory as the Felix JAR file.\n        // Try to load it from one of these places.\n\n        // See if the property URL was specified as a property.\n        URL propURL = null;\n        try {\n            File file = new File(new File(karafBase, \"etc\"), SYSTEM_PROPERTIES_FILE_NAME);\n            propURL = file.toURL();\n        }\n        catch (MalformedURLException ex) {\n            System.err.print(\"Main: \" + ex);\n            return;\n        }\n\n        // Read the properties file.\n        Properties props = new Properties();\n        InputStream is = null;\n        try {\n            is = propURL.openConnection().getInputStream();\n            props.load(is);\n            is.close();\n        }\n        catch (FileNotFoundException ex) {\n            // Ignore file not found.\n        }\n        catch (Exception ex) {\n            System.err.println(\n                    \"Main: Error loading system properties from \" + propURL);\n            System.err.println(\"Main: \" + ex);\n            try {\n                if (is != null) is.close();\n            }\n            catch (IOException ex2) {\n                // Nothing we can do.\n            }\n            return;\n        }\n\n        // Perform variable substitution on specified properties.\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String name = (String) e.nextElement();\n            String value = System.getProperty(name, props.getProperty(name));\n            System.setProperty(name, substVars(value, name, null, null));\n        }\n    }","commit_id":"d209bf27b8a971cce1eb138a922919124cc6847b","url":"https://github.com/apache/felix"},{"original_method":"private static void addLocalPackages( Analyzer analyzer, MavenProject project )\n    {\n        DirectoryScanner scanner = new DirectoryScanner();\n        scanner.setBasedir( project.getBuild().getSourceDirectory() );\n        scanner.setIncludes( new String[]\n            { \"**/*.java\" } );\n\n        scanner.addDefaultExcludes();\n        scanner.scan();\n\n        Collection packages = new HashSet();\n\n        String[] paths = scanner.getIncludedFiles();\n        for ( int i = 0; i < paths.length; i++ )\n        {\n            packages.add( getPackageName( paths[i] ) );\n        }\n\n        StringBuffer exportPackage = new StringBuffer();\n        StringBuffer privatePackage = new StringBuffer();\n\n        for ( Iterator i = packages.iterator(); i.hasNext(); )\n        {\n            String pkg = ( String ) i.next();\n            if ( \".\".equals( pkg ) || pkg.contains( \".internal\" ) || pkg.contains( \".impl\" ) )\n            {\n                privatePackage.append( pkg ).append( ',' );\n            }\n            else\n            {\n                exportPackage.append( pkg ).append( ',' );\n            }\n        }\n\n        analyzer.setProperty( Analyzer.EXPORT_PACKAGE, exportPackage.toString() );\n        analyzer.setProperty( Analyzer.PRIVATE_PACKAGE, privatePackage.toString() );\n    }","id":29106,"modified_method":"private static void addLocalPackages( String sourceDirectory, Analyzer analyzer )\n    {\n        Collection packages = new HashSet();\n\n        if ( sourceDirectory != null && new File( sourceDirectory ).isDirectory() )\n        {\n            // scan local Java sources for potential packages\n            DirectoryScanner scanner = new DirectoryScanner();\n            scanner.setBasedir( sourceDirectory );\n            scanner.setIncludes( new String[]\n                { \"**/*.java\" } );\n\n            scanner.addDefaultExcludes();\n            scanner.scan();\n\n            String[] paths = scanner.getIncludedFiles();\n            for ( int i = 0; i < paths.length; i++ )\n            {\n                packages.add( getPackageName( paths[i] ) );\n            }\n        }\n\n        StringBuffer exportedPkgs = new StringBuffer();\n        StringBuffer privatePkgs = new StringBuffer();\n\n        for ( Iterator i = packages.iterator(); i.hasNext(); )\n        {\n            String pkg = ( String ) i.next();\n\n            // mark all source packages as private by default (can be overridden by export list)\n            privatePkgs.append( pkg ).append( ',' );\n\n            // we can't export the default package (\".\") and we shouldn't export internal packages \n            if ( !( \".\".equals( pkg ) || pkg.contains( \".internal\" ) || pkg.contains( \".impl\" ) ) )\n            {\n                exportedPkgs.append( pkg ).append( ',' );\n            }\n        }\n\n        if ( analyzer.getProperty( Analyzer.EXPORT_PACKAGE ) == null )\n        {\n            if ( analyzer.getProperty( Analyzer.EXPORT_CONTENTS ) == null )\n            {\n                // no -exportcontents overriding the exports, so use our computed list\n                analyzer.setProperty( Analyzer.EXPORT_PACKAGE, exportedPkgs.toString() );\n            }\n            else\n            {\n                // leave Export-Package empty (but non-null) as we have -exportcontents\n                analyzer.setProperty( Analyzer.EXPORT_PACKAGE, \"\" );\n            }\n        }\n\n        if ( analyzer.getProperty( Analyzer.PRIVATE_PACKAGE ) == null )\n        {\n            // if there are really no private packages then use \"!*\" as this will keep the Bnd Tool happy\n            analyzer.setProperty( Analyzer.PRIVATE_PACKAGE, privatePkgs.length() == 0 ? \"!*\" : privatePkgs.toString() );\n        }\n    }","commit_id":"b371e7ef4f7618f202c7ec958029be73e124b593","url":"https://github.com/apache/felix"},{"original_method":"public static String getPackageName( String filename )\n    {\n        int n = filename.lastIndexOf( File.separatorChar );\n        return n < 0 ? \".\" : filename.substring( 0, n ).replace( File.separatorChar, '.' );\n    }","id":29107,"modified_method":"private static String getPackageName( String filename )\n    {\n        int n = filename.lastIndexOf( File.separatorChar );\n        return n < 0 ? \".\" : filename.substring( 0, n ).replace( File.separatorChar, '.' );\n    }","commit_id":"b371e7ef4f7618f202c7ec958029be73e124b593","url":"https://github.com/apache/felix"},{"original_method":"protected Builder buildOSGiBundle( MavenProject currentProject, Map originalInstructions, Properties properties,\n        Jar[] classpath ) throws Exception\n    {\n        properties.putAll( getDefaultProperties( currentProject ) );\n        properties.putAll( transformDirectives( originalInstructions ) );\n\n        Builder builder = new Builder();\n        builder.setBase( currentProject.getBasedir() );\n        builder.setProperties( properties );\n        builder.setClasspath( classpath );\n\n        // update BND instructions to add included Maven resources\n        includeMavenResources( currentProject, builder, getLog() );\n\n        if ( builder.getProperty( Analyzer.EXPORT_PACKAGE ) == null\n            && builder.getProperty( Analyzer.PRIVATE_PACKAGE ) == null )\n        {\n            if ( builder.getProperty( Analyzer.EXPORT_CONTENTS ) != null )\n            {\n                /*\n                 * if we have exportcontents but no export packages or private packages then we're probably embedding or\n                 * inlining one or more jars, so set private package to a non-null (but empty) value to keep Bnd happy.\n                 */\n                builder.setProperty( Analyzer.PRIVATE_PACKAGE, \"!*\" );\n            }\n            else\n            {\n                addLocalPackages( builder, currentProject );\n            }\n        }\n\n        // update BND instructions to embed selected Maven dependencies\n        Collection embeddableArtifacts = getEmbeddableArtifacts( currentProject, builder );\n        new DependencyEmbedder( embeddableArtifacts ).processHeaders( builder );\n\n        dumpInstructions( \"BND Instructions:\", builder.getProperties(), getLog() );\n        dumpClasspath( \"BND Classpath:\", builder.getClasspath(), getLog() );\n\n        builder.build();\n        Jar jar = builder.getJar();\n\n        dumpManifest( \"BND Manifest:\", jar.getManifest(), getLog() );\n\n        String[] removeHeaders = builder.getProperty( Analyzer.REMOVE_HEADERS, \"\" ).split( \",\" );\n\n        mergeMavenManifest( currentProject, jar, removeHeaders, getLog() );\n        builder.setJar( jar );\n\n        dumpManifest( \"Final Manifest:\", jar.getManifest(), getLog() );\n\n        return builder;\n    }","id":29108,"modified_method":"protected Builder buildOSGiBundle( MavenProject currentProject, Map originalInstructions, Properties properties,\n        Jar[] classpath ) throws Exception\n    {\n        properties.putAll( getDefaultProperties( currentProject ) );\n        properties.putAll( transformDirectives( originalInstructions ) );\n\n        Builder builder = new Builder();\n        builder.setBase( currentProject.getBasedir() );\n        builder.setProperties( properties );\n        builder.setClasspath( classpath );\n\n        // update BND instructions to add included Maven resources\n        includeMavenResources( currentProject, builder, getLog() );\n\n        // calculate default export/private settings based on sources\n        if ( builder.getProperty( Analyzer.PRIVATE_PACKAGE ) == null\n            || builder.getProperty( Analyzer.EXPORT_PACKAGE ) == null )\n        {\n            addLocalPackages( currentProject.getBuild().getSourceDirectory(), builder );\n        }\n\n        // update BND instructions to embed selected Maven dependencies\n        Collection embeddableArtifacts = getEmbeddableArtifacts( currentProject, builder );\n        new DependencyEmbedder( embeddableArtifacts ).processHeaders( builder );\n\n        dumpInstructions( \"BND Instructions:\", builder.getProperties(), getLog() );\n        dumpClasspath( \"BND Classpath:\", builder.getClasspath(), getLog() );\n\n        builder.build();\n        Jar jar = builder.getJar();\n\n        dumpManifest( \"BND Manifest:\", jar.getManifest(), getLog() );\n\n        String[] removeHeaders = builder.getProperty( Analyzer.REMOVE_HEADERS, \"\" ).split( \",\" );\n\n        mergeMavenManifest( currentProject, jar, removeHeaders, getLog() );\n        builder.setJar( jar );\n\n        dumpManifest( \"Final Manifest:\", jar.getManifest(), getLog() );\n\n        return builder;\n    }","commit_id":"b371e7ef4f7618f202c7ec958029be73e124b593","url":"https://github.com/apache/felix"},{"original_method":"private void addBundle(Bundle bundle, Logger logger)\n    {\n        \n        /*\n         * Concurrency note: This method MUST be called in a context which\n         * is synchronized on this instance to prevent data structure\n         * corruption.\n         */\n        \n        try\n        {\n            m_localResourceList.put(new Long(bundle.getBundleId()), new LocalResourceImpl(bundle, m_logger));\n        }\n        catch (InvalidSyntaxException ex)\n        {\n            // This should never happen since we are generating filters,\n            // but ignore the resource if it does occur.\n            m_logger.log(Logger.LOG_WARNING, ex.getMessage(), ex);\n        }\n    }","id":29109,"modified_method":"private void addBundle(Bundle bundle, Logger logger)\n    {\n        \n        /*\n         * Concurrency note: This method MUST be called in a context which\n         * is synchronized on this instance to prevent data structure\n         * corruption.\n         */\n\n        // Ignore system bundle\n        if (bundle.getBundleId() == 0)\n        {\n            return;\n        }\n        try\n        {\n            m_localResourceList.put(new Long(bundle.getBundleId()), new LocalResourceImpl(bundle));\n        }\n        catch (InvalidSyntaxException ex)\n        {\n            // This should never happen since we are generating filters,\n            // but ignore the resource if it does occur.\n            m_logger.log(Logger.LOG_WARNING, ex.getMessage(), ex);\n        }\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Constructor.\n     *\n     * @param bundleContext bundle context\n     */\n    Logger(BundleContext context)\n    {\n        m_context = context;\n        try\n        {\n            org.osgi.service.log.LogService.class.getName();\n            m_isLogClassPresent = true;\n        }\n        catch (NoClassDefFoundError ex)\n        {\n            m_isLogClassPresent = false;\n        }\n    }","id":29110,"modified_method":"/**\n     * Constructor.\n     *\n     * @param context bundle context\n     */\n    Logger(BundleContext context)\n    {\n        m_context = context;\n        try\n        {\n            org.osgi.service.log.LogService.class.getName();\n            m_isLogClassPresent = true;\n        }\n        catch (NoClassDefFoundError ex)\n        {\n            m_isLogClassPresent = false;\n        }\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"LocalRepositoryImpl getLocalRepository()\n    {\n        return m_local;\n    }","id":29111,"modified_method":"public Repository getLocalRepository()\n    {\n        return m_local;\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"public synchronized Resolver resolver()\n    {\n        if (!m_initialized)\n        {\n            initialize();\n        }\n\n        return new ResolverImpl(m_context, this, m_logger);\n    }","id":29112,"modified_method":"public synchronized Resolver resolver()\n    {\n        if (!m_initialized)\n        {\n            initialize();\n        }\n\n        List repositories = new ArrayList();\n        repositories.add(m_system);\n        repositories.add(m_local);\n        repositories.addAll(m_repoMap.values());\n\n        return resolver((Repository[]) repositories.toArray(new Repository[repositories.size()]));\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"public RepositoryAdminImpl(BundleContext context, Logger logger)\n    {\n        m_context = context;\n        m_logger = logger;\n        m_local = new LocalRepositoryImpl(context, logger);\n    }","id":29113,"modified_method":"public RepositoryAdminImpl(BundleContext context, Logger logger)\n    {\n        m_context = context;\n        m_logger = logger;\n        m_system = new SystemRepositoryImpl(context, logger);\n        m_local = new LocalRepositoryImpl(context, logger);\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"private RepositoryAdminImpl createRepositoryAdmin()\n    {\n        final MockBundleContext bundleContext = new MockBundleContext() {\n            public Filter createFilter(String arg0) {\n                return new FilterImpl(arg0);\n            }\n        };\n        RepositoryAdminImpl repoAdmin = new RepositoryAdminImpl(bundleContext, new Logger(bundleContext));\n\n        // force initialization && remove all initial repositories\n        Repository[] repos = repoAdmin.listRepositories();\n        for (int i = 0; repos != null && i < repos.length; i++)\n        {\n            repoAdmin.removeRepository(repos[i].getURL());\n        }\n\n        return repoAdmin;\n    }","id":29114,"modified_method":"private RepositoryAdminImpl createRepositoryAdmin() throws Exception\n    {\n        BundleContext bundleContext = (BundleContext) EasyMock.createMock(BundleContext.class);\n        Bundle systemBundle = (Bundle) EasyMock.createMock(Bundle.class);\n\n        EasyMock.expect(bundleContext.getProperty((String) EasyMock.anyObject())).andReturn(null).anyTimes();\n        EasyMock.expect(bundleContext.getBundle(0)).andReturn(systemBundle);\n        EasyMock.expect(systemBundle.getHeaders()).andReturn(new Hashtable());\n        EasyMock.expect(systemBundle.getRegisteredServices()).andReturn(null);\n        EasyMock.expect(new Long(systemBundle.getBundleId())).andReturn(new Long(0)).anyTimes();\n        EasyMock.expect(systemBundle.getBundleContext()).andReturn(bundleContext);\n        bundleContext.addBundleListener((BundleListener) EasyMock.anyObject());\n        bundleContext.addServiceListener((ServiceListener) EasyMock.anyObject());\n        EasyMock.expect(bundleContext.getBundles()).andReturn(new Bundle[] { systemBundle });\n        final Capture c = new Capture();\n        EasyMock.expect(bundleContext.createFilter((String) capture(c))).andAnswer(new IAnswer() {\n            public Object answer() throws Throwable {\n                return new FilterImpl((String) c.getValue());\n            }\n        }).anyTimes();\n        EasyMock.replay(new Object[] { bundleContext, systemBundle });\n\n        RepositoryAdminImpl repoAdmin = new RepositoryAdminImpl(bundleContext, new Logger(bundleContext));\n\n        // force initialization && remove all initial repositories\n        Repository[] repos = repoAdmin.listRepositories();\n        for (int i = 0; repos != null && i < repos.length; i++)\n        {\n            repoAdmin.removeRepository(repos[i].getURL());\n        }\n\n        return repoAdmin;\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"private RepositoryAdminImpl createRepositoryAdmin()\n    {\n        final MockBundleContext bundleContext = new MockBundleContext();\n        RepositoryAdminImpl repoAdmin = new RepositoryAdminImpl(bundleContext, new Logger(bundleContext));\n\n        // force initialization && remove all initial repositories\n        Repository[] repos = repoAdmin.listRepositories();\n        for (int i = 0; repos != null && i < repos.length; i++)\n        {\n            repoAdmin.removeRepository(repos[i].getURL());\n        }\n\n        return repoAdmin;\n    }","id":29115,"modified_method":"private RepositoryAdminImpl createRepositoryAdmin() throws Exception\n    {\n        BundleContext bundleContext = (BundleContext) EasyMock.createMock(BundleContext.class);\n        Bundle systemBundle = (Bundle) EasyMock.createMock(Bundle.class);\n\n        EasyMock.expect(bundleContext.getProperty((String) EasyMock.anyObject())).andReturn(null).anyTimes();\n        EasyMock.expect(bundleContext.getBundle(0)).andReturn(systemBundle);\n        EasyMock.expect(systemBundle.getHeaders()).andReturn(new Hashtable());\n        EasyMock.expect(systemBundle.getRegisteredServices()).andReturn(null);\n        EasyMock.expect(new Long(systemBundle.getBundleId())).andReturn(new Long(0)).anyTimes();\n        EasyMock.expect(systemBundle.getBundleContext()).andReturn(bundleContext);\n        bundleContext.addBundleListener((BundleListener) EasyMock.anyObject());\n        bundleContext.addServiceListener((ServiceListener) EasyMock.anyObject());\n        EasyMock.expect(bundleContext.getBundles()).andReturn(new Bundle[] { systemBundle });\n        EasyMock.expect(bundleContext.createFilter(null)).andReturn(new Filter() {\n            public boolean match(ServiceReference reference) {\n                return true;\n            }\n            public boolean match(Dictionary dictionary) {\n                return true;\n            }\n            public boolean matchCase(Dictionary dictionary) {\n                return true;\n            }\n        }).anyTimes();\n        EasyMock.replay(new Object[] { bundleContext, systemBundle });\n\n        RepositoryAdminImpl repoAdmin = new RepositoryAdminImpl(bundleContext, new Logger(bundleContext));\n\n        // force initialization && remove all initial repositories\n        Repository[] repos = repoAdmin.listRepositories();\n        for (int i = 0; repos != null && i < repos.length; i++)\n        {\n            repoAdmin.removeRepository(repos[i].getURL());\n        }\n\n        return repoAdmin;\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"private boolean resolve(Resource resource)\n    {\n        boolean result = true;\n\n        // Check for cycles.\n        if (m_resolveSet.contains(resource))\n        {\n            return true;\n        }\n        else if (m_failedSet.contains(resource))\n        {\n            return false;\n        }\n\n        // Add to resolve map to avoid cycles.\n        m_resolveSet.add(resource);\n\n        // Resolve the requirements for the resource according to the\n        // search order of: added, resolving, local and finally remote\n        // resources.\n        Requirement[] reqs = resource.getRequirements();\n        if (reqs != null)\n        {\n            Resource candidate = null;\n            for (int reqIdx = 0; reqIdx < reqs.length; reqIdx++)\n            {\n                candidate = searchAddedResources(reqs[reqIdx]);\n                if (candidate == null)\n                {\n                    candidate = searchResolvingResources(reqs[reqIdx]);\n                    if (candidate == null)\n                    {\n                        List candidateCapabilities = searchLocalResources(reqs[reqIdx]);\n                        candidateCapabilities.addAll(searchRemoteResources(reqs[reqIdx]));\n\n                        // Determine the best candidate available that\n                        // can resolve.\n                        while ((candidate == null) && !candidateCapabilities.isEmpty())\n                        {\n                            Capability bestCapability = getBestCandidate(candidateCapabilities);\n\n                            // Try to resolve the best resource.\n                            if (resolve(((CapabilityImpl) bestCapability).getResource()))\n                            {\n                                candidate = ((CapabilityImpl) bestCapability).getResource();\n                            }\n                            else\n                            {\n                                candidateCapabilities.remove(bestCapability);\n                            }\n                        }\n                    }\n                }\n\n                if ((candidate == null) && !reqs[reqIdx].isOptional())\n                {\n                    // The resolve failed.\n                    result = false;\n                    // Associated the current resource to the requirement\n                    // in the unsatisfied requirement map.\n                    Resource[] resources = (Resource[]) m_unsatisfiedMap.get(reqs[reqIdx]);\n                    if (resources == null)\n                    {\n                        resources = new Resource[] { resource };\n                    }\n                    else\n                    {\n                        Resource[] tmp = new Resource[resources.length + 1];\n                        System.arraycopy(resources, 0, tmp, 0, resources.length);\n                        tmp[resources.length] = resource;\n                        resources = tmp;\n                    }\n                    m_unsatisfiedMap.put(reqs[reqIdx], resources);\n                }\n                else if (candidate != null)\n                {\n\n                    // Try to resolve the candidate.\n                    if (resolve(candidate))\n                    {\n                        // The resolved succeeded; record the candidate\n                        // as either optional or required.\n                        if (reqs[reqIdx].isOptional())\n                        {\n                            m_optionalSet.add(candidate);\n                        }\n                        else\n                        {\n                            m_requiredSet.add(candidate);\n                        }\n\n                        // Add the reason why the candidate was selected.\n                        addReason(candidate, reqs[reqIdx]);\n                    }\n                    else\n                    {\n                        result = false;\n                    }\n                }\n            }\n        }\n\n        // If the resolve failed, remove the resource from the resolve set and\n        // add it to the failed set to avoid trying to resolve it again.\n        if (!result)\n        {\n            m_resolveSet.remove(resource);\n            m_failedSet.add(resource);\n        }\n\n        return result;\n    }","id":29116,"modified_method":"private boolean resolve(Resource resource, Resource[] locals, Resource[] remotes)\n    {\n        boolean result = true;\n\n        // Check for cycles.\n        if (m_resolveSet.contains(resource))\n        {\n            return true;\n        }\n        else if (m_failedSet.contains(resource))\n        {\n            return false;\n        }\n\n        // Add to resolve map to avoid cycles.\n        m_resolveSet.add(resource);\n\n        // Resolve the requirements for the resource according to the\n        // search order of: added, resolving, local and finally remote\n        // resources.\n        Requirement[] reqs = resource.getRequirements();\n        if (reqs != null)\n        {\n            Resource candidate = null;\n            for (int reqIdx = 0; reqIdx < reqs.length; reqIdx++)\n            {\n                candidate = searchAddedResources(reqs[reqIdx]);\n                if (candidate == null)\n                {\n                    candidate = searchResolvingResources(reqs[reqIdx]);\n                    if (candidate == null)\n                    {\n                        List candidateCapabilities = searchResources(reqs[reqIdx], locals);\n                        candidateCapabilities.addAll(searchResources(reqs[reqIdx], remotes));\n\n                        // Determine the best candidate available that\n                        // can resolve.\n                        while ((candidate == null) && !candidateCapabilities.isEmpty())\n                        {\n                            Capability bestCapability = getBestCandidate(candidateCapabilities);\n\n                            // Try to resolve the best resource.\n                            if (resolve(((CapabilityImpl) bestCapability).getResource(), locals, remotes))\n                            {\n                                candidate = ((CapabilityImpl) bestCapability).getResource();\n                            }\n                            else\n                            {\n                                candidateCapabilities.remove(bestCapability);\n                            }\n                        }\n                    }\n                }\n\n                if ((candidate == null) && !reqs[reqIdx].isOptional())\n                {\n                    // The resolve failed.\n                    result = false;\n                    // Associated the current resource to the requirement\n                    // in the unsatisfied requirement map.\n                    Resource[] resources = (Resource[]) m_unsatisfiedMap.get(reqs[reqIdx]);\n                    if (resources == null)\n                    {\n                        resources = new Resource[] { resource };\n                    }\n                    else\n                    {\n                        Resource[] tmp = new Resource[resources.length + 1];\n                        System.arraycopy(resources, 0, tmp, 0, resources.length);\n                        tmp[resources.length] = resource;\n                        resources = tmp;\n                    }\n                    m_unsatisfiedMap.put(reqs[reqIdx], resources);\n                }\n                else if (candidate != null)\n                {\n\n                    // Try to resolve the candidate.\n                    if (resolve(candidate, locals, remotes))\n                    {\n                        // The resolved succeeded; record the candidate\n                        // as either optional or required.\n                        if (reqs[reqIdx].isOptional())\n                        {\n                            m_optionalSet.add(candidate);\n                        }\n                        else\n                        {\n                            m_requiredSet.add(candidate);\n                        }\n\n                        // Add the reason why the candidate was selected.\n                        addReason(candidate, reqs[reqIdx]);\n                    }\n                    else\n                    {\n                        result = false;\n                    }\n                }\n            }\n        }\n\n        // If the resolve failed, remove the resource from the resolve set and\n        // add it to the failed set to avoid trying to resolve it again.\n        if (!result)\n        {\n            m_resolveSet.remove(resource);\n            m_failedSet.add(resource);\n        }\n\n        return result;\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"private LocalResourceImpl findUpdatableLocalResource(Resource resource)\n    {\n        // Determine if any other versions of the specified resource\n        // already installed.\n        Resource[] localResources = findLocalResources(resource.getSymbolicName());\n        if (localResources != null)\n        {\n            // Since there are local resources with the same symbolic\n            // name installed, then we must determine if we can\n            // update an existing resource or if we must install\n            // another one. Loop through all local resources with same\n            // symbolic name and find the first one that can be updated\n            // without breaking constraints of existing local resources.\n            for (int i = 0; i < localResources.length; i++)\n            {\n                if (isResourceUpdatable(localResources[i], resource, m_local.getResources()))\n                {\n                    return (LocalResourceImpl) localResources[i];\n                }\n            }\n        }\n        return null;\n    }","id":29117,"modified_method":"private LocalResourceImpl findUpdatableLocalResource(Resource resource)\n    {\n        // Determine if any other versions of the specified resource\n        // already installed.\n        Resource[] localResources = findLocalResources(resource.getSymbolicName());\n        if (localResources != null)\n        {\n            // Since there are local resources with the same symbolic\n            // name installed, then we must determine if we can\n            // update an existing resource or if we must install\n            // another one. Loop through all local resources with same\n            // symbolic name and find the first one that can be updated\n            // without breaking constraints of existing local resources.\n            for (int i = 0; i < localResources.length; i++)\n            {\n                if (isResourceUpdatable(localResources[i], resource, localResources))\n                {\n                    return (LocalResourceImpl) localResources[i];\n                }\n            }\n        }\n        return null;\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"public ResolverImpl(BundleContext context, RepositoryAdminImpl admin, Logger logger)\n    {\n        m_context = context;\n        m_admin = admin;\n        m_logger = logger;\n        m_local = admin.getLocalRepository();        \n        String s = context.getProperty(PREFER_LOCAL);\n        if (s != null)\n        {\n            m_preferLocal = Boolean.parseBoolean(s);\n        }\n    }","id":29118,"modified_method":"public ResolverImpl(BundleContext context, Repository[] repositories, Logger logger)\n    {\n        m_context = context;\n        m_logger = logger;\n        m_repositories = repositories;\n        String s = context.getProperty(PREFER_LOCAL);\n        if (s != null)\n        {\n            m_preferLocal = Boolean.parseBoolean(s);\n        }\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Searches for remote resources that do meet the given requirement\n     * @param req\n     * @return all remote resources meeting the given requirement\n     */\n    private List searchRemoteResources(Requirement req)\n    {\n        List matchingCapabilities = new ArrayList();\n\n        Repository[] repos = m_admin.listRepositories();\n        for (int repoIdx = 0; (repos != null) && (repoIdx < repos.length); repoIdx++)\n        {\n            Resource[] resources = repos[repoIdx].getResources();\n            for (int resIdx = 0; (resources != null) && (resIdx < resources.length); resIdx++)\n            {\n                checkInterrupt();\n                // We don't need to look at resources we've already looked at.\n                if (!m_failedSet.contains(resources[resIdx])\n                    && !m_resolveSet.contains(resources[resIdx]))\n                {\n                    Capability[] caps = resources[resIdx].getCapabilities();\n                    for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n                    {\n                        if (caps[capIdx].getName().equals(req.getName())\n                                && req.isSatisfied(caps[capIdx]))\n                        {\n                            matchingCapabilities.add(caps[capIdx]);\n                        }\n                    }\n                }\n            }\n        }\n\n        return matchingCapabilities;\n    }","id":29119,"modified_method":"/**\n     * Searches for resources that do meet the given requirement\n     * @param req\n     * @return all resources meeting the given requirement\n     */\n    private List searchResources(Requirement req, Resource[] resources)\n    {\n        List matchingCapabilities = new ArrayList();\n\n        for (int repoIdx = 0; (m_repositories != null) && (repoIdx < m_repositories.length); repoIdx++)\n        {\n            for (int resIdx = 0; (resources != null) && (resIdx < resources.length); resIdx++)\n            {\n                checkInterrupt();\n                // We don't need to look at resources we've already looked at.\n                if (!m_failedSet.contains(resources[resIdx])\n                    && !m_resolveSet.contains(resources[resIdx]))\n                {\n                    Capability[] caps = resources[resIdx].getCapabilities();\n                    for (int capIdx = 0; (caps != null) && (capIdx < caps.length); capIdx++)\n                    {\n                        if (caps[capIdx].getName().equals(req.getName())\n                                && req.isSatisfied(caps[capIdx]))\n                        {\n                            matchingCapabilities.add(caps[capIdx]);\n                        }\n                    }\n                }\n            }\n        }\n\n        return matchingCapabilities;\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Returns all local resources with the given symbolic name.\n     * @param symName The symbolic name of the wanted local resources.\n     * @return The local resources with the specified symbolic name.\n     */\n    private Resource[] findLocalResources(String symName)\n    {\n        Resource[] localResources = m_local.getResources();\n\n        List matchList = new ArrayList();\n        for (int i = 0; i < localResources.length; i++)\n        {\n            String localSymName = localResources[i].getSymbolicName();\n            if ((localSymName != null) && localSymName.equals(symName))\n            {\n                matchList.add(localResources[i]);\n            }\n        }\n        return (Resource[]) matchList.toArray(new Resource[matchList.size()]);\n    }","id":29120,"modified_method":"/**\n     * Returns all local resources with the given symbolic name.\n     * @param symName The symbolic name of the wanted local resources.\n     * @return The local resources with the specified symbolic name.\n     */\n    private Resource[] findLocalResources(String symName)\n    {\n        Resource[] localResources = getResources(true);\n\n        List matchList = new ArrayList();\n        for (int i = 0; i < localResources.length; i++)\n        {\n            String localSymName = localResources[i].getSymbolicName();\n            if ((localSymName != null) && localSymName.equals(symName))\n            {\n                matchList.add(localResources[i]);\n            }\n        }\n        return (Resource[]) matchList.toArray(new Resource[matchList.size()]);\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"public synchronized void deploy(boolean start)\n    {\n        // Must resolve if not already resolved.\n        if (!m_resolved && !resolve())\n        {\n            m_logger.log(Logger.LOG_ERROR, \"Resolver: Cannot resolve target resources.\");\n            return;\n        }\n\n        // Check to make sure that our local state cache is up-to-date\n        // and error if it is not. This is not completely safe, because\n        // the state can still change during the operation, but we will\n        // be optimistic. This could also be made smarter so that it checks\n        // to see if the local state changes overlap with the resolver.\n        if (m_resolveTimeStamp != m_local.getLastModified())\n        {\n            throw new IllegalStateException(\"Framework state has changed, must resolve again.\");\n        }\n\n        // Eliminate duplicates from target, required, optional resources.\n        Map deployMap = new HashMap();\n        Resource[] resources = getAddedResources();\n        for (int i = 0; (resources != null) && (i < resources.length); i++)\n        {\n            deployMap.put(resources[i], resources[i]);\n        }\n        resources = getRequiredResources();\n        for (int i = 0; (resources != null) && (i < resources.length); i++)\n        {\n            deployMap.put(resources[i], resources[i]);\n        }\n        resources = getOptionalResources();\n        for (int i = 0; (resources != null) && (i < resources.length); i++)\n        {\n            deployMap.put(resources[i], resources[i]);\n        }\n        Resource[] deployResources = (Resource[])\n            deployMap.keySet().toArray(new Resource[deployMap.size()]);\n\n        // List to hold all resources to be started.\n        List startList = new ArrayList();\n\n        // Deploy each resource, which will involve either finding a locally\n        // installed resource to update or the installation of a new version\n        // of the resource to be deployed.\n        for (int i = 0; i < deployResources.length; i++)\n        {\n            // For the resource being deployed, see if there is an older\n            // version of the resource already installed that can potentially\n            // be updated.\n            LocalRepositoryImpl.LocalResourceImpl localResource =\n                findUpdatableLocalResource(deployResources[i]);\n            // If a potentially updatable older version was found,\n            // then verify that updating the local resource will not\n            // break any of the requirements of any of the other\n            // resources being deployed.\n            if ((localResource != null) &&\n                isResourceUpdatable(localResource, deployResources[i], deployResources))\n            {\n                // Only update if it is a different version.\n                if (!localResource.equals(deployResources[i]))\n                {\n                    // Update the installed bundle.\n                    try\n                    {\n                        // stop the bundle before updating to prevent\n                        // the bundle update from throwing due to not yet\n                        // resolved dependencies\n                        boolean doStartBundle = start;\n                        if (localResource.getBundle().getState() == Bundle.ACTIVE)\n                        {\n                            doStartBundle = true;\n                            localResource.getBundle().stop();\n                        }\n                        \n                        localResource.getBundle().update(deployResources[i].getURL().openStream());\n\n                        // If necessary, save the updated bundle to be\n                        // started later.\n                        if (doStartBundle)\n                        {\n                            Bundle bundle = localResource.getBundle();\n                            if (!isFragmentBundle(bundle)) \n                            {\n                                startList.add(bundle);\n                            }\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        m_logger.log(\n                            Logger.LOG_ERROR,\n                            \"Resolver: Update error - \" + Util.getBundleName(localResource.getBundle()),\n                            ex);\n                        return;\n                    }\n                }\n            }\n            else\n            {\n                // Install the bundle.\n                try\n                {\n                    // Perform the install, but do not use the actual\n                    // bundle JAR URL for the bundle location, since this will\n                    // limit OBR's ability to manipulate bundle versions. Instead,\n                    // use a unique timestamp as the bundle location.\n                    URL url = deployResources[i].getURL();\n                    if (url != null)\n                    {\n                        Bundle bundle = m_context.installBundle(\n                            \"obr://\"\n                            + deployResources[i].getSymbolicName()\n                            + \"/-\" + System.currentTimeMillis(),\n                            url.openStream());\n\n                        // If necessary, save the installed bundle to be\n                        // started later.\n                        if (start)\n                        {\n                            if (!isFragmentBundle(bundle)) \n                            {\n                                startList.add(bundle);    \n                            }\n                        }\n                    }\n                }\n                catch (Exception ex)\n                {\n                    m_logger.log(\n                        Logger.LOG_ERROR,\n                        \"Resolver: Install error - \" + deployResources[i].getSymbolicName(), \n                        ex);\n                    return;\n                }\n            }\n        }\n\n        for (int i = 0; i < startList.size(); i++)\n        {\n            try\n            {\n                ((Bundle) startList.get(i)).start();\n            }\n            catch (BundleException ex)\n            {\n                m_logger.log(\n                    Logger.LOG_ERROR,\n                    \"Resolver: Start error - \" + ((Bundle) startList.get(i)).getSymbolicName(),\n                    ex);\n            }\n        }\n    }","id":29121,"modified_method":"public synchronized void deploy(boolean start)\n    {\n        // Must resolve if not already resolved.\n        if (!m_resolved && !resolve())\n        {\n            m_logger.log(Logger.LOG_ERROR, \"Resolver: Cannot resolve target resources.\");\n            return;\n        }\n\n        // Check to make sure that our local state cache is up-to-date\n        // and error if it is not. This is not completely safe, because\n        // the state can still change during the operation, but we will\n        // be optimistic. This could also be made smarter so that it checks\n        // to see if the local state changes overlap with the resolver.\n        for (int repoIdx = 0; (m_repositories != null) && (repoIdx < m_repositories.length); repoIdx++)\n        {\n            if (m_repositories[repoIdx].isLocal()\n                    && m_repositories[repoIdx].getLastModified() > m_resolveTimeStamp)\n            {\n                throw new IllegalStateException(\"Framework state has changed, must resolve again.\");\n            }\n        }\n\n        // Eliminate duplicates from target, required, optional resources.\n        Map deployMap = new HashMap();\n        Resource[] resources = getAddedResources();\n        for (int i = 0; (resources != null) && (i < resources.length); i++)\n        {\n            deployMap.put(resources[i], resources[i]);\n        }\n        resources = getRequiredResources();\n        for (int i = 0; (resources != null) && (i < resources.length); i++)\n        {\n            deployMap.put(resources[i], resources[i]);\n        }\n        resources = getOptionalResources();\n        for (int i = 0; (resources != null) && (i < resources.length); i++)\n        {\n            deployMap.put(resources[i], resources[i]);\n        }\n        Resource[] deployResources = (Resource[])\n            deployMap.keySet().toArray(new Resource[deployMap.size()]);\n\n        // List to hold all resources to be started.\n        List startList = new ArrayList();\n\n        // Deploy each resource, which will involve either finding a locally\n        // installed resource to update or the installation of a new version\n        // of the resource to be deployed.\n        for (int i = 0; i < deployResources.length; i++)\n        {\n            // For the resource being deployed, see if there is an older\n            // version of the resource already installed that can potentially\n            // be updated.\n            LocalResourceImpl localResource =\n                findUpdatableLocalResource(deployResources[i]);\n            // If a potentially updatable older version was found,\n            // then verify that updating the local resource will not\n            // break any of the requirements of any of the other\n            // resources being deployed.\n            if ((localResource != null) &&\n                isResourceUpdatable(localResource, deployResources[i], deployResources))\n            {\n                // Only update if it is a different version.\n                if (!localResource.equals(deployResources[i]))\n                {\n                    // Update the installed bundle.\n                    try\n                    {\n                        // stop the bundle before updating to prevent\n                        // the bundle update from throwing due to not yet\n                        // resolved dependencies\n                        boolean doStartBundle = start;\n                        if (localResource.getBundle().getState() == Bundle.ACTIVE)\n                        {\n                            doStartBundle = true;\n                            localResource.getBundle().stop();\n                        }\n                        \n                        localResource.getBundle().update(deployResources[i].getURL().openStream());\n\n                        // If necessary, save the updated bundle to be\n                        // started later.\n                        if (doStartBundle)\n                        {\n                            Bundle bundle = localResource.getBundle();\n                            if (!isFragmentBundle(bundle)) \n                            {\n                                startList.add(bundle);\n                            }\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        m_logger.log(\n                            Logger.LOG_ERROR,\n                            \"Resolver: Update error - \" + Util.getBundleName(localResource.getBundle()),\n                            ex);\n                        return;\n                    }\n                }\n            }\n            else\n            {\n                // Install the bundle.\n                try\n                {\n                    // Perform the install, but do not use the actual\n                    // bundle JAR URL for the bundle location, since this will\n                    // limit OBR's ability to manipulate bundle versions. Instead,\n                    // use a unique timestamp as the bundle location.\n                    URL url = deployResources[i].getURL();\n                    if (url != null)\n                    {\n                        Bundle bundle = m_context.installBundle(\n                            \"obr://\"\n                            + deployResources[i].getSymbolicName()\n                            + \"/-\" + System.currentTimeMillis(),\n                            url.openStream());\n\n                        // If necessary, save the installed bundle to be\n                        // started later.\n                        if (start)\n                        {\n                            if (!isFragmentBundle(bundle)) \n                            {\n                                startList.add(bundle);    \n                            }\n                        }\n                    }\n                }\n                catch (Exception ex)\n                {\n                    m_logger.log(\n                        Logger.LOG_ERROR,\n                        \"Resolver: Install error - \" + deployResources[i].getSymbolicName(), \n                        ex);\n                    return;\n                }\n            }\n        }\n\n        for (int i = 0; i < startList.size(); i++)\n        {\n            try\n            {\n                ((Bundle) startList.get(i)).start();\n            }\n            catch (BundleException ex)\n            {\n                m_logger.log(\n                    Logger.LOG_ERROR,\n                    \"Resolver: Start error - \" + ((Bundle) startList.get(i)).getSymbolicName(),\n                    ex);\n            }\n        }\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"public synchronized boolean resolve()\n    {\n        // time of the resolution process start\n        m_resolveTimeStamp = m_local.getLastModified();\n\n        // Reset instance values.\n        m_failedSet.clear();\n        m_resolveSet.clear();\n        m_requiredSet.clear();\n        m_optionalSet.clear();\n        m_reasonMap.clear();\n        m_unsatisfiedMap.clear();\n        m_resolved = true;\n\n        boolean result = true;\n\n        // Add a fake resource if needed\n        if (!m_addedRequirementSet.isEmpty())\n        {\n            ResourceImpl fake = new ResourceImpl();\n            for (Iterator iter = m_addedRequirementSet.iterator(); iter.hasNext(); )\n            {\n                fake.addRequire((Requirement) iter.next());\n            }\n            if (!resolve(fake))\n            {\n                result = false;\n            }\n        }\n\n        // Loop through each resource in added list and resolve.\n        for (Iterator iter = m_addedSet.iterator(); iter.hasNext(); )\n        {\n            if (!resolve((Resource) iter.next()))\n            {\n                // If any resource does not resolve, then the\n                // entire result will be false.\n                result = false;\n            }\n        }\n\n        // Clean up the resulting data structures.\n        List locals = Arrays.asList(m_local.getResources());\n        m_requiredSet.removeAll(m_addedSet);\n        m_requiredSet.removeAll(locals);\n        m_optionalSet.removeAll(m_addedSet);\n        m_optionalSet.removeAll(m_requiredSet);\n        m_optionalSet.removeAll(locals);\n\n        // Return final result.\n        return result;\n    }","id":29122,"modified_method":"public synchronized boolean resolve()\n    {\n        // Find resources\n        Resource[] locals = getResources(true);\n        Resource[] remotes = getResources(false);\n\n        // time of the resolution process start\n        m_resolveTimeStamp = 0;\n        for (int repoIdx = 0; (m_repositories != null) && (repoIdx < m_repositories.length); repoIdx++)\n        {\n            if (m_repositories[repoIdx].isLocal())\n            {\n                m_resolveTimeStamp = Math.max(m_resolveTimeStamp, m_repositories[repoIdx].getLastModified());\n            }\n        }\n\n        // Reset instance values.\n        m_failedSet.clear();\n        m_resolveSet.clear();\n        m_requiredSet.clear();\n        m_optionalSet.clear();\n        m_reasonMap.clear();\n        m_unsatisfiedMap.clear();\n        m_resolved = true;\n\n        boolean result = true;\n\n        // Add a fake resource if needed\n        if (!m_addedRequirementSet.isEmpty())\n        {\n            ResourceImpl fake = new ResourceImpl();\n            for (Iterator iter = m_addedRequirementSet.iterator(); iter.hasNext(); )\n            {\n                fake.addRequire((Requirement) iter.next());\n            }\n            if (!resolve(fake, locals, remotes))\n            {\n                result = false;\n            }\n        }\n\n        // Loop through each resource in added list and resolve.\n        for (Iterator iter = m_addedSet.iterator(); iter.hasNext(); )\n        {\n            if (!resolve((Resource) iter.next(), locals, remotes))\n            {\n                // If any resource does not resolve, then the\n                // entire result will be false.\n                result = false;\n            }\n        }\n\n        // Clean up the resulting data structures.\n        m_requiredSet.removeAll(m_addedSet);\n        m_requiredSet.removeAll(Arrays.asList(locals));\n        m_optionalSet.removeAll(m_addedSet);\n        m_optionalSet.removeAll(m_requiredSet);\n        m_optionalSet.removeAll(Arrays.asList(locals));\n\n        // Return final result.\n        return result;\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"public void testReferral1() throws Exception\n    {\n\n        URL url = getClass().getResource(\"/repo_for_resolvertest.xml\");\n        RepositoryAdminImpl repoAdmin = createRepositoryAdmin();\n        RepositoryImpl repo = (RepositoryImpl) repoAdmin.addRepository(url);\n\n        Resolver resolver = repoAdmin.resolver();\n\n        Resource r = null;\n        //MockContext doesn't support filtering!\n        Resource[] discoverResources = repoAdmin.discoverResources(\"\");\n        for (int i = 0; i < discoverResources.length; i++)\n        {\n            Resource resource = discoverResources[i];\n            if (resource.getSymbolicName().contains(\"org.apache.felix.test\"))\n            {\n                r = resource;\n            }\n        }\n\n        resolver.add(r);\n        assertTrue(resolver.resolve());\n    }","id":29123,"modified_method":"public void testReferral1() throws Exception\n    {\n\n        URL url = getClass().getResource(\"/repo_for_resolvertest.xml\");\n        RepositoryAdminImpl repoAdmin = createRepositoryAdmin();\n        RepositoryImpl repo = (RepositoryImpl) repoAdmin.addRepository(url);\n\n        Resolver resolver = repoAdmin.resolver();\n\n        Resource[] discoverResources = repoAdmin.discoverResources(\"(symbolicname=org.apache.felix.test*)\");\n        assertNotNull(discoverResources);\n        assertEquals(1, discoverResources.length);\n\n        resolver.add(discoverResources[0]);\n        assertTrue(resolver.resolve());\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"private RepositoryAdminImpl createRepositoryAdmin()\n    {\n        final MockBundleContext bundleContext = new MockBundleContext();\n        bundleContext.setProperty(RepositoryAdminImpl.REPOSITORY_URL_PROP,\n                                  getClass().getResource(\"/referred.xml\").toExternalForm());\n        RepositoryAdminImpl repoAdmin = new RepositoryAdminImpl(bundleContext, new Logger(bundleContext));\n\n        // force initialization && remove all initial repositories\n        Repository[] repos = repoAdmin.listRepositories();\n        for (int i = 0; repos != null && i < repos.length; i++)\n        {\n            repoAdmin.removeRepository(repos[i].getURL());\n        }\n\n        return repoAdmin;\n    }","id":29124,"modified_method":"private RepositoryAdminImpl createRepositoryAdmin() throws Exception\n    {\n        BundleContext bundleContext = (BundleContext) EasyMock.createMock(BundleContext.class);\n        Bundle systemBundle = (Bundle) EasyMock.createMock(Bundle.class);\n\n        EasyMock.expect(bundleContext.getProperty(RepositoryAdminImpl.REPOSITORY_URL_PROP))\n                    .andReturn(getClass().getResource(\"/referred.xml\").toExternalForm());\n        EasyMock.expect(bundleContext.getProperty((String) EasyMock.anyObject())).andReturn(null).anyTimes();\n        EasyMock.expect(bundleContext.getBundle(0)).andReturn(systemBundle);\n        EasyMock.expect(systemBundle.getHeaders()).andReturn(new Hashtable());\n        EasyMock.expect(systemBundle.getRegisteredServices()).andReturn(null);\n        EasyMock.expect(new Long(systemBundle.getBundleId())).andReturn(new Long(0)).anyTimes();\n        EasyMock.expect(systemBundle.getBundleContext()).andReturn(bundleContext);\n        bundleContext.addBundleListener((BundleListener) EasyMock.anyObject());\n        bundleContext.addServiceListener((ServiceListener) EasyMock.anyObject());\n        EasyMock.expect(bundleContext.getBundles()).andReturn(new Bundle[] { systemBundle });\n        final Capture c = new Capture();\n        EasyMock.expect(bundleContext.createFilter((String) capture(c))).andAnswer(new IAnswer() {\n            public Object answer() throws Throwable {\n                return new FilterImpl((String) c.getValue());\n            }\n        }).anyTimes();\n        EasyMock.replay(new Object[] { bundleContext, systemBundle });\n\n        RepositoryAdminImpl repoAdmin = new RepositoryAdminImpl(bundleContext, new Logger(bundleContext));\n\n        // force initialization && remove all initial repositories\n        Repository[] repos = repoAdmin.listRepositories();\n        for (int i = 0; repos != null && i < repos.length; i++)\n        {\n            repoAdmin.removeRepository(repos[i].getURL());\n        }\n\n        return repoAdmin;\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"public void testStaxParser() throws Exception\n    {\n        URL url = getClass().getResource(\"/repo_for_resolvertest.xml\");\n        RepositoryAdminImpl repoAdmin = createRepositoryAdmin(StaxParser.class);\n        RepositoryImpl repo = (RepositoryImpl) repoAdmin.addRepository(url);\n\n        Resolver resolver = repoAdmin.resolver();\n\n        Resource r = null;\n        //MockContext doesn't support filtering!\n        Resource[] discoverResources = repoAdmin.discoverResources(\"\");\n        for (int i = 0; i < discoverResources.length; i++)\n        {\n            Resource resource = discoverResources[i];\n            if (resource.getSymbolicName().contains(\"org.apache.felix.test\"))\n            {\n                r = resource;\n            }\n        }\n        assertNotNull(r);\n\n        resolver.add(r);\n        assertTrue(resolver.resolve());\n    }","id":29125,"modified_method":"public void testStaxParser() throws Exception\n    {\n        URL url = getClass().getResource(\"/repo_for_resolvertest.xml\");\n        RepositoryAdminImpl repoAdmin = createRepositoryAdmin(StaxParser.class);\n        RepositoryImpl repo = (RepositoryImpl) repoAdmin.addRepository(url);\n\n        Resolver resolver = repoAdmin.resolver();\n\n        Resource[] discoverResources = repoAdmin.discoverResources(\"(symbolicname=org.apache.felix.test*)\");\n        assertNotNull(discoverResources);\n        assertEquals(1, discoverResources.length);\n\n        resolver.add(discoverResources[0]);\n        assertTrue(resolver.resolve());\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"private RepositoryAdminImpl createRepositoryAdmin(Class repositoryParser)\n    {\n        final MockBundleContext bundleContext = new MockBundleContext();\n        bundleContext.setProperty(RepositoryAdminImpl.REPOSITORY_URL_PROP,\n            getClass().getResource(\"/referral1_repository.xml\").toExternalForm());\n        bundleContext.setProperty(RepositoryImpl.OBR_PARSER_CLASS,\n            repositoryParser.getName());\n        RepositoryAdminImpl repoAdmin = new RepositoryAdminImpl(bundleContext, new Logger(bundleContext));\n\n        // force initialization && remove all initial repositories\n        Repository[] repos = repoAdmin.listRepositories();\n        for (int i = 0; repos != null && i < repos.length; i++)\n        {\n            repoAdmin.removeRepository(repos[i].getURL());\n        }\n\n        return repoAdmin;\n    }","id":29126,"modified_method":"private RepositoryAdminImpl createRepositoryAdmin(Class repositoryParser) throws Exception\n    {\n        BundleContext bundleContext = (BundleContext) EasyMock.createMock(BundleContext.class);\n        Bundle systemBundle = (Bundle) EasyMock.createMock(Bundle.class);\n\n        EasyMock.expect(bundleContext.getProperty(RepositoryAdminImpl.REPOSITORY_URL_PROP))\n                    .andReturn(getClass().getResource(\"/referral1_repository.xml\").toExternalForm());\n        EasyMock.expect(bundleContext.getProperty(RepositoryImpl.OBR_PARSER_CLASS))\n                    .andReturn(repositoryParser.getName());\n        EasyMock.expect(bundleContext.getProperty((String) EasyMock.anyObject())).andReturn(null).anyTimes();\n        EasyMock.expect(bundleContext.getBundle(0)).andReturn(systemBundle);\n        EasyMock.expect(systemBundle.getHeaders()).andReturn(new Hashtable());\n        EasyMock.expect(systemBundle.getRegisteredServices()).andReturn(null);\n        EasyMock.expect(new Long(systemBundle.getBundleId())).andReturn(new Long(0)).anyTimes();\n        EasyMock.expect(systemBundle.getBundleContext()).andReturn(bundleContext);\n        bundleContext.addBundleListener((BundleListener) EasyMock.anyObject());\n        bundleContext.addServiceListener((ServiceListener) EasyMock.anyObject());\n        EasyMock.expect(bundleContext.getBundles()).andReturn(new Bundle[] { systemBundle });\n        final Capture c = new Capture();\n        EasyMock.expect(bundleContext.createFilter((String) capture(c))).andAnswer(new IAnswer() {\n            public Object answer() throws Throwable {\n                return new FilterImpl((String) c.getValue());\n            }\n        }).anyTimes();\n        EasyMock.replay(new Object[] { bundleContext, systemBundle });\n\n        RepositoryAdminImpl repoAdmin = new RepositoryAdminImpl(bundleContext, new Logger(bundleContext));\n\n        // force initialization && remove all initial repositories\n        Repository[] repos = repoAdmin.listRepositories();\n        for (int i = 0; repos != null && i < repos.length; i++)\n        {\n            repoAdmin.removeRepository(repos[i].getURL());\n        }\n\n        return repoAdmin;\n    }","commit_id":"66b87bd804356d18f8390bf279e628718796f251","url":"https://github.com/apache/felix"},{"original_method":"protected void checkJavaFieldType(\n\t\t\tJavaTerm javaTerm, Set<String> annotationsExclusions,\n\t\t\tSet<String> immutableFieldTypes)\n\t\tthrows Exception {\n\n\t\tif (!BaseSourceProcessor.portalSource || !javaTerm.isVariable()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString javaTermName = javaTerm.getName();\n\n\t\tPattern pattern = Pattern.compile(\n\t\t\t\"\\t(private |protected |public )\" +\n\t\t\t\t\"(((final|static|transient)( |\\n))*)([\\\\s\\\\S]*?)\" +\n\t\t\t\t\tjavaTermName);\n\n\t\tString javaTermContent = javaTerm.getContent();\n\n\t\tMatcher matcher = pattern.matcher(javaTermContent);\n\n\t\tif (!matcher.find()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (javaTerm.isPrivate() && !javaTermName.equals(\"serialVersionUID\") &&\n\t\t\t(javaTermName.charAt(0) != CharPool.UNDERLINE)) {\n\n\t\t\t_content = _content.replaceAll(\n\t\t\t\t\"(?<=[\\\\W&&[^.\\\"]])(\" + javaTermName + \")\\\\b\",\n\t\t\t\tStringPool.UNDERLINE.concat(javaTermName));\n\t\t}\n\n\t\tString modifierDefinition = StringUtil.trim(\n\t\t\tjavaTermContent.substring(matcher.start(1), matcher.start(6)));\n\n\t\tboolean isFinal = modifierDefinition.contains(\"final\");\n\t\tboolean isStatic = modifierDefinition.contains(\"static\");\n\t\tString javaFieldType = StringUtil.trim(matcher.group(6));\n\n\t\tif (isFinal && isStatic && javaFieldType.startsWith(\"Map<\")) {\n\t\t\tcheckMutableFieldType(javaTerm);\n\t\t}\n\n\t\tif (!javaTerm.isPrivate()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isFinal) {\n\t\t\tif (immutableFieldTypes.contains(javaFieldType)) {\n\t\t\t\tif (isStatic) {\n\t\t\t\t\tcheckImmutableFieldType(javaTerm);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcheckStaticableFieldType(javaTerm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcheckFinalableFieldType(\n\t\t\t\tjavaTerm, annotationsExclusions, modifierDefinition);\n\t\t}\n\t}","id":29127,"modified_method":"protected void checkJavaFieldType(\n\t\t\tJavaTerm javaTerm, Set<String> annotationsExclusions,\n\t\t\tSet<String> immutableFieldTypes)\n\t\tthrows Exception {\n\n\t\tif (!BaseSourceProcessor.portalSource || !javaTerm.isVariable()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString javaTermName = javaTerm.getName();\n\n\t\tPattern pattern = Pattern.compile(\n\t\t\t\"\\t(private |protected |public )\" +\n\t\t\t\t\"(((final|static|transient)( |\\n))*)([\\\\s\\\\S]*?)\" +\n\t\t\t\t\tjavaTermName);\n\n\t\tString javaTermContent = javaTerm.getContent();\n\n\t\tMatcher matcher = pattern.matcher(javaTermContent);\n\n\t\tif (!matcher.find()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ((javaTerm.isPrivate() && !javaTermName.equals(\"serialVersionUID\")) ^\n\t\t\t(javaTermName.charAt(0) == CharPool.UNDERLINE)) {\n\n\t\t\tif (javaTerm.isPrivate()) {\n\t\t\t\t_content = _content.replaceAll(\n\t\t\t\t\t\"(?<=[\\\\W&&[^.\\\"]])(\" + javaTermName + \")\\\\b\",\n\t\t\t\t\tStringPool.UNDERLINE.concat(javaTermName));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_javaSourceProcessor.processErrorMessage(\n\t\t\t\t\t_fileName,\n\t\t\t\t\t\"Only private var should start with underscore: \" +\n\t\t\t\t\t\t_fileName + \" \" + javaTerm.getLineCount());\n\t\t\t}\n\t\t}\n\n\t\tString modifierDefinition = StringUtil.trim(\n\t\t\tjavaTermContent.substring(matcher.start(1), matcher.start(6)));\n\n\t\tboolean isFinal = modifierDefinition.contains(\"final\");\n\t\tboolean isStatic = modifierDefinition.contains(\"static\");\n\t\tString javaFieldType = StringUtil.trim(matcher.group(6));\n\n\t\tif (isFinal && isStatic && javaFieldType.startsWith(\"Map<\")) {\n\t\t\tcheckMutableFieldType(javaTerm);\n\t\t}\n\n\t\tif (!javaTerm.isPrivate()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isFinal) {\n\t\t\tif (immutableFieldTypes.contains(javaFieldType)) {\n\t\t\t\tif (isStatic) {\n\t\t\t\t\tcheckImmutableFieldType(javaTerm);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcheckStaticableFieldType(javaTerm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcheckFinalableFieldType(\n\t\t\t\tjavaTerm, annotationsExclusions, modifierDefinition);\n\t\t}\n\t}","commit_id":"d325d8b87c330fe5c7ea944ca527eda7be2deeaf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static int getFlagsForVisibility(@NotNull Visibility visibility) {\n        if (visibility == Visibilities.INTERNAL) {\n            return JvmStdlibNames.FLAG_INTERNAL_BIT;\n        }\n        else if (visibility == Visibilities.PRIVATE) {\n            return JvmStdlibNames.FLAG_PRIVATE_BIT;\n        }\n        return 0;\n    }","id":29128,"modified_method":"public static int getFlagsForVisibility(@NotNull Visibility visibility) {\n        if (visibility == Visibilities.INTERNAL) {\n            return JvmStdlibNames.FLAG_INTERNAL_BIT;\n        }\n        else if (visibility == Visibilities.PRIVATE) {\n            return JvmStdlibNames.FLAG_PRIVATE_BIT;\n        }\n        else if (visibility == Visibilities.PROTECTED) {\n            return JvmStdlibNames.FLAG_PROTECTED_BIT;\n        }\n        return 0;\n    }","commit_id":"86f5114b7da30f8227dd29fd58ba029b46bfd3e3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static Visibility resolveVisibility(\n            @NotNull PsiModifierListOwner modifierListOwner,\n            @Nullable PsiAnnotationWithFlags annotation\n    ) {\n        if (annotation != null) {\n            if (annotation.hasPrivateFlag()) {\n                return Visibilities.PRIVATE;\n            }\n            else if (annotation.hasInternalFlag()) {\n                return Visibilities.INTERNAL;\n            }\n        }\n\n        if (modifierListOwner.hasModifierProperty(PsiModifier.PUBLIC)) {\n            return Visibilities.PUBLIC;\n        }\n        if (modifierListOwner.hasModifierProperty(PsiModifier.PRIVATE)) {\n            return Visibilities.PRIVATE;\n        }\n        if (modifierListOwner.hasModifierProperty(PsiModifier.PROTECTED)) {\n            if (modifierListOwner.hasModifierProperty(PsiModifier.STATIC)) {\n                return JavaDescriptorResolver.PROTECTED_STATIC_VISIBILITY;\n            }\n            return JavaDescriptorResolver.PROTECTED_AND_PACKAGE;\n        }\n        return JavaDescriptorResolver.PACKAGE_VISIBILITY;\n    }","id":29129,"modified_method":"public static Visibility resolveVisibility(\n            @NotNull PsiModifierListOwner modifierListOwner,\n            @Nullable PsiAnnotationWithFlags annotation\n    ) {\n        if (annotation != null) {\n            if (annotation.hasPrivateFlag()) {\n                return Visibilities.PRIVATE;\n            }\n            else if (annotation.hasInternalFlag()) {\n                return Visibilities.INTERNAL;\n            }\n            else if (annotation.hasProtectedFlag()) {\n                return Visibilities.PROTECTED;\n            }\n        }\n\n        if (modifierListOwner.hasModifierProperty(PsiModifier.PUBLIC)) {\n            return Visibilities.PUBLIC;\n        }\n        if (modifierListOwner.hasModifierProperty(PsiModifier.PRIVATE)) {\n            return Visibilities.PRIVATE;\n        }\n        if (modifierListOwner.hasModifierProperty(PsiModifier.PROTECTED)) {\n            if (modifierListOwner.hasModifierProperty(PsiModifier.STATIC)) {\n                return JavaDescriptorResolver.PROTECTED_STATIC_VISIBILITY;\n            }\n            return JavaDescriptorResolver.PROTECTED_AND_PACKAGE;\n        }\n        return JavaDescriptorResolver.PACKAGE_VISIBILITY;\n    }","commit_id":"86f5114b7da30f8227dd29fd58ba029b46bfd3e3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private PropertyGetterDescriptorImpl resolveGetter(\n            Visibility visibility,\n            CallableMemberDescriptor.Kind kind,\n            PropertyPsiDataElement getter,\n            PropertyDescriptor propertyDescriptor\n    ) {\n        if (getter == null) {\n            return null;\n        }\n        return new PropertyGetterDescriptorImpl(\n                propertyDescriptor,\n                annotationResolver.resolveAnnotations(getter.getMember().getPsiMember()),\n                Modality.OPEN,\n                visibility,\n                true,\n                false,\n                kind);\n    }","id":29130,"modified_method":"@Nullable\n    private PropertyGetterDescriptorImpl resolveGetter(\n            Visibility visibility,\n            CallableMemberDescriptor.Kind kind,\n            PropertyPsiDataElement getter,\n            PropertyDescriptor propertyDescriptor\n    ) {\n        if (getter == null) {\n            return null;\n        }\n        return new PropertyGetterDescriptorImpl(\n                propertyDescriptor,\n                annotationResolver.resolveAnnotations(getter.getMember().getPsiMember()),\n                propertyDescriptor.getModality(),\n                visibility,\n                true,\n                false,\n                kind);\n    }","commit_id":"86f5114b7da30f8227dd29fd58ba029b46bfd3e3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private PropertyDescriptor resolveProperty(\n            @NotNull ClassOrNamespaceDescriptor owner,\n            @NotNull PsiDeclarationProvider scopeData,\n            @NotNull Name propertyName,\n            @NotNull String context,\n            @NotNull PropertyPsiData psiData\n    ) {\n        boolean isFinal = isPropertyFinal(scopeData, psiData);\n        boolean isVar = psiData.isVar();\n\n        PropertyPsiDataElement characteristicMember = psiData.getCharacteristicMember();\n\n        Visibility visibility = DescriptorResolverUtils.resolveVisibility(psiData.getCharacteristicPsi(), null);\n        CallableMemberDescriptor.Kind kind = CallableMemberDescriptor.Kind.DECLARATION;\n\n        PropertyPsiDataElement getter = psiData.getGetter();\n        if (getter != null) {\n            JetMethodAnnotation methodAnnotation = ((PsiMethodWrapper) getter.getMember()).getJetMethodAnnotation();\n            visibility = DescriptorResolverUtils.resolveVisibility(psiData.getCharacteristicPsi(), methodAnnotation);\n            kind = DescriptorKindUtils.flagsToKind(methodAnnotation.kind());\n        }\n\n        boolean isEnumEntry = psiData.getCharacteristicPsi() instanceof PsiEnumConstant;\n        PropertyDescriptorImpl propertyDescriptor = new PropertyDescriptorImpl(\n                owner,\n                annotationResolver.resolveAnnotations(psiData.getCharacteristicPsi()),\n                DescriptorResolverUtils.resolveModality(characteristicMember.getMember(),\n                                                        isFinal || isEnumEntry || psiData.isPropertyForNamedObject()),\n                visibility,\n                isVar,\n                propertyName,\n                kind);\n\n        //TODO: this is a hack to indicate that this enum entry is an object\n        // class descriptor for enum entries is not used by backends so for now this should be safe to use\n        // remove this when JavaDescriptorResolver gets rewritten\n        if (isEnumEntry) {\n            assert DescriptorUtils.isEnumClassObject(owner) : \"Enum entries should be put into class object of enum only: \" + owner;\n            ClassDescriptorImpl dummyClassDescriptorForEnumEntryObject =\n                    new ClassDescriptorImpl(owner, Collections.<AnnotationDescriptor>emptyList(), Modality.FINAL, propertyName);\n            dummyClassDescriptorForEnumEntryObject.initialize(\n                    true,\n                    Collections.<TypeParameterDescriptor>emptyList(),\n                    Collections.<JetType>emptyList(), JetScope.EMPTY,\n                    Collections.<ConstructorDescriptor>emptySet(), null,\n                    false);\n            trace.record(BindingContext.OBJECT_DECLARATION_CLASS, propertyDescriptor, dummyClassDescriptorForEnumEntryObject);\n        }\n\n        PropertyGetterDescriptorImpl getterDescriptor = resolveGetter(visibility, kind, getter, propertyDescriptor);\n        PropertySetterDescriptorImpl setterDescriptor = resolveSetter(psiData, kind, propertyDescriptor);\n\n        propertyDescriptor.initialize(getterDescriptor, setterDescriptor);\n\n        List<TypeParameterDescriptor> typeParameters = resolvePropertyTypeParameters(psiData, characteristicMember, propertyDescriptor);\n\n        TypeVariableResolver typeVariableResolverForPropertyInternals = TypeVariableResolvers.typeVariableResolverFromTypeParameters(\n                typeParameters, propertyDescriptor, \"property \" + propertyName + \" in \" + context);\n\n        JetType propertyType = getPropertyType(psiData, characteristicMember, typeVariableResolverForPropertyInternals);\n        JetType receiverType = getReceiverType(characteristicMember, typeVariableResolverForPropertyInternals);\n\n\n        propertyType = getAlternativeSignatureData(isVar, characteristicMember, propertyDescriptor, propertyType);\n\n        propertyDescriptor.setType(\n                propertyType,\n                typeParameters,\n                DescriptorUtils.getExpectedThisObjectIfNeeded(owner),\n                receiverType\n        );\n        initializeSetterAndGetter(propertyDescriptor, getterDescriptor, setterDescriptor, propertyType);\n\n        if (kind == CallableMemberDescriptor.Kind.DECLARATION) {\n            trace.record(BindingContext.VARIABLE, psiData.getCharacteristicPsi(), propertyDescriptor);\n        }\n\n        recordObjectDeclarationClassIfNeeded(psiData, owner, propertyDescriptor, propertyType);\n\n        if (scopeData.getDeclarationOrigin() == JAVA) {\n            trace.record(BindingContext.IS_DECLARED_IN_JAVA, propertyDescriptor);\n        }\n        return propertyDescriptor;\n    }","id":29131,"modified_method":"@NotNull\n    private PropertyDescriptor resolveProperty(\n            @NotNull ClassOrNamespaceDescriptor owner,\n            @NotNull PsiDeclarationProvider scopeData,\n            @NotNull Name propertyName,\n            @NotNull String context,\n            @NotNull PropertyPsiData psiData\n    ) {\n        boolean isFinal = isPropertyFinal(scopeData, psiData);\n        boolean isVar = psiData.isVar();\n\n        PropertyPsiDataElement characteristicMember = psiData.getCharacteristicMember();\n\n        Visibility visibility = DescriptorResolverUtils.resolveVisibility(psiData.getCharacteristicPsi(), null);\n        CallableMemberDescriptor.Kind kind = CallableMemberDescriptor.Kind.DECLARATION;\n\n        PropertyPsiDataElement getter = psiData.getGetter();\n        if (getter != null) {\n            JetMethodAnnotation methodAnnotation = ((PsiMethodWrapper) getter.getMember()).getJetMethodAnnotation();\n            visibility = DescriptorResolverUtils.resolveVisibility(psiData.getCharacteristicPsi(), methodAnnotation);\n            kind = DescriptorKindUtils.flagsToKind(methodAnnotation.kind());\n        }\n\n        boolean isEnumEntry = psiData.getCharacteristicPsi() instanceof PsiEnumConstant;\n        PropertyDescriptorImpl propertyDescriptor = new PropertyDescriptorImpl(\n                owner,\n                annotationResolver.resolveAnnotations(psiData.getCharacteristicPsi()),\n                DescriptorResolverUtils.resolveModality(characteristicMember.getMember(),\n                                                        isFinal || isEnumEntry || psiData.isPropertyForNamedObject()),\n                visibility,\n                isVar,\n                propertyName,\n                kind);\n\n        //TODO: this is a hack to indicate that this enum entry is an object\n        // class descriptor for enum entries is not used by backends so for now this should be safe to use\n        // remove this when JavaDescriptorResolver gets rewritten\n        if (isEnumEntry) {\n            assert DescriptorUtils.isEnumClassObject(owner) : \"Enum entries should be put into class object of enum only: \" + owner;\n            ClassDescriptorImpl dummyClassDescriptorForEnumEntryObject =\n                    new ClassDescriptorImpl(owner, Collections.<AnnotationDescriptor>emptyList(), Modality.FINAL, propertyName);\n            dummyClassDescriptorForEnumEntryObject.initialize(\n                    true,\n                    Collections.<TypeParameterDescriptor>emptyList(),\n                    Collections.<JetType>emptyList(), JetScope.EMPTY,\n                    Collections.<ConstructorDescriptor>emptySet(), null,\n                    false);\n            trace.record(BindingContext.OBJECT_DECLARATION_CLASS, propertyDescriptor, dummyClassDescriptorForEnumEntryObject);\n        }\n\n        PropertyGetterDescriptorImpl getterDescriptor = resolveGetter(visibility, kind, getter, propertyDescriptor);\n        PropertySetterDescriptorImpl setterDescriptor = resolveSetter(psiData, kind, propertyDescriptor);\n\n        propertyDescriptor.initialize(getterDescriptor, setterDescriptor);\n\n        List<TypeParameterDescriptor> typeParameters = resolvePropertyTypeParameters(psiData, characteristicMember, propertyDescriptor);\n\n        TypeVariableResolver typeVariableResolverForPropertyInternals = TypeVariableResolvers.typeVariableResolverFromTypeParameters(\n                typeParameters, propertyDescriptor, \"property \" + propertyName + \" in \" + context);\n\n        JetType propertyType = getPropertyType(psiData, characteristicMember, typeVariableResolverForPropertyInternals);\n        JetType receiverType = getReceiverType(characteristicMember, typeVariableResolverForPropertyInternals);\n\n\n        propertyType = getAlternativeSignatureData(isVar, characteristicMember, propertyDescriptor, propertyType);\n\n        propertyDescriptor.setType(\n                propertyType,\n                typeParameters,\n                DescriptorUtils.getExpectedThisObjectIfNeeded(owner),\n                receiverType\n        );\n        initializeSetterAndGetter(propertyDescriptor, getterDescriptor, setterDescriptor, propertyType, psiData);\n\n        if (kind == CallableMemberDescriptor.Kind.DECLARATION) {\n            trace.record(BindingContext.VARIABLE, psiData.getCharacteristicPsi(), propertyDescriptor);\n        }\n\n        recordObjectDeclarationClassIfNeeded(psiData, owner, propertyDescriptor, propertyType);\n\n        if (scopeData.getDeclarationOrigin() == JAVA) {\n            trace.record(BindingContext.IS_DECLARED_IN_JAVA, propertyDescriptor);\n        }\n        return propertyDescriptor;\n    }","commit_id":"86f5114b7da30f8227dd29fd58ba029b46bfd3e3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private PropertySetterDescriptorImpl resolveSetter(\n            PropertyPsiData psiData,\n            CallableMemberDescriptor.Kind kind,\n            PropertyDescriptor propertyDescriptor\n    ) {\n        PropertyPsiDataElement setter = psiData.getSetter();\n        if (setter == null) {\n            return null;\n        }\n        Visibility setterVisibility = DescriptorResolverUtils.resolveVisibility(setter.getMember().getPsiMember(), null);\n        if (setter.getMember() instanceof PsiMethodWrapper) {\n            setterVisibility = DescriptorResolverUtils.resolveVisibility(\n                    setter.getMember().getPsiMember(),\n                    ((PsiMethodWrapper) setter.getMember())\n                            .getJetMethodAnnotation());\n        }\n        return new PropertySetterDescriptorImpl(\n                propertyDescriptor,\n                annotationResolver.resolveAnnotations(setter.getMember().getPsiMember()),\n                Modality.OPEN,\n                setterVisibility,\n                true,\n                false,\n                kind);\n    }","id":29132,"modified_method":"@Nullable\n    private PropertySetterDescriptorImpl resolveSetter(\n            PropertyPsiData psiData,\n            CallableMemberDescriptor.Kind kind,\n            PropertyDescriptor propertyDescriptor\n    ) {\n        PropertyPsiDataElement setter = psiData.getSetter();\n        if (setter == null) {\n            return null;\n        }\n        Visibility setterVisibility = DescriptorResolverUtils.resolveVisibility(setter.getMember().getPsiMember(), null);\n        if (setter.getMember() instanceof PsiMethodWrapper) {\n            setterVisibility = DescriptorResolverUtils.resolveVisibility(\n                    setter.getMember().getPsiMember(),\n                    ((PsiMethodWrapper) setter.getMember())\n                            .getJetMethodAnnotation());\n        }\n        return new PropertySetterDescriptorImpl(\n                propertyDescriptor,\n                annotationResolver.resolveAnnotations(setter.getMember().getPsiMember()),\n                propertyDescriptor.getModality(),\n                setterVisibility,\n                true,\n                false,\n                kind);\n    }","commit_id":"86f5114b7da30f8227dd29fd58ba029b46bfd3e3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void initializeSetterAndGetter(\n            PropertyDescriptor propertyDescriptor,\n            PropertyGetterDescriptorImpl getterDescriptor,\n            PropertySetterDescriptorImpl setterDescriptor,\n            JetType propertyType\n    ) {\n        if (getterDescriptor != null) {\n            getterDescriptor.initialize(propertyType);\n        }\n        if (setterDescriptor != null) {\n            setterDescriptor.initialize(new ValueParameterDescriptorImpl(\n                    setterDescriptor,\n                    0,\n                    Collections.<AnnotationDescriptor>emptyList(),\n                    Name.identifier(\"p0\") /*TODO*/,\n                    propertyDescriptor.getType(),\n                    false,\n                    null));\n        }\n    }","id":29133,"modified_method":"private static void initializeSetterAndGetter(\n            @NotNull PropertyDescriptor propertyDescriptor,\n            @Nullable PropertyGetterDescriptorImpl getterDescriptor,\n            @Nullable PropertySetterDescriptorImpl setterDescriptor,\n            @NotNull JetType propertyType,\n            @NotNull PropertyPsiData data\n    ) {\n        if (getterDescriptor != null) {\n            getterDescriptor.initialize(propertyType);\n        }\n        if (setterDescriptor != null) {\n            PropertyPsiDataElement setter = data.getSetter();\n            assert setter != null;\n            List<PsiParameterWrapper> parameters = ((PsiMethodWrapper) setter.getMember()).getParameters();\n            assert parameters.size() != 0;\n            int valueIndex = parameters.size() - 1;\n            PsiParameterWrapper valueParameter = parameters.get(valueIndex);\n            setterDescriptor.initialize(new ValueParameterDescriptorImpl(\n                    setterDescriptor,\n                    0,\n                    Collections.<AnnotationDescriptor>emptyList(),\n                    Name.identifierNoValidate(valueParameter.getJetValueParameter().name()),\n                    propertyDescriptor.getType(),\n                    false,\n                    null));\n        }\n    }","commit_id":"86f5114b7da30f8227dd29fd58ba029b46bfd3e3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private boolean includeMember(PsiMemberWrapper member) {\n            if (psiClass.getPsiClass().isEnum() && staticMembers) {\n                return member.isStatic();\n            }\n\n            if (member.isStatic() != staticMembers) {\n                return false;\n            }\n\n            if (member.getPsiMember().getContainingClass() != psiClass.getPsiClass()) {\n                return false;\n            }\n\n            if (member.isPrivate()) {\n                return false;\n            }\n\n            return true;\n        }","id":29134,"modified_method":"private boolean includeMember(PsiMemberWrapper member) {\n            if (psiClass.getPsiClass().isEnum() && staticMembers) {\n                return member.isStatic();\n            }\n\n            if (member.isStatic() != staticMembers) {\n                return false;\n            }\n\n            if (member.getPsiMember().getContainingClass() != psiClass.getPsiClass()) {\n                return false;\n            }\n\n            //process private accessors\n            if (member.isPrivate()\n                && !(member instanceof PsiMethodWrapper && ((PsiMethodWrapper)member).getJetMethodAnnotation().hasPropertyFlag())) {\n                return false;\n            }\n\n            return true;\n        }","commit_id":"86f5114b7da30f8227dd29fd58ba029b46bfd3e3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n\tpublic Fields mergeFields(Fields newFields, Fields existingFields) {\n\t\tString[] newFieldsDisplayValues = splitFieldsDisplayValue(\n\t\t\tnewFields.get(DDMImpl.FIELDS_DISPLAY_NAME));\n\n\t\tString[] existingFieldsDisplayValues = splitFieldsDisplayValue(\n\t\t\texistingFields.get(DDMImpl.FIELDS_DISPLAY_NAME));\n\n\t\tIterator<Field> itr = newFields.iterator(true);\n\n\t\twhile (itr.hasNext()) {\n\t\t\tField newField = itr.next();\n\n\t\t\tField existingField = existingFields.get(newField.getName());\n\n\t\t\tif (existingField == null) {\n\t\t\t\texistingFields.put(newField);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (newField.isPrivate()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\texistingField.setDefaultLocale(newField.getDefaultLocale());\n\n\t\t\tMap<Locale, List<Serializable>> mergedFieldValuesMap =\n\t\t\t\tgetMergedFieldValuesMap(\n\t\t\t\t\tnewField, newFieldsDisplayValues, existingField,\n\t\t\t\t\texistingFieldsDisplayValues);\n\n\t\t\texistingField.setValuesMap(mergedFieldValuesMap);\n\t\t}\n\n\t\treturn existingFields;\n\t}","id":29135,"modified_method":"@Override\n\tpublic Fields mergeFields(Fields newFields, Fields existingFields) {\n\t\tString[] newFieldsDisplayValues = splitFieldsDisplayValue(\n\t\t\tnewFields.get(DDMImpl.FIELDS_DISPLAY_NAME));\n\n\t\tString[] existingFieldsDisplayValues = splitFieldsDisplayValue(\n\t\t\texistingFields.get(DDMImpl.FIELDS_DISPLAY_NAME));\n\n\t\tIterator<Field> itr = newFields.iterator(true);\n\n\t\twhile (itr.hasNext()) {\n\t\t\tField newField = itr.next();\n\n\t\t\tField existingField = existingFields.get(newField.getName());\n\n\t\t\tif (existingField == null) {\n\t\t\t\texistingFields.put(newField);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (newField.isPrivate()) {\n\t\t\t\tString[] existingFieldValues = splitFieldsDisplayValue(\n\t\t\t\t\texistingField);\n\n\t\t\t\tString[] newFieldValues = splitFieldsDisplayValue(newField);\n\n\t\t\t\tif (newFieldValues.length > existingFieldValues.length) {\n\t\t\t\t\texistingFields.put(newField);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\texistingField.setDefaultLocale(newField.getDefaultLocale());\n\n\t\t\tMap<Locale, List<Serializable>> mergedFieldValuesMap =\n\t\t\t\tgetMergedFieldValuesMap(\n\t\t\t\t\tnewField, newFieldsDisplayValues, existingField,\n\t\t\t\t\texistingFieldsDisplayValues);\n\n\t\t\texistingField.setValuesMap(mergedFieldValuesMap);\n\t\t}\n\n\t\treturn existingFields;\n\t}","commit_id":"12f6e626d9be9dcf985cacc0a62d436c5380a65c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void visitMethod(Method obj) {\n        super.visitMethod(obj);\n        if (obj.isPrivate() && !getMethodName().equals(\"writeReplace\") && !getMethodName().equals(\"readResolve\")\n                && !getMethodName().equals(\"readObject\") && !getMethodName().equals(\"readObjectNoData\")\n                && !getMethodName().equals(\"writeObject\") && getMethodName().indexOf(\"debug\") == -1\n                && getMethodName().indexOf(\"Debug\") == -1 && getMethodName().indexOf(\"trace\") == -1\n                && getMethodName().indexOf(\"Trace\") == -1 && !getMethodName().equals(\"<init>\")\n                && !getMethodName().equals(\"<clinit>\")) {\n            for(AnnotationEntry a : obj.getAnnotationEntries()) {\n                String typeName =  a.getAnnotationType();\n                if (typeName.equals(\"Ljavax/annotation/PostConstruct;\")\n                    || typeName.equals(\"Ljavax/annotation/PreDestroy;\"))\n                    return;\n            }\n            definedPrivateMethods.add(MethodAnnotation.fromVisitedMethod(this));\n        }\n    }","id":29136,"modified_method":"@Override\n    public void visitMethod(Method obj) {\n        if (!obj.isPrivate() || obj.isSynthetic()) {\n            return;\n        }\n        super.visitMethod(obj);\n        String methodName = getMethodName();\n        if (!methodName.equals(\"writeReplace\") && !methodName.equals(\"readResolve\")\n                && !methodName.equals(\"readObject\") && !methodName.equals(\"readObjectNoData\")\n                && !methodName.equals(\"writeObject\")\n                && methodName.indexOf(\"debug\") == -1 && methodName.indexOf(\"Debug\") == -1\n                && methodName.indexOf(\"trace\") == -1 && methodName.indexOf(\"Trace\") == -1\n                && !methodName.equals(\"<init>\") && !methodName.equals(\"<clinit>\")) {\n            for(AnnotationEntry a : obj.getAnnotationEntries()) {\n                String typeName =  a.getAnnotationType();\n                if (typeName.equals(\"Ljavax/annotation/PostConstruct;\")\n                        || typeName.equals(\"Ljavax/annotation/PreDestroy;\"))\n                    return;\n            }\n            definedPrivateMethods.add(MethodAnnotation.fromVisitedMethod(this));\n        }\n    }","commit_id":"8bb7ee567bcbce0edd4f49919df5540ce09061c4","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Test\n  public void testDeletingBlocks() throws IOException {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(new HdfsConfiguration()).build();\n    try {\n      cluster.waitActive();\n      DataNode dn = cluster.getDataNodes().get(0);\n      \n      FsDatasetImpl ds = (FsDatasetImpl) DataNodeTestUtils.getFSDataset(dn);\n      FsVolumeImpl vol;\n      try (FsDatasetSpi.FsVolumeReferences volumes = ds.getFsVolumeReferences()) {\n        vol = (FsVolumeImpl)volumes.get(0);\n      }\n\n      ExtendedBlock eb;\n      ReplicaInfo info;\n      List<Block> blockList = new ArrayList<Block>();\n      for (int i = 1; i <= 63; i++) {\n        eb = new ExtendedBlock(BLOCKPOOL, i, 1, 1000 + i);\n        info = new FinalizedReplica(\n            eb.getLocalBlock(), vol, vol.getCurrentDir().getParentFile());\n        ds.volumeMap.add(BLOCKPOOL, info);\n        info.getBlockFile().createNewFile();\n        info.getMetaFile().createNewFile();\n        blockList.add(info);\n      }\n      ds.invalidate(BLOCKPOOL, blockList.toArray(new Block[0]));\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        // Nothing to do\n      }\n      assertTrue(ds.isDeletingBlock(BLOCKPOOL, blockList.get(0).getBlockId()));\n\n      blockList.clear();\n      eb = new ExtendedBlock(BLOCKPOOL, 64, 1, 1064);\n      info = new FinalizedReplica(\n          eb.getLocalBlock(), vol, vol.getCurrentDir().getParentFile());\n      ds.volumeMap.add(BLOCKPOOL, info);\n      info.getBlockFile().createNewFile();\n      info.getMetaFile().createNewFile();\n      blockList.add(info);\n      ds.invalidate(BLOCKPOOL, blockList.toArray(new Block[0]));\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        // Nothing to do\n      }\n      assertFalse(ds.isDeletingBlock(BLOCKPOOL, blockList.get(0).getBlockId()));\n    } finally {\n      cluster.shutdown();\n    }\n  }","id":29137,"modified_method":"@Test\n  public void testDeletingBlocks() throws IOException {\n    HdfsConfiguration conf = new HdfsConfiguration();\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).build();\n    try {\n      cluster.waitActive();\n      DataNode dn = cluster.getDataNodes().get(0);\n      \n      FsDatasetSpi<?> ds = DataNodeTestUtils.getFSDataset(dn);\n      ds.addBlockPool(BLOCKPOOL, conf);\n      FsVolumeImpl vol;\n      try (FsDatasetSpi.FsVolumeReferences volumes = ds.getFsVolumeReferences()) {\n        vol = (FsVolumeImpl)volumes.get(0);\n      }\n\n      ExtendedBlock eb;\n      ReplicaInfo info;\n      List<Block> blockList = new ArrayList<>();\n      for (int i = 1; i <= 63; i++) {\n        eb = new ExtendedBlock(BLOCKPOOL, i, 1, 1000 + i);\n        cluster.getFsDatasetTestUtils(0).createFinalizedReplica(eb);\n        blockList.add(eb.getLocalBlock());\n      }\n      ds.invalidate(BLOCKPOOL, blockList.toArray(new Block[0]));\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        // Nothing to do\n      }\n      assertTrue(ds.isDeletingBlock(BLOCKPOOL, blockList.get(0).getBlockId()));\n\n      blockList.clear();\n      eb = new ExtendedBlock(BLOCKPOOL, 64, 1, 1064);\n      cluster.getFsDatasetTestUtils(0).createFinalizedReplica(eb);\n      blockList.add(eb.getLocalBlock());\n      ds.invalidate(BLOCKPOOL, blockList.toArray(new Block[0]));\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        // Nothing to do\n      }\n      assertFalse(ds.isDeletingBlock(BLOCKPOOL, blockList.get(0).getBlockId()));\n    } finally {\n      cluster.shutdown();\n    }\n  }","commit_id":"71e533a153cbe547c99d2bc18c4cd8b7da9b00b7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * This is a test to check the replica map before and after the datanode \n   * quick restart (less than 5 minutes)\n   * @throws Exception\n   */\n  @Test\n  public  void testReplicaMapAfterDatanodeRestart() throws Exception {\n    Configuration conf = new HdfsConfiguration();\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf)\n        .nnTopology(MiniDFSNNTopology.simpleFederatedTopology(2))\n        .build();\n    try {\n      cluster.waitActive();\n      NameNode nn1 = cluster.getNameNode(0);\n      NameNode nn2 = cluster.getNameNode(1);\n      assertNotNull(\"cannot create nn1\", nn1);\n      assertNotNull(\"cannot create nn2\", nn2);\n      \n      // check number of volumes in fsdataset\n      DataNode dn = cluster.getDataNodes().get(0);\n      FsDatasetImpl dataSet = (FsDatasetImpl)DataNodeTestUtils.\n          getFSDataset(dn);\n      ReplicaMap replicaMap = dataSet.volumeMap;\n      \n      List<FsVolumeImpl> volumes = null;\n      try (FsDatasetSpi.FsVolumeReferences referredVols = dataSet.getFsVolumeReferences()) {\n        // number of volumes should be 2 - [data1, data2]\n        assertEquals(\"number of volumes is wrong\", 2, referredVols.size());\n        volumes = new ArrayList<>(referredVols.size());\n        for (FsVolumeSpi vol : referredVols) {\n          volumes.add((FsVolumeImpl) vol);\n        }\n      }\n      ArrayList<String> bpList = new ArrayList<String>(Arrays.asList(\n          cluster.getNamesystem(0).getBlockPoolId(), \n          cluster.getNamesystem(1).getBlockPoolId()));\n      \n      Assert.assertTrue(\"Cluster should have 2 block pools\", \n          bpList.size() == 2);\n      \n      createReplicas(bpList, volumes, replicaMap);\n      ReplicaMap oldReplicaMap = new ReplicaMap(this);\n      oldReplicaMap.addAll(replicaMap);\n      \n      cluster.restartDataNode(0);\n      cluster.waitActive();\n      dn = cluster.getDataNodes().get(0);\n      dataSet = (FsDatasetImpl) dn.getFSDataset();\n      testEqualityOfReplicaMap(oldReplicaMap, dataSet.volumeMap, bpList);\n    } finally {\n      cluster.shutdown();\n    }\n  }","id":29138,"modified_method":"/**\n   * This is a test to check the replica map before and after the datanode \n   * quick restart (less than 5 minutes)\n   * @throws Exception\n   */\n  @Test\n  public  void testReplicaMapAfterDatanodeRestart() throws Exception {\n    Configuration conf = new HdfsConfiguration();\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf)\n        .nnTopology(MiniDFSNNTopology.simpleFederatedTopology(2))\n        .build();\n    try {\n      cluster.waitActive();\n      NameNode nn1 = cluster.getNameNode(0);\n      NameNode nn2 = cluster.getNameNode(1);\n      assertNotNull(\"cannot create nn1\", nn1);\n      assertNotNull(\"cannot create nn2\", nn2);\n      \n      // check number of volumes in fsdataset\n      DataNode dn = cluster.getDataNodes().get(0);\n      FsDatasetImpl dataSet = (FsDatasetImpl)DataNodeTestUtils.\n          getFSDataset(dn);\n      \n      List<FsVolumeSpi> volumes = null;\n      try (FsDatasetSpi.FsVolumeReferences referredVols = dataSet.getFsVolumeReferences()) {\n        // number of volumes should be 2 - [data1, data2]\n        assertEquals(\"number of volumes is wrong\", 2, referredVols.size());\n        volumes = new ArrayList<>(referredVols.size());\n        for (FsVolumeSpi vol : referredVols) {\n          volumes.add(vol);\n        }\n      }\n      ArrayList<String> bpList = new ArrayList<>(Arrays.asList(\n          cluster.getNamesystem(0).getBlockPoolId(),\n          cluster.getNamesystem(1).getBlockPoolId()));\n      \n      Assert.assertTrue(\"Cluster should have 2 block pools\", \n          bpList.size() == 2);\n      \n      createReplicas(bpList, volumes, cluster.getFsDatasetTestUtils(dn));\n      ReplicaMap oldReplicaMap = new ReplicaMap(this);\n      oldReplicaMap.addAll(dataSet.volumeMap);\n\n      cluster.restartDataNode(0);\n      cluster.waitActive();\n      dn = cluster.getDataNodes().get(0);\n      dataSet = (FsDatasetImpl) dn.getFSDataset();\n      testEqualityOfReplicaMap(oldReplicaMap, dataSet.volumeMap, bpList);\n    } finally {\n      cluster.shutdown();\n    }\n  }","commit_id":"71e533a153cbe547c99d2bc18c4cd8b7da9b00b7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Generate testing environment and return a collection of blocks\n   * on which to run the tests.\n   * \n   * @param bpid Block pool ID to generate blocks for\n   * @param dataSet Namespace in which to insert blocks\n   * @return Contrived blocks for further testing.\n   * @throws IOException\n   */\n  private ExtendedBlock[] setup(String bpid, FsDatasetImpl dataSet) throws IOException {\n    // setup replicas map\n    \n    ExtendedBlock[] blocks = new ExtendedBlock[] {\n        new ExtendedBlock(bpid, 1, 1, 2001), new ExtendedBlock(bpid, 2, 1, 2002), \n        new ExtendedBlock(bpid, 3, 1, 2003), new ExtendedBlock(bpid, 4, 1, 2004),\n        new ExtendedBlock(bpid, 5, 1, 2005), new ExtendedBlock(bpid, 6, 1, 2006)\n    };\n    \n    ReplicaMap replicasMap = dataSet.volumeMap;\n    try (FsDatasetSpi.FsVolumeReferences references =\n        dataSet.getFsVolumeReferences()) {\n      FsVolumeImpl vol = (FsVolumeImpl) references.get(0);\n      ReplicaInfo replicaInfo = new FinalizedReplica(\n          blocks[FINALIZED].getLocalBlock(), vol,\n          vol.getCurrentDir().getParentFile());\n      replicasMap.add(bpid, replicaInfo);\n      replicaInfo.getBlockFile().createNewFile();\n      replicaInfo.getMetaFile().createNewFile();\n\n      replicasMap.add(bpid, new ReplicaInPipeline(\n          blocks[TEMPORARY].getBlockId(),\n          blocks[TEMPORARY].getGenerationStamp(), vol,\n          vol.createTmpFile(bpid, blocks[TEMPORARY].getLocalBlock())\n              .getParentFile(), 0));\n\n      replicaInfo = new ReplicaBeingWritten(blocks[RBW].getLocalBlock(), vol,\n          vol.createRbwFile(bpid, blocks[RBW].getLocalBlock()).getParentFile(),\n          null);\n      replicasMap.add(bpid, replicaInfo);\n      replicaInfo.getBlockFile().createNewFile();\n      replicaInfo.getMetaFile().createNewFile();\n\n      replicasMap.add(bpid, new ReplicaWaitingToBeRecovered(\n          blocks[RWR].getLocalBlock(), vol, vol.createRbwFile(bpid,\n          blocks[RWR].getLocalBlock()).getParentFile()));\n      replicasMap\n          .add(bpid, new ReplicaUnderRecovery(new FinalizedReplica(blocks[RUR]\n              .getLocalBlock(), vol, vol.getCurrentDir().getParentFile()),\n              2007));\n    }\n    return blocks;\n  }","id":29139,"modified_method":"/**\n   * Generate testing environment and return a collection of blocks\n   * on which to run the tests.\n   * \n   * @param bpid Block pool ID to generate blocks for\n   * @param testUtils FsDatasetTestUtils provides white box access to FsDataset.\n   * @return Contrived blocks for further testing.\n   * @throws IOException\n   */\n  private ExtendedBlock[] setup(String bpid, FsDatasetTestUtils testUtils)\n      throws IOException {\n    // setup replicas map\n    \n    ExtendedBlock[] blocks = new ExtendedBlock[] {\n        new ExtendedBlock(bpid, 1, 1, 2001), new ExtendedBlock(bpid, 2, 1, 2002), \n        new ExtendedBlock(bpid, 3, 1, 2003), new ExtendedBlock(bpid, 4, 1, 2004),\n        new ExtendedBlock(bpid, 5, 1, 2005), new ExtendedBlock(bpid, 6, 1, 2006)\n    };\n\n    testUtils.createFinalizedReplica(blocks[FINALIZED]);\n    testUtils.createReplicaInPipeline(blocks[TEMPORARY]);\n    testUtils.createRBW(blocks[RBW]);\n    testUtils.createReplicaWaitingToBeRecovered(blocks[RWR]);\n    testUtils.createReplicaUnderRecovery(blocks[RUR], 2007);\n\n    return blocks;\n  }","commit_id":"71e533a153cbe547c99d2bc18c4cd8b7da9b00b7","url":"https://github.com/apache/hadoop"},{"original_method":"private void testAppend(String bpid, FsDatasetImpl dataSet, ExtendedBlock[] blocks) throws IOException {\n    long newGS = blocks[FINALIZED].getGenerationStamp()+1;\n    final FsVolumeImpl v = (FsVolumeImpl)dataSet.volumeMap.get(\n        bpid, blocks[FINALIZED].getLocalBlock()).getVolume();\n    long available = v.getCapacity()-v.getDfsUsed();\n    long expectedLen = blocks[FINALIZED].getNumBytes();\n    try {\n      v.onBlockFileDeletion(bpid, -available);\n      blocks[FINALIZED].setNumBytes(expectedLen+100);\n      dataSet.append(blocks[FINALIZED], newGS, expectedLen);\n      Assert.fail(\"Should not have space to append to an RWR replica\" + blocks[RWR]);\n    } catch (DiskOutOfSpaceException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          \"Insufficient space for appending to \"));\n    }\n    v.onBlockFileDeletion(bpid, available);\n    blocks[FINALIZED].setNumBytes(expectedLen);\n\n    newGS = blocks[RBW].getGenerationStamp()+1;\n    dataSet.append(blocks[FINALIZED], newGS, \n        blocks[FINALIZED].getNumBytes());  // successful\n    blocks[FINALIZED].setGenerationStamp(newGS);\n        \n    try {\n      dataSet.append(blocks[TEMPORARY], blocks[TEMPORARY].getGenerationStamp()+1, \n          blocks[TEMPORARY].getNumBytes());\n      Assert.fail(\"Should not have appended to a temporary replica \" \n          + blocks[TEMPORARY]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertEquals(ReplicaNotFoundException.UNFINALIZED_REPLICA +\n          blocks[TEMPORARY], e.getMessage());\n    }\n\n    try {\n      dataSet.append(blocks[RBW], blocks[RBW].getGenerationStamp()+1,\n          blocks[RBW].getNumBytes());\n      Assert.fail(\"Should not have appended to an RBW replica\" + blocks[RBW]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertEquals(ReplicaNotFoundException.UNFINALIZED_REPLICA +\n          blocks[RBW], e.getMessage());\n    }\n\n    try {\n      dataSet.append(blocks[RWR], blocks[RWR].getGenerationStamp()+1,\n          blocks[RBW].getNumBytes());\n      Assert.fail(\"Should not have appended to an RWR replica\" + blocks[RWR]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertEquals(ReplicaNotFoundException.UNFINALIZED_REPLICA +\n          blocks[RWR], e.getMessage());\n    }\n\n    try {\n      dataSet.append(blocks[RUR], blocks[RUR].getGenerationStamp()+1,\n          blocks[RUR].getNumBytes());\n      Assert.fail(\"Should not have appended to an RUR replica\" + blocks[RUR]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertEquals(ReplicaNotFoundException.UNFINALIZED_REPLICA +\n          blocks[RUR], e.getMessage());\n    }\n\n    try {\n      dataSet.append(blocks[NON_EXISTENT], \n          blocks[NON_EXISTENT].getGenerationStamp(), \n          blocks[NON_EXISTENT].getNumBytes());\n      Assert.fail(\"Should not have appended to a non-existent replica \" + \n          blocks[NON_EXISTENT]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertEquals(ReplicaNotFoundException.NON_EXISTENT_REPLICA + \n          blocks[NON_EXISTENT], e.getMessage());\n    }\n    \n    newGS = blocks[FINALIZED].getGenerationStamp()+1;\n    dataSet.recoverAppend(blocks[FINALIZED], newGS, \n        blocks[FINALIZED].getNumBytes());  // successful\n    blocks[FINALIZED].setGenerationStamp(newGS);\n    \n    try {\n      dataSet.recoverAppend(blocks[TEMPORARY], blocks[TEMPORARY].getGenerationStamp()+1, \n          blocks[TEMPORARY].getNumBytes());\n      Assert.fail(\"Should not have appended to a temporary replica \" \n          + blocks[TEMPORARY]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.UNFINALIZED_AND_NONRBW_REPLICA));\n    }\n\n    newGS = blocks[RBW].getGenerationStamp()+1;\n    dataSet.recoverAppend(blocks[RBW], newGS, blocks[RBW].getNumBytes());\n    blocks[RBW].setGenerationStamp(newGS);\n\n    try {\n      dataSet.recoverAppend(blocks[RWR], blocks[RWR].getGenerationStamp()+1,\n          blocks[RBW].getNumBytes());\n      Assert.fail(\"Should not have appended to an RWR replica\" + blocks[RWR]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.UNFINALIZED_AND_NONRBW_REPLICA));\n    }\n\n    try {\n      dataSet.recoverAppend(blocks[RUR], blocks[RUR].getGenerationStamp()+1,\n          blocks[RUR].getNumBytes());\n      Assert.fail(\"Should not have appended to an RUR replica\" + blocks[RUR]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.UNFINALIZED_AND_NONRBW_REPLICA));\n    }\n\n    try {\n      dataSet.recoverAppend(blocks[NON_EXISTENT], \n          blocks[NON_EXISTENT].getGenerationStamp(), \n          blocks[NON_EXISTENT].getNumBytes());\n      Assert.fail(\"Should not have appended to a non-existent replica \" + \n          blocks[NON_EXISTENT]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.NON_EXISTENT_REPLICA));\n    }\n  }","id":29140,"modified_method":"private void testAppend(String bpid, FsDatasetSpi<?> dataSet,\n                          ExtendedBlock[] blocks) throws IOException {\n    long newGS = blocks[FINALIZED].getGenerationStamp()+1;\n    final FsVolumeSpi v = dataSet.getVolume(blocks[FINALIZED]);\n    if (v instanceof FsVolumeImpl) {\n      FsVolumeImpl fvi = (FsVolumeImpl) v;\n      long available = fvi.getCapacity() - fvi.getDfsUsed();\n      long expectedLen = blocks[FINALIZED].getNumBytes();\n      try {\n        fvi.onBlockFileDeletion(bpid, -available);\n        blocks[FINALIZED].setNumBytes(expectedLen + 100);\n        dataSet.append(blocks[FINALIZED], newGS, expectedLen);\n        Assert.fail(\"Should not have space to append to an RWR replica\" + blocks[RWR]);\n      } catch (DiskOutOfSpaceException e) {\n        Assert.assertTrue(e.getMessage().startsWith(\n            \"Insufficient space for appending to \"));\n      }\n      fvi.onBlockFileDeletion(bpid, available);\n      blocks[FINALIZED].setNumBytes(expectedLen);\n    }\n\n    newGS = blocks[RBW].getGenerationStamp()+1;\n    dataSet.append(blocks[FINALIZED], newGS, \n        blocks[FINALIZED].getNumBytes());  // successful\n    blocks[FINALIZED].setGenerationStamp(newGS);\n        \n    try {\n      dataSet.append(blocks[TEMPORARY], blocks[TEMPORARY].getGenerationStamp()+1, \n          blocks[TEMPORARY].getNumBytes());\n      Assert.fail(\"Should not have appended to a temporary replica \" \n          + blocks[TEMPORARY]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertEquals(ReplicaNotFoundException.UNFINALIZED_REPLICA +\n          blocks[TEMPORARY], e.getMessage());\n    }\n\n    try {\n      dataSet.append(blocks[RBW], blocks[RBW].getGenerationStamp()+1,\n          blocks[RBW].getNumBytes());\n      Assert.fail(\"Should not have appended to an RBW replica\" + blocks[RBW]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertEquals(ReplicaNotFoundException.UNFINALIZED_REPLICA +\n          blocks[RBW], e.getMessage());\n    }\n\n    try {\n      dataSet.append(blocks[RWR], blocks[RWR].getGenerationStamp()+1,\n          blocks[RBW].getNumBytes());\n      Assert.fail(\"Should not have appended to an RWR replica\" + blocks[RWR]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertEquals(ReplicaNotFoundException.UNFINALIZED_REPLICA +\n          blocks[RWR], e.getMessage());\n    }\n\n    try {\n      dataSet.append(blocks[RUR], blocks[RUR].getGenerationStamp()+1,\n          blocks[RUR].getNumBytes());\n      Assert.fail(\"Should not have appended to an RUR replica\" + blocks[RUR]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertEquals(ReplicaNotFoundException.UNFINALIZED_REPLICA +\n          blocks[RUR], e.getMessage());\n    }\n\n    try {\n      dataSet.append(blocks[NON_EXISTENT], \n          blocks[NON_EXISTENT].getGenerationStamp(), \n          blocks[NON_EXISTENT].getNumBytes());\n      Assert.fail(\"Should not have appended to a non-existent replica \" + \n          blocks[NON_EXISTENT]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertEquals(ReplicaNotFoundException.NON_EXISTENT_REPLICA + \n          blocks[NON_EXISTENT], e.getMessage());\n    }\n    \n    newGS = blocks[FINALIZED].getGenerationStamp()+1;\n    dataSet.recoverAppend(blocks[FINALIZED], newGS, \n        blocks[FINALIZED].getNumBytes());  // successful\n    blocks[FINALIZED].setGenerationStamp(newGS);\n    \n    try {\n      dataSet.recoverAppend(blocks[TEMPORARY], blocks[TEMPORARY].getGenerationStamp()+1, \n          blocks[TEMPORARY].getNumBytes());\n      Assert.fail(\"Should not have appended to a temporary replica \" \n          + blocks[TEMPORARY]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.UNFINALIZED_AND_NONRBW_REPLICA));\n    }\n\n    newGS = blocks[RBW].getGenerationStamp()+1;\n    dataSet.recoverAppend(blocks[RBW], newGS, blocks[RBW].getNumBytes());\n    blocks[RBW].setGenerationStamp(newGS);\n\n    try {\n      dataSet.recoverAppend(blocks[RWR], blocks[RWR].getGenerationStamp()+1,\n          blocks[RBW].getNumBytes());\n      Assert.fail(\"Should not have appended to an RWR replica\" + blocks[RWR]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.UNFINALIZED_AND_NONRBW_REPLICA));\n    }\n\n    try {\n      dataSet.recoverAppend(blocks[RUR], blocks[RUR].getGenerationStamp()+1,\n          blocks[RUR].getNumBytes());\n      Assert.fail(\"Should not have appended to an RUR replica\" + blocks[RUR]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.UNFINALIZED_AND_NONRBW_REPLICA));\n    }\n\n    try {\n      dataSet.recoverAppend(blocks[NON_EXISTENT], \n          blocks[NON_EXISTENT].getGenerationStamp(), \n          blocks[NON_EXISTENT].getNumBytes());\n      Assert.fail(\"Should not have appended to a non-existent replica \" + \n          blocks[NON_EXISTENT]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.NON_EXISTENT_REPLICA));\n    }\n  }","commit_id":"71e533a153cbe547c99d2bc18c4cd8b7da9b00b7","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testClose() throws Exception {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(new HdfsConfiguration()).build();\n    \n    try {\n      cluster.waitActive();\n      DataNode dn = cluster.getDataNodes().get(0);\n      FsDatasetImpl dataSet = (FsDatasetImpl)DataNodeTestUtils.getFSDataset(dn);\n\n      // set up replicasMap\n      String bpid = cluster.getNamesystem().getBlockPoolId();\n      \n      ExtendedBlock[] blocks = setup(bpid, dataSet);\n\n      // test close\n      testClose(dataSet, blocks);\n    } finally {\n      cluster.shutdown();\n    }\n  }","id":29141,"modified_method":"@Test\n  public void testClose() throws Exception {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(new HdfsConfiguration()).build();\n    \n    try {\n      cluster.waitActive();\n      DataNode dn = cluster.getDataNodes().get(0);\n      FsDatasetSpi<?> dataSet = DataNodeTestUtils.getFSDataset(dn);\n\n      // set up replicasMap\n      String bpid = cluster.getNamesystem().getBlockPoolId();\n      \n      ExtendedBlock[] blocks = setup(bpid, cluster.getFsDatasetTestUtils(dn));\n\n      // test close\n      testClose(dataSet, blocks);\n    } finally {\n      cluster.shutdown();\n    }\n  }","commit_id":"71e533a153cbe547c99d2bc18c4cd8b7da9b00b7","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testAppend() throws Exception {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(new HdfsConfiguration()).build();\n    try {\n      cluster.waitActive();\n      DataNode dn = cluster.getDataNodes().get(0);\n      FsDatasetImpl dataSet = (FsDatasetImpl)DataNodeTestUtils.getFSDataset(dn);\n\n      // set up replicasMap\n      String bpid = cluster.getNamesystem().getBlockPoolId();\n      ExtendedBlock[] blocks = setup(bpid, dataSet);\n\n      // test append\n      testAppend(bpid, dataSet, blocks);\n    } finally {\n      cluster.shutdown();\n    }\n  }","id":29142,"modified_method":"@Test\n  public void testAppend() throws Exception {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(new HdfsConfiguration()).build();\n    try {\n      cluster.waitActive();\n      DataNode dn = cluster.getDataNodes().get(0);\n      FsDatasetSpi<?> dataSet = DataNodeTestUtils.getFSDataset(dn);\n\n      // set up replicasMap\n      String bpid = cluster.getNamesystem().getBlockPoolId();\n      ExtendedBlock[] blocks = setup(bpid, cluster.getFsDatasetTestUtils(dn));\n\n      // test append\n      testAppend(bpid, dataSet, blocks);\n    } finally {\n      cluster.shutdown();\n    }\n  }","commit_id":"71e533a153cbe547c99d2bc18c4cd8b7da9b00b7","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testWriteToTemporary() throws Exception {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(new HdfsConfiguration()).build();\n    try {\n      cluster.waitActive();\n      DataNode dn = cluster.getDataNodes().get(0);\n      FsDatasetImpl dataSet = (FsDatasetImpl)DataNodeTestUtils.getFSDataset(dn);\n\n      // set up replicasMap\n      String bpid = cluster.getNamesystem().getBlockPoolId();\n      ExtendedBlock[] blocks = setup(bpid, dataSet);\n\n      // test writeToTemporary\n      testWriteToTemporary(dataSet, blocks);\n    } finally {\n      cluster.shutdown();\n    }\n  }","id":29143,"modified_method":"@Test\n  public void testWriteToTemporary() throws Exception {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(new HdfsConfiguration()).build();\n    try {\n      cluster.waitActive();\n      DataNode dn = cluster.getDataNodes().get(0);\n      FsDatasetImpl dataSet = (FsDatasetImpl)DataNodeTestUtils.getFSDataset(dn);\n\n      // set up replicasMap\n      String bpid = cluster.getNamesystem().getBlockPoolId();\n      ExtendedBlock[] blocks = setup(bpid, cluster.getFsDatasetTestUtils(dn));\n\n      // test writeToTemporary\n      testWriteToTemporary(dataSet, blocks);\n    } finally {\n      cluster.shutdown();\n    }\n  }","commit_id":"71e533a153cbe547c99d2bc18c4cd8b7da9b00b7","url":"https://github.com/apache/hadoop"},{"original_method":"private void createReplicas(List<String> bpList, List<FsVolumeImpl> volumes,\n      ReplicaMap volumeMap) throws IOException {\n    Assert.assertTrue(\"Volume map can't be null\" , volumeMap != null);\n    \n    // Here we create all different type of replicas and add it\n    // to volume map. \n    // Created all type of ReplicaInfo, each under Blkpool corresponding volume\n    long id = 1; // This variable is used as both blockId and genStamp\n    for (String bpId: bpList) {\n      for (FsVolumeImpl volume: volumes) {\n        ReplicaInfo finalizedReplica = new FinalizedReplica(id, 1, id, volume,\n            DatanodeUtil.idToBlockDir(volume.getFinalizedDir(bpId), id));\n        volumeMap.add(bpId, finalizedReplica);\n        id++;\n        \n        ReplicaInfo rbwReplica = new ReplicaBeingWritten(id, 1, id, volume, \n            volume.getRbwDir(bpId), null, 100);\n        volumeMap.add(bpId, rbwReplica);\n        id++;\n\n        ReplicaInfo rwrReplica = new ReplicaWaitingToBeRecovered(id, 1, id, \n            volume, volume.getRbwDir(bpId));\n        volumeMap.add(bpId, rwrReplica);\n        id++;\n        \n        ReplicaInfo ripReplica = new ReplicaInPipeline(id, id, volume, \n            volume.getTmpDir(bpId), 0);\n        volumeMap.add(bpId, ripReplica);\n        id++;\n      }\n    }\n    \n    for (String bpId: bpList) {\n      for (ReplicaInfo replicaInfo: volumeMap.replicas(bpId)) {\n        File parentFile = replicaInfo.getBlockFile().getParentFile();\n        if (!parentFile.exists()) {\n          if (!parentFile.mkdirs()) {\n            throw new IOException(\"Failed to mkdirs \" + parentFile);\n          }\n        }\n        replicaInfo.getBlockFile().createNewFile();\n        replicaInfo.getMetaFile().createNewFile();\n      }\n    }\n  }","id":29144,"modified_method":"private void createReplicas(List<String> bpList, List<FsVolumeSpi> volumes,\n                              FsDatasetTestUtils testUtils) throws IOException {\n    // Here we create all different type of replicas and add it\n    // to volume map. \n    // Created all type of ReplicaInfo, each under Blkpool corresponding volume\n    long id = 1; // This variable is used as both blockId and genStamp\n    for (String bpId: bpList) {\n      for (FsVolumeSpi volume: volumes) {\n        ExtendedBlock eb = new ExtendedBlock(bpId, id, 1, id);\n        testUtils.createFinalizedReplica(volume, eb);\n        id++;\n\n        eb = new ExtendedBlock(bpId, id, 1, id);\n        testUtils.createRBW(volume, eb);\n        id++;\n\n        eb = new ExtendedBlock(bpId, id, 1, id);\n        testUtils.createReplicaWaitingToBeRecovered(volume, eb);\n        id++;\n\n        eb = new ExtendedBlock(bpId, id, 1, id);\n        testUtils.createReplicaInPipeline(volume, eb);\n        id++;\n      }\n    }\n  }","commit_id":"71e533a153cbe547c99d2bc18c4cd8b7da9b00b7","url":"https://github.com/apache/hadoop"},{"original_method":"private void testClose(FsDatasetImpl dataSet, ExtendedBlock [] blocks) throws IOException {\n    long newGS = blocks[FINALIZED].getGenerationStamp()+1;\n    dataSet.recoverClose(blocks[FINALIZED], newGS, \n        blocks[FINALIZED].getNumBytes());  // successful\n    blocks[FINALIZED].setGenerationStamp(newGS);\n    \n    try {\n      dataSet.recoverClose(blocks[TEMPORARY], blocks[TEMPORARY].getGenerationStamp()+1, \n          blocks[TEMPORARY].getNumBytes());\n      Assert.fail(\"Should not have recovered close a temporary replica \" \n          + blocks[TEMPORARY]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.UNFINALIZED_AND_NONRBW_REPLICA));\n    }\n\n    newGS = blocks[RBW].getGenerationStamp()+1;\n    dataSet.recoverClose(blocks[RBW], newGS, blocks[RBW].getNumBytes());\n    blocks[RBW].setGenerationStamp(newGS);\n\n    try {\n      dataSet.recoverClose(blocks[RWR], blocks[RWR].getGenerationStamp()+1,\n          blocks[RBW].getNumBytes());\n      Assert.fail(\"Should not have recovered close an RWR replica\" + blocks[RWR]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.UNFINALIZED_AND_NONRBW_REPLICA));\n    }\n\n    try {\n      dataSet.recoverClose(blocks[RUR], blocks[RUR].getGenerationStamp()+1,\n          blocks[RUR].getNumBytes());\n      Assert.fail(\"Should not have recovered close an RUR replica\" + blocks[RUR]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.UNFINALIZED_AND_NONRBW_REPLICA));\n    }\n\n    try {\n      dataSet.recoverClose(blocks[NON_EXISTENT], \n          blocks[NON_EXISTENT].getGenerationStamp(), \n          blocks[NON_EXISTENT].getNumBytes());\n      Assert.fail(\"Should not have recovered close a non-existent replica \" + \n          blocks[NON_EXISTENT]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.NON_EXISTENT_REPLICA));\n    }\n  }","id":29145,"modified_method":"private void testClose(FsDatasetSpi<?> dataSet, ExtendedBlock [] blocks) throws IOException {\n    long newGS = blocks[FINALIZED].getGenerationStamp()+1;\n    dataSet.recoverClose(blocks[FINALIZED], newGS, \n        blocks[FINALIZED].getNumBytes());  // successful\n    blocks[FINALIZED].setGenerationStamp(newGS);\n    \n    try {\n      dataSet.recoverClose(blocks[TEMPORARY], blocks[TEMPORARY].getGenerationStamp()+1, \n          blocks[TEMPORARY].getNumBytes());\n      Assert.fail(\"Should not have recovered close a temporary replica \" \n          + blocks[TEMPORARY]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.UNFINALIZED_AND_NONRBW_REPLICA));\n    }\n\n    newGS = blocks[RBW].getGenerationStamp()+1;\n    dataSet.recoverClose(blocks[RBW], newGS, blocks[RBW].getNumBytes());\n    blocks[RBW].setGenerationStamp(newGS);\n\n    try {\n      dataSet.recoverClose(blocks[RWR], blocks[RWR].getGenerationStamp()+1,\n          blocks[RBW].getNumBytes());\n      Assert.fail(\"Should not have recovered close an RWR replica\" + blocks[RWR]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.UNFINALIZED_AND_NONRBW_REPLICA));\n    }\n\n    try {\n      dataSet.recoverClose(blocks[RUR], blocks[RUR].getGenerationStamp()+1,\n          blocks[RUR].getNumBytes());\n      Assert.fail(\"Should not have recovered close an RUR replica\" + blocks[RUR]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.UNFINALIZED_AND_NONRBW_REPLICA));\n    }\n\n    try {\n      dataSet.recoverClose(blocks[NON_EXISTENT], \n          blocks[NON_EXISTENT].getGenerationStamp(), \n          blocks[NON_EXISTENT].getNumBytes());\n      Assert.fail(\"Should not have recovered close a non-existent replica \" + \n          blocks[NON_EXISTENT]);\n    } catch (ReplicaNotFoundException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\n          ReplicaNotFoundException.NON_EXISTENT_REPLICA));\n    }\n  }","commit_id":"71e533a153cbe547c99d2bc18c4cd8b7da9b00b7","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testWriteToRbw() throws Exception {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(new HdfsConfiguration()).build();\n    try {\n      cluster.waitActive();\n      DataNode dn = cluster.getDataNodes().get(0);\n      FsDatasetImpl dataSet = (FsDatasetImpl)DataNodeTestUtils.getFSDataset(dn);\n\n      // set up replicasMap\n      String bpid = cluster.getNamesystem().getBlockPoolId();\n      ExtendedBlock[] blocks = setup(bpid, dataSet);\n\n      // test writeToRbw\n      testWriteToRbw(dataSet, blocks);\n    } finally {\n      cluster.shutdown();\n    }\n  }","id":29146,"modified_method":"@Test\n  public void testWriteToRbw() throws Exception {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(new HdfsConfiguration()).build();\n    try {\n      cluster.waitActive();\n      DataNode dn = cluster.getDataNodes().get(0);\n      FsDatasetImpl dataSet = (FsDatasetImpl)DataNodeTestUtils.getFSDataset(dn);\n\n      // set up replicasMap\n      String bpid = cluster.getNamesystem().getBlockPoolId();\n      ExtendedBlock[] blocks = setup(bpid, cluster.getFsDatasetTestUtils(dn));\n\n      // test writeToRbw\n      testWriteToRbw(dataSet, blocks);\n    } finally {\n      cluster.shutdown();\n    }\n  }","commit_id":"71e533a153cbe547c99d2bc18c4cd8b7da9b00b7","url":"https://github.com/apache/hadoop"},{"original_method":"private long getResizeUpStabilizationDelay() {\n        return getConfig(RESIZE_UP_STABILIZATION_DELAY);\n    }","id":29147,"modified_method":"private Duration getResizeUpStabilizationDelay() {\n        return getConfig(RESIZE_UP_STABILIZATION_DELAY);\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private long getMaxReachedNotificationDelay() {\n        return getConfig(MAX_REACHED_NOTIFICATION_DELAY);\n    }","id":29148,"modified_method":"private Duration getMaxReachedNotificationDelay() {\n        return getConfig(MAX_REACHED_NOTIFICATION_DELAY);\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void init() {\n        long maxReachedNotificationDelay = getMaxReachedNotificationDelay();\n        recentUnboundedResizes = new SizeHistory(maxReachedNotificationDelay);\n        \n        long maxResizeStabilizationDelay = Math.max(getResizeUpStabilizationDelay(), getResizeDownStabilizationDelay());\n        recentDesiredResizes = new SizeHistory(maxResizeStabilizationDelay);\n        \n        // TODO Should re-use the execution manager's thread pool, somehow\n        executor = Executors.newSingleThreadScheduledExecutor(newThreadFactory());\n    }","id":29149,"modified_method":"@Override\n    public void init() {\n        long maxReachedNotificationDelay = getMaxReachedNotificationDelay().toMilliseconds();\n        recentUnboundedResizes = new SizeHistory(maxReachedNotificationDelay);\n        \n        long maxResizeStabilizationDelay = Math.max(getResizeUpStabilizationDelay().toMilliseconds(), getResizeDownStabilizationDelay().toMilliseconds());\n        recentDesiredResizes = new SizeHistory(maxResizeStabilizationDelay);\n        \n        // TODO Should re-use the execution manager's thread pool, somehow\n        executor = Executors.newSingleThreadScheduledExecutor(newThreadFactory());\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private long getResizeDownStabilizationDelay() {\n        return getConfig(RESIZE_DOWN_STABILIZATION_DELAY);\n    }","id":29150,"modified_method":"private Duration getResizeDownStabilizationDelay() {\n        return getConfig(RESIZE_DOWN_STABILIZATION_DELAY);\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public void setResizeUpStabilizationDelay(long val) {\n        if (LOG.isInfoEnabled()) LOG.info(\"{} changing resizeUpStabilizationDelay from {} to {}\", new Object[] {this, getResizeUpStabilizationDelay(), val});\n        setConfig(RESIZE_UP_STABILIZATION_DELAY, val);\n    }","id":29151,"modified_method":"public void setResizeUpStabilizationDelay(long val) {\n        setResizeUpStabilizationDelay(Duration.millis(val));\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public void setResizeDownStabilizationDelay(long val) {\n        if (LOG.isInfoEnabled()) LOG.info(\"{} changing resizeDownStabilizationDelay from {} to {}\", new Object[] {this, getResizeDownStabilizationDelay(), val});\n        setConfig(RESIZE_DOWN_STABILIZATION_DELAY, val);\n    }","id":29152,"modified_method":"public void setResizeDownStabilizationDelay(long val) {\n        setResizeDownStabilizationDelay(Duration.millis(val));\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private long getMinPeriodBetweenExecs() {\n        return getConfig(MIN_PERIOD_BETWEEN_EXECS);\n    }","id":29153,"modified_method":"private Duration getMinPeriodBetweenExecs() {\n        return getConfig(MIN_PERIOD_BETWEEN_EXECS);\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public void setMinPeriodBetweenExecs(long val) {\n        if (LOG.isInfoEnabled()) LOG.info(\"{} changing minPeriodBetweenExecs from {} to {}\", new Object[] {this, getMinPeriodBetweenExecs(), val});\n        setConfig(MIN_PERIOD_BETWEEN_EXECS, val);\n    }","id":29154,"modified_method":"public void setMinPeriodBetweenExecs(long val) {\n        setMinPeriodBetweenExecs(Duration.millis(val));\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Complicated logic for stabilization-delay...\n     * Only grow if we have consistently been asked to grow for the resizeUpStabilizationDelay period;\n     * Only shrink if we have consistently been asked to shrink for the resizeDownStabilizationDelay period.\n     * \n     * @return tuple of desired pool size, and whether this is \"stable\" (i.e. if we receive no more events \n     *         will this continue to be the desired pool size)\n     */\n    private CalculatedDesiredPoolSize calculateDesiredPoolSize(long currentPoolSize) {\n        long now = System.currentTimeMillis();\n        WindowSummary downsizeSummary = recentDesiredResizes.summarizeWindow(getResizeDownStabilizationDelay());\n        WindowSummary upsizeSummary = recentDesiredResizes.summarizeWindow(getResizeUpStabilizationDelay());\n        \n        // this is the _sustained_ growth value; the smallest size that has been requested in the \"stable-for-growing\" period\n        long maxDesiredPoolSize = upsizeSummary.min;\n        boolean stableForGrowing = upsizeSummary.stableForGrowth;\n        \n        // this is the _sustained_ shrink value; largest size that has been requested in the \"stable-for-shrinking\" period:\n        long minDesiredPoolSize = downsizeSummary.max;\n        boolean stableForShrinking = downsizeSummary.stableForShrinking;\n        \n        // (it is a logical consequence of the above that minDesired >= maxDesired -- this is correct, if confusing:\n        // think of minDesired as the minimum size we are allowed to resize to, and similarly for maxDesired; \n        // if min > max we can scale to max if current < max, or scale to min if current > min)\n\n        long desiredPoolSize;\n        \n        boolean stable;\n        \n        if (currentPoolSize < maxDesiredPoolSize) {\n            // we have valid request to grow \n            // (we'll never have a valid request to grow and a valid to shrink simultaneously, btw)\n            desiredPoolSize = maxDesiredPoolSize;\n            stable = stableForGrowing;\n        } else if (currentPoolSize > minDesiredPoolSize) {\n            // we have valid request to shrink\n            desiredPoolSize = minDesiredPoolSize;\n            stable = stableForShrinking;\n        } else {\n            desiredPoolSize = currentPoolSize;\n            stable = stableForGrowing && stableForShrinking;\n        }\n\n        if (LOG.isTraceEnabled()) LOG.trace(\"{} calculated desired pool size: from {} to {}; minDesired {}, maxDesired {}; \" +\n                \"stable {}; now {}; downsizeHistory {}; upsizeHistory {}\", \n                new Object[] {this, currentPoolSize, desiredPoolSize, minDesiredPoolSize, maxDesiredPoolSize, stable, now, downsizeSummary, upsizeSummary});\n        \n        return new CalculatedDesiredPoolSize(desiredPoolSize, stable);\n    }","id":29155,"modified_method":"/**\n     * Complicated logic for stabilization-delay...\n     * Only grow if we have consistently been asked to grow for the resizeUpStabilizationDelay period;\n     * Only shrink if we have consistently been asked to shrink for the resizeDownStabilizationDelay period.\n     * \n     * @return tuple of desired pool size, and whether this is \"stable\" (i.e. if we receive no more events \n     *         will this continue to be the desired pool size)\n     */\n    private CalculatedDesiredPoolSize calculateDesiredPoolSize(long currentPoolSize) {\n        long now = System.currentTimeMillis();\n        WindowSummary downsizeSummary = recentDesiredResizes.summarizeWindow(getResizeDownStabilizationDelay().toMilliseconds());\n        WindowSummary upsizeSummary = recentDesiredResizes.summarizeWindow(getResizeUpStabilizationDelay().toMilliseconds());\n        \n        // this is the _sustained_ growth value; the smallest size that has been requested in the \"stable-for-growing\" period\n        long maxDesiredPoolSize = upsizeSummary.min;\n        boolean stableForGrowing = upsizeSummary.stableForGrowth;\n        \n        // this is the _sustained_ shrink value; largest size that has been requested in the \"stable-for-shrinking\" period:\n        long minDesiredPoolSize = downsizeSummary.max;\n        boolean stableForShrinking = downsizeSummary.stableForShrinking;\n        \n        // (it is a logical consequence of the above that minDesired >= maxDesired -- this is correct, if confusing:\n        // think of minDesired as the minimum size we are allowed to resize to, and similarly for maxDesired; \n        // if min > max we can scale to max if current < max, or scale to min if current > min)\n\n        long desiredPoolSize;\n        \n        boolean stable;\n        \n        if (currentPoolSize < maxDesiredPoolSize) {\n            // we have valid request to grow \n            // (we'll never have a valid request to grow and a valid to shrink simultaneously, btw)\n            desiredPoolSize = maxDesiredPoolSize;\n            stable = stableForGrowing;\n        } else if (currentPoolSize > minDesiredPoolSize) {\n            // we have valid request to shrink\n            desiredPoolSize = minDesiredPoolSize;\n            stable = stableForShrinking;\n        } else {\n            desiredPoolSize = currentPoolSize;\n            stable = stableForGrowing && stableForShrinking;\n        }\n\n        if (LOG.isTraceEnabled()) LOG.trace(\"{} calculated desired pool size: from {} to {}; minDesired {}, maxDesired {}; \" +\n                \"stable {}; now {}; downsizeHistory {}; upsizeHistory {}\", \n                new Object[] {this, currentPoolSize, desiredPoolSize, minDesiredPoolSize, maxDesiredPoolSize, stable, now, downsizeSummary, upsizeSummary});\n        \n        return new CalculatedDesiredPoolSize(desiredPoolSize, stable);\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private void scheduleResize() {\n        // TODO Make scale-out calls concurrent, rather than waiting for first resize to entirely \n        // finish. On ec2 for example, this can cause us to grow very slowly if first request is for\n        // just one new VM to be provisioned.\n        \n        if (isRunning() && isEntityUp() && executorQueued.compareAndSet(false, true)) {\n            long now = System.currentTimeMillis();\n            long delay = Math.max(0, (executorTime + getMinPeriodBetweenExecs()) - now);\n            if (LOG.isTraceEnabled()) LOG.trace(\"{} scheduling resize in {}ms\", this, delay);\n            \n            executor.schedule(new Runnable() {\n                @Override public void run() {\n                    try {\n                        executorTime = System.currentTimeMillis();\n                        executorQueued.set(false);\n\n                        resizeNow();\n                        notifyMaxReachedIfRequiredNow();\n                        \n                    } catch (Exception e) {\n                        if (isRunning()) {\n                            LOG.error(\"Error resizing: \"+e, e);\n                        } else {\n                            if (LOG.isDebugEnabled()) LOG.debug(\"Error resizing, but no longer running: \"+e, e);\n                        }\n                    } catch (Throwable t) {\n                        LOG.error(\"Error resizing: \"+t, t);\n                        throw Throwables.propagate(t);\n                    }\n                }},\n                delay,\n                TimeUnit.MILLISECONDS);\n        }\n    }","id":29156,"modified_method":"private void scheduleResize() {\n        // TODO Make scale-out calls concurrent, rather than waiting for first resize to entirely \n        // finish. On ec2 for example, this can cause us to grow very slowly if first request is for\n        // just one new VM to be provisioned.\n        \n        if (isRunning() && isEntityUp() && executorQueued.compareAndSet(false, true)) {\n            long now = System.currentTimeMillis();\n            long delay = Math.max(0, (executorTime + getMinPeriodBetweenExecs().toMilliseconds()) - now);\n            if (LOG.isTraceEnabled()) LOG.trace(\"{} scheduling resize in {}ms\", this, delay);\n            \n            executor.schedule(new Runnable() {\n                @Override public void run() {\n                    try {\n                        executorTime = System.currentTimeMillis();\n                        executorQueued.set(false);\n\n                        resizeNow();\n                        notifyMaxReachedIfRequiredNow();\n                        \n                    } catch (Exception e) {\n                        if (isRunning()) {\n                            LOG.error(\"Error resizing: \"+e, e);\n                        } else {\n                            if (LOG.isDebugEnabled()) LOG.debug(\"Error resizing, but no longer running: \"+e, e);\n                        }\n                    } catch (Throwable t) {\n                        LOG.error(\"Error resizing: \"+t, t);\n                        throw Throwables.propagate(t);\n                    }\n                }},\n                delay,\n                TimeUnit.MILLISECONDS);\n        }\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    protected <T> void doReconfigureConfig(ConfigKey<T> key, T val) {\n        if (key.equals(RESIZE_UP_STABILIZATION_DELAY)) {\n            long maxResizeStabilizationDelay = Math.max((Long)val, getResizeDownStabilizationDelay());\n            recentDesiredResizes.setWindowSize(maxResizeStabilizationDelay);\n        } else if (key.equals(RESIZE_DOWN_STABILIZATION_DELAY)) {\n            long maxResizeStabilizationDelay = Math.max((Long)val, getResizeUpStabilizationDelay());\n            recentDesiredResizes.setWindowSize(maxResizeStabilizationDelay);\n        } else if (key.equals(METRIC_LOWER_BOUND)) {\n            // TODO If recorded what last metric value was then we could recalculate immediately\n            // Rely on next metric-change to trigger recalculation; \n            // and same for those below...\n        } else if (key.equals(METRIC_UPPER_BOUND)) {\n\n        } else if (key.equals(MIN_POOL_SIZE)) {\n            int newMin = (Integer) val;\n            if (newMin > getConfig(MAX_POOL_SIZE)) {\n                throw new IllegalArgumentException(\"Min pool size \"+val+\" must not be greater than max pool size \"+getConfig(MAX_POOL_SIZE));\n            }\n            onPoolSizeLimitsChanged(newMin, getConfig(MAX_POOL_SIZE));\n        } else if (key.equals(MAX_POOL_SIZE)) {\n            int newMax = (Integer) val;\n            if (newMax < getConfig(MIN_POOL_SIZE)) {\n                throw new IllegalArgumentException(\"Min pool size \"+val+\" must not be greater than max pool size \"+getConfig(MAX_POOL_SIZE));\n            }\n            onPoolSizeLimitsChanged(getConfig(MIN_POOL_SIZE), newMax);\n        } else {\n            throw new UnsupportedOperationException(\"reconfiguring \"+key+\" unsupported for \"+this);\n        }\n    }","id":29157,"modified_method":"@Override\n    protected <T> void doReconfigureConfig(ConfigKey<T> key, T val) {\n        if (key.equals(RESIZE_UP_STABILIZATION_DELAY)) {\n            long maxResizeStabilizationDelay = Math.max(((Duration)val).toMilliseconds(), getResizeDownStabilizationDelay().toMilliseconds());\n            recentDesiredResizes.setWindowSize(maxResizeStabilizationDelay);\n        } else if (key.equals(RESIZE_DOWN_STABILIZATION_DELAY)) {\n            long maxResizeStabilizationDelay = Math.max(((Duration)val).toMilliseconds(), getResizeUpStabilizationDelay().toMilliseconds());\n            recentDesiredResizes.setWindowSize(maxResizeStabilizationDelay);\n        } else if (key.equals(METRIC_LOWER_BOUND)) {\n            // TODO If recorded what last metric value was then we could recalculate immediately\n            // Rely on next metric-change to trigger recalculation; \n            // and same for those below...\n        } else if (key.equals(METRIC_UPPER_BOUND)) {\n\n        } else if (key.equals(MIN_POOL_SIZE)) {\n            int newMin = (Integer) val;\n            if (newMin > getConfig(MAX_POOL_SIZE)) {\n                throw new IllegalArgumentException(\"Min pool size \"+val+\" must not be greater than max pool size \"+getConfig(MAX_POOL_SIZE));\n            }\n            onPoolSizeLimitsChanged(newMin, getConfig(MAX_POOL_SIZE));\n        } else if (key.equals(MAX_POOL_SIZE)) {\n            int newMax = (Integer) val;\n            if (newMax < getConfig(MIN_POOL_SIZE)) {\n                throw new IllegalArgumentException(\"Min pool size \"+val+\" must not be greater than max pool size \"+getConfig(MAX_POOL_SIZE));\n            }\n            onPoolSizeLimitsChanged(getConfig(MIN_POOL_SIZE), newMax);\n        } else {\n            throw new UnsupportedOperationException(\"reconfiguring \"+key+\" unsupported for \"+this);\n        }\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Looks at the values for \"unbounded pool size\" (i.e. if we ignore caps of minSize and maxSize) to report what\n     * those values have been within a time window. The time window used is the \"maxReachedNotificationDelay\",\n     * which determines how many milliseconds after being consistently above the max-size will it take before\n     * we emit the sensor event (if any).\n     */\n    private void notifyMaxReachedIfRequiredNow() {\n        BasicNotificationSensor<? super MaxPoolSizeReachedEvent> maxSizeReachedSensor = getMaxSizeReachedSensor();\n        if (maxSizeReachedSensor == null) {\n            return;\n        }\n        \n        WindowSummary valsSummary = recentUnboundedResizes.summarizeWindow(getMaxReachedNotificationDelay());\n        long timeWindowSize = getMaxReachedNotificationDelay();\n        long currentPoolSize = getCurrentSizeOperator().apply(poolEntity);\n        int maxAllowedPoolSize = getMaxPoolSize();\n        long unboundedSustainedMaxPoolSize = valsSummary.min; // The sustained maximum (i.e. the smallest it's dropped down to)\n        long unboundedCurrentPoolSize = valsSummary.latest;\n        \n        if (maxReachedLastNotifiedTime > 0) {\n            // already notified the listener; don't do it again\n            // TODO Could have max period for notifications, or a step increment to warn when exceeded by ever bigger amounts\n            \n        } else if (unboundedSustainedMaxPoolSize > maxAllowedPoolSize) {\n            // We have consistently wanted to be bigger than the max allowed; tell the listener\n            if (LOG.isDebugEnabled()) LOG.debug(\"{} notifying listener of max pool size reached; current {}, max {}, unbounded current {}, unbounded max {}\", \n                    new Object[] {this, currentPoolSize, maxAllowedPoolSize, unboundedCurrentPoolSize, unboundedSustainedMaxPoolSize});\n            \n            maxReachedLastNotifiedTime = System.currentTimeMillis();\n            MaxPoolSizeReachedEvent event = MaxPoolSizeReachedEvent.builder()\n                    .currentPoolSize(currentPoolSize)\n                    .maxAllowed(maxAllowedPoolSize)\n                    .currentUnbounded(unboundedCurrentPoolSize)\n                    .maxUnbounded(unboundedSustainedMaxPoolSize)\n                    .timeWindow(timeWindowSize)\n                    .build();\n            entity.emit(maxSizeReachedSensor, event);\n            \n        } else if (valsSummary.max > maxAllowedPoolSize) {\n            // We temporarily wanted to be bigger than the max allowed; check back later to see if consistent\n            // TODO Could check if there has been anything bigger than \"min\" since min happened (would be more efficient)\n            if (LOG.isTraceEnabled()) LOG.trace(\"{} re-scheduling max-reached check for {}, as unbounded size not stable (min {}, max {}, latest {})\", \n                    new Object[] {this, poolEntity, valsSummary.min, valsSummary.max, valsSummary.latest});\n            scheduleResize();\n            \n        } else {\n            // nothing to write home about; continually below maxAllowed\n        }\n    }","id":29158,"modified_method":"/**\n     * Looks at the values for \"unbounded pool size\" (i.e. if we ignore caps of minSize and maxSize) to report what\n     * those values have been within a time window. The time window used is the \"maxReachedNotificationDelay\",\n     * which determines how many milliseconds after being consistently above the max-size will it take before\n     * we emit the sensor event (if any).\n     */\n    private void notifyMaxReachedIfRequiredNow() {\n        BasicNotificationSensor<? super MaxPoolSizeReachedEvent> maxSizeReachedSensor = getMaxSizeReachedSensor();\n        if (maxSizeReachedSensor == null) {\n            return;\n        }\n        \n        WindowSummary valsSummary = recentUnboundedResizes.summarizeWindow(getMaxReachedNotificationDelay().toMilliseconds());\n        long timeWindowSize = getMaxReachedNotificationDelay().toMilliseconds();\n        long currentPoolSize = getCurrentSizeOperator().apply(poolEntity);\n        int maxAllowedPoolSize = getMaxPoolSize();\n        long unboundedSustainedMaxPoolSize = valsSummary.min; // The sustained maximum (i.e. the smallest it's dropped down to)\n        long unboundedCurrentPoolSize = valsSummary.latest;\n        \n        if (maxReachedLastNotifiedTime > 0) {\n            // already notified the listener; don't do it again\n            // TODO Could have max period for notifications, or a step increment to warn when exceeded by ever bigger amounts\n            \n        } else if (unboundedSustainedMaxPoolSize > maxAllowedPoolSize) {\n            // We have consistently wanted to be bigger than the max allowed; tell the listener\n            if (LOG.isDebugEnabled()) LOG.debug(\"{} notifying listener of max pool size reached; current {}, max {}, unbounded current {}, unbounded max {}\", \n                    new Object[] {this, currentPoolSize, maxAllowedPoolSize, unboundedCurrentPoolSize, unboundedSustainedMaxPoolSize});\n            \n            maxReachedLastNotifiedTime = System.currentTimeMillis();\n            MaxPoolSizeReachedEvent event = MaxPoolSizeReachedEvent.builder()\n                    .currentPoolSize(currentPoolSize)\n                    .maxAllowed(maxAllowedPoolSize)\n                    .currentUnbounded(unboundedCurrentPoolSize)\n                    .maxUnbounded(unboundedSustainedMaxPoolSize)\n                    .timeWindow(timeWindowSize)\n                    .build();\n            entity.emit(maxSizeReachedSensor, event);\n            \n        } else if (valsSummary.max > maxAllowedPoolSize) {\n            // We temporarily wanted to be bigger than the max allowed; check back later to see if consistent\n            // TODO Could check if there has been anything bigger than \"min\" since min happened (would be more efficient)\n            if (LOG.isTraceEnabled()) LOG.trace(\"{} re-scheduling max-reached check for {}, as unbounded size not stable (min {}, max {}, latest {})\", \n                    new Object[] {this, poolEntity, valsSummary.min, valsSummary.max, valsSummary.latest});\n            scheduleResize();\n            \n        } else {\n            // nothing to write home about; continually below maxAllowed\n        }\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testReconfigureResizeUpStabilizationDelay() {\n        tc.resize(1);\n        \n        AutoScalerPolicy policy = new AutoScalerPolicy.Builder().metric(MY_ATTRIBUTE)\n                .metricLowerBound(50).metricUpperBound(100)\n                .resizeUpStabilizationDelay(100000)\n                .build();\n        tc.addPolicy(policy);\n\n        policy.setConfig(AutoScalerPolicy.RESIZE_UP_STABILIZATION_DELAY, 0L);\n\n        tc.setAttribute(MY_ATTRIBUTE, 101);\n        executeUntilSucceeds(ImmutableMap.of(\"timeout\", TIMEOUT_MS), currentSizeAsserter(tc, 2));\n    }","id":29159,"modified_method":"@Test\n    public void testReconfigureResizeUpStabilizationDelay() {\n        tc.resize(1);\n        \n        AutoScalerPolicy policy = new AutoScalerPolicy.Builder().metric(MY_ATTRIBUTE)\n                .metricLowerBound(50).metricUpperBound(100)\n                .resizeUpStabilizationDelay(100000)\n                .build();\n        tc.addPolicy(policy);\n\n        policy.setConfig(AutoScalerPolicy.RESIZE_UP_STABILIZATION_DELAY, Duration.ZERO);\n\n        tc.setAttribute(MY_ATTRIBUTE, 101);\n        executeUntilSucceeds(ImmutableMap.of(\"timeout\", TIMEOUT_MS), currentSizeAsserter(tc, 2));\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testReconfigureResizeDownStabilizationDelay() {\n        tc.resize(2);\n        \n        AutoScalerPolicy policy = new AutoScalerPolicy.Builder().metric(MY_ATTRIBUTE)\n                .metricLowerBound(50).metricUpperBound(100)\n                .resizeDownStabilizationDelay(100000)\n                .build();\n        tc.addPolicy(policy);\n\n        policy.setConfig(AutoScalerPolicy.RESIZE_DOWN_STABILIZATION_DELAY, 0L);\n\n        tc.setAttribute(MY_ATTRIBUTE, 1);\n        executeUntilSucceeds(ImmutableMap.of(\"timeout\", TIMEOUT_MS), currentSizeAsserter(tc, 1));\n    }","id":29160,"modified_method":"@Test\n    public void testReconfigureResizeDownStabilizationDelay() {\n        tc.resize(2);\n        \n        AutoScalerPolicy policy = new AutoScalerPolicy.Builder().metric(MY_ATTRIBUTE)\n                .metricLowerBound(50).metricUpperBound(100)\n                .resizeDownStabilizationDelay(100000)\n                .build();\n        tc.addPolicy(policy);\n\n        policy.setConfig(AutoScalerPolicy.RESIZE_DOWN_STABILIZATION_DELAY, Duration.ZERO);\n\n        tc.setAttribute(MY_ATTRIBUTE, 1);\n        executeUntilSucceeds(ImmutableMap.of(\"timeout\", TIMEOUT_MS), currentSizeAsserter(tc, 1));\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected synchronized void onDetectedFailure(SensorEvent<Object> event) {\n        if (isSuspended()) {\n            LOG.warn(\"ServiceRestarter suspended, so not acting on failure detected at \"+entity+\" (\"+event.getValue()+\")\");\n            return;\n        }\n\n        LOG.warn(\"ServiceRestarter acting on failure detected at \"+entity+\" (\"+event.getValue()+\")\");\n        long current = System.currentTimeMillis();\n        Long last = lastFailureTime.getAndSet(current);\n        long elapsed = last==null ? -1 : current-last;\n        if (elapsed>=0 && elapsed <= getConfig(FAIL_ON_RECURRING_FAILURES_IN_THIS_DURATION)) {\n            onRestartFailed(\"Restart failure (failed again after \"+Time.makeTimeStringRounded(elapsed)+\") at \"+entity+\": \"+event.getValue());\n            return;\n        }\n        try {\n            entity.setAttribute(Attributes.SERVICE_STATE, Lifecycle.STARTING);\n            Entities.invokeEffector(entity, entity, Startable.RESTART).get();\n        } catch (Exception e) {\n            onRestartFailed(\"Restart failure (error \"+e+\") at \"+entity+\": \"+event.getValue());\n        }\n    }","id":29161,"modified_method":"protected synchronized void onDetectedFailure(SensorEvent<Object> event) {\n        if (isSuspended()) {\n            LOG.warn(\"ServiceRestarter suspended, so not acting on failure detected at \"+entity+\" (\"+event.getValue()+\")\");\n            return;\n        }\n\n        LOG.warn(\"ServiceRestarter acting on failure detected at \"+entity+\" (\"+event.getValue()+\")\");\n        long current = System.currentTimeMillis();\n        Long last = lastFailureTime.getAndSet(current);\n        long elapsed = last==null ? -1 : current-last;\n        if (elapsed>=0 && elapsed <= getConfig(FAIL_ON_RECURRING_FAILURES_IN_THIS_DURATION).toMilliseconds()) {\n            onRestartFailed(\"Restart failure (failed again after \"+Time.makeTimeStringRounded(elapsed)+\") at \"+entity+\": \"+event.getValue());\n            return;\n        }\n        try {\n            entity.setAttribute(Attributes.SERVICE_STATE, Lifecycle.STARTING);\n            Entities.invokeEffector(entity, entity, Startable.RESTART).get();\n        } catch (Exception e) {\n            onRestartFailed(\"Restart failure (error \"+e+\") at \"+entity+\": \"+event.getValue());\n        }\n    }","commit_id":"1ba912cb71b4ea4cc915047f2e168eb76087d31e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        Sink sink = getSink();\n\n        PMD pmd = getPMD();\n        RuleContext ruleContext = new RuleContext();\n        Report report = new Report();\n        // TODO: use source roots instead\n        String sourceDirectory = getProject().getBuild().getSourceDirectory();\n        PmdReportListener reportSink = new PmdReportListener( sink, sourceDirectory, getBundle( locale ) );\n        if ( linkXref )\n        {\n            reportSink.setXrefLocation( xrefLocation );\n        }\n\n        report.addListener( reportSink );\n        ruleContext.setReport( report );\n        reportSink.beginDocument();\n\n        List files;\n        try\n        {\n            files = getFilesToProcess( \"**/*.java\", null );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Can't parse \" + sourceDirectory, e );\n        }\n\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        RuleSet[] sets = new RuleSet[rulesets.length];\n        for ( int idx = 0; idx < rulesets.length; idx++ )\n        {\n            String set = rulesets[idx];\n            String location = \"/rulesets/\" + set + \".xml\";\n            getLog().debug( \"Preparing \" + set + \" ruleset found in classpath:\" + location );\n            InputStream rulesInput = pmd.getClass().getResourceAsStream( location );\n            sets[idx] = ruleSetFactory.createRuleSet( rulesInput );\n        }\n\n        for ( Iterator i = files.iterator(); i.hasNext(); )\n        {\n            File file = (File) i.next();\n\n            try\n            {\n                // TODO: lazily call beginFile in case there are no rules\n\n                reportSink.beginFile( file );\n                ruleContext.setSourceCodeFilename( file.getAbsolutePath() );\n                for ( int idx = 0; idx < rulesets.length; idx++ )\n                {\n                    // PMD closes this Reader even though it did not open it.\n                    pmd.processFile( new FileReader( file ), sets[idx], ruleContext );\n                }\n                reportSink.endFile( file );\n            }\n            catch ( PMDException e )\n            {\n                Exception ex = e;\n                if ( e.getReason() != null )\n                {\n                    ex = e.getReason();\n                }\n                throw new MavenReportException( \"Failure executing PMD for: \" + file, ex );\n            }\n            catch ( FileNotFoundException e )\n            {\n                throw new MavenReportException( \"Error opening source file: \" + file, e );\n            }\n        }\n        reportSink.endDocument();\n        \n        if ( !isHtml() )\n        {\n            // Use the PMD renderers to render in any format aside from HTML.\n            Renderer r = createRenderer();\n            String buffer = r.render( report );\n            try\n            {\n                Writer writer = new FileWriter( new File( this.getReportOutputDirectory(), \"pmd.\" + format ) );\n                writer.write( buffer, 0, buffer.length() );\n                writer.close();\n            }\n            catch ( IOException ioe )\n            {\n                throw new MavenReportException( ioe.getMessage(), ioe );\n            }\n        }\n    }","id":29162,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        Sink sink = getSink();\n\n        PMD pmd = getPMD();\n        RuleContext ruleContext = new RuleContext();\n        Report report = new Report();\n        // TODO: use source roots instead\n        String sourceDirectory = getProject().getBuild().getSourceDirectory();\n        PmdReportListener reportSink = new PmdReportListener( sink, sourceDirectory, getBundle( locale ) );\n        if ( linkXref )\n        {\n            reportSink.setXrefLocation( xrefLocation );\n        }\n\n        report.addListener( reportSink );\n        ruleContext.setReport( report );\n        reportSink.beginDocument();\n\n        List files;\n        try\n        {\n            files = getFilesToProcess( \"**/*.java\", null );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Can't parse \" + sourceDirectory, e );\n        }\n\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        RuleSet[] sets = new RuleSet[rulesets.length];\n        for ( int idx = 0; idx < rulesets.length; idx++ )\n        {\n            String set = rulesets[idx];\n            String location = \"/rulesets/\" + set + \".xml\";\n            getLog().debug( \"Preparing \" + set + \" ruleset found in classpath:\" + location );\n            InputStream rulesInput = pmd.getClass().getResourceAsStream( location );\n            sets[idx] = ruleSetFactory.createRuleSet( rulesInput );\n        }\n        \n        boolean hasEncoding = sourceEncoding != null;\n\n        for ( Iterator i = files.iterator(); i.hasNext(); )\n        {\n            File file = (File) i.next();\n\n            try\n            {\n                // TODO: lazily call beginFile in case there are no rules\n\n                reportSink.beginFile( file );\n                ruleContext.setSourceCodeFilename( file.getAbsolutePath() );\n                for ( int idx = 0; idx < rulesets.length; idx++ )\n                {\n                    try\n                    {\n                        // PMD closes this Reader even though it did not open it so we have\n                        // to open a new one with every call to processFile().\n                        Reader reader = hasEncoding ? new InputStreamReader( new FileInputStream( file ), sourceEncoding ) \n                                                    : new FileReader( file );\n                        pmd.processFile( reader, sets[idx], ruleContext );\n                    }\n                    catch ( UnsupportedEncodingException e1 )\n                    {\n                        throw new MavenReportException( \"Encoding '\" + sourceEncoding + \"' is not supported.\", e1 );\n                    }\n                }\n                reportSink.endFile( file );\n            }\n            catch ( PMDException e )\n            {\n                Exception ex = e;\n                if ( e.getReason() != null )\n                {\n                    ex = e.getReason();\n                }\n                throw new MavenReportException( \"Failure executing PMD for: \" + file, ex );\n            }\n            catch ( FileNotFoundException e )\n            {\n                throw new MavenReportException( \"Error opening source file: \" + file, e );\n            }\n        }\n        reportSink.endDocument();\n        \n        if ( !isHtml() )\n        {\n            // Use the PMD renderers to render in any format aside from HTML.\n            Renderer r = createRenderer();\n            String buffer = r.render( report );\n            try\n            {\n                Writer writer = new FileWriter( new File( this.getReportOutputDirectory(), \"pmd.\" + format ) );\n                writer.write( buffer, 0, buffer.length() );\n                writer.close();\n            }\n            catch ( IOException ioe )\n            {\n                throw new MavenReportException( ioe.getMessage(), ioe );\n            }\n        }\n    }","commit_id":"0ea76725dd69e47590735b691866226f70e75b76","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** @return whether the migration requires next round */\n    private boolean processRecursively(String parent, HdfsFileStatus status) {\n      String fullPath = status.getFullName(parent);\n      boolean hasRemaining = false;\n      if (status.isDir()) {\n        if (!fullPath.endsWith(Path.SEPARATOR)) {\n          fullPath = fullPath + Path.SEPARATOR;\n        }\n\n        hasRemaining = processPath(fullPath);\n        // process snapshots if this is a snapshottable directory\n        if (snapshottableDirs.contains(fullPath)) {\n          final String dirSnapshot = fullPath + HdfsConstants.DOT_SNAPSHOT_DIR;\n          hasRemaining |= processPath(dirSnapshot);\n        }\n      } else if (!status.isSymlink()) { // file\n        try {\n          if (!isSnapshotPathInCurrent(fullPath)) {\n            // the full path is a snapshot path but it is also included in the\n            // current directory tree, thus ignore it.\n            hasRemaining = processFile(fullPath, (HdfsLocatedFileStatus)status);\n          }\n        } catch (IOException e) {\n          LOG.warn(\"Failed to check the status of \" + parent\n              + \". Ignore it and continue.\", e);\n          return false;\n        }\n      }\n      return hasRemaining;\n    }","id":29163,"modified_method":"/** @return whether the migration requires next round */\n    private void processRecursively(String parent, HdfsFileStatus status,\n        Result result) {\n      String fullPath = status.getFullName(parent);\n      if (status.isDir()) {\n        if (!fullPath.endsWith(Path.SEPARATOR)) {\n          fullPath = fullPath + Path.SEPARATOR;\n        }\n\n        processPath(fullPath, result);\n        // process snapshots if this is a snapshottable directory\n        if (snapshottableDirs.contains(fullPath)) {\n          final String dirSnapshot = fullPath + HdfsConstants.DOT_SNAPSHOT_DIR;\n          processPath(dirSnapshot, result);\n        }\n      } else if (!status.isSymlink()) { // file\n        try {\n          if (!isSnapshotPathInCurrent(fullPath)) {\n            // the full path is a snapshot path but it is also included in the\n            // current directory tree, thus ignore it.\n            processFile(fullPath, (HdfsLocatedFileStatus) status, result);\n          }\n        } catch (IOException e) {\n          LOG.warn(\"Failed to check the status of \" + parent\n              + \". Ignore it and continue.\", e);\n        }\n      }\n    }","commit_id":"321940cf19375febe9660e96d905360cfcc15f5f","url":"https://github.com/apache/hadoop"},{"original_method":"/** @return true if it is necessary to run another round of migration */\n    private boolean processFile(String fullPath, HdfsLocatedFileStatus status) {\n      final byte policyId = status.getStoragePolicy();\n      // currently we ignore files with unspecified storage policy\n      if (policyId == HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n        return false;\n      }\n      final BlockStoragePolicy policy = blockStoragePolicies[policyId];\n      if (policy == null) {\n        LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n        return false;\n      }\n      final List<StorageType> types = policy.chooseStorageTypes(\n          status.getReplication());\n\n      final LocatedBlocks locatedBlocks = status.getBlockLocations();\n      boolean hasRemaining = false;\n      final boolean lastBlkComplete = locatedBlocks.isLastBlockComplete();\n      List<LocatedBlock> lbs = locatedBlocks.getLocatedBlocks();\n      for(int i = 0; i < lbs.size(); i++) {\n        if (i == lbs.size() - 1 && !lastBlkComplete) {\n          // last block is incomplete, skip it\n          continue;\n        }\n        LocatedBlock lb = lbs.get(i);\n        final StorageTypeDiff diff = new StorageTypeDiff(types,\n            lb.getStorageTypes());\n        if (!diff.removeOverlap(true)) {\n          if (scheduleMoves4Block(diff, lb)) {\n            hasRemaining |= (diff.existing.size() > 1 &&\n                diff.expected.size() > 1);\n          }\n        }\n      }\n      return hasRemaining;\n    }","id":29164,"modified_method":"/** @return true if it is necessary to run another round of migration */\n    private void processFile(String fullPath, HdfsLocatedFileStatus status,\n        Result result) {\n      final byte policyId = status.getStoragePolicy();\n      // currently we ignore files with unspecified storage policy\n      if (policyId == HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n        return;\n      }\n      final BlockStoragePolicy policy = blockStoragePolicies[policyId];\n      if (policy == null) {\n        LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n        return;\n      }\n      final List<StorageType> types = policy.chooseStorageTypes(\n          status.getReplication());\n\n      final LocatedBlocks locatedBlocks = status.getBlockLocations();\n      final boolean lastBlkComplete = locatedBlocks.isLastBlockComplete();\n      List<LocatedBlock> lbs = locatedBlocks.getLocatedBlocks();\n      for (int i = 0; i < lbs.size(); i++) {\n        if (i == lbs.size() - 1 && !lastBlkComplete) {\n          // last block is incomplete, skip it\n          continue;\n        }\n        LocatedBlock lb = lbs.get(i);\n        final StorageTypeDiff diff = new StorageTypeDiff(types,\n            lb.getStorageTypes());\n        if (!diff.removeOverlap(true)) {\n          if (scheduleMoves4Block(diff, lb)) {\n            result.updateHasRemaining(diff.existing.size() > 1\n                && diff.expected.size() > 1);\n            // One block scheduled successfully, set noBlockMoved to false\n            result.setNoBlockMoved(false);\n          } else {\n            result.updateHasRemaining(true);\n          }\n        }\n      }\n    }","commit_id":"321940cf19375febe9660e96d905360cfcc15f5f","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n     * @return whether there is still remaing migration work for the next\n     *         round\n     */\n    private boolean processPath(String fullPath) {\n      boolean hasRemaining = false;\n      for (byte[] lastReturnedName = HdfsFileStatus.EMPTY_NAME;;) {\n        final DirectoryListing children;\n        try {\n          children = dfs.listPaths(fullPath, lastReturnedName, true);\n        } catch(IOException e) {\n          LOG.warn(\"Failed to list directory \" + fullPath\n              + \". Ignore the directory and continue.\", e);\n          return hasRemaining;\n        }\n        if (children == null) {\n          return hasRemaining;\n        }\n        for (HdfsFileStatus child : children.getPartialListing()) {\n          hasRemaining |= processRecursively(fullPath, child);\n        }\n        if (children.hasMore()) {\n          lastReturnedName = children.getLastName();\n        } else {\n          return hasRemaining;\n        }\n      }\n    }","id":29165,"modified_method":"/**\n     * @return whether there is still remaing migration work for the next\n     *         round\n     */\n    private void processPath(String fullPath, Result result) {\n      for (byte[] lastReturnedName = HdfsFileStatus.EMPTY_NAME;;) {\n        final DirectoryListing children;\n        try {\n          children = dfs.listPaths(fullPath, lastReturnedName, true);\n        } catch(IOException e) {\n          LOG.warn(\"Failed to list directory \" + fullPath\n              + \". Ignore the directory and continue.\", e);\n          return;\n        }\n        if (children == null) {\n          return;\n        }\n        for (HdfsFileStatus child : children.getPartialListing()) {\n          processRecursively(fullPath, child, result);\n        }\n        if (children.hasMore()) {\n          lastReturnedName = children.getLastName();\n        } else {\n          return;\n        }\n      }\n    }","commit_id":"321940cf19375febe9660e96d905360cfcc15f5f","url":"https://github.com/apache/hadoop"},{"original_method":"private ExitStatus run() {\n    try {\n      init();\n      boolean hasRemaining = new Processor().processNamespace();\n      return hasRemaining ? ExitStatus.IN_PROGRESS : ExitStatus.SUCCESS;\n    } catch (IllegalArgumentException e) {\n      System.out.println(e + \".  Exiting ...\");\n      return ExitStatus.ILLEGAL_ARGUMENTS;\n    } catch (IOException e) {\n      System.out.println(e + \".  Exiting ...\");\n      return ExitStatus.IO_EXCEPTION;\n    } finally {\n      dispatcher.shutdownNow();\n    }\n  }","id":29166,"modified_method":"private ExitStatus run() {\n    try {\n      init();\n      return new Processor().processNamespace().getExitStatus();\n    } catch (IllegalArgumentException e) {\n      System.out.println(e + \".  Exiting ...\");\n      return ExitStatus.ILLEGAL_ARGUMENTS;\n    } catch (IOException e) {\n      System.out.println(e + \".  Exiting ...\");\n      return ExitStatus.IO_EXCEPTION;\n    } finally {\n      dispatcher.shutdownNow();\n    }\n  }","commit_id":"321940cf19375febe9660e96d905360cfcc15f5f","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n     * @return whether there is still remaining migration work for the next\n     *         round\n     */\n    private boolean processNamespace() throws IOException {\n      getSnapshottableDirs();\n      boolean hasRemaining = false;\n      for (Path target : targetPaths) {\n        hasRemaining |= processPath(target.toUri().getPath());\n      }\n      // wait for pending move to finish and retry the failed migration\n      boolean hasFailed = Dispatcher.waitForMoveCompletion(storages.targets\n          .values());\n      if (hasFailed) {\n        if (retryCount.get() == retryMaxAttempts) {\n          throw new IOException(\"Failed to move some block's after \"\n              + retryMaxAttempts + \" retries.\");\n        } else {\n          retryCount.incrementAndGet();\n        }\n      } else {\n        // Reset retry count if no failure.\n        retryCount.set(0);\n      }\n      hasRemaining |= hasFailed;\n      return hasRemaining;\n    }","id":29167,"modified_method":"/**\n     * @return whether there is still remaining migration work for the next\n     *         round\n     */\n    private Result processNamespace() throws IOException {\n      getSnapshottableDirs();\n      Result result = new Result();\n      for (Path target : targetPaths) {\n        processPath(target.toUri().getPath(), result);\n      }\n      // wait for pending move to finish and retry the failed migration\n      boolean hasFailed = Dispatcher.waitForMoveCompletion(storages.targets\n          .values());\n      if (hasFailed) {\n        if (retryCount.get() == retryMaxAttempts) {\n          throw new IOException(\"Failed to move some block's after \"\n              + retryMaxAttempts + \" retries.\");\n        } else {\n          retryCount.incrementAndGet();\n        }\n      } else {\n        // Reset retry count if no failure.\n        retryCount.set(0);\n      }\n      result.updateHasRemaining(hasFailed);\n      return result;\n    }","commit_id":"321940cf19375febe9660e96d905360cfcc15f5f","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Move an open file into archival storage\n   */\n  @Test\n  public void testMigrateOpenFileToArchival() throws Exception {\n    LOG.info(\"testMigrateOpenFileToArchival\");\n    final Path fooDir = new Path(\"/foo\");\n    Map<Path, BlockStoragePolicy> policyMap = Maps.newHashMap();\n    policyMap.put(fooDir, COLD);\n    NamespaceScheme nsScheme = new NamespaceScheme(Arrays.asList(fooDir), null,\n        BLOCK_SIZE, null, policyMap);\n    ClusterScheme clusterScheme = new ClusterScheme(DEFAULT_CONF,\n        NUM_DATANODES, REPL, genStorageTypes(NUM_DATANODES), null);\n    MigrationTest test = new MigrationTest(clusterScheme, nsScheme);\n    test.setupCluster();\n\n    // create an open file\n    banner(\"writing to file /foo/bar\");\n    final Path barFile = new Path(fooDir, \"bar\");\n    DFSTestUtil.createFile(test.dfs, barFile, BLOCK_SIZE, (short) 1, 0L);\n    FSDataOutputStream out = test.dfs.append(barFile);\n    out.writeBytes(\"hello, \");\n    ((DFSOutputStream) out.getWrappedStream()).hsync();\n\n    try {\n      banner(\"start data migration\");\n      test.setStoragePolicy(); // set /foo to COLD\n      test.migrate();\n\n      // make sure the under construction block has not been migrated\n      LocatedBlocks lbs = test.dfs.getClient().getLocatedBlocks(\n          barFile.toString(), BLOCK_SIZE);\n      LOG.info(\"Locations: \" + lbs);\n      List<LocatedBlock> blks = lbs.getLocatedBlocks();\n      Assert.assertEquals(1, blks.size());\n      Assert.assertEquals(1, blks.get(0).getLocations().length);\n\n      banner(\"finish the migration, continue writing\");\n      // make sure the writing can continue\n      out.writeBytes(\"world!\");\n      ((DFSOutputStream) out.getWrappedStream()).hsync();\n      IOUtils.cleanup(LOG, out);\n\n      lbs = test.dfs.getClient().getLocatedBlocks(\n          barFile.toString(), BLOCK_SIZE);\n      LOG.info(\"Locations: \" + lbs);\n      blks = lbs.getLocatedBlocks();\n      Assert.assertEquals(1, blks.size());\n      Assert.assertEquals(1, blks.get(0).getLocations().length);\n\n      banner(\"finish writing, starting reading\");\n      // check the content of /foo/bar\n      FSDataInputStream in = test.dfs.open(barFile);\n      byte[] buf = new byte[13];\n      // read from offset 1024\n      in.readFully(BLOCK_SIZE, buf, 0, buf.length);\n      IOUtils.cleanup(LOG, in);\n      Assert.assertEquals(\"hello, world!\", new String(buf));\n    } finally {\n      test.shutdownCluster();\n    }\n  }","id":29168,"modified_method":"/**\n   * Move an open file into archival storage\n   */\n  @Test\n  public void testMigrateOpenFileToArchival() throws Exception {\n    LOG.info(\"testMigrateOpenFileToArchival\");\n    final Path fooDir = new Path(\"/foo\");\n    Map<Path, BlockStoragePolicy> policyMap = Maps.newHashMap();\n    policyMap.put(fooDir, COLD);\n    NamespaceScheme nsScheme = new NamespaceScheme(Arrays.asList(fooDir), null,\n        BLOCK_SIZE, null, policyMap);\n    ClusterScheme clusterScheme = new ClusterScheme(DEFAULT_CONF,\n        NUM_DATANODES, REPL, genStorageTypes(NUM_DATANODES), null);\n    MigrationTest test = new MigrationTest(clusterScheme, nsScheme);\n    test.setupCluster();\n\n    // create an open file\n    banner(\"writing to file /foo/bar\");\n    final Path barFile = new Path(fooDir, \"bar\");\n    DFSTestUtil.createFile(test.dfs, barFile, BLOCK_SIZE, (short) 1, 0L);\n    FSDataOutputStream out = test.dfs.append(barFile);\n    out.writeBytes(\"hello, \");\n    ((DFSOutputStream) out.getWrappedStream()).hsync();\n\n    try {\n      banner(\"start data migration\");\n      test.setStoragePolicy(); // set /foo to COLD\n      test.migrate(ExitStatus.SUCCESS);\n\n      // make sure the under construction block has not been migrated\n      LocatedBlocks lbs = test.dfs.getClient().getLocatedBlocks(\n          barFile.toString(), BLOCK_SIZE);\n      LOG.info(\"Locations: \" + lbs);\n      List<LocatedBlock> blks = lbs.getLocatedBlocks();\n      Assert.assertEquals(1, blks.size());\n      Assert.assertEquals(1, blks.get(0).getLocations().length);\n\n      banner(\"finish the migration, continue writing\");\n      // make sure the writing can continue\n      out.writeBytes(\"world!\");\n      ((DFSOutputStream) out.getWrappedStream()).hsync();\n      IOUtils.cleanup(LOG, out);\n\n      lbs = test.dfs.getClient().getLocatedBlocks(\n          barFile.toString(), BLOCK_SIZE);\n      LOG.info(\"Locations: \" + lbs);\n      blks = lbs.getLocatedBlocks();\n      Assert.assertEquals(1, blks.size());\n      Assert.assertEquals(1, blks.get(0).getLocations().length);\n\n      banner(\"finish writing, starting reading\");\n      // check the content of /foo/bar\n      FSDataInputStream in = test.dfs.open(barFile);\n      byte[] buf = new byte[13];\n      // read from offset 1024\n      in.readFully(BLOCK_SIZE, buf, 0, buf.length);\n      IOUtils.cleanup(LOG, in);\n      Assert.assertEquals(\"hello, world!\", new String(buf));\n    } finally {\n      test.shutdownCluster();\n    }\n  }","commit_id":"321940cf19375febe9660e96d905360cfcc15f5f","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Test DISK is running out of spaces.\n   */\n  @Test\n  public void testNoSpaceDisk() throws Exception {\n    LOG.info(\"testNoSpaceDisk\");\n    final PathPolicyMap pathPolicyMap = new PathPolicyMap(0);\n    final NamespaceScheme nsScheme = pathPolicyMap.newNamespaceScheme();\n\n    Configuration conf = new Configuration(DEFAULT_CONF);\n    final ClusterScheme clusterScheme = new ClusterScheme(conf,\n        NUM_DATANODES, REPL, genStorageTypes(NUM_DATANODES), null);\n    final MigrationTest test = new MigrationTest(clusterScheme, nsScheme);\n\n    try {\n      test.runBasicTest(false);\n\n      // create 2 hot files with replication 3\n      final short replication = 3;\n      for (int i = 0; i < 2; i++) {\n        final Path p = new Path(pathPolicyMap.hot, \"file\" + i);\n        DFSTestUtil.createFile(test.dfs, p, BLOCK_SIZE, replication, 0L);\n        waitForAllReplicas(replication, p, test.dfs);\n      }\n\n      // set all the DISK volume to full\n      for (DataNode dn : test.cluster.getDataNodes()) {\n        setVolumeFull(dn, StorageType.DISK);\n        DataNodeTestUtils.triggerHeartbeat(dn);\n      }\n\n      // test increasing replication.  Since DISK is full,\n      // new replicas should be stored in ARCHIVE as a fallback storage.\n      final Path file0 = new Path(pathPolicyMap.hot, \"file0\");\n      final Replication r = test.getReplication(file0);\n      final short newReplication = (short) 5;\n      test.dfs.setReplication(file0, newReplication);\n      Thread.sleep(10000);\n      test.verifyReplication(file0, r.disk, newReplication - r.disk);\n\n      // test creating a cold file and then increase replication\n      final Path p = new Path(pathPolicyMap.cold, \"foo\");\n      DFSTestUtil.createFile(test.dfs, p, BLOCK_SIZE, replication, 0L);\n      test.verifyReplication(p, 0, replication);\n\n      test.dfs.setReplication(p, newReplication);\n      Thread.sleep(10000);\n      test.verifyReplication(p, 0, newReplication);\n\n      //test move a hot file to warm\n      final Path file1 = new Path(pathPolicyMap.hot, \"file1\");\n      test.dfs.rename(file1, pathPolicyMap.warm);\n      test.migrate();\n      test.verifyFile(new Path(pathPolicyMap.warm, \"file1\"), WARM.getId());\n    } finally {\n      test.shutdownCluster();\n    }\n  }","id":29169,"modified_method":"/**\n   * Test DISK is running out of spaces.\n   */\n  @Test\n  public void testNoSpaceDisk() throws Exception {\n    LOG.info(\"testNoSpaceDisk\");\n    final PathPolicyMap pathPolicyMap = new PathPolicyMap(0);\n    final NamespaceScheme nsScheme = pathPolicyMap.newNamespaceScheme();\n\n    Configuration conf = new Configuration(DEFAULT_CONF);\n    final ClusterScheme clusterScheme = new ClusterScheme(conf,\n        NUM_DATANODES, REPL, genStorageTypes(NUM_DATANODES), null);\n    final MigrationTest test = new MigrationTest(clusterScheme, nsScheme);\n\n    try {\n      test.runBasicTest(false);\n\n      // create 2 hot files with replication 3\n      final short replication = 3;\n      for (int i = 0; i < 2; i++) {\n        final Path p = new Path(pathPolicyMap.hot, \"file\" + i);\n        DFSTestUtil.createFile(test.dfs, p, BLOCK_SIZE, replication, 0L);\n        waitForAllReplicas(replication, p, test.dfs);\n      }\n\n      // set all the DISK volume to full\n      for (DataNode dn : test.cluster.getDataNodes()) {\n        setVolumeFull(dn, StorageType.DISK);\n        DataNodeTestUtils.triggerHeartbeat(dn);\n      }\n\n      // test increasing replication.  Since DISK is full,\n      // new replicas should be stored in ARCHIVE as a fallback storage.\n      final Path file0 = new Path(pathPolicyMap.hot, \"file0\");\n      final Replication r = test.getReplication(file0);\n      final short newReplication = (short) 5;\n      test.dfs.setReplication(file0, newReplication);\n      Thread.sleep(10000);\n      test.verifyReplication(file0, r.disk, newReplication - r.disk);\n\n      // test creating a cold file and then increase replication\n      final Path p = new Path(pathPolicyMap.cold, \"foo\");\n      DFSTestUtil.createFile(test.dfs, p, BLOCK_SIZE, replication, 0L);\n      test.verifyReplication(p, 0, replication);\n\n      test.dfs.setReplication(p, newReplication);\n      Thread.sleep(10000);\n      test.verifyReplication(p, 0, newReplication);\n\n      //test move a hot file to warm\n      final Path file1 = new Path(pathPolicyMap.hot, \"file1\");\n      test.dfs.rename(file1, pathPolicyMap.warm);\n      test.migrate(ExitStatus.NO_MOVE_BLOCK);\n      test.verifyFile(new Path(pathPolicyMap.warm, \"file1\"), WARM.getId());\n    } finally {\n      test.shutdownCluster();\n    }\n  }","commit_id":"321940cf19375febe9660e96d905360cfcc15f5f","url":"https://github.com/apache/hadoop"},{"original_method":"private void runBasicTest(boolean shutdown) throws Exception {\n      setupCluster();\n      try {\n        prepareNamespace();\n        verify(true);\n\n        setStoragePolicy();\n        migrate();\n        verify(true);\n      } finally {\n        if (shutdown) {\n          shutdownCluster();\n        }\n      }\n    }","id":29170,"modified_method":"private void runBasicTest(boolean shutdown) throws Exception {\n      setupCluster();\n      try {\n        prepareNamespace();\n        verify(true);\n\n        setStoragePolicy();\n        migrate(ExitStatus.SUCCESS);\n        verify(true);\n      } finally {\n        if (shutdown) {\n          shutdownCluster();\n        }\n      }\n    }","commit_id":"321940cf19375febe9660e96d905360cfcc15f5f","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Test directories with Hot, Warm and Cold polices.\n   */\n  @Test\n  public void testHotWarmColdDirs() throws Exception {\n    LOG.info(\"testHotWarmColdDirs\");\n    PathPolicyMap pathPolicyMap = new PathPolicyMap(3);\n    NamespaceScheme nsScheme = pathPolicyMap.newNamespaceScheme();\n    ClusterScheme clusterScheme = new ClusterScheme();\n    MigrationTest test = new MigrationTest(clusterScheme, nsScheme);\n\n    try {\n      test.runBasicTest(false);\n      pathPolicyMap.moveAround(test.dfs);\n      test.migrate();\n\n      test.verify(true);\n    } finally {\n      test.shutdownCluster();\n    }\n  }","id":29171,"modified_method":"/**\n   * Test directories with Hot, Warm and Cold polices.\n   */\n  @Test\n  public void testHotWarmColdDirs() throws Exception {\n    LOG.info(\"testHotWarmColdDirs\");\n    PathPolicyMap pathPolicyMap = new PathPolicyMap(3);\n    NamespaceScheme nsScheme = pathPolicyMap.newNamespaceScheme();\n    ClusterScheme clusterScheme = new ClusterScheme();\n    MigrationTest test = new MigrationTest(clusterScheme, nsScheme);\n\n    try {\n      test.runBasicTest(false);\n      pathPolicyMap.moveAround(test.dfs);\n      test.migrate(ExitStatus.SUCCESS);\n\n      test.verify(true);\n    } finally {\n      test.shutdownCluster();\n    }\n  }","commit_id":"321940cf19375febe9660e96d905360cfcc15f5f","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Test ARCHIVE is running out of spaces.\n   */\n  @Test\n  public void testNoSpaceArchive() throws Exception {\n    LOG.info(\"testNoSpaceArchive\");\n    final PathPolicyMap pathPolicyMap = new PathPolicyMap(0);\n    final NamespaceScheme nsScheme = pathPolicyMap.newNamespaceScheme();\n\n    final ClusterScheme clusterScheme = new ClusterScheme(DEFAULT_CONF,\n        NUM_DATANODES, REPL, genStorageTypes(NUM_DATANODES), null);\n    final MigrationTest test = new MigrationTest(clusterScheme, nsScheme);\n\n    try {\n      test.runBasicTest(false);\n\n      // create 2 hot files with replication 3\n      final short replication = 3;\n      for (int i = 0; i < 2; i++) {\n        final Path p = new Path(pathPolicyMap.cold, \"file\" + i);\n        DFSTestUtil.createFile(test.dfs, p, BLOCK_SIZE, replication, 0L);\n        waitForAllReplicas(replication, p, test.dfs);\n      }\n\n      // set all the ARCHIVE volume to full\n      for (DataNode dn : test.cluster.getDataNodes()) {\n        setVolumeFull(dn, StorageType.ARCHIVE);\n        DataNodeTestUtils.triggerHeartbeat(dn);\n      }\n\n      { // test increasing replication but new replicas cannot be created\n        // since no more ARCHIVE space.\n        final Path file0 = new Path(pathPolicyMap.cold, \"file0\");\n        final Replication r = test.getReplication(file0);\n        Assert.assertEquals(0, r.disk);\n\n        final short newReplication = (short) 5;\n        test.dfs.setReplication(file0, newReplication);\n        Thread.sleep(10000);\n\n        test.verifyReplication(file0, 0, r.archive);\n      }\n\n      { // test creating a hot file\n        final Path p = new Path(pathPolicyMap.hot, \"foo\");\n        DFSTestUtil.createFile(test.dfs, p, BLOCK_SIZE, (short) 3, 0L);\n      }\n\n      { //test move a cold file to warm\n        final Path file1 = new Path(pathPolicyMap.cold, \"file1\");\n        test.dfs.rename(file1, pathPolicyMap.warm);\n        test.migrate();\n        test.verify(true);\n      }\n    } finally {\n      test.shutdownCluster();\n    }\n  }","id":29172,"modified_method":"/**\n   * Test ARCHIVE is running out of spaces.\n   */\n  @Test\n  public void testNoSpaceArchive() throws Exception {\n    LOG.info(\"testNoSpaceArchive\");\n    final PathPolicyMap pathPolicyMap = new PathPolicyMap(0);\n    final NamespaceScheme nsScheme = pathPolicyMap.newNamespaceScheme();\n\n    final ClusterScheme clusterScheme = new ClusterScheme(DEFAULT_CONF,\n        NUM_DATANODES, REPL, genStorageTypes(NUM_DATANODES), null);\n    final MigrationTest test = new MigrationTest(clusterScheme, nsScheme);\n\n    try {\n      test.runBasicTest(false);\n\n      // create 2 hot files with replication 3\n      final short replication = 3;\n      for (int i = 0; i < 2; i++) {\n        final Path p = new Path(pathPolicyMap.cold, \"file\" + i);\n        DFSTestUtil.createFile(test.dfs, p, BLOCK_SIZE, replication, 0L);\n        waitForAllReplicas(replication, p, test.dfs);\n      }\n\n      // set all the ARCHIVE volume to full\n      for (DataNode dn : test.cluster.getDataNodes()) {\n        setVolumeFull(dn, StorageType.ARCHIVE);\n        DataNodeTestUtils.triggerHeartbeat(dn);\n      }\n\n      { // test increasing replication but new replicas cannot be created\n        // since no more ARCHIVE space.\n        final Path file0 = new Path(pathPolicyMap.cold, \"file0\");\n        final Replication r = test.getReplication(file0);\n        Assert.assertEquals(0, r.disk);\n\n        final short newReplication = (short) 5;\n        test.dfs.setReplication(file0, newReplication);\n        Thread.sleep(10000);\n\n        test.verifyReplication(file0, 0, r.archive);\n      }\n\n      { // test creating a hot file\n        final Path p = new Path(pathPolicyMap.hot, \"foo\");\n        DFSTestUtil.createFile(test.dfs, p, BLOCK_SIZE, (short) 3, 0L);\n      }\n\n      { //test move a cold file to warm\n        final Path file1 = new Path(pathPolicyMap.cold, \"file1\");\n        test.dfs.rename(file1, pathPolicyMap.warm);\n        test.migrate(ExitStatus.SUCCESS);\n        test.verify(true);\n      }\n    } finally {\n      test.shutdownCluster();\n    }\n  }","commit_id":"321940cf19375febe9660e96d905360cfcc15f5f","url":"https://github.com/apache/hadoop"},{"original_method":"public void iterateIndexableFilesIn(VirtualFile file, ContentIterator iterator) {\n    iterator.processFile(file);\n    if (file.isDirectory()) {\n      for (VirtualFile virtualFile : file.getChildren()) {\n        iterateIndexableFilesIn(virtualFile, iterator);\n      }\n    }\n  }","id":29173,"modified_method":"public void iterateIndexableFilesIn(VirtualFile file, ContentIterator iterator) {\n    if (!isInSet(file)) return;\n\n    if (file.isDirectory()) {\n      for (VirtualFile child : file.getChildren()) {\n        iterateIndexableFilesIn(child, iterator);\n      }\n    }\n    else {\n      iterator.processFile(file);\n    }\n  }","commit_id":"4d42954d2ac788afc69c6f231a62b664e9eca6d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * test equality between two arg collections.  This function defines the statement:\n     * \"not fun to write\"\n     *\n     * @param other the other collection\n     *\n     * @return true if they're equal\n     */\n    public boolean equals(GATKArgumentCollection other) {\n        if (other == null) return false;\n        if (other.samFiles.size() != samFiles.size()) {\n            return false;\n        }\n        for (int x = 0; x < samFiles.size(); x++) {\n            if (!samFiles.get(x).equals(other.samFiles.get(x))) {\n                return false;\n            }\n        }\n        if (other.walkerArgs.size() != walkerArgs.size()) {\n            return false;\n        }\n        for (String s : walkerArgs.keySet()) {\n            if (!other.walkerArgs.containsKey(s)) {\n                return false;\n            }\n        }\n        if (other.RODBindings.size() != RODBindings.size()) {\n            return false;\n        }\n        for (int x = 0; x < RODBindings.size(); x++) {\n            if (!RODBindings.get(x).equals(other.RODBindings.get(x))) {\n                return false;\n            }\n        }\n        if (!other.samFiles.equals(this.samFiles)) {\n            return false;\n        }\n        if(other.readBufferSize == null || this.readBufferSize == null) {\n            // If either is null, return false if they're both null, otherwise keep going...\n            if(other.readBufferSize != null || this.readBufferSize != null)\n                return false;\n        }\n        else {\n            if(!other.readBufferSize.equals(this.readBufferSize))\n                return false;\n        }\n        if (!(other.readBufferSize == null && this.readBufferSize == null) && (other.readBufferSize == null || this.readBufferSize == null)) {\n            return false;\n        }\n        if (!other.strictnessLevel.equals(this.strictnessLevel)) {\n            return false;\n        }\n        if (!other.referenceFile.equals(this.referenceFile)) {\n            return false;\n        }\n        if (!other.intervals.equals(this.intervals)) {\n            return false;\n        }\n        if (!other.excludeIntervals.equals(this.excludeIntervals)) {\n            return false;\n        }\n        if (!other.DBSNPFile.equals(this.DBSNPFile)) {\n            return false;\n        }\n        if (!other.unsafe.equals(this.unsafe)) {\n            return false;\n        }\n        if ((other.downsampleFraction == null && this.downsampleFraction != null) ||\n                (other.downsampleFraction != null && !other.downsampleFraction.equals(this.downsampleFraction))) {\n            return false;\n        }\n        if ((other.downsampleCoverage == null && this.downsampleCoverage != null) ||\n                (other.downsampleCoverage != null && !other.downsampleCoverage.equals(this.downsampleCoverage))) {\n            return false;\n        }\n        if (other.numberOfThreads != this.numberOfThreads) {\n            return false;\n        }\n        if (other.intervalMerging != this.intervalMerging) {\n            return false;\n        }\n        if ((other.RODToInterval == null && RODToInterval != null) ||\n            (other.RODToInterval != null && !other.RODToInterval.equals(RODToInterval))) {\n            return false;\n        }\n\n        if (other.phoneHomeType != this.phoneHomeType) {\n            return false;\n        }\n        if ((other.S3SecretKey == null && this.S3SecretKey != null) ||\n                (other.S3SecretKey != null && !other.S3SecretKey.equals(this.S3SecretKey))) {\n            return false;\n        }\n\n        if (BTIMergeRule != other.BTIMergeRule)\n            return false;\n\n        if ( BAQMode != other.BAQMode) return false;\n        if ( BAQGOP != other.BAQGOP ) return false;\n\n        if ((other.performanceLog == null && this.performanceLog != null) ||\n                (other.performanceLog != null && !other.performanceLog.equals(this.performanceLog)))\n            return false;\n\n        if ((other.processingTrackerFile == null && this.processingTrackerFile != null) ||\n                (other.processingTrackerFile != null && !other.processingTrackerFile.equals(this.processingTrackerFile)))\n            return false;\n\n        if ((other.processingTrackerStatusFile == null && this.processingTrackerStatusFile != null) ||\n                (other.processingTrackerStatusFile != null && !other.processingTrackerStatusFile.equals(this.processingTrackerStatusFile)))\n            return false;\n\n        if ( restartProcessingTracker != other.restartProcessingTracker )\n            return false;\n\n        if ( processTrackerID != other.processTrackerID )\n            return false;\n\n        return true;\n    }","id":29174,"modified_method":"/**\n     * test equality between two arg collections.  This function defines the statement:\n     * \"not fun to write\"\n     *\n     * @param other the other collection\n     *\n     * @return true if they're equal\n     */\n    public boolean equals(GATKArgumentCollection other) {\n        if (other == null) return false;\n        if (other.samFiles.size() != samFiles.size()) {\n            return false;\n        }\n        for (int x = 0; x < samFiles.size(); x++) {\n            if (!samFiles.get(x).equals(other.samFiles.get(x))) {\n                return false;\n            }\n        }\n        if (other.walkerArgs.size() != walkerArgs.size()) {\n            return false;\n        }\n        for (String s : walkerArgs.keySet()) {\n            if (!other.walkerArgs.containsKey(s)) {\n                return false;\n            }\n        }\n        if (other.RODBindings.size() != RODBindings.size()) {\n            return false;\n        }\n        for (int x = 0; x < RODBindings.size(); x++) {\n            if (!RODBindings.get(x).equals(other.RODBindings.get(x))) {\n                return false;\n            }\n        }\n        if (!other.samFiles.equals(this.samFiles)) {\n            return false;\n        }\n        if(other.readBufferSize == null || this.readBufferSize == null) {\n            // If either is null, return false if they're both null, otherwise keep going...\n            if(other.readBufferSize != null || this.readBufferSize != null)\n                return false;\n        }\n        else {\n            if(!other.readBufferSize.equals(this.readBufferSize))\n                return false;\n        }\n        if (!(other.readBufferSize == null && this.readBufferSize == null) && (other.readBufferSize == null || this.readBufferSize == null)) {\n            return false;\n        }\n        if (!other.strictnessLevel.equals(this.strictnessLevel)) {\n            return false;\n        }\n        if (!other.referenceFile.equals(this.referenceFile)) {\n            return false;\n        }\n        if (!other.intervals.equals(this.intervals)) {\n            return false;\n        }\n        if (!other.excludeIntervals.equals(this.excludeIntervals)) {\n            return false;\n        }\n        if (!other.DBSNPFile.equals(this.DBSNPFile)) {\n            return false;\n        }\n        if (!other.unsafe.equals(this.unsafe)) {\n            return false;\n        }\n        if ((other.downsampleFraction == null && this.downsampleFraction != null) ||\n                (other.downsampleFraction != null && !other.downsampleFraction.equals(this.downsampleFraction))) {\n            return false;\n        }\n        if ((other.downsampleCoverage == null && this.downsampleCoverage != null) ||\n                (other.downsampleCoverage != null && !other.downsampleCoverage.equals(this.downsampleCoverage))) {\n            return false;\n        }\n        if (other.numberOfThreads != this.numberOfThreads) {\n            return false;\n        }\n        if (other.intervalMerging != this.intervalMerging) {\n            return false;\n        }\n        if ((other.RODToInterval == null && RODToInterval != null) ||\n            (other.RODToInterval != null && !other.RODToInterval.equals(RODToInterval))) {\n            return false;\n        }\n\n        if (other.phoneHomeType != this.phoneHomeType) {\n            return false;\n        }\n\n        if (BTIMergeRule != other.BTIMergeRule)\n            return false;\n\n        if ( BAQMode != other.BAQMode) return false;\n        if ( BAQGOP != other.BAQGOP ) return false;\n\n        if ((other.performanceLog == null && this.performanceLog != null) ||\n                (other.performanceLog != null && !other.performanceLog.equals(this.performanceLog)))\n            return false;\n\n        if ((other.processingTrackerFile == null && this.processingTrackerFile != null) ||\n                (other.processingTrackerFile != null && !other.processingTrackerFile.equals(this.processingTrackerFile)))\n            return false;\n\n        if ((other.processingTrackerStatusFile == null && this.processingTrackerStatusFile != null) ||\n                (other.processingTrackerStatusFile != null && !other.processingTrackerStatusFile.equals(this.processingTrackerStatusFile)))\n            return false;\n\n        if ( restartProcessingTracker != other.restartProcessingTracker )\n            return false;\n\n        if ( processTrackerID != other.processTrackerID )\n            return false;\n\n        return true;\n    }","commit_id":"b5d1aab8dcf5448e749f92519314431205618541","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new RunReport and population all of the fields with values from the walker and engine\n     *\n     * @param walker the GATK walker that we ran\n     * @param e the exception caused by running this walker, or null if we completed successfully\n     * @param engine the GAE we used to run the walker, so we can fetch runtime, args, etc\n     */\n    public GATKRunReport(Walker<?,?> walker, Exception e, GenomeAnalysisEngine engine, PhoneHomeOption type) {\n        if ( type == PhoneHomeOption.NO_ET )\n            throw new ReviewedStingException(\"Trying to create a run report when type is NO_ET!\");\n\n        logger.info(\"Aggregating data for run report\");\n\n        mGATKHeader = CommandLineGATK.createApplicationHeader();\n        currentPath = System.getProperty(\"user.dir\");\n\n        // what did we run?\n        id = org.apache.commons.lang.RandomStringUtils.randomAlphanumeric(32);\n        try {\n            cmdLine = engine.createApproximateCommandLineArgumentString(engine, walker);\n        } catch (Exception ignore) { }\n\n        this.mCollection = engine.getArguments();\n        walkerName = engine.getWalkerName(walker.getClass());\n        svnVersion = CommandLineGATK.getVersionNumber();\n\n        // runtime performance metrics\n        Date end = new java.util.Date();\n        endTime = dateFormat.format(end);\n        if ( engine.getStartTime() != null ) { // made it this far during initialization\n            startTime = dateFormat.format(engine.getStartTime());\n            runTime = (end.getTime() - engine.getStartTime().getTime()) / 1000L; // difference in seconds\n        }\n        tmpDir = System.getProperty(\"java.io.tmpdir\");\n\n        // deal with memory usage\n        Runtime.getRuntime().gc(); // call GC so totalMemory is ~ used memory\n        maxMemory = Runtime.getRuntime().maxMemory();\n        totalMemory = Runtime.getRuntime().totalMemory();\n\n        // we can only do some operations if an error hasn't occurred\n        if ( engine.getCumulativeMetrics() != null ) {\n            // it's possible we aborted so early that these data structures arent initialized\n            nIterations = engine.getCumulativeMetrics().getNumIterations();\n            nReads = engine.getCumulativeMetrics().getNumReadsSeen();\n        }\n\n        // user and hostname -- information about the runner of the GATK\n        userName = System.getProperty(\"user.name\");\n        hostName = \"unknown\"; // resolveHostname();\n\n        // basic java information\n        java = Utils.join(\"-\", Arrays.asList(System.getProperty(\"java.vendor\"), System.getProperty(\"java.version\")));\n        machine = Utils.join(\"-\", Arrays.asList(System.getProperty(\"os.name\"), System.getProperty(\"os.arch\")));\n\n        // if there was an exception, capture it\n        this.mException = e == null ? null : new ExceptionToXML(e);\n\n        this.S3SecretKey = engine.getArguments().S3SecretKey;\n    }","id":29175,"modified_method":"/**\n     * Create a new RunReport and population all of the fields with values from the walker and engine\n     *\n     * @param walker the GATK walker that we ran\n     * @param e the exception caused by running this walker, or null if we completed successfully\n     * @param engine the GAE we used to run the walker, so we can fetch runtime, args, etc\n     */\n    public GATKRunReport(Walker<?,?> walker, Exception e, GenomeAnalysisEngine engine, PhoneHomeOption type) {\n        if ( type == PhoneHomeOption.NO_ET )\n            throw new ReviewedStingException(\"Trying to create a run report when type is NO_ET!\");\n\n        logger.info(\"Aggregating data for run report\");\n\n        mGATKHeader = CommandLineGATK.createApplicationHeader();\n        currentPath = System.getProperty(\"user.dir\");\n\n        // what did we run?\n        id = org.apache.commons.lang.RandomStringUtils.randomAlphanumeric(32);\n        try {\n            cmdLine = engine.createApproximateCommandLineArgumentString(engine, walker);\n        } catch (Exception ignore) { }\n\n        this.mCollection = engine.getArguments();\n        walkerName = engine.getWalkerName(walker.getClass());\n        svnVersion = CommandLineGATK.getVersionNumber();\n\n        // runtime performance metrics\n        Date end = new java.util.Date();\n        endTime = dateFormat.format(end);\n        if ( engine.getStartTime() != null ) { // made it this far during initialization\n            startTime = dateFormat.format(engine.getStartTime());\n            runTime = (end.getTime() - engine.getStartTime().getTime()) / 1000L; // difference in seconds\n        }\n        tmpDir = System.getProperty(\"java.io.tmpdir\");\n\n        // deal with memory usage\n        Runtime.getRuntime().gc(); // call GC so totalMemory is ~ used memory\n        maxMemory = Runtime.getRuntime().maxMemory();\n        totalMemory = Runtime.getRuntime().totalMemory();\n\n        // we can only do some operations if an error hasn't occurred\n        if ( engine.getCumulativeMetrics() != null ) {\n            // it's possible we aborted so early that these data structures arent initialized\n            nIterations = engine.getCumulativeMetrics().getNumIterations();\n            nReads = engine.getCumulativeMetrics().getNumReadsSeen();\n        }\n\n        // user and hostname -- information about the runner of the GATK\n        userName = System.getProperty(\"user.name\");\n        hostName = \"unknown\"; // resolveHostname();\n\n        // basic java information\n        java = Utils.join(\"-\", Arrays.asList(System.getProperty(\"java.vendor\"), System.getProperty(\"java.version\")));\n        machine = Utils.join(\"-\", Arrays.asList(System.getProperty(\"os.name\"), System.getProperty(\"os.arch\")));\n\n        // if there was an exception, capture it\n        this.mException = e == null ? null : new ExceptionToXML(e);\n    }","commit_id":"b5d1aab8dcf5448e749f92519314431205618541","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void exceptDuringRunReport(String msg, Throwable e) {\n        logger.warn(\"An occurred during GATK run reporting [everything is fine, but no report could be generated].  Message is: \" + msg + \".  Error message is: \" + e.getMessage() + \".  Stack track follows\" + e.getStackTrace());\n    }","id":29176,"modified_method":"private void exceptDuringRunReport(String msg, Throwable e) {\n        logger.warn(\"An occurred during GATK run reporting [everything is fine, but no report could be generated].  Message is: \" + msg + \".  Error message is: \" + e.getMessage() + \".  Stack track follows\");\n        e.printStackTrace();\n    }","commit_id":"b5d1aab8dcf5448e749f92519314431205618541","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void postReportToAWSS3() {\n        // modifying example code from http://jets3t.s3.amazonaws.com/toolkit/code-samples.html\n        if ( S3SecretKey == null )\n            exceptDuringRunReport(\"Cannot upload run reports to AWS S3 without providing a secret key on the command line\");\n        else {\n            this.hostName = resolveHostname(); // we want to fill in the host name\n            File localFile = postReportToLocalDisk(new File(\"./\"));\n            logger.info(\"Generating GATK report to AWS S3 based on local file \" + localFile);\n            if ( localFile != null ) {\n                try {\n                    // we succeeded in creating the local file\n\n                    // Your Amazon Web Services (AWS) login credentials are required to manage S3 accounts. These credentials\n                    // are stored in an AWSCredentials object:\n                    String awsAccessKey = \"AKIAJQQEIHTAHSM333EQ\";\n                    AWSCredentials awsCredentials = new AWSCredentials(awsAccessKey, S3SecretKey);\n\n                    // To communicate with S3, create a class that implements an S3Service. We will use the REST/HTTP\n                    // implementation based on HttpClient, as this is the most robust implementation provided with JetS3t.\n                    S3Service s3Service = new RestS3Service(awsCredentials);\n\n                    // grab the reports bucket\n                    S3Bucket reportsBucket = s3Service.getBucket(REPORT_BUCKET_NAME);\n                    logger.info(\"Uploading to bucket: \" + reportsBucket);\n\n                    // Create an S3Object based on a file, with Content-Length set automatically and\n                    // Content-Type set based on the file's extension (using the Mimetypes utility class)\n                    S3Object fileObject = new S3Object(localFile);\n                    logger.info(\"Created S3Object\" + fileObject);\n                    logger.info(\"Uploading \" + localFile + \" to AWS bucket\");\n                    s3Service.putObject(reportsBucket, fileObject);\n                    //logger.info(\"Done.  File hash value: \" + fileObject.getMd5HashAsHex());\n                } catch ( S3ServiceException e ) {\n                    exceptDuringRunReport(\"S3 exception occurred\", e);\n                } catch ( NoSuchAlgorithmException e ) {\n                    exceptDuringRunReport(\"Couldn't calculate MD5\", e);\n                } catch ( IOException e ) {\n                    exceptDuringRunReport(\"Couldn't read report file\", e);\n                } finally {\n                    localFile.delete();\n                }\n            }\n        }\n    }","id":29177,"modified_method":"private void postReportToAWSS3() {\n        // modifying example code from http://jets3t.s3.amazonaws.com/toolkit/code-samples.html\n        this.hostName = resolveHostname(); // we want to fill in the host name\n        File localFile = postReportToLocalDisk(new File(\"./\"));\n        logger.info(\"Generating GATK report to AWS S3 based on local file \" + localFile);\n        if ( localFile != null ) {\n            try {\n                // we succeeded in creating the local file\n\n                // Your Amazon Web Services (AWS) login credentials are required to manage S3 accounts. These credentials\n                // are stored in an AWSCredentials object:\n\n                // IAM GATK user credentials -- only right is to PutObject into GATK_Run_Report bucket\n                String awsAccessKey = \"AKIAJXU7VIHBPDW4TDSQ\"; // GATK AWS user\n                String awsSecretKey = \"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\"; // GATK AWS user\n                AWSCredentials awsCredentials = new AWSCredentials(awsAccessKey, awsSecretKey);\n\n                // To communicate with S3, create a class that implements an S3Service. We will use the REST/HTTP\n                // implementation based on HttpClient, as this is the most robust implementation provided with JetS3t.\n                S3Service s3Service = new RestS3Service(awsCredentials);\n\n                // Create an S3Object based on a file, with Content-Length set automatically and\n                // Content-Type set based on the file's extension (using the Mimetypes utility class)\n                S3Object fileObject = new S3Object(localFile);\n                logger.info(\"Created S3Object\" + fileObject);\n                logger.info(\"Uploading \" + localFile + \" to AWS bucket\");\n                S3Object s3Object = s3Service.putObject(REPORT_BUCKET_NAME, fileObject);\n                logger.info(\"Uploaded: \" + s3Object);\n            } catch ( S3ServiceException e ) {\n                exceptDuringRunReport(\"S3 exception occurred\", e);\n            } catch ( NoSuchAlgorithmException e ) {\n                exceptDuringRunReport(\"Couldn't calculate MD5\", e);\n            } catch ( IOException e ) {\n                exceptDuringRunReport(\"Couldn't read report file\", e);\n            } finally {\n                localFile.delete();\n            }\n        }\n    }","commit_id":"b5d1aab8dcf5448e749f92519314431205618541","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void doUpload(S3BlobStore blobStore, String bucketName, String blobName, InputStream is, int length,\n                            boolean serverSideEncryption) throws AmazonS3Exception {\n        ObjectMetadata md = new ObjectMetadata();\n        if (serverSideEncryption) {\n            md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION);\n        }\n        md.setContentLength(length);\n        blobStore.client().putObject(bucketName, blobName, is, md);\n    }","id":29178,"modified_method":"protected void doUpload(S3BlobStore blobStore, String bucketName, String blobName, InputStream is, int length,\n                            boolean serverSideEncryption) throws AmazonS3Exception {\n        ObjectMetadata md = new ObjectMetadata();\n        if (serverSideEncryption) {\n            md.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION);\n        }\n        md.setContentLength(length);\n\n        InputStream inputStream = is;\n\n        // We try to compute a MD5 while reading it\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            inputStream = new DigestInputStream(is, messageDigest);\n        } catch (NoSuchAlgorithmException impossible) {\n            // Every implementation of the Java platform is required to support MD5 (see MessageDigest)\n            throw new RuntimeException(impossible);\n        }\n        PutObjectResult putObjectResult = blobStore.client().putObject(bucketName, blobName, inputStream, md);\n\n        String localMd5 = Base64.encodeAsString(messageDigest.digest());\n        String remoteMd5 = putObjectResult.getContentMd5();\n        if (!localMd5.equals(remoteMd5)) {\n            logger.debug(\"MD5 local [{}], remote [{}] are not equal...\", localMd5, remoteMd5);\n            throw new AmazonS3Exception(\"MD5 local [\" + localMd5 +\n                    \"], remote [\" + remoteMd5 +\n                    \"] are not equal...\");\n        }\n    }","commit_id":"2d4fd39c60e3ce50a5b8f08a7d1a29779d7ea8d2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n  public void close() throws IOException {\n    if (mClosed.getAndSet(true)) {\n      return;\n    }\n    mLocalOutputStream.close();\n    try {\n      S3Object obj = new S3Object(mKey);\n      obj.setBucketName(mBucketName);\n      obj.setDataInputFile(mFile);\n      obj.setContentLength(mFile.length());\n      obj.setContentEncoding(Mimetypes.MIMETYPE_BINARY_OCTET_STREAM);\n      if (mHash != null) {\n        obj.setMd5Hash(mHash.digest());\n      } else {\n        LOG.warn(\"MD5 was not computed for: {}\", mKey);\n      }\n      mClient.putObject(mBucketName, obj);\n      if (!mFile.delete()) {\n        LOG.error(\"Failed to delete temporary file @ {}\", mFile.getPath());\n      }\n    } catch (ServiceException e) {\n      LOG.error(\"Failed to upload {}. Temporary file @ {}\", mKey, mFile.getPath());\n      throw new IOException(e);\n    }\n  }","id":29179,"modified_method":"@Override\n  public void close() throws IOException {\n    if (mClosed.getAndSet(true)) {\n      return;\n    }\n    mLocalOutputStream.close();\n    try {\n      S3Object obj = new S3Object(mKey);\n      obj.setBucketName(mBucketName);\n      obj.setDataInputFile(mFile);\n      obj.setContentLength(mFile.length());\n      obj.setContentEncoding(Mimetypes.MIMETYPE_BINARY_OCTET_STREAM);\n      if (mHash != null) {\n        obj.setMd5Hash(mHash.digest());\n      } else {\n        LOG.warn(\"MD5 was not computed for: {}\", mKey);\n      }\n      if (MULTIPART_UTIL.isFileLargerThanMaxPartSize(mFile)) {\n        // Big object will be split into parts and uploaded to S3 in parallel.\n        List<StorageObject> objectsToUploadAsMultipart = new ArrayList<>();\n        objectsToUploadAsMultipart.add(obj);\n        MULTIPART_UTIL.uploadObjects(mBucketName, mClient, objectsToUploadAsMultipart, null);\n      } else {\n        // Avoid uploading file with Multipart if it's not necessary to save the\n        // extra overhead.\n        mClient.putObject(mBucketName, obj);\n      }\n      if (!mFile.delete()) {\n        LOG.error(\"Failed to delete temporary file @ {}\", mFile.getPath());\n      }\n    } catch (Exception e) {\n      LOG.error(\"Failed to upload {}. Temporary file @ {}\", mKey, mFile.getPath());\n      throw new IOException(e);\n    }\n  }","commit_id":"bdfe89711c17d13412aef0a4ffd9ea9fbe5cd792","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n    public void testSetBodyRepresentation() throws Exception {\n        HttpGet get = new HttpGet(\"http://localhost:\" + portNum + \"/images/123\");\n        CloseableHttpClient httpclient = HttpClientBuilder.create().build();\n        InputStream is = null;\n        try {\n            HttpResponse response = httpclient.execute(get);\n            assertEquals(200, response.getStatusLine().getStatusCode());\n            assertEquals(\"image/png\", response.getEntity().getContentType().getValue());\n            is = response.getEntity().getContent();\n            assertEquals(\"Get wrong available size\", 256, response.getEntity().getContentLength());\n            byte[] buffer = new byte[256];\n            assumeThat(\"Should read all data\", is.read(buffer), equalTo(256));\n            assertThat(\"Data should match\", buffer, equalTo(getAllBytes()));\n        } finally {\n            httpclient.close();\n            if (is != null) {\n                is.close();\n            }\n        }\n    }","id":29180,"modified_method":"@Test\n    public void testSetBodyRepresentation() throws Exception {\n        HttpGet get = new HttpGet(\"http://localhost:\" + portNum + \"/images/123\");\n        try (CloseableHttpClient httpclient = HttpClientBuilder.create().build()) {\n            HttpResponse response = httpclient.execute(get);\n            assertEquals(200, response.getStatusLine().getStatusCode());\n            assertEquals(\"image/png\", response.getEntity().getContentType().getValue());\n            assertEquals(\"Get wrong available size\", 256, response.getEntity().getContentLength());\n            try (InputStream is = response.getEntity().getContent()) {\n                byte[] buffer = new byte[256];\n                assumeThat(\"Should read all data\", is.read(buffer), equalTo(256));\n                assertThat(\"Data should match\", buffer, equalTo(getAllBytes()));\n            }\n        }\n    }","commit_id":"8b4d5f0f98d546b7fed693090700ea5a03d70d7c","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void consumerShouldReturnByteArray() throws Exception {\n        HttpGet get = new HttpGet(\"http://localhost:\" + portNum + \"/music/123\");\n        CloseableHttpClient httpclient = HttpClientBuilder.create().build();\n        InputStream is = null;\n        try {\n            HttpResponse response = httpclient.execute(get);\n            assertEquals(200, response.getStatusLine().getStatusCode());\n            assertEquals(\"audio/mpeg\", response.getEntity().getContentType().getValue());\n            is = response.getEntity().getContent();\n            assertEquals(\"Content length should match returned data\", 256, response.getEntity().getContentLength());\n            byte[] buffer = new byte[256];\n            assumeThat(\"Should read all data\", is.read(buffer), equalTo(256));\n            assertThat(\"Binary content should match\", buffer, equalTo(getAllBytes()));\n        } finally {\n            httpclient.close();\n            if (is != null) {\n                is.close();\n            }\n        }\n    }","id":29181,"modified_method":"@Test\n    public void consumerShouldReturnByteArray() throws Exception {\n        HttpGet get = new HttpGet(\"http://localhost:\" + portNum + \"/music/123\");\n        try (CloseableHttpClient httpclient = HttpClientBuilder.create().build()) {\n            HttpResponse response = httpclient.execute(get);\n            assertEquals(200, response.getStatusLine().getStatusCode());\n            assertEquals(\"audio/mpeg\", response.getEntity().getContentType().getValue());\n            assertEquals(\"Content length should match returned data\", 256, response.getEntity().getContentLength());\n            try (InputStream is = response.getEntity().getContent()) {\n                byte[] buffer = new byte[256];\n                assumeThat(\"Should read all data\", is.read(buffer), equalTo(256));\n                assertThat(\"Binary content should match\", buffer, equalTo(getAllBytes()));\n            }\n        }\n    }","commit_id":"8b4d5f0f98d546b7fed693090700ea5a03d70d7c","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void consumerShouldReturnInputStream() throws Exception {\n        HttpGet get = new HttpGet(\"http://localhost:\" + portNum + \"/video/123\");\n        CloseableHttpClient httpclient = HttpClientBuilder.create().build();\n        InputStream is = null;\n        try {\n            HttpResponse response = httpclient.execute(get);\n            assertEquals(200, response.getStatusLine().getStatusCode());\n            assertEquals(\"video/mp4\", response.getEntity().getContentType().getValue());\n            assertTrue(\"Content should be streamed\", response.getEntity().isChunked());\n            assertEquals(\"Content length should be unknown\", -1, response.getEntity().getContentLength());\n            is = response.getEntity().getContent();\n            byte[] buffer = new byte[256];\n            assumeThat(\"Should read all data\", is.read(buffer), equalTo(256));\n            assertThat(\"Binary content should match\", buffer, equalTo(getAllBytes()));\n        } finally {\n            httpclient.close();\n            if (is != null) {\n                is.close();\n            }\n        }\n    }","id":29182,"modified_method":"@Test\n    public void consumerShouldReturnInputStream() throws Exception {\n        HttpGet get = new HttpGet(\"http://localhost:\" + portNum + \"/video/123\");\n        try (CloseableHttpClient httpclient = HttpClientBuilder.create().build()) {\n            HttpResponse response = httpclient.execute(get);\n            assertEquals(200, response.getStatusLine().getStatusCode());\n            assertEquals(\"video/mp4\", response.getEntity().getContentType().getValue());\n            assertTrue(\"Content should be streamed\", response.getEntity().isChunked());\n            assertEquals(\"Content length should be unknown\", -1, response.getEntity().getContentLength());\n            try (InputStream is = response.getEntity().getContent()) {\n                byte[] buffer = new byte[256];\n                assumeThat(\"Should read all data\", is.read(buffer), equalTo(256));\n                assertThat(\"Binary content should match\", buffer, equalTo(getAllBytes()));\n            }\n        }\n    }","commit_id":"8b4d5f0f98d546b7fed693090700ea5a03d70d7c","url":"https://github.com/apache/camel"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testCrossNSMapperDatasetAccess() throws Exception {\n    NamespaceMeta inputNS = new NamespaceMeta.Builder().setName(\"inputNS\").build();\n    NamespaceMeta outputNS = new NamespaceMeta.Builder().setName(\"outputNS\").build();\n    getNamespaceAdmin().create(inputNS);\n    getNamespaceAdmin().create(outputNS);\n\n    addDatasetInstance(inputNS.getNamespaceId().toId(), \"keyValueTable\", \"table1\").create();\n    addDatasetInstance(outputNS.getNamespaceId().toId(), \"keyValueTable\", \"table2\").create();\n    DataSetManager<KeyValueTable> tableManager = getDataset(inputNS.getNamespaceId().toId(), \"table1\");\n    KeyValueTable inputTable = tableManager.get();\n    inputTable.write(\"hello\", \"world\");\n    tableManager.flush();\n\n    ApplicationManager appManager = deployApplication(DatasetCrossNSAccessWithMAPApp.class);\n    Map<String, String> argsForMR = ImmutableMap.of(\n      DatasetCrossNSAccessWithMAPApp.INPUT_DATASET_NS, inputNS.getName(),\n      DatasetCrossNSAccessWithMAPApp.INPUT_DATASET_NAME, \"table1\",\n      DatasetCrossNSAccessWithMAPApp.OUTPUT_DATASET_NS, outputNS.getName(),\n      DatasetCrossNSAccessWithMAPApp.OUTPUT_DATASET_NAME, \"table2\");\n    MapReduceManager mrManager = appManager.getMapReduceManager(DatasetCrossNSAccessWithMAPApp.MAPREDUCE_PROGRAM)\n      .start(argsForMR);\n    mrManager.waitForFinish(5, TimeUnit.MINUTES);\n    appManager.stopAll();\n\n    DataSetManager<KeyValueTable> outTableManager = getDataset(outputNS.getNamespaceId().toId(), \"table2\");\n    verifyMapperJobOutput(DatasetCrossNSAccessWithMAPApp.class, outTableManager);\n  }","id":29183,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testCrossNSMapperDatasetAccess() throws Exception {\n    NamespaceMeta inputNS = new NamespaceMeta.Builder().setName(\"inputNS\").build();\n    NamespaceMeta outputNS = new NamespaceMeta.Builder().setName(\"outputNS\").build();\n    getNamespaceAdmin().create(inputNS);\n    getNamespaceAdmin().create(outputNS);\n\n    addDatasetInstance(inputNS.getNamespaceId().toId(), \"keyValueTable\", \"table1\");\n    addDatasetInstance(outputNS.getNamespaceId().toId(), \"keyValueTable\", \"table2\");\n    DataSetManager<KeyValueTable> tableManager = getDataset(inputNS.getNamespaceId().toId(), \"table1\");\n    KeyValueTable inputTable = tableManager.get();\n    inputTable.write(\"hello\", \"world\");\n    tableManager.flush();\n\n    ApplicationManager appManager = deployApplication(DatasetCrossNSAccessWithMAPApp.class);\n    Map<String, String> argsForMR = ImmutableMap.of(\n      DatasetCrossNSAccessWithMAPApp.INPUT_DATASET_NS, inputNS.getName(),\n      DatasetCrossNSAccessWithMAPApp.INPUT_DATASET_NAME, \"table1\",\n      DatasetCrossNSAccessWithMAPApp.OUTPUT_DATASET_NS, outputNS.getName(),\n      DatasetCrossNSAccessWithMAPApp.OUTPUT_DATASET_NAME, \"table2\");\n    MapReduceManager mrManager = appManager.getMapReduceManager(DatasetCrossNSAccessWithMAPApp.MAPREDUCE_PROGRAM)\n      .start(argsForMR);\n    mrManager.waitForFinish(5, TimeUnit.MINUTES);\n    appManager.stopAll();\n\n    DataSetManager<KeyValueTable> outTableManager = getDataset(outputNS.getNamespaceId().toId(), \"table2\");\n    verifyMapperJobOutput(DatasetCrossNSAccessWithMAPApp.class, outTableManager);\n  }","commit_id":"ef919059e92c3a1f47f3243e28fcd5bba76f14f7","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testCustomActionDatasetAccess() throws Exception {\n    addDatasetInstance(\"keyValueTable\", DatasetWithCustomActionApp.CUSTOM_TABLE).create();\n    addDatasetInstance(\"fileSet\", DatasetWithCustomActionApp.CUSTOM_FILESET).create();\n\n    ApplicationManager appManager = deployApplication(DatasetWithCustomActionApp.class);\n    ServiceManager serviceManager = appManager.getServiceManager(DatasetWithCustomActionApp.CUSTOM_SERVICE).start();\n    serviceManager.waitForStatus(true);\n\n    WorkflowManager workflowManager = appManager.getWorkflowManager(DatasetWithCustomActionApp.CUSTOM_WORKFLOW).start();\n    workflowManager.waitForFinish(2, TimeUnit.MINUTES);\n    appManager.stopAll();\n\n    DataSetManager<KeyValueTable> outTableManager = getDataset(DatasetWithCustomActionApp.CUSTOM_TABLE);\n    KeyValueTable outputTable = outTableManager.get();\n\n    Assert.assertEquals(\"world\", Bytes.toString(outputTable.read(\"hello\")));\n    Assert.assertEquals(\"service\", Bytes.toString(outputTable.read(\"hi\")));\n    Assert.assertEquals(\"another.world\", Bytes.toString(outputTable.read(\"another.hello\")));\n\n    DataSetManager<FileSet> outFileSetManager = getDataset(DatasetWithCustomActionApp.CUSTOM_FILESET);\n    FileSet fs = outFileSetManager.get();\n    try (InputStream in = fs.getLocation(\"test\").getInputStream()) {\n      Assert.assertEquals(42, in.read());\n    }\n  }","id":29184,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testCustomActionDatasetAccess() throws Exception {\n    addDatasetInstance(\"keyValueTable\", DatasetWithCustomActionApp.CUSTOM_TABLE);\n    addDatasetInstance(\"fileSet\", DatasetWithCustomActionApp.CUSTOM_FILESET);\n\n    ApplicationManager appManager = deployApplication(DatasetWithCustomActionApp.class);\n    ServiceManager serviceManager = appManager.getServiceManager(DatasetWithCustomActionApp.CUSTOM_SERVICE).start();\n    serviceManager.waitForStatus(true);\n\n    WorkflowManager workflowManager = appManager.getWorkflowManager(DatasetWithCustomActionApp.CUSTOM_WORKFLOW).start();\n    workflowManager.waitForFinish(2, TimeUnit.MINUTES);\n    appManager.stopAll();\n\n    DataSetManager<KeyValueTable> outTableManager = getDataset(DatasetWithCustomActionApp.CUSTOM_TABLE);\n    KeyValueTable outputTable = outTableManager.get();\n\n    Assert.assertEquals(\"world\", Bytes.toString(outputTable.read(\"hello\")));\n    Assert.assertEquals(\"service\", Bytes.toString(outputTable.read(\"hi\")));\n    Assert.assertEquals(\"another.world\", Bytes.toString(outputTable.read(\"another.hello\")));\n\n    DataSetManager<FileSet> outFileSetManager = getDataset(DatasetWithCustomActionApp.CUSTOM_FILESET);\n    FileSet fs = outFileSetManager.get();\n    try (InputStream in = fs.getLocation(\"test\").getInputStream()) {\n      Assert.assertEquals(42, in.read());\n    }\n  }","commit_id":"ef919059e92c3a1f47f3243e28fcd5bba76f14f7","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 60000L)\n  public void testAppWithExistingDatasetInjectedByAnnotation() throws Exception {\n    deployDatasetModule(\"my-kv\", AppsWithDataset.KeyValueTableDefinition.Module.class);\n    addDatasetInstance(\"myKeyValueTable\", \"myTable\", DatasetProperties.EMPTY).create();\n    testAppWithDataset(AppsWithDataset.AppUsesAnnotation.class, \"MyServiceWithUseDataSetAnnotation\");\n  }","id":29185,"modified_method":"@Test(timeout = 60000L)\n  public void testAppWithExistingDatasetInjectedByAnnotation() throws Exception {\n    deployDatasetModule(\"my-kv\", AppsWithDataset.KeyValueTableDefinition.Module.class);\n    addDatasetInstance(\"myKeyValueTable\", \"myTable\", DatasetProperties.EMPTY);\n    testAppWithDataset(AppsWithDataset.AppUsesAnnotation.class, \"MyServiceWithUseDataSetAnnotation\");\n  }","commit_id":"ef919059e92c3a1f47f3243e28fcd5bba76f14f7","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 60000L)\n  public void testDatasetWithoutApp() throws Exception {\n    // TODO: Although this has nothing to do with this testcase, deploying a dummy app to create the default namespace\n    deployApplication(testSpace, DummyApp.class);\n    deployDatasetModule(testSpace, \"my-kv\", AppsWithDataset.KeyValueTableDefinition.Module.class);\n    addDatasetInstance(testSpace, \"myKeyValueTable\", \"myTable\", DatasetProperties.EMPTY).create();\n    DataSetManager<AppsWithDataset.KeyValueTableDefinition.KeyValueTable> dataSetManager =\n      getDataset(testSpace, \"myTable\");\n    AppsWithDataset.KeyValueTableDefinition.KeyValueTable kvTable = dataSetManager.get();\n    kvTable.put(\"test\", \"hello\");\n    dataSetManager.flush();\n    Assert.assertEquals(\"hello\", dataSetManager.get().get(\"test\"));\n  }","id":29186,"modified_method":"@Test(timeout = 60000L)\n  public void testDatasetWithoutApp() throws Exception {\n    // TODO: Although this has nothing to do with this testcase, deploying a dummy app to create the default namespace\n    deployApplication(testSpace, DummyApp.class);\n    deployDatasetModule(testSpace, \"my-kv\", AppsWithDataset.KeyValueTableDefinition.Module.class);\n    addDatasetInstance(testSpace, \"myKeyValueTable\", \"myTable\", DatasetProperties.EMPTY);\n    DataSetManager<AppsWithDataset.KeyValueTableDefinition.KeyValueTable> dataSetManager =\n      getDataset(testSpace, \"myTable\");\n    AppsWithDataset.KeyValueTableDefinition.KeyValueTable kvTable = dataSetManager.get();\n    kvTable.put(\"test\", \"hello\");\n    dataSetManager.flush();\n    Assert.assertEquals(\"hello\", dataSetManager.get().get(\"test\"));\n  }","commit_id":"ef919059e92c3a1f47f3243e28fcd5bba76f14f7","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 60000L)\n  public void testAppWithExistingDataset() throws Exception {\n    deployDatasetModule(\"my-kv\", AppsWithDataset.KeyValueTableDefinition.Module.class);\n    addDatasetInstance(\"myKeyValueTable\", \"myTable\", DatasetProperties.EMPTY).create();\n    testAppWithDataset(AppsWithDataset.AppWithExisting.class, \"MyService\");\n  }","id":29187,"modified_method":"@Test(timeout = 60000L)\n  public void testAppWithExistingDataset() throws Exception {\n    deployDatasetModule(\"my-kv\", AppsWithDataset.KeyValueTableDefinition.Module.class);\n    addDatasetInstance(\"myKeyValueTable\", \"myTable\", DatasetProperties.EMPTY);\n    testAppWithDataset(AppsWithDataset.AppWithExisting.class, \"MyService\");\n  }","commit_id":"ef919059e92c3a1f47f3243e28fcd5bba76f14f7","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testMapperDatasetAccess() throws Exception {\n    addDatasetInstance(\"keyValueTable\", \"table1\").create();\n    addDatasetInstance(\"keyValueTable\", \"table2\").create();\n    DataSetManager<KeyValueTable> tableManager = getDataset(\"table1\");\n    KeyValueTable inputTable = tableManager.get();\n    inputTable.write(\"hello\", \"world\");\n    tableManager.flush();\n\n    ApplicationManager appManager = deployApplication(DatasetWithMRApp.class);\n    Map<String, String> argsForMR = ImmutableMap.of(DatasetWithMRApp.INPUT_KEY, \"table1\",\n                                                    DatasetWithMRApp.OUTPUT_KEY, \"table2\");\n    MapReduceManager mrManager = appManager.getMapReduceManager(DatasetWithMRApp.MAPREDUCE_PROGRAM).start(argsForMR);\n    mrManager.waitForFinish(5, TimeUnit.MINUTES);\n    appManager.stopAll();\n\n    DataSetManager<KeyValueTable> outTableManager = getDataset(\"table2\");\n    verifyMapperJobOutput(DatasetWithMRApp.class, outTableManager);\n  }","id":29188,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testMapperDatasetAccess() throws Exception {\n    addDatasetInstance(\"keyValueTable\", \"table1\");\n    addDatasetInstance(\"keyValueTable\", \"table2\");\n    DataSetManager<KeyValueTable> tableManager = getDataset(\"table1\");\n    KeyValueTable inputTable = tableManager.get();\n    inputTable.write(\"hello\", \"world\");\n    tableManager.flush();\n\n    ApplicationManager appManager = deployApplication(DatasetWithMRApp.class);\n    Map<String, String> argsForMR = ImmutableMap.of(DatasetWithMRApp.INPUT_KEY, \"table1\",\n                                                    DatasetWithMRApp.OUTPUT_KEY, \"table2\");\n    MapReduceManager mrManager = appManager.getMapReduceManager(DatasetWithMRApp.MAPREDUCE_PROGRAM).start(argsForMR);\n    mrManager.waitForFinish(5, TimeUnit.MINUTES);\n    appManager.stopAll();\n\n    DataSetManager<KeyValueTable> outTableManager = getDataset(\"table2\");\n    verifyMapperJobOutput(DatasetWithMRApp.class, outTableManager);\n  }","commit_id":"ef919059e92c3a1f47f3243e28fcd5bba76f14f7","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n\t * This method performs the error handling for the OpenCms.\n\t * All CmsExetions throns in the OpenCms are forwared to this method and are\n\t * processed here.\n\t * \n\t * @param cms The CmsObject\n\t * @param cmsReq   The clints request.\n\t * @param cmsRes   The servlets response.\n\t * @param e The CmsException to be processed. \n\t */\n\t private void errorHandling(CmsObject cms, I_CmsRequest cmsReq, I_CmsResponse cmsRes,\n\t\t\t\t\t\t\t\tCmsException e){\n\t\tint errorType = e.getType();\n\t\t\n\t\tHttpServletRequest req=(HttpServletRequest)cmsReq.getOriginalRequest();\n\t\tHttpServletResponse res=(HttpServletResponse)cmsRes.getOriginalResponse();\n\t\t\n\t\ttry{\n\t\t\tswitch (errorType) {\n\t\t\t// access denied error - display login dialog\n\t\t\tcase CmsException.C_ACCESS_DENIED: \n\t\t\t\trequestAuthorization(req,res); \n\t\t\t\te.printStackTrace();\n\t\t\t\tbreak;\n\t\t\t// file not found - display 404 error.\n\t\t\tcase CmsException.C_NOT_FOUND:\n\t\t\t\tres.setContentType(\"text/HTML\");\n\t\t\t\t//res.getWriter().print(createErrorBox(e));\n\t\t\t\tres.sendError(res.SC_NOT_FOUND);\n\t\t\t\tbreak;\n\t\t\tcase CmsException.C_SERVICE_UNAVAILABLE:\n\t\t\t\tres.sendError(res.SC_SERVICE_UNAVAILABLE, e.toString());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tres.setContentType(\"text/HTML\");\n\t\t\t\te.printStackTrace();\n\t\t\t\tres.getWriter().print(createErrorBox(e));\n\t\t\t\t//res.sendError(res.SC_INTERNAL_SERVER_ERROR);\n\t\t\t}\n\t\t} catch (IOException ex) {\n\t\t   \n\t\t}\n\t}","id":29189,"modified_method":"/**\n\t * This method performs the error handling for the OpenCms.\n\t * All CmsExetions throns in the OpenCms are forwared to this method and are\n\t * processed here.\n\t * \n\t * @param cms The CmsObject\n\t * @param cmsReq   The clints request.\n\t * @param cmsRes   The servlets response.\n\t * @param e The CmsException to be processed. \n\t */\n\t private void errorHandling(CmsObject cms, I_CmsRequest cmsReq, I_CmsResponse cmsRes,\n\t\t\t\t\t\t\t\tCmsException e){\n\t\tint errorType = e.getType();\n\t\t\n\t\tHttpServletRequest req=(HttpServletRequest)cmsReq.getOriginalRequest();\n\t\tHttpServletResponse res=(HttpServletResponse)cmsRes.getOriginalResponse();\n\t\t\n\t\ttry{\n\t\t\tswitch (errorType) {\n\t\t\t// access denied error - display login dialog\n\t\t\tcase CmsException.C_ACCESS_DENIED: \n\t\t\t\trequestAuthorization(req,res); \n\t\t\t\t// e.printStackTrace();\n\t\t\t\tbreak;\n\t\t\t// file not found - display 404 error.\n\t\t\tcase CmsException.C_NOT_FOUND:\n\t\t\t\tres.setContentType(\"text/HTML\");\n\t\t\t\t//res.getWriter().print(createErrorBox(e));\n\t\t\t\tres.sendError(res.SC_NOT_FOUND);\n\t\t\t\tbreak;\n\t\t\tcase CmsException.C_SERVICE_UNAVAILABLE:\n\t\t\t\tres.sendError(res.SC_SERVICE_UNAVAILABLE, e.toString());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tres.setContentType(\"text/HTML\");\n\t\t\t\t//e.printStackTrace();\n                // set some HTTP headers preventing proxy servers from caching the error box                \n                res.setHeader(\"Cache-Control\", \"no-cache\");\n                res.setHeader(\"Pragme\", \"no-cache\");\n                res.getWriter().print(createErrorBox(e));\n\t\t\t\t//res.sendError(res.SC_INTERNAL_SERVER_ERROR);\n\t\t\t}\n\t\t} catch (IOException ex) {\n\t\t   \n\t\t}\n\t}","commit_id":"02aa796757f6f19fde42209d1a99eaffc3d7092c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t* Method invoked on each HTML POST request. \n\t* <p>\n\t* (Overloaded Servlet API method, posting a document)\n\t* The OpenCmsMultipartRequest is invoked to upload a new document into OpenCms.\n\t* \n\t* @param req   The clints request.\n\t* @param res   The servlets response.\n\t* @exception ServletException Thrown if request fails.\n\t* @exception IOException Thrown if user autherization fails.\n\t*/\n\tpublic void doPost(HttpServletRequest req, HttpServletResponse res) \n\t\tthrows ServletException, IOException {\n\t\n\t\t //Check for content type \"form/multipart\" and decode it\n\t\t String type = req.getHeader(\"content-type\");\n\n\t\t CmsObject cms=null;\n\t     if ((type != null) && type.startsWith(\"multipart/form-data\")){\n\t\t  //  req = new CmsMultipartRequest(req);\n\t\t }\n\t\t \n\t\t CmsRequestHttpServlet cmsReq= new CmsRequestHttpServlet(req);\n\t\t CmsResponseHttpServlet cmsRes= new CmsResponseHttpServlet(req,res,m_clusterurl);\n\t\t \n\t\ttry {\t\t\n\t\t\tcms=initUser(cmsReq,cmsRes);\t\t\t \t  \n\t\t\tcheckRelocation(cms);\n\t\t\tCmsFile file=m_opencms.initResource(cms); \n\t\t\tm_opencms.setResponse(cms,file);\n\t\t\tm_opencms.showResource(cms,file);\n\t\t\tupdateUser(cms,cmsReq,cmsRes);\n\t\t} catch (CmsException e) {\n\t\t   errorHandling(cms,cmsReq,cmsRes,e);\n\t\t} \n\t}","id":29190,"modified_method":"/**\n\t* Method invoked on each HTML POST request. \n\t* <p>\n\t* (Overloaded Servlet API method, posting a document)\n\t* The OpenCmsMultipartRequest is invoked to upload a new document into OpenCms.\n\t* \n\t* @param req   The clints request.\n\t* @param res   The servlets response.\n\t* @exception ServletException Thrown if request fails.\n\t* @exception IOException Thrown if user autherization fails.\n\t*/\n\tpublic void doPost(HttpServletRequest req, HttpServletResponse res) \n\t\tthrows ServletException, IOException {\n\t\n\t\t //Check for content type \"form/multipart\" and decode it\n\t\t String type = req.getHeader(\"content-type\");\n\n\t\t CmsObject cms=null;\n\t     if ((type != null) && type.startsWith(\"multipart/form-data\")){\n\t\t  //  req = new CmsMultipartRequest(req);\n\t\t }\n\t\t \n\t\t CmsRequestHttpServlet cmsReq= new CmsRequestHttpServlet(req);\n\t\t CmsResponseHttpServlet cmsRes= new CmsResponseHttpServlet(req,res,m_clusterurl);\n\t\t \n\t\ttry {\t\t\n\t\t\tcms=initUser(cmsReq,cmsRes);\t\t\t \t  \n\t\t\tcheckRelocation(cms);\n\t\t\tCmsFile file=m_opencms.initResource(cms); \n            if(file != null) {\n                // If the CmsFile object is null, the resource could not be found.\n                // Stop processing in this case to avoid NullPointerExceptions\n\t    \t\tm_opencms.setResponse(cms,file);\n    \t\t\tm_opencms.showResource(cms,file);\n\t\t    \tupdateUser(cms,cmsReq,cmsRes);\n            }\n\t\t} catch (CmsException e) {\n\t\t   errorHandling(cms,cmsReq,cmsRes,e);\n\t\t} \n\t}","commit_id":"02aa796757f6f19fde42209d1a99eaffc3d7092c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Method invoked on each HTML GET request.\n\t * <p>\n\t * (Overloaded Servlet API method, requesting a document).\n\t * Reads the URI received from the client and invokes the appropiate action.\n\t * \n\t * @param req   The clints request.\n\t * @param res   The servlets response.\n\t * @exception ServletException Thrown if request fails.\n\t * @exception IOException Thrown if user autherization fails.\n\t */\n\tpublic void doGet(HttpServletRequest req, HttpServletResponse res) \n\t\tthrows ServletException, IOException {\t\n\n\t\tif (req.getRequestURI().indexOf(\"system/workplace/action/login.html\")>0)\n\t\t{\n\t\t\tHttpSession session = req.getSession(false);\n\t\t\tif (session!=null) session.invalidate();\n\t\t}\n\n\t\tCmsObject cms=null;\n\t\t\n\t\tCmsRequestHttpServlet cmsReq= new CmsRequestHttpServlet(req);\n\t\tCmsResponseHttpServlet cmsRes= new CmsResponseHttpServlet(req,res,m_clusterurl);\n\n\t\ttry {\n\t\t\t\n\t\t   cms=initUser(cmsReq,cmsRes);\n\t\t\t \t  \n\t\t   checkRelocation(cms);\n\t\t   CmsFile file=m_opencms.initResource(cms); \n\t\t   m_opencms.setResponse(cms,file);\n\t\t   m_opencms.showResource(cms,file);\n\t\t   updateUser(cms,cmsReq,cmsRes);\n\t\t} catch (CmsException e) {\n\t\t\terrorHandling(cms,cmsReq,cmsRes,e);\n\t\t} \n\t}","id":29191,"modified_method":"/**\n\t * Method invoked on each HTML GET request.\n\t * <p>\n\t * (Overloaded Servlet API method, requesting a document).\n\t * Reads the URI received from the client and invokes the appropiate action.\n\t * \n\t * @param req   The clints request.\n\t * @param res   The servlets response.\n\t * @exception ServletException Thrown if request fails.\n\t * @exception IOException Thrown if user autherization fails.\n\t */\n\tpublic void doGet(HttpServletRequest req, HttpServletResponse res) \n\t\tthrows ServletException, IOException {\t\n\n\t\tif (req.getRequestURI().indexOf(\"system/workplace/action/login.html\")>0)\n\t\t{\n\t\t\tHttpSession session = req.getSession(false);\n\t\t\tif (session!=null) session.invalidate();\n\t\t}\n\n\t\tCmsObject cms=null;\n\t\t\n\t\tCmsRequestHttpServlet cmsReq= new CmsRequestHttpServlet(req);\n\t\tCmsResponseHttpServlet cmsRes= new CmsResponseHttpServlet(req,res,m_clusterurl);\n\n\t\ttry {\n\t\t\t\n\t\t   cms=initUser(cmsReq,cmsRes);\n\t\t\t \t  \n\t\t   checkRelocation(cms);\n\t\t   CmsFile file=m_opencms.initResource(cms); \n           if(file != null) {\n               // If the CmsFile object is null, the resource could not be found.\n               // Stop processing in this case to avoid NullPointerExceptions\n\t\t       m_opencms.setResponse(cms,file);\n\t\t       m_opencms.showResource(cms,file);\n\t\t       updateUser(cms,cmsReq,cmsRes);\n           }\n\t\t} catch (CmsException e) {\n\t\t\terrorHandling(cms,cmsReq,cmsRes,e);\n\t\t} \n\t}","commit_id":"02aa796757f6f19fde42209d1a99eaffc3d7092c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Performs a render of this component.\n\t */\n\tpublic final void render()\n\t{\n\t\t// Rendering is beginning\n\t\tinternalOnBeginRender();\n\t\tonBeginRender();\n\t\tif (log.isDebugEnabled())\n\t\t{\n\t\t\tlog.debug(\"Begin render \" + this);\n\t\t}\n\n\t\t// Any runtime exception that was thrown during rendering\n\t\tRuntimeException renderException = null;\n\n\t\ttry\n\t\t{\n\t\t\t// Get request cycle to render to\n\t\t\tfinal RequestCycle cycle = getRequestCycle();\n\n\t\t\t// Save original Response\n\t\t\tfinal Response originalResponse = cycle.getResponse();\n\n\t\t\t// If component is not visible, set response to NullResponse\n\t\t\tif (!isVisible())\n\t\t\t{\n\t\t\t\tcycle.setResponse(NullResponse.getInstance());\n\t\t\t}\n\n\t\t\t// Synchronize on model lock while rendering to help ensure\n\t\t\t// that the model doesn't change while its being read\n\t\t\tsynchronized (getModelLock())\n\t\t\t{\n\t\t\t\t// Call implementation to render component\n\t\t\t\tonRender();\n\n\t\t\t\t// Component has been rendered\n\t\t\t\trendered();\n\t\t\t}\n\n\t\t\t// Restore original response\n\t\t\tcycle.setResponse(originalResponse);\n\t\t}\n\t\tcatch (RuntimeException e)\n\t\t{\n\t\t\t// Remember exception in finally block\n\t\t\trenderException = e;\n\t\t\tthrow e;\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tif (log.isDebugEnabled())\n\t\t\t{\n\t\t\t\tlog.debug(\"End render \" + this);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Rendering has completed\n\t\t\t\tonEndRender();\n\t\t\t\tinternalOnEndRender();\n\n\t\t\t\t// Detach models now that rendering is fully completed\n\t\t\t\tdetachModels();\n\t\t\t}\n\t\t\tcatch (RuntimeException e)\n\t\t\t{\n\t\t\t\tif (renderException != null)\n\t\t\t\t{\n\t\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\t\"Exception thrown while cleaning up from the following exception which was thrown during rendering: \"\n\t\t\t\t\t\t\t\t\t+ Strings.toString(renderException), e);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":29192,"modified_method":"/**\n\t * Performs a render of this component.\n\t */\n\tpublic final void render()\n\t{\n\t\t// Any runtime exception thrown during rendering\n\t\tRuntimeException renderException = null;\n\t\t\n\t\t// Determine if component is visible\n\t\tfinal boolean isVisible = isVisible();\n\n\t\ttry\n\t\t{\n\t\t\t// Get request cycle to render to\n\t\t\tfinal RequestCycle cycle = getRequestCycle();\n\n\t\t\t// Save original Response\n\t\t\tfinal Response originalResponse;\n\n\t\t\t// If component is not visible, set response to NullResponse\n\t\t\tif (isVisible)\n\t\t\t{\n\t\t\t\t// No response to restore\n\t\t\t\toriginalResponse = null;\n\t\t\t\t\n\t\t\t\t// Rendering is beginning\n\t\t\t\tinternalOnBeginRender();\n\t\t\t\tonBeginRender();\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t{\n\t\t\t\t\tlog.debug(\"Begin render \" + this);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toriginalResponse = cycle.getResponse();\n\t\t\t\tcycle.setResponse(NullResponse.getInstance());\n\t\t\t}\n\n\t\t\t// Synchronize on model lock while rendering to help ensure\n\t\t\t// that the model doesn't change while its being read\n\t\t\tsynchronized (getModelLock())\n\t\t\t{\n\t\t\t\t// Call implementation to render component\n\t\t\t\tonRender();\n\n\t\t\t\t// Component has been rendered\n\t\t\t\trendered();\n\t\t\t}\n\n\t\t\t// Restore original response if any\n\t\t\tif (!isVisible)\n\t\t\t{\n\t\t\t\tcycle.setResponse(originalResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException e)\n\t\t{\n\t\t\t// Remember exception in finally block\n\t\t\trenderException = e;\n\t\t\tthrow e;\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tif (isVisible)\n\t\t\t{\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t{\n\t\t\t\t\tlog.debug(\"End render \" + this);\n\t\t\t\t}\n\t\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// Rendering has completed\n\t\t\t\t\tonEndRender();\n\t\t\t\t\tinternalOnEndRender();\n\t\n\t\t\t\t\t// Detach models now that rendering is fully completed\n\t\t\t\t\tdetachModels();\n\t\t\t\t}\n\t\t\t\tcatch (RuntimeException e)\n\t\t\t\t{\n\t\t\t\t\tif (renderException != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\t\t\"Exception thrown while cleaning up from the following exception which was thrown during rendering: \"\n\t\t\t\t\t\t\t\t\t\t+ Strings.toString(renderException), e);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"debd108b77dd4e3272d36cac91d2905c193369c1","url":"https://github.com/apache/wicket"},{"original_method":"/**\n     * Capture the full desktop screen using <tt>java.awt.Robot<\/tt>.\n     *\n     * @return <tt>BufferedImage<\/tt> of the desktop screen\n     */\n    public BufferedImage captureScreen()\n    {\n        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();\n\n        return captureScreen(0, 0, (int)dim.getWidth(), (int)dim.getHeight());\n    }","id":29193,"modified_method":"/**\n     * Capture the full desktop screen using <tt>java.awt.Robot<\/tt>.\n     *\n     * @return <tt>BufferedImage<\/tt> of the desktop screen\n     */\n    public BufferedImage captureScreen()\n    {\n        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();\n\n        return captureScreen(0, 0, dim.width, dim.height);\n    }","commit_id":"fef3d696e2bfc93aef8dfd634ae804a3dad4d297","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Capture the full desktop screen using native grabber.\n     *\n     * Contrary to other captureScreen method, it only returns raw bytes\n     * and not <tt>BufferedImage<\/tt>. It is done in order to limit\n     * slow operation such as converting ARGB images (uint32_t) to bytes\n     * especially for big big screen. For example a 1920x1200 desktop consumes\n     * 9 MB of memory for grabbing and another 9 MB array for convertion operation.\n     *\n     * @param output output buffer to store bytes in.\n     * Be sure that output length is sufficient\n     * @return true if success, false if JNI error or output length too short\n     */\n    public boolean captureScreen(byte output[])\n    {\n        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();\n\n        return captureScreen(0, 0, (int)dim.getWidth(), (int)dim.getHeight(), output);\n    }","id":29194,"modified_method":"/**\n     * Capture the full desktop screen using native grabber.\n     *\n     * Contrary to other captureScreen method, it only returns raw bytes\n     * and not <tt>BufferedImage<\/tt>. It is done in order to limit\n     * slow operation such as converting ARGB images (uint32_t) to bytes\n     * especially for big big screen. For example a 1920x1200 desktop consumes\n     * 9 MB of memory for grabbing and another 9 MB array for conversion\n     * operation.\n     *\n     * @param output output buffer to store bytes in.\n     * Be sure that output length is sufficient\n     * @return true if success, false if JNI error or output length too short\n     */\n    public boolean captureScreen(byte output[])\n    {\n        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();\n\n        return captureScreen(0, 0, dim.width, dim.height,\n                output);\n    }","commit_id":"fef3d696e2bfc93aef8dfd634ae804a3dad4d297","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Block and read a buffer from the stream.\n     *\n     * @param buffer the <tt>Buffer<\/tt> to read captured media into\n     * @throws IOException if an error occurs while reading.\n     */\n    public void read(Buffer buffer)\n        throws IOException\n    {\n        //System.out.println(System.currentTimeMillis());\n        byte data[] = (byte[])buffer.getData();\n        int dataLength = (data != null) ? data.length : 0;\n        long begin = System.currentTimeMillis();\n        /* maximum time allowed for a capture to respect frame rate */\n        long maxTime = 1000 / 10; \n        int wait = 0;\n\n        if((data != null) || (dataLength != 0))\n        {\n            byte buf[] = readScreen(data);\n\n            if(buf != data)\n            {\n                /* readScreen returns us a different buffer than JMF ones,\n                 * it means that JMF's initial buffer was too short.\n                 */\n                //System.out.println(\"use our own buffer\");\n                buffer.setData(buf);\n            }\n\n            buffer.setOffset(0);\n            buffer.setLength(buf.length);\n            buffer.setFormat(getFormat());\n            buffer.setHeader(null);\n            buffer.setTimeStamp(System.nanoTime());\n            buffer.setSequenceNumber(seqNo);\n            buffer.setFlags(Buffer.FLAG_SYSTEM_TIME | Buffer.FLAG_LIVE_DATA);\n            seqNo++;\n        }\n        \n        wait = (int)(maxTime - (System.currentTimeMillis() - begin));\n\n        try\n        {\n            /* sleep to respect as much as possible the \n             * frame rate\n             */\n            if(wait > 0)\n            {\n                Thread.sleep(wait);\n            }\n            else\n            {\n                /* yield a little bit to not use all the \n                 * CPU\n                 */\n                Thread.yield();\n            }\n        }\n        catch(Exception e)\n        {\n        }\n    }","id":29195,"modified_method":"/**\n     * Block and read a buffer from the stream.\n     *\n     * @param buffer the <tt>Buffer<\/tt> to read captured media into\n     * @throws IOException if an error occurs while reading.\n     */\n    public void read(Buffer buffer)\n        throws IOException\n    {\n        //System.out.println(System.currentTimeMillis());\n        long begin = System.currentTimeMillis();\n        /* maximum time allowed for a capture to respect frame rate */\n        long maxTime = 1000 / 10;\n        int wait = 0;\n\n        if(buffer.getFormat() instanceof AVFrameFormat)\n        {\n            /* native transfert: we keep data in native memory rather\n             * than Java Heap until we reach SwScaler\n             */\n            Object dataAv = buffer.getData();\n            AVFrame bufferFrame = null;\n            long bufferFramePtr = 0;\n\n            if (dataAv instanceof AVFrame)\n            {\n                bufferFrame = (AVFrame)dataAv;\n                bufferFramePtr = bufferFrame.getPtr();\n            }\n            else\n            {\n                bufferFrame = new FinalizableAVFrame();\n                bufferFramePtr = bufferFrame.getPtr();\n            }\n\n            AVFrameFormat bufferFrameFormat = (AVFrameFormat)buffer.getFormat();\n            Dimension bufferFrameSize = bufferFrameFormat.getSize();\n\n            if(readScreenNative(bufferFrameSize))\n            {\n                FFmpeg.avpicture_fill(\n                        bufferFramePtr,\n                        data.ptr,\n                        bufferFrameFormat.getPixFmt(),\n                        bufferFrameSize.width, bufferFrameSize.height);\n            }\n\n            buffer.setData(bufferFrame);\n        }\n        else\n        {\n            byte dataByte[] = (byte[])buffer.getData();\n            int dataLength = (dataByte != null) ? dataByte.length : 0;\n\n            if((dataByte != null) || (dataLength != 0))\n            {\n                byte buf[] = readScreen(dataByte);\n\n                if(buf != dataByte)\n                {\n                    /* readScreen returns us a different buffer than JMF ones,\n                     * it means that JMF's initial buffer was too short.\n                     */\n                    //System.out.println(\"use our own buffer\");\n                    buffer.setData(buf);\n                }\n\n                buffer.setOffset(0);\n                buffer.setLength(buf.length);\n            }\n        }\n\n        buffer.setFormat(buffer.getFormat());\n        buffer.setHeader(null);\n        buffer.setTimeStamp(System.nanoTime());\n        buffer.setSequenceNumber(seqNo);\n        buffer.setFlags(Buffer.FLAG_SYSTEM_TIME | Buffer.FLAG_LIVE_DATA);\n        seqNo++;\n\n        wait = (int)(maxTime - (System.currentTimeMillis() - begin));\n\n        try\n        {\n            /* sleep to respect as much as possible the\n             * frame rate\n             */\n            if(wait > 0)\n            {\n                Thread.sleep(wait);\n            }\n            else\n            {\n                /* yield a little bit to not use all the\n                 * CPU\n                 */\n                Thread.yield();\n            }\n        }\n        catch(Exception e)\n        {\n        }\n    }","commit_id":"fef3d696e2bfc93aef8dfd634ae804a3dad4d297","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stop desktop capture stream.\n     *\n     * @see AbstractPullBufferStream#stop()\n     */\n    @Override\n    public void stop()\n    {\n        logger.info(\"Stop stream\");\n    }","id":29196,"modified_method":"/**\n     * Stop desktop capture stream.\n     *\n     * @see AbstractPullBufferStream#stop()\n     */\n    @Override\n    public void stop()\n    {\n        logger.info(\"Stop stream\");\n\n        /* native pointer is freed in FinalizableAVFrame */\n        data = null;\n    }","commit_id":"fef3d696e2bfc93aef8dfd634ae804a3dad4d297","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void verifyCount( PageCursor cursor, int recordNumber, int counterNumber, long expectedCount )\n    {\n        cursor.setOffset( recordNumber * getRecordSize() + counterNumber * SizeOfLong );\n        long actualCount = cursor.getLong();\n\n        assertThat( actualCount, is( expectedCount ) );\n    }","id":29197,"modified_method":"public void verifyCount( PageCursor cursor, int recordNumber, int counterNumber, long expectedCount ) throws IOException\n    {\n        long actualCount;\n        do\n        {\n            cursor.setOffset( recordNumber * getRecordSize() + counterNumber * SizeOfLong );\n\n            actualCount = cursor.getLong();\n        } while ( cursor.shouldRetry() );\n\n        assertThat( actualCount, is( expectedCount ) );\n    }","commit_id":"ec7bddc713f0f5206fc112105a4058db273dbab5","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void verifyChecksum( PageCursor cursor, int recordNumber )\n    {\n        cursor.setOffset( recordNumber * getRecordSize() );\n\n        long actualChecksum = 0;\n        for ( int i = 0; i < numberOfCounters; i++ )\n        {\n            long count = cursor.getLong();\n\n            actualChecksum += count;\n        }\n        long checksum = cursor.getLong();\n\n        assertThat( actualChecksum, is( checksum ) );\n    }","id":29198,"modified_method":"public void verifyChecksum( PageCursor cursor, int recordNumber ) throws IOException\n    {\n        long actualChecksum = 0;\n        long checksum;\n        do\n        {\n            cursor.setOffset( recordNumber * getRecordSize() );\n\n            for ( int i = 0; i < numberOfCounters; i++ )\n            {\n                long count = cursor.getLong();\n\n                actualChecksum += count;\n            }\n\n            checksum = cursor.getLong();\n        } while ( cursor.shouldRetry() );\n\n        assertThat( actualChecksum, is( checksum ) );\n    }","commit_id":"ec7bddc713f0f5206fc112105a4058db273dbab5","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Performs the media processing defined by this codec.\n     * @param inputBuffer The <tt>Buffer<\/tt> that contains the media data\n     *        to be processed.\n     * @param outputBuffer The <tt>Buffer<\/tt> in which to store\n     *        the processed media data.\n     * @return <tt>BUFFER_PROCESSED_OK<\/tt> if the processing is successful.\n     *         @see PlugIn\n     */\n    public int process(Buffer inputBuffer, Buffer outputBuffer)\n    {\n        //copy the actual data from input to the output.\n        byte[] b = new byte[inputBuffer.getLength()];\n        outputBuffer.setLength(inputBuffer.getLength());\n\n        System.arraycopy(\n            inputBuffer.getData(), inputBuffer.getOffset(), b, 0, b.length);\n        outputBuffer.setData(b);\n\n        //now copy the output to the level dispatcher.\n        eventDispatcher.addData(outputBuffer);\n\n        //now copy the rest of the data.\n        outputBuffer.setFormat(inputBuffer.getFormat());\n        outputBuffer.setOffset(inputBuffer.getOffset());\n        outputBuffer.setHeader(inputBuffer.getHeader());\n        outputBuffer.setSequenceNumber(inputBuffer.getSequenceNumber());\n        outputBuffer.setTimeStamp(inputBuffer.getTimeStamp());\n        outputBuffer.setFlags(inputBuffer.getFlags());\n        outputBuffer.setDiscard(inputBuffer.isDiscard());\n        outputBuffer.setEOM(inputBuffer.isEOM());\n        outputBuffer.setDuration(inputBuffer.getDuration());\n\n        return BUFFER_PROCESSED_OK;\n    }","id":29199,"modified_method":"/**\n     * Performs the media processing defined by this codec.\n     * @param inputBuffer The <tt>Buffer<\/tt> that contains the media data\n     *        to be processed.\n     * @param outputBuffer The <tt>Buffer<\/tt> in which to store\n     *        the processed media data.\n     * @return <tt>BUFFER_PROCESSED_OK<\/tt> if the processing is successful.\n     *         @see PlugIn\n     */\n    public int process(Buffer inputBuffer, Buffer outputBuffer)\n    {\n        //copy the actual data from input to the output.\n        Object data = outputBuffer.getData();\n        byte[] bufferData;\n        if (data instanceof byte[] && ((byte[])data).length >= inputBuffer.getLength()) {\n            bufferData = (byte[])data;\n        }\n        else\n        {\n            bufferData = new byte[inputBuffer.getLength()];\n            outputBuffer.setData(bufferData);\n        }\n        outputBuffer.setLength(inputBuffer.getLength());\n        outputBuffer.setOffset(0);\n\n        System.arraycopy(\n            inputBuffer.getData(), inputBuffer.getOffset(), bufferData, 0, inputBuffer.getLength());\n\n        //now copy the output to the level dispatcher.\n        eventDispatcher.addData(outputBuffer);\n\n        //now copy the rest of the data.\n        outputBuffer.setFormat(inputBuffer.getFormat());\n        outputBuffer.setHeader(inputBuffer.getHeader());\n        outputBuffer.setSequenceNumber(inputBuffer.getSequenceNumber());\n        outputBuffer.setTimeStamp(inputBuffer.getTimeStamp());\n        outputBuffer.setFlags(inputBuffer.getFlags());\n        outputBuffer.setDiscard(inputBuffer.isDiscard());\n        outputBuffer.setEOM(inputBuffer.isEOM());\n        outputBuffer.setDuration(inputBuffer.getDuration());\n\n        return BUFFER_PROCESSED_OK;\n    }","commit_id":"93cae19530af93a9ae5d3aee12b6c6e762d29613","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Creates a new <tt>RawPacket<\/tt> from a specific <tt>DatagramPacket<\/tt>\r\n     * in order to have this instance receive its packet data through its\r\n     * {@link #read(byte[], int, int)} method. Allows extenders to intercept the\r\n     * packet data and possibly filter and/or modify it.\r\n     *\r\n     * @param datagramPacket the <tt>DatagramPacket<\/tt> containing the packet\r\n     * data\r\n     * @return a new <tt>RawPacket<\/tt> containing the packet data of the\r\n     * specified <tt>DatagramPacket<\/tt> or possibly its modification;\r\n     * <tt>null<\/tt> to ignore the packet data of the specified\r\n     * <tt>DatagramPacket<\/tt> and not make it available to this instance\r\n     * through its {@link #read(byte[], int, int)} method\r\n     */\r\n    protected RawPacket createRawPacket(DatagramPacket datagramPacket)\r\n    {\r\n        return\r\n            new RawPacket(\r\n                    datagramPacket.getData(),\r\n                    datagramPacket.getOffset(),\r\n                    datagramPacket.getLength());\r\n    }","id":29200,"modified_method":"/**\r\n     * Creates a new <tt>RawPacket<\/tt> from a specific <tt>DatagramPacket<\/tt>\r\n     * in order to have this instance receive its packet data through its\r\n     * {@link #read(byte[], int, int)} method. Allows extenders to intercept the\r\n     * packet data and possibly filter and/or modify it.\r\n     *\r\n     * @param datagramPacket the <tt>DatagramPacket<\/tt> containing the packet\r\n     * data\r\n     * @return a new <tt>RawPacket<\/tt> containing the packet data of the\r\n     * specified <tt>DatagramPacket<\/tt> or possibly its modification;\r\n     * <tt>null<\/tt> to ignore the packet data of the specified\r\n     * <tt>DatagramPacket<\/tt> and not make it available to this instance\r\n     * through its {@link #read(byte[], int, int)} method\r\n     */\r\n    protected RawPacket createRawPacket(DatagramPacket datagramPacket)\r\n    {\r\n        if (pkt == null || pkt.getBuffer().length < datagramPacket.getLength()) \r\n        {\r\n            pkt = null;\r\n            return new RawPacket(\r\n                    datagramPacket.getData(),\r\n                    datagramPacket.getOffset(),\r\n                    datagramPacket.getLength());      \r\n        }\r\n        System.arraycopy(datagramPacket.getData(), datagramPacket.getOffset(), pkt.getBuffer(), 0, datagramPacket.getLength());\r\n        return pkt;\r\n\r\n    }","commit_id":"93cae19530af93a9ae5d3aee12b6c6e762d29613","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Provides a dummy implementation to {@link\r\n     * RTPConnectorInputStream#getContentLength()} that always returns\r\n     * <tt>LENGTH_UNKNOWN<\/tt>.\r\n     *\r\n     * @return <tt>LENGTH_UNKNOWN<\/tt>, no matter what.\r\n     */\r\n    public long getContentLength()\r\n    {\r\n        return LENGTH_UNKNOWN;\r\n    }","id":29201,"modified_method":"/**\r\n     * Provides a dummy implementation to {@link\r\n     * RTPConnectorInputStream#getContentLength()} that always returns\r\n     * <tt>LENGTH_UNKNOWN<\/tt>.\r\n     *\r\n     * @return <tt>LENGTH_UNKNOWN<\/tt>, no matter what.\r\n     */\r\n    public long getContentLength()\r\n    {\r\n        return pkt.getLength();\r\n    }","commit_id":"93cae19530af93a9ae5d3aee12b6c6e762d29613","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Creates a new <tt>RawPacket<\/tt> from a specific <tt>byte[]<\/tt> buffer\r\n     * in order to have this instance send its packet data through its\r\n     * {@link #write(byte[], int, int)} method. Allows extenders to intercept\r\n     * the packet data and possibly filter and/or modify it.\r\n     *\r\n     * @param buffer the packet data to be sent to the targets of this instance\r\n     * @param offset the offset of the packet data in <tt>buffer<\/tt>\r\n     * @param length the length of the packet data in <tt>buffer<\/tt>\r\n     * @return a new <tt>RawPacket<\/tt> containing the packet data of the\r\n     * specified <tt>byte[]<\/tt> buffer or possibly its modification;\r\n     * <tt>null<\/tt> to ignore the packet data of the specified <tt>byte[]<\/tt>\r\n     * buffer and not send it to the targets of this instance through its\r\n     * {@link #write(byte[], int, int)} method\r\n     */\r\n    protected RawPacket createRawPacket(byte[] buffer, int offset, int length)\r\n    {\r\n        return new RawPacket(buffer, offset, length);\r\n    }","id":29202,"modified_method":"/**\r\n     * Creates a new <tt>RawPacket<\/tt> from a specific <tt>byte[]<\/tt> buffer\r\n     * in order to have this instance send its packet data through its\r\n     * {@link #write(byte[], int, int)} method. Allows extenders to intercept\r\n     * the packet data and possibly filter and/or modify it.\r\n     *\r\n     * @param buffer the packet data to be sent to the targets of this instance\r\n     * @param offset the offset of the packet data in <tt>buffer<\/tt>\r\n     * @param length the length of the packet data in <tt>buffer<\/tt>\r\n     * @return a new <tt>RawPacket<\/tt> containing the packet data of the\r\n     * specified <tt>byte[]<\/tt> buffer or possibly its modification;\r\n     * <tt>null<\/tt> to ignore the packet data of the specified <tt>byte[]<\/tt>\r\n     * buffer and not send it to the targets of this instance through its\r\n     * {@link #write(byte[], int, int)} method\r\n     */\r\n    protected RawPacket createRawPacket(byte[] buffer, int offset, int length)\r\n    {\r\n        RawPacket pkt = availRawPackets.poll();\r\n        if (pkt == null || pkt.getBuffer().length < length) \r\n        {\r\n            pkt = null;\r\n            return new RawPacket(buffer, offset, length);        \r\n        }\r\n        System.arraycopy(buffer, offset, pkt.getBuffer(), 0, length);\r\n        return pkt;\r\n    }","commit_id":"93cae19530af93a9ae5d3aee12b6c6e762d29613","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Sends a specific RTP packet through the <tt>DatagramSocket<\/tt> of this\r\n     * <tt>OutputDataSource<\/tt>.\r\n     *\r\n     * @param packet the RTP packet to be sent through the\r\n     * <tt>DatagramSocket<\/tt> of this <tt>OutputDataSource<\/tt>\r\n     * @return <tt>true<\/tt> if the specified <tt>packet<\/tt> was successfully\r\n     * sent; otherwise, <tt>false<\/tt>\r\n     */\r\n    private boolean send(RawPacket packet)\r\n    {\r\n        for (InetSocketAddress target : targets)\r\n        {\r\n            try\r\n            {\r\n                socket.send(\r\n                        new DatagramPacket(\r\n                                packet.getBuffer(),\r\n                                packet.getOffset(),\r\n                                packet.getLength(),\r\n                                target.getAddress(),\r\n                                target.getPort()));\r\n            }\r\n            catch (IOException ex)\r\n            {\r\n                // TODO error handling\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }","id":29203,"modified_method":"/**\r\n     * Sends a specific RTP packet through the <tt>DatagramSocket<\/tt> of this\r\n     * <tt>OutputDataSource<\/tt>.\r\n     *\r\n     * @param packet the RTP packet to be sent through the\r\n     * <tt>DatagramSocket<\/tt> of this <tt>OutputDataSource<\/tt>\r\n     * @return <tt>true<\/tt> if the specified <tt>packet<\/tt> was successfully\r\n     * sent; otherwise, <tt>false<\/tt>\r\n     */\r\n    private boolean send(RawPacket packet)\r\n    {\r\n        for (InetSocketAddress target : targets)\r\n        {\r\n            try\r\n            {\r\n                socket.send(\r\n                        new DatagramPacket(\r\n                                packet.getBuffer(),\r\n                                packet.getOffset(),\r\n                                packet.getLength(),\r\n                                target.getAddress(),\r\n                                target.getPort()));\r\n            }\r\n            catch (IOException ex)\r\n            {\r\n                availRawPackets.offer(packet);\r\n                // TODO error handling\r\n                return false;\r\n            }\r\n        }\r\n        availRawPackets.offer(packet);\r\n        return true;\r\n    }","commit_id":"93cae19530af93a9ae5d3aee12b6c6e762d29613","url":"https://github.com/jitsi/jitsi"},{"original_method":"@NotNull\n  @Override\n  public String toKotlin() {\n    return \"namespace\" + SPACE + myPackageName + SPACE + \"{\" + N +\n      AstUtil.joinNodes(myImports, N) + N2 +\n      AstUtil.joinNodes(myClasses, N) + N +\n      \"}\";\n  }","id":29204,"modified_method":"@NotNull\n  @Override\n  public String toKotlin() {\n    final String common = AstUtil.joinNodes(myImports, N) + N2 + AstUtil.joinNodes(myClasses, N) + N;\n    if (myPackageName.isEmpty())\n      return common;\n    return \"namespace\" + SPACE + myPackageName + SPACE + \"{\" + N +\n      common +\n      \"}\";\n  }","commit_id":"76995743d86985e9b808d757127edb4cd1ffbc84","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n  protected String methodToKotlin(String text) throws IOException {\n    String result = classToKotlin(\"final class C {\" + text + \"}\")\n      .replaceAll(\"class C\\\\(\\\\) \\\\{\", \"\");\n    result = result.substring(0, result.lastIndexOf(\"}\"));\n    return prettify(result);\n  }","id":29205,"modified_method":"@NotNull\n  protected String methodToKotlin(String text) throws IOException {\n    String result = fileToKotlin(\"final class C {\" + text + \"}\")\n      .replaceAll(\"class C\\\\(\\\\) \\\\{\", \"\");\n    result = result.substring(0, result.lastIndexOf(\"}\"));\n    return prettify(result);\n  }","commit_id":"76995743d86985e9b808d757127edb4cd1ffbc84","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n  protected void runTest() throws Throwable {\n    String javaPath = getTestDataPath() + File.separator + getTestFilePath();\n    String kotlinPath = javaPath.replace(\".jav\", \".kt\");\n\n    final File kotlinFile = new File(kotlinPath);\n    if (!kotlinFile.exists())\n      writeStringToFile(kotlinFile, \"\");\n    final String expected = readFileToString(kotlinFile);\n    final File javaFile = new File(javaPath);\n    final String javaCode = readFileToString(javaFile);\n\n    String actual = \"\";\n    if (javaFile.getParent().endsWith(\"/expression\")) actual = expressionToKotlin(javaCode);\n    else if (javaFile.getParent().endsWith(\"/statement\")) actual = statementToKotlin(javaCode);\n    else if (javaFile.getParent().endsWith(\"/method\")) actual = methodToKotlin(javaCode);\n    else if (javaFile.getParent().endsWith(\"/class\")) actual = classToKotlin(javaCode);\n    else if (javaFile.getParent().endsWith(\"/file\")) actual = fileToKotlin(javaCode);\n\n    assert !actual.equals(\"\") : \"Specify what is it: file, class, method, statement or expression\";\n\n    final File tmp = new File(kotlinPath + \".tmp\");\n    if (!expected.equals(actual)) writeStringToFile(tmp, actual);\n    if (expected.equals(actual) && tmp.exists()) tmp.delete();\n\n    Assert.assertEquals(expected, actual);\n  }","id":29206,"modified_method":"@Override\n  protected void runTest() throws Throwable {\n    String javaPath = getTestDataPath() + File.separator + getTestFilePath();\n    String kotlinPath = javaPath.replace(\".jav\", \".kt\");\n\n    final File kotlinFile = new File(kotlinPath);\n    if (!kotlinFile.exists())\n      writeStringToFile(kotlinFile, \"\");\n    final String expected = readFileToString(kotlinFile);\n    final File javaFile = new File(javaPath);\n    final String javaCode = readFileToString(javaFile);\n\n    String actual = \"\";\n    if (javaFile.getParent().endsWith(\"/expression\")) actual = expressionToKotlin(javaCode);\n    else if (javaFile.getParent().endsWith(\"/statement\")) actual = statementToKotlin(javaCode);\n    else if (javaFile.getParent().endsWith(\"/method\")) actual = methodToKotlin(javaCode);\n    else if (javaFile.getParent().endsWith(\"/class\")) actual = fileToKotlin(javaCode);\n    else if (javaFile.getParent().endsWith(\"/file\")) actual = fileToKotlin(javaCode);\n\n    assert !actual.equals(\"\") : \"Specify what is it: file, class, method, statement or expression\";\n\n    final File tmp = new File(kotlinPath + \".tmp\");\n    if (!expected.equals(actual)) writeStringToFile(tmp, actual);\n    if (expected.equals(actual) && tmp.exists()) tmp.delete();\n\n    Assert.assertEquals(expected, actual);\n  }","commit_id":"76995743d86985e9b808d757127edb4cd1ffbc84","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n  List<Function> methodsExceptConstructors() {\n    final LinkedList<Function> result = new LinkedList<Function>();\n    for (Function m : myMethods)\n      if (m.getKind() != Kind.CONSTRUCTOR)\n        result.add(m);\n    return result;\n  }","id":29207,"modified_method":"@NotNull\n  LinkedList<Member> membersExceptConstructors() {\n    final LinkedList<Member> result = new LinkedList<Member>();\n    for (Member m : myMembers)\n      if (m.getKind() != Kind.CONSTRUCTOR)\n        result.add(m);\n    return result;\n  }","commit_id":"62bfb55973a159c92468e438a2c7f94053203229","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public Class(Identifier name, Set<String> modifiers, List<Element> typeParameters, List<Type> extendsTypes,\n               List<Expression> baseClassParams, List<Type> implementsTypes, List<Class> innerClasses, List<Function> methods, List<Field> fields, List<Initializer> initializers) {\n    myName = name;\n    myBaseClassParams = baseClassParams;\n    myModifiers = modifiers;\n    myTypeParameters = typeParameters;\n    myExtendsTypes = extendsTypes;\n    myImplementsTypes = implementsTypes;\n    myInnerClasses = innerClasses;\n    myMethods = methods;\n    myFields = fields;\n    myInitializers = initializers;\n  }","id":29208,"modified_method":"public Class(Identifier name, Set<String> modifiers, List<Element> typeParameters, List<Type> extendsTypes,\n               List<Expression> baseClassParams, List<Type> implementsTypes, List<? extends Member> members) {\n    myName = name;\n    myBaseClassParams = baseClassParams;\n    myModifiers = modifiers;\n    myTypeParameters = typeParameters;\n    myExtendsTypes = extendsTypes;\n    myImplementsTypes = implementsTypes;\n    myMembers = members;\n  }","commit_id":"62bfb55973a159c92468e438a2c7f94053203229","url":"https://github.com/JetBrains/kotlin"},{"original_method":"String bodyToKotlin() {\n    return SPACE + \"{\" + N +\n      AstUtil.joinNodes(getNonStatic(myFields), N) + N +\n      AstUtil.joinNodes(getNonStatic(myInitializers), N) + N +\n      classObjectToKotlin() + N +\n      AstUtil.joinNodes(getNonStatic(methodsExceptConstructors()), N) + N +\n      AstUtil.joinNodes(getNonStatic(myInnerClasses), N) + N +\n      primaryConstructorBodyToKotlin() + N +\n      \"}\";\n  }","id":29209,"modified_method":"String bodyToKotlin() {\n    return SPACE + \"{\" + N +\n      AstUtil.joinNodes(getNonStatic(membersExceptConstructors()), N) + N +\n      classObjectToKotlin() + N +\n      primaryConstructorBodyToKotlin() + N +\n      \"}\";\n  }","commit_id":"62bfb55973a159c92468e438a2c7f94053203229","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n  private Constructor getPrimaryConstructor() {\n    for (Function m : myMethods)\n      if (m.getKind() == Kind.CONSTRUCTOR)\n        if (((Constructor) m).isPrimary())\n          return (Constructor) m;\n    return null;\n  }","id":29210,"modified_method":"@Nullable\n  private Constructor getPrimaryConstructor() {\n    for (Member m : myMembers)\n      if (m.getKind() == Kind.CONSTRUCTOR)\n        if (((Constructor) m).isPrimary())\n          return (Constructor) m;\n    return null;\n  }","commit_id":"62bfb55973a159c92468e438a2c7f94053203229","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n  List<Function> secondaryConstructorsAsStaticInitFunction() {\n    final LinkedList<Function> result = new LinkedList<Function>();\n    for (Function m : myMethods)\n      if (m.getKind() == Kind.CONSTRUCTOR && !((Constructor) m).isPrimary()) {\n        Set<String> modifiers = new HashSet<String>(m.myModifiers);\n        modifiers.add(Modifier.STATIC);\n\n        final List<Statement> statements = m.getBlock().getStatements();\n        statements.add(new ReturnStatement(new IdentifierImpl(\"__\"))); // TODO: move to one place, find other __ usages\n        final Block block = new Block(statements);\n\n        result.add(new Function(\n          new IdentifierImpl(\"init\"),\n          modifiers,\n          new ClassType(myName),\n          m.getTypeParameters(),\n          m.getParams(),\n          block\n        ));\n      }\n    return result;\n  }","id":29211,"modified_method":"@NotNull\n  List<Function> secondaryConstructorsAsStaticInitFunction() {\n    final LinkedList<Function> result = new LinkedList<Function>();\n    for (Member m : myMembers)\n      if (m.getKind() == Kind.CONSTRUCTOR && !((Constructor) m).isPrimary()) {\n        Function f = (Function) m;\n        Set<String> modifiers = new HashSet<String>(m.myModifiers);\n        modifiers.add(Modifier.STATIC);\n\n        final List<Statement> statements = f.getBlock().getStatements();\n        statements.add(new ReturnStatement(new IdentifierImpl(\"__\"))); // TODO: move to one place, find other __ usages\n        final Block block = new Block(statements);\n\n        result.add(new Function(\n          new IdentifierImpl(\"init\"),\n          modifiers,\n          new ClassType(myName),\n          f.getTypeParameters(),\n          f.getParams(),\n          block\n        ));\n      }\n    return result;\n  }","commit_id":"62bfb55973a159c92468e438a2c7f94053203229","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private String classObjectToKotlin() {\n    final List<Member> staticMethods = new LinkedList<Member>(secondaryConstructorsAsStaticInitFunction());\n    staticMethods.addAll(getStatic(methodsExceptConstructors()));\n    final List<Member> staticFields = getStatic(myFields);\n    final List<Member> staticInitializers = getStatic(myInitializers);\n    final List<Member> staticInnerClasses = getStatic(myInnerClasses);\n    if (staticFields.size() + staticMethods.size() + staticInnerClasses.size() + staticInitializers.size() > 0) {\n      return \"class\" + SPACE + \"object\" + SPACE + \"{\" + N +\n        AstUtil.joinNodes(staticFields, N) + N +\n        AstUtil.joinNodes(staticInitializers, N) + N +\n        AstUtil.joinNodes(staticMethods, N) + N +\n        AstUtil.joinNodes(staticInnerClasses, N) + N +\n        \"}\";\n    }\n    return EMPTY;\n  }","id":29212,"modified_method":"private String classObjectToKotlin() {\n    final List<Member> staticMembers = new LinkedList<Member>(secondaryConstructorsAsStaticInitFunction());\n    staticMembers.addAll(getStatic(membersExceptConstructors()));\n    if (staticMembers.size() > 0) {\n      return \"class\" + SPACE + \"object\" + SPACE + \"{\" + N +\n        AstUtil.joinNodes(staticMembers, N) + N +\n        \"}\";\n    }\n    return EMPTY;\n  }","commit_id":"62bfb55973a159c92468e438a2c7f94053203229","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n  private static Class classToClass(@NotNull PsiClass psiClass) {\n    final Set<String> modifiers = modifiersListToModifiersSet(psiClass.getModifierList());\n    final List<Class> innerClasses = classesToClassList(psiClass.getAllInnerClasses());\n    final List<Function> methods = methodsToFunctionList(psiClass.getMethods());\n    final List<Field> fields = fieldsToFieldList(psiClass.getFields());\n    final List<Initializer> anonymousInitializers = initializersToInitializerList(psiClass.getInitializers());\n    final List<Element> typeParameters = elementsToElementList(psiClass.getTypeParameters());\n    final List<Type> implementsTypes = typesToNotNullableTypeList(psiClass.getImplementsListTypes());\n    final List<Type> extendsTypes = typesToNotNullableTypeList(psiClass.getExtendsListTypes());\n    final IdentifierImpl name = new IdentifierImpl(psiClass.getName());\n    final List<Expression> baseClassParams = new LinkedList<Expression>();\n\n    // we try to find super() call and generate class declaration like that: class A(name: String, i : Int) : Base(name)\n    final SuperVisitor visitor = new SuperVisitor();\n    psiClass.accept(visitor);\n    final HashSet<PsiExpressionList> resolvedSuperCallParameters = visitor.getResolvedSuperCallParameters();\n    if (resolvedSuperCallParameters.size() == 1)\n      baseClassParams.addAll(\n        expressionsToExpressionList(\n          resolvedSuperCallParameters.toArray(new PsiExpressionList[1])[0].getExpressions()\n        )\n      );\n\n    // we create primary constructor from all non final fields and fields without initializers\n    if (!psiClass.isEnum() && !psiClass.isInterface() && psiClass.getConstructors().length > 1 && getPrimaryConstructorForThisCase(psiClass) == null) {\n      final List<Field> finalOrWithEmptyInitializer = getFinalOrWithEmptyInitializer(fields);\n      final Map<String, String> initializers = new HashMap<String, String>();\n\n      for (final Function f : methods) {\n        for (Field fo : finalOrWithEmptyInitializer) {\n          String init = getDefaultInitializer(fo);\n          initializers.put(fo.getIdentifier().toKotlin(), init);\n        }\n\n        // and modify secondaries\n        if (f.getKind() == INode.Kind.CONSTRUCTOR && !((Constructor) f).isPrimary()) {\n          final List<Statement> newStatements = new LinkedList<Statement>();\n\n          for (Statement s : f.getBlock().getStatements()) {\n            boolean isRemoved = false;\n\n            if (s.getKind() == INode.Kind.ASSIGNMENT_EXPRESSION) {\n              final AssignmentExpression assignmentExpression = (AssignmentExpression) s;\n              if (assignmentExpression.getLeft().getKind() == INode.Kind.CALL_CHAIN) {\n                for (Field fo : finalOrWithEmptyInitializer) {\n                  final String id = fo.getIdentifier().toKotlin();\n                  if (((CallChainExpression) assignmentExpression.getLeft()).getIdentifier().toKotlin().endsWith(\".\" + id)) {\n                    initializers.put(id, assignmentExpression.getRight().toKotlin());\n                    isRemoved = true;\n                  }\n                }\n              }\n            }\n            if (!isRemoved) {\n              newStatements.add(s);\n            }\n          }\n\n          newStatements.add(\n            0,\n            new DummyStringStatement(\n              \"val __ = \" + createPrimaryConstructorInvocation(\n                name.toKotlin(),\n                finalOrWithEmptyInitializer,\n                initializers)));\n\n          f.setBlock(new Block(newStatements));\n        }\n      }\n\n      methods.add(\n        new Constructor(\n          Identifier.EMPTY_IDENTIFIER,\n          Collections.<String>emptySet(),\n          new ClassType(name),\n          Collections.<Element>emptyList(),\n          new ParameterList(createParametersFromFields(finalOrWithEmptyInitializer)),\n          new Block(createInitStatementsFromFields(finalOrWithEmptyInitializer)),\n          true\n        )\n      );\n    }\n\n    if (psiClass.isInterface())\n      return new Trait(name, modifiers, typeParameters, extendsTypes, Collections.<Expression>emptyList(), implementsTypes, innerClasses, methods, fields, anonymousInitializers);\n    if (psiClass.isEnum())\n      return new Enum(name, modifiers, typeParameters, Collections.<Type>emptyList(), Collections.<Expression>emptyList(), implementsTypes,\n        innerClasses, methods, fieldsToFieldListForEnums(psiClass.getAllFields()), anonymousInitializers);\n    return new Class(name, modifiers, typeParameters, extendsTypes, baseClassParams, implementsTypes, innerClasses, methods, fields, anonymousInitializers);\n  }","id":29213,"modified_method":"@NotNull\n  private static Class classToClass(@NotNull PsiClass psiClass) {\n    final Set<String> modifiers = modifiersListToModifiersSet(psiClass.getModifierList());\n    final List<Field> fields = fieldsToFieldList(psiClass.getFields());\n    final List<Element> typeParameters = elementsToElementList(psiClass.getTypeParameters());\n    final List<Type> implementsTypes = typesToNotNullableTypeList(psiClass.getImplementsListTypes());\n    final List<Type> extendsTypes = typesToNotNullableTypeList(psiClass.getExtendsListTypes());\n    final IdentifierImpl name = new IdentifierImpl(psiClass.getName());\n    final List<Expression> baseClassParams = new LinkedList<Expression>();\n\n    List<Member> members = getMembers(psiClass);\n\n    // we try to find super() call and generate class declaration like that: class A(name: String, i : Int) : Base(name)\n    final SuperVisitor visitor = new SuperVisitor();\n    psiClass.accept(visitor);\n    final HashSet<PsiExpressionList> resolvedSuperCallParameters = visitor.getResolvedSuperCallParameters();\n    if (resolvedSuperCallParameters.size() == 1)\n      baseClassParams.addAll(\n        expressionsToExpressionList(\n          resolvedSuperCallParameters.toArray(new PsiExpressionList[1])[0].getExpressions()\n        )\n      );\n\n    // we create primary constructor from all non final fields and fields without initializers\n    if (!psiClass.isEnum() && !psiClass.isInterface() && psiClass.getConstructors().length > 1 && getPrimaryConstructorForThisCase(psiClass) == null) {\n      final List<Field> finalOrWithEmptyInitializer = getFinalOrWithEmptyInitializer(fields);\n      final Map<String, String> initializers = new HashMap<String, String>();\n\n      for (final Member m : members) {\n        // and modify secondaries\n        if (m.getKind() == INode.Kind.CONSTRUCTOR) {\n          Function f = (Function)m;\n          if (!((Constructor) f).isPrimary()) {\n            for (Field fo : finalOrWithEmptyInitializer) {\n              String init = getDefaultInitializer(fo);\n              initializers.put(fo.getIdentifier().toKotlin(), init);\n            }\n\n            final List<Statement> newStatements = new LinkedList<Statement>();\n\n            for (Statement s : f.getBlock().getStatements()) {\n              boolean isRemoved = false;\n\n              if (s.getKind() == INode.Kind.ASSIGNMENT_EXPRESSION) {\n                final AssignmentExpression assignmentExpression = (AssignmentExpression) s;\n                if (assignmentExpression.getLeft().getKind() == INode.Kind.CALL_CHAIN) {\n                  for (Field fo : finalOrWithEmptyInitializer) {\n                    final String id = fo.getIdentifier().toKotlin();\n                    if (((CallChainExpression) assignmentExpression.getLeft()).getIdentifier().toKotlin().endsWith(\".\" + id)) {\n                      initializers.put(id, assignmentExpression.getRight().toKotlin());\n                      isRemoved = true;\n                    }\n                  }\n                }\n              }\n              if (!isRemoved) {\n                newStatements.add(s);\n              }\n            }\n\n            newStatements.add(\n              0,\n              new DummyStringStatement(\n                \"val __ = \" + createPrimaryConstructorInvocation(\n                  name.toKotlin(),\n                  finalOrWithEmptyInitializer,\n                  initializers)));\n\n            f.setBlock(new Block(newStatements));\n          }\n        }\n      }\n\n      members.add(\n        new Constructor(\n          Identifier.EMPTY_IDENTIFIER,\n          Collections.<String>emptySet(),\n          new ClassType(name),\n          Collections.<Element>emptyList(),\n          new ParameterList(createParametersFromFields(finalOrWithEmptyInitializer)),\n          new Block(createInitStatementsFromFields(finalOrWithEmptyInitializer)),\n          true\n        )\n      );\n    }\n\n    if (psiClass.isInterface())\n      return new Trait(name, modifiers, typeParameters, extendsTypes, Collections.<Expression>emptyList(), implementsTypes, members);\n    if (psiClass.isEnum())\n      return new Enum(name, modifiers, typeParameters, Collections.<Type>emptyList(), Collections.<Expression>emptyList(), implementsTypes, members);\n    return new Class(name, modifiers, typeParameters, extendsTypes, baseClassParams, implementsTypes, members);\n  }","commit_id":"62bfb55973a159c92468e438a2c7f94053203229","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n  public static AnonymousClass anonymousClassToAnonymousClass(@NotNull PsiAnonymousClass anonymousClass) {\n    // TODO: replace by Block, use class.getChild() method\n    return new AnonymousClass(\n      classesToClassList(anonymousClass.getAllInnerClasses()),\n      methodsToFunctionList(anonymousClass.getMethods()),\n      fieldsToFieldList(anonymousClass.getAllFields()),\n      initializersToInitializerList(anonymousClass.getInitializers())\n    );\n  }","id":29214,"modified_method":"@NotNull\n  public static AnonymousClass anonymousClassToAnonymousClass(@NotNull PsiAnonymousClass anonymousClass) {\n    return new AnonymousClass(getMembers(anonymousClass));\n  }","commit_id":"62bfb55973a159c92468e438a2c7f94053203229","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n  @Override\n  public String toKotlin() {\n    return modifiersToKotlin() + \"enum\" + SPACE + myName.toKotlin() + primaryConstructorSignatureToKotlin() + typeParametersToKotlin() + implementTypesToKotlin() + SPACE + \"{\" + N +\n      AstUtil.joinNodes(myFields, N) + N +\n      AstUtil.joinNodes(methodsExceptConstructors(), N) + N +\n      AstUtil.joinNodes(myInnerClasses, N) + N +\n      primaryConstructorBodyToKotlin() + N +\n      \"}\";\n  }","id":29215,"modified_method":"@NotNull\n  @Override\n  public String toKotlin() {\n    return modifiersToKotlin() + \"enum\" + SPACE + myName.toKotlin() + primaryConstructorSignatureToKotlin() +\n      typeParametersToKotlin() + implementTypesToKotlin() + SPACE + \"{\" + N +\n      AstUtil.joinNodes(membersExceptConstructors(), N) + N +\n      primaryConstructorBodyToKotlin() + N +\n      \"}\";\n  }","commit_id":"62bfb55973a159c92468e438a2c7f94053203229","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public Enum(Identifier name, Set<String> modifiers, List<Element> typeParameters, List<Type> extendsTypes, List<Expression> baseClassParams, List<Type> implementsTypes, List<Class> innerClasses, List<Function> methods, List<Field> fields, List<Initializer> initializers) {\n    super(name, modifiers, typeParameters, extendsTypes, baseClassParams, implementsTypes, innerClasses, methods, fields, initializers);\n  }","id":29216,"modified_method":"public Enum(Identifier name, Set<String> modifiers, List<Element> typeParameters, List<Type> extendsTypes,\n              List<Expression> baseClassParams, List<Type> implementsTypes, List<Member> members) {\n    super(name, modifiers, typeParameters, extendsTypes, baseClassParams, implementsTypes, members);\n  }","commit_id":"62bfb55973a159c92468e438a2c7f94053203229","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public Trait(Identifier name, Set<String> modifiers, List<Element> typeParameters, List<Type> extendsTypes, List<Expression> baseClassParams, List<Type> implementsTypes, List<Class> innerClasses, List<Function> methods, List<Field> fields, List<Initializer> initializers) {\n    super(name, modifiers, typeParameters, extendsTypes, baseClassParams, implementsTypes, innerClasses, methods, fields, initializers);\n    TYPE = \"trait\";\n  }","id":29217,"modified_method":"public Trait(Identifier name, Set<String> modifiers, List<Element> typeParameters, List<Type> extendsTypes,\n               List<Expression> baseClassParams, List<Type> implementsTypes, List<Member> members) {\n    super(name, modifiers, typeParameters, extendsTypes, baseClassParams, implementsTypes, members);\n    TYPE = \"trait\";\n  }","commit_id":"62bfb55973a159c92468e438a2c7f94053203229","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n\tpublic void initialize() {\n\t\tcoverage = new RunningCoverage(0,WINDOW_SIZE);\n\t\t\n\t\tint nSams = getToolkit().getArguments().samFiles.size(); \n\t\t\n\t\t\n\t\tif ( call_somatic ) {\n\t\t\tif ( nSams != 2 ) {\n\t\t\t\tSystem.out.println(\"In --somatic mode two input bam files must be specified (normal/tumor)\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t\tnormal_coverage = new RunningCoverage(0,WINDOW_SIZE);\n\t\t\t\n\t\t\t// this is an ugly hack: we want to be able to tell what file (tumor/normal sample) each read came from,\n\t\t\t// but reads do not carry this information!\n\t\t\t\n//\t\t\tSAMFileReader rn = new SAMFileReader(getToolkit().getArguments().samFiles.get(0));\n//\t\t\tfor ( SAMReadGroupRecord rec : rn.getFileHeader().getReadGroups() ) {\n//\t\t\t\tnormal_samples.add(rec.getSample());\n//\t\t\t}\n//\t\t\trn.close();\n//\t\t\trn = new SAMFileReader(getToolkit().getArguments().samFiles.get(1));\n//\t\t\tfor ( SAMReadGroupRecord rec : rn.getFileHeader().getReadGroups() ) {\n//\t\t\t\ttumor_samples.add(rec.getSample());\n//\t\t\t}\n//\t\t\trn.close();\n\t\t\t\n\t\t} else {\n\t\t\tif ( nSams != 1 ) System.out.println(\"WARNING: multiple input files specified. \\n\"+\n\t\t\t\t\t\"WARNING: Without --somatic option they will be merged and processed as a single sample\");\n\t\t}\n\t\ttry {\n\t\t\toutput = new java.io.FileWriter(bed_file);\n\t\t} catch (IOException e) {\n\t\t\tthrow new StingException(\"Failed to open file for writing BED output\");\n\t\t}\n\t}","id":29218,"modified_method":"@Override\n\tpublic void initialize() {\n\t\tcoverage = new RunningCoverage(0,WINDOW_SIZE);\n\t\t\n\t\tReferenceOrderedData<rodRefSeq> refseq = new ReferenceOrderedData<rodRefSeq>(\"refseq\",\n\t\t\t\t\tnew java.io.File(\"/humgen/gsa-scr1/GATK_Data/refGene.sorted.txt\"),rodRefSeq.class);\n\t\t\n\t\trefseqIterator = refseq.iterator();\n\t\t\n\t\tint nSams = getToolkit().getArguments().samFiles.size(); \n\t\t\n\t\tlocation = new GenomeLoc(0,1);\n\t\t\n\t\tif ( call_somatic ) {\n\t\t\tif ( nSams != 2 ) {\n\t\t\t\tSystem.out.println(\"In --somatic mode two input bam files must be specified (normal/tumor)\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t\tnormal_coverage = new RunningCoverage(0,WINDOW_SIZE);\n\t\t\t\n\t\t\t// this is an ugly hack: we want to be able to tell what file (tumor/normal sample) each read came from,\n\t\t\t// but reads do not carry this information!\n\t\t\t\n//\t\t\tSAMFileReader rn = new SAMFileReader(getToolkit().getArguments().samFiles.get(0));\n//\t\t\tfor ( SAMReadGroupRecord rec : rn.getFileHeader().getReadGroups() ) {\n//\t\t\t\tnormal_samples.add(rec.getSample());\n//\t\t\t}\n//\t\t\trn.close();\n//\t\t\trn = new SAMFileReader(getToolkit().getArguments().samFiles.get(1));\n//\t\t\tfor ( SAMReadGroupRecord rec : rn.getFileHeader().getReadGroups() ) {\n//\t\t\t\ttumor_samples.add(rec.getSample());\n//\t\t\t}\n//\t\t\trn.close();\n\t\t\t\n\t\t} else {\n\t\t\tif ( nSams != 1 ) System.out.println(\"WARNING: multiple input files specified. \\n\"+\n\t\t\t\t\t\"WARNING: Without --somatic option they will be merged and processed as a single sample\");\n\t\t}\n\t\ttry {\n\t\t\toutput = new java.io.FileWriter(bed_file);\n\t\t} catch (IOException e) {\n\t\t\tthrow new StingException(\"Failed to open file for writing BED output\");\n\t\t}\n\t}","commit_id":"ca09a10b768ab143bdf3ae6edf6df6aafe06ce56","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n\tpublic Integer map(char[] ref, SAMRecord read) {\n\t\t\n\t\tif ( read.getReadUnmappedFlag() && read.getReferenceIndex() == SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX &&\n\t\t\t\tread.getAlignmentStart() == SAMRecord.NO_ALIGNMENT_START ) {\n\t\t\tSystem.out.println(\"I think I reached unmapped reads at the end of the file(s) and I am done...\");\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif ( read.getReadUnmappedFlag() ||\n\t\t\t read.getDuplicateReadFlag() ||\n\t\t\t read.getNotPrimaryAlignmentFlag() ||\n\t\t\t read.getMappingQuality() == 0 ) return 0; // we do not need those reads!\n\t\t\n\t\t\n\t\tif ( read.getReferenceIndex() != currentContigIndex ) { \n\t\t\t// we just jumped onto a new contig\n\t\t\t\n\t\t\tif ( read.getReferenceIndex() < currentContigIndex ) // paranoidal \n\t\t\t\tthrow new StingException(\"Read \"+read.getReadName()+\": contig is out of order\");\n\t\t\t\n\t\t\tif ( call_somatic) emit_somatic(1000000000); // print remaining indels from the previous contig (if any);\n\t\t\telse emit(1000000000);\n\t\t\tcurrentContigIndex = read.getReferenceIndex();\n\t\t\trefName = new String(read.getReferenceName());\n\t\t\tcoverage.clear(); // reset coverage window; this will also set reference position to 0\n\t\t\tif ( call_somatic) normal_coverage.clear();\n\t\t}\n\t\t\n\t\tif ( read.getAlignmentStart() < coverage.getStart() ) {\n\t\t\t// should never happen\n\t\t\tthrow new StingException(\"Read \"+read.getReadName()+\": out of order on the contig\");\n\t\t}\n\t\t\n\t\t// a little trick here: we want to make sure that current read completely fits into the current\n\t\t// window so that we can accumulate the coverage/indel counts over the whole length of the read.\n\t\t// The ::getAlignmentEnd() method returns the last position on the reference where bases from the\n\t\t// read actually match (M or D cigar elements). After our cleaning procedure, we can have reads that end\n\t\t// with I element, which is not gonna be counted into alignment length on the reference. On the other hand, \n\t\t// in this program we assign insertions, internally, to the first base *after* the insertion position. \n\t\t// Hence, we have to make sure that that extra base is already in the window or we will get IndexOutOfBounds.\n\t\t\n\t\tlong alignmentEnd = read.getAlignmentEnd();\n\t\tCigar c = read.getCigar();\n\t\tif ( c.getCigarElement(c.numCigarElements()-1).getOperator() == CigarOperator.I) alignmentEnd++;\n\t\t\n\t\tif ( alignmentEnd > coverage.getStop()) {\n\t\t\t\n\t\t\t// we don't emit anything until we reach a read that does not fit into the current window.\n\t\t\t// At that point we shift the window to the start of that read and emit everything prior to \n\t\t\t// that position (reads are sorted, so we are not gonna see any more coverage at those lower positions).\n\t\t\t// Clearly, we assume here that window is large enough to accomodate any single read, so simply shifting\n\t\t\t// the window to the read's start will ensure that the read fits...\n\t\t\t\n\t\t\tif ( call_somatic ) emit_somatic( read.getAlignmentStart() );\n\t\t\telse emit( read.getAlignmentStart() );\n\n\t\t\tif ( read.getAlignmentEnd() > coverage.getStop()) {\n\t\t\t\t// ooops, looks like the read does not fit into the current window!!\n\t\t\t\tthrow new StingException(\"Read \"+read.getReadName()+\": out of coverage window bounds.Probably window is too small.\\n\"+\n\t\t\t\t\t\"Read length=\"+read.getReadLength()+\"; cigar=\"+read.getCigarString()+\"; start=\"+\n\t\t\t\t\tread.getAlignmentStart()+\"; end=\"+read.getAlignmentEnd()+\"; window start=\"+coverage.getStart()+\n\t\t\t\t\t\"; window end=\"+coverage.getStop());\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( call_somatic ) {\n\t\t\t\n\t\t\t// this is a hack. currently we can get access to the merged header only through the read,\n\t\t\t// so below we figure out which of the reassigned read groups in the merged stream are normal\n\t\t\t// and which are tumor, and we make sure we do it only once:\n\t\t\tif ( normal_samples.size() == 0 ) assignReadGroups(read.getHeader()); \n\t\t\t\n\t\t\tString rg = (String)read.getAttribute(\"RG\");\n\t\t\tif ( rg == null ) throw new StingException(\"Read \"+read.getReadName()+\" has no read group in merged stream\");\n\t\t\t\n\t\t\tif ( normal_samples.contains(rg) ) {\n\t\t\t\tnormal_coverage.add(read,ref);\n\t\t\t} else if ( tumor_samples.contains(rg) ) {\n\t\t\t\tcoverage.add(read,ref);\n\t\t\t} else {\n\t\t\t\tthrow new StingException(\"Unrecognized read group in merged stream: \"+rg);\n\t\t\t}\n\t\t} else { \n\t\t\tcoverage.add(read, ref);\n\t\t}\n\t\t\n\t\treturn 1;\n\t}","id":29219,"modified_method":"@Override\n\tpublic Integer map(char[] ref, SAMRecord read) {\n\t\t\n\t\tif ( read.getReadUnmappedFlag() && read.getReferenceIndex() == SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX &&\n\t\t\t\tread.getAlignmentStart() == SAMRecord.NO_ALIGNMENT_START ) {\n\t\t\tSystem.out.println(\"I think I reached unmapped reads at the end of the file(s) and I am done...\");\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif ( read.getReadUnmappedFlag() ||\n\t\t\t read.getDuplicateReadFlag() ||\n\t\t\t read.getNotPrimaryAlignmentFlag() ||\n\t\t\t read.getMappingQuality() == 0 ) return 0; // we do not need those reads!\n\t\t\n\t\t\n\t\tif ( read.getReferenceIndex() != currentContigIndex ) { \n\t\t\t// we just jumped onto a new contig\n\t\t\t\n\t\t\tif ( read.getReferenceIndex() < currentContigIndex ) // paranoidal \n\t\t\t\tthrow new StingException(\"Read \"+read.getReadName()+\": contig is out of order\");\n\t\t\t\n\t\t\tif ( call_somatic) emit_somatic(1000000000); // print remaining indels from the previous contig (if any);\n\t\t\telse emit(1000000000);\n\t\t\tcurrentContigIndex = read.getReferenceIndex();\n\t\t\trefName = new String(read.getReferenceName());\n\t\t\tlocation.setContig(refName);\n\t\t\t\n\t\t\tcoverage.clear(); // reset coverage window; this will also set reference position to 0\n\t\t\tif ( call_somatic) normal_coverage.clear();\n\t\t}\n\t\t\n\t\tif ( read.getAlignmentStart() < coverage.getStart() ) {\n\t\t\t// should never happen\n\t\t\tthrow new StingException(\"Read \"+read.getReadName()+\": out of order on the contig\\n\"+\n\t\t\t\t\t\"Read starts at \"+read.getReferenceName()+\":\"+read.getAlignmentStart()+ \" (cigar=\"+read.getCigarString()+\n\t\t\t\t\t\"); window starts at \"+coverage.getStart());\n\t\t}\n\t\t\n\t\t// a little trick here: we want to make sure that current read completely fits into the current\n\t\t// window so that we can accumulate the coverage/indel counts over the whole length of the read.\n\t\t// The ::getAlignmentEnd() method returns the last position on the reference where bases from the\n\t\t// read actually match (M or D cigar elements). After our cleaning procedure, we can have reads that end\n\t\t// with I element, which is not gonna be counted into alignment length on the reference. On the other hand, \n\t\t// in this program we assign insertions, internally, to the first base *after* the insertion position. \n\t\t// Hence, we have to make sure that that extra base is already in the window or we will get IndexOutOfBounds.\n\t\t\n\t\tlong alignmentEnd = read.getAlignmentEnd();\n\t\tCigar c = read.getCigar();\n\t\tif ( c.getCigarElement(c.numCigarElements()-1).getOperator() == CigarOperator.I) alignmentEnd++;\n\t\t\n\t\tif ( alignmentEnd > coverage.getStop()) {\n\t\t\t\n\t\t\t// we don't emit anything until we reach a read that does not fit into the current window.\n\t\t\t// At that point we shift the window to the start of that read and emit everything prior to \n\t\t\t// that position (reads are sorted, so we are not gonna see any more coverage at those lower positions).\n\t\t\t// Clearly, we assume here that window is large enough to accomodate any single read, so simply shifting\n\t\t\t// the window to the read's start will ensure that the read fits...\n\t\t\t\n\t\t\tif ( call_somatic ) emit_somatic( read.getAlignmentStart() );\n\t\t\telse emit( read.getAlignmentStart() );\n\n\t\t\tif ( read.getAlignmentEnd() > coverage.getStop()) {\n\t\t\t\t// ooops, looks like the read does not fit into the current window!!\n\t\t\t\tthrow new StingException(\"Read \"+read.getReadName()+\": out of coverage window bounds.Probably window is too small.\\n\"+\n\t\t\t\t\t\"Read length=\"+read.getReadLength()+\"; cigar=\"+read.getCigarString()+\"; start=\"+\n\t\t\t\t\tread.getAlignmentStart()+\"; end=\"+read.getAlignmentEnd()+\"; window start=\"+coverage.getStart()+\n\t\t\t\t\t\"; window end=\"+coverage.getStop());\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( call_somatic ) {\n\t\t\t\n\t\t\t// this is a hack. currently we can get access to the merged header only through the read,\n\t\t\t// so below we figure out which of the reassigned read groups in the merged stream are normal\n\t\t\t// and which are tumor, and we make sure we do it only once:\n\t\t\tif ( normal_samples.size() == 0 ) assignReadGroups(read.getHeader()); \n\t\t\t\n\t\t\tString rg = (String)read.getAttribute(\"RG\");\n\t\t\tif ( rg == null ) throw new StingException(\"Read \"+read.getReadName()+\" has no read group in merged stream\");\n\t\t\t\n\t\t\tif ( normal_samples.contains(rg) ) {\n\t\t\t\tnormal_coverage.add(read,ref);\n\t\t\t} else if ( tumor_samples.contains(rg) ) {\n\t\t\t\tcoverage.add(read,ref);\n\t\t\t} else {\n\t\t\t\tthrow new StingException(\"Unrecognized read group in merged stream: \"+rg);\n\t\t\t}\n\t\t} else { \n\t\t\tcoverage.add(read, ref);\n\t\t}\n\t\t\n\t\treturn 1;\n\t}","commit_id":"ca09a10b768ab143bdf3ae6edf6df6aafe06ce56","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Output somatic indel calls up to the specified position and shift the coverage array(s): after this method is executed\n\t * first elements of the coverage arrays map onto 'position'\n\t * \n\t * @param position\n\t */\n\tprivate void emit_somatic(long position) {\n\t\t\n\t\tfor ( long pos = coverage.getStart() ; pos < Math.min(position,coverage.getStop()+1) ; pos++ ) {\n\t\t\t\n\t\t\tList<IndelVariant> tumor_variants = coverage.indelsAt(pos);\n\t\t\tList<IndelVariant> normal_variants = normal_coverage.indelsAt(pos);\n\n\t\t\tif ( tumor_variants.size() == 0 ) continue; // no indels in tumor\n\n\t\t\t\t\t\n\t\t\tint tumor_cov = coverage.coverageAt(pos);\n\t\t\tint normal_cov = normal_coverage.coverageAt(pos);\n\t\t\t\n\t\t\tif ( tumor_cov < minCoverage ) continue; // low coverage\n\t\t\tif ( normal_cov < minNormalCoverage ) continue; // low coverage\n\t\t\t\n\t\t\tint total_variant_count_tumor = 0;\n\t\t\tint max_variant_count_tumor = 0;\n\t\t\tString indelStringTumor = null;\n\t\t\tint event_length_tumor = 0; // length of the event on the reference\n\t\t\t\n\t\t\tfor ( IndelVariant var : tumor_variants ) {\n\t\t\t\tint cnt = var.getCount();\n\t\t\t\ttotal_variant_count_tumor +=cnt;\n\t\t\t\tif ( cnt > max_variant_count_tumor ) {\n\t\t\t\t\tmax_variant_count_tumor = cnt;\n\t\t\t\t\tindelStringTumor = var.getBases();\n\t\t\t\t\tevent_length_tumor = var.lengthOnRef();\n\t\t\t\t}\n\t\t\t}\t\n\t\t\t\n\t\t\tif ( (double)total_variant_count_tumor > minFraction * tumor_cov && (double) max_variant_count_tumor > minConsensusFraction*total_variant_count_tumor ) {\n\t\t\t\t\n\t\t\t\tString message = refName+\"\\t\"+(pos-1)+\"\\t\"+(event_length_tumor > 0 ? pos-1+event_length_tumor : pos-1)+\n\t\t\t\t\t\t\t\"\\t\"+(event_length_tumor >0? \"-\":\"+\")+indelStringTumor +\":\"+total_variant_count_tumor+\"/\"+tumor_cov;\n\t\t\t\tif ( normal_variants.size() == 0 ) { \t\t\n\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\toutput.write(refName+\"\\t\"+(pos-1)+\"\\t\"+(event_length_tumor > 0 ? pos-1+event_length_tumor : pos-1)+\n\t\t\t\t\t\t\t\t\"\\t\"+(event_length_tumor >0? \"-\":\"+\")+indelStringTumor +\":\"+total_variant_count_tumor+\"/\"+tumor_cov+\"\\n\");\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tSystem.out.println(e.getMessage());\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\tthrow new StingException(\"Error encountered while writing into output BED file\");\n\t\t\t\t\t}\n\t\t\t\t\tmessage += \"\\tSOMATIC\";\n\t\t\t\t} else {\n\t\t\t\t\tmessage += \"\\tGERMLINE\";\n\t\t\t\t}\n\t\t\t\tif ( verbose ) System.out.println(message);\n\t\t\t}\n//\t\t\tfor ( IndelVariant var : variants ) {\n//\t\t\t\tSystem.out.print(\"\\t\"+var.getType()+\"\\t\"+var.getBases()+\"\\t\"+var.getCount());\n//\t\t\t}\n\t\t}\n\t\t\n\t\tcoverage.shift((int)(position - coverage.getStart() ) );\n\t\tnormal_coverage.shift((int)(position - normal_coverage.getStart() ) );\n\t}","id":29220,"modified_method":"/** Output somatic indel calls up to the specified position and shift the coverage array(s): after this method is executed\n\t * first elements of the coverage arrays map onto 'position'\n\t * \n\t * @param position\n\t */\n\tprivate void emit_somatic(long position) {\n\t\t\n\t\tfor ( long pos = coverage.getStart() ; pos < Math.min(position,coverage.getStop()+1) ; pos++ ) {\n\t\t\t\n\t\t\t\n\t\t\tList<IndelVariant> tumor_variants = coverage.indelsAt(pos);\n\t\t\tList<IndelVariant> normal_variants = normal_coverage.indelsAt(pos);\n\n\t\t\tif ( tumor_variants.size() == 0 ) continue; // no indels in tumor\n\n\t\t\t\t\t\n\t\t\tint tumor_cov = coverage.coverageAt(pos);\n\t\t\tint normal_cov = normal_coverage.coverageAt(pos);\n\t\t\t\n\t\t\tif ( tumor_cov < minCoverage ) continue; // low coverage\n\t\t\tif ( normal_cov < minNormalCoverage ) continue; // low coverage\n\t\t\t\n\t\t\tlocation.setStart(pos); location.setStop(pos); // retrieve annotation data\n\t\t\trodRefSeq annotation = refseqIterator.seekForward(location);\n\t\t\t\n\n\t\t\tint total_variant_count_tumor = 0;\n\t\t\tint max_variant_count_tumor = 0;\n\t\t\tString indelStringTumor = null;\n\t\t\tint event_length_tumor = 0; // length of the event on the reference\n\t\t\t\n\t\t\tfor ( IndelVariant var : tumor_variants ) {\n\t\t\t\tint cnt = var.getCount();\n\t\t\t\ttotal_variant_count_tumor +=cnt;\n\t\t\t\tif ( cnt > max_variant_count_tumor ) {\n\t\t\t\t\tmax_variant_count_tumor = cnt;\n\t\t\t\t\tindelStringTumor = var.getBases();\n\t\t\t\t\tevent_length_tumor = var.lengthOnRef();\n\t\t\t\t}\n\t\t\t}\t\n\t\t\t\n\t\t\tif ( (double)total_variant_count_tumor > minFraction * tumor_cov && (double) max_variant_count_tumor > minConsensusFraction*total_variant_count_tumor ) {\n\t\t\t\t\n\t\t\t\tString annotationString = null;\n\t\t\t\tif ( annotation == null ) annotationString = \"GENOMIC\";\n\t\t\t\telse {\n\t\t\t\t\tif ( annotation.isExon() ) {\n\t\t\t\t\t\tif ( annotation.isCoding() ) annotationString = \"CODING\";\n\t\t\t\t\t\telse annotationString = \"UTR\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( annotation.isCoding() ) annotationString = \"INTRON\";\n\t\t\t\t\t\telse annotationString = \"UNKNOWN\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tString message = refName+\"\\t\"+(pos-1)+\"\\t\"+(event_length_tumor > 0 ? pos-1+event_length_tumor : pos-1)+\n\t\t\t\t\t\t\t\"\\t\"+(event_length_tumor >0? \"-\":\"+\")+indelStringTumor +\":\"+total_variant_count_tumor+\"/\"+tumor_cov;\n\t\t\t\tif ( normal_variants.size() == 0 ) { \t\t\n\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\toutput.write(message+\"\\n\");\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tSystem.out.println(e.getMessage());\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\tthrow new StingException(\"Error encountered while writing into output BED file\");\n\t\t\t\t\t}\n\t\t\t\t\tmessage += \"\\tSOMATIC\\t\";\n\t\t\t\t} else {\n\t\t\t\t\tmessage += \"\\tGERMLINE\\t\";\n\t\t\t\t}\n\t\t\t\tmessage += annotationString;\n\t\t\t\tif ( verbose ) System.out.println(message);\n\t\t\t}\n//\t\t\tfor ( IndelVariant var : variants ) {\n//\t\t\t\tSystem.out.print(\"\\t\"+var.getType()+\"\\t\"+var.getBases()+\"\\t\"+var.getCount());\n//\t\t\t}\n\t\t}\n\t\t\n\t\tcoverage.shift((int)(position - coverage.getStart() ) );\n\t\tnormal_coverage.shift((int)(position - normal_coverage.getStart() ) );\n\t}","commit_id":"ca09a10b768ab143bdf3ae6edf6df6aafe06ce56","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected int execute() {\n        boolean isPaired = (END > 0);\n\n        BustardFileParser bfp = new BustardFileParser(DIR, LANE, isPaired, \"BS\");\n        BustardReadData bread = bfp.next();\n\n        int cycle_offset = (END <= 1) ? 0 : bread.getIntensities().length/2;\n        BasecallingReadModel p = new BasecallingReadModel(bread.getFirstReadSequence().length());\n        int queryid;\n\n        // learn parameters\n        queryid = 0;\n        do {\n            String bases = (END <= 1) ? bread.getFirstReadSequence() : bread.getSecondReadSequence();\n            byte[] quals = (END <= 1) ? bread.getFirstReadPhredBinaryQualities() : bread.getSecondReadPhredBinaryQualities();\n            double[][] intensities = bread.getIntensities();\n\n            for (int cycle = 0; cycle < bases.length(); cycle++) {\n                char basePrev = (cycle == 0) ? '*' : bases.charAt(cycle - 1);\n                char baseCur  = bases.charAt(cycle);\n                byte qualCur  = quals[cycle];\n                double[] fourintensity = intensities[cycle + cycle_offset];\n\n                p.addTrainingPoint(cycle, basePrev, baseCur, qualCur, fourintensity);\n            }\n\n            queryid++;\n        } while (queryid < TRAINING_LIMIT && bfp.hasNext() && (bread = bfp.next()) != null);\n\n        // call bases\n        SAMFileHeader sfh = new SAMFileHeader();\n        SAMFileWriter sfw = new SAMFileWriterFactory().makeSAMOrBAMWriter(sfh, false, OUT);\n\n        queryid = 0;\n        do {\n            String bases = (END <= 1) ? bread.getFirstReadSequence() : bread.getSecondReadSequence();\n            byte[] quals = (END <= 1) ? bread.getFirstReadPhredBinaryQualities() : bread.getSecondReadPhredBinaryQualities();\n            double[][] intensities = bread.getIntensities();\n\n            byte[] asciiseq = new byte[bases.length()];\n            byte[] bestqual = new byte[bases.length()];\n            byte[] nextbestqual = new byte[bases.length()];\n\n            for (int cycle = 0; cycle < bases.length(); cycle++) {\n                char basePrev = (cycle == 0) ? '*' : bases.charAt(cycle - 1);\n                byte qualPrev = (cycle == 0) ? 0 : quals[cycle - 1];\n                double[] fourintensity = intensities[cycle + cycle_offset];\n\n                FourProb fp = p.computeProbabilities(cycle, basePrev, qualPrev, fourintensity);\n\n                asciiseq[cycle] = (byte) fp.baseAtRank(0);\n                bestqual[cycle] = fp.qualAtRank(0);\n                nextbestqual[cycle] = QualityUtils.qualAndProbToCompressedQuality(fp.indexAtRank(1), fp.probAtRank(1));\n            }\n\n            SAMRecord sr = new SAMRecord(sfh);\n            sr.setReadName(bread.getReadName());\n            sr.setReadUmappedFlag(true);\n            sr.setReadBases(asciiseq);\n            sr.setBaseQualities(bestqual);\n            sr.setAttribute(\"SQ\", nextbestqual);\n            sr.setReadFailsVendorQualityCheckFlag(!bread.isPf());\n            sr.setReadPairedFlag(isPaired);\n            if (isPaired) {\n                sr.setMateUnmappedFlag(true);\n                sr.setFirstOfPairFlag(END <= 1);\n                sr.setSecondOfPairFlag(END > 1);\n            }\n            sfw.addAlignment(sr);\n\n            /*\n            System.out.println(sr.format());\n            System.out.println(sr.getReadString());\n            System.out.println(bases);\n            System.out.println(\"\\n\");\n            */\n\n            queryid++;\n        } while (queryid < CALLING_LIMIT && bfp.hasNext() && (bread = bfp.next()) != null);\n\n        return 0;\n    }","id":29221,"modified_method":"protected int execute() {\n        boolean isPaired = (END > 0);\n\n        BustardFileParser bfp;\n        BustardReadData bread;\n\n        bfp = new BustardFileParser(DIR, LANE, isPaired, \"FB\");\n        bread = bfp.next();\n\n        int cycle_offset = (END <= 1) ? 0 : bread.getIntensities().length/2;\n        BasecallingReadModel p = new BasecallingReadModel(bread.getFirstReadSequence().length());\n        int queryid;\n\n        // learn initial parameters\n        queryid = 0;\n        do {\n            String bases = (END <= 1) ? bread.getFirstReadSequence() : bread.getSecondReadSequence();\n            byte[] quals = (END <= 1) ? bread.getFirstReadPhredBinaryQualities() : bread.getSecondReadPhredBinaryQualities();\n            double[][] intensities = bread.getIntensities();\n\n            for (int cycle = 0; cycle < bases.length(); cycle++) {\n                char basePrev = (cycle == 0) ? '*' : bases.charAt(cycle - 1);\n                char baseCur  = bases.charAt(cycle);\n                byte qualCur  = quals[cycle];\n                double[] fourintensity = intensities[cycle + cycle_offset];\n\n                p.addTrainingPoint(cycle, basePrev, baseCur, qualCur, fourintensity);\n            }\n\n            queryid++;\n        } while (queryid < TRAINING_LIMIT && bfp.hasNext() && (bread = bfp.next()) != null);\n\n        // call bases\n        SAMFileHeader sfh = new SAMFileHeader();\n        SAMFileWriter sfw = new SAMFileWriterFactory().makeSAMOrBAMWriter(sfh, false, OUT);\n        \n        bfp = new BustardFileParser(DIR, LANE, isPaired, \"FB\");\n        bread = bfp.next();\n\n        queryid = 0;\n        do {\n            String bases = (END <= 1) ? bread.getFirstReadSequence() : bread.getSecondReadSequence();\n            byte[] quals = (END <= 1) ? bread.getFirstReadPhredBinaryQualities() : bread.getSecondReadPhredBinaryQualities();\n            double[][] intensities = bread.getIntensities();\n\n            byte[] asciiseq = new byte[bases.length()];\n            byte[] bestqual = new byte[bases.length()];\n            byte[] nextbestqual = new byte[bases.length()];\n\n            for (int cycle = 0; cycle < bases.length(); cycle++) {\n                //char basePrev = (cycle == 0) ? '*' : bases.charAt(cycle - 1);\n                //byte qualPrev = (cycle == 0) ? 0 : quals[cycle - 1];\n                char basePrev = (cycle == 0) ? '*' : (char) asciiseq[cycle - 1];\n                byte qualPrev = (cycle == 0) ? 0 : bestqual[cycle - 1];\n                double[] fourintensity = intensities[cycle + cycle_offset];\n\n                FourProb fp = p.computeProbabilities(cycle, basePrev, qualPrev, fourintensity);\n\n                asciiseq[cycle] = (byte) fp.baseAtRank(0);\n                bestqual[cycle] = fp.qualAtRank(0);\n                nextbestqual[cycle] = QualityUtils.baseAndProbToCompressedQuality(fp.indexAtRank(1), fp.probAtRank(1));\n            }\n\n            SAMRecord sr = new SAMRecord(sfh);\n            sr.setReadName(\"KIR_\" + bread.getReadName());\n            sr.setReadUmappedFlag(true);\n            sr.setReadBases(asciiseq);\n            sr.setBaseQualities(bestqual);\n            sr.setAttribute(\"SQ\", nextbestqual);\n            sr.setReadFailsVendorQualityCheckFlag(!bread.isPf());\n            sr.setReadPairedFlag(isPaired);\n            if (isPaired) {\n                sr.setMateUnmappedFlag(true);\n                sr.setFirstOfPairFlag(END <= 1);\n                sr.setSecondOfPairFlag(END > 1);\n            }\n            sfw.addAlignment(sr);\n\n            SAMRecord sr2 = new SAMRecord(sfh);\n            sr2.setReadName(\"BUS_\" + bread.getReadName());\n            sr2.setReadUmappedFlag(true);\n            sr2.setReadString(bases);\n            sr2.setBaseQualities(quals);\n            sr2.setReadFailsVendorQualityCheckFlag(!bread.isPf());\n            sr2.setReadPairedFlag(isPaired);\n            if (isPaired) {\n                sr2.setMateUnmappedFlag(true);\n                sr2.setFirstOfPairFlag(END <= 1);\n                sr2.setSecondOfPairFlag(END > 1);\n            }\n            sfw.addAlignment(sr2);\n\n            /*\n            System.out.println(sr.format());\n            System.out.println(sr2.format());\n            System.out.println(\"\\n\");\n            */\n            \n            queryid++;\n        } while (queryid < CALLING_LIMIT && bfp.hasNext() && (bread = bfp.next()) != null);\n\n        return 0;\n    }","commit_id":"50199712904adeedbc6c2cd41f372346e0d264a9","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Increments coverage in the currently held window for every position covered by the \n\t\t * specified read; we count the hole span of read getAlignmentStart()-getAlignmentEnd() here,\n\t\t * regardless of whether there are indels in the middle.Read must be completely within the current\n\t\t * window, or an exception will be thrown.\n\t\t * @param r\n\t\t */\n\t\tpublic void add(SAMRecord r, char [] ref) {\n\t\t\tfinal long rStart = r.getAlignmentStart();\n\t\t\tfinal long rStop = r.getAlignmentEnd();\n\n\t        int localStart = (int)( rStart - start ); // start of the alignment wrt start of the current window\n\t\t\t\n\t\t\ttry {\n\t\t\t\tfor ( int k = localStart; k <= (int)(rStop-start) ; k++ ) coverageWindow.increment(k, 1);\n\t\t\t} catch ( IndexOutOfBoundsException e) { // replace the message and re-throw:\n\t\t\t\tthrow new IndexOutOfBoundsException(\"Current coverage window: \"+getStart()+\"-\"+getStop()+\n\t\t\t\t\t\t\"; illegal attempt to add read spanning \"+rStart+\"-\"+rStop);\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// now let's extract indels:\n\t\t\t\n\t\t   \tCigar c = r.getCigar();\n\t    \tfinal int nCigarElems = c.numCigarElements();\n\n\t    \t// if read has no indels, there is nothing to do\n\t        if ( c.numCigarElements() <= 1 ) return ; \n\t    \t\n\t        int posOnRead = 0;\n\t        int posOnRef = 0; // the chunk of reference ref[] that we have access to is aligned with the read:\n\t        \t              // its start on the actual full reference contig is r.getAlignmentStart()\n\t        \n\t        for ( int i = 0 ; i < nCigarElems ; i++ ) {\n\n\t            final CigarElement ce = c.getCigarElement(i);\n\t            IndelVariant.Type type = null;\n\t            String bases = null;\n\t            \n\t            int indelPosition = 0; // indel position in our coverage window (i.e. relative to getStart()).\n\t            \t                   // note that here we assign indels to the first deleted base or to the first\n\t            \t                   // base after insertion\n\t            \n\t            switch(ce.getOperator()) {\n\t            case I:\n\t                    type = IndelVariant.Type.I; \n\t                    bases = r.getReadString().substring(posOnRead,posOnRead+ce.getLength()); \n\t                    indelPosition = localStart + posOnRef ;\n\t                    // will increment position on the read below, there's no 'break' statement yet...\n\t            case H:\n\t            case S:\n\t            \t\t// here we also skip hard and soft-clipped bases on th eread; according to SAM format specification, \n               \t\t\t// alignment start position on the reference points to where the actually aligned \n    \t\t\t\t\t// (not clipped) bases go, so we do not need to increment reference position here\t                    \n\t            \t\tposOnRead += ce.getLength();\n\t                    break;\n\t            case D: \n\t            \t\ttype = IndelVariant.Type.D;\n\t            \t\tbases = new String( ref, posOnRef, ce.getLength() );\n\t                    indelPosition = localStart + posOnRef ;\n\t                    posOnRef += ce.getLength();\n\t                    break;\n\t            case M: \n\t            \t\tposOnRef += ce.getLength(); \n\t            \t\tposOnRead += ce.getLength(); \n\t            \t\tbreak; // advance along the gapless block in the alignment\n\t            default :\n\t                throw new IllegalArgumentException(\"Unexpected operator in cigar string: \"+ce.getOperator());\n\t            }\n\n\t            if ( type == null ) continue; // element was not an indel, go grab next element...\n\t            \n\t            // we got an indel if we are here...\n\t            if ( i == 0 ) System.out.println(\"WARNING: Indel at the start of the read \"+r.getReadName());\n\t            if ( i == nCigarElems - 1) System.out.println(\"WARNING: Indel at the end of the read \"+r.getReadName());\n\n\t            updateCount(indelPosition, type, bases);\n\t        }\n\t            \n\t\t\t\n\t\t}","id":29222,"modified_method":"/** Increments coverage in the currently held window for every position covered by the \n\t\t * specified read; we count the hole span of read getAlignmentStart()-getAlignmentEnd() here,\n\t\t * regardless of whether there are indels in the middle.Read must be completely within the current\n\t\t * window, or an exception will be thrown.\n\t\t * @param r\n\t\t */\n\t\tpublic void add(SAMRecord r, char [] ref) {\n\t\t\tfinal long rStart = r.getAlignmentStart();\n\t\t\tfinal long rStop = r.getAlignmentEnd();\n\n\t        int localStart = (int)( rStart - start ); // start of the alignment wrt start of the current window\n\t\t\t\n\t\t\ttry {\n\t\t\t\tfor ( int k = localStart; k <= (int)(rStop-start) ; k++ ) coverageWindow.increment(k, 1);\n\t\t\t} catch ( IndexOutOfBoundsException e) { // replace the message and re-throw:\n\t\t\t\tthrow new IndexOutOfBoundsException(\"Current coverage window: \"+getStart()+\"-\"+getStop()+\n\t\t\t\t\t\t\"; illegal attempt to add read spanning \"+rStart+\"-\"+rStop);\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// now let's extract indels:\n\t\t\t\n\t\t   \tCigar c = r.getCigar();\n\t    \tfinal int nCigarElems = c.numCigarElements();\n\n\t    \t// if read has no indels, there is nothing to do\n\t        if ( c.numCigarElements() <= 1 ) return ; \n\t    \t\n\t        int posOnRead = 0;\n\t        int posOnRef = 0; // the chunk of reference ref[] that we have access to is aligned with the read:\n\t        \t              // its start on the actual full reference contig is r.getAlignmentStart()\n\t        \n\t        for ( int i = 0 ; i < nCigarElems ; i++ ) {\n\n\t            final CigarElement ce = c.getCigarElement(i);\n\t            IndelVariant.Type type = null;\n\t            String bases = null;\n\t            \n\t            int indelPosition = 0; // indel position in our coverage window (i.e. relative to getStart()).\n\t            \t                   // note that here we assign indels to the first deleted base or to the first\n\t            \t                   // base after insertion\n\t            \n\t            switch(ce.getOperator()) {\n\t            case I:\n\t                    type = IndelVariant.Type.I; \n\t                    bases = r.getReadString().substring(posOnRead,posOnRead+ce.getLength()); \n\t                    indelPosition = localStart + posOnRef ;\n\t                    // will increment position on the read below, there's no 'break' statement yet...\n\t            case H:\n\t            case S:\n\t            \t\t// here we also skip hard and soft-clipped bases on th eread; according to SAM format specification, \n               \t\t\t// alignment start position on the reference points to where the actually aligned \n    \t\t\t\t\t// (not clipped) bases go, so we do not need to increment reference position here\t                    \n\t            \t\tposOnRead += ce.getLength();\n\t                    break;\n\t            case D: \n\t            \t\ttype = IndelVariant.Type.D;\n\t            \t\tbases = new String( ref, posOnRef, ce.getLength() );\n\t                    indelPosition = localStart + posOnRef ;\n\t                    posOnRef += ce.getLength();\n\t                    break;\n\t            case M: \n\t            \t\tposOnRef += ce.getLength(); \n\t            \t\tposOnRead += ce.getLength(); \n\t            \t\tbreak; // advance along the gapless block in the alignment\n\t            default :\n\t                throw new IllegalArgumentException(\"Unexpected operator in cigar string: \"+ce.getOperator());\n\t            }\n\n\t            if ( type == null ) continue; // element was not an indel, go grab next element...\n\t            \n\t            // we got an indel if we are here...\n\t            if ( i == 0 ) logger.warn(\"Indel at the start of the read \"+r.getReadName());\n\t            if ( i == nCigarElems - 1) logger.warn(\"Indel at the end of the read \"+r.getReadName());\n\n\t            updateCount(indelPosition, type, bases);\n\t        }\n\t            \n\t\t\t\n\t\t}","commit_id":"06e5a765f89de523449d064e7b7de3e249d2ea30","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n\tpublic Integer map(char[] ref, SAMRecord read) {\n\t\t\n\t\tif ( read.getReadUnmappedFlag() ||\n\t\t\t read.getDuplicateReadFlag() ||\n\t\t\t read.getNotPrimaryAlignmentFlag() ||\n\t\t\t read.getMappingQuality() == 0 ) return 0; // we do not need those reads!\n\t\t\n\t\tif ( read.getReferenceIndex() != currentContigIndex ) {\n\t\t\t\n\t\t\tif ( read.getReferenceIndex() < currentContigIndex ) // paranoidal \n\t\t\t\tthrow new StingException(\"Read \"+read.getReadName()+\": contig is out of order\");\n\t\t\t\n\t\t\tcurrentContigIndex = read.getReferenceIndex();\n\t\t\tcoverage.clear(); // reset coverage window; this will also set reference position to 0\n\t\t}\n\t\t\n\t\tif ( read.getAlignmentStart() < coverage.getStart() ) {\n\t\t\t// should never happen\n\t\t\tthrow new StingException(\"Read \"+read.getReadName()+\": out of order on the contig\");\n\t\t}\n\t\t\n\t\t// reads are sorted; we are not going to see any more coverage or new indels prior\n\t\t// to current read's start position!\n\t\tfor ( long pos = coverage.getStart() ; pos < Math.min(read.getAlignmentStart(),coverage.getStop()+1) ; pos++ ) {\n\t\t\tList<IndelVariant> variants = coverage.indelsAt(pos);\n\t\t\tif ( variants.size() == 0 ) continue;\n\t\t\tSystem.out.print(read.getReferenceName()+\"\\t\"+pos+\"\\t\"+coverage.coverageAt(pos));\n\t\t\tfor ( IndelVariant var : variants ) {\n\t\t\t\tSystem.out.print(\"\\t\"+var.getType()+\"\\t\"+var.getBases()+\"\\t\"+var.getCount());\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t\tcoverage.shift((int)(read.getAlignmentStart() - coverage.getStart() ) );\n\t\t\n\t\tif ( read.getAlignmentEnd() > coverage.getStop()) {\n\t\t\t// should never happen\n\t\t\tthrow new StingException(\"Read \"+read.getReadName()+\": out of coverage window bounds\");\n\t\t}\n\t\t\n\t\tcoverage.add(read,ref);\n\t\t\n\t\t\n\t\t\n\t\treturn 1;\n\t}","id":29223,"modified_method":"@Override\n\tpublic Integer map(char[] ref, SAMRecord read) {\n\t\t\n\t\tif ( read.getReadUnmappedFlag() ||\n\t\t\t read.getDuplicateReadFlag() ||\n\t\t\t read.getNotPrimaryAlignmentFlag() ||\n\t\t\t read.getMappingQuality() == 0 ) return 0; // we do not need those reads!\n\t\t\n\t\t\n\t\tif ( read.getReferenceIndex() != currentContigIndex ) { \n\t\t\t// we just jumped onto a new contig\n\t\t\t\n\t\t\tif ( read.getReferenceIndex() < currentContigIndex ) // paranoidal \n\t\t\t\tthrow new StingException(\"Read \"+read.getReadName()+\": contig is out of order\");\n\t\t\t\n\t\t\tif ( call_somatic) emit_somatic(1000000000); // print remaining indels from the previous contig (if any);\n\t\t\telse emit(1000000000);\n\t\t\tcurrentContigIndex = read.getReferenceIndex();\n\t\t\trefName = new String(read.getReferenceName());\n\t\t\tcoverage.clear(); // reset coverage window; this will also set reference position to 0\n\t\t\tif ( call_somatic) normal_coverage.clear();\n\t\t}\n\t\t\n\t\tif ( read.getAlignmentStart() < coverage.getStart() ) {\n\t\t\t// should never happen\n\t\t\tthrow new StingException(\"Read \"+read.getReadName()+\": out of order on the contig\");\n\t\t}\n\t\t\n\t\t// reads are sorted; we are not going to see any more coverage or new indels prior\n\t\t// to current read's start position!\n\t\t\n\t\tif ( call_somatic ) emit_somatic( read.getAlignmentStart() );\n\t\telse emit( read.getAlignmentStart() );\n\t\t\n\t\t\n\t\tif ( read.getAlignmentEnd() > coverage.getStop()) {\n\t\t\t// should never happen\n\t\t\tthrow new StingException(\"Read \"+read.getReadName()+\": out of coverage window bounds.\\n\"+\n\t\t\t\t\t\"Read length=\"+read.getReadLength()+\"; cigar=\"+read.getCigarString()+\"; start=\"+\n\t\t\t\t\tread.getAlignmentStart()+\"; end=\"+read.getAlignmentEnd()+\"; window start=\"+coverage.getStart()+\n\t\t\t\t\t\"; window end=\"+coverage.getStop());\n\t\t}\n\t\t\n\t\tif ( call_somatic ) {\n\t\t\tString rg = (String)read.getAttribute(\"RG\");\n\t\t\t\n\t\t\tString sample = read.getHeader().getReadGroup(rg).getSample();\n\t\t\t\n\t\t\tif ( normal_samples.contains(sample) ) {\n\t\t\t\tnormal_coverage.add(read,ref);\n\t\t\t} else if ( tumor_samples.contains(sample) ) {\n\t\t\t\tcoverage.add(read,ref);\n\t\t\t} else {\n\t\t\t\tthrow new StingException(\"Unrecognized sample: \"+sample);\n\t\t\t}\n\t\t} else { \n\t\t\tcoverage.add(read, ref);\n\t\t}\n\t\t\n\t\treturn 1;\n\t}","commit_id":"06e5a765f89de523449d064e7b7de3e249d2ea30","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n\tpublic void initialize() {\n\t\tcoverage = new RunningCoverage(0,100);\n\t}","id":29224,"modified_method":"@Override\n\tpublic void initialize() {\n\t\tcoverage = new RunningCoverage(0,WINDOW_SIZE);\n\t\t\n\t\tint nSams = getToolkit().getArguments().samFiles.size(); \n\t\t\n\t\t\n\t\tif ( call_somatic ) {\n\t\t\tif ( nSams != 2 ) {\n\t\t\t\tSystem.out.println(\"In --somatic mode two input bam files must be specified (normal/tumor)\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t\tnormal_coverage = new RunningCoverage(0,WINDOW_SIZE);\n\t\t\t\n\t\t\t// this is an ugly hack: we want to be able to tell what file (tumor/normal sample) each read came from,\n\t\t\t// but reads do not carry this information!\n\t\t\t\n\t\t\tSAMFileReader rn = new SAMFileReader(getToolkit().getArguments().samFiles.get(0));\n\t\t\tfor ( SAMReadGroupRecord rec : rn.getFileHeader().getReadGroups() ) {\n\t\t\t\tnormal_samples.add(rec.getSample());\n\t\t\t}\n\t\t\trn.close();\n\t\t\trn = new SAMFileReader(getToolkit().getArguments().samFiles.get(1));\n\t\t\tfor ( SAMReadGroupRecord rec : rn.getFileHeader().getReadGroups() ) {\n\t\t\t\ttumor_samples.add(rec.getSample());\n\t\t\t}\n\t\t\trn.close();\n\t\t\t\n\t\t} else {\n\t\t\tif ( nSams != 1 ) System.out.println(\"WARNING: multiple input files specified. \\n\"+\n\t\t\t\t\t\"WARNING: Without --somatic option they will be merged and processed as a single sample\");\n\t\t}\n\t\ttry {\n\t\t\toutput = new java.io.FileWriter(bed_file);\n\t\t} catch (IOException e) {\n\t\t\tthrow new StingException(\"Failed to open file for writing BED output\");\n\t\t}\n\t}","commit_id":"06e5a765f89de523449d064e7b7de3e249d2ea30","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void onTraversalDone(Pair<Long, Long> result) {\n        //Print HLA allele combinations with highest likelihood sums\n        if (!PrintedOutput){\n            out.print(\"\\nDone calculating likelihoods\\n\");\n\n            ArrayList<Integer> TopAlleles = new ArrayList<Integer>();\n\n            double maxA = 0;  int i_maxA =0;   int j_maxA = 0; int maxAphase = 0; double maxAfreq = 0.0;\n            double maxA2 = 0; int i_maxA_2 =0; int j_maxA_2 = 0;\n\n            double maxB = 0;  int i_maxB =0;   int j_maxB = 0; int maxBphase = 0; double maxBfreq = 0.0;\n            double maxB2 = 0; int i_maxB_2 =0; int j_maxB_2 = 0;\n\n            double maxC = 0;  int i_maxC =0;   int j_maxC = 0; int maxCphase = 0; double maxCfreq = 0.0;\n            double maxC2 = 0; int i_maxC_2 =0; int j_maxC_2 = 0;\n\n            \n            out.print(\"Finding allele pair with highest likelihood\\n\");\n            //Find max likelihood scores for each HLA gene.\n            for (int i = 0; i < numHLAlleles; i++){\n                for (int j = i; j < numHLAlleles; j++){\n                    //Print likelihoods for all alleles\n                    if (DEBUG){\n                        out.printf(\"%s\\t%s\\t%5.0f\\n\",HLAnames.get(i),HLAnames.get(j),LOD[i][j]);\n                    }\n                    if (HLAnames.get(i).indexOf(\"HLA_A\") > -1 && HLAnames.get(j).indexOf(\"HLA_A\") > -1){\n                        if (LOD[i][j] > maxA){\n                            maxA2 = maxA; i_maxA_2 = i_maxA; j_maxA_2 = j_maxA;\n                            maxA = LOD[i][j]; i_maxA = i; j_maxA = j;\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_B\") > -1 && HLAnames.get(j).indexOf(\"HLA_B\") > -1){\n                        if (LOD[i][j] > maxB){\n                            maxB2 = maxB; i_maxB_2 = i_maxB; j_maxB_2 = j_maxB;\n                            maxB = LOD[i][j]; i_maxB = i; j_maxB = j;\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_C\") > -1 && HLAnames.get(j).indexOf(\"HLA_C\") > -1){\n                        if (LOD[i][j] > maxC){\n                            maxC2 = maxC; i_maxC_2 = i_maxC; j_maxC_2 = j_maxC;\n                            maxC = LOD[i][j]; i_maxC = i; j_maxC = j;\n                        }\n                    }\n\t\t}\n            }\n\n            //Record alleles in highest likelihood combinations\n            for (Integer i = 0; i < numHLAlleles; i++){\n                for (Integer j = i; j < numHLAlleles; j++){\n                    if (HLAnames.get(i).indexOf(\"HLA_A\") > -1 && HLAnames.get(j).indexOf(\"HLA_A\") > -1){\n                        if (LOD[i][j] == maxA && maxA > 0){\n                            if (!TopAlleles.contains(i)){TopAlleles.add(i);}\n                            if (!TopAlleles.contains(j)){TopAlleles.add(j);}\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_B\") > -1 && HLAnames.get(j).indexOf(\"HLA_B\") > -1){\n                        if (LOD[i][j] == maxB && maxB > 0){\n                            if (!TopAlleles.contains(i)){TopAlleles.add(i);}\n                            if (!TopAlleles.contains(j)){TopAlleles.add(j);}\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_C\") > -1 && HLAnames.get(j).indexOf(\"HLA_C\") > -1){\n                        if (LOD[i][j] == maxC && maxC > 0){\n                            if (!TopAlleles.contains(i)){TopAlleles.add(i);}\n                            if (!TopAlleles.contains(j)){TopAlleles.add(j);}\n                        }\n                    }\n\n                }\n            }\n\n            out.printf(\"\\nCalculating SNP correlation matrix for %s SNPs\\n\",SNPcount);\n            SNPcorrelation = new int[SNPs.size()*5][SNPs.size()*5];\n\n            \n            //Create correlation matrix and update correlation scores for all reads\n            for (int i = 0; i < AllReads.size(); i++){\n                if (i == 2045){\n                    UpdateCorrelation(AllReads.get(i), false);\n                }else{\n                    UpdateCorrelation(AllReads.get(i), false);\n                }\n                //out.printf(\"[%s,%s]\\n\", ((Integer) SNPs.get(\"31431982\")) * 4,((Integer) SNPs.get(\"31432003\")) * 4 );\n                //out.printf(\"%s\\t[%s,%s]\\t31431982[A] 31432003[A]\\t%s\\n\",i,((Integer) SNPs.get(\"31431982\")) * 4,((Integer) SNPs.get(\"31432003\")) * 4 , SNPcorrelation[((Integer) SNPs.get(\"31431982\")) * 4][((Integer) SNPs.get(\"31432003\")) * 4]);\n            }\n\n            Hashtable indexer = new Hashtable();\n            indexer.put('A', (Integer) 0);\n            indexer.put('C', (Integer) 1);\n            indexer.put('G', (Integer) 2);\n            indexer.put('T', (Integer) 3);\n            indexer.put('D', (Integer) 4); // D for deletion\n            char[] bases = {'A','C','G','T','D'};\n\n            if ( false ){\n                //prints entries in the correlation matrix that are > 0\n                out.print(\"\\n\");\n                for (int i = 0; i < SNPs.size(); i++){\n                    int loc1 = SNPlocations.get(i);\n                    for (int j = i ; j < SNPs.size(); j++){\n                        int loc2 = SNPlocations.get(j);\n                        for (char c1 : bases){\n                            for (char c2 : bases){\n                                int a = i*5 + (Integer) indexer.get(c1);\n                                int b = j*5 + (Integer) indexer.get(c2);\n                                if (SNPcorrelation[a][b] > 0){\n                                    out.printf(\"[i,j]=[%s,%s]\\t[a,b]=[%s,%s]\\tPOS:%s[%s],%s[%s]\\tCorr=%s\\n\",i,j,a,b,loc1,c1,loc2,c2,SNPcorrelation[a][b]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n\n            int k, readstart, readstop, allelestart, allelestop, pos_k;\n            out.printf(\"Calculating phase scores for %s top alleles\\n\",TopAlleles.size());\n\n            //Calculate Phase score for each allele\n            int[] SinglePhaseScores = new int[TopAlleles.size()];\n            for (int i = 0; i < TopAlleles.size(); i++){\n                SinglePhaseScores[i] = GetPhaseScore(TopAlleles.get(i));\n                if ( DEBUG ){\n                    //Debugging: print list of alleles to be checked for phasing\n                    out.printf(\"index=%s\\t%s\\tscore=%s\\n\",TopAlleles.get(i),HLAnames.get(TopAlleles.get(i)),SinglePhaseScores[i]);\n                }\n            }\n\n            out.print(\"Calculating phasing score for pairs of alleles\\n\");\n            //Calculate phasing score and population frequencies for pairs of alleles, and find pairs with the highest scores\n            String alleleA, alleleB;\n            Double freq1 = 0.0, freq2 = 0.0;\n            for (Integer i = 0; i < numHLAlleles; i++){\n                for (Integer j = i; j < numHLAlleles; j++){\n                    if (HLAnames.get(i).indexOf(\"HLA_A\") > -1 && HLAnames.get(j).indexOf(\"HLA_A\") > -1){\n                        if (LOD[i][j] == maxA && maxA > 0){\n                            PhasingScores[i][j]= SinglePhaseScores[TopAlleles.indexOf(i)] + SinglePhaseScores[TopAlleles.indexOf(j)];\n                            if (PhasingScores[i][j] > maxAphase){maxAphase = PhasingScores[i][j];}\n                            alleleA=HLAnames.get(i).substring(4); if (AlleleFrequencies.containsKey(alleleA)){freq1 = Double.parseDouble((String) AlleleFrequencies.get(alleleA).toString());}else{freq1=0.0001;}\n                            alleleB=HLAnames.get(j).substring(4); if (AlleleFrequencies.containsKey(alleleB)){freq2 = Double.parseDouble((String) AlleleFrequencies.get(alleleB).toString());}else{freq2=0.0001;}\n                            SingleAlleleFrequencies[i]=freq1; SingleAlleleFrequencies[j]=freq2; CombinedAlleleFrequencies[i][j]=freq1*freq2;\n                            if (CombinedAlleleFrequencies[i][j] > maxAfreq){maxAfreq = CombinedAlleleFrequencies[i][j];}\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_B\") > -1 && HLAnames.get(j).indexOf(\"HLA_B\") > -1){\n                        if (LOD[i][j] == maxB && maxB > 0){\n                            PhasingScores[i][j]= SinglePhaseScores[TopAlleles.indexOf(i)] + SinglePhaseScores[TopAlleles.indexOf(j)];\n                            if (PhasingScores[i][j] > maxBphase){maxBphase = PhasingScores[i][j];}\n                            alleleA=HLAnames.get(i).substring(4); if (AlleleFrequencies.containsKey(alleleA)){freq1 = Double.parseDouble((String) AlleleFrequencies.get(alleleA).toString());}else{freq1=0.0001;}\n                            alleleB=HLAnames.get(j).substring(4); if (AlleleFrequencies.containsKey(alleleB)){freq2 = Double.parseDouble((String) AlleleFrequencies.get(alleleB).toString());}else{freq2=0.0001;}\n                            SingleAlleleFrequencies[i]=freq1; SingleAlleleFrequencies[j]=freq2; CombinedAlleleFrequencies[i][j]=freq1*freq2;\n                            if (freq1*freq2 > maxBfreq){maxBfreq = freq1*freq2;}\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_C\") > -1 && HLAnames.get(j).indexOf(\"HLA_C\") > -1){\n                        if (LOD[i][j] == maxC && maxC > 0){\n                            PhasingScores[i][j]= SinglePhaseScores[TopAlleles.indexOf(i)] + SinglePhaseScores[TopAlleles.indexOf(j)];\n                            if (PhasingScores[i][j] > maxCphase){maxCphase = PhasingScores[i][j];}\n                            alleleA=HLAnames.get(i).substring(4); if (AlleleFrequencies.containsKey(alleleA)){freq1 = Double.parseDouble((String) AlleleFrequencies.get(alleleA).toString());}else{freq1=0.0001;}\n                            alleleB=HLAnames.get(j).substring(4); if (AlleleFrequencies.containsKey(alleleB)){freq2 = Double.parseDouble((String) AlleleFrequencies.get(alleleB).toString());}else{freq2=0.0001;}\n                            SingleAlleleFrequencies[i]=freq1; SingleAlleleFrequencies[j]=freq2; CombinedAlleleFrequencies[i][j]=freq1*freq2;\n                            if (freq1*freq2 > maxCfreq){maxCfreq = freq1*freq2;}\n                        }\n                    }\n                }\n            }\n\n            //Print allele pairs with highest likelihood score and highest phasing score\n            for (Integer i = 0; i < numHLAlleles; i++){\n                for (Integer j = i; j < numHLAlleles; j++){\n                    if (HLAnames.get(i).indexOf(\"HLA_A\") > -1 && HLAnames.get(j).indexOf(\"HLA_A\") > -1){\n                        if (LOD[i][j] == maxA && maxA > 0 && PhasingScores[i][j] == maxAphase && CombinedAlleleFrequencies[i][j] == maxAfreq){\n                            out.printf(\"%s\\t%s\\tLOD=%5.0f\\tCONF=%5.0f\\tPhase=%s\\tfreq1=%s\\tfreq2=%s\\tCombined_Freq=%.6f\\tBEST\\n\",HLAnames.get(i),HLAnames.get(j),maxA,maxA-maxA2,PhasingScores[i][j],SingleAlleleFrequencies[i],SingleAlleleFrequencies[j],CombinedAlleleFrequencies[i][j]);\n                        }else if(LOD[i][j] == maxA && maxA > 0 && PhasingScores[i][j] == maxAphase){\n                            out.printf(\"%s\\t%s\\tLOD=%5.0f\\tCONF=%5.0f\\tPhase=%s\\tfreq1=%s\\tfreq2=%s\\tCombined_Freq=%.6f\\n\",HLAnames.get(i),HLAnames.get(j),maxA,maxA-maxA2,PhasingScores[i][j],SingleAlleleFrequencies[i],SingleAlleleFrequencies[j],CombinedAlleleFrequencies[i][j]);\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_B\") > -1 && HLAnames.get(j).indexOf(\"HLA_B\") > -1){\n                        if (LOD[i][j] == maxB && maxB > 0 && PhasingScores[i][j] == maxBphase && CombinedAlleleFrequencies[i][j] == maxBfreq){\n                            out.printf(\"%s\\t%s\\tLOD=%5.0f\\tCONF=%5.0f\\tPhase=%s\\tfreq1=%s\\tfreq2=%s\\tCombined_Freq=%.6f\\tBEST\\n\",HLAnames.get(i),HLAnames.get(j),maxB,maxB-maxB2,PhasingScores[i][j],SingleAlleleFrequencies[i],SingleAlleleFrequencies[j],CombinedAlleleFrequencies[i][j]);\n                        }else if(LOD[i][j] == maxB && maxB > 0 && PhasingScores[i][j] == maxBphase){\n                            out.printf(\"%s\\t%s\\tLOD=%5.0f\\tCONF=%5.0f\\tPhase=%s\\tfreq1=%s\\tfreq2=%s\\tCombined_Freq=%.6f\\n\",HLAnames.get(i),HLAnames.get(j),maxB,maxB-maxB2,PhasingScores[i][j],SingleAlleleFrequencies[i],SingleAlleleFrequencies[j],CombinedAlleleFrequencies[i][j]);\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_C\") > -1 && HLAnames.get(j).indexOf(\"HLA_C\") > -1){\n                        if (LOD[i][j] == maxC && maxC > 0 && PhasingScores[i][j] == maxCphase && CombinedAlleleFrequencies[i][j] == maxCfreq){\n                            out.printf(\"%s\\t%s\\tLOD=%5.0f\\tCONF=%5.0f\\tPhase=%s\\tfreq1=%s\\tfreq2=%s\\tCombined_Freq=%.6f\\tBEST\\n\",HLAnames.get(i),HLAnames.get(j),maxC,maxC-maxC2,PhasingScores[i][j],SingleAlleleFrequencies[i],SingleAlleleFrequencies[j],CombinedAlleleFrequencies[i][j]);\n                        }else if (LOD[i][j] == maxC && maxC > 0 && PhasingScores[i][j] == maxCphase){\n                            out.printf(\"%s\\t%s\\tLOD=%5.0f\\tCONF=%5.0f\\tPhase=%s\\tfreq1=%s\\tfreq2=%s\\tCombined_Freq=%.6f\\n\",HLAnames.get(i),HLAnames.get(j),maxC,maxC-maxC2,PhasingScores[i][j],SingleAlleleFrequencies[i],SingleAlleleFrequencies[j],CombinedAlleleFrequencies[i][j]);\n                        }\n                    }\n                }\n            }\n\n            //2nd Highest likelihoods\n            for (int i = 0; i < numHLAlleles; i++){\n                for (int j = i; j < numHLAlleles; j++){\n                    if (LOD[i][j] == maxA2){\n                        //out.printf(\"2nd Highest likelihood: %5.0f in %s and %s; i=%s, j=%s\\n\",maxA2,HLAnames.get(i),HLAnames.get(j),i,j);\n                    }\n                }\n            }\n\n            PrintedOutput = true;\n            //out.printf(\"Average depth of coverage is: %.2f in %d total coverage over %d sites\\n\",((double)result.getFirst() / (double)result.getSecond()), result.getFirst(), result.getSecond());\n        }\n    }","id":29225,"modified_method":"public void onTraversalDone(Pair<Long, Long> result) {\n        //Print HLA allele combinations with highest likelihood sums\n        if (!PrintedOutput){\n            out.print(\"\\nDone calculating likelihoods\\n\");\n\n            ArrayList<Integer> TopAlleles = new ArrayList<Integer>();\n\n            double maxA = 0;  int i_maxA =0;   int j_maxA = 0; int maxAphase = 0; double maxAfreq = 0.0; double maxlikelihoodA = 0.0;\n            double maxA2 = 0; int i_maxA_2 =0; int j_maxA_2 = 0;\n\n            double maxB = 0;  int i_maxB =0;   int j_maxB = 0; int maxBphase = 0; double maxBfreq = 0.0; double maxlikelihoodB = 0.0;\n            double maxB2 = 0; int i_maxB_2 =0; int j_maxB_2 = 0;\n\n            double maxC = 0;  int i_maxC =0;   int j_maxC = 0; int maxCphase = 0; double maxCfreq = 0.0; double maxlikelihoodC = 0.0;\n            double maxC2 = 0; int i_maxC_2 =0; int j_maxC_2 = 0;\n\n            \n            out.print(\"Finding allele pair with highest likelihood\\n\");\n            //Find the maximum likelihood scores for each HLA gene,\n            for (int i = 0; i < numHLAlleles; i++){\n                for (int j = i; j < numHLAlleles; j++){\n                    //Print likelihoods for all alleles\n                    if (DEBUG){}//out.printf(\"%s\\t%s\\t%5.0f\\n\",HLAnames.get(i),HLAnames.get(j),LOD[i][j]);}\n                    if (HLAnames.get(i).indexOf(\"HLA_A\") > -1 && HLAnames.get(j).indexOf(\"HLA_A\") > -1){\n                        if (LOD[i][j] > maxA){\n                            maxA2 = maxA; i_maxA_2 = i_maxA; j_maxA_2 = j_maxA;\n                            maxA = LOD[i][j]; i_maxA = i; j_maxA = j; maxlikelihoodA = LikelihoodScores[i][j];\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_B\") > -1 && HLAnames.get(j).indexOf(\"HLA_B\") > -1){\n                        if (LOD[i][j] > maxB){\n                            maxB2 = maxB; i_maxB_2 = i_maxB; j_maxB_2 = j_maxB;\n                            maxB = LOD[i][j]; i_maxB = i; j_maxB = j; maxlikelihoodB = LikelihoodScores[i][j];\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_C\") > -1 && HLAnames.get(j).indexOf(\"HLA_C\") > -1){\n                        if (LOD[i][j] > maxC){\n                            maxC2 = maxC; i_maxC_2 = i_maxC; j_maxC_2 = j_maxC;\n                            maxC = LOD[i][j]; i_maxC = i; j_maxC = j; maxlikelihoodC = LikelihoodScores[i][j];\n                        }\n                    }\n\t\t}\n            }\n\n\n            //Record alleles with the highest likelihood combinations, sum likelihoods (within 5 orders of magnitide of best score) to calculate posterior probabilities for each allele combination\n            for (Integer i = 0; i < numHLAlleles; i++){\n                for (Integer j = i; j < numHLAlleles; j++){\n                    if (HLAnames.get(i).indexOf(\"HLA_A\") > -1 && HLAnames.get(j).indexOf(\"HLA_A\") > -1 && maxA > 0){\n                        if (maxA - LOD[i][j] <= 5 && maxA - LOD[i][j] >= 0){\n                            inverseMaxProbA = inverseMaxProbA + java.lang.Math.pow(10,LikelihoodScores[i][j]-maxlikelihoodA);\n                            if (DEBUG){\n                                out.printf(\"HLA-A: likelihood=%.5f\\tmaxlikelihood=%.5f\\tdelta_likelihood=%.5f\\tinvP=%.5f\\n\",LikelihoodScores[i][j],maxlikelihoodA,LikelihoodScores[i][j]-maxlikelihoodA,inverseMaxProbA);\n                            }\n                        }\n                        if (LOD[i][j] == maxA){\n                            if (!TopAlleles.contains(i)){TopAlleles.add(i);}\n                            if (!TopAlleles.contains(j)){TopAlleles.add(j);}\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_B\") > -1 && HLAnames.get(j).indexOf(\"HLA_B\") > -1 && maxB > 0){\n                        if (maxB - LOD[i][j] <= 5 && maxB - LOD[i][j] >= 0){\n                            inverseMaxProbB = inverseMaxProbB + java.lang.Math.pow(10,LikelihoodScores[i][j]-maxlikelihoodB);\n                            if (DEBUG){\n                                out.printf(\"HLA-B: likelihood=%.5f\\tmaxlikelihood=%.5f\\tdelta_likelihood=%.5f\\tinvP=%.5f\\n\",LikelihoodScores[i][j],maxlikelihoodB,LikelihoodScores[i][j]-maxlikelihoodA,inverseMaxProbB);\n                            }\n                        }\n                        if (LOD[i][j] == maxB){\n                            if (!TopAlleles.contains(i)){TopAlleles.add(i);}\n                            if (!TopAlleles.contains(j)){TopAlleles.add(j);}\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_C\") > -1 && HLAnames.get(j).indexOf(\"HLA_C\") > -1 && maxC > 0){\n                        if (maxC - LOD[i][j] <= 5 && maxC - LOD[i][j] >= 0){\n                            inverseMaxProbC = inverseMaxProbC + java.lang.Math.pow(10,LikelihoodScores[i][j]-maxlikelihoodC);\n                            if (DEBUG){\n                                out.printf(\"HLA-C: likelihood=%.5f\\tmaxlikelihood=%.5f\\tdelta_likelihood=%.5f\\tinvP=%.5f\\n\",LikelihoodScores[i][j],maxlikelihoodC,LikelihoodScores[i][j]-maxlikelihoodA,inverseMaxProbC);\n                            }\n                        }\n                        if (LOD[i][j] == maxC){\n                            if (!TopAlleles.contains(i)){TopAlleles.add(i);}\n                            if (!TopAlleles.contains(j)){TopAlleles.add(j);}\n                        }\n                    }\n                }\n            }\n\n            out.printf(\"\\nCalculating SNP correlation matrix for %s SNPs\\n\",SNPcount);\n            SNPcorrelation = new int[SNPs.size()*5][SNPs.size()*5];\n\n            \n            //Create correlation matrix and update correlation scores for all reads\n            for (int i = 0; i < AllReads.size(); i++){\n                if (i == 2045){\n                    UpdateCorrelation(AllReads.get(i), false);\n                }else{\n                    UpdateCorrelation(AllReads.get(i), false);\n                }\n                //out.printf(\"[%s,%s]\\n\", ((Integer) SNPs.get(\"31431982\")) * 4,((Integer) SNPs.get(\"31432003\")) * 4 );\n                //out.printf(\"%s\\t[%s,%s]\\t31431982[A] 31432003[A]\\t%s\\n\",i,((Integer) SNPs.get(\"31431982\")) * 4,((Integer) SNPs.get(\"31432003\")) * 4 , SNPcorrelation[((Integer) SNPs.get(\"31431982\")) * 4][((Integer) SNPs.get(\"31432003\")) * 4]);\n            }\n\n            Hashtable indexer = new Hashtable();\n            indexer.put('A', (Integer) 0);\n            indexer.put('C', (Integer) 1);\n            indexer.put('G', (Integer) 2);\n            indexer.put('T', (Integer) 3);\n            indexer.put('D', (Integer) 4); // D for deletion\n            char[] bases = {'A','C','G','T','D'};\n\n            if ( false ){\n                //prints entries in the correlation matrix that are > 0\n                out.print(\"\\n\");\n                for (int i = 0; i < SNPs.size(); i++){\n                    int loc1 = SNPlocations.get(i);\n                    for (int j = i ; j < SNPs.size(); j++){\n                        int loc2 = SNPlocations.get(j);\n                        for (char c1 : bases){\n                            for (char c2 : bases){\n                                int a = i*5 + (Integer) indexer.get(c1);\n                                int b = j*5 + (Integer) indexer.get(c2);\n                                if (SNPcorrelation[a][b] > 0){\n                                    out.printf(\"[i,j]=[%s,%s]\\t[a,b]=[%s,%s]\\tPOS:%s[%s],%s[%s]\\tCorr=%s\\n\",i,j,a,b,loc1,c1,loc2,c2,SNPcorrelation[a][b]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n\n            int k, readstart, readstop, allelestart, allelestop, pos_k;\n            out.printf(\"Calculating phase scores for %s top alleles\\n\",TopAlleles.size());\n\n            //Calculate Phase score for each allele\n            int[] SinglePhaseScores = new int[TopAlleles.size()];\n            for (int i = 0; i < TopAlleles.size(); i++){\n                SinglePhaseScores[i] = GetPhaseScore(TopAlleles.get(i));\n                if ( DEBUG ){\n                    //Debugging: print list of alleles to be checked for phasing\n                    out.printf(\"index=%s\\t%s\\tscore=%s\\n\",TopAlleles.get(i),HLAnames.get(TopAlleles.get(i)),SinglePhaseScores[i]);\n                }\n            }\n\n            out.print(\"Calculating phasing score for pairs of alleles\\n\");\n            //Calculate phasing score and population frequencies for pairs of alleles, and find pairs with the highest scores, and sum combined probabilities\n            String alleleA, alleleB;\n            Double freq1 = 0.0, freq2 = 0.0;\n            Double ProbSumA = 0.0, ProbSumB = 0.0, ProbSumC = 0.0, likelihoodPrior;\n            for (Integer i = 0; i < numHLAlleles; i++){\n                for (Integer j = i; j < numHLAlleles; j++){\n                    if (HLAnames.get(i).indexOf(\"HLA_A\") > -1 && HLAnames.get(j).indexOf(\"HLA_A\") > -1){\n                        if (LOD[i][j] == maxA && maxA > 0){\n                            PhasingScores[i][j]= SinglePhaseScores[TopAlleles.indexOf(i)] + SinglePhaseScores[TopAlleles.indexOf(j)];\n                            if (PhasingScores[i][j] > maxAphase){maxAphase = PhasingScores[i][j];}\n                            alleleA=HLAnames.get(i).substring(4); if (AlleleFrequencies.containsKey(alleleA)){freq1 = Double.parseDouble((String) AlleleFrequencies.get(alleleA).toString());}else{freq1=0.0001;}\n                            alleleB=HLAnames.get(j).substring(4); if (AlleleFrequencies.containsKey(alleleB)){freq2 = Double.parseDouble((String) AlleleFrequencies.get(alleleB).toString());}else{freq2=0.0001;}\n                            SingleAlleleFrequencies[i]=freq1; SingleAlleleFrequencies[j]=freq2; CombinedAlleleFrequencies[i][j]=freq1*freq2;\n                            if (CombinedAlleleFrequencies[i][j] > maxAfreq){maxAfreq = CombinedAlleleFrequencies[i][j];}\n                            likelihoodPrior = java.lang.Math.pow(10,LikelihoodScores[i][j]-maxlikelihoodA)/inverseMaxProbA;\n                            ProbSumA = ProbSumA + likelihoodPrior*CombinedAlleleFrequencies[i][j];\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_B\") > -1 && HLAnames.get(j).indexOf(\"HLA_B\") > -1){\n                        if (LOD[i][j] == maxB && maxB > 0){\n                            PhasingScores[i][j]= SinglePhaseScores[TopAlleles.indexOf(i)] + SinglePhaseScores[TopAlleles.indexOf(j)];\n                            if (PhasingScores[i][j] > maxBphase){maxBphase = PhasingScores[i][j];}\n                            alleleA=HLAnames.get(i).substring(4); if (AlleleFrequencies.containsKey(alleleA)){freq1 = Double.parseDouble((String) AlleleFrequencies.get(alleleA).toString());}else{freq1=0.0001;}\n                            alleleB=HLAnames.get(j).substring(4); if (AlleleFrequencies.containsKey(alleleB)){freq2 = Double.parseDouble((String) AlleleFrequencies.get(alleleB).toString());}else{freq2=0.0001;}\n                            SingleAlleleFrequencies[i]=freq1; SingleAlleleFrequencies[j]=freq2; CombinedAlleleFrequencies[i][j]=freq1*freq2;\n                            if (freq1*freq2 > maxBfreq){maxBfreq = freq1*freq2;}\n                            likelihoodPrior = java.lang.Math.pow(10,LikelihoodScores[i][j]-maxlikelihoodB)/inverseMaxProbB;\n                            ProbSumB = ProbSumB + likelihoodPrior*CombinedAlleleFrequencies[i][j];\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_C\") > -1 && HLAnames.get(j).indexOf(\"HLA_C\") > -1){\n                        if (LOD[i][j] == maxC && maxC > 0){\n                            PhasingScores[i][j]= SinglePhaseScores[TopAlleles.indexOf(i)] + SinglePhaseScores[TopAlleles.indexOf(j)];\n                            if (PhasingScores[i][j] > maxCphase){maxCphase = PhasingScores[i][j];}\n                            alleleA=HLAnames.get(i).substring(4); if (AlleleFrequencies.containsKey(alleleA)){freq1 = Double.parseDouble((String) AlleleFrequencies.get(alleleA).toString());}else{freq1=0.0001;}\n                            alleleB=HLAnames.get(j).substring(4); if (AlleleFrequencies.containsKey(alleleB)){freq2 = Double.parseDouble((String) AlleleFrequencies.get(alleleB).toString());}else{freq2=0.0001;}\n                            SingleAlleleFrequencies[i]=freq1; SingleAlleleFrequencies[j]=freq2; CombinedAlleleFrequencies[i][j]=freq1*freq2;\n                            if (freq1*freq2 > maxCfreq){maxCfreq = freq1*freq2;}\n                            likelihoodPrior = java.lang.Math.pow(10,LikelihoodScores[i][j]-maxlikelihoodC)/inverseMaxProbC;\n                            ProbSumC = ProbSumC + likelihoodPrior*CombinedAlleleFrequencies[i][j];\n                        }\n                    }\n                }\n            }\n\n            //Print allele pairs with highest likelihood score and highest phasing score\n            \n            for (Integer i = 0; i < numHLAlleles; i++){\n                for (Integer j = i; j < numHLAlleles; j++){\n                    if (HLAnames.get(i).indexOf(\"HLA_A\") > -1 && HLAnames.get(j).indexOf(\"HLA_A\") > -1){\n                        if(LOD[i][j] == maxA && maxA > 0 && PhasingScores[i][j] == maxAphase){\n                            likelihoodPrior = java.lang.Math.pow(10,LikelihoodScores[i][j]-maxlikelihoodA)/inverseMaxProbA;\n                            out.printf(\"%s\\t%s\\tloglikelihood=%5.0f\\tmax=%5.0f\\tinvP=%.2f\\tPrior=%.3f\\tPhase=%s\\tfreq1=%s\\tfreq2=%s\\tf1*f2=%.8f\\tProb=%.3f\",HLAnames.get(i),HLAnames.get(j),LikelihoodScores[i][j],maxlikelihoodA,inverseMaxProbA,likelihoodPrior,PhasingScores[i][j],SingleAlleleFrequencies[i],SingleAlleleFrequencies[j],CombinedAlleleFrequencies[i][j],likelihoodPrior*CombinedAlleleFrequencies[i][j]/ProbSumA);\n                            if (CombinedAlleleFrequencies[i][j] == maxAfreq){out.printf(\"\\tBEST\");}\n                            out.printf(\"\\n\");\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_B\") > -1 && HLAnames.get(j).indexOf(\"HLA_B\") > -1){\n                        if(LOD[i][j] == maxB && maxB > 0 && PhasingScores[i][j] == maxBphase){\n                            likelihoodPrior = java.lang.Math.pow(10,LikelihoodScores[i][j]-maxlikelihoodB)/inverseMaxProbB;\n                            out.printf(\"%s\\t%s\\tloglikelihood=%5.0f\\tmax=%5.0f\\tinvP=%.2f\\tPrior=%.3f\\tPhase=%s\\tfreq1=%s\\tfreq2=%s\\tf1*f2=%.8f\\tProb=%.3f\",HLAnames.get(i),HLAnames.get(j),LikelihoodScores[i][j],maxlikelihoodB,inverseMaxProbB,likelihoodPrior,PhasingScores[i][j],SingleAlleleFrequencies[i],SingleAlleleFrequencies[j],CombinedAlleleFrequencies[i][j],likelihoodPrior*CombinedAlleleFrequencies[i][j]/ProbSumB);\n                            if (CombinedAlleleFrequencies[i][j] == maxBfreq){out.printf(\"\\tBEST\");}\n                            out.printf(\"\\n\");\n                        }\n                    } else if (HLAnames.get(i).indexOf(\"HLA_C\") > -1 && HLAnames.get(j).indexOf(\"HLA_C\") > -1){\n                        if(LOD[i][j] == maxC && maxC > 0 && PhasingScores[i][j] == maxCphase){\n                            likelihoodPrior = java.lang.Math.pow(10,LikelihoodScores[i][j]-maxlikelihoodC)/inverseMaxProbC;\n                            out.printf(\"%s\\t%s\\tloglikelihood=%5.0f\\tmax=%5.0f\\tinvP=%.2f\\tPrior=%.3f\\tPhase=%s\\tfreq1=%s\\tfreq2=%s\\tf1*f2=%.8f\\tProb=%.3f\",HLAnames.get(i),HLAnames.get(j),LikelihoodScores[i][j],maxlikelihoodC,inverseMaxProbC,likelihoodPrior,PhasingScores[i][j],SingleAlleleFrequencies[i],SingleAlleleFrequencies[j],CombinedAlleleFrequencies[i][j],likelihoodPrior*CombinedAlleleFrequencies[i][j]/ProbSumC);\n                            if (CombinedAlleleFrequencies[i][j] == maxCfreq){out.printf(\"\\tBEST\");}\n                            out.printf(\"\\n\");\n                        }\n                    }\n                }\n            }\n\n            //2nd Highest likelihoods\n            for (int i = 0; i < numHLAlleles; i++){\n                for (int j = i; j < numHLAlleles; j++){\n                    if (LOD[i][j] == maxA2){\n                        //out.printf(\"2nd Highest likelihood: %5.0f in %s and %s; i=%s, j=%s\\n\",maxA2,HLAnames.get(i),HLAnames.get(j),i,j);\n                    }\n                }\n            }\n\n            PrintedOutput = true;\n            //out.printf(\"Average depth of coverage is: %.2f in %d total coverage over %d sites\\n\",((double)result.getFirst() / (double)result.getSecond()), result.getFirst(), result.getSecond());\n        }\n    }","commit_id":"83e6e5a3e4208392d49dd38cba49386a453177df","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        \n        List<SAMRecord> reads = context.getReads();\n\n        List<Integer> offsets = context.getOffsets();\n        GenomeLoc Gloc = context.getLocation();\n\n        //Create pileup of reads at this locus\n        ReadBackedPileup pileup = new ReadBackedPileup(ref.getBase(), context);\n\n        long loc = context.getPosition();\n\n        if( context.getReads().size() > 0 ) {\n            //out.printf(\"RG for first read: %s%n\",context.getReads().get(0).getReadName());\n            int numAs = 0;\n            int numCs = 0;\n            int numGs = 0;\n            int numTs = 0;\n            int depth = 0;\n            String c1 = \"\"; String c2 = \"\";\n            long pos_k = 0; long pos_j = 0;\n            \n            //Debugging purposes: print location, reference base, pileup, and count (before quality filtering)\n            if (DEBUG){\n                out.printf(\"%s\\t\", context.getLocation());\n                out.printf(\"ref=%s\\t\", ref.getBase());\n                //out.printf(\"%s\\t\",pileup.getBases().toString());\n                //out.printf(\"%s\\t\",pileup.getBasePileupAsCountsString());\n            }\n\n            //Calculate posterior probabilities!\n\n\n            GenotypeLikelihoods G = new ThreeStateErrorGenotypeLikelihoods();\n\n            //Check for bad bases and ensure mapping quality myself. This works.\n            for (int i = 0; i < context.getReads().size(); i++) {\n                \n                SAMRecord read = context.getReads().get(i);\n                int offset = context.getOffsets().get(i);\n                char base = read.getReadString().charAt(offset);\n                byte qual = read.getBaseQualities()[offset];\n                int mapquality = read.getMappingQuality();\n                if (mapquality >= 5 && BaseUtils.simpleBaseToBaseIndex(base) != -1) {\n\n                    String name = read.getReadName();\n                    if (!AllReadNames.contains(name)){\n                        AllReadNames.add(name);\n                        AllReads.add(read);\n                        if( DEBUG){\n                            //out.print(\"\\n\" + read.getReadName() + \"\\t\" + read.getCigarString() + \"\\t\" + read.getReadLength() + \"\\n\");\n                        }\n                    }\n\n                    if (base == 'A'){numAs++; depth++;}\n                    if (base == 'C'){numCs++; depth++;}\n                    if (base == 'T'){numTs++; depth++;}\n                    if (base == 'G'){numGs++; depth++;}\n                    //consider base in likelihood calculations if it looks good and has high mapping score\n                    G.add(base, qual, read, offset);\n                }\n            }\n\n            //Debugging purposes\n            if (DEBUG) {out.printf(\"A[%s]\\tC[%s]\\tT[%s]\\tg[%s]\\t\",numAs,numCs,numTs,numGs);}\n\n            if (depth > 0){\n                //Store confidence scores - this is a local hash that we use to get likelihood given a particular genotype\n                Scores = new Hashtable();\n\n                Double likelihood = 0.0;\n                \n                for ( DiploidGenotype g : DiploidGenotype.values() ) {\n                    likelihood = G.getLikelihood(g);\n\n                    Scores.put(g.toString(), likelihood);\n                    //also hash other combination not stored by DiploidGenotype\n                    if (g.toString().equals(\"AC\")) {\n                        Scores.put(\"CA\", likelihood);\n                    } else if (g.toString().equals(\"AG\")){\n                        Scores.put(\"GA\", likelihood);\n                    } else if (g.toString().equals(\"AT\")){\n                        Scores.put(\"TA\", likelihood);\n                    } else if (g.toString().equals(\"CG\")){\n                        Scores.put(\"GC\", likelihood);\n                    } else if (g.toString().equals(\"CT\")){\n                        Scores.put(\"TC\", likelihood);\n                    } else if (g.toString().equals(\"GT\")){\n                        Scores.put(\"TG\", likelihood);\n                    }\n                }\n\n                //Get likelihood score for homozygous ref: used to normalize likelihoood scores at 0.\n                String homref = String.valueOf(ref.getBase())+String.valueOf(ref.getBase());\n                Double homreflikelihood = Double.parseDouble((String) Scores.get(homref).toString());\n\n                //Add SNP if it is a SNP and hasn't been added before\n                for ( DiploidGenotype g : DiploidGenotype.values() ) {\n                    likelihood = G.getLikelihood(g);\n                    if (likelihood > homreflikelihood && !SNPs.containsKey(Long.toString(loc))){\n                        SNPcount++; SNPs.put(Long.toString(loc),SNPcount); SNPlocations.add(Integer.valueOf(Long.toString(loc)));\n                        \n                    }\n                }\n\n                //Update likelihood for each combinations of alleles\n                String r1 = \"\", r2 = \"\", s1 = \"\", s2 = \"\";\n                for (int j = 0; j < numHLAlleles; j++){\n\n                    //check if allele 1 overlaps current position\n                    if (loc >= HLAstartpos[j] && loc <= HLAstoppos[j]){\n                        pos_j = loc - HLAstartpos[j];\n                        c1 = Character.toString(Character.toUpperCase(HLAreads.get(j).charAt((int) pos_j)));\n\n                        //Extract bases for HLA alleles indicated in reduceInit (for debugging)\n                        if (j == j1) r1 = c1;\n                        if (j == k1) r2 = c1;\n                        if (j == j2) s1 = c1;\n                        if (j == k2) s2 = c1;\n\n                        //Only check HLA A-A, B-B, C-C combinations\n                        int kStart = 0, kStop = 0;\n                        if (j >= iAstart && j <= iAstop){\n                            kStart = iAstart; kStop = iAstop;\n                        } else if (j >= iBstart && j <= iBstop){\n                            kStart = iBstart; kStop = iBstop;\n                        } else if (j >= iCstart && j <= iCstop){\n                            kStart = iCstart; kStop = iCstop;\n                        }\n\n                        //Fill half-matrix only to speed up process\n                        if (j > kStart){kStart = j;}\n\n                        if (DEBUG){\n                            //out.printf(\"j[%s],k[%s,%s]\\t\",j,kStart,kStop);\n                        }\n\n                        //Update likelihoods\n                        for (int k = kStart; k <= kStop; k++){\n\n                            //check if allele 2 overlaps current position\n                            if (loc >= HLAstartpos[k] && loc <= HLAstoppos[k]){\n                                pos_k = loc - HLAstartpos[k];\n                                c2 = Character.toString(Character.toUpperCase(HLAreads.get(k).charAt((int) pos_k)));\n\n                                //updates likelihoods for both permutations of the alleles, normalized to the likelihood for homozygous reference\n                                if (!homref.equals(c1+c2)){\n                                    if (Scores.containsKey(c1 + c2)){\n                                        //out.printf(\"j[%s],k[%s],g[%s],s[%.0f]\\t\",j,k,c1+c2,Scores.get(c1 + c2));\n                                        likelihood = Double.parseDouble((String) Scores.get(c1 + c2).toString());\n                                        ActualLikelihoods[j][k] = LOD[j][k]+ likelihood;\n                                        LOD[j][k]= ActualLikelihoods[j][k] - homreflikelihood;\n\n                                    } else{\n                                        if (DEBUG){\n                                        //out.printf(\"\\nCharacters [%s] not found,j[%s],k[%s],%s,%s\\n\",c1+c2,j,k,HLAnames.get(j),HLAnames.get(k));\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                    }\n                }\n            \n\n                if ( DEBUG ){\n                    //Debugging: print updated likelihoods for 2 sets of HLA alleles, as well as normalized likelihoods for all 10 genotypes\n                    out.printf(\"%s%s:%5.0f\\t%s%s:%5.0f\\t\",r1,r2,LOD[j1][k1],s1,s2,LOD[j2][k2]);\n                    for ( DiploidGenotype g : DiploidGenotype.values() ) {\n                        out.printf(\"%s %5.0f\\t\",g.toString(),Scores.get(g.toString()));\n                    }\n                    out.printf(\"\\n\");\n                }\n            }\n        }\n        \n        return context.getReads().size();\n    }","id":29226,"modified_method":"public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        \n        List<SAMRecord> reads = context.getReads();\n        List<Integer> offsets = context.getOffsets();\n        GenomeLoc Gloc = context.getLocation();\n\n        //Create pileup of reads at this locus\n        ReadBackedPileup pileup = new ReadBackedPileup(ref.getBase(), context);\n\n        long loc = context.getPosition();\n        if( context.getReads().size() > 0 ) {\n            //out.printf(\"RG for first read: %s%n\",context.getReads().get(0).getReadName());\n            int numAs = 0, numCs = 0, numGs = 0, numTs = 0,depth = 0;\n            String c1 = \"\", c2 = \"\";\n            long pos_k = 0, pos_j = 0;\n            \n            //Debugging purposes: print location, reference base, pileup, and count (before quality filtering)\n            if (DEBUG){\n                out.printf(\"%s\\t\", context.getLocation());\n                out.printf(\"ref=%s\\t\", ref.getBase());\n            }\n\n            //Calculate posterior probabilities\n            GenotypeLikelihoods G = new ThreeStateErrorGenotypeLikelihoods();\n            SAMRecord read; int offset; char base; byte qual; int mapquality; String readname;\n\n            //Check for bad bases and ensure mapping quality myself. This works.\n            for (int i = 0; i < context.getReads().size(); i++) {\n                read = context.getReads().get(i);\n                offset = context.getOffsets().get(i);\n                base = read.getReadString().charAt(offset);\n                qual = read.getBaseQualities()[offset];\n                mapquality = read.getMappingQuality();\n                if (mapquality >= 5 && BaseUtils.simpleBaseToBaseIndex(base) != -1) {\n                    //consider base in likelihood calculations if it looks good and has high mapping score\n                    G.add(base, qual, read, offset);\n                    readname = read.getReadName();\n                    if (!AllReadNames.contains(readname)){AllReadNames.add(readname); AllReads.add(read);}\n                    if (base == 'A'){numAs++; depth++;}\n                    else if (base == 'C'){numCs++; depth++;}\n                    else if (base == 'T'){numTs++; depth++;}\n                    else if (base == 'G'){numGs++; depth++;}\n                }\n            }\n\n            //Debugging purposes\n            if (DEBUG) {out.printf(\"A[%s]\\tC[%s]\\tT[%s]\\tg[%s]\\t\",numAs,numCs,numTs,numGs);}\n\n            if (depth > 0){\n                //Store confidence scores - this is a local hash that we use to get likelihood given a particular genotype\n                Scores = new Hashtable();\n                Double likelihood = 0.0;\n                for ( DiploidGenotype g : DiploidGenotype.values() ) {\n                    likelihood = G.getLikelihood(g);\n                    Scores.put(g.toString(), likelihood);\n                    //also hash other combination not stored by DiploidGenotype\n                    if (g.toString().equals(\"AC\")) {\n                        Scores.put(\"CA\", likelihood);\n                    } else if (g.toString().equals(\"AG\")){\n                        Scores.put(\"GA\", likelihood);\n                    } else if (g.toString().equals(\"AT\")){\n                        Scores.put(\"TA\", likelihood);\n                    } else if (g.toString().equals(\"CG\")){\n                        Scores.put(\"GC\", likelihood);\n                    } else if (g.toString().equals(\"CT\")){\n                        Scores.put(\"TC\", likelihood);\n                    } else if (g.toString().equals(\"GT\")){\n                        Scores.put(\"TG\", likelihood);\n                    }\n                }\n\n                //Get likelihood score for homozygous ref: used to normalize likelihoood scores at 0.\n                String homref = String.valueOf(ref.getBase())+String.valueOf(ref.getBase());\n                Double homreflikelihood = Double.parseDouble((String) Scores.get(homref).toString());\n\n                //Add SNP if it is a SNP and hasn't been added before\n                for ( DiploidGenotype g : DiploidGenotype.values() ) {\n                    likelihood = G.getLikelihood(g);\n                    if (likelihood > homreflikelihood && !SNPs.containsKey(Long.toString(loc))){\n                        SNPcount++; SNPs.put(Long.toString(loc),SNPcount); SNPlocations.add(Integer.valueOf(Long.toString(loc)));                        \n                    }\n                }\n\n                //Update likelihood for each combinations of alleles\n                String r1 = \"\", r2 = \"\", s1 = \"\", s2 = \"\";\n                for (int j = 0; j < numHLAlleles; j++){\n                    //check if allele 1 overlaps current position\n                    if (loc >= HLAstartpos[j] && loc <= HLAstoppos[j]){\n                        pos_j = loc - HLAstartpos[j];\n                        c1 = Character.toString(Character.toUpperCase(HLAreads.get(j).charAt((int) pos_j)));\n\n                        //Extract bases for HLA alleles indicated in reduceInit (for debugging)\n                        if (j == j1) r1 = c1;\n                        if (j == k1) r2 = c1;\n                        if (j == j2) s1 = c1;\n                        if (j == k2) s2 = c1;\n\n                        //Only check HLA A-A, B-B, C-C combinations\n                        int kStart = 0, kStop = 0;\n                        if (j >= iAstart && j <= iAstop){\n                            kStart = iAstart; kStop = iAstop;\n                        } else if (j >= iBstart && j <= iBstop){\n                            kStart = iBstart; kStop = iBstop;\n                        } else if (j >= iCstart && j <= iCstop){\n                            kStart = iCstart; kStop = iCstop;\n                        }\n\n                        //Fill half-matrix only to speed up process\n                        if (j > kStart){kStart = j;}\n\n                        if (DEBUG){\n                            //out.printf(\"j[%s],k[%s,%s]\\t\",j,kStart,kStop);\n                        }\n\n                        //Update likelihoods\n                        for (int k = kStart; k <= kStop; k++){\n\n                            //check if allele 2 overlaps current position\n                            if (loc >= HLAstartpos[k] && loc <= HLAstoppos[k]){\n                                pos_k = loc - HLAstartpos[k];\n                                c2 = Character.toString(Character.toUpperCase(HLAreads.get(k).charAt((int) pos_k)));\n\n                                //updates likelihoods for both permutations of the alleles, normalized to the likelihood for homozygous reference\n                                if (!homref.equals(c1+c2)){\n                                    if (Scores.containsKey(c1 + c2)){\n                                        //out.printf(\"j[%s],k[%s],g[%s],s[%.0f]\\t\",j,k,c1+c2,Scores.get(c1 + c2));\n                                        likelihood = Double.parseDouble((String) Scores.get(c1 + c2).toString());\n                                        LikelihoodScores[j][k] = LikelihoodScores[j][k] + likelihood;\n                                        LOD[j][k]= LOD[j][k] + likelihood - homreflikelihood;\n\n                                    } else{\n                                        if (DEBUG){\n                                        //out.printf(\"\\nCharacters [%s] not found,j[%s],k[%s],%s,%s\\n\",c1+c2,j,k,HLAnames.get(j),HLAnames.get(k));\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if ( DEBUG ){\n                    //Debugging: print updated likelihoods for 2 sets of HLA alleles, as well as normalized likelihoods for all 10 genotypes\n                    out.printf(\"%s%s:%5.0f\\t%s%s:%5.0f\\t\",r1,r2,LOD[j1][k1],s1,s2,LOD[j2][k2]);\n                    for ( DiploidGenotype g : DiploidGenotype.values() ) {\n                        out.printf(\"%s %5.0f\\t\",g.toString(),Scores.get(g.toString()));\n                    }\n                    out.printf(\"\\n\");\n                }\n            }\n        }\n        return context.getReads().size();\n    }","commit_id":"83e6e5a3e4208392d49dd38cba49386a453177df","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Pair<Long, Long> reduceInit() {\n        //Load sequences corresponding to HLA alleles from sam file\n\n        if (!DatabaseLoaded){\n            try{\n                out.printf(\"Reading HLA database ...\");\n                FileInputStream fstream = new FileInputStream(HLAdatabaseFile);\n                DataInputStream in = new DataInputStream(fstream);\n                BufferedReader br = new BufferedReader(new InputStreamReader(in));\n                String strLine; String [] s = null;\n                //Read File Line By Line\n                int i = 0;\n                while ((strLine = br.readLine()) != null)   {\n                    s = strLine.split(\"\\\\t\");\n                    if (s.length>=10){\n                        //Parse the reads with cigar parser\n                        HLAreads.add(CigarFormatted(s[5],s[9]));\n                        HLAcigars.add(s[5]);\n                        HLAnames.add(s[0]);\n                        HLApositions.add(s[3]);\n                        if (s[0].indexOf(\"HLA_A\") > -1){\n                            if (iAstart < 0){iAstart=i;}\n                            iAstop = i; i++;\n                        }else if (s[0].indexOf(\"HLA_B\") > -1){\n                            if (iBstart < 0){iBstart=i;}\n                            iBstop = i; i++;\n                        }else if (s[0].indexOf(\"HLA_C\") > -1){\n                            if (iCstart < 0){iCstart=i;}\n                            iCstop = i; i++;\n                        }\n                    }\n                }\n                in.close();\n                int n = HLApositions.size(); numHLAlleles = n;\n                HLAstartpos = new int[n]; HLAstoppos = new int[n];\n                SingleAlleleFrequencies = new double[n];\n                LOD = new double[n][n];\n                ActualLikelihoods = new double[n][n];\n                PhasingScores = new int[n][n];\n                CombinedAlleleFrequencies = new double[n][n];\n\n                for (i = 0; i < n; i++){\n                    //Find start and stop positions for each allele\n                    HLAstartpos[i]=Integer.parseInt(HLApositions.get(i));\n                    HLAstoppos[i]=HLAstartpos[i]+HLAreads.get(i).length()-1;\n                    SingleAlleleFrequencies[i]=0.0;\n                    //Initialize matrix of probabilities / likelihoods\n                    for (int j = 0; j <n; j++){\n                        LOD[i][j]=0;\n                        ActualLikelihoods[i][j]=0;\n                        PhasingScores[i][j]=0;\n                        CombinedAlleleFrequencies[i][j]=0.0;\n                    }\n                    //For debugging: get index for specific alleles\n                    if (HLAnames.get(i).equals(\"HLA_B*0801\"))\n                        j1 = i;\n                    if (HLAnames.get(i).equals(\"HLA_B*5601\"))\n                        k1 = i;\n                    if (HLAnames.get(i).equals(\"HLA_B*0813\"))\n                        j2 = i;\n                    if (HLAnames.get(i).equals(\"HLA_B*5613\"))\n                        k2 = i;\n                }\n                out.printf(\"DONE! Read %s alleles\\n\",HLAreads.size());\n            }catch (Exception e){//Catch exception if any\n              System.err.println(\"Error: \" + e.getMessage());\n            }\n\n            try{\n                out.printf(\"Reading allele frequences ...\");\n                FileInputStream fstream = new FileInputStream(CaucasianAlleleFrequencyFile);\n                DataInputStream in = new DataInputStream(fstream);\n                BufferedReader br = new BufferedReader(new InputStreamReader(in));\n                String strLine; String [] s = null;\n                //Read File Line By Line\n                int count = 0;\n                while ((strLine = br.readLine()) != null)   {\n                    s = strLine.split(\"\\\\t\");\n                    AlleleFrequencies.put(s[0], s[1]);\n                    count++;\n                }\n                in.close();\n                out.printf(\"Done! Read %s alleles\\n\",count);\n            }catch (Exception e){//Catch exception if any\n              System.err.println(\"Error: \" + e.getMessage());\n            }\n\n            DatabaseLoaded = true;\n            out.printf(\"Comparing reads to database ...\\n\");\n\n            //For debugging: prints which HLA alleles were indexed before\n            if (j1 > k1){int tmp = k1; k1 = j1; j1 = tmp;}\n            if (j2 > k2){int tmp = k2; k2 = j2; j2 = tmp;}\n\n            if (DEBUG){\n                out.printf(\"Astart[%s]\\tAstop[%s]\\tBstart[%s]\\tBstop[%s]\\tCstart[%s]\\tCstop[%s]\\tnumAlleles[%s]\\n\",iAstart,iAstop,iBstart,iBstop,iCstart,iCstop,numHLAlleles);\n                out.printf(\"%s,%s\\t%s,%s\\n\",HLAnames.get(j1),HLAnames.get(k1),HLAnames.get(j2),HLAnames.get(k2));\n            }\n        }\n        out.printf(\"Computing for interval %s...\\n\",numInterval);\n        numInterval++;\n        return new Pair<Long,Long>(0l,0l);\n    }","id":29227,"modified_method":"public Pair<Long, Long> reduceInit() {\n        //Load sequences corresponding to HLA alleles from sam file\n\n        if (!DatabaseLoaded){\n            try{\n                out.printf(\"Reading HLA database ...\");\n                FileInputStream fstream = new FileInputStream(HLAdatabaseFile);\n                DataInputStream in = new DataInputStream(fstream);\n                BufferedReader br = new BufferedReader(new InputStreamReader(in));\n                String strLine; String [] s = null;\n                //Read File Line By Line\n                int i = 0;\n                while ((strLine = br.readLine()) != null)   {\n                    s = strLine.split(\"\\\\t\");\n                    if (s.length>=10){\n                        //Parse the reads with cigar parser\n                        HLAreads.add(CigarFormatted(s[5],s[9]));\n                        HLAcigars.add(s[5]);\n                        HLAnames.add(s[0]);\n                        HLApositions.add(s[3]);\n                        if (s[0].indexOf(\"HLA_A\") > -1){\n                            if (iAstart < 0){iAstart=i;}\n                            iAstop = i; i++;\n                        }else if (s[0].indexOf(\"HLA_B\") > -1){\n                            if (iBstart < 0){iBstart=i;}\n                            iBstop = i; i++;\n                        }else if (s[0].indexOf(\"HLA_C\") > -1){\n                            if (iCstart < 0){iCstart=i;}\n                            iCstop = i; i++;\n                        }\n                    }\n                }\n                in.close();\n                int n = HLApositions.size(); numHLAlleles = n;\n                HLAstartpos = new int[n]; HLAstoppos = new int[n];\n                SingleAlleleFrequencies = new double[n];\n                LOD = new double[n][n];\n                LikelihoodScores = new double[n][n];\n                PhasingScores = new int[n][n];\n                CombinedAlleleFrequencies = new double[n][n];\n\n                for (i = 0; i < n; i++){\n                    //Find start and stop positions for each allele\n                    HLAstartpos[i]=Integer.parseInt(HLApositions.get(i));\n                    HLAstoppos[i]=HLAstartpos[i]+HLAreads.get(i).length()-1;\n                    SingleAlleleFrequencies[i]=0.0;\n                    //Initialize matrix of probabilities / likelihoods\n                    for (int j = 0; j <n; j++){\n                        LOD[i][j]=0;\n                        LikelihoodScores[i][j]=0;\n                        PhasingScores[i][j]=0;\n                        CombinedAlleleFrequencies[i][j]=0.0;\n                    }\n                    //For debugging: get index for specific alleles\n                    if (HLAnames.get(i).equals(\"HLA_B*0801\"))\n                        j1 = i;\n                    if (HLAnames.get(i).equals(\"HLA_B*5601\"))\n                        k1 = i;\n                    if (HLAnames.get(i).equals(\"HLA_B*0766\"))\n                        j2 = i;\n                    if (HLAnames.get(i).equals(\"HLA_B*0726\"))\n                        k2 = i;\n                }\n                out.printf(\"DONE! Read %s alleles\\n\",HLAreads.size());\n            }catch (Exception e){//Catch exception if any\n              System.err.println(\"Error: \" + e.getMessage());\n            }\n\n            try{\n                out.printf(\"Reading allele frequences ...\");\n                FileInputStream fstream = new FileInputStream(CaucasianAlleleFrequencyFile);\n                DataInputStream in = new DataInputStream(fstream);\n                BufferedReader br = new BufferedReader(new InputStreamReader(in));\n                String strLine; String [] s = null;\n                //Read File Line By Line\n                int count = 0;\n                while ((strLine = br.readLine()) != null)   {\n                    s = strLine.split(\"\\\\t\");\n                    AlleleFrequencies.put(s[0], s[1]);\n                    count++;\n                }\n                in.close();\n                out.printf(\"Done! Read %s alleles\\n\",count);\n            }catch (Exception e){//Catch exception if any\n              System.err.println(\"Error: \" + e.getMessage());\n            }\n\n            DatabaseLoaded = true;\n            out.printf(\"Comparing reads to database ...\\n\");\n\n            //For debugging: prints which HLA alleles were indexed before\n            if (j1 > k1){int tmp = k1; k1 = j1; j1 = tmp;}\n            if (j2 > k2){int tmp = k2; k2 = j2; j2 = tmp;}\n\n            if (DEBUG){\n                out.printf(\"Astart[%s]\\tAstop[%s]\\tBstart[%s]\\tBstop[%s]\\tCstart[%s]\\tCstop[%s]\\tnumAlleles[%s]\\n\",iAstart,iAstop,iBstart,iBstop,iCstart,iCstop,numHLAlleles);\n                out.printf(\"%s,%s\\t%s,%s\\n\",HLAnames.get(j1),HLAnames.get(k1),HLAnames.get(j2),HLAnames.get(k2));\n            }\n        }\n        out.printf(\"Computing for interval %s...\\n\",numInterval);\n        numInterval++;\n        return new Pair<Long,Long>(0l,0l);\n    }","commit_id":"83e6e5a3e4208392d49dd38cba49386a453177df","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Returns the data for the given sitemap.<p>\n     * \n     * @param xmlSitemap the XML sitemap to use\n     * \n     * @return the data for the given sitemap\n     * \n     * @throws JSONException if something goes wrong with the JSON manipulation\n     * @throws CmsException if something goes wrong\n     */\n    public JSONObject getSitemap(CmsXmlSitemap xmlSitemap) throws JSONException, CmsException {\n\n        CmsObject cms = getCmsObject();\n        CmsSitemapBean sitemap = xmlSitemap.getSitemap(cms, cms.getRequestContext().getLocale());\n        // create empty result object\n        JSONObject result = new JSONObject();\n\n        // get properties configuration \n        Map<String, CmsXmlContentProperty> propertiesConf = getPropertyConfig(xmlSitemap.getFile());\n\n        // collect the site map entries\n        JSONArray siteEntries = new JSONArray();\n        for (CmsSitemapEntry entry : sitemap.getSiteEntries()) {\n            JSONObject siteEntry = jsonifyEntry(entry, propertiesConf);\n            if (siteEntry != null) {\n                siteEntries.put(siteEntry);\n            }\n        }\n\n        CmsXmlSitemap superSitemap = OpenCms.getSitemapManager().getParentSitemap(cms, xmlSitemap);\n        if (superSitemap == null) {\n            // root sitemap\n            result.put(JsonResponse.superSitemap.name(), \"\");\n            result.put(JsonResponse.sitemap.name(), siteEntries);\n        } else {\n            // sub-sitemap\n            result.put(JsonResponse.superSitemap.name(), cms.getSitePath(superSitemap.getFile()));\n            // deliver parent entry\n            CmsSitemapEntry parentEntry = OpenCms.getSitemapManager().getEntryForUri(cms, sitemap.getEntryPoint());\n            JSONObject jsonParentEntry = jsonifyEntry(new CmsSitemapEntry(\n                parentEntry.getId(),\n                parentEntry.getOriginalUri(),\n                parentEntry.getResourceId(),\n                parentEntry.getName(),\n                parentEntry.getTitle(),\n                parentEntry.getInheritedProperties(),\n                null), propertiesConf);\n            jsonParentEntry.put(JsonSiteEntry.subentries.name(), siteEntries);\n            result.put(JsonResponse.sitemap.name(), jsonParentEntry);\n        }\n\n        result.put(JsonResponse.referencePath.name(), cms.getRequestContext().removeSiteRoot(sitemap.getEntryPoint()));\n\n        // collect the properties\n        result.put(JsonResponse.properties.name(), CmsXmlContentPropertyHelper.getPropertyInfoJSON(\n            cms,\n            xmlSitemap.getFile()));\n\n        return result;\n    }","id":29228,"modified_method":"/**\n     * Returns the data for the given sitemap.<p>\n     * \n     * @param xmlSitemap the XML sitemap to use\n     * \n     * @return the data for the given sitemap\n     * \n     * @throws JSONException if something goes wrong with the JSON manipulation\n     * @throws CmsException if something goes wrong\n     */\n    public JSONObject getSitemap(CmsXmlSitemap xmlSitemap) throws JSONException, CmsException {\n\n        CmsObject cms = getCmsObject();\n        CmsSitemapBean sitemap = xmlSitemap.getSitemap(cms, cms.getRequestContext().getLocale());\n        // create empty result object\n        JSONObject result = new JSONObject();\n\n        // get properties configuration \n        Map<String, CmsXmlContentProperty> propertiesConf = getPropertyConfig(xmlSitemap.getFile());\n\n        // collect the site map entries\n        JSONArray siteEntries = new JSONArray();\n        for (CmsSitemapEntry entry : sitemap.getSiteEntries()) {\n            JSONObject siteEntry = jsonifyEntry(entry, propertiesConf);\n            if (siteEntry != null) {\n                siteEntries.put(siteEntry);\n            }\n        }\n\n        CmsXmlSitemap superSitemap = OpenCms.getSitemapManager().getParentSitemap(cms, xmlSitemap);\n        if (superSitemap == null) {\n            // root sitemap\n            result.put(JsonResponse.superSitemap.name(), \"\");\n            result.put(JsonResponse.sitemap.name(), siteEntries);\n        } else {\n            // sub-sitemap\n            result.put(JsonResponse.superSitemap.name(), cms.getSitePath(superSitemap.getFile()));\n            // deliver parent entry\n            CmsSitemapEntry parentEntry = OpenCms.getSitemapManager().getEntryForUri(\n                cms,\n                cms.getRequestContext().removeSiteRoot(sitemap.getEntryPoint()));\n            Map<String, String> properties = new HashMap<String, String>(parentEntry.getInheritedProperties());\n            properties.remove(CmsSitemapManager.Property.sitemap.getName());\n            JSONObject jsonParentEntry = jsonifyEntry(new CmsSitemapEntry(\n                parentEntry.getId(),\n                parentEntry.getOriginalUri(),\n                parentEntry.getResourceId(),\n                parentEntry.getName(),\n                parentEntry.getTitle(),\n                properties,\n                null), propertiesConf);\n            jsonParentEntry.put(JsonSiteEntry.subentries.name(), siteEntries);\n            siteEntries = new JSONArray();\n            siteEntries.put(jsonParentEntry);\n            result.put(JsonResponse.sitemap.name(), siteEntries);\n        }\n\n        result.put(JsonResponse.referencePath.name(), cms.getRequestContext().removeSiteRoot(sitemap.getEntryPoint()));\n\n        // collect the properties\n        result.put(JsonResponse.properties.name(), CmsXmlContentPropertyHelper.getPropertyInfoJSON(\n            cms,\n            xmlSitemap.getFile()));\n\n        return result;\n    }","commit_id":"1a520e7e7d58c5f8ec1480cb6b073fefe1a16fe7","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Saves the new state of the sitemap.<p>\n     * \n     * @param sitemapRes the sitemap resource to save\n     * @param sitemap the sitemap data\n     * \n     * @throws CmsException if something goes wrong with the cms context\n     * @throws JSONException if something goes wrong with the JSON manipulation\n     */\n    public void saveSitemap(CmsResource sitemapRes, JSONObject sitemap) throws CmsException, JSONException {\n\n        CmsObject cms = getCmsObject();\n\n        CmsXmlSitemap xmlSitemap = CmsXmlSitemapFactory.unmarshal(cms, cms.readFile(sitemapRes), getRequest());\n        List<CmsSitemapEntry> sitemapEntries = jsonToEntryList(\n            sitemap.getJSONArray(JsonResponse.sitemap.name()),\n            getPropertyConfig(sitemapRes),\n            true);\n\n        String entryPoint = xmlSitemap.getSitemap(cms, cms.getRequestContext().getLocale()).getEntryPoint();\n        entryPoint = cms.getRequestContext().removeSiteRoot(entryPoint);\n        CmsSitemapEntry entryPointEntry = OpenCms.getSitemapManager().getEntryForUri(cms, entryPoint);\n        if (entryPointEntry.isSitemap()) {\n            // sub-sitemap: remove parent entry, see #getSitemap\n            sitemapEntries = sitemapEntries.get(0).getSubEntries();\n        }\n        xmlSitemap.save(cms, sitemapEntries);\n    }","id":29229,"modified_method":"/**\n     * Saves the new state of the sitemap.<p>\n     * \n     * @param sitemapRes the sitemap resource to save\n     * @param sitemap the sitemap data\n     * \n     * @throws CmsException if something goes wrong with the cms context\n     * @throws JSONException if something goes wrong with the JSON manipulation\n     */\n    public void saveSitemap(CmsResource sitemapRes, JSONObject sitemap) throws CmsException, JSONException {\n\n        CmsObject cms = getCmsObject();\n\n        CmsXmlSitemap xmlSitemap = CmsXmlSitemapFactory.unmarshal(cms, cms.readFile(sitemapRes), getRequest());\n        List<CmsSitemapEntry> sitemapEntries = jsonToEntryList(\n            sitemap.getJSONArray(JsonResponse.sitemap.name()),\n            getPropertyConfig(sitemapRes),\n            true);\n\n        String entryPoint = sitemap.getString(JsonResponse.referencePath.name());\n        CmsSitemapEntry entryPointEntry = OpenCms.getSitemapManager().getEntryForUri(cms, entryPoint);\n        // TODO: this might be incorrect if a sub-sitemap entry point is a valid VFS path...\n        if (entryPointEntry.isSitemap() && !cms.existsResource(entryPoint)) {\n            // sub-sitemap: remove parent entry, see #getSitemap\n            sitemapEntries = sitemapEntries.get(0).getSubEntries();\n        }\n        xmlSitemap.save(cms, entryPoint, sitemapEntries);\n    }","commit_id":"1a520e7e7d58c5f8ec1480cb6b073fefe1a16fe7","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Recomputes the properties for a client sitemap entry.<p>\n     * \n     * @param entry the sitemap entry whose properties should be updated \n     * @param propState the property state of the entry's parent \n     */\n    protected void recomputeProperties(CmsClientSitemapEntry entry, CmsPropertyInheritanceState propState) {\n\n        CmsPropertyInheritanceState myState = propState.update(entry.getProperties(), entry.getSitePath());\n        Map<String, CmsComputedPropertyValue> myProps = myState.getInheritedProperties();\n        entry.setParentInheritedProperties(propState.getInheritedProperties());\n        entry.setInheritedProperties(myProps);\n        for (I_CmsPropertyUpdateHandler handler : m_propertyUpdateHandlers) {\n            handler.handlePropertyUpdate(entry);\n        }\n\n        for (CmsClientSitemapEntry child : entry.getSubEntries()) {\n            recomputeProperties(child, myState);\n        }\n        CmsSitemapView.getInstance().getTreeItem(entry.getSitePath());\n    }","id":29230,"modified_method":"/**\n     * Recomputes the properties for a client sitemap entry.<p>\n     * \n     * @param entry the sitemap entry whose properties should be updated \n     * @param propState the property state of the entry's parent \n     */\n    protected void recomputeProperties(CmsClientSitemapEntry entry, CmsPropertyInheritanceState propState) {\n\n        CmsPropertyInheritanceState myState = propState.update(entry.getProperties(), entry.getSitePath());\n        Map<String, CmsComputedPropertyValue> myProps = new HashMap<String, CmsComputedPropertyValue>(\n            myState.getInheritedProperties());\n        Map<String, CmsComputedPropertyValue> myParentProps = new HashMap<String, CmsComputedPropertyValue>(\n            propState.getInheritedProperties());\n        entry.setParentInheritedProperties(myParentProps);\n        entry.setInheritedProperties(myProps);\n        for (I_CmsPropertyUpdateHandler handler : m_propertyUpdateHandlers) {\n            handler.handlePropertyUpdate(entry);\n        }\n\n        for (CmsClientSitemapEntry child : entry.getSubEntries()) {\n            recomputeProperties(child, myState);\n        }\n        CmsSitemapView.getInstance().getTreeItem(entry.getSitePath());\n    }","commit_id":"013fdcc3cf540b89132711d9b473e650b0177f45","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private Query newTermQuery(@Nullable FieldMapper mapper, Term term) {\n        if (fuzziness != null) {\n            if (mapper != null) {\n                Query query = mapper.fuzzyQuery(term.text(), fuzziness, fuzzyPrefixLength, maxExpansions, transpositions);\n                if (query instanceof FuzzyQuery) {\n                    QueryParsers.setRewriteMethod((FuzzyQuery) query, fuzzyRewriteMethod);\n                }\n            }\n            int edits = fuzziness.asDistance(term.text());\n            FuzzyQuery query = new FuzzyQuery(term, edits, fuzzyPrefixLength, maxExpansions, transpositions);\n            QueryParsers.setRewriteMethod(query, rewriteMethod);\n            return query;\n        }\n        if (mapper != null) {\n            Query termQuery = mapper.queryStringTermQuery(term);\n            if (termQuery != null) {\n                return termQuery;\n            }\n        }\n        return new TermQuery(term);\n    }","id":29231,"modified_method":"protected Query blendTermQuery(Term term, FieldMapper mapper) {\n        if (fuzziness != null) {\n            if (mapper != null) {\n                Query query = mapper.fuzzyQuery(term.text(), fuzziness, fuzzyPrefixLength, maxExpansions, transpositions);\n                if (query instanceof FuzzyQuery) {\n                    QueryParsers.setRewriteMethod((FuzzyQuery) query, fuzzyRewriteMethod);\n                }\n            }\n            int edits = fuzziness.asDistance(term.text());\n            FuzzyQuery query = new FuzzyQuery(term, edits, fuzzyPrefixLength, maxExpansions, transpositions);\n            QueryParsers.setRewriteMethod(query, rewriteMethod);\n            return query;\n        }\n        if (mapper != null) {\n            Query termQuery = mapper.queryStringTermQuery(term);\n            if (termQuery != null) {\n                return termQuery;\n            }\n        }\n        return new TermQuery(term);\n    }","commit_id":"162ca993762ffb5f720ae7f82adcc209d16a5bd2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Query parse(Type type, String fieldName, Object value) throws IOException {\n        FieldMapper mapper = null;\n        final String field;\n        MapperService.SmartNameFieldMappers smartNameFieldMappers = parseContext.smartFieldMappers(fieldName);\n        if (smartNameFieldMappers != null && smartNameFieldMappers.hasMapper()) {\n            mapper = smartNameFieldMappers.mapper();\n            field = mapper.names().indexName();\n        } else {\n            field = fieldName;\n        }\n\n        if (mapper != null && mapper.useTermQueryWithQueryString()) {\n            if (smartNameFieldMappers.explicitTypeInNameWithDocMapper()) {\n                String[] previousTypes = QueryParseContext.setTypesWithPrevious(new String[]{smartNameFieldMappers.docMapper().type()});\n                try {\n                    return wrapSmartNameQuery(mapper.termQuery(value, parseContext), smartNameFieldMappers, parseContext);\n                } catch (RuntimeException e) {\n                    if (lenient) {\n                        return null;\n                    }\n                    throw e;\n                } finally {\n                    QueryParseContext.setTypes(previousTypes);\n                }\n            } else {\n                try {\n                    return wrapSmartNameQuery(mapper.termQuery(value, parseContext), smartNameFieldMappers, parseContext);\n                } catch (RuntimeException e) {\n                    if (lenient) {\n                        return null;\n                    }\n                    throw e;\n                }\n            }\n        }\n\n        Analyzer analyzer = null;\n        if (this.analyzer == null) {\n            if (mapper != null) {\n                analyzer = mapper.searchAnalyzer();\n            }\n            if (analyzer == null && smartNameFieldMappers != null) {\n                analyzer = smartNameFieldMappers.searchAnalyzer();\n            }\n            if (analyzer == null) {\n                analyzer = parseContext.mapperService().searchAnalyzer();\n            }\n        } else {\n            analyzer = parseContext.mapperService().analysisService().analyzer(this.analyzer);\n            if (analyzer == null) {\n                throw new ElasticsearchIllegalArgumentException(\"No analyzer found for [\" + this.analyzer + \"]\");\n            }\n        }\n\n        // Logic similar to QueryParser#getFieldQuery\n        final TokenStream source = analyzer.tokenStream(field, value.toString());\n        source.reset();\n        int numTokens = 0;\n        int positionCount = 0;\n        boolean severalTokensAtSamePosition = false;\n        \n        final CachingTokenFilter buffer = new CachingTokenFilter(source);\n        buffer.reset();\n        final CharTermAttribute termAtt = buffer.addAttribute(CharTermAttribute.class);\n        final PositionIncrementAttribute posIncrAtt = buffer.addAttribute(PositionIncrementAttribute.class);\n        boolean hasMoreTokens =  buffer.incrementToken();\n        while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = posIncrAtt.getPositionIncrement();\n            if (positionIncrement != 0) {\n                positionCount += positionIncrement;\n            } else {\n                severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n        }\n        // rewind the buffer stream\n        buffer.reset();\n        source.close();\n\n        if (numTokens == 0) {\n            return zeroTermsQuery();\n        } else if (type == Type.BOOLEAN) {\n            if (numTokens == 1) {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                final Query q = newTermQuery(mapper, new Term(field, termToByteRef(termAtt)));\n                return wrapSmartNameQuery(q, smartNameFieldMappers, parseContext);\n            }\n            if (commonTermsCutoff != null) {\n                ExtendedCommonTermsQuery q = new ExtendedCommonTermsQuery(occur, occur, commonTermsCutoff, positionCount == 1);\n                for (int i = 0; i < numTokens; i++) {\n                    boolean hasNext = buffer.incrementToken();\n                    assert hasNext == true;\n                    q.add(new Term(field, termToByteRef(termAtt)));\n                }\n                return wrapSmartNameQuery(q, smartNameFieldMappers, parseContext);\n            } if (severalTokensAtSamePosition && occur == Occur.MUST) {\n                BooleanQuery q = new BooleanQuery(positionCount == 1);\n                Query currentQuery = null;\n                for (int i = 0; i < numTokens; i++) {\n                    boolean hasNext = buffer.incrementToken();\n                    assert hasNext == true;\n                  if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                    if (!(currentQuery instanceof BooleanQuery)) {\n                      Query t = currentQuery;\n                      currentQuery = new BooleanQuery(true);\n                      ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                    }\n                    ((BooleanQuery)currentQuery).add(newTermQuery(mapper, new Term(field, termToByteRef(termAtt))), BooleanClause.Occur.SHOULD);\n                  } else {\n                    if (currentQuery != null) {\n                      q.add(currentQuery, occur);\n                    }\n                    currentQuery = newTermQuery(mapper, new Term(field, termToByteRef(termAtt)));\n                  }\n                }\n                q.add(currentQuery, occur);\n                return wrapSmartNameQuery(q, smartNameFieldMappers, parseContext);\n            } else {\n                BooleanQuery q = new BooleanQuery(positionCount == 1);\n                for (int i = 0; i < numTokens; i++) {\n                    boolean hasNext = buffer.incrementToken();\n                    assert hasNext == true;\n                    final Query currentQuery = newTermQuery(mapper, new Term(field, termToByteRef(termAtt)));\n                    q.add(currentQuery, occur);\n                }\n                return wrapSmartNameQuery(q, smartNameFieldMappers, parseContext);\n            }\n        } else if (type == Type.PHRASE) {\n            if (severalTokensAtSamePosition) {\n                final MultiPhraseQuery mpq = new MultiPhraseQuery();\n                mpq.setSlop(phraseSlop);\n                final List<Term> multiTerms = new ArrayList<Term>();\n                int position = -1;\n                for (int i = 0; i < numTokens; i++) {\n                    int positionIncrement = 1;\n                    boolean hasNext = buffer.incrementToken();\n                    assert hasNext == true;\n                    positionIncrement = posIncrAtt.getPositionIncrement();\n\n                    if (positionIncrement > 0 && multiTerms.size() > 0) {\n                        if (enablePositionIncrements) {\n                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);\n                        } else {\n                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));\n                        }\n                        multiTerms.clear();\n                    }\n                    position += positionIncrement;\n                    //LUCENE 4 UPGRADE instead of string term we can convert directly from utf-16 to utf-8 \n                    multiTerms.add(new Term(field, termToByteRef(termAtt)));\n                }\n                if (enablePositionIncrements) {\n                    mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);\n                } else {\n                    mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));\n                }\n                return wrapSmartNameQuery(mpq, smartNameFieldMappers, parseContext);\n            } else {\n                PhraseQuery pq = new PhraseQuery();\n                pq.setSlop(phraseSlop);\n                int position = -1;\n                for (int i = 0; i < numTokens; i++) {\n                    int positionIncrement = 1;\n                    boolean hasNext = buffer.incrementToken();\n                    assert hasNext == true;\n                    positionIncrement = posIncrAtt.getPositionIncrement();\n\n                    if (enablePositionIncrements) {\n                        position += positionIncrement;\n                        //LUCENE 4 UPGRADE instead of string term we can convert directly from utf-16 to utf-8\n                        pq.add(new Term(field, termToByteRef(termAtt)), position);\n                    } else {\n                        pq.add(new Term(field, termToByteRef(termAtt)));\n                    }\n                }\n                return wrapSmartNameQuery(pq, smartNameFieldMappers, parseContext);\n            }\n        } else if (type == Type.PHRASE_PREFIX) {\n            MultiPhrasePrefixQuery mpq = new MultiPhrasePrefixQuery();\n            mpq.setSlop(phraseSlop);\n            mpq.setMaxExpansions(maxExpansions);\n            List<Term> multiTerms = new ArrayList<Term>();\n            int position = -1;\n            for (int i = 0; i < numTokens; i++) {\n                int positionIncrement = 1;\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                positionIncrement = posIncrAtt.getPositionIncrement();\n\n                if (positionIncrement > 0 && multiTerms.size() > 0) {\n                    if (enablePositionIncrements) {\n                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);\n                    } else {\n                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));\n                    }\n                    multiTerms.clear();\n                }\n                position += positionIncrement;\n                multiTerms.add(new Term(field, termToByteRef(termAtt)));\n            }\n            if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);\n            } else {\n                mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));\n            }\n            return wrapSmartNameQuery(mpq, smartNameFieldMappers, parseContext);\n        }\n\n        throw new ElasticsearchIllegalStateException(\"No type found for [\" + type + \"]\");\n    }","id":29232,"modified_method":"public Query parse(Type type, String fieldName, Object value) throws IOException {\n        FieldMapper mapper = null;\n        final String field;\n        MapperService.SmartNameFieldMappers smartNameFieldMappers = parseContext.smartFieldMappers(fieldName);\n        if (smartNameFieldMappers != null && smartNameFieldMappers.hasMapper()) {\n            mapper = smartNameFieldMappers.mapper();\n            field = mapper.names().indexName();\n        } else {\n            field = fieldName;\n        }\n\n        if (mapper != null && mapper.useTermQueryWithQueryString() && !forceAnalyzeQueryString()) {\n            if (smartNameFieldMappers.explicitTypeInNameWithDocMapper()) {\n                String[] previousTypes = QueryParseContext.setTypesWithPrevious(new String[]{smartNameFieldMappers.docMapper().type()});\n                try {\n                    return wrapSmartNameQuery(mapper.termQuery(value, parseContext), smartNameFieldMappers, parseContext);\n                } catch (RuntimeException e) {\n                    if (lenient) {\n                        return null;\n                    }\n                    throw e;\n                } finally {\n                    QueryParseContext.setTypes(previousTypes);\n                }\n            } else {\n                try {\n                    return wrapSmartNameQuery(mapper.termQuery(value, parseContext), smartNameFieldMappers, parseContext);\n                } catch (RuntimeException e) {\n                    if (lenient) {\n                        return null;\n                    }\n                    throw e;\n                }\n            }\n        }\n        Analyzer analyzer = getAnalyzer(mapper, smartNameFieldMappers);\n        MatchQueryBuilder builder = new MatchQueryBuilder(analyzer, mapper);\n        builder.setEnablePositionIncrements(this.enablePositionIncrements);\n\n        Query query = null;\n        switch (type) {\n            case BOOLEAN:\n                if (commonTermsCutoff == null) {\n                    query = builder.createBooleanQuery(field, value.toString(), occur);\n                } else {\n                    query = builder.createCommonTermsQuery(field, value.toString(), occur, occur, commonTermsCutoff);\n                }\n                break;\n            case PHRASE:\n                query = builder.createPhraseQuery(field, value.toString(), phraseSlop);\n                break;\n            case PHRASE_PREFIX:\n                query = builder.createPhrasePrefixQuery(field, value.toString(), phraseSlop, maxExpansions);\n                break;\n            default:\n                throw new ElasticsearchIllegalStateException(\"No type found for [\" + type + \"]\");\n        }\n\n        if (query == null) {\n            return zeroTermsQuery();\n        } else {\n            return wrapSmartNameQuery(query, smartNameFieldMappers, parseContext);\n        }\n    }","commit_id":"162ca993762ffb5f720ae7f82adcc209d16a5bd2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Query parse(Type type, Map<String, Float> fieldNames, Object value, String minimumShouldMatch) throws IOException {\n        if (fieldNames.size() == 1) {\n            Map.Entry<String, Float> fieldBoost = fieldNames.entrySet().iterator().next();\n            Float boostValue = fieldBoost.getValue();\n            return parseAndApply(type, fieldBoost.getKey(), value, minimumShouldMatch, boostValue);\n        }\n\n        if (useDisMax) {\n            DisjunctionMaxQuery disMaxQuery = new DisjunctionMaxQuery(tieBreaker);\n            boolean clauseAdded = false;\n            for (String fieldName : fieldNames.keySet()) {\n                Float boostValue = fieldNames.get(fieldName);\n                Query query = parseAndApply(type, fieldName, value, minimumShouldMatch, boostValue);\n                if (query != null) {\n                    clauseAdded = true;\n                    disMaxQuery.add(query);\n                }\n            }\n            return clauseAdded ? disMaxQuery : null;\n        } else {\n            BooleanQuery booleanQuery = new BooleanQuery();\n            for (String fieldName : fieldNames.keySet()) {\n                Float boostValue = fieldNames.get(fieldName);\n                Query query = parseAndApply(type, fieldName, value, minimumShouldMatch, boostValue);\n                if (query != null) {\n                    booleanQuery.add(query, BooleanClause.Occur.SHOULD);\n                }\n            }\n            return !booleanQuery.clauses().isEmpty() ? booleanQuery : null;\n        }\n    }","id":29233,"modified_method":"public Query parse(MultiMatchQueryBuilder.Type type, Map<String, Float> fieldNames, Object value, String minimumShouldMatch) throws IOException {\n        if (fieldNames.size() == 1) {\n            Map.Entry<String, Float> fieldBoost = fieldNames.entrySet().iterator().next();\n            Float boostValue = fieldBoost.getValue();\n            return parseAndApply(type.matchQueryType(), fieldBoost.getKey(), value, minimumShouldMatch, boostValue);\n        }\n\n        final float tieBreaker = groupTieBreaker == null ? type.tieBreaker() : groupTieBreaker;\n        switch (type) {\n            case PHRASE:\n            case PHRASE_PREFIX:\n            case BEST_FIELDS:\n            case MOST_FIELDS:\n                queryBuilder = new QueryBuilder(tieBreaker);\n                break;\n            case CROSS_FIELDS:\n                queryBuilder = new CrossFieldsQueryBuilder(tieBreaker);\n                break;\n            default:\n                throw new ElasticsearchIllegalStateException(\"No such type: \" + type);\n        }\n        final List<? extends Query> queries = queryBuilder.buildGroupedQueries(type, fieldNames, value, minimumShouldMatch);\n        return queryBuilder.conbineGrouped(queries);\n    }","commit_id":"162ca993762ffb5f720ae7f82adcc209d16a5bd2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void setTieBreaker(float tieBreaker) {\n        this.tieBreaker = tieBreaker;\n    }","id":29234,"modified_method":"public void setTieBreaker(float tieBreaker) {\n        this.groupTieBreaker = tieBreaker;\n    }","commit_id":"162ca993762ffb5f720ae7f82adcc209d16a5bd2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Sets the type of the text query.\n     */\n    public MultiMatchQueryBuilder type(MatchQueryBuilder.Type type) {\n        this.type = type;\n        return this;\n    }","id":29235,"modified_method":"/**\n     * Sets the type of the text query.\n     */\n    public MultiMatchQueryBuilder type(MultiMatchQueryBuilder.Type type) {\n        this.type = type;\n        return this;\n    }","commit_id":"162ca993762ffb5f720ae7f82adcc209d16a5bd2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public MultiMatchQueryBuilder tieBreaker(Float tieBreaker) {\n        this.tieBreaker = tieBreaker;\n        return this;\n    }","id":29236,"modified_method":"/**\n     * <p>Tie-Breaker for \"best-match\" disjunction queries (OR-Queries).\n     * The tie breaker capability allows documents that match more than on query clause\n     * (in this case on more than one field) to be scored better than documents that\n     * match only the best of the fields, without confusing this with the better case of\n     * two distinct matches in the multiple fields.<\/p>\n     *\n     * <p>A tie-breaker value of <tt>1.0<\/tt> is interpreted as a signal to score queries as\n     * \"most-match\" queries where all matching query clauses are considered for scoring.<\/p>\n     *\n     * @see Type\n     */\n    public MultiMatchQueryBuilder tieBreaker(float tieBreaker) {\n        this.tieBreaker = tieBreaker;\n        return this;\n    }","commit_id":"162ca993762ffb5f720ae7f82adcc209d16a5bd2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public MultiMatchQueryBuilder useDisMax(Boolean useDisMax) {\n        this.useDisMax = useDisMax;\n        return this;\n    }","id":29237,"modified_method":"/**\n     * @deprecated use a tieBreaker of 1.0f to disable \"dis-max\"\n     * query or select the appropriate {@link Type}\n     */\n    @Deprecated\n    public MultiMatchQueryBuilder useDisMax(boolean useDisMax) {\n        this.useDisMax = useDisMax;\n        return this;\n    }","commit_id":"162ca993762ffb5f720ae7f82adcc209d16a5bd2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Query parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        Object value = null;\n        float boost = 1.0f;\n        MatchQuery.Type type = MatchQuery.Type.BOOLEAN;\n        MultiMatchQuery multiMatchQuery = new MultiMatchQuery(parseContext);\n        String minimumShouldMatch = null;\n        Map<String, Float> fieldNameWithBoosts = Maps.newHashMap();\n        String queryName = null;\n\n        XContentParser.Token token;\n        String currentFieldName = null;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (\"fields\".equals(currentFieldName)) {\n                if (token == XContentParser.Token.START_ARRAY) {\n                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n                        extractFieldAndBoost(parseContext, parser, fieldNameWithBoosts);\n                    }\n                } else if (token.isValue()) {\n                    extractFieldAndBoost(parseContext, parser, fieldNameWithBoosts);\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[\" + NAME + \"] query does not support [\" + currentFieldName\n                            + \"]\");\n                }\n            } else if (token.isValue()) {\n                if (\"query\".equals(currentFieldName)) {\n                    value = parser.objectText();\n                } else if (\"type\".equals(currentFieldName)) {\n                    String tStr = parser.text();\n                    if (\"boolean\".equals(tStr)) {\n                        type = MatchQuery.Type.BOOLEAN;\n                    } else if (\"phrase\".equals(tStr)) {\n                        type = MatchQuery.Type.PHRASE;\n                    } else if (\"phrase_prefix\".equals(tStr) || \"phrasePrefix\".equals(currentFieldName)) {\n                        type = MatchQuery.Type.PHRASE_PREFIX;\n                    } else {\n                        throw new QueryParsingException(parseContext.index(), \"[\" + NAME + \"] query does not support type \" + tStr);\n                    }\n                } else if (\"analyzer\".equals(currentFieldName)) {\n                    String analyzer = parser.text();\n                    if (parseContext.analysisService().analyzer(analyzer) == null) {\n                        throw new QueryParsingException(parseContext.index(), \"[\"+ NAME +\"] analyzer [\" + parser.text() + \"] not found\");\n                    }\n                    multiMatchQuery.setAnalyzer(analyzer);\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = parser.floatValue();\n                } else if (\"slop\".equals(currentFieldName) || \"phrase_slop\".equals(currentFieldName) || \"phraseSlop\".equals(currentFieldName)) {\n                    multiMatchQuery.setPhraseSlop(parser.intValue());\n                } else if (Fuzziness.FIELD.match(currentFieldName, parseContext.parseFlags())) {\n                    multiMatchQuery.setFuzziness(Fuzziness.parse(parser));\n                } else if (\"prefix_length\".equals(currentFieldName) || \"prefixLength\".equals(currentFieldName)) {\n                    multiMatchQuery.setFuzzyPrefixLength(parser.intValue());\n                } else if (\"max_expansions\".equals(currentFieldName) || \"maxExpansions\".equals(currentFieldName)) {\n                    multiMatchQuery.setMaxExpansions(parser.intValue());\n                } else if (\"operator\".equals(currentFieldName)) {\n                    String op = parser.text();\n                    if (\"or\".equalsIgnoreCase(op)) {\n                        multiMatchQuery.setOccur(BooleanClause.Occur.SHOULD);\n                    } else if (\"and\".equalsIgnoreCase(op)) {\n                        multiMatchQuery.setOccur(BooleanClause.Occur.MUST);\n                    } else {\n                        throw new QueryParsingException(parseContext.index(), \"text query requires operator to be either 'and' or 'or', not [\" + op + \"]\");\n                    }\n                } else if (\"minimum_should_match\".equals(currentFieldName) || \"minimumShouldMatch\".equals(currentFieldName)) {\n                    minimumShouldMatch = parser.textOrNull();\n                } else if (\"rewrite\".equals(currentFieldName)) {\n                    multiMatchQuery.setRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(), null));\n                } else if (\"fuzzy_rewrite\".equals(currentFieldName) || \"fuzzyRewrite\".equals(currentFieldName)) {\n                    multiMatchQuery.setFuzzyRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(), null));\n                } else if (\"use_dis_max\".equals(currentFieldName) || \"useDisMax\".equals(currentFieldName)) {\n                    multiMatchQuery.setUseDisMax(parser.booleanValue());\n                } else if (\"tie_breaker\".equals(currentFieldName) || \"tieBreaker\".equals(currentFieldName)) {\n                    multiMatchQuery.setTieBreaker(parser.floatValue());\n                }  else if (\"cutoff_frequency\".equals(currentFieldName)) {\n                    multiMatchQuery.setCommonTermsCutoff(parser.floatValue());\n                } else if (\"lenient\".equals(currentFieldName)) {\n                    multiMatchQuery.setLenient(parser.booleanValue());\n                } else if (\"zero_terms_query\".equals(currentFieldName)) {\n                    String zeroTermsDocs = parser.text();\n                    if (\"none\".equalsIgnoreCase(zeroTermsDocs)) {\n                        multiMatchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.NONE);\n                    } else if (\"all\".equalsIgnoreCase(zeroTermsDocs)) {\n                        multiMatchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.ALL);\n                    } else {\n                        throw new QueryParsingException(parseContext.index(), \"Unsupported zero_terms_docs value [\" + zeroTermsDocs + \"]\");\n                    }\n                } else if (\"_name\".equals(currentFieldName)) {\n                    queryName = parser.text();\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[match] query does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n\n        if (value == null) {\n            throw new QueryParsingException(parseContext.index(), \"No text specified for match_all query\");\n        }\n\n        if (fieldNameWithBoosts.isEmpty()) {\n            throw new QueryParsingException(parseContext.index(), \"No fields specified for match_all query\");\n        }\n\n        Query query = multiMatchQuery.parse(type, fieldNameWithBoosts, value, minimumShouldMatch);\n        if (query == null) {\n            return null;\n        }\n\n        query.setBoost(boost);\n        if (queryName != null) {\n            parseContext.addNamedQuery(queryName, query);\n        }\n        return query;\n    }","id":29238,"modified_method":"@Override\n    public Query parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        Object value = null;\n        float boost = 1.0f;\n        Float tieBreaker = null;\n        MultiMatchQueryBuilder.Type type = null;\n        MultiMatchQuery multiMatchQuery = new MultiMatchQuery(parseContext);\n        String minimumShouldMatch = null;\n        Map<String, Float> fieldNameWithBoosts = Maps.newHashMap();\n        String queryName = null;\n        XContentParser.Token token;\n        String currentFieldName = null;\n        Boolean useDisMax = null;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (\"fields\".equals(currentFieldName)) {\n                if (token == XContentParser.Token.START_ARRAY) {\n                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n                        extractFieldAndBoost(parseContext, parser, fieldNameWithBoosts);\n                    }\n                } else if (token.isValue()) {\n                    extractFieldAndBoost(parseContext, parser, fieldNameWithBoosts);\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[\" + NAME + \"] query does not support [\" + currentFieldName\n                            + \"]\");\n                }\n            } else if (token.isValue()) {\n                if (\"query\".equals(currentFieldName)) {\n                    value = parser.objectText();\n                } else if (\"type\".equals(currentFieldName)) {\n                    type = MultiMatchQueryBuilder.Type.parse(parser.text(), parseContext.parseFlags());\n                } else if (\"analyzer\".equals(currentFieldName)) {\n                    String analyzer = parser.text();\n                    if (parseContext.analysisService().analyzer(analyzer) == null) {\n                        throw new QueryParsingException(parseContext.index(), \"[\"+ NAME +\"] analyzer [\" + parser.text() + \"] not found\");\n                    }\n                    multiMatchQuery.setAnalyzer(analyzer);\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = parser.floatValue();\n                } else if (\"slop\".equals(currentFieldName) || \"phrase_slop\".equals(currentFieldName) || \"phraseSlop\".equals(currentFieldName)) {\n                    multiMatchQuery.setPhraseSlop(parser.intValue());\n                } else if (Fuzziness.FIELD.match(currentFieldName, parseContext.parseFlags())) {\n                    multiMatchQuery.setFuzziness(Fuzziness.parse(parser));\n                } else if (\"prefix_length\".equals(currentFieldName) || \"prefixLength\".equals(currentFieldName)) {\n                    multiMatchQuery.setFuzzyPrefixLength(parser.intValue());\n                } else if (\"max_expansions\".equals(currentFieldName) || \"maxExpansions\".equals(currentFieldName)) {\n                    multiMatchQuery.setMaxExpansions(parser.intValue());\n                } else if (\"operator\".equals(currentFieldName)) {\n                    String op = parser.text();\n                    if (\"or\".equalsIgnoreCase(op)) {\n                        multiMatchQuery.setOccur(BooleanClause.Occur.SHOULD);\n                    } else if (\"and\".equalsIgnoreCase(op)) {\n                        multiMatchQuery.setOccur(BooleanClause.Occur.MUST);\n                    } else {\n                        throw new QueryParsingException(parseContext.index(), \"text query requires operator to be either 'and' or 'or', not [\" + op + \"]\");\n                    }\n                } else if (\"minimum_should_match\".equals(currentFieldName) || \"minimumShouldMatch\".equals(currentFieldName)) {\n                    minimumShouldMatch = parser.textOrNull();\n                } else if (\"rewrite\".equals(currentFieldName)) {\n                    multiMatchQuery.setRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(), null));\n                } else if (\"fuzzy_rewrite\".equals(currentFieldName) || \"fuzzyRewrite\".equals(currentFieldName)) {\n                    multiMatchQuery.setFuzzyRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(), null));\n                } else if (\"use_dis_max\".equals(currentFieldName) || \"useDisMax\".equals(currentFieldName)) {\n                    useDisMax = parser.booleanValue();\n                } else if (\"tie_breaker\".equals(currentFieldName) || \"tieBreaker\".equals(currentFieldName)) {\n                    multiMatchQuery.setTieBreaker(tieBreaker = parser.floatValue());\n                }  else if (\"cutoff_frequency\".equals(currentFieldName)) {\n                    multiMatchQuery.setCommonTermsCutoff(parser.floatValue());\n                } else if (\"lenient\".equals(currentFieldName)) {\n                    multiMatchQuery.setLenient(parser.booleanValue());\n                } else if (\"zero_terms_query\".equals(currentFieldName)) {\n                    String zeroTermsDocs = parser.text();\n                    if (\"none\".equalsIgnoreCase(zeroTermsDocs)) {\n                        multiMatchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.NONE);\n                    } else if (\"all\".equalsIgnoreCase(zeroTermsDocs)) {\n                        multiMatchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.ALL);\n                    } else {\n                        throw new QueryParsingException(parseContext.index(), \"Unsupported zero_terms_docs value [\" + zeroTermsDocs + \"]\");\n                    }\n                } else if (\"_name\".equals(currentFieldName)) {\n                    queryName = parser.text();\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[match] query does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n\n        if (value == null) {\n            throw new QueryParsingException(parseContext.index(), \"No text specified for match_all query\");\n        }\n\n        if (fieldNameWithBoosts.isEmpty()) {\n            throw new QueryParsingException(parseContext.index(), \"No fields specified for match_all query\");\n        }\n        if (type == null) {\n            type = MultiMatchQueryBuilder.Type.BEST_FIELDS;\n        }\n        if (useDisMax != null) { // backwards foobar\n            boolean typeUsesDismax = type.tieBreaker() != 1.0f;\n            if (typeUsesDismax != useDisMax) {\n                if (useDisMax && tieBreaker == null) {\n                    multiMatchQuery.setTieBreaker(0.0f);\n                } else {\n                    multiMatchQuery.setTieBreaker(1.0f);\n                }\n            }\n        }\n        Query query = multiMatchQuery.parse(type, fieldNameWithBoosts, value, minimumShouldMatch);\n        if (query == null) {\n            return null;\n        }\n\n        query.setBoost(boost);\n        if (queryName != null) {\n            parseContext.addNamedQuery(queryName, query);\n        }\n        return query;\n    }","commit_id":"162ca993762ffb5f720ae7f82adcc209d16a5bd2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testPhraseType() {\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"Man the Ultimate\", \"full_name_phrase\", \"first_name_phrase\", \"last_name_phrase\", \"category_phrase\")\n                        .operator(MatchQueryBuilder.Operator.OR).type(MatchQueryBuilder.Type.PHRASE)).get();\n        assertFirstHit(searchResponse, hasId(\"ultimate2\"));\n        assertHitCount(searchResponse, 1l);\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"Captain\", \"full_name_phrase\", \"first_name_phrase\", \"last_name_phrase\", \"category_phrase\")\n                        .operator(MatchQueryBuilder.Operator.OR).type(MatchQueryBuilder.Type.PHRASE)).get();\n        assertThat(searchResponse.getHits().getTotalHits(), greaterThan(1l));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"the Ul\", \"full_name_phrase\", \"first_name_phrase\", \"last_name_phrase\", \"category_phrase\")\n                        .operator(MatchQueryBuilder.Operator.OR).type(MatchQueryBuilder.Type.PHRASE_PREFIX)).get();\n        assertFirstHit(searchResponse, hasId(\"ultimate2\"));\n        assertSecondHit(searchResponse, hasId(\"ultimate1\"));\n        assertHitCount(searchResponse, 2l);\n    }","id":29239,"modified_method":"@Test\n    public void testPhraseType() {\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"Man the Ultimate\", \"full_name_phrase\", \"first_name_phrase\", \"last_name_phrase\", \"category_phrase\")\n                        .operator(MatchQueryBuilder.Operator.OR).type(MatchQueryBuilder.Type.PHRASE))).get();\n        assertFirstHit(searchResponse, hasId(\"ultimate2\"));\n        assertHitCount(searchResponse, 1l);\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"Captain\", \"full_name_phrase\", \"first_name_phrase\", \"last_name_phrase\", \"category_phrase\")\n                        .operator(MatchQueryBuilder.Operator.OR).type(MatchQueryBuilder.Type.PHRASE))).get();\n        assertThat(searchResponse.getHits().getTotalHits(), greaterThan(1l));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"the Ul\", \"full_name_phrase\", \"first_name_phrase\", \"last_name_phrase\", \"category_phrase\")\n                        .operator(MatchQueryBuilder.Operator.OR).type(MatchQueryBuilder.Type.PHRASE_PREFIX))).get();\n        assertFirstHit(searchResponse, hasId(\"ultimate2\"));\n        assertSecondHit(searchResponse, hasId(\"ultimate1\"));\n        assertHitCount(searchResponse, 2l);\n    }","commit_id":"162ca993762ffb5f720ae7f82adcc209d16a5bd2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testDefaults() throws ExecutionException, InterruptedException {\n        MatchQueryBuilder.Type type = randomBoolean() ? null : MatchQueryBuilder.Type.BOOLEAN;\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR)).get();\n        Set<String> topNIds = Sets.newHashSet(\"theone\", \"theother\");\n        for (int i = 0; i < searchResponse.getHits().hits().length; i++) {\n            topNIds.remove(searchResponse.getHits().getAt(i).getId());\n            // very likely that we hit a random doc that has the same score so orders are random since\n            // the doc id is the tie-breaker\n        }\n        assertThat(topNIds, empty());\n        assertThat(searchResponse.getHits().hits()[0].getScore(), equalTo(searchResponse.getHits().hits()[1].getScore()));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR).useDisMax(false).type(type)).get();\n        assertFirstHit(searchResponse, anyOf(hasId(\"theone\"), hasId(\"theother\")));\n        assertThat(searchResponse.getHits().hits()[0].getScore(), greaterThan(searchResponse.getHits().hits()[1].getScore()));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"marvel hero\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR).type(type)).get();\n        assertFirstHit(searchResponse, hasId(\"theother\"));\n\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.AND).type(type)).get();\n        assertHitCount(searchResponse, 1l);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.AND).type(type)).get();\n        assertHitCount(searchResponse, 1l);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n    }","id":29240,"modified_method":"@Test\n    public void testDefaults() throws ExecutionException, InterruptedException {\n        MatchQueryBuilder.Type type = randomBoolean() ? null : MatchQueryBuilder.Type.BOOLEAN;\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR))).get();\n        Set<String> topNIds = Sets.newHashSet(\"theone\", \"theother\");\n        for (int i = 0; i < searchResponse.getHits().hits().length; i++) {\n            topNIds.remove(searchResponse.getHits().getAt(i).getId());\n            // very likely that we hit a random doc that has the same score so orders are random since\n            // the doc id is the tie-breaker\n        }\n        assertThat(topNIds, empty());\n        assertThat(searchResponse.getHits().hits()[0].getScore(), equalTo(searchResponse.getHits().hits()[1].getScore()));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR).useDisMax(false).type(type))).get();\n        assertFirstHit(searchResponse, anyOf(hasId(\"theone\"), hasId(\"theother\")));\n        assertThat(searchResponse.getHits().hits()[0].getScore(), greaterThan(searchResponse.getHits().hits()[1].getScore()));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR).type(type))).get();\n        assertFirstHit(searchResponse, hasId(\"theother\"));\n\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.AND).type(type))).get();\n        assertHitCount(searchResponse, 1l);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.AND).type(type))).get();\n        assertHitCount(searchResponse, 1l);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n    }","commit_id":"162ca993762ffb5f720ae7f82adcc209d16a5bd2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testCutoffFreq() throws ExecutionException, InterruptedException {\n        final long numDocs = client().prepareCount(\"test\")\n                .setQuery(matchAllQuery()).get().getCount();\n        MatchQueryBuilder.Type type = randomBoolean() ? null : MatchQueryBuilder.Type.BOOLEAN;\n        Float cutoffFrequency = randomBoolean() ? Math.min(1, numDocs * 1.f / between(10, 20)) : 1.f / between(10, 20);\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR).cutoffFrequency(cutoffFrequency)).get();\n        Set<String> topNIds = Sets.newHashSet(\"theone\", \"theother\");\n        for (int i = 0; i < searchResponse.getHits().hits().length; i++) {\n            topNIds.remove(searchResponse.getHits().getAt(i).getId());\n            // very likely that we hit a random doc that has the same score so orders are random since\n            // the doc id is the tie-breaker\n        }\n        assertThat(topNIds, empty());\n        assertThat(searchResponse.getHits().hits()[0].getScore(), greaterThanOrEqualTo(searchResponse.getHits().hits()[1].getScore()));\n\n        cutoffFrequency = randomBoolean() ? Math.min(1, numDocs * 1.f / between(10, 20)) : 1.f / between(10, 20);\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR).useDisMax(false).cutoffFrequency(cutoffFrequency).type(type)).get();\n        assertFirstHit(searchResponse, anyOf(hasId(\"theone\"), hasId(\"theother\")));\n        assertThat(searchResponse.getHits().hits()[0].getScore(), greaterThan(searchResponse.getHits().hits()[1].getScore()));\n        long size = searchResponse.getHits().getTotalHits();\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR).useDisMax(false).type(type)).get();\n        assertFirstHit(searchResponse, anyOf(hasId(\"theone\"), hasId(\"theother\")));\n        assertThat(\"common terms expected to be a way smaller result set\", size, lessThan(searchResponse.getHits().getTotalHits()));\n\n        cutoffFrequency = randomBoolean() ? Math.min(1, numDocs * 1.f / between(10, 20)) : 1.f / between(10, 20);\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"marvel hero\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR).cutoffFrequency(cutoffFrequency).type(type)).get();\n        assertFirstHit(searchResponse, hasId(\"theother\"));\n\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.AND).cutoffFrequency(cutoffFrequency).type(type)).get();\n        assertHitCount(searchResponse, 1l);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.AND).cutoffFrequency(cutoffFrequency).type(type)).get();\n        assertHitCount(searchResponse, 1l);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n    }","id":29241,"modified_method":"@Test\n    public void testCutoffFreq() throws ExecutionException, InterruptedException {\n        final long numDocs = client().prepareCount(\"test\")\n                .setQuery(matchAllQuery()).get().getCount();\n        MatchQueryBuilder.Type type = randomBoolean() ? null : MatchQueryBuilder.Type.BOOLEAN;\n        Float cutoffFrequency = randomBoolean() ? Math.min(1, numDocs * 1.f / between(10, 20)) : 1.f / between(10, 20);\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR).cutoffFrequency(cutoffFrequency))).get();\n        Set<String> topNIds = Sets.newHashSet(\"theone\", \"theother\");\n        for (int i = 0; i < searchResponse.getHits().hits().length; i++) {\n            topNIds.remove(searchResponse.getHits().getAt(i).getId());\n            // very likely that we hit a random doc that has the same score so orders are random since\n            // the doc id is the tie-breaker\n        }\n        assertThat(topNIds, empty());\n        assertThat(searchResponse.getHits().hits()[0].getScore(), greaterThanOrEqualTo(searchResponse.getHits().hits()[1].getScore()));\n\n        cutoffFrequency = randomBoolean() ? Math.min(1, numDocs * 1.f / between(10, 20)) : 1.f / between(10, 20);\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR).useDisMax(false).cutoffFrequency(cutoffFrequency).type(type))).get();\n        assertFirstHit(searchResponse, anyOf(hasId(\"theone\"), hasId(\"theother\")));\n        assertThat(searchResponse.getHits().hits()[0].getScore(), greaterThan(searchResponse.getHits().hits()[1].getScore()));\n        long size = searchResponse.getHits().getTotalHits();\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR).useDisMax(false).type(type))).get();\n        assertFirstHit(searchResponse, anyOf(hasId(\"theone\"), hasId(\"theother\")));\n        assertThat(\"common terms expected to be a way smaller result set\", size, lessThan(searchResponse.getHits().getTotalHits()));\n\n        cutoffFrequency = randomBoolean() ? Math.min(1, numDocs * 1.f / between(10, 20)) : 1.f / between(10, 20);\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.OR).cutoffFrequency(cutoffFrequency).type(type))).get();\n        assertFirstHit(searchResponse, hasId(\"theother\"));\n\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.AND).cutoffFrequency(cutoffFrequency).type(type))).get();\n        assertHitCount(searchResponse, 1l);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.AND).cutoffFrequency(cutoffFrequency).type(type))).get();\n        assertHitCount(searchResponse, 1l);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero\", \"first_name\", \"last_name\", \"category\")\n                        .operator(MatchQueryBuilder.Operator.AND).cutoffFrequency(cutoffFrequency)\n                        .analyzer(\"category\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS))).get();\n        assertHitCount(searchResponse, 1l);\n        assertFirstHit(searchResponse, hasId(\"theother\"));\n    }","commit_id":"162ca993762ffb5f720ae7f82adcc209d16a5bd2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Before\n    public void init() throws Exception {\n        CreateIndexRequestBuilder builder = prepareCreate(\"test\").setSettings(settingsBuilder()\n                .put(SETTING_NUMBER_OF_SHARDS, 1)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .put(\"index.analysis.analyzer.perfect_match.type\", \"custom\")\n                .put(\"index.analysis.analyzer.perfect_match.tokenizer\", \"keyword\")\n                .put(\"index.analysis.analyzer.perfect_match.filter\", \"lowercase\")\n                .put(\"index.analysis.analyzer.category.type\", \"custom\")\n                .put(\"index.analysis.analyzer.category.tokenizer\", \"whitespace\")\n                .put(\"index.analysis.analyzer.category.filter\", \"lowercase\")\n        );\n        assertAcked(builder.addMapping(\"test\", createMapping()));\n        ensureGreen();\n        int numDocs = atLeast(50);\n        List<IndexRequestBuilder> builders = new ArrayList<IndexRequestBuilder>();\n        builders.add(client().prepareIndex(\"test\", \"test\", \"theone\").setSource(\n                \"full_name\", \"Captain America\",\n                \"first_name\", \"Captain\",\n                \"last_name\", \"America\",\n                \"category\", \"marvel hero\"));\n        builders.add(client().prepareIndex(\"test\", \"test\", \"theother\").setSource(\n                \"full_name\", \"marvel hero\",\n                \"first_name\", \"marvel\",\n                \"last_name\", \"hero\",\n                \"category\", \"bogus\"));\n\n        builders.add(client().prepareIndex(\"test\", \"test\", \"ultimate1\").setSource(\n                \"full_name\", \"Alpha the Ultimate Mutant\",\n                \"first_name\", \"Alpha the\",\n                \"last_name\", \"Ultimate Mutant\",\n                \"category\", \"marvel hero\"));\n        builders.add(client().prepareIndex(\"test\", \"test\", \"ultimate2\").setSource(\n                \"full_name\", \"Man the Ultimate Ninja\",\n                \"first_name\", \"Man the Ultimate\",\n                \"last_name\", \"Ninja\",\n                \"category\", \"marvel hero\"));\n\n        builders.add(client().prepareIndex(\"test\", \"test\", \"anotherhero\").setSource(\n                \"full_name\", \"ultimate\",\n                \"first_name\", \"wolferine\",\n                \"last_name\", \"\",\n                \"category\", \"marvel hero\"));\n        List<String> firstNames = new ArrayList<String>();\n        fill(firstNames, \"Captain\", between(15, 25));\n        fill(firstNames, \"Ultimate\", between(5, 10));\n        fillRandom(firstNames, between(3, 7));\n        List<String> lastNames = new ArrayList<String>();\n        fill(lastNames, \"Captain\", between(3, 7));\n        fillRandom(lastNames, between(30, 40));\n        for (int i = 0; i < numDocs; i++) {\n            String first = RandomPicks.randomFrom(getRandom(), firstNames);\n            String last = randomPickExcept(lastNames, first);\n            builders.add(client().prepareIndex(\"test\", \"test\", \"\" + i).setSource(\n                    \"full_name\", first + \" \" + last,\n                    \"first_name\", first,\n                    \"last_name\", last,\n                    \"category\", randomBoolean() ? \"marvel hero\" : \"bogus\"));\n        }\n        indexRandom(true, builders);\n    }","id":29242,"modified_method":"@Before\n    public void init() throws Exception {\n        CreateIndexRequestBuilder builder = prepareCreate(\"test\").setSettings(settingsBuilder()\n                .put(SETTING_NUMBER_OF_SHARDS, 1)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .put(\"index.analysis.analyzer.perfect_match.type\", \"custom\")\n                .put(\"index.analysis.analyzer.perfect_match.tokenizer\", \"keyword\")\n                .put(\"index.analysis.analyzer.perfect_match.filter\", \"lowercase\")\n                .put(\"index.analysis.analyzer.category.type\", \"custom\")\n                .put(\"index.analysis.analyzer.category.tokenizer\", \"whitespace\")\n                .put(\"index.analysis.analyzer.category.filter\", \"lowercase\")\n        );\n        assertAcked(builder.addMapping(\"test\", createMapping()));\n        ensureGreen();\n        int numDocs = atLeast(50);\n        List<IndexRequestBuilder> builders = new ArrayList<IndexRequestBuilder>();\n        builders.add(client().prepareIndex(\"test\", \"test\", \"theone\").setSource(\n                \"full_name\", \"Captain America\",\n                \"first_name\", \"Captain\",\n                \"last_name\", \"America\",\n                \"category\", \"marvel hero\",\n                \"skill\", 15,\n                \"int-field\", 25));\n        builders.add(client().prepareIndex(\"test\", \"test\", \"theother\").setSource(\n                \"full_name\", \"marvel hero\",\n                \"first_name\", \"marvel\",\n                \"last_name\", \"hero\",\n                \"category\", \"bogus\",\n                \"skill\", 5));\n\n        builders.add(client().prepareIndex(\"test\", \"test\", \"ultimate1\").setSource(\n                \"full_name\", \"Alpha the Ultimate Mutant\",\n                \"first_name\", \"Alpha the\",\n                \"last_name\", \"Ultimate Mutant\",\n                \"category\", \"marvel hero\",\n                \"skill\", 1));\n        builders.add(client().prepareIndex(\"test\", \"test\", \"ultimate2\").setSource(\n                \"full_name\", \"Man the Ultimate Ninja\",\n                \"first_name\", \"Man the Ultimate\",\n                \"last_name\", \"Ninja\",\n                \"category\", \"marvel hero\",\n                \"skill\", 3));\n\n        builders.add(client().prepareIndex(\"test\", \"test\", \"anotherhero\").setSource(\n                \"full_name\", \"ultimate\",\n                \"first_name\", \"wolferine\",\n                \"last_name\", \"\",\n                \"category\", \"marvel hero\",\n                \"skill\", 1));\n        List<String> firstNames = new ArrayList<String>();\n        fill(firstNames, \"Captain\", between(15, 25));\n        fill(firstNames, \"Ultimate\", between(5, 10));\n        fillRandom(firstNames, between(3, 7));\n        List<String> lastNames = new ArrayList<String>();\n        fill(lastNames, \"Captain\", between(3, 7));\n        fillRandom(lastNames, between(30, 40));\n        for (int i = 0; i < numDocs; i++) {\n            String first = RandomPicks.randomFrom(getRandom(), firstNames);\n            String last = randomPickExcept(lastNames, first);\n            builders.add(client().prepareIndex(\"test\", \"test\", \"\" + i).setSource(\n                    \"full_name\", first + \" \" + last,\n                    \"first_name\", first,\n                    \"last_name\", last,\n                    \"category\", randomBoolean() ? \"marvel hero\" : \"bogus\",\n                    \"skill\", between(1, 3)));\n        }\n        indexRandom(true, builders);\n    }","commit_id":"162ca993762ffb5f720ae7f82adcc209d16a5bd2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testEquivalence() {\n\n        final int numDocs = (int) client().prepareCount(\"test\")\n                .setQuery(matchAllQuery()).get().getCount();\n        int numIters = atLeast(5);\n        for (int i = 0; i < numIters; i++) {\n            {\n                MatchQueryBuilder.Type type = randomBoolean() ? null : MatchQueryBuilder.Type.BOOLEAN;\n                SearchResponse left = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                                .operator(MatchQueryBuilder.Operator.OR).type(type)).get();\n\n                SearchResponse right = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(disMaxQuery().\n                                add(matchQuery(\"full_name\", \"marvel hero captain america\"))\n                                .add(matchQuery(\"first_name\", \"marvel hero captain america\"))\n                                .add(matchQuery(\"last_name\", \"marvel hero captain america\"))\n                                .add(matchQuery(\"category\", \"marvel hero captain america\"))\n                        ).get();\n                assertEquivalent(\"marvel hero captain america\", left, right);\n            }\n\n            {\n                MatchQueryBuilder.Type type = randomBoolean() ? null : MatchQueryBuilder.Type.BOOLEAN;\n                String minShouldMatch = randomBoolean() ? null : \"\" + between(0, 1);\n                MatchQueryBuilder.Operator op = randomBoolean() ? MatchQueryBuilder.Operator.AND : MatchQueryBuilder.Operator.OR;\n                SearchResponse left = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                                .operator(op).useDisMax(false).minimumShouldMatch(minShouldMatch).type(type)).get();\n\n                SearchResponse right = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(boolQuery().minimumShouldMatch(minShouldMatch)\n                                .should(randomBoolean() ? termQuery(\"full_name\", \"captain america\") : matchQuery(\"full_name\", \"captain america\").operator(op))\n                                .should(matchQuery(\"first_name\", \"captain america\").operator(op))\n                                .should(matchQuery(\"last_name\", \"captain america\").operator(op))\n                                .should(matchQuery(\"category\", \"captain america\").operator(op))\n                        ).get();\n                assertEquivalent(\"captain america\", left, right);\n            }\n\n            {\n                String minShouldMatch = randomBoolean() ? null : \"\" + between(0, 1);\n                MatchQueryBuilder.Operator op = randomBoolean() ? MatchQueryBuilder.Operator.AND : MatchQueryBuilder.Operator.OR;\n                SearchResponse left = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(multiMatchQuery(\"capta\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                                .type(MatchQueryBuilder.Type.PHRASE_PREFIX).useDisMax(false).minimumShouldMatch(minShouldMatch)).get();\n\n                SearchResponse right = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(boolQuery().minimumShouldMatch(minShouldMatch)\n                                .should(matchPhrasePrefixQuery(\"full_name\", \"capta\"))\n                                .should(matchPhrasePrefixQuery(\"first_name\", \"capta\").operator(op))\n                                .should(matchPhrasePrefixQuery(\"last_name\", \"capta\").operator(op))\n                                .should(matchPhrasePrefixQuery(\"category\", \"capta\").operator(op))\n                        ).get();\n                assertEquivalent(\"capta\", left, right);\n            }\n            {\n                String minShouldMatch = randomBoolean() ? null : \"\" + between(0, 1);\n                MatchQueryBuilder.Operator op = randomBoolean() ? MatchQueryBuilder.Operator.AND : MatchQueryBuilder.Operator.OR;\n                SearchResponse left = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                                .type(MatchQueryBuilder.Type.PHRASE).useDisMax(false).minimumShouldMatch(minShouldMatch)).get();\n\n                SearchResponse right = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(boolQuery().minimumShouldMatch(minShouldMatch)\n                                .should(matchPhraseQuery(\"full_name\", \"captain america\"))\n                                .should(matchPhraseQuery(\"first_name\", \"captain america\").operator(op))\n                                .should(matchPhraseQuery(\"last_name\", \"captain america\").operator(op))\n                                .should(matchPhraseQuery(\"category\", \"captain america\").operator(op))\n                        ).get();\n                assertEquivalent(\"captain america\", left, right);\n            }\n        }\n    }","id":29243,"modified_method":"@Test\n    public void testEquivalence() {\n\n        final int numDocs = (int) client().prepareCount(\"test\")\n                .setQuery(matchAllQuery()).get().getCount();\n        int numIters = atLeast(5);\n        for (int i = 0; i < numIters; i++) {\n            {\n                MatchQueryBuilder.Type type = randomBoolean() ? null : MatchQueryBuilder.Type.BOOLEAN;\n                MultiMatchQueryBuilder multiMatchQueryBuilder = randomBoolean() ? multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\") :\n                        multiMatchQuery(\"marvel hero captain america\", \"*_name\", randomBoolean() ? \"category\" : \"categ*\");\n                SearchResponse left = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(randomizeType(multiMatchQueryBuilder\n                                .operator(MatchQueryBuilder.Operator.OR).type(type))).get();\n\n                SearchResponse right = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(disMaxQuery().\n                                add(matchQuery(\"full_name\", \"marvel hero captain america\"))\n                                .add(matchQuery(\"first_name\", \"marvel hero captain america\"))\n                                .add(matchQuery(\"last_name\", \"marvel hero captain america\"))\n                                .add(matchQuery(\"category\", \"marvel hero captain america\"))\n                        ).get();\n                assertEquivalent(\"marvel hero captain america\", left, right);\n            }\n\n            {\n                MatchQueryBuilder.Type type = randomBoolean() ? null : MatchQueryBuilder.Type.BOOLEAN;\n                String minShouldMatch = randomBoolean() ? null : \"\" + between(0, 1);\n                MatchQueryBuilder.Operator op = randomBoolean() ? MatchQueryBuilder.Operator.AND : MatchQueryBuilder.Operator.OR;\n                MultiMatchQueryBuilder multiMatchQueryBuilder = randomBoolean() ? multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\") :\n                        multiMatchQuery(\"captain america\", \"*_name\", randomBoolean() ? \"category\" : \"categ*\");\n                SearchResponse left = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(randomizeType(multiMatchQueryBuilder\n                                .operator(op).useDisMax(false).minimumShouldMatch(minShouldMatch).type(type))).get();\n\n                SearchResponse right = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(boolQuery().minimumShouldMatch(minShouldMatch)\n                                .should(randomBoolean() ? termQuery(\"full_name\", \"captain america\") : matchQuery(\"full_name\", \"captain america\").operator(op))\n                                .should(matchQuery(\"first_name\", \"captain america\").operator(op))\n                                .should(matchQuery(\"last_name\", \"captain america\").operator(op))\n                                .should(matchQuery(\"category\", \"captain america\").operator(op))\n                        ).get();\n                assertEquivalent(\"captain america\", left, right);\n            }\n\n            {\n                String minShouldMatch = randomBoolean() ? null : \"\" + between(0, 1);\n                MatchQueryBuilder.Operator op = randomBoolean() ? MatchQueryBuilder.Operator.AND : MatchQueryBuilder.Operator.OR;\n                SearchResponse left = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(randomizeType(multiMatchQuery(\"capta\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                                .type(MatchQueryBuilder.Type.PHRASE_PREFIX).useDisMax(false).minimumShouldMatch(minShouldMatch))).get();\n\n                SearchResponse right = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(boolQuery().minimumShouldMatch(minShouldMatch)\n                                .should(matchPhrasePrefixQuery(\"full_name\", \"capta\"))\n                                .should(matchPhrasePrefixQuery(\"first_name\", \"capta\").operator(op))\n                                .should(matchPhrasePrefixQuery(\"last_name\", \"capta\").operator(op))\n                                .should(matchPhrasePrefixQuery(\"category\", \"capta\").operator(op))\n                        ).get();\n                assertEquivalent(\"capta\", left, right);\n            }\n            {\n                String minShouldMatch = randomBoolean() ? null : \"\" + between(0, 1);\n                MatchQueryBuilder.Operator op = randomBoolean() ? MatchQueryBuilder.Operator.AND : MatchQueryBuilder.Operator.OR;\n                SearchResponse left;\n                if (randomBoolean()) {\n                    left = client().prepareSearch(\"test\").setSize(numDocs)\n                            .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                                    .type(MatchQueryBuilder.Type.PHRASE).useDisMax(false).minimumShouldMatch(minShouldMatch))).get();\n                } else {\n                    left = client().prepareSearch(\"test\").setSize(numDocs)\n                            .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                                    .type(MatchQueryBuilder.Type.PHRASE).tieBreaker(1.0f).minimumShouldMatch(minShouldMatch))).get();\n                }\n                SearchResponse right = client().prepareSearch(\"test\").setSize(numDocs)\n                        .setQuery(boolQuery().minimumShouldMatch(minShouldMatch)\n                                .should(matchPhraseQuery(\"full_name\", \"captain america\"))\n                                .should(matchPhraseQuery(\"first_name\", \"captain america\").operator(op))\n                                .should(matchPhraseQuery(\"last_name\", \"captain america\").operator(op))\n                                .should(matchPhraseQuery(\"category\", \"captain america\").operator(op))\n                        ).get();\n                assertEquivalent(\"captain america\", left, right);\n            }\n        }\n    }","commit_id":"162ca993762ffb5f720ae7f82adcc209d16a5bd2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void initTemplateModels() {\n    assert myGenerationStepController == null : \"method can't be used with 'auto-plan' generation\";\n\n    myTemplateModels = new ArrayList<SModelDescriptor>();\n    for (Generator generatorModule : myGeneratorModules) {\n      List<SModelDescriptor> templateModels = generatorModule.getOwnTemplateModels();\n      CollectionUtil.addAllNotPresent(templateModels, myTemplateModels);\n    }\n\n    if (myCustomMappingConfigurations != null) {\n      myMappingConfigurations = new HashSet<MappingConfiguration>(myCustomMappingConfigurations);\n    } else {\n      myMappingConfigurations = new HashSet<MappingConfiguration>();\n      for (SModelDescriptor templateModel : myTemplateModels) {\n        myMappingConfigurations.addAll(templateModel.getSModel().allAdapters(MappingConfiguration.class));\n      }\n    }\n  }","id":29244,"modified_method":"private void initTemplateModels() {\n    assert myGenerationStepController == null : \"method can't be used with 'auto-plan' generation\";\n\n    myTemplateModels = new ArrayList<SModelDescriptor>();\n    for (Generator generatorModule : myGeneratorModules) {\n      List<SModelDescriptor> templateModels = generatorModule.getOwnTemplateModels();\n      CollectionUtil.addAllNotPresent(templateModels, myTemplateModels);\n    }\n\n    if (myCustomMappingConfigurations != null) {\n      myMappingConfigurations = new LinkedHashSet<MappingConfiguration>(myCustomMappingConfigurations);\n    } else {\n      myMappingConfigurations = new LinkedHashSet<MappingConfiguration>();\n      for (SModelDescriptor templateModel : myTemplateModels) {\n        myMappingConfigurations.addAll(templateModel.getSModel().allAdapters(MappingConfiguration.class));\n      }\n    }\n  }","commit_id":"c0cfa0987545ca58d59707fcefbb579f6146014d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void updateGenerationStepData(GenerationStepController generationStepController) {\n    myGenerationStepController = generationStepController;\n    myGeneratorModules = myGenerationStepController.getGenerators();\n    myTemplateModels = myGenerationStepController.getTemplateModels();\n    myMappingConfigurations = CollectionUtil.listAsSet(myGenerationStepController.getMappings());\n    myTransientModule.addGeneratorModules(myGeneratorModules);\n  }","id":29245,"modified_method":"public void updateGenerationStepData(GenerationStepController generationStepController) {\n    myGenerationStepController = generationStepController;\n    myGeneratorModules = myGenerationStepController.getGenerators();\n    myTemplateModels = myGenerationStepController.getTemplateModels();\n    myMappingConfigurations = new LinkedHashSet<MappingConfiguration>(myGenerationStepController.getMappings());\n    myTransientModule.addGeneratorModules(myGeneratorModules);\n  }","commit_id":"c0cfa0987545ca58d59707fcefbb579f6146014d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public GenerationSessionContext(Language targetLanguage,\n                                  SModel inputModel,\n                                  IOperationContext invocationContext,\n                                  Set<MappingConfiguration> configs,\n                                  GenerationSessionContext prevContext) {\n\n\n    myTargetLanguage = targetLanguage;\n    myInvocationContext = invocationContext;\n    myCustomMappingConfigurations = null;\n\n    if (targetLanguage == null) {\n      // auto-plan\n      myGenerationStepController = new GenerationStepController(inputModel);\n      myGeneratorModules = myGenerationStepController.getGenerators();\n      myTemplateModels = myGenerationStepController.getTemplateModels();\n      myMappingConfigurations = CollectionUtil.listAsSet(myGenerationStepController.getMappings());\n    } else {\n      // old\n      myGeneratorModules = getUsedGenerators(inputModel);\n      if (configs != null) {\n        myCustomMappingConfigurations = new LinkedHashSet<MappingConfiguration>(configs);\n      }\n      initTemplateModels();\n    }\n\n    myTransientModule = new TransientModule(invocationContext.getModule(), myGeneratorModules);\n    if (prevContext != null) {\n      myTransientModule.addDependency(prevContext.getModule());\n    }\n  }","id":29246,"modified_method":"public GenerationSessionContext(Language targetLanguage,\n                                  SModel inputModel,\n                                  IOperationContext invocationContext,\n                                  Set<MappingConfiguration> configs,\n                                  GenerationSessionContext prevContext) {\n\n\n    myTargetLanguage = targetLanguage;\n    myInvocationContext = invocationContext;\n    myCustomMappingConfigurations = null;\n\n    if (targetLanguage == null) {\n      // auto-plan\n      myGenerationStepController = new GenerationStepController(inputModel);\n      myGeneratorModules = myGenerationStepController.getGenerators();\n      myTemplateModels = myGenerationStepController.getTemplateModels();\n      myMappingConfigurations = new LinkedHashSet<MappingConfiguration>(myGenerationStepController.getMappings());\n    } else {\n      // old\n      myGeneratorModules = getUsedGenerators(inputModel);\n      if (configs != null) {\n        myCustomMappingConfigurations = new LinkedHashSet<MappingConfiguration>(configs);\n      }\n      initTemplateModels();\n    }\n\n    myTransientModule = new TransientModule(invocationContext.getModule(), myGeneratorModules);\n    if (prevContext != null) {\n      myTransientModule.addDependency(prevContext.getModule());\n    }\n  }","commit_id":"c0cfa0987545ca58d59707fcefbb579f6146014d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public synchronized Collection<AbstractMapping> addHttpContext(Bundle bundle, String contextId, HttpContext context)\n    {\n        String id = createId(bundle, contextId);\n        HttpContextHolder holder = new HttpContextHolder(context);\n\n        Set<AbstractMapping> orphans = this.orphanMappings.remove(contextId);\n        if (orphans != null)\n        {\n            for (Iterator<AbstractMapping> mi = orphans.iterator(); mi.hasNext();)\n            {\n                AbstractMapping mapping = mi.next();\n                if (bundle == null || bundle.equals(mapping.getBundle()))\n                {\n                    holder.addMapping(mapping);\n                    mi.remove();\n                }\n            }\n\n            // put any remaining orphans back\n            if (!orphans.isEmpty())\n            {\n                this.orphanMappings.put(contextId, orphans);\n            }\n        }\n\n        this.idMap.put(id, holder);\n        this.contextMap.put(context, id);\n\n        return holder.getMappings();\n    }","id":29247,"modified_method":"public synchronized Collection<AbstractMapping> addHttpContext(Bundle bundle, String contextId, HttpContext context)\n    {\n        String id = createId(bundle, contextId);\n        HttpContextHolder holder = new HttpContextHolder(context);\n\n        Set<AbstractMapping> orphans = this.orphanMappings.remove(contextId);\n        if (orphans != null)\n        {\n            for (Iterator<AbstractMapping> mi = orphans.iterator(); mi.hasNext();)\n            {\n                AbstractMapping mapping = mi.next();\n                if (bundle == null || bundle.equals(mapping.getBundle()))\n                {\n                    holder.addMapping(mapping);\n                    mi.remove();\n                }\n            }\n\n            // put any remaining orphans back\n            if (!orphans.isEmpty())\n            {\n                this.orphanMappings.put(contextId, orphans);\n            }\n        }\n\n        this.idMap.put(id, holder);\n        this.contextMap.put(context, id);\n        \n        // return a copy to prevent concurrent modification\n        return new HashSet<AbstractMapping>(holder.getMappings());\n    }","commit_id":"db2e295826f1619504c2f15a4196344a224f278b","url":"https://github.com/apache/felix"},{"original_method":"public CoreEnvironment(Disposable parentDisposable) {\n    Extensions.cleanRootArea(parentDisposable);\n\n    myFileTypeRegistry = new CoreFileTypeRegistry();\n    myEncodingRegistry = new CoreEncodingRegistry();\n\n    myApplication = new MockApplication(parentDisposable);\n    if (ApplicationManager.getApplication() == null) {\n      ApplicationManager.setApplication(myApplication,\n                                        new StaticGetter<FileTypeRegistry>(myFileTypeRegistry),\n                                        new StaticGetter<EncodingRegistry>(myEncodingRegistry),\n                                        parentDisposable);\n    }\n    myLocalFileSystem = new CoreLocalFileSystem();\n    myJarFileSystem = new CoreJarFileSystem();\n\n    Extensions.registerAreaClass(\"IDEA_PROJECT\", null);\n    myProject = new MockProject(myApplication.getPicoContainer(), parentDisposable);\n\n    final MutablePicoContainer appContainer = myApplication.getPicoContainer();\n    registerComponentInstance(appContainer, FileDocumentManager.class, new MockFileDocumentManagerImpl(new Function<CharSequence, Document>() {\n      @Override\n      public Document fun(CharSequence charSequence) {\n        return new DocumentImpl(charSequence);\n      }\n    }, null));\n\n    registerComponentInstance(appContainer, VirtualFileManager.class,\n                              new VirtualFileManagerImpl(new VirtualFileSystem[] {myLocalFileSystem, myJarFileSystem},\n                                                         new MessageBusImpl(myApplication, null),\n                                                         new FileSystemPersistence() {\n                                                           @Override\n                                                           public void refresh(boolean asynchronous, Runnable postAction, ModalityState modalityState) {\n                                                           }\n\n                                                           @Override\n                                                           public int getCheapFileSystemModificationCount() {\n                                                             return 0;\n                                                           }\n                                                         }\n                              )\n    );\n\n    myApplication.registerService(DefaultASTFactory.class, new CoreASTFactory());\n    myApplication.registerService(PsiBuilderFactory.class, new PsiBuilderFactoryImpl());\n    myApplication.registerService(ReferenceProvidersRegistry.class, new MockReferenceProvidersRegistry());\n    myApplication.registerService(StubTreeLoader.class, new CoreStubTreeLoader());\n\n    registerExtensionPoint(Extensions.getRootArea(), ContentBasedFileSubstitutor.EP_NAME, ContentBasedFileSubstitutor.class);\n    registerExtensionPoint(Extensions.getRootArea(), BinaryFileStubBuilders.EP_NAME, FileTypeExtensionPoint.class);\n\n    myFileIndexFacade = new MockFileIndexFacade(myProject);\n    final MutablePicoContainer projectContainer = myProject.getPicoContainer();\n\n    PsiModificationTrackerImpl modificationTracker = new PsiModificationTrackerImpl(myProject);\n    myProject.registerService(PsiModificationTracker.class, modificationTracker);\n    myProject.registerService(FileIndexFacade.class, myFileIndexFacade);\n    myProject.registerService(ResolveScopeManager.class, new MockResolveScopeManager(myProject));\n    myProject.registerService(ResolveCache.class, new ResolveCache(null));\n    \n    registerProjectExtensionPoint(PsiTreeChangePreprocessor.EP_NAME, PsiTreeChangePreprocessor.class);\n    myPsiManager = new PsiManagerImpl(myProject, null, null, myFileIndexFacade, null, modificationTracker);\n    ((FileManagerImpl) myPsiManager.getFileManager()).markInitialized();\n    registerComponentInstance(projectContainer, PsiManager.class, myPsiManager);\n\n    myProject.registerService(PsiFileFactory.class, new PsiFileFactoryImpl(myPsiManager));\n    myProject.registerService(CachedValuesManager.class, new CachedValuesManagerImpl(myProject, new PsiCachedValuesFactory(myPsiManager)));\n    myProject.registerService(PsiDirectoryFactory.class, new PsiDirectoryFactoryImpl(myPsiManager));\n    myProject.registerService(ProjectScopeBuilder.class, new CoreProjectScopeBuilder(myProject, myFileIndexFacade));\n    myProject.registerService(DumbService.class, new MockDumbService(myProject));\n  }","id":29248,"modified_method":"public CoreEnvironment(Disposable parentDisposable) {\n    Extensions.cleanRootArea(parentDisposable);\n\n    myFileTypeRegistry = new CoreFileTypeRegistry();\n    myEncodingRegistry = new CoreEncodingRegistry();\n\n    myApplication = new MockApplication(parentDisposable);\n    ApplicationManager.setApplication(myApplication,\n                                      new StaticGetter<FileTypeRegistry>(myFileTypeRegistry),\n                                      new StaticGetter<EncodingRegistry>(myEncodingRegistry),\n                                      parentDisposable);\n    myLocalFileSystem = new CoreLocalFileSystem();\n    myJarFileSystem = new CoreJarFileSystem();\n\n    Extensions.registerAreaClass(\"IDEA_PROJECT\", null);\n    myProject = new MockProject(myApplication.getPicoContainer(), parentDisposable);\n\n    final MutablePicoContainer appContainer = myApplication.getPicoContainer();\n    registerComponentInstance(appContainer, FileDocumentManager.class, new MockFileDocumentManagerImpl(new Function<CharSequence, Document>() {\n      @Override\n      public Document fun(CharSequence charSequence) {\n        return new DocumentImpl(charSequence);\n      }\n    }, null));\n\n    registerComponentInstance(appContainer, VirtualFileManager.class,\n                              new VirtualFileManagerImpl(new VirtualFileSystem[] {myLocalFileSystem, myJarFileSystem},\n                                                         new MessageBusImpl(myApplication, null),\n                                                         new FileSystemPersistence() {\n                                                           @Override\n                                                           public void refresh(boolean asynchronous, Runnable postAction, ModalityState modalityState) {\n                                                           }\n\n                                                           @Override\n                                                           public int getCheapFileSystemModificationCount() {\n                                                             return 0;\n                                                           }\n                                                         }\n                              )\n    );\n\n    myApplication.registerService(DefaultASTFactory.class, new CoreASTFactory());\n    myApplication.registerService(PsiBuilderFactory.class, new PsiBuilderFactoryImpl());\n    myApplication.registerService(ReferenceProvidersRegistry.class, new MockReferenceProvidersRegistry());\n    myApplication.registerService(StubTreeLoader.class, new CoreStubTreeLoader());\n\n    registerExtensionPoint(Extensions.getRootArea(), ContentBasedFileSubstitutor.EP_NAME, ContentBasedFileSubstitutor.class);\n    registerExtensionPoint(Extensions.getRootArea(), BinaryFileStubBuilders.EP_NAME, FileTypeExtensionPoint.class);\n\n    myFileIndexFacade = new MockFileIndexFacade(myProject);\n    final MutablePicoContainer projectContainer = myProject.getPicoContainer();\n\n    PsiModificationTrackerImpl modificationTracker = new PsiModificationTrackerImpl(myProject);\n    myProject.registerService(PsiModificationTracker.class, modificationTracker);\n    myProject.registerService(FileIndexFacade.class, myFileIndexFacade);\n    myProject.registerService(ResolveScopeManager.class, new MockResolveScopeManager(myProject));\n    myProject.registerService(ResolveCache.class, new ResolveCache(null));\n    \n    registerProjectExtensionPoint(PsiTreeChangePreprocessor.EP_NAME, PsiTreeChangePreprocessor.class);\n    myPsiManager = new PsiManagerImpl(myProject, null, null, myFileIndexFacade, null, modificationTracker);\n    ((FileManagerImpl) myPsiManager.getFileManager()).markInitialized();\n    registerComponentInstance(projectContainer, PsiManager.class, myPsiManager);\n\n    myProject.registerService(PsiFileFactory.class, new PsiFileFactoryImpl(myPsiManager));\n    myProject.registerService(CachedValuesManager.class, new CachedValuesManagerImpl(myProject, new PsiCachedValuesFactory(myPsiManager)));\n    myProject.registerService(PsiDirectoryFactory.class, new PsiDirectoryFactoryImpl(myPsiManager));\n    myProject.registerService(ProjectScopeBuilder.class, new CoreProjectScopeBuilder(myProject, myFileIndexFacade));\n    myProject.registerService(DumbService.class, new MockDumbService(myProject));\n  }","commit_id":"46cfd05608dec63b5e7ce6263f91848bfb624069","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Add an application class to the class hierarchy graph.\n\t * To the extent possible, supertype vertices are also added.\n\t * \n\t * @param appClass the application class\n\t */\n\tprivate void addToClassHierarchyGraph(JavaClass appClass) {\n\t\tLinkedList<WorkListItem> workList = new LinkedList<WorkListItem>();\n\t\tworkList.add(new WorkListItem(appClass));\n\t\t\n\t\twhile (!workList.isEmpty()) {\n\t\t\tWorkListItem item = workList.removeFirst();\n\t\t\tClassHierarchyGraphVertex vertex = classHierarchyGraph.lookupVertex(item.getClassName());\n\t\t\t\n\t\t\tif (vertex == null) {\n\t\t\t\tvertex = classHierarchyGraph.addVertex(item.getClassName(), item.getVertexType());\n\t\t\t} else if (vertex.isFinished() && !item.isApplication()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tJavaClass javaClass = null;\n\t\t\t\n\t\t\t// Figure out whether or not this is an application class,\n\t\t\t// and whether it can be found in the repository or on the classpath.\n\t\t\tif (item.isApplication()) {\n\t\t\t\tvertex.setApplication(true);\n\t\t\t\tvertex.setMissing(false);\n\t\t\t\tvertex.setFinished(true); // This vertex is now authoritative\n\t\t\t\tjavaClass = item.getJavaClass();\n\t\t\t} else {\n\t\t\t\tvertex.setApplication(false);\n\t\t\t\ttry {\n\t\t\t\t\tjavaClass = Repository.lookupClass(item.getClassName());\n\t\t\t\t\tvertex.setMissing(false);\n\t\t\t\t\tvertex.setFinished(true); // This vertex is now authoritative\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\tlookupFailureCallback.reportMissingClass(e);\n\t\t\t\t\tvertex.setMissing(true);\n\t\t\t\t\t// We might see this class or interface later, so\n\t\t\t\t\t// for now leave it unfinished\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Create inheritance edge\n\t\t\tif (item.getSubType() != null) {\n\t\t\t\tclassHierarchyGraph.createEdge(item.getSubType(), vertex);\n\t\t\t}\n\t\t\t\n\t\t\t// If we know the representation of this type,\n\t\t\t// add superclasses and superinterfaces\n\t\t\tif (javaClass != null) {\n\t\t\t\tString superclassName = javaClass.getSuperclassName();\n\t\t\t\tif (superclassName != null) {\n\t\t\t\t\tworkList.add(new WorkListItem(\n\t\t\t\t\t\t\tsuperclassName,\n\t\t\t\t\t\t\tClassHierarchyGraphVertexType.CLASS_VERTEX,\n\t\t\t\t\t\t\tvertex));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tString[] interfaceNameList = javaClass.getInterfaceNames();\n\t\t\t\tfor (int i = 0; i < interfaceNameList.length; ++i) {\n\t\t\t\t\tworkList.add(new WorkListItem(\n\t\t\t\t\t\t\tinterfaceNameList[i],\n\t\t\t\t\t\t\tClassHierarchyGraphVertexType.INTERFACE_VERTEX,\n\t\t\t\t\t\t\tvertex));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":29249,"modified_method":"/**\n\t * Add an application class to the class hierarchy graph.\n\t * To the extent possible, supertype vertices are also added.\n\t * \n\t * @param appClass the application class\n\t */\n\tprivate void addToClassHierarchyGraph(JavaClass appClass) {\n\t\tif (DEBUG_HIERARCHY) {\n\t\t\tSystem.out.println(\"Adding application class: \" + appClass.getClassName());\n\t\t}\n\t\t\n\t\tLinkedList<WorkListItem> workList = new LinkedList<WorkListItem>();\n\t\tworkList.add(new WorkListItem(appClass));\n\t\t\n\t\twhile (!workList.isEmpty()) {\n\t\t\tWorkListItem item = workList.removeFirst();\n\n\t\t\tClassHierarchyGraphVertex vertex = classHierarchyGraph.addVertex(\n\t\t\t\t\titem.getClassName(), item.getVertexType());\n\t\t\tif (item.isApplication())\n\t\t\t\tvertex.setApplication(true);\n\t\t\t\n\t\t\tif (item.getSubType() != null) {\n\t\t\t\tif (DEBUG_HIERARCHY) {\n\t\t\t\t\tSystem.out.println(\"Class hierarchy graph edge: \" +\n\t\t\t\t\t\t\titem.getSubType().getClassName() +\n\t\t\t\t\t\t\t\" -> \" +\n\t\t\t\t\t\t\tvertex.getClassName());\n\t\t\t\t}\n\t\t\t\tclassHierarchyGraph.createEdge(item.getSubType(), vertex);\n\t\t\t}\n\t\t\t\n\t\t\tif (vertex.isFinished()) {\n\t\t\t\t// Visited this guy's superclasses/superinterfaces already\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Find the representation of this class or interface in order\n\t\t\t// to find superclasses/superinterfaces\n\t\t\tJavaClass javaClass = item.getJavaClass();\n\t\t\tif (javaClass == null) {\n\t\t\t\ttry {\n\t\t\t\t\tjavaClass = Repository.lookupClass(item.getClassName());\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\tvertex.setMissing(true);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add superclass/superinterface edges\n\t\t\tString superclassName = javaClass.getSuperclassName();\n\t\t\tif (superclassName != null) {\n\t\t\t\tworkList.add(new WorkListItem(\n\t\t\t\t\t\tsuperclassName,\n\t\t\t\t\t\tClassHierarchyGraphVertexType.CLASS_VERTEX,\n\t\t\t\t\t\tvertex));\n\t\t\t}\n\t\t\t\n\t\t\tString[] interfaceNameList = javaClass.getInterfaceNames();\n\t\t\tfor (int i = 0; i < interfaceNameList.length; ++i) {\n\t\t\t\tworkList.add(new WorkListItem(\n\t\t\t\t\t\tinterfaceNameList[i],\n\t\t\t\t\t\tClassHierarchyGraphVertexType.INTERFACE_VERTEX,\n\t\t\t\t\t\tvertex));\n\t\t\t}\n\n\t\t\t// Now this vertex will have its superclass/superinterface edges discovered\n\t\t\tvertex.setFinished(true);\n\t\t}\n\t}","commit_id":"041ec7a3e5d713178c9b690257da2eef278d0537","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Post an event to all pages that have a suspended connection. This will invoke the event\n\t * handlers on components, annotated with {@link Subscribe}. The resulting AJAX updates are\n\t * pushed to the clients.\n\t * \n\t * @param event\n\t */\n\tpublic void post(Object event)\n\t{\n\t\tThreadContext oldContext = ThreadContext.get(false);\n\t\ttry\n\t\t{\n\t\t\tThreadContext.restore(null);\n\t\t\tThreadContext.setApplication(application);\n\t\t\tfor (AtmosphereResource resource : broadcaster.getAtmosphereResources())\n\t\t\t{\n\t\t\t\tPageKey key;\n\t\t\t\tCollection<EventSubscription> subscriptionsForPage;\n\t\t\t\tsynchronized (this)\n\t\t\t\t{\n\t\t\t\t\tkey = trackedPages.get(AtmosphereBehavior.getUUID(resource));\n\t\t\t\t\tsubscriptionsForPage = Collections2.filter(\n\t\t\t\t\t\tCollections.unmodifiableCollection(subscriptions.get(key)),\n\t\t\t\t\t\tnew EventFilter(event));\n\t\t\t\t}\n\t\t\t\tif (key == null)\n\t\t\t\t\tbroadcaster.removeAtmosphereResource(resource);\n\t\t\t\telse\n\t\t\t\t\tpost(resource, key, subscriptionsForPage, event);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tThreadContext.detach();\n\t\t\tif (oldContext != null)\n\t\t\t\tThreadContext.restore(oldContext);\n\t\t}\n\t}","id":29250,"modified_method":"/**\n\t * Post an event to all pages that have a suspended connection. This will invoke the event\n\t * handlers on components, annotated with {@link Subscribe}. The resulting AJAX updates are\n\t * pushed to the clients.\n\t * \n\t * @param event\n\t */\n\tpublic void post(Object event)\n\t{\n\t\tThreadContext oldContext = ThreadContext.get(false);\n\t\ttry\n\t\t{\n\t\t\tfor (AtmosphereResource resource : broadcaster.getAtmosphereResources())\n\t\t\t{\n\t\t\t\tThreadContext.detach();\n\t\t\t\tThreadContext.setApplication(application);\n\t\t\t\tPageKey key;\n\t\t\t\tCollection<EventSubscription> subscriptionsForPage;\n\t\t\t\tsynchronized (this)\n\t\t\t\t{\n\t\t\t\t\tkey = trackedPages.get(AtmosphereBehavior.getUUID(resource));\n\t\t\t\t\tsubscriptionsForPage = Collections2.filter(\n\t\t\t\t\t\tCollections.unmodifiableCollection(subscriptions.get(key)),\n\t\t\t\t\t\tnew EventFilter(event));\n\t\t\t\t}\n\t\t\t\tif (key == null)\n\t\t\t\t\tbroadcaster.removeAtmosphereResource(resource);\n\t\t\t\telse\n\t\t\t\t\tpost(resource, key, subscriptionsForPage, event);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tThreadContext.restore(oldContext);\n\t\t}\n\t}","commit_id":"4da8399a66c7eb47407d05d6e3ff7fc01e1b8a9c","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n    public void map (Chunk[]cs){\n      if (!_createFrame.randomize) return;\n      final Random rng = new Random();\n\n      // response\n      for (int r = 0; r < cs[0]._len; r++) {\n        setSeed(rng, 0, cs[0]._start + r);\n        if (_createFrame.response_factors >1)\n          cs[0].set0(r, (int)(rng.nextDouble() * _createFrame.response_factors)); //classification\n        else\n          cs[0].set0(r, _createFrame.real_range * (1 - 2 * rng.nextDouble())); //regression\n      }\n\n      for (int c : _cat_cols) {\n        for (int r = 0; r < cs[c]._len; r++) {\n          setSeed(rng, c, cs[c]._start + r);\n          cs[c].set0(r, (int)(rng.nextDouble() * _createFrame.factors));\n        }\n      }\n      for (int c : _int_cols) {\n        for (int r = 0; r < cs[c]._len; r++) {\n          setSeed(rng, c, cs[c]._start + r);\n          cs[c].set0(r, (long) ((_createFrame.integer_range+1) * (1 - 2 * rng.nextDouble())));\n        }\n      }\n      for (int c : _real_cols) {\n        for (int r = 0; r < cs[c]._len; r++) {\n          setSeed(rng, c, cs[c]._start + r);\n          cs[c].set0(r, _createFrame.real_range * (1 - 2 * rng.nextDouble()));\n        }\n      }\n    }","id":29251,"modified_method":"@Override\n    public void map (Chunk[]cs){\n      if (!_createFrame.randomize) return;\n      final Random rng = new Random();\n\n      // response\n      for (int r = 0; r < cs[0]._len; r++) {\n        setSeed(rng, 0, cs[0]._start + r);\n        if (_createFrame.response_factors >1)\n          cs[0].set0(r, (int)(rng.nextDouble() * _createFrame.response_factors)); //classification\n        else if (_createFrame.positive_response)\n          cs[0].set0(r, _createFrame.real_range * rng.nextDouble()); //regression with positive response\n        else\n          cs[0].set0(r, _createFrame.real_range * (1 - 2 * rng.nextDouble())); //regression\n      }\n\n      for (int c : _cat_cols) {\n        for (int r = 0; r < cs[c]._len; r++) {\n          setSeed(rng, c, cs[c]._start + r);\n          cs[c].set0(r, (int)(rng.nextDouble() * _createFrame.factors));\n        }\n      }\n      for (int c : _int_cols) {\n        for (int r = 0; r < cs[c]._len; r++) {\n          setSeed(rng, c, cs[c]._start + r);\n          cs[c].set0(r, (long) ((_createFrame.integer_range+1) * (1 - 2 * rng.nextDouble())));\n        }\n      }\n      for (int c : _real_cols) {\n        for (int r = 0; r < cs[c]._len; r++) {\n          setSeed(rng, c, cs[c]._start + r);\n          cs[c].set0(r, _createFrame.real_range * (1 - 2 * rng.nextDouble()));\n        }\n      }\n    }","commit_id":"2df4d71f820a0f0c4490209c976bb3a5e20eaa5b","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n    public void map(Chunk[] cs) {\n      // find unique interaction domain\n      for (int r = 0; r < cs[0]._len; r++) {\n        final int a = cs[_i].isNA0(r) ? _missing : (int)cs[_i].at80(r);\n        final int b = cs[_j].isNA0(r) ? _missing : (int)cs[_j].at80(r);\n\n        // key: combine both ints into a long\n        final long ab = ((long)a << 32) | (b & 0xFFFFFFFFL);\n        assert a == (int)(ab >> 32);\n        assert b == (int)ab;\n\n        // linear search in sorted array of factor levels (descending by occurrence), should be fastest for most small domains\n        int level = -1;\n        for (int i = 0; i < _keys.length; ++i) {\n          if (ab == _keys[i]) {\n            level = i;\n            break;\n          }\n        }\n        if (level == -1) {\n          level = _fr.lastVec().domain().length-1;\n          assert _fr.lastVec().domain()[level] == _other;\n        }\n\n        cs[cs.length - 1].set0(r, level);\n\n      }\n    }","id":29252,"modified_method":"@Override\n    public void map(Chunk[] cs) {\n      // find unique interaction domain\n      for (int r = 0; r < cs[0]._len; r++) {\n        final int a = cs[_i].isNA0(r) ? _missing : (int)cs[_i].at80(r);\n        long ab;\n        if (_j != _i) {\n          final int b = cs[_j].isNA0(r) ? _missing : (int) cs[_j].at80(r);\n          ab = ((long) a << 32) | (b & 0xFFFFFFFFL); // key: combine both ints into a long\n        } else {\n          ab = (long)a;\n        }\n\n        if (_i == _j && cs[_i].isNA0(r)) {\n          cs[cs.length - 1].setNA0(r);\n        } else {\n          // linear search in sorted array of factor levels (descending by occurrence), should be fastest for most small domains\n          int level = -1;\n          for (int i = 0; i < _keys.length; ++i) {\n            if (ab == _keys[i]) {\n              level = i;\n              break;\n            }\n          }\n          if (level == -1) {\n            level = _fr.lastVec().domain().length-1;\n            assert _fr.lastVec().domain()[level] == _other;\n          }\n          cs[cs.length - 1].set0(r, level);\n        }\n      }\n    }","commit_id":"71d4acb424b55f1537617612d595853567825b84","url":"https://github.com/h2oai/h2o-2"},{"original_method":"protected String[] makeDomain(Map<IcedLong, IcedLong> unsortedMap, int _i, int _j) {\n    String[] _domain;\n    Frame _fr = _out;\n//    Log.info(\"Collected hash table\");\n//    Log.info(java.util.Arrays.deepToString(unsortedMap.entrySet().toArray()));\n\n//    Log.info(\"Interaction between \" + _fr.domains()[_i].length + \" and \" + _fr.domains()[_j].length + \" factor levels => \" +\n//            ((long)_fr.domains()[_i].length * (long)_fr.domains()[_j].length) + \" possible factors.\");\n\n    _sortedMap = mySort(unsortedMap);\n\n    // create domain of the most frequent unique factors\n    long factorCount = 0;\n//    Log.info(\"Found \" + _sortedMap.size() + \" unique interaction factors (out of \" + ((long)_fr.domains()[_i].length * (long)_fr.domains()[_j].length) + \").\");\n    _domain = new String[_sortedMap.size()]; //TODO: use ArrayList here, then convert to array\n    Iterator it2 = _sortedMap.entrySet().iterator();\n    int d = 0;\n    while (it2.hasNext()) {\n      Map.Entry kv = (Map.Entry)it2.next();\n      long ab = (Long)kv.getKey();\n      long count = (Long)kv.getValue();\n      if (factorCount < _ci.max_factors) {\n        factorCount++;\n        // extract the two original factor enums\n        int a = (int)(ab >> 32);\n        int b = (int)ab;\n        assert ab == (((long)a << 32) | (b & 0xFFFFFFFFL));\n\n        final String fA = a != _missing ? _fr.domains()[_i][a] : \"NA\";\n        final String fB = b != _missing ? _fr.domains()[_j][b] : \"NA\";\n        final String feature = fA + \"_\" + fB;\n//        Log.info(\"Adding interaction feature \" + feature + \", occurrence count: \" + count);\n//        Log.info(\"Total number of interaction factors so far: \" + factorCount);\n        _domain[d++] = feature;\n      } else break;\n    }\n    if (d < _sortedMap.size()) {\n      Log.info(\"Truncated map to \" + _sortedMap.size() + \" elements.\");\n      String[] copy = new String[d+1];\n      System.arraycopy(_domain, 0, copy, 0, d);\n      copy[d] = _other;\n      _domain = copy;\n\n      Map tm = new LinkedHashMap<Long, Long>();\n      it2 = _sortedMap.entrySet().iterator();\n      while (--d >= 0) {\n        Map.Entry kv = (Map.Entry) it2.next();\n        tm.put(kv.getKey(), kv.getValue());\n      }\n      _sortedMap = tm;\n    }\n//    Log.info(\"Created domain: \" + Arrays.deepToString(_domain));\n    return _domain;\n  }","id":29253,"modified_method":"protected String[] makeDomain(Map<IcedLong, IcedLong> unsortedMap, int _i, int _j) {\n    String[] _domain;\n    Frame _fr = _out;\n//    Log.info(\"Collected hash table\");\n//    Log.info(java.util.Arrays.deepToString(unsortedMap.entrySet().toArray()));\n\n//    Log.info(\"Interaction between \" + _fr.domains()[_i].length + \" and \" + _fr.domains()[_j].length + \" factor levels => \" +\n//            ((long)_fr.domains()[_i].length * (long)_fr.domains()[_j].length) + \" possible factors.\");\n\n    _sortedMap = mySort(unsortedMap);\n\n    // create domain of the most frequent unique factors\n    long factorCount = 0;\n//    Log.info(\"Found \" + _sortedMap.size() + \" unique interaction factors (out of \" + ((long)_fr.domains()[_i].length * (long)_fr.domains()[_j].length) + \").\");\n    _domain = new String[_sortedMap.size()]; //TODO: use ArrayList here, then convert to array\n    Iterator it2 = _sortedMap.entrySet().iterator();\n    int d = 0;\n    while (it2.hasNext()) {\n      Map.Entry kv = (Map.Entry)it2.next();\n      final long ab = (Long)kv.getKey();\n      final long count = (Long)kv.getValue();\n      if (factorCount < _ci.max_factors && count >= _ci.min_occurrence) {\n        factorCount++;\n        // extract the two original factor enums\n        String feature = \"\";\n        if (_j != _i) {\n          int a = (int)(ab >> 32);\n          final String fA = a != _missing ? _fr.domains()[_i][a] : \"NA\";\n          feature = fA + \"_\";\n        }\n        int b = (int) ab;\n        String fB = b != _missing ? _fr.domains()[_j][b] : \"NA\";\n        feature += fB;\n\n//        Log.info(\"Adding interaction feature \" + feature + \", occurrence count: \" + count);\n//        Log.info(\"Total number of interaction factors so far: \" + factorCount);\n        _domain[d++] = feature;\n      } else break;\n    }\n    if (d < _sortedMap.size()) {\n      Log.info(\"Truncated map to \" + _sortedMap.size() + \" elements.\");\n      String[] copy = new String[d+1];\n      System.arraycopy(_domain, 0, copy, 0, d);\n      copy[d] = _other;\n      _domain = copy;\n\n      Map tm = new LinkedHashMap<Long, Long>();\n      it2 = _sortedMap.entrySet().iterator();\n      while (--d >= 0) {\n        Map.Entry kv = (Map.Entry) it2.next();\n        tm.put(kv.getKey(), kv.getValue());\n      }\n      _sortedMap = tm;\n    }\n//    Log.info(\"Created domain: \" + Arrays.deepToString(_domain));\n    return _domain;\n  }","commit_id":"71d4acb424b55f1537617612d595853567825b84","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n  public void compute2() {\n    // base frame - same as source\n    DKV.remove(Key.make(_ci.target));//shouldn't be needed, but this avoids missing chunk issues\n    _out = new Frame(Key.make(_ci.target), _ci.source.names().clone(), _ci.source.vecs().clone());\n    _out.delete_and_lock(_job);\n\n    int idx1 = _ci.factors[0];\n    Vec tmp = null;\n    for (int i=1; i<_ci.factors.length; ++i) {\n      if (i>1) {\n        idx1 = _out.find(tmp);\n        assert idx1 >= 0;\n      }\n      int idx2 = _ci.factors[i];\n//      Log.info(\"Combining columns \" + idx1 + \" and \" + idx2);\n\n      // Pass 1: compute unique domains of all interaction features\n      createInteractionDomain pass1 = new createInteractionDomain(idx1, idx2).doAll(_out);\n\n      // Create a new Vec based on the domain\n      _out.add(_out._names[idx1] + \"_\" + _out._names[idx2], _out.anyVec().makeZero(makeDomain(pass1._unsortedMap, idx1, idx2)));\n      _out.update(_job);\n\n      // Create array of enum pairs, in the same (sorted) order as in the _domain map -> for linear lookup\n      // Note: \"other\" is not mapped in keys, so keys.length can be 1 less than domain.length\n      long[] keys = new long[_sortedMap.size()];\n      int pos = 0;\n      for (long k : _sortedMap.keySet()) {\n        keys[pos++] = k;\n      }\n      assert(_out.lastVec().domain().length == keys.length || _out.lastVec().domain().length == keys.length + 1); // domain might contain _other\n\n      // Pass 2: fill Vec values\n      new fillInteractionEnums(idx1, idx2, keys).doAll(_out);\n      tmp = _out.lastVec();\n\n      // remove temporary vec\n      if (i>1) {\n        final int idx = _out.vecs().length-2; //second-last vec\n//        Log.info(\"Removing column \" + _out._names[idx]);\n        _out.remove(idx);\n        _out.update(_job);\n      }\n    }\n    tryComplete();\n  }","id":29254,"modified_method":"@Override\n  public void compute2() {\n    // base frame - same as source\n    DKV.remove(Key.make(_ci.target));//shouldn't be needed, but this avoids missing chunk issues\n    _out = new Frame(Key.make(_ci.target), _ci.source.names().clone(), _ci.source.vecs().clone());\n    _out.delete_and_lock(_job);\n\n    int idx1 = _ci.factors[0];\n    Vec tmp = null;\n    int start = _ci.factors.length == 1 ? 0 : 1;\n    for (int i=start; i<_ci.factors.length; ++i) {\n      if (i>1) {\n        idx1 = _out.find(tmp);\n        assert idx1 >= 0;\n      }\n      int idx2 = _ci.factors[i];\n//      Log.info(\"Combining columns \" + idx1 + \" and \" + idx2);\n\n      // Pass 1: compute unique domains of all interaction features\n      createInteractionDomain pass1 = new createInteractionDomain(idx1, idx2).doAll(_out);\n\n      // Create a new Vec based on the domain\n      final String name = _out._names[idx1] + \"_\" + _out._names[idx2];\n      final Vec vec = _out.anyVec().makeZero(makeDomain(pass1._unsortedMap, idx1, idx2));\n      _out.add(name, vec);\n      _out.update(_job);\n\n      // Create array of enum pairs, in the same (sorted) order as in the _domain map -> for linear lookup\n      // Note: \"other\" is not mapped in keys, so keys.length can be 1 less than domain.length\n      long[] keys = new long[_sortedMap.size()];\n      int pos = 0;\n      for (long k : _sortedMap.keySet()) {\n        keys[pos++] = k;\n      }\n      assert(_out.lastVec().domain().length == keys.length || _out.lastVec().domain().length == keys.length + 1); // domain might contain _other\n\n      // Pass 2: fill Vec values\n      new fillInteractionEnums(idx1, idx2, keys).doAll(_out);\n      tmp = _out.lastVec();\n\n      // remove temporary vec\n      if (i>1) {\n        final int idx = _out.vecs().length-2; //second-last vec\n//        Log.info(\"Removing column \" + _out._names[idx]);\n        _out.remove(idx);\n        _out.update(_job);\n      }\n    }\n    tryComplete();\n  }","commit_id":"71d4acb424b55f1537617612d595853567825b84","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n  public void map(Chunk[] cs) {\n    _unsortedMap = new Utils.IcedHashMap<IcedLong, IcedLong>();\n    // find unique interaction domain\n    for (int r = 0; r < cs[0]._len; r++) {\n      int a = cs[_i].isNA0(r) ? _missing : (int)cs[_i].at80(r);\n      int b = cs[_j].isNA0(r) ? _missing : (int)cs[_j].at80(r);\n\n      // key: combine both ints into a long\n      long ab = ((long)a << 32) | (b & 0xFFFFFFFFL);\n      assert a == (int)(ab >> 32);\n      assert b == (int)ab;\n\n      // add key to hash map, and count occurrences (for pruning)\n      IcedLong AB = new IcedLong(ab);\n      if (_unsortedMap.containsKey(AB)) {\n        _unsortedMap.put(AB, new IcedLong(_unsortedMap.get(AB)._val + 1));\n      } else {\n        _unsortedMap.put(AB, new IcedLong(1));\n      }\n    }\n  }","id":29255,"modified_method":"@Override\n  public void map(Chunk[] cs) {\n    _unsortedMap = new Utils.IcedHashMap<IcedLong, IcedLong>();\n    // find unique interaction domain\n    for (int r = 0; r < cs[0]._len; r++) {\n      int a = cs[_i].isNA0(r) ? _missing : (int)cs[_i].at80(r);\n      long ab;\n      if (_j != _i) {\n        int b = cs[_j].isNA0(r) ? _missing : (int) cs[_j].at80(r);\n\n        // key: combine both ints into a long\n        ab = ((long) a << 32) | (b & 0xFFFFFFFFL);\n        assert a == (int) (ab >> 32);\n        assert b == (int) ab;\n      } else {\n        if (a == _missing) continue;\n        ab = (long)a;\n      }\n\n      // add key to hash map, and count occurrences (for pruning)\n      IcedLong AB = new IcedLong(ab);\n      if (_unsortedMap.containsKey(AB)) {\n        _unsortedMap.put(AB, new IcedLong(_unsortedMap.get(AB)._val + 1));\n      } else {\n        _unsortedMap.put(AB, new IcedLong(1));\n      }\n    }\n  }","commit_id":"71d4acb424b55f1537617612d595853567825b84","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void exportSchema() throws IOException {\r\n\t\tlistener.onMessage(\"\\nExporting schema...\");\r\n\r\n\t\twriter.beginObject(1, true, \"schema\");\r\n\t\tOSchema s = database.getMetadata().getSchema();\r\n\t\twriter.writeAttribute(2, true, \"version\", s.getDocument().getVersion());\r\n\r\n\t\tif (s.getClasses().size() > 0) {\r\n\t\t\twriter.beginCollection(2, true, \"classes\");\r\n\t\t\tfor (OClass cls : s.getClasses()) {\r\n\t\t\t\twriter.beginObject(3, true, \"class\");\r\n\t\t\t\twriter.writeAttribute(0, false, \"name\", cls.getName());\r\n\t\t\t\twriter.writeAttribute(0, false, \"id\", cls.getId());\r\n\t\t\t\twriter.writeAttribute(0, false, \"default-cluster-id\", cls.getDefaultClusterId());\r\n\t\t\t\twriter.writeAttribute(0, false, \"cluster-ids\", cls.getClusterIds());\r\n\t\t\t\tif (cls.getSuperClass() != null)\r\n\t\t\t\t\twriter.writeAttribute(0, false, \"super-class\", cls.getSuperClass().getName());\r\n\r\n\t\t\t\tif (cls.properties().size() > 0) {\r\n\t\t\t\t\twriter.beginCollection(4, true, \"properties\");\r\n\t\t\t\t\tfor (OProperty p : cls.properties()) {\r\n\t\t\t\t\t\twriter.beginObject(5, true, null);\r\n\t\t\t\t\t\twriter.writeAttribute(0, false, \"name\", p.getName());\r\n\t\t\t\t\t\twriter.writeAttribute(0, false, \"id\", p.getId());\r\n\t\t\t\t\t\twriter.writeAttribute(0, false, \"type\", p.getType());\r\n\t\t\t\t\t\tif (p.getLinkedClass() != null)\r\n\t\t\t\t\t\t\twriter.writeAttribute(0, false, \"linked-class\", p.getLinkedClass().getName());\r\n\t\t\t\t\t\tif (p.getLinkedType() != null)\r\n\t\t\t\t\t\t\twriter.writeAttribute(0, false, \"linked-type\", p.getLinkedType());\r\n\t\t\t\t\t\tif (p.getMin() != null)\r\n\t\t\t\t\t\t\twriter.writeAttribute(0, false, \"min\", p.getMin());\r\n\t\t\t\t\t\tif (p.getMax() != null)\r\n\t\t\t\t\t\t\twriter.writeAttribute(0, false, \"max\", p.getMax());\r\n\t\t\t\t\t\tif (p.getIndex() != null) {\r\n\t\t\t\t\t\t\twriter.writeAttribute(0, false, \"index-rid\", p.getIndex().getRecord().getIdentity());\r\n\t\t\t\t\t\t\twriter.writeAttribute(0, false, \"index-unique\", p.getIndex().isUnique());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twriter.endObject(0, false);\r\n\t\t\t\t\t}\r\n\t\t\t\t\twriter.endCollection(4, true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\twriter.endObject(3, true);\r\n\t\t\t}\r\n\t\t\twriter.endCollection(2, true);\r\n\t\t}\r\n\r\n\t\twriter.endObject(1, true);\r\n\r\n\t\tlistener.onMessage(\"OK (\" + s.getClasses().size() + \" classes)\");\r\n\t}","id":29256,"modified_method":"private void exportSchema() throws IOException {\r\n\t\tlistener.onMessage(\"\\nExporting schema...\");\r\n\r\n\t\twriter.beginObject(1, true, \"schema\");\r\n\t\tOSchema s = database.getMetadata().getSchema();\r\n\t\twriter.writeAttribute(2, true, \"version\", s.getDocument().getVersion());\r\n\r\n\t\tif (s.getClasses().size() > 0) {\r\n\t\t\twriter.beginCollection(2, true, \"classes\");\r\n\t\t\tfor (OClass cls : s.getClasses()) {\r\n\t\t\t\twriter.beginObject(3, true, null);\r\n\t\t\t\twriter.writeAttribute(0, false, \"name\", cls.getName());\r\n\t\t\t\twriter.writeAttribute(0, false, \"id\", cls.getId());\r\n\t\t\t\twriter.writeAttribute(0, false, \"default-cluster-id\", cls.getDefaultClusterId());\r\n\t\t\t\twriter.writeAttribute(0, false, \"cluster-ids\", cls.getClusterIds());\r\n\t\t\t\tif (cls.getSuperClass() != null)\r\n\t\t\t\t\twriter.writeAttribute(0, false, \"super-class\", cls.getSuperClass().getName());\r\n\r\n\t\t\t\tif (cls.properties().size() > 0) {\r\n\t\t\t\t\twriter.beginCollection(4, true, \"properties\");\r\n\t\t\t\t\tfor (OProperty p : cls.properties()) {\r\n\t\t\t\t\t\twriter.beginObject(5, true, null);\r\n\t\t\t\t\t\twriter.writeAttribute(0, false, \"name\", p.getName());\r\n\t\t\t\t\t\twriter.writeAttribute(0, false, \"id\", p.getId());\r\n\t\t\t\t\t\twriter.writeAttribute(0, false, \"type\", p.getType().toString());\r\n\t\t\t\t\t\tif (p.getLinkedClass() != null)\r\n\t\t\t\t\t\t\twriter.writeAttribute(0, false, \"linked-class\", p.getLinkedClass().getName());\r\n\t\t\t\t\t\tif (p.getLinkedType() != null)\r\n\t\t\t\t\t\t\twriter.writeAttribute(0, false, \"linked-type\", p.getLinkedType().toString());\r\n\t\t\t\t\t\tif (p.getMin() != null)\r\n\t\t\t\t\t\t\twriter.writeAttribute(0, false, \"min\", p.getMin());\r\n\t\t\t\t\t\tif (p.getMax() != null)\r\n\t\t\t\t\t\t\twriter.writeAttribute(0, false, \"max\", p.getMax());\r\n\t\t\t\t\t\tif (p.getIndex() != null) {\r\n\t\t\t\t\t\t\twriter.writeAttribute(0, false, \"index-rid\", p.getIndex().getRecord().getIdentity());\r\n\t\t\t\t\t\t\twriter.writeAttribute(0, false, \"index-unique\", p.getIndex().isUnique());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twriter.endObject(0, false);\r\n\t\t\t\t\t}\r\n\t\t\t\t\twriter.endCollection(4, true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\twriter.endObject(3, true);\r\n\t\t\t}\r\n\t\t\twriter.endCollection(2, true);\r\n\t\t}\r\n\r\n\t\twriter.endObject(1, true);\r\n\r\n\t\tlistener.onMessage(\"OK (\" + s.getClasses().size() + \" classes)\");\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void exportInfo() throws IOException {\r\n\t\tlistener.onMessage(\"\\nExporting database info...\");\r\n\r\n\t\twriter.beginObject(1, true, \"info\");\r\n\t\twriter.writeAttribute(2, true, \"name\", database.getName());\r\n\t\twriter.writeAttribute(2, true, \"default-cluster-id\", database.getDefaultClusterId());\r\n\t\twriter.endObject(1, true);\r\n\r\n\t\tlistener.onMessage(\"OK\");\r\n\t}","id":29257,"modified_method":"private void exportInfo() throws IOException {\r\n\t\tlistener.onMessage(\"\\nExporting database info...\");\r\n\r\n\t\twriter.beginObject(1, true, \"info\");\r\n\t\twriter.writeAttribute(2, true, \"name\", database.getName().replace('\\\\', '/'));\r\n\t\twriter.writeAttribute(2, true, \"default-cluster-id\", database.getDefaultClusterId());\r\n\t\twriter.endObject(1, true);\r\n\r\n\t\tlistener.onMessage(\"OK\");\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OConsoleDatabaseExport exportDatabase() {\r\n\t\ttry {\r\n\t\t\texportInfo();\r\n\t\t\texportDictionary();\r\n\t\t\texportSchema();\r\n\t\t\texportAllClusters();\r\n\r\n\t\t\tlistener.onMessage(\"\\nExport of database completed.\");\r\n\r\n\t\t\twriter.flush();\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new ODatabaseExportException(\"Error on exporting database '\" + database.getName() + \" to: \" + fileName, e);\r\n\t\t} finally {\r\n\t\t\tclose();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}","id":29258,"modified_method":"public OConsoleDatabaseExport exportDatabase() {\r\n\t\ttry {\r\n\t\t\texportInfo();\r\n\t\t\texportAllClusters();\r\n\t\t\texportSchema();\r\n\t\t\texportRecords();\r\n\t\t\texportDictionary();\r\n\r\n\t\t\tlistener.onMessage(\"\\nExport of database completed.\");\r\n\r\n\t\t\twriter.flush();\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new ODatabaseExportException(\"Error on exporting database '\" + database.getName() + \" to: \" + fileName, e);\r\n\t\t} finally {\r\n\t\t\tclose();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void exportAllClusters() throws IOException {\r\n\t\tlistener.onMessage(\"\\nExporting clusters...\");\r\n\r\n\t\twriter.beginObject(1, true, \"clusters\");\r\n\t\texportClusters(database.getClusterNames().toArray(new String[database.getClusterNames().size()]), 2);\r\n\t\twriter.endObject(1, true);\r\n\r\n\t}","id":29259,"modified_method":"private void exportAllClusters() throws IOException {\r\n\t\tlistener.onMessage(\"\\nExporting clusters...\");\r\n\r\n\t\twriter.beginCollection(1, true, \"clusters\");\r\n\t\texportClusters(database.getClusterNames().toArray(new String[database.getClusterNames().size()]), 2);\r\n\t\twriter.endCollection(1, true);\r\n\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public long exportClusters(final String[] iClusters, final int iLevel) throws IOException {\r\n\t\tlong totalRecords = 0;\r\n\t\tfor (String clusterName : iClusters) {\r\n\t\t\tlong recordTot = database.countClusterElements(clusterName);\r\n\t\t\tlistener.onMessage(\"\\n- Exporting cluster '\" + clusterName + \"' (records=\" + recordTot + \") -> \");\r\n\r\n\t\t\twriter.beginObject(iLevel, true, \"cluster\");\r\n\t\t\twriter.writeAttribute(iLevel + 1, true, \"name\", clusterName);\r\n\t\t\twriter.writeAttribute(0, false, \"id\", database.getClusterIdByName(clusterName));\r\n\t\t\twriter.writeAttribute(0, false, \"type\", database.getClusterType(clusterName));\r\n\r\n\t\t\tif (recordTot > 0) {\r\n\t\t\t\twriter.beginCollection(iLevel + 1, true, \"records\");\r\n\r\n\t\t\t\tlong recordNum = 0;\r\n\t\t\t\tfor (ORecord<?> rec : database.browseCluster(clusterName))\r\n\t\t\t\t\texportRecord(recordTot, recordNum, rec);\r\n\r\n\t\t\t\twriter.endCollection(iLevel + 1, true);\r\n\t\t\t}\r\n\r\n\t\t\tlistener.onMessage(\"OK\");\r\n\r\n\t\t\ttotalRecords += recordTot;\r\n\r\n\t\t\twriter.endObject(iLevel, true);\r\n\t\t}\r\n\r\n\t\tlistener.onMessage(\"\\n\\nDone. Exported \" + totalRecords + \" records\\n\");\r\n\r\n\t\treturn totalRecords;\r\n\t}","id":29260,"modified_method":"public long exportClusters(final String[] iClusters, final int iLevel) throws IOException {\r\n\t\tlong totalRecords = 0;\r\n\r\n\t\tfor (String clusterName : iClusters) {\r\n\t\t\tlong recordTot = database.countClusterElements(clusterName);\r\n\r\n\t\t\twriter.beginObject(iLevel, true, null);\r\n\t\t\twriter.writeAttribute(0, false, \"name\", clusterName);\r\n\t\t\twriter.writeAttribute(0, false, \"id\", database.getClusterIdByName(clusterName));\r\n\t\t\twriter.writeAttribute(0, false, \"type\", database.getClusterType(clusterName));\r\n\r\n\t\t\ttotalRecords += recordTot;\r\n\r\n\t\t\twriter.endObject(iLevel, false);\r\n\t\t}\r\n\r\n\t\tlistener.onMessage(\"OK\");\r\n\r\n\t\treturn totalRecords;\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void exportRecord(long recordTot, long recordNum, ORecord<?> rec) throws IOException {\r\n\t\tif (rec == null)\r\n\t\t\treturn;\r\n\r\n\t\twriter.beginObject(4, true, null);\r\n\t\twriter.writeAttribute(0, false, ORecordSerializerJSON.ATTRIBUTE_ID, rec.getIdentity());\r\n\t\twriter.writeAttribute(0, false, ORecordSerializerJSON.ATTRIBUTE_VERSION, rec.getVersion());\r\n\r\n\t\tif (rec.getIdentity().isValid())\r\n\t\t\trec.load();\r\n\r\n\t\tif (rec instanceof ODocument) {\r\n\t\t\tfinal ODocument vobj = (ODocument) rec;\r\n\r\n\t\t\twriter.writeAttribute(0, false, ATTRIBUTE_TYPE, \"v\");\r\n\r\n\t\t\tif (vobj.getClassName() != null)\r\n\t\t\t\twriter.writeAttribute(0, false, \"@class\", vobj.getClassName());\r\n\r\n\t\t\tObject value;\r\n\t\t\tif (vobj.fieldNames() != null && vobj.fieldNames().length > 0) {\r\n\t\t\t\twriter.beginObject(5, true, \"value\");\r\n\t\t\t\tfor (String f : vobj.fieldNames()) {\r\n\t\t\t\t\tvalue = vobj.field(f);\r\n\r\n\t\t\t\t\twriter.writeAttribute(6, true, f, value);\r\n\t\t\t\t}\r\n\t\t\t\twriter.endObject(5, true);\r\n\t\t\t}\r\n\t\t} else if (rec instanceof ORecordColumn) {\r\n\t\t\tORecordColumn csv = (ORecordColumn) rec;\r\n\r\n\t\t\twriter.writeAttribute(0, false, ATTRIBUTE_TYPE, \"c\");\r\n\r\n\t\t\tif (csv.size() > 0) {\r\n\t\t\t\twriter.beginCollection(5, true, \"value\");\r\n\t\t\t\tfor (int i = 0; i < csv.size(); ++i) {\r\n\t\t\t\t\twriter.writeValue(6, true, csv.field(i));\r\n\t\t\t\t}\r\n\t\t\t\twriter.endCollection(5, true);\r\n\t\t\t}\r\n\t\t} else if (rec instanceof ORecordFlat) {\r\n\t\t\tfinal ORecordFlat flat = (ORecordFlat) rec;\r\n\r\n\t\t\twriter.writeAttribute(0, false, ATTRIBUTE_TYPE, \"f\");\r\n\t\t\twriter.writeAttribute(6, true, \"value\", flat.value());\r\n\t\t} else if (rec instanceof ORecordBytes) {\r\n\r\n\t\t\tfinal ORecordBytes bytes = (ORecordBytes) rec;\r\n\r\n\t\t\twriter.writeAttribute(0, false, ATTRIBUTE_TYPE, \"b\");\r\n\t\t\twriter.writeAttribute(6, true, \"value\", bytes.toStream());\r\n\t\t}\r\n\r\n\t\twriter.endObject(4, true);\r\n\r\n\t\trecordNum++;\r\n\r\n\t\tif (recordTot > 10 && (recordNum + 1) % (recordTot / 10) == 0)\r\n\t\t\tlistener.onMessage(\".\");\r\n\t}","id":29261,"modified_method":"private void exportRecord(long recordTot, long recordNum, ORecordInternal<?> rec) throws IOException {\r\n\t\tif (rec == null)\r\n\t\t\treturn;\r\n\r\n\t\tbyte recordType = rec.getRecordType();\r\n\r\n\t\twriter.beginObject(3, true, null);\r\n\t\twriter.writeAttribute(0, false, ATTRIBUTE_TYPE, \"\" + (char) recordType);\r\n\t\twriter.writeAttribute(0, false, ORecordSerializerJSON.ATTRIBUTE_ID, rec.getIdentity());\r\n\t\twriter.writeAttribute(0, false, ORecordSerializerJSON.ATTRIBUTE_VERSION, rec.getVersion());\r\n\r\n\t\tif (rec.getIdentity().isValid())\r\n\t\t\trec.load();\r\n\r\n\t\tswitch (recordType) {\r\n\t\tcase ODocument.RECORD_TYPE:\r\n\t\t\tfinal ODocument vobj = (ODocument) rec;\r\n\t\t\tif (vobj.getClassName() != null)\r\n\t\t\t\twriter.writeAttribute(0, false, \"@class\", vobj.getClassName());\r\n\r\n\t\t\tObject value;\r\n\t\t\tif (vobj.fieldNames() != null && vobj.fieldNames().length > 0) {\r\n\t\t\t\tfor (String f : vobj.fieldNames()) {\r\n\t\t\t\t\tvalue = vobj.field(f);\r\n\t\t\t\t\twriter.writeAttribute(5, true, f, value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase ORecordColumn.RECORD_TYPE:\r\n\t\t\tORecordColumn csv = (ORecordColumn) rec;\r\n\t\t\tif (csv.size() > 0) {\r\n\t\t\t\twriter.beginCollection(4, true, null);\r\n\t\t\t\tfor (int i = 0; i < csv.size(); ++i) {\r\n\t\t\t\t\twriter.writeValue(5, true, csv.field(i));\r\n\t\t\t\t}\r\n\t\t\t\twriter.endCollection(4, true);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase ORecordFlat.RECORD_TYPE:\r\n\t\t\twriter.writeAttribute(5, true, \"value\", ((ORecordFlat) rec).value());\r\n\t\t\tbreak;\r\n\r\n\t\tcase ORecordBytes.RECORD_TYPE:\r\n\t\t\twriter.writeAttribute(5, true, \"value\", rec.toStream());\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\twriter.endObject(3, true);\r\n\r\n\t\trecordNum++;\r\n\r\n\t\tif (recordTot > 10 && (recordNum + 1) % (recordTot / 10) == 0)\r\n\t\t\tlistener.onMessage(\".\");\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n\tprivate void importClusterRecord() throws IOException, ParseException {\r\n\t\tjsonReader.readNext(OJSONReader.BEGIN_OBJECT);\r\n\r\n\t\tString id = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"@id\\\"\").readString(OJSONReader.COMMA_SEPARATOR);\r\n\r\n\t\tint version = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"@ver\\\"\")\r\n\t\t\t\t.readInteger(OJSONReader.COMMA_SEPARATOR);\r\n\r\n\t\tchar type = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"@type\\\"\").readString(OJSONReader.COMMA_SEPARATOR)\r\n\t\t\t\t.charAt(0);\r\n\r\n\t\t// CREATE THE RECORD FOLLOWING THE ORIGINAL TYPE\r\n\t\tswitch (type) {\r\n\t\tcase 'b':\r\n\t\t\t// BINARY\r\n\t\t\tif (record == null || !(record instanceof ORecordBytes))\r\n\t\t\t\trecord = new ORecordBytes(database);\r\n\t\t\telse\r\n\t\t\t\trecord.reset();\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'v':\r\n\t\t\t// ODOCUMENT\r\n\t\t\tif (record == null || !(record instanceof ODocument))\r\n\t\t\t\trecord = new ODocument(database);\r\n\t\t\telse\r\n\t\t\t\trecord.reset();\r\n\r\n\t\t\tif (jsonReader.getValue().equals(\"\\\"@class\\\"\")) {\r\n\t\t\t\t((ODocument) record).setClassName(jsonReader.readString(OJSONReader.COMMA_SEPARATOR));\r\n\t\t\t\tjsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'c':\r\n\t\t\t// COLUMN\r\n\t\t\tif (record == null || !(record instanceof ORecordColumn))\r\n\t\t\t\trecord = new ORecordColumn(database);\r\n\t\t\telse\r\n\t\t\t\trecord.reset();\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'f':\r\n\t\t\t// FLAT\r\n\t\t\tif (record == null || !(record instanceof ORecordFlat))\r\n\t\t\t\trecord = new ORecordFlat(database);\r\n\t\t\telse\r\n\t\t\t\trecord.reset();\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\t// ERROR\r\n\t\t\tthrow new OSchemaException(\"Error: unsupported record type: \" + type);\r\n\t\t}\r\n\r\n\t\tString value = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"value\\\"\")\r\n\t\t\t\t.readString(OJSONReader.END_OBJECT, true);\r\n\r\n\t\trecord.fromJSON(value);\r\n\r\n\t\t// SAVE THE RECORD\r\n\t\trecord.setVersion(version);\r\n\r\n\t\trid.fromString(id);\r\n\t\tif (rid.clusterPosition < database.countClusterElements(rid.clusterId)) {\r\n\t\t\trecord.setIdentity(rid);\r\n\t\t\tif (record instanceof ORecordBytes)\r\n\t\t\t\t((ODatabaseRecord<ORecordBytes>) database.getUnderlying()).save((ORecordBytes) record);\r\n\t\t\telse if (record instanceof ORecordFlat)\r\n\t\t\t\t((ODatabaseRecord<ORecordFlat>) database.getUnderlying()).save((ORecordFlat) record);\r\n\t\t\telse if (record instanceof ODocument)\r\n\t\t\t\t((ODocument) record).save();\r\n\t\t} else {\r\n\t\t\tString clusterName = database.getClusterNameById(rid.clusterId);\r\n\t\t\trecord.setIdentity(-1, -1);\r\n\t\t\tif (record instanceof ORecordBytes)\r\n\t\t\t\t((ODatabaseRecord<ORecordBytes>) database.getUnderlying()).save((ORecordBytes) record, clusterName);\r\n\t\t\telse if (record instanceof ORecordFlat)\r\n\t\t\t\t((ODatabaseRecord<ORecordInternal<?>>) database.getUnderlying()).save(record, clusterName);\r\n\t\t\telse if (record instanceof ODocument)\r\n\t\t\t\t((ODatabaseRecord<ORecordInternal<?>>) database.getUnderlying()).save(record, clusterName);\r\n\t\t}\r\n\r\n\t\tif (!record.getIdentity().toString().equals(id))\r\n\t\t\tthrow new OSchemaException(\"Imported record '\" + record.getIdentity() + \"' has rid different from the original: \" + id);\r\n\r\n\t\tjsonReader.readNext(OJSONReader.NEXT_IN_ARRAY);\r\n\t}","id":29262,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n\tprivate void importRecord() throws IOException, ParseException {\r\n\t\tString value = jsonReader.readString(OJSONReader.END_OBJECT, true);\r\n\r\n\t\trecord = ORecordSerializerJSON.INSTANCE.fromString(database, value, record);\r\n\r\n\t\tString rid = record.getIdentity().toString();\r\n\r\n\t\tSystem.out.print(\"\\nImporting record of type '\" + (char) record.getRecordType() + \"' with id=\" + rid);\r\n\r\n\t\t// SAVE THE RECORD\r\n\t\tif (record.getIdentity().getClusterPosition() < database.countClusterElements(record.getIdentity().getClusterId())) {\r\n\t\t\tif (record instanceof ORecordBytes)\r\n\t\t\t\t((ODatabaseRecord<ORecordBytes>) database.getUnderlying()).save((ORecordBytes) record);\r\n\t\t\telse if (record instanceof ORecordFlat || record instanceof ODocument)\r\n\t\t\t\t((ODocument) record).save();\r\n\t\t} else {\r\n\t\t\tString clusterName = database.getClusterNameById(record.getIdentity().getClusterId());\r\n\t\t\trecord.setIdentity(-1, -1);\r\n\t\t\tif (record instanceof ORecordBytes)\r\n\t\t\t\t((ODatabaseRecord<ORecordBytes>) database.getUnderlying()).save((ORecordBytes) record, clusterName);\r\n\t\t\telse if (record instanceof ORecordFlat)\r\n\t\t\t\t((ODatabaseRecord<ORecordInternal<?>>) database.getUnderlying()).save(record, clusterName);\r\n\t\t\telse if (record instanceof ODocument)\r\n\t\t\t\t((ODatabaseRecord<ORecordInternal<?>>) database.getUnderlying()).save(record, clusterName);\r\n\t\t}\r\n\r\n\t\tif (!record.getIdentity().toString().equals(rid))\r\n\t\t\tthrow new OSchemaException(\"Imported record '\" + record.getIdentity() + \"' has rid different from the original: \" + rid);\r\n\r\n\t\tjsonReader.readNext(OJSONReader.NEXT_IN_ARRAY);\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private long importAllClusters() throws ParseException, IOException {\r\n\t\tlong total = 0;\r\n\r\n\t\tjsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT);\r\n\t\tjsonReader.checkContent(\"\\\"clusters\\\"\");\r\n\t\tjsonReader.readNext(OJSONReader.BEGIN_OBJECT);\r\n\r\n\t\tlong totalRecords = 0;\r\n\r\n\t\twhile (jsonReader.lastChar() != ']') {\r\n\t\t\tjsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT);\r\n\t\t\tjsonReader.checkContent(\"\\\"cluster\\\"\");\r\n\t\t\tjsonReader.readNext(OJSONReader.BEGIN_OBJECT);\r\n\r\n\t\t\tString name = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"name\\\"\")\r\n\t\t\t\t\t.readString(OJSONReader.COMMA_SEPARATOR);\r\n\t\t\tint id = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"id\\\"\").readInteger(OJSONReader.COMMA_SEPARATOR);\r\n\t\t\tString type = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"type\\\"\")\r\n\t\t\t\t\t.readString(OJSONReader.NEXT_IN_OBJECT);\r\n\r\n\t\t\tint clusterId = database.getClusterIdByName(name);\r\n\t\t\tif (clusterId == -1) {\r\n\t\t\t\t// CREATE IT\r\n\t\t\t\tif (type.equals(\"PHYSICAL\"))\r\n\t\t\t\t\tclusterId = database.addPhysicalCluster(name, name, -1);\r\n\t\t\t\telse\r\n\t\t\t\t\tclusterId = database.addLogicalCluster(name, database.getDefaultClusterId());\r\n\t\t\t}\r\n\r\n\t\t\tif (clusterId != id)\r\n\t\t\t\tthrow new OSchemaException(\"Imported cluster '\" + name + \"' has id=\" + clusterId + \" different from the original: \" + id);\r\n\r\n\t\t\tif (jsonReader.lastChar() != '}') {\r\n\t\t\t\t// PARSE RECORDS\r\n\t\t\t\tjsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT);\r\n\t\t\t\tjsonReader.checkContent(\"\\\"records\\\"\");\r\n\t\t\t\tjsonReader.readNext(OJSONReader.BEGIN_COLLECTION);\r\n\r\n\t\t\t\tlistener.onMessage(\"\\n- Exporting cluster '\" + name + \"' -> \");\r\n\r\n\t\t\t\tlong clusterRecords;\r\n\t\t\t\tfor (clusterRecords = 0; jsonReader.lastChar() != ']'; ++clusterRecords) {\r\n\t\t\t\t\timportClusterRecord();\r\n\r\n\t\t\t\t\tif (jsonReader.lastChar() == '}')\r\n\t\t\t\t\t\tjsonReader.readNext(OJSONReader.NEXT_IN_ARRAY);\r\n\t\t\t\t}\r\n\t\t\t\ttotalRecords += clusterRecords;\r\n\r\n\t\t\t\tlistener.onMessage(\"OK (\" + clusterRecords + \" records)\");\r\n\r\n\t\t\t\tjsonReader.readNext(OJSONReader.END_OBJECT);\r\n\t\t\t}\r\n\r\n\t\t\tjsonReader.readNext(OJSONReader.COMMA_SEPARATOR);\r\n\t\t}\r\n\r\n\t\tlistener.onMessage(\"\\n\\nDone. Imported \" + totalRecords + \" records\");\r\n\r\n\t\treturn total;\r\n\t}","id":29263,"modified_method":"private long importClusters() throws ParseException, IOException {\r\n\t\tlistener.onMessage(\"\\nImporting clusters...\");\r\n\r\n\t\tlong total = 0;\r\n\r\n\t\tjsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT);\r\n\t\tjsonReader.checkContent(\"\\\"clusters\\\"\");\r\n\t\tjsonReader.readNext(OJSONReader.BEGIN_OBJECT);\r\n\r\n\t\twhile (jsonReader.lastChar() != ']') {\r\n\t\t\tjsonReader.readNext(OJSONReader.BEGIN_OBJECT);\r\n\r\n\t\t\tString name = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"name\\\"\")\r\n\t\t\t\t\t.readString(OJSONReader.COMMA_SEPARATOR);\r\n\t\t\tint id = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"id\\\"\").readInteger(OJSONReader.COMMA_SEPARATOR);\r\n\t\t\tString type = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"type\\\"\")\r\n\t\t\t\t\t.readString(OJSONReader.NEXT_IN_OBJECT);\r\n\r\n\t\t\tint clusterId = database.getClusterIdByName(name);\r\n\t\t\tif (clusterId == -1) {\r\n\t\t\t\t// CREATE IT\r\n\t\t\t\tif (type.equals(\"PHYSICAL\"))\r\n\t\t\t\t\tclusterId = database.addPhysicalCluster(name, name, -1);\r\n\t\t\t\telse\r\n\t\t\t\t\tclusterId = database.addLogicalCluster(name, database.getDefaultClusterId());\r\n\t\t\t}\r\n\r\n\t\t\tif (clusterId != id)\r\n\t\t\t\tthrow new OSchemaException(\"Imported cluster '\" + name + \"' has id=\" + clusterId + \" different from the original: \" + id);\r\n\r\n\t\t\ttotal++;\r\n\r\n\t\t\tjsonReader.readNext(OJSONReader.NEXT_IN_ARRAY);\r\n\t\t}\r\n\t\tjsonReader.readNext(OJSONReader.COMMA_SEPARATOR);\r\n\r\n\t\tlistener.onMessage(\"OK (\" + total + \" clusters)\");\r\n\r\n\t\treturn total;\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OConsoleDatabaseImport importDatabase() {\r\n\t\ttry {\r\n\t\t\tjsonReader.readNext(OJSONReader.BEGIN_OBJECT);\r\n\r\n\t\t\timportInfo();\r\n\t\t\timportDictionary();\r\n\t\t\timportSchema();\r\n\r\n\t\t\tlong total = importAllClusters();\r\n\r\n\t\t\tjsonReader.readNext(OJSONReader.END_OBJECT);\r\n\r\n\t\t\tlistener.onMessage(\"\\n\\nImported \" + total + \" records\");\r\n\t\t\tlistener.onMessage(\"\\nImport of database completed.\");\r\n\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new ODatabaseExportException(\"Error on importing database '\" + database.getName() + \"' from file: \" + fileName, e);\r\n\t\t} finally {\r\n\t\t\tclose();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}","id":29264,"modified_method":"public OConsoleDatabaseImport importDatabase() {\r\n\t\ttry {\r\n\t\t\tjsonReader.readNext(OJSONReader.BEGIN_OBJECT);\r\n\r\n\t\t\timportInfo();\r\n\t\t\timportClusters();\r\n\t\t\timportSchema();\r\n\t\t\timportRecords();\r\n\t\t\timportDictionary();\r\n\r\n\t\t\tjsonReader.readNext(OJSONReader.END_OBJECT);\r\n\r\n\t\t\tlistener.onMessage(\"\\nImport of database completed.\");\r\n\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new ODatabaseExportException(\"Error on importing database '\" + database.getName() + \"' from file: \" + fileName, e);\r\n\t\t} finally {\r\n\t\t\tclose();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void importSchema() throws IOException, ParseException {\r\n\t\tlistener.onMessage(\"\\nImporting database schema...\");\r\n\r\n\t\tjsonReader.readNext(OJSONReader.BEGIN_OBJECT).checkContent(\"\\\"schema\\\":\").readNext(OJSONReader.FIELD_ASSIGNMENT);\r\n\t\t@SuppressWarnings(\"unused\")\r\n\t\tint schemaVersion = jsonReader.checkContent(\"\\\"version\\\"\").readNumber(OJSONReader.ANY_NUMBER, true);\r\n\t\tjsonReader.readNext(OJSONReader.COMMA_SEPARATOR).readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"classes\\\"\");\r\n\t\tjsonReader.readNext(OJSONReader.BEGIN_COLLECTION);\r\n\r\n\t\tlong classImported = 0;\r\n\t\tString className;\r\n\t\tint classId;\r\n\t\tint classDefClusterId;\r\n\t\tString classClusterIds;\r\n\t\tString classSuper = null;\r\n\r\n\t\tOClass cls;\r\n\r\n\t\ttry {\r\n\t\t\tdo {\r\n\t\t\t\tjsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"class\\\"\").readString(OJSONReader.BEGIN_OBJECT);\r\n\r\n\t\t\t\tclassName = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"name\\\"\")\r\n\t\t\t\t\t\t.readString(OJSONReader.COMMA_SEPARATOR);\r\n\r\n\t\t\t\tclassId = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"id\\\"\").readInteger(OJSONReader.COMMA_SEPARATOR);\r\n\r\n\t\t\t\tclassDefClusterId = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"default-cluster-id\\\"\")\r\n\t\t\t\t\t\t.readInteger(OJSONReader.COMMA_SEPARATOR);\r\n\r\n\t\t\t\tclassClusterIds = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"cluster-ids\\\"\")\r\n\t\t\t\t\t\t.readString(OJSONReader.NEXT_IN_OBJECT).trim();\r\n\r\n\t\t\t\tcls = database.getMetadata().getSchema().getClass(className);\r\n\r\n\t\t\t\tif (cls != null) {\r\n\t\t\t\t\tif (cls.getDefaultClusterId() != classDefClusterId)\r\n\t\t\t\t\t\tcls.setDefaultClusterId(classDefClusterId);\r\n\t\t\t\t} else\r\n\t\t\t\t\tcls = database.getMetadata().getSchema().createClass(className, classDefClusterId);\r\n\r\n\t\t\t\tif (classId != cls.getId())\r\n\t\t\t\t\tthrow new OSchemaException(\"Imported class '\" + className + \"' has id=\" + cls.getId() + \" different from the original: \"\r\n\t\t\t\t\t\t\t+ classId);\r\n\r\n\t\t\t\tif (classClusterIds != null) {\r\n\t\t\t\t\t// REMOVE BRACES\r\n\t\t\t\t\tclassClusterIds = classClusterIds.substring(1, classClusterIds.length() - 1);\r\n\r\n\t\t\t\t\t// ASSIGN OTHER CLUSTER IDS\r\n\t\t\t\t\tfor (int i : OStringSerializerHelper.splitIntArray(classClusterIds)) {\r\n\t\t\t\t\t\tcls.addClusterIds(i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tString value;\r\n\t\t\t\twhile (jsonReader.lastChar() == ',') {\r\n\t\t\t\t\tjsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT);\r\n\t\t\t\t\tvalue = jsonReader.getValue();\r\n\r\n\t\t\t\t\tif (value.equals(\"\\\"super-class\\\"\")) {\r\n\t\t\t\t\t\tclassSuper = jsonReader.readString(OJSONReader.NEXT_IN_OBJECT);\r\n\t\t\t\t\t\tsuperClasses.put(cls, classSuper);\r\n\t\t\t\t\t} else if (value.equals(\"\\\"properties\\\"\")) {\r\n\t\t\t\t\t\t// GET PROPERTIES\r\n\t\t\t\t\t\tjsonReader.readString(OJSONReader.BEGIN_COLLECTION);\r\n\r\n\t\t\t\t\t\twhile (jsonReader.lastChar() != ']') {\r\n\t\t\t\t\t\t\timportProperty(cls);\r\n\r\n\t\t\t\t\t\t\tif (jsonReader.lastChar() == '}')\r\n\t\t\t\t\t\t\t\tjsonReader.readNext(OJSONReader.NEXT_IN_ARRAY);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tjsonReader.readNext(OJSONReader.END_OBJECT);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tclassImported++;\r\n\r\n\t\t\t\tjsonReader.readNext(OJSONReader.NEXT_IN_ARRAY);\r\n\t\t\t} while (jsonReader.lastChar() == ',');\r\n\r\n\t\t\t// REBUILD ALL THE INHERITANCE\r\n\t\t\tfor (Map.Entry<OClass, String> entry : superClasses.entrySet()) {\r\n\t\t\t\tcls.setSuperClass(database.getMetadata().getSchema().getClass(entry.getValue()));\r\n\t\t\t}\r\n\r\n\t\t\t// SET ALL THE LINKED CLASSES\r\n\t\t\tfor (Map.Entry<OProperty, String> entry : linkedClasses.entrySet()) {\r\n\t\t\t\tentry.getKey().setLinkedClass(database.getMetadata().getSchema().getClass(entry.getValue()));\r\n\t\t\t}\r\n\r\n\t\t\tlistener.onMessage(\"OK (\" + classImported + \" entries)\");\r\n\r\n\t\t\tjsonReader.readNext(OJSONReader.END_OBJECT);\r\n\t\t\tjsonReader.readNext(OJSONReader.COMMA_SEPARATOR);\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tlistener.onMessage(\"ERROR (\" + classImported + \" entries): \" + e);\r\n\t\t}\r\n\t}","id":29265,"modified_method":"private void importSchema() throws IOException, ParseException {\r\n\t\tlistener.onMessage(\"\\nImporting database schema...\");\r\n\r\n\t\tjsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"schema\\\"\").readNext(OJSONReader.BEGIN_OBJECT);\r\n\t\t@SuppressWarnings(\"unused\")\r\n\t\tint schemaVersion = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"version\\\"\")\r\n\t\t\t\t.readNumber(OJSONReader.ANY_NUMBER, true);\r\n\t\tjsonReader.readNext(OJSONReader.COMMA_SEPARATOR).readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"classes\\\"\")\r\n\t\t\t\t.readNext(OJSONReader.BEGIN_COLLECTION);\r\n\r\n\t\tlong classImported = 0;\r\n\t\tString className;\r\n\t\tint classId;\r\n\t\tint classDefClusterId;\r\n\t\tString classClusterIds;\r\n\t\tString classSuper = null;\r\n\r\n\t\tOClass cls;\r\n\r\n\t\ttry {\r\n\t\t\tdo {\r\n\t\t\t\tjsonReader.readNext(OJSONReader.BEGIN_OBJECT);\r\n\r\n\t\t\t\tclassName = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"name\\\"\")\r\n\t\t\t\t\t\t.readString(OJSONReader.COMMA_SEPARATOR);\r\n\r\n\t\t\t\tclassId = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"id\\\"\").readInteger(OJSONReader.COMMA_SEPARATOR);\r\n\r\n\t\t\t\tclassDefClusterId = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"default-cluster-id\\\"\")\r\n\t\t\t\t\t\t.readInteger(OJSONReader.COMMA_SEPARATOR);\r\n\r\n\t\t\t\tclassClusterIds = jsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT).checkContent(\"\\\"cluster-ids\\\"\")\r\n\t\t\t\t\t\t.readString(OJSONReader.NEXT_IN_OBJECT).trim();\r\n\r\n\t\t\t\tcls = database.getMetadata().getSchema().getClass(className);\r\n\r\n\t\t\t\tif (cls != null) {\r\n\t\t\t\t\tif (cls.getDefaultClusterId() != classDefClusterId)\r\n\t\t\t\t\t\tcls.setDefaultClusterId(classDefClusterId);\r\n\t\t\t\t} else\r\n\t\t\t\t\tcls = database.getMetadata().getSchema().createClass(className, classDefClusterId);\r\n\r\n\t\t\t\tif (classId != cls.getId())\r\n\t\t\t\t\tthrow new OSchemaException(\"Imported class '\" + className + \"' has id=\" + cls.getId() + \" different from the original: \"\r\n\t\t\t\t\t\t\t+ classId);\r\n\r\n\t\t\t\tif (classClusterIds != null) {\r\n\t\t\t\t\t// REMOVE BRACES\r\n\t\t\t\t\tclassClusterIds = classClusterIds.substring(1, classClusterIds.length() - 1);\r\n\r\n\t\t\t\t\t// ASSIGN OTHER CLUSTER IDS\r\n\t\t\t\t\tfor (int i : OStringSerializerHelper.splitIntArray(classClusterIds)) {\r\n\t\t\t\t\t\tcls.addClusterIds(i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tString value;\r\n\t\t\t\twhile (jsonReader.lastChar() == ',') {\r\n\t\t\t\t\tjsonReader.readNext(OJSONReader.FIELD_ASSIGNMENT);\r\n\t\t\t\t\tvalue = jsonReader.getValue();\r\n\r\n\t\t\t\t\tif (value.equals(\"\\\"super-class\\\"\")) {\r\n\t\t\t\t\t\tclassSuper = jsonReader.readString(OJSONReader.NEXT_IN_OBJECT);\r\n\t\t\t\t\t\tsuperClasses.put(cls, classSuper);\r\n\t\t\t\t\t} else if (value.equals(\"\\\"properties\\\"\")) {\r\n\t\t\t\t\t\t// GET PROPERTIES\r\n\t\t\t\t\t\tjsonReader.readString(OJSONReader.BEGIN_COLLECTION);\r\n\r\n\t\t\t\t\t\twhile (jsonReader.lastChar() != ']') {\r\n\t\t\t\t\t\t\timportProperty(cls);\r\n\r\n\t\t\t\t\t\t\tif (jsonReader.lastChar() == '}')\r\n\t\t\t\t\t\t\t\tjsonReader.readNext(OJSONReader.NEXT_IN_ARRAY);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tjsonReader.readNext(OJSONReader.END_OBJECT);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tclassImported++;\r\n\r\n\t\t\t\tjsonReader.readNext(OJSONReader.NEXT_IN_ARRAY);\r\n\t\t\t} while (jsonReader.lastChar() == ',');\r\n\r\n\t\t\t// REBUILD ALL THE INHERITANCE\r\n\t\t\tfor (Map.Entry<OClass, String> entry : superClasses.entrySet()) {\r\n\t\t\t\tcls.setSuperClass(database.getMetadata().getSchema().getClass(entry.getValue()));\r\n\t\t\t}\r\n\r\n\t\t\t// SET ALL THE LINKED CLASSES\r\n\t\t\tfor (Map.Entry<OProperty, String> entry : linkedClasses.entrySet()) {\r\n\t\t\t\tentry.getKey().setLinkedClass(database.getMetadata().getSchema().getClass(entry.getValue()));\r\n\t\t\t}\r\n\r\n\t\t\tlistener.onMessage(\"OK (\" + classImported + \" classes)\");\r\n\r\n\t\t\tjsonReader.readNext(OJSONReader.END_OBJECT);\r\n\t\t\tjsonReader.readNext(OJSONReader.COMMA_SEPARATOR);\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tlistener.onMessage(\"ERROR (\" + classImported + \" entries): \" + e);\r\n\t\t}\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public List<OGraphVertex> traverse(final int iStartLevel, final int iEndLevel) {\r\n\t\tOSQLQuery<ODocument> result = new OSQLQuery<ODocument>(\"select from \" + getClass().getSimpleName() + \" where\") {\r\n\t\t};\r\n\t\treturn null;\r\n\t}","id":29266,"modified_method":"public List<OGraphVertex> traverse(final int iStartLevel, final int iEndLevel) {\r\n\t\treturn null;\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static String writeValue(final Object iValue) throws IOException {\r\n\t\tStringBuilder buffer = new StringBuilder();\r\n\r\n\t\tif (iValue == null)\r\n\t\t\tbuffer.append(\"\\\"null\\\"\");\r\n\r\n\t\telse if (iValue instanceof ORecord<?>) {\r\n\t\t\tORecord<?> linked = (ORecord<?>) iValue;\r\n\t\t\tif (linked.getIdentity().isValid()) {\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t\tbuffer.append(linked.getIdentity().toString());\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t} else {\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t\tbuffer.append(linked.toString());\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t}\r\n\r\n\t\t} else if (iValue.getClass().isArray()) {\r\n\r\n\t\t\tif (iValue instanceof byte[]) {\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t\tbyte[] source = (byte[]) iValue;\r\n\t\t\t\tint v;\r\n\t\t\t\tfor (int i = 0; i < source.length; ++i) {\r\n\t\t\t\t\tv = source[i];\r\n\t\t\t\t\tif (v < 0)\r\n\t\t\t\t\t\tv = (int) v & 0xFF;\r\n\t\t\t\t\tbuffer.append(String.format(\"%03d\", v));\r\n\t\t\t\t}\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t} else {\r\n\t\t\t\tbuffer.append('[');\r\n\t\t\t\tfor (int i = 0; i < Array.getLength(iValue); ++i) {\r\n\t\t\t\t\tif (i > 0)\r\n\t\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\t\tbuffer.append(writeValue(Array.get(iValue, i)));\r\n\t\t\t\t}\r\n\t\t\t\tbuffer.append(']');\r\n\t\t\t}\r\n\r\n\t\t} else if (iValue instanceof Collection<?>) {\r\n\t\t\tCollection<Object> coll = (Collection<Object>) iValue;\r\n\t\t\tbuffer.append('[');\r\n\t\t\tint i = 0;\r\n\t\t\tfor (Iterator<Object> it = coll.iterator(); it.hasNext(); ++i) {\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(writeValue(it.next()));\r\n\t\t\t}\r\n\t\t\tbuffer.append(']');\r\n\r\n\t\t} else if (iValue instanceof Map<?, ?>) {\r\n\t\t\tMap<Object, Object> map = (Map<Object, Object>) iValue;\r\n\t\t\tbuffer.append('{');\r\n\t\t\tint i = 0;\r\n\t\t\tEntry<Object, Object> entry;\r\n\t\t\tfor (Iterator<Entry<Object, Object>> it = map.entrySet().iterator(); it.hasNext(); ++i) {\r\n\t\t\t\tentry = it.next();\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(writeValue(entry.getKey()));\r\n\t\t\t\tbuffer.append(\": \");\r\n\t\t\t\tbuffer.append(writeValue(entry.getValue()));\r\n\t\t\t}\r\n\t\t\tbuffer.append('}');\r\n\r\n\t\t} else if (iValue instanceof String || iValue instanceof ORecordId || iValue instanceof Date) {\r\n\t\t\tString v = iValue.toString();\r\n\t\t\tif (v.startsWith(\"\\\"\"))\r\n\t\t\t\tbuffer.append(v);\r\n\t\t\telse {\r\n\t\t\t\tbuffer.append('\"');\r\n\t\t\t\tbuffer.append(v);\r\n\t\t\t\tbuffer.append('\"');\r\n\t\t\t}\r\n\t\t} else\r\n\t\t\tbuffer.append(iValue.toString());\r\n\r\n\t\treturn buffer.toString();\r\n\t}","id":29267,"modified_method":"public static String writeValue(final Object iValue) throws IOException {\r\n\t\tStringBuilder buffer = new StringBuilder();\r\n\r\n\t\tif (iValue == null)\r\n\t\t\tbuffer.append(\"\\\"null\\\"\");\r\n\r\n\t\telse if (iValue instanceof ORecord<?>) {\r\n\t\t\tORecord<?> linked = (ORecord<?>) iValue;\r\n\t\t\tif (linked.getIdentity().isValid()) {\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t\tbuffer.append(linked.getIdentity().toString());\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t} else {\r\n\t\t\t\tbuffer.append(linked.toJSON(\"id,ver,class,ident:6\"));\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if (iValue.getClass().isArray()) {\r\n\r\n\t\t\tif (iValue instanceof byte[]) {\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t\tbyte[] source = (byte[]) iValue;\r\n\t\t\t\tint v;\r\n\t\t\t\tfor (int i = 0; i < source.length; ++i) {\r\n\t\t\t\t\tv = source[i];\r\n\t\t\t\t\tif (v < 0)\r\n\t\t\t\t\t\tv = (int) v & 0xFF;\r\n\t\t\t\t\tbuffer.append(String.format(\"%03d\", v));\r\n\t\t\t\t}\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t} else {\r\n\t\t\t\tbuffer.append('[');\r\n\t\t\t\tfor (int i = 0; i < Array.getLength(iValue); ++i) {\r\n\t\t\t\t\tif (i > 0)\r\n\t\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\t\tbuffer.append(writeValue(Array.get(iValue, i)));\r\n\t\t\t\t}\r\n\t\t\t\tbuffer.append(']');\r\n\t\t\t}\r\n\r\n\t\t} else if (iValue instanceof Collection<?>) {\r\n\t\t\tCollection<Object> coll = (Collection<Object>) iValue;\r\n\t\t\tbuffer.append('[');\r\n\t\t\tint i = 0;\r\n\t\t\tfor (Iterator<Object> it = coll.iterator(); it.hasNext(); ++i) {\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(writeValue(it.next()));\r\n\t\t\t}\r\n\t\t\tbuffer.append(']');\r\n\r\n\t\t} else if (iValue instanceof Map<?, ?>) {\r\n\t\t\tMap<Object, Object> map = (Map<Object, Object>) iValue;\r\n\t\t\tbuffer.append('{');\r\n\t\t\tint i = 0;\r\n\t\t\tEntry<Object, Object> entry;\r\n\t\t\tfor (Iterator<Entry<Object, Object>> it = map.entrySet().iterator(); it.hasNext(); ++i) {\r\n\t\t\t\tentry = it.next();\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(writeValue(entry.getKey()));\r\n\t\t\t\tbuffer.append(\": \");\r\n\t\t\t\tbuffer.append(writeValue(entry.getValue()));\r\n\t\t\t}\r\n\t\t\tbuffer.append('}');\r\n\r\n\t\t} else if (iValue instanceof String || iValue instanceof ORecordId || iValue instanceof Date) {\r\n\t\t\tString v = iValue.toString();\r\n\t\t\tif (v.startsWith(\"\\\"\"))\r\n\t\t\t\tbuffer.append(v);\r\n\t\t\telse {\r\n\t\t\t\tbuffer.append('\"');\r\n\t\t\t\tbuffer.append(v);\r\n\t\t\t\tbuffer.append('\"');\r\n\t\t\t}\r\n\t\t} else\r\n\t\t\tbuffer.append(iValue.toString());\r\n\r\n\t\treturn buffer.toString();\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Object fieldFromStream(final ODatabaseRecord<?> iDatabase, final OType iType, OClass iLinkedClass, OType iLinkedType,\r\n\t\t\tfinal String iName, final String iValue) {\r\n\r\n\t\tif (iValue == null)\r\n\t\t\treturn null;\r\n\r\n\t\tswitch (iType) {\r\n\t\tcase EMBEDDEDLIST:\r\n\t\tcase EMBEDDEDSET:\r\n\t\t\treturn embeddedCollectionFromStream(iDatabase, iType, iLinkedClass, iLinkedType, iValue);\r\n\r\n\t\tcase LINKLIST:\r\n\t\tcase LINKSET: {\r\n\t\t\tif (iValue.length() == 0)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t// REMOVE BEGIN & END COLLECTIONS CHARACTERS IF IT'S A COLLECTION\r\n\t\t\tString value = iValue.startsWith(\"[\") ? iValue.substring(1, iValue.length() - 1) : iValue;\r\n\r\n\t\t\tCollection<Object> coll = iType == OType.LINKLIST ? new OLazyRecordList(iDatabase, ODocument.RECORD_TYPE)\r\n\t\t\t\t\t: new OLazyRecordSet(iDatabase, ODocument.RECORD_TYPE);\r\n\r\n\t\t\tif (value.length() == 0)\r\n\t\t\t\treturn coll;\r\n\r\n\t\t\tfinal List<String> items = OStringSerializerHelper.smartSplit(value, OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\tfor (String item : items) {\r\n\t\t\t\t// GET THE CLASS NAME IF ANY\r\n\t\t\t\tint classSeparatorPos = value.indexOf(OStringSerializerHelper.CLASS_SEPARATOR);\r\n\t\t\t\tif (classSeparatorPos > -1) {\r\n\t\t\t\t\tString className = value.substring(1, classSeparatorPos);\r\n\t\t\t\t\tif (className != null) {\r\n\t\t\t\t\t\tiLinkedClass = iDatabase.getMetadata().getSchema().getClass(className);\r\n\t\t\t\t\t\titem = item.substring(classSeparatorPos + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else\r\n\t\t\t\t\titem = item.substring(1);\r\n\r\n\t\t\t\tcoll.add(new ORecordId(item));\r\n\t\t\t\t// coll.add(new ODocument(iDatabase, iLinkedClass != null ? iLinkedClass.getName() : null, new ORecordId(item)));\r\n\t\t\t}\r\n\r\n\t\t\treturn coll;\r\n\t\t}\r\n\t\tcase EMBEDDEDMAP: {\r\n\t\t\tif (iValue.length() == 0)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t// REMOVE BEGIN & END MAP CHARACTERS\r\n\t\t\tString value = iValue.substring(1, iValue.length() - 1);\r\n\r\n\t\t\t@SuppressWarnings(\"rawtypes\")\r\n\t\t\tfinal Map map = new OLazyRecordMap(iDatabase, ODocument.RECORD_TYPE);\r\n\r\n\t\t\tif (value.length() == 0)\r\n\t\t\t\treturn map;\r\n\r\n\t\t\tfinal List<String> items = OStringSerializerHelper.smartSplit(value, OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\t// EMBEDDED LITERALS\r\n\t\t\tList<String> entry;\r\n\t\t\tString mapValue;\r\n\t\t\tfor (String item : items) {\r\n\t\t\t\tif (item != null && item.length() > 0) {\r\n\t\t\t\t\tentry = OStringSerializerHelper.split(item, OStringSerializerHelper.ENTRY_SEPARATOR);\r\n\t\t\t\t\tif (entry.size() > 0) {\r\n\t\t\t\t\t\tmapValue = entry.get(1);\r\n\r\n\t\t\t\t\t\tif (iLinkedType == null) {\r\n\t\t\t\t\t\t\tif (mapValue.length() > 0) {\r\n\t\t\t\t\t\t\t\tif (mapValue.startsWith(OStringSerializerHelper.LINK)) {\r\n\t\t\t\t\t\t\t\t\tiLinkedType = OType.LINK;\r\n\r\n\t\t\t\t\t\t\t\t\t// GET THE CLASS NAME IF ANY\r\n\t\t\t\t\t\t\t\t\tint classSeparatorPos = value.indexOf(OStringSerializerHelper.CLASS_SEPARATOR);\r\n\t\t\t\t\t\t\t\t\tif (classSeparatorPos > -1) {\r\n\t\t\t\t\t\t\t\t\t\tString className = value.substring(1, classSeparatorPos);\r\n\t\t\t\t\t\t\t\t\t\tif (className != null)\r\n\t\t\t\t\t\t\t\t\t\t\tiLinkedClass = iDatabase.getMetadata().getSchema().getClass(className);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else if (mapValue.charAt(0) == OStringSerializerHelper.EMBEDDED) {\r\n\t\t\t\t\t\t\t\t\tiLinkedType = OType.EMBEDDED;\r\n\t\t\t\t\t\t\t\t} else if (Character.isDigit(mapValue.charAt(0)) || mapValue.charAt(0) == '+' || mapValue.charAt(0) == '-') {\r\n\t\t\t\t\t\t\t\t\tiLinkedType = getNumber(mapValue);\r\n\t\t\t\t\t\t\t\t} else if (mapValue.charAt(0) == '\\'' || mapValue.charAt(0) == '\"')\r\n\t\t\t\t\t\t\t\t\tiLinkedType = OType.STRING;\r\n\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\tiLinkedType = OType.EMBEDDED;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmap.put((String) OStringSerializerHelper.fieldTypeFromStream(OType.STRING, entry.get(0)),\r\n\t\t\t\t\t\t\t\tOStringSerializerHelper.fieldTypeFromStream(iLinkedType, mapValue));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn map;\r\n\t\t}\r\n\r\n\t\tcase LINK:\r\n\t\t\tif (iValue.length() > 1) {\r\n\t\t\t\tint pos = iValue.indexOf(OStringSerializerHelper.CLASS_SEPARATOR);\r\n\t\t\t\tif (pos > -1)\r\n\t\t\t\t\tiLinkedClass = iDatabase.getMetadata().getSchema().getClass(iValue.substring(OStringSerializerHelper.LINK.length(), pos));\r\n\t\t\t\telse\r\n\t\t\t\t\tpos = 0;\r\n\r\n\t\t\t\treturn new ORecordId(iValue.substring(pos + 1));\r\n\t\t\t\t// return new ODocument(iDatabase, iLinkedClass != null ? iLinkedClass.getName() : null, new ORecordId(\r\n\t\t\t\t// iValue.substring(pos + 1)));\r\n\t\t\t} else\r\n\t\t\t\treturn null;\r\n\r\n\t\tdefault:\r\n\t\t\treturn OStringSerializerHelper.fieldTypeFromStream(iType, iValue);\r\n\t\t}\r\n\t}","id":29268,"modified_method":"public Object fieldFromStream(final ODatabaseRecord<?> iDatabase, final OType iType, OClass iLinkedClass, OType iLinkedType,\r\n\t\t\tfinal String iName, final String iValue) {\r\n\r\n\t\tif (iValue == null)\r\n\t\t\treturn null;\r\n\r\n\t\tswitch (iType) {\r\n\t\tcase EMBEDDEDLIST:\r\n\t\tcase EMBEDDEDSET:\r\n\t\t\treturn embeddedCollectionFromStream(iDatabase, iType, iLinkedClass, iLinkedType, iValue);\r\n\r\n\t\tcase LINKLIST:\r\n\t\tcase LINKSET: {\r\n\t\t\tif (iValue.length() == 0)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t// REMOVE BEGIN & END COLLECTIONS CHARACTERS IF IT'S A COLLECTION\r\n\t\t\tString value = iValue.startsWith(\"[\") ? iValue.substring(1, iValue.length() - 1) : iValue;\r\n\r\n\t\t\tCollection<Object> coll = iType == OType.LINKLIST ? new OLazyRecordList(iDatabase, ODocument.RECORD_TYPE)\r\n\t\t\t\t\t: new OLazyRecordSet(iDatabase, ODocument.RECORD_TYPE);\r\n\r\n\t\t\tif (value.length() == 0)\r\n\t\t\t\treturn coll;\r\n\r\n\t\t\tfinal List<String> items = OStringSerializerHelper.smartSplit(value, OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\tfor (String item : items) {\r\n\t\t\t\t// GET THE CLASS NAME IF ANY\r\n\t\t\t\tint classSeparatorPos = value.indexOf(OStringSerializerHelper.CLASS_SEPARATOR);\r\n\t\t\t\tif (classSeparatorPos > -1) {\r\n\t\t\t\t\tString className = value.substring(1, classSeparatorPos);\r\n\t\t\t\t\tif (className != null) {\r\n\t\t\t\t\t\tiLinkedClass = iDatabase.getMetadata().getSchema().getClass(className);\r\n\t\t\t\t\t\titem = item.substring(classSeparatorPos + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else\r\n\t\t\t\t\titem = item.substring(1);\r\n\r\n\t\t\t\tcoll.add(new ORecordId(item));\r\n\t\t\t\t// coll.add(new ODocument(iDatabase, iLinkedClass != null ? iLinkedClass.getName() : null, new ORecordId(item)));\r\n\t\t\t}\r\n\r\n\t\t\treturn coll;\r\n\t\t}\r\n\t\tcase EMBEDDEDMAP: {\r\n\t\t\treturn embeddedMapFromStream(iDatabase, iLinkedType, iValue);\r\n\t\t}\r\n\r\n\t\tcase LINK:\r\n\t\t\tif (iValue.length() > 1) {\r\n\t\t\t\tint pos = iValue.indexOf(OStringSerializerHelper.CLASS_SEPARATOR);\r\n\t\t\t\tif (pos > -1)\r\n\t\t\t\t\tiLinkedClass = iDatabase.getMetadata().getSchema().getClass(iValue.substring(OStringSerializerHelper.LINK.length(), pos));\r\n\t\t\t\telse\r\n\t\t\t\t\tpos = 0;\r\n\r\n\t\t\t\treturn new ORecordId(iValue.substring(pos + 1));\r\n\t\t\t\t// return new ODocument(iDatabase, iLinkedClass != null ? iLinkedClass.getName() : null, new ORecordId(\r\n\t\t\t\t// iValue.substring(pos + 1)));\r\n\t\t\t} else\r\n\t\t\t\treturn null;\r\n\r\n\t\tdefault:\r\n\t\t\treturn OStringSerializerHelper.fieldTypeFromStream(iType, iValue);\r\n\t\t}\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic ORecordInternal<?> fromString(final ODatabaseRecord<?> iDatabase, String iSource, final ORecordInternal<?> iRecord) {\r\n\t\ttry {\r\n\t\t\tiSource = iSource.trim();\r\n\r\n\t\t\tif (iRecord instanceof ODocument) {\r\n\t\t\t\t// DOCUMENT\r\n\t\t\t\tif (!iSource.startsWith(\"{\") || !iSource.endsWith(\"}\"))\r\n\t\t\t\t\tthrow new OSerializationException(\"Error on unmarshalling JSON content: content must be embraced by { }\");\r\n\r\n\t\t\t\tiSource = iSource.substring(1, iSource.length() - 1).trim();\r\n\r\n\t\t\t\tString[] fields = OStringParser.getWords(iSource, \":,\");\r\n\r\n\t\t\t\tif (fields != null && fields.length > 0) {\r\n\t\t\t\t\tODocument doc = (ODocument) iRecord;\r\n\r\n\t\t\t\t\tboolean isNew = !doc.getIdentity().isValid();\r\n\r\n\t\t\t\t\tString fieldName;\r\n\t\t\t\t\tString fieldValue;\r\n\r\n\t\t\t\t\tfor (int i = 0; i < fields.length; i += 2) {\r\n\t\t\t\t\t\tfieldName = fields[i];\r\n\t\t\t\t\t\tfieldValue = fields[i + 1];\r\n\t\t\t\t\t\tif (fieldName.equals(ATTRIBUTE_CLASS))\r\n\t\t\t\t\t\t\tdoc.setClassName(fields[i + 1]);\r\n\t\t\t\t\t\telse if (fieldName.equals(ATTRIBUTE_ID)) {\r\n\t\t\t\t\t\t\tif (isNew) {\r\n\t\t\t\t\t\t\t\t// NEW RECORD: SET THE RECORD ID\r\n\t\t\t\t\t\t\t\tORecordId rid = new ORecordId(fieldValue);\r\n\t\t\t\t\t\t\t\tdoc.setIdentity(rid.clusterId, rid.clusterPosition);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (fieldName.equals(ATTRIBUTE_VERSION)) {\r\n\t\t\t\t\t\t\tif (!isNew) {\r\n\t\t\t\t\t\t\t\t// UPDATE RECORD: SET THE VERSION NUMBER\r\n\t\t\t\t\t\t\t\tdoc.setVersion(Integer.parseInt(fieldValue));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (fieldValue.equals(\"null\"))\r\n\t\t\t\t\t\t\t\tdoc.field(fieldName, null);\r\n\t\t\t\t\t\t\telse if (fieldValue.startsWith(\"{\") && fieldValue.endsWith(\"}\")) {\r\n\t\t\t\t\t\t\t\t// MAP\r\n\t\t\t\t\t\t\t\tMap<String, String> map = OStringSerializerHelper.getMap(fieldValue);\r\n\t\t\t\t\t\t\t\tdoc.field(fieldName, map);\r\n\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\tdoc.field(fieldName, fieldValue);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (iRecord instanceof ORecordColumn) {\r\n\t\t\t\t// COLUMN\r\n\r\n\t\t\t} else if (iRecord instanceof ORecordStringable) {\r\n\t\t\t\t// FLAT\r\n\t\t\t\t((ORecordStringable) iRecord).value(iSource);\r\n\r\n\t\t\t} else if (iRecord instanceof ORecordBytes) {\r\n\t\t\t\t// BYTES\r\n\t\t\t\tint b;\r\n\t\t\t\tint offset;\r\n\t\t\t\tbyte[] buffer = new byte[iSource.length() / 3];\r\n\t\t\t\tfor (int i = 0; i < buffer.length; ++i) {\r\n\t\t\t\t\toffset = i * 3;\r\n\t\t\t\t\tb = Integer.parseInt(iSource.substring(offset, offset + 3));\r\n\t\t\t\t\tbuffer[i] = (byte) b;\r\n\t\t\t\t}\r\n\t\t\t\tiRecord.fromStream(buffer);\r\n\t\t\t}\r\n\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new OSerializationException(\"Error on unmarshalling JSON content\", e);\r\n\t\t}\r\n\t\treturn iRecord;\r\n\t}","id":29269,"modified_method":"@Override\r\n\tpublic ORecordInternal<?> fromString(final ODatabaseRecord<?> iDatabase, String iSource, ORecordInternal<?> iRecord) {\r\n\t\tiSource = iSource.trim();\r\n\t\tif (!iSource.startsWith(\"{\") || !iSource.endsWith(\"}\"))\r\n\t\t\tthrow new OSerializationException(\"Error on unmarshalling JSON content: content must be embraced by { }\");\r\n\r\n\t\tif (iRecord != null)\r\n\t\t\tiRecord.setDirty();\r\n\r\n\t\tiSource = iSource.substring(1, iSource.length() - 1).trim();\r\n\r\n\t\tString[] fields = OStringParser.getWords(iSource, \":,\");\r\n\r\n\t\ttry {\r\n\t\t\tif (fields != null && fields.length > 0) {\r\n\t\t\t\tString fieldName;\r\n\t\t\t\tString fieldValue;\r\n\r\n\t\t\t\tfor (int i = 0; i < fields.length; i += 2) {\r\n\t\t\t\t\tfieldName = fields[i];\r\n\t\t\t\t\tfieldValue = fields[i + 1];\r\n\r\n\t\t\t\t\t// RECORD ATTRIBUTES\r\n\t\t\t\t\tif (fieldName.equals(ATTRIBUTE_ID))\r\n\t\t\t\t\t\tiRecord.setIdentity(new ORecordId(fieldValue));\r\n\r\n\t\t\t\t\telse if (fieldName.equals(ATTRIBUTE_VERSION))\r\n\t\t\t\t\t\tiRecord.setVersion(Integer.parseInt(fieldValue));\r\n\r\n\t\t\t\t\telse if (fieldName.equals(ATTRIBUTE_TYPE)) {\r\n\t\t\t\t\t\tif (iRecord == null || iRecord.getRecordType() != fieldValue.charAt(0)) {\r\n\t\t\t\t\t\t\t// CREATE THE RIGHT RECORD INSTANCE\r\n\t\t\t\t\t\t\tiRecord = ORecordFactory.newInstance((byte) fieldValue.charAt(0));\r\n\t\t\t\t\t\t\tiRecord.setDatabase(iDatabase);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if (fieldName.equals(ATTRIBUTE_CLASS) && iRecord instanceof ODocument)\r\n\t\t\t\t\t\t((ODocument) iRecord).setClassName(fieldValue);\r\n\r\n\t\t\t\t\t// RECORD VALUE(S)\r\n\t\t\t\t\telse if (fieldName.equals(\"value\")) {\r\n\t\t\t\t\t\tif (iRecord instanceof ORecordColumn) {\r\n\t\t\t\t\t\t\tfieldValue = fieldValue.trim();\r\n\t\t\t\t\t\t\tif (!fieldValue.startsWith(\"[\") || !fieldValue.endsWith(\"]\"))\r\n\t\t\t\t\t\t\t\tthrow new OSerializationException(\"Error on unmarshalling JSON content: value must be embraced by [ ]\");\r\n\r\n\t\t\t\t\t\t\tfieldValue = fieldValue.substring(1, fieldValue.length() - 1).trim();\r\n\r\n\t\t\t\t\t\t\tString[] items = OStringParser.getWords(fieldValue, \",\");\r\n\t\t\t\t\t\t\tfor (String item : items) {\r\n\t\t\t\t\t\t\t\t((ORecordColumn) iRecord).add(item);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else if (iRecord instanceof ORecordBytes) {\r\n\t\t\t\t\t\t\t// BYTES\r\n\t\t\t\t\t\t\tint b;\r\n\t\t\t\t\t\t\tint offset;\r\n\t\t\t\t\t\t\tbyte[] buffer = new byte[fieldValue.length() / 3];\r\n\t\t\t\t\t\t\tfor (int pos = 0; pos < buffer.length; ++pos) {\r\n\t\t\t\t\t\t\t\toffset = pos * 3;\r\n\t\t\t\t\t\t\t\tb = Integer.parseInt(fieldValue.substring(offset, offset + 3));\r\n\t\t\t\t\t\t\t\tbuffer[pos] = (byte) b;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tiRecord.fromStream(buffer);\r\n\t\t\t\t\t\t} else if (iRecord instanceof ORecordStringable) {\r\n\t\t\t\t\t\t\t((ORecordStringable) iRecord).value(fieldValue);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (iRecord instanceof ODocument)\r\n\t\t\t\t\t\t\t((ODocument) iRecord).field(fieldName, extractFieldValue(iRecord, fieldValue));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new OSerializationException(\"Error on unmarshalling JSON content\", e);\r\n\t\t}\r\n\t\treturn iRecord;\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic String toString(final ORecordInternal<?> iRecord, final String iFormat, final OUserObject2RecordHandler iObjHandler,\r\n\t\t\tfinal Map<ORecordInternal<?>, ORecordId> iMarshalledRecords) {\r\n\t\ttry {\r\n\t\t\tfinal StringWriter buffer = new StringWriter();\r\n\t\t\tfinal OJSONWriter json = new OJSONWriter(buffer);\r\n\r\n\t\t\tboolean includeVer;\r\n\t\t\tboolean includeId;\r\n\t\t\tboolean includeClazz;\r\n\t\t\tint identLevel;\r\n\r\n\t\t\tif (iFormat == null) {\r\n\t\t\t\tincludeVer = true;\r\n\t\t\t\tincludeId = true;\r\n\t\t\t\tincludeClazz = true;\r\n\t\t\t\tidentLevel = 0;\r\n\t\t\t} else {\r\n\t\t\t\tincludeVer = false;\r\n\t\t\t\tincludeId = false;\r\n\t\t\t\tincludeClazz = false;\r\n\t\t\t\tidentLevel = 0;\r\n\r\n\t\t\t\tString[] format = iFormat.split(\",\");\r\n\t\t\t\tfor (String f : format)\r\n\t\t\t\t\tif (f.equals(\"id\"))\r\n\t\t\t\t\t\tincludeId = true;\r\n\t\t\t\t\telse if (f.equals(\"ver\"))\r\n\t\t\t\t\t\tincludeVer = true;\r\n\t\t\t\t\telse if (f.equals(\"class\"))\r\n\t\t\t\t\t\tincludeClazz = true;\r\n\t\t\t\t\telse if (f.startsWith(\"ident\"))\r\n\t\t\t\t\t\tidentLevel = Integer.parseInt(f.substring(f.indexOf(\":\") + 1));\r\n\t\t\t}\r\n\r\n\t\t\tjson.beginObject(identLevel);\r\n\r\n\t\t\tif (includeId)\r\n\t\t\t\tjson.writeAttribute(identLevel + 1, true, ATTRIBUTE_ID, iRecord.getIdentity());\r\n\t\t\tif (includeVer)\r\n\t\t\t\tjson.writeAttribute(identLevel + 1, true, ATTRIBUTE_VERSION, iRecord.getVersion());\r\n\t\t\tif (includeClazz && iRecord instanceof ORecordSchemaAware<?>)\r\n\t\t\t\tjson.writeAttribute(identLevel + 1, true, ATTRIBUTE_CLASS, ((ORecordSchemaAware<?>) iRecord).getClassName());\r\n\r\n\t\t\tif (iRecord instanceof ORecordSchemaAware<?>) {\r\n\t\t\t\t// SCHEMA AWARE\r\n\t\t\t\tfinal ORecordSchemaAware<?> record = (ORecordSchemaAware<?>) iRecord;\r\n\t\t\t\tfor (String fieldName : record.fieldNames()) {\r\n\t\t\t\t\tjson.writeAttribute(identLevel + 1, true, fieldName, encode(record.field(fieldName)));\r\n\t\t\t\t}\r\n\t\t\t} else if (iRecord instanceof ORecordStringable) {\r\n\r\n\t\t\t\t// STRINGABLE\r\n\t\t\t\tfinal ORecordStringable record = (ORecordStringable) iRecord;\r\n\t\t\t\tjson.writeAttribute(identLevel + 1, true, \"value\", record.value());\r\n\t\t\t} else\r\n\t\t\t\tthrow new OSerializationException(\"Error on marshalling record of type '\" + iRecord.getClass()\r\n\t\t\t\t\t\t+ \"' to JSON. The record type can't be exported to JSON\");\r\n\r\n\t\t\tjson.endObject(identLevel);\r\n\r\n\t\t\treturn buffer.toString();\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new OSerializationException(\"Error on marshalling of record to JSON\", e);\r\n\t\t}\r\n\t}","id":29270,"modified_method":"@Override\r\n\tpublic String toString(final ORecordInternal<?> iRecord, final String iFormat, final OUserObject2RecordHandler iObjHandler,\r\n\t\t\tfinal Map<ORecordInternal<?>, ORecordId> iMarshalledRecords) {\r\n\t\ttry {\r\n\t\t\tfinal StringWriter buffer = new StringWriter();\r\n\t\t\tfinal OJSONWriter json = new OJSONWriter(buffer);\r\n\r\n\t\t\tboolean includeVer;\r\n\t\t\tboolean includeType;\r\n\t\t\tboolean includeId;\r\n\t\t\tboolean includeClazz;\r\n\t\t\tint identLevel;\r\n\r\n\t\t\tif (iFormat == null) {\r\n\t\t\t\tincludeVer = true;\r\n\t\t\t\tincludeType = true;\r\n\t\t\t\tincludeId = true;\r\n\t\t\t\tincludeClazz = true;\r\n\t\t\t\tidentLevel = 0;\r\n\t\t\t} else {\r\n\t\t\t\tincludeVer = false;\r\n\t\t\t\tincludeType = true;\r\n\t\t\t\tincludeId = false;\r\n\t\t\t\tincludeClazz = false;\r\n\t\t\t\tidentLevel = 0;\r\n\r\n\t\t\t\tString[] format = iFormat.split(\",\");\r\n\t\t\t\tfor (String f : format)\r\n\t\t\t\t\tif (f.equals(\"id\"))\r\n\t\t\t\t\t\tincludeId = true;\r\n\t\t\t\t\telse if (f.equals(\"type\"))\r\n\t\t\t\t\t\tincludeType = true;\r\n\t\t\t\t\telse if (f.equals(\"ver\"))\r\n\t\t\t\t\t\tincludeVer = true;\r\n\t\t\t\t\telse if (f.equals(\"class\"))\r\n\t\t\t\t\t\tincludeClazz = true;\r\n\t\t\t\t\telse if (f.startsWith(\"ident\"))\r\n\t\t\t\t\t\tidentLevel = Integer.parseInt(f.substring(f.indexOf(\":\") + 1));\r\n\t\t\t}\r\n\r\n\t\t\tjson.beginObject(identLevel);\r\n\r\n\t\t\tif (includeType)\r\n\t\t\t\tjson.writeAttribute(identLevel + 1, true, ATTRIBUTE_TYPE, \"\" + (char) iRecord.getRecordType());\r\n\t\t\tif (includeId)\r\n\t\t\t\tjson.writeAttribute(identLevel + 1, true, ATTRIBUTE_ID, iRecord.getIdentity());\r\n\t\t\tif (includeVer)\r\n\t\t\t\tjson.writeAttribute(identLevel + 1, true, ATTRIBUTE_VERSION, iRecord.getVersion());\r\n\t\t\tif (includeClazz && iRecord instanceof ORecordSchemaAware<?>)\r\n\t\t\t\tjson.writeAttribute(identLevel + 1, true, ATTRIBUTE_CLASS, ((ORecordSchemaAware<?>) iRecord).getClassName());\r\n\r\n\t\t\tif (iRecord instanceof ORecordSchemaAware<?>) {\r\n\t\t\t\t// SCHEMA AWARE\r\n\t\t\t\tfinal ORecordSchemaAware<?> record = (ORecordSchemaAware<?>) iRecord;\r\n\t\t\t\tfor (String fieldName : record.fieldNames()) {\r\n\t\t\t\t\tjson.writeAttribute(identLevel + 1, true, fieldName, encode(record.field(fieldName)));\r\n\t\t\t\t}\r\n\t\t\t} else if (iRecord instanceof ORecordStringable) {\r\n\r\n\t\t\t\t// STRINGABLE\r\n\t\t\t\tfinal ORecordStringable record = (ORecordStringable) iRecord;\r\n\t\t\t\tjson.writeAttribute(identLevel + 1, true, \"value\", record.value());\r\n\t\t\t} else\r\n\t\t\t\tthrow new OSerializationException(\"Error on marshalling record of type '\" + iRecord.getClass()\r\n\t\t\t\t\t\t+ \"' to JSON. The record type can't be exported to JSON\");\r\n\r\n\t\t\tjson.endObject(identLevel);\r\n\r\n\t\t\treturn buffer.toString();\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new OSerializationException(\"Error on marshalling of record to JSON\", e);\r\n\t\t}\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tString[] urlParts = checkSyntax(iRequest.url, 2, \"Syntax error: document/<database>\");\r\n\r\n\t\tiRequest.data.commandInfo = \"Create document\";\r\n\r\n\t\tODatabaseDocumentTx db = null;\r\n\t\tODocument doc = new ODocument().fromJSON(iRequest.content);\r\n\r\n\t\t// ASSURE TO MAKE THE RECORD ID INVALID\r\n\t\t((ORecordId) doc.getIdentity()).clusterPosition = ORID.CLUSTER_POS_INVALID;\r\n\r\n\t\ttry {\r\n\t\t\tdb = getProfiledDatabaseInstance(iRequest, urlParts[1]);\r\n\r\n\t\t\tdoc.setDatabase(db);\r\n\t\t\tdoc.save();\r\n\r\n\t\t} finally {\r\n\t\t\tif (db != null)\r\n\t\t\t\tOSharedDocumentDatabase.release(db);\r\n\t\t}\r\n\r\n\t\tsendTextContent(iRequest, 201, OHttpUtils.STATUS_OK_DESCRIPTION, null, OHttpUtils.CONTENT_TEXT_PLAIN, doc.getIdentity());\r\n\t}","id":29271,"modified_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tString[] urlParts = checkSyntax(iRequest.url, 2, \"Syntax error: document/<database>\");\r\n\r\n\t\tiRequest.data.commandInfo = \"Create document\";\r\n\r\n\t\tODatabaseDocumentTx db = null;\r\n\r\n\t\tODocument doc = null;\r\n\r\n\t\ttry {\r\n\t\t\tdb = getProfiledDatabaseInstance(iRequest, urlParts[1]);\r\n\r\n\t\t\tdoc = new ODocument(db).fromJSON(iRequest.content);\r\n\r\n\t\t\t// ASSURE TO MAKE THE RECORD ID INVALID\r\n\t\t\t((ORecordId) doc.getIdentity()).clusterPosition = ORID.CLUSTER_POS_INVALID;\r\n\r\n\t\t\tdoc.save();\r\n\r\n\t\t} finally {\r\n\t\t\tif (db != null)\r\n\t\t\t\tOSharedDocumentDatabase.release(db);\r\n\t\t}\r\n\r\n\t\tsendTextContent(iRequest, 201, OHttpUtils.STATUS_OK_DESCRIPTION, null, OHttpUtils.CONTENT_TEXT_PLAIN,\r\n\t\t\t\tdoc != null ? doc.getIdentity() : \"?\");\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static String[] getWords(String iText, final String iSeparatorChars, final String iJumpChars) {\r\n\t\tiText = iText.trim();\r\n\r\n\t\tArrayList<String> fields = new ArrayList<String>();\r\n\t\tStringBuilder buffer = new StringBuilder();\r\n\t\tchar stringBeginChar = ' ';\r\n\t\tchar c;\r\n\t\tint openBraket = 0;\r\n\t\tboolean charFound;\r\n\r\n\t\tfor (int i = 0; i < iText.length(); ++i) {\r\n\t\t\tc = iText.charAt(i);\r\n\t\t\tif (openBraket == 0 && (c == '\\'' || c == '\"')) {\r\n\t\t\t\tif (stringBeginChar != ' ') {\r\n\t\t\t\t\t// CLOSE THE STRING?\r\n\t\t\t\t\tif (stringBeginChar == c) {\r\n\t\t\t\t\t\t// SAME CHAR AS THE BEGIN OF THE STRING: CLOSE IT AND PUSH\r\n\t\t\t\t\t\tstringBeginChar = ' ';\r\n\t\t\t\t\t\tfields.add(buffer.toString());\r\n\t\t\t\t\t\tbuffer.setLength(0);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// START STRING\r\n\t\t\t\t\tstringBeginChar = c;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t} else if (stringBeginChar == ' ') {\r\n\t\t\t\tif (c == '[')\r\n\t\t\t\t\topenBraket++;\r\n\t\t\t\telse if (c == ']')\r\n\t\t\t\t\topenBraket--;\r\n\t\t\t\telse if (openBraket == 0) {\r\n\t\t\t\t\tcharFound = false;\r\n\t\t\t\t\tfor (int sepIndex = 0; sepIndex < iSeparatorChars.length(); ++sepIndex) {\r\n\t\t\t\t\t\tif (iSeparatorChars.charAt(sepIndex) == c) {\r\n\t\t\t\t\t\t\tcharFound = true;\r\n\t\t\t\t\t\t\tif (buffer.length() > 0) {\r\n\t\t\t\t\t\t\t\t// SEPARATOR (OUTSIDE A STRING): PUSH\r\n\t\t\t\t\t\t\t\tfields.add(buffer.toString());\r\n\t\t\t\t\t\t\t\tbuffer.setLength(0);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (charFound)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// CHECK IF IT MUST JUMP THE CHAR\r\n\t\t\tif (buffer.length() == 0) {\r\n\t\t\t\tcharFound = false;\r\n\r\n\t\t\t\tfor (int jumpIndex = 0; jumpIndex < iJumpChars.length(); ++jumpIndex) {\r\n\t\t\t\t\tif (iJumpChars.charAt(jumpIndex) == c) {\r\n\t\t\t\t\t\tcharFound = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (charFound)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tbuffer.append(c);\r\n\t\t}\r\n\r\n\t\tif (buffer.length() > 0)\r\n\t\t\t// ADD THE LAST WORD IF ANY\r\n\t\t\tfields.add(buffer.toString());\r\n\r\n\t\tString[] result = new String[fields.size()];\r\n\t\tfields.toArray(result);\r\n\t\treturn result;\r\n\t}","id":29272,"modified_method":"public static String[] getWords(String iText, final String iSeparatorChars, final String iJumpChars) {\r\n\t\tiText = iText.trim();\r\n\r\n\t\tArrayList<String> fields = new ArrayList<String>();\r\n\t\tStringBuilder buffer = new StringBuilder();\r\n\t\tchar stringBeginChar = ' ';\r\n\t\tchar c;\r\n\t\tint openBraket = 0;\r\n\t\tint openGraph = 0;\r\n\t\tboolean charFound;\r\n\r\n\t\tfor (int i = 0; i < iText.length(); ++i) {\r\n\t\t\tc = iText.charAt(i);\r\n\t\t\tif (openBraket == 0 && openGraph == 0 && (c == '\\'' || c == '\"')) {\r\n\t\t\t\tif (stringBeginChar != ' ') {\r\n\t\t\t\t\t// CLOSE THE STRING?\r\n\t\t\t\t\tif (stringBeginChar == c) {\r\n\t\t\t\t\t\t// SAME CHAR AS THE BEGIN OF THE STRING: CLOSE IT AND PUSH\r\n\t\t\t\t\t\tstringBeginChar = ' ';\r\n\t\t\t\t\t\tfields.add(buffer.toString());\r\n\t\t\t\t\t\tbuffer.setLength(0);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// START STRING\r\n\t\t\t\t\tstringBeginChar = c;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t} else if (stringBeginChar == ' ') {\r\n\t\t\t\tif (c == '[')\r\n\t\t\t\t\topenBraket++;\r\n\t\t\t\telse if (c == ']')\r\n\t\t\t\t\topenBraket--;\r\n\t\t\t\tif (c == '{')\r\n\t\t\t\t\topenGraph++;\r\n\t\t\t\telse if (c == '}')\r\n\t\t\t\t\topenGraph--;\r\n\t\t\t\telse if (openBraket == 0 && openGraph == 0) {\r\n\t\t\t\t\tcharFound = false;\r\n\t\t\t\t\tfor (int sepIndex = 0; sepIndex < iSeparatorChars.length(); ++sepIndex) {\r\n\t\t\t\t\t\tif (iSeparatorChars.charAt(sepIndex) == c) {\r\n\t\t\t\t\t\t\tcharFound = true;\r\n\t\t\t\t\t\t\tif (buffer.length() > 0) {\r\n\t\t\t\t\t\t\t\t// SEPARATOR (OUTSIDE A STRING): PUSH\r\n\t\t\t\t\t\t\t\tfields.add(buffer.toString());\r\n\t\t\t\t\t\t\t\tbuffer.setLength(0);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (charFound)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// CHECK IF IT MUST JUMP THE CHAR\r\n\t\t\tif (buffer.length() == 0) {\r\n\t\t\t\tcharFound = false;\r\n\r\n\t\t\t\tfor (int jumpIndex = 0; jumpIndex < iJumpChars.length(); ++jumpIndex) {\r\n\t\t\t\t\tif (iJumpChars.charAt(jumpIndex) == c) {\r\n\t\t\t\t\t\tcharFound = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (charFound)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tbuffer.append(c);\r\n\t\t}\r\n\r\n\t\tif (buffer.length() > 0)\r\n\t\t\t// ADD THE LAST WORD IF ANY\r\n\t\t\tfields.add(buffer.toString());\r\n\r\n\t\tString[] result = new String[fields.size()];\r\n\t\tfields.toArray(result);\r\n\t\treturn result;\r\n\t}","commit_id":"65bb0fc88a48bf3e03f27fba51b2355ceb30e351","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static String writeValue(final Object iValue) throws IOException {\r\n\t\tStringBuilder buffer = new StringBuilder();\r\n\r\n\t\tif (iValue == null)\r\n\t\t\tbuffer.append(\"\\\"null\\\"\");\r\n\r\n\t\telse if (iValue instanceof ORecordId) {\r\n\t\t\tORecordId rid = (ORecordId) iValue;\r\n\t\t\tbuffer.append(\"\\\"\");\r\n\t\t\tbuffer.append(rid.toString());\r\n\t\t\tbuffer.append('\\\"');\r\n\r\n\t\t} else if (iValue instanceof ORecord<?>) {\r\n\t\t\tORecord<?> linked = (ORecord<?>) iValue;\r\n\t\t\tif (linked.getIdentity().isValid()) {\r\n\t\t\t\tbuffer.append(\"\\\"#\");\r\n\r\n\t\t\t\tif (linked instanceof ODocument && ((ODocument) linked).getClassName() != null) {\r\n\t\t\t\t\tbuffer.append(((ODocument) linked).getClassName());\r\n\t\t\t\t\tbuffer.append('@');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbuffer.append(linked.getIdentity().toString());\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t} else {\r\n\t\t\t\tbuffer.append(linked.toJSON(\"rid,version,class,attribSameRow,indent:6\"));\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if (iValue.getClass().isArray()) {\r\n\r\n\t\t\tif (iValue instanceof byte[]) {\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t\tbyte[] source = (byte[]) iValue;\r\n\r\n\t\t\t\tbuffer.append(OBase64Utils.encodeBytes(source));\r\n\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t} else {\r\n\t\t\t\tbuffer.append('[');\r\n\t\t\t\tfor (int i = 0; i < Array.getLength(iValue); ++i) {\r\n\t\t\t\t\tif (i > 0)\r\n\t\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\t\tbuffer.append(writeValue(Array.get(iValue, i)));\r\n\t\t\t\t}\r\n\t\t\t\tbuffer.append(']');\r\n\t\t\t}\r\n\r\n\t\t} else if (iValue instanceof Collection<?>) {\r\n\t\t\tCollection<Object> coll = (Collection<Object>) iValue;\r\n\t\t\tbuffer.append('[');\r\n\t\t\tint i = 0;\r\n\t\t\tfor (Iterator<Object> it = coll.iterator(); it.hasNext(); ++i) {\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(writeValue(it.next()));\r\n\t\t\t}\r\n\t\t\tbuffer.append(']');\r\n\r\n\t\t} else if (iValue instanceof Map<?, ?>) {\r\n\t\t\tMap<Object, Object> map = (Map<Object, Object>) iValue;\r\n\t\t\tbuffer.append('{');\r\n\t\t\tint i = 0;\r\n\t\t\tEntry<Object, Object> entry;\r\n\t\t\tfor (Iterator<Entry<Object, Object>> it = map.entrySet().iterator(); it.hasNext(); ++i) {\r\n\t\t\t\tentry = it.next();\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(writeValue(entry.getKey()));\r\n\t\t\t\tbuffer.append(\": \");\r\n\t\t\t\tbuffer.append(writeValue(entry.getValue()));\r\n\t\t\t}\r\n\t\t\tbuffer.append('}');\r\n\r\n\t\t} else if (iValue instanceof String || iValue instanceof Date) {\r\n\t\t\tString v = iValue.toString();\r\n\t\t\tif (v.startsWith(\"\\\"\"))\r\n\t\t\t\tbuffer.append(v);\r\n\t\t\telse {\r\n\t\t\t\tbuffer.append('\"');\r\n\t\t\t\tbuffer.append(v);\r\n\t\t\t\tbuffer.append('\"');\r\n\t\t\t}\r\n\t\t} else\r\n\t\t\tbuffer.append(iValue.toString());\r\n\r\n\t\treturn buffer.toString();\r\n\t}","id":29273,"modified_method":"public static String writeValue(final Object iValue) throws IOException {\r\n\t\tStringBuilder buffer = new StringBuilder();\r\n\r\n\t\tif (iValue == null)\r\n\t\t\tbuffer.append(\"\\\"null\\\"\");\r\n\r\n\t\telse if (iValue instanceof ORecordId) {\r\n\t\t\tORecordId rid = (ORecordId) iValue;\r\n\t\t\tbuffer.append(\"\\\"\");\r\n\t\t\tbuffer.append(rid.toString());\r\n\t\t\tbuffer.append('\\\"');\r\n\r\n\t\t} else if (iValue instanceof ORecord<?>) {\r\n\t\t\tORecord<?> linked = (ORecord<?>) iValue;\r\n\t\t\tif (linked.getIdentity().isValid()) {\r\n\t\t\t\tbuffer.append(\"\\\"#\");\r\n\r\n//\t\t\t\tif (linked instanceof ODocument && ((ODocument) linked).getClassName() != null) {\r\n//\t\t\t\t\tbuffer.append(((ODocument) linked).getClassName());\r\n//\t\t\t\t\tbuffer.append('@');\r\n//\t\t\t\t}\r\n\r\n\t\t\t\tbuffer.append(linked.getIdentity().toString());\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t} else {\r\n\t\t\t\tbuffer.append(linked.toJSON(\"rid,version,class,attribSameRow,indent:6\"));\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if (iValue.getClass().isArray()) {\r\n\r\n\t\t\tif (iValue instanceof byte[]) {\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t\tbyte[] source = (byte[]) iValue;\r\n\r\n\t\t\t\tbuffer.append(OBase64Utils.encodeBytes(source));\r\n\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t} else {\r\n\t\t\t\tbuffer.append('[');\r\n\t\t\t\tfor (int i = 0; i < Array.getLength(iValue); ++i) {\r\n\t\t\t\t\tif (i > 0)\r\n\t\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\t\tbuffer.append(writeValue(Array.get(iValue, i)));\r\n\t\t\t\t}\r\n\t\t\t\tbuffer.append(']');\r\n\t\t\t}\r\n\r\n\t\t} else if (iValue instanceof Collection<?>) {\r\n\t\t\tCollection<Object> coll = (Collection<Object>) iValue;\r\n\t\t\tbuffer.append('[');\r\n\t\t\tint i = 0;\r\n\t\t\tfor (Iterator<Object> it = coll.iterator(); it.hasNext(); ++i) {\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(writeValue(it.next()));\r\n\t\t\t}\r\n\t\t\tbuffer.append(']');\r\n\r\n\t\t} else if (iValue instanceof Map<?, ?>) {\r\n\t\t\tMap<Object, Object> map = (Map<Object, Object>) iValue;\r\n\t\t\tbuffer.append('{');\r\n\t\t\tint i = 0;\r\n\t\t\tEntry<Object, Object> entry;\r\n\t\t\tfor (Iterator<Entry<Object, Object>> it = map.entrySet().iterator(); it.hasNext(); ++i) {\r\n\t\t\t\tentry = it.next();\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(writeValue(entry.getKey()));\r\n\t\t\t\tbuffer.append(\": \");\r\n\t\t\t\tbuffer.append(writeValue(entry.getValue()));\r\n\t\t\t}\r\n\t\t\tbuffer.append('}');\r\n\r\n\t\t} else if (iValue instanceof String || iValue instanceof Date) {\r\n\t\t\tString v = iValue.toString();\r\n\t\t\tif (v.startsWith(\"\\\"\"))\r\n\t\t\t\tbuffer.append(v);\r\n\t\t\telse {\r\n\t\t\t\tbuffer.append('\"');\r\n\t\t\t\tbuffer.append(v);\r\n\t\t\t\tbuffer.append('\"');\r\n\t\t\t}\r\n\t\t} else\r\n\t\t\tbuffer.append(iValue.toString());\r\n\r\n\t\treturn buffer.toString();\r\n\t}","commit_id":"a5c6a13b535f0a5885f2070dc03392cccb27d070","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tODatabaseDocumentTx db = null;\r\n\r\n\t\ttry {\r\n\t\t\tfinal String[] urlParts = checkSyntax(iRequest.url, 3, \"Syntax error: studio/<database>/<context>\");\r\n\r\n\t\t\tdb = getProfiledDatabaseInstance(iRequest, urlParts[1]);\r\n\r\n\t\t\tfinal String req = iRequest.content;\r\n\r\n\t\t\t// PARSE PARAMETERS\r\n\t\t\tString operation = null;\r\n\t\t\tString rid = null;\r\n\t\t\tString className = null;\r\n\r\n\t\t\tfinal Map<String, String> fields = new HashMap<String, String>();\r\n\r\n\t\t\tfinal String[] params = req.split(\"&\");\r\n\t\t\tString value;\r\n\r\n\t\t\tfor (String p : params) {\r\n\t\t\t\tString[] pairs = p.split(\"=\");\r\n\t\t\t\tvalue = pairs.length == 1 ? null : pairs[1];\r\n\r\n\t\t\t\tif (\"oper\".equals(pairs[0]))\r\n\t\t\t\t\toperation = value;\r\n\t\t\t\telse if (\"0\".equals(pairs[0]))\r\n\t\t\t\t\trid = value;\r\n\t\t\t\telse if (\"1\".equals(pairs[0]))\r\n\t\t\t\t\tclassName = value;\r\n\t\t\t\telse if (pairs[0].startsWith(\"_class\"))\r\n\t\t\t\t\tclassName = value;\r\n\t\t\t\telse if (pairs[0].startsWith(\"_\") || pairs[0].equals(\"id\"))\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\telse {\r\n\t\t\t\t\tfields.put(pairs[0], value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tString context = urlParts[2];\r\n\t\t\tif (\"document\".equals(context))\r\n\t\t\t\texecuteDocument(iRequest, db, operation, rid, className, fields);\r\n\t\t\telse if (\"classes\".equals(context))\r\n\t\t\t\texecuteClasses(iRequest, db, operation, rid, className, fields);\r\n\t\t\telse if (\"clusters\".equals(context))\r\n\t\t\t\texecuteClusters(iRequest, db, operation, rid, className, fields);\r\n\t\t\telse if (\"classProperties\".equals(context))\r\n\t\t\t\texecuteClassProperties(iRequest, db, operation, rid, className, fields);\r\n\r\n\t\t} finally {\r\n\t\t\tif (db != null)\r\n\t\t\t\tOSharedDocumentDatabase.release(db);\r\n\t\t}\r\n\t}","id":29274,"modified_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tODatabaseDocumentTx db = null;\r\n\r\n\t\ttry {\r\n\t\t\tfinal String[] urlParts = checkSyntax(iRequest.url, 3, \"Syntax error: studio/<database>/<context>\");\r\n\r\n\t\t\tdb = getProfiledDatabaseInstance(iRequest, urlParts[1]);\r\n\r\n\t\t\tfinal String req = iRequest.content;\r\n\r\n\t\t\t// PARSE PARAMETERS\r\n\t\t\tString operation = null;\r\n\t\t\tString rid = null;\r\n\t\t\tString className = null;\r\n\r\n\t\t\tfinal Map<String, String> fields = new HashMap<String, String>();\r\n\r\n\t\t\tfinal String[] params = req.split(\"&\");\r\n\t\t\tString value;\r\n\r\n\t\t\tfor (String p : params) {\r\n\t\t\t\tString[] pairs = p.split(\"=\");\r\n\t\t\t\tvalue = pairs.length == 1 ? null : pairs[1];\r\n\r\n\t\t\t\tif (\"oper\".equals(pairs[0]))\r\n\t\t\t\t\toperation = value;\r\n\t\t\t\telse if (\"0\".equals(pairs[0]))\r\n\t\t\t\t\trid = value;\r\n\t\t\t\telse if (\"1\".equals(pairs[0]))\r\n\t\t\t\t\tclassName = value;\r\n\t\t\t\telse if (pairs[0].startsWith(\"@class\"))\r\n\t\t\t\t\tclassName = value;\r\n\t\t\t\telse if (pairs[0].startsWith(\"@\") || pairs[0].equals(\"id\"))\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\telse {\r\n\t\t\t\t\tfields.put(pairs[0], value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tString context = urlParts[2];\r\n\t\t\tif (\"document\".equals(context))\r\n\t\t\t\texecuteDocument(iRequest, db, operation, rid, className, fields);\r\n\t\t\telse if (\"classes\".equals(context))\r\n\t\t\t\texecuteClasses(iRequest, db, operation, rid, className, fields);\r\n\t\t\telse if (\"clusters\".equals(context))\r\n\t\t\t\texecuteClusters(iRequest, db, operation, rid, className, fields);\r\n\t\t\telse if (\"classProperties\".equals(context))\r\n\t\t\t\texecuteClassProperties(iRequest, db, operation, rid, className, fields);\r\n\r\n\t\t} finally {\r\n\t\t\tif (db != null)\r\n\t\t\t\tOSharedDocumentDatabase.release(db);\r\n\t\t}\r\n\t}","commit_id":"a5c6a13b535f0a5885f2070dc03392cccb27d070","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void executeDocument(final OHttpRequest iRequest, final ODatabaseDocumentTx db, final String operation, final String rid,\r\n\t\t\tfinal String className, final Map<String, String> fields) throws IOException {\r\n\t\tif (\"edit\".equals(operation)) {\r\n\t\t\tiRequest.data.commandInfo = \"Studio edit document\";\r\n\r\n\t\t\tif (rid == null)\r\n\t\t\t\tthrow new IllegalArgumentException(\"Record ID not found in request\");\r\n\r\n\t\t\tfinal ODocument doc = new ODocument(db, className, new ORecordId(rid));\r\n\t\t\tdoc.load();\r\n\r\n\t\t\t// BIND ALL CHANGED FIELDS\r\n\t\t\tObject oldValue;\r\n\t\t\tObject newValue;\r\n\t\t\tfor (Entry<String, String> f : fields.entrySet()) {\r\n\t\t\t\toldValue = doc.field(f.getKey());\r\n\t\t\t\tnewValue = f.getValue();\r\n\r\n\t\t\t\tif (oldValue != null) {\r\n\t\t\t\t\tif (oldValue instanceof ORecord<?>) {\r\n\t\t\t\t\t\tORecord<?> rec = (ORecord<?>) oldValue;\r\n\t\t\t\t\t\tORecordId newRid = new ORecordId(f.getValue());\r\n\r\n\t\t\t\t\t\tif (!rec.getIdentity().equals(newRid)) {\r\n\t\t\t\t\t\t\t// CHANGED RID\r\n\t\t\t\t\t\t\t((ORecordId) rec.getIdentity()).fromString(f.getValue());\r\n\r\n\t\t\t\t\t\t\t// RELOAD TO ASSURE IT EXISTS\r\n\t\t\t\t\t\t\trec.load();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnewValue = oldValue;\r\n\t\t\t\t\t} else if (oldValue instanceof Collection<?>) {\r\n\t\t\t\t\t\tnewValue = new ArrayList<ODocument>();\r\n\r\n\t\t\t\t\t\tif (f.getValue() != null) {\r\n\t\t\t\t\t\t\tString[] items = f.getValue().split(\",\");\r\n\t\t\t\t\t\t\tfor (String s : items) {\r\n\t\t\t\t\t\t\t\t((List<ODocument>) newValue).add(new ODocument(db, new ORecordId(s)));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdoc.field(f.getKey(), newValue);\r\n\t\t\t}\r\n\r\n\t\t\tdoc.save();\r\n\t\t\tsendTextContent(iRequest, OHttpUtils.STATUS_OK_CODE, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, \"Record \" + rid\r\n\t\t\t\t\t+ \" updated successfully.\");\r\n\t\t} else if (\"add\".equals(operation)) {\r\n\t\t\tiRequest.data.commandInfo = \"Studio create document\";\r\n\r\n\t\t\tfinal ODocument doc = new ODocument(db, className);\r\n\r\n\t\t\t// BIND ALL CHANGED FIELDS\r\n\t\t\tfor (Entry<String, String> f : fields.entrySet())\r\n\t\t\t\tdoc.field(f.getKey(), f.getValue());\r\n\r\n\t\t\tdoc.save();\r\n\t\t\tsendTextContent(iRequest, 201, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, \"Record \" + doc.getIdentity()\r\n\t\t\t\t\t+ \" updated successfully.\");\r\n\r\n\t\t} else if (\"del\".equals(operation)) {\r\n\t\t\tiRequest.data.commandInfo = \"Studio delete document\";\r\n\r\n\t\t\tif (rid == null)\r\n\t\t\t\tthrow new IllegalArgumentException(\"Record ID not found in request\");\r\n\r\n\t\t\tfinal ODocument doc = new ODocument(db, new ORecordId(rid));\r\n\t\t\tdoc.delete();\r\n\t\t\tsendTextContent(iRequest, OHttpUtils.STATUS_OK_CODE, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, \"Record \" + rid\r\n\t\t\t\t\t+ \" deleted successfully.\");\r\n\r\n\t\t} else\r\n\t\t\tsendTextContent(iRequest, 500, \"Error\", null, OHttpUtils.CONTENT_TEXT_PLAIN, \"Operation not supported\");\r\n\t}","id":29275,"modified_method":"private void executeDocument(final OHttpRequest iRequest, final ODatabaseDocumentTx db, final String operation, final String rid,\r\n\t\t\tfinal String className, final Map<String, String> fields) throws IOException {\r\n\t\tif (\"edit\".equals(operation)) {\r\n\t\t\tiRequest.data.commandInfo = \"Studio edit document\";\r\n\r\n\t\t\tif (rid == null)\r\n\t\t\t\tthrow new IllegalArgumentException(\"Record ID not found in request\");\r\n\r\n\t\t\tfinal ODocument doc = new ODocument(db, className, new ORecordId(rid));\r\n\t\t\tdoc.load();\r\n\r\n\t\t\t// BIND ALL CHANGED FIELDS\r\n\t\t\tObject oldValue;\r\n\t\t\tObject newValue;\r\n\t\t\tfor (Entry<String, String> f : fields.entrySet()) {\r\n\t\t\t\toldValue = doc.field(f.getKey());\r\n\t\t\t\tnewValue = f.getValue();\r\n\r\n\t\t\t\tif (oldValue != null) {\r\n\t\t\t\t\tif (oldValue instanceof ORecord<?>) {\r\n\t\t\t\t\t\tORecord<?> rec = (ORecord<?>) oldValue;\r\n\t\t\t\t\t\tString parsedRid = f.getValue();\r\n\t\t\t\t\t\tif (parsedRid != null && parsedRid.charAt(0) == '#')\r\n\t\t\t\t\t\t\tparsedRid = parsedRid.substring(1);\r\n\r\n\t\t\t\t\t\tif (!rec.getIdentity().toString().equals(parsedRid)) {\r\n\t\t\t\t\t\t\t// CHANGED RID\r\n\t\t\t\t\t\t\trec.reset();\r\n\t\t\t\t\t\t\t((ORecordId) rec.getIdentity()).fromString(parsedRid);\r\n\r\n\t\t\t\t\t\t\t// RELOAD TO ASSURE IT EXISTS\r\n\t\t\t\t\t\t\trec.load();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnewValue = oldValue;\r\n\t\t\t\t\t} else if (oldValue instanceof Collection<?>) {\r\n\t\t\t\t\t\tnewValue = new ArrayList<ODocument>();\r\n\r\n\t\t\t\t\t\tif (f.getValue() != null) {\r\n\t\t\t\t\t\t\tString[] items = f.getValue().split(\",\");\r\n\t\t\t\t\t\t\tfor (String s : items) {\r\n\t\t\t\t\t\t\t\t((List<ODocument>) newValue).add(new ODocument(db, new ORecordId(s)));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdoc.field(f.getKey(), newValue);\r\n\t\t\t}\r\n\r\n\t\t\tdoc.save();\r\n\t\t\tsendTextContent(iRequest, OHttpUtils.STATUS_OK_CODE, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, \"Record \" + rid\r\n\t\t\t\t\t+ \" updated successfully.\");\r\n\t\t} else if (\"add\".equals(operation)) {\r\n\t\t\tiRequest.data.commandInfo = \"Studio create document\";\r\n\r\n\t\t\tfinal ODocument doc = new ODocument(db, className);\r\n\r\n\t\t\t// BIND ALL CHANGED FIELDS\r\n\t\t\tfor (Entry<String, String> f : fields.entrySet())\r\n\t\t\t\tdoc.field(f.getKey(), f.getValue());\r\n\r\n\t\t\tdoc.save();\r\n\t\t\tsendTextContent(iRequest, 201, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, \"Record \" + doc.getIdentity()\r\n\t\t\t\t\t+ \" updated successfully.\");\r\n\r\n\t\t} else if (\"del\".equals(operation)) {\r\n\t\t\tiRequest.data.commandInfo = \"Studio delete document\";\r\n\r\n\t\t\tif (rid == null)\r\n\t\t\t\tthrow new IllegalArgumentException(\"Record ID not found in request\");\r\n\r\n\t\t\tfinal ODocument doc = new ODocument(db, new ORecordId(rid));\r\n\t\t\tdoc.delete();\r\n\t\t\tsendTextContent(iRequest, OHttpUtils.STATUS_OK_CODE, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, \"Record \" + rid\r\n\t\t\t\t\t+ \" deleted successfully.\");\r\n\r\n\t\t} else\r\n\t\t\tsendTextContent(iRequest, 500, \"Error\", null, OHttpUtils.CONTENT_TEXT_PLAIN, \"Operation not supported\");\r\n\t}","commit_id":"a5c6a13b535f0a5885f2070dc03392cccb27d070","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private static void append(@Nonnull List<String> list, @Nonnull SyncResult r) {\n        SyncedIdentity syncedIdentity = r.getIdentity();\n        String uid = JsonUtil.getJsonString((syncedIdentity == null ? null : syncedIdentity.getId()));\n        ExternalIdentityRef externalIdentityRef = (syncedIdentity == null) ? null : syncedIdentity.getExternalIdRef();\n        String eid = (externalIdentityRef == null) ? \"\\\"\\\"\" : JsonUtil.getJsonString(externalIdentityRef.getString());\n        String jsonStr = String.format(\"{op:\\\"%s\\\",uid:%s,eid:%s}\", getOperationFromStatus(r.getStatus()), uid, eid);\n        list.add(jsonStr);\n    }","id":29276,"modified_method":"private static void append(@Nonnull List<String> list, @Nonnull SyncResult r) {\n        if (r instanceof ErrorSyncResult) {\n            ((ErrorSyncResult) r).append(list);\n        } else {\n            append(list, r.getIdentity(), getOperationFromStatus(r.getStatus()), null);\n        }\n    }","commit_id":"12417cb516307809042a497224ed91f6613f2c5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static void append(@Nonnull List<String> list, @Nonnull SyncedIdentity id, @Nonnull Exception e) {\n        String uid = JsonUtil.getJsonString(id.getId());\n        ExternalIdentityRef ref = id.getExternalIdRef();\n        String eid = (ref == null) ? \"\\\"\\\"\" : JsonUtil.getJsonString(ref.getString());\n        String msg = JsonUtil.getJsonString(e.toString());\n        list.add(String.format(\"{op:\\\"ERR\\\",uid:%s,eid:%s,msg:%s}\", uid, eid, msg));\n    }","id":29277,"modified_method":"private static void append(@Nonnull List<String> list, @CheckForNull SyncedIdentity syncedIdentity, @Nonnull Exception e) {\n        append(list, syncedIdentity, \"ERR\", e.toString());\n    }","commit_id":"12417cb516307809042a497224ed91f6613f2c5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static void append(@Nonnull List<String> list, @Nonnull ExternalIdentityRef idRef, @Nonnull Exception e) {\n        String uid = JsonUtil.getJsonString(idRef.getId());\n        String eid = JsonUtil.getJsonString(idRef.getString());\n        String msg = JsonUtil.getJsonString(e.toString());\n        String jsonStr = String.format(\"{op:\\\"ERR\\\",uid:%s,eid:%s,msg:%s}\", uid, eid, msg);\n        list.add(jsonStr);\n    }","id":29278,"modified_method":"private static void append(@Nonnull List<String> list, @Nonnull List<SyncResult> results, @Nonnull Exception e) {\n        for (SyncResult result : results) {\n            if (result instanceof ErrorSyncResult) {\n                ((ErrorSyncResult) result).append(list);\n            } else {\n                SyncResult.Status st = result.getStatus();\n                switch (st) {\n                    case ADD:\n                    case DELETE:\n                    case UPDATE:\n                        append(list, result.getIdentity(), e);\n                        break;\n                    default:\n                        append(list, result);\n                }\n            }\n        }\n    }","commit_id":"12417cb516307809042a497224ed91f6613f2c5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Delegatee(@Nonnull SyncHandler handler, @Nonnull ExternalIdentityProvider idp,\n                      @Nonnull JackrabbitSession systemSession) throws SyncException, RepositoryException {\n        this.handler = handler;\n        this.idp = idp;\n\n        this.systemSession = systemSession;\n        this.userMgr = systemSession.getUserManager();\n        this.context = handler.createContext(idp, userMgr, systemSession.getValueFactory());\n\n        log.info(\"Created delegatee for SyncMBean with session: {} {}\", systemSession, systemSession.getUserID());\n    }","id":29279,"modified_method":"private Delegatee(@Nonnull SyncHandler handler, @Nonnull ExternalIdentityProvider idp,\n                      @Nonnull JackrabbitSession systemSession, int batchSize) throws SyncException, RepositoryException {\n        this.handler = handler;\n        this.idp = idp;\n\n        this.systemSession = systemSession;\n        this.userMgr = systemSession.getUserManager();\n        this.context = handler.createContext(idp, userMgr, systemSession.getValueFactory());\n        this.batchSize = batchSize;\n\n        log.info(\"Created delegatee for SyncMBean with session: {} {}\", systemSession, systemSession.getUserID());\n    }","commit_id":"12417cb516307809042a497224ed91f6613f2c5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * @see SynchronizationMBean#syncAllUsers(boolean)\n     */\n    @Nonnull\n    String[] syncAllUsers(boolean purge) {\n        try {\n            List<String> list = new ArrayList<String>();\n            context.setKeepMissing(!purge)\n                    .setForceGroupSync(true)\n                    .setForceUserSync(true);\n            Iterator<SyncedIdentity> iter = handler.listIdentities(userMgr);\n            while (iter.hasNext()) {\n                SyncedIdentity id = iter.next();\n                if (isMyIDP(id)) {\n                    try {\n                        append(list, syncUser(id.getId()));\n                    } catch (SyncException e) {\n                        log.error(ERROR_SYNC_USER, id, e);\n                        append(list, id, e);\n                    }\n                }\n            }\n            return list.toArray(new String[list.size()]);\n        } catch (RepositoryException e) {\n            throw new IllegalStateException(\"Error retrieving users for syncing\", e);\n        }\n    }","id":29280,"modified_method":"/**\n     * @see SynchronizationMBean#syncAllUsers(boolean)\n     */\n    @Nonnull\n    String[] syncAllUsers(boolean purge) {\n        try {\n            List<String> list = new ArrayList<String>();\n            context.setKeepMissing(!purge)\n                    .setForceGroupSync(true)\n                    .setForceUserSync(true);\n            Iterator<SyncedIdentity> it = handler.listIdentities(userMgr);\n\n            List<SyncResult> results = new ArrayList<SyncResult>(batchSize);\n            while (it.hasNext()) {\n                SyncedIdentity id = it.next();\n                if (isMyIDP(id)) {\n                    results = syncUser(id.getId(), false, results, list);\n                }\n            }\n            commit(list, results, NO_BATCH_SIZE);\n            return list.toArray(new String[list.size()]);\n        } catch (RepositoryException e) {\n            throw new IllegalStateException(\"Error retrieving users for syncing\", e);\n        }\n    }","commit_id":"12417cb516307809042a497224ed91f6613f2c5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * @see SynchronizationMBean#syncAllExternalUsers()\n     */\n    @Nonnull\n    String[] syncAllExternalUsers() {\n        List<String> list = new ArrayList<String>();\n        context.setForceGroupSync(true).setForceUserSync(true);\n        try {\n            Iterator<ExternalUser> iter = idp.listUsers();\n            while (iter.hasNext()) {\n                ExternalUser user = iter.next();\n                try {\n                    SyncResult r = syncUser(user);\n                    if (r.getIdentity() == null) {\n                        r = new DefaultSyncResultImpl(\n                                new DefaultSyncedIdentity(user.getId(), user.getExternalId(), false, -1),\n                                SyncResult.Status.NO_SUCH_IDENTITY\n                        );\n                        log.warn(\"sync failed. {}\", r.getIdentity());\n                    } else {\n                        log.info(\"synced {}\", r.getIdentity());\n                    }\n                    append(list, r);\n                } catch (SyncException e) {\n                    log.error(ERROR_SYNC_USER, user, e);\n                    append(list, user.getExternalId(), e);\n                }\n            }\n            return list.toArray(new String[list.size()]);\n        } catch (ExternalIdentityException e) {\n            throw new SyncRuntimeException(\"Unable to retrieve external users\", e);\n        }\n    }","id":29281,"modified_method":"/**\n     * @see SynchronizationMBean#syncAllExternalUsers()\n     */\n    @Nonnull\n    String[] syncAllExternalUsers() {\n        List<String> list = new ArrayList<String>();\n        context.setForceGroupSync(true).setForceUserSync(true);\n        try {\n            List<SyncResult> results = new ArrayList<SyncResult>(batchSize);\n            Iterator<ExternalUser> it = idp.listUsers();\n            while (it.hasNext()) {\n                ExternalUser user = it.next();\n                results = syncUser(user, results, list);\n            }\n            commit(list, results, NO_BATCH_SIZE);\n            return list.toArray(new String[list.size()]);\n        } catch (ExternalIdentityException e) {\n            throw new SyncRuntimeException(\"Unable to retrieve external users\", e);\n        }\n    }","commit_id":"12417cb516307809042a497224ed91f6613f2c5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"static Delegatee createInstance(@Nonnull final Repository repository, @Nonnull SyncHandler handler, @Nonnull ExternalIdentityProvider idp) {\n        Session systemSession;\n        try {\n            systemSession = Subject.doAs(SystemSubject.INSTANCE, new PrivilegedExceptionAction<Session>() {\n                @Override\n                public Session run() throws RepositoryException {\n                    if (repository instanceof JackrabbitRepository) {\n                        // this is to bypass GuestCredentials injection in the \"AbstractSlingRepository2\"\n                        return ((JackrabbitRepository) repository).login(null, null, null);\n                    } else {\n                        return repository.login(null, null);\n                    }\n                }\n            });\n        } catch (PrivilegedActionException e) {\n            throw new SyncRuntimeException(ERROR_CREATE_DELEGATEE, e);\n        }\n\n        if (!(systemSession instanceof JackrabbitSession)) {\n            systemSession.logout();\n            throw new SyncRuntimeException(\"Unable to create SyncContext: JackrabbitSession required.\");\n        }\n        try {\n            return new Delegatee(handler, idp, (JackrabbitSession) systemSession);\n        } catch (RepositoryException e) {\n            systemSession.logout();\n            throw new SyncRuntimeException(ERROR_CREATE_DELEGATEE, e);\n        } catch (SyncException e) {\n            systemSession.logout();\n            throw new SyncRuntimeException(ERROR_CREATE_DELEGATEE, e);\n        }\n    }","id":29282,"modified_method":"static Delegatee createInstance(@Nonnull final Repository repository,\n                                    @Nonnull SyncHandler handler,\n                                    @Nonnull ExternalIdentityProvider idp) {\n        return createInstance(repository, handler, idp, DEFAULT_BATCH_SIZE);\n    }","commit_id":"12417cb516307809042a497224ed91f6613f2c5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * @see SynchronizationMBean#purgeOrphanedUsers()\n     */\n    @Nonnull\n    String[] purgeOrphanedUsers() {\n        context.setKeepMissing(false);\n        List<String> list = new ArrayList<String>();\n        Iterator<String> orphanedIdentities = internalListOrphanedIdentities();\n        while (orphanedIdentities.hasNext()) {\n            String userId = orphanedIdentities.next();\n            try {\n                append(list, syncUser(userId));\n            } catch (SyncException e) {\n                log.warn(ERROR_SYNC_USER, userId, e);\n                append(list, new DefaultSyncedIdentity(userId, new ExternalIdentityRef(userId, idp.getName()), false, -1), e);\n            }\n        }\n        return list.toArray(new String[list.size()]);\n    }","id":29283,"modified_method":"/**\n     * @see SynchronizationMBean#purgeOrphanedUsers()\n     */\n    @Nonnull\n    String[] purgeOrphanedUsers() {\n        context.setKeepMissing(false);\n        List<String> list = new ArrayList<String>();\n        Iterator<String> orphanedIdentities = internalListOrphanedIdentities();\n\n        List<SyncResult> results = new ArrayList<SyncResult>(batchSize);\n        while (orphanedIdentities.hasNext()) {\n            String userId = orphanedIdentities.next();\n            results = syncUser(userId, true, results, list);\n        }\n        commit(list, results, NO_BATCH_SIZE);\n        return list.toArray(new String[list.size()]);\n    }","commit_id":"12417cb516307809042a497224ed91f6613f2c5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * @see SynchronizationMBean#syncExternalUsers(String[])\n     */\n    @Nonnull\n    String[] syncExternalUsers(@Nonnull String[] externalIds) {\n        List<String> list = new ArrayList<String>();\n        context.setForceGroupSync(true).setForceUserSync(true);\n        for (String externalId : externalIds) {\n            ExternalIdentityRef ref = ExternalIdentityRef.fromString(externalId);\n            if (!idp.getName().equals(ref.getProviderName())) {\n                append(list, new DefaultSyncResultImpl(new DefaultSyncedIdentity(ref.getId(), ref, false, -1), SyncResult.Status.FOREIGN));\n            } else {\n                try {\n                    ExternalIdentity id = idp.getIdentity(ref);\n                    SyncResult r;\n                    if (id != null) {\n                        r = syncUser(id);\n                    } else {\n                        r = new DefaultSyncResultImpl(\n                                new DefaultSyncedIdentity(\"\", ref, false, -1),\n                                SyncResult.Status.NO_SUCH_IDENTITY\n                        );\n                    }\n                    append(list, r);\n                } catch (ExternalIdentityException e) {\n                    log.warn(\"error while fetching the external identity {}\", externalId, e);\n                    append(list, ref, e);\n                } catch (SyncException e) {\n                    log.error(ERROR_SYNC_USER, ref, e);\n                    append(list, ref, e);\n                }\n            }\n        }\n        return list.toArray(new String[list.size()]);\n    }","id":29284,"modified_method":"/**\n     * @see SynchronizationMBean#syncExternalUsers(String[])\n     */\n    @Nonnull\n    String[] syncExternalUsers(@Nonnull String[] externalIds) {\n        List<String> list = new ArrayList<String>();\n        context.setForceGroupSync(true).setForceUserSync(true);\n\n        List<SyncResult> results = new ArrayList<SyncResult>(batchSize);\n        for (String externalId : externalIds) {\n            ExternalIdentityRef ref = ExternalIdentityRef.fromString(externalId);\n            if (!idp.getName().equals(ref.getProviderName())) {\n                results.add(new DefaultSyncResultImpl(new DefaultSyncedIdentity(ref.getId(), ref, false, -1), SyncResult.Status.FOREIGN));\n            } else {\n                try {\n                    ExternalIdentity id = idp.getIdentity(ref);\n                    if (id != null) {\n                        results = syncUser(id, results, list);\n                    } else {\n                        results.add(new DefaultSyncResultImpl(\n                                new DefaultSyncedIdentity(\"\", ref, false, -1),\n                                SyncResult.Status.NO_SUCH_IDENTITY\n                        ));\n                    }\n                } catch (ExternalIdentityException e) {\n                    log.warn(\"error while fetching the external identity {}\", externalId, e);\n                    results.add(new ErrorSyncResult(ref, e));\n                }\n            }\n        }\n        commit(list, results, NO_BATCH_SIZE);\n        return list.toArray(new String[list.size()]);\n    }","commit_id":"12417cb516307809042a497224ed91f6613f2c5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private boolean isMyIDP(@Nonnull SyncedIdentity id) {\n        ExternalIdentityRef ref = id.getExternalIdRef();\n        String providerName = (ref == null) ? null : ref.getProviderName();\n        return providerName != null && (providerName.isEmpty() || providerName.equals(idp.getName()));\n    }","id":29285,"modified_method":"@Nonnull\n    private List<SyncResult> syncUser(@Nonnull ExternalIdentity id, @Nonnull List<SyncResult> results, @Nonnull List<String> list) {\n        try {\n            SyncResult r = context.sync(id);\n            if (r.getIdentity() == null) {\n                r = new DefaultSyncResultImpl(\n                        new DefaultSyncedIdentity(id.getId(), id.getExternalId(), false, -1),\n                        SyncResult.Status.NO_SUCH_IDENTITY\n                );\n                log.warn(\"sync failed. {}\", r.getIdentity());\n            } else {\n                log.info(\"synced {}\", r.getIdentity());\n            }\n            results.add(r);\n        } catch (SyncException e) {\n            log.error(ERROR_SYNC_USER, id, e);\n            results.add(new ErrorSyncResult(id.getExternalId(), e));\n        }\n        return commit(list, results, batchSize);\n    }","commit_id":"12417cb516307809042a497224ed91f6613f2c5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * @see SynchronizationMBean#syncUsers(String[], boolean)\n     */\n    @Nonnull\n    String[] syncUsers(@Nonnull String[] userIds, boolean purge) {\n        context.setKeepMissing(!purge)\n                .setForceGroupSync(true)\n                .setForceUserSync(true);\n        List<String> list = new ArrayList<String>();\n        for (String userId : userIds) {\n            try {\n                append(list, syncUser(userId));\n            } catch (SyncException e) {\n                log.warn(ERROR_SYNC_USER, userId, e);\n                append(list, new DefaultSyncedIdentity(userId, null, false, -1), e);\n            }\n        }\n        return list.toArray(new String[list.size()]);\n    }","id":29286,"modified_method":"/**\n     * @see SynchronizationMBean#syncUsers(String[], boolean)\n     */\n    @Nonnull\n    String[] syncUsers(@Nonnull String[] userIds, boolean purge) {\n        context.setKeepMissing(!purge)\n                .setForceGroupSync(true)\n                .setForceUserSync(true);\n        List<String> list = new ArrayList<String>();\n\n        List<SyncResult> results = new ArrayList<SyncResult>(batchSize);\n        for (String userId : userIds) {\n            results = syncUser(userId, false, results, list);\n        }\n        commit(list, results, NO_BATCH_SIZE);\n        return list.toArray(new String[list.size()]);\n    }","commit_id":"12417cb516307809042a497224ed91f6613f2c5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    private Iterator<String> internalListOrphanedIdentities() {\n        try {\n            Iterator<SyncedIdentity> iter = handler.listIdentities(userMgr);\n            return Iterators.filter(Iterators.transform(iter, new Function<SyncedIdentity, String>() {\n                @Nullable\n                @Override\n                public String apply(@Nullable SyncedIdentity syncedIdentity) {\n                    if (syncedIdentity != null && isMyIDP(syncedIdentity)) {\n                        ExternalIdentityRef ref = syncedIdentity.getExternalIdRef();\n                        try {\n                            ExternalIdentity extId = (ref == null) ? null : idp.getIdentity(ref);\n                            if (extId == null) {\n                                return syncedIdentity.getId();\n                            }\n                        } catch (ExternalIdentityException e) {\n                            log.error(\"Error while fetching external identity {}\", syncedIdentity, e);\n                        }\n                    }\n                    return null;\n                }\n            }), Predicates.notNull());\n        } catch (RepositoryException e) {\n            log.error(\"Error while listing orphaned users\", e);\n            return Iterators.emptyIterator();\n        }\n    }","id":29287,"modified_method":"@Nonnull\n    private Iterator<String> internalListOrphanedIdentities() {\n        try {\n            Iterator<SyncedIdentity> it = handler.listIdentities(userMgr);\n            return Iterators.filter(Iterators.transform(it, new Function<SyncedIdentity, String>() {\n                @Nullable\n                @Override\n                public String apply(@Nullable SyncedIdentity syncedIdentity) {\n                    if (syncedIdentity != null && isMyIDP(syncedIdentity)) {\n                        ExternalIdentityRef ref = syncedIdentity.getExternalIdRef();\n                        try {\n                            ExternalIdentity extId = (ref == null) ? null : idp.getIdentity(ref);\n                            if (extId == null) {\n                                return syncedIdentity.getId();\n                            }\n                        } catch (ExternalIdentityException e) {\n                            log.error(\"Error while fetching external identity {}\", syncedIdentity, e);\n                        }\n                    }\n                    return null;\n                }\n            }), Predicates.notNull());\n        } catch (RepositoryException e) {\n            log.error(\"Error while listing orphaned users\", e);\n            return Iterators.emptyIterator();\n        }\n    }","commit_id":"12417cb516307809042a497224ed91f6613f2c5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Before\n    public void before() throws Exception {\n        idp = new TestIdentityProvider();\n        foreignIDP = new TestIdentityProvider() {\n            @Nonnull\n            public String getName() {\n                return \"anotherIDP\";\n            }\n\n        };\n        syncConfig = new DefaultSyncConfig();\n        syncConfig.user().setMembershipNestingDepth(1);\n\n        syncMgr = new SyncManager() {\n            @CheckForNull\n            @Override\n            public SyncHandler getSyncHandler(@Nonnull String name) {\n                if (SYNC_NAME.equals(name)) {\n                    return new DefaultSyncHandler(syncConfig);\n                } else if (ThrowingSyncHandler.NAME.equals(name)) {\n                    return new ThrowingSyncHandler(false);\n                } else if (ThrowingSyncHandler.NAME_ALLOWS_IDENTITY_LISTING.equals(name)) {\n                    return new ThrowingSyncHandler(true);\n                } else {\n                    return null;\n                }\n            }\n        };\n        idpMgr = new ExternalIdentityProviderManager() {\n            @CheckForNull\n            @Override\n            public ExternalIdentityProvider getProvider(@Nonnull String name) {\n                if (name.equals(idp.getName())) {\n                    return idp;\n                } else {\n                    return null;\n                }\n            }\n        };\n        syncMBean = new SyncMBeanImpl(REPOSITORY, syncMgr, SYNC_NAME, idpMgr, idp.getName());\n\n        session = REPOSITORY.login(new SimpleCredentials(\"admin\", \"admin\".toCharArray()));\n        if (!(session instanceof JackrabbitSession)) {\n            throw new IllegalStateException();\n        } else {\n            userManager = ((JackrabbitSession) session).getUserManager();\n        }\n        ids = Sets.newHashSet(getAllAuthorizableIds(userManager));\n    }","id":29288,"modified_method":"@Before\n    public void before() throws Exception {\n        super.before();\n\n        syncMgr = new SyncManager() {\n            @CheckForNull\n            @Override\n            public SyncHandler getSyncHandler(@Nonnull String name) {\n                if (SYNC_NAME.equals(name)) {\n                    return new DefaultSyncHandler(syncConfig);\n                } else if (ThrowingSyncHandler.NAME.equals(name)) {\n                    return new ThrowingSyncHandler(false);\n                } else if (ThrowingSyncHandler.NAME_ALLOWS_IDENTITY_LISTING.equals(name)) {\n                    return new ThrowingSyncHandler(true);\n                } else {\n                    return null;\n                }\n            }\n        };\n        idpMgr = new ExternalIdentityProviderManager() {\n            @CheckForNull\n            @Override\n            public ExternalIdentityProvider getProvider(@Nonnull String name) {\n                if (name.equals(idp.getName())) {\n                    return idp;\n                } else {\n                    return null;\n                }\n            }\n        };\n        syncMBean = new SyncMBeanImpl(REPOSITORY, syncMgr, SYNC_NAME, idpMgr, idp.getName());\n    }","commit_id":"12417cb516307809042a497224ed91f6613f2c5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public int compareTo(final OIdentifiable iOther) {\r\n\t\tif (iOther == this)\r\n\t\t\treturn 0;\r\n\r\n\t\tif (iOther == null)\r\n\t\t\treturn 1;\r\n\r\n\t\tfinal ORID other = iOther.getIdentity();\r\n\r\n\t\tif (clusterId == other.getClusterId()) {\r\n\t\t\tif (clusterPosition == other.getClusterPosition())\r\n\t\t\t\treturn 0;\r\n\t\t\telse if (clusterPosition > other.getClusterPosition())\r\n\t\t\t\treturn 1;\r\n\t\t\telse if (clusterPosition < other.getClusterPosition())\r\n\t\t\t\treturn -1;\r\n\t\t} else if (clusterId > other.getClusterId())\r\n\t\t\treturn 1;\r\n\r\n\t\treturn -1;\r\n\t}","id":29289,"modified_method":"public int compareTo(final OIdentifiable iOther) {\r\n    if (iOther == this)\r\n      return 0;\r\n\r\n    if (iOther == null)\r\n      return 1;\r\n\r\n    final int otherClusterId = iOther.getIdentity().getClusterId();\r\n    if (clusterId == otherClusterId) {\r\n      final long otherClusterPos = iOther.getIdentity().getClusterPosition();\r\n\r\n      if (clusterPosition == otherClusterPos)\r\n        return 0;\r\n      else if (clusterPosition > otherClusterPos)\r\n        return 1;\r\n      else if (clusterPosition < otherClusterPos)\r\n        return -1;\r\n    } else if (clusterId > otherClusterId)\r\n      return 1;\r\n\r\n    return -1;\r\n  }","commit_id":"99ba3a225b8207696996e1054b1ad4c060274bf8","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int doEndTag() throws JspException {\n\t\ttry {\n\t\t\tdoTag(\n\t\t\t\tgetLifecycle(), _windowState, _portletMode, _var, _varImpl,\n\t\t\t\t_secure, _copyCurrentRenderParameters, _escapeXml, _name,\n\t\t\t\t_resourceID, _cacheability, _plid, _portletName, _anchor,\n\t\t\t\t_encrypt, _doAsUserId, _portletConfiguration, getParams(), true,\n\t\t\t\tpageContext);\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t\tfinally {\n\t\t\tclearParams();\n\t\t\tclearProperties();\n\n\t\t\t_plid = LayoutConstants.DEFAULT_PLID;\n\t\t}\n\t}","id":29290,"modified_method":"public int doEndTag() throws JspException {\n\t\ttry {\n\t\t\tdoTag(\n\t\t\t\tgetLifecycle(), _windowState, _portletMode, _var, _varImpl,\n\t\t\t\t_secure, _copyCurrentRenderParameters, _escapeXml, _name,\n\t\t\t\t_resourceID, _cacheability, _plid, _portletName, _anchor,\n\t\t\t\t_encrypt, _doAsUserId, _portletConfiguration, getParams(),\n\t\t\t\tpageContext);\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t\tfinally {\n\t\t\tclearParams();\n\t\t\tclearProperties();\n\n\t\t\t_plid = LayoutConstants.DEFAULT_PLID;\n\t\t}\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String doTag(\n\t\t\tString lifecycle, String windowState, String portletMode,\n\t\t\tString var, String varImpl, Boolean secure,\n\t\t\tBoolean copyCurrentRenderParameters, Boolean escapeXml, String name,\n\t\t\tString resourceID, String cacheability, long plid,\n\t\t\tString portletName, Boolean anchor, Boolean encrypt,\n\t\t\tlong doAsUserId, Boolean portletConfiguration,\n\t\t\tMap<String, String[]> params, boolean writeOutput,\n\t\t\tPageContext pageContext)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tif (portletName == null) {\n\t\t\tportletName = _getPortletName(request);\n\t\t}\n\n\t\tLiferayPortletURL portletURL = _getLiferayPortletURL(\n\t\t\trequest, plid, portletName, lifecycle);\n\n\t\tif (portletURL == null) {\n\t\t\t_log.error(\n\t\t\t\t\"Render response is null because this tag is not being \" +\n\t\t\t\t\t\"called within the context of a portlet\");\n\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tif (Validator.isNotNull(windowState)) {\n\t\t\tportletURL.setWindowState(\n\t\t\t\tWindowStateFactory.getWindowState(windowState));\n\t\t}\n\n\t\tif (Validator.isNotNull(portletMode)) {\n\t\t\tportletURL.setPortletMode(\n\t\t\t\tPortletModeFactory.getPortletMode(portletMode));\n\t\t}\n\n\t\tif (secure != null) {\n\t\t\tportletURL.setSecure(secure.booleanValue());\n\t\t}\n\t\telse {\n\t\t\tportletURL.setSecure(request.isSecure());\n\t\t}\n\n\t\tif (copyCurrentRenderParameters != null) {\n\t\t\tportletURL.setCopyCurrentRenderParameters(\n\t\t\t\tcopyCurrentRenderParameters.booleanValue());\n\t\t}\n\n\t\tif (escapeXml != null) {\n\t\t\tportletURL.setEscapeXml(escapeXml.booleanValue());\n\t\t}\n\n\t\tif (lifecycle.equals(PortletRequest.ACTION_PHASE) &&\n\t\t\tValidator.isNotNull(name)) {\n\n\t\t\tportletURL.setParameter(ActionRequest.ACTION_NAME, name);\n\t\t}\n\n\t\tif (resourceID != null) {\n\t\t\tportletURL.setResourceID(resourceID);\n\t\t}\n\n\t\tif (cacheability != null) {\n\t\t\tportletURL.setCacheability(cacheability);\n\t\t}\n\n\t\tif (anchor != null) {\n\t\t\tportletURL.setAnchor(anchor.booleanValue());\n\t\t}\n\n\t\tif (encrypt != null) {\n\t\t\tportletURL.setEncrypt(encrypt.booleanValue());\n\t\t}\n\n\t\tif (doAsUserId > 0) {\n\t\t\tportletURL.setDoAsUserId(doAsUserId);\n\t\t}\n\n\t\tif ((portletConfiguration != null) &&\n\t\t\tportletConfiguration.booleanValue()) {\n\n\t\t\tString returnToFullPageURL = ParamUtil.getString(\n\t\t\t\trequest, \"returnToFullPageURL\");\n\t\t\tString portletResource = ParamUtil.getString(\n\t\t\t\trequest, \"portletResource\");\n\t\t\tString previewWidth = ParamUtil.getString(request, \"previewWidth\");\n\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"struts_action\", \"/portlet_configuration/edit_configuration\");\n\t\t\tportletURL.setParameter(\"returnToFullPageURL\", returnToFullPageURL);\n\t\t\tportletURL.setParameter(\"portletResource\", portletResource);\n\t\t\tportletURL.setParameter(\"previewWidth\", previewWidth);\n\t\t}\n\n\t\tif (params != null) {\n\t\t\tMapUtil.merge(portletURL.getParameterMap(), params);\n\n\t\t\tportletURL.setParameters(params);\n\t\t}\n\n\t\tString portletURLToString = portletURL.toString();\n\n\t\tif (Validator.isNotNull(var)) {\n\t\t\tpageContext.setAttribute(var, portletURLToString);\n\t\t}\n\t\telse if (Validator.isNotNull(varImpl)) {\n\t\t\tpageContext.setAttribute(varImpl, portletURL);\n\t\t}\n\t\telse if (writeOutput) {\n\t\t\tpageContext.getOut().print(portletURLToString);\n\t\t}\n\n\t\treturn portletURLToString;\n\t}","id":29291,"modified_method":"public static void doTag(\n\t\t\tString lifecycle, String windowState, String portletMode,\n\t\t\tString var, String varImpl, Boolean secure,\n\t\t\tBoolean copyCurrentRenderParameters, Boolean escapeXml, String name,\n\t\t\tString resourceID, String cacheability, long plid,\n\t\t\tString portletName, Boolean anchor, Boolean encrypt,\n\t\t\tlong doAsUserId, Boolean portletConfiguration,\n\t\t\tMap<String, String[]> params, PageContext pageContext)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tif (portletName == null) {\n\t\t\tportletName = _getPortletName(request);\n\t\t}\n\n\t\tLiferayPortletURL portletURL = _getLiferayPortletURL(\n\t\t\trequest, plid, portletName, lifecycle);\n\n\t\tif (portletURL == null) {\n\t\t\t_log.error(\n\t\t\t\t\"Render response is null because this tag is not being \" +\n\t\t\t\t\t\"called within the context of a portlet\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (Validator.isNotNull(windowState)) {\n\t\t\tportletURL.setWindowState(\n\t\t\t\tWindowStateFactory.getWindowState(windowState));\n\t\t}\n\n\t\tif (Validator.isNotNull(portletMode)) {\n\t\t\tportletURL.setPortletMode(\n\t\t\t\tPortletModeFactory.getPortletMode(portletMode));\n\t\t}\n\n\t\tif (secure != null) {\n\t\t\tportletURL.setSecure(secure.booleanValue());\n\t\t}\n\t\telse {\n\t\t\tportletURL.setSecure(request.isSecure());\n\t\t}\n\n\t\tif (copyCurrentRenderParameters != null) {\n\t\t\tportletURL.setCopyCurrentRenderParameters(\n\t\t\t\tcopyCurrentRenderParameters.booleanValue());\n\t\t}\n\n\t\tif (escapeXml != null) {\n\t\t\tportletURL.setEscapeXml(escapeXml.booleanValue());\n\t\t}\n\n\t\tif (lifecycle.equals(PortletRequest.ACTION_PHASE) &&\n\t\t\tValidator.isNotNull(name)) {\n\n\t\t\tportletURL.setParameter(ActionRequest.ACTION_NAME, name);\n\t\t}\n\n\t\tif (resourceID != null) {\n\t\t\tportletURL.setResourceID(resourceID);\n\t\t}\n\n\t\tif (cacheability != null) {\n\t\t\tportletURL.setCacheability(cacheability);\n\t\t}\n\n\t\tif (anchor != null) {\n\t\t\tportletURL.setAnchor(anchor.booleanValue());\n\t\t}\n\n\t\tif (encrypt != null) {\n\t\t\tportletURL.setEncrypt(encrypt.booleanValue());\n\t\t}\n\n\t\tif (doAsUserId > 0) {\n\t\t\tportletURL.setDoAsUserId(doAsUserId);\n\t\t}\n\n\t\tif ((portletConfiguration != null) &&\n\t\t\tportletConfiguration.booleanValue()) {\n\n\t\t\tString returnToFullPageURL = ParamUtil.getString(\n\t\t\t\trequest, \"returnToFullPageURL\");\n\t\t\tString portletResource = ParamUtil.getString(\n\t\t\t\trequest, \"portletResource\");\n\t\t\tString previewWidth = ParamUtil.getString(request, \"previewWidth\");\n\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"struts_action\", \"/portlet_configuration/edit_configuration\");\n\t\t\tportletURL.setParameter(\"returnToFullPageURL\", returnToFullPageURL);\n\t\t\tportletURL.setParameter(\"portletResource\", portletResource);\n\t\t\tportletURL.setParameter(\"previewWidth\", previewWidth);\n\t\t}\n\n\t\tif (params != null) {\n\t\t\tMapUtil.merge(portletURL.getParameterMap(), params);\n\n\t\t\tportletURL.setParameters(params);\n\t\t}\n\n\t\tString portletURLToString = portletURL.toString();\n\n\t\tif (Validator.isNotNull(var)) {\n\t\t\tpageContext.setAttribute(var, portletURLToString);\n\t\t}\n\t\telse if (Validator.isNotNull(varImpl)) {\n\t\t\tpageContext.setAttribute(varImpl, portletURL);\n\t\t}\n\t\telse {\n\t\t\tpageContext.getOut().print(portletURLToString);\n\t\t}\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String doTag(\n\t\t\tlong doAsUserId, String var, boolean writeOutput,\n\t\t\tPageContext pageContext)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tCompany company = themeDisplay.getCompany();\n\n\t\tString doAsURL = company.getHomeURL();\n\n\t\tif (Validator.isNull(doAsURL)) {\n\t\t\tdoAsURL = _COMPANY_DEFAULT_HOME_URL;\n\t\t}\n\n\t\tif (doAsUserId <= 0) {\n\t\t\tdoAsUserId = company.getDefaultUser().getUserId();\n\t\t}\n\n\t\tString encDoAsUserId = Encryptor.encrypt(\n\t\t\tcompany.getKeyObj(), String.valueOf(doAsUserId));\n\n\t\tdoAsURL = HttpUtil.addParameter(\n\t\t\tdoAsURL, \"doAsUserId\", encDoAsUserId);\n\n\t\tif (Validator.isNotNull(var)) {\n\t\t\tpageContext.setAttribute(var, doAsURL);\n\t\t}\n\t\telse if (writeOutput) {\n\t\t\tpageContext.getOut().print(doAsURL);\n\t\t}\n\n\t\treturn doAsURL;\n\t}","id":29292,"modified_method":"public static void doTag(\n\t\t\tlong doAsUserId, String var, PageContext pageContext)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tCompany company = themeDisplay.getCompany();\n\n\t\tString doAsURL = company.getHomeURL();\n\n\t\tif (Validator.isNull(doAsURL)) {\n\t\t\tdoAsURL = _COMPANY_DEFAULT_HOME_URL;\n\t\t}\n\n\t\tif (doAsUserId <= 0) {\n\t\t\tdoAsUserId = company.getDefaultUser().getUserId();\n\t\t}\n\n\t\tString encDoAsUserId = Encryptor.encrypt(\n\t\t\tcompany.getKeyObj(), String.valueOf(doAsUserId));\n\n\t\tdoAsURL = HttpUtil.addParameter(\n\t\t\tdoAsURL, \"doAsUserId\", encDoAsUserId);\n\n\t\tif (Validator.isNotNull(var)) {\n\t\t\tpageContext.setAttribute(var, doAsURL);\n\t\t}\n\t\telse {\n\t\t\tpageContext.getOut().print(doAsURL);\n\t\t}\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doEndTag() throws JspException {\n\t\ttry {\n\t\t\tdoTag(_doAsUserId, _var, true, pageContext);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\n\t\treturn EVAL_PAGE;\n\t}","id":29293,"modified_method":"public int doEndTag() throws JspException {\n\t\ttry {\n\t\t\tdoTag(_doAsUserId, _var, pageContext);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\n\t\treturn EVAL_PAGE;\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doEndTag() throws JspException {\n\t\ttry {\n\t\t\tdoTag(\n\t\t\t\t_redirect, _modelResource, _modelResourceDescription,\n\t\t\t\t_resourcePrimKey, _var, true, pageContext);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\n\t\treturn EVAL_PAGE;\n\t}","id":29294,"modified_method":"public int doEndTag() throws JspException {\n\t\ttry {\n\t\t\tdoTag(\n\t\t\t\t_redirect, _modelResource, _modelResourceDescription,\n\t\t\t\t_resourcePrimKey, _var, pageContext);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\n\t\treturn EVAL_PAGE;\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String doTag(\n\t\t\tString redirect, String modelResource,\n\t\t\tString modelResourceDescription, String resourcePrimKey, String var,\n\t\t\tboolean writeOutput, PageContext pageContext)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletDisplay portletDisplay = themeDisplay.getPortletDisplay();\n\n\t\tLayout layout = themeDisplay.getLayout();\n\n\t\tif (Validator.isNull(redirect)) {\n\t\t\tredirect = PortalUtil.getCurrentURL(request);\n\t\t}\n\n\t\tPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\trequest, PortletKeys.PORTLET_CONFIGURATION, layout.getPlid(),\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tif (themeDisplay.isStatePopUp()) {\n\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t}\n\t\telse {\n\t\t\tportletURL.setWindowState(WindowState.MAXIMIZED);\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"struts_action\", \"/portlet_configuration/edit_permissions\");\n\t\tportletURL.setParameter(\"redirect\", redirect);\n\n\t\tif (!themeDisplay.isStateMaximized()) {\n\t\t\tportletURL.setParameter(\"returnToFullPageURL\", redirect);\n\t\t}\n\n\t\tportletURL.setParameter(\"portletResource\", portletDisplay.getId());\n\t\tportletURL.setParameter(\"modelResource\", modelResource);\n\t\tportletURL.setParameter(\n\t\t\t\"modelResourceDescription\", modelResourceDescription);\n\t\tportletURL.setParameter(\"resourcePrimKey\", resourcePrimKey);\n\n\t\tString portletURLToString = portletURL.toString();\n\n\t\tif (Validator.isNotNull(var)) {\n\t\t\tpageContext.setAttribute(var, portletURLToString);\n\t\t}\n\t\telse if (writeOutput) {\n\t\t\tpageContext.getOut().print(portletURLToString);\n\t\t}\n\n\t\treturn portletURLToString;\n\t}","id":29295,"modified_method":"public static void doTag(\n\t\t\tString redirect, String modelResource,\n\t\t\tString modelResourceDescription, String resourcePrimKey, String var,\n\t\t\tPageContext pageContext)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletDisplay portletDisplay = themeDisplay.getPortletDisplay();\n\n\t\tLayout layout = themeDisplay.getLayout();\n\n\t\tif (Validator.isNull(redirect)) {\n\t\t\tredirect = PortalUtil.getCurrentURL(request);\n\t\t}\n\n\t\tPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\trequest, PortletKeys.PORTLET_CONFIGURATION, layout.getPlid(),\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tif (themeDisplay.isStatePopUp()) {\n\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t}\n\t\telse {\n\t\t\tportletURL.setWindowState(WindowState.MAXIMIZED);\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"struts_action\", \"/portlet_configuration/edit_permissions\");\n\t\tportletURL.setParameter(\"redirect\", redirect);\n\n\t\tif (!themeDisplay.isStateMaximized()) {\n\t\t\tportletURL.setParameter(\"returnToFullPageURL\", redirect);\n\t\t}\n\n\t\tportletURL.setParameter(\"portletResource\", portletDisplay.getId());\n\t\tportletURL.setParameter(\"modelResource\", modelResource);\n\t\tportletURL.setParameter(\n\t\t\t\"modelResourceDescription\", modelResourceDescription);\n\t\tportletURL.setParameter(\"resourcePrimKey\", resourcePrimKey);\n\n\t\tString portletURLToString = portletURL.toString();\n\n\t\tif (Validator.isNotNull(var)) {\n\t\t\tpageContext.setAttribute(var, portletURLToString);\n\t\t}\n\t\telse {\n\t\t\tpageContext.getOut().print(portletURLToString);\n\t\t}\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String actionURL(\n\t\t\tString windowState, String portletMode, Boolean secure,\n\t\t\tBoolean copyCurrentRenderParameters, Boolean escapeXml, String name,\n\t\t\tlong plid, String portletName, Boolean anchor, Boolean encrypt,\n\t\t\tlong doAsUserId, Boolean portletConfiguration, String queryString)\n\t\tthrows Exception {\n\n\t\tString var = null;\n\t\tString varImpl = null;\n\t\tString resourceID = null;\n\t\tString cacheability = null;\n\t\tMap<String, String[]> params = HttpUtil.parameterMapFromString(\n\t\t\tqueryString);\n\t\tboolean writeOutput = false;\n\n\t\treturn ActionURLTag.doTag(\n\t\t\tPortletRequest.ACTION_PHASE, windowState, portletMode, var, varImpl,\n\t\t\tsecure, copyCurrentRenderParameters, escapeXml, name, resourceID,\n\t\t\tcacheability, plid, portletName, anchor, encrypt, doAsUserId,\n\t\t\tportletConfiguration, params, writeOutput, _pageContext);\n\t}","id":29296,"modified_method":"public void actionURL(\n\t\t\tString windowState, String portletMode, Boolean secure,\n\t\t\tBoolean copyCurrentRenderParameters, Boolean escapeXml, String name,\n\t\t\tlong plid, String portletName, Boolean anchor, Boolean encrypt,\n\t\t\tlong doAsUserId, Boolean portletConfiguration, String queryString)\n\t\tthrows Exception {\n\n\t\tString var = null;\n\t\tString varImpl = null;\n\t\tString resourceID = null;\n\t\tString cacheability = null;\n\t\tMap<String, String[]> params = HttpUtil.parameterMapFromString(\n\t\t\tqueryString);\n\n\t\tActionURLTag.doTag(\n\t\t\tPortletRequest.ACTION_PHASE, windowState, portletMode, var, varImpl,\n\t\t\tsecure, copyCurrentRenderParameters, escapeXml, name, resourceID,\n\t\t\tcacheability, plid, portletName, anchor, encrypt, doAsUserId,\n\t\t\tportletConfiguration, params, _pageContext);\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String doAsURL(long doAsUserId) throws Exception {\n\t\treturn DoAsURLTag.doTag(doAsUserId, null, false, _pageContext);\n\t}","id":29297,"modified_method":"public void doAsURL(long doAsUserId) throws Exception {\n\t\tDoAsURLTag.doTag(doAsUserId, null, _pageContext);\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String renderURL(String portletName, String queryString)\n\t\tthrows Exception {\n\n\t\treturn renderURL(\n\t\t\tLayoutConstants.DEFAULT_PLID, portletName, queryString);\n\t}","id":29298,"modified_method":"public void renderURL(String portletName, String queryString)\n\t\tthrows Exception {\n\n\t\trenderURL(LayoutConstants.DEFAULT_PLID, portletName, queryString);\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String renderURL(\n\t\t\tString windowState, String portletMode, long plid,\n\t\t\tString portletName, String queryString)\n\t\tthrows Exception {\n\n\t\tBoolean secure = null;\n\t\tBoolean copyCurrentRenderParameters = null;\n\t\tBoolean escapeXml = null;\n\t\tBoolean anchor = null;\n\t\tBoolean encrypt = null;\n\t\tlong doAsUserId = 0;\n\t\tBoolean portletConfiguration = null;\n\n\t\treturn renderURL(\n\t\t\twindowState, portletMode, secure, copyCurrentRenderParameters,\n\t\t\tescapeXml, plid, portletName, anchor, encrypt, doAsUserId,\n\t\t\tportletConfiguration, queryString);\n\t}","id":29299,"modified_method":"public void renderURL(\n\t\t\tString windowState, String portletMode, long plid,\n\t\t\tString portletName, String queryString)\n\t\tthrows Exception {\n\n\t\tBoolean secure = null;\n\t\tBoolean copyCurrentRenderParameters = null;\n\t\tBoolean escapeXml = null;\n\t\tBoolean anchor = null;\n\t\tBoolean encrypt = null;\n\t\tlong doAsUserId = 0;\n\t\tBoolean portletConfiguration = null;\n\n\t\trenderURL(\n\t\t\twindowState, portletMode, secure, copyCurrentRenderParameters,\n\t\t\tescapeXml, plid, portletName, anchor, encrypt, doAsUserId,\n\t\t\tportletConfiguration, queryString);\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String renderURL(\n\t\t\tString windowState, String portletMode, Boolean secure,\n\t\t\tBoolean copyCurrentRenderParameters, Boolean escapeXml,\n\t\t\tlong plid, String portletName, Boolean anchor, Boolean encrypt,\n\t\t\tlong doAsUserId, Boolean portletConfiguration, String queryString)\n\t\tthrows Exception {\n\n\t\tString var = null;\n\t\tString varImpl = null;\n\t\tString name = null;\n\t\tString resourceID = null;\n\t\tString cacheability = null;\n\t\tMap<String, String[]> params = HttpUtil.parameterMapFromString(\n\t\t\tqueryString);\n\t\tboolean writeOutput = false;\n\n\t\treturn ActionURLTag.doTag(\n\t\t\tPortletRequest.RENDER_PHASE, windowState, portletMode, var, varImpl,\n\t\t\tsecure, copyCurrentRenderParameters, escapeXml, name, resourceID,\n\t\t\tcacheability, plid, portletName, anchor, encrypt, doAsUserId,\n\t\t\tportletConfiguration, params, writeOutput, _pageContext);\n\t}","id":29300,"modified_method":"public void renderURL(\n\t\t\tString windowState, String portletMode, Boolean secure,\n\t\t\tBoolean copyCurrentRenderParameters, Boolean escapeXml,\n\t\t\tlong plid, String portletName, Boolean anchor, Boolean encrypt,\n\t\t\tlong doAsUserId, Boolean portletConfiguration, String queryString)\n\t\tthrows Exception {\n\n\t\tString var = null;\n\t\tString varImpl = null;\n\t\tString name = null;\n\t\tString resourceID = null;\n\t\tString cacheability = null;\n\t\tMap<String, String[]> params = HttpUtil.parameterMapFromString(\n\t\t\tqueryString);\n\n\t\tActionURLTag.doTag(\n\t\t\tPortletRequest.RENDER_PHASE, windowState, portletMode, var, varImpl,\n\t\t\tsecure, copyCurrentRenderParameters, escapeXml, name, resourceID,\n\t\t\tcacheability, plid, portletName, anchor, encrypt, doAsUserId,\n\t\t\tportletConfiguration, params, _pageContext);\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String permissionsURL(\n\t\t\tString redirect, String modelResource,\n\t\t\tString modelResourceDescription, String resourcePrimKey)\n\t\tthrows Exception {\n\n\t\treturn PermissionsURLTag.doTag(\n\t\t\tredirect, modelResource, modelResourceDescription, resourcePrimKey,\n\t\t\tnull, false, _pageContext);\n\t}","id":29301,"modified_method":"public void permissionsURL(\n\t\t\tString redirect, String modelResource,\n\t\t\tString modelResourceDescription, String resourcePrimKey)\n\t\tthrows Exception {\n\n\t\tPermissionsURLTag.doTag(\n\t\t\tredirect, modelResource, modelResourceDescription, resourcePrimKey,\n\t\t\tnull, _pageContext);\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String actionURL(String portletName, String queryString)\n\t\tthrows Exception {\n\n\t\treturn actionURL(\n\t\t\tLayoutConstants.DEFAULT_PLID, portletName, queryString);\n\t}","id":29302,"modified_method":"public void actionURL(String portletName, String queryString)\n\t\tthrows Exception {\n\n\t\tactionURL(LayoutConstants.DEFAULT_PLID, portletName, queryString);\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String actionURL(\n\t\t\tString windowState, String portletMode, long plid,\n\t\t\tString portletName, String queryString)\n\t\tthrows Exception {\n\n\t\tBoolean secure = null;\n\t\tBoolean copyCurrentRenderParameters = null;\n\t\tBoolean escapeXml = null;\n\t\tString name = null;\n\t\tBoolean anchor = null;\n\t\tBoolean encrypt = null;\n\t\tlong doAsUserId = 0;\n\t\tBoolean portletConfiguration = null;\n\n\t\treturn actionURL(\n\t\t\twindowState, portletMode, secure, copyCurrentRenderParameters,\n\t\t\tescapeXml, name, plid, portletName, anchor, encrypt, doAsUserId,\n\t\t\tportletConfiguration, queryString);\n\t}","id":29303,"modified_method":"public void actionURL(\n\t\t\tString windowState, String portletMode, long plid,\n\t\t\tString portletName, String queryString)\n\t\tthrows Exception {\n\n\t\tBoolean secure = null;\n\t\tBoolean copyCurrentRenderParameters = null;\n\t\tBoolean escapeXml = null;\n\t\tString name = null;\n\t\tBoolean anchor = null;\n\t\tBoolean encrypt = null;\n\t\tlong doAsUserId = 0;\n\t\tBoolean portletConfiguration = null;\n\n\t\tactionURL(\n\t\t\twindowState, portletMode, secure, copyCurrentRenderParameters,\n\t\t\tescapeXml, name, plid, portletName, anchor, encrypt, doAsUserId,\n\t\t\tportletConfiguration, queryString);\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String actionURL(long plid, String portletName, String queryString)\n\t\tthrows Exception {\n\n\t\tString windowState = WindowState.NORMAL.toString();\n\t\tString portletMode = PortletMode.VIEW.toString();\n\n\t\treturn actionURL(\n\t\t\twindowState, portletMode, plid, portletName, queryString);\n\t}","id":29304,"modified_method":"public void actionURL(long plid, String portletName, String queryString)\n\t\tthrows Exception {\n\n\t\tString windowState = WindowState.NORMAL.toString();\n\t\tString portletMode = PortletMode.VIEW.toString();\n\n\t\tactionURL(windowState, portletMode, plid, portletName, queryString);\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String actionURL(\n\t\t\tString windowState, String portletMode, String portletName,\n\t\t\tString queryString)\n\t\tthrows Exception {\n\n\t\treturn actionURL(\n\t\t\twindowState, portletMode, LayoutConstants.DEFAULT_PLID, portletName,\n\t\t\tqueryString);\n\t}","id":29305,"modified_method":"public void actionURL(\n\t\t\tString windowState, String portletMode, String portletName,\n\t\t\tString queryString)\n\t\tthrows Exception {\n\n\t\tactionURL(\n\t\t\twindowState, portletMode, LayoutConstants.DEFAULT_PLID, portletName,\n\t\t\tqueryString);\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String renderURL(\n\t\t\tString windowState, String portletMode, String portletName,\n\t\t\tString queryString)\n\t\tthrows Exception {\n\n\t\treturn renderURL(\n\t\t\twindowState, portletMode, LayoutConstants.DEFAULT_PLID, portletName,\n\t\t\tqueryString);\n\t}","id":29306,"modified_method":"public void renderURL(\n\t\t\tString windowState, String portletMode, String portletName,\n\t\t\tString queryString)\n\t\tthrows Exception {\n\n\t\trenderURL(\n\t\t\twindowState, portletMode, LayoutConstants.DEFAULT_PLID, portletName,\n\t\t\tqueryString);\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String renderURL(long plid, String portletName, String queryString)\n\t\tthrows Exception {\n\n\t\tString windowState = WindowState.NORMAL.toString();\n\t\tString portletMode = PortletMode.VIEW.toString();\n\n\t\treturn renderURL(\n\t\t\twindowState, portletMode, plid, portletName, queryString);\n\t}","id":29307,"modified_method":"public void renderURL(long plid, String portletName, String queryString)\n\t\tthrows Exception {\n\n\t\tString windowState = WindowState.NORMAL.toString();\n\t\tString portletMode = PortletMode.VIEW.toString();\n\n\t\trenderURL(windowState, portletMode, plid, portletName, queryString);\n\t}","commit_id":"1ca1b5b4321ce2b54e1a4de276db50cb7bc21d21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void open(@Nullable final OpenInBrowserRequest request, boolean preferLocalUrl, @Nullable final WebBrowser browser) {\n    if (request == null) {\n      return;\n    }\n\n    try {\n      Collection<Url> urls = WebBrowserService.getInstance().getUrlsToOpen(request, preferLocalUrl);\n      if (!urls.isEmpty()) {\n        chooseUrl(urls).doWhenDone(new Consumer<Url>() {\n          @Override\n          public void consume(Url url) {\n            ApplicationManager.getApplication().saveAll();\n            BrowserLauncher.getInstance().browse(url.toExternalForm(), browser, request.getProject());\n          }\n        });\n      }\n    }\n    catch (WebBrowserUrlProvider.BrowserException e1) {\n      Messages.showErrorDialog(e1.getMessage(), IdeBundle.message(\"browser.error\"));\n    }\n    catch (Exception e1) {\n      LOG.error(e1);\n    }\n  }","id":29308,"modified_method":"public static void open(@Nullable final OpenInBrowserRequest request, boolean preferLocalUrl, @Nullable final WebBrowser browser) {\n    if (request == null) {\n      return;\n    }\n\n    try {\n      Collection<Url> urls = WebBrowserService.getInstance().getUrlsToOpen(request, preferLocalUrl);\n      if (!urls.isEmpty()) {\n        chooseUrl(urls)\n          .done(new Consumer<Url>() {\n            @Override\n            public void consume(Url url) {\n              ApplicationManager.getApplication().saveAll();\n              BrowserLauncher.getInstance().browse(url.toExternalForm(), browser, request.getProject());\n            }\n          });\n      }\n    }\n    catch (WebBrowserUrlProvider.BrowserException e1) {\n      Messages.showErrorDialog(e1.getMessage(), IdeBundle.message(\"browser.error\"));\n    }\n    catch (Exception e1) {\n      LOG.error(e1);\n    }\n  }","commit_id":"0caa188ecf3b0afbf146160fa89c06b16a8a5a0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static AsyncResult<Url> chooseUrl(@NotNull Collection<Url> urls) {\n    if (urls.size() == 1) {\n      return new AsyncResult.Done<Url>(ContainerUtil.getFirstItem(urls));\n    }\n\n    final JBList list = new JBList(urls);\n    list.setCellRenderer(new ColoredListCellRenderer() {\n      @Override\n      protected void customizeCellRenderer(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n        // todo icons looks good, but is it really suitable for all URLs providers?\n        setIcon(AllIcons.Nodes.Servlet);\n        append(((Url)value).toDecodedForm());\n      }\n    });\n\n    final AsyncResult<Url> result = new AsyncResult<Url>();\n    JBPopupFactory.getInstance().\n      createListPopupBuilder(list).\n      setTitle(\"Choose Url\").\n      setItemChoosenCallback(new Runnable() {\n        @Override\n        public void run() {\n          Url value = (Url)list.getSelectedValue();\n          if (value != null) {\n            result.setDone(value);\n          }\n          else {\n            result.setRejected();\n          }\n        }\n      }).\n      createPopup().showInFocusCenter();\n    return result;\n  }","id":29309,"modified_method":"@NotNull\n  private static Promise<Url> chooseUrl(@NotNull Collection<Url> urls) {\n    if (urls.size() == 1) {\n      return Promise.resolve(ContainerUtil.getFirstItem(urls));\n    }\n\n    final JBList list = new JBList(urls);\n    list.setCellRenderer(new ColoredListCellRenderer() {\n      @Override\n      protected void customizeCellRenderer(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n        // todo icons looks good, but is it really suitable for all URLs providers?\n        setIcon(AllIcons.Nodes.Servlet);\n        append(((Url)value).toDecodedForm());\n      }\n    });\n\n    final AsyncPromise<Url> result = new AsyncPromise<Url>();\n    JBPopupFactory.getInstance()\n      .createListPopupBuilder(list)\n      .setTitle(\"Choose Url\")\n      .setItemChoosenCallback(new Runnable() {\n        @Override\n        public void run() {\n          Url value = (Url)list.getSelectedValue();\n          if (value == null) {\n            result.setError(Promise.createError(\"selected value is null\"));\n          }\n          else {\n            result.setResult(value);\n          }\n        }\n      })\n      .createPopup()\n      .showInFocusCenter();\n    return result;\n  }","commit_id":"0caa188ecf3b0afbf146160fa89c06b16a8a5a0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getWorkingDirectory(@Nullable Project project) {\n    if (project == null) return null;\n    PropertiesComponent propertiesComponent = PropertiesComponent.getInstance(project);\n    String value = propertiesComponent.getValue(PHONEGAP_WORK_DIRECTORY);\n    if (value != null) return value;\n\n    return ContainerUtil.getFirstItem(PhoneGapUtil.getDefaultWorkingDirectory(project));\n  }","id":29310,"modified_method":"@NotNull\n  public String getWorkingDirectory(@Nullable Project project) {\n    if (project == null) return \"\";\n    PropertiesComponent propertiesComponent = PropertiesComponent.getInstance(project);\n    String value = propertiesComponent.getValue(PHONEGAP_WORK_DIRECTORY);\n    if (value != null) return value;\n\n    String item = ContainerUtil.getFirstItem(PhoneGapUtil.getDefaultWorkingDirectory(project));\n    return item == null ? \"\" : item;\n  }","commit_id":"ad0c068dbb8af3b493b9afe13fb29c5ff71adab5","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void showSelectionUI(@NotNull Collection<WebBrowser> browsers) {\n    final String message;\n    if (browsers.isEmpty()) {\n      message = \"Karma tests can not be debugged\";\n    }\n    else {\n      message = formatUrl(browsers);\n    }\n\n    ToolWindowManager.getInstance(myProject).notifyByBalloon(\n      myEnv.getExecutor().getToolWindowId(),\n      MessageType.WARNING,\n      message,\n      null,\n      new HyperlinkAdapter() {\n        @Override\n        protected void hyperlinkActivated(HyperlinkEvent e) {\n          WebBrowser browser = WebBrowserManager.getInstance().findBrowserById(e.getDescription());\n          JSDebugEngine debugEngine = browser == null ? null :JSDebugEngine.findByBrowser(browser);\n          if (debugEngine != null) {\n            setDebugEngineToReuse(debugEngine);\n            if (!ExecutorRegistry.getInstance().isStarting(myProject, myEnv.getExecutor().getId(), myProgramRunner.getRunnerId())) {\n              ExecutionManager executionManager = ExecutionManager.getInstance(myProject);\n              executionManager.restartRunProfile(myProgramRunner, myEnv, myEnv.getContentToReuse());\n            }\n          }\n        }\n      }\n    );\n  }","id":29311,"modified_method":"private void showBrowserSelectionUi(@NotNull Collection<DebuggableWebBrowser> debuggableActiveCapturedBrowsers) {\n    final String message;\n    if (debuggableActiveCapturedBrowsers.isEmpty()) {\n      List<WebBrowser> activeBrowsers = WebBrowserManager.getInstance().getActiveBrowsers();\n      List<DebuggableWebBrowser> debuggableActiveBrowsers = toDebuggableWebBrowsers(activeBrowsers);\n      if (debuggableActiveBrowsers.isEmpty()) {\n        message = \"<html><body>\" +\n                  \"No supported browsers found.\" +\n                  \"<p/>\" +\n                  \"JavaScript debugging is currently supported in Chrome or Firefox\" +\n                  \"<\/body><\/html>\";\n      }\n      else {\n        message = formatBrowserSelectionHtml(debuggableActiveBrowsers);\n      }\n    }\n    else {\n      message = formatBrowserSelectionHtml(debuggableActiveCapturedBrowsers);\n    }\n\n    ToolWindowManager.getInstance(myProject).notifyByBalloon(\n      myEnv.getExecutor().getToolWindowId(),\n      MessageType.WARNING,\n      message,\n      null,\n      new HyperlinkAdapter() {\n        @Override\n        protected void hyperlinkActivated(HyperlinkEvent e) {\n          WebBrowser browser = WebBrowserManager.getInstance().findBrowserById(e.getDescription());\n          if (browser != null) {\n            setWebBrowserToReuse(browser);\n            if (!ExecutorRegistry.getInstance().isStarting(myProject, myEnv.getExecutor().getId(), myProgramRunner.getRunnerId())) {\n              ExecutionManager executionManager = ExecutionManager.getInstance(myProject);\n              executionManager.restartRunProfile(myProgramRunner, myEnv, myEnv.getContentToReuse());\n            }\n          }\n        }\n      }\n    );\n  }","commit_id":"1f3e513e97f43b3fbbeaf35a7e027e8b68c0478d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private String formatUrl(@NotNull Collection<WebBrowser> debugEngines) {\n    StringBuilder builder = new StringBuilder(\"<html><body>\");\n    if (myCapturedBrowsers.size() == 1) {\n      builder.append(\"Can not debug tests in <code>\\\"\").append(myCapturedBrowsers.get(0).getName()).append(\"\\\"<\/code>.\");\n    }\n    else if (!myCapturedBrowsers.isEmpty()) {\n      builder.append(\"Can not debug tests in any of:\");\n      builder.append(\"<pre>\");\n      for (CapturedBrowser browser : myCapturedBrowsers) {\n        builder.append(\" - \").append(browser.getName()).append(\"\\n\");\n      }\n      builder.append(\"<\/pre>\");\n    }\n\n    builder.append(\"<div style='padding-top:4px; padding-bottom:4px'>\");\n    builder.append(\"Karma tests can be debugged in Google Chrome or Mozilla Firefox only.\");\n    builder.append(\"<\/div>\");\n\n    builder.append(\"<table align='center' cellspacing='0' cellpadding='0' style='border: none;padding-bottom:2px'>\");\n    builder.append(\"<tr>\");\n    for (WebBrowser browser : debugEngines) {\n      builder.append(\"<td>\");\n      builder.append(\"<div style='padding-right:7px;padding-left:7px'>\");\n      builder.append(\"<a href='\").append(browser.getId()).append(\"'>\")\n        .append(\"Debug in \").append(browser.getName())\n        .append(\"<\/a>\");\n      builder.append(\"<\/div>\");\n      builder.append(\"<\/td>\");\n    }\n    builder.append(\"<\/tr>\");\n    builder.append(\"<\/table>\");\n    builder.append(\"<\/body><\/html>\");\n    return builder.toString();\n  }","id":29312,"modified_method":"@NotNull\n  private static String formatBrowserSelectionHtml(@NotNull Collection<DebuggableWebBrowser> browsers) {\n    StringBuilder builder = new StringBuilder(\"<html><body>\");\n    builder.append(\"<div style='padding-top:4px; padding-bottom:4px'>\");\n    builder.append(\"Karma tests can be debugged in Google Chrome or Mozilla Firefox only\");\n    builder.append(\"<\/div>\");\n\n    builder.append(\"<table align='center' cellspacing='0' cellpadding='0' style='border: none;padding-bottom:2px'>\");\n    builder.append(\"<tr>\");\n    for (DebuggableWebBrowser browser : browsers) {\n      builder.append(\"<td>\");\n      builder.append(\"<div style='padding-right:7px;padding-left:7px'>\");\n      builder.append(\"<a href='\").append(browser.getWebBrowser().getId()).append(\"'>\")\n        .append(\"Debug in \").append(browser.getWebBrowser().getName())\n        .append(\"<\/a>\");\n      builder.append(\"<\/div>\");\n      builder.append(\"<\/td>\");\n    }\n    builder.append(\"<\/tr>\");\n    builder.append(\"<\/table>\");\n    builder.append(\"<\/body><\/html>\");\n    return builder.toString();\n  }","commit_id":"1f3e513e97f43b3fbbeaf35a7e027e8b68c0478d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  public Pair<JSDebugEngine, WebBrowser> selectDebugEngine() {\n    List<WebBrowser> result = ContainerUtil.newArrayList();\n    List<WebBrowser> browsers = WebBrowserManager.getInstance().getActiveBrowsers();\n    for (WebBrowser browser : browsers) {\n      boolean matched = false;\n      for (CapturedBrowser capturedBrowser : myCapturedBrowsers) {\n        if (StringUtil.containsIgnoreCase(capturedBrowser.getName(), browser.getFamily().getName())) {\n          matched = true;\n          break;\n        }\n      }\n      if (matched) {\n        result.add(browser);\n      }\n    }\n\n    if (result.size() == 1) {\n      WebBrowser browser = ContainerUtil.getFirstItem(result);\n      assert browser != null;\n      JSDebugEngine debugEngine = JSDebugEngine.findByBrowser(browser);\n      return debugEngine == null ? null : Pair.create(debugEngine, browser);\n    }\n    JSDebugEngine debugEngineToReuse = getDebugEngineToReuse();\n    if (debugEngineToReuse != null) {\n      return Pair.create(debugEngineToReuse, WebBrowserManager.getInstance().getFirstBrowser(debugEngineToReuse.getBrowserFamily()));\n    }\n    showSelectionUI(result);\n    return null;\n  }","id":29313,"modified_method":"@Nullable\n  public DebuggableWebBrowser selectDebugEngine() {\n    List<WebBrowser> activeCapturedBrowsers = getActiveCapturedBrowsers();\n    List<DebuggableWebBrowser> debuggableActiveCapturedBrowsers = toDebuggableWebBrowsers(activeCapturedBrowsers);\n    if (debuggableActiveCapturedBrowsers.size() == 1) {\n      DebuggableWebBrowser debuggableWebBrowser = ContainerUtil.getFirstItem(debuggableActiveCapturedBrowsers);\n      if (debuggableWebBrowser != null) {\n        setWebBrowserToReuse(null);\n        return debuggableWebBrowser;\n      }\n    }\n    WebBrowser browserToReuse = getWebBrowserToReuse();\n    if (browserToReuse != null) {\n      DebuggableWebBrowser debuggableBrowser = DebuggableWebBrowser.create(browserToReuse);\n      if (debuggableBrowser != null) {\n        return debuggableBrowser;\n      }\n    }\n    showBrowserSelectionUi(debuggableActiveCapturedBrowsers);\n    return null;\n  }","commit_id":"1f3e513e97f43b3fbbeaf35a7e027e8b68c0478d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static AsyncResult<RunProfileStarter> prepareDebugger(@NotNull final Project project,\n                                                               @Nullable final Pair<JSDebugEngine, WebBrowser> engineAndBrowser,\n                                                               @NotNull final RunProfileStarter starter) {\n    if (engineAndBrowser == null) {\n      return AsyncResult.done(starter);\n    }\n    else {\n      final AsyncResult<RunProfileStarter> result = new AsyncResult<RunProfileStarter>();\n      engineAndBrowser.first.prepareDebugger(project, engineAndBrowser.second).notifyWhenRejected(result).doWhenDone(new Runnable() {\n        @Override\n        public void run() {\n          result.setDone(starter);\n        }\n      });\n      return result;\n    }\n  }","id":29314,"modified_method":"public static AsyncResult<RunProfileStarter> prepareDebugger(@NotNull final Project project,\n                                                               @Nullable final DebuggableWebBrowser debuggableWebBrowser,\n                                                               @NotNull final RunProfileStarter starter) {\n    if (debuggableWebBrowser == null) {\n      return AsyncResult.done(starter);\n    }\n    else {\n      final AsyncResult<RunProfileStarter> result = new AsyncResult<RunProfileStarter>();\n      JSDebugEngine debugEngine = debuggableWebBrowser.getDebugEngine();\n      WebBrowser browser = debuggableWebBrowser.getWebBrowser();\n      debugEngine.prepareDebugger(project, browser).notifyWhenRejected(result).doWhenDone(new Runnable() {\n        @Override\n        public void run() {\n          result.setDone(starter);\n        }\n      });\n      return result;\n    }\n  }","commit_id":"1f3e513e97f43b3fbbeaf35a7e027e8b68c0478d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  protected AsyncResult<RunProfileStarter> prepare(@NotNull Project project,\n                                                   @NotNull ExecutionEnvironment environment,\n                                                   @NotNull RunProfileState state) throws ExecutionException {\n    final ExecutionResult executionResult = state.execute(environment.getExecutor(), this);\n    if (executionResult == null) {\n      return AsyncResult.rejected();\n    }\n\n    final KarmaConsoleView consoleView = KarmaConsoleView.get(executionResult);\n    if (consoleView == null) {\n      throw new RuntimeException(\"KarmaConsoleView was expected!\");\n    }\n\n    final KarmaServer karmaServer = consoleView.getKarmaExecutionSession().getKarmaServer();\n    if (karmaServer.areBrowsersReady()) {\n      final Pair<JSDebugEngine, WebBrowser> engineAndBrowser =\n        new KarmaDebugBrowserSelector(project, karmaServer.getCapturedBrowsers(), environment, this).selectDebugEngine();\n      return prepareDebugger(project, engineAndBrowser, new RunProfileStarter() {\n        @Nullable\n        @Override\n        public RunContentDescriptor execute(@NotNull Project project,\n                                            @NotNull Executor executor,\n                                            @NotNull RunProfileState state,\n                                            @Nullable RunContentDescriptor contentToReuse,\n                                            @NotNull ExecutionEnvironment env) throws ExecutionException {\n          if (engineAndBrowser == null) {\n            return null;\n          }\n\n          final Url url = Urls.newFromEncoded(karmaServer.formatUrl(\"/debug.html\"));\n          final DebuggableFileFinder fileFinder = getDebuggableFileFinder(karmaServer);\n          XDebugSession session = XDebuggerManager.getInstance(project).startSession(\n            KarmaDebugProgramRunner.this,\n            env,\n            contentToReuse,\n            new XDebugProcessStarter() {\n              @Override\n              @NotNull\n              public XDebugProcess start(@NotNull final XDebugSession session) {\n                JSDebugProcess<?> debugProcess =\n                  engineAndBrowser.first.createDebugProcess(session, engineAndBrowser.second, fileFinder, url, executionResult, true);\n                debugProcess.setElementsInspectorEnabled(false);\n                debugProcess.setLayouter(consoleView.createDebugLayouter(debugProcess));\n                return debugProcess;\n              }\n            }\n          );\n          return session.getRunContentDescriptor();\n\n        }\n      });\n    }\n    else {\n      return AsyncResult.<RunProfileStarter>done(new RunProfileStarter() {\n        @Nullable\n        @Override\n        public RunContentDescriptor execute(@NotNull Project project,\n                                            @NotNull Executor executor,\n                                            @NotNull RunProfileState state,\n                                            @Nullable RunContentDescriptor contentToReuse,\n                                            @NotNull ExecutionEnvironment env) {\n          RunContentBuilder contentBuilder = new RunContentBuilder(KarmaDebugProgramRunner.this, executionResult, env);\n          final RunContentDescriptor descriptor = contentBuilder.showRunContent(contentToReuse);\n          karmaServer.onBrowsersReady(new Runnable() {\n            @Override\n            public void run() {\n              KarmaUtil.restart(descriptor);\n            }\n          });\n          return descriptor;\n        }\n      });\n    }\n  }","id":29315,"modified_method":"@NotNull\n  @Override\n  protected AsyncResult<RunProfileStarter> prepare(@NotNull Project project,\n                                                   @NotNull ExecutionEnvironment environment,\n                                                   @NotNull RunProfileState state) throws ExecutionException {\n    final ExecutionResult executionResult = state.execute(environment.getExecutor(), this);\n    if (executionResult == null) {\n      return AsyncResult.rejected();\n    }\n\n    final KarmaConsoleView consoleView = KarmaConsoleView.get(executionResult);\n    if (consoleView == null) {\n      throw new RuntimeException(\"KarmaConsoleView was expected!\");\n    }\n\n    final KarmaServer karmaServer = consoleView.getKarmaExecutionSession().getKarmaServer();\n    if (karmaServer.areBrowsersReady()) {\n      final DebuggableWebBrowser debuggableWebBrowser =\n        new KarmaDebugBrowserSelector(project, karmaServer.getCapturedBrowsers(), environment, this).selectDebugEngine();\n      return prepareDebugger(project, debuggableWebBrowser, new RunProfileStarter() {\n        @Nullable\n        @Override\n        public RunContentDescriptor execute(@NotNull Project project,\n                                            @NotNull Executor executor,\n                                            @NotNull RunProfileState state,\n                                            @Nullable RunContentDescriptor contentToReuse,\n                                            @NotNull ExecutionEnvironment env) throws ExecutionException {\n          if (debuggableWebBrowser == null) {\n            return null;\n          }\n\n          final Url url = Urls.newFromEncoded(karmaServer.formatUrl(\"/debug.html\"));\n          final DebuggableFileFinder fileFinder = getDebuggableFileFinder(karmaServer);\n          XDebugSession session = XDebuggerManager.getInstance(project).startSession(\n            KarmaDebugProgramRunner.this,\n            env,\n            contentToReuse,\n            new XDebugProcessStarter() {\n              @Override\n              @NotNull\n              public XDebugProcess start(@NotNull final XDebugSession session) {\n                JSDebugEngine debugEngine = debuggableWebBrowser.getDebugEngine();\n                WebBrowser browser = debuggableWebBrowser.getWebBrowser();\n                JSDebugProcess<?> debugProcess = debugEngine.createDebugProcess(session, browser, fileFinder, url, executionResult, true);\n                debugProcess.setElementsInspectorEnabled(false);\n                debugProcess.setLayouter(consoleView.createDebugLayouter(debugProcess));\n                return debugProcess;\n              }\n            }\n          );\n          return session.getRunContentDescriptor();\n\n        }\n      });\n    }\n    else {\n      return AsyncResult.<RunProfileStarter>done(new RunProfileStarter() {\n        @Nullable\n        @Override\n        public RunContentDescriptor execute(@NotNull Project project,\n                                            @NotNull Executor executor,\n                                            @NotNull RunProfileState state,\n                                            @Nullable RunContentDescriptor contentToReuse,\n                                            @NotNull ExecutionEnvironment env) {\n          RunContentBuilder contentBuilder = new RunContentBuilder(KarmaDebugProgramRunner.this, executionResult, env);\n          final RunContentDescriptor descriptor = contentBuilder.showRunContent(contentToReuse);\n          karmaServer.onBrowsersReady(new Runnable() {\n            @Override\n            public void run() {\n              KarmaUtil.restart(descriptor);\n            }\n          });\n          return descriptor;\n        }\n      });\n    }\n  }","commit_id":"1f3e513e97f43b3fbbeaf35a7e027e8b68c0478d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private <D extends CallableDescriptor> OverloadResolutionResultsImpl<D> completeTypeInferenceDependentOnExpectedType(\n            @NotNull BasicCallResolutionContext context,\n            @NotNull OverloadResolutionResultsImpl<D> results,\n            @NotNull TracingStrategy tracing\n    ) {\n        if (results.isSingleResult()) {\n            ResolvedCall<D> call = results.getResultingCall();\n            if (call instanceof ResolvedCallImpl) {\n                argumentTypeResolver.checkUnmappedArgumentTypes(context, ((ResolvedCallImpl<D>)call).getUnmappedArguments());\n            }\n        }\n\n        if (!results.isSingleResult()) return results;\n\n        ResolvedCallImpl<D> resolvedCall = results.getResultingCall().getCallToCompleteTypeArgumentInference();\n\n        if (!resolvedCall.hasIncompleteTypeParameters()) {\n            CallCandidateResolutionContext<D> callCandidateResolutionContext =\n                    CallCandidateResolutionContext.createForCallBeingAnalyzed(resolvedCall, context, tracing);\n            candidateResolver.completeNestedCallsInference(callCandidateResolutionContext);\n            candidateResolver.checkValueArgumentTypes(callCandidateResolutionContext);\n            return results;\n        }\n        ResolvedCallImpl<D> copy = CallResolverUtil.copy(resolvedCall, context);\n        CallCandidateResolutionContext<D> callCandidateResolutionContext =\n                CallCandidateResolutionContext.createForCallBeingAnalyzed(copy, context, tracing);\n        candidateResolver.completeTypeInferenceDependentOnExpectedTypeForCall(callCandidateResolutionContext, false);\n\n        if (copy.getStatus().isSuccess()) {\n            return OverloadResolutionResultsImpl.success(copy);\n        }\n        return OverloadResolutionResultsImpl.incompleteTypeInference(copy);\n    }","id":29316,"modified_method":"private <D extends CallableDescriptor> OverloadResolutionResultsImpl<D> completeTypeInferenceDependentOnExpectedType(\n            @NotNull BasicCallResolutionContext context,\n            @NotNull OverloadResolutionResultsImpl<D> results,\n            @NotNull TracingStrategy tracing\n    ) {\n        if (results.isSingleResult()) {\n            argumentTypeResolver.checkUnmappedArgumentTypes(\n                    context, results.getResultingCall().getCallToCompleteTypeArgumentInference().getUnmappedArguments());\n        }\n\n        if (!results.isSingleResult()) return results;\n\n        ResolvedCallImpl<D> resolvedCall = results.getResultingCall().getCallToCompleteTypeArgumentInference();\n\n        if (!resolvedCall.hasIncompleteTypeParameters()) {\n            CallCandidateResolutionContext<D> callCandidateResolutionContext =\n                    CallCandidateResolutionContext.createForCallBeingAnalyzed(resolvedCall, context, tracing);\n            candidateResolver.completeNestedCallsInference(callCandidateResolutionContext);\n            candidateResolver.checkValueArgumentTypes(callCandidateResolutionContext);\n            return results;\n        }\n        ResolvedCallImpl<D> copy = CallResolverUtil.copy(resolvedCall, context);\n        CallCandidateResolutionContext<D> callCandidateResolutionContext =\n                CallCandidateResolutionContext.createForCallBeingAnalyzed(copy, context, tracing);\n        candidateResolver.completeTypeInferenceDependentOnExpectedTypeForCall(callCandidateResolutionContext, false);\n\n        if (copy.getStatus().isSuccess()) {\n            return OverloadResolutionResultsImpl.success(copy);\n        }\n        return OverloadResolutionResultsImpl.incompleteTypeInference(copy);\n    }","commit_id":"c66d8dbc8a601ad800c1c5093eb97dbc661ef744","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private <D extends CallableDescriptor> OverloadResolutionResults<D> resolveFunctionArguments(\n            @NotNull BasicCallResolutionContext context,\n            @NotNull OverloadResolutionResults<D> results\n    ) {\n        if (results.isSingleResult()) {\n            ResolvedCall<D> resolvedCall = results.getResultingCall();\n            if (resolvedCall instanceof ResolvedCallImpl) {\n                argumentTypeResolver.checkTypesForFunctionArguments(context, (ResolvedCallImpl<D>) resolvedCall);\n            }\n        }\n        else {\n            argumentTypeResolver.checkTypesForFunctionArgumentsWithNoCallee(context);\n        }\n        return results;\n    }","id":29317,"modified_method":"private <D extends CallableDescriptor> OverloadResolutionResults<D> resolveFunctionArguments(\n            @NotNull BasicCallResolutionContext context,\n            @NotNull OverloadResolutionResultsImpl<D> results\n    ) {\n        if (results.isSingleResult()) {\n            argumentTypeResolver.checkTypesForFunctionArguments(context, results.getResultingCall().getCallToCompleteTypeArgumentInference());\n        }\n        else {\n            argumentTypeResolver.checkTypesForFunctionArgumentsWithNoCallee(context);\n        }\n        return results;\n    }","commit_id":"c66d8dbc8a601ad800c1c5093eb97dbc661ef744","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean hasReturnTypeDependentOnNotInferredParams(@NotNull ResolvedCallImpl<?> callToComplete) {\n        ConstraintSystem constraintSystem = callToComplete.getConstraintSystem();\n        if (constraintSystem == null) return false;\n\n        CallableDescriptor candidateDescriptor = callToComplete.getCandidateDescriptor();\n        JetType returnType = candidateDescriptor.getReturnType();\n        if (returnType == null) return false;\n\n        for (TypeParameterDescriptor typeVariable : constraintSystem.getTypeVariables()) {\n            JetType inferredValueForTypeVariable = constraintSystem.getTypeBounds(typeVariable).getValue();\n            if (inferredValueForTypeVariable == null) {\n                if (TypeUtils.dependsOnTypeParameters(returnType, Collections.singleton(typeVariable))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":29318,"modified_method":"private static boolean hasReturnTypeDependentOnNotInferredParams(\n            @NotNull CallableDescriptor candidateDescriptor,\n            @NotNull ConstraintSystem constraintSystem\n    ) {\n        JetType returnType = candidateDescriptor.getReturnType();\n        if (returnType == null) return false;\n\n        for (TypeParameterDescriptor typeVariable : constraintSystem.getTypeVariables()) {\n            JetType inferredValueForTypeVariable = constraintSystem.getTypeBounds(typeVariable).getValue();\n            if (inferredValueForTypeVariable == null) {\n                if (TypeUtils.dependsOnTypeParameters(returnType, Collections.singleton(typeVariable))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"9c60430ef2c2e4ca45f8499c38bd10b87b3f8260","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private <D extends CallableDescriptor> JetType reportInferenceError(\n            @NotNull CallCandidateResolutionContext<D> context\n    ) {\n        ResolvedCallImpl<D> resolvedCall = context.candidateCall;\n        ConstraintSystem constraintSystem = resolvedCall.getConstraintSystem();\n        assert constraintSystem != null;\n\n        resolvedCall.setResultingSubstitutor(constraintSystem.getResultingSubstitutor());\n        completeNestedCallsInference(context);\n        List<JetType> argumentTypes = checkValueArgumentTypes(\n                context, resolvedCall, context.trace, RESOLVE_FUNCTION_ARGUMENTS).argumentTypes;\n        JetType receiverType = resolvedCall.getReceiverArgument().exists() ? resolvedCall.getReceiverArgument().getType() : null;\n        InferenceErrorData errorData = InferenceErrorData\n                .create(resolvedCall.getCandidateDescriptor(), constraintSystem, argumentTypes, receiverType, context.expectedType);\n\n        context.tracing.typeInferenceFailed(context.trace, errorData);\n        resolvedCall.addStatus(ResolutionStatus.OTHER_ERROR);\n        if (!CallResolverUtil.hasInferredReturnType(resolvedCall)) return null;\n        return resolvedCall.getResultingDescriptor().getReturnType();\n    }","id":29319,"modified_method":"private <D extends CallableDescriptor> JetType reportInferenceError(\n            @NotNull CallCandidateResolutionContext<D> context\n    ) {\n        ResolvedCallImpl<D> resolvedCall = context.candidateCall;\n        ConstraintSystem constraintSystem = resolvedCall.getConstraintSystem();\n        assert constraintSystem != null;\n\n        resolvedCall.setResultingSubstitutor(constraintSystem.getResultingSubstitutor());\n        completeNestedCallsInference(context);\n        List<JetType> argumentTypes = checkValueArgumentTypes(\n                context, resolvedCall, context.trace, RESOLVE_FUNCTION_ARGUMENTS).argumentTypes;\n        JetType receiverType = resolvedCall.getReceiverArgument().exists() ? resolvedCall.getReceiverArgument().getType() : null;\n        InferenceErrorData errorData = InferenceErrorData\n                .create(resolvedCall.getCandidateDescriptor(), constraintSystem, argumentTypes, receiverType, context.expectedType);\n\n        context.tracing.typeInferenceFailed(context.trace, errorData);\n        resolvedCall.addStatus(ResolutionStatus.OTHER_ERROR);\n        if (!resolvedCall.hasInferredReturnType()) return null;\n        return resolvedCall.getResultingDescriptor().getReturnType();\n    }","commit_id":"9c60430ef2c2e4ca45f8499c38bd10b87b3f8260","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static <D extends CallableDescriptor> ResolvedCallWithTrace<D> getResultingCall(\n            @NotNull OverloadResolutionResultsImpl<D> results,\n            @NotNull ContextDependency contextDependency\n    ) {\n        if (results.isSingleResult() && contextDependency == ContextDependency.INDEPENDENT) {\n            if (!CallResolverUtil.hasInferredReturnType(results.getResultingCall())) {\n                return null;\n            }\n        }\n        return results.isSingleResult() ? results.getResultingCall() : null;\n    }","id":29320,"modified_method":"@Nullable\n    public static <D extends CallableDescriptor> ResolvedCallWithTrace<D> getResultingCall(\n            @NotNull OverloadResolutionResultsImpl<D> results,\n            @NotNull ContextDependency contextDependency\n    ) {\n        if (results.isSingleResult() && contextDependency == ContextDependency.INDEPENDENT) {\n            if (!results.getResultingCall().getCallToCompleteTypeArgumentInference().hasInferredReturnType()) {\n                return null;\n            }\n        }\n        return results.isSingleResult() ? results.getResultingCall() : null;\n    }","commit_id":"9c60430ef2c2e4ca45f8499c38bd10b87b3f8260","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void cleanInternalData() {\n        trace = null;\n        constraintSystem = null;\n        tracing = null;\n        cleaned = true;\n    }","id":29321,"modified_method":"@Override\n    public void cleanInternalData() {\n        if (!cleaned) {\n            hasInferredReturnType = CallResolverUtil.hasInferredReturnType(candidateDescriptor, constraintSystem);\n        }\n        trace = null;\n        constraintSystem = null;\n        tracing = null;\n        cleaned = true;\n    }","commit_id":"9c60430ef2c2e4ca45f8499c38bd10b87b3f8260","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private FunctionDescriptor resolveCallableNotCheckingArguments(\n            @NotNull JetSimpleNameExpression reference,\n            @NotNull ReceiverValue receiver,\n            @NotNull ExpressionTypingContext context,\n            @NotNull boolean[] result\n    ) {\n        Call call = CallMaker.makeCall(reference, receiver, null, reference, ThrowingList.<ValueArgument>instance());\n\n        TemporaryBindingTrace trace = TemporaryBindingTrace.create(context.trace, \"trace to resolve as function\", reference);\n\n        ExpressionTypingContext contextForResolve = context.replaceBindingTrace(trace).replaceExpectedType(NO_EXPECTED_TYPE);\n        ResolvedCallWithTrace<FunctionDescriptor> function = components.expressionTypingServices.getCallExpressionResolver()\n                .getResolvedCallForFunction(call, reference, contextForResolve, CheckValueArgumentsMode.DISABLED, result);\n        if (!result[0]) return null;\n\n        if (function instanceof VariableAsFunctionResolvedCall) {\n            // TODO: KProperty\n            context.trace.report(UNSUPPORTED.on(reference, \"References to variables aren't supported yet\"));\n            context.trace.report(UNRESOLVED_REFERENCE.on(reference, reference));\n            return null;\n        }\n\n        trace.commit();\n        return function != null ? function.getResultingDescriptor() : null;\n    }","id":29322,"modified_method":"@Nullable\n    private FunctionDescriptor resolveCallableNotCheckingArguments(\n            @NotNull JetSimpleNameExpression reference,\n            @NotNull ReceiverValue receiver,\n            @NotNull ExpressionTypingContext context,\n            @NotNull boolean[] result\n    ) {\n        Call call = CallMaker.makeCall(reference, receiver, null, reference, ThrowingList.<ValueArgument>instance());\n\n        TemporaryBindingTrace trace = TemporaryBindingTrace.create(context.trace, \"trace to resolve as function\", reference);\n\n        ExpressionTypingContext contextForResolve = context.replaceBindingTrace(trace).replaceExpectedType(NO_EXPECTED_TYPE);\n        ResolvedCall<FunctionDescriptor> function = components.expressionTypingServices.getCallExpressionResolver()\n                .getResolvedCallForFunction(call, reference, contextForResolve, CheckValueArgumentsMode.DISABLED, result);\n        if (!result[0]) return null;\n\n        if (function instanceof VariableAsFunctionResolvedCall) {\n            // TODO: KProperty\n            context.trace.report(UNSUPPORTED.on(reference, \"References to variables aren't supported yet\"));\n            context.trace.report(UNRESOLVED_REFERENCE.on(reference, reference));\n            return null;\n        }\n\n        trace.commit();\n        return function != null ? function.getResultingDescriptor() : null;\n    }","commit_id":"8f1c7aa8f6206c708e633b5baa9dee47e8abb0cd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public ResolvedCallWithTrace<FunctionDescriptor> getResolvedCallForFunction(\n            @NotNull Call call, @NotNull JetExpression callExpression,\n            @NotNull ResolutionContext context, @NotNull CheckValueArgumentsMode checkArguments,\n            @NotNull boolean[] result\n    ) {\n        CallResolver callResolver = expressionTypingServices.getCallResolver();\n        OverloadResolutionResultsImpl<FunctionDescriptor> results = callResolver.resolveFunctionCall(\n                BasicCallResolutionContext.create(context, call, checkArguments));\n        if (!results.isNothing()) {\n            checkSuper(call.getExplicitReceiver(), results, context.trace, callExpression);\n            result[0] = true;\n            return OverloadResolutionResultsUtil.getResultingCall(results, context.contextDependency);\n        }\n        result[0] = false;\n        return null;\n    }","id":29323,"modified_method":"@Nullable\n    public ResolvedCall<FunctionDescriptor> getResolvedCallForFunction(\n            @NotNull Call call, @NotNull JetExpression callExpression,\n            @NotNull ResolutionContext context, @NotNull CheckValueArgumentsMode checkArguments,\n            @NotNull boolean[] result\n    ) {\n        CallResolver callResolver = expressionTypingServices.getCallResolver();\n        OverloadResolutionResults<FunctionDescriptor> results = callResolver.resolveFunctionCall(\n                BasicCallResolutionContext.create(context, call, checkArguments));\n        if (!results.isNothing()) {\n            checkSuper(call.getExplicitReceiver(), results, context.trace, callExpression);\n            result[0] = true;\n            return OverloadResolutionResultsUtil.getResultingCall(results, context.contextDependency);\n        }\n        result[0] = false;\n        return null;\n    }","commit_id":"8f1c7aa8f6206c708e633b5baa9dee47e8abb0cd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public JetTypeInfo getCallExpressionTypeInfoWithoutFinalTypeCheck(\n            @NotNull JetCallExpression callExpression, @NotNull ReceiverValue receiver,\n            @Nullable ASTNode callOperationNode, @NotNull ExpressionTypingContext context\n    ) {\n        boolean[] result = new boolean[1];\n        Call call = CallMaker.makeCall(receiver, callOperationNode, callExpression);\n\n        TemporaryTraceAndCache temporaryForFunction = TemporaryTraceAndCache.create(\n                context, \"trace to resolve as function call\", callExpression);\n        ResolvedCallWithTrace<FunctionDescriptor> resolvedCall = getResolvedCallForFunction(\n                call, callExpression, context.replaceTraceAndCache(temporaryForFunction),\n                CheckValueArgumentsMode.ENABLED, result);\n        if (result[0]) {\n            FunctionDescriptor functionDescriptor = resolvedCall != null ? resolvedCall.getResultingDescriptor() : null;\n            temporaryForFunction.commit();\n            if (callExpression.getValueArgumentList() == null && callExpression.getFunctionLiteralArguments().isEmpty()) {\n                // there are only type arguments\n                boolean hasValueParameters = functionDescriptor == null || functionDescriptor.getValueParameters().size() > 0;\n                context.trace.report(FUNCTION_CALL_EXPECTED.on(callExpression, callExpression, hasValueParameters));\n            }\n            if (functionDescriptor == null) {\n                return JetTypeInfo.create(null, context.dataFlowInfo);\n            }\n            if (functionDescriptor instanceof ConstructorDescriptor && DescriptorUtils.isAnnotationClass(functionDescriptor.getContainingDeclaration())) {\n                if (!canInstantiateAnnotationClass(callExpression)) {\n                    context.trace.report(ANNOTATION_CLASS_CONSTRUCTOR_CALL.on(callExpression));\n                }\n            }\n\n            JetType type = functionDescriptor.getReturnType();\n\n            return JetTypeInfo.create(type, resolvedCall.getDataFlowInfoForArguments().getResultInfo());\n        }\n\n        JetExpression calleeExpression = callExpression.getCalleeExpression();\n        if (calleeExpression instanceof JetSimpleNameExpression && callExpression.getTypeArgumentList() == null) {\n            TemporaryTraceAndCache temporaryForVariable = TemporaryTraceAndCache.create(\n                    context, \"trace to resolve as variable with 'invoke' call\", callExpression);\n            JetType type = getVariableType((JetSimpleNameExpression) calleeExpression, receiver, callOperationNode,\n                                           context.replaceTraceAndCache(temporaryForVariable), result);\n            if (result[0]) {\n                temporaryForVariable.commit();\n                context.trace.report(FUNCTION_EXPECTED.on((JetReferenceExpression) calleeExpression, calleeExpression,\n                                                          type != null ? type : ErrorUtils.createErrorType(\"\")));\n                return JetTypeInfo.create(null, context.dataFlowInfo);\n            }\n        }\n        temporaryForFunction.commit();\n        return JetTypeInfo.create(null, context.dataFlowInfo);\n    }","id":29324,"modified_method":"@NotNull\n    public JetTypeInfo getCallExpressionTypeInfoWithoutFinalTypeCheck(\n            @NotNull JetCallExpression callExpression, @NotNull ReceiverValue receiver,\n            @Nullable ASTNode callOperationNode, @NotNull ExpressionTypingContext context\n    ) {\n        boolean[] result = new boolean[1];\n        Call call = CallMaker.makeCall(receiver, callOperationNode, callExpression);\n\n        TemporaryTraceAndCache temporaryForFunction = TemporaryTraceAndCache.create(\n                context, \"trace to resolve as function call\", callExpression);\n        ResolvedCall<FunctionDescriptor> resolvedCall = getResolvedCallForFunction(\n                call, callExpression, context.replaceTraceAndCache(temporaryForFunction),\n                CheckValueArgumentsMode.ENABLED, result);\n        if (result[0]) {\n            FunctionDescriptor functionDescriptor = resolvedCall != null ? resolvedCall.getResultingDescriptor() : null;\n            temporaryForFunction.commit();\n            if (callExpression.getValueArgumentList() == null && callExpression.getFunctionLiteralArguments().isEmpty()) {\n                // there are only type arguments\n                boolean hasValueParameters = functionDescriptor == null || functionDescriptor.getValueParameters().size() > 0;\n                context.trace.report(FUNCTION_CALL_EXPECTED.on(callExpression, callExpression, hasValueParameters));\n            }\n            if (functionDescriptor == null) {\n                return JetTypeInfo.create(null, context.dataFlowInfo);\n            }\n            if (functionDescriptor instanceof ConstructorDescriptor && DescriptorUtils.isAnnotationClass(functionDescriptor.getContainingDeclaration())) {\n                if (!canInstantiateAnnotationClass(callExpression)) {\n                    context.trace.report(ANNOTATION_CLASS_CONSTRUCTOR_CALL.on(callExpression));\n                }\n            }\n\n            JetType type = functionDescriptor.getReturnType();\n\n            return JetTypeInfo.create(type, resolvedCall.getDataFlowInfoForArguments().getResultInfo());\n        }\n\n        JetExpression calleeExpression = callExpression.getCalleeExpression();\n        if (calleeExpression instanceof JetSimpleNameExpression && callExpression.getTypeArgumentList() == null) {\n            TemporaryTraceAndCache temporaryForVariable = TemporaryTraceAndCache.create(\n                    context, \"trace to resolve as variable with 'invoke' call\", callExpression);\n            JetType type = getVariableType((JetSimpleNameExpression) calleeExpression, receiver, callOperationNode,\n                                           context.replaceTraceAndCache(temporaryForVariable), result);\n            if (result[0]) {\n                temporaryForVariable.commit();\n                context.trace.report(FUNCTION_EXPECTED.on((JetReferenceExpression) calleeExpression, calleeExpression,\n                                                          type != null ? type : ErrorUtils.createErrorType(\"\")));\n                return JetTypeInfo.create(null, context.dataFlowInfo);\n            }\n        }\n        temporaryForFunction.commit();\n        return JetTypeInfo.create(null, context.dataFlowInfo);\n    }","commit_id":"8f1c7aa8f6206c708e633b5baa9dee47e8abb0cd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    /*package*/ OverloadResolutionResultsImpl<FunctionDescriptor> resolveFunctionCall(@NotNull BasicCallResolutionContext context) {\n\n        ProgressIndicatorProvider.checkCanceled();\n\n        List<ResolutionTask<CallableDescriptor, FunctionDescriptor>> prioritizedTasks;\n\n        JetExpression calleeExpression = context.call.getCalleeExpression();\n        JetReferenceExpression functionReference;\n        if (calleeExpression instanceof JetSimpleNameExpression) {\n            JetSimpleNameExpression expression = (JetSimpleNameExpression) calleeExpression;\n            functionReference = expression;\n\n            Name name = expression.getReferencedNameAsName();\n\n            TracingStrategy tracing = TracingStrategyImpl.create(expression, context.call);\n            prioritizedTasks = TaskPrioritizer.<CallableDescriptor, FunctionDescriptor>computePrioritizedTasks(\n                    context, name, tracing, CallableDescriptorCollectors.FUNCTIONS_AND_VARIABLES);\n            ResolutionTask.DescriptorCheckStrategy abstractConstructorCheck = new ResolutionTask.DescriptorCheckStrategy() {\n                @Override\n                public <D extends CallableDescriptor> boolean performAdvancedChecks(D descriptor, BindingTrace trace, TracingStrategy tracing) {\n                    if (descriptor instanceof ConstructorDescriptor) {\n                        Modality modality = ((ConstructorDescriptor) descriptor).getContainingDeclaration().getModality();\n                        if (modality == Modality.ABSTRACT) {\n                            tracing.instantiationOfAbstractClass(trace);\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            };\n            for (ResolutionTask task : prioritizedTasks) {\n                task.setCheckingStrategy(abstractConstructorCheck);\n            }\n        }\n        else {\n            JetValueArgumentList valueArgumentList = context.call.getValueArgumentList();\n            PsiElement reportAbsenceOn = valueArgumentList == null ? context.call.getCallElement() : valueArgumentList;\n            if (calleeExpression instanceof JetConstructorCalleeExpression) {\n                assert !context.call.getExplicitReceiver().exists();\n\n                JetConstructorCalleeExpression expression = (JetConstructorCalleeExpression) calleeExpression;\n                functionReference = expression.getConstructorReferenceExpression();\n                if (functionReference == null) {\n                    return checkArgumentTypesAndFail(context); // No type there\n                }\n                JetTypeReference typeReference = expression.getTypeReference();\n                assert typeReference != null;\n                JetType constructedType = typeResolver.resolveType(context.scope, typeReference, context.trace, true);\n\n                if (constructedType.isError()) {\n                    return checkArgumentTypesAndFail(context);\n                }\n\n                DeclarationDescriptor declarationDescriptor = constructedType.getConstructor().getDeclarationDescriptor();\n                if (declarationDescriptor instanceof ClassDescriptor) {\n                    ClassDescriptor classDescriptor = (ClassDescriptor) declarationDescriptor;\n                    Collection<ConstructorDescriptor> constructors = classDescriptor.getConstructors();\n                    if (constructors.isEmpty()) {\n                        context.trace.report(NO_CONSTRUCTOR.on(reportAbsenceOn));\n                        return checkArgumentTypesAndFail(context);\n                    }\n                    Collection<ResolutionCandidate<CallableDescriptor>> candidates =\n                            TaskPrioritizer.<CallableDescriptor>convertWithImpliedThisAndNoReceiver(\n                                    context.scope, constructors, context.call);\n                    prioritizedTasks = TaskPrioritizer.<CallableDescriptor, FunctionDescriptor>computePrioritizedTasksFromCandidates(\n                            context, candidates, TracingStrategyImpl.create(functionReference, context.call));\n                }\n                else {\n                    context.trace.report(NOT_A_CLASS.on(calleeExpression));\n                    return checkArgumentTypesAndFail(context);\n                }\n            }\n            else if (calleeExpression instanceof JetThisReferenceExpression) {\n                functionReference = (JetThisReferenceExpression) calleeExpression;\n                DeclarationDescriptor containingDeclaration = context.scope.getContainingDeclaration();\n                if (containingDeclaration instanceof ConstructorDescriptor) {\n                    containingDeclaration = containingDeclaration.getContainingDeclaration();\n                }\n                assert containingDeclaration instanceof ClassDescriptor;\n                ClassDescriptor classDescriptor = (ClassDescriptor) containingDeclaration;\n\n                Collection<ConstructorDescriptor> constructors = classDescriptor.getConstructors();\n                if (constructors.isEmpty()) {\n                    context.trace.report(NO_CONSTRUCTOR.on(reportAbsenceOn));\n                    return checkArgumentTypesAndFail(context);\n                }\n                List<ResolutionCandidate<CallableDescriptor>> candidates = ResolutionCandidate.<CallableDescriptor>convertCollection(\n                        context.call, constructors, JetPsiUtil.isSafeCall(context.call));\n                prioritizedTasks = Collections.singletonList(new ResolutionTask<CallableDescriptor, FunctionDescriptor>(candidates, functionReference, context)); // !! DataFlowInfo.EMPTY\n            }\n            else if (calleeExpression != null) {\n\n                // Here we handle the case where the callee expression must be something of type function, e.g. (foo.bar())(1, 2)\n                JetType calleeType = expressionTypingServices.safeGetType(context.scope, calleeExpression, NO_EXPECTED_TYPE, context.dataFlowInfo, context.trace); // We are actually expecting a function, but there seems to be no easy way of expressing this\n                ExpressionReceiver expressionReceiver = new ExpressionReceiver(calleeExpression, calleeType);\n\n                Call call = new CallTransformer.CallForImplicitInvoke(\n                        context.call.getExplicitReceiver(), expressionReceiver, context.call);\n                TracingStrategyForInvoke tracingForInvoke = new TracingStrategyForInvoke(calleeExpression, call, calleeType);\n                return (OverloadResolutionResultsImpl<FunctionDescriptor>)\n                        resolveCallForInvoke(context.replaceCall(call), tracingForInvoke);\n            }\n            else {\n//                checkTypesWithNoCallee(trace, scope, call);\n                return checkArgumentTypesAndFail(context);\n            }\n        }\n\n        TracingStrategy tracing = TracingStrategyImpl.create(functionReference, context.call);\n        OverloadResolutionResultsImpl<FunctionDescriptor> results = doResolveCallOrGetCachedResults(\n                ResolutionResultsCache.FUNCTION_MEMBER_TYPE, context, prioritizedTasks,\n                CallTransformer.FUNCTION_CALL_TRANSFORMER, tracing);\n        if (calleeExpression instanceof JetSimpleNameExpression) {\n            ExpressionTypingUtils.checkCapturingInClosure((JetSimpleNameExpression) calleeExpression, context.trace, context.scope);\n        }\n        return results;\n    }","id":29325,"modified_method":"@NotNull\n    public OverloadResolutionResults<FunctionDescriptor> resolveFunctionCall(@NotNull BasicCallResolutionContext context) {\n\n        ProgressIndicatorProvider.checkCanceled();\n\n        List<ResolutionTask<CallableDescriptor, FunctionDescriptor>> prioritizedTasks;\n\n        JetExpression calleeExpression = context.call.getCalleeExpression();\n        JetReferenceExpression functionReference;\n        if (calleeExpression instanceof JetSimpleNameExpression) {\n            JetSimpleNameExpression expression = (JetSimpleNameExpression) calleeExpression;\n            functionReference = expression;\n\n            Name name = expression.getReferencedNameAsName();\n\n            TracingStrategy tracing = TracingStrategyImpl.create(expression, context.call);\n            prioritizedTasks = TaskPrioritizer.<CallableDescriptor, FunctionDescriptor>computePrioritizedTasks(\n                    context, name, tracing, CallableDescriptorCollectors.FUNCTIONS_AND_VARIABLES);\n            ResolutionTask.DescriptorCheckStrategy abstractConstructorCheck = new ResolutionTask.DescriptorCheckStrategy() {\n                @Override\n                public <D extends CallableDescriptor> boolean performAdvancedChecks(D descriptor, BindingTrace trace, TracingStrategy tracing) {\n                    if (descriptor instanceof ConstructorDescriptor) {\n                        Modality modality = ((ConstructorDescriptor) descriptor).getContainingDeclaration().getModality();\n                        if (modality == Modality.ABSTRACT) {\n                            tracing.instantiationOfAbstractClass(trace);\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            };\n            for (ResolutionTask task : prioritizedTasks) {\n                task.setCheckingStrategy(abstractConstructorCheck);\n            }\n        }\n        else {\n            JetValueArgumentList valueArgumentList = context.call.getValueArgumentList();\n            PsiElement reportAbsenceOn = valueArgumentList == null ? context.call.getCallElement() : valueArgumentList;\n            if (calleeExpression instanceof JetConstructorCalleeExpression) {\n                assert !context.call.getExplicitReceiver().exists();\n\n                JetConstructorCalleeExpression expression = (JetConstructorCalleeExpression) calleeExpression;\n                functionReference = expression.getConstructorReferenceExpression();\n                if (functionReference == null) {\n                    return checkArgumentTypesAndFail(context); // No type there\n                }\n                JetTypeReference typeReference = expression.getTypeReference();\n                assert typeReference != null;\n                JetType constructedType = typeResolver.resolveType(context.scope, typeReference, context.trace, true);\n\n                if (constructedType.isError()) {\n                    return checkArgumentTypesAndFail(context);\n                }\n\n                DeclarationDescriptor declarationDescriptor = constructedType.getConstructor().getDeclarationDescriptor();\n                if (declarationDescriptor instanceof ClassDescriptor) {\n                    ClassDescriptor classDescriptor = (ClassDescriptor) declarationDescriptor;\n                    Collection<ConstructorDescriptor> constructors = classDescriptor.getConstructors();\n                    if (constructors.isEmpty()) {\n                        context.trace.report(NO_CONSTRUCTOR.on(reportAbsenceOn));\n                        return checkArgumentTypesAndFail(context);\n                    }\n                    Collection<ResolutionCandidate<CallableDescriptor>> candidates =\n                            TaskPrioritizer.<CallableDescriptor>convertWithImpliedThisAndNoReceiver(\n                                    context.scope, constructors, context.call);\n                    prioritizedTasks = TaskPrioritizer.<CallableDescriptor, FunctionDescriptor>computePrioritizedTasksFromCandidates(\n                            context, candidates, TracingStrategyImpl.create(functionReference, context.call));\n                }\n                else {\n                    context.trace.report(NOT_A_CLASS.on(calleeExpression));\n                    return checkArgumentTypesAndFail(context);\n                }\n            }\n            else if (calleeExpression instanceof JetThisReferenceExpression) {\n                functionReference = (JetThisReferenceExpression) calleeExpression;\n                DeclarationDescriptor containingDeclaration = context.scope.getContainingDeclaration();\n                if (containingDeclaration instanceof ConstructorDescriptor) {\n                    containingDeclaration = containingDeclaration.getContainingDeclaration();\n                }\n                assert containingDeclaration instanceof ClassDescriptor;\n                ClassDescriptor classDescriptor = (ClassDescriptor) containingDeclaration;\n\n                Collection<ConstructorDescriptor> constructors = classDescriptor.getConstructors();\n                if (constructors.isEmpty()) {\n                    context.trace.report(NO_CONSTRUCTOR.on(reportAbsenceOn));\n                    return checkArgumentTypesAndFail(context);\n                }\n                List<ResolutionCandidate<CallableDescriptor>> candidates = ResolutionCandidate.<CallableDescriptor>convertCollection(\n                        context.call, constructors, JetPsiUtil.isSafeCall(context.call));\n                prioritizedTasks = Collections.singletonList(new ResolutionTask<CallableDescriptor, FunctionDescriptor>(candidates, functionReference, context)); // !! DataFlowInfo.EMPTY\n            }\n            else if (calleeExpression != null) {\n\n                // Here we handle the case where the callee expression must be something of type function, e.g. (foo.bar())(1, 2)\n                JetType calleeType = expressionTypingServices.safeGetType(context.scope, calleeExpression, NO_EXPECTED_TYPE, context.dataFlowInfo, context.trace); // We are actually expecting a function, but there seems to be no easy way of expressing this\n                ExpressionReceiver expressionReceiver = new ExpressionReceiver(calleeExpression, calleeType);\n\n                Call call = new CallTransformer.CallForImplicitInvoke(\n                        context.call.getExplicitReceiver(), expressionReceiver, context.call);\n                TracingStrategyForInvoke tracingForInvoke = new TracingStrategyForInvoke(calleeExpression, call, calleeType);\n                return resolveCallForInvoke(context.replaceCall(call), tracingForInvoke);\n            }\n            else {\n                return checkArgumentTypesAndFail(context);\n            }\n        }\n\n        TracingStrategy tracing = TracingStrategyImpl.create(functionReference, context.call);\n        OverloadResolutionResultsImpl<FunctionDescriptor> results = doResolveCallOrGetCachedResults(\n                ResolutionResultsCache.FUNCTION_MEMBER_TYPE, context, prioritizedTasks,\n                CallTransformer.FUNCTION_CALL_TRANSFORMER, tracing);\n        if (calleeExpression instanceof JetSimpleNameExpression) {\n            ExpressionTypingUtils.checkCapturingInClosure((JetSimpleNameExpression) calleeExpression, context.trace, context.scope);\n        }\n        return results;\n    }","commit_id":"8f1c7aa8f6206c708e633b5baa9dee47e8abb0cd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static <D extends CallableDescriptor> ResolvedCallWithTrace<D> getResultingCall(\n            @NotNull OverloadResolutionResultsImpl<D> results,\n            @NotNull ContextDependency contextDependency\n    ) {\n        if (results.isSingleResult() && contextDependency == ContextDependency.INDEPENDENT) {\n            if (!results.getResultingCall().getCallToCompleteTypeArgumentInference().hasInferredReturnType()) {\n                return null;\n            }\n        }\n        return results.isSingleResult() ? results.getResultingCall() : null;\n    }","id":29326,"modified_method":"@Nullable\n    public static <D extends CallableDescriptor> ResolvedCall<D> getResultingCall(\n            @NotNull OverloadResolutionResults<D> results,\n            @NotNull ContextDependency contextDependency\n    ) {\n        if (results.isSingleResult() && contextDependency == ContextDependency.INDEPENDENT) {\n            ResolvedCall<D> resultingCall = results.getResultingCall();\n            if (!((ResolvedCallWithTrace<D>)resultingCall).getCallToCompleteTypeArgumentInference().hasInferredReturnType()) {\n                return null;\n            }\n        }\n        return results.isSingleResult() ? results.getResultingCall() : null;\n    }","commit_id":"8f1c7aa8f6206c708e633b5baa9dee47e8abb0cd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static <D extends CallableDescriptor> JetType getResultingType(\n            @NotNull OverloadResolutionResults<D> results,\n            @NotNull ContextDependency contextDependency\n    ) {\n        ResolvedCall<D> resultingCall = getResultingCall((OverloadResolutionResultsImpl<D>) results, contextDependency);\n        return resultingCall != null ? resultingCall.getResultingDescriptor().getReturnType() : null;\n    }","id":29327,"modified_method":"@Nullable\n    public static <D extends CallableDescriptor> JetType getResultingType(\n            @NotNull OverloadResolutionResults<D> results,\n            @NotNull ContextDependency contextDependency\n    ) {\n        ResolvedCall<D> resultingCall = getResultingCall(results, contextDependency);\n        return resultingCall != null ? resultingCall.getResultingDescriptor().getReturnType() : null;\n    }","commit_id":"8f1c7aa8f6206c708e633b5baa9dee47e8abb0cd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public ArtifactResolutionResult()\n    {\n        conflicts = new HashMap();\n    }","id":29328,"modified_method":"public ArtifactResolutionResult()\n    {\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"public void setArtifacts( Set artifacts )\n    {\n        this.artifacts = artifacts;\n    }","id":29329,"modified_method":"public void setArtifactResolutionNodes( Set resolutionNodes )\n    {\n        this.resolutionNodes = resolutionNodes;\n        \n        // clear the cache\n        this.artifacts = null;\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"public Set getArtifacts()\n    {\n        return artifacts;\n    }","id":29330,"modified_method":"public Set getArtifacts()\n    {\n        if ( artifacts == null )\n        {\n            artifacts = new HashSet();\n            \n            for ( Iterator it = resolutionNodes.iterator(); it.hasNext(); )\n            {\n                ResolutionNode node = (ResolutionNode) it.next();\n                artifacts.add( node.getArtifact() );\n            }\n        }\n        \n        return artifacts;\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"public void testTransitiveResolutionWhereAllArtifactsAreNotPresentInTheLocalRepositoryAndMustBeRetrievedFromTheRemoteRepository()\n        throws Exception\n    {\n        Artifact i = createRemoteArtifact( \"i\", \"1.0\" );\n        deleteLocalArtifact( i );\n\n        Artifact j = createRemoteArtifact( \"j\", \"1.0\" );\n        deleteLocalArtifact( j );\n\n        ArtifactMetadataSource mds = new ArtifactMetadataSource()\n        {\n            public Set retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n            {\n                Set dependencies = new HashSet();\n\n                if ( artifact.getArtifactId().equals( \"i\" ) )\n                {\n                    dependencies.add( createArtifact( \"org.apache.maven\", \"j\", \"1.0\", \"jar\" ) );\n                }\n\n                return dependencies;\n            }\n        };\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( Collections.singleton( i ),\n                                                                                projectArtifact, remoteRepositories(),\n                                                                                localRepository(), mds );\n\n        assertEquals( 2, result.getArtifacts().size() );\n\n        assertTrue( result.getArtifacts().contains( i ) );\n\n        assertTrue( result.getArtifacts().contains( j ) );\n\n        assertLocalArtifactPresent( i );\n\n        assertLocalArtifactPresent( j );\n    }","id":29331,"modified_method":"public void testTransitiveResolutionWhereAllArtifactsAreNotPresentInTheLocalRepositoryAndMustBeRetrievedFromTheRemoteRepository()\n        throws Exception\n    {\n        Artifact i = createRemoteArtifact( \"i\", \"1.0\" );\n        deleteLocalArtifact( i );\n\n        Artifact j = createRemoteArtifact( \"j\", \"1.0\" );\n        deleteLocalArtifact( j );\n\n        ArtifactMetadataSource mds = new ArtifactMetadataSource()\n        {\n            public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n            {\n                Set dependencies = new HashSet();\n\n                if ( artifact.getArtifactId().equals( \"i\" ) )\n                {\n                    dependencies.add( createArtifact( \"org.apache.maven\", \"j\", \"1.0\", \"jar\" ) );\n                }\n\n                return new ResolutionGroup( dependencies, remoteRepositories );\n            }\n        };\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( Collections.singleton( i ),\n                                                                                projectArtifact, remoteRepositories(),\n                                                                                localRepository(), mds );\n\n        assertEquals( 2, result.getArtifacts().size() );\n\n        assertTrue( result.getArtifacts().contains( i ) );\n\n        assertTrue( result.getArtifacts().contains( j ) );\n\n        assertLocalArtifactPresent( i );\n\n        assertLocalArtifactPresent( j );\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"public void testTransitiveResolutionWhereAllArtifactsArePresentInTheLocalRepository()\n        throws Exception\n    {\n        Artifact g = createLocalArtifact( \"g\", \"1.0\" );\n\n        Artifact h = createLocalArtifact( \"h\", \"1.0\" );\n\n        ArtifactMetadataSource mds = new ArtifactMetadataSource()\n        {\n            public Set retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n            {\n                Set dependencies = new HashSet();\n\n                if ( artifact.getArtifactId().equals( \"g\" ) )\n                {\n                    dependencies.add( createArtifact( \"org.apache.maven\", \"h\", \"1.0\", \"jar\" ) );\n                }\n\n                return dependencies;\n            }\n        };\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( Collections.singleton( g ),\n                                                                                projectArtifact, remoteRepositories(),\n                                                                                localRepository(), mds );\n\n        assertEquals( 2, result.getArtifacts().size() );\n\n        assertTrue( result.getArtifacts().contains( g ) );\n\n        assertTrue( result.getArtifacts().contains( h ) );\n\n        assertLocalArtifactPresent( g );\n\n        assertLocalArtifactPresent( h );\n    }","id":29332,"modified_method":"public void testTransitiveResolutionWhereAllArtifactsArePresentInTheLocalRepository()\n        throws Exception\n    {\n        Artifact g = createLocalArtifact( \"g\", \"1.0\" );\n\n        Artifact h = createLocalArtifact( \"h\", \"1.0\" );\n\n        ArtifactMetadataSource mds = new ArtifactMetadataSource()\n        {\n            public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n            {\n                Set dependencies = new HashSet();\n\n                if ( artifact.getArtifactId().equals( \"g\" ) )\n                {\n                    dependencies.add( createArtifact( \"org.apache.maven\", \"h\", \"1.0\", \"jar\" ) );\n                }\n\n                return new ResolutionGroup( dependencies, remoteRepositories );\n            }\n        };\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( Collections.singleton( g ),\n                                                                                projectArtifact, remoteRepositories(),\n                                                                                localRepository(), mds );\n\n        assertEquals( 2, result.getArtifacts().size() );\n\n        assertTrue( result.getArtifacts().contains( g ) );\n\n        assertTrue( result.getArtifacts().contains( h ) );\n\n        assertLocalArtifactPresent( g );\n\n        assertLocalArtifactPresent( h );\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,\n                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,\n                          ArtifactFilter filter, ArtifactFactory artifactFactory, List listeners )\n        throws CyclicDependencyException, TransitiveArtifactResolutionException\n    {\n        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );\n\n        // TODO: conflict resolvers, shouldn't be munging original artifact perhaps?\n        Object key = node.getKey();\n        if ( managedVersions.containsKey( key ) )\n        {\n            Artifact artifact = (Artifact) managedVersions.get( key );\n\n            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );\n\n            if ( artifact.getVersion() != null )\n            {\n                node.getArtifact().setVersion( artifact.getVersion() );\n            }\n            if ( artifact.getScope() != null )\n            {\n                node.getArtifact().setScope( artifact.getScope() );\n            }\n        }\n\n        ResolutionNode previous = (ResolutionNode) resolvedArtifacts.get( key );\n        if ( previous != null )\n        {\n            // TODO: use as conflict resolver(s), chain and introduce version mediation\n\n            // previous one is more dominant\n            if ( previous.getDepth() <= node.getDepth() )\n            {\n                checkScopeUpdate( node, previous, artifactFactory, listeners );\n            }\n            else\n            {\n                checkScopeUpdate( previous, node, artifactFactory, listeners );\n            }\n\n            if ( previous.getDepth() <= node.getDepth() )\n            {\n                fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, node, previous.getArtifact() );\n                return;\n            }\n        }\n\n        resolvedArtifacts.put( key, node );\n\n        fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );\n\n        fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );\n\n        for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )\n        {\n            ResolutionNode child = (ResolutionNode) i.next();\n            if ( !child.isResolved() )\n            {\n                try\n                {\n                    Set artifacts = source.retrieve( child.getArtifact(), localRepository, remoteRepositories );\n                    child.addDependencies( artifacts, filter );\n                }\n                catch ( CyclicDependencyException e )\n                {\n                    // would like to throw this, but we have crappy stuff in the repo\n                    // no logger to use here either just now\n                    fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,\n                               new ResolutionNode( e.getArtifact(), child ) );\n                }\n                catch ( ArtifactMetadataRetrievalException e )\n                {\n                    child.getArtifact().setDependencyTrail( node.getDependencyTrail() );\n                    throw new TransitiveArtifactResolutionException( e.getMessage(), child.getArtifact(),\n                                                                     remoteRepositories, e );\n                }\n\n                recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter,\n                         artifactFactory, listeners );\n            }\n        }\n\n        fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );\n    }","id":29333,"modified_method":"private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,\n                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,\n                          ArtifactFilter filter, ArtifactFactory artifactFactory, List listeners )\n        throws CyclicDependencyException, TransitiveArtifactResolutionException\n    {\n        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );\n\n        // TODO: conflict resolvers, shouldn't be munging original artifact perhaps?\n        Object key = node.getKey();\n        if ( managedVersions.containsKey( key ) )\n        {\n            Artifact artifact = (Artifact) managedVersions.get( key );\n\n            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );\n\n            if ( artifact.getVersion() != null )\n            {\n                node.getArtifact().setVersion( artifact.getVersion() );\n            }\n            if ( artifact.getScope() != null )\n            {\n                node.getArtifact().setScope( artifact.getScope() );\n            }\n        }\n\n        ResolutionNode previous = (ResolutionNode) resolvedArtifacts.get( key );\n        if ( previous != null )\n        {\n            // TODO: use as conflict resolver(s), chain and introduce version mediation\n\n            // previous one is more dominant\n            if ( previous.getDepth() <= node.getDepth() )\n            {\n                checkScopeUpdate( node, previous, artifactFactory, listeners );\n            }\n            else\n            {\n                checkScopeUpdate( previous, node, artifactFactory, listeners );\n            }\n\n            if ( previous.getDepth() <= node.getDepth() )\n            {\n                fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, node, previous.getArtifact() );\n                return;\n            }\n        }\n\n        resolvedArtifacts.put( key, node );\n\n        fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );\n\n        fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );\n\n        for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )\n        {\n            ResolutionNode child = (ResolutionNode) i.next();\n            if ( !child.isResolved() )\n            {\n                try\n                {\n                    ResolutionGroup rGroup = source.retrieve( child.getArtifact(), localRepository, remoteRepositories );\n                    child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );\n                }\n                catch ( CyclicDependencyException e )\n                {\n                    // would like to throw this, but we have crappy stuff in the repo\n                    // no logger to use here either just now\n                    \n                    // TODO: should the remoteRepositories list be null here?!\n                    fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,\n                               new ResolutionNode( e.getArtifact(), null, child ) );\n                }\n                catch ( ArtifactMetadataRetrievalException e )\n                {\n                    child.getArtifact().setDependencyTrail( node.getDependencyTrail() );\n                    throw new TransitiveArtifactResolutionException( e.getMessage(), child.getArtifact(),\n                                                                     remoteRepositories, e );\n                }\n\n                recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter,\n                         artifactFactory, listeners );\n            }\n        }\n\n        fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"public ArtifactResolutionResult collect( Set artifacts, Artifact originatingArtifact, Map managedVersions,\n                                             ArtifactRepository localRepository, List remoteRepositories,\n                                             ArtifactMetadataSource source, ArtifactFilter filter,\n                                             ArtifactFactory artifactFactory, List listeners )\n        throws ArtifactResolutionException\n    {\n        Map resolvedArtifacts = new HashMap();\n\n        ResolutionNode root = new ResolutionNode( originatingArtifact );\n        root.addDependencies( artifacts, filter );\n\n        recurse( root, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter,\n                 artifactFactory, listeners );\n\n        Set set = new HashSet();\n\n        for ( Iterator i = resolvedArtifacts.values().iterator(); i.hasNext(); )\n        {\n            ResolutionNode node = (ResolutionNode) i.next();\n            if ( node != root )\n            {\n                Artifact artifact = node.getArtifact();\n\n                artifact.setDependencyTrail( node.getDependencyTrail() );\n\n                set.add( artifact );\n            }\n        }\n\n        ArtifactResolutionResult result = new ArtifactResolutionResult();\n\n        result.setArtifacts( set );\n\n        return result;\n    }","id":29334,"modified_method":"public ArtifactResolutionResult collect( Set artifacts, Artifact originatingArtifact, Map managedVersions,\n                                             ArtifactRepository localRepository, List remoteRepositories,\n                                             ArtifactMetadataSource source, ArtifactFilter filter,\n                                             ArtifactFactory artifactFactory, List listeners )\n        throws ArtifactResolutionException\n    {\n        Map resolvedArtifacts = new HashMap();\n\n        ResolutionNode root = new ResolutionNode( originatingArtifact, remoteRepositories );\n        root.addDependencies( artifacts, remoteRepositories, filter );\n\n        recurse( root, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter,\n                 artifactFactory, listeners );\n\n        Set set = new HashSet();\n\n        for ( Iterator i = resolvedArtifacts.values().iterator(); i.hasNext(); )\n        {\n            ResolutionNode node = (ResolutionNode) i.next();\n            if ( node != root )\n            {\n                Artifact artifact = node.getArtifact();\n\n                artifact.setDependencyTrail( node.getDependencyTrail() );\n\n                set.add( node );\n            }\n        }\n\n        ArtifactResolutionResult result = new ArtifactResolutionResult();\n\n        result.setArtifactResolutionNodes( set );\n\n        return result;\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"public Set retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n            throws ArtifactMetadataRetrievalException\n        {\n            ArtifactSpec a = (ArtifactSpec) artifacts.get( artifact.getId() );\n            return createArtifacts( artifactFactory, a.dependencies, artifact.getScope(),\n                                    artifact.getDependencyFilter() );\n        }","id":29335,"modified_method":"public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n            throws ArtifactMetadataRetrievalException\n        {\n            ArtifactSpec a = (ArtifactSpec) artifacts.get( artifact.getId() );\n            return new ResolutionGroup( createArtifacts( artifactFactory, a.dependencies, artifact.getScope(),\n                                    artifact.getDependencyFilter() ), Collections.EMPTY_LIST );\n        }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"private ArtifactResolutionResult resolveTransitively( Set artifacts, Artifact originatingArtifact,\n                                                          Map managedVersions, ArtifactRepository localRepository,\n                                                          List remoteRepositories, ArtifactMetadataSource source,\n                                                          ArtifactFilter filter, List listeners )\n        throws ArtifactResolutionException\n    {\n        ArtifactResolutionResult artifactResolutionResult;\n        artifactResolutionResult = artifactCollector.collect( artifacts, originatingArtifact, managedVersions,\n                                                              localRepository, remoteRepositories, source, filter,\n                                                              artifactFactory, listeners );\n\n        for ( Iterator i = artifactResolutionResult.getArtifacts().iterator(); i.hasNext(); )\n        {\n            Artifact artifact = (Artifact) i.next();\n            resolve( artifact, remoteRepositories, localRepository );\n        }\n\n        return artifactResolutionResult;\n    }","id":29336,"modified_method":"private ArtifactResolutionResult resolveTransitively( Set artifacts, Artifact originatingArtifact,\n                                                          Map managedVersions, ArtifactRepository localRepository,\n                                                          List remoteRepositories, ArtifactMetadataSource source,\n                                                          ArtifactFilter filter, List listeners )\n        throws ArtifactResolutionException\n    {\n        ArtifactResolutionResult artifactResolutionResult;\n        artifactResolutionResult = artifactCollector.collect( artifacts, originatingArtifact, managedVersions,\n                                                              localRepository, remoteRepositories, source, filter,\n                                                              artifactFactory, listeners );\n\n        for ( Iterator i = artifactResolutionResult.getArtifactResolutionNodes().iterator(); i.hasNext(); )\n        {\n            ResolutionNode node = (ResolutionNode) i.next();\n            resolve( node.getArtifact(), node.getRemoteRepositories(), localRepository );\n        }\n\n        return artifactResolutionResult;\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"private void ensurePluginContainerIsComplete( PluginDescriptor pluginDescriptor, PlexusContainer pluginContainer,\n                                                  MavenProject project, MavenSession session )\n        throws PluginConfigurationException\n    {\n        // if the plugin's already been used once, don't re-do this step...\n        // otherwise, we have to finish resolving the plugin's classpath and start the container.\n        if ( pluginDescriptor.getArtifacts() != null && pluginDescriptor.getArtifacts().size() == 1 )\n        {\n            // TODO: this is a little shady...\n            Artifact pluginArtifact = (Artifact) pluginDescriptor.getArtifacts().get( 0 );\n\n            try\n            {\n                MavenMetadataSource metadataSource = new MavenMetadataSource( artifactResolver, mavenProjectBuilder,\n                                                                              artifactFactory );\n    \n                List remoteRepositories = new ArrayList();\n                \n                remoteRepositories.addAll( project.getRemoteArtifactRepositories() );\n                remoteRepositories.addAll( project.getPluginArtifactRepositories() );\n                \n                ArtifactRepository localRepository = session.getLocalRepository();\n                Set dependencies = metadataSource.retrieve( pluginArtifact, localRepository,\n                                                            project.getPluginArtifactRepositories() );\n    \n                ArtifactResolutionResult result = artifactResolver.resolveTransitively( dependencies, pluginArtifact,\n                                                                                        localRepository,\n                                                                                        remoteRepositories,\n                                                                                        metadataSource,\n                                                                                        artifactFilter );\n    \n                Set resolved = result.getArtifacts();\n    \n                for ( Iterator it = resolved.iterator(); it.hasNext(); )\n                {\n                    Artifact artifact = (Artifact) it.next();\n    \n                    if ( artifact != pluginArtifact )\n                    {\n                        pluginContainer.addJarResource( artifact.getFile() );\n                    }\n                }\n    \n                pluginDescriptor.setClassRealm( pluginContainer.getContainerRealm() );\n    \n                // TODO: this is probably overkill as it is rarely used - can we use a mojo tag to signal this will be\n                // used or check its configuration? Also, when it is used, perhaps it is more effecient to resolve\n                // everything at once and apply the exclusion filter when constructing the plugin container above.\n                // Check this out with yourkit\n                ArtifactFilter distroProvidedFilter = new InversionArtifactFilter( artifactFilter );\n    \n                ArtifactResolutionResult distroProvidedResult = artifactResolver\n                    .resolveTransitively( dependencies, pluginArtifact, localRepository, remoteRepositories,\n                                          metadataSource, distroProvidedFilter );\n    \n                Set distroProvided = distroProvidedResult.getArtifacts();\n    \n                List unfilteredArtifactList = new ArrayList( resolved.size() + distroProvided.size() );\n    \n                unfilteredArtifactList.addAll( resolved );\n                unfilteredArtifactList.addAll( distroProvided );\n    \n                pluginDescriptor.setArtifacts( unfilteredArtifactList );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new PluginConfigurationException( \"Cannot resolve plugin dependencies\", e );\n            }\n            catch ( PlexusContainerException e )\n            {\n                throw new PluginConfigurationException( \"Cannot start plugin container\", e );\n            }\n            catch ( ArtifactMetadataRetrievalException e )\n            {\n                throw new PluginConfigurationException( \"Cannot resolve plugin dependencies\", e );\n            }\n        }\n    }","id":29337,"modified_method":"private void ensurePluginContainerIsComplete( PluginDescriptor pluginDescriptor, PlexusContainer pluginContainer,\n                                                  MavenProject project, MavenSession session )\n        throws PluginConfigurationException\n    {\n        // if the plugin's already been used once, don't re-do this step...\n        // otherwise, we have to finish resolving the plugin's classpath and start the container.\n        if ( pluginDescriptor.getArtifacts() != null && pluginDescriptor.getArtifacts().size() == 1 )\n        {\n            // TODO: this is a little shady...\n            Artifact pluginArtifact = (Artifact) pluginDescriptor.getArtifacts().get( 0 );\n\n            try\n            {\n                MavenMetadataSource metadataSource = new MavenMetadataSource( artifactResolver, mavenProjectBuilder,\n                                                                              artifactFactory );\n    \n                List remoteRepositories = new ArrayList();\n                \n                remoteRepositories.addAll( project.getRemoteArtifactRepositories() );\n                remoteRepositories.addAll( project.getPluginArtifactRepositories() );\n                \n                ArtifactRepository localRepository = session.getLocalRepository();\n                \n                ResolutionGroup resolutionGroup = metadataSource.retrieve( pluginArtifact, localRepository,\n                                                            project.getPluginArtifactRepositories() );\n                \n                Set dependencies = resolutionGroup.getArtifacts();\n    \n                ArtifactResolutionResult result = artifactResolver.resolveTransitively( dependencies, pluginArtifact,\n                                                                                        localRepository,\n                                                                                        remoteRepositories,\n                                                                                        metadataSource,\n                                                                                        artifactFilter );\n    \n                Set resolved = result.getArtifacts();\n    \n                for ( Iterator it = resolved.iterator(); it.hasNext(); )\n                {\n                    Artifact artifact = (Artifact) it.next();\n    \n                    if ( artifact != pluginArtifact )\n                    {\n                        pluginContainer.addJarResource( artifact.getFile() );\n                    }\n                }\n    \n                pluginDescriptor.setClassRealm( pluginContainer.getContainerRealm() );\n    \n                // TODO: this is probably overkill as it is rarely used - can we use a mojo tag to signal this will be\n                // used or check its configuration? Also, when it is used, perhaps it is more effecient to resolve\n                // everything at once and apply the exclusion filter when constructing the plugin container above.\n                // Check this out with yourkit\n                ArtifactFilter distroProvidedFilter = new InversionArtifactFilter( artifactFilter );\n    \n                ArtifactResolutionResult distroProvidedResult = artifactResolver\n                    .resolveTransitively( dependencies, pluginArtifact, localRepository, remoteRepositories,\n                                          metadataSource, distroProvidedFilter );\n    \n                Set distroProvided = distroProvidedResult.getArtifacts();\n    \n                List unfilteredArtifactList = new ArrayList( resolved.size() + distroProvided.size() );\n    \n                unfilteredArtifactList.addAll( resolved );\n                unfilteredArtifactList.addAll( distroProvided );\n    \n                pluginDescriptor.setArtifacts( unfilteredArtifactList );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new PluginConfigurationException( \"Cannot resolve plugin dependencies\", e );\n            }\n            catch ( PlexusContainerException e )\n            {\n                throw new PluginConfigurationException( \"Cannot start plugin container\", e );\n            }\n            catch ( ArtifactMetadataRetrievalException e )\n            {\n                throw new PluginConfigurationException( \"Cannot resolve plugin dependencies\", e );\n            }\n        }\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"public Set retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n        throws ArtifactMetadataRetrievalException\n    {\n        // TODO: only metadata is really needed - resolve as metadata\n        Artifact pomArtifact = artifactFactory.createArtifact( artifact.getGroupId(), artifact.getArtifactId(),\n                                                               artifact.getVersion(), artifact.getScope(), \"pom\" );\n\n        // TODO: this a very thin wrapper around a project builder - is it needed?\n        List dependencies = null;\n\n        // Use the ProjectBuilder, to enable post-processing and inheritance calculation before retrieving the\n        // associated artifacts.\n        try\n        {\n            MavenProject p = mavenProjectBuilder.buildFromRepository( pomArtifact, remoteRepositories,\n                                                                      localRepository );\n            dependencies = p.getDependencies();\n            artifact.setDownloadUrl( pomArtifact.getDownloadUrl() );\n        }\n        catch ( ProjectBuildingException e )\n        {\n            throw new ArtifactMetadataRetrievalException( \"Unable to read the metadata file\", e );\n        }\n        return createArtifacts( artifactFactory, dependencies, artifact.getScope(), artifact.getDependencyFilter() );\n    }","id":29338,"modified_method":"public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n        throws ArtifactMetadataRetrievalException\n    {\n        // TODO: only metadata is really needed - resolve as metadata\n        Artifact pomArtifact = artifactFactory.createArtifact( artifact.getGroupId(), artifact.getArtifactId(),\n                                                               artifact.getVersion(), artifact.getScope(), \"pom\" );\n\n        // TODO: this a very thin wrapper around a project builder - is it needed?\n        List dependencies = null;\n\n        // Use the ProjectBuilder, to enable post-processing and inheritance calculation before retrieving the\n        // associated artifacts.\n        try\n        {\n            MavenProject p = mavenProjectBuilder.buildFromRepository( pomArtifact, remoteRepositories,\n                                                                      localRepository );\n            dependencies = p.getDependencies();\n            artifact.setDownloadUrl( pomArtifact.getDownloadUrl() );\n            \n            Set artifacts = createArtifacts( artifactFactory, dependencies, artifact.getScope(), artifact.getDependencyFilter() );\n            \n            return new ResolutionGroup( artifacts, p.getRemoteArtifactRepositories() );\n        }\n        catch ( ProjectBuildingException e )\n        {\n            throw new ArtifactMetadataRetrievalException( \"Unable to read the metadata file\", e );\n        }\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"public MavenMetadataSource( ArtifactResolver artifactResolver, MavenProjectBuilder projectBuilder,\n                                ArtifactFactory artifactFactory )\n    {\n        this.artifactResolver = artifactResolver;\n        this.mavenProjectBuilder = projectBuilder;\n        this.artifactFactory = artifactFactory;\n    }","id":29339,"modified_method":"public MavenMetadataSource( ArtifactResolver artifactResolver, MavenProjectBuilder projectBuilder,\n                                ArtifactFactory artifactFactory )\n    {\n        this.mavenProjectBuilder = projectBuilder;\n        this.artifactFactory = artifactFactory;\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        projectBuilder = (MavenProjectBuilder) lookup( MavenProjectBuilder.ROLE );\n        artifactFactory = (ArtifactFactory) lookup( ArtifactFactory.ROLE );\n    }","id":29340,"modified_method":"protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        projectBuilder = (MavenProjectBuilder) lookup( MavenProjectBuilder.ROLE );\n        artifactFactory = (ArtifactFactory) lookup( ArtifactFactory.ROLE );\n        artifactRepositoryFactory = (ArtifactRepositoryFactory) lookup( ArtifactRepositoryFactory.ROLE );\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"protected MavenProject getProjectWithDependencies( File pom )\n        throws Exception\n    {\n        return projectBuilder.buildWithDependencies( pom, getLocalRepository(),\n                                                     new ProjectClasspathArtifactResolver.Source( artifactFactory ),\n                                                     Collections.EMPTY_LIST );\n    }","id":29341,"modified_method":"protected MavenProject getProjectWithDependencies( File pom )\n        throws Exception\n    {\n        return projectBuilder.buildWithDependencies( pom, getLocalRepository(),\n                                                     new ProjectClasspathArtifactResolver.Source( artifactFactory, artifactRepositoryFactory, getContainer() ),\n                                                     Collections.EMPTY_LIST );\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"public Set retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n            throws ArtifactMetadataRetrievalException\n        {\n            Model model = null;\n            InputStreamReader r = null;\n            try\n            {\n                String scope = artifact.getArtifactId().substring( \"scope-\".length() );\n                if ( artifact.getGroupId().equals( \"maven-test\" ) )\n                {\n                    String name = \"/projects/scope/transitive-\" + scope + \"-dep.xml\";\n                    r = new InputStreamReader( getClass().getResourceAsStream( name ) );\n                    MavenXpp3Reader reader = new MavenXpp3Reader();\n                    model = reader.read( r );\n                }\n                else\n                {\n                    model = new Model();\n                }\n                model.setGroupId( artifact.getGroupId() );\n                model.setArtifactId( artifact.getArtifactId() );\n            }\n            catch ( IOException e )\n            {\n                throw new ArtifactMetadataRetrievalException( e );\n            }\n            catch ( XmlPullParserException e )\n            {\n                throw new ArtifactMetadataRetrievalException( e );\n            }\n            finally\n            {\n                IOUtil.close( r );\n            }\n            return createArtifacts( model.getDependencies(), artifact.getScope() );\n        }","id":29342,"modified_method":"public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n            throws ArtifactMetadataRetrievalException\n        {\n            Model model = null;\n            InputStreamReader r = null;\n            try\n            {\n                String scope = artifact.getArtifactId().substring( \"scope-\".length() );\n                if ( artifact.getGroupId().equals( \"maven-test\" ) )\n                {\n                    String name = \"/projects/scope/transitive-\" + scope + \"-dep.xml\";\n                    r = new InputStreamReader( getClass().getResourceAsStream( name ) );\n                    MavenXpp3Reader reader = new MavenXpp3Reader();\n                    model = reader.read( r );\n                }\n                else\n                {\n                    model = new Model();\n                }\n                model.setGroupId( artifact.getGroupId() );\n                model.setArtifactId( artifact.getArtifactId() );\n            }\n            catch ( IOException e )\n            {\n                throw new ArtifactMetadataRetrievalException( e );\n            }\n            catch ( XmlPullParserException e )\n            {\n                throw new ArtifactMetadataRetrievalException( e );\n            }\n            finally\n            {\n                IOUtil.close( r );\n            }\n            \n            Set artifacts = createArtifacts( model.getDependencies(), artifact.getScope() );\n            \n            List artifactRepositories;\n            try\n            {\n                artifactRepositories = ProjectUtils.buildArtifactRepositories( model.getRepositories(), repositoryFactory, container );\n            }\n            catch ( ProjectBuildingException e )\n            {\n                throw new ArtifactMetadataRetrievalException( e );\n            }\n            \n            return new ResolutionGroup( artifacts, artifactRepositories );\n        }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"public ArtifactResolutionResult resolveTransitively( Set artifacts, Artifact originatingArtifact,\n                                                         List remoteRepositories, ArtifactRepository localRepository,\n                                                         ArtifactMetadataSource source )\n        throws ArtifactResolutionException\n    {\n        return super.resolveTransitively( artifacts, originatingArtifact, remoteRepositories, localRepository,\n                                          new Source( artifactFactory ) );\n    }","id":29343,"modified_method":"public ArtifactResolutionResult resolveTransitively( Set artifacts, Artifact originatingArtifact,\n                                                         List remoteRepositories, ArtifactRepository localRepository,\n                                                         ArtifactMetadataSource source )\n        throws ArtifactResolutionException\n    {\n        return super.resolveTransitively( artifacts, originatingArtifact, remoteRepositories, localRepository,\n                                          new Source( artifactFactory, repositoryFactory, container ) );\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"public ArtifactResolutionResult resolveTransitively( Set artifacts, Artifact originatingArtifact,\n                                                         ArtifactRepository localRepository, List remoteRepositories,\n                                                         ArtifactMetadataSource source, ArtifactFilter filter )\n        throws ArtifactResolutionException\n    {\n        return super.resolveTransitively( artifacts, originatingArtifact, localRepository, remoteRepositories,\n                                          new Source( artifactFactory ), filter );\n    }","id":29344,"modified_method":"public ArtifactResolutionResult resolveTransitively( Set artifacts, Artifact originatingArtifact,\n                                                         ArtifactRepository localRepository, List remoteRepositories,\n                                                         ArtifactMetadataSource source, ArtifactFilter filter )\n        throws ArtifactResolutionException\n    {\n        return super.resolveTransitively( artifacts, originatingArtifact, localRepository, remoteRepositories,\n                                          new Source( artifactFactory, repositoryFactory, container ), filter );\n    }","commit_id":"c7d5e83520949f2577db6ad37e63c27cb10f4ae3","url":"https://github.com/apache/maven"},{"original_method":"public static boolean contains(\n\t\tPermissionChecker permissionChecker, WikiPage page, String actionId) {\n\n\t\tif (actionId.equals(ActionKeys.VIEW)) {\n\t\t\tWikiPage redirectPage = page.getRedirectPage();\n\n\t\t\tif (redirectPage != null) {\n\t\t\t\tpage = redirectPage;\n\t\t\t}\n\t\t}\n\n\t\tWikiNode node = page.getNode();\n\n\t\tif (PropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\t\t\tWikiPage originalPage = page;\n\n\t\t\tif (!WikiNodePermission.contains(\n\t\t\t\t\tpermissionChecker, node, ActionKeys.VIEW)) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\twhile (page != null) {\n\t\t\t\tif (page.isPending()) {\n\t\t\t\t\tBoolean hasPermission =\n\t\t\t\t\t\tWorkflowPermissionUtil.hasPermission(\n\t\t\t\t\t\t\tpermissionChecker, page.getGroupId(),\n\t\t\t\t\t\t\tWikiPage.class.getName(), page.getResourcePrimKey(),\n\t\t\t\t\t\t\tactionId);\n\n\t\t\t\t\tif (hasPermission != null) {\n\t\t\t\t\t\treturn hasPermission.booleanValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (page.isDraft() && actionId.equals(ActionKeys.DELETE) &&\n\t\t\t\t\t(page.getStatusByUserId() ==\n\t\t\t\t\t\tpermissionChecker.getUserId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (!permissionChecker.hasOwnerPermission(\n\t\t\t\t\t\tpage.getCompanyId(), WikiPage.class.getName(),\n\t\t\t\t\t\tpage.getPageId(), page.getUserId(), ActionKeys.VIEW) &&\n\t\t\t\t\t!permissionChecker.hasPermission(\n\t\t\t\t\t\tpage.getGroupId(), WikiPage.class.getName(),\n\t\t\t\t\t\tpage.getPageId(), ActionKeys.VIEW)) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tpage = page.getParentPage();\n\t\t\t}\n\n\t\t\tif (actionId.equals(ActionKeys.VIEW)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpage = originalPage;\n\t\t}\n\n\t\tif (WikiNodePermission.contains(permissionChecker, node, actionId)) {\n\t\t\t\treturn true;\n\t\t}\n\n\t\twhile (page != null) {\n\t\t\tif (page.isPending()) {\n\t\t\t\tBoolean hasPermission =\n\t\t\t\t\tWorkflowPermissionUtil.hasPermission(\n\t\t\t\t\t\tpermissionChecker, page.getGroupId(),\n\t\t\t\t\t\tWikiPage.class.getName(), page.getResourcePrimKey(),\n\t\t\t\t\t\tactionId);\n\n\t\t\t\tif (hasPermission != null) {\n\t\t\t\t\treturn hasPermission.booleanValue();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (page.isDraft() && actionId.equals(ActionKeys.DELETE) &&\n\t\t\t\t(page.getStatusByUserId() == permissionChecker.getUserId())) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (permissionChecker.hasOwnerPermission(\n\t\t\t\t\tpage.getCompanyId(), WikiPage.class.getName(),\n\t\t\t\t\tpage.getPageId(), page.getUserId(), actionId) ||\n\t\t\t\tpermissionChecker.hasPermission(\n\t\t\t\t\tpage.getGroupId(), WikiPage.class.getName(),\n\t\t\t\t\tpage.getPageId(), actionId)) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpage = page.getParentPage();\n\t\t}\n\n\t\treturn false;\n\t}","id":29345,"modified_method":"public static boolean contains(\n\t\tPermissionChecker permissionChecker, WikiPage page, String actionId) {\n\n\t\tif (actionId.equals(ActionKeys.VIEW)) {\n\t\t\tWikiPage redirectPage = page.getRedirectPage();\n\n\t\t\tif (redirectPage != null) {\n\t\t\t\tpage = redirectPage;\n\t\t\t}\n\t\t}\n\n\t\tWikiNode node = page.getNode();\n\n\t\tif (PropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\t\t\tWikiPage originalPage = page;\n\n\t\t\tif (!WikiNodePermission.contains(\n\t\t\t\t\tpermissionChecker, node, ActionKeys.VIEW)) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\twhile (page != null) {\n\t\t\t\tif (!permissionChecker.hasOwnerPermission(\n\t\t\t\t\t\tpage.getCompanyId(), WikiPage.class.getName(),\n\t\t\t\t\t\tpage.getPageId(), page.getUserId(), ActionKeys.VIEW) &&\n\t\t\t\t\t!permissionChecker.hasPermission(\n\t\t\t\t\t\tpage.getGroupId(), WikiPage.class.getName(),\n\t\t\t\t\t\tpage.getPageId(), ActionKeys.VIEW)) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tpage = page.getParentPage();\n\t\t\t}\n\n\t\t\tif (actionId.equals(ActionKeys.VIEW)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpage = originalPage;\n\t\t}\n\n\t\tif (WikiNodePermission.contains(permissionChecker, node, actionId)) {\n\t\t\treturn true;\n\t\t}\n\n\t\twhile (page != null) {\n\t\t\tif (page.isPending()) {\n\t\t\t\tBoolean hasPermission =\n\t\t\t\t\tWorkflowPermissionUtil.hasPermission(\n\t\t\t\t\t\tpermissionChecker, page.getGroupId(),\n\t\t\t\t\t\tWikiPage.class.getName(), page.getResourcePrimKey(),\n\t\t\t\t\t\tactionId);\n\n\t\t\t\tif ((hasPermission != null) && hasPermission.booleanValue()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (page.isDraft() && actionId.equals(ActionKeys.DELETE) &&\n\t\t\t\t(page.getStatusByUserId() == permissionChecker.getUserId())) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (permissionChecker.hasOwnerPermission(\n\t\t\t\t\tpage.getCompanyId(), WikiPage.class.getName(),\n\t\t\t\t\tpage.getPageId(), page.getUserId(), actionId) ||\n\t\t\t\tpermissionChecker.hasPermission(\n\t\t\t\t\tpage.getGroupId(), WikiPage.class.getName(),\n\t\t\t\t\tpage.getPageId(), actionId)) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpage = page.getParentPage();\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"b599ed4b3025cca289485ab000cf624d75764b48","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void onEvent(final Event e) {\n        LOG.debug(\"onEvent: Waiting to process event: {} uei: {}, dbid: {}\", e, e.getUei(), e.getDbid());\n        synchronized (m_pendingPollEvents) {\n            LOG.debug(\"onEvent: Received event: {} uei: {}, dbid: {}, pendingEventCount: {}\", e, e.getUei(), e.getDbid(), m_pendingPollEvents.size());\n            for (final Iterator<PendingPollEvent> it = m_pendingPollEvents.iterator(); it.hasNext();) {\n                final PendingPollEvent pollEvent = it.next();\n                LOG.trace(\"onEvent: comparing events to poll event: {}\", pollEvent);\n                if (e.equals(pollEvent.getEvent())) {\n                    LOG.trace(\"onEvent: completing pollevent: {}\", pollEvent);\n                    pollEvent.complete(e);\n                }\n            }\n\n            for (Iterator<PendingPollEvent> it = m_pendingPollEvents.iterator(); it.hasNext(); ) {\n                PendingPollEvent pollEvent = it.next();\n                LOG.trace(\"onEvent: determining if pollEvent is pending: {}\", pollEvent);\n                if (pollEvent.isPending()) continue;\n\n                LOG.trace(\"onEvent: processing pending pollEvent...: {}\", pollEvent);\n                pollEvent.processPending();\n                it.remove();\n                LOG.trace(\"onEvent: processing of pollEvent completed.: {}\", pollEvent);\n            }\n        }\n        LOG.debug(\"onEvent: Finished processing event: {} uei: {}, dbid: {}\", e, e.getUei(), e.getDbid());\n        \n    }","id":29346,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void onEvent(final Event event) {\n        if (LOG.isDebugEnabled()) {\n            // CAUTION: m_pendingPollEvents.size() is not a constant-time operation\n            LOG.debug(\"onEvent: Received event: {} uei: {}, dbid: {}, pendingEventCount: {}\", event, event.getUei(), event.getDbid(), m_pendingPollEvents.size());\n        }\n\n        for (final PendingPollEvent pollEvent : m_pendingPollEvents) {\n            LOG.trace(\"onEvent: comparing event to pollEvent: {}\", pollEvent);\n            // TODO: This equals comparison is more like a '==' operation because\n            // I think that both events would have to be identical instances to\n            // have the same event ID. This will probably cause problems if we\n            // cluster event processing and the event instances are ever not \n            // identical.\n            if (event.equals(pollEvent.getEvent())) {\n                LOG.trace(\"onEvent: found matching pollEvent, completing pollEvent: {}\", pollEvent);\n                // Thread-safe and idempotent\n                pollEvent.complete(event);\n                // TODO: Can we break here? I think there should only be one \n                // instance of any given event in m_pendingPollEvents\n                // break;\n            }\n        }\n\n        for (final Iterator<PendingPollEvent> it = m_pendingPollEvents.iterator(); it.hasNext();) {\n            final PendingPollEvent pollEvent = it.next();\n            LOG.trace(\"onEvent: determining if pollEvent is pending: {}\", pollEvent);\n            if (!pollEvent.isPending()) {\n                try {\n                    // Thread-safe and idempotent\n                    processPending(pollEvent);\n                } catch (Throwable e) {\n                    LOG.error(\"Unexpected exception while processing pollEvent: \" + pollEvent, e);\n                }\n                // TODO: Should we remove the task before processing it? This would\n                // reduce the chances that two threads could process the same event\n                // simultaneously, although since the call is now thread-safe and\n                // idempotent, that's not really a problem.\n                it.remove();\n                continue;\n            }\n\n            // If the event was not completed and it is still pending, then don't do anything to it\n        }\n        LOG.debug(\"onEvent: Finished processing event: {} uei: {}, dbid: {}\", event, event.getUei(), event.getDbid());\n    }","commit_id":"6d209c31d4621f92cc3bf1e463e96eb0cf8e3741","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public PollEvent sendEvent(Event event) {\n        if (!m_listenerAdded) {\n            getEventManager().addEventListener(this, Arrays.asList(UEIS));\n            m_listenerAdded = true;\n        }\n        PendingPollEvent pollEvent = new PendingPollEvent(event);\n        synchronized (m_pendingPollEvents) {\n            m_pendingPollEvents.add(pollEvent);\n        }\n        //log().info(\"Sending \"+event.getUei()+\" for element \"+event.getNodeid()+\":\"+event.getInterface()+\":\"+event.getService(), new Exception(\"StackTrace\"));\n        getEventManager().sendNow(event);\n        return pollEvent;\n    }","id":29347,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public PollEvent sendEvent(Event event) {\n        if (!m_listenerAdded) {\n            getEventManager().addEventListener(this, Arrays.asList(UEIS));\n            m_listenerAdded = true;\n        }\n        PendingPollEvent pollEvent = new PendingPollEvent(event);\n        m_pendingPollEvents.add(pollEvent);\n\n        //log().info(\"Sending \"+event.getUei()+\" for element \"+event.getNodeid()+\":\"+event.getInterface()+\":\"+event.getService(), new Exception(\"StackTrace\"));\n        getEventManager().sendNow(event);\n        return pollEvent;\n    }","commit_id":"6d209c31d4621f92cc3bf1e463e96eb0cf8e3741","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>addPending<\/p>\n     *\n     * @param r a {@link java.lang.Runnable} object.\n     */\n    public synchronized void addPending(Runnable r) {\n        if (m_pending) {\n            m_pendingOutages.add(r);\n        }\n        else {\n            r.run();\n        }\n    }","id":29348,"modified_method":"/**\n     * <p>addPending<\/p>\n     *\n     * @param r a {@link java.lang.Runnable} object.\n     */\n    public void addPending(Runnable r) {\n        if (m_pending.get()) {\n            m_pendingOutages.add(r);\n        } else {\n            r.run();\n        }\n    }","commit_id":"6d209c31d4621f92cc3bf1e463e96eb0cf8e3741","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>complete<\/p>\n     *\n     * @param e a {@link org.opennms.netmgt.xml.event.Event} object.\n     */\n    public synchronized void complete(Event e) {\n        m_pending = false;\n    }","id":29349,"modified_method":"/**\n     * Changes the state of this event from \"pending\" to \"not pending\".\n     * It is important that this call be thread-safe and idempotent because\n     * it may be invoked by multiple {@link DefaultPollContext#onEvent(Event)}\n     * threads.\n     *\n     * @param e a {@link org.opennms.netmgt.xml.event.Event} object.\n     */\n    public void complete(Event e) {\n        m_pending.set(false);\n    }","commit_id":"6d209c31d4621f92cc3bf1e463e96eb0cf8e3741","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>isPending<\/p>\n     *\n     * @return a boolean.\n     */\n\n    public synchronized boolean isPending() {\n        if (m_pending) {\n            // still pending, check if we've timed out\n            if (isTimedOut()) {\n                m_pending = false;\n            }\n        }\n        return m_pending;\n    }","id":29350,"modified_method":"/**\n     * <p>isPending<\/p>\n     *\n     * @return a boolean.\n     */\n\n    public boolean isPending() {\n        if (m_pending.get()) {\n            // still pending, check if we've timed out\n            if (isTimedOut()) {\n                m_pending.set(false);\n            }\n        }\n        return m_pending.get();\n    }","commit_id":"6d209c31d4621f92cc3bf1e463e96eb0cf8e3741","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String toString() {\n        return m_event+\", uei: \"+m_event.getUei()+\", id: \"+m_event.getDbid()+\", isPending: \"+m_pending+\", list size: \"+m_pendingOutages.size();\n    }","id":29351,"modified_method":"public String toString() {\n        return m_event+\", uei: \"+m_event.getUei()+\", id: \"+m_event.getDbid()+\", isPending: \"+m_pending.get()+\", list size: \"+m_pendingOutages.size();\n    }","commit_id":"6d209c31d4621f92cc3bf1e463e96eb0cf8e3741","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>processPending<\/p>\n     */\n    public synchronized void processPending() {\n        for (Runnable r : m_pendingOutages) {\n            r.run();\n        }\n        m_pendingOutages.clear();\n        \n    }","id":29352,"modified_method":"/**\n     * Synchronously processes all pending tasks attached to this event.\n     * It is important that this call be thread-safe and idempotent because\n     * it may be invoked by multiple {@link DefaultPollContext#onEvent(Event)}\n     * threads.\n     *\n     * @param e a {@link org.opennms.netmgt.xml.event.Event} object.\n     */\n    public void processPending() {\n        while (!m_pendingOutages.isEmpty()) {\n            Runnable runnable = m_pendingOutages.poll();\n            if (runnable != null) {\n                runnable.run();\n            } else {\n                return;\n            }\n        }\n    }","commit_id":"6d209c31d4621f92cc3bf1e463e96eb0cf8e3741","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>getScope<\/p>\n     *\n     * @return a {@link org.opennms.netmgt.poller.pollables.Scope} object.\n     */\n    public Scope getScope() {\n        return m_scope;\n    }","id":29353,"modified_method":"/**\n     * <p>getScope<\/p>\n     *\n     * @return a {@link org.opennms.netmgt.poller.pollables.Scope} object.\n     */\n    public final Scope getScope() {\n        return m_scope;\n    }","commit_id":"6d209c31d4621f92cc3bf1e463e96eb0cf8e3741","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public BlogsEntry moveEntryToTrash(long userId, BlogsEntry entry)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Entry\n\n\t\tint oldStatus = entry.getStatus();\n\n\t\tupdateStatus(\n\t\t\tuserId, entry.getEntryId(), WorkflowConstants.STATUS_IN_TRASH,\n\t\t\tnew ServiceContext());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, entry.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tentry.getEntryId(), SocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\tStringPool.BLANK, 0);\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\tuserId, entry.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tentry.getEntryId(), oldStatus, null, null);\n\n\t\t// Workflow\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_PENDING) {\n\t\t\tWorkflowInstanceLink workflowInstanceLink =\n\t\t\t\tworkflowInstanceLinkLocalService.getWorkflowInstanceLink(\n\t\t\t\t\tentry.getCompanyId(), entry.getGroupId(),\n\t\t\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t\tWorkflowInstance workflowInstance =\n\t\t\t\tWorkflowInstanceManagerUtil.getWorkflowInstance(\n\t\t\t\t\tentry.getCompanyId(),\n\t\t\t\t\tworkflowInstanceLink.getWorkflowInstanceId());\n\n\t\t\tMap<String, Serializable> workflowContext =\n\t\t\t\tworkflowInstance.getWorkflowContext();\n\n\t\t\tServiceContext serviceContext = (ServiceContext)workflowContext.get(\n\t\t\t\tWorkflowConstants.CONTEXT_SERVICE_CONTEXT);\n\n\t\t\tboolean update = ParamUtil.getBoolean(serviceContext, \"update\");\n\n\t\t\tif (update) {\n\t\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT_FROM_APPROVED);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t\t}\n\n\t\t\tworkflowInstanceLinkLocalService.deleteWorkflowInstanceLink(\n\t\t\t\tworkflowInstanceLink.getWorkflowInstanceId());\n\t\t}\n\n\t\treturn entry;\n\t}","id":29354,"modified_method":"public BlogsEntry moveEntryToTrash(long userId, BlogsEntry entry)\n\t\tthrows PortalException, SystemException {\n\n\t\tint oldStatus = entry.getStatus();\n\n\t\t// Workflow\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_PENDING) {\n\t\t\tWorkflowInstanceLink workflowInstanceLink =\n\t\t\t\tworkflowInstanceLinkLocalService.getWorkflowInstanceLink(\n\t\t\t\t\tentry.getCompanyId(), entry.getGroupId(),\n\t\t\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t\tWorkflowInstance workflowInstance =\n\t\t\t\tWorkflowInstanceManagerUtil.getWorkflowInstance(\n\t\t\t\t\tentry.getCompanyId(),\n\t\t\t\t\tworkflowInstanceLink.getWorkflowInstanceId());\n\n\t\t\tMap<String, Serializable> workflowContext =\n\t\t\t\tworkflowInstance.getWorkflowContext();\n\n\t\t\tServiceContext serviceContext = (ServiceContext)workflowContext.get(\n\t\t\t\tWorkflowConstants.CONTEXT_SERVICE_CONTEXT);\n\n\t\t\tboolean update = ParamUtil.getBoolean(serviceContext, \"update\");\n\n\t\t\tif (update) {\n\t\t\t\toldStatus = WorkflowConstants.STATUS_DRAFT_FROM_APPROVED;\n\t\t\t}\n\t\t\telse {\n\t\t\t\toldStatus = WorkflowConstants.STATUS_DRAFT;\n\t\t\t}\n\n\t\t\tentry.setStatus(oldStatus);\n\n\t\t\tblogsEntryPersistence.update(entry, false);\n\n\t\t\tworkflowInstanceLinkLocalService.deleteWorkflowInstanceLink(\n\t\t\t\tworkflowInstanceLink.getWorkflowInstanceLinkId());\n\t\t}\n\n\t\tupdateStatus(\n\t\t\tuserId, entry.getEntryId(), WorkflowConstants.STATUS_IN_TRASH,\n\t\t\tnew ServiceContext());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, entry.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tentry.getEntryId(), SocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\tStringPool.BLANK, 0);\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\tuserId, entry.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tentry.getEntryId(), oldStatus, null, null);\n\n\t\treturn entry;\n\t}","commit_id":"e9df1e898325a4fde4c475b9302e2e17e33afd25","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public FileEntry moveFileEntryToTrash(long userId, FileEntry fileEntry)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tDLFileEntry dlFileEntry = (DLFileEntry)fileEntry.getModel();\n\n\t\tdlFileEntry.setTitle(\n\t\t\tDLAppUtil.appendTrashNamespace(dlFileEntry.getTitle()));\n\n\t\tdlFileEntryPersistence.update(dlFileEntry, false);\n\n\t\tList<DLFileVersion> dlFileVersions =\n\t\t\tdlFileVersionLocalService.getFileVersions(\n\t\t\t\tfileEntry.getFileEntryId(), WorkflowConstants.STATUS_ANY);\n\n\t\tdlFileVersions = ListUtil.copy(dlFileVersions);\n\n\t\tCollections.sort(dlFileVersions, new FileVersionVersionComparator());\n\n\t\tFileVersion fileVersion = new LiferayFileVersion(dlFileVersions.get(0));\n\n\t\tint oldStatus = fileVersion.getStatus();\n\n\t\t// File version\n\n\t\tdlFileEntryLocalService.updateStatus(\n\t\t\tuserId, fileVersion.getFileVersionId(),\n\t\t\tWorkflowConstants.STATUS_IN_TRASH,\n\t\t\tnew HashMap<String, Serializable>(), new ServiceContext());\n\n\t\t// File shortcut\n\n\t\tdlFileShortcutLocalService.disableFileShortcuts(\n\t\t\tfileEntry.getFileEntryId());\n\n\t\t// File rank\n\n\t\tdlFileRankLocalService.disableFileRanks(fileEntry.getFileEntryId());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, fileEntry.getGroupId(), DLFileEntryConstants.getClassName(),\n\t\t\tfileEntry.getFileEntryId(),\n\t\t\tSocialActivityConstants.TYPE_MOVE_TO_TRASH, StringPool.BLANK, 0);\n\n\t\t// Trash\n\n\t\tList<ObjectValuePair<Long, Integer>> fileVersionStatuses =\n\t\t\tnew ArrayList<ObjectValuePair<Long, Integer>>(\n\t\t\t\tdlFileVersions.size());\n\n\t\tfor (DLFileVersion dlFileVersion : dlFileVersions) {\n\t\t\tObjectValuePair<Long, Integer> fileVersionStatus =\n\t\t\t\tnew ObjectValuePair<Long, Integer>();\n\n\t\t\tfileVersionStatus.setKey(dlFileVersion.getFileVersionId());\n\t\t\tfileVersionStatus.setValue(dlFileVersion.getStatus());\n\n\t\t\tfileVersionStatuses.add(fileVersionStatus);\n\t\t}\n\n\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\tuserId, fileEntry.getGroupId(), DLFileEntryConstants.getClassName(),\n\t\t\tfileEntry.getFileEntryId(), oldStatus, fileVersionStatuses, null);\n\n\t\t// Workflow\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_PENDING) {\n\t\t\tworkflowInstanceLinkLocalService.deleteWorkflowInstanceLink(\n\t\t\t\tfileVersion.getCompanyId(), fileVersion.getGroupId(),\n\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\tfileVersion.getFileVersionId());\n\t\t}\n\n\t\treturn fileEntry;\n\t}","id":29355,"modified_method":"public FileEntry moveFileEntryToTrash(long userId, FileEntry fileEntry)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tDLFileEntry dlFileEntry = (DLFileEntry)fileEntry.getModel();\n\n\t\tdlFileEntry.setTitle(\n\t\t\tDLAppUtil.appendTrashNamespace(dlFileEntry.getTitle()));\n\n\t\tdlFileEntryPersistence.update(dlFileEntry, false);\n\n\t\tList<DLFileVersion> dlFileVersions =\n\t\t\tdlFileVersionLocalService.getFileVersions(\n\t\t\t\tfileEntry.getFileEntryId(), WorkflowConstants.STATUS_ANY);\n\n\t\tdlFileVersions = ListUtil.copy(dlFileVersions);\n\n\t\tCollections.sort(dlFileVersions, new FileVersionVersionComparator());\n\n\t\tFileVersion fileVersion = new LiferayFileVersion(dlFileVersions.get(0));\n\n\t\tint oldStatus = fileVersion.getStatus();\n\n\t\t// File version\n\n\t\tdlFileEntryLocalService.updateStatus(\n\t\t\tuserId, fileVersion.getFileVersionId(),\n\t\t\tWorkflowConstants.STATUS_IN_TRASH,\n\t\t\tnew HashMap<String, Serializable>(), new ServiceContext());\n\n\t\t// File shortcut\n\n\t\tdlFileShortcutLocalService.disableFileShortcuts(\n\t\t\tfileEntry.getFileEntryId());\n\n\t\t// File rank\n\n\t\tdlFileRankLocalService.disableFileRanks(fileEntry.getFileEntryId());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, fileEntry.getGroupId(), DLFileEntryConstants.getClassName(),\n\t\t\tfileEntry.getFileEntryId(),\n\t\t\tSocialActivityConstants.TYPE_MOVE_TO_TRASH, StringPool.BLANK, 0);\n\n\t\t// Trash\n\n\t\tList<ObjectValuePair<Long, Integer>> fileVersionStatuses =\n\t\t\tnew ArrayList<ObjectValuePair<Long, Integer>>(\n\t\t\t\tdlFileVersions.size());\n\n\t\tfor (DLFileVersion dlFileVersion : dlFileVersions) {\n\t\t\tObjectValuePair<Long, Integer> fileVersionStatus =\n\t\t\t\tnew ObjectValuePair<Long, Integer>();\n\n\t\t\tfileVersionStatus.setKey(dlFileVersion.getFileVersionId());\n\n\t\t\tint status = dlFileVersion.getStatus();\n\n\t\t\tif (status == WorkflowConstants.STATUS_PENDING) {\n\t\t\t\tstatus = WorkflowConstants.STATUS_DRAFT;\n\t\t\t}\n\n\t\t\tfileVersionStatus.setValue(status);\n\n\t\t\tfileVersionStatuses.add(fileVersionStatus);\n\t\t}\n\n\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\tuserId, fileEntry.getGroupId(), DLFileEntryConstants.getClassName(),\n\t\t\tfileEntry.getFileEntryId(), oldStatus, fileVersionStatuses, null);\n\n\t\t// Workflow\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_PENDING) {\n\t\t\tworkflowInstanceLinkLocalService.deleteWorkflowInstanceLink(\n\t\t\t\tfileVersion.getCompanyId(), fileVersion.getGroupId(),\n\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\tfileVersion.getFileVersionId());\n\t\t}\n\n\t\treturn fileEntry;\n\t}","commit_id":"e9df1e898325a4fde4c475b9302e2e17e33afd25","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateStatuses(\n\t\t\tUser user, List<Object> dlFileEntriesAndDLFolders, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\tfor (Object object : dlFileEntriesAndDLFolders) {\n\t\t\tif (object instanceof DLFileEntry) {\n\t\t\t\tDLFileEntry dlFileEntry = (DLFileEntry)object;\n\n\t\t\t\tDLFileVersion dlFileVersion =\n\t\t\t\t\tdlFileVersionLocalService.getLatestFileVersion(\n\t\t\t\t\t\tdlFileEntry.getFileEntryId(), false);\n\n\t\t\t\tif ((status == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t\t(dlFileVersion.getStatus() ==\n\t\t\t\t\t\tWorkflowConstants.STATUS_IN_TRASH)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Asset\n\n\t\t\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\t\t\tif (dlFileVersion.isApproved()) {\n\t\t\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\t\tdlFileEntry.getFileEntryId(), true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tdlFileEntry.getFileEntryId(), false);\n\t\t\t\t}\n\n\t\t\t\t// Social\n\n\t\t\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\t\t\tsocialActivityCounterLocalService.enableActivityCounters(\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tdlFileEntry.getFileEntryId());\n\n\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\tuser.getUserId(), dlFileEntry.getGroupId(),\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tdlFileEntry.getFileEntryId(),\n\t\t\t\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH,\n\t\t\t\t\t\tStringPool.BLANK, 0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\tuser.getUserId(), dlFileEntry.getGroupId(),\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tdlFileEntry.getFileEntryId(),\n\t\t\t\t\t\tSocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\t\t\t\tStringPool.BLANK, 0);\n\t\t\t\t}\n\n\t\t\t\t// Index\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\t\tDLFileEntry.class);\n\n\t\t\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\t\t\tindexer.reindex(dlFileEntry);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tindexer.delete(dlFileEntry);\n\t\t\t\t}\n\n\t\t\t\t// Workflow\n\n\t\t\t\tif ((status != WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t\tdlFileVersion.isPending()) {\n\n\t\t\t\t\tworkflowInstanceLinkLocalService.\n\t\t\t\t\t\tdeleteWorkflowInstanceLink(\n\t\t\t\t\t\t\tdlFileVersion.getCompanyId(),\n\t\t\t\t\t\t\tdlFileVersion.getGroupId(),\n\t\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\t\tdlFileVersion.getFileVersionId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (object instanceof DLFolder) {\n\t\t\t\tDLFolder dlFolder = (DLFolder)object;\n\n\t\t\t\tif (dlFolder.getStatus() == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tQueryDefinition queryDefinition = new QueryDefinition(\n\t\t\t\t\tWorkflowConstants.STATUS_ANY);\n\n\t\t\t\tList<Object> foldersAndFileEntriesAndFileShortcuts =\n\t\t\t\t\tdlFolderLocalService.\n\t\t\t\t\t\tgetFoldersAndFileEntriesAndFileShortcuts(\n\t\t\t\t\t\t\tdlFolder.getGroupId(), dlFolder.getFolderId(), null,\n\t\t\t\t\t\t\tfalse, queryDefinition);\n\n\t\t\t\tupdateStatuses(\n\t\t\t\t\tuser, foldersAndFileEntriesAndFileShortcuts, status);\n\t\t\t}\n\t\t}\n\t}","id":29356,"modified_method":"public void updateStatuses(\n\t\t\tUser user, List<Object> dlFileEntriesAndDLFolders, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\tfor (Object object : dlFileEntriesAndDLFolders) {\n\t\t\tif (object instanceof DLFileEntry) {\n\t\t\t\tDLFileEntry dlFileEntry = (DLFileEntry)object;\n\n\t\t\t\tList<DLFileVersion> dlFileVersions =\n\t\t\t\t\tdlFileVersionLocalService.getFileVersions(\n\t\t\t\t\t\tdlFileEntry.getFileEntryId(),\n\t\t\t\t\t\tWorkflowConstants.STATUS_ANY);\n\n\t\t\t\tdlFileVersions = ListUtil.copy(dlFileVersions);\n\n\t\t\t\tCollections.sort(\n\t\t\t\t\tdlFileVersions, new FileVersionVersionComparator());\n\n\t\t\t\tDLFileVersion latestDlFileVersion = dlFileVersions.get(0);\n\n\t\t\t\tif ((status == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t\t(latestDlFileVersion.getStatus() ==\n\t\t\t\t\t\tWorkflowConstants.STATUS_IN_TRASH)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Asset\n\n\t\t\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\t\t\tif (latestDlFileVersion.isApproved()) {\n\t\t\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\t\tdlFileEntry.getFileEntryId(), true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tdlFileEntry.getFileEntryId(), false);\n\t\t\t\t}\n\n\t\t\t\t// Social\n\n\t\t\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\t\t\tsocialActivityCounterLocalService.enableActivityCounters(\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tdlFileEntry.getFileEntryId());\n\n\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\tuser.getUserId(), dlFileEntry.getGroupId(),\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tdlFileEntry.getFileEntryId(),\n\t\t\t\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH,\n\t\t\t\t\t\tStringPool.BLANK, 0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\tuser.getUserId(), dlFileEntry.getGroupId(),\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tdlFileEntry.getFileEntryId(),\n\t\t\t\t\t\tSocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\t\t\t\tStringPool.BLANK, 0);\n\t\t\t\t}\n\n\t\t\t\t// Index\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\t\tDLFileEntry.class);\n\n\t\t\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\t\t\tindexer.reindex(dlFileEntry);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tindexer.delete(dlFileEntry);\n\t\t\t\t}\n\n\t\t\t\t// Workflow\n\n\t\t\t\tif (status != WorkflowConstants.STATUS_APPROVED) {\n\t\t\t\t\tfor (DLFileVersion dlFileVersion : dlFileVersions) {\n\t\t\t\t\t\tif (!dlFileVersion.isPending()) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdlFileVersion.setStatus(WorkflowConstants.STATUS_DRAFT);\n\n\t\t\t\t\t\tdlFileVersionPersistence.update(dlFileVersion, false);\n\n\t\t\t\t\t\tworkflowInstanceLinkLocalService.\n\t\t\t\t\t\t\tdeleteWorkflowInstanceLink(\n\t\t\t\t\t\t\t\tdlFileVersion.getCompanyId(),\n\t\t\t\t\t\t\t\tdlFileVersion.getGroupId(),\n\t\t\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\t\t\tdlFileVersion.getFileVersionId());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (object instanceof DLFolder) {\n\t\t\t\tDLFolder dlFolder = (DLFolder)object;\n\n\t\t\t\tif (dlFolder.getStatus() == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tQueryDefinition queryDefinition = new QueryDefinition(\n\t\t\t\t\tWorkflowConstants.STATUS_ANY);\n\n\t\t\t\tList<Object> foldersAndFileEntriesAndFileShortcuts =\n\t\t\t\t\tdlFolderLocalService.\n\t\t\t\t\t\tgetFoldersAndFileEntriesAndFileShortcuts(\n\t\t\t\t\t\t\tdlFolder.getGroupId(), dlFolder.getFolderId(), null,\n\t\t\t\t\t\t\tfalse, queryDefinition);\n\n\t\t\t\tupdateStatuses(\n\t\t\t\t\tuser, foldersAndFileEntriesAndFileShortcuts, status);\n\t\t\t}\n\t\t}\n\t}","commit_id":"e9df1e898325a4fde4c475b9302e2e17e33afd25","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteWorkflowInstanceLink(\n\t\t\tlong companyId, long groupId, String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tWorkflowInstanceLink workflowInstanceLink = fetchWorkflowInstanceLink(\n\t\t\tcompanyId, groupId, className, classPK);\n\n\t\tif (workflowInstanceLink == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tdeleteWorkflowInstanceLink(workflowInstanceLink);\n\t}","id":29357,"modified_method":"public WorkflowInstanceLink deleteWorkflowInstanceLink(\n\t\t\tlong companyId, long groupId, String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tWorkflowInstanceLink workflowInstanceLink = fetchWorkflowInstanceLink(\n\t\t\tcompanyId, groupId, className, classPK);\n\n\t\treturn deleteWorkflowInstanceLink(workflowInstanceLink);\n\t}","commit_id":"e9df1e898325a4fde4c475b9302e2e17e33afd25","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic WorkflowInstanceLink deleteWorkflowInstanceLink(\n\t\t\tWorkflowInstanceLink workflowInstanceLink)\n\t\tthrows PortalException, SystemException {\n\n\t\tsuper.deleteWorkflowInstanceLink(workflowInstanceLink);\n\n\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\tworkflowInstanceLink.getCompanyId(),\n\t\t\tWorkflowInstance.class.getName(),\n\t\t\tworkflowInstanceLink.getWorkflowInstanceId());\n\n\t\tWorkflowInstanceManagerUtil.deleteWorkflowInstance(\n\t\t\tworkflowInstanceLink.getCompanyId(),\n\t\t\tworkflowInstanceLink.getWorkflowInstanceId());\n\n\t\treturn workflowInstanceLink;\n\t}","id":29358,"modified_method":"@Override\n\tpublic WorkflowInstanceLink deleteWorkflowInstanceLink(\n\t\t\tWorkflowInstanceLink workflowInstanceLink)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (workflowInstanceLink != null) {\n\t\t\tsuper.deleteWorkflowInstanceLink(workflowInstanceLink);\n\n\t\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\t\tworkflowInstanceLink.getCompanyId(),\n\t\t\t\tWorkflowInstance.class.getName(),\n\t\t\t\tworkflowInstanceLink.getWorkflowInstanceId());\n\n\t\t\tWorkflowInstanceManagerUtil.deleteWorkflowInstance(\n\t\t\t\tworkflowInstanceLink.getCompanyId(),\n\t\t\t\tworkflowInstanceLink.getWorkflowInstanceId());\n\t\t}\n\n\t\treturn workflowInstanceLink;\n\t}","commit_id":"e9df1e898325a4fde4c475b9302e2e17e33afd25","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    // properties declared in specified concept\n    SNode applicableConcept = NodePropertyConstraint_Behavior.call_getApplicableConcept_1213877292345(_context.getReferenceNode());\n    if (applicableConcept == null) {\n      SNode containingRoot = SNodeOperations.getContainingRoot(_context.getEnclosingNode());\n      assert SNodeOperations.isInstanceOf(containingRoot, \"jetbrains.mps.lang.constraints.structure.ConceptConstraints\");\n      applicableConcept = SLinkOperations.getTarget(SNodeOperations.cast(containingRoot, \"jetbrains.mps.lang.constraints.structure.ConceptConstraints\"), \"concept\", false);\n    }\n    return AbstractConceptDeclaration_Behavior.call_getPropertyDeclarations_1213877394546(applicableConcept);\n  }","id":29359,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    // properties declared in specified concept\n    SNode applicableConcept = NodePropertyConstraint_Behavior.call_getApplicableConcept_1213877292345(_context.getReferenceNode());\n    if (applicableConcept == null) {\n      SNode root = SNodeOperations.getContainingRoot(_context.getEnclosingNode());\n      if (SNodeOperations.isInstanceOf(root, \"jetbrains.mps.lang.constraints.structure.ConceptConstraints\")) {\n        applicableConcept = SLinkOperations.getTarget(SNodeOperations.cast(root, \"jetbrains.mps.lang.constraints.structure.ConceptConstraints\"), \"concept\", false);\n      } else\n      {\n        applicableConcept = SLinkOperations.getTarget(SNodeOperations.cast(root, \"jetbrains.mps.lang.behavior.structure.ConceptBehavior\"), \"concept\", false);\n      }\n    }\n    return AbstractConceptDeclaration_Behavior.call_getPropertyDeclarations_1213877394546(applicableConcept);\n  }","commit_id":"3d7bb877210772cf83338f647e91f77643d7f628","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    // links declared in specified concept\n    SNode applicableConcept = NodeReferentConstraint_Behavior.call_getApplicableConcept_1213877399322(_context.getReferenceNode());\n    if (applicableConcept == null) {\n      applicableConcept = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getContainingRoot(_context.getEnclosingNode()), \"jetbrains.mps.lang.behavior.structure.ConceptBehavior\"), \"concept\", false);\n    }\n    return AbstractConceptDeclaration_Behavior.call_getReferenceLinkDeclarations_1213877394496(applicableConcept);\n  }","id":29360,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    // links declared in specified concept\n    SNode applicableConcept = NodeReferentConstraint_Behavior.call_getApplicableConcept_1213877399322(_context.getReferenceNode());\n    if (applicableConcept == null) {\n      SNode root = SNodeOperations.getContainingRoot(_context.getEnclosingNode());\n      if (SNodeOperations.isInstanceOf(root, \"jetbrains.mps.lang.constraints.structure.ConceptConstraints\")) {\n        applicableConcept = SLinkOperations.getTarget(SNodeOperations.cast(root, \"jetbrains.mps.lang.constraints.structure.ConceptConstraints\"), \"concept\", false);\n      } else\n      {\n        applicableConcept = SLinkOperations.getTarget(SNodeOperations.cast(root, \"jetbrains.mps.lang.behavior.structure.ConceptBehavior\"), \"concept\", false);\n      }\n    }\n    return AbstractConceptDeclaration_Behavior.call_getReferenceLinkDeclarations_1213877394496(applicableConcept);\n  }","commit_id":"3d7bb877210772cf83338f647e91f77643d7f628","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    // properties declared in specified concept\n    SNode applicableConcept = NodePropertyConstraint_Behavior.call_getApplicableConcept_1213877292345(_context.getReferenceNode());\n    if (applicableConcept == null) {\n      applicableConcept = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getContainingRoot(_context.getEnclosingNode()), \"jetbrains.mps.lang.behavior.structure.ConceptBehavior\"), \"concept\", false);\n    }\n    return AbstractConceptDeclaration_Behavior.call_getPropertyDeclarations_1213877394546(applicableConcept);\n  }","id":29361,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    // properties declared in specified concept\n    SNode applicableConcept = NodePropertyConstraint_Behavior.call_getApplicableConcept_1213877292345(_context.getReferenceNode());\n    if (applicableConcept == null) {\n      SNode containingRoot = SNodeOperations.getContainingRoot(_context.getEnclosingNode());\n      assert SNodeOperations.isInstanceOf(containingRoot, \"jetbrains.mps.lang.constraints.structure.ConceptConstraints\");\n      applicableConcept = SLinkOperations.getTarget(SNodeOperations.cast(containingRoot, \"jetbrains.mps.lang.constraints.structure.ConceptConstraints\"), \"concept\", false);\n    }\n    return AbstractConceptDeclaration_Behavior.call_getPropertyDeclarations_1213877394546(applicableConcept);\n  }","commit_id":"2597d1e5591566ecff48043b8b17f4960588256b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void editNode(final SNode node) {\n    if (myNode == node) {\n      return;\n    }\n    myContainingRoot = node.getContainingRoot();\n    super.editNode(node);\n  }","id":29362,"modified_method":"public void editNode(final SNode node) {\n    if (myNode == node) {\n      return;\n    }\n    myContainingRoot = node == null ? null : node.getContainingRoot();\n    super.editNode(node);\n  }","commit_id":"47c43b499dcbf6eb8ffab17da2634db882c6daa2","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void showMenu() {\n\n  }","id":29363,"modified_method":"private void showMenu() {\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        List<SNode> nodes = myDescriptor.getNodes(myTabbedEditor.getBaseNode().getNode());\n        myTabbedEditor.selectNode(nodes.get(0));\n      }\n    });\n  }","commit_id":"877b6966e535444fdeffe3e747b8504078b5c720","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorTab(EditorTabDescriptor descriptor) {\n    myDescriptor = descriptor;\n    setAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        showMenu();\n      }\n    });\n  }","id":29364,"modified_method":"public EditorTab(NewTabbedEditor tabbedEditor, EditorTabDescriptor descriptor) {\n    myTabbedEditor = tabbedEditor;\n    myDescriptor = descriptor;\n    setAction(new AbstractAction(descriptor.getTitle()) {\n      public void actionPerformed(ActionEvent e) {\n        showMenu();\n      }\n    });\n  }","commit_id":"877b6966e535444fdeffe3e747b8504078b5c720","url":"https://github.com/JetBrains/MPS"},{"original_method":"private IEditor openEditor(final SNode root, IOperationContext context, boolean openBaseNode) {\n    SNode baseNode = null;\n\n    if (openBaseNode) {\n      baseNode = getBaseNode(context, root);\n    }\n\n    if (baseNode == null) {\n      baseNode = root;\n    }\n\n    // [++] assertions for http://youtrack.jetbrains.net/issue/MPS-7792\n    assert baseNode.isRegistered() : \"BaseNode is not registered\";\n    SNode node = new SNodePointer(baseNode).getNode();\n    assert node != null : \"Unable to get Node by SNodePointer\";\n    assert node.isRegistered() : \"Returned node is not registered (\" + node + \"|\" + baseNode + \")\";\n    // [--] assertions for http://youtrack.jetbrains.net/issue/MPS-7792\n    MPSNodeVirtualFile file = MPSNodesVirtualFileSystem.getInstance().getFileFor(baseNode);\n    // [++] assertion for http://youtrack.jetbrains.net/issue/MPS-9753\n    assert file.isValid() : \"Invalid file returned for: \" + baseNode + \", corresponding node from SNodePointer: \" + new SNodePointer(baseNode).getNode();\n    // [--] assertion for http://youtrack.jetbrains.net/issue/MPS-9753\n    FileEditorManager editorManager = FileEditorManager.getInstance(myProject);\n    FileEditor fileEditor = editorManager.openFile(file, false)[0];\n\n    MPSFileNodeEditor fileNodeEditor = (MPSFileNodeEditor) fileEditor;\n\n    IEditor nodeEditor = fileNodeEditor.getNodeEditor();\n\n    if (nodeEditor instanceof TabbedEditor) {\n      ((TabbedEditor) nodeEditor).selectLinkedEditor(new SNodePointer(root));\n    }\n\n    return nodeEditor;\n  }","id":29365,"modified_method":"private IEditor openEditor(final SNode root, IOperationContext context, boolean openBaseNode) {\n    SNode baseNode = null;\n\n    if (openBaseNode) {\n      baseNode = getBaseNode(context, root);\n    }\n\n    if (baseNode == null) {\n      baseNode = root;\n    }\n\n    // [++] assertions for http://youtrack.jetbrains.net/issue/MPS-7792\n    assert baseNode.isRegistered() : \"BaseNode is not registered\";\n    SNode node = new SNodePointer(baseNode).getNode();\n    assert node != null : \"Unable to get Node by SNodePointer\";\n    assert node.isRegistered() : \"Returned node is not registered (\" + node + \"|\" + baseNode + \")\";\n    // [--] assertions for http://youtrack.jetbrains.net/issue/MPS-7792\n    MPSNodeVirtualFile file = MPSNodesVirtualFileSystem.getInstance().getFileFor(baseNode);\n    // [++] assertion for http://youtrack.jetbrains.net/issue/MPS-9753\n    assert file.isValid() : \"Invalid file returned for: \" + baseNode + \", corresponding node from SNodePointer: \" + new SNodePointer(baseNode).getNode();\n    // [--] assertion for http://youtrack.jetbrains.net/issue/MPS-9753\n    FileEditorManager editorManager = FileEditorManager.getInstance(myProject);\n    FileEditor fileEditor = editorManager.openFile(file, false)[0];\n\n    MPSFileNodeEditor fileNodeEditor = (MPSFileNodeEditor) fileEditor;\n\n    IEditor nodeEditor = fileNodeEditor.getNodeEditor();\n\n    if (nodeEditor instanceof TabbedEditor) {\n      ((TabbedEditor) nodeEditor).selectLinkedEditor(new SNodePointer(root));\n    }\n    if (nodeEditor instanceof NewTabbedEditor) {\n      ((NewTabbedEditor) nodeEditor).selectNode(root);\n    }\n\n    return nodeEditor;\n  }","commit_id":"877b6966e535444fdeffe3e747b8504078b5c720","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void selectNode(SNode node) {\n    SNode containingRoot = node.getContainingRoot();\n    EditorComponent editor = getCurrentEditorComponent();\n    editor.editNode(containingRoot, getOperationContext());\n    editor.selectNode(node);\n  }","id":29366,"modified_method":"public void selectNode(SNode node) {\n    SNode containingRoot = node.isRoot() ? node : node.getContainingRoot();\n    EditorComponent editor = getCurrentEditorComponent();\n    editor.editNode(containingRoot, getOperationContext());\n    editor.selectNode(node);\n  }","commit_id":"877b6966e535444fdeffe3e747b8504078b5c720","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void updateTabs() {\n    myTabsPanel.removeAll();\n    myRealTabs.clear();\n    for (EditorTabDescriptor d : myPossibleTabs) {\n      if (!d.getNodes(myBaseNode.getNode()).isEmpty()) {\n        EditorTab tab = new EditorTab(d);\n        myRealTabs.add(tab);\n        myTabsPanel.add(tab);\n      }\n    }\n  }","id":29367,"modified_method":"private void updateTabs() {\n    myTabsPanel.removeAll();\n    myRealTabs.clear();\n    for (EditorTabDescriptor d : myPossibleTabs) {\n      if (!d.getNodes(myBaseNode.getNode()).isEmpty()) {\n        EditorTab tab = new EditorTab(this, d);\n        myRealTabs.add(tab);\n        myTabsPanel.add(tab);\n      }\n    }\n    myTabsPanel.add(new AddConceptButton());\n  }","commit_id":"877b6966e535444fdeffe3e747b8504078b5c720","url":"https://github.com/JetBrains/MPS"},{"original_method":"public NewTabbedEditor(SNodePointer baseNode, Set<EditorTabDescriptor> possibleTabs, IOperationContext context) {\n    super(context);\n    myBaseNode = baseNode;\n    myPossibleTabs = possibleTabs;\n\n    getComponent().add(myTabsPanel, BorderLayout.SOUTH);\n    updateTabs();\n  }","id":29368,"modified_method":"public NewTabbedEditor(SNodePointer baseNode, Set<EditorTabDescriptor> possibleTabs, IOperationContext context) {\n    super(context);\n    myBaseNode = baseNode;\n    myPossibleTabs = possibleTabs;\n\n    getCurrentEditorComponent().editNode(baseNode.getNode(), context);\n\n    getComponent().add(myTabsPanel, BorderLayout.SOUTH);\n    updateTabs();\n  }","commit_id":"877b6966e535444fdeffe3e747b8504078b5c720","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static JSONObject _toJSONObject(\n\t\t\tHttpServletRequest request, long groupId,\n\t\t\tLayoutTreeNodes layoutTreeNodes)\n\t\tthrows Exception {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\tsb.append(\"_toJSON(groupId=\");\n\t\t\tsb.append(groupId);\n\t\t\tsb.append(\", layoutTreeNodes=\");\n\t\t\tsb.append(layoutTreeNodes);\n\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\t_log.debug(sb.toString());\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tboolean hasManageLayoutsPermission = GroupPermissionUtil.contains(\n\t\t\tthemeDisplay.getPermissionChecker(), groupId,\n\t\t\tActionKeys.MANAGE_LAYOUTS);\n\n\t\tfor (LayoutTreeNode layoutTreeNode : layoutTreeNodes) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tString childrenJSON = _toJSONObject(\n\t\t\t\trequest, groupId,\n\t\t\t\tlayoutTreeNode.getChildLayoutTreeNodes()).toString();\n\n\t\t\tjsonObject.put(\n\t\t\t\t\"children\", JSONFactoryUtil.createJSONObject(childrenJSON));\n\n\t\t\tLayout layout = layoutTreeNode.getLayout();\n\n\t\t\tjsonObject.put(\"contentDisplayPage\", layout.isContentDisplayPage());\n\t\t\tjsonObject.put(\"deleteable\", _isDeleteable(layout, themeDisplay));\n\t\t\tjsonObject.put(\"friendlyURL\", layout.getFriendlyURL());\n\n\t\t\tif (layout instanceof VirtualLayout) {\n\t\t\t\tVirtualLayout virtualLayout = (VirtualLayout)layout;\n\n\t\t\t\tjsonObject.put(\"groupId\", virtualLayout.getSourceGroupId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjsonObject.put(\"groupId\", layout.getGroupId());\n\t\t\t}\n\n\t\t\tjsonObject.put(\"hasChildren\", layout.hasChildren());\n\t\t\tjsonObject.put(\"layoutId\", layout.getLayoutId());\n\t\t\tjsonObject.put(\"name\", layout.getName(themeDisplay.getLocale()));\n\t\t\tjsonObject.put(\n\t\t\t\t\"parentable\",\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tthemeDisplay.getPermissionChecker(), layout,\n\t\t\t\t\tActionKeys.ADD_LAYOUT));\n\t\t\tjsonObject.put(\"parentLayoutId\", layout.getParentLayoutId());\n\t\t\tjsonObject.put(\"plid\", layout.getPlid());\n\t\t\tjsonObject.put(\"priority\", layout.getPriority());\n\t\t\tjsonObject.put(\"privateLayout\", layout.isPrivateLayout());\n\t\t\tjsonObject.put(\"regularURL\", layout.getRegularURL(request));\n\t\t\tjsonObject.put(\n\t\t\t\t\"sortable\",\n\t\t\t\thasManageLayoutsPermission &&\n\t\t\t\t\tSitesUtil.isLayoutSortable(layout));\n\t\t\tjsonObject.put(\"type\", layout.getType());\n\t\t\tjsonObject.put(\n\t\t\t\t\"updateable\",\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tthemeDisplay.getPermissionChecker(), layout,\n\t\t\t\t\tActionKeys.UPDATE));\n\t\t\tjsonObject.put(\"uuid\", layout.getUuid());\n\n\t\t\tLayoutRevision layoutRevision = LayoutStagingUtil.getLayoutRevision(\n\t\t\t\tlayout);\n\n\t\t\tif (layoutRevision != null) {\n\t\t\t\tlong layoutSetBranchId = layoutRevision.getLayoutSetBranchId();\n\n\t\t\t\tif (StagingUtil.isIncomplete(layout, layoutSetBranchId)) {\n\t\t\t\t\tjsonObject.put(\"incomplete\", true);\n\t\t\t\t}\n\n\t\t\t\tLayoutSetBranch layoutSetBranch =\n\t\t\t\t\tLayoutSetBranchLocalServiceUtil.getLayoutSetBranch(\n\t\t\t\t\t\tlayoutSetBranchId);\n\n\t\t\t\tLayoutBranch layoutBranch = layoutRevision.getLayoutBranch();\n\n\t\t\t\tif (!layoutBranch.isMaster()) {\n\t\t\t\t\tjsonObject.put(\n\t\t\t\t\t\t\"layoutBranchId\", layoutBranch.getLayoutBranchId());\n\t\t\t\t\tjsonObject.put(\"layoutBranchName\", layoutBranch.getName());\n\t\t\t\t}\n\n\t\t\t\tif (layoutRevision.isHead()) {\n\t\t\t\t\tjsonObject.put(\"layoutRevisionHead\", true);\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"layoutRevisionId\", layoutRevision.getLayoutRevisionId());\n\t\t\t\tjsonObject.put(\"layoutSetBranchId\", layoutSetBranchId);\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"layoutSetBranchName\", layoutSetBranch.getName());\n\t\t\t}\n\n\t\t\tjsonArray.put(jsonObject);\n\t\t}\n\n\t\tJSONObject responseJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\tresponseJSONObject.put(\"layouts\", jsonArray);\n\t\tresponseJSONObject.put(\"total\", layoutTreeNodes.getTotal());\n\n\t\treturn responseJSONObject;\n\t}","id":29369,"modified_method":"private static JSONObject _toJSONObject(\n\t\t\tHttpServletRequest request, long groupId,\n\t\t\tLayoutTreeNodes layoutTreeNodes)\n\t\tthrows Exception {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\tsb.append(\"_toJSON(groupId=\");\n\t\t\tsb.append(groupId);\n\t\t\tsb.append(\", layoutTreeNodes=\");\n\t\t\tsb.append(layoutTreeNodes);\n\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\t_log.debug(sb.toString());\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tboolean hasManageLayoutsPermission = GroupPermissionUtil.contains(\n\t\t\tthemeDisplay.getPermissionChecker(), groupId,\n\t\t\tActionKeys.MANAGE_LAYOUTS);\n\n\t\tfor (LayoutTreeNode layoutTreeNode : layoutTreeNodes) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tJSONObject childrenJSONObject = _toJSONObject(\n\t\t\t\trequest, groupId, layoutTreeNode.getChildLayoutTreeNodes());\n\n\t\t\tjsonObject.put(\"children\", childrenJSONObject);\n\n\t\t\tLayout layout = layoutTreeNode.getLayout();\n\n\t\t\tjsonObject.put(\"contentDisplayPage\", layout.isContentDisplayPage());\n\t\t\tjsonObject.put(\"deleteable\", _isDeleteable(layout, themeDisplay));\n\t\t\tjsonObject.put(\"friendlyURL\", layout.getFriendlyURL());\n\n\t\t\tif (layout instanceof VirtualLayout) {\n\t\t\t\tVirtualLayout virtualLayout = (VirtualLayout)layout;\n\n\t\t\t\tjsonObject.put(\"groupId\", virtualLayout.getSourceGroupId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjsonObject.put(\"groupId\", layout.getGroupId());\n\t\t\t}\n\n\t\t\tjsonObject.put(\"hasChildren\", layout.hasChildren());\n\t\t\tjsonObject.put(\"layoutId\", layout.getLayoutId());\n\t\t\tjsonObject.put(\"name\", layout.getName(themeDisplay.getLocale()));\n\t\t\tjsonObject.put(\n\t\t\t\t\"parentable\",\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tthemeDisplay.getPermissionChecker(), layout,\n\t\t\t\t\tActionKeys.ADD_LAYOUT));\n\t\t\tjsonObject.put(\"parentLayoutId\", layout.getParentLayoutId());\n\t\t\tjsonObject.put(\"plid\", layout.getPlid());\n\t\t\tjsonObject.put(\"priority\", layout.getPriority());\n\t\t\tjsonObject.put(\"privateLayout\", layout.isPrivateLayout());\n\t\t\tjsonObject.put(\"regularURL\", layout.getRegularURL(request));\n\t\t\tjsonObject.put(\n\t\t\t\t\"sortable\",\n\t\t\t\thasManageLayoutsPermission &&\n\t\t\t\t\tSitesUtil.isLayoutSortable(layout));\n\t\t\tjsonObject.put(\"type\", layout.getType());\n\t\t\tjsonObject.put(\n\t\t\t\t\"updateable\",\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tthemeDisplay.getPermissionChecker(), layout,\n\t\t\t\t\tActionKeys.UPDATE));\n\t\t\tjsonObject.put(\"uuid\", layout.getUuid());\n\n\t\t\tLayoutRevision layoutRevision = LayoutStagingUtil.getLayoutRevision(\n\t\t\t\tlayout);\n\n\t\t\tif (layoutRevision != null) {\n\t\t\t\tlong layoutSetBranchId = layoutRevision.getLayoutSetBranchId();\n\n\t\t\t\tif (StagingUtil.isIncomplete(layout, layoutSetBranchId)) {\n\t\t\t\t\tjsonObject.put(\"incomplete\", true);\n\t\t\t\t}\n\n\t\t\t\tLayoutSetBranch layoutSetBranch =\n\t\t\t\t\tLayoutSetBranchLocalServiceUtil.getLayoutSetBranch(\n\t\t\t\t\t\tlayoutSetBranchId);\n\n\t\t\t\tLayoutBranch layoutBranch = layoutRevision.getLayoutBranch();\n\n\t\t\t\tif (!layoutBranch.isMaster()) {\n\t\t\t\t\tjsonObject.put(\n\t\t\t\t\t\t\"layoutBranchId\", layoutBranch.getLayoutBranchId());\n\t\t\t\t\tjsonObject.put(\"layoutBranchName\", layoutBranch.getName());\n\t\t\t\t}\n\n\t\t\t\tif (layoutRevision.isHead()) {\n\t\t\t\t\tjsonObject.put(\"layoutRevisionHead\", true);\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"layoutRevisionId\", layoutRevision.getLayoutRevisionId());\n\t\t\t\tjsonObject.put(\"layoutSetBranchId\", layoutSetBranchId);\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"layoutSetBranchName\", layoutSetBranch.getName());\n\t\t\t}\n\n\t\t\tjsonArray.put(jsonObject);\n\t\t}\n\n\t\tJSONObject responseJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\tresponseJSONObject.put(\"layouts\", jsonArray);\n\t\tresponseJSONObject.put(\"total\", layoutTreeNodes.getTotal());\n\n\t\treturn responseJSONObject;\n\t}","commit_id":"7a2ce857bc687eebf76abf1a1ce16a9af3ce3772","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static String _toJSON(\n\t\t\tHttpServletRequest request, long groupId,\n\t\t\tLayoutTreeNodes layoutTreeNodes)\n\t\tthrows Exception {\n\n\t\treturn _toJSONObject(request, groupId, layoutTreeNodes).toString();\n\t}","id":29370,"modified_method":"private static String _toJSON(\n\t\t\tHttpServletRequest request, long groupId,\n\t\t\tLayoutTreeNodes layoutTreeNodes)\n\t\tthrows Exception {\n\n\t\tJSONObject jsonObject = _toJSONObject(\n\t\t\trequest, groupId, layoutTreeNodes);\n\n\t\treturn jsonObject.toString();\n\t}","commit_id":"f9711735c232d9bd2b5cc19da32a2aefa98f946a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddContentVirtualHostCommunity() throws Exception {\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Back to My Community\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.click(RuntimeVariables.replace(\"link=Back to My Community\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"//li[7]/ul/li[1]/a[2]\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"//div[2]/ul/li/a/span\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(\"link=Add Application\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@id='News-Announcements']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.click(\"//div[@id='News-Announcements']/p/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Configuration\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.click(RuntimeVariables.replace(\"link=Manage Entries\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.select(\"_84_distributionScope\", \"label=General\");\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"//input[@value='Add Entry']\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.typeKeys(\"_84_title\", RuntimeVariables.replace(\"Welcome\"));\n\t\tselenium.type(\"_84_title\", RuntimeVariables.replace(\"Welcome\"));\n\t\tselenium.type(\"_84_content\",\n\t\t\tRuntimeVariables.replace(\n\t\t\t\t\"Hello and welcome to the Virtual Hosting Test Community!\"));\n\t\tselenium.click(RuntimeVariables.replace(\"//input[@value='Save']\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"link=New Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertTrue(selenium.isTextPresent(\n\t\t\t\t\"Hello and welcome to the Virtual Hosting Test Community!\"));\n\t}","id":29371,"modified_method":"public void testAddContentVirtualHostCommunity() throws Exception {\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.click(RuntimeVariables.replace(\"link=Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"link=Back to My Community\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"//li[7]/ul/li[1]/a[2]\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"//div[2]/ul/li/a/span\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(\"link=Add Application\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@id='News-Announcements']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.click(\"//div[@id='News-Announcements']/p/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Configuration\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.click(RuntimeVariables.replace(\"link=Manage Entries\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.select(\"_84_distributionScope\", \"label=General\");\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"//input[@value='Add Entry']\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.type(\"_84_title\", RuntimeVariables.replace(\"Welcome\"));\n\t\tselenium.type(\"_84_content\",\n\t\t\tRuntimeVariables.replace(\n\t\t\t\t\"Hello and welcome to the Virtual Hosting Test Community!\"));\n\t\tselenium.click(RuntimeVariables.replace(\"//input[@value='Save']\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"link=New Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertTrue(selenium.isTextPresent(\n\t\t\t\t\"Hello and welcome to the Virtual Hosting Test Community!\"));\n\t}","commit_id":"0be3caaad78aa7a7b0461c67d6cb63cf3d12d77c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddVirtualHostCommunity() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\n\t\t\t\tboolean MyCommunityPage = selenium.isElementPresent(\n\t\t\t\t\t\t\"my-community-private-pages\");\n\n\t\t\t\tif (!MyCommunityPage) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"my-community-private-pages\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"link=Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\n\t\t\tcase 2:\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"link=Communities\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"link=Add\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.typeKeys(\"_134_name\",\n\t\t\t\t\tRuntimeVariables.replace(\"Virtual Hosting Test Communit\"));\n\t\t\t\tselenium.type(\"_134_name\",\n\t\t\t\t\tRuntimeVariables.replace(\"Virtual Hosting Test Community\"));\n\t\t\t\tselenium.type(\"_134_description\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"This is the Virtual Hosting test community.\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Save']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.isTextPresent(\n\t\t\t\t\t\t\"Your request processed successfully.\"));\n\t\t\t\tassertTrue(selenium.isTextPresent(\n\t\t\t\t\t\t\"Virtual Hosting Test Community\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":29372,"modified_method":"public void testAddVirtualHostCommunity() throws Exception {\n\t\tselenium.click(RuntimeVariables.replace(\"link=Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"link=Communities\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"link=Add\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.typeKeys(\"_134_name\",\n\t\t\tRuntimeVariables.replace(\"Virtual Hosting Test Communit\"));\n\t\tselenium.type(\"_134_name\",\n\t\t\tRuntimeVariables.replace(\"Virtual Hosting Test Community\"));\n\t\tselenium.typeKeys(\"_134_description\",\n\t\t\tRuntimeVariables.replace(\n\t\t\t\t\"This is the Virtual Hosting test communit.\"));\n\t\tselenium.type(\"_134_description\",\n\t\t\tRuntimeVariables.replace(\n\t\t\t\t\"This is the Virtual Hosting test community.\"));\n\t\tselenium.click(RuntimeVariables.replace(\"//input[@value='Save']\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertTrue(selenium.isTextPresent(\n\t\t\t\t\"Your request processed successfully.\"));\n\t\tassertTrue(selenium.isTextPresent(\"Virtual Hosting Test Community\"));\n\t}","commit_id":"0be3caaad78aa7a7b0461c67d6cb63cf3d12d77c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAssertVirtualHostDefault() throws Exception {\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.click(RuntimeVariables.replace(\"link=Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"link=Communities\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(\"//tr[6]/td[6]/ul/li/strong/span\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"//body/div[2]/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.click(RuntimeVariables.replace(\"//body/div[2]/ul/li[2]/a\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"//form/ul[1]/li[3]/a\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"link=Virtual Host\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertEquals(\"www.able.com\", selenium.getValue(\"_134_publicVirtualHost\"));\n\t\tassertEquals(\"\", selenium.getValue(\"_134_privateVirtualHost\"));\n\t\tassertEquals(\"/virtual-hosting-test-community\",\n\t\t\tselenium.getValue(\"_134_friendlyURL\"));\n\t}","id":29373,"modified_method":"public void testAssertVirtualHostDefault() throws Exception {\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.click(RuntimeVariables.replace(\"link=Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"link=Communities\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(\"//tr[6]/td[6]/ul/li/strong/span\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"//body/div[2]/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.click(RuntimeVariables.replace(\"//body/div[2]/ul/li[2]/a\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"//form/ul[1]/li[3]/a\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"link=Virtual Host\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertEquals(\"\", selenium.getValue(\"_134_publicVirtualHost\"));\n\t\tassertEquals(\"\", selenium.getValue(\"_134_privateVirtualHost\"));\n\t\tassertEquals(\"/virtual-hosting-test-community\",\n\t\t\tselenium.getValue(\"_134_friendlyURL\"));\n\t}","commit_id":"0be3caaad78aa7a7b0461c67d6cb63cf3d12d77c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTestSuite(ControlPanelTest.class);\n\t\ttestSuite.addTestSuite(SetupTest.class);\n\t\ttestSuite.addTestSuite(AddCommunitiesTest.class);\n\t\ttestSuite.addTestSuite(AddAsteriskCommunityNameTest.class);\n\t\ttestSuite.addTestSuite(AddCommaCommunityNameTest.class);\n\t\ttestSuite.addTestSuite(AddDuplicateCommunityNameTest.class);\n\t\ttestSuite.addTestSuite(AddNullCommunityNameTest.class);\n\t\ttestSuite.addTestSuite(AddNumberCommunityNameTest.class);\n\t\ttestSuite.addTestSuite(ApplyCommunityTest.class);\n\t\ttestSuite.addTestSuite(AssertApplyCommunityTest.class);\n\t\ttestSuite.addTestSuite(RemoveApplyCommunityTest.class);\n\t\ttestSuite.addTestSuite(AssertRemoveApplyCommunityTest.class);\n\t\ttestSuite.addTestSuite(SearchCommunityTest.class);\n\t\ttestSuite.addTestSuite(AddTemporaryCommunityTest.class);\n\t\ttestSuite.addTestSuite(EditCommunityTest.class);\n\t\ttestSuite.addTestSuite(DeleteTemporaryCommunityTest.class);\n\t\ttestSuite.addTestSuite(DeleteInvalidCommunityTest.class);\n\t\ttestSuite.addTestSuite(AddTemporaryLARCommunityTest.class);\n\t\ttestSuite.addTestSuite(AssertNoLARCommunityContentTest.class);\n\t\ttestSuite.addTestSuite(ImportCommunityLARTest.class);\n\t\ttestSuite.addTestSuite(AssertCommunityLARImportTest.class);\n\t\ttestSuite.addTestSuite(AddVirtualHostCommunityTest.class);\n\t\ttestSuite.addTestSuite(AddContentVirtualHostCommunityTest.class);\n\t\ttestSuite.addTestSuite(EnableVirtualHostingTest.class);\n\t\ttestSuite.addTestSuite(AssertVirtualHostDefaultTest.class);\n\t\ttestSuite.addTestSuite(AssertVirtualHostingAddressTest.class);\n\t\ttestSuite.addTestSuite(DeleteVirtualHostCommunityContentTest.class);\n\t\ttestSuite.addTestSuite(DeleteVirtualHostCommunityTest.class);\n\t\ttestSuite.addTestSuite(TearDownTest.class);\n\t\ttestSuite.addTestSuite(EndControlPanelTest.class);\n\n\t\treturn testSuite;\n\t}","id":29374,"modified_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTestSuite(ControlPanelTest.class);\n\t\ttestSuite.addTestSuite(SetupTest.class);\n\t\ttestSuite.addTestSuite(AddCommunitiesTest.class);\n\t\ttestSuite.addTestSuite(AddAsteriskCommunityNameTest.class);\n\t\ttestSuite.addTestSuite(AddCommaCommunityNameTest.class);\n\t\ttestSuite.addTestSuite(AddDuplicateCommunityNameTest.class);\n\t\ttestSuite.addTestSuite(AddNullCommunityNameTest.class);\n\t\ttestSuite.addTestSuite(AddNumberCommunityNameTest.class);\n\t\ttestSuite.addTestSuite(ApplyCommunityTest.class);\n\t\ttestSuite.addTestSuite(AssertApplyCommunityTest.class);\n\t\ttestSuite.addTestSuite(RemoveApplyCommunityTest.class);\n\t\ttestSuite.addTestSuite(AssertRemoveApplyCommunityTest.class);\n\t\ttestSuite.addTestSuite(SearchCommunityTest.class);\n\t\ttestSuite.addTestSuite(AddTemporaryCommunityTest.class);\n\t\ttestSuite.addTestSuite(EditCommunityTest.class);\n\t\ttestSuite.addTestSuite(DeleteTemporaryCommunityTest.class);\n\t\ttestSuite.addTestSuite(DeleteInvalidCommunityTest.class);\n\t\ttestSuite.addTestSuite(AddTemporaryLARCommunityTest.class);\n\t\ttestSuite.addTestSuite(AssertNoLARCommunityContentTest.class);\n\t\ttestSuite.addTestSuite(ImportCommunityLARTest.class);\n\t\ttestSuite.addTestSuite(AssertCommunityLARImportTest.class);\n\t\ttestSuite.addTestSuite(AddVirtualHostCommunityTest.class);\n\t\ttestSuite.addTestSuite(AddContentVirtualHostCommunityTest.class);\n\t\ttestSuite.addTestSuite(AssertVirtualHostDefaultTest.class);\n\t\ttestSuite.addTestSuite(EnableVirtualHostingTest.class);\n\t\ttestSuite.addTestSuite(AssertVirtualHostingAddressTest.class);\n\t\ttestSuite.addTestSuite(DeleteVirtualHostCommunityContentTest.class);\n\t\ttestSuite.addTestSuite(DeleteVirtualHostCommunityTest.class);\n\t\ttestSuite.addTestSuite(TearDownTest.class);\n\t\ttestSuite.addTestSuite(EndControlPanelTest.class);\n\n\t\treturn testSuite;\n\t}","commit_id":"0be3caaad78aa7a7b0461c67d6cb63cf3d12d77c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testDeleteVirtualHostCommunity() throws Exception {\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"my-community-private-pages\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.click(RuntimeVariables.replace(\"my-community-private-pages\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"link=Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"link=Communities\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(\"//tr[6]/td[6]/ul/li/strong/span\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"//body/div[2]/ul/li[6]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.click(RuntimeVariables.replace(\"//body/div[2]/ul/li[6]/a\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isTextPresent(\n\t\t\t\t\t\t\t\"Your request processed successfully.\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\t}","id":29375,"modified_method":"public void testDeleteVirtualHostCommunity() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\n\t\t\t\tboolean HomepageLocation = !selenium.isElementPresent(\n\t\t\t\t\t\t\"link=Plugins\");\n\n\t\t\t\tif (!HomepageLocation) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.open(\"http://localhost:8080/web/guest/home\");\n\n\t\t\tcase 2:\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"my-community-private-pages\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"link=Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"link=Communities\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.click(\"//tr[6]/td[6]/ul/li/strong/span\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\t\t\"//body/div[2]/ul/li[6]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//body/div[2]/ul/li[6]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isTextPresent(\n\t\t\t\t\t\t\t\t\t\"Your request processed successfully.\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"link=Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"0be3caaad78aa7a7b0461c67d6cb63cf3d12d77c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testEnableVirtualHosting() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\n\t\t\t\tboolean MyCommunityPage = selenium.isElementPresent(\n\t\t\t\t\t\t\"my-community-private-pages\");\n\n\t\t\t\tif (!MyCommunityPage) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//a[@id='my-community-private-pages']/span\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"link=Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\n\t\t\tcase 2:\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"link=Communities\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.click(\"//tr[6]/td[6]/ul/li/strong/span\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\t\t\"//body/div[2]/ul/li[2]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//body/div[2]/ul/li[2]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//form/ul[1]/li[3]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"link=Virtual Host\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.typeKeys(\"_134_publicVirtualHost\",\n\t\t\t\t\tRuntimeVariables.replace(\"www.able.com\"));\n\t\t\t\tselenium.type(\"_134_publicVirtualHost\",\n\t\t\t\t\tRuntimeVariables.replace(\"www.able.com\"));\n\t\t\t\tselenium.type(\"_134_privateVirtualHost\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.type(\"_134_friendlyURL\",\n\t\t\t\t\tRuntimeVariables.replace(\"/virtual-hosting-test-community\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Save']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.isTextPresent(\n\t\t\t\t\t\t\"Your request processed successfully.\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":29376,"modified_method":"public void testEnableVirtualHosting() throws Exception {\n\t\tselenium.click(RuntimeVariables.replace(\"link=Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"link=Communities\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(\"//tr[6]/td[6]/ul/li/strong/span\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"//body/div[2]/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.click(RuntimeVariables.replace(\"//body/div[2]/ul/li[2]/a\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"//form/ul[1]/li[3]/a\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.click(RuntimeVariables.replace(\"link=Virtual Host\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.typeKeys(\"_134_publicVirtualHost\",\n\t\t\tRuntimeVariables.replace(\"www.able.com\"));\n\t\tselenium.type(\"_134_publicVirtualHost\",\n\t\t\tRuntimeVariables.replace(\"www.able.com\"));\n\t\tselenium.type(\"_134_privateVirtualHost\", RuntimeVariables.replace(\"\"));\n\t\tselenium.typeKeys(\"_134_friendlyURL\",\n\t\t\tRuntimeVariables.replace(\"/virtual-hosting-test-communit\"));\n\t\tselenium.type(\"_134_friendlyURL\",\n\t\t\tRuntimeVariables.replace(\"/virtual-hosting-test-community\"));\n\t\tselenium.click(RuntimeVariables.replace(\"//input[@value='Save']\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tassertTrue(selenium.isTextPresent(\n\t\t\t\t\"Your request processed successfully.\"));\n\t}","commit_id":"0be3caaad78aa7a7b0461c67d6cb63cf3d12d77c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Session getSession() throws NamingException {\n\t\treturn (Session)JNDIUtil.lookup(\n\t\t\tnew InitialContext(), MAIL_SESSION, true);\n\t}","id":29377,"modified_method":"public static Session getSession() throws NamingException {\n\t\tSession session = (Session)JNDIUtil.lookup(\n\t\t\tnew InitialContext(), MAIL_SESSION, true);\n\n\t\tsession.setDebug(_log.isDebugEnabled());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tsession.getProperties().list(System.out);\n\t\t}\n\n\t\treturn session;\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void completeMessage(HttpSession ses, MailMessage mm,\n\t\t\tboolean send, long draftId, String url)\n\t\tthrows ContentException, ContentPathException, FolderException,\n\t\t\tRecipientException, StoreException {\n\n\t\ttry {\n\t\t\tif (send && Validator.isNull(mm.getTo()) &&\n\t\t\t\tValidator.isNull(mm.getCc()) && Validator.isNull(mm.getBcc())) {\n\n\t\t\t\t_log.error(\"A message with no recipients cannot be sent\");\n\t\t\t\tthrow new RecipientException();\n\t\t\t}\n\n\t\t\tString fromAddy = ((InternetAddress)mm.getFrom()).getAddress();\n\t\t\tString fromName = ((InternetAddress)mm.getFrom()).getPersonal();\n\n\t\t\tMessage message = new MimeMessage(_getSession());\n\n\t\t\tmessage.setSubject(mm.getSubject());\n\t\t\tmessage.setFrom(new InternetAddress(fromAddy, fromName));\n\t\t\tif (!Validator.isNull(mm.getTo())) {\n\t\t\t\tmessage.setRecipients(Message.RecipientType.TO, mm.getTo());\n\t\t\t}\n\t\t\tif (!Validator.isNull(mm.getCc())) {\n\t\t\t\tmessage.setRecipients(Message.RecipientType.CC, mm.getCc());\n\t\t\t}\n\t\t\tif (!Validator.isNull(mm.getBcc())) {\n\t\t\t\tmessage.setRecipients(Message.RecipientType.BCC, mm.getBcc());\n\t\t\t}\n\n\t\t\t_replaceEmbeddedImages(ses, mm, url);\n\n\t\t\tMultipart multipart = new MimeMultipart();\n\n\t\t\tBodyPart bodypart = new MimeBodyPart();\n\t\t\tbodypart.setContent(mm.getHtmlBody(), Constants.TEXT_HTML);\n\t\t\tmultipart.addBodyPart(bodypart);\n\n\t\t\tList attachments = mm.getAttachments();\n\t\t\tfor (Iterator itr = attachments.iterator(); itr.hasNext(); ) {\n\t\t\t\tMailAttachment ma = (MailAttachment)itr.next();\n\n\t\t\t\tDataSource ds = new ByteArrayDataSource(\n\t\t\t\t\tma.getContent(), ma.getContentType());\n\n\t\t\t\tBodyPart attachment = new MimeBodyPart();\n\t\t\t\tattachment.setDataHandler(new DataHandler(ds));\n\t\t\t\tattachment.setFileName(ma.getFilename());\n\t\t\t\tif (Validator.isNotNull(ma.getContentID())) {\n\t\t\t\t\tattachment.addHeader(\n\t\t\t\t\t\tConstants.CONTENT_ID, ma.getContentID());\n\t\t\t\t}\n\t\t\t\tmultipart.addBodyPart(attachment);\n\t\t\t}\n\n\t\t\tList remoteAttachments = mm.getRemoteAttachments();\n\t\t\tfor (Iterator itr = remoteAttachments.iterator(); itr.hasNext(); ) {\n\t\t\t\tRemoteMailAttachment rma = (RemoteMailAttachment)itr.next();\n\n\t\t\t\tObject [] parts = getAttachment(ses, rma.getContentPath());\n\t\t\t\tDataSource ds = new ByteArrayDataSource(\n\t\t\t\t\t(byte [])parts[0], (String)parts[1]);\n\n\t\t\t\tBodyPart attachment = new MimeBodyPart();\n\t\t\t\tattachment.setDataHandler(new DataHandler(ds));\n\t\t\t\tattachment.setFileName(rma.getFilename());\n\t\t\t\tmultipart.addBodyPart(attachment);\n\t\t\t}\n\n\t\t\tmessage.setContent(multipart);\n\t\t\tmessage.setSentDate(new Date());\n\n\t\t\tif (send) {\n\t\t\t\tTransport.send(message);\n\t\t\t\tsetCurrentFolder(ses, MAIL_SENT_NAME);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetCurrentFolder(ses, MAIL_DRAFTS_NAME);\n\t\t\t}\n\n\t\t\t_getCurrentFolder(ses).appendMessages(new Message [] { message });\n\n\t\t\tif (draftId > 0L) {\n\t\t\t\tsetCurrentFolder(ses, MAIL_DRAFTS_NAME);\n\t\t\t\tMessage msg = _getCurrentFolder(ses).getMessageByUID(draftId);\n\n\t\t\t\t_getCurrentFolder(ses).setFlags(\n\t\t\t\t\tnew Message [] { msg }, new Flags(Flags.Flag.DELETED), true);\n\t\t\t\t_getCurrentFolder(ses).expunge();\n\t\t\t}\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t_log.error(\"Error in building and sending email object\");\n\t\t\tthrow new ContentException(e);\n\t\t} catch (NamingException e) {\n\t\t\t_log.error(\"Error in building and sending email object\");\n\t\t\tthrow new ContentException(e);\n\t\t} catch (MessagingException e) {\n\t\t\t_log.error(\"Error in building and sending email object\");\n\t\t\tthrow new ContentException(e);\n\t\t}\n\t}","id":29378,"modified_method":"public static void completeMessage(\n\t\t\tHttpSession ses, MailMessage mm, boolean send, long draftId,\n\t\t\tString url)\n\t\tthrows ContentException, ContentPathException, FolderException,\n\t\t\t   RecipientException, StoreException {\n\n\t\ttry {\n\t\t\tif (send && Validator.isNull(mm.getTo()) &&\n\t\t\t\tValidator.isNull(mm.getCc()) && Validator.isNull(mm.getBcc())) {\n\n\t\t\t\t_log.error(\"A message with no recipients cannot be sent\");\n\n\t\t\t\tthrow new RecipientException();\n\t\t\t}\n\n\t\t\tString fromAddress = ((InternetAddress)mm.getFrom()).getAddress();\n\t\t\tString fromName = ((InternetAddress)mm.getFrom()).getPersonal();\n\n\t\t\tMessage message = new MimeMessage(_getSession());\n\n\t\t\tmessage.setFrom(new InternetAddress(fromAddress, fromName));\n\n\t\t\tif (!Validator.isNull(mm.getTo())) {\n\t\t\t\tmessage.setRecipients(Message.RecipientType.TO, mm.getTo());\n\t\t\t}\n\n\t\t\tif (!Validator.isNull(mm.getCc())) {\n\t\t\t\tmessage.setRecipients(Message.RecipientType.CC, mm.getCc());\n\t\t\t}\n\n\t\t\tif (!Validator.isNull(mm.getBcc())) {\n\t\t\t\tmessage.setRecipients(Message.RecipientType.BCC, mm.getBcc());\n\t\t\t}\n\n\t\t\tmessage.setSubject(mm.getSubject());\n\n\t\t\t_replaceEmbeddedImages(ses, mm, url);\n\n\t\t\tMultipart multipart = new MimeMultipart();\n\n\t\t\tBodyPart bodyPart = new MimeBodyPart();\n\n\t\t\tbodyPart.setContent(mm.getHtmlBody(), Constants.TEXT_HTML);\n\n\t\t\tmultipart.addBodyPart(bodyPart);\n\n\t\t\tList attachments = mm.getAttachments();\n\n\t\t\tIterator itr = attachments.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tMailAttachment ma = (MailAttachment)itr.next();\n\n\t\t\t\tDataSource ds = new ByteArrayDataSource(\n\t\t\t\t\tma.getContent(), ma.getContentType());\n\n\t\t\t\tBodyPart attachment = new MimeBodyPart();\n\n\t\t\t\tattachment.setDataHandler(new DataHandler(ds));\n\t\t\t\tattachment.setFileName(ma.getFilename());\n\n\t\t\t\tif (Validator.isNotNull(ma.getContentID())) {\n\t\t\t\t\tattachment.addHeader(\n\t\t\t\t\t\tConstants.CONTENT_ID, ma.getContentID());\n\t\t\t\t}\n\n\t\t\t\tmultipart.addBodyPart(attachment);\n\t\t\t}\n\n\t\t\tList remoteAttachments = mm.getRemoteAttachments();\n\n\t\t\titr = remoteAttachments.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tRemoteMailAttachment rma = (RemoteMailAttachment)itr.next();\n\n\t\t\t\tObject[] parts = getAttachment(ses, rma.getContentPath());\n\n\t\t\t\tDataSource ds = new ByteArrayDataSource(\n\t\t\t\t\t(byte[])parts[0], (String)parts[1]);\n\n\t\t\t\tBodyPart attachment = new MimeBodyPart();\n\n\t\t\t\tattachment.setDataHandler(new DataHandler(ds));\n\t\t\t\tattachment.setFileName(rma.getFilename());\n\n\t\t\t\tmultipart.addBodyPart(attachment);\n\t\t\t}\n\n\t\t\tmessage.setContent(multipart);\n\t\t\tmessage.setSentDate(new Date());\n\n\t\t\tif (send) {\n\t\t\t\tTransport.send(message);\n\n\t\t\t\tsetCurrentFolder(ses, MAIL_SENT_NAME);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetCurrentFolder(ses, MAIL_DRAFTS_NAME);\n\t\t\t}\n\n\t\t\tIMAPFolder folder = _getCurrentFolder(ses);\n\n\t\t\tfolder.appendMessages(new Message[] {message});\n\n\t\t\tif (draftId > 0L) {\n\t\t\t\tsetCurrentFolder(ses, MAIL_DRAFTS_NAME);\n\n\t\t\t\tfolder = _getCurrentFolder(ses);\n\n\t\t\t\tMessage msg = folder.getMessageByUID(draftId);\n\n\t\t\t\tfolder.setFlags(\n\t\t\t\t\tnew Message[] {msg}, new Flags(Flags.Flag.DELETED), true);\n\n\t\t\t\tfolder.expunge();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Error in building and sending email object\");\n\n\t\t\tthrow new ContentException(e);\n\t\t}\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static IMAPFolder _getFolder(HttpSession ses, String folderName)\n\t\tthrows FolderException, StoreException {\n\n\t\tIMAPFolder folder = null;\n\n\t\ttry {\n\t\t\tif (Validator.isNull(folderName)) {\n\t\t\t\tfolderName = MAIL_INBOX_NAME;\n\t\t\t}\n\t\t\telse if (!folderName.equals(MAIL_INBOX_NAME) &&\n\t\t\t\t!folderName.startsWith(MAIL_BOX_STYLE)) {\n\n\t\t\t\tfolderName = MAIL_BOX_STYLE + folderName;\n\t\t\t}\n\n\t\t\tfolder = (IMAPFolder)ses.getAttribute(WebKeys.MAIL_FOLDER);\n\n\t\t\tif (folder != null) {\n\t\t\t\tif (!folder.getName().equals(folderName)) {\n\t\t\t\t\t_closeFolder(ses);\n\n\t\t\t\t\tfolder = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (folder == null) {\n\t\t\t\tfolder = (IMAPFolder)_getStore(ses).getFolder(folderName);\n\t\t\t\tfolder.open(IMAPFolder.READ_WRITE);\n\n\t\t\t\tses.setAttribute(WebKeys.MAIL_FOLDER, folder);\n\t\t\t\tses.removeAttribute(WebKeys.MAIL_MESSAGE);\n\t\t\t}\n\t\t}\n\t\tcatch (MessagingException ex) {\n\t\t\t_log.error(\"Error trying to access folder: \" + folderName);\n\t\t\tthrow new FolderException(ex);\n\t\t}\n\n\t\treturn folder;\n\t}","id":29379,"modified_method":"private static IMAPFolder _getFolder(HttpSession ses, String folderName)\n\t\tthrows FolderException, StoreException {\n\n\t\tIMAPFolder folder = null;\n\n\t\ttry {\n\t\t\tif (Validator.isNull(folderName)) {\n\t\t\t\tfolderName = MAIL_INBOX_NAME;\n\t\t\t}\n\t\t\telse if (!folderName.equals(MAIL_INBOX_NAME) &&\n\t\t\t\t!folderName.startsWith(MAIL_BOX_STYLE)) {\n\n\t\t\t\tfolderName = MAIL_BOX_STYLE + folderName;\n\t\t\t}\n\n\t\t\tfolder = (IMAPFolder)ses.getAttribute(WebKeys.MAIL_FOLDER);\n\n\t\t\tif (folder != null) {\n\t\t\t\tif (!folder.getName().equals(folderName)) {\n\t\t\t\t\t_closeFolder(ses);\n\n\t\t\t\t\tfolder = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (folder == null) {\n\t\t\t\tfolder = (IMAPFolder)_getStore(ses).getFolder(folderName);\n\t\t\t\tfolder.open(IMAPFolder.READ_WRITE);\n\n\t\t\t\tses.setAttribute(WebKeys.MAIL_FOLDER, folder);\n\t\t\t\tses.removeAttribute(WebKeys.MAIL_MESSAGE);\n\t\t\t}\n\t\t}\n\t\tcatch (MessagingException ex) {\n\t\t\t_log.error(\"Error trying to access folder \" + folderName);\n\t\t\tthrow new FolderException(ex);\n\t\t}\n\n\t\treturn folder;\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteMessages(HttpSession ses, long [] messageUIDs)\n\t\tthrows FolderException, StoreException {\n\n\t\ttry {\n\t\t\tIMAPFolder folder = _getCurrentFolder(ses);\n\t\t\tif (!folder.getName().equals(MAIL_TRASH_NAME)) {\n\t\t\t\tmoveMessages(ses, messageUIDs, MAIL_TRASH_NAME);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMessage [] msgs =\n\t\t\t\t\t_getCurrentFolder(ses).getMessagesByUID(messageUIDs);\n\n\t\t\t\t_getCurrentFolder(ses).setFlags(\n\t\t\t\t\tmsgs, new Flags(Flags.Flag.DELETED), true);\n\t\t\t\t_getCurrentFolder(ses).expunge();\n\t\t\t}\n\t\t}\n\t\tcatch (MessagingException ex) {\n\t\t\t_log.error(\"Unable to delete messages\");\n\t\t\tthrow new FolderException(ex);\n\t\t}\n\t}","id":29380,"modified_method":"public static void deleteMessages(HttpSession ses, long[] messageUIDs)\n\t\tthrows FolderException, StoreException {\n\n\t\ttry {\n\t\t\tIMAPFolder folder = _getCurrentFolder(ses);\n\n\t\t\tif (!folder.getName().equals(MAIL_TRASH_NAME)) {\n\t\t\t\tmoveMessages(ses, messageUIDs, MAIL_TRASH_NAME);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMessage[] msgs = folder.getMessagesByUID(messageUIDs);\n\n\t\t\t\tfolder.setFlags(msgs, new Flags(Flags.Flag.DELETED), true);\n\n\t\t\t\tfolder.expunge();\n\t\t\t}\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\t_log.error(\"Unable to delete messages\");\n\n\t\t\tthrow new FolderException(me);\n\t\t}\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static Session _getSession() throws NamingException {\n\t\tSession session = (Session)JNDIUtil.lookup(\n\t\t\tnew InitialContext(), MAIL_SESSION);\n\n\t\tsession.setDebug(GetterUtil.getBoolean(\n\t\t\tPropsUtil.get(PropsUtil.MAIL_SMTP_DEBUG)));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tsession.getProperties().list(System.out);\n\t\t}\n\n\t\treturn session;\n\t}","id":29381,"modified_method":"private static Session _getSession() throws NamingException {\n\t\treturn MailEngine.getSession();\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void _replaceEmbeddedImages(\n\t\t\tHttpSession ses, MailMessage mm, String actionurl)\n\t\tthrows ContentException, ContentPathException, FolderException,\n\t\t\tStoreException {\n\n\t\tString cidPrefix = ses.getId() + (new Date()).getTime();\n\n\t\tint cidCount = 0;\n\n\t\tString html = mm.getHtmlBody();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Body before content paths have been replaced:\\n\" + html);\n\t\t}\n\n\t\tint beg = html.indexOf(actionurl);\n\t\twhile (beg >= 0) {\n\t\t\tint end = html.indexOf(\"-1\", beg);\n\n\t\t\tif (end > 0) {\n\t\t\t\tend += 2;\n\n\t\t\t\tString attachmentPath = html.substring(beg, end);\n\n\t\t\t\tString fileName =\n\t\t\t\t\tHttp.getParameter(attachmentPath, \"fileName\", true);\n\t\t\t\tString contentPath =\n\t\t\t\t\tHttp.getParameter(attachmentPath, \"contentPath\", true);\n\n\t\t\t\tString cid = cidPrefix + cidCount;\n\n\t\t\t\t_log.info(\"Replacing all attachment paths '\" + attachmentPath +\n\t\t\t\t\t\t\"' with: \" + cid);\n\n\t\t\t\tObject [] parts = getAttachment(ses, contentPath);\n\n\t\t\t\tMailAttachment ma = new MailAttachment();\n\t\t\t\tma.setContent((byte [])parts[0]);\n\t\t\t\tma.setContentType((String)parts[1]);\n\t\t\t\tma.setContentID(\n\t\t\t\t\tStringPool.LESS_THAN + cid + StringPool.GREATER_THAN);\n\t\t\t\tma.setFilename(fileName);\n\t\t\t\tmm.appendAttachment(ma);\n\n\t\t\t\thtml = StringUtil.replace(html, attachmentPath, \"cid:\" + cid);\n\n\t\t\t\tcidCount++;\n\n\t\t\t\tbeg = html.indexOf(actionurl);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeg = html.indexOf(actionurl, beg + 1);\n\t\t\t}\n\t\t}\n\n\t\tif (cidCount > 0) {\n\t\t\tmm.setHtmlBody(html);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Body after content paths have been replaced:\\n\" + html);\n\t\t}\n\t}","id":29382,"modified_method":"private static void _replaceEmbeddedImages(\n\t\t\tHttpSession ses, MailMessage mm, String actionurl)\n\t\tthrows ContentException, ContentPathException, FolderException,\n\t\t\tStoreException {\n\n\t\tString cidPrefix = ses.getId() + (new Date()).getTime();\n\n\t\tint cidCount = 0;\n\n\t\tString html = mm.getHtmlBody();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Body before content paths have been replaced:\\n\" + html);\n\t\t}\n\n\t\tint beg = html.indexOf(actionurl);\n\t\twhile (beg >= 0) {\n\t\t\tint end = html.indexOf(\"-1\", beg);\n\n\t\t\tif (end > 0) {\n\t\t\t\tend += 2;\n\n\t\t\t\tString attachmentPath = html.substring(beg, end);\n\n\t\t\t\tString fileName =\n\t\t\t\t\tHttp.getParameter(attachmentPath, \"fileName\", true);\n\t\t\t\tString contentPath =\n\t\t\t\t\tHttp.getParameter(attachmentPath, \"contentPath\", true);\n\n\t\t\t\tString cid = cidPrefix + cidCount;\n\n\t\t\t\t_log.info(\"Replacing all attachment paths '\" + attachmentPath +\n\t\t\t\t\t\t\"' with \" + cid);\n\n\t\t\t\tObject[] parts = getAttachment(ses, contentPath);\n\n\t\t\t\tMailAttachment ma = new MailAttachment();\n\t\t\t\tma.setContent((byte[])parts[0]);\n\t\t\t\tma.setContentType((String)parts[1]);\n\t\t\t\tma.setContentID(\n\t\t\t\t\tStringPool.LESS_THAN + cid + StringPool.GREATER_THAN);\n\t\t\t\tma.setFilename(fileName);\n\t\t\t\tmm.appendAttachment(ma);\n\n\t\t\t\thtml = StringUtil.replace(html, attachmentPath, \"cid:\" + cid);\n\n\t\t\t\tcidCount++;\n\n\t\t\t\tbeg = html.indexOf(actionurl);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeg = html.indexOf(actionurl, beg + 1);\n\t\t\t}\n\t\t}\n\n\t\tif (cidCount > 0) {\n\t\t\tmm.setHtmlBody(html);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Body after content paths have been replaced:\\n\" + html);\n\t\t}\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static Object [] _getAttachmentFromPath(\n\t\t\tPart part, String mimePath)\n\t\tthrows ContentPathException, IOException, MessagingException {\n\n\t\tint index = GetterUtil.getInteger(\n\t\t\tStringUtil.split(mimePath.substring(1), StringPool.PERIOD)[0]);\n\n\t\tif (part.getContent() instanceof Multipart) {\n    \t\tString prefix = Integer.toString(index) + StringPool.PERIOD;\n\n            Multipart mp = (Multipart)part.getContent();\n\n            for (int i = 0; i < mp.getCount(); i++) {\n        \t\tif (index == i) {\n        \t\t\treturn _getAttachmentFromPath(mp.getBodyPart(i),\n        \t\t\t\tmimePath.substring(prefix.length()));\n        \t\t}\n        \t}\n\n        \tthrow new ContentPathException();\n        }\n\t\telse if (index != -1) {\n        \tthrow new ContentPathException();\n\t\t}\n\n\t\tInputStream in = part.getInputStream();\n\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n\t\tbyte[] buffer = new byte[8192];\n\t\tint count = 0;\n\n\t\twhile ((count = in.read(buffer)) >= 0) {\n\t\t\tbaos.write(buffer,0,count);\n\t\t}\n\t\tin.close();\n\n\t\tObject [] parts = new Object[] {\n\t\t\tbaos.toByteArray(), part.getContentType()\n\t\t};\n\n\t\treturn parts;\n\t}","id":29383,"modified_method":"private static Object[] _getAttachmentFromPath(Part part, String mimePath)\n\t\tthrows ContentPathException, IOException, MessagingException {\n\n\t\tint index = GetterUtil.getInteger(\n\t\t\tStringUtil.split(mimePath.substring(1), StringPool.PERIOD)[0]);\n\n\t\tif (part.getContent() instanceof Multipart) {\n    \t\tString prefix = Integer.toString(index) + StringPool.PERIOD;\n\n            Multipart mp = (Multipart)part.getContent();\n\n            for (int i = 0; i < mp.getCount(); i++) {\n        \t\tif (index == i) {\n        \t\t\treturn _getAttachmentFromPath(\n\t\t\t\t\t\tmp.getBodyPart(i), mimePath.substring(prefix.length()));\n        \t\t}\n        \t}\n\n        \tthrow new ContentPathException();\n        }\n\t\telse if (index != -1) {\n        \tthrow new ContentPathException();\n\t\t}\n\n\t\tInputStream is = part.getInputStream();\n\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n\t\tbyte[] buffer = new byte[8192];\n\t\tint count = 0;\n\n\t\twhile ((count = is.read(buffer)) >= 0) {\n\t\t\tbaos.write(buffer,0,count);\n\t\t}\n\n\t\tis.close();\n\n\t\tObject[] parts = new Object[] {\n\t\t\tbaos.toByteArray(), part.getContentType()\n\t\t};\n\n\t\treturn parts;\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void createFolder(HttpSession ses, String folderName)\n\t\tthrows FolderException, StoreException {\n\n\t\tFolder folder = null;\n\t\ttry {\n\t\t\tfor (Iterator itr = getAllFolders(ses).iterator(); itr.hasNext(); ) {\n\t\t\t\tMailFolder mf = (MailFolder)itr.next();\n\n\t\t\t\tif (mf.getName().equals(folderName)) {\n\t\t\t\t\tthrow new FolderException(\n\t\t\t\t\t\t\"Folder \" + folderName + \" already exists\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStore store = _getStore(ses);\n\n\t\t\tif (!folderName.equals(MAIL_INBOX_NAME) &&\n\t\t\t\t!folderName.startsWith(MAIL_BOX_STYLE)) {\n\t\t\t\tfolderName = MAIL_BOX_STYLE + folderName;\n\t\t\t}\n\n\t\t\tfolder = store.getFolder(folderName);\n\t\t\tfolder.create(Folder.HOLDS_MESSAGES);\n\t\t}\n\t\tcatch (MessagingException ex) {\n\t\t\t_log.error(\"Error creating new folder: \" + folderName);\n\t\t\tthrow new FolderException(ex);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (folder != null && folder.isOpen()) {\n\t\t\t\t\tfolder.close(false);\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t}\n\t\t}\n\t}","id":29384,"modified_method":"public static void createFolder(HttpSession ses, String folderName)\n\t\tthrows FolderException, StoreException {\n\n\t\tFolder folder = null;\n\n\t\ttry {\n\t\t\tIterator itr = getAllFolders(ses).iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tMailFolder mf = (MailFolder)itr.next();\n\n\t\t\t\tif (mf.getName().equals(folderName)) {\n\t\t\t\t\tthrow new FolderException(\n\t\t\t\t\t\t\"Folder \" + folderName + \" already exists\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStore store = _getStore(ses);\n\n\t\t\tif (!folderName.equals(MAIL_INBOX_NAME) &&\n\t\t\t\t!folderName.startsWith(MAIL_BOX_STYLE)) {\n\n\t\t\t\tfolderName = MAIL_BOX_STYLE + folderName;\n\t\t\t}\n\n\t\t\tfolder = store.getFolder(folderName);\n\n\t\t\tfolder.create(Folder.HOLDS_MESSAGES);\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\t_log.error(\"Error creating new folder \" + folderName);\n\n\t\t\tthrow new FolderException(me);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif ((folder != null) && folder.isOpen()) {\n\t\t\t\t\tfolder.close(false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void _replaceContentIds(MailMessage mm, String url) {\n\t\tList list = mm.getRemoteAttachments();\n\n\t\tString body = mm.getHtmlBody();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Body before CIDs have been replaced:\\n\" + body);\n\t\t}\n\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tRemoteMailAttachment rma = (RemoteMailAttachment)list.get(i);\n\n\t\t\tif (Validator.isNotNull(rma.getContentID())) {\n\t\t\t\tString cid = rma.getContentID();\n\n\t\t\t\tif (cid.startsWith(StringPool.LESS_THAN) &&\n\t\t\t\t\tcid.endsWith(StringPool.GREATER_THAN)) {\n\n\t\t\t\t\tcid = \"cid:\" + cid.substring(1, cid.length() - 1);\n\t\t\t\t}\n\n\t\t\t\tString remotePath = url + \"fileName=\" + rma.getFilename() +\n\t\t\t\t\t\"&contentPath=\" + rma.getContentPath();\n\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Replacing all CIDs '\" + cid + \"' with: \" + remotePath);\n\n\t\t\t\tbody = StringUtil.replace(body, cid, remotePath);\n\n\t\t\t\tlist.remove(i);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Body after CIDs have been replaced:\\n\" + body);\n\t\t}\n\n\t\tmm.setHtmlBody(body);\n\t}","id":29385,"modified_method":"private static void _replaceContentIds(MailMessage mm, String url) {\n\t\tList list = mm.getRemoteAttachments();\n\n\t\tString body = mm.getHtmlBody();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Body before CIDs have been replaced:\\n\" + body);\n\t\t}\n\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tRemoteMailAttachment rma = (RemoteMailAttachment)list.get(i);\n\n\t\t\tif (Validator.isNotNull(rma.getContentID())) {\n\t\t\t\tString cid = rma.getContentID();\n\n\t\t\t\tif (cid.startsWith(StringPool.LESS_THAN) &&\n\t\t\t\t\tcid.endsWith(StringPool.GREATER_THAN)) {\n\n\t\t\t\t\tcid = \"cid:\" + cid.substring(1, cid.length() - 1);\n\t\t\t\t}\n\n\t\t\t\tString remotePath = url + \"fileName=\" + rma.getFilename() +\n\t\t\t\t\t\"&contentPath=\" + rma.getContentPath();\n\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Replacing all CIDs '\" + cid + \"' with \" + remotePath);\n\n\t\t\t\tbody = StringUtil.replace(body, cid, remotePath);\n\n\t\t\t\tlist.remove(i);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Body after CIDs have been replaced:\\n\" + body);\n\t\t}\n\n\t\tmm.setHtmlBody(body);\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List getAllFolders(HttpSession ses)\n\t\tthrows StoreException, FolderException {\n\n\t\tList list = new ArrayList();\n\n\t\tIMAPFolder root = null;\n\n\t\ttry {\n\t\t\troot = (IMAPFolder)_getStore(ses).getDefaultFolder();\n\n\t\t\tFolder [] folders = root.list();\n\n\t\t\t_getFolders(list, folders);\n\t\t}\n\t\tcatch (MessagingException ex) {\n\t\t\tthrow new FolderException(\n\t\t\t\t\"Error trying to access the default folder\", ex);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (root != null && root.isOpen()) {\n\t\t\t\t\t\troot.close(false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}","id":29386,"modified_method":"public static List getAllFolders(HttpSession ses)\n\t\tthrows StoreException, FolderException {\n\n\t\tList list = new ArrayList();\n\n\t\tIMAPFolder root = null;\n\n\t\ttry {\n\t\t\troot = (IMAPFolder)_getStore(ses).getDefaultFolder();\n\n\t\t\tFolder[] folders = root.list();\n\n\t\t\t_getFolders(list, folders);\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tthrow new FolderException(\n\t\t\t\t\"Error trying to access the default folder\", me);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif ((root != null) && root.isOpen()) {\n\t\t\t\t\troot.close(false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Object [] getAttachment(HttpSession ses, String contentPath)\n\t\tthrows ContentException, ContentPathException, FolderException,\n\t\t\tStoreException {\n\n\t\tObject [] parts = null;\n\n\t\ttry {\n\t\t\tString [] path = RemoteMailAttachment.parsePath(contentPath);\n\n\t\t\tString folderName = path[0];\n\t\t\tlong messageUID = GetterUtil.getLong(path[1]);\n\t\t\tString mimePath = path[2];\n\n\t\t\tsetCurrentFolder(ses, folderName);\n\t\t\tMessage message =\n\t\t\t\t_getCurrentFolder(ses).getMessageByUID(messageUID);\n\n\t\t\tparts = _getAttachmentFromPath(message, mimePath);\n\t\t}\n\t\tcatch (MessagingException ex) {\n\t\t\t_log.error(\n\t\t\t\t\"Error obtaining attachment from content path: \" + contentPath);\n\t\t\tthrow new ContentException(ex);\n\t\t} catch (IOException ex) {\n\t\t\t_log.error(\n\t\t\t\t\"Error obtaining attachment from content path: \" + contentPath);\n\t\t\tthrow new ContentException(ex);\n\t\t}\n\t\tcatch (ContentPathException ex) {\n\t\t\t_log.error(\"Invalid content path: \" + contentPath);\n\t\t\tthrow ex;\n\t\t}\n\n\t\treturn parts;\n\t}","id":29387,"modified_method":"public static Object[] getAttachment(HttpSession ses, String contentPath)\n\t\tthrows ContentException, ContentPathException, FolderException,\n\t\t\t   StoreException {\n\n\t\tObject[] parts = null;\n\n\t\ttry {\n\t\t\tString[] path = RemoteMailAttachment.parsePath(contentPath);\n\n\t\t\tString folderName = path[0];\n\t\t\tlong messageUID = GetterUtil.getLong(path[1]);\n\t\t\tString mimePath = path[2];\n\n\t\t\tsetCurrentFolder(ses, folderName);\n\n\t\t\tIMAPFolder folder = _getCurrentFolder(ses);\n\n\t\t\tMessage message = folder.getMessageByUID(messageUID);\n\n\t\t\tparts = _getAttachmentFromPath(message, mimePath);\n\t\t}\n\t\tcatch (ContentPathException cpe) {\n\t\t\t_log.error(\"Invalid content path \" + contentPath);\n\n\t\t\tthrow cpe;\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\n\t\t\t\t\"Error obtaining attachment from content path \" + contentPath);\n\n\t\t\tthrow new ContentException(ioe);\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\t_log.error(\n\t\t\t\t\"Error obtaining attachment from content path \" + contentPath);\n\n\t\t\tthrow new ContentException(me);\n\t\t}\n\n\t\treturn parts;\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void removeFolder(HttpSession ses, String folderName)\n\t\tthrows FolderException, StoreException {\n\n\t\ttry {\n\t\t\tif (!folderName.equals(MAIL_INBOX_NAME) &&\n\t\t\t\t!folderName.startsWith(MAIL_BOX_STYLE)) {\n\t\t\t\tfolderName = MAIL_BOX_STYLE + folderName;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < DEFAULT_FOLDERS.length; i++) {\n\t\t\t\tif (DEFAULT_FOLDERS[i].equals(folderName)) {\n\t\t\t\t\t_log.error(\"The folder \" + folderName +\n\t\t\t\t\t\t\" is a system-defined folder and cannot be changed\");\n\t\t\t\t\tthrow new FolderException();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStore store = _getStore(ses);\n\t\t\tFolder folder = store.getFolder(folderName);\n\t\t\tif (!folder.exists()) {\n\t\t\t\t_log.error(\"The folder \" + folderName +\n\t\t\t\t\t\" does not currently exist in the system\");\n\t\t\t\tthrow new FolderException();\n\t\t\t}\n\n\t\t\tfolder.delete(true);\n\t\t}\n\t\tcatch (MessagingException ex) {\n\t\t\t_log.error(\"Error trying to remove the folder: \" + folderName);\n\t\t\tthrow new FolderException(ex);\n\t\t}\n\t}","id":29388,"modified_method":"public static void removeFolder(HttpSession ses, String folderName)\n\t\tthrows FolderException, StoreException {\n\n\t\ttry {\n\t\t\tif (!folderName.equals(MAIL_INBOX_NAME) &&\n\t\t\t\t!folderName.startsWith(MAIL_BOX_STYLE)) {\n\t\t\t\tfolderName = MAIL_BOX_STYLE + folderName;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < DEFAULT_FOLDERS.length; i++) {\n\t\t\t\tif (DEFAULT_FOLDERS[i].equals(folderName)) {\n\t\t\t\t\t_log.error(\"The folder \" + folderName +\n\t\t\t\t\t\t\" is a system-defined folder and cannot be changed\");\n\t\t\t\t\tthrow new FolderException();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStore store = _getStore(ses);\n\t\t\tFolder folder = store.getFolder(folderName);\n\t\t\tif (!folder.exists()) {\n\t\t\t\t_log.error(\"The folder \" + folderName +\n\t\t\t\t\t\" does not currently exist in the system\");\n\t\t\t\tthrow new FolderException();\n\t\t\t}\n\n\t\t\tfolder.delete(true);\n\t\t}\n\t\tcatch (MessagingException ex) {\n\t\t\t_log.error(\"Error trying to remove the folder \" + folderName);\n\t\t\tthrow new FolderException(ex);\n\t\t}\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static RemoteMailAttachment _getRemoteAttachment(\n\t\t\tPart part, String contentPath)\n\t\tthrows ContentException {\n\n\t\tRemoteMailAttachment rma = new RemoteMailAttachment();\n\n\t\ttry {\n\t\t\trma.setFilename(part.getFileName());\n\t\t\trma.setContentPath(contentPath);\n\t\t\tString [] contentId = part.getHeader(Constants.CONTENT_ID);\n\t\t\tif (contentId != null && contentId.length == 1) {\n\t\t\t\trma.setContentID(contentId[0]);\n\t\t\t}\n\t\t}\n\t\tcatch (MessagingException ex) {\n\t\t\t_log.error(\"Unable to properly get file name of MIME attachment\");\n\t\t\tthrow new ContentException(ex);\n\t\t}\n\n\t\treturn rma;\n\t}","id":29389,"modified_method":"private static RemoteMailAttachment _getRemoteAttachment(\n\t\t\tPart part, String contentPath)\n\t\tthrows ContentException {\n\n\t\tRemoteMailAttachment rma = new RemoteMailAttachment();\n\n\t\ttry {\n\t\t\trma.setFilename(part.getFileName());\n\t\t\trma.setContentPath(contentPath);\n\n\t\t\tString[] contentId = part.getHeader(Constants.CONTENT_ID);\n\n\t\t\tif ((contentId != null) && (contentId.length == 1)) {\n\t\t\t\trma.setContentID(contentId[0]);\n\t\t\t}\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\t_log.error(\"Unable to properly get file name of MIME attachment\");\n\n\t\t\tthrow new ContentException(me);\n\t\t}\n\n\t\treturn rma;\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void cleanup(HttpSession ses) throws StoreException {\n\t\ttry {\n\t\t\t_closeFolder(ses);\n\n\t\t\tStore store = (Store)ses.getAttribute(WebKeys.MAIL_STORE);\n\t\t\tif (store != null) {\n\t\t\t\tstore.close();\n\n\t\t\t\tses.removeAttribute(WebKeys.MAIL_STORE);\n\t\t\t}\n\n\t\t\tses.removeAttribute(WebKeys.MAIL_MESSAGE);\n\t\t}\n\t\tcatch (MessagingException e) {\n\t\t\t_log.error(\"Unable to close store\");\n\t\t\tthrow new StoreException(e);\n\t\t}\n\t}","id":29390,"modified_method":"public static void cleanUp(HttpSession ses) throws StoreException {\n\t\ttry {\n\t\t\t_closeFolder(ses);\n\n\t\t\tStore store = (Store)ses.getAttribute(WebKeys.MAIL_STORE);\n\n\t\t\tif (store != null) {\n\t\t\t\tstore.close();\n\n\t\t\t\tses.removeAttribute(WebKeys.MAIL_STORE);\n\t\t\t}\n\n\t\t\tses.removeAttribute(WebKeys.MAIL_MESSAGE);\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\t_log.error(\"Unable to close store\");\n\n\t\t\tthrow new StoreException(me);\n\t\t}\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void sessionDestroyed(HttpSessionEvent event) {\n\t\tHttpSession ses = event.getSession();\n\n\t\tPortalSessionContext.remove(ses.getId());\n\n\t\tif (ServerDetector.isWebLogic()) {\n\t\t\tPortletSessionPool.remove(ses.getId());\n\t\t}\n\n\t\ttry {\n\t\t\tString companyId = (String)ses.getAttribute(WebKeys.COMPANY_ID);\n\t\t\tString userId = (String)ses.getAttribute(WebKeys.USER_ID);\n\n\t\t\tif (companyId == null) {\n\t\t\t\t_log.warn(\"Company id is not in the session\");\n\t\t\t}\n\n\t\t\tif (userId == null) {\n\t\t\t\t_log.warn(\"User id is not in the session\");\n\t\t\t}\n\n\t\t\tif ((companyId == null) || (userId == null)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Close mail connections\n\n\t\t\tMailUtil.cleanup(ses);\n\n\t\t\t// User tracker\n\n\t\t\tMap currentUsers =\n\t\t\t\t(Map)WebAppPool.get(companyId, WebKeys.CURRENT_USERS);\n\n\t\t\tUserTracker userTracker = null;\n\n\t\t\tif (currentUsers != null) {\n\t\t\t\tuserTracker = (UserTracker)currentUsers.remove(ses.getId());\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (userTracker != null) {\n\t\t\t\t\tUserTrackerLocalServiceUtil.addUserTracker(\n\t\t\t\t\t\tuserTracker.getCompanyId(), userTracker.getUserId(),\n\t\t\t\t\t\tuserTracker.getModifiedDate(),\n\t\t\t\t\t\tuserTracker.getRemoteAddr(),\n\t\t\t\t\t\tuserTracker.getRemoteHost(), userTracker.getUserAgent(),\n\t\t\t\t\t\tuserTracker.getPaths());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e1) {\n\t\t\t\t_log.warn(e1.getMessage());\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\t\t\t_log.warn(\"Please upgrade to a servlet 2.4 compliant container\");\n\t\t}\n\t\tcatch (Exception e2) {\n\t\t\t_log.error(StackTraceUtil.getStackTrace(e2));\n\t\t}\n\n\t\t// Process session destroyed events\n\n\t\ttry {\n\t\t\tEventsProcessor.process(PropsUtil.getArray(\n\t\t\t\tPropsUtil.SERVLET_SESSION_DESTROY_EVENTS), ses);\n\t\t}\n\t\tcatch (ActionException ae) {\n\t\t\t_log.error(StackTraceUtil.getStackTrace(ae));\n\t\t}\n\t}","id":29391,"modified_method":"public void sessionDestroyed(HttpSessionEvent event) {\n\t\tHttpSession ses = event.getSession();\n\n\t\tPortalSessionContext.remove(ses.getId());\n\n\t\tif (ServerDetector.isWebLogic()) {\n\t\t\tPortletSessionPool.remove(ses.getId());\n\t\t}\n\n\t\ttry {\n\t\t\tString companyId = (String)ses.getAttribute(WebKeys.COMPANY_ID);\n\t\t\tString userId = (String)ses.getAttribute(WebKeys.USER_ID);\n\n\t\t\tif (companyId == null) {\n\t\t\t\t_log.warn(\"Company id is not in the session\");\n\t\t\t}\n\n\t\t\tif (userId == null) {\n\t\t\t\t_log.warn(\"User id is not in the session\");\n\t\t\t}\n\n\t\t\tif ((companyId == null) || (userId == null)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Close mail connections\n\n\t\t\tMailUtil.cleanUp(ses);\n\n\t\t\t// User tracker\n\n\t\t\tMap currentUsers =\n\t\t\t\t(Map)WebAppPool.get(companyId, WebKeys.CURRENT_USERS);\n\n\t\t\tUserTracker userTracker = null;\n\n\t\t\tif (currentUsers != null) {\n\t\t\t\tuserTracker = (UserTracker)currentUsers.remove(ses.getId());\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (userTracker != null) {\n\t\t\t\t\tUserTrackerLocalServiceUtil.addUserTracker(\n\t\t\t\t\t\tuserTracker.getCompanyId(), userTracker.getUserId(),\n\t\t\t\t\t\tuserTracker.getModifiedDate(),\n\t\t\t\t\t\tuserTracker.getRemoteAddr(),\n\t\t\t\t\t\tuserTracker.getRemoteHost(), userTracker.getUserAgent(),\n\t\t\t\t\t\tuserTracker.getPaths());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e1) {\n\t\t\t\t_log.warn(e1.getMessage());\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\t\t\t_log.warn(\"Please upgrade to a servlet 2.4 compliant container\");\n\t\t}\n\t\tcatch (Exception e2) {\n\t\t\t_log.error(StackTraceUtil.getStackTrace(e2));\n\t\t}\n\n\t\t// Process session destroyed events\n\n\t\ttry {\n\t\t\tEventsProcessor.process(PropsUtil.getArray(\n\t\t\t\tPropsUtil.SERVLET_SESSION_DESTROY_EVENTS), ses);\n\t\t}\n\t\tcatch (ActionException ae) {\n\t\t\t_log.error(StackTraceUtil.getStackTrace(ae));\n\t\t}\n\t}","commit_id":"6f49b9f49a85be7e47a834bbb57449420a9d4784","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void sendMessage(\r\n\t\t\tString userId, String password, MailMessage mm) \r\n\t\tthrows Exception {\r\n\r\n\t\tEmail email = null;\r\n\t\tif (mm.isSimple()) {\r\n\t\t\tSimpleEmail se = new SimpleEmail();\r\n\t\t\tse.setMsg(mm.getPlainBody());\r\n\r\n\t\t\temail = se;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tHtmlEmail he = new HtmlEmail();\r\n\t\t\the.setMsg(mm.getPlainBody());\r\n\t\t\the.setHtmlMsg(mm.getHtmlBody());\r\n\r\n\t\t\tList attachments = mm.getAttachments();\r\n\t\t\tfor (Iterator itr = attachments.iterator(); itr.hasNext(); ) {\r\n\t\t\t\tMailAttachment ma = (MailAttachment)itr.next();\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tDataSource ds = new ByteArrayDataSource(\r\n\t\t\t\t\t\tma.getContent(), ma.getContentType());\r\n\t\t\t\t\the.attach(ds, ma.getFilename(), ma.getFilename());\r\n\t\t\t\t}\r\n\t\t\t\tcatch (Exception ex) {\r\n\t\t\t\t\tex.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\temail = he;\r\n\t\t}\r\n\r\n\t\tString fromAddy = ((InternetAddress)mm.getFrom()).getAddress();\r\n\t\tString fromName = ((InternetAddress)mm.getFrom()).getPersonal();\r\n\r\n\t\temail.setSubject(mm.getSubject());\r\n\t\temail.setHostName(_getSMTPHost());\r\n\t\temail.setAuthentication(_getLogin(userId), password);\r\n\t\temail.setFrom(fromAddy, fromName);\r\n\r\n\t\tAddress [] tos = mm.getTo();\r\n\t\tfor (int i = 0; i < tos.length; i++) {\r\n\t\t\tString toAddy = ((InternetAddress)tos[i]).getAddress();\r\n\t\t\tString toName = ((InternetAddress)tos[i]).getPersonal();\r\n\t\t\temail.addTo(toAddy, toName);\r\n\t\t}\r\n\r\n\t\tAddress [] ccs = mm.getCc();\r\n\t\tfor (int i = 0; i < ccs.length; i++) {\r\n\t\t\tString ccAddy = ((InternetAddress)ccs[i]).getAddress();\r\n\t\t\tString ccName = ((InternetAddress)ccs[i]).getPersonal();\r\n\t\t\temail.addCc(ccAddy, ccName);\r\n\t\t}\r\n\r\n\t\tAddress [] bccs = mm.getBcc();\r\n\t\tfor (int i = 0; i < bccs.length; i++) {\r\n\t\t\tString bccAddy = ((InternetAddress)bccs[i]).getAddress();\r\n\t\t\tString bccName = ((InternetAddress)bccs[i]).getPersonal();\r\n\t\t\temail.addBcc(bccAddy, bccName);\r\n\t\t}\r\n\r\n\t\temail.send();\r\n\t}","id":29392,"modified_method":"public static void sendMessage(\r\n\t\t\tString userId, String password, MailMessage mm) \r\n\t\tthrows Exception {\r\n\r\n\t\tEmail email = null;\r\n\t\tif (mm.isSimple()) {\r\n\t\t\tSimpleEmail se = new SimpleEmail();\r\n\t\t\tse.setMsg(mm.getPlainBody());\r\n\r\n\t\t\temail = se;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tHtmlEmail he = new HtmlEmail();\r\n\t\t\the.setMsg(mm.getPlainBody());\r\n\t\t\the.setHtmlMsg(mm.getHtmlBody());\r\n\r\n\t\t\tList attachments = mm.getAttachments();\r\n\t\t\tfor (Iterator itr = attachments.iterator(); itr.hasNext(); ) {\r\n\t\t\t\tMailAttachment ma = (MailAttachment)itr.next();\r\n\r\n\t\t\t\tDataSource ds = new ByteArrayDataSource(\r\n\t\t\t\t\tma.getContent(), ma.getContentType());\r\n\t\t\t\the.attach(ds, ma.getFilename(), ma.getFilename());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\temail = he;\r\n\t\t}\r\n\r\n\t\tString fromAddy = ((InternetAddress)mm.getFrom()).getAddress();\r\n\t\tString fromName = ((InternetAddress)mm.getFrom()).getPersonal();\r\n\r\n\t\temail.setSubject(mm.getSubject());\r\n\t\temail.setHostName(_getSMTPHost());\r\n\t\temail.setAuthentication(_getLogin(userId), password);\r\n\t\temail.setFrom(fromAddy, fromName);\r\n\r\n\t\tAddress [] tos = mm.getTo();\r\n\t\tfor (int i = 0; i < tos.length; i++) {\r\n\t\t\tString toAddy = ((InternetAddress)tos[i]).getAddress();\r\n\t\t\tString toName = ((InternetAddress)tos[i]).getPersonal();\r\n\t\t\temail.addTo(toAddy, toName);\r\n\t\t}\r\n\r\n\t\tAddress [] ccs = mm.getCc();\r\n\t\tfor (int i = 0; i < ccs.length; i++) {\r\n\t\t\tString ccAddy = ((InternetAddress)ccs[i]).getAddress();\r\n\t\t\tString ccName = ((InternetAddress)ccs[i]).getPersonal();\r\n\t\t\temail.addCc(ccAddy, ccName);\r\n\t\t}\r\n\r\n\t\tAddress [] bccs = mm.getBcc();\r\n\t\tfor (int i = 0; i < bccs.length; i++) {\r\n\t\t\tString bccAddy = ((InternetAddress)bccs[i]).getAddress();\r\n\t\t\tString bccName = ((InternetAddress)bccs[i]).getPersonal();\r\n\t\t\temail.addBcc(bccAddy, bccName);\r\n\t\t}\r\n\r\n\t\temail.send();\r\n\t}","commit_id":"8da8858ce5ac6292de2a3f11372700ef05042e94","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteMessages(\r\n\t\t\tString userId, String password, int [] messageUIDs) \r\n\t\tthrows Exception {\r\n\r\n\t\tif (!_getCurrentFolder(userId).getName().equals(MAIL_TRASH_NAME)) {\r\n\t\t\tmoveMessages(userId, password, messageUIDs, MAIL_TRASH_NAME);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tMessage [] msgs = _getCurrentFolder(userId).getMessages(messageUIDs);\r\n\t\t\t_getCurrentFolder(userId).setFlags(\r\n\t\t\t\tmsgs, new Flags(Flags.Flag.DELETED), true);\r\n\t\t\t_getCurrentFolder(userId).expunge();\r\n\t\t}\r\n\t}","id":29393,"modified_method":"public static void deleteMessages(\r\n\t\t\tString userId, String password, int [] messageUIDs) \r\n\t\tthrows Exception {\r\n\r\n\t\tFolder folder = _getCurrentFolder(userId); \r\n\t\tif (!folder.getName().equals(MAIL_TRASH_NAME)) {\r\n\t\t\tmoveMessages(userId, password, messageUIDs, MAIL_TRASH_NAME);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tMessage [] msgs = \r\n\t\t\t\t_getCurrentFolder(userId).getMessages(messageUIDs);\r\n\r\n\t\t\t_getCurrentFolder(userId).setFlags(\r\n\t\t\t\tmsgs, new Flags(Flags.Flag.DELETED), true);\r\n\t\t}\r\n\t}","commit_id":"8da8858ce5ac6292de2a3f11372700ef05042e94","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void moveMessages(String userId, String password, \r\n\t\t\tint [] messageUIDs, String toFolderName)\r\n\t\tthrows Exception {\r\n\t\t\r\n\t\tif (_getCurrentFolder(userId).getName().equals(toFolderName)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tFolder toFolder = null;\r\n\t\ttry {\r\n\t\t\ttoFolder = _getStore(userId, password).getFolder(toFolderName);\r\n\t\t\ttoFolder.open(Folder.READ_WRITE);\r\n\t\t\t\r\n\t\t\tMessage [] msgs = _getCurrentFolder(userId).getMessages(messageUIDs);\r\n\t\r\n\t\t\t_getCurrentFolder(userId).copyMessages(msgs, toFolder);\r\n\t\t\t_getCurrentFolder(userId).setFlags(\r\n\t\t\t\tmsgs, new Flags(Flags.Flag.DELETED), true);\r\n\t\t\t_getCurrentFolder(userId).expunge();\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tif (toFolder != null && toFolder.isOpen()) {\r\n\t\t\t\ttoFolder.close(false);\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":29394,"modified_method":"public static void moveMessages(String userId, String password, \r\n\t\t\tint [] messageUIDs, String toFolderName)\r\n\t\tthrows Exception {\r\n\t\t\r\n\t\tif (_getCurrentFolder(userId).getName().equals(toFolderName)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tFolder toFolder = null;\r\n\t\ttry {\r\n\t\t\ttoFolder = _getStore(userId, password).getFolder(toFolderName);\r\n\t\t\ttoFolder.open(Folder.READ_WRITE);\r\n\t\t\t\r\n\t\t\tMessage [] msgs = _getCurrentFolder(userId).getMessages(messageUIDs);\r\n\t\r\n\t\t\t_getCurrentFolder(userId).copyMessages(msgs, toFolder);\r\n\t\t\t_getCurrentFolder(userId).setFlags(\r\n\t\t\t\tmsgs, new Flags(Flags.Flag.DELETED), true);\r\n\t\t}\r\n\t\tcatch(Exception e) {\r\n\t\t\t_log.error(e);\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tif (toFolder != null && toFolder.isOpen()) {\r\n\t\t\t\ttoFolder.close(true);\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"8da8858ce5ac6292de2a3f11372700ef05042e94","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void _closeFolder(String userId) throws Exception {\r\n\t\tFolder folder = (Folder)_folder.get(userId);\r\n\r\n\t\tif (folder != null && folder.isOpen()) {\r\n\t\t\tfolder.close(false);\r\n\t\t\t_folder.remove(userId);\r\n\t\t}\r\n\t}","id":29395,"modified_method":"private static void _closeFolder(String userId) {\r\n\t\tFolder folder = (Folder)_folder.get(userId);\r\n\r\n\t\tif (folder != null && folder.isOpen()) {\r\n\t\t\ttry {\r\n\t\t\t\tfolder.close(false);\r\n\t\t\t}\r\n\t\t\tcatch (MessagingException me) {\r\n\t\t\t\t_log.error(\"Unknown error while closing current folder\");\r\n\t\t\t}\r\n\r\n\t\t\t_folder.remove(userId);\r\n\t\t}\r\n\t}","commit_id":"8da8858ce5ac6292de2a3f11372700ef05042e94","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static MailMessage getMessage(String userId, int messageUID)\r\n\t\tthrows Exception {\r\n\r\n\t\tMessage message = _getCurrentFolder(userId).getMessage(messageUID);\r\n\t\t\r\n\t\tMailMessage mm = new MailMessage();\r\n\t\tmm.setSubject(message.getSubject());\r\n\t\tmm.setFrom(message.getFrom()[0]);\r\n\t\tmm.setTo(message.getRecipients(RecipientType.TO));\r\n\t\tmm.setCc(message.getRecipients(RecipientType.CC));\r\n\t\tmm.setBcc(message.getRecipients(RecipientType.BCC));\r\n\t\tmm = _getContent(message, mm);\r\n\r\n\t\treturn mm;\r\n\t}","id":29396,"modified_method":"public static MailMessage getMessage(String userId, int messageUID)\r\n\t\tthrows Exception {\r\n\r\n\t\tMailMessage mm = null;\r\n\r\n\t\ttry {\r\n\t\t\tMessage message = _getCurrentFolder(userId).getMessage(messageUID);\r\n\r\n\t\t\tmm = new MailMessage();\r\n\t\t\tmm.setSubject(message.getSubject());\r\n\t\t\tmm.setFrom(message.getFrom()[0]);\r\n\t\t\tmm.setTo(message.getRecipients(RecipientType.TO));\r\n\t\t\tmm.setCc(message.getRecipients(RecipientType.CC));\r\n\t\t\tmm.setBcc(message.getRecipients(RecipientType.BCC));\r\n\t\t\tmm = _getContent(message, mm);\r\n\t\t}\r\n\t\tcatch (MessagingException me) {\r\n\t\t\t_log.error(me);\r\n\t\t\tthrow me;\r\n\t\t}\r\n\t\t\t\r\n\t\treturn mm;\r\n\t}","commit_id":"8da8858ce5ac6292de2a3f11372700ef05042e94","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List getEnvelopes(String userId) \r\n\t\tthrows Exception {\r\n\r\n\t\tList envelopes = new ArrayList();\r\n\r\n        Message [] msgs = _getCurrentFolder(userId).getMessages();\r\n\r\n        FetchProfile fp = new FetchProfile();\r\n        fp.add(FetchProfile.Item.ENVELOPE);\r\n        fp.add(FetchProfile.Item.FLAGS);\r\n\r\n        _getCurrentFolder(userId).fetch(msgs, fp);\r\n\r\n        for (int i = 0; i < msgs.length; i++) {\r\n\t\t\tif (msgs[i].isExpunged()) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n        \tMailEnvelope me = new MailEnvelope();\r\n\r\n        \tif (MAIL_SENT_NAME.equals(_getCurrentFolder(userId).getName()) ||\r\n        \t\tMAIL_DRAFTS_NAME.equals(_getCurrentFolder(userId).getName())) {\r\n        \t\t\r\n\t        \tAddress [] recipients = msgs[i].getAllRecipients();\r\n\r\n\t        \tStringBuffer email = new StringBuffer();\r\n\r\n\t        \tfor (int j = 0; j < recipients.length; j++) {\r\n\t        \t\tInternetAddress ia = (InternetAddress)recipients[j];\r\n\t        \t\temail.append(\r\n\t        \t\t\tGetterUtil.get(ia.getPersonal(), ia.getAddress()));\r\n\r\n\t        \t\tif (j < recipients.length - 1) {\r\n\t        \t\t\temail.append(\", \");\r\n\t        \t\t}\r\n\t        \t}\r\n\r\n\t        \tme.setEmail(email.toString());\r\n        \t}\r\n        \telse {\r\n        \t\tAddress [] from = msgs[i].getFrom();\r\n        \t\tif (from.length > 0) {\r\n        \t\t\tInternetAddress ia = (InternetAddress)from[0];\r\n        \t\t\tme.setEmail(\r\n        \t\t\t\tGetterUtil.get(ia.getPersonal(), ia.getAddress()));\r\n        \t\t}\r\n        \t}\r\n\r\n        \tme.setDate(msgs[i].getSentDate());\r\n        \tme.setSubject(msgs[i].getSubject());\r\n        \tme.setUID(((IMAPFolder)_getCurrentFolder(userId)).getUID(msgs[i]));\r\n        \tme.setRecent(msgs[i].isSet(Flag.RECENT));\r\n        \tme.setFlagged(msgs[i].isSet(Flag.FLAGGED));\r\n        \tme.setAnswered(msgs[i].isSet(Flag.ANSWERED));\r\n\r\n        \tenvelopes.add(me);\r\n        }\r\n\r\n        return envelopes;\r\n\t}","id":29397,"modified_method":"public static List getEnvelopes(String userId) \r\n\t\tthrows Exception {\r\n\r\n\t\tList envelopes = new ArrayList();\r\n\r\n        Message [] msgs = _getCurrentFolder(userId).getMessages();\r\n\r\n        FetchProfile fp = new FetchProfile();\r\n        fp.add(FetchProfile.Item.ENVELOPE);\r\n        fp.add(FetchProfile.Item.FLAGS);\r\n\r\n        _getCurrentFolder(userId).fetch(msgs, fp);\r\n\r\n        for (int ii = msgs.length - 1; ii >= 0; ii--) {\r\n\t\t\tif (msgs[ii].isExpunged()) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n        \tMailEnvelope me = new MailEnvelope();\r\n\r\n        \tif (MAIL_SENT_NAME.equals(_getCurrentFolder(userId).getName()) ||\r\n        \t\tMAIL_DRAFTS_NAME.equals(_getCurrentFolder(userId).getName())) {\r\n        \t\t\r\n\t        \tAddress [] recipients = msgs[ii].getAllRecipients();\r\n\r\n\t        \tStringBuffer email = new StringBuffer();\r\n\r\n\t        \tfor (int j = 0; j < recipients.length; j++) {\r\n\t        \t\tInternetAddress ia = (InternetAddress)recipients[j];\r\n\t        \t\temail.append(\r\n\t        \t\t\tGetterUtil.get(ia.getPersonal(), ia.getAddress()));\r\n\r\n\t        \t\tif (j < recipients.length - 1) {\r\n\t        \t\t\temail.append(\", \");\r\n\t        \t\t}\r\n\t        \t}\r\n\r\n\t        \tme.setEmail(email.toString());\r\n        \t}\r\n        \telse {\r\n        \t\tAddress [] from = msgs[ii].getFrom();\r\n        \t\tif (from.length > 0) {\r\n        \t\t\tInternetAddress ia = (InternetAddress)from[0];\r\n        \t\t\tme.setEmail(\r\n        \t\t\t\tGetterUtil.get(ia.getPersonal(), ia.getAddress()));\r\n        \t\t}\r\n        \t}\r\n\r\n        \tme.setDate(msgs[ii].getSentDate());\r\n        \tme.setSubject(msgs[ii].getSubject());\r\n        \tme.setMsgNum(msgs[ii].getMessageNumber());\r\n        \tme.setRecent(msgs[ii].isSet(Flag.RECENT));\r\n        \tme.setFlagged(msgs[ii].isSet(Flag.FLAGGED));\r\n        \tme.setAnswered(msgs[ii].isSet(Flag.ANSWERED));\r\n\r\n        \tenvelopes.add(me);\r\n        }\r\n\r\n        return envelopes;\r\n\t}","commit_id":"8da8858ce5ac6292de2a3f11372700ef05042e94","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static Folder _getCurrentFolder(String userId)\r\n\t\tthrows Exception {\r\n\t\t\r\n\t\tFolder folder = (Folder)_folder.get(userId);\r\n\t\tif (folder != null) {\r\n\t\t\treturn folder;\r\n\t\t}\r\n\t\t\r\n\t\tthrow new Exception();\r\n\t}","id":29398,"modified_method":"private static Folder _getCurrentFolder(String userId)\r\n\t\tthrows Exception {\r\n\t\t\r\n\t\tFolder folder = (Folder)_folder.get(userId);\r\n\t\tif (folder != null) {\r\n\t\t\treturn folder;\r\n\t\t}\r\n\r\n\t\tthrow new Exception(\"A folder must first be selected\");\r\n\t}","commit_id":"8da8858ce5ac6292de2a3f11372700ef05042e94","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _getPreviewHeaders(HttpServletRequest req) {\r\n\t\tJSONObject jsonObj = new JSONObject();\r\n\t\t\t\r\n\t\ttry {\r\n\t\t\tString userId = PortalUtil.getUserId(req);\r\n\t\t\tString password = PortalUtil.getUserPassword(req);\r\n\t\t\tString folderId = ParamUtil.getString(req, \"folderId\");\t\t\t\r\n\r\n\t\t\tMailUtil.setCurrentFolder(userId, password, folderId);\r\n\r\n\t\t\tList list = MailUtil.getEnvelopes(userId);\r\n\t\t\t\r\n\t\t\tJSONArray meArray = new JSONArray();\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < list.size(); i++) {\r\n\t\t\t\tMailEnvelope me = (MailEnvelope)list.get(i);\r\n\t\t\t\tJSONObject jMe = new JSONObject();\r\n\t\t\t\t\r\n\t\t\t\tjMe.put(\"id\", me.getUID());\r\n\t\t\t\tjMe.put(\"email\", me.getEmail());\r\n\t\t\t\tjMe.put(\"subject\", me.getSubject());\r\n\t\t\t\tjMe.put(\"date\", me.getDate().toString());\r\n\t\t\t\tmeArray.put(jMe);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tjsonObj.put(\"headers\", meArray);\r\n\t\t}\r\n\t\tcatch (Exception e) {\r\n\t\t}\r\n\t\t\r\n\t\treturn jsonObj.toString();\r\n\t}","id":29399,"modified_method":"private String _getPreviewHeaders(HttpServletRequest req) {\r\n\t\tJSONObject jsonObj = new JSONObject();\r\n\t\t\t\r\n\t\ttry {\r\n\t\t\tString userId = PortalUtil.getUserId(req);\r\n\t\t\tString password = PortalUtil.getUserPassword(req);\r\n\t\t\tString folderId = ParamUtil.getString(req, \"folderId\");\t\t\t\r\n\r\n\t\t\tMailUtil.setCurrentFolder(userId, password, folderId);\r\n\r\n\t\t\tList list = MailUtil.getEnvelopes(userId);\r\n\t\t\t\r\n\t\t\tJSONArray meArray = new JSONArray();\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < list.size(); i++) {\r\n\t\t\t\tMailEnvelope me = (MailEnvelope)list.get(i);\r\n\t\t\t\tJSONObject jMe = new JSONObject();\r\n\t\t\t\t\r\n\t\t\t\tjMe.put(\"id\", me.getMsgNum());\r\n\t\t\t\tjMe.put(\"email\", me.getEmail());\r\n\t\t\t\tjMe.put(\"subject\", me.getSubject());\r\n\t\t\t\tjMe.put(\"date\", me.getDate().toString());\r\n\t\t\t\tmeArray.put(jMe);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tjsonObj.put(\"headers\", meArray);\r\n\t\t}\r\n\t\tcatch (Exception e) {\r\n\t\t}\r\n\t\t\r\n\t\treturn jsonObj.toString();\r\n\t}","commit_id":"8da8858ce5ac6292de2a3f11372700ef05042e94","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static SearchContext createSearchContext() {\n    AnActionEvent event = new AnActionEvent(null, DataManager.getInstance().getDataContext(),\n                                            \"\", new DefaultActionGroup().getTemplatePresentation(), ActionManager.getInstance(), 0);\n    SearchContext searchContext = new SearchContext();\n    searchContext.configureFromDataContext(event.getDataContext());\n    return searchContext;\n  }","id":29400,"modified_method":"private static SearchContext createSearchContext() {\n    AnActionEvent event = new AnActionEvent(null, DataManager.getInstance().getDataContext(),\n                                            \"\", new DefaultActionGroup().getTemplatePresentation(), ActionManager.getInstance(), 0);\n    return SearchContext.buildFromDataContext(event.getDataContext());\n  }","commit_id":"a829a97362ea12a8550811c816fd94114dde9509","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setCurrentFile(VirtualFile currentFile) {\n    this.currentFile = currentFile;\n  }","id":29401,"modified_method":"private SearchContext(Project project, PsiFile file) {\n    this.project = project;\n    this.file = file;\n  }","commit_id":"a829a97362ea12a8550811c816fd94114dde9509","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void configureFromDataContext(DataContext context) {\n    Project project = CommonDataKeys.PROJECT.getData(context);\n    if (project == null) {\n      project = ProjectManager.getInstance().getDefaultProject();\n    }\n    setProject(project);\n\n    setFile(CommonDataKeys.PSI_FILE.getData(context));\n    setCurrentFile(CommonDataKeys.VIRTUAL_FILE.getData(context));\n  }","id":29402,"modified_method":"public static SearchContext buildFromDataContext(DataContext context) {\n    Project project = CommonDataKeys.PROJECT.getData(context);\n    if (project == null) {\n      project = ProjectManager.getInstance().getDefaultProject();\n    }\n\n    PsiFile file = CommonDataKeys.PSI_FILE.getData(context);\n    final VirtualFile vFile = CommonDataKeys.VIRTUAL_FILE.getData(context);\n    if (vFile != null && (file == null || !vFile.equals(file.getContainingFile().getVirtualFile()))) {\n      file = PsiManager.getInstance(project).findFile(vFile);\n    }\n    return new SearchContext(project, file);\n  }","commit_id":"a829a97362ea12a8550811c816fd94114dde9509","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiFile getFile() {\n    if (currentFile != null && (file == null || !currentFile.equals(file.getContainingFile().getVirtualFile()))) {\n      file = PsiManager.getInstance(project).findFile(currentFile);\n    }\n\n    return file;\n  }","id":29403,"modified_method":"public PsiFile getFile() {\n    return file;\n  }","commit_id":"a829a97362ea12a8550811c816fd94114dde9509","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** Handles IDEA action event\n   * @param event the event of action\n   */\n  public void actionPerformed(AnActionEvent event) {\n    try {\n      searchContext.configureFromDataContext(event.getDataContext());\n\n      triggerAction(null,searchContext);\n    }\n    finally {\n      searchContext.setProject(null);\n      searchContext.setFile(null);\n      searchContext.setCurrentFile(null);\n    }\n  }","id":29404,"modified_method":"/** Handles IDEA action event\n   * @param event the event of action\n   */\n  public void actionPerformed(AnActionEvent event) {\n    triggerAction(null, SearchContext.buildFromDataContext(event.getDataContext()));\n  }","commit_id":"a829a97362ea12a8550811c816fd94114dde9509","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** Handles IDEA action event\n   * @param event the event of action\n   */\n  public void actionPerformed(AnActionEvent event) {\n    try {\n      searchContext.configureFromDataContext(event.getDataContext());\n\n      triggerAction(null,searchContext);\n    }\n    finally {\n      searchContext.setProject(null);\n      searchContext.setFile(null);\n      searchContext.setCurrentFile(null);\n    }\n  }","id":29405,"modified_method":"/** Handles IDEA action event\n   * @param event the event of action\n   */\n  public void actionPerformed(AnActionEvent event) {\n    triggerAction(null, SearchContext.buildFromDataContext(event.getDataContext()));\n  }","commit_id":"a829a97362ea12a8550811c816fd94114dde9509","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public EditPage createPage(String spaceValue, String pageValue, boolean isTerminalPage)\n    {\n        createPageInternal(spaceValue, pageValue, isTerminalPage);\n        clickCreate();\n        return new EditPage();\n    }","id":29406,"modified_method":"public EditPage createPage(String spaceValue, String pageValue, boolean isTerminalPage)\n    {\n        return createPage(null, spaceValue, pageValue, isTerminalPage);\n    }","commit_id":"d261716340388dd39c740532594a5436d6bab5d5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void createPageInternal(String spaceValue, String pageValue, boolean isTerminalPage)\n    {\n        setSpace(spaceValue);\n        setPage(pageValue);\n        // Since the default is to not create terminal pages, only set this if the user is asking to create a terminal\n        // page. This allows this API to work when using isTerminalPage = false even for simpler users which don't get\n        // to see the Terminal option.\n        if (isTerminalPage) {\n            setTerminalPage(isTerminalPage);\n        }\n    }","id":29407,"modified_method":"private void createPageInternal(String title, String spaceValue, String pageValue, boolean isTerminalPage)\n    {\n        if (title != null) {\n            setTitle(title);\n        }\n\n        if (spaceValue != null) {\n            setSpace(spaceValue);\n        }\n\n        if (pageValue != null) {\n            setPage(pageValue);\n        }\n\n        // Since the default is to not create terminal pages, only set this if the user is asking to create a terminal\n        // page. This allows this API to work when using isTerminalPage = false even for simpler users which don't get\n        // to see the Terminal option.\n        if (isTerminalPage) {\n            setTerminalPage(isTerminalPage);\n        }\n    }","commit_id":"d261716340388dd39c740532594a5436d6bab5d5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public EditPage createPageFromTemplate(String spaceValue, String pageValue, String templateValue)\n    {\n        return createPageFromTemplate(spaceValue, pageValue, templateValue, false);\n    }","id":29408,"modified_method":"public EditPage createPageFromTemplate(String spaceValue, String pageValue, String templateValue)\n    {\n        return createPageFromTemplate(null, spaceValue, pageValue, templateValue);\n    }","commit_id":"d261716340388dd39c740532594a5436d6bab5d5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setPage(String page)\n    {\n        this.pageTextField.clear();\n        this.pageTextField.sendKeys(page);\n    }","id":29409,"modified_method":"public void setPage(String page)\n    {\n        getDriver().setTextInputValue(this.pageTextField, page);\n    }","commit_id":"d261716340388dd39c740532594a5436d6bab5d5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setSpace(String space)\n    {\n        this.spaceTextField.clear();\n        this.spaceTextField.sendKeys(space);\n    }","id":29410,"modified_method":"public void setSpace(String space)\n    {\n        getDriver().setTextInputValue(this.spaceTextField, space);\n    }","commit_id":"d261716340388dd39c740532594a5436d6bab5d5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @since 7.2M1\n     */\n    public EditPage createPageFromTemplate(String spaceValue, String pageValue, String templateValue,\n        boolean isTerminalPage)\n    {\n        createPageInternal(spaceValue, pageValue, isTerminalPage);\n        setTemplate(templateValue);\n        clickCreate();\n        return new EditPage();\n    }","id":29411,"modified_method":"/**\n     * @since 7.2M1\n     */\n    public EditPage createPageFromTemplate(String spaceValue, String pageValue, String templateValue,\n        boolean isTerminalPage)\n    {\n        return createPageFromTemplate(null, spaceValue, pageValue, templateValue, isTerminalPage);\n    }","commit_id":"d261716340388dd39c740532594a5436d6bab5d5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Tests that creating a page or a space that already exists displays an error.\n     */\n    @Test\n    @IgnoreBrowser(value = \"internet.*\", version = \"8\\\\.*\", reason = \"See http://jira.xwiki.org/browse/XE-1146\")\n    public void createExistingPageAndSpace()\n    {\n        // Step 0: Setup the correct environment for the test\n\n        EntityReference existingPageReference =\n            getUtil().resolveDocumentReference(getTestClassName() + \".ExistingPage.WebHome\");\n        String existingSpaceName = getTestClassName() + \"Existing\";\n\n        // All these pages are created during this test\n        getUtil().deletePage(existingPageReference);\n        getUtil().deletePage(existingSpaceName, \"WebHome\");\n\n        // create a template to make sure that we have a template to create from\n        String templateProviderName = TEMPLATE_NAME + \"Provider\";\n        String templateContent = \"Templates are fun\";\n        String templateTitle = \"Funny templates\";\n        createTemplateAndTemplateProvider(templateProviderName, templateContent, templateTitle, false);\n\n        // create a page and a space webhome\n        getUtil().createPage(existingPageReference, \"Page that already exists\", \"Existing page\");\n        getUtil().createPage(existingSpaceName, \"WebHome\", \"Some content\", \"Existing space\");\n\n        // Step 1: Create an empty page for a page that already exists\n        // First we must click on create from a page that already exists as otherwise we won't get the create UI\n        ViewPage vp = getUtil().gotoPage(existingPageReference);\n        CreatePagePage createPage = vp.createPage();\n        createPage.setSpace(getTestClassName());\n        createPage.setPage(\"ExistingPage\");\n        String currentURL = getDriver().getCurrentUrl();\n        createPage.clickCreate();\n        // make sure that we stay on the same page and that an error is displayed to the user. Maybe we should check the\n        // error\n        assertEquals(currentURL, getDriver().getCurrentUrl());\n        createPage.waitForErrorMessage();\n\n        // Step 2:  Create a page from Template for a page that already exists\n        // restart everything to make sure it's not the error before\n        vp = getUtil().gotoPage(existingPageReference);\n        createPage = vp.createPage();\n        createPage.setSpace(getTestClassName());\n        createPage.setPage(\"ExistingPage\");\n        createPage.setTemplate(getTestClassName() + \".\" + templateProviderName);\n        currentURL = getDriver().getCurrentUrl();\n        createPage.clickCreate();\n        // make sure that we stay on the same page and that an error is displayed to the user. Maybe we should check the\n        // error\n        assertEquals(currentURL, getDriver().getCurrentUrl());\n        createPage.waitForErrorMessage();\n\n        // Step 3: Create a space that already exists\n        // Since the Flamingo skin no longer supports creating a space from the UI, trigger the Space creation UI\n        // by using directly the direct action URL for it.\n        getUtil().gotoPage(getUtil().getURL(\"create\", \n                new String[] {getTestClassName(), \"ExistingPage\", \"WebHome\"}, \"tocreate=space\"));\n        CreateSpacePage createSpace = new CreateSpacePage();\n        currentURL = getDriver().getCurrentUrl();\n        // strip the parameters out of this URL\n        currentURL =\n            currentURL.substring(0, currentURL.indexOf('?') > 0 ? currentURL.indexOf('?') : currentURL.length());\n        createSpace.createSpace(existingSpaceName);\n        String urlAfterSubmit = getDriver().getCurrentUrl();\n        urlAfterSubmit =\n            urlAfterSubmit.substring(0,\n                urlAfterSubmit.indexOf('?') > 0 ? urlAfterSubmit.indexOf('?') : urlAfterSubmit.length());\n        // make sure that we stay on the same page and that an error is displayed to the user. Maybe we should check the\n        // error\n        assertEquals(currentURL, urlAfterSubmit);\n        assertTrue(createSpace.hasError());\n    }","id":29412,"modified_method":"/**\n     * Tests that creating a page or a space that already exists displays an error.\n     */\n    @Test\n    @IgnoreBrowser(value = \"internet.*\", version = \"8\\\\.*\", reason = \"See http://jira.xwiki.org/browse/XE-1146\")\n    public void createExistingPageAndSpace()\n    {\n        // Step 0: Setup the correct environment for the test\n\n        EntityReference existingPageReference =\n            getUtil().resolveDocumentReference(getTestClassName() + \".ExistingPage.WebHome\");\n        String existingSpaceName = getTestClassName() + \"Existing\";\n\n        // All these pages are created during this test\n        getUtil().deletePage(existingPageReference);\n        getUtil().deletePage(existingSpaceName, \"WebHome\");\n\n        // create a template to make sure that we have a template to create from\n        String templateProviderName = TEMPLATE_NAME + \"Provider\";\n        String templateContent = \"Templates are fun\";\n        String templateTitle = \"Funny templates\";\n        createTemplateAndTemplateProvider(templateProviderName, templateContent, templateTitle, false);\n\n        // create a page and a space webhome\n        getUtil().createPage(existingPageReference, \"Page that already exists\", \"Existing page\");\n        getUtil().createPage(existingSpaceName, \"WebHome\", \"Some content\", \"Existing space\");\n\n        // Step 1: Create an empty page for a page that already exists\n        // First we must click on create from a page that already exists as otherwise we won't get the create UI\n        ViewPage vp = getUtil().gotoPage(existingPageReference);\n        CreatePagePage createPage = vp.createPage();\n        createPage.setSpace(getTestClassName());\n        createPage.setPage(\"ExistingPage\");\n        String currentURL = getDriver().getCurrentUrl();\n        createPage.clickCreate();\n        // make sure that we stay on the same page and that an error is displayed to the user. Maybe we should check the\n        // error\n        assertEquals(currentURL, getDriver().getCurrentUrl());\n        createPage.waitForErrorMessage();\n\n        // Step 2: Create a page from Template for a page that already exists\n        // restart everything to make sure it's not the error before\n        vp = getUtil().gotoPage(existingPageReference);\n        createPage = vp.createPage();\n        createPage.setSpace(getTestClassName());\n        createPage.setPage(\"ExistingPage\");\n        createPage.setTemplate(getTestClassName() + \".\" + templateProviderName);\n        currentURL = getDriver().getCurrentUrl();\n        createPage.clickCreate();\n        // make sure that we stay on the same page and that an error is displayed to the user. Maybe we should check the\n        // error\n        assertEquals(currentURL, getDriver().getCurrentUrl());\n        createPage.waitForErrorMessage();\n\n        // Step 3: Create a space that already exists\n        // Since the Flamingo skin no longer supports creating a space from the UI, trigger the Space creation UI\n        // by using directly the direct action URL for it.\n        getUtil().gotoPage(\n            getUtil().getURL(\"create\", new String[] {getTestClassName(), \"ExistingPage\", \"WebHome\"}, \"tocreate=space\"));\n        CreatePagePage createSpace = new CreatePagePage();\n        // Check that the terminal choice is not displayed in this mode.\n        assertFalse(createSpace.isTerminalOptionDisplayed());\n\n        currentURL = getDriver().getCurrentUrl();\n        // strip the parameters out of this URL\n        currentURL =\n            currentURL.substring(0, currentURL.indexOf('?') > 0 ? currentURL.indexOf('?') : currentURL.length());\n        // Try to create the a space (non-terminal document) that already exist.\n        createSpace.createPage(existingSpaceName, \"\", null, false);\n        String urlAfterSubmit = getDriver().getCurrentUrl();\n        urlAfterSubmit =\n            urlAfterSubmit.substring(0,\n                urlAfterSubmit.indexOf('?') > 0 ? urlAfterSubmit.indexOf('?') : urlAfterSubmit.length());\n        // make sure that we stay on the same page and that an error is displayed to the user. Maybe we should check the\n        // error\n        assertEquals(currentURL, urlAfterSubmit);\n        createSpace.waitForErrorMessage();\n    }","commit_id":"d261716340388dd39c740532594a5436d6bab5d5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Tests the creation of a page from a save and edit template, tests that the page is indeed saved.\n     */\n    @Test\n    @IgnoreBrowsers({\n    @IgnoreBrowser(value = \"internet.*\", version = \"8\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1146\"),\n    @IgnoreBrowser(value = \"internet.*\", version = \"9\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1177\")\n    })\n    public void createPageWithSaveAndEditTemplate()\n    {\n        EntityReference newPageReference = getUtil().resolveDocumentReference(getTestClassName() + \".NewPage.WebHome\");\n        getUtil().deletePage(newPageReference);\n\n        // Create a template\n        String templateProviderName = TEMPLATE_NAME + \"Provider\";\n        String templateContent = \"Templates are fun\";\n        String templateTitle = \"Funny templates\";\n        String templateProviderFullName = getTestClassName() + \".\" + templateProviderName;\n        ViewPage templatePage =\n            createTemplateAndTemplateProvider(templateProviderName, templateContent, templateTitle, true);\n\n        // create the page\n        CreatePagePage createPage = templatePage.createPage();\n        EditPage editCreatedPage =\n            createPage.createPageFromTemplate(getTestClassName(), \"NewPage\", templateProviderFullName);\n        // and now cancel it\n        ViewPage newPage = editCreatedPage.clickCancel();\n        // make sure we're not in unexisting page\n        assertTrue(newPage.exists());\n        // we should be in view mode (useless check since the impl of isNonExisting page calls it anyway)\n        assertTrue(getUtil().isInViewMode());\n        // make sure it's the page we want\n        assertEquals(getTestClassName() + \".NewPage\", newPage.getMetaDataValue(\"space\"));\n        assertEquals(\"WebHome\", newPage.getMetaDataValue(\"page\"));\n        // and now test the title is the name of the page and the content is the one from the template\n        assertEquals(\"NewPage\", newPage.getDocumentTitle());\n        assertEquals(templateContent, newPage.getContent());\n        // and the parent, it should be the template provider, since that's where we created it from\n        assertEquals(\"CreatePageTest NewPage\", newPage.getBreadcrumbContent());\n    }","id":29413,"modified_method":"/**\n     * Tests the creation of a page from a save and edit template, tests that the page is indeed saved.\n     */\n    @Test\n    @IgnoreBrowsers({\n    @IgnoreBrowser(value = \"internet.*\", version = \"8\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1146\"),\n    @IgnoreBrowser(value = \"internet.*\", version = \"9\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1177\")\n    })\n    public void createPageWithSaveAndEditTemplate()\n    {\n        // Cleanup of the test space for any leftovers from previous tests.\n        getUtil().deleteSpace(getTestClassName());\n\n        // Create a template\n        String templateProviderName = TEMPLATE_NAME + \"Provider\";\n        String templateContent = \"Templates are fun\";\n        String templateTitle = \"Funny templates\";\n        String templateProviderFullName = getTestClassName() + \".\" + templateProviderName;\n        ViewPage templatePage =\n            createTemplateAndTemplateProvider(templateProviderName, templateContent, templateTitle, true);\n\n        // create the page\n        CreatePagePage createPage = templatePage.createPage();\n        EditPage editCreatedPage =\n            createPage.createPageFromTemplate(getTestClassName(), \"NewPage\", templateProviderFullName);\n        // and now cancel it\n        ViewPage newPage = editCreatedPage.clickCancel();\n        // make sure we're not in unexisting page\n        assertTrue(newPage.exists());\n        // we should be in view mode (useless check since the impl of isNonExisting page calls it anyway)\n        assertTrue(getUtil().isInViewMode());\n        // make sure it's the page we want\n        assertEquals(getTestClassName() + \".NewPage\", newPage.getMetaDataValue(\"space\"));\n        assertEquals(\"WebHome\", newPage.getMetaDataValue(\"page\"));\n        // and now test the title is the name of the page and the content is the one from the template\n        assertEquals(\"NewPage\", newPage.getDocumentTitle());\n        assertEquals(templateContent, newPage.getContent());\n        // and the parent, it should be the template provider, since that's where we created it from\n        assertEquals(\"/CreatePageTest/NewPage\", newPage.getBreadcrumbContent());\n    }","commit_id":"d261716340388dd39c740532594a5436d6bab5d5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Helper function to Create both a Template and a Template Provider for the tests in this class.\n     */\n    private ViewPage createTemplateAndTemplateProvider(String templateProviderName, String templateContent,\n        String templateTitle, boolean saveAndEdit)\n    {\n        getUtil().deletePage(getTestClassName(), TEMPLATE_NAME);\n        getUtil().deletePage(getTestClassName(), TEMPLATE_NAME + \"Provider\");\n\n        // Create a Template page\n        getUtil().createPage(getTestClassName(), TEMPLATE_NAME, templateContent, templateTitle);\n\n        // Create a Template Provider\n        TemplatesAdministrationSectionPage sectionPage = TemplatesAdministrationSectionPage.gotoPage();\n        TemplateProviderInlinePage templateProviderInline =\n            sectionPage.createTemplateProvider(getTestClassName(), templateProviderName);\n        templateProviderInline.setTemplateName(\"Test Template\");\n        templateProviderInline.setTemplate(getTestClassName() + \".\" + TEMPLATE_NAME);\n        if (saveAndEdit) {\n            templateProviderInline.setActionOnCreate(TemplateProviderInlinePage.ACTION_SAVEANDEDIT);\n        }\n        return templateProviderInline.clickSaveAndView();\n    }","id":29414,"modified_method":"/**\n     * Helper function to Create both a Template and a Template Provider for the tests in this class.\n     */\n    private ViewPage createTemplateAndTemplateProvider(String templateProviderName, String templateContent,\n        String templateTitle, boolean saveAndEdit)\n    {\n        // Cleanup of the test space for any leftovers from previous tests.\n        getUtil().deleteSpace(getTestClassName());\n\n        // Create a Template page\n        getUtil().createPage(getTestClassName(), TEMPLATE_NAME, templateContent, templateTitle);\n\n        // Create a Template Provider\n        TemplatesAdministrationSectionPage sectionPage = TemplatesAdministrationSectionPage.gotoPage();\n        TemplateProviderInlinePage templateProviderInline =\n            sectionPage.createTemplateProvider(getTestClassName(), templateProviderName);\n        templateProviderInline.setTemplateName(\"Test Template\");\n        templateProviderInline.setTemplate(getTestClassName() + \".\" + TEMPLATE_NAME);\n        if (saveAndEdit) {\n            templateProviderInline.setActionOnCreate(TemplateProviderInlinePage.ACTION_SAVEANDEDIT);\n        }\n        return templateProviderInline.clickSaveAndView();\n    }","commit_id":"d261716340388dd39c740532594a5436d6bab5d5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Tests if a new page can be created from a template.\n     */\n    @Test\n    @IgnoreBrowsers({\n    @IgnoreBrowser(value = \"internet.*\", version = \"8\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1146\"),\n    @IgnoreBrowser(value = \"internet.*\", version = \"9\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1177\")\n    })\n    public void createPagesFromTemplate()\n    {\n        // Step 0: Setup the correct environment for the test\n\n        // All these pages are created during this test\n        getUtil().deletePage(getTestClassName(), getTestMethodName());\n        EntityReference templateInstanceReference =\n            getUtil().resolveDocumentReference(getTestClassName() + \".\" + TEMPLATE_NAME + \"Instance\" + \".WebHome\");\n        getUtil().deletePage(templateInstanceReference);\n        getUtil().deletePage(getTestClassName(), \"NewPage\");\n        getUtil().deletePage(getTestClassName(), TEMPLATE_NAME + \"UnexistingInstance\");\n        getUtil().deletePage(getTestClassName(), \"EmptyPage\");\n\n        String templateContent = \"Test Template Content\";\n        String templateTitle = \"Test Template Title\";\n        String templateProviderName = TEMPLATE_NAME + \"Provider\";\n        String templateProviderFullName = getTestClassName() + \".\" + templateProviderName;\n\n        // Step 1: Create a Template and a Template Provider and try to create a new page by using the Add Menu and\n        //         using the created Template\n\n        ViewPage templateProviderView =\n            createTemplateAndTemplateProvider(templateProviderName, templateContent, templateTitle, false);\n\n        // Create the new document from template\n        CreatePagePage createPagePage = templateProviderView.createPage();\n        // Save the number of available templates so that we can make some checks later on.\n        int availableTemplateSize = createPagePage.getAvailableTemplateSize();\n        String templateInstanceName = TEMPLATE_NAME + \"Instance\";\n        EditPage templateInstanceEditWysiwyg = createPagePage.createPageFromTemplate(getTestClassName(),\n            templateInstanceName, templateProviderFullName);\n        WikiEditPage templateInstanceEdit = templateInstanceEditWysiwyg.clickSaveAndView().editWiki();\n\n        // Verify template instance content\n        assertEquals(templateInstanceName, templateInstanceEdit.getTitle());\n        assertEquals(templateContent, templateInstanceEdit.getContent());\n        // check the parent of the template instance\n        assertEquals(templateProviderFullName, templateInstanceEdit.getParent());\n\n        // Step 2: Create a wanted link and verify that clicking it displays the Template and that we can use it.\n\n        // Put a wanted link in the template instance\n        templateInstanceEdit.setContent(\"[[NewPage]]\");\n        ViewPage vp = templateInstanceEdit.clickSaveAndView();\n\n        // Verify that clicking on the wanted link pops up a box to choose the template.\n        EntityReference wantedLinkReference =\n            getUtil().resolveDocumentReference(getTestClassName() + \".\" + TEMPLATE_NAME + \"Instance\" + \".NewPage\");\n        vp.clickWantedLink(wantedLinkReference, true);\n        List<WebElement> templates = getDriver().findElements(By.name(\"templateprovider\"));\n        // Note: We need to remove 1 to exclude the \"Empty Page\" template entry\n        assertEquals(availableTemplateSize, templates.size() - 1);\n        assertTrue(createPagePage.getAvailableTemplates().contains(templateProviderFullName));\n\n        // Step 3: Create a new page when located on a non-existing page\n\n        getUtil().gotoPage(getTestClassName(), TEMPLATE_NAME + \"UnexistingInstance\", \"view\", \"spaceRedirect=false\");\n        vp = new ViewPage();\n        assertFalse(vp.exists());\n        DocumentDoesNotExistPage unexistingPage = new DocumentDoesNotExistPage();\n        unexistingPage.clickEditThisPageToCreate();\n        CreatePagePage createUnexistingPage = new CreatePagePage();\n        // Make sure we're in create mode.\n        assertTrue(getUtil().isInCreateMode());\n        // count the available templates, make sure they're as many as before and that our template is among them\n        templates = getDriver().findElements(By.name(\"templateprovider\"));\n        // Note: We need to remove 1 to exclude the \"Empty Page\" template entry\n        assertEquals(availableTemplateSize, templates.size() - 1);\n        assertTrue(createPagePage.getAvailableTemplates().contains(templateProviderFullName));\n        // select it\n        createUnexistingPage.setTemplate(templateProviderFullName);\n        // and create\n        createUnexistingPage.clickCreate();\n        EditPage ep = new EditPage();\n        WikiEditPage unexistingPageEdit = ep.clickSaveAndView().editWiki();\n\n        // Verify template instance content\n        assertEquals(TEMPLATE_NAME + \"UnexistingInstance\", unexistingPageEdit.getTitle());\n        assertEquals(templateContent, unexistingPageEdit.getContent());\n        // test that this page has no parent\n        assertEquals(\"Main.WebHome\", unexistingPageEdit.getParent());\n\n        // Step 4: Create an empty new page when there are Templates available\n\n        // Make sure we are on a page that exists so that Add > Page will show the space and page fields\n\n        CreatePagePage createEmptyPage = unexistingPageEdit.clickCancel().createPage();\n        assertTrue(createEmptyPage.getAvailableTemplateSize() > 0);\n        EditPage editEmptyPage = createEmptyPage.createPage(getTestClassName(), \"EmptyPage\");\n        ViewPage emptyPage = editEmptyPage.clickSaveAndView();\n        // make sure it's empty\n        assertEquals(\"\", emptyPage.getContent());\n        // make sure parent is the right one\n        assertEquals(\"Welcome to the templates test space EmptyPage\", emptyPage.getBreadcrumbContent());\n        // mare sure title is the right one\n        assertEquals(\"EmptyPage\", emptyPage.getDocumentTitle());\n\n        // Step 5: Verify that restricting a Template to a space works\n\n        // Restrict the template to its own space\n        templateProviderView = getUtil().gotoPage(getTestClassName(), TEMPLATE_NAME + \"Provider\");\n        templateProviderView.editInline();\n        TemplateProviderInlinePage templateProviderInline = new TemplateProviderInlinePage();\n        List<String> allowedSpaces = new ArrayList<String>();\n        allowedSpaces.add(getTestClassName());\n        templateProviderInline.setSpaces(allowedSpaces);\n        templateProviderView = templateProviderInline.clickSaveAndView();\n\n        // Verify we can still create a page from template in the test space\n        createPagePage = templateProviderView.createPage();\n        // Make sure we get in create mode.\n        assertTrue(getUtil().isInCreateMode());\n        assertEquals(availableTemplateSize, createPagePage.getAvailableTemplateSize());\n        assertTrue(createPagePage.getAvailableTemplates().contains(templateProviderFullName));\n\n        // Modify the target space and verify the form can't be submitted\n        createPagePage.setTemplate(templateProviderFullName);\n        createPagePage.setSpace(\"Foobar\");\n        String currentURL = getDriver().getCurrentUrl();\n        createPagePage.clickCreate();\n        assertEquals(currentURL, getDriver().getCurrentUrl());\n        // and check that an error is displayed to the user\n        createPagePage.waitForFieldErrorMessage();\n\n        // Verify the template we have removed is no longer available.\n        CreatePagePage.gotoPage();\n\n        // make sure that the template provider is not in the list of templates\n        assertFalse(createPagePage.getAvailableTemplates().contains(templateProviderFullName));\n    }","id":29415,"modified_method":"/**\n     * Tests if a new page can be created from a template.\n     */\n    @Test\n    @IgnoreBrowsers({\n    @IgnoreBrowser(value = \"internet.*\", version = \"8\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1146\"),\n    @IgnoreBrowser(value = \"internet.*\", version = \"9\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1177\")\n    })\n    public void createPagesFromTemplate()\n    {\n        // Step 0: Setup the correct environment for the test\n\n        // All these pages are created during this test\n        getUtil().deleteSpace(getTestClassName());\n        getUtil().deletePage(getTestClassName(), getTestMethodName());\n        EntityReference templateInstanceReference =\n            getUtil().resolveDocumentReference(getTestClassName() + \".\" + TEMPLATE_NAME + \"Instance\" + \".WebHome\");\n        getUtil().deletePage(templateInstanceReference);\n        getUtil().deletePage(getTestClassName(), \"NewPage\");\n        getUtil().deletePage(getTestClassName(), TEMPLATE_NAME + \"UnexistingInstance\");\n        getUtil().deletePage(getTestClassName(), \"EmptyPage\");\n\n        String templateContent = \"Test Template Content\";\n        String templateTitle = \"Test Template Title\";\n        String templateProviderName = TEMPLATE_NAME + \"Provider\";\n        String templateProviderFullName = getTestClassName() + \".\" + templateProviderName;\n\n        // Step 1: Create a Template and a Template Provider and try to create a new page by using the Add Menu and\n        //         using the created Template\n\n        ViewPage templateProviderView =\n            createTemplateAndTemplateProvider(templateProviderName, templateContent, templateTitle, false);\n\n        // Create the new document from template\n        CreatePagePage createPagePage = templateProviderView.createPage();\n        // Save the number of available templates so that we can make some checks later on.\n        int availableTemplateSize = createPagePage.getAvailableTemplateSize();\n        String templateInstanceName = TEMPLATE_NAME + \"Instance\";\n        EditPage templateInstanceEditWysiwyg =\n            createPagePage.createPageFromTemplate(templateInstanceName, getTestClassName(), null,\n                templateProviderFullName);\n        WikiEditPage templateInstanceEdit = templateInstanceEditWysiwyg.clickSaveAndView().editWiki();\n\n        // Verify template instance location and content\n        assertEquals(templateInstanceName, templateInstanceEdit.getTitle());\n        assertEquals(getTestClassName() + \".\" + templateInstanceName, templateInstanceEdit.getMetaDataValue(\"space\"));\n        assertEquals(\"WebHome\", templateInstanceEdit.getMetaDataValue(\"page\"));\n        assertEquals(templateContent, templateInstanceEdit.getContent());\n        // check the parent of the template instance\n        assertEquals(templateProviderFullName, templateInstanceEdit.getParent());\n\n        // Step 2: Create a wanted link and verify that clicking it displays the Template and that we can use it.\n\n        // Put a wanted link in the template instance\n        templateInstanceEdit.setContent(\"[[NewPage]]\");\n        ViewPage vp = templateInstanceEdit.clickSaveAndView();\n\n        // Verify that clicking on the wanted link pops up a box to choose the template.\n        EntityReference wantedLinkReference =\n            getUtil().resolveDocumentReference(getTestClassName() + \".\" + TEMPLATE_NAME + \"Instance\" + \".NewPage\");\n        vp.clickWantedLink(wantedLinkReference, true);\n        List<WebElement> templates = getDriver().findElements(By.name(\"templateprovider\"));\n        // Note: We need to remove 1 to exclude the \"Empty Page\" template entry\n        assertEquals(availableTemplateSize, templates.size() - 1);\n        assertTrue(createPagePage.getAvailableTemplates().contains(templateProviderFullName));\n\n        // Step 3: Create a new page when located on a non-existing page\n\n        getUtil().gotoPage(getTestClassName(), TEMPLATE_NAME + \"UnexistingInstance\", \"view\", \"spaceRedirect=false\");\n        vp = new ViewPage();\n        assertFalse(vp.exists());\n        DocumentDoesNotExistPage unexistingPage = new DocumentDoesNotExistPage();\n        unexistingPage.clickEditThisPageToCreate();\n        CreatePagePage createUnexistingPage = new CreatePagePage();\n        // Make sure we're in create mode.\n        assertTrue(getUtil().isInCreateMode());\n        // count the available templates, make sure they're as many as before and that our template is among them\n        assertEquals(availableTemplateSize, createUnexistingPage.getAvailableTemplateSize());\n        assertTrue(createUnexistingPage.getAvailableTemplates().contains(templateProviderFullName));\n        // select it\n        createUnexistingPage.setTemplate(templateProviderFullName);\n        // and create\n        createUnexistingPage.clickCreate();\n        EditPage ep = new EditPage();\n        WikiEditPage unexistingPageEdit = ep.clickSaveAndView().editWiki();\n\n        // Verify template instance location and content\n        assertEquals(getTestClassName(), templateInstanceEdit.getMetaDataValue(\"space\"));\n        assertEquals(TEMPLATE_NAME + \"UnexistingInstance\", templateInstanceEdit.getMetaDataValue(\"page\"));\n        assertEquals(TEMPLATE_NAME + \"UnexistingInstance\", unexistingPageEdit.getTitle());\n        assertEquals(templateContent, unexistingPageEdit.getContent());\n        // test that this page has no parent\n        assertEquals(\"Main.WebHome\", unexistingPageEdit.getParent());\n\n        // Step 4: Create an empty new page when there are Templates available\n\n        // Make sure we are on a page that exists so that Add > Page will show the space and page fields\n\n        CreatePagePage createEmptyPage = unexistingPageEdit.clickCancel().createPage();\n        assertTrue(createEmptyPage.getAvailableTemplateSize() > 0);\n        EditPage editEmptyPage = createEmptyPage.createPage(getTestClassName(), \"EmptyPage\");\n        ViewPage emptyPage = editEmptyPage.clickSaveAndView();\n        // make sure it's empty\n        assertEquals(\"\", emptyPage.getContent());\n        // make sure parent is the right one\n        assertEquals(\"/\" + getTestClassName() + \"/EmptyPage\", emptyPage.getBreadcrumbContent());\n        // mare sure title is the right one\n        assertEquals(\"EmptyPage\", emptyPage.getDocumentTitle());\n\n        // Step 5: Verify that restricting a Template to a space works\n\n        // Restrict the template to its own space\n        templateProviderView = getUtil().gotoPage(getTestClassName(), TEMPLATE_NAME + \"Provider\");\n        templateProviderView.editInline();\n        TemplateProviderInlinePage templateProviderInline = new TemplateProviderInlinePage();\n        List<String> allowedSpaces = new ArrayList<String>();\n        allowedSpaces.add(getTestClassName());\n        templateProviderInline.setSpaces(allowedSpaces);\n        templateProviderView = templateProviderInline.clickSaveAndView();\n\n        // Verify we can still create a page from template in the test space\n        createPagePage = templateProviderView.createPage();\n        // Make sure we get in create mode.\n        assertTrue(getUtil().isInCreateMode());\n        assertEquals(availableTemplateSize, createPagePage.getAvailableTemplateSize());\n        assertTrue(createPagePage.getAvailableTemplates().contains(templateProviderFullName));\n\n        // Modify the target space and verify the form can't be submitted\n        createPagePage.setTemplate(templateProviderFullName);\n        createPagePage.setSpace(\"Foobar\");\n        String currentURL = getDriver().getCurrentUrl();\n        createPagePage.clickCreate();\n        assertEquals(currentURL, getDriver().getCurrentUrl());\n        // and check that an error is displayed to the user\n        createPagePage.waitForFieldErrorMessage();\n\n        // Verify the template we have removed is no longer available.\n        CreatePagePage.gotoPage();\n\n        // make sure that the template provider is not in the list of templates\n        assertFalse(createPagePage.getAvailableTemplates().contains(templateProviderFullName));\n    }","commit_id":"d261716340388dd39c740532594a5436d6bab5d5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Tests what happens when creating a page when no template is available in the specific space.\n     */\n    @Test\n    @IgnoreBrowsers({\n    @IgnoreBrowser(value = \"internet.*\", version = \"8\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1146\"),\n    @IgnoreBrowser(value = \"internet.*\", version = \"9\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1177\")\n    })\n    public void createPageWhenNoTemplateAvailable()\n    {\n        // prepare the test environment, create a test space and exclude all templates for this space\n        // create the home page of this space to make sure the space exists\n        getUtil().createPage(getTestClassName(), \"WebHome\", \"You can have fun with templates here\",\n            \"Welcome to the templates test space\");\n        // we'll create all these pages during this test\n        getUtil().deletePage(getTestClassName(), \"NewUnexistingPage\");\n        EntityReference newPageReference = getUtil().resolveDocumentReference(getTestClassName() + \".NewPage.WebHome\");\n        getUtil().deletePage(newPageReference);\n        getUtil().deletePage(getTestClassName(), \"NewLinkedPage\");\n        // go through all the templates and make sure they are disabled on this space\n        TemplatesAdministrationSectionPage sectionPage = TemplatesAdministrationSectionPage.gotoPage();\n\n        // get the links to existing templates, navigate to each of them and disable the current space\n        List<String> spacesToExclude = Collections.singletonList(getTestClassName());\n        List<WebElement> existingTemplatesLinks = sectionPage.getExistingTemplatesLinks();\n        for (int i = 0; i < existingTemplatesLinks.size(); i++) {\n            WebElement link = existingTemplatesLinks.get(i);\n            link.click();\n            ViewPage templateViewPage = new ViewPage();\n            templateViewPage.editInline();\n            TemplateProviderInlinePage providerEditPage = new TemplateProviderInlinePage();\n\n            // FIXME: Temporary until we remove the template provider type altogether and make all providers page\n            // template providers.\n            if (!providerEditPage.isPageTemplate()) {\n                providerEditPage.setPageTemplate(true);\n            }\n\n            providerEditPage.excludeSpaces(spacesToExclude);\n            providerEditPage.clickSaveAndView();\n\n            // go back to the admin page, to leave this in a valid state\n            sectionPage = TemplatesAdministrationSectionPage.gotoPage();\n            existingTemplatesLinks = sectionPage.getExistingTemplatesLinks();\n        }\n\n        // TODO: should reset these template settings at the end of the test, to leave things in the same state as they\n        // were at the beginning of the test\n\n        // and now start testing!\n\n        // 1/ create a page from the link in the page displayed when navigating to a non-existing page\n        getUtil().gotoPage(getTestClassName(), \"NewUnexistingPage\", \"view\", \"spaceRedirect=false\");\n        ViewPage newUnexistentPage = new ViewPage();\n        assertFalse(newUnexistentPage.exists());\n        DocumentDoesNotExistPage nonExistingPage = new DocumentDoesNotExistPage();\n        nonExistingPage.clickEditThisPageToCreate();\n        // make sure we're not in create mode anymore\n        assertFalse(getUtil().isInCreateMode());\n        // TODO: check that we're indeed in the edit mode of space.NewUnexitingPage\n        EditPage editNewUnexistingPage = new EditPage();\n        assertEquals(getTestClassName(), editNewUnexistingPage.getMetaDataValue(\"space\"));\n        assertEquals(\"NewUnexistingPage\", editNewUnexistingPage.getMetaDataValue(\"page\"));\n\n        // 2/ create a page from the create menu on an existing page, by filling in space and name\n        ViewPage spaceHomePage = getUtil().gotoPage(getTestClassName(), \"WebHome\");\n        CreatePagePage createNewPage = spaceHomePage.createPage();\n        // we expect no templates available\n        assertEquals(0, createNewPage.getAvailableTemplateSize());\n        // fill in data and create the page\n        createNewPage.setSpace(getTestClassName());\n        createNewPage.setPage(\"NewPage\");\n        createNewPage.clickCreate();\n        // we expect to go to the edit mode of the new page\n        assertFalse(getUtil().isInCreateMode());\n        EditPage editNewPage = new EditPage();\n        assertEquals(getTestClassName() + \".NewPage\", editNewPage.getMetaDataValue(\"space\"));\n        assertEquals(\"WebHome\", editNewPage.getMetaDataValue(\"page\"));\n\n        // 3/ create a page from a link in another page\n        WikiEditPage editNewPageWiki = editNewPage.clickSaveAndView().editWiki();\n        // put a link to the new page to create\n        editNewPageWiki.setContent(\"[[NewLinkedPage]]\");\n        ViewPage newPage = editNewPageWiki.clickSaveAndView();\n        // no templates are available, so we don't expect a panel with a list of templates, we just expect it goes\n        // directly to edit mode of the new page\n        // it would be nice to be able to test here that the create page panel is not displayed, ever. However, we can't\n        // since we need to wait for that time, and we don't know how much is never.\n        EntityReference wantedLinkReference =\n            getUtil().resolveDocumentReference(getTestClassName() + \".NewPage.NewLinkedPage\");\n        newPage.clickWantedLink(wantedLinkReference, false);\n        EditPage editNewLinkedPage = new EditPage();\n        // since the edit mode loads as a result of a redirect that comes from a async call made by the click, we need\n        // to wait for the page to load\n        getDriver().waitUntilElementIsVisible(By.xpath(\"//div[@id='mainEditArea']\"));\n        assertEquals(getTestClassName() + \".NewPage\", editNewLinkedPage.getMetaDataValue(\"space\"));\n        assertEquals(\"NewLinkedPage\", editNewLinkedPage.getMetaDataValue(\"page\"));\n    }","id":29416,"modified_method":"/**\n     * Tests what happens when creating a page when no template is available in the specific space.\n     */\n    @Test\n    @IgnoreBrowsers({\n    @IgnoreBrowser(value = \"internet.*\", version = \"8\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1146\"),\n    @IgnoreBrowser(value = \"internet.*\", version = \"9\\\\.*\", reason=\"See http://jira.xwiki.org/browse/XE-1177\")\n    })\n    public void createPageWhenNoTemplateAvailable()\n    {\n        // We'll create all these pages during this test\n        getUtil().deleteSpace(getTestClassName());\n        EntityReference newPageReference = getUtil().resolveDocumentReference(getTestClassName() + \".NewPage.WebHome\");\n        getUtil().deletePage(newPageReference);\n\n        // prepare the test environment, create a test space and exclude all templates for this space\n        // create the home page of this space to make sure the space exists\n        getUtil().createPage(getTestClassName(), \"WebHome\", \"You can have fun with templates here\",\n            \"Welcome to the templates test space\");\n\n        // go through all the templates and make sure they are disabled on this space\n        TemplatesAdministrationSectionPage sectionPage = TemplatesAdministrationSectionPage.gotoPage();\n\n        // get the links to existing templates, navigate to each of them and disable the current space\n        List<String> spacesToExclude = Collections.singletonList(getTestClassName());\n        List<WebElement> existingTemplatesLinks = sectionPage.getExistingTemplatesLinks();\n        for (int i = 0; i < existingTemplatesLinks.size(); i++) {\n            WebElement link = existingTemplatesLinks.get(i);\n            link.click();\n            ViewPage templateViewPage = new ViewPage();\n            templateViewPage.editInline();\n            TemplateProviderInlinePage providerEditPage = new TemplateProviderInlinePage();\n\n            // FIXME: Temporary until we remove the template provider type altogether and make all providers page\n            // template providers.\n            if (!providerEditPage.isPageTemplate()) {\n                providerEditPage.setPageTemplate(true);\n            }\n\n            providerEditPage.excludeSpaces(spacesToExclude);\n            providerEditPage.clickSaveAndView();\n\n            // go back to the admin page, to leave this in a valid state\n            sectionPage = TemplatesAdministrationSectionPage.gotoPage();\n            existingTemplatesLinks = sectionPage.getExistingTemplatesLinks();\n        }\n\n        // TODO: should reset these template settings at the end of the test, to leave things in the same state as they\n        // were at the beginning of the test\n\n        // and now start testing!\n\n        // 1/ create a page from the link in the page displayed when navigating to a non-existing page\n        getUtil().gotoPage(getTestClassName(), \"NewUnexistingPage\", \"view\", \"spaceRedirect=false\");\n        ViewPage newUnexistentPage = new ViewPage();\n        assertFalse(newUnexistentPage.exists());\n        DocumentDoesNotExistPage nonExistingPage = new DocumentDoesNotExistPage();\n        nonExistingPage.clickEditThisPageToCreate();\n        // make sure we're not in create mode anymore\n        assertFalse(getUtil().isInCreateMode());\n        // TODO: check that we're indeed in the edit mode of space.NewUnexitingPage\n        EditPage editNewUnexistingPage = new EditPage();\n        assertEquals(getTestClassName(), editNewUnexistingPage.getMetaDataValue(\"space\"));\n        assertEquals(\"NewUnexistingPage\", editNewUnexistingPage.getMetaDataValue(\"page\"));\n\n        // 2/ create a page from the create menu on an existing page, by filling in space and name\n        ViewPage spaceHomePage = getUtil().gotoPage(getTestClassName(), \"WebHome\");\n        CreatePagePage createNewPage = spaceHomePage.createPage();\n        // we expect no templates available\n        assertEquals(0, createNewPage.getAvailableTemplateSize());\n        // fill in data and create the page\n        createNewPage.setTitle(\"A New Page\");\n        createNewPage.setSpace(getTestClassName());\n        createNewPage.setPage(\"NewPage\");\n        createNewPage.clickCreate();\n        // we expect to go to the edit mode of the new page\n        assertFalse(getUtil().isInCreateMode());\n        EditPage editNewPage = new EditPage();\n        assertEquals(getTestClassName() + \".NewPage\", editNewPage.getMetaDataValue(\"space\"));\n        assertEquals(\"WebHome\", editNewPage.getMetaDataValue(\"page\"));\n        ViewPage viewNewPage = editNewPage.clickSaveAndView();\n        // mare sure title is the right one\n        assertEquals(\"A New Page\", viewNewPage.getDocumentTitle());\n        // Check that the breadcrumb uses titles for the parents and the current page.\n        assertEquals(\"/Welcome to the templates test space/A New Page\", viewNewPage.getBreadcrumbContent());\n\n        // 3/ create a page from a link in another page\n        WikiEditPage editNewPageWiki = viewNewPage.editWiki();\n        // put a link to the new page to create\n        editNewPageWiki.setContent(\"[[NewLinkedPage]]\");\n        ViewPage newPage = editNewPageWiki.clickSaveAndView();\n        // no templates are available, so we don't expect a panel with a list of templates, we just expect it goes\n        // directly to edit mode of the new page\n        // it would be nice to be able to test here that the create page panel is not displayed, ever. However, we can't\n        // since we need to wait for that time, and we don't know how much is never.\n        EntityReference wantedLinkReference =\n            getUtil().resolveDocumentReference(getTestClassName() + \".NewPage.NewLinkedPage\");\n        newPage.clickWantedLink(wantedLinkReference, false);\n        EditPage editNewLinkedPage = new EditPage();\n        // since the edit mode loads as a result of a redirect that comes from a async call made by the click, we need\n        // to wait for the page to load\n        getDriver().waitUntilElementIsVisible(By.xpath(\"//div[@id='mainEditArea']\"));\n        assertEquals(getTestClassName() + \".NewPage\", editNewLinkedPage.getMetaDataValue(\"space\"));\n        assertEquals(\"NewLinkedPage\", editNewLinkedPage.getMetaDataValue(\"page\"));\n    }","commit_id":"d261716340388dd39c740532594a5436d6bab5d5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public WYSIWYGEditPage createSpace(String spaceValue)\n    {\n        this.spaceTextField.sendKeys(spaceValue);\n        this.spaceTextField.submit();\n        return new WYSIWYGEditPage();\n    }","id":29417,"modified_method":"public WYSIWYGEditPage createSpace(String spaceValue)\n    {\n        this.createPage(\"\", spaceValue);\n        return new WYSIWYGEditPage();\n    }","commit_id":"d261716340388dd39c740532594a5436d6bab5d5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n   * Used in SQALE\n   * If 'pageSize' params is set no -1, all rules are returned (using scrolling)\n   */\n  public PagedResult<Rule> find(Map<String, Object> params) {\n    RuleQuery query = new RuleQuery();\n    query.setQueryText(Strings.emptyToNull((String) params.get(\"searchQuery\")));\n    query.setKey(Strings.emptyToNull((String) params.get(\"key\")));\n    query.setLanguages(RubyUtils.toStrings(params.get(\"languages\")));\n    query.setRepositories(RubyUtils.toStrings(params.get(\"repositories\")));\n    query.setSeverities(RubyUtils.toStrings(params.get(\"severities\")));\n    query.setStatuses(RubyUtils.toEnums(params.get(\"statuses\"), RuleStatus.class));\n    query.setTags(RubyUtils.toStrings(params.get(\"tags\")));\n    query.setDebtCharacteristics(RubyUtils.toStrings(params.get(\"debtCharacteristics\")));\n    query.setHasDebtCharacteristic(RubyUtils.toBoolean(params.get(\"hasDebtCharacteristic\")));\n    query.setSortField(RuleNormalizer.RuleField.NAME);\n    String profile = Strings.emptyToNull((String) params.get(\"profile\"));\n    if (profile != null) {\n      query.setQProfileKey(profile);\n      query.setActivation(true);\n    }\n\n    QueryContext options = new QueryContext();\n    Integer pageSize = RubyUtils.toInteger(params.get(\"pageSize\"));\n    int size = pageSize != null ? pageSize : 50;\n    Integer page = RubyUtils.toInteger(params.get(\"p\"));\n    int pageIndex = page != null ? page : 1;\n    options.setPage(pageIndex, size);\n    Result<Rule> result = service.search(query, options);\n    return new PagedResult<Rule>(result.getHits(), PagingResult.create(options.getLimit(), pageIndex, result.getTotal()));\n  }","id":29418,"modified_method":"/**\n   * Used in SQALE\n   * If 'pageSize' params is set no -1, all rules are returned (using scrolling)\n   */\n  public PagedResult<Rule> find(Map<String, Object> params) {\n    RuleQuery query = new RuleQuery();\n    query.setQueryText(Strings.emptyToNull((String) params.get(\"searchQuery\")));\n    query.setKey(Strings.emptyToNull((String) params.get(\"key\")));\n    query.setLanguages(RubyUtils.toStrings(params.get(\"languages\")));\n    query.setRepositories(RubyUtils.toStrings(params.get(\"repositories\")));\n    query.setSeverities(RubyUtils.toStrings(params.get(\"severities\")));\n    query.setStatuses(RubyUtils.toEnums(params.get(\"statuses\"), RuleStatus.class));\n    query.setTags(RubyUtils.toStrings(params.get(\"tags\")));\n    query.setDebtCharacteristics(RubyUtils.toStrings(params.get(\"debtCharacteristics\")));\n    query.setHasDebtCharacteristic(RubyUtils.toBoolean(params.get(\"hasDebtCharacteristic\")));\n    query.setSortField(RuleNormalizer.RuleField.NAME);\n    String profile = Strings.emptyToNull((String) params.get(\"profile\"));\n    if (profile != null) {\n      query.setQProfileKey(profile);\n      query.setActivation(true);\n    }\n\n    QueryContext options = new QueryContext();\n    Integer pageSize = RubyUtils.toInteger(params.get(\"pageSize\"));\n    int size = pageSize != null ? pageSize : 50;\n    if (size > -1) {\n      Integer page = RubyUtils.toInteger(params.get(\"p\"));\n      int pageIndex = page != null ? page : 1;\n      options.setPage(pageIndex, size);\n      Result<Rule> result = service.search(query, options);\n      return new PagedResult<>(result.getHits(), PagingResult.create(options.getLimit(), pageIndex, result.getTotal()));\n    } else {\n      List<Rule> rules = newArrayList(service.search(query, new QueryContext().setScroll(true)).scroll());\n      return new PagedResult<>(rules, PagingResult.create(Integer.MAX_VALUE, 1, rules.size()));\n    }\n  }","commit_id":"4a97e3539c69b00802f88a30e10a4cbc0d8336d7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void respond(RequestCycle requestCycle)\n\t{\n\t\tlog.info(\"action -> \" + requestCycle.getRequestTarget());\n\t\tPortletRequestCodingStrategy strategy = (PortletRequestCodingStrategy)requestCycle\n\t\t\t\t.getProcessor().getRequestCodingStrategy();\n\t\tstrategy.setRenderParameters((PortletRequestCycle)requestCycle, requestCycle\n\t\t\t\t.getRequestTarget());\n\t}","id":29419,"modified_method":"public void respond(RequestCycle requestCycle)\n\t{\n\t\tPortletRequestCodingStrategy strategy = (PortletRequestCodingStrategy)requestCycle\n\t\t\t\t.getProcessor().getRequestCodingStrategy();\n\t\tstrategy.setRenderParameters((PortletRequestCycle)requestCycle, requestCycle\n\t\t\t\t.getRequestTarget());\n\t}","commit_id":"0442fdc2b820b530751bbf90879650f562b2ed1b","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor. Having this constructor public means that your page is\n\t * 'bookmarkable' and hence can be called/ created from anywhere.\n\t */\n\tprotected PortletPage()\n\t{\n\t}","id":29420,"modified_method":"/**\n\t * @see Page#Page()\n\t */\n\tprotected PortletPage()\n\t{\n\t\tsuper();\n\t}","commit_id":"0442fdc2b820b530751bbf90879650f562b2ed1b","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Resolves to a page target that was previously rendered. Optionally\n\t * resolves to a component call target, which is a specialization of a page\n\t * target. If no corresponding page could be found, a expired page target\n\t * will be returned.\n\t * \n\t * @param requestCycle\n\t *            the current request cycle\n\t * @param requestParameters\n\t *            the request parameters object\n\t * @return the previously rendered page as a request target\n\t */\n\tprotected IRequestTarget resolveRenderedPage(final RequestCycle requestCycle,\n\t\t\tfinal RequestParameters requestParameters)\n\t{\n\t\tfinal String componentPath = requestParameters.getComponentPath();\n\t\tfinal Session session = requestCycle.getSession();\n\n\t\tfinal Page page = session.getPage(requestParameters.getPageMapName(), componentPath,\n\t\t\t\trequestParameters.getVersionNumber());\n\n\t\t// Does page exist?\n\t\tif (page != null)\n\t\t{\n\t\t\t// Set page on request\n\t\t\trequestCycle.getRequest().setPage(page);\n\n\t\t\t// see whether this resolves to a component call or just the page\n\t\t\tfinal String interfaceName = requestParameters.getInterfaceName();\n\t\t\tif (interfaceName != null)\n\t\t\t{\n\t\t\t\treturn resolveListenerInterfaceTarget(requestCycle, page, componentPath,\n\t\t\t\t\t\tinterfaceName, requestParameters);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn new PageRequestTarget(page);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Page was expired from session, probably because backtracking\n\t\t\t// limit was reached\n\t\t\treturn new ExpiredPageClassRequestTarget();\n\t\t}\n\t}","id":29421,"modified_method":"/**\n\t * Resolves to a page target that was previously rendered. Optionally\n\t * resolves to a component call target, which is a specialization of a page\n\t * target. If no corresponding page could be found, a expired page target\n\t * will be returned.\n\t * \n\t * @param requestCycle\n\t *            the current request cycle\n\t * @param requestParameters\n\t *            the request parameters object\n\t * @return the previously rendered page as a request target\n\t */\n\tprotected IRequestTarget resolveRenderedPage(final RequestCycle requestCycle,\n\t\t\tfinal RequestParameters requestParameters)\n\t{\n\t\tfinal String componentPath = requestParameters.getComponentPath();\n\t\tfinal Session session = requestCycle.getSession();\n\n\t\tfinal PortletPage page = (PortletPage)session.getPage(requestParameters.getPageMapName(), componentPath,\n\t\t\t\trequestParameters.getVersionNumber());\n\n\t\t// Does page exist?\n\t\tif (page != null)\n\t\t{\n\n\t\t\tPortletRequestCycle cycle = (PortletRequestCycle)requestCycle;\n\t\t\tIRequestTarget prevTarget=cycle.getRequestTarget();\n\n\t\t\tpage.setPortletMode(cycle.getPortletRequest().getPortletRequest().getPortletMode());\n\t\t\tpage.setWindowState(cycle.getPortletRequest().getPortletRequest().getWindowState());\t\t\t\n\n\t\t\tif(requestCycle.getRequestTarget()!=prevTarget){\t\t\t\n\t\t\t\t// setPortletMode or setWindowState changed the request target and we should continue to there.\n\t\t\t\treturn requestCycle.getRequestTarget();\n\t\t\t}\n\n\t\t\t// Set page on request\n\t\t\trequestCycle.getRequest().setPage(page);\n\t\t\t\n\t\t\t// see whether this resolves to a component call or just the page\n\t\t\tfinal String interfaceName = requestParameters.getInterfaceName();\n\t\t\tif (interfaceName != null)\n\t\t\t{\n\t\t\t\treturn resolveListenerInterfaceTarget(requestCycle, page, componentPath,\n\t\t\t\t\t\tinterfaceName, requestParameters);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn new PageRequestTarget(page);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Page was expired from session, probably because backtracking\n\t\t\t// limit was reached\n\t\t\treturn new ExpiredPageClassRequestTarget();\n\t\t}\n\t}","commit_id":"0442fdc2b820b530751bbf90879650f562b2ed1b","url":"https://github.com/apache/wicket"},{"original_method":"private boolean setColumnPreferredSize() {\n    boolean sizeCalculated = false;\n    Font tableFont = UIManager.getFont(\"Table.font\");\n    for (int i = 0; i < getColumnCount(); i++) {\n      TableColumn column = getColumnModel().getColumn(i);\n      if (i == GraphTableModel.ROOT_COLUMN) { // thin stripe, or root name, or nothing\n        setRootColumnSize(column);\n      }\n      else if (i == GraphTableModel.AUTHOR_COLUMN) { // detect author with the longest name\n        // to avoid querying the last row (it would lead to full graph loading)\n        int maxRowsToCheck = Math.min(MAX_ROWS_TO_CALC_WIDTH, getRowCount() - MAX_ROWS_TO_CALC_OFFSET);\n        if (maxRowsToCheck < 0) { // but if the log is small, check all of them\n          maxRowsToCheck = getRowCount();\n        }\n        int maxWidth = 0;\n        for (int row = 0; row < maxRowsToCheck; row++) {\n          String value = getModel().getValueAt(row, i).toString();\n          maxWidth = Math.max(getFontMetrics(tableFont.deriveFont(Font.BOLD)).stringWidth(value), maxWidth);\n          if (!value.isEmpty()) sizeCalculated = true;\n        }\n        int min = Math.min(maxWidth + myStringCellRenderer.getHorizontalTextPadding(), MAX_DEFAULT_AUTHOR_COLUMN_WIDTH);\n        column.setPreferredWidth(min);\n      }\n      else if (i == GraphTableModel.DATE_COLUMN) { // all dates have nearly equal sizes\n        int min = getFontMetrics(tableFont.deriveFont(Font.BOLD)).stringWidth(DateFormatUtil.formatDateTime(new Date())) +\n                  myStringCellRenderer.getHorizontalTextPadding();\n        column.setPreferredWidth(min);\n      }\n    }\n\n    updateCommitColumnWidth();\n\n    return sizeCalculated;\n  }","id":29422,"modified_method":"private boolean setColumnPreferredSize() {\n    boolean sizeCalculated = false;\n    Font tableFont = UIManager.getFont(\"Table.font\");\n    for (int i = 0; i < getColumnCount(); i++) {\n      TableColumn column = getColumnModel().getColumn(i);\n      if (i == GraphTableModel.ROOT_COLUMN) { // thin stripe, or root name, or nothing\n        setRootColumnSize(column);\n      }\n      else if (i == GraphTableModel.AUTHOR_COLUMN) { // detect author with the longest name\n        // to avoid querying the last row (it would lead to full graph loading)\n        int maxRowsToCheck = Math.min(MAX_ROWS_TO_CALC_WIDTH, getRowCount() - MAX_ROWS_TO_CALC_OFFSET);\n        if (maxRowsToCheck < 0) { // but if the log is small, check all of them\n          maxRowsToCheck = getRowCount();\n        }\n        int maxWidth = 0;\n        for (int row = 0; row < maxRowsToCheck; row++) {\n          String value = getModel().getValueAt(row, i).toString();\n          Font font = tableFont;\n          VcsLogHighlighter.TextStyle style = getStyle(row, i, value, false, false).getTextStyle();\n          if (BOLD.equals(style)) {\n            font = tableFont.deriveFont(Font.BOLD);\n          }\n          else if (ITALIC.equals(style)) {\n            font = tableFont.deriveFont(Font.ITALIC);\n          }\n          maxWidth = Math.max(getFontMetrics(font).stringWidth(value + \"*\"), maxWidth);\n          if (!value.isEmpty()) sizeCalculated = true;\n        }\n        int min = Math.min(maxWidth + myStringCellRenderer.getHorizontalTextPadding(), MAX_DEFAULT_AUTHOR_COLUMN_WIDTH);\n        column.setPreferredWidth(min);\n      }\n      else if (i == GraphTableModel.DATE_COLUMN) { // all dates have nearly equal sizes\n        int min = getFontMetrics(tableFont.deriveFont(Font.BOLD)).stringWidth(DateFormatUtil.formatDateTime(new Date())) +\n                  myStringCellRenderer.getHorizontalTextPadding();\n        column.setPreferredWidth(min);\n      }\n    }\n\n    updateCommitColumnWidth();\n\n    return sizeCalculated;\n  }","commit_id":"22d9ed3e83705c9fd993a32ff5bc4cf2340c3e71","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void out(String s) {\n        System.out.println(\"TextBox@\" + id() + \" \" + s);\n    }","id":29423,"modified_method":"private void out(String s) {\n        System.out.println(\"TextBox@\" + id() + \" [\" + getText() + \"] \" + s);\n        //System.out.println(\"TextBox@\" + id() + \" \" + s);\n    }","commit_id":"85280c4a15aaf94b4076215cf250fbfc067e8cc1","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n    public void addNotify()\n    {\n        if (TestDebug||DEBUG.TEXT) out(\"*** ADDNOTIFY ***\");\n        if (getText().length() < 1)\n            setText(\"<label>\");\n        keyWasPressed = false;\n        Dimension size = getSize();\n        super.addNotify();\n        // note: we get a a flash/move if we add the border before the super.addNotify()\n        if (false && TestDebug)\n            ; //setBorder(javax.swing.BorderFactory.createLineBorder(Color.green));\n        else {\n            // ADDING THIS BORDER INCREASES THE PREFERRED SIZE\n            // Width goes up by 4 pix and height goes up by a line because\n            // actual getSize width no longer fits.  Very convoluted.\n            //setBorder(javax.swing.border.LineBorder.createGrayLineBorder());\n        }\n        java.awt.Container parent = getParent();\n        if (parent instanceof MapViewer) { // todo: could be a scroller!\n            double zoom = ((MapViewer)parent).getZoomFactor();\n            // todo: also account for getScale of children!\n            zoom *= lwc.getMapScale();\n            if (zoom != 1.0) {\n                Font f = lwc.getFont();\n                float zoomedPointSize = (float) (f.getSize() * zoom);\n                if (zoomedPointSize < MinEditSize)\n                    zoomedPointSize = MinEditSize;\n                preZoomFont = f;\n                setDocumentFont(f.deriveFont(f.getStyle(), zoomedPointSize));\n                if (WrapText) {\n                    double boxZoom = zoomedPointSize / preZoomFont.getSize();\n                    size.width *= boxZoom;\n                    size.height *= boxZoom;\n                } else {\n                    setSize(getPreferredSize());\n                }\n            } else {\n                // this forces the AWT to redraw this component\n                // (just calling repaint doesn't do it).\n                // When zoomed we must do this (see above), so\n                // in that case it's already handled.\n                setDocumentFont(lwc.getFont());\n            }\n        }\n            \n        wasOpaque = isOpaque();\n        Color background = lwc.getRenderFillColor(null);\n        //if (c == null && lwc.getParent() != null && lwc.getParent() instanceof LWNode)\n        final LWContainer nodeParent = lwc.getParent();\n        if (background == null && nodeParent != null)\n            background = nodeParent.getRenderFillColor(null); // todo: only handles 1 level transparent embed!\n        // todo: could also consider using map background if the node itself\n        // is transpatent (has no fill color)\n\n        // TODO: this workaround until we can recursively find a real fill color\n        // node that for SLIDES, we'd have to get awfully fancy and\n        // usually pull the color of the master slide (unless the slide\n        // happened to have it's own special color).  Only super clean\n        // way to do this would be to have established some kind of\n        // rendering pipeline record... (yeah, right)\n        if (background == null) background = Color.gray;\n        //out(\"BACKGROUND COLOR \" + background);\n\n        // TODO: the *selection* color always appears to be gray in for edits\n        // in the slide viewer on the mac, even if we manually set the selection\n        // color (which works in the main MapViewer) -- this is an oddity...\n        \n        if (background != null) {\n            // note that if we set opaque to false, interaction speed is\n            // noticably slowed down in edit mode because it has to consider\n            // repainting the entire map each cursor blink as the object\n            // is transparent, and thus it's background is the displayed\n            // map.  So if we can guess at a reasonable fill color in edit mode,\n            // we temporarily set us to opaque.\n            setOpaque(true);\n            setBackground(background);\n        }\n        setSize(size);\n\n        Dimension preferred = getPreferredSize();\n        int w = getWidth() + 1;\n        if (w < preferred.width)\n            mKeepTextWidth = true;\n        else\n            mKeepTextWidth = false;\n        if (TestDebug||DEBUG.TEXT) out(\"width+1=\" + w + \" < preferred.width=\" + preferred.width + \" fixedWidth=\" + mKeepTextWidth);\n        \n        if (TestDebug||DEBUG.TEXT) out(\"addNotify end: insets=\"+getInsets());\n        mFirstAfterAddNotify = true;\n    }","id":29424,"modified_method":"@Override\n    public void addNotify()\n    {\n        if (TestDebug||DEBUG.TEXT) out(\"*** ADDNOTIFY ***\");\n        if (getText().length() < 1)\n            setText(\"<label>\");\n        keyWasPressed = false;\n        Dimension size = getSize();\n        super.addNotify();\n        // note: we get a a flash/move if we add the border before the super.addNotify()\n        if (false && TestDebug)\n            ; //setBorder(javax.swing.BorderFactory.createLineBorder(Color.green));\n        else {\n            // ADDING THIS BORDER INCREASES THE PREFERRED SIZE\n            // Width goes up by 4 pix and height goes up by a line because\n            // actual getSize width no longer fits.  Very convoluted.\n            //setBorder(javax.swing.border.LineBorder.createGrayLineBorder());\n        }\n        java.awt.Container parent = getParent();\n        if (parent instanceof MapViewer) { // todo: could be a scroller?\n            double zoom = ((MapViewer)parent).getZoomFactor();\n            zoom *= lwc.getMapScale();\n            if (zoom != 1.0) {\n                final Font f = lwc.getFont();\n                float zoomedPointSize = (float) (f.getSize() * zoom);\n                if (zoomedPointSize < MinEditSize)\n                    zoomedPointSize = MinEditSize;\n                preZoomFont = f;\n                final Font screenFont = f.deriveFont(f.getStyle(), zoomedPointSize);\n                setDocumentFont(screenFont);\n                if (TestDebug||DEBUG.TEXT) {\n                    out(\"derived temporary screen font:\"\n                        + \"\\n\\t   net zoom: \" + zoom\n                        + \"\\n\\t  node font: \" + f\n                        + \"\\n\\tscreen font: \" + screenFont + \" size2D=\" + screenFont.getSize2D()\n                        );\n                }\n                if (WrapText) {\n                    double boxZoom = zoomedPointSize / preZoomFont.getSize();\n                    size.width *= boxZoom;\n                    size.height *= boxZoom;\n                } else {\n                    setSize(getPreferredSize());\n                }\n            } else {\n                // this forces the AWT to redraw this component\n                // (just calling repaint doesn't do it).\n                // When zoomed we must do this (see above), so\n                // in that case it's already handled.\n                setDocumentFont(lwc.getFont());\n            }\n        }\n            \n        wasOpaque = isOpaque();\n        Color background = lwc.getRenderFillColor(null);\n        //if (c == null && lwc.getParent() != null && lwc.getParent() instanceof LWNode)\n        final LWContainer nodeParent = lwc.getParent();\n        if (background == null && nodeParent != null)\n            background = nodeParent.getRenderFillColor(null); // todo: only handles 1 level transparent embed!\n        // todo: could also consider using map background if the node itself\n        // is transpatent (has no fill color)\n\n        // TODO: this workaround until we can recursively find a real fill color\n        // node that for SLIDES, we'd have to get awfully fancy and\n        // usually pull the color of the master slide (unless the slide\n        // happened to have it's own special color).  Only super clean\n        // way to do this would be to have established some kind of\n        // rendering pipeline record... (yeah, right)\n        if (background == null) background = Color.gray;\n        //out(\"BACKGROUND COLOR \" + background);\n\n        // TODO: the *selection* color always appears to be gray in for edits\n        // in the slide viewer on the mac, even if we manually set the selection\n        // color (which works in the main MapViewer) -- this is an oddity...\n        \n        if (background != null) {\n            // note that if we set opaque to false, interaction speed is\n            // noticably slowed down in edit mode because it has to consider\n            // repainting the entire map each cursor blink as the object\n            // is transparent, and thus it's background is the displayed\n            // map.  So if we can guess at a reasonable fill color in edit mode,\n            // we temporarily set us to opaque.\n            setOpaque(true);\n            setBackground(background);\n        }\n        setSize(size);\n\n        Dimension preferred = getPreferredSize();\n        int w = getWidth() + 1;\n        if (w < preferred.width)\n            mKeepTextWidth = true;\n        else\n            mKeepTextWidth = false;\n        if (TestDebug||DEBUG.TEXT) out(\"width+1=\" + w + \" < preferred.width=\" + preferred.width + \" fixedWidth=\" + mKeepTextWidth);\n        \n        if (TestDebug||DEBUG.TEXT) out(\"addNotify end: insets=\"+getInsets());\n        mFirstAfterAddNotify = true;\n    }","commit_id":"85280c4a15aaf94b4076215cf250fbfc067e8cc1","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n    public void removeNotify()\n    {\n        if (TestDebug||DEBUG.TEXT) out(\"*** REMOVENOTIFY ***\");\n        \n        //------------------------------------------------------------------\n        // We need to clear any text selection here as a workaround\n        // for an obscure bug where sometimes if the focus change is\n        // to a pop-up menu, the edit properly goes inactive, but the\n        // selection within it is still drawn with it's highlighted\n        // background.\n        clearSelection();\n        //------------------------------------------------------------------\n        \n        super.removeNotify();\n\n        if (mFirstAfterAddNotify == false) {\n            // if cleared, it was used\n            out(\"restoring expanded width\");\n            setSize(new Dimension(getWidth()-1, getHeight()));\n            //out(\"SKPPING restoring expanded width\");\n        } else\n            mFirstAfterAddNotify = false;\n        \n        setBorder(null);\n        if (preZoomFont != null) {\n            setDocumentFont(preZoomFont);\n            preZoomFont = null;\n            if (WrapText)\n                adjustSizeDynamically();\n            else\n                setSize(getPreferredSize());\n        }\n        \n        if (wasOpaque != isOpaque())\n            setOpaque(wasOpaque);\n        if (TestDebug||DEBUG.TEXT) out(\"*** REMOVENOTIFY end: insets=\"+getInsets());\n    }","id":29425,"modified_method":"@Override\n    public void removeNotify()\n    {\n        if (TestDebug||DEBUG.TEXT) out(\"*** REMOVENOTIFY ***\");\n        \n        //------------------------------------------------------------------\n        // We need to clear any text selection here as a workaround\n        // for an obscure bug where sometimes if the focus change is\n        // to a pop-up menu, the edit properly goes inactive, but the\n        // selection within it is still drawn with it's highlighted\n        // background.\n        clearSelection();\n        //------------------------------------------------------------------\n        \n        super.removeNotify();\n\n        if (mFirstAfterAddNotify == false) {\n            // if cleared, it was used\n            out(\"restoring expanded width\");\n            setSize(new Dimension(getWidth()-1, getHeight()));\n            //out(\"SKPPING restoring expanded width\");\n        } else\n            mFirstAfterAddNotify = false;\n        \n        setBorder(null);\n        if (preZoomFont != null) {\n            setDocumentFont(preZoomFont);\n            preZoomFont = null;\n            if (WrapText) {\n                adjustSizeDynamically();\n            } else {\n                setSize(getPreferredSize());\n                // WE MUST DO THIS A SECOND TIME TO MAKE SURE THIS WORKS:\n                // JTextPane can actually produce inconsistent results\n                // when getPreferredSize() is called, especially if it's\n                // results were just use to set the size of the object.\n                // A second get/set produces more reliable results.\n                setSize(getPreferredSize());\n            }\n        }\n        \n        if (wasOpaque != isOpaque())\n            setOpaque(wasOpaque);\n        if (TestDebug||DEBUG.TEXT) out(\"*** REMOVENOTIFY end: insets=\"+getInsets());\n    }","commit_id":"85280c4a15aaf94b4076215cf250fbfc067e8cc1","url":"https://github.com/VUE/VUE"},{"original_method":"public static IdeaTitledBorder createTitledBorder(String title, boolean hasBoldFont, boolean hasIndent) {\n    Font font = hasBoldFont ? UIUtil.getBorderFont().deriveFont(Font.BOLD) : UIUtil.getBorderFont();\n    int indent = hasIndent ? (hasBoldFont ? 18 : 15) : 0;\n    Insets insets = hasBoldFont ? new Insets(5,0,10,0) : new Insets(3,0,6,0);\n    return new IdeaTitledBorder(title, font, UIUtil.getBorderColor(), indent, 1, insets);\n  }","id":29426,"modified_method":"public static IdeaTitledBorder createTitledBorder(String title, boolean hasBoldFont, boolean hasIndent) {\n    Font font = UIUtil.getBorderFont();\n    if (hasBoldFont) {\n      font = font.deriveFont(Font.BOLD);\n    }\n    int indent = hasIndent ? (hasBoldFont ? 18 : 15) : 0;\n    Insets insets = hasBoldFont ? new Insets(5,0,10,0) : new Insets(3,0,6,0);\n    return new IdeaTitledBorder(title, font, UIUtil.getBorderColor(), indent, 1, insets);\n  }","commit_id":"c59d7808915ed2fe7a73fda503c32a139a3b3eb9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean checkArrayInitializerLBrace(final HighlighterIterator iterator) {\n    if (iterator.getTokenType() != JavaTokenType.LBRACE) return false;\n    iterator.retreat();\n    if (iterator.getTokenType() == JavaTokenType.WHITE_SPACE) iterator.retreat();\n    if (iterator.getTokenType() != JavaTokenType.RBRACKET) return false;\n    iterator.retreat();\n    if (iterator.getTokenType() != JavaTokenType.LBRACKET) return false;\n    return true;\n  }","id":29427,"modified_method":"private static boolean checkArrayInitializerLBrace(final HighlighterIterator iterator) {\n    int lbraceCount = 0;\n    while(iterator.getTokenType() == JavaTokenType.LBRACE) {\n      lbraceCount++;\n      iterator.retreat();\n    }\n    if (lbraceCount == 0) return false;\n    if (iterator.getTokenType() == JavaTokenType.WHITE_SPACE) iterator.retreat();\n    for(int i=0; i<lbraceCount; i++) {\n      if (iterator.getTokenType() != JavaTokenType.RBRACKET) return false;\n      iterator.retreat();\n      if (iterator.getTokenType() != JavaTokenType.LBRACKET) return false;\n      iterator.retreat();\n    }\n    return true;\n  }","commit_id":"0f8fa76ba83432899ff286499d05c0e7fc063d84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isAfterClassLikeIdentifier(final int offset, final Editor editor) {\n    HighlighterIterator iterator = ((EditorEx) editor).getHighlighter().createIterator(offset);\n    iterator.retreat();\n    final IElementType tokenType = iterator.getTokenType();\n    if (tokenType == JavaTokenType.IDENTIFIER && iterator.getEnd() == offset) {\n      final CharSequence chars = editor.getDocument().getCharsSequence();\n      final char startChar = chars.charAt(iterator.getStart());\n      if (!Character.isUpperCase(startChar)) return false;\n      final CharSequence word = chars.subSequence(iterator.getStart(), iterator.getEnd());\n      if (word.length() == 1) return true;\n      for (int i = 1; i < word.length(); i++) {\n        if (Character.isLowerCase(word.charAt(i))) return true;\n      }\n    }\n\n    return false;\n  }","id":29428,"modified_method":"public static boolean isAfterClassLikeIdentifier(final int offset, final Editor editor) {\n    HighlighterIterator iterator = ((EditorEx) editor).getHighlighter().createIterator(offset);\n    if (iterator.getStart() > 0) iterator.retreat();\n    final IElementType tokenType = iterator.getTokenType();\n    if (tokenType == JavaTokenType.IDENTIFIER && iterator.getEnd() == offset) {\n      final CharSequence chars = editor.getDocument().getCharsSequence();\n      final char startChar = chars.charAt(iterator.getStart());\n      if (!Character.isUpperCase(startChar)) return false;\n      final CharSequence word = chars.subSequence(iterator.getStart(), iterator.getEnd());\n      if (word.length() == 1) return true;\n      for (int i = 1; i < word.length(); i++) {\n        if (Character.isLowerCase(word.charAt(i))) return true;\n      }\n    }\n\n    return false;\n  }","commit_id":"7849666e149e57d7ecadf5fbc958e40e0dec2936","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getTagName(CharSequence fileText, HighlighterIterator iterator) {\n    IElementType tokenType = iterator.getTokenType();\n    String name = null;\n    if (tokenType == XmlTokenType.XML_START_TAG_START) {\n      {\n        iterator.advance();\n        IElementType tokenType1;\n        if (!iterator.atEnd() &&\n            ( (tokenType1 = iterator.getTokenType()) == XmlTokenType.XML_TAG_NAME ||\n              tokenType1 == XmlTokenType.XML_NAME\n            )\n           ) {\n          name = fileText.subSequence(iterator.getStart(), iterator.getEnd()).toString();\n        }\n        iterator.retreat();\n      }\n    }\n    else if (tokenType == XmlTokenType.XML_TAG_END || tokenType == XmlTokenType.XML_EMPTY_ELEMENT_END) {\n      {\n        int count = 0;\n        while (true) {\n          iterator.retreat();\n          count++;\n          if (iterator.atEnd()) break;\n          IElementType tokenType1 = iterator.getTokenType();\n          if (tokenType1 == XmlTokenType.XML_NAME) {\n            iterator.retreat();\n            tokenType1 = iterator.getTokenType();\n            iterator.advance();\n            if (tokenType1 == XmlTokenType.XML_START_TAG_START || tokenType1== XmlTokenType.XML_END_TAG_START) {\n              name = fileText.subSequence(iterator.getStart(), iterator.getEnd()).toString();\n              break;\n            }\n          } else if (tokenType1 == XmlTokenType.XML_TAG_NAME) {\n            name = fileText.subSequence(iterator.getStart(), iterator.getEnd()).toString();\n            break;\n          }\n        }\n        for (int i = 0; i < count; i++) {\n          iterator.advance();\n        }\n      }\n    }\n    else if (tokenType == JspTokenType.JSP_ACTION_START) {\n      {\n        iterator.advance();\n        if (!iterator.atEnd() && iterator.getTokenType() == JspTokenType.JSP_ACTION_NAME) {\n          name = fileText.subSequence(iterator.getStart(), iterator.getEnd()).toString();\n        }\n        iterator.retreat();\n      }\n    }\n    else if (tokenType == JspTokenType.JSP_ACTION_END || tokenType == JspTokenType.JSP_EMPTY_ACTION_END) {\n      {\n        int count = 0;\n        while (true) {\n          iterator.retreat();\n          count++;\n          if (iterator.atEnd()) break;\n          IElementType tokenType1 = iterator.getTokenType();\n          if (tokenType1 == JspTokenType.JSP_ACTION_NAME) {\n            name = fileText.subSequence(iterator.getStart(), iterator.getEnd()).toString();\n            break;\n          }\n        }\n        for (int i = 0; i < count; i++) {\n          iterator.advance();\n        }\n      }\n    }\n\n    return name;\n  }","id":29429,"modified_method":"private static String getTagName(CharSequence fileText, HighlighterIterator iterator) {\n    IElementType tokenType = iterator.getTokenType();\n    String name = null;\n    if (tokenType == XmlTokenType.XML_START_TAG_START) {\n      {\n        boolean wasWhiteSpace = false;\n        iterator.advance();\n        IElementType tokenType1 = (!iterator.atEnd() ? iterator.getTokenType():null);\n\n        if (tokenType1 == JavaTokenType.WHITE_SPACE) {\n          wasWhiteSpace = true;\n          iterator.advance();\n          tokenType1 = (!iterator.atEnd() ? iterator.getTokenType():null);\n        }\n\n        if (tokenType1 == XmlTokenType.XML_TAG_NAME ||\n            tokenType1 == XmlTokenType.XML_NAME\n           ) {\n          name = fileText.subSequence(iterator.getStart(), iterator.getEnd()).toString();\n        }\n\n        if (wasWhiteSpace) iterator.retreat();\n        iterator.retreat();\n      }\n    }\n    else if (tokenType == XmlTokenType.XML_TAG_END || tokenType == XmlTokenType.XML_EMPTY_ELEMENT_END) {\n      {\n        int count = 0;\n        while (true) {\n          iterator.retreat();\n          count++;\n          if (iterator.atEnd()) break;\n          IElementType tokenType1 = iterator.getTokenType();\n          if (tokenType1 == XmlTokenType.XML_NAME) {\n            iterator.retreat();\n            tokenType1 = iterator.getTokenType();\n            \n            if (tokenType1 == JavaTokenType.WHITE_SPACE) {\n              iterator.retreat();\n              tokenType1 = iterator.getTokenType();\n              iterator.advance();\n            }\n            iterator.advance();\n            if (tokenType1 == XmlTokenType.XML_START_TAG_START || tokenType1== XmlTokenType.XML_END_TAG_START) {\n              name = fileText.subSequence(iterator.getStart(), iterator.getEnd()).toString();\n              break;\n            }\n          } else if (tokenType1 == XmlTokenType.XML_TAG_NAME) {\n            name = fileText.subSequence(iterator.getStart(), iterator.getEnd()).toString();\n            break;\n          }\n        }\n        for (int i = 0; i < count; i++) {\n          iterator.advance();\n        }\n      }\n    }\n    else if (tokenType == JspTokenType.JSP_ACTION_START) {\n      {\n        iterator.advance();\n        if (!iterator.atEnd() && iterator.getTokenType() == JspTokenType.JSP_ACTION_NAME) {\n          name = fileText.subSequence(iterator.getStart(), iterator.getEnd()).toString();\n        }\n        iterator.retreat();\n      }\n    }\n    else if (tokenType == JspTokenType.JSP_ACTION_END || tokenType == JspTokenType.JSP_EMPTY_ACTION_END) {\n      {\n        int count = 0;\n        while (true) {\n          iterator.retreat();\n          count++;\n          if (iterator.atEnd()) break;\n          IElementType tokenType1 = iterator.getTokenType();\n          if (tokenType1 == JspTokenType.JSP_ACTION_NAME) {\n            name = fileText.subSequence(iterator.getStart(), iterator.getEnd()).toString();\n            break;\n          }\n        }\n        for (int i = 0; i < count; i++) {\n          iterator.advance();\n        }\n      }\n    }\n\n    return name;\n  }","commit_id":"8ee099b1ad3b6e7b3ac14d7bd37d0bf7e98b7ee7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Issue(\"JENKINS-24433\")\n    @Test\n    public void testSearchByProjectNameInAFolder() throws Exception {\n        final String projectName = \"testSearchByProjectName\";\n        j.createFreeStyleProject(projectName);\n        j.createFolder(\"my-folder-1\").createProject(FreeStyleProject.class, \"my-job-1\");\n\n        Page result = j.createWebClient().goTo(\"job/my-folder-1/search?q=\"+ \"my-folder-1/my-job-1\");\n\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        // make sure we've fetched the testSearchByDisplayName project page\n        String contents = result.getWebResponse().getContentAsString();\n        assertTrue(contents.contains(String.format(\"<title>%s [Jenkins]<\/title>\", \"my-job-1 [my-folder-1]\")));\n    }","id":29430,"modified_method":"@Issue(\"JENKINS-24433\")\n    @Test\n    public void testSearchByProjectNameInAFolder() throws Exception {\n\n        MockFolder myMockFolder = j.createFolder(\"my-folder-1\");\n        FreeStyleProject myFreeStyleProject = myMockFolder.createProject(FreeStyleProject.class, \"my-job-1\");\n\n        Page result = j.createWebClient().goTo(myMockFolder.getUrl() + \"search?q=\" + myFreeStyleProject.getFullName());\n\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        URL resultUrl = result.getWebResponse().getUrl();\n        assertTrue(resultUrl.toString().equals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl()));\n    }","commit_id":"cb174607b348636eeaf27c6b0eab502ec1f2f3a6","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Issue(\"JENKINS-24433\")\n    @Test\n    public void testSearchByProjectNameBehindAFolder() throws Exception {\n        final String projectName = \"testSearchByProjectName\";\n        j.createFreeStyleProject(projectName);\n        j.createFolder(\"my-folder-1\").createProject(FreeStyleProject.class, \"my-job-1\");\n\n        Page result = j.createWebClient().goTo(\"job/my-folder-1/search?q=\"+ projectName);\n\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        // make sure we've fetched the testSearchByDisplayName project page\n        String contents = result.getWebResponse().getContentAsString();\n        assertTrue(contents.contains(String.format(\"<title>%s [Jenkins]<\/title>\", projectName)));\n    }","id":29431,"modified_method":"@Issue(\"JENKINS-24433\")\n    @Test\n    public void testSearchByProjectNameBehindAFolder() throws Exception {\n        FreeStyleProject myFreeStyleProject = j.createFreeStyleProject(\"testSearchByProjectName\");\n        MockFolder myMockFolder = j.createFolder(\"my-folder-1\");\n\n        Page result = j.createWebClient().goTo(myMockFolder.getUrl() + \"search?q=\"+ myFreeStyleProject.getName());\n\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        URL resultUrl = result.getWebResponse().getUrl();\n        assertTrue(resultUrl.toString().equals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl()));\n    }","commit_id":"cb174607b348636eeaf27c6b0eab502ec1f2f3a6","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Issue(\"JENKINS-24433\")\n    @Test\n    public void testProjectNameBehindAFolderDisplayName() throws Exception {\n        final String projectName1 = \"job-1\";\n        final String displayName1 = \"job-1\";\n\n        final String projectName2 = \"job-2\";\n        final String displayName2 = \"job-2\";\n\n        FreeStyleProject project1 = j.createFreeStyleProject(projectName1);\n        project1.setDisplayName(displayName1);\n\n        FreeStyleProject project2 = j.createFolder(\"my-folder-1\").createProject(FreeStyleProject.class, projectName2);\n        project2.setDisplayName(displayName2);\n\n        WebClient wc = j.createWebClient();\n        Page result = wc.goTo(\"job/my-folder-1/search/suggest?query=\" + projectName1, \"application/json\");\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        String content = result.getWebResponse().getContentAsString();\n        JSONObject jsonContent = (JSONObject)JSONSerializer.toJSON(content);\n        assertNotNull(jsonContent);\n        JSONArray jsonArray = jsonContent.getJSONArray(\"suggestions\");\n        assertNotNull(jsonArray);\n\n        assertEquals(1, jsonArray.size());\n\n        boolean foundProjectName = false;\n        boolean foundDisplayName = false;\n        for(Object suggestion : jsonArray) {\n            JSONObject jsonSuggestion = (JSONObject)suggestion;\n\n            String name = (String)jsonSuggestion.get(\"name\");\n            if(projectName1.equals(name)) {\n                foundProjectName = true;\n            }\n            if(displayName1.equals(name)) {\n                foundDisplayName = true;\n            }\n        }\n\n        assertTrue(foundProjectName);\n        assertTrue(foundDisplayName);\n    }","id":29432,"modified_method":"@Issue(\"JENKINS-24433\")\n    @Test\n    public void testProjectNameBehindAFolderDisplayName() throws Exception {\n        final String projectName1 = \"job-1\";\n        final String displayName1 = \"job-1\";\n\n        final String projectName2 = \"job-2\";\n        final String displayName2 = \"job-2\";\n\n        FreeStyleProject project1 = j.createFreeStyleProject(projectName1);\n        project1.setDisplayName(displayName1);\n\n        FreeStyleProject project2 = j.createFolder(\"my-folder-1\").createProject(FreeStyleProject.class, projectName2);\n        project2.setDisplayName(displayName2);\n\n        WebClient wc = j.createWebClient();\n        Page result = wc.goTo(\"job/my-folder-1/search/suggest?query=\" + projectName1, \"application/json\");\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        String content = result.getWebResponse().getContentAsString();\n        JSONObject jsonContent = (JSONObject)JSONSerializer.toJSON(content);\n        assertNotNull(jsonContent);\n        JSONArray jsonArray = jsonContent.getJSONArray(\"suggestions\");\n        assertNotNull(jsonArray);\n\n        assertEquals(1, jsonArray.size());\n\n        boolean foundProjectName = false;\n        boolean foundDisplayName = false;\n        for(Object suggestion : jsonArray) {\n            JSONObject jsonSuggestion = (JSONObject)suggestion;\n\n            String name = (String)jsonSuggestion.get(\"name\");\n            if(displayName1.equals(name)) {\n                foundDisplayName = true;\n            }\n        }\n\n        assertTrue(foundDisplayName);\n    }","commit_id":"cb174607b348636eeaf27c6b0eab502ec1f2f3a6","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n\t\tprotected void execute(final IProgressMonitor monitor) throws CoreException, InvocationTargetException,\n\t\t\t\tInterruptedException {\n\t\t\tmonitor.beginTask(\"Creating dsl project's \" + xtextProjectInfo.getProjectName(), 3);\n\n\t\t\tString basePackage = xtextProjectInfo.getBasePackage();\n\t\t\t// DSL Project\n\t\t\tfinal IProject dslProject = EclipseResourceUtil.createProject(xtextProjectInfo.getProjectName(),\n\t\t\t\t\tSRC_FOLDER_LIST, Collections.<IProject> emptyList(), new LinkedHashSet<String>(Arrays.asList(\n\t\t\t\t\t\t\t\"org.eclipse.xtext.log4j;bundle-version=\\\"1.2.15\\\"\", \"org.eclipse.xtext\",\n\t\t\t\t\t\t\t\"org.eclipse.xtext.generator\")), Arrays.asList(basePackage, basePackage + \".parser\",\n\t\t\t\t\t\t\tbasePackage + \".parser.internal\", basePackage + \".parsetree.reconstr\", basePackage\n\t\t\t\t\t\t\t\t\t+ \".services\"), null, monitor, NewXtextProjectWizard.this.getShell());\n\n\t\t\tif (dslProject == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmonitor.worked(1);\n\n\t\t\t// DSL UI Project\n\t\t\tfinal IProject dslUIProject = EclipseResourceUtil.createProject(xtextProjectInfo.getProjectName() + \".ui\",\n\t\t\t\t\tSRC_FOLDER_LIST, Collections.<IProject> emptyList(), new LinkedHashSet<String>(Arrays.asList(\n\t\t\t\t\t\t\txtextProjectInfo.getProjectName().toLowerCase() + \";visibility:=reexport\",\n\t\t\t\t\t\t\t\"org.eclipse.xtext.ui.core\", \"org.eclipse.xtext.ui.common\",\n\t\t\t\t\t\t\t\"org.eclipse.xtext.log4j;bundle-version=\\\"1.2.15\\\"\",\n\t\t\t\t\t\t\t\"org.eclipse.ui.editors;bundle-version=\\\"3.4.0\\\"\")), Arrays.asList(basePackage\n\t\t\t\t\t\t\t+ \".ui.services\"), basePackage + \".ui.Activator\", monitor, NewXtextProjectWizard.this\n\t\t\t\t\t\t\t.getShell());\n\n\t\t\tif (dslUIProject == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmonitor.worked(1);\n\n\t\t\t// Generator Project\n\t\t\tif (xtextProjectInfo.isCreateGeneratorProject()) {\n\t\t\t\tfinal IProject dslGeneratorProject = EclipseResourceUtil.createProject(xtextProjectInfo\n\t\t\t\t\t\t.getProjectName()\n\t\t\t\t\t\t+ \".generator\", SRC_FOLDER_LIST, Collections.<IProject> emptyList(),\n\t\t\t\t\t\tnew LinkedHashSet<String>(), Collections.<String> emptyList(), null, monitor,\n\t\t\t\t\t\tNewXtextProjectWizard.this.getShell());\n\n\t\t\t\tif (dslGeneratorProject == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmonitor.worked(1);\n\n\t\t\tIFolder basePackageFolder = createSubPackages(basePackage, dslProject, (IFolder) dslProject\n\t\t\t\t\t.findMember(SRC_ROOT), monitor);\n\n\t\t\tOutputImpl output = new OutputImpl();\n\t\t\tString defaultEncoding = System.getProperty(\"file.encoding\");\n\t\t\toutput.addOutlet(new Outlet(false, defaultEncoding, \"GENERATOR_OUTLET\", true, basePackageFolder\n\t\t\t\t\t.getLocation().makeAbsolute().toOSString()));\n\t\t\toutput.addOutlet(new Outlet(false, defaultEncoding, \"ACTIVATOR_OUTLET\", true, dslUIProject.getFolder(\n\t\t\t\t\tSRC_ROOT + IPath.SEPARATOR + xtextProjectInfo.getBasePath() + IPath.SEPARATOR + \"ui\").getLocation()\n\t\t\t\t\t.makeAbsolute().toOSString()));\n\t\t\tXpandExecutionContextImpl execCtx = new XpandExecutionContextImpl(output, null, Collections.singletonMap(\n\t\t\t\t\t\"xtextProjectInfo\", new Variable(\"xtextProjectInfo\", xtextProjectInfo)), null, null);\n\t\t\texecCtx.registerMetaModel(new JavaMetaModel());\n\t\t\t// generate generator and activator for dsl and dsl.ui project\n\t\t\tXpandFacade facade = XpandFacade.create(execCtx);\n\t\t\tfacade.evaluate(\"org::eclipse::xtext::xtext::ui::wizard::project::XtextTemplateFile::root\",\n\t\t\t\t\txtextProjectInfo);\n\t\t\tfacade\n\t\t\t\t\t.evaluate(\"org::eclipse::xtext::xtext::ui::wizard::project::GrammarGenerator::root\",\n\t\t\t\t\t\t\txtextProjectInfo);\n\t\t\tfacade.evaluate(\"org::eclipse::xtext::xtext::ui::wizard::project::Activator::root\", xtextProjectInfo);\n\t\t\tEclipseResourceUtil.createFile(\"dummy.properties\", createSubPackages(basePackage + \".ui.services\",\n\t\t\t\t\tdslUIProject, (IFolder) dslUIProject.findMember(SRC_ROOT), monitor), \"a=b\", monitor);\n\n\t\t\tmonitor.worked(1);\n\n\t\t\t// refresh folder and select file to edit\n\t\t\tbasePackageFolder.refreshLocal(1, monitor);\n\t\t\tIFile dslGrammarFile = getDslGrammarFile(basePackageFolder);\n\t\t\tBasicNewResourceWizard\n\t\t\t\t\t.selectAndReveal(dslGrammarFile, PlatformUI.getWorkbench().getActiveWorkbenchWindow());\n\t\t\tEclipseResourceUtil.openFileToEdit(getShell(), dslGrammarFile);\n\n\t\t}","id":29433,"modified_method":"@Override\n\t\tprotected void execute(final IProgressMonitor monitor) throws CoreException, InvocationTargetException,\n\t\t\t\tInterruptedException {\n\t\t\tmonitor.beginTask(\"Creating dsl project's \" + xtextProjectInfo.getProjectName(), 3);\n\n\t\t\tString basePackage = xtextProjectInfo.getBasePackage();\n\t\t\t// DSL Project\n\t\t\tfinal IProject dslProject = EclipseResourceUtil.createProject(xtextProjectInfo.getProjectName(),\n\t\t\t\t\tSRC_FOLDER_LIST, Collections.<IProject> emptyList(), new LinkedHashSet<String>(Arrays.asList(\n\t\t\t\t\t\t\t\"org.eclipse.xtext.log4j;bundle-version=\\\"1.2.15\\\"\", \"org.eclipse.xtext\",\n\t\t\t\t\t\t\t\"org.eclipse.xtext.generator\", \"org.apache.log4j\", \"org.antlr\", \"org.eclipse.xtend\",\n\t\t\t\t\t\t\t\"org.eclipse.xtend.typesystem.emf\", \"org.eclipse.xpand\", \"org.apache.commons.logging\",\n\t\t\t\t\t\t\t\"org.eclipse.xtend.util.stdlib\")), Arrays.asList(basePackage, basePackage + \".parser\",\n\t\t\t\t\t\t\tbasePackage + \".parser.internal\", basePackage + \".parsetree.reconstr\", basePackage\n\t\t\t\t\t\t\t\t\t+ \".services\"), null, monitor, NewXtextProjectWizard.this.getShell());\n\n\t\t\tif (dslProject == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmonitor.worked(1);\n\n\t\t\t// DSL UI Project\n\t\t\tfinal IProject dslUIProject = EclipseResourceUtil.createProject(xtextProjectInfo.getProjectName() + \".ui\",\n\t\t\t\t\tSRC_FOLDER_LIST, Collections.<IProject> emptyList(), new LinkedHashSet<String>(Arrays.asList(\n\t\t\t\t\t\t\txtextProjectInfo.getProjectName().toLowerCase() + \";visibility:=reexport\",\n\t\t\t\t\t\t\t\"org.eclipse.xtext.ui.core\", \"org.eclipse.xtext.ui.common\",\n\t\t\t\t\t\t\t\"org.eclipse.xtext.log4j;bundle-version=\\\"1.2.15\\\"\",\n\t\t\t\t\t\t\t\"org.eclipse.ui.editors;bundle-version=\\\"3.4.0\\\"\")), Arrays.asList(basePackage\n\t\t\t\t\t\t\t+ \".ui.services\"), null, monitor, NewXtextProjectWizard.this.getShell());\n\n\t\t\tif (dslUIProject == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmonitor.worked(1);\n\n\t\t\t// Generator Project\n\t\t\tIProject dslGeneratorProject = null;\n\t\t\tif (xtextProjectInfo.isCreateGeneratorProject()) {\n\t\t\t\tdslGeneratorProject = EclipseResourceUtil.createProject(xtextProjectInfo.getProjectName()\n\t\t\t\t\t\t+ \".generator\", SRC_FOLDER_LIST, Collections.<IProject> emptyList(), new LinkedHashSet<String>(\n\t\t\t\t\t\tArrays.asList(xtextProjectInfo.getProjectName().toLowerCase(), \"org.eclipse.xtext\",\n\t\t\t\t\t\t\t\t\"org.eclipse.xtext.generator\")), Collections.<String> emptyList(), null, monitor,\n\t\t\t\t\t\tNewXtextProjectWizard.this.getShell());\n\n\t\t\t\tif (dslGeneratorProject == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmonitor.worked(1);\n\n\t\t\tIFolder basePackageFolder = createSubPackages(basePackage, dslProject, (IFolder) dslProject\n\t\t\t\t\t.findMember(SRC_ROOT), monitor);\n\n\t\t\tOutputImpl output = new OutputImpl();\n\t\t\tString defaultEncoding = System.getProperty(\"file.encoding\");\n\t\t\toutput.addOutlet(new Outlet(false, defaultEncoding, \"GRAMMAR_GENERATOR_OUTLET\", true, basePackageFolder\n\t\t\t\t\t.getLocation().makeAbsolute().toOSString()));\n\t\t\tif (dslGeneratorProject != null) {\n\t\t\t\toutput.addOutlet(new Outlet(false, defaultEncoding, \"GENERATOR_OUTLET\", true, createSubPackages(\n\t\t\t\t\t\tbasePackage, dslGeneratorProject, (IFolder) dslGeneratorProject.findMember(SRC_ROOT), monitor)\n\t\t\t\t\t\t.getLocation().makeAbsolute().toOSString()));\n\t\t\t\tEclipseResourceUtil.createFile(\"Model.\" + xtextProjectInfo.getFirstFileExtension(), createSubPackages(\n\t\t\t\t\t\t\"model\", dslGeneratorProject, (IFolder) dslGeneratorProject.findMember(SRC_ROOT), monitor),\n\t\t\t\t\t\t\"//Your model\", monitor);\n\t\t\t}\n\t\t\toutput.addOutlet(new Outlet(false, defaultEncoding, \"ACTIVATOR_OUTLET\", true, dslUIProject.getFolder(\n\t\t\t\t\tSRC_ROOT + IPath.SEPARATOR + xtextProjectInfo.getBasePath() + IPath.SEPARATOR + \"ui\").getLocation()\n\t\t\t\t\t.makeAbsolute().toOSString()));\n\t\t\tXpandExecutionContextImpl execCtx = new XpandExecutionContextImpl(output, null, Collections.singletonMap(\n\t\t\t\t\t\"xtextProjectInfo\", new Variable(\"xtextProjectInfo\", xtextProjectInfo)), null, null);\n\t\t\texecCtx.registerMetaModel(new JavaMetaModel());\n\n\t\t\t// generate generator and activator for dsl and dsl.ui project\n\t\t\tXpandFacade facade = XpandFacade.create(execCtx);\n\t\t\tfacade.evaluate(\"org::eclipse::xtext::xtext::ui::wizard::project::XtextTemplateFile::root\",\n\t\t\t\t\txtextProjectInfo);\n\t\t\tfacade\n\t\t\t\t\t.evaluate(\"org::eclipse::xtext::xtext::ui::wizard::project::GrammarGenerator::root\",\n\t\t\t\t\t\t\txtextProjectInfo);\n\t\t\tfacade.evaluate(\"org::eclipse::xtext::xtext::ui::wizard::project::Generator::root\", xtextProjectInfo);\n\n\t\t\tEclipseResourceUtil.createFile(\"dummy.properties\", createSubPackages(basePackage + \".ui.services\",\n\t\t\t\t\tdslUIProject, (IFolder) dslUIProject.findMember(SRC_ROOT), monitor), \"a=b\", monitor);\n\n\t\t\tmonitor.worked(1);\n\n\t\t\t// refresh folder and select file to edit\n\t\t\tbasePackageFolder.refreshLocal(1, monitor);\n\t\t\tIFile dslGrammarFile = getDslGrammarFile(basePackageFolder);\n\t\t\tBasicNewResourceWizard\n\t\t\t\t\t.selectAndReveal(dslGrammarFile, PlatformUI.getWorkbench().getActiveWorkbenchWindow());\n\t\t\tEclipseResourceUtil.openFileToEdit(getShell(), dslGrammarFile);\n\n\t\t}","commit_id":"b13175ac1440842155ec3c76ca04e9e5637ce9bc","url":"https://github.com/eclipse/xtext"},{"original_method":"@Issue(\"JENKINS-24433\")\n    @Test\n    public void testProjectNameBehindAFolderDisplayName() throws Exception {\n        final String projectName1 = \"job-1\";\n        final String displayName1 = \"job-1\";\n\n        final String projectName2 = \"job-2\";\n        final String displayName2 = \"job-2\";\n\n        FreeStyleProject project1 = j.createFreeStyleProject(projectName1);\n        project1.setDisplayName(displayName1);\n\n        FreeStyleProject project2 = j.createFolder(\"my-folder-1\").createProject(FreeStyleProject.class, projectName2);\n        project2.setDisplayName(displayName2);\n\n        WebClient wc = j.createWebClient();\n        Page result = wc.goTo(\"job/my-folder-1/search/suggest?query=\" + projectName1, \"application/json\");\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        String content = result.getWebResponse().getContentAsString();\n        JSONObject jsonContent = (JSONObject)JSONSerializer.toJSON(content);\n        assertNotNull(jsonContent);\n        JSONArray jsonArray = jsonContent.getJSONArray(\"suggestions\");\n        assertNotNull(jsonArray);\n\n        assertEquals(1, jsonArray.size());\n\n        boolean foundProjectName = false;\n        boolean foundDisplayName = false;\n        for(Object suggestion : jsonArray) {\n            JSONObject jsonSuggestion = (JSONObject)suggestion;\n\n            String name = (String)jsonSuggestion.get(\"name\");\n            if(projectName1.equals(name)) {\n                foundProjectName = true;\n            }\n            if(displayName1.equals(name)) {\n                foundDisplayName = true;\n            }\n        }\n\n        assertTrue(foundProjectName);\n        assertTrue(foundDisplayName);\n    }","id":29434,"modified_method":"@Issue(\"JENKINS-24433\")\n    @Test\n    public void testProjectNameBehindAFolderDisplayName() throws Exception {\n        final String projectName1 = \"job-1\";\n        final String displayName1 = \"job-1\";\n\n        final String projectName2 = \"job-2\";\n        final String displayName2 = \"job-2\";\n\n        FreeStyleProject project1 = j.createFreeStyleProject(projectName1);\n        project1.setDisplayName(displayName1);\n\n        FreeStyleProject project2 = j.createFolder(\"my-folder-1\").createProject(FreeStyleProject.class, projectName2);\n        project2.setDisplayName(displayName2);\n\n        WebClient wc = j.createWebClient();\n        Page result = wc.goTo(\"job/my-folder-1/search/suggest?query=\" + projectName1, \"application/json\");\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        String content = result.getWebResponse().getContentAsString();\n        JSONObject jsonContent = (JSONObject)JSONSerializer.toJSON(content);\n        assertNotNull(jsonContent);\n        JSONArray jsonArray = jsonContent.getJSONArray(\"suggestions\");\n        assertNotNull(jsonArray);\n\n        assertEquals(1, jsonArray.size());\n\n        boolean foundProjectName = false;\n        boolean foundDisplayName = false;\n        for(Object suggestion : jsonArray) {\n            JSONObject jsonSuggestion = (JSONObject)suggestion;\n\n            String name = (String)jsonSuggestion.get(\"name\");\n            if(displayName1.equals(name)) {\n                foundDisplayName = true;\n            }\n        }\n\n        assertTrue(foundDisplayName);\n    }","commit_id":"4535beee8552aeaa73e2d811e5a4e07cecd35a2d","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Issue(\"JENKINS-24433\")\n    @Test\n    public void testSearchByProjectNameBehindAFolder() throws Exception {\n        final String projectName = \"testSearchByProjectName\";\n        j.createFreeStyleProject(projectName);\n        j.createFolder(\"my-folder-1\").createProject(FreeStyleProject.class, \"my-job-1\");\n\n        Page result = j.createWebClient().goTo(\"job/my-folder-1/search?q=\"+ projectName);\n\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        // make sure we've fetched the testSearchByDisplayName project page\n        String contents = result.getWebResponse().getContentAsString();\n        assertTrue(contents.contains(String.format(\"<title>%s [Jenkins]<\/title>\", projectName)));\n    }","id":29435,"modified_method":"@Issue(\"JENKINS-24433\")\n    @Test\n    public void testSearchByProjectNameBehindAFolder() throws Exception {\n        FreeStyleProject myFreeStyleProject = j.createFreeStyleProject(\"testSearchByProjectName\");\n        MockFolder myMockFolder = j.createFolder(\"my-folder-1\");\n\n        Page result = j.createWebClient().goTo(myMockFolder.getUrl() + \"search?q=\"+ myFreeStyleProject.getName());\n\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        URL resultUrl = result.getWebResponse().getUrl();\n        assertTrue(resultUrl.toString().equals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl()));\n    }","commit_id":"4535beee8552aeaa73e2d811e5a4e07cecd35a2d","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Issue(\"JENKINS-24433\")\n    @Test\n    public void testSearchByProjectNameInAFolder() throws Exception {\n        final String projectName = \"testSearchByProjectName\";\n        j.createFreeStyleProject(projectName);\n        j.createFolder(\"my-folder-1\").createProject(FreeStyleProject.class, \"my-job-1\");\n\n        Page result = j.createWebClient().goTo(\"job/my-folder-1/search?q=\"+ \"my-folder-1/my-job-1\");\n\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        // make sure we've fetched the testSearchByDisplayName project page\n        String contents = result.getWebResponse().getContentAsString();\n        assertTrue(contents.contains(String.format(\"<title>%s [Jenkins]<\/title>\", \"my-job-1 [my-folder-1]\")));\n    }","id":29436,"modified_method":"@Issue(\"JENKINS-24433\")\n    @Test\n    public void testSearchByProjectNameInAFolder() throws Exception {\n\n        MockFolder myMockFolder = j.createFolder(\"my-folder-1\");\n        FreeStyleProject myFreeStyleProject = myMockFolder.createProject(FreeStyleProject.class, \"my-job-1\");\n\n        Page result = j.createWebClient().goTo(myMockFolder.getUrl() + \"search?q=\" + myFreeStyleProject.getFullName());\n\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        URL resultUrl = result.getWebResponse().getUrl();\n        assertTrue(resultUrl.toString().equals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl()));\n    }","commit_id":"4535beee8552aeaa73e2d811e5a4e07cecd35a2d","url":"https://github.com/kohsuke/hudson"},{"original_method":"public void testSkipNullPartialIndex() {\n        {\n            //CREATE INDEX partial_idx_6 ON c (g) where g is not null;\n            // skipNull predicate is redundant and eliminated\n            AbstractPlanNode pn = compile(\"select count(*) from c where g > 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXCOUNT, \"\\\"TARGET_INDEX_NAME\\\":\\\"PARTIAL_IDX_6\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, true);\n        }\n        {\n            //CREATE INDEX partial_idx_6 ON c (g) where g is not null;\n            // skipNull predicate is redundant and eliminated\n            AbstractPlanNode pn = compile(\"select e from c where g > 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXSCAN, \"\\\"TARGET_INDEX_NAME\\\":\\\"PARTIAL_IDX_6\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, true);\n        }\n        {\n            // CREATE UNIQUE INDEX z_full_idx_a ON c (a);\n            // skipNull is required - full index\n            AbstractPlanNode pn = compile(\"select count(*) from c where a > 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXCOUNT, \"\\\"TARGET_INDEX_NAME\\\":\\\"Z_FULL_IDX_A\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, false);\n        }\n        {\n            // CREATE UNIQUE INDEX z_full_idx_a ON c (a);\n            // skipNull is required - full index\n            AbstractPlanNode pn = compile(\"select e from c where a > 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXSCAN, \"\\\"TARGET_INDEX_NAME\\\":\\\"Z_FULL_IDX_A\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, false);\n        }\n        {\n            // CREATE INDEX partial_idx_3 ON c (b) where d > 0;\n            // skipNull is required - index predicate is not NULL-rejecting for column B\n            AbstractPlanNode pn = compile(\"select count(*) from c where b > 0 and d > 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXCOUNT, \"\\\"TARGET_INDEX_NAME\\\":\\\"PARTIAL_IDX_3\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, false);\n        }\n        {\n            // CREATE INDEX partial_idx_3 ON c (b) where d > 0;\n            // skipNull is required - index predicate is not NULL-rejecting for column B\n            AbstractPlanNode pn = compile(\"select b from c where b > 0 and d > 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXSCAN, \"\\\"TARGET_INDEX_NAME\\\":\\\"PARTIAL_IDX_3\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, false);\n        }\n    }","id":29437,"modified_method":"public void testSkipNullPartialIndex() {\n        {\n            //CREATE INDEX partial_idx_7 ON c (g) where g is not null;\n            // skipNull predicate is redundant and eliminated\n            AbstractPlanNode pn = compile(\"select count(*) from c where g > 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXCOUNT, \"\\\"TARGET_INDEX_NAME\\\":\\\"PARTIAL_IDX_7\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, false);\n        }\n        {\n            //CREATE INDEX partial_idx_7 ON c (g) where g is not null;\n            // skipNull predicate is redundant and eliminated\n            AbstractPlanNode pn = compile(\"select e from c where g > 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXSCAN, \"\\\"TARGET_INDEX_NAME\\\":\\\"PARTIAL_IDX_7\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, false);\n        }\n        {\n            //CREATE INDEX partial_idx_6 ON c (g) where g < 0;\n            // skipNull predicate is redundant and eliminated\n            AbstractPlanNode pn = compile(\"select count(*) from c where g < 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXCOUNT, \"\\\"TARGET_INDEX_NAME\\\":\\\"PARTIAL_IDX_6\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, false);\n        }\n        {\n            //CREATE INDEX partial_idx_6 ON c (g) where g < 0;\n            // skipNull predicate is redundant and eliminated\n            AbstractPlanNode pn = compile(\"select g from c where g < 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXSCAN, \"\\\"TARGET_INDEX_NAME\\\":\\\"PARTIAL_IDX_6\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, false);\n        }\n        {\n            // CREATE UNIQUE INDEX z_full_idx_a ON c (a);\n            // skipNull is required - full index\n            AbstractPlanNode pn = compile(\"select count(*) from c where a > 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXCOUNT, \"\\\"TARGET_INDEX_NAME\\\":\\\"Z_FULL_IDX_A\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, true);\n        }\n        {\n            // CREATE UNIQUE INDEX z_full_idx_a ON c (a);\n            // skipNull is required - full index\n            AbstractPlanNode pn = compile(\"select e from c where a > 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXSCAN, \"\\\"TARGET_INDEX_NAME\\\":\\\"Z_FULL_IDX_A\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, true);\n        }\n        {\n            // CREATE INDEX partial_idx_3 ON c (b) where d > 0;\n            // skipNull is required - index predicate is not NULL-rejecting for column B\n            AbstractPlanNode pn = compile(\"select count(*) from c where b > 0 and d > 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXCOUNT, \"\\\"TARGET_INDEX_NAME\\\":\\\"PARTIAL_IDX_3\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, true);\n        }\n        {\n            // CREATE INDEX partial_idx_3 ON c (b) where d > 0;\n            // skipNull is required - index predicate is not NULL-rejecting for column B\n            AbstractPlanNode pn = compile(\"select b from c where b > 0 and d > 0;\");\n            checkIndexName(pn, PlanNodeType.INDEXSCAN, \"\\\"TARGET_INDEX_NAME\\\":\\\"PARTIAL_IDX_3\\\"\");\n            checkIndexSkipNullPredicateIsNull(pn, true);\n        }\n    }","commit_id":"a541d5f9f18afb5530b275e36b2e8fc161f219a3","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void checkIndexPredicateContains(AbstractPlanNode pn, String[] columns)\n    {\n        assertEquals(1, pn.getChildCount());\n        pn = pn.getChild(0);\n        assertEquals(PlanNodeType.INDEXSCAN, pn.getPlanNodeType());\n        IndexScanPlanNode ipn = (IndexScanPlanNode) pn;\n        AbstractExpression pred = ipn.getPredicate();\n        assertTrue(pred != null);\n        List<TupleValueExpression> tves = ExpressionUtil.getTupleValueExpressions(pred);\n        for (TupleValueExpression tve : tves) {\n            boolean match = false;\n            for (String column: columns) {\n                if (match = tve.getColumnName().equals(column)) {\n                    break;\n                }\n            }\n            assertTrue(match == true);\n        }\n    }","id":29438,"modified_method":"private void checkIndexPredicateContains(AbstractPlanNode pn, String[] columns)\n    {\n        assertEquals(1, pn.getChildCount());\n        pn = pn.getChild(0);\n        assertEquals(PlanNodeType.INDEXSCAN, pn.getPlanNodeType());\n        IndexScanPlanNode ipn = (IndexScanPlanNode) pn;\n        AbstractExpression pred = ipn.getPredicate();\n        assertTrue(pred != null);\n        List<TupleValueExpression> tves = ExpressionUtil.getTupleValueExpressions(pred);\n        for (TupleValueExpression tve : tves) {\n            boolean match = false;\n            for (String column: columns) {\n                if (match = tve.getColumnName().equals(column)) {\n                    break;\n                }\n            }\n            assertEquals(true, match);\n        }\n    }","commit_id":"a541d5f9f18afb5530b275e36b2e8fc161f219a3","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void checkIndexSkipNullPredicateIsNull(AbstractPlanNode pn, boolean isTrue) {\n        assertEquals(1, pn.getChildCount());\n        pn = pn.getChild(0);\n        String json = pn.toJSONString();\n        if (pn instanceof IndexCountPlanNode) {\n            assertTrue(isTrue == (!json.contains(\"SKIP_NULL_PREDICATE\")));\n        } else {\n            // index scan\n            AbstractExpression skipNull = ((IndexScanPlanNode) pn).getSkipNullPredicate();\n            assertTrue(isTrue == (skipNull == null));\n        }\n    }","id":29439,"modified_method":"private void checkIndexSkipNullPredicateIsNull(AbstractPlanNode pn, boolean hasSkipNullPredicate) {\n        assertEquals(1, pn.getChildCount());\n        pn = pn.getChild(0);\n        String json = pn.toJSONString();\n        if (pn instanceof IndexCountPlanNode) {\n            assertEquals(hasSkipNullPredicate, json.contains(\"SKIP_NULL_PREDICATE\"));\n        } else {\n            // index scan\n            AbstractExpression skipNull = ((IndexScanPlanNode) pn).getSkipNullPredicate();\n            assertEquals(hasSkipNullPredicate, skipNull != null);\n        }\n    }","commit_id":"a541d5f9f18afb5530b275e36b2e8fc161f219a3","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n  public void can_load() {\n    BaseIndex index = getIndex(this.searchClient);\n    assertThat(index).isNotNull();\n  }","id":29440,"modified_method":"@Test\n  public void can_load() {\n    BaseIndex index = getIndex(searchClient);\n    assertThat(index).isNotNull();\n  }","commit_id":"45bf3e6974a3c664d920fc34783dabb1268a6039","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setup() throws IOException {\n    File dataDir = temp.newFolder();\n    Settings settings = new Settings();\n    settings.setProperty(ProcessConstants.CLUSTER_ACTIVATE, false);\n    settings.setProperty(ProcessConstants.CLUSTER_NAME, clusterName);\n    settings.setProperty(ProcessConstants.CLUSTER_NODE_NAME, \"test\");\n    settings.setProperty(ProcessConstants.SEARCH_PORT, clusterPort.toString());\n    settings.setProperty(ProcessConstants.PATH_HOME, dataDir.getAbsolutePath());\n    searchClient = new SearchClient(settings);\n  }","id":29441,"modified_method":"@Before\n  public void setup() throws IOException {\n    EsServerHolder holder = EsServerHolder.get();\n    Settings settings = new Settings();\n    settings.setProperty(ProcessConstants.CLUSTER_ACTIVATE, false);\n    settings.setProperty(ProcessConstants.CLUSTER_NAME, holder.getClusterName());\n    settings.setProperty(ProcessConstants.CLUSTER_NODE_NAME, holder.getNodeName());\n    settings.setProperty(ProcessConstants.SEARCH_PORT, String.valueOf(holder.getPort()));\n    searchClient = new SearchClient(settings);\n  }","commit_id":"45bf3e6974a3c664d920fc34783dabb1268a6039","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * This method should not be called by test when ServerTester is annotated with {@link org.junit.Rule}\n   */\n  public void start() {\n    checkNotStarted();\n\n    Properties properties = new Properties();\n    properties.putAll(initialProps);\n    properties.setProperty(ProcessConstants.CLUSTER_NAME, clusterName);\n    properties.setProperty(ProcessConstants.CLUSTER_NODE_NAME, \"test\");\n    properties.setProperty(ProcessConstants.SEARCH_PORT, clusterPort.toString());\n    properties.setProperty(ProcessConstants.PATH_HOME, homeDir.getAbsolutePath());\n    properties.setProperty(DatabaseProperties.PROP_URL, \"jdbc:h2:\" + homeDir.getAbsolutePath() + \"/h2\");\n    for (Map.Entry<Object, Object> entry : System.getProperties().entrySet()) {\n      String key = entry.getKey().toString();\n      if (key.startsWith(PROP_PREFIX)) {\n        properties.put(StringUtils.substringAfter(key, PROP_PREFIX), entry.getValue());\n      }\n    }\n\n    try {\n      LOG.info(\"Starting elasticsearch server\");\n      searchServer.start();\n      // wait for ES to be ready\n      searchServer.isReady();\n      LOG.info(\"Elasticsearch server started\");\n      \n      platform.init(properties);\n      platform.addComponents(components);\n      platform.doStart();\n    } catch (Exception e) {\n      stop();\n      Throwables.propagate(e);\n    }\n    if (!platform.isStarted()) {\n      throw new IllegalStateException(\"Server not started. You should check that db migrations \" +\n        \"are correctly declared, for example in schema-h2.sql or DatabaseVersion\");\n    }\n  }","id":29442,"modified_method":"/**\n   * This method should not be called by test when ServerTester is annotated with {@link org.junit.Rule}\n   */\n  public void start() {\n    checkNotStarted();\n\n    try {\n      Properties properties = new Properties();\n      properties.putAll(initialProps);\n      EsServerHolder esServerHolder = EsServerHolder.get();\n\n      properties.setProperty(ProcessConstants.CLUSTER_NAME, esServerHolder.getClusterName());\n      properties.setProperty(ProcessConstants.CLUSTER_NODE_NAME, esServerHolder.getNodeName());\n      properties.setProperty(ProcessConstants.SEARCH_PORT, String.valueOf(esServerHolder.getPort()));\n      properties.setProperty(ProcessConstants.PATH_HOME, homeDir.getAbsolutePath());\n      properties.setProperty(DatabaseProperties.PROP_URL, \"jdbc:h2:\" + homeDir.getAbsolutePath() + \"/h2\");\n      for (Map.Entry<Object, Object> entry : System.getProperties().entrySet()) {\n        String key = entry.getKey().toString();\n        if (key.startsWith(PROP_PREFIX)) {\n          properties.put(StringUtils.substringAfter(key, PROP_PREFIX), entry.getValue());\n        }\n      }\n      platform = new Platform();\n      platform.init(properties);\n      platform.addComponents(components);\n      platform.doStart();\n    } catch (Exception e) {\n      stop();\n      Throwables.propagate(e);\n    }\n    if (!platform.isStarted()) {\n      throw new IllegalStateException(\"Server not started. You should check that db migrations \" +\n        \"are correctly declared, for example in schema-h2.sql or DatabaseVersion\");\n    }\n  }","commit_id":"45bf3e6974a3c664d920fc34783dabb1268a6039","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * This method should not be called by test when ServerTester is annotated with {@link org.junit.Rule}\n   */\n  public void stop() {\n    try {\n      if (platform != null) {\n        platform.doStop();\n      }\n    } catch (Exception e) {\n      LOG.error(\"Fail to stop web server\", e);\n    }\n    platform = null;\n    try {\n      if (searchServer != null) {\n        LOG.info(\"Stopping Elasticsearch server\");\n        searchServer.stop();\n        LOG.info(\"Elasticsearch server stopped\");\n      }\n    } catch (Exception e) {\n      LOG.error(\"Fail to stop elasticsearch server\", e);\n    }\n    searchServer = null;\n    FileUtils.deleteQuietly(homeDir);\n  }","id":29443,"modified_method":"/**\n   * This method should not be called by test when ServerTester is annotated with {@link org.junit.Rule}\n   */\n  public void stop() {\n    try {\n      if (platform != null) {\n        platform.doStop();\n      }\n    } catch (Exception e) {\n      LOG.error(\"Fail to stop web server\", e);\n    }\n    platform = null;\n    FileUtils.deleteQuietly(homeDir);\n  }","commit_id":"45bf3e6974a3c664d920fc34783dabb1268a6039","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        BasicCacheContainer cacheContainer = configuration.getCacheContainer();\n        String cacheName = configuration.getCacheName();\n        cache = cacheName == null ? cacheContainer.getCache() : cacheContainer.getCache(cacheName);\n        if (InfinispanUtil.isEmbedded(cacheContainer)) {\n            listener = InfinispanConsumerEmbeddedHandler.INSTANCE.start(this);\n        } else if (InfinispanUtil.isRemote(cacheContainer)) {\n            listener = InfinispanConsumerRemoteHandler.INSTANCE.start(this);\n        } else {\n            throw new UnsupportedOperationException(\"Consumer not support for CacheContainer: \" + cacheContainer);\n        }\n        super.doStart();\n\n    }","id":29444,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        BasicCacheContainer cacheContainer = configuration.getCacheContainer();\n        cache = InfinispanUtil.getCache(configuration.getCacheContainer(), configuration.getCacheName());\n\n        if (configuration.hasQueryBuilder()) {\n            if (InfinispanUtil.isRemote(cache)) {\n                RemoteCache<Object, Object> remoteCache = InfinispanUtil.asRemote(cache);\n                Query query = InfinispanRemoteOperation.buildQuery(configuration.getQueryBuilder(), remoteCache);\n\n                continuousQuery = Search.getContinuousQuery(remoteCache);\n                continuousQuery.addContinuousQueryListener(query, new ContinuousQueryEventListener(cache.getName()));\n            } else {\n                throw new IllegalArgumentException(\"Can't run continuous queries against embedded cache (\" + cache.getName() + \")\");\n            }\n        } else {\n            if (InfinispanUtil.isEmbedded(cacheContainer)) {\n                consumerHandler = InfinispanConsumerEmbeddedHandler.INSTANCE;\n            } else if (InfinispanUtil.isRemote(cacheContainer)) {\n                consumerHandler = InfinispanConsumerRemoteHandler.INSTANCE;\n            } else {\n                throw new UnsupportedOperationException(\"Consumer not support for CacheContainer: \" + cacheContainer);\n            }\n\n            listener = consumerHandler.start(this);\n        }\n    }","commit_id":"9df244d2f7e2e0979f429e1db5448787ce6cca20","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStop() throws Exception {\n        if (cacheManager != null) {\n            cacheManager.removeListener(listener);\n        }\n        super.doStop();\n    }","id":29445,"modified_method":"@Override\n    protected void doStop() throws Exception {\n        if (continuousQuery != null) {\n            continuousQuery.removeAllListeners();\n        }\n\n        if (consumerHandler != null) {\n            consumerHandler.stop(this);\n        }\n\n        super.doStop();\n    }","commit_id":"9df244d2f7e2e0979f429e1db5448787ce6cca20","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void stop(InfinispanConsumer consumer) {\n        RemoteCache<?, ?> remoteCache = (RemoteCache<?, ?>) consumer.getCache();\n        remoteCache.removeClientListener(consumer.getListener());\n    }","id":29446,"modified_method":"@Override\n    public void stop(InfinispanConsumer consumer) {\n        InfinispanUtil.asRemote(consumer.getCache()).removeClientListener(consumer.getListener());\n    }","commit_id":"9df244d2f7e2e0979f429e1db5448787ce6cca20","url":"https://github.com/apache/camel"},{"original_method":"public static Query buildQuery(InfinispanQueryBuilder queryBuilder, BasicCache<Object, Object> cache) {\n        return queryBuilder != null ? queryBuilder.build(Search.getQueryFactory(InfinispanUtil.asRemote(cache))) : null;\n    }","id":29447,"modified_method":"public static Query buildQuery(InfinispanQueryBuilder queryBuilder, BasicCache<Object, Object> cache) {\n        return buildQuery(queryBuilder, InfinispanUtil.asRemote(cache));\n    }","commit_id":"9df244d2f7e2e0979f429e1db5448787ce6cca20","url":"https://github.com/apache/camel"},{"original_method":"public final void start() {\n    if (monitor != null) {\n      throw new IllegalStateException(\"Already started\");\n    }\n    LOGGER.debug(\"Process[{}] starting\", name);\n    scheduleAutokill(this.isMonitored);\n    doStart();\n    LOGGER.debug(\"Process[{}] started\", name);\n  }","id":29448,"modified_method":"public final void start() {\n    if (monitor != null) {\n      throw new IllegalStateException(\"Already started\");\n    }\n    LOGGER.debug(\"Process[{}] starting\", name);\n    scheduleAutokill(this.isMonitored);\n    try {\n      doStart();\n    } catch (Exception e) {\n      LOGGER.error(\"Could not start process: {}\", e);\n      this.terminate();\n    }\n    LOGGER.debug(\"Process[{}] started\", name);\n  }","commit_id":"bfe5863aae84dc467e19fc58ed494422c5bb6e13","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  protected void doStart() {\n\n    Integer port = props.intOf(ES_PORT_PROPERTY);\n    String clusterName = props.of(ES_CLUSTER_PROPERTY);\n\n    LoggerFactory.getLogger(SearchServer.class).info(\"Starting ES[{}] on port: {}\", clusterName, port);\n\n    ImmutableSettings.Builder esSettings = ImmutableSettings.settingsBuilder()\n\n      // Disable MCast\n      .put(\"discovery.zen.ping.multicast.enabled\", \"false\")\n\n        // Index storage policies\n      .put(\"index.merge.policy.max_merge_at_once\", \"200\")\n      .put(\"index.merge.policy.segments_per_tier\", \"200\")\n      .put(\"index.number_of_shards\", \"1\")\n      .put(\"index.number_of_replicas\", MINIMUM_INDEX_REPLICATION)\n      .put(\"index.store.type\", \"mmapfs\")\n      .put(\"indices.store.throttle.type\", \"merge\")\n      .put(\"indices.store.throttle.max_bytes_per_sec\", \"200mb\")\n\n        // Install our own listUpdate scripts\n      .put(\"script.default_lang\", \"native\")\n      .put(\"script.native.\" + ListUpdate.NAME + \".type\", ListUpdate.UpdateListScriptFactory.class.getName())\n\n        // Node is pure transport\n      .put(\"transport.tcp.port\", port)\n      .put(\"http.enabled\", false)\n\n        // Setting up ES paths\n      .put(\"path.data\", esDataDir().getAbsolutePath())\n      .put(\"path.work\", esWorkDir().getAbsolutePath())\n      .put(\"path.logs\", esLogDir().getAbsolutePath());\n\n    if (!nodes.isEmpty()) {\n      LoggerFactory.getLogger(SearchServer.class).info(\"Joining ES cluster with masters: {}\", nodes);\n      esSettings.put(\"discovery.zen.ping.unicast.hosts\", StringUtils.join(nodes, \",\"));\n\n      // Enforce a N/2+1 number of masters in cluster\n      esSettings.put(\"discovery.zen.minimum_master_nodes\",\n        (int) Math.floor(nodes.size() / 2.0) + 1);\n    }\n\n    // Set cluster coordinates\n    esSettings.put(\"cluster.name\", clusterName);\n    esSettings.put(\"node.rack_id\", StringUtils.defaultIfEmpty(props.of(SONAR_NODE_NAME), \"unknown\"));\n    esSettings.put(\"cluster.routing.allocation.awareness.attributes\", \"rack_id\");\n    if (props.contains(SONAR_NODE_NAME)) {\n      esSettings.put(\"node.name\", props.of(SONAR_NODE_NAME));\n    } else {\n      try {\n        esSettings.put(\"node.name\", InetAddress.getLocalHost().getHostName());\n      } catch (Exception e) {\n        LoggerFactory.getLogger(SearchServer.class).warn(\"Could not determine hostname\", e);\n        esSettings.put(\"node.name\", \"sq-\" + System.currentTimeMillis());\n      }\n    }\n\n    // Make sure the index settings are up to date.\n    initAnalysis(esSettings);\n\n    // And building our ES Node\n    node = NodeBuilder.nodeBuilder()\n      .settings(esSettings)\n      .build().start();\n\n    node.client().admin().indices()\n      .preparePutTemplate(\"default\")\n      .setTemplate(\"*\")\n      .addMapping(\"_default_\", \"{\\\"dynamic\\\": \\\"strict\\\"}\")\n      .get();\n\n    if (this.isBlocking) {\n      while (node != null && !node.isClosed()) {\n        try {\n          Thread.sleep(100);\n        } catch (InterruptedException e) {\n          // Ignore\n        }\n      }\n    }\n  }","id":29449,"modified_method":"@Override\n  protected void doStart() {\n\n    Integer port = props.intOf(ES_PORT_PROPERTY);\n    String clusterName = props.of(ES_CLUSTER_PROPERTY);\n\n    LoggerFactory.getLogger(SearchServer.class).info(\"Starting ES[{}] on port: {}\", clusterName, port);\n\n    ImmutableSettings.Builder esSettings = ImmutableSettings.settingsBuilder()\n\n      // Disable MCast\n      .put(\"discovery.zen.ping.multicast.enabled\", \"false\")\n\n        // Index storage policies\n      .put(\"index.merge.policy.max_merge_at_once\", \"200\")\n      .put(\"index.merge.policy.segments_per_tier\", \"200\")\n      .put(\"index.number_of_shards\", \"1\")\n      .put(\"index.number_of_replicas\", MINIMUM_INDEX_REPLICATION)\n      .put(\"index.store.type\", \"mmapfs\")\n      .put(\"indices.store.throttle.type\", \"merge\")\n      .put(\"indices.store.throttle.max_bytes_per_sec\", \"200mb\")\n\n        // Install our own listUpdate scripts\n      .put(\"script.default_lang\", \"native\")\n      .put(\"script.native.\" + ListUpdate.NAME + \".type\", ListUpdate.UpdateListScriptFactory.class.getName())\n\n        // Node is pure transport\n      .put(\"transport.tcp.port\", port)\n      .put(\"http.enabled\", false)\n\n        // Setting up ES paths\n      .put(\"path.data\", esDataDir().getAbsolutePath())\n      .put(\"path.work\", esWorkDir().getAbsolutePath())\n      .put(\"path.logs\", esLogDir().getAbsolutePath());\n\n    if (!nodes.isEmpty()) {\n\n      LoggerFactory.getLogger(SearchServer.class).info(\"Joining ES cluster with masters: {}\", nodes);\n      esSettings.put(\"discovery.zen.ping.unicast.hosts\", StringUtils.join(nodes, \",\"));\n      esSettings.put(\"node.master\", false);\n      // Enforce a N/2+1 number of masters in cluster\n      esSettings.put(\"discovery.zen.minimum_master_nodes\", 1);\n      // Change master pool requirement when in distributed mode\n      // esSettings.put(\"discovery.zen.minimum_master_nodes\", (int) Math.floor(nodes.size() / 2.0) + 1);\n    }\n\n    // Set cluster coordinates\n    esSettings.put(\"cluster.name\", clusterName);\n    esSettings.put(\"node.rack_id\", StringUtils.defaultIfEmpty(props.of(SONAR_NODE_NAME), \"unknown\"));\n    esSettings.put(\"cluster.routing.allocation.awareness.attributes\", \"rack_id\");\n    if (props.contains(SONAR_NODE_NAME)) {\n      esSettings.put(\"node.name\", props.of(SONAR_NODE_NAME));\n    } else {\n      try {\n        esSettings.put(\"node.name\", InetAddress.getLocalHost().getHostName());\n      } catch (Exception e) {\n        LoggerFactory.getLogger(SearchServer.class).warn(\"Could not determine hostname\", e);\n        esSettings.put(\"node.name\", \"sq-\" + System.currentTimeMillis());\n      }\n    }\n\n    // Make sure the index settings are up to date.\n    initAnalysis(esSettings);\n\n    // And building our ES Node\n    node = NodeBuilder.nodeBuilder()\n      .settings(esSettings)\n      .build().start();\n\n    node.client().admin().indices()\n      .preparePutTemplate(\"default\")\n      .setTemplate(\"*\")\n      .addMapping(\"_default_\", \"{\\\"dynamic\\\": \\\"strict\\\"}\")\n      .get();\n\n    if (this.isBlocking) {\n      while (node != null && !node.isClosed()) {\n        try {\n          Thread.sleep(100);\n        } catch (InterruptedException e) {\n          // Ignore\n        }\n      }\n    }\n  }","commit_id":"bfe5863aae84dc467e19fc58ed494422c5bb6e13","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * The main entry point to the Sling Launcher Standalone Java Application.\n     * This method is generally only called by the Java VM to launch Sling.\n     *\n     * @param args The command line arguments supplied when starting the Sling\n     *            Launcher through the Java VM.\n     */\n    public static void main(final String[] args) {\n        final Map<String, String> rawArgs = parseCommandLine(args);\n\n        // support usage first\n        if (doHelp(rawArgs)) {\n            System.exit(0);\n        }\n\n        final Map<String, String> props = convertCommandLineArgs(rawArgs);\n        if (props == null) {\n            System.exit(1);\n        }\n\n        final Main main = new Main(props);\n\n        // check for control commands\n        int rc = main.doControlAction();\n        if (rc >= 0) {\n            main.terminateVM(rc);\n        }\n\n        // finally start Sling\n        main.doStart();\n    }","id":29450,"modified_method":"/**\n     * The main entry point to the Sling Launcher Standalone Java Application.\n     * This method is generally only called by the Java VM to launch Sling.\n     *\n     * @param args The command line arguments supplied when starting the Sling\n     *            Launcher through the Java VM.\n     */\n    public static void main(final String[] args) {\n        final Map<String, String> rawArgs = parseCommandLine(args);\n\n        // support usage first\n        if (doHelp(rawArgs)) {\n            System.exit(0);\n        }\n\n        final Map<String, String> props = convertCommandLineArgs(rawArgs);\n        if (props == null) {\n            System.exit(1);\n        }\n\n        final Main main = new Main(props);\n\n        // check for control commands\n        int rc = main.doControlAction();\n        if (rc >= 0) {\n            main.terminateVM(rc);\n        }\n\n        // finally start Sling\n        if (!main.doStart()) {\n            error(\"Failed to start Sling; terminating\", null);\n            main.terminateVM(1);\n        }\n    }","commit_id":"e51139cbf7874b45de92280d2bd74af059487370","url":"https://github.com/apache/sling"},{"original_method":"private boolean startSling(final URL launcherJar) {\n        if (launcherJar != null) {\n            try {\n                loader.installLauncherJar(launcherJar);\n            } catch (IOException ioe) {\n                startupFailure(\"Failed installing \" + launcherJar, ioe);\n                return false;\n            }\n        } else {\n            info(\"No Launcher JAR to install\", null);\n        }\n\n        Object object = null;\n        try {\n            object = loader.loadLauncher(SharedConstants.DEFAULT_SLING_MAIN);\n        } catch (IllegalArgumentException iae) {\n            startupFailure(\"Failed loading Sling class \"\n                + SharedConstants.DEFAULT_SLING_MAIN, iae);\n            return false;\n        }\n\n        if (object instanceof Launcher) {\n\n            // configure the launcher\n            Launcher sling = (Launcher) object;\n            sling.setNotifiable(new Notified());\n            sling.setCommandLine(commandLineArgs);\n            sling.setSlingHome(slingHome);\n\n            // launch it\n            info(\"Starting launcher ...\", null);\n            if (sling.start()) {\n                info(\"Startup completed\", null);\n                this.sling = sling;\n                addShutdownHook();\n                return true;\n            }\n\n            error(\"There was a problem launching Apache Sling\", null);\n        }\n\n        return false;\n    }","id":29451,"modified_method":"private boolean startSling(final URL launcherJar) {\n        if (launcherJar != null) {\n            try {\n                loader.installLauncherJar(launcherJar);\n            } catch (IOException ioe) {\n                error(\"Cannot launch: Cannot install \" + launcherJar\n                    + \" for use\", ioe);\n                return false;\n            }\n        } else {\n            info(\"No Launcher JAR to install\", null);\n        }\n\n        Object object = null;\n        try {\n            object = loader.loadLauncher(SharedConstants.DEFAULT_SLING_MAIN);\n        } catch (IllegalArgumentException iae) {\n            error(\"Cannot launch: Failed loading Sling class \"\n                + SharedConstants.DEFAULT_SLING_MAIN, iae);\n            return false;\n        }\n\n        if (object instanceof Launcher) {\n\n            // configure the launcher\n            Launcher sling = (Launcher) object;\n            sling.setNotifiable(new Notified());\n            sling.setCommandLine(commandLineArgs);\n            sling.setSlingHome(slingHome);\n\n            // launch it\n            info(\"Starting launcher ...\", null);\n            if (sling.start()) {\n                info(\"Startup completed\", null);\n                this.sling = sling;\n                addShutdownHook();\n                return true;\n            }\n\n            error(\"Cannot launch: Launcher.start() returned false\", null);\n\n        } else {\n\n            error(\"Cannot launch: Class \" + SharedConstants.DEFAULT_SLING_MAIN + \" is not a Launcher class\", null);\n\n        }\n\n        return false;\n    }","commit_id":"e51139cbf7874b45de92280d2bd74af059487370","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Starts the application with the configuration supplied with the\n     * configuration properties when this instance has been created.\n     * <p>\n     * Calling this method multiple times before calling {@link #doStop()} will\n     * cause a message to be printed and <code>true<\/code> being returned.\n     *\n     * @return <code>true<\/code> if startup was successfull or the application\n     *         is considered to be started already. Otherwise an error message\n     *         has been logged and <code>false<\/code> is returned.\n     */\n    protected boolean doStart() {\n\n        // prevent duplicate start\n        if ( this.started) {\n            info(\"Apache Sling has already been started\", null);\n            return true;\n        }\n\n        info(\"Starting Apache Sling in \" + slingHome, null);\n        this.started = true;\n\n        // The Loader helper\n        Loader loaderTmp = null;\n        try {\n            final File launchpadHome = getLaunchpadHome(slingHome,\n                commandLineArgs);\n            loaderTmp = new Loader(launchpadHome) {\n                @Override\n                protected void info(String msg) {\n                    Main.info(msg, null);\n                }\n            };\n        } catch (IllegalArgumentException iae) {\n            startupFailure(iae.getMessage(), null);\n            return false;\n        }\n        this.loader = loaderTmp;\n\n        // ensure up-to-date launcher jar\n        return startSling(getClass().getResource(\n            SharedConstants.DEFAULT_SLING_LAUNCHER_JAR));\n    }","id":29452,"modified_method":"/**\n     * Starts the application with the configuration supplied with the\n     * configuration properties when this instance has been created.\n     * <p>\n     * Calling this method multiple times before calling {@link #doStop()} will\n     * cause a message to be printed and <code>true<\/code> being returned.\n     *\n     * @return <code>true<\/code> if startup was successfull or the application\n     *         is considered to be started already. Otherwise an error message\n     *         has been logged and <code>false<\/code> is returned.\n     */\n    protected boolean doStart() {\n\n        // prevent duplicate start\n        if ( this.started) {\n            info(\"Apache Sling has already been started\", null);\n            return true;\n        }\n\n        info(\"Starting Apache Sling in \" + slingHome, null);\n        this.started = true;\n\n        // The Loader helper\n        Loader loaderTmp = null;\n        try {\n            final File launchpadHome = getLaunchpadHome(slingHome,\n                commandLineArgs);\n            loaderTmp = new Loader(launchpadHome) {\n                @Override\n                protected void info(String msg) {\n                    Main.info(msg, null);\n                }\n            };\n        } catch (IllegalArgumentException iae) {\n            error(\n                \"Cannot launch: Launchpad folder cannot be used: \"\n                    + iae.getMessage(), null);\n            return false;\n        }\n        this.loader = loaderTmp;\n\n        // ensure up-to-date launcher jar\n        return startSling(getClass().getResource(\n            SharedConstants.DEFAULT_SLING_LAUNCHER_JAR));\n    }","commit_id":"e51139cbf7874b45de92280d2bd74af059487370","url":"https://github.com/apache/sling"},{"original_method":"/**\n         * The framework has been stopped with the intent to be restarted by\n         * calling either of the <code>Bundle.update<\/code> methods on the\n         * system bundle.\n         * <p>\n         * If an <code>InputStream<\/code> was provided, this has been copied to\n         * a temporary file, which will be used in place of the existing\n         * launcher jar file.\n         *\n         * @param updateFile The temporary file to replace the existing launcher\n         *            jar file. If <code>null<\/code> the existing launcher jar\n         *            will be used again.\n         */\n        public void updated(File updateFile) {\n\n            Main.this.sling = null;\n            Main.this.stopSling();\n\n            if (updateFile == null) {\n\n                Main.info(\"Restarting Framework and Apache Sling\", null);\n                Main.this.startSling(null);\n\n            } else {\n\n                Main.info(\n                    \"Restarting Framework with update from \" + updateFile, null);\n                try {\n                    Main.this.startSling(updateFile.toURI().toURL());\n                } catch (MalformedURLException mue) {\n                    Main.error(\"Cannot get URL for file \" + updateFile, mue);\n                } finally {\n                    updateFile.delete();\n                }\n\n            }\n        }","id":29453,"modified_method":"/**\n         * The framework has been stopped with the intent to be restarted by\n         * calling either of the <code>Bundle.update<\/code> methods on the\n         * system bundle.\n         * <p>\n         * If an <code>InputStream<\/code> was provided, this has been copied to\n         * a temporary file, which will be used in place of the existing\n         * launcher jar file.\n         *\n         * @param updateFile The temporary file to replace the existing launcher\n         *            jar file. If <code>null<\/code> the existing launcher jar\n         *            will be used again.\n         */\n        public void updated(File updateFile) {\n\n            Main.this.sling = null;\n            Main.this.stopSling();\n\n            if (updateFile == null) {\n\n                Main.info(\"Restarting Framework and Apache Sling\", null);\n                if (!Main.this.startSling(null)) {\n                    Main.error(\"Failed to restart Sling; terminating\", null);\n                    Main.this.terminateVM(1);\n                }\n\n            } else {\n\n                Main.info(\n                    \"Restarting Framework with update from \" + updateFile, null);\n                boolean started = false;\n                try {\n                    started = Main.this.startSling(updateFile.toURI().toURL());\n                } catch (MalformedURLException mue) {\n                    Main.error(\"Cannot get URL for file \" + updateFile, mue);\n                } finally {\n                    updateFile.delete();\n                }\n\n                if (!started) {\n                    Main.error(\"Failed to restart Sling; terminating\", null);\n                    Main.this.terminateVM(1);\n                }\n            }\n        }","commit_id":"e51139cbf7874b45de92280d2bd74af059487370","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void setFloatAttribute(String key, float value) {\n        notSupportedOnClient();\n    }","id":29454,"modified_method":"@Override\n    public void setFloatAttribute(String key, float value) {\n        throw notSupportedOnClient();\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void setLongAttribute(String key, long value) {\n        notSupportedOnClient();\n    }","id":29455,"modified_method":"@Override\n    public void setLongAttribute(String key, long value) {\n        throw notSupportedOnClient();\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void removeAttribute(String key) {\n        notSupportedOnClient();\n    }","id":29456,"modified_method":"@Override\n    public void removeAttribute(String key) {\n        throw notSupportedOnClient();\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Double getDoubleAttribute(String key) {\n        final Object attribute = getAttribute(key);\n        return attribute != null ? Double.valueOf(attribute.toString()) : null;\n    }","id":29457,"modified_method":"@Override\n    public Double getDoubleAttribute(String key) {\n        Object attribute = getAttribute(key);\n        return attribute != null ? Double.valueOf(attribute.toString()) : null;\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"null means 'missing'\")\n    @Override\n    public Boolean getBooleanAttribute(String key) {\n        final Object attribute = getAttribute(key);\n        return attribute != null ? Boolean.valueOf(attribute.toString()) : null;\n    }","id":29458,"modified_method":"@SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"null means 'missing'\")\n    @Override\n    public Boolean getBooleanAttribute(String key) {\n        Object attribute = getAttribute(key);\n        return attribute != null ? Boolean.valueOf(attribute.toString()) : null;\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void setShortAttribute(String key, short value) {\n        notSupportedOnClient();\n    }","id":29459,"modified_method":"@Override\n    public void setShortAttribute(String key, short value) {\n        throw notSupportedOnClient();\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void notSupportedOnClient() {\n        throw new UnsupportedOperationException(\"Attributes on remote members must not be changed\");\n    }","id":29460,"modified_method":"private UnsupportedOperationException notSupportedOnClient() {\n        return new UnsupportedOperationException(\"Attributes on remote members must not be changed\");\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Integer getIntAttribute(String key) {\n        final Object attribute = getAttribute(key);\n        return attribute != null ? Integer.valueOf(attribute.toString()) : null;\n    }","id":29461,"modified_method":"@Override\n    public Integer getIntAttribute(String key) {\n        Object attribute = getAttribute(key);\n        return attribute != null ? Integer.valueOf(attribute.toString()) : null;\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Byte getByteAttribute(String key) {\n        final Object attribute = getAttribute(key);\n        return attribute != null ? Byte.valueOf(attribute.toString()) : null;\n    }","id":29462,"modified_method":"@Override\n    public Byte getByteAttribute(String key) {\n        Object attribute = getAttribute(key);\n        return attribute != null ? Byte.valueOf(attribute.toString()) : null;\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void setIntAttribute(String key, int value) {\n        notSupportedOnClient();\n    }","id":29463,"modified_method":"@Override\n    public void setIntAttribute(String key, int value) {\n        throw notSupportedOnClient();\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void setDoubleAttribute(String key, double value) {\n        notSupportedOnClient();\n    }","id":29464,"modified_method":"@Override\n    public void setDoubleAttribute(String key, double value) {\n        throw notSupportedOnClient();\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void setByteAttribute(String key, byte value) {\n        notSupportedOnClient();\n    }","id":29465,"modified_method":"@Override\n    public void setByteAttribute(String key, byte value) {\n        throw notSupportedOnClient();\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Short getShortAttribute(String key) {\n        final Object attribute = getAttribute(key);\n        return attribute != null ? Short.valueOf(attribute.toString()) : null;\n    }","id":29466,"modified_method":"@Override\n    public Short getShortAttribute(String key) {\n        Object attribute = getAttribute(key);\n        return attribute != null ? Short.valueOf(attribute.toString()) : null;\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void setStringAttribute(String key, String value) {\n        notSupportedOnClient();\n    }","id":29467,"modified_method":"@Override\n    public void setStringAttribute(String key, String value) {\n        throw notSupportedOnClient();\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void setBooleanAttribute(String key, boolean value) {\n        notSupportedOnClient();\n    }","id":29468,"modified_method":"@Override\n    public void setBooleanAttribute(String key, boolean value) {\n        throw notSupportedOnClient();\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Float getFloatAttribute(String key) {\n        final Object attribute = getAttribute(key);\n        return attribute != null ? Float.valueOf(attribute.toString()) : null;\n    }","id":29469,"modified_method":"@Override\n    public Float getFloatAttribute(String key) {\n        Object attribute = getAttribute(key);\n        return attribute != null ? Float.valueOf(attribute.toString()) : null;\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Long getLongAttribute(String key) {\n        final Object attribute = getAttribute(key);\n        return attribute != null ? Long.getLong(attribute.toString()) : null;\n    }","id":29470,"modified_method":"@Override\n    public Long getLongAttribute(String key) {\n        Object attribute = getAttribute(key);\n        return attribute != null ? Long.valueOf(attribute.toString()) : null;\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = UnsupportedOperationException.class)\n    public void testSetAttribute_onRemoteMember() {\n        member = new MemberImpl(address, false);\n        member.setStringAttribute(\"remoteMemberSet\", \"wontWork\");\n    }","id":29471,"modified_method":"@Test(expected = UnsupportedOperationException.class)\n    public void testSetAttribute_onRemoteMember() {\n        MemberImpl member = new MemberImpl(address, false);\n        member.setStringAttribute(\"remoteMemberSet\", \"wontWork\");\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testConstructor_withHazelcastInstance() throws Exception {\n        member = new MemberImpl(address, true, \"uuid2342\", hazelcastInstance);\n\n        assertMemberImpl();\n        assertTrue(member.localMember());\n        assertEquals(\"uuid2342\", member.getUuid());\n    }","id":29472,"modified_method":"@Test\n    public void testConstructor_withHazelcastInstance() throws Exception {\n        MemberImpl member = new MemberImpl(address, true, \"uuid2342\", hazelcastInstance);\n\n        assertBasicMemberImplFields(member);\n        assertTrue(member.localMember());\n        assertEquals(\"uuid2342\", member.getUuid());\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testFloatAttribute() {\n        member = new MemberImpl(address, true);\n        assertNull(member.getFloatAttribute(\"floatKey\"));\n\n        Float value = Float.MAX_VALUE;\n        member.setFloatAttribute(\"floatKey\", value);\n        assertEquals(value, member.getFloatAttribute(\"floatKey\"), 0.001);\n    }","id":29473,"modified_method":"@Test\n    public void testFloatAttribute() {\n        MemberImpl member = new MemberImpl(address, true);\n        assertNull(member.getFloatAttribute(\"floatKey\"));\n\n        Float value = Float.MAX_VALUE;\n        member.setFloatAttribute(\"floatKey\", value);\n        assertEquals(value, member.getFloatAttribute(\"floatKey\"), 0.001);\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testBooleanAttribute() {\n        member = new MemberImpl(address, true);\n        assertNull(member.getBooleanAttribute(\"booleanKeyTrue\"));\n        assertNull(member.getBooleanAttribute(\"booleanKeyFalse\"));\n\n        member.setBooleanAttribute(\"booleanKeyTrue\", true);\n        assertTrue(member.getBooleanAttribute(\"booleanKeyTrue\"));\n\n        member.setBooleanAttribute(\"booleanKeyFalse\", false);\n        assertFalse(member.getBooleanAttribute(\"booleanKeyFalse\"));\n    }","id":29474,"modified_method":"@Test\n    public void testBooleanAttribute() {\n        MemberImpl member = new MemberImpl(address, true);\n        assertNull(member.getBooleanAttribute(\"booleanKeyTrue\"));\n        assertNull(member.getBooleanAttribute(\"booleanKeyFalse\"));\n\n        member.setBooleanAttribute(\"booleanKeyTrue\", true);\n        assertTrue(member.getBooleanAttribute(\"booleanKeyTrue\"));\n\n        member.setBooleanAttribute(\"booleanKeyFalse\", false);\n        assertFalse(member.getBooleanAttribute(\"booleanKeyFalse\"));\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void assertMemberImpl() {\n        assertEquals(address, member.getAddress());\n        assertEquals(5701, member.getPort());\n        assertEquals(\"127.0.0.1\", member.getInetAddress().getHostAddress());\n        assertTrue(member.getFactoryId() > -1);\n        assertTrue(member.getId() > -1);\n    }","id":29475,"modified_method":"private static void assertBasicMemberImplFields(MemberImpl member) {\n        assertEquals(address, member.getAddress());\n        assertEquals(5701, member.getPort());\n        assertEquals(\"127.0.0.1\", member.getInetAddress().getHostAddress());\n        assertTrue(member.getFactoryId() > -1);\n        assertTrue(member.getId() > -1);\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testByteAttribute() {\n        member = new MemberImpl(address, true);\n        assertNull(member.getByteAttribute(\"byteKey\"));\n\n        Byte value = Byte.MAX_VALUE;\n        member.setByteAttribute(\"byteKey\", value);\n        assertEquals(value, member.getByteAttribute(\"byteKey\"));\n    }","id":29476,"modified_method":"@Test\n    public void testByteAttribute() {\n        MemberImpl member = new MemberImpl(address, true);\n        assertNull(member.getByteAttribute(\"byteKey\"));\n\n        Byte value = Byte.MAX_VALUE;\n        member.setByteAttribute(\"byteKey\", value);\n        assertEquals(value, member.getByteAttribute(\"byteKey\"));\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testSetHazelcastInstance() throws Exception {\n        member = new MemberImpl(address, true);\n        assertNull(member.getLogger());\n\n        member.setHazelcastInstance(hazelcastInstance);\n\n        assertNotNull(member.getLogger());\n    }","id":29477,"modified_method":"@Test\n    public void testSetHazelcastInstance() throws Exception {\n        MemberImpl member = new MemberImpl(address, true);\n        assertNull(member.getLogger());\n\n        member.setHazelcastInstance(hazelcastInstance);\n\n        assertNotNull(member.getLogger());\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testConstructor_withLocalMember_isTrue() {\n        member = new MemberImpl(address, true);\n\n        assertMemberImpl();\n        assertTrue(member.localMember());\n    }","id":29478,"modified_method":"@Test\n    public void testConstructor_withLocalMember_isTrue() {\n        MemberImpl member = new MemberImpl(address, true);\n\n        assertBasicMemberImplFields(member);\n        assertTrue(member.localMember());\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testConstructor_withLiteMember_isTrue() {\n        member = new MemberImpl(address, true, true);\n\n        assertMemberImpl();\n        assertTrue(member.localMember());\n        assertTrue(member.isLiteMember());\n    }","id":29479,"modified_method":"@Test\n    public void testConstructor_withLiteMember_isTrue() {\n        MemberImpl member = new MemberImpl(address, true, true);\n\n        assertBasicMemberImplFields(member);\n        assertTrue(member.localMember());\n        assertTrue(member.isLiteMember());\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testRemoveAttribute() {\n        member = new MemberImpl(address, true);\n        assertNull(member.getStringAttribute(\"removeKey\"));\n\n        member.setStringAttribute(\"removeKey\", \"removeValue\");\n        assertEquals(\"removeValue\", member.getStringAttribute(\"removeKey\"));\n\n        member.removeAttribute(\"removeKey\");\n        assertNull(member.getStringAttribute(\"removeKey\"));\n    }","id":29480,"modified_method":"@Test\n    public void testRemoveAttribute() {\n        MemberImpl member = new MemberImpl(address, true);\n        assertNull(member.getStringAttribute(\"removeKey\"));\n\n        member.setStringAttribute(\"removeKey\", \"removeValue\");\n        assertEquals(\"removeValue\", member.getStringAttribute(\"removeKey\"));\n\n        member.removeAttribute(\"removeKey\");\n        assertNull(member.getStringAttribute(\"removeKey\"));\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testDoubleAttribute() {\n        member = new MemberImpl(address, true);\n        assertNull(member.getDoubleAttribute(\"doubleKey\"));\n\n        Double value = Double.MAX_VALUE;\n        member.setDoubleAttribute(\"doubleKey\", value);\n        assertEquals(value, member.getDoubleAttribute(\"doubleKey\"), 0.001);\n    }","id":29481,"modified_method":"@Test\n    public void testDoubleAttribute() {\n        MemberImpl member = new MemberImpl(address, true);\n        assertNull(member.getDoubleAttribute(\"doubleKey\"));\n\n        Double value = Double.MAX_VALUE;\n        member.setDoubleAttribute(\"doubleKey\", value);\n        assertEquals(value, member.getDoubleAttribute(\"doubleKey\"), 0.001);\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testConstructor_withLocalMember_isFalse() {\n        member = new MemberImpl(address, false);\n\n        assertMemberImpl();\n        assertFalse(member.localMember());\n    }","id":29482,"modified_method":"@Test\n    public void testConstructor_withLocalMember_isFalse() {\n        MemberImpl member = new MemberImpl(address, false);\n\n        assertBasicMemberImplFields(member);\n        assertFalse(member.localMember());\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testConstructor_withAttributes() throws Exception {\n        Map<String, Object> attributes = new HashMap<String, Object>();\n        attributes.put(\"key1\", \"value\");\n        attributes.put(\"key2\", 12345);\n\n        member = new MemberImpl(address, true, \"uuid2342\", hazelcastInstance, attributes, false);\n\n        assertMemberImpl();\n        assertTrue(member.localMember());\n        assertEquals(\"uuid2342\", member.getUuid());\n        assertEquals(\"value\", member.getAttribute(\"key1\"));\n        assertEquals(12345, member.getAttribute(\"key2\"));\n        assertFalse(member.isLiteMember());\n    }","id":29483,"modified_method":"@Test\n    public void testConstructor_withAttributes() throws Exception {\n        Map<String, Object> attributes = new HashMap<String, Object>();\n        attributes.put(\"key1\", \"value\");\n        attributes.put(\"key2\", 12345);\n\n        MemberImpl member = new MemberImpl(address, true, \"uuid2342\", hazelcastInstance, attributes, false);\n\n        assertBasicMemberImplFields(member);\n        assertTrue(member.localMember());\n        assertEquals(\"uuid2342\", member.getUuid());\n        assertEquals(\"value\", member.getAttribute(\"key1\"));\n        assertEquals(12345, member.getAttribute(\"key2\"));\n        assertFalse(member.isLiteMember());\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testRemoveAttribute_withHazelcastInstance() {\n        member = new MemberImpl(address, true, \"uuid\", hazelcastInstance);\n\n        member.removeAttribute(\"removeKeyWithInstance\");\n        assertNull(member.getStringAttribute(\"removeKeyWithInstance\"));\n    }","id":29484,"modified_method":"@Test\n    public void testRemoveAttribute_withHazelcastInstance() {\n        MemberImpl member = new MemberImpl(address, true, \"uuid\", hazelcastInstance);\n\n        member.removeAttribute(\"removeKeyWithInstance\");\n        assertNull(member.getStringAttribute(\"removeKeyWithInstance\"));\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testSetAttribute_withHazelcastInstance() {\n        member = new MemberImpl(address, true, \"uuid\", hazelcastInstance);\n\n        member.setStringAttribute(\"setKeyWithInstance\", \"setValueWithInstance\");\n        assertEquals(\"setValueWithInstance\", member.getStringAttribute(\"setKeyWithInstance\"));\n    }","id":29485,"modified_method":"@Test\n    public void testSetAttribute_withHazelcastInstance() {\n        MemberImpl member = new MemberImpl(address, true, \"uuid\", hazelcastInstance);\n\n        member.setStringAttribute(\"setKeyWithInstance\", \"setValueWithInstance\");\n        assertEquals(\"setValueWithInstance\", member.getStringAttribute(\"setKeyWithInstance\"));\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testConstructor_withMemberImpl() {\n        member = new MemberImpl(new MemberImpl(address, true));\n\n        assertMemberImpl();\n        assertTrue(member.localMember());\n    }","id":29486,"modified_method":"@Test\n    public void testConstructor_withMemberImpl() {\n        MemberImpl member = new MemberImpl(new MemberImpl(address, true));\n\n        assertBasicMemberImplFields(member);\n        assertTrue(member.localMember());\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testIntAttribute() {\n        member = new MemberImpl(address, true);\n        assertNull(member.getIntAttribute(\"intKey\"));\n\n        Integer value = Integer.MAX_VALUE;\n        member.setIntAttribute(\"intKey\", value);\n        assertEquals(value, member.getIntAttribute(\"intKey\"));\n    }","id":29487,"modified_method":"@Test\n    public void testIntAttribute() {\n        MemberImpl member = new MemberImpl(address, true);\n        assertNull(member.getIntAttribute(\"intKey\"));\n\n        Integer value = Integer.MAX_VALUE;\n        member.setIntAttribute(\"intKey\", value);\n        assertEquals(value, member.getIntAttribute(\"intKey\"));\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testStringAttribute() {\n        member = new MemberImpl(address, true);\n        assertNull(member.getStringAttribute(\"stringKey\"));\n\n        member.setStringAttribute(\"stringKey\", \"stringValue\");\n        assertEquals(\"stringValue\", member.getStringAttribute(\"stringKey\"));\n    }","id":29488,"modified_method":"@Test\n    public void testStringAttribute() {\n        MemberImpl member = new MemberImpl(address, true);\n        assertNull(member.getStringAttribute(\"stringKey\"));\n\n        member.setStringAttribute(\"stringKey\", \"stringValue\");\n        assertEquals(\"stringValue\", member.getStringAttribute(\"stringKey\"));\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = UnsupportedOperationException.class)\n    public void testRemoveAttribute_onRemoteMember() {\n        member = new MemberImpl(address, false);\n        member.removeAttribute(\"remoteMemberRemove\");\n    }","id":29489,"modified_method":"@Test(expected = UnsupportedOperationException.class)\n    public void testRemoveAttribute_onRemoteMember() {\n        MemberImpl member = new MemberImpl(address, false);\n        member.removeAttribute(\"remoteMemberRemove\");\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testLongAttribute() {\n        member = new MemberImpl(address, true);\n        assertNull(member.getLongAttribute(\"longKey\"));\n\n        Long value = Long.MAX_VALUE;\n        member.setLongAttribute(\"longKey\", value);\n        assertEquals(value, member.getLongAttribute(\"longKey\"));\n    }","id":29490,"modified_method":"@Test\n    public void testLongAttribute() {\n        MemberImpl member = new MemberImpl(address, true);\n        assertNull(member.getLongAttribute(\"longKey\"));\n\n        Long value = Long.MAX_VALUE;\n        member.setLongAttribute(\"longKey\", value);\n        assertEquals(value, member.getLongAttribute(\"longKey\"));\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testShortAttribute() {\n        member = new MemberImpl(address, true);\n        assertNull(member.getShortAttribute(\"shortKey\"));\n\n        Short value = Short.MAX_VALUE;\n        member.setShortAttribute(\"shortKey\", value);\n        assertEquals(value, member.getShortAttribute(\"shortKey\"));\n    }","id":29491,"modified_method":"@Test\n    public void testShortAttribute() {\n        MemberImpl member = new MemberImpl(address, true);\n        assertNull(member.getShortAttribute(\"shortKey\"));\n\n        Short value = Short.MAX_VALUE;\n        member.setShortAttribute(\"shortKey\", value);\n        assertEquals(value, member.getShortAttribute(\"shortKey\"));\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testConstructor_withLiteMember_isFalse() {\n        member = new MemberImpl(address, true, false);\n\n        assertMemberImpl();\n        assertTrue(member.localMember());\n        assertFalse(member.isLiteMember());\n    }","id":29492,"modified_method":"@Test\n    public void testConstructor_withLiteMember_isFalse() {\n        MemberImpl member = new MemberImpl(address, true, false);\n\n        assertBasicMemberImplFields(member);\n        assertTrue(member.localMember());\n        assertFalse(member.isLiteMember());\n    }","commit_id":"12feb50463574c4b0df094f4791d67be5eb83c9a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public String toString() {\n      return Objects.toStringHelper(this)\n        .add(\"activeEntryId\", activeEntryId)\n        .add(\"consumerReadPointer\", consumerReadPointer)\n        .add(\"queueWritePointer\", queueWrtiePointer)\n        .add(\"cachedEntries\", cachedEntries.toString())\n        .toString();\n    }","id":29493,"modified_method":"@Override\n    public String toString() {\n      return Objects.toStringHelper(this)\n        .add(\"activeEntryId\", activeEntryId)\n        .add(\"activeEntryTries\", activeEntryTries)\n        .add(\"consumerReadPointer\", consumerReadPointer)\n        .add(\"queueWritePointer\", queueWrtiePointer)\n        .add(\"cachedEntries\", cachedEntries.toString())\n        .toString();\n    }","commit_id":"51793149a04ee195796af325ebb298b933c053de","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public List<Long> fetchNextEntries(QueueConsumer consumer, QueueConfig config, QueueState queueState, ReadPointer readPointer) throws OperationException {\n      long entryId = queueState.getConsumerReadPointer();\n      QueuePartitioner partitioner=config.getPartitionerType().getPartitioner();\n      List<Long> newEntryIds = new ArrayList<Long>();\n\n      while (newEntryIds.isEmpty()) {\n        if(entryId >= queueState.getQueueWritePointer()) {\n          // Reached the end of queue as per cached QueueWritePointer,\n          // read it again to see if there is any progress made by producers\n          // TODO: use raw Get instead of the workaround of incrementing zero\n          long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n          queueState.setQueueWritePointer(queueWritePointer);\n          // If still no progress, return empty queue\n          if(entryId >= queueState.getQueueWritePointer()) {\n            return Collections.EMPTY_LIST;\n          }\n        }\n\n        // For now non-disjoint partitions use batchSize = 1\n        int tempBatchSize = 1;\n        long endEntryId = table.incrementAtomicDirtily(makeRowKey(GROUP_READ_POINTER, consumer.getGroupId()),\n                                                       GROUP_READ_POINTER, tempBatchSize);\n        long startEntryId = endEntryId;\n        // Note: incrementing GROUP_READ_POINTER, and storing the ActiveEntryId in HBase ideally need to happen atomically.\n        //       HBase doesn't support atomic increment and put.\n        //       Also, for performance reasons we have moved the write to method saveDequeueEntryState where all writes for a dequeue happen\n        queueState.setActiveEntryId(endEntryId);\n\n        // Read  header data from underlying storage, if any\n        final int cacheSize = (int)(endEntryId - startEntryId + 1);\n\n        // Determine which entries  need to be read from storage based on partition type\n        for(int id = 0; id < cacheSize; ++id) {\n          final long currentEntryId = startEntryId + id;\n          if(partitioner.shouldEmit(consumer, currentEntryId)) {\n            newEntryIds.add(currentEntryId);\n          }\n        }\n        entryId = endEntryId;\n      }\n      return newEntryIds;\n    }","id":29494,"modified_method":"@Override\n    public List<Long> fetchNextEntries(QueueConsumer consumer, QueueConfig config, QueueStateImpl queueState, ReadPointer readPointer) throws OperationException {\n      long entryId = queueState.getConsumerReadPointer();\n      QueuePartitioner partitioner=config.getPartitionerType().getPartitioner();\n      List<Long> newEntryIds = new ArrayList<Long>();\n\n      while (newEntryIds.isEmpty()) {\n        if(entryId >= queueState.getQueueWritePointer()) {\n          // Reached the end of queue as per cached QueueWritePointer,\n          // read it again to see if there is any progress made by producers\n          // TODO: use raw Get instead of the workaround of incrementing zero\n          long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n          queueState.setQueueWritePointer(queueWritePointer);\n          // If still no progress, return empty queue\n          if(entryId >= queueState.getQueueWritePointer()) {\n            return Collections.EMPTY_LIST;\n          }\n        }\n\n        // For now non-disjoint partitions use batchSize = 1\n        int tempBatchSize = 1;\n        long endEntryId = table.incrementAtomicDirtily(makeRowKey(GROUP_READ_POINTER, consumer.getGroupId()),\n                                                       GROUP_READ_POINTER, tempBatchSize);\n        long startEntryId = endEntryId;\n        // Note: incrementing GROUP_READ_POINTER, and storing the ActiveEntryId in HBase ideally need to happen atomically.\n        //       HBase doesn't support atomic increment and put.\n        //       Also, for performance reasons we have moved the write to method saveDequeueEntryState where all writes for a dequeue happen\n        queueState.setActiveEntryId(endEntryId);\n\n        // Read  header data from underlying storage, if any\n        final int cacheSize = (int)(endEntryId - startEntryId + 1);\n\n        // Determine which entries  need to be read from storage based on partition type\n        for(int id = 0; id < cacheSize; ++id) {\n          final long currentEntryId = startEntryId + id;\n          if(partitioner.shouldEmit(consumer, currentEntryId)) {\n            newEntryIds.add(currentEntryId);\n          }\n        }\n        entryId = endEntryId;\n      }\n      return newEntryIds;\n    }","commit_id":"51793149a04ee195796af325ebb298b933c053de","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void saveDequeueState(QueueConsumer consumer, QueueConfig config, QueueState queueState, ReadPointer readPointer) throws OperationException {\n      // Persist the entryId this consumer will be working on\n      // TODO: Later when active entry can saved in memory, there is no need to write it into HBase -> (not true for FIFO!)\n      long entryId = queueState.getActiveEntryId();\n\n      table.put(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                     new byte[][]{\n                       CONSUMER_READ_POINTER,\n                       ACTIVE_ENTRY,\n                       makeColumnName(META_ENTRY_PREFIX, entryId)\n                     },\n                     readPointer.getMaximum(),\n                     new byte[][]{\n                       Bytes.toBytes(queueState.getConsumerReadPointer()),\n                       Bytes.toBytes(queueState.getActiveEntryId()),\n                       new EntryConsumerMeta(EntryConsumerMeta.EntryState.CLAIMED, 0).getBytes()\n                     }\n      );\n    }","id":29495,"modified_method":"@Override\n    public void saveDequeueState(QueueConsumer consumer, QueueConfig config, QueueStateImpl queueState, ReadPointer readPointer) throws OperationException {\n      // Persist the entryId this consumer will be working on\n      // TODO: Later when active entry can saved in memory, there is no need to write it into HBase -> (not true for FIFO!)\n      long entryId = queueState.getActiveEntryId();\n\n      table.put(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                     new byte[][]{\n                       CONSUMER_READ_POINTER,\n                       ACTIVE_ENTRY,\n                       makeColumnName(META_ENTRY_PREFIX, entryId)\n                     },\n                     readPointer.getMaximum(),\n                     new byte[][]{\n                       Bytes.toBytes(queueState.getConsumerReadPointer()),\n                       Bytes.toBytes(queueState.getActiveEntryId()),\n                       new EntryConsumerMeta(EntryConsumerMeta.EntryState.CLAIMED, 0).getBytes()\n                     }\n      );\n    }","commit_id":"51793149a04ee195796af325ebb298b933c053de","url":"https://github.com/caskdata/cdap"},{"original_method":"QueueState constructQueueState(QueueConsumer consumer, QueueConfig config,\n                               ReadPointer readPointer) throws OperationException;","id":29496,"modified_method":"QueueStateImpl constructQueueState(QueueConsumer consumer, QueueConfig config,\n                               ReadPointer readPointer) throws OperationException;","commit_id":"51793149a04ee195796af325ebb298b933c053de","url":"https://github.com/caskdata/cdap"},{"original_method":"private void readEntries(QueueConsumer consumer, QueueConfig config, QueueState queueState, ReadPointer readPointer,\n                            List<Long> entryIds) throws OperationException{\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(String.format(\"Reading entries from storage - \", Arrays.toString(entryIds.toArray())));\n    }\n    if(entryIds.isEmpty()) {\n      queueState.setCachedEntries(CachedList.EMPTY_LIST);\n      return;\n    }\n\n    final byte[][] entryRowKeys = new byte[entryIds.size()][];\n    for(int i = 0; i < entryIds.size(); ++i) {\n      entryRowKeys[i] = makeRowKey(GLOBAL_DATA_PREFIX, entryIds.get(i));\n    }\n\n    final byte[][] entryColKeys = new byte[][]{ ENTRY_META, ENTRY_DATA };\n    OperationResult<Map<byte[], Map<byte[], byte[]>>> entriesResult =\n                                                          this.table.get(entryRowKeys, entryColKeys, readPointer);\n    if(entriesResult.isEmpty()) {\n      queueState.setCachedEntries(CachedList.EMPTY_LIST);\n    } else {\n      List<QueueStateEntry> entries = new ArrayList<QueueStateEntry>(entryIds.size());\n      for(int i = 0; i < entryIds.size(); ++i) {\n        Map<byte[], byte[]> entryMap = entriesResult.getValue().get(entryRowKeys[i]);\n        if(entryMap == null) {\n          queueState.setCachedEntries(CachedList.EMPTY_LIST);\n          return;\n        }\n        byte[] entryMetaBytes = entryMap.get(ENTRY_META);\n        if(entryMetaBytes == null) {\n          queueState.setCachedEntries(CachedList.EMPTY_LIST);\n          return;\n        }\n        EntryMeta entryMeta = EntryMeta.fromBytes(entryMetaBytes);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"entryId:\" + entryIds.get(i) + \". entryMeta : \" + entryMeta.toString());\n        }\n\n        // Check if entry has been invalidated or evicted\n        if (entryMeta.isInvalid() || entryMeta.isEvicted()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found invalidated or evicted entry at \" + entryIds.get(i) +\n                        \" (\" + entryMeta.toString() + \")\");\n          }\n        } else {\n          // Entry is visible and valid!\n          assert(entryMeta.isValid());\n          byte [] entryData = entryMap.get(ENTRY_DATA);\n          entries.add(new QueueStateEntry(entryData, entryIds.get(i)));\n        }\n      }\n      queueState.setCachedEntries(new CachedList<QueueStateEntry>(entries));\n    }\n  }","id":29497,"modified_method":"private void readEntries(QueueConsumer consumer, QueueConfig config, QueueStateImpl queueState, ReadPointer readPointer,\n                            List<Long> entryIds) throws OperationException{\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(String.format(\"Reading entries from storage - \", Arrays.toString(entryIds.toArray())));\n    }\n    if(entryIds.isEmpty()) {\n      queueState.setCachedEntries(CachedList.EMPTY_LIST);\n      return;\n    }\n\n    final byte[][] entryRowKeys = new byte[entryIds.size()][];\n    for(int i = 0; i < entryIds.size(); ++i) {\n      entryRowKeys[i] = makeRowKey(GLOBAL_DATA_PREFIX, entryIds.get(i));\n    }\n\n    final byte[][] entryColKeys = new byte[][]{ ENTRY_META, ENTRY_DATA };\n    OperationResult<Map<byte[], Map<byte[], byte[]>>> entriesResult =\n                                                          this.table.get(entryRowKeys, entryColKeys, readPointer);\n    if(entriesResult.isEmpty()) {\n      queueState.setCachedEntries(CachedList.EMPTY_LIST);\n    } else {\n      List<QueueStateEntry> entries = new ArrayList<QueueStateEntry>(entryIds.size());\n      for(int i = 0; i < entryIds.size(); ++i) {\n        Map<byte[], byte[]> entryMap = entriesResult.getValue().get(entryRowKeys[i]);\n        if(entryMap == null) {\n          queueState.setCachedEntries(CachedList.EMPTY_LIST);\n          return;\n        }\n        byte[] entryMetaBytes = entryMap.get(ENTRY_META);\n        if(entryMetaBytes == null) {\n          queueState.setCachedEntries(CachedList.EMPTY_LIST);\n          return;\n        }\n        EntryMeta entryMeta = EntryMeta.fromBytes(entryMetaBytes);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"entryId:\" + entryIds.get(i) + \". entryMeta : \" + entryMeta.toString());\n        }\n\n        // Check if entry has been invalidated or evicted\n        if (entryMeta.isInvalid() || entryMeta.isEvicted()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found invalidated or evicted entry at \" + entryIds.get(i) +\n                        \" (\" + entryMeta.toString() + \")\");\n          }\n        } else {\n          // Entry is visible and valid!\n          assert(entryMeta.isValid());\n          byte [] entryData = entryMap.get(ENTRY_DATA);\n          entries.add(new QueueStateEntry(entryData, entryIds.get(i)));\n        }\n      }\n      queueState.setCachedEntries(new CachedList<QueueStateEntry>(entries));\n    }\n  }","commit_id":"51793149a04ee195796af325ebb298b933c053de","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void ack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    ackInternal(entryPointer, consumer, readPointer);\n    if(consumer.isStateful()) {\n      consumer.getQueueState().setActiveEntryId(INVALID_ENTRY_ID);\n    }\n  }","id":29498,"modified_method":"@Override\n  public void ack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    ackInternal(entryPointer, consumer, readPointer);\n    if(consumer.isStateful()) {\n      getQueueStateImpl(consumer.getQueueState()).setActiveEntryId(INVALID_ENTRY_ID);\n    }\n  }","commit_id":"51793149a04ee195796af325ebb298b933c053de","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public QueueState constructQueueState(QueueConsumer consumer, QueueConfig config, ReadPointer readPointer)\n                                                       throws OperationException {\n      // ACTIVE_ENTRY contains the entry if any that is dequeued, but not acked\n      // CONSUMER_READ_POINTER + 1 points to the next entry that can be read by this queue consuemr\n      QueueState queueState = new QueueStateImpl();\n      OperationResult<Map<byte[], byte[]>> stateBytes =\n        table.get(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                       new byte[][] {ACTIVE_ENTRY, CONSUMER_READ_POINTER}, readPointer);\n      if(!stateBytes.isEmpty()) {\n        long activeEntryId = Bytes.toLong(stateBytes.getValue().get(ACTIVE_ENTRY));\n        // TODO: check max tries\n        queueState.setActiveEntryId(activeEntryId);\n\n        byte[] consumerReadPointerBytes = stateBytes.getValue().get(CONSUMER_READ_POINTER);\n        if(consumerReadPointerBytes != null) {\n          queueState.setConsumerReadPointer(Bytes.toLong(consumerReadPointerBytes));\n        }\n      }\n\n      // Read queue write pointer\n      // TODO: use raw Get instead of the workaround of incrementing zero\n      long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n      queueState.setQueueWritePointer(queueWritePointer);\n\n      // If active entry is present, read that from storage\n      if(queueState.getActiveEntryId() != INVALID_ENTRY_ID) {\n        readEntries(consumer, config, queueState, readPointer, Collections.singletonList(queueState.getActiveEntryId()));\n        // Set the active entry as the current entry\n        queueState.getCachedEntries().getNext();\n      }\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(String.format(\"Constructed new QueueState - %s\", queueState));\n      }\n      return queueState;\n    }","id":29499,"modified_method":"@Override\n    public QueueStateImpl constructQueueState(QueueConsumer consumer, QueueConfig config, ReadPointer readPointer)\n                                                       throws OperationException {\n      // ACTIVE_ENTRY contains the entry if any that is dequeued, but not acked\n      // CONSUMER_READ_POINTER + 1 points to the next entry that can be read by this queue consuemr\n      QueueStateImpl queueState = new QueueStateImpl();\n      OperationResult<Map<byte[], byte[]>> stateBytes =\n        table.get(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                       new byte[][] {ACTIVE_ENTRY, CONSUMER_READ_POINTER}, readPointer);\n      if(!stateBytes.isEmpty()) {\n        long activeEntryId = Bytes.toLong(stateBytes.getValue().get(ACTIVE_ENTRY));\n        // TODO: check max tries\n        queueState.setActiveEntryId(activeEntryId);\n\n        byte[] consumerReadPointerBytes = stateBytes.getValue().get(CONSUMER_READ_POINTER);\n        if(consumerReadPointerBytes != null) {\n          queueState.setConsumerReadPointer(Bytes.toLong(consumerReadPointerBytes));\n        }\n      }\n\n      // Read queue write pointer\n      // TODO: use raw Get instead of the workaround of incrementing zero\n      long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n      queueState.setQueueWritePointer(queueWritePointer);\n\n      // If active entry is present, read that from storage\n      if(queueState.getActiveEntryId() != INVALID_ENTRY_ID) {\n        readEntries(consumer, config, queueState, readPointer, Collections.singletonList(queueState.getActiveEntryId()));\n        // Set the active entry as the current entry\n        queueState.getCachedEntries().getNext();\n      }\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(String.format(\"Constructed new QueueState - %s\", queueState));\n      }\n      return queueState;\n    }","commit_id":"51793149a04ee195796af325ebb298b933c053de","url":"https://github.com/caskdata/cdap"},{"original_method":"void saveDequeueState(QueueConsumer consumer, QueueConfig config, QueueState queueState,\n                          ReadPointer readPointer) throws OperationException;","id":29500,"modified_method":"void saveDequeueState(QueueConsumer consumer, QueueConfig config, QueueStateImpl queueState,\n                          ReadPointer readPointer) throws OperationException;","commit_id":"51793149a04ee195796af325ebb298b933c053de","url":"https://github.com/caskdata/cdap"},{"original_method":"List<Long> fetchNextEntries(QueueConsumer consumer, QueueConfig config, QueueState queueState,\n                          ReadPointer readPointer) throws OperationException;","id":29501,"modified_method":"List<Long> fetchNextEntries(QueueConsumer consumer, QueueConfig config, QueueStateImpl queueState,\n                          ReadPointer readPointer) throws OperationException;","commit_id":"51793149a04ee195796af325ebb298b933c053de","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void unack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    // TODO: 1. Later when active entry can saved in memory, there is no need to write it into HBase\n    // TODO: 2. Need to treat Ack as a simple write operation so that it can use a simple write rollback for unack\n    // TODO: 3. Ack gets rolled back with tries=0. Need to fix this by fixing point 2 above.\n    this.table.put(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n      new byte[][] {makeColumnName(META_ENTRY_PREFIX, entryPointer.getEntryId()), ACTIVE_ENTRY}, readPointer.getMaximum(),\n      new byte[][] {new EntryConsumerMeta(EntryConsumerMeta.EntryState.CLAIMED, 0).getBytes(),\n                                                                        Bytes.toBytes(entryPointer.getEntryId())});\n    if(consumer.isStateful()) {\n      consumer.getQueueState().setActiveEntryId(entryPointer.getEntryId());\n    }\n  }","id":29502,"modified_method":"@Override\n  public void unack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    // TODO: 1. Later when active entry can saved in memory, there is no need to write it into HBase\n    // TODO: 2. Need to treat Ack as a simple write operation so that it can use a simple write rollback for unack\n    // TODO: 3. Ack gets rolled back with tries=0. Need to fix this by fixing point 2 above.\n    this.table.put(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n      new byte[][] {makeColumnName(META_ENTRY_PREFIX, entryPointer.getEntryId()), ACTIVE_ENTRY}, readPointer.getMaximum(),\n      new byte[][] {new EntryConsumerMeta(EntryConsumerMeta.EntryState.CLAIMED, 0).getBytes(),\n                                                                        Bytes.toBytes(entryPointer.getEntryId())});\n    if(consumer.isStateful()) {\n      getQueueStateImpl(consumer.getQueueState()).setActiveEntryId(entryPointer.getEntryId());\n    }\n  }","commit_id":"51793149a04ee195796af325ebb298b933c053de","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public DequeueResult dequeue(QueueConsumer consumer, ReadPointer readPointer) throws OperationException {\n    final QueueConfig config = consumer.getQueueConfig();\n    if (LOG.isDebugEnabled())\n      LOG.debug(\"Attempting dequeue [curNumDequeues=\" + this.dequeueReturns.get() +\n                  \"] (\" + consumer + \", \" + config + \", \" + readPointer + \")\");\n\n    // Determine what dequeue strategy to use based on the partitioner\n    final QueuePartitioner queuePartitioner = config.getPartitionerType().getPartitioner();\n    DequeueStrategy dequeueStrategy;\n    if(queuePartitioner instanceof QueuePartitioner.HashPartitioner) {\n      dequeueStrategy = new HashDequeueStrategy();\n    } else if(queuePartitioner instanceof QueuePartitioner.RoundRobinPartitioner) {\n      dequeueStrategy = new RoundRobinDequeueStrategy();\n    } else if(queuePartitioner instanceof QueuePartitioner.FifoPartitioner) {\n      dequeueStrategy = new FifoDequeueStrategy();\n    } else {\n      throw new IllegalStateException(\n        String.format(\"Cannot figure out the dequeue strategy to use for partitioner %s\", queuePartitioner.getClass()));\n    }\n\n    // If QueueState is null, read the queue state from underlying storage.\n    QueueState queueState = consumer.getQueueState();\n    if(queueState == null) {\n      queueState = dequeueStrategy.constructQueueState(consumer, config, readPointer);\n      consumer.setQueueState(queueState);\n    }\n\n    // If the previous entry was not acked, return the same one (Note: will need to change for async mode)\n    if(queueState.getActiveEntryId() != INVALID_ENTRY_ID) {\n      if(!queueState.getCachedEntries().hasCurrent()) {\n        throw new OperationException(StatusCode.INTERNAL_ERROR, \"Queue state error - cannot fetch active entry id from cached entries\");\n      }\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getCurrent();\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                                                      new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    }\n\n    // If no more cached entries, read entries from storage\n    if(!queueState.getCachedEntries().hasNext()) {\n      List<Long> entryIds = dequeueStrategy.fetchNextEntries(consumer, config, queueState, readPointer);\n      readEntries(consumer, config, queueState, readPointer, entryIds);\n    }\n\n    if(queueState.getCachedEntries().hasNext()) {\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getNext();\n      this.dequeueReturns.incrementAndGet();\n      queueState.setActiveEntryId(cachedEntry.getEntryId());\n      queueState.setConsumerReadPointer(cachedEntry.getEntryId());\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                               new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    } else {\n      // No queue entries available to dequue, return queue empty\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"End of queue reached using \" + \"read pointer \" + readPointer);\n      }\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.EMPTY);\n      return dequeueResult;\n    }\n  }","id":29503,"modified_method":"@Override\n  public DequeueResult dequeue(QueueConsumer consumer, ReadPointer readPointer) throws OperationException {\n    final QueueConfig config = consumer.getQueueConfig();\n    if (LOG.isDebugEnabled())\n      LOG.debug(\"Attempting dequeue [curNumDequeues=\" + this.dequeueReturns.get() +\n                  \"] (\" + consumer + \", \" + config + \", \" + readPointer + \")\");\n\n    // Determine what dequeue strategy to use based on the partitioner\n    final QueuePartitioner queuePartitioner = config.getPartitionerType().getPartitioner();\n    DequeueStrategy dequeueStrategy;\n    if(queuePartitioner instanceof QueuePartitioner.HashPartitioner) {\n      dequeueStrategy = new HashDequeueStrategy();\n    } else if(queuePartitioner instanceof QueuePartitioner.RoundRobinPartitioner) {\n      dequeueStrategy = new RoundRobinDequeueStrategy();\n    } else if(queuePartitioner instanceof QueuePartitioner.FifoPartitioner) {\n      dequeueStrategy = new FifoDequeueStrategy();\n    } else {\n      throw new IllegalStateException(\n        String.format(\"Cannot figure out the dequeue strategy to use for partitioner %s\", queuePartitioner.getClass()));\n    }\n\n    // If QueueState is null, read the queue state from underlying storage.\n    QueueStateImpl queueState = getQueueStateImpl(consumer.getQueueState());\n    if(queueState == null) {\n      queueState = dequeueStrategy.constructQueueState(consumer, config, readPointer);\n      consumer.setQueueState(queueState);\n    }\n\n    // If the previous entry was not acked, return the same one (Note: will need to change for async mode)\n    if(queueState.getActiveEntryId() != INVALID_ENTRY_ID) {\n      if(!queueState.getCachedEntries().hasCurrent()) {\n        throw new OperationException(StatusCode.INTERNAL_ERROR, \"Queue state error - cannot fetch active entry id from cached entries\");\n      }\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getCurrent();\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                                                      new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    }\n\n    // If no more cached entries, read entries from storage\n    if(!queueState.getCachedEntries().hasNext()) {\n      List<Long> entryIds = dequeueStrategy.fetchNextEntries(consumer, config, queueState, readPointer);\n      readEntries(consumer, config, queueState, readPointer, entryIds);\n    }\n\n    if(queueState.getCachedEntries().hasNext()) {\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getNext();\n      this.dequeueReturns.incrementAndGet();\n      queueState.setActiveEntryId(cachedEntry.getEntryId());\n      queueState.setConsumerReadPointer(cachedEntry.getEntryId());\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                               new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    } else {\n      // No queue entries available to dequue, return queue empty\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"End of queue reached using \" + \"read pointer \" + readPointer);\n      }\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.EMPTY);\n      return dequeueResult;\n    }\n  }","commit_id":"51793149a04ee195796af325ebb298b933c053de","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public List<Long> fetchNextEntries(QueueConsumer consumer, QueueConfig config, QueueState queueState, ReadPointer readPointer) throws OperationException {\n      long entryId = queueState.getConsumerReadPointer();\n      QueuePartitioner partitioner=config.getPartitionerType().getPartitioner();\n      List<Long> newEntryIds = new ArrayList<Long>();\n\n      while (newEntryIds.isEmpty()) {\n        if(entryId >= queueState.getQueueWritePointer()) {\n          // Reached the end of queue as per cached QueueWritePointer,\n          // read it again to see if there is any progress made by producers\n          // TODO: use raw Get instead of the workaround of incrementing zero\n          long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n          queueState.setQueueWritePointer(queueWritePointer);\n          // If still no progress, return empty queue\n          if(entryId >= queueState.getQueueWritePointer()) {\n            return Collections.EMPTY_LIST;\n          }\n        }\n\n        long startEntryId = entryId + 1;\n        long endEntryId =\n                  startEntryId + (config.getBatchSize() * consumer.getGroupSize()) < queueState.getQueueWritePointer() ?\n                  startEntryId + (config.getBatchSize() * consumer.getGroupSize()) : queueState.getQueueWritePointer();\n\n        final int cacheSize = (int)(endEntryId - startEntryId + 1);\n\n        // Determine which entries  need to be read from storage\n        for(int id = 0; id < cacheSize; ++id) {\n          final long currentEntryId = startEntryId + id;\n          if(partitioner.shouldEmit(consumer, currentEntryId)) {\n            newEntryIds.add(currentEntryId);\n          }\n        }\n        entryId = endEntryId;\n      }\n      return newEntryIds;\n    }","id":29504,"modified_method":"@Override\n    public List<Long> fetchNextEntries(QueueConsumer consumer, QueueConfig config, QueueStateImpl queueState, ReadPointer readPointer) throws OperationException {\n      long entryId = queueState.getConsumerReadPointer();\n      QueuePartitioner partitioner=config.getPartitionerType().getPartitioner();\n      List<Long> newEntryIds = new ArrayList<Long>();\n\n      while (newEntryIds.isEmpty()) {\n        if(entryId >= queueState.getQueueWritePointer()) {\n          // Reached the end of queue as per cached QueueWritePointer,\n          // read it again to see if there is any progress made by producers\n          // TODO: use raw Get instead of the workaround of incrementing zero\n          long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n          queueState.setQueueWritePointer(queueWritePointer);\n          // If still no progress, return empty queue\n          if(entryId >= queueState.getQueueWritePointer()) {\n            return Collections.EMPTY_LIST;\n          }\n        }\n\n        long startEntryId = entryId + 1;\n        long endEntryId =\n                  startEntryId + (config.getBatchSize() * consumer.getGroupSize()) < queueState.getQueueWritePointer() ?\n                  startEntryId + (config.getBatchSize() * consumer.getGroupSize()) : queueState.getQueueWritePointer();\n\n        final int cacheSize = (int)(endEntryId - startEntryId + 1);\n\n        // Determine which entries  need to be read from storage\n        for(int id = 0; id < cacheSize; ++id) {\n          final long currentEntryId = startEntryId + id;\n          if(partitioner.shouldEmit(consumer, currentEntryId)) {\n            newEntryIds.add(currentEntryId);\n          }\n        }\n        entryId = endEntryId;\n      }\n      return newEntryIds;\n    }","commit_id":"51793149a04ee195796af325ebb298b933c053de","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public List<Long> fetchNextEntries(\n      QueueConsumer consumer, QueueConfig config, QueueState queueState, ReadPointer readPointer) throws OperationException {\n      long entryId = queueState.getConsumerReadPointer();\n      QueuePartitioner partitioner=config.getPartitionerType().getPartitioner();\n      List<Long> newEntryIds = new ArrayList<Long>();\n\n      outerLoop:\n      while (newEntryIds.isEmpty()) {\n        if(entryId >= queueState.getQueueWritePointer()) {\n          // Reached the end of queue as per cached QueueWritePointer,\n          // read it again to see if there is any progress made by producers\n          // TODO: use raw Get instead of the workaround of incrementing zero\n          long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n          queueState.setQueueWritePointer(queueWritePointer);\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(String.format(\"New queueWritePointer = %d\", queueWritePointer));\n          }\n          // If still no progress, return empty queue\n          if(entryId >= queueState.getQueueWritePointer()) {\n            return Collections.EMPTY_LIST;\n          }\n        }\n\n        long startEntryId = entryId + 1;\n        long endEntryId =\n                startEntryId + (config.getBatchSize() * consumer.getGroupSize()) < queueState.getQueueWritePointer() ?\n                    startEntryId + (config.getBatchSize() * consumer.getGroupSize()) : queueState.getQueueWritePointer();\n\n        // Read  header data from underlying storage, if any\n        final int cacheSize = (int)(endEntryId - startEntryId + 1);\n        final String partitioningKey = consumer.getPartitioningKey();\n        if(partitioningKey == null || partitioningKey.isEmpty()) {\n          throw new IllegalStateException(String.format(\"Using Hash Partitioning with null/empty partitioningKey!\"));\n        }\n        final byte [][] rowKeys = new byte[cacheSize][];\n        for(int id = 0; id < cacheSize; ++id) {\n          rowKeys[id] = makeRowKey(GLOBAL_DATA_PREFIX, startEntryId + id);\n        }\n        final byte[][] columnKeys = new byte[1][];\n        columnKeys[0] = makeColumnName(ENTRY_HEADER, partitioningKey);\n        OperationResult<Map<byte[], Map<byte[], byte[]>>> headerResult = table.get(rowKeys, columnKeys, readPointer);\n\n        // Determine which entries  need to be read from storage\n        for(int id = 0; id < cacheSize; ++id) {\n          final long currentEntryId = startEntryId + id;\n          if (!headerResult.isEmpty()) {\n            Map<byte[], Map<byte[], byte[]>> headerValue = headerResult.getValue();\n            Map<byte[], byte[]> headerMap = headerValue.get(rowKeys[id]);\n            if(headerMap == null) {\n              break outerLoop;\n            }\n            byte[] hashBytes = headerMap.get(columnKeys[0]);\n            if(hashBytes == null) {\n              break outerLoop;\n            }\n            int hashValue = Bytes.toInt(hashBytes);\n            if(partitioner.shouldEmit(consumer, currentEntryId, hashValue)) {\n              newEntryIds.add(currentEntryId);\n            }\n          } else {\n            // Not able to read header\n            break outerLoop;\n          }\n        }\n        entryId = endEntryId;\n      }\n      return newEntryIds;\n    }","id":29505,"modified_method":"@Override\n    public List<Long> fetchNextEntries(\n      QueueConsumer consumer, QueueConfig config, QueueStateImpl queueState, ReadPointer readPointer) throws OperationException {\n      long entryId = queueState.getConsumerReadPointer();\n      QueuePartitioner partitioner=config.getPartitionerType().getPartitioner();\n      List<Long> newEntryIds = new ArrayList<Long>();\n\n      outerLoop:\n      while (newEntryIds.isEmpty()) {\n        if(entryId >= queueState.getQueueWritePointer()) {\n          // Reached the end of queue as per cached QueueWritePointer,\n          // read it again to see if there is any progress made by producers\n          // TODO: use raw Get instead of the workaround of incrementing zero\n          long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n          queueState.setQueueWritePointer(queueWritePointer);\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(String.format(\"New queueWritePointer = %d\", queueWritePointer));\n          }\n          // If still no progress, return empty queue\n          if(entryId >= queueState.getQueueWritePointer()) {\n            return Collections.EMPTY_LIST;\n          }\n        }\n\n        long startEntryId = entryId + 1;\n        long endEntryId =\n                startEntryId + (config.getBatchSize() * consumer.getGroupSize()) < queueState.getQueueWritePointer() ?\n                    startEntryId + (config.getBatchSize() * consumer.getGroupSize()) : queueState.getQueueWritePointer();\n\n        // Read  header data from underlying storage, if any\n        final int cacheSize = (int)(endEntryId - startEntryId + 1);\n        final String partitioningKey = consumer.getPartitioningKey();\n        if(partitioningKey == null || partitioningKey.isEmpty()) {\n          throw new IllegalStateException(String.format(\"Using Hash Partitioning with null/empty partitioningKey!\"));\n        }\n        final byte [][] rowKeys = new byte[cacheSize][];\n        for(int id = 0; id < cacheSize; ++id) {\n          rowKeys[id] = makeRowKey(GLOBAL_DATA_PREFIX, startEntryId + id);\n        }\n        final byte[][] columnKeys = new byte[1][];\n        columnKeys[0] = makeColumnName(ENTRY_HEADER, partitioningKey);\n        OperationResult<Map<byte[], Map<byte[], byte[]>>> headerResult = table.get(rowKeys, columnKeys, readPointer);\n\n        // Determine which entries  need to be read from storage\n        for(int id = 0; id < cacheSize; ++id) {\n          final long currentEntryId = startEntryId + id;\n          if (!headerResult.isEmpty()) {\n            Map<byte[], Map<byte[], byte[]>> headerValue = headerResult.getValue();\n            Map<byte[], byte[]> headerMap = headerValue.get(rowKeys[id]);\n            if(headerMap == null) {\n              break outerLoop;\n            }\n            byte[] hashBytes = headerMap.get(columnKeys[0]);\n            if(hashBytes == null) {\n              break outerLoop;\n            }\n            int hashValue = Bytes.toInt(hashBytes);\n            if(partitioner.shouldEmit(consumer, currentEntryId, hashValue)) {\n              newEntryIds.add(currentEntryId);\n            }\n          } else {\n            // Not able to read header\n            break outerLoop;\n          }\n        }\n        entryId = endEntryId;\n      }\n      return newEntryIds;\n    }","commit_id":"51793149a04ee195796af325ebb298b933c053de","url":"https://github.com/caskdata/cdap"},{"original_method":"public void start() {\n\t\tNSSelector selector = ERXSelectorUtilities.notificationSelector(\"editingContextDidSaveChanges\");\n        NSNotificationCenter.defaultCenter().addObserver(this, selector, \n                EOEditingContext.EditingContextDidSaveChangesNotification, null);\n        selector = ERXSelectorUtilities.notificationSelector(\"clearCaches\");\n        NSNotificationCenter.defaultCenter().addObserver(this, selector, \n                ERXEnterpriseObjectCache.ClearCachesNotification, null);\n\t}","id":29506,"modified_method":"public void start() {\n\t\tNSSelector selector = ERXSelectorUtilities.notificationSelector(\"editingContextDidSaveChanges\");\n        NSNotificationCenter.defaultCenter().addObserver(this, selector, \n                EOEditingContext.EditingContextDidSaveChangesNotification, null);\n        selector = ERXSelectorUtilities.notificationSelector(\"clearCaches\");\n        NSNotificationCenter.defaultCenter().addObserver(this, selector, \n                ERXEnterpriseObjectCache.ClearCachesNotification, null);\n        \n        if (_timeout > 0) {\n        \t_cache.startBackgroundExpiration();\n        }\n\t}","commit_id":"ea0a35947c682b499d570ba662199022e337b2a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Retrieves an EO that matches the given key or null if no match \n     * is in the cache.\n     * @param ec editing context to get the object into\n     * @param key key value under which the object is registered \n     * @return \n     */\n    public T objectForKey(EOEditingContext ec, Object key) {\n        Map cache = cache();\n        EOGlobalID gid = (EOGlobalID) cache.get(key);\n        if(gid == NO_GID_MARKER) {\n            return null;\n        } else if(gid == null) {\n            handleUnsuccessfullQueryForKey(key);\n            gid = (EOGlobalID) cache.get(key);\n            if(gid == NO_GID_MARKER) {\n                return null;\n            } else if(gid == null) {\n               return null;\n            }\n        }\n        T eo = (T) ec.faultForGlobalID(gid, ec);\n        return eo;\n    }","id":29507,"modified_method":"/**\n     * Retrieves an EO that matches the given key or null if no match \n     * is in the cache.\n     * @param ec editing context to get the object into\n     * @param key key value under which the object is registered \n     * @return \n     */\n    public T objectForKey(EOEditingContext ec, Object key) {\n        ERXExpiringCache<Object, EOGlobalID> cache = cache();\n        EOGlobalID gid = cache.objectForKey(key);\n        if(gid == NO_GID_MARKER) {\n            return null;\n        } else if(gid == null) {\n            handleUnsuccessfullQueryForKey(key);\n            gid = cache.objectForKey(key);\n            if(gid == NO_GID_MARKER) {\n                return null;\n            } else if(gid == null) {\n               return null;\n            }\n        }\n        T eo = (T) ec.faultForGlobalID(gid, ec);\n        return eo;\n    }","commit_id":"ea0a35947c682b499d570ba662199022e337b2a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Resets the cache by clearing the internal map. When the next value \n     * is accessed, the objects are refetched.\n     */\n    public synchronized void reset() {\n        _cache = null;\n    }","id":29508,"modified_method":"/**\n     * Resets the cache by clearing the internal map. When the next value \n     * is accessed, the objects are refetched.\n     */\n    public synchronized void reset() {\n    \tif (_cache != null) {\n    \t\t_cache.removeAllObjects();\n    \t}\n    }","commit_id":"ea0a35947c682b499d570ba662199022e337b2a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Handler for the editingContextDidSaveChanges notification. Calls reset if\n     * and object of the given entity were changed.\n     * @param n\n     */\n    public void editingContextDidSaveChanges(NSNotification n) {\n        EOEditingContext ec = (EOEditingContext) n.object();\n        if(ec.parentObjectStore() instanceof EOObjectStoreCoordinator) {\n        \tNSArray<T> releventsInsertedEOs = relevantChanges(n.userInfo(), EOEditingContext.InsertedKey);\n        \tNSArray<T> releventsUpdatedEOs = relevantChanges(n.userInfo(), EOEditingContext.UpdatedKey);\n        \tNSArray<T> releventsDeletedEOs = relevantChanges(n.userInfo(), EOEditingContext.DeletedKey);\n        \tMap<Object, EOGlobalID> cache = cache();\n        \tsynchronized (cache) { \n\t        \tif (releventsInsertedEOs != null) {\n\t        \t\tfor (T eo : releventsInsertedEOs) {\n\t        \t\t\taddObject(eo);\n\t        \t\t}\n\t        \t}\n\t        \tif (releventsUpdatedEOs != null) {\n\t        \t\tfor (T eo : releventsUpdatedEOs) {\n\t        \t\t\tupdateObject(eo);\n\t        \t\t}\n\t        \t}\n\t        \tif (releventsDeletedEOs != null) {\n\t        \t\tfor (T eo : releventsDeletedEOs) {\n\t        \t\t\tremoveObject(eo);\n\t        \t\t}\n\t        \t}\n        \t}\n        }\n    }","id":29509,"modified_method":"/**\n     * Handler for the editingContextDidSaveChanges notification. Calls reset if\n     * and object of the given entity were changed.\n     * @param n\n     */\n    public void editingContextDidSaveChanges(NSNotification n) {\n        EOEditingContext ec = (EOEditingContext) n.object();\n        if(ec.parentObjectStore() instanceof EOObjectStoreCoordinator) {\n        \tNSArray<T> releventsInsertedEOs = relevantChanges(n.userInfo(), EOEditingContext.InsertedKey);\n        \tNSArray<T> releventsUpdatedEOs = relevantChanges(n.userInfo(), EOEditingContext.UpdatedKey);\n        \tNSArray<T> releventsDeletedEOs = relevantChanges(n.userInfo(), EOEditingContext.DeletedKey);\n        \tERXExpiringCache<Object, EOGlobalID> cache = cache();\n        \tsynchronized (cache) { \n\t        \tif (releventsInsertedEOs != null) {\n\t        \t\tfor (T eo : releventsInsertedEOs) {\n\t        \t\t\taddObject(eo);\n\t        \t\t}\n\t        \t}\n\t        \tif (releventsUpdatedEOs != null) {\n\t        \t\tfor (T eo : releventsUpdatedEOs) {\n\t        \t\t\tupdateObject(eo);\n\t        \t\t}\n\t        \t}\n\t        \tif (releventsDeletedEOs != null) {\n\t        \t\tfor (T eo : releventsDeletedEOs) {\n\t        \t\t\tremoveObject(eo);\n\t        \t\t}\n\t        \t}\n        \t}\n        }\n    }","commit_id":"ea0a35947c682b499d570ba662199022e337b2a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Retrieves an EO that matches the given key or null if no match \n     * is in the cache.\n     * @param ec editing context to get the object into\n     * @param key key value under which the object is registered \n     * @return \n     */\n    public T objectsForKey(EOEditingContext ec, Object key) {\n        Map cache = cache();\n        EOGlobalID gid = (EOGlobalID) cache.get(key);\n        if(gid == NO_GID_MARKER) {\n            return null;\n        } else if(gid == null) {\n            handleUnsuccessfullQueryForKey(key);\n            gid = (EOGlobalID) cache.get(key);\n            if(gid == NO_GID_MARKER) {\n                return null;\n            } else if(gid == null) {\n               return null;\n            }\n        }\n        T eo = (T) ec.faultForGlobalID(gid, ec);\n        return eo;\n    }","id":29510,"modified_method":"/**\n     * Retrieves an EO that matches the given key or null if no match \n     * is in the cache.\n     * @param ec editing context to get the object into\n     * @param key key value under which the object is registered \n     * @return \n     */\n    public T objectsForKey(EOEditingContext ec, Object key) {\n        ERXExpiringCache<Object, EOGlobalID> cache = cache();\n        EOGlobalID gid = cache.objectForKey(key);\n        if(gid == NO_GID_MARKER) {\n            return null;\n        } else if(gid == null) {\n            handleUnsuccessfullQueryForKey(key);\n            gid = cache.objectForKey(key);\n            if(gid == NO_GID_MARKER) {\n                return null;\n            } else if(gid == null) {\n               return null;\n            }\n        }\n        T eo = (T) ec.faultForGlobalID(gid, ec);\n        return eo;\n    }","commit_id":"ea0a35947c682b499d570ba662199022e337b2a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void stop() {\n\t\tNSNotificationCenter.defaultCenter().removeObserver(this, EOEditingContext.EditingContextDidSaveChangesNotification, null);\n\t\tNSNotificationCenter.defaultCenter().removeObserver(this, ERXEnterpriseObjectCache.ClearCachesNotification, null);\n\t}","id":29511,"modified_method":"public void stop() {\n\t\tNSNotificationCenter.defaultCenter().removeObserver(this, EOEditingContext.EditingContextDidSaveChangesNotification, null);\n\t\tNSNotificationCenter.defaultCenter().removeObserver(this, ERXEnterpriseObjectCache.ClearCachesNotification, null);\n    \t_cache.stopBackgroundExpiration();\n\t}","commit_id":"ea0a35947c682b499d570ba662199022e337b2a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Called when a query hasn't found an entry in the cache. This\n     * implementation puts a not-found marker in the cache so\n     * the next query will return null. You could override this\n     * method to create an EO with sensible default values and\n     * call {@link #addObject(EOEnterpriseObject)} on it.\n     * @param key\n     */\n    protected void handleUnsuccessfullQueryForKey(Object key) {\n    \tif (!_fetchInitialValues) {\n            ERXEC ec = (ERXEC)ERXEC.newEditingContext();\n            ec.setCoalesceAutoLocks(false);\n        \tec.lock();\n        \ttry {\n        \t\ttry {\n        \t\t\tT eo = (T) EOUtilities.objectMatchingKeyAndValue(ec, _entityName, _keyPath, key);\n        \t\t\taddObject(eo);\n        \t\t}\n        \t\tcatch (EOObjectNotAvailableException e) {\n            \t\tcache().put(key, NO_GID_MARKER);\n        \t\t}\n        \t}\n        \tfinally {\n        \t\tec.unlock();\n        \t\tec.dispose();\n        \t}\n    \t}\n    \telse {\n    \t\tcache().put(key, NO_GID_MARKER);\n    \t}\n    }","id":29512,"modified_method":"/**\n     * Called when a query hasn't found an entry in the cache. This\n     * implementation puts a not-found marker in the cache so\n     * the next query will return null. You could override this\n     * method to create an EO with sensible default values and\n     * call {@link #addObject(EOEnterpriseObject)} on it.\n     * @param key\n     */\n    protected void handleUnsuccessfullQueryForKey(Object key) {\n    \tif (!_fetchInitialValues) {\n            ERXEC ec = (ERXEC)ERXEC.newEditingContext();\n            ec.setCoalesceAutoLocks(false);\n        \tec.lock();\n        \ttry {\n        \t\ttry {\n        \t\t\tT eo = (T) EOUtilities.objectMatchingKeyAndValue(ec, _entityName, _keyPath, key);\n        \t\t\taddObject(eo);\n        \t\t}\n        \t\tcatch (EOObjectNotAvailableException e) {\n            \t\tcache().setObjectForKey(NO_GID_MARKER, key);\n        \t\t}\n        \t}\n        \tfinally {\n        \t\tec.unlock();\n        \t\tec.dispose();\n        \t}\n    \t}\n    \telse {\n    \t\tcache().setObjectForKey(NO_GID_MARKER, key);\n    \t}\n    }","commit_id":"ea0a35947c682b499d570ba662199022e337b2a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void updateObjectForKey(T eo, Object key) {\n        EOGlobalID gid = NO_GID_MARKER;\n        if(eo != null) {\n            gid = eo.editingContext().globalIDForObject(eo);\n        }\n        Map<Object, EOGlobalID> cache = cache();\n        synchronized (cache) {\n        \tObject previousKey = null;\n        \tfor (Map.Entry<Object, EOGlobalID> entry : cache.entrySet()) {\n        \t\tif (gid.equals(entry.getValue())) {\n        \t\t\tpreviousKey = entry.getKey();\n        \t\t\tbreak;\n        \t\t}\n        \t}\n        \tif (previousKey != null) {\n        \t\tif (!previousKey.equals(key)) {\n\t        \t\tremoveObjectForKey(eo, previousKey);\n\t            \taddObjectForKey(eo, key);\n\t        \t}\n\t        \telse if (_qualifier != null && !_qualifier.evaluateWithObject(eo)) {\n\t        \t\tremoveObjectForKey(eo, previousKey);\n\t        \t}\n\t        \telse {\n\t            \t// leave it alone\n\t        \t}\n        \t}\n        \telse {\n        \t\taddObjectForKey(eo, key);\n        \t}\n        }\n    }","id":29513,"modified_method":"public void updateObjectForKey(T eo, Object key) {\n        EOGlobalID gid = NO_GID_MARKER;\n        if(eo != null) {\n            gid = eo.editingContext().globalIDForObject(eo);\n        }\n        ERXExpiringCache<Object, EOGlobalID> cache = cache();\n        synchronized (cache) {\n        \tObject previousKey = null;\n        \tfor (Object entryKey : cache.allKeys()) {\n        \t\tEOGlobalID entryValue = cache.objectForKey(entryKey);\n        \t\tif (entryValue != null && entryValue.equals(gid)) {\n        \t\t\tpreviousKey = entryKey;\n        \t\t\tbreak;\n        \t\t}\n        \t}\n        \tif (previousKey != null) {\n        \t\tif (!previousKey.equals(key)) {\n\t        \t\tremoveObjectForKey(eo, previousKey);\n\t            \taddObjectForKey(eo, key);\n\t        \t}\n\t        \telse if (_qualifier != null && !_qualifier.evaluateWithObject(eo)) {\n\t        \t\tremoveObjectForKey(eo, previousKey);\n\t        \t}\n\t        \telse {\n\t            \t// leave it alone\n\t        \t}\n        \t}\n        \telse {\n        \t\taddObjectForKey(eo, key);\n        \t}\n        }\n    }","commit_id":"ea0a35947c682b499d570ba662199022e337b2a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void removeObjectForKey(T eo, Object key) {\n        cache().put(key, NO_GID_MARKER);\n    }","id":29514,"modified_method":"public void removeObjectForKey(T eo, Object key) {\n        cache().setObjectForKey(NO_GID_MARKER, key);\n    }","commit_id":"ea0a35947c682b499d570ba662199022e337b2a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Add an object to the cache with the given key. The object\n     * can be null.\n     * @param eo\n     * @param key \n     */\n    public void addObjectForKey(T eo, Object key) {\n    \tif (_qualifier == null || _qualifier.evaluateWithObject(eo)) {\n\t        EOGlobalID gid = NO_GID_MARKER;\n\t        if(eo != null) {\n\t            gid = eo.editingContext().globalIDForObject(eo);\n\t        }\n\t        cache().put(key, gid);\n    \t}\n    }","id":29515,"modified_method":"/**\n     * Add an object to the cache with the given key. The object\n     * can be null.\n     * @param eo\n     * @param key \n     */\n    public void addObjectForKey(T eo, Object key) {\n    \tif (_qualifier == null || _qualifier.evaluateWithObject(eo)) {\n\t        EOGlobalID gid = NO_GID_MARKER;\n\t        if(eo != null) {\n\t            gid = eo.editingContext().globalIDForObject(eo);\n\t        }\n\t        cache().setObjectForKey(gid, key);\n    \t}\n    }","commit_id":"ea0a35947c682b499d570ba662199022e337b2a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns the backing cache. If the cache is to old, it is cleared first.\n     * @return \n     */\n    protected synchronized Map<Object, EOGlobalID> cache() {\n        long now = System.currentTimeMillis();\n        if(_timeout > 0L && (now - _timeout) > _fetchTime) {\n            reset();\n        }\n        if(_cache == null) {\n            _cache = Collections.synchronizedMap(new HashMap());\n            if (_fetchInitialValues) {\n\t            ERXEC ec = (ERXEC)ERXEC.newEditingContext();\n\t            ec.setCoalesceAutoLocks(false);\n\t            ec.lock();\n\t            try {\n\t                NSArray objects = initialObjects(ec);\n\t                for (Enumeration enumeration = objects.objectEnumerator(); enumeration.hasMoreElements();) {\n\t                    T eo = (T) enumeration.nextElement();\n\t                    addObject(eo);\n\t                }\n\t            } finally {\n\t                ec.unlock();\n\t                ec.dispose();\n\t            }\n            }\n            _fetchTime = System.currentTimeMillis();\n        }\n        return _cache;\n    }","id":29516,"modified_method":"/**\n     * Returns the backing cache. If the cache is to old, it is cleared first.\n     * @return \n     */\n    protected synchronized ERXExpiringCache<Object, EOGlobalID> cache() {\n        long now = System.currentTimeMillis();\n        if(_fetchInitialValues && _timeout > 0L && (now - _timeout) > _fetchTime) {\n            reset();\n        }\n        if(_cache == null) {\n        \tif (_fetchInitialValues) {\n                _cache = new ERXExpiringCache<Object, EOGlobalID>(ERXExpiringCache.NO_TIMEOUT);\n        \t}\n        \telse {\n                _cache = new ERXExpiringCache<Object, EOGlobalID>(_timeout);\n                if (_timeout > 0) {\n                \t_cache.startBackgroundExpiration();\n                }\n        \t}\n            if (_fetchInitialValues) {\n\t            ERXEC ec = (ERXEC)ERXEC.newEditingContext();\n\t            ec.setCoalesceAutoLocks(false);\n\t            ec.lock();\n\t            try {\n\t                NSArray objects = initialObjects(ec);\n\t                for (Enumeration enumeration = objects.objectEnumerator(); enumeration.hasMoreElements();) {\n\t                    T eo = (T) enumeration.nextElement();\n\t                    addObject(eo);\n\t                }\n\t            } finally {\n\t                ec.unlock();\n\t                ec.dispose();\n\t            }\n            }\n            _fetchTime = System.currentTimeMillis();\n        }\n        return _cache;\n    }","commit_id":"ea0a35947c682b499d570ba662199022e337b2a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"public CollapsedLinearGraphController(@NotNull CascadeLinearGraphController delegateLinearGraphController,\n                                           @NotNull final PermanentGraphInfo permanentGraphInfo) {\n    super(delegateLinearGraphController, permanentGraphInfo);\n    myCollapsedGraph = CollapsedGraph.newInstance(getDelegateLinearGraphController().getCompiledGraph(), null);\n    myLinearFragmentGenerator = new LinearFragmentGenerator(myCollapsedGraph.getCompiledGraph(), new Condition<Integer>() {\n      @Override\n      public boolean value(Integer nodeIndex) {\n        int nodeId = myCollapsedGraph.getCompiledGraph().getNodeId(nodeIndex);\n        return permanentGraphInfo.getNotCollapsedNodes().value(nodeId);\n      }\n    });\n    myFragmentGenerator = new FragmentGenerator(LinearGraphUtils.asLiteLinearGraph(myCollapsedGraph.getCompiledGraph()), new Condition<Integer>() {\n      @Override\n      public boolean value(Integer integer) {\n        return false;\n      }\n    });\n  }","id":29517,"modified_method":"public CollapsedLinearGraphController(@NotNull CascadeLinearGraphController delegateLinearGraphController,\n                                           @NotNull final PermanentGraphInfo<?> permanentGraphInfo) {\n    super(delegateLinearGraphController, permanentGraphInfo);\n    myCollapsedGraph = CollapsedGraph.newInstance(getDelegateLinearGraphController().getCompiledGraph(), null);\n\n    Set<Integer> branchNodeIndexes =\n      LinearGraphUtils.convertIdsToNodeIndexes(myCollapsedGraph.getCompiledGraph(), permanentGraphInfo.getBranchNodeIds());\n    myLinearFragmentGenerator =\n      new LinearFragmentGenerator(LinearGraphUtils.asLiteLinearGraph(myCollapsedGraph.getCompiledGraph()), branchNodeIndexes);\n    myFragmentGenerator =\n      new FragmentGenerator(LinearGraphUtils.asLiteLinearGraph(myCollapsedGraph.getCompiledGraph()), new Condition<Integer>() {\n        @Override\n        public boolean value(Integer integer) {\n          return false;\n        }\n      });\n  }","commit_id":"5a4264da3b9cd47e2630dd1085f4d7529198092a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LinearFragmentGenerator(@NotNull LinearGraph linearGraph, @NotNull Condition<Integer> thisNodeCantBeInMiddle) {\n    myLinearGraph = LinearGraphUtils.asLiteLinearGraph(linearGraph);\n    myThisNodeCantBeInMiddle = thisNodeCantBeInMiddle;\n  }","id":29518,"modified_method":"public LinearFragmentGenerator(@NotNull LiteLinearGraph linearGraph, @NotNull Set<Integer> pinnedNodes) {\n    myLinearGraph = linearGraph;\n    myPinnedNodes = pinnedNodes;\n  }","commit_id":"5a4264da3b9cd47e2630dd1085f4d7529198092a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Pair<Integer, Integer> getFragment(int startNode,\n                                                    Function<Integer, List<Integer>> getNextNodes,\n                                                    Function<Integer, List<Integer>> getPrevNodes,\n                                                    Condition<Integer> thisNodeCantBeInMiddle) {\n    Set<Integer> blackNodes = new HashSet<Integer>();\n    blackNodes.add(startNode);\n\n    Set<Integer> grayNodes = new HashSet<Integer>();\n    grayNodes.addAll(getNextNodes.fun(startNode));\n\n    int endNode = -1;\n    while (blackNodes.size() < SHORT_FRAGMENT_MAX_SIZE) {\n      int nextBlackNode = -1;\n      for (int grayNode : grayNodes) {\n        if (blackNodes.containsAll(getPrevNodes.fun(grayNode))) {\n          nextBlackNode = grayNode;\n          break;\n        }\n      }\n\n      if (nextBlackNode == -1)\n        return null;\n\n      if (grayNodes.size() == 1) {\n        endNode = nextBlackNode;\n        break;\n      }\n\n      List<Integer> nextGrayNodes = getNextNodes.fun(nextBlackNode);\n      if (nextGrayNodes.isEmpty() || thisNodeCantBeInMiddle.value(nextBlackNode))\n        return null;\n\n      blackNodes.add(nextBlackNode);\n      grayNodes.remove(nextBlackNode);\n      grayNodes.addAll(nextGrayNodes);\n    }\n\n    if (endNode != -1)\n      return Pair.create(startNode, endNode);\n    else\n      return null;\n  }","id":29519,"modified_method":"@Nullable\n  private static Pair<Integer, Integer> getFragment(int startNode,\n                                                    Function<Integer, List<Integer>> getNextNodes,\n                                                    Function<Integer, List<Integer>> getPrevNodes,\n                                                    Set<Integer> thisNodeCantBeInMiddle) {\n    Set<Integer> blackNodes = new HashSet<Integer>();\n    blackNodes.add(startNode);\n\n    Set<Integer> grayNodes = new HashSet<Integer>();\n    grayNodes.addAll(getNextNodes.fun(startNode));\n\n    int endNode = -1;\n    while (blackNodes.size() < SHORT_FRAGMENT_MAX_SIZE) {\n      int nextBlackNode = -1;\n      for (int grayNode : grayNodes) {\n        if (blackNodes.containsAll(getPrevNodes.fun(grayNode))) {\n          nextBlackNode = grayNode;\n          break;\n        }\n      }\n\n      if (nextBlackNode == -1)\n        return null;\n\n      if (grayNodes.size() == 1) {\n        endNode = nextBlackNode;\n        break;\n      }\n\n      List<Integer> nextGrayNodes = getNextNodes.fun(nextBlackNode);\n      if (nextGrayNodes.isEmpty() || thisNodeCantBeInMiddle.contains(nextBlackNode))\n        return null;\n\n      blackNodes.add(nextBlackNode);\n      grayNodes.remove(nextBlackNode);\n      grayNodes.addAll(nextGrayNodes);\n    }\n\n    if (endNode != -1)\n      return Pair.create(startNode, endNode);\n    else\n      return null;\n  }","commit_id":"5a4264da3b9cd47e2630dd1085f4d7529198092a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private GraphFragment getLongFragment(@Nullable GraphFragment startFragment, int bound) {\n    if (startFragment == null)\n      return null;\n\n    GraphFragment shortFragment;\n\n    int maxDown = startFragment.downNodeIndex;\n    while ((shortFragment = getDownFragment(maxDown)) != null && !myThisNodeCantBeInMiddle.value(maxDown)) {\n      maxDown = shortFragment.downNodeIndex;\n      if (maxDown - startFragment.downNodeIndex > bound)\n        break;\n    }\n\n    int maxUp = startFragment.upNodeIndex;\n    while ((shortFragment = getUpFragment(maxUp)) != null && !myThisNodeCantBeInMiddle.value(maxUp)) {\n      maxUp = shortFragment.upNodeIndex;\n      if (startFragment.upNodeIndex - maxUp > bound)\n        break;\n    }\n\n    if (maxUp != startFragment.upNodeIndex || maxDown != startFragment.downNodeIndex) {\n      return new GraphFragment(maxUp, maxDown);\n    } else {\n      // start fragment is Simple\n      if (myLinearGraph.getNodes(startFragment.upNodeIndex, DOWN).size() != 1)\n        return startFragment;\n    }\n    return null;\n  }","id":29520,"modified_method":"@Nullable\n  private GraphFragment getLongFragment(@Nullable GraphFragment startFragment, int bound) {\n    if (startFragment == null)\n      return null;\n\n    GraphFragment shortFragment;\n\n    int maxDown = startFragment.downNodeIndex;\n    while ((shortFragment = getDownFragment(maxDown)) != null && !myPinnedNodes.contains(maxDown)) {\n      maxDown = shortFragment.downNodeIndex;\n      if (maxDown - startFragment.downNodeIndex > bound)\n        break;\n    }\n\n    int maxUp = startFragment.upNodeIndex;\n    while ((shortFragment = getUpFragment(maxUp)) != null && !myPinnedNodes.contains(maxUp)) {\n      maxUp = shortFragment.upNodeIndex;\n      if (startFragment.upNodeIndex - maxUp > bound)\n        break;\n    }\n\n    if (maxUp != startFragment.upNodeIndex || maxDown != startFragment.downNodeIndex) {\n      return new GraphFragment(maxUp, maxDown);\n    } else {\n      // start fragment is Simple\n      if (myLinearGraph.getNodes(startFragment.upNodeIndex, DOWN).size() != 1)\n        return startFragment;\n    }\n    return null;\n  }","commit_id":"5a4264da3b9cd47e2630dd1085f4d7529198092a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public GraphFragment getUpFragment(int lowerNodeIndex) {\n    Pair<Integer, Integer> fragment = getFragment(lowerNodeIndex, upNodesFun, downNodesFun, myThisNodeCantBeInMiddle);\n    return fragment == null ? null : new GraphFragment(fragment.second, fragment.first);\n  }","id":29521,"modified_method":"@Nullable\n  public GraphFragment getUpFragment(int lowerNodeIndex) {\n    Pair<Integer, Integer> fragment = getFragment(lowerNodeIndex, upNodesFun, downNodesFun, myPinnedNodes);\n    return fragment == null ? null : new GraphFragment(fragment.second, fragment.first);\n  }","commit_id":"5a4264da3b9cd47e2630dd1085f4d7529198092a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public GraphFragment getDownFragment(int upperVisibleNodeIndex) {\n    Pair<Integer, Integer> fragment = getFragment(upperVisibleNodeIndex, downNodesFun, upNodesFun, myThisNodeCantBeInMiddle);\n    return fragment == null ? null : new GraphFragment(fragment.first, fragment.second);\n  }","id":29522,"modified_method":"@Nullable\n  public GraphFragment getDownFragment(int upperVisibleNodeIndex) {\n    Pair<Integer, Integer> fragment = getFragment(upperVisibleNodeIndex, downNodesFun, upNodesFun, myPinnedNodes);\n    return fragment == null ? null : new GraphFragment(fragment.first, fragment.second);\n  }","commit_id":"5a4264da3b9cd47e2630dd1085f4d7529198092a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  protected LinearGraphAnswer performAction(@NotNull LinearGraphAction action) {\n    if (action.getAffectedElement() != null) {\n      if (action.getType() == GraphAction.Type.MOUSE_CLICK) {\n        GraphElement graphElement = action.getAffectedElement().getGraphElement();\n        if (graphElement instanceof GraphEdge) {\n          GraphEdge edge = (GraphEdge)graphElement;\n          if (edge.getType() == GraphEdgeType.DOTTED) {\n            return new LinearGraphAnswer(replacedEdges(Collections.singleton(edge), myCompiledGraph.expandEdge(edge),\n                                                       getDelegateLinearGraphController().getCompiledGraph()), null, null, null);\n          }\n        }\n        else if (graphElement instanceof GraphNode) {\n          if (new LinearBekGraphBuilder(myCompiledGraph, myBekGraphLayout).collapseFragment(((GraphNode)graphElement).getNodeIndex())) {\n            return new LinearGraphAnswer(GraphChanges.SOME_CHANGES, null, null, null);\n          }\n        }\n      }\n      else if (action.getType() == GraphAction.Type.MOUSE_OVER) {\n        GraphElement graphElement = action.getAffectedElement().getGraphElement();\n        if (graphElement instanceof GraphEdge) {\n          GraphEdge edge = (GraphEdge)graphElement;\n          if (edge.getType() == GraphEdgeType.DOTTED) {\n            return LinearGraphUtils\n              .createSelectedAnswer(myCompiledGraph, ContainerUtil.set(edge.getUpNodeIndex(), edge.getDownNodeIndex()));\n          }\n        }\n        else if (graphElement instanceof GraphNode) {\n          LinearBekGraphBuilder.MergeFragment fragment =\n            new LinearBekGraphBuilder(myCompiledGraph, myBekGraphLayout).getFragment(((GraphNode)graphElement).getNodeIndex());\n          if (fragment != null) {\n            return LinearGraphUtils.createSelectedAnswer(myCompiledGraph, fragment.getAllNodes());\n          }\n        }\n      }\n    }\n    return null;\n  }","id":29523,"modified_method":"@Nullable\n  @Override\n  protected LinearGraphAnswer performAction(@NotNull LinearGraphAction action) {\n    if (action.getAffectedElement() != null) {\n      if (action.getType() == GraphAction.Type.MOUSE_CLICK) {\n        GraphElement graphElement = action.getAffectedElement().getGraphElement();\n        if (graphElement instanceof GraphEdge) {\n          GraphEdge edge = (GraphEdge)graphElement;\n          if (edge.getType() == GraphEdgeType.DOTTED) {\n            return new LinearGraphAnswer(replacedEdges(Collections.singleton(edge), myCompiledGraph.expandEdge(edge),\n                                                       getDelegateLinearGraphController().getCompiledGraph()), null, null, null);\n          }\n        }\n        else if (graphElement instanceof GraphNode) {\n          if (myLinearBekGraphBuilder.collapseFragment(((GraphNode)graphElement).getNodeIndex())) {\n            return new LinearGraphAnswer(GraphChanges.SOME_CHANGES, null, null, null);\n          }\n        }\n      }\n      else if (action.getType() == GraphAction.Type.MOUSE_OVER) {\n        GraphElement graphElement = action.getAffectedElement().getGraphElement();\n        if (graphElement instanceof GraphEdge) {\n          GraphEdge edge = (GraphEdge)graphElement;\n          if (edge.getType() == GraphEdgeType.DOTTED) {\n            return LinearGraphUtils\n              .createSelectedAnswer(myCompiledGraph, ContainerUtil.set(edge.getUpNodeIndex(), edge.getDownNodeIndex()));\n          }\n        }\n        else if (graphElement instanceof GraphNode) {\n          LinearBekGraphBuilder.MergeFragment fragment = myLinearBekGraphBuilder.getFragment(((GraphNode)graphElement).getNodeIndex());\n          if (fragment != null) {\n            return LinearGraphUtils.createSelectedAnswer(myCompiledGraph, fragment.getAllNodes());\n          }\n        }\n      }\n    }\n    return null;\n  }","commit_id":"3ff72fa396c6a7ace6cf148bb4624a391df9044d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LinearBekController(@NotNull BekBaseLinearGraphController controller, @NotNull PermanentGraphInfo permanentGraphInfo) {\n    super(controller, permanentGraphInfo);\n    myBekIntMap = controller.getBekIntMap();\n    myBekGraphLayout = new BekGraphLayout(permanentGraphInfo.getPermanentGraphLayout(), myBekIntMap);\n    myCompiledGraph = compileGraph(getDelegateLinearGraphController().getCompiledGraph(), myBekGraphLayout);\n  }","id":29524,"modified_method":"public LinearBekController(@NotNull BekBaseLinearGraphController controller, @NotNull PermanentGraphInfo permanentGraphInfo) {\n    super(controller, permanentGraphInfo);\n    myCompiledGraph = new LinearBekGraph(getDelegateLinearGraphController().getCompiledGraph());\n    myLinearBekGraphBuilder = new LinearBekGraphBuilder(myCompiledGraph, new BekGraphLayout(permanentGraphInfo.getPermanentGraphLayout(), controller.getBekIntMap()));\n\n    long start = System.currentTimeMillis();\n    myLinearBekGraphBuilder.collapseAll();\n    System.err.println((System.currentTimeMillis() - start) / 1000.0 + \" sec\");\n  }","commit_id":"3ff72fa396c6a7ace6cf148bb4624a391df9044d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  protected LinearGraphAnswer performAction(@NotNull LinearGraphAction action) {\n    if (action.getAffectedElement() != null) {\n      if (action.getType() == GraphAction.Type.MOUSE_CLICK) {\n        GraphElement graphElement = action.getAffectedElement().getGraphElement();\n        if (graphElement instanceof GraphEdge) {\n          GraphEdge edge = (GraphEdge)graphElement;\n          if (edge.getType() == GraphEdgeType.DOTTED) {\n            return new ExpandedEdgeAnswer(edge, myCompiledGraph.expandEdge(edge), getDelegateLinearGraphController().getCompiledGraph());\n          }\n        }\n      }\n      else if (action.getType() == GraphAction.Type.MOUSE_OVER) {\n        GraphElement graphElement = action.getAffectedElement().getGraphElement();\n        if (graphElement instanceof GraphEdge) {\n          GraphEdge edge = (GraphEdge)graphElement;\n          if (edge.getType() == GraphEdgeType.DOTTED) {\n            return LinearGraphUtils\n              .createSelectedAnswer(myCompiledGraph, ContainerUtil.set(edge.getUpNodeIndex(), edge.getDownNodeIndex()));\n          }\n        }\n      }\n    }\n    return LinearGraphUtils.createCursorAnswer(/*handCursor =*/ false);\n  }","id":29525,"modified_method":"@Nullable\n  @Override\n  protected LinearGraphAnswer performAction(@NotNull LinearGraphAction action) {\n    if (action.getAffectedElement() != null) {\n      if (action.getType() == GraphAction.Type.MOUSE_CLICK) {\n        GraphElement graphElement = action.getAffectedElement().getGraphElement();\n        if (graphElement instanceof GraphEdge) {\n          GraphEdge edge = (GraphEdge)graphElement;\n          if (edge.getType() == GraphEdgeType.DOTTED) {\n            return new LinearGraphAnswer(calculateChanges(edge, myCompiledGraph.expandEdge(edge),\n                                                          getDelegateLinearGraphController().getCompiledGraph()), null, null, null);\n          }\n        }\n      }\n      else if (action.getType() == GraphAction.Type.MOUSE_OVER) {\n        GraphElement graphElement = action.getAffectedElement().getGraphElement();\n        if (graphElement instanceof GraphEdge) {\n          GraphEdge edge = (GraphEdge)graphElement;\n          if (edge.getType() == GraphEdgeType.DOTTED) {\n            return LinearGraphUtils\n              .createSelectedAnswer(myCompiledGraph, ContainerUtil.set(edge.getUpNodeIndex(), edge.getDownNodeIndex()));\n          }\n        }\n      }\n    }\n    return LinearGraphUtils.createCursorAnswer(/*handCursor =*/ false);\n  }","commit_id":"5dc943e6d106c68aabc01939a33dd7df14c73074","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * The controller maintains an editing context for the duration of the request. The first time you call this method,\n\t * you will get a new EOEditingContext. Subsequent calls will return the same instance. This makes it a little more\n\t * convenient when you're using update, create, etc methods.\n\t * \n\t * @return an EOEditingContext\n\t */\n\tpublic EOEditingContext editingContext() {\n\t\tif (_editingContext == null) {\n\t\t\t_editingContext = ERXEC.newEditingContext();\n\t\t}\n\t\treturn _editingContext;\n\t}","id":29526,"modified_method":"/**\n\t * The controller maintains an editing context for the duration of the request. The first time you call this method,\n\t * you will get a new EOEditingContext. Subsequent calls will return the same instance. This makes it a little more\n\t * convenient when you're using update, create, etc methods.\n\t * \n\t * @return an EOEditingContext\n\t */\n\tpublic EOEditingContext editingContext() {\n\t\tif (_editingContext == null) {\n\t\t\tERXRestTransactionRequestAdaptor transactionAdaptor = ERXRestTransactionRequestAdaptor.defaultAdaptor();\n\t\t\tif (transactionAdaptor.transactionsEnabled() && transactionAdaptor.isExecutingTransaction(context(), request())) {\n\t\t\t\t_editingContext = newEditingContext(transactionAdaptor.executingTransaction(context(), request()).editingContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_editingContext = newEditingContext();\n\t\t\t}\n\t\t}\n\t\treturn _editingContext;\n\t}","commit_id":"6857c4429262073dbb022bae0366bb1f3856c914","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Performs the given action, optionally throwing exceptions instead of converting to http response codes.\n\t *  \n\t * @param actionName the name of the action to perform\n\t * @param throwExceptions whether or not to throw exceptions\n\t * @return the action results\n\t * @throws RuntimeException if a failure occurs\n\t */\n\tpublic WOActionResults performActionNamed(String actionName, boolean throwExceptions) throws RuntimeException {\n\t\ttry {\n\t\t\tcheckAccess();\n\n\t\t\tWOActionResults results = null;\n\t\t\tif (isAutomaticHtmlRoutingEnabled() && format() == ERXRestFormat.HTML) {\n\t\t\t\tString pageName = pageNameForAction(actionName);\n\t\t\t\tif (_NSUtilities.classWithName(pageName) != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresults = pageWithName(pageName);\n\t\t\t\t\t\tif (!(results instanceof IERXRouteComponent)) {\n\t\t\t\t\t\t\tlog.error(pageName + \" does not implement IERXRouteComponent, so it will be ignored.\");\n\t\t\t\t\t\t\tresults = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (WOPageNotFoundException e) {\n\t\t\t\t\t\tlog.info(pageName + \" does not exist, falling back to route controller.\");\n\t\t\t\t\t\tresults = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.info(pageName + \" does not exist, falling back to route controller.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (results == null) {\n\t\t        Method actionMethod = _methodForAction(actionName, WODirectAction.actionText);\n\t\t        if (actionMethod == null || actionMethod.getParameterTypes().length > 0) {\n\t\t        \tString actionMethodName = actionName + WODirectAction.actionText;\n\t\t        \tint bestParameterCount = 0;\n\t\t        \tMethod bestMethod = null;\n        \t\t\tList<PathParam> bestParams = null;\n\t\t        \tfor (Method method : getClass().getDeclaredMethods()) {\n\t\t        \t\tif (method.getName().equals(actionMethodName)) {\n\t\t        \t\t\tint parameterCount = 0;\n\t\t\t\t        \tList<PathParam> params = new LinkedList<PathParam>();\n\t\t        \t\t\tfor (Annotation[] parameterAnnotations : method.getParameterAnnotations()) {\n\t\t        \t\t\t\tfor (Annotation parameterAnnotation : parameterAnnotations) {\n\t\t        \t\t\t\t\tif (parameterAnnotation instanceof PathParam) {\n\t\t        \t\t\t\t\t\tPathParam pathParam = (PathParam)parameterAnnotation;\n\t\t        \t\t\t\t\t\tparams.add(pathParam);\n\t\t        \t\t\t\t\t\tparameterCount ++;\n\t\t        \t\t\t\t\t}\n\t\t        \t\t\t\t\telse {\n\t\t        \t\t\t\t\t\tparameterCount = -1;\n\t\t        \t\t\t\t\t\tbreak;\n\t\t        \t\t\t\t\t}\n\t\t        \t\t\t\t}\n\t\t        \t\t\t\tif (parameterCount == -1) {\n\t\t        \t\t\t\t\tbreak;\n\t\t        \t\t\t\t}\n\t\t        \t\t\t}\n\t\t        \t\t\tif (parameterCount > bestParameterCount) {\n\t\t        \t\t\t\tbestMethod = method;\n\t\t        \t\t\t\tbestParameterCount = parameterCount;\n\t\t        \t\t\t\tbestParams = params;\n\t\t        \t\t\t}\n\t\t        \t\t}\n\t\t        \t}\n\t\t        \tif (bestMethod == null) {\n\t\t        \t\tperformUnknownAction(actionName);\n\t\t        \t}\n\t\t        \telse {\n\t\t        \t\tObject[] params = new Object[bestParameterCount];\n\t\t        \t\tfor (int paramNum = 0; paramNum < params.length; paramNum ++) {\n\t\t        \t\t\tPathParam param = bestParams.get(paramNum);\n\t\t        \t\t\tparams[paramNum] = routeObjectForKey(param.value());\n\t\t        \t\t}\n\t\t        \t\tresults = (WOActionResults)bestMethod.invoke(this, params);\n\t\t        \t}\n\t\t        }\n\t\t        else {\n\t        \t\tresults = (WOActionResults)actionMethod.invoke(this, _NSUtilities._NoObjectArray);\n\t\t        }\n\t\t\t}\n\n\t\t\tif (results == null) {\n\t\t\t\tresults = response(null, ERXKeyFilter.filterWithAttributes());\n\t\t\t}\n\t\t\telse if (results instanceof IERXRouteComponent) {\n\t\t\t\t_takeRouteParametersFromRequest(results);\n\t\t\t}\n\n\t\t\tWOContext context = context();\n\t\t\tWOSession session = context._session();\n\t\t\tif (session != null && session.storesIDsInCookies() && results instanceof WOResponse) {\n\t\t\t\tWOResponse response = (WOResponse) results;\n\t\t\t\tsession._appendCookieToResponse(response);\n\t\t\t}\n\n\t\t\treturn results;\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tif (throwExceptions) {\n\t\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(t);\n\t\t\t}\n\t\t\tThrowable meaningfulThrowble = ERXExceptionUtilities.getMeaningfulThrowable(t);\n\t\t\tif (meaningfulThrowble instanceof ObjectNotAvailableException) {\n\t\t\t\treturn errorResponse(meaningfulThrowble, WOMessage.HTTP_STATUS_NOT_FOUND);\n\t\t\t}\n\t\t\telse if (meaningfulThrowble instanceof SecurityException) {\n\t\t\t\treturn errorResponse(meaningfulThrowble, WOMessage.HTTP_STATUS_FORBIDDEN);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn errorResponse(meaningfulThrowble, WOMessage.HTTP_STATUS_INTERNAL_ERROR);\n\t\t\t}\n\t\t}\n\t}","id":29527,"modified_method":"/**\n\t * Performs the given action, optionally throwing exceptions instead of converting to http response codes.\n\t *  \n\t * @param actionName the name of the action to perform\n\t * @param throwExceptions whether or not to throw exceptions\n\t * @return the action results\n\t * @throws RuntimeException if a failure occurs\n\t */\n\tpublic WOActionResults performActionNamed(String actionName, boolean throwExceptions) throws RuntimeException {\n\t\tWOActionResults results = null;\n\t\t\n\t\ttry {\n\t\t\tERXRestTransactionRequestAdaptor transactionAdaptor = ERXRestTransactionRequestAdaptor.defaultAdaptor();\n\t\t\tif (transactionAdaptor.transactionsEnabled() && !transactionAdaptor.isExecutingTransaction(context(), request())) {\n\t\t\t\tif (!transactionAdaptor.willHandleRequest(context(), request())) {\n\t\t\t\t\tif (transactionAdaptor.didHandleRequest(context(), request())) {\n\t\t\t\t\t\tresults = stringResponse(\"Transaction request enqueued.\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresults = stringResponse(\"Transaction executed.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (results == null) {\n\t\t\t\tcheckAccess();\n\t\t\t}\n\n\t\t\tif (results == null && isAutomaticHtmlRoutingEnabled() && format() == ERXRestFormat.HTML) {\n\t\t\t\tString pageName = pageNameForAction(actionName);\n\t\t\t\tif (_NSUtilities.classWithName(pageName) != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresults = pageWithName(pageName);\n\t\t\t\t\t\tif (!(results instanceof IERXRouteComponent)) {\n\t\t\t\t\t\t\tlog.error(pageName + \" does not implement IERXRouteComponent, so it will be ignored.\");\n\t\t\t\t\t\t\tresults = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (WOPageNotFoundException e) {\n\t\t\t\t\t\tlog.info(pageName + \" does not exist, falling back to route controller.\");\n\t\t\t\t\t\tresults = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.info(pageName + \" does not exist, falling back to route controller.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (results == null) {\n\t\t        Method actionMethod = _methodForAction(actionName, WODirectAction.actionText);\n\t\t        if (actionMethod == null || actionMethod.getParameterTypes().length > 0) {\n\t\t        \tString actionMethodName = actionName + WODirectAction.actionText;\n\t\t        \tint bestParameterCount = 0;\n\t\t        \tMethod bestMethod = null;\n        \t\t\tList<PathParam> bestParams = null;\n\t\t        \tfor (Method method : getClass().getDeclaredMethods()) {\n\t\t        \t\tif (method.getName().equals(actionMethodName)) {\n\t\t        \t\t\tint parameterCount = 0;\n\t\t\t\t        \tList<PathParam> params = new LinkedList<PathParam>();\n\t\t        \t\t\tfor (Annotation[] parameterAnnotations : method.getParameterAnnotations()) {\n\t\t        \t\t\t\tfor (Annotation parameterAnnotation : parameterAnnotations) {\n\t\t        \t\t\t\t\tif (parameterAnnotation instanceof PathParam) {\n\t\t        \t\t\t\t\t\tPathParam pathParam = (PathParam)parameterAnnotation;\n\t\t        \t\t\t\t\t\tparams.add(pathParam);\n\t\t        \t\t\t\t\t\tparameterCount ++;\n\t\t        \t\t\t\t\t}\n\t\t        \t\t\t\t\telse {\n\t\t        \t\t\t\t\t\tparameterCount = -1;\n\t\t        \t\t\t\t\t\tbreak;\n\t\t        \t\t\t\t\t}\n\t\t        \t\t\t\t}\n\t\t        \t\t\t\tif (parameterCount == -1) {\n\t\t        \t\t\t\t\tbreak;\n\t\t        \t\t\t\t}\n\t\t        \t\t\t}\n\t\t        \t\t\tif (parameterCount > bestParameterCount) {\n\t\t        \t\t\t\tbestMethod = method;\n\t\t        \t\t\t\tbestParameterCount = parameterCount;\n\t\t        \t\t\t\tbestParams = params;\n\t\t        \t\t\t}\n\t\t        \t\t}\n\t\t        \t}\n\t\t        \tif (bestMethod == null) {\n\t\t        \t\tperformUnknownAction(actionName);\n\t\t        \t}\n\t\t        \telse {\n\t\t        \t\tObject[] params = new Object[bestParameterCount];\n\t\t        \t\tfor (int paramNum = 0; paramNum < params.length; paramNum ++) {\n\t\t        \t\t\tPathParam param = bestParams.get(paramNum);\n\t\t        \t\t\tparams[paramNum] = routeObjectForKey(param.value());\n\t\t        \t\t}\n\t\t        \t\tresults = (WOActionResults)bestMethod.invoke(this, params);\n\t\t        \t}\n\t\t        }\n\t\t        else {\n\t        \t\tresults = (WOActionResults)actionMethod.invoke(this, _NSUtilities._NoObjectArray);\n\t\t        }\n\t\t\t}\n\n\t\t\tif (results == null) {\n\t\t\t\tresults = response(null, ERXKeyFilter.filterWithAttributes());\n\t\t\t}\n\t\t\telse if (results instanceof IERXRouteComponent) {\n\t\t\t\t_takeRouteParametersFromRequest(results);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tif (throwExceptions) {\n\t\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(t);\n\t\t\t}\n\t\t\tThrowable meaningfulThrowble = ERXExceptionUtilities.getMeaningfulThrowable(t);\n\t\t\tif (meaningfulThrowble instanceof ObjectNotAvailableException) {\n\t\t\t\tresults = errorResponse(meaningfulThrowble, WOMessage.HTTP_STATUS_NOT_FOUND);\n\t\t\t}\n\t\t\telse if (meaningfulThrowble instanceof SecurityException) {\n\t\t\t\tresults = errorResponse(meaningfulThrowble, WOMessage.HTTP_STATUS_FORBIDDEN);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresults = errorResponse(meaningfulThrowble, WOMessage.HTTP_STATUS_INTERNAL_ERROR);\n\t\t\t}\n\t\t\t// MS: Should we jam the exception in the response userInfo so the transaction adaptor can rethrow the real exception?\n\t\t}\n\n\t\tWOContext context = context();\n\t\tWOSession session = context._session();\n\t\tif (session != null && session.storesIDsInCookies() && results instanceof WOResponse) {\n\t\t\tWOResponse response = (WOResponse) results;\n\t\t\tsession._appendCookieToResponse(response);\n\t\t}\n\t\t\n\t\treturn results;\n\t}","commit_id":"6857c4429262073dbb022bae0366bb1f3856c914","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns the default format to use if no other format is found, or if the requested format is invalid.\n\t * \n\t * @return the default format to use if no other format is found, or if the requested format is invalid\n\t */\n\tprotected ERXRestFormat defaultFormat() {\n\t\treturn ERXRestFormat.XML;\n\t}","id":29528,"modified_method":"/**\n\t * Returns the default format to use if no other format is found, or if the requested format is invalid.\n\t * \n\t * @return the default format to use if no other format is found, or if the requested format is invalid\n\t */\n\tprotected ERXRestFormat defaultFormat() {\n\t\tString defaultFormatName = ERXProperties.stringForKeyWithDefault(\"ERXRest.defaultFormat\", ERXRestFormat.XML.name());\n\t\treturn ERXRestFormat.formatNamed(defaultFormatName);\n\t}","commit_id":"6857c4429262073dbb022bae0366bb1f3856c914","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n\tpublic WOActionResults indexAction() {\n\t\tERXRestFetchSpecification<T> fetchSpec = new ERXRestFetchSpecification<T>(entityName(), null, null, queryFilter(), null, 25);\n\t\treturn response(fetchSpec, showFilter());\n\t}","id":29529,"modified_method":"@Override\n\tpublic WOActionResults indexAction() {\n\t\tif (isSchemaRequest()) {\n\t\t\treturn schemaResponse(queryFilter());\n\t\t}\n\t\t\n\t\tERXRestFetchSpecification<T> fetchSpec = new ERXRestFetchSpecification<T>(entityName(), null, null, queryFilter(), null, 25);\n\t\treturn response(fetchSpec, showFilter());\n\t}","commit_id":"6857c4429262073dbb022bae0366bb1f3856c914","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static String getRDFDescriptionForLWComponent(LWComponent comp,LWMap map) {\n        String rdfDescription = new String();\n        rdfDescription = \"<rdf:RDF xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\" xmlns:rel=\\\"info:fedora/fedora-system:def/relations-external#\\\">\";\n        rdfDescription += \"<rdf:Description rdf:about=\\\"info:fedora/\"+getFedoraPid(comp)+\"\\\">\";\n        for(LWComponent c: map.getAllDescendents(LWComponent.ChildKind.PROPER)) {\n            for(VueMetadataElement element: c.getMetadataList().getMetadata()) {\n                if(element.getKey().equals(ONT_TYPE_METADATA) && element.getValue().startsWith(FEDORA_ONTOLOGY) && c instanceof LWLink){\n                    LWLink link = (LWLink)c;\n                    LWComponent head = link.getHead();\n                    if(head == comp) {\n                        LWComponent tail = link.getTail();\n                        rdfDescription +=  \"<rel:\"+getFedoraOntologyTerm(element.getValue())+\" rdf:resource=\\\"info:fedora/\"+getFedoraPid(tail)+\"\\\" />\";\n                    }\n                }\n            }\n        }\n        rdfDescription +=  \"<rel:IsPartOf rdf:resource=\\\"info:fedora/\"+getFedoraPid(map)+\"\\\" />\";\n        rdfDescription += \"<\/rdf:Description>\";\n        rdfDescription +=      \"<\/rdf:RDF>\";\n        return rdfDescription;\n    }","id":29530,"modified_method":"public static String getRDFDescriptionForLWComponent(LWComponent comp,LWMap map) {\n        String rdfDescription = new String();\n        rdfDescription = \"<rdf:RDF xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\" xmlns:rel=\\\"info:fedora/fedora-system:def/relations-external#\\\">\";\n        rdfDescription += \"<rdf:Description rdf:about=\\\"info:fedora/\"+getFedoraPid(comp)+\"\\\">\";\n        for(LWComponent c: map.getAllDescendents(LWComponent.ChildKind.PROPER)) {\n            for(VueMetadataElement element: c.getMetadataList().getMetadata()) {\n                if(DEBUG.RDF) System.out.println(\"METADATA: \"+element.getValue()+\" key:  \"+element.getKey()+\" LWComponent: \"+comp.getLabel() );\n                if(element.getKey().equals(ONT_TYPE_METADATA) && element.getValue().startsWith(FEDORA_ONTOLOGY) && c instanceof LWLink){\n                    LWLink link = (LWLink)c;\n                    LWComponent head = link.getHead();\n                    if(getFedoraPid(head).equals(getFedoraPid(comp))) {\n                        if(DEBUG.RDF) System.out.println(\"METADATA MATCH COMPONENT: \"+element.getValue()+\" key:  \"+element.getKey()+\" LWComponent: \"+comp.getLabel() +\" Link:\"+link);\n                        LWComponent tail = link.getTail();\n                        rdfDescription +=  \"<rel:\"+getFedoraOntologyTerm(element.getValue())+\" rdf:resource=\\\"info:fedora/\"+getFedoraPid(tail)+\"\\\" />\\n\";\n                    }\n                }\n            }\n        }\n        rdfDescription +=  \"<rel:IsPartOf rdf:resource=\\\"info:fedora/\"+getFedoraPid(map)+\"\\\" />\";\n        rdfDescription += \"<\/rdf:Description>\";\n        rdfDescription +=      \"<\/rdf:RDF>\";\n        return rdfDescription;\n    }","commit_id":"dd89f8f97446a54178949dbf5ea90f39fad496df","url":"https://github.com/VUE/VUE"},{"original_method":"private static void modifyObject(FedoraClient fc,Properties p, String cModel,File file,LWComponent comp,LWMap map) throws Exception{\n        String pid = getFedoraPid(comp);\n        String dsName = RESOURCE_DS;\n        String mimeType = (new MimetypesFileTypeMap().getContentType(file));\n        if(cModel.equals(VUE_CM)) {\n            dsName = VUE_DS;\n            mimeType =VUE_MIME_TYPE;\n        }\n        String dcXML= getDC(comp,comp.getLabel(),pid);\n        fc.getAPIM().modifyDatastreamByValue(pid,DC_DS,null,DC_LABEL,XML_MIME_TYPE,DC_URL,dcXML.getBytes(),null,null,COMMENT,true);\n        \n        // modifying rels-ext for non VUE_CM\n        if(!cModel.equals(VUE_CM)){\n            fc.getAPIM().modifyDatastreamByValue(pid,RELS_DS,null,RELS_LABEL,XML_MIME_TYPE,RELS_URL, getRDFDescriptionForLWComponent(comp,map).getBytes(),null,null,COMMENT,true);\n        }\n        if(cModel.equals(REMOTE_CM)){\n        }else {\n            Uploader uploader = new Uploader(HTTPS, p.getProperty(\"fedora22Address\"),Integer.parseInt(p.getProperty(\"fedora22SecurePort\")),p.getProperty(\"fedora22UserName\"), p.getProperty(\"fedora22Password\"));\n            String uploadId = uploader.upload(file);\n            fc.getAPIM().modifyDatastreamByReference(pid, dsName,  null,comp.getLabel(), mimeType, VUE_FORMAT_URL, uploadId, null,null,  COMMENT,true);\n            \n        }\n    }","id":29531,"modified_method":"private static void modifyObject(FedoraClient fc,Properties p, String cModel,File file,LWComponent comp,LWMap map) throws Exception{\n        String pid = getFedoraPid(comp);\n        String dsName = RESOURCE_DS;\n        String mimeType = \"text/html\";\n        if(file!= null) {\n            mimeType =  new MimetypesFileTypeMap().getContentType(file) ;\n        } else{\n            mimeType =  new MimetypesFileTypeMap().getContentType(comp.getResource().getSpec());\n        }if(cModel.equals(VUE_CM)) {\n            dsName = VUE_DS;\n            mimeType =VUE_MIME_TYPE;\n        }\n        String dcXML= getDC(comp,comp.getLabel(),pid);\n        fc.getAPIM().modifyDatastreamByValue(pid,DC_DS,null,DC_LABEL,XML_MIME_TYPE,DC_URL,dcXML.getBytes(),null,null,COMMENT,true);\n        // modifying rels-ext for non VUE_CM\n        if(!cModel.equals(VUE_CM)){\n            fc.getAPIM().modifyDatastreamByValue(pid,RELS_DS,null,RELS_LABEL,XML_MIME_TYPE,RELS_URL, getRDFDescriptionForLWComponent(comp,map).getBytes(),null,null,COMMENT,true);\n        }\n        if(cModel.equals(REMOTE_CM)){\n            fc.getAPIM().modifyDatastreamByReference(pid, dsName,  null,comp.getLabel(), mimeType, VUE_FORMAT_URL, comp.getResource().getSpec(), null,null,  COMMENT,true);\n        }else {\n            Uploader uploader = new Uploader(HTTPS, p.getProperty(\"fedora22Address\"),Integer.parseInt(p.getProperty(\"fedora22SecurePort\")),p.getProperty(\"fedora22UserName\"), p.getProperty(\"fedora22Password\"));\n            String uploadId = uploader.upload(file);\n            fc.getAPIM().modifyDatastreamByReference(pid, dsName,  null,comp.getLabel(), mimeType, VUE_FORMAT_URL, uploadId, null,null,  COMMENT,true);\n            \n        }\n    }","commit_id":"dd89f8f97446a54178949dbf5ea90f39fad496df","url":"https://github.com/VUE/VUE"},{"original_method":"private static String getOjectDSXML(Properties p,LWComponent comp,String cModel, File file) throws Exception {\n        SimpleDateFormat  formatter =  new java.text.SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'.000Z'\");\n        Date currentTime = new Date();\n        String dateString = formatter.format(currentTime);\n        String uploadId = new String();\n        String pid = getFedoraPid(comp);\n        String dsName = RESOURCE_DS;\n        String mimeType = (new MimetypesFileTypeMap().getContentType(file));\n        String controlGroup = \"M\";\n        String contentLocationType = \"INTERNAL_ID\";\n        if(cModel.equals(VUE_CM)) {\n            dsName = VUE_DS;\n            mimeType =VUE_MIME_TYPE;\n        }\n        if(!cModel.equals(REMOTE_CM)){\n            Uploader uploader = new Uploader(HTTPS, p.getProperty(\"fedora22Address\"),Integer.parseInt(p.getProperty(\"fedora22SecurePort\")),p.getProperty(\"fedora22UserName\"), p.getProperty(\"fedora22Password\"));\n            uploadId = uploader.upload(file);\n        } else {\n            controlGroup = \"E\";\n            contentLocationType = \"URL\";\n        }\n        \n        StringBuffer xml = new StringBuffer();\n        xml.append(\"<foxml:datastream CONTROL_GROUP=\\\"\"+controlGroup+\"\\\" ID=\\\"\"+dsName+\"\\\" STATE=\\\"A\\\" VERSIONABLE=\\\"true\\\">\\n\");\n        xml.append(\"<foxml:datastreamVersion CREATED=\\\"\"+dateString+\"\\\" FORMAT_URI=\\\"http://vue.tufts.edu/docs/vueformat/\\\"\");\n        xml.append(\" ID=\\\"\"+dsName+\".0\\\" LABEL=\\\"\"+comp.getLabel()+\"\\\" MIMETYPE=\\\"\"+mimeType+\"\\\">\\n\");\n        xml.append(\"<foxml:contentDigest DIGEST=\\\"none\\\" TYPE=\\\"DISABLED\\\"/>\\n\");\n        xml.append(\"<foxml:contentLocation  REF=\\\"\"+uploadId+\"\\\" TYPE=\\\"\"+contentLocationType+\"\\\"/>\\n\");\n        xml.append(\"<\/foxml:datastreamVersion><\/foxml:datastream>\\n\");\n        return xml.toString();\n    }","id":29532,"modified_method":"private static String getOjectDSXML(Properties p,LWComponent comp,String cModel, File file) throws Exception {\n        SimpleDateFormat  formatter =  new java.text.SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'.000Z'\");\n        Date currentTime = new Date();\n        String dateString = formatter.format(currentTime);\n        String uploadId = new String();\n        String pid = getFedoraPid(comp);\n        String dsName = RESOURCE_DS;\n        String mimeType = \"text/html\";\n        if(file!= null) {\n            mimeType =  new MimetypesFileTypeMap().getContentType(file) ;\n        } else{\n            mimeType =  new MimetypesFileTypeMap().getContentType(comp.getResource().getSpec());\n        }\n        String controlGroup = \"M\";\n        String contentLocationType = \"INTERNAL_ID\";\n        if(cModel.equals(VUE_CM)) {\n            dsName = VUE_DS;\n            mimeType =VUE_MIME_TYPE;\n        }\n        if(!cModel.equals(REMOTE_CM)){\n            Uploader uploader = new Uploader(HTTPS, p.getProperty(\"fedora22Address\"),Integer.parseInt(p.getProperty(\"fedora22SecurePort\")),p.getProperty(\"fedora22UserName\"), p.getProperty(\"fedora22Password\"));\n            uploadId = uploader.upload(file);\n        } else {\n            controlGroup = \"E\";\n            contentLocationType = \"URL\";\n            uploadId = comp.getResource().getSpec();\n        }\n        \n        StringBuffer xml = new StringBuffer();\n        xml.append(\"<foxml:datastream CONTROL_GROUP=\\\"\"+controlGroup+\"\\\" ID=\\\"\"+dsName+\"\\\" STATE=\\\"A\\\" VERSIONABLE=\\\"true\\\">\\n\");\n        xml.append(\"<foxml:datastreamVersion CREATED=\\\"\"+dateString+\"\\\" FORMAT_URI=\\\"http://vue.tufts.edu/docs/vueformat/\\\"\");\n        xml.append(\" ID=\\\"\"+dsName+\".0\\\" LABEL=\\\"\"+comp.getLabel()+\"\\\" MIMETYPE=\\\"\"+mimeType+\"\\\">\\n\");\n        xml.append(\"<foxml:contentDigest DIGEST=\\\"none\\\" TYPE=\\\"DISABLED\\\"/>\\n\");\n        xml.append(\"<foxml:contentLocation  REF=\\\"\"+uploadId+\"\\\" TYPE=\\\"\"+contentLocationType+\"\\\"/>\\n\");\n        xml.append(\"<\/foxml:datastreamVersion><\/foxml:datastream>\\n\");\n        return xml.toString();\n    }","commit_id":"dd89f8f97446a54178949dbf5ea90f39fad496df","url":"https://github.com/VUE/VUE"},{"original_method":"public static void uploadMapAll(edu.tufts.vue.dsm.DataSource ds, LWMap map) throws Exception{\n        Properties properties = ds.getConfiguration();\n        LWMap cloneMap = (LWMap)map.clone();\n        cloneMap.setLabel(map.getLabel());\n        Iterator i = cloneMap.getAllDescendents(LWComponent.ChildKind.PROPER).iterator();\n        while(i.hasNext()) {\n            LWComponent component = (LWComponent) i.next();\n            if(component.hasResource() && (component instanceof LWNode || component instanceof LWLink) && (component.getResource() instanceof URLResource)){\n                URLResource resource = (URLResource) component.getResource();\n                if(resource.isLocalFile()) {\n                    String pid = getFedoraPid(component);\n                    File file = new File(resource.getSpec().replace(FILE_PREFIX,\"\"));\n                    addObjectToRepository(ds,OTHER_CM, file,  component, map);\n                    String ingestUrl = HTTP+\"://\"+properties.getProperty(\"fedora22Address\")+\":\"+properties.getProperty(\"fedora22Port\")+FEDORA_URL_PATH+\"get/\"+pid+\"/\"+RESOURCE_DS;\n                }\n            }\n        }\n        uploadMap(ds,map);\n    }","id":29533,"modified_method":"public static void uploadMapAll(edu.tufts.vue.dsm.DataSource ds, LWMap map) throws Exception{\n        Properties properties = ds.getConfiguration();\n        LWMap cloneMap = (LWMap)map.clone();\n        cloneMap.setLabel(map.getLabel());\n        Iterator i = cloneMap.getAllDescendents(LWComponent.ChildKind.PROPER).iterator();\n        while(i.hasNext()) {\n            LWComponent component = (LWComponent) i.next();\n            if(component.hasResource() && (component instanceof LWNode || component instanceof LWLink) && (component.getResource() instanceof URLResource)){\n                URLResource resource = (URLResource) component.getResource();\n                String pid = getFedoraPid(component);\n                if(resource.isLocalFile()) {\n                    File file = new File(resource.getSpec().replace(FILE_PREFIX,\"\"));\n                    addObjectToRepository(ds,OTHER_CM, file,  component, map);\n                } else {\n                    addObjectToRepository(ds,REMOTE_CM,null,component,map);\n                }\n                String ingestUrl = HTTP+\"://\"+properties.getProperty(\"fedora22Address\")+\":\"+properties.getProperty(\"fedora22Port\")+FEDORA_URL_PATH+\"get/\"+pid+\"/\"+RESOURCE_DS;\n            }\n        }\n        uploadMap(ds,map);\n    }","commit_id":"dd89f8f97446a54178949dbf5ea90f39fad496df","url":"https://github.com/VUE/VUE"},{"original_method":"public static void uploadMapAll(edu.tufts.vue.dsm.DataSource ds, LWMap map) throws Exception{\n        Properties properties = ds.getConfiguration();\n        String mapLabel = map.getLabel();\n        File origFile = map.getFile();\n        \n        File tempFile  = new File(VueUtil.getDefaultUserFolder()+File.separator+origFile.getName());\n        tempFile.deleteOnExit();\n        tufts.vue.action.ActionUtil.marshallMap(tempFile,map);\n        \n        LWMap cloneMap =   tufts.vue.action.OpenAction.loadMap(tempFile.getAbsolutePath());\n        \n        Iterator i = cloneMap.getAllDescendents(LWComponent.ChildKind.PROPER).iterator();\n        while(i.hasNext()) {\n            LWComponent component = (LWComponent) i.next();\n            if(component.hasResource() && (component instanceof LWNode || component instanceof LWLink) && (component.getResource() instanceof URLResource)){\n                URLResource resource = (URLResource) component.getResource();\n                String pid = getFedoraPid(component);\n                if(resource.isLocalFile()) {\n                    File localFile = new File(resource.getSpec().replace(FILE_PREFIX,\"\"));\n                    addObjectToRepository(ds,OTHER_CM, localFile,  component, cloneMap);\n                } else {\n                    addObjectToRepository(ds,REMOTE_CM,null,component,cloneMap);\n                }\n                String ingestUrl = HTTP+\"://\"+properties.getProperty(\"fedora22Address\")+\":\"+properties.getProperty(\"fedora22Port\")+FEDORA_URL_PATH+\"get/\"+pid+\"/\"+RESOURCE_DS;\n                //System.out.println(\"Replacing resource: \"+resource+ \" with \"+ingestUrl);\n                component.setResource(URLResource.create(ingestUrl));\n                \n            }\n        }\n        tufts.vue.action.ActionUtil.marshallMap(tempFile,cloneMap);\n        uploadMap(ds,cloneMap);\n        tufts.vue.action.ActionUtil.marshallMap(origFile, map);\n        \n        \n    }","id":29534,"modified_method":"public static void uploadMapAll(edu.tufts.vue.dsm.DataSource ds, LWMap map) throws Exception{\n        Properties properties = ds.getConfiguration();\n        String mapLabel = map.getLabel();\n        File origFile = map.getFile();\n        \n        File tempFile  = new File(VueUtil.getDefaultUserFolder()+File.separator+origFile.getName());\n        tempFile.deleteOnExit();\n        tufts.vue.action.ActionUtil.marshallMap(tempFile,map);\n        \n        LWMap cloneMap =   tufts.vue.action.OpenAction.loadMap(tempFile.getAbsolutePath());\n        \n        Iterator i = cloneMap.getAllDescendents(LWComponent.ChildKind.PROPER).iterator();\n        while(i.hasNext()) {\n            LWComponent component = (LWComponent) i.next();\n            if(component.hasResource() && (component instanceof LWNode || component instanceof LWLink) && (component.getResource() instanceof URLResource)){\n                URLResource resource = (URLResource) component.getResource();\n                String pid = getFedoraPid(component);\n                if(resource.isLocalFile()) {\n                    File localFile = new File(resource.getSpec().replace(FILE_PREFIX,\"\"));\n                    addObjectToRepository(ds,OTHER_CM, localFile,  component, cloneMap);\n                    String ingestUrl = HTTP+\"://\"+properties.getProperty(\"fedora22Address\")+\":\"+properties.getProperty(\"fedora22Port\")+FEDORA_URL_PATH+\"get/\"+pid+\"/\"+RESOURCE_DS;\n                   component.setResource(URLResource.create(ingestUrl));\n                } else if(!(resource instanceof Osid2AssetResource)) {\n                    addObjectToRepository(ds,REMOTE_CM,null,component,cloneMap);\n                    String ingestUrl = HTTP+\"://\"+properties.getProperty(\"fedora22Address\")+\":\"+properties.getProperty(\"fedora22Port\")+FEDORA_URL_PATH+\"get/\"+pid+\"/\"+RESOURCE_DS;\n                     component.setResource(URLResource.create(ingestUrl));\n                }\n          //        System.out.println(\"Replacing resource: \"+resource+ \" with \"+ingestUrl+\" resource is \"+resource.getClass());\n                   \n                \n            }\n        }\n        tufts.vue.action.ActionUtil.marshallMap(tempFile,cloneMap);\n        uploadMap(ds,cloneMap);\n        tufts.vue.action.ActionUtil.marshallMap(origFile, map);\n        \n        \n    }","commit_id":"508f857445b62535ed6b1bbee9268c94fe4961d6","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n  public Runnable showOption(final String option) {\n    final String lowerCaseOption = option.toLowerCase();\n    DefaultListModel model = (DefaultListModel)myOptionsList.getModel();\n\n    for (int i = 0; i < model.size(); i++) {\n      Object o = model.get(i);\n      if (o instanceof EditorSchemeAttributeDescriptor) {\n        String type = ((EditorSchemeAttributeDescriptor)o).getType();\n        if (type.toLowerCase().contains(lowerCaseOption) ||\n            o.toString().toLowerCase().contains(lowerCaseOption)) {\n          final int i1 = i;\n          return new Runnable() {\n            @Override\n            public void run() {\n              ListScrollingUtil.selectItem(myOptionsList, i1);\n            }\n          };\n\n        }\n      }\n    }\n\n    return null;\n  }","id":29535,"modified_method":"@Override\n  public Runnable showOption(String attribute) {\n    final int index = getAttributeIndex(attribute);\n    return index < 0 ? null : new Runnable() {\n      @Override\n      public void run() {\n        ListScrollingUtil.selectItem(myOptionsList, index);\n      }\n    };\n  }","commit_id":"0c9df8ff4b2b4a12c4a3b9639904b0d0f1495cfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void fillOptionsList() {\n    int selIndex = myOptionsList.getSelectedIndex();\n\n    DefaultListModel listModel = (DefaultListModel)myOptionsList.getModel();\n    listModel.removeAllElements();\n\n    EditorSchemeAttributeDescriptor[] descriptions = myOptions.getCurrentDescriptions();\n\n    for (EditorSchemeAttributeDescriptor description : descriptions) {\n      if (description.getGroup().equals(myCategoryName)) {\n        listModel.addElement(description);\n      }\n    }\n    if (selIndex >= 0) {\n      myOptionsList.setSelectedIndex(selIndex);\n    }\n    ListScrollingUtil.ensureSelectionExists(myOptionsList);\n\n    Object selected = myOptionsList.getSelectedValue();\n    if (selected instanceof EditorSchemeAttributeDescriptor) {\n      myDispatcher.getMulticaster().selectedOptionChanged(selected);\n    }\n  }","id":29536,"modified_method":"private void fillOptionsList() {\n    int selIndex = myOptionsList.getSelectedIndex();\n\n    myListModel.removeAll();\n\n    ArrayList<EditorSchemeAttributeDescriptor> list = ContainerUtil.newArrayList();\n    for (EditorSchemeAttributeDescriptor description : myOptions.getCurrentDescriptions()) {\n      if (!description.getGroup().equals(myCategoryName)) continue;\n      list.add(description);\n    }\n    Collections.sort(list, ATTR_COMPARATOR);\n    myListModel.add(list);\n    if (selIndex >= 0) {\n      myOptionsList.setSelectedIndex(selIndex);\n    }\n    ListScrollingUtil.ensureSelectionExists(myOptionsList);\n\n    Object selected = myOptionsList.getSelectedValue();\n    if (selected instanceof EditorSchemeAttributeDescriptor) {\n      myDispatcher.getMulticaster().selectedOptionChanged(selected);\n    }\n  }","commit_id":"0c9df8ff4b2b4a12c4a3b9639904b0d0f1495cfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public OptionsPanelImpl(ColorAndFontDescriptionPanel optionsPanel, ColorAndFontOptions options, SchemesPanel schemesProvider,\n                      String categoryName) {\n    super(new BorderLayout());\n    myOptions = options;\n    mySchemesProvider = schemesProvider;\n    myCategoryName = categoryName;\n\n    optionsPanel.setActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(final ActionEvent e) {\n        myDispatcher.getMulticaster().settingsChanged();\n      }\n    });\n\n    myOptionsList = new JBList();\n\n    myOptionsList.addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        if (!mySchemesProvider.areSchemesLoaded()) return;\n        processListValueChanged();\n      }\n    });\n    myOptionsList.setCellRenderer(new DefaultListCellRenderer(){\n      @Override\n      public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n        Component component = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        if (value instanceof ColorAndFontDescription) {\n          setIcon(((ColorAndFontDescription)value).getIcon());\n          setToolTipText(((ColorAndFontDescription)value).getToolTip());\n        }\n        return component;\n      }\n    });\n\n    myOptionsList.setModel(new DefaultListModel());\n    myOptionsList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myOptionsList);\n    scrollPane.setPreferredSize(new Dimension(230, 60));\n    JPanel north = new JPanel(new BorderLayout());\n    north.add(scrollPane, BorderLayout.CENTER);\n    north.add(optionsPanel, BorderLayout.EAST);\n    myOptionsPanel = optionsPanel;\n    add(north, BorderLayout.NORTH);\n  }","id":29537,"modified_method":"public OptionsPanelImpl(ColorAndFontDescriptionPanel optionsPanel,\n                          ColorAndFontOptions options,\n                          SchemesPanel schemesProvider,\n                          String categoryName) {\n    super(new BorderLayout());\n    myOptions = options;\n    mySchemesProvider = schemesProvider;\n    myCategoryName = categoryName;\n\n    optionsPanel.setActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(final ActionEvent e) {\n        myDispatcher.getMulticaster().settingsChanged();\n      }\n    });\n\n    myListModel = new CollectionListModel<EditorSchemeAttributeDescriptor>();\n    myOptionsList = new JBList(myListModel);\n    new ListSpeedSearch(myOptionsList);\n\n    myOptionsList.addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        if (!mySchemesProvider.areSchemesLoaded()) return;\n        processListValueChanged();\n      }\n    });\n    myOptionsList.setCellRenderer(new DefaultListCellRenderer(){\n      @Override\n      public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n        Component component = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        if (value instanceof ColorAndFontDescription) {\n          setIcon(((ColorAndFontDescription)value).getIcon());\n          setToolTipText(((ColorAndFontDescription)value).getToolTip());\n        }\n        return component;\n      }\n    });\n\n    myOptionsList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myOptionsList);\n    scrollPane.setPreferredSize(new Dimension(230, 60));\n    JPanel north = new JPanel(new BorderLayout());\n    north.add(scrollPane, BorderLayout.CENTER);\n    north.add(optionsPanel, BorderLayout.EAST);\n    myOptionsPanel = optionsPanel;\n    add(north, BorderLayout.NORTH);\n  }","commit_id":"0c9df8ff4b2b4a12c4a3b9639904b0d0f1495cfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void selectOption(final String typeToSelect) {\n    DefaultListModel model = (DefaultListModel)myOptionsList.getModel();\n\n    for (int i = 0; i < model.size(); i++) {\n      Object o = model.get(i);\n      if (o instanceof EditorSchemeAttributeDescriptor) {\n        if (typeToSelect.equals(((EditorSchemeAttributeDescriptor)o).getType())) {\n          ListScrollingUtil.selectItem(myOptionsList, i);\n          return;\n        }\n      }\n    }\n\n  }","id":29538,"modified_method":"@Override\n  public void selectOption(String attribute) {\n    int index = getAttributeIndex(attribute);\n    if (index < 0) return;\n    ListScrollingUtil.selectItem(myOptionsList, index);\n  }","commit_id":"0c9df8ff4b2b4a12c4a3b9639904b0d0f1495cfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Endpoint createEndpoint(String uri) throws Exception {\n        ObjectHelper.notNull(getCamelContext(), \"camelContext\");\n        // check URI string to the unsafe URI characters\n        String encodedUri = preProcessUri(uri);\n        URI u = new URI(encodedUri);\n        String path = u.getSchemeSpecificPart();\n\n        // lets trim off any query arguments\n        if (path.startsWith(\"//\")) {\n            path = path.substring(2);\n        }\n        int idx = path.indexOf('?');\n        if (idx > 0) {\n            path = path.substring(0, idx);\n        }\n        Map<String, Object> parameters = URISupport.parseParameters(u);\n\n        validateURI(encodedUri, path, parameters);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Creating endpoint uri=[{}], path=[{}], parameters=[{}]\", new Object[]{encodedUri, path, parameters});\n        }\n        Endpoint endpoint = createEndpoint(encodedUri, path, parameters);\n        if (endpoint == null) {\n            return null;\n        }\n\n        if (parameters != null && !parameters.isEmpty()) {\n            endpoint.configureProperties(parameters);\n            if (useIntrospectionOnEndpoint()) {\n                setProperties(endpoint, parameters);\n            }\n\n            // if endpoint is strict (not lenient) and we have unknown parameters configured then\n            // fail if there are parameters that could not be set, then they are probably misspell or not supported at all\n            if (!endpoint.isLenientProperties()) {\n                validateParameters(encodedUri, parameters, null);\n            }\n        }\n\n        afterConfiguration(encodedUri, path, endpoint, parameters);\n        return endpoint;\n    }","id":29539,"modified_method":"public Endpoint createEndpoint(String uri) throws Exception {\n        ObjectHelper.notNull(getCamelContext(), \"camelContext\");\n        // check URI string to the unsafe URI characters\n        String encodedUri = preProcessUri(uri);\n        URI u = new URI(encodedUri);\n        String path = u.getSchemeSpecificPart();\n\n        // lets trim off any query arguments\n        if (path.startsWith(\"//\")) {\n            path = path.substring(2);\n        }\n        int idx = path.indexOf('?');\n        if (idx > 0) {\n            path = path.substring(0, idx);\n        }\n        Map<String, Object> parameters = URISupport.parseParameters(u);\n\n        validateURI(encodedUri, path, parameters);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Creating endpoint uri=[{}], path=[{}], parameters=[{}]\", new Object[]{URISupport.sanitizeUri(encodedUri), path, parameters});\n        }\n        Endpoint endpoint = createEndpoint(encodedUri, path, parameters);\n        if (endpoint == null) {\n            return null;\n        }\n\n        if (parameters != null && !parameters.isEmpty()) {\n            endpoint.configureProperties(parameters);\n            if (useIntrospectionOnEndpoint()) {\n                setProperties(endpoint, parameters);\n            }\n\n            // if endpoint is strict (not lenient) and we have unknown parameters configured then\n            // fail if there are parameters that could not be set, then they are probably misspell or not supported at all\n            if (!endpoint.isLenientProperties()) {\n                validateParameters(encodedUri, parameters, null);\n            }\n        }\n\n        afterConfiguration(encodedUri, path, endpoint, parameters);\n        return endpoint;\n    }","commit_id":"4297abb08c4fa3e15b6fa9c6ae8341114282f84f","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public String toString() {\n        return \"Consumer[\" + endpoint.getEndpointUri() + \"]\";\n    }","id":29540,"modified_method":"@Override\n    public String toString() {\n        return \"Consumer[\" + URISupport.sanitizeUri(endpoint.getEndpointUri()) + \"]\";\n    }","commit_id":"4297abb08c4fa3e15b6fa9c6ae8341114282f84f","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public ScheduledExecutorService newScheduledThreadPool(Object source, String name, ThreadPoolProfile profile) {\n        profile.addDefaults(getDefaultThreadPoolProfile());\n        ScheduledExecutorService answer = threadPoolFactory.newScheduledThreadPool(profile, createThreadFactory(name, true));\n        onThreadPoolCreated(answer, source, null);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Created new ScheduledThreadPool for source: {} with name: {}. -> {}\", new Object[]{source, name, answer});\n        }\n        return answer;\n\n    }","id":29541,"modified_method":"@Override\n    public ScheduledExecutorService newScheduledThreadPool(Object source, String name, ThreadPoolProfile profile) {\n        String sanitizedName = URISupport.sanitizeUri(name);\n        profile.addDefaults(getDefaultThreadPoolProfile());\n        ScheduledExecutorService answer = threadPoolFactory.newScheduledThreadPool(profile, createThreadFactory(sanitizedName, true));\n        onThreadPoolCreated(answer, source, null);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Created new ScheduledThreadPool for source: {} with name: {}. -> {}\", new Object[]{source, sanitizedName, answer});\n        }\n        return answer;\n\n    }","commit_id":"4297abb08c4fa3e15b6fa9c6ae8341114282f84f","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public ExecutorService newCachedThreadPool(Object source, String name) {\n        ExecutorService answer = threadPoolFactory.newCachedThreadPool(createThreadFactory(name, true));\n        onThreadPoolCreated(answer, source, null);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Created new CachedThreadPool for source: {} with name: {}. -> {}\", new Object[]{source, name, answer});\n        }\n        return answer;\n    }","id":29542,"modified_method":"@Override\n    public ExecutorService newCachedThreadPool(Object source, String name) {\n        String sanitizedName = URISupport.sanitizeUri(name);\n        ExecutorService answer = threadPoolFactory.newCachedThreadPool(createThreadFactory(sanitizedName, true));\n        onThreadPoolCreated(answer, source, null);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Created new CachedThreadPool for source: {} with name: {}. -> {}\", new Object[]{source, sanitizedName, answer});\n        }\n        return answer;\n    }","commit_id":"4297abb08c4fa3e15b6fa9c6ae8341114282f84f","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public ExecutorService newThreadPool(Object source, String name, ThreadPoolProfile profile) {\n        ObjectHelper.notNull(profile, \"ThreadPoolProfile\");\n\n        ThreadPoolProfile defaultProfile = getDefaultThreadPoolProfile();\n        profile.addDefaults(defaultProfile);\n\n        ThreadFactory threadFactory = createThreadFactory(name, true);\n        ExecutorService executorService = threadPoolFactory.newThreadPool(profile, threadFactory);\n        onThreadPoolCreated(executorService, source, profile.getId());\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Created new ThreadPool for source: {} with name: {}. -> {}\", new Object[]{source, name, executorService});\n        }\n\n        return executorService;\n    }","id":29543,"modified_method":"@Override\n    public ExecutorService newThreadPool(Object source, String name, ThreadPoolProfile profile) {\n        String sanitizedName = URISupport.sanitizeUri(name);\n        ObjectHelper.notNull(profile, \"ThreadPoolProfile\");\n\n        ThreadPoolProfile defaultProfile = getDefaultThreadPoolProfile();\n        profile.addDefaults(defaultProfile);\n\n        ThreadFactory threadFactory = createThreadFactory(sanitizedName, true);\n        ExecutorService executorService = threadPoolFactory.newThreadPool(profile, threadFactory);\n        onThreadPoolCreated(executorService, source, profile.getId());\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Created new ThreadPool for source: {} with name: {}. -> {}\", new Object[]{source, sanitizedName, executorService});\n        }\n\n        return executorService;\n    }","commit_id":"4297abb08c4fa3e15b6fa9c6ae8341114282f84f","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Removes detected sensitive information (such as passwords) from the URI and returns the result.\n     * @param uri The uri to sanitize.\n     * @see #SECRETS for the matched pattern\n     *\n     * @return Returns null if the uri is null, otherwise the URI with the passphrase, password or secretKey sanitized.\n     */\n    public static String sanitizeUri(String uri) {\n        return uri == null ? null : SECRETS.matcher(uri).replaceAll(\"$1=******\");\n    }","id":29544,"modified_method":"/**\n     * Removes detected sensitive information (such as passwords) from the URI and returns the result.\n     * @param uri The uri to sanitize.\n     * @see #SECRETS for the matched pattern\n     *\n     * @return Returns null if the uri is null, otherwise the URI with the passphrase, password or secretKey sanitized.\n     */\n    public static String sanitizeUri(String uri) {\n        String sanitized = uri;\n        if (uri != null) {\n            sanitized = SECRETS.matcher(sanitized).replaceAll(\"$1=******\");\n            sanitized = USERINFO_PASSWORD.matcher(sanitized).replaceFirst(\"$1******$3\");\n        }\n        return sanitized;\n    }","commit_id":"4297abb08c4fa3e15b6fa9c6ae8341114282f84f","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public String toString() {\n        return \"Endpoint[\" + getEndpointUri() + \"]\";\n    }","id":29545,"modified_method":"@Override\n    public String toString() {\n        return String.format(\"Endpoint[%s]\", sanitizeUri(getEndpointUri()));\n    }","commit_id":"6153f66d8f569c8ee98714a74cd55bf984bb1f0a","url":"https://github.com/apache/camel"},{"original_method":"public List<CamelContext> getCamelContexts() {\n        List<CamelContext> camelContexts = new ArrayList<CamelContext>();\n        try {\n            ServiceReference<?>[] references = bundleContext.getServiceReferences(CamelContext.class.getName(), null);\n            if (references != null) {\n                for (ServiceReference<?> reference : references) {\n                    if (reference != null) {\n                        CamelContext camelContext = (CamelContext) bundleContext.getService(reference);\n                        if (camelContext != null) {\n                            camelContexts.add(camelContext);\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Cannot retrieve the list of Camel contexts.\", e);\n        }\n        return camelContexts;\n    }","id":29546,"modified_method":"public List<CamelContext> getCamelContexts() {\n        List<CamelContext> camelContexts = new ArrayList<CamelContext>();\n        try {\n            ServiceReference<?>[] references = bundleContext.getServiceReferences(CamelContext.class.getName(), null);\n            if (references != null) {\n                for (ServiceReference<?> reference : references) {\n                    if (reference != null) {\n                        CamelContext camelContext = (CamelContext) bundleContext.getService(reference);\n                        if (camelContext != null) {\n                            camelContexts.add(camelContext);\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Cannot retrieve the list of Camel contexts.\", e);\n        }\n\n        // sort the list\n        Collections.sort(camelContexts, new Comparator<CamelContext>() {\n            @Override\n            public int compare(CamelContext o1, CamelContext o2) {\n                return o1.getName().compareTo(o2.getName());\n            }\n        });\n\n        return camelContexts;\n    }","commit_id":"f5302d3ef9d2b69480f0a1877b4acb932e662c10","url":"https://github.com/apache/camel"},{"original_method":"public List<Route> getRoutes(String camelContextName, String filter) {\n        List<Route> routes = null;\n        if (camelContextName != null) {\n            CamelContext context = this.getCamelContext(camelContextName);\n            if (context != null) {\n                for (Route route : context.getRoutes()) {\n                    if (routes == null) {\n                        routes = new ArrayList<Route>();\n                    }\n                    if (route.getId().matches(filter)) {\n                        routes.add(route);\n                    }\n                }\n            }\n        } else {\n            List<CamelContext> camelContexts = this.getCamelContexts();\n            for (CamelContext camelContext : camelContexts) {\n                for (Route route : camelContext.getRoutes()) {\n                    if (routes == null) {\n                        routes = new ArrayList<Route>();\n                    }\n                    if (route.getId().matches(filter)) {\n                        routes.add(route);\n                    }\n                }\n            }\n        }\n        return routes;\n    }","id":29547,"modified_method":"public List<Route> getRoutes(String camelContextName, String filter) {\n        List<Route> routes = new ArrayList<Route>();\n\n        if (camelContextName != null) {\n            CamelContext context = this.getCamelContext(camelContextName);\n            if (context != null) {\n                for (Route route : context.getRoutes()) {\n                    if (filter == null || route.getId().matches(filter)) {\n                        routes.add(route);\n                    }\n                }\n            }\n        } else {\n            List<CamelContext> camelContexts = this.getCamelContexts();\n            for (CamelContext camelContext : camelContexts) {\n                for (Route route : camelContext.getRoutes()) {\n                    if (filter == null || route.getId().matches(filter)) {\n                        routes.add(route);\n                    }\n                }\n            }\n        }\n\n        // sort the list\n        Collections.sort(routes, new Comparator<Route>() {\n            @Override\n            public int compare(Route o1, Route o2) {\n                // group by camel context first, then by route name\n                String c1 = o1.getRouteContext().getCamelContext().getName();\n                String c2 = o2.getRouteContext().getCamelContext().getName();\n\n                int answer = c1.compareTo(c2);\n                if (answer == 0) {\n                    // okay from same camel context, then sort by route id\n                    answer = o1.getId().compareTo(o2.getId());\n                }\n                return answer;\n            }\n        });\n        return routes;\n    }","commit_id":"f5302d3ef9d2b69480f0a1877b4acb932e662c10","url":"https://github.com/apache/camel"},{"original_method":"public List<Route> getRoutes(String camelContextName) {\n        if (camelContextName != null) {\n            CamelContext context = this.getCamelContext(camelContextName);\n            if (context != null) {\n                return context.getRoutes();\n            }\n        } else {\n            List<Route> routes = new ArrayList<Route>();\n            List<CamelContext> camelContexts = this.getCamelContexts();\n            for (CamelContext camelContext : camelContexts) {\n                for (Route route : camelContext.getRoutes()) {\n                    routes.add(route);\n                }\n            }\n            return routes;\n        }\n        return null;\n    }","id":29548,"modified_method":"public List<Route> getRoutes(String camelContextName) {\n        return getRoutes(camelContextName, null);\n    }","commit_id":"f5302d3ef9d2b69480f0a1877b4acb932e662c10","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"deprecation\")\n    public List<RouteDefinition> getRouteDefinitions(String camelContextName) {\n        if (camelContextName != null) {\n            CamelContext context = this.getCamelContext(camelContextName);\n            if (context != null) {\n                return context.getRouteDefinitions();\n            }\n        } else {\n            List<RouteDefinition> routeDefinitions = new ArrayList<RouteDefinition>();\n            List<CamelContext> camelContexts = this.getCamelContexts();\n            for (CamelContext camelContext : camelContexts) {\n                for (RouteDefinition routeDefinition : camelContext.getRouteDefinitions()) {\n                    routeDefinitions.add(routeDefinition);\n                }\n            }\n            return routeDefinitions;\n        }\n        return null;\n    }","id":29549,"modified_method":"@SuppressWarnings(\"deprecation\")\n    public List<RouteDefinition> getRouteDefinitions(String camelContextName) {\n        List<RouteDefinition> answer = new ArrayList<RouteDefinition>();\n\n        if (camelContextName != null) {\n            CamelContext context = this.getCamelContext(camelContextName);\n            if (context != null) {\n                List<RouteDefinition> routes = context.getRouteDefinitions();\n                // sort routes\n                Collections.sort(routes, new Comparator<RouteDefinition>() {\n                    @Override\n                    public int compare(RouteDefinition o1, RouteDefinition o2) {\n                        // already sorted by camel context first, so just sort the ids\n                        return o1.getId().compareTo(o2.getId());\n                    }\n                });\n                answer.addAll(routes);\n            }\n        } else {\n            // already sorted by camel context\n            List<CamelContext> camelContexts = this.getCamelContexts();\n            for (CamelContext camelContext : camelContexts) {\n                for (RouteDefinition routeDefinition : camelContext.getRouteDefinitions()) {\n                    List<RouteDefinition> routes = new ArrayList<RouteDefinition>();\n                    // sort routes\n                    Collections.sort(routes, new Comparator<RouteDefinition>() {\n                        @Override\n                        public int compare(RouteDefinition o1, RouteDefinition o2) {\n                            // already sorted by camel context first, so just sort the ids\n                            return o1.getId().compareTo(o2.getId());\n                        }\n                    });\n                    answer.addAll(routes);\n                }\n            }\n        }\n        // already sorted\n        return answer;\n    }","commit_id":"f5302d3ef9d2b69480f0a1877b4acb932e662c10","url":"https://github.com/apache/camel"},{"original_method":"protected Object doExecute() throws Exception {\n        final List<CamelContext> camelContexts = camelController.getCamelContexts();\n\n        final Map<String, Integer> columnWidths = computeColumnWidths(camelContexts);\n        final String headerFormat = buildFormatString(columnWidths, true);\n        final String rowFormat = buildFormatString(columnWidths, false);\n        final PrintStream out = System.out;\n\n        if (camelContexts.size() > 0) {\n            out.println(String.format(headerFormat, NAME_COLUMN_LABEL, STATUS_COLUMN_LABEL, UPTIME_COLUMN_LABEL));\n            for (final CamelContext camelContext : camelContexts) {\n                out.println(String.format(rowFormat, camelContext.getName(), camelContext.getStatus(), camelContext.getUptime()));\n            }\n        }\n\n        return null;\n    }","id":29550,"modified_method":"protected Object doExecute() throws Exception {\n        final List<CamelContext> camelContexts = camelController.getCamelContexts();\n\n        final Map<String, Integer> columnWidths = computeColumnWidths(camelContexts);\n        final String headerFormat = buildFormatString(columnWidths, true);\n        final String rowFormat = buildFormatString(columnWidths, false);\n        final PrintStream out = System.out;\n\n        if (camelContexts.size() > 0) {\n            out.println(String.format(headerFormat, CONTEXT_COLUMN_LABEL, STATUS_COLUMN_LABEL, UPTIME_COLUMN_LABEL));\n            for (final CamelContext camelContext : camelContexts) {\n                out.println(String.format(rowFormat, camelContext.getName(), camelContext.getStatus(), camelContext.getUptime()));\n            }\n        }\n\n        return null;\n    }","commit_id":"f5302d3ef9d2b69480f0a1877b4acb932e662c10","url":"https://github.com/apache/camel"},{"original_method":"private static String buildFormatString(final Map<String, Integer> columnWidths, final boolean isHeader) {\n        final String fieldPreamble;\n        final String fieldPostamble;\n        final int columnWidthIncrement;\n\n        if (isHeader) {\n            fieldPreamble = DEFAULT_HEADER_PREAMBLE;\n            fieldPostamble = DEFAULT_HEADER_POSTAMBLE;\n        } else {\n            fieldPreamble = DEFAULT_FIELD_PREAMBLE;\n            fieldPostamble = DEFAULT_FIELD_POSTAMBLE;\n        }\n        columnWidthIncrement = DEFAULT_COLUMN_WIDTH_INCREMENT;\n\n        final int nameLen = java.lang.Math.min(columnWidths.get(NAME_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        final int statusLen = java.lang.Math.min(columnWidths.get(STATUS_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        final int uptimeLen = java.lang.Math.min(columnWidths.get(UPTIME_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n\n        final StringBuilder retval = new StringBuilder(DEFAULT_FORMAT_BUFFER_LENGTH);\n        retval.append(fieldPreamble).append(\"%-\").append(nameLen).append('.').append(nameLen).append('s').append(fieldPostamble).append(' ');\n        retval.append(fieldPreamble).append(\"%-\").append(statusLen).append('.').append(statusLen).append('s').append(fieldPostamble).append(' ');\n        retval.append(fieldPreamble).append(\"%-\").append(uptimeLen).append('.').append(uptimeLen).append('s').append(fieldPostamble).append(' ');\n\n        return retval.toString();\n    }","id":29551,"modified_method":"private static String buildFormatString(final Map<String, Integer> columnWidths, final boolean isHeader) {\n        final String fieldPreamble;\n        final String fieldPostamble;\n        final int columnWidthIncrement;\n\n        if (isHeader) {\n            fieldPreamble = DEFAULT_HEADER_PREAMBLE;\n            fieldPostamble = DEFAULT_HEADER_POSTAMBLE;\n        } else {\n            fieldPreamble = DEFAULT_FIELD_PREAMBLE;\n            fieldPostamble = DEFAULT_FIELD_POSTAMBLE;\n        }\n        columnWidthIncrement = DEFAULT_COLUMN_WIDTH_INCREMENT;\n\n        final int nameLen = java.lang.Math.min(columnWidths.get(CONTEXT_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        final int statusLen = java.lang.Math.min(columnWidths.get(STATUS_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        final int uptimeLen = java.lang.Math.min(columnWidths.get(UPTIME_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n\n        final StringBuilder retval = new StringBuilder(DEFAULT_FORMAT_BUFFER_LENGTH);\n        retval.append(fieldPreamble).append(\"%-\").append(nameLen).append('.').append(nameLen).append('s').append(fieldPostamble).append(' ');\n        retval.append(fieldPreamble).append(\"%-\").append(statusLen).append('.').append(statusLen).append('s').append(fieldPostamble).append(' ');\n        retval.append(fieldPreamble).append(\"%-\").append(uptimeLen).append('.').append(uptimeLen).append('s').append(fieldPostamble).append(' ');\n\n        return retval.toString();\n    }","commit_id":"f5302d3ef9d2b69480f0a1877b4acb932e662c10","url":"https://github.com/apache/camel"},{"original_method":"private static Map<String, Integer> computeColumnWidths(final Iterable<CamelContext> camelContexts) throws Exception {\n        if (camelContexts == null) {\n            throw new IllegalArgumentException(\"Unable to determine column widths from null Iterable<CamelContext>\");\n        } else {\n            int maxNameLen = 0;\n            int maxStatusLen = 0;\n            int maxUptimeLen = 0;\n\n            for (final CamelContext camelContext : camelContexts) {\n                final String name = camelContext.getName();\n                maxNameLen = java.lang.Math.max(maxNameLen, name == null ? 0 : name.length());\n\n                final String status = camelContext.getStatus().toString();\n                maxStatusLen = java.lang.Math.max(maxStatusLen, status == null ? 0 : status.length());\n\n                final String uptime = camelContext.getUptime();\n                maxUptimeLen = java.lang.Math.max(maxUptimeLen, uptime == null ? 0 : uptime.length());\n            }\n\n            final Map<String, Integer> retval = new Hashtable<String, Integer>(3);\n            retval.put(NAME_COLUMN_LABEL, maxNameLen);\n            retval.put(STATUS_COLUMN_LABEL, maxStatusLen);\n            retval.put(UPTIME_COLUMN_LABEL, maxUptimeLen);\n\n            return retval;\n        }\n    }","id":29552,"modified_method":"private static Map<String, Integer> computeColumnWidths(final Iterable<CamelContext> camelContexts) throws Exception {\n        if (camelContexts == null) {\n            throw new IllegalArgumentException(\"Unable to determine column widths from null Iterable<CamelContext>\");\n        } else {\n            int maxNameLen = 0;\n            int maxStatusLen = 0;\n            int maxUptimeLen = 0;\n\n            for (final CamelContext camelContext : camelContexts) {\n                final String name = camelContext.getName();\n                maxNameLen = java.lang.Math.max(maxNameLen, name == null ? 0 : name.length());\n\n                final String status = camelContext.getStatus().toString();\n                maxStatusLen = java.lang.Math.max(maxStatusLen, status == null ? 0 : status.length());\n\n                final String uptime = camelContext.getUptime();\n                maxUptimeLen = java.lang.Math.max(maxUptimeLen, uptime == null ? 0 : uptime.length());\n            }\n\n            final Map<String, Integer> retval = new Hashtable<String, Integer>(3);\n            retval.put(CONTEXT_COLUMN_LABEL, maxNameLen);\n            retval.put(STATUS_COLUMN_LABEL, maxStatusLen);\n            retval.put(UPTIME_COLUMN_LABEL, maxUptimeLen);\n\n            return retval;\n        }\n    }","commit_id":"f5302d3ef9d2b69480f0a1877b4acb932e662c10","url":"https://github.com/apache/camel"},{"original_method":"protected String getState(Endpoint endpoint) {\n        // must use String type to be sure remote JMX can read the attribute without requiring Camel classes.\n        if (endpoint instanceof StatefulService) {\n            ServiceStatus status = ((StatefulService) endpoint).getStatus();\n            return status.name();\n        }\n\n        // assume started if not a ServiceSupport instance\n        return ServiceStatus.Started.name();\n    }","id":29553,"modified_method":"private static String getEndpointState(Endpoint endpoint) {\n        // must use String type to be sure remote JMX can read the attribute without requiring Camel classes.\n        if (endpoint instanceof StatefulService) {\n            ServiceStatus status = ((StatefulService) endpoint).getStatus();\n            return status.name();\n        }\n\n        // assume started if not a ServiceSupport instance\n        return ServiceStatus.Started.name();\n    }","commit_id":"f5302d3ef9d2b69480f0a1877b4acb932e662c10","url":"https://github.com/apache/camel"},{"original_method":"protected Object doExecute() throws Exception {\n        System.out.println(String.format(HEADER_FORMAT, \"camel-id\", \"uri\", \"Status\"));\n\n        List<CamelContext> camelContexts = camelController.getCamelContexts();\n        for (CamelContext camelContext : camelContexts) {\n            List<Endpoint> endpoints = (List<Endpoint>) camelContext.getEndpoints();\n            for (Endpoint endpoint : endpoints) {\n                System.out.println(String.format(OUTPUT_FORMAT, camelContext.getName(), endpoint.getEndpointUri(), getState(endpoint)));\n            }\n        }\n\n        return null;\n    }","id":29554,"modified_method":"protected Object doExecute() throws Exception {\n        List<Endpoint> endpoints = camelController.getEndpoints(name);\n\n        final Map<String, Integer> columnWidths = computeColumnWidths(endpoints);\n        final String headerFormat = buildFormatString(columnWidths, true);\n        final String rowFormat = buildFormatString(columnWidths, false);\n        final PrintStream out = System.out;\n\n        if (endpoints.size() > 0) {\n            out.println(String.format(headerFormat, CONTEXT_COLUMN_LABEL, URI_COLUMN_LABEL, STATUS_COLUMN_LABEL));\n            for (final Endpoint endpoint : endpoints) {\n                String contextId = endpoint.getCamelContext().getName();\n                String uri = endpoint.getEndpointUri();\n                if (decode == null || decode) {\n                    // decode uri so its more human readable\n                    uri = URLDecoder.decode(uri, \"UTF-8\");\n                }\n                // sanitize and mask uri so we dont see passwords\n                uri = URISupport.sanitizeUri(uri);\n                String state = getEndpointState(endpoint);\n                out.println(String.format(rowFormat, contextId, uri, state));\n            }\n        }\n\n        return null;\n    }","commit_id":"f5302d3ef9d2b69480f0a1877b4acb932e662c10","url":"https://github.com/apache/camel"},{"original_method":"protected Object doExecute() throws Exception {\n        System.out.println(String.format(HEADER_FORMAT, ROUTE_ID, CONTEXT_ID, STATUS));\n\n        List<CamelContext> camelContexts = new LinkedList<CamelContext>();\n        if (name != null && camelController.getCamelContext(name) != null) {\n            camelContexts.add(camelController.getCamelContext(name));\n        } else {\n            camelContexts = camelController.getCamelContexts();\n        }\n\n        for (CamelContext camelContext : camelContexts) {\n            List<RouteDefinition> routeDefinitions = camelController.getRouteDefinitions(camelContext.getName());\n            if (routeDefinitions != null && !routeDefinitions.isEmpty()) {\n                for (RouteDefinition routeDefinition : routeDefinitions) {\n                    String contextName = camelContext.getName();\n                    ServiceStatus status = camelContext.getRouteStatus(routeDefinition.getId());\n                    System.out.println(String.format(OUTPUT_FORMAT, routeDefinition.getId(), contextName, status != null ? status.name() : UNKNOWN));\n                }\n            }\n        }\n\n        return null;\n    }","id":29555,"modified_method":"protected Object doExecute() throws Exception {\n        List<Route> routes = camelController.getRoutes(name);\n\n        final Map<String, Integer> columnWidths = computeColumnWidths(routes);\n        final String headerFormat = buildFormatString(columnWidths, true);\n        final String rowFormat = buildFormatString(columnWidths, false);\n        final PrintStream out = System.out;\n\n        if (routes.size() > 0) {\n            out.println(String.format(headerFormat, CONTEXT_COLUMN_LABEL, ROUTE_COLUMN_LABEL, STATUS_COLUMN_LABEL));\n            for (Route route : routes) {\n                String contextId = route.getRouteContext().getCamelContext().getName();\n                String routeId = route.getId();\n                ServiceStatus status = route.getRouteContext().getCamelContext().getRouteStatus(routeId);\n                out.println(String.format(rowFormat, contextId, routeId, status));\n            }\n        }\n\n        return null;\n    }","commit_id":"f5302d3ef9d2b69480f0a1877b4acb932e662c10","url":"https://github.com/apache/camel"},{"original_method":"/**\n   * @param y <code>y<\/code> coordinate in layered pane coordinate system.\n   * @param hideByAnyKey\n   */\n  @Nullable\n  public static LightweightHint showEditorFragmentHintAt(Editor editor,\n                                                         TextRange range,\n                                                         int y,\n                                                         boolean showUpward,\n                                                         boolean showFolding,\n                                                         boolean hideByAnyKey) {\n    if (ApplicationManager.getApplication().isUnitTestMode()) return null;\n    Document document = editor.getDocument();\n\n    int startOffset = range.getStartOffset();\n    int startLine = document.getLineNumber(startOffset);\n    CharSequence text = document.getCharsSequence();\n    // There is a possible case that we have a situation like below:\n    //    line 1\n    //    line 2 <fragment start>\n    //    line 3<fragment end>\n    // We don't want to include 'line 2' to the target fragment then.\n    boolean incrementLine = false;\n    for (int offset = startOffset, max = Math.min(range.getEndOffset(), text.length()); offset < max; offset++) {\n      char c = text.charAt(offset);\n      incrementLine = StringUtil.isWhiteSpace(c);\n      if (!incrementLine || c == '\\n') {\n        break;\n      } \n    }\n    if (incrementLine) {\n      startLine++;\n    } \n    \n    int endLine = Math.min(document.getLineNumber(range.getEndOffset()) + 1, document.getLineCount() - 1);\n\n    //if (editor.logicalPositionToXY(new LogicalPosition(startLine, 0)).y >= editor.logicalPositionToXY(new LogicalPosition(endLine, 0)).y) return null;\n    if (startLine >= endLine) return null;\n\n    EditorFragmentComponent fragmentComponent = createEditorFragmentComponent(editor, startLine, endLine, showFolding, true);\n\n\n    if (showUpward) {\n      y -= fragmentComponent.getPreferredSize().height + 10;\n      y  = Math.max(0,y);\n    }\n\n    final JComponent c = editor.getComponent();\n    int x = SwingUtilities.convertPoint(c, new Point(-3,0), UIUtil.getRootPane(c)).x; //IDEA-68016\n\n    Point p = new Point(x, y);\n    LightweightHint hint = new MyComponentHint(fragmentComponent);\n    HintManagerImpl.getInstanceImpl().showEditorHint(hint, editor, p, (hideByAnyKey ? HintManager.HIDE_BY_ANY_KEY : 0) |\n                                                                      HintManager.HIDE_BY_TEXT_CHANGE | HintManager.HIDE_BY_MOUSEOVER,\n                                                     0, false, new HintHint(editor, p));\n    return hint;\n  }","id":29556,"modified_method":"/**\n   * @param y <code>y<\/code> coordinate in layered pane coordinate system.\n   * @param hideByAnyKey\n   */\n  @Nullable\n  public static LightweightHint showEditorFragmentHintAt(Editor editor,\n                                                         TextRange range,\n                                                         int y,\n                                                         boolean showUpward,\n                                                         boolean showFolding,\n                                                         boolean hideByAnyKey) {\n    if (ApplicationManager.getApplication().isUnitTestMode()) return null;\n    Document document = editor.getDocument();\n\n    int startOffset = range.getStartOffset();\n    int startLine = document.getLineNumber(startOffset);\n    CharSequence text = document.getCharsSequence();\n    // There is a possible case that we have a situation like below:\n    //    line 1\n    //    line 2 <fragment start>\n    //    line 3<fragment end>\n    // We don't want to include 'line 2' to the target fragment then.\n    boolean incrementLine = false;\n    for (int offset = startOffset, max = Math.min(range.getEndOffset(), text.length()); offset < max; offset++) {\n      char c = text.charAt(offset);\n      incrementLine = StringUtil.isWhiteSpace(c);\n      if (!incrementLine || c == '\\n') {\n        break;\n      } \n    }\n    if (incrementLine) {\n      startLine++;\n    } \n    \n    int endLine = Math.min(document.getLineNumber(range.getEndOffset()) + 1, document.getLineCount() - 1);\n\n    if (startLine >= endLine) return null;\n\n    EditorFragmentComponent fragmentComponent = createEditorFragmentComponent(editor, startLine, endLine, showFolding, true);\n\n\n    if (showUpward) {\n      y -= fragmentComponent.getPreferredSize().height;\n      y  = Math.max(0,y);\n    }\n\n    final JComponent c = editor.getComponent();\n    int x = SwingUtilities.convertPoint(c, new Point(-1, 0), UIUtil.getRootPane(c)).x; //IDEA-68016\n\n    Point p = new Point(x, y);\n    LightweightHint hint = new MyComponentHint(fragmentComponent);\n    HintManagerImpl.getInstanceImpl().showEditorHint(hint, editor, p, (hideByAnyKey ? HintManager.HIDE_BY_ANY_KEY : 0) |\n                                                                      HintManager.HIDE_BY_TEXT_CHANGE | HintManager.HIDE_BY_MOUSEOVER,\n                                                     0, false, new HintHint(editor, p));\n    return hint;\n  }","commit_id":"0f71b5358d37616bf42ecf85319d56444789edc6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doInit(EditorEx editor, int startLine, int endLine, boolean showFolding, boolean showGutter) {\n    Document doc = editor.getDocument();\n    final int endOffset = endLine < doc.getLineCount() ? doc.getLineEndOffset(endLine) : doc.getTextLength();\n    final int textImageWidth = Math.min(editor.getMaxWidthInRange(doc.getLineStartOffset(startLine), endOffset), ScreenUtil\n      .getScreenRectangle(1, 1).width);\n    LOG.assertTrue(textImageWidth > 0, \"TextWidth: \"+textImageWidth+\"; startLine:\" + startLine + \"; endLine:\" + endLine + \";\");\n\n    FoldingModelEx foldingModel = editor.getFoldingModel();\n    boolean isFoldingEnabled = foldingModel.isFoldingEnabled();\n    if (!showFolding) {\n      foldingModel.setFoldingEnabled(false);\n    }\n\n    Point p1 = editor.logicalPositionToXY(new LogicalPosition(startLine, 0));\n    Point p2 = editor.logicalPositionToXY(new LogicalPosition(Math.max(endLine, startLine + 1), 0));\n    int y1 = p1.y;\n    int y2 = p2.y;\n    final int textImageHeight = y2 - y1 == 0 ? editor.getLineHeight() : y2 - y1;\n    LOG.assertTrue(textImageHeight > 0, \"Height: \" + textImageHeight + \"; startLine:\" + startLine + \"; endLine:\" + endLine + \"; p1:\" + p1 + \"; p2:\" + p2);\n\n    int savedScrollOffset = editor.getScrollingModel().getHorizontalScrollOffset();\n    if (savedScrollOffset > 0) {\n      editor.getScrollingModel().scrollHorizontally(0);\n    }\n\n    final BufferedImage textImage = UIUtil.createImage(textImageWidth, textImageHeight, BufferedImage.TYPE_INT_RGB);\n    Graphics textGraphics = textImage.getGraphics();\n    UISettings.setupAntialiasing(textGraphics);\n\n    final JComponent rowHeader;\n    final BufferedImage markersImage;\n    final int markersImageWidth;\n\n    if (showGutter) {\n      rowHeader = editor.getGutterComponentEx();\n      markersImageWidth = Math.max(1, rowHeader.getWidth());\n\n      markersImage = UIUtil.createImage(markersImageWidth, textImageHeight, BufferedImage.TYPE_INT_RGB);\n      Graphics markerGraphics = markersImage.getGraphics();\n      UISettings.setupAntialiasing(markerGraphics);\n\n      markerGraphics.translate(0, -y1);\n      markerGraphics.setClip(0, y1, rowHeader.getWidth(), textImageHeight);\n      markerGraphics.setColor(getBackgroundColor(editor));\n      markerGraphics.fillRect(0, y1, rowHeader.getWidth(), textImageHeight);\n      rowHeader.paint(markerGraphics);\n    }\n    else {\n      markersImageWidth = 0;\n      rowHeader = null;\n      markersImage = null;\n    }\n\n    textGraphics.translate(0, -y1);\n    textGraphics.setClip(0, y1, textImageWidth, textImageHeight);\n    final boolean wasVisible = editor.setCaretVisible(false);\n    editor.getContentComponent().paint(textGraphics);\n    if (wasVisible) {\n      editor.setCaretVisible(true);\n    }\n\n    if (!showFolding) {\n      foldingModel.setFoldingEnabled(isFoldingEnabled);\n    }\n\n    if (savedScrollOffset > 0) {\n      editor.getScrollingModel().scrollHorizontally(savedScrollOffset);\n    }\n\n    JComponent component = new JComponent() {\n      @Override\n      public Dimension getPreferredSize() {\n        return new Dimension(textImageWidth + markersImageWidth, textImageHeight);\n      }\n\n      @Override\n      protected void paintComponent(Graphics graphics) {\n        if (markersImage != null) {\n          UIUtil.drawImage(graphics, markersImage, 0, 0, null);\n          UIUtil.drawImage(graphics, textImage, rowHeader.getWidth(), 0, null);\n        }\n        else {\n          UIUtil.drawImage(graphics, textImage, 0, 0, null);\n        }\n      }\n    };\n\n    setLayout(new BorderLayout());\n    add(component);\n\n    final Color borderColor = editor.getColorsScheme().getColor(EditorColors.SELECTED_TEARLINE_COLOR);\n\n    Border outsideBorder = BorderFactory.createLineBorder(borderColor, 1);\n    Border insideBorder = BorderFactory.createEmptyBorder(2, 2, 2, 2);\n    setBorder(BorderFactory.createCompoundBorder(outsideBorder, insideBorder));\n  }","id":29557,"modified_method":"private void doInit(EditorEx editor, int startLine, int endLine, boolean showFolding, boolean showGutter) {\n    Document doc = editor.getDocument();\n    final int endOffset = endLine < doc.getLineCount() ? doc.getLineEndOffset(endLine) : doc.getTextLength();\n    final int textImageWidth = Math.min(editor.getMaxWidthInRange(doc.getLineStartOffset(startLine), endOffset), ScreenUtil\n      .getScreenRectangle(1, 1).width);\n    LOG.assertTrue(textImageWidth > 0, \"TextWidth: \"+textImageWidth+\"; startLine:\" + startLine + \"; endLine:\" + endLine + \";\");\n\n    FoldingModelEx foldingModel = editor.getFoldingModel();\n    boolean isFoldingEnabled = foldingModel.isFoldingEnabled();\n    if (!showFolding) {\n      foldingModel.setFoldingEnabled(false);\n    }\n\n    Point p1 = editor.logicalPositionToXY(new LogicalPosition(startLine, 0));\n    Point p2 = editor.logicalPositionToXY(new LogicalPosition(Math.max(endLine, startLine + 1), 0));\n    int y1 = p1.y;\n    int y2 = p2.y;\n    final int textImageHeight = y2 - y1 == 0 ? editor.getLineHeight() : y2 - y1;\n    LOG.assertTrue(textImageHeight > 0, \"Height: \" + textImageHeight + \"; startLine:\" + startLine + \"; endLine:\" + endLine + \"; p1:\" + p1 + \"; p2:\" + p2);\n\n    int savedScrollOffset = editor.getScrollingModel().getHorizontalScrollOffset();\n    if (savedScrollOffset > 0) {\n      editor.getScrollingModel().scrollHorizontally(0);\n    }\n\n    final BufferedImage textImage = UIUtil.createImage(textImageWidth, textImageHeight, BufferedImage.TYPE_INT_RGB);\n    Graphics textGraphics = textImage.getGraphics();\n    UISettings.setupAntialiasing(textGraphics);\n\n    final JComponent rowHeader;\n    final BufferedImage markersImage;\n    final int markersImageWidth;\n\n    if (showGutter) {\n      rowHeader = editor.getGutterComponentEx();\n      markersImageWidth = Math.max(1, rowHeader.getWidth());\n\n      markersImage = UIUtil.createImage(markersImageWidth, textImageHeight, BufferedImage.TYPE_INT_RGB);\n      Graphics markerGraphics = markersImage.getGraphics();\n      UISettings.setupAntialiasing(markerGraphics);\n\n      markerGraphics.translate(0, -y1);\n      markerGraphics.setClip(0, y1, rowHeader.getWidth(), textImageHeight);\n      markerGraphics.setColor(getBackgroundColor(editor));\n      markerGraphics.fillRect(0, y1, rowHeader.getWidth(), textImageHeight);\n      rowHeader.paint(markerGraphics);\n    }\n    else {\n      markersImageWidth = 0;\n      rowHeader = null;\n      markersImage = null;\n    }\n\n    textGraphics.translate(0, -y1);\n    textGraphics.setClip(0, y1, textImageWidth, textImageHeight);\n    final boolean wasVisible = editor.setCaretVisible(false);\n    editor.getContentComponent().paint(textGraphics);\n    if (wasVisible) {\n      editor.setCaretVisible(true);\n    }\n\n    if (!showFolding) {\n      foldingModel.setFoldingEnabled(isFoldingEnabled);\n    }\n\n    if (savedScrollOffset > 0) {\n      editor.getScrollingModel().scrollHorizontally(savedScrollOffset);\n    }\n\n    JComponent component = new JComponent() {\n      @Override\n      public Dimension getPreferredSize() {\n        return new Dimension(textImageWidth + markersImageWidth, textImageHeight);\n      }\n\n      @Override\n      protected void paintComponent(Graphics graphics) {\n        if (markersImage != null) {\n          UIUtil.drawImage(graphics, markersImage, 0, 0, null);\n          UIUtil.drawImage(graphics, textImage, rowHeader.getWidth(), 0, null);\n        }\n        else {\n          UIUtil.drawImage(graphics, textImage, 0, 0, null);\n        }\n      }\n    };\n\n    setLayout(new BorderLayout());\n    add(component);\n\n    final Color borderColor = editor.getColorsScheme().getColor(EditorColors.SELECTED_TEARLINE_COLOR);\n\n    Border outsideBorder = BorderFactory.createLineBorder(borderColor, 1);\n    Border insideBorder = BorderFactory.createEmptyBorder(2, 0, 2, 2);\n    setBorder(BorderFactory.createCompoundBorder(outsideBorder, insideBorder));\n  }","commit_id":"0f71b5358d37616bf42ecf85319d56444789edc6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static EditorFragmentComponent createEditorFragmentComponent(Editor editor,\n                                                                      int startLine,\n                                                                      int endLine,\n                                                                      boolean showFolding, boolean showGutter) {\n    final EditorEx editorEx = (EditorEx)editor;\n    final Color old = editorEx.getBackgroundColor();\n    Color backColor = getBackgroundColor(editor);\n    editorEx.setBackgroundColor(backColor);\n    EditorFragmentComponent fragmentComponent = new EditorFragmentComponent(editorEx, startLine, endLine,\n                                                                            showFolding, showGutter);\n    fragmentComponent.setBackground(backColor);\n\n    editorEx.setBackgroundColor(old);\n    return fragmentComponent;\n  }","id":29558,"modified_method":"public static EditorFragmentComponent createEditorFragmentComponent(Editor editor,\n                                                                      int startLine,\n                                                                      int endLine,\n                                                                      boolean showFolding, boolean showGutter) {\n    EditorFragmentComponent fragmentComponent = new EditorFragmentComponent((EditorEx)editor, startLine, endLine, showFolding, showGutter);\n    fragmentComponent.setBackground(getBackgroundColor(editor));\n    return fragmentComponent;\n  }","commit_id":"0f71b5358d37616bf42ecf85319d56444789edc6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Color getBackgroundColor(Editor editor){\n    EditorColorsScheme colorsScheme = editor.getColorsScheme();\n    Color color = colorsScheme.getColor(EditorColors.CARET_ROW_COLOR);\n    if (color == null){\n      color = colorsScheme.getDefaultBackground();\n    }\n    return color;\n  }","id":29559,"modified_method":"public static Color getBackgroundColor(Editor editor){\n    return editor.getColorsScheme().getDefaultBackground();\n  }","commit_id":"0f71b5358d37616bf42ecf85319d56444789edc6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ImplementationViewComponent(PsiElement[] elements, final int index) {\n    super(new BorderLayout());\n\n    final Project project = elements.length > 0 ? elements[0].getProject() : null;\n    EditorFactory factory = EditorFactory.getInstance();\n    Document doc = factory.createDocument(\"\");\n    doc.setReadOnly(true);\n    myEditor = factory.createEditor(doc, project);\n    ((EditorEx)myEditor).setBackgroundColor(EditorFragmentComponent.getBackgroundColor(myEditor));\n\n    final EditorSettings settings = myEditor.getSettings();\n    settings.setAdditionalLinesCount(1);\n    settings.setAdditionalColumnsCount(1);\n    settings.setLineMarkerAreaShown(false);\n    settings.setIndentGuidesShown(false);\n    settings.setLineNumbersShown(false);\n    settings.setFoldingOutlineShown(false);\n\n    myBinarySwitch = new CardLayout();\n    myViewingPanel = new JPanel(myBinarySwitch);\n    myEditor.setBorder(null);\n    ((EditorEx)myEditor).getScrollPane().setViewportBorder(JBScrollPane.createIndentBorder());\n    myViewingPanel.add(myEditor.getComponent(), TEXT_PAGE_KEY);\n\n    myBinaryPanel = new JPanel(new BorderLayout());\n    myViewingPanel.add(myBinaryPanel, BINARY_PAGE_KEY);\n\n    add(myViewingPanel, BorderLayout.CENTER);\n\n    myToolbar = createToolbar();\n    myLocationLabel = new JLabel();\n    myCountLabel = new JLabel();\n\n    final JPanel header = new JPanel(new BorderLayout(2, 0));\n    header.setBorder(BorderFactory.createCompoundBorder(IdeBorderFactory.createBorder(SideBorder.BOTTOM),\n                                                        IdeBorderFactory.createEmptyBorder(0, 0, 0, 5)));\n    final JPanel toolbarPanel = new JPanel(new GridBagLayout());\n    final GridBagConstraints gc = new GridBagConstraints(GridBagConstraints.RELATIVE, 0, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,2,0,0), 0,0);\n    toolbarPanel.add(myToolbar.getComponent(), gc);\n\n    setPreferredSize(JBUI.size(600, 400));\n\n    update(elements, new PairFunction<PsiElement[], List<FileDescriptor>, Boolean>() {\n      @Override\n      public Boolean fun(final PsiElement[] psiElements, final List<FileDescriptor> fileDescriptors) {\n        if (psiElements.length == 0) return false;\n        myElements = psiElements;\n\n        myIndex = index < myElements.length ? index : 0;\n        PsiFile psiFile = getContainingFile(myElements[myIndex]);\n\n        VirtualFile virtualFile = psiFile.getVirtualFile();\n        EditorHighlighter highlighter;\n        if (virtualFile != null)\n          highlighter = HighlighterFactory.createHighlighter(project, virtualFile);\n        else {\n          String fileName = psiFile.getName();  // some artificial psi file, lets do best we can\n          highlighter = HighlighterFactory.createHighlighter(project, fileName);\n        }\n\n        ((EditorEx)myEditor).setHighlighter(highlighter);\n\n        gc.fill = GridBagConstraints.HORIZONTAL;\n        gc.weightx = 1;\n        myLabel = new JLabel();\n        myFileChooser = new ComboBox(fileDescriptors.toArray(new FileDescriptor[fileDescriptors.size()]), 250);\n        myFileChooser.addActionListener(new ActionListener() {\n          @Override\n          public void actionPerformed(ActionEvent e) {\n            int index = myFileChooser.getSelectedIndex();\n            if (myIndex != index) {\n              myIndex = index;\n              updateControls();\n            }\n          }\n        });\n        toolbarPanel.add(myFileChooser, gc);\n\n        if (myElements.length > 1) {\n          updateRenderer(project);\n          myLabel.setVisible(false);\n        }\n        else {\n          myFileChooser.setVisible(false);\n          myCountLabel.setVisible(false);\n\n          VirtualFile file = psiFile.getVirtualFile();\n          if (file != null) {\n            myLabel.setIcon(getIconForFile(psiFile));\n            myLabel.setForeground(FileStatusManager.getInstance(project).getStatus(file).getColor());\n            myLabel.setText(file.getPresentableName());\n            myLabel.setBorder(new CompoundBorder(IdeBorderFactory.createRoundedBorder(), IdeBorderFactory.createEmptyBorder(0, 0, 0, 5)));\n          }\n          toolbarPanel.add(myLabel, gc);\n        }\n\n        gc.fill = GridBagConstraints.NONE;\n        gc.weightx = 0;\n        toolbarPanel.add(myCountLabel, gc);\n\n        header.add(toolbarPanel, BorderLayout.CENTER);\n        header.add(myLocationLabel, BorderLayout.EAST);\n\n        add(header, BorderLayout.NORTH);\n\n        updateControls();\n        return true;\n      }\n    });\n  }","id":29560,"modified_method":"public ImplementationViewComponent(PsiElement[] elements, final int index) {\n    super(new BorderLayout());\n\n    final Project project = elements.length > 0 ? elements[0].getProject() : null;\n    EditorFactory factory = EditorFactory.getInstance();\n    Document doc = factory.createDocument(\"\");\n    doc.setReadOnly(true);\n    myEditor = factory.createEditor(doc, project);\n    \n    setBackgroundColor(myEditor);\n\n    final EditorSettings settings = myEditor.getSettings();\n    settings.setAdditionalLinesCount(1);\n    settings.setAdditionalColumnsCount(1);\n    settings.setLineMarkerAreaShown(false);\n    settings.setIndentGuidesShown(false);\n    settings.setLineNumbersShown(false);\n    settings.setFoldingOutlineShown(false);\n\n    myBinarySwitch = new CardLayout();\n    myViewingPanel = new JPanel(myBinarySwitch);\n    myEditor.setBorder(null);\n    ((EditorEx)myEditor).getScrollPane().setViewportBorder(JBScrollPane.createIndentBorder());\n    myViewingPanel.add(myEditor.getComponent(), TEXT_PAGE_KEY);\n\n    myBinaryPanel = new JPanel(new BorderLayout());\n    myViewingPanel.add(myBinaryPanel, BINARY_PAGE_KEY);\n\n    add(myViewingPanel, BorderLayout.CENTER);\n\n    myToolbar = createToolbar();\n    myLocationLabel = new JLabel();\n    myCountLabel = new JLabel();\n\n    final JPanel header = new JPanel(new BorderLayout(2, 0));\n    header.setBorder(BorderFactory.createCompoundBorder(IdeBorderFactory.createBorder(SideBorder.BOTTOM),\n                                                        IdeBorderFactory.createEmptyBorder(0, 0, 0, 5)));\n    final JPanel toolbarPanel = new JPanel(new GridBagLayout());\n    final GridBagConstraints gc = new GridBagConstraints(GridBagConstraints.RELATIVE, 0, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,2,0,0), 0,0);\n    toolbarPanel.add(myToolbar.getComponent(), gc);\n\n    setPreferredSize(JBUI.size(600, 400));\n\n    update(elements, new PairFunction<PsiElement[], List<FileDescriptor>, Boolean>() {\n      @Override\n      public Boolean fun(final PsiElement[] psiElements, final List<FileDescriptor> fileDescriptors) {\n        if (psiElements.length == 0) return false;\n        myElements = psiElements;\n\n        myIndex = index < myElements.length ? index : 0;\n        PsiFile psiFile = getContainingFile(myElements[myIndex]);\n\n        VirtualFile virtualFile = psiFile.getVirtualFile();\n        EditorHighlighter highlighter;\n        if (virtualFile != null)\n          highlighter = HighlighterFactory.createHighlighter(project, virtualFile);\n        else {\n          String fileName = psiFile.getName();  // some artificial psi file, lets do best we can\n          highlighter = HighlighterFactory.createHighlighter(project, fileName);\n        }\n\n        ((EditorEx)myEditor).setHighlighter(highlighter);\n\n        gc.fill = GridBagConstraints.HORIZONTAL;\n        gc.weightx = 1;\n        myLabel = new JLabel();\n        myFileChooser = new ComboBox(fileDescriptors.toArray(new FileDescriptor[fileDescriptors.size()]), 250);\n        myFileChooser.addActionListener(new ActionListener() {\n          @Override\n          public void actionPerformed(ActionEvent e) {\n            int index = myFileChooser.getSelectedIndex();\n            if (myIndex != index) {\n              myIndex = index;\n              updateControls();\n            }\n          }\n        });\n        toolbarPanel.add(myFileChooser, gc);\n\n        if (myElements.length > 1) {\n          updateRenderer(project);\n          myLabel.setVisible(false);\n        }\n        else {\n          myFileChooser.setVisible(false);\n          myCountLabel.setVisible(false);\n\n          VirtualFile file = psiFile.getVirtualFile();\n          if (file != null) {\n            myLabel.setIcon(getIconForFile(psiFile));\n            myLabel.setForeground(FileStatusManager.getInstance(project).getStatus(file).getColor());\n            myLabel.setText(file.getPresentableName());\n            myLabel.setBorder(new CompoundBorder(IdeBorderFactory.createRoundedBorder(), IdeBorderFactory.createEmptyBorder(0, 0, 0, 5)));\n          }\n          toolbarPanel.add(myLabel, gc);\n        }\n\n        gc.fill = GridBagConstraints.NONE;\n        gc.weightx = 0;\n        toolbarPanel.add(myCountLabel, gc);\n\n        header.add(toolbarPanel, BorderLayout.CENTER);\n        header.add(myLocationLabel, BorderLayout.EAST);\n\n        add(header, BorderLayout.NORTH);\n\n        updateControls();\n        return true;\n      }\n    });\n  }","commit_id":"0f71b5358d37616bf42ecf85319d56444789edc6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void showInEditor(DetailView panel, VirtualFile virtualFile, int line) {\n    TextAttributes attributes =\n      EditorColorsManager.getInstance().getGlobalScheme().getAttributes(DebuggerColors.BREAKPOINT_ATTRIBUTES);\n\n    DetailView.PreviewEditorState state = DetailView.PreviewEditorState.create(virtualFile, line, attributes);\n\n    if (state.equals(panel.getEditorState())) {\n      return;\n    }\n\n    panel.navigateInPreviewEditor(state);\n\n    TextAttributes softerAttributes = attributes.clone();\n    softerAttributes.setBackgroundColor(ColorUtil.softer(softerAttributes.getBackgroundColor()));\n\n    final Editor editor = panel.getEditor();\n    final MarkupModel editorModel = editor.getMarkupModel();\n    final MarkupModel documentModel =\n      DocumentMarkupModel.forDocument(editor.getDocument(), editor.getProject(), false);\n\n    for (RangeHighlighter highlighter : documentModel.getAllHighlighters()) {\n      if (highlighter.getUserData(DebuggerColors.BREAKPOINT_HIGHLIGHTER_KEY) == Boolean.TRUE) {\n        final int line1 = editor.offsetToLogicalPosition(highlighter.getStartOffset()).line;\n        if (line1 != line) {\n          editorModel.addLineHighlighter(line1,\n                                         DebuggerColors.BREAKPOINT_HIGHLIGHTER_LAYER + 1, softerAttributes);\n        }\n      }\n    }\n  }","id":29561,"modified_method":"protected static void showInEditor(DetailView panel, VirtualFile virtualFile, int line) {\n    TextAttributes attributes =\n      EditorColorsManager.getInstance().getGlobalScheme().getAttributes(DebuggerColors.BREAKPOINT_ATTRIBUTES);\n\n    DetailView.PreviewEditorState state = DetailView.PreviewEditorState.create(virtualFile, line, attributes);\n\n    if (state.equals(panel.getEditorState())) {\n      return;\n    }\n\n    panel.navigateInPreviewEditor(state);\n\n    TextAttributes softerAttributes = attributes.clone();\n    Color backgroundColor = softerAttributes.getBackgroundColor();\n    if (backgroundColor != null) {\n      softerAttributes.setBackgroundColor(ColorUtil.softer(backgroundColor));\n    }\n\n    final Editor editor = panel.getEditor();\n    final MarkupModel editorModel = editor.getMarkupModel();\n    final MarkupModel documentModel =\n      DocumentMarkupModel.forDocument(editor.getDocument(), editor.getProject(), false);\n\n    for (RangeHighlighter highlighter : documentModel.getAllHighlighters()) {\n      if (highlighter.getUserData(DebuggerColors.BREAKPOINT_HIGHLIGHTER_KEY) == Boolean.TRUE) {\n        final int line1 = editor.offsetToLogicalPosition(highlighter.getStartOffset()).line;\n        if (line1 != line) {\n          editorModel.addLineHighlighter(line1,\n                                         DebuggerColors.BREAKPOINT_HIGHLIGHTER_LAYER + 1, softerAttributes);\n        }\n      }\n    }\n  }","commit_id":"883ebfbf1583d14ec4451e9c032f67a807463ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(final AnActionEvent e) {\n      final Project project = e.getData(PlatformDataKeys.PROJECT);\n      RunConfiguration configuration = chooseTempConfiguration(project);\n      if (project != null && configuration != null) {\n        final RunManager runManager = RunManager.getInstance(project);\n        runManager.makeStable(configuration);\n      }\n    }","id":29562,"modified_method":"public void actionPerformed(final AnActionEvent e) {\n      final Project project = e.getData(PlatformDataKeys.PROJECT);\n      if (project != null) {\n        RunConfiguration configuration = chooseTempConfiguration(project);\n        if (configuration != null) {\n          final RunManager runManager = RunManager.getInstance(project);\n          runManager.makeStable(configuration);\n        }\n      }\n    }","commit_id":"883ebfbf1583d14ec4451e9c032f67a807463ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void getVisibleModes(List<ApplicationMode> values, Set<ApplicationMode> selected, List<ApplicationMode> visible) {\n\t\tif (visible.size() == 3) {\n\t\t\tfor (ApplicationMode mode : selected){\n\t\t\t\tif (visible.contains(mode)){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvisible.clear();\n\t\tvisible.add(ApplicationMode.DEFAULT);\n\t\tfor (ApplicationMode mode : selected){\n\t\t\tif (mode != ApplicationMode.DEFAULT) {\n\t\t\t\tvisible.add(mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(ApplicationMode mode : values) {\n\t\t\tif (!visible.contains(mode)) {\n\t\t\t\tvisible.add(mode);\n\t\t\t\tif (visible.size() == 3){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":29563,"modified_method":"private static void getVisibleModes(List<ApplicationMode> values, Set<ApplicationMode> selected, List<ApplicationMode> visible) {\n\t\tif (visible.size() <= 4 && (selected.isEmpty() || visible.contains(selected.iterator().next()))) {\n\t\t\treturn;\n\t\t}\n\t\tvisible.clear();\n\t\tvisible.addAll(selected);\n\t\tif(!selected.contains(ApplicationMode.DEFAULT)) {\n\t\t\tvisible.add(0, ApplicationMode.DEFAULT);\n\t\t}\n\t\tfor(ApplicationMode mode : values) {\n\t\t\tif(visible.size() >= 3) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!visible.contains(mode)) {\n\t\t\t\tvisible.add(mode);\n\t\t\t}\n\t\t}\n\t}","commit_id":"23527a47198b460c105daf4efb015af260f80d85","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void showWaypointsInDrawer(boolean flat) {\n\t\tfinal int[] running = new int[] { -1 };\n\t\tArrayAdapter<Object> listAdapter = waypointDialogHelper.getWaypointsDrawerAdapter(mapActivity, running, flat);\n\t\tmDrawerList.setAdapter(listAdapter);\n\t\trefreshDrawer = false;\n\t\tmDrawerList.setDivider(mapActivity.getResources().getDrawable(R.drawable.drawer_divider));\n\t\tmDrawerList.setBackgroundColor(getMyApplication().getSettings().isLightContentMenu() ? mapActivity\n\t\t\t\t.getResources().getColor(R.color.color_white) : mapActivity.getResources().getColor(\n\t\t\t\tR.color.dark_drawer_bg_color));\n\t\tmDrawerList.setOnItemClickListener(waypointDialogHelper.getDrawerItemClickListener(mapActivity, running,\n\t\t\t\tlistAdapter, null));\n\t}","id":29564,"modified_method":"public void showWaypointsInDrawer(boolean flat) {\n\t\tfinal int[] running = new int[] { -1 };\n\t\tArrayAdapter<Object> listAdapter = waypointDialogHelper.getWaypointsDrawerAdapter(mapActivity, running, flat);\n\t\tmDrawerList.setAdapter(listAdapter);\n\t\trefreshDrawer = false;\n\t\tmDrawerList.setDivider(mapActivity.getResources().getDrawable(R.drawable.drawer_divider));\n\t\tfinal int color = getMyApplication().getSettings().isLightContentMenu() ? mapActivity\n\t\t\t\t.getResources().getColor(R.color.color_white) : mapActivity.getResources().getColor(\n\t\t\t\tR.color.dark_drawer_bg_color);\n\t\tmDrawerList.setBackgroundColor(color);\n\t\tmDrawerList.setCacheColorHint(color);\n\t\tmDrawerList.setOnItemClickListener(waypointDialogHelper.getDrawerItemClickListener(mapActivity, running,\n\t\t\t\tlistAdapter, null));\n\t}","commit_id":"23527a47198b460c105daf4efb015af260f80d85","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void prepareOptionsMenu(final ContextMenuAdapter cm) {\n\t\tfinal ArrayAdapter<?> listAdapter =\n\t\t\t\tcm.createListAdapter(mapActivity, getMyApplication().getSettings().isLightContentMenu());\n\t\tmDrawerList.setAdapter(listAdapter);\n\t\trefreshDrawer = false;\n\t\tmDrawerList.setDivider(mapActivity.getResources().getDrawable(R.drawable.drawer_divider));\n\t\tmDrawerList.setBackgroundColor(cm.getBackgroundColor(mapActivity, getMyApplication().getSettings().isLightContentMenu()));\n\t\tmDrawerList.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onItemClick(AdapterView<?> parent, View view, int which, long id) {\n\t\t\t\tOnContextMenuClick click = cm.getClickAdapter(which);\n\t\t\t\tif(click instanceof OnRowItemClick) {\n\t\t\t\t\tboolean cl = ((OnRowItemClick) click).onRowItemClick(listAdapter, view, cm.getElementId(which), which);\n\t\t\t\t\tif(cl) {\n\t\t\t\t\t\tmDrawerLayout.closeDrawer(mDrawerList);\n\t\t\t\t\t}\n\t\t\t\t} else if (click != null) {\n\t\t\t\t\tCompoundButton btn = (CompoundButton) view.findViewById(R.id.check_item);\n\t\t\t\t\tif (btn != null && btn.getVisibility() == View.VISIBLE) {\n\t\t\t\t\t\tbtn.setChecked(!btn.isChecked());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (click.onContextMenuClick(listAdapter, cm.getElementId(which), which, false)) {\n\t\t\t\t\t\t\tmDrawerLayout.closeDrawer(mDrawerList);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmDrawerLayout.closeDrawer(mDrawerList);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","id":29565,"modified_method":"public void prepareOptionsMenu(final ContextMenuAdapter cm) {\n\t\tfinal ArrayAdapter<?> listAdapter =\n\t\t\t\tcm.createListAdapter(mapActivity, getMyApplication().getSettings().isLightContentMenu());\n\t\tmDrawerList.setAdapter(listAdapter);\n\t\trefreshDrawer = false;\n\t\tmDrawerList.setDivider(mapActivity.getResources().getDrawable(R.drawable.drawer_divider));\n\t\tfinal int colorHint = cm.getBackgroundColor(mapActivity, getMyApplication().getSettings().isLightContentMenu());\n\t\tmDrawerList.setBackgroundColor(colorHint);\n\t\tmDrawerList.setCacheColorHint(colorHint);\n\t\tmDrawerList.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onItemClick(AdapterView<?> parent, View view, int which, long id) {\n\t\t\t\tOnContextMenuClick click = cm.getClickAdapter(which);\n\t\t\t\tif(click instanceof OnRowItemClick) {\n\t\t\t\t\tboolean cl = ((OnRowItemClick) click).onRowItemClick(listAdapter, view, cm.getElementId(which), which);\n\t\t\t\t\tif(cl) {\n\t\t\t\t\t\tmDrawerLayout.closeDrawer(mDrawerList);\n\t\t\t\t\t}\n\t\t\t\t} else if (click != null) {\n\t\t\t\t\tCompoundButton btn = (CompoundButton) view.findViewById(R.id.check_item);\n\t\t\t\t\tif (btn != null && btn.getVisibility() == View.VISIBLE) {\n\t\t\t\t\t\tbtn.setChecked(!btn.isChecked());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (click.onContextMenuClick(listAdapter, cm.getElementId(which), which, false)) {\n\t\t\t\t\t\t\tmDrawerLayout.closeDrawer(mDrawerList);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmDrawerLayout.closeDrawer(mDrawerList);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","commit_id":"23527a47198b460c105daf4efb015af260f80d85","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void sendRecordFileUpload(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tlong recordId, String fieldName)\n\t\tthrows Exception {\n\n\t\tDDLRecord record = DDLRecordServiceUtil.getRecord(recordId);\n\n\t\tsendRecordFileUpload(request, response, record, fieldName);\n\t}","id":29566,"modified_method":"public void sendRecordFileUpload(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tlong recordId, String fieldName, int valueIndex)\n\t\tthrows Exception {\n\n\t\tDDLRecord record = DDLRecordServiceUtil.getRecord(recordId);\n\n\t\tsendRecordFileUpload(request, response, record, fieldName, valueIndex);\n\t}","commit_id":"33f7c2cad62ed8c8c390ca919915ba9380d9a3c2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void sendRecordFileUpload(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tDDLRecord record, String fieldName)\n\t\tthrows Exception {\n\n\t\tField field = record.getField(fieldName);\n\n\t\tDDMUtil.sendFieldFile(request, response, field);\n\t}","id":29567,"modified_method":"public void sendRecordFileUpload(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tDDLRecord record, String fieldName, int valueIndex)\n\t\tthrows Exception {\n\n\t\tField field = record.getField(fieldName);\n\n\t\tDDMUtil.sendFieldFile(request, response, field, valueIndex);\n\t}","commit_id":"33f7c2cad62ed8c8c390ca919915ba9380d9a3c2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String uploadRecordFieldFile(\n\t\t\tDDLRecord record, String fieldName, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tDDLRecordSet recordSet = record.getRecordSet();\n\n\t\tDDMStructure ddmStructure = recordSet.getDDMStructure();\n\n\t\tDDLRecordVersion recordVersion = record.getLatestRecordVersion();\n\n\t\treturn DDMUtil.uploadFieldFile(\n\t\t\tddmStructure.getStructureId(), recordVersion.getDDMStorageId(),\n\t\t\trecord, fieldName, serviceContext);\n\t}","id":29568,"modified_method":"public void uploadRecordFieldFile(\n\t\t\tDDLRecord record, String fieldName, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tDDLRecordSet recordSet = record.getRecordSet();\n\n\t\tDDMStructure ddmStructure = recordSet.getDDMStructure();\n\n\t\tDDLRecordVersion recordVersion = record.getLatestRecordVersion();\n\n\t\tDDMUtil.uploadFieldFile(\n\t\t\tddmStructure.getStructureId(), recordVersion.getDDMStorageId(),\n\t\t\trecord, fieldName, serviceContext);\n\t}","commit_id":"33f7c2cad62ed8c8c390ca919915ba9380d9a3c2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void sendRecordFileUpload(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tlong recordId, String fieldName)\n\t\tthrows Exception {\n\n\t\tgetDDL().sendRecordFileUpload(request, response, recordId, fieldName);\n\t}","id":29569,"modified_method":"public static void sendRecordFileUpload(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tlong recordId, String fieldName, int valueIndex)\n\t\tthrows Exception {\n\n\t\tgetDDL().sendRecordFileUpload(\n\t\t\trequest, response, recordId, fieldName, valueIndex);\n\t}","commit_id":"33f7c2cad62ed8c8c390ca919915ba9380d9a3c2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String uploadRecordFieldFile(\n\t\t\tDDLRecord record, String fieldName, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\treturn getDDL().uploadRecordFieldFile(\n\t\t\trecord, fieldName, serviceContext);\n\t}","id":29570,"modified_method":"public static void uploadRecordFieldFile(\n\t\t\tDDLRecord record, String fieldName, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tgetDDL().uploadRecordFieldFile(record, fieldName, serviceContext);\n\t}","commit_id":"33f7c2cad62ed8c8c390ca919915ba9380d9a3c2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void getRecordFileUpload(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tDDLRecord record, String fieldName)\n\t\tthrows Exception {\n\n\t\tgetDDL().sendRecordFileUpload(request, response, record, fieldName);\n\t}","id":29571,"modified_method":"public static void getRecordFileUpload(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tDDLRecord record, String fieldName, int valueIndex)\n\t\tthrows Exception {\n\n\t\tgetDDL().sendRecordFileUpload(\n\t\t\trequest, response, record, fieldName, valueIndex);\n\t}","commit_id":"33f7c2cad62ed8c8c390ca919915ba9380d9a3c2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void sendRecordFileUpload(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tDDLRecord record, String fieldName)\n\t\tthrows Exception {\n\n\t\tgetDDL().sendRecordFileUpload(request, response, record, fieldName);\n\t}","id":29572,"modified_method":"public static void sendRecordFileUpload(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tDDLRecord record, String fieldName, int valueIndex)\n\t\tthrows Exception {\n\n\t\tgetDDL().sendRecordFileUpload(\n\t\t\trequest, response, record, fieldName, valueIndex);\n\t}","commit_id":"33f7c2cad62ed8c8c390ca919915ba9380d9a3c2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String uploadFieldFile(\n\t\t\tlong structureId, long storageId, BaseModel<?> baseModel,\n\t\t\tString fieldName, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\treturn uploadFieldFile(\n\t\t\tstructureId, storageId, baseModel, fieldName, StringPool.BLANK,\n\t\t\tserviceContext);\n\t}","id":29573,"modified_method":"public void uploadFieldFile(\n\t\t\tlong structureId, long storageId, BaseModel<?> baseModel,\n\t\t\tString fieldName, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tuploadFieldFile(\n\t\t\tstructureId, storageId, baseModel, fieldName, StringPool.BLANK,\n\t\t\tserviceContext);\n\t}","commit_id":"b6fa731785b7e61c1724bf8f8642534b2dce04d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Fields getFields(\n\t\t\tlong ddmStructureId, long ddmTemplateId, String fieldNamespace,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tDDMStructure ddmStructure = DDMStructureLocalServiceUtil.getStructure(\n\t\t\tddmStructureId);\n\n\t\ttry {\n\t\t\tDDMTemplate ddmTemplate = DDMTemplateLocalServiceUtil.getTemplate(\n\t\t\t\tddmTemplateId);\n\n\t\t\t// Clone ddmStructure to make sure changes are never persisted\n\n\t\t\tddmStructure = (DDMStructure)ddmStructure.clone();\n\n\t\t\tddmStructure.setXsd(ddmTemplate.getScript());\n\t\t}\n\t\tcatch (NoSuchTemplateException nste) {\n\t\t}\n\n\t\tSet<String> fieldNames = ddmStructure.getFieldNames();\n\n\t\tFields fields = new Fields();\n\n\t\tfor (String fieldName : fieldNames) {\n\t\t\tField field = new Field();\n\n\t\t\tfield.setName(fieldName);\n\n\t\t\tString fieldDataType = ddmStructure.getFieldDataType(fieldName);\n\t\t\tString fieldType = ddmStructure.getFieldType(fieldName);\n\t\t\tSerializable fieldValue = serviceContext.getAttribute(\n\t\t\t\tfieldNamespace + fieldName);\n\n\t\t\tif (fieldDataType.equals(FieldConstants.DATE)) {\n\t\t\t\tint fieldValueMonth = GetterUtil.getInteger(\n\t\t\t\t\tserviceContext.getAttribute(\n\t\t\t\t\t\tfieldNamespace + fieldName + \"Month\"));\n\t\t\t\tint fieldValueYear = GetterUtil.getInteger(\n\t\t\t\t\tserviceContext.getAttribute(\n\t\t\t\t\t\tfieldNamespace + fieldName + \"Year\"));\n\t\t\t\tint fieldValueDay = GetterUtil.getInteger(\n\t\t\t\t\tserviceContext.getAttribute(\n\t\t\t\t\t\tfieldNamespace + fieldName + \"Day\"));\n\n\t\t\t\tDate fieldValueDate = PortalUtil.getDate(\n\t\t\t\t\tfieldValueMonth, fieldValueDay, fieldValueYear);\n\n\t\t\t\tif (fieldValueDate != null) {\n\t\t\t\t\tfieldValue = String.valueOf(fieldValueDate.getTime());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((fieldValue == null) ||\n\t\t\t\tfieldDataType.equals(FieldConstants.FILE_UPLOAD)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (fieldType.equals(DDMImpl.TYPE_RADIO) ||\n\t\t\t\tfieldType.equals(DDMImpl.TYPE_SELECT)) {\n\n\t\t\t\tif (fieldValue instanceof String) {\n\t\t\t\t\tfieldValue = new String[] {String.valueOf(fieldValue)};\n\t\t\t\t}\n\n\t\t\t\tfieldValue = JSONFactoryUtil.serialize(fieldValue);\n\t\t\t}\n\n\t\t\tSerializable fieldValueSerializable =\n\t\t\t\tFieldConstants.getSerializable(\n\t\t\t\t\tfieldDataType, GetterUtil.getString(fieldValue));\n\n\t\t\tfield.setValue(fieldValueSerializable);\n\n\t\t\tfields.put(field);\n\t\t}\n\n\t\treturn fields;\n\t}","id":29574,"modified_method":"public Fields getFields(\n\t\t\tlong ddmStructureId, long ddmTemplateId, String fieldNamespace,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tDDMStructure ddmStructure = getDDMStructure(\n\t\t\tddmStructureId, ddmTemplateId);\n\n\t\tJSONObject repeatabaleFields = getRepeatableFieldsJSON(serviceContext);\n\n\t\tSet<String> fieldNames = ddmStructure.getFieldNames();\n\n\t\tFields fields = new Fields();\n\n\t\tfor (String fieldName : fieldNames) {\n\t\t\tList<Serializable> fieldValues = getFieldValues(\n\t\t\t\tddmStructure, repeatabaleFields, fieldName, fieldNamespace,\n\t\t\t\tserviceContext);\n\n\t\t\tif (fieldValues == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tField field = new Field(ddmStructureId, fieldName, fieldValues);\n\n\t\t\tfields.put(field);\n\t\t}\n\n\t\treturn fields;\n\t}","commit_id":"b6fa731785b7e61c1724bf8f8642534b2dce04d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String uploadFieldFile(\n\t\t\tlong structureId, long storageId, BaseModel<?> baseModel,\n\t\t\tString fieldName, String fieldNamespace,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request = serviceContext.getRequest();\n\n\t\tif (!(request instanceof UploadRequest)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tUploadRequest uploadRequest = (UploadRequest)request;\n\n\t\tString fileName = uploadRequest.getFileName(fieldNamespace + fieldName);\n\n\t\tString fieldValue = StringPool.BLANK;\n\n\t\tInputStream inputStream = null;\n\n\t\tFields fields = StorageEngineUtil.getFields(storageId);\n\n\t\ttry {\n\t\t\tinputStream = uploadRequest.getFileAsStream(\n\t\t\t\tfieldNamespace + fieldName, true);\n\n\t\t\tif (inputStream != null) {\n\t\t\t\tString filePath = storeFieldFile(\n\t\t\t\t\tbaseModel, fieldName, inputStream, serviceContext);\n\n\t\t\t\tJSONObject recordFileJSONObject =\n\t\t\t\t\tJSONFactoryUtil.createJSONObject();\n\n\t\t\t\trecordFileJSONObject.put(\"name\", fileName);\n\t\t\t\trecordFileJSONObject.put(\"path\", filePath);\n\t\t\t\trecordFileJSONObject.put(\n\t\t\t\t\t\"className\", baseModel.getModelClassName());\n\t\t\t\trecordFileJSONObject.put(\n\t\t\t\t\t\"classPK\", String.valueOf(baseModel.getPrimaryKeyObj()));\n\n\t\t\t\tfieldValue = recordFileJSONObject.toString();\n\t\t\t}\n\t\t\telse if (fields.contains(fieldName)) {\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tField field = new Field(structureId, fieldName, fieldValue);\n\n\t\t\tfields.put(field);\n\n\t\t\tStorageEngineUtil.update(storageId, fields, true, serviceContext);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t}\n\n\t\treturn fieldValue;\n\t}","id":29575,"modified_method":"public void uploadFieldFile(\n\t\t\tlong structureId, long storageId, BaseModel<?> baseModel,\n\t\t\tString fieldName, String fieldNamespace,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request = serviceContext.getRequest();\n\n\t\tif (!(request instanceof UploadRequest)) {\n\t\t\treturn;\n\t\t}\n\n\t\tDDMStructure ddmStructure =\n\t\t\tDDMStructureLocalServiceUtil.getDDMStructure(structureId);\n\n\t\tJSONObject repeatabaleFields = getRepeatableFieldsJSON(serviceContext);\n\n\t\tList<String> namespacedFieldNames = getNamespacedFieldNames(\n\t\t\tddmStructure, fieldNamespace, fieldName, repeatabaleFields);\n\n\t\tUploadRequest uploadRequest = (UploadRequest)request;\n\n\t\tFields fields = StorageEngineUtil.getFields(storageId);\n\n\t\tInputStream inputStream = null;\n\n\t\tList<Serializable> fieldValues = new ArrayList<Serializable>();\n\n\t\tfor (String namespacedFieldName : namespacedFieldNames) {\n\t\t\ttry {\n\t\t\t\tString fileName = uploadRequest.getFileName(\n\t\t\t\t\tnamespacedFieldName);\n\n\t\t\t\tinputStream = uploadRequest.getFileAsStream(\n\t\t\t\t\tnamespacedFieldName, true);\n\n\t\t\t\tif (inputStream != null) {\n\t\t\t\t\tString filePath = storeFieldFile(\n\t\t\t\t\t\tbaseModel, namespacedFieldName, inputStream,\n\t\t\t\t\t\tserviceContext);\n\n\t\t\t\t\tJSONObject recordFileJSONObject =\n\t\t\t\t\t\tJSONFactoryUtil.createJSONObject();\n\n\t\t\t\t\trecordFileJSONObject.put(\"name\", fileName);\n\t\t\t\t\trecordFileJSONObject.put(\"path\", filePath);\n\t\t\t\t\trecordFileJSONObject.put(\n\t\t\t\t\t\t\"className\", baseModel.getModelClassName());\n\t\t\t\t\trecordFileJSONObject.put(\n\t\t\t\t\t\t\"classPK\",\n\t\t\t\t\t\tString.valueOf(baseModel.getPrimaryKeyObj()));\n\n\t\t\t\t\tString fieldValue = recordFileJSONObject.toString();\n\n\t\t\t\t\tfieldValues.add(fieldValue);\n\t\t\t\t}\n\t\t\t\telse if (fields.contains(fieldName)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t\t}\n\t\t}\n\n\t\tField field = new Field(structureId, fieldName, fieldValues);\n\n\t\tfields.put(field);\n\n\t\tStorageEngineUtil.update(storageId, fields, true, serviceContext);\n\t}","commit_id":"b6fa731785b7e61c1724bf8f8642534b2dce04d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void sendFieldFile(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tField field)\n\t\tthrows Exception {\n\n\t\tif (field == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDDMStructure structure = field.getDDMStructure();\n\n\t\tSerializable fieldValue = field.getValue();\n\n\t\tJSONObject fileJSONObject = JSONFactoryUtil.createJSONObject(\n\t\t\tString.valueOf(fieldValue));\n\n\t\tString fileName = fileJSONObject.getString(\"name\");\n\t\tString filePath = fileJSONObject.getString(\"path\");\n\n\t\tInputStream is = DLStoreUtil.getFileAsStream(\n\t\t\tstructure.getCompanyId(), CompanyConstants.SYSTEM, filePath);\n\t\tlong contentLength = DLStoreUtil.getFileSize(\n\t\t\tstructure.getCompanyId(), CompanyConstants.SYSTEM, filePath);\n\t\tString contentType = MimeTypesUtil.getContentType(fileName);\n\n\t\tServletResponseUtil.sendFile(\n\t\t\trequest, response, fileName, is, contentLength, contentType);\n\t}","id":29576,"modified_method":"public void sendFieldFile(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tField field, int valueIndex)\n\t\tthrows Exception {\n\n\t\tif (field == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDDMStructure structure = field.getDDMStructure();\n\n\t\tSerializable fieldValue = field.getValue(valueIndex);\n\n\t\tJSONObject fileJSONObject = JSONFactoryUtil.createJSONObject(\n\t\t\tString.valueOf(fieldValue));\n\n\t\tString fileName = fileJSONObject.getString(\"name\");\n\t\tString filePath = fileJSONObject.getString(\"path\");\n\n\t\tInputStream is = DLStoreUtil.getFileAsStream(\n\t\t\tstructure.getCompanyId(), CompanyConstants.SYSTEM, filePath);\n\t\tlong contentLength = DLStoreUtil.getFileSize(\n\t\t\tstructure.getCompanyId(), CompanyConstants.SYSTEM, filePath);\n\t\tString contentType = MimeTypesUtil.getContentType(fileName);\n\n\t\tServletResponseUtil.sendFile(\n\t\t\trequest, response, fileName, is, contentLength, contentType);\n\t}","commit_id":"b6fa731785b7e61c1724bf8f8642534b2dce04d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String uploadFieldFile(\n\t\t\tlong structureId, long storageId, BaseModel<?> baseModel,\n\t\t\tString fieldName, String fieldNamespace,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\treturn getDDM().uploadFieldFile(\n\t\t\tstructureId, storageId, baseModel, fieldName, fieldNamespace,\n\t\t\tserviceContext);\n\t}","id":29577,"modified_method":"public static void uploadFieldFile(\n\t\t\tlong structureId, long storageId, BaseModel<?> baseModel,\n\t\t\tString fieldName, String fieldNamespace,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tgetDDM().uploadFieldFile(\n\t\t\tstructureId, storageId, baseModel, fieldName, fieldNamespace,\n\t\t\tserviceContext);\n\t}","commit_id":"b6fa731785b7e61c1724bf8f8642534b2dce04d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void sendFieldFile(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tField field)\n\t\tthrows Exception {\n\n\t\tgetDDM().sendFieldFile(request, response, field);\n\t}","id":29578,"modified_method":"public static void sendFieldFile(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tField field, int valueIndex)\n\t\tthrows Exception {\n\n\t\tgetDDM().sendFieldFile(request, response, field, valueIndex);\n\t}","commit_id":"b6fa731785b7e61c1724bf8f8642534b2dce04d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String uploadFieldFile(\n\t\t\tlong structureId, long storageId, BaseModel<?> baseModel,\n\t\t\tString fieldName, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\treturn getDDM().uploadFieldFile(\n\t\t\tstructureId, storageId, baseModel, fieldName, serviceContext);\n\t}","id":29579,"modified_method":"public static void uploadFieldFile(\n\t\t\tlong structureId, long storageId, BaseModel<?> baseModel,\n\t\t\tString fieldName, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tgetDDM().uploadFieldFile(\n\t\t\tstructureId, storageId, baseModel, fieldName, serviceContext);\n\t}","commit_id":"b6fa731785b7e61c1724bf8f8642534b2dce04d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Collection<Number> map(ReadBackedPileup pileup) {\n        List<Integer> insertSizes = new ArrayList<Integer>(pileup.size());\n        for ( PileupElement e : pileup ) {\n            insertSizes.add(Math.abs(e.getRead().getInferredInsertSize()));\n        }\n\n        return (Collection) insertSizes;\n    }","id":29580,"modified_method":"public Collection<Number> map(ReadBackedPileup pileup) {\n        List<Integer> insertSizes = new ArrayList<Integer>(pileup.size());\n        for ( PileupElement e : pileup ) {\n            if ( e.getMappingQual() >= MAPQ_THRESHOLD ) {\n                insertSizes.add(Math.abs(e.getRead().getInferredInsertSize()));\n            }\n        }\n\n        return (Collection) insertSizes;\n    }","commit_id":"e28fc2164286ce39249b8dbf42469eae6726b08b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Pair<Number,Number> map(ReadBackedPileup pileup) {\n        int tot = 0;\n        int otherCon = 0;\n        for ( PileupElement e : pileup ) {\n            if ( e.getRead().getReadPairedFlag() ) {\n                ++tot;\n                if ( ! e.getRead().getMateReferenceIndex().equals(e.getRead().getReferenceIndex()) ) {\n                    ++otherCon;\n                }\n            }\n        }\n\n        return new Pair<Number,Number>(otherCon,tot);\n    }","id":29581,"modified_method":"public Pair<Number,Number> map(ReadBackedPileup pileup) {\n        int tot = 0;\n        int otherCon = 0;\n        for ( PileupElement e : pileup ) {\n            if ( e.getRead().getReadPairedFlag() && e.getRead().getMappingQuality() >= MAPQ_THRESHOLD ) {\n                ++tot;\n                if ( ! e.getRead().getMateReferenceIndex().equals(e.getRead().getReferenceIndex()) ) {\n                    ++otherCon;\n                }\n            }\n        }\n\n        return new Pair<Number,Number>(otherCon,tot);\n    }","commit_id":"e28fc2164286ce39249b8dbf42469eae6726b08b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Pair<Number,Number> map(ReadBackedPileup rbp) {\n        int numPairs = 0;\n        int mateSameStrand = 0;\n        for (PileupElement e : rbp ) {\n            if ( e.getRead().getReadPairedFlag() ) {\n                ++numPairs;\n                if ( e.getRead().getMateNegativeStrandFlag() == e.getRead().getReadNegativeStrandFlag() ) {\n                    ++mateSameStrand;\n                }\n            }\n        }\n\n        return new Pair<Number,Number>(mateSameStrand,numPairs);\n    }","id":29582,"modified_method":"public Pair<Number,Number> map(ReadBackedPileup rbp) {\n        int numPairs = 0;\n        int mateSameStrand = 0;\n        for (PileupElement e : rbp ) {\n            if ( e.getRead().getReadPairedFlag() && e.getMappingQual() >= MAPQ_THRESHOLD) {\n                ++numPairs;\n                if ( e.getRead().getMateNegativeStrandFlag() == e.getRead().getReadNegativeStrandFlag() ) {\n                    ++mateSameStrand;\n                }\n            }\n        }\n\n        return new Pair<Number,Number>(mateSameStrand,numPairs);\n    }","commit_id":"e28fc2164286ce39249b8dbf42469eae6726b08b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Pair<Number,Number> map(ReadBackedPileup pileup) {\n        int numMatedReads = 0;\n        int numPairUnmapped = 0;\n        for (PileupElement e : pileup ) {\n            if (e.getRead().getReadPairedFlag()  ) {\n                ++numMatedReads;\n                if ( e.getRead().getMateUnmappedFlag() ) {\n                    ++numPairUnmapped;\n                }\n            }\n        }\n\n        return new Pair<Number,Number>(numPairUnmapped,numMatedReads);\n    }","id":29583,"modified_method":"public Pair<Number,Number> map(ReadBackedPileup pileup) {\n        int numMatedReads = 0;\n        int numPairUnmapped = 0;\n        for (PileupElement e : pileup ) {\n            if (e.getRead().getReadPairedFlag() && e.getMappingQual() >= MAPQ_THRESHOLD ) {\n                ++numMatedReads;\n                if ( e.getRead().getMateUnmappedFlag() ) {\n                    ++numPairUnmapped;\n                }\n            }\n        }\n\n        return new Pair<Number,Number>(numPairUnmapped,numMatedReads);\n    }","commit_id":"e28fc2164286ce39249b8dbf42469eae6726b08b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Pair<Number,Number> map(ReadBackedPileup rbp) {\n        int numReads = 0;\n        int numPropPair = 0;\n        for (PileupElement e : rbp ) {\n            ++numReads;\n            if ( e.getRead().getReadPairedFlag() && e.getRead().getProperPairFlag() ) {\n                ++numPropPair;\n            }\n        }\n\n        return new Pair<Number,Number>(numPropPair,numReads);\n    }","id":29584,"modified_method":"public Pair<Number,Number> map(ReadBackedPileup rbp) {\n        int numReads = 0;\n        int numPropPair = 0;\n        for (PileupElement e : rbp ) {\n            if ( e.getRead().getReadPairedFlag() && e.getMappingQual() >= MAPQ_THRESHOLD ) {\n                ++numReads;\n                if ( e.getRead().getReadPairedFlag() && e.getRead().getProperPairFlag() ) {\n                    ++numPropPair;\n                }\n            }\n        }\n\n        return new Pair<Number,Number>(numPropPair,numReads);\n    }","commit_id":"e28fc2164286ce39249b8dbf42469eae6726b08b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Pair<Number,Number> map(ReadBackedPileup pileup) {\n        int numReads = 0;\n        int numWithIndels = 0;\n        for ( PileupElement e : pileup ) {\n            ++numReads;\n            if ( e.getRead().getCigar().getCigarElements().contains(CigarOperator.DELETION) || e.getRead().getCigar().getCigarElements().contains(CigarOperator.INSERTION)) {\n                ++numWithIndels;\n            }\n        }\n\n        return new Pair<Number,Number>(numWithIndels,numReads);\n    }","id":29585,"modified_method":"public Pair<Number,Number> map(ReadBackedPileup pileup) {\n        int numReads = 0;\n        int numWithIndels = 0;\n        for ( PileupElement e : pileup ) {\n            ++numReads;\n            for ( CigarElement element : e.getRead().getCigar().getCigarElements() ) {\n                if ( element.getOperator().equals(CigarOperator.DELETION) || element.getOperator().equals(CigarOperator.INSERTION) ) {\n                    ++numWithIndels;\n                    break;\n                }\n            }\n        }\n\n        return new Pair<Number,Number>(numWithIndels,numReads);\n    }","commit_id":"e28fc2164286ce39249b8dbf42469eae6726b08b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void actionPerformed(ThumbnailView thumbnailView, AnActionEvent e) {\n        thumbnailView.hide();\n    }","id":29586,"modified_method":"public void actionPerformed(ThumbnailView thumbnailView, AnActionEvent e) {\n        thumbnailView.setVisible(false);\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n        DataContext dataContext = e.getDataContext();\n        Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n        VirtualFile file = (VirtualFile)dataContext.getData(DataConstants.VIRTUAL_FILE);\n        if (project != null && file != null && file.isDirectory()) {\n            ThumbnailManager thumbnailManager = ThumbnailManager.getInstance();\n            ThumbnailView thumbnailView = thumbnailManager.getThumbnailView(project);\n            thumbnailView.setRoot(file);\n            thumbnailView.show();\n        }\n    }","id":29587,"modified_method":"public void actionPerformed(AnActionEvent e) {\n        DataContext dataContext = e.getDataContext();\n        Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n        VirtualFile file = (VirtualFile)dataContext.getData(DataConstants.VIRTUAL_FILE);\n        if (project != null && file != null && file.isDirectory()) {\n            ThumbnailManager thumbnailManager = ThumbnailManager.getInstance();\n            ThumbnailView thumbnailView = thumbnailManager.getThumbnailView(project);\n            thumbnailView.setRoot(file);\n            thumbnailView.setVisible(true);\n            thumbnailView.activate();\n        }\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void projectOpened(Project project) {\n    }","id":29588,"modified_method":"public void projectOpened(Project project) {\n        SelectInManager selectInManager = SelectInManager.getInstance(project);\n        selectInManager.addTarget(selectInTarget);\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean canCloseProject(Project project) {\n        return false;\n    }","id":29589,"modified_method":"public boolean canCloseProject(Project project) {\n        return true;\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void initComponent() {\n    }","id":29590,"modified_method":"public void initComponent() {\n        ProjectManager.getInstance().addProjectManagerListener(this);\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void projectClosed(Project project) {\n        ThumbnailView thumbnailView = views.remove(project);\n        thumbnailView.dispose();\n    }","id":29591,"modified_method":"public void projectClosed(Project project) {\n        ThumbnailView thumbnailView = views.remove(project);\n        if (thumbnailView != null) {\n            thumbnailView.dispose();\n        }\n        SelectInManager selectInManager = SelectInManager.getInstance(project);\n        selectInManager.removeTarget(selectInTarget);\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void disposeComponent() {\n    }","id":29592,"modified_method":"public void disposeComponent() {\n        ProjectManager.getInstance().removeProjectManagerListener(this);\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateUI() {\n        getUI().refresh();\n    }","id":29593,"modified_method":"private void updateUI() {\n        if (isVisible()) {\n            getUI().refresh();\n        }\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setTransparencyChessboardVisible(boolean visible) {\n        getUI().setTransparencyChessboardVisible(visible);\n    }","id":29594,"modified_method":"public void setTransparencyChessboardVisible(boolean visible) {\n        if (isVisible()) {\n            getUI().setTransparencyChessboardVisible(visible);\n        }\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isTransparencyChessboardVisible() {\n        return getUI().isTransparencyChessboardVisible();\n    }","id":29595,"modified_method":"public boolean isTransparencyChessboardVisible() {\n        return isVisible() && getUI().isTransparencyChessboardVisible();\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void refresh() {\n        if (list != null && cellRenderer != null) {\n            DefaultListModel model = (DefaultListModel)list.getModel();\n            model.clear();\n\n            Set<VirtualFile> files = findFiles(thumbnailView.getRoot().getChildren());\n            VirtualFile[] virtualFiles = files.toArray(new VirtualFile[]{});\n            Arrays.sort(\n                virtualFiles, new Comparator<VirtualFile>() {\n                public int compare(VirtualFile o1, VirtualFile o2) {\n                    if (o1.isDirectory() && !o2.isDirectory()) {\n                        return -1;\n                    }\n                    if (o2.isDirectory() && !o1.isDirectory()) {\n                        return 1;\n                    }\n\n                    return o1.getPath().toLowerCase().compareTo(o2.getPath().toLowerCase());\n                }\n            }\n            );\n\n            model.ensureCapacity(model.size() + virtualFiles.length);\n            for (VirtualFile virtualFile : virtualFiles) {\n                model.addElement(virtualFile);\n            }\n        }\n    }","id":29596,"modified_method":"public void refresh() {\n        createUI();\n\n        DefaultListModel model = (DefaultListModel)list.getModel();\n        model.clear();\n\n        Set<VirtualFile> files = findFiles(thumbnailView.getRoot().getChildren());\n        VirtualFile[] virtualFiles = files.toArray(EMPTY_VIRTUAL_FILE_ARRAY);\n        Arrays.sort(\n            virtualFiles, new Comparator<VirtualFile>() {\n            public int compare(VirtualFile o1, VirtualFile o2) {\n                if (o1.isDirectory() && !o2.isDirectory()) {\n                    return -1;\n                }\n                if (o2.isDirectory() && !o1.isDirectory()) {\n                    return 1;\n                }\n\n                return o1.getPath().toLowerCase().compareTo(o2.getPath().toLowerCase());\n            }\n        }\n        );\n\n        model.ensureCapacity(model.size() + virtualFiles.length);\n        for (VirtualFile virtualFile : virtualFiles) {\n            model.addElement(virtualFile);\n        }\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean canNavigate() {\n            return files != null;\n        }","id":29597,"modified_method":"public boolean canNavigate() {\n            return file != null;\n        }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable public Object getData(String dataId) {\n        if (DataConstants.PROJECT.equals(dataId)) {\n            return thumbnailView.getProject();\n        } else if (DataConstants.VIRTUAL_FILE.equals(dataId)) {\n            VirtualFile[] selectedFiles = getSelectedFiles();\n            return selectedFiles != null && selectedFiles.length > 0 ? selectedFiles[0] : null;\n        } else if (DataConstants.VIRTUAL_FILE_ARRAY.equals(dataId)) {\n            return getSelectedFiles();\n        } else if (DataConstants.NAVIGATABLE.equals(dataId)) {\n            return new ThumbnailNavigatable(getSelectedFiles());\n        }\n\n        return null;\n    }","id":29598,"modified_method":"@Nullable public Object getData(String dataId) {\n        if (DataConstants.PROJECT.equals(dataId)) {\n            return thumbnailView.getProject();\n        } else if (DataConstants.VIRTUAL_FILE.equals(dataId)) {\n            VirtualFile[] selectedFiles = getSelectedFiles();\n            return selectedFiles != null && selectedFiles.length > 0 ? selectedFiles[0] : null;\n        } else if (DataConstants.VIRTUAL_FILE_ARRAY.equals(dataId)) {\n            return getSelectedFiles();\n        } else if (DataConstants.NAVIGATABLE.equals(dataId)) {\n            VirtualFile[] selectedFiles = getSelectedFiles();\n            return new ThumbnailNavigatable(selectedFiles != null && selectedFiles.length > 0 ? selectedFiles[0] : null);\n        } else if (DataConstants.NAVIGATABLE_ARRAY.equals(dataId)) {\n            VirtualFile[] selectedFiles = getSelectedFiles();\n            if (selectedFiles != null) {\n                Navigatable[] navigatables = new Navigatable[selectedFiles.length];\n                for (int i = 0; i < selectedFiles.length; i++) {\n                    VirtualFile selectedFile = selectedFiles[i];\n                    navigatables[i] = new ThumbnailNavigatable(selectedFile);\n                }\n                return navigatables;\n            }\n            return null;\n        }\n\n        return null;\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isTransparencyChessboardVisible() {\n        return cellRenderer.getImageComponent().isTransparencyChessboardVisible();\n    }","id":29599,"modified_method":"public boolean isTransparencyChessboardVisible() {\n        createUI();\n        return cellRenderer.getImageComponent().isTransparencyChessboardVisible();\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void createUI() {\n        if (cellRenderer == null || list == null) {\n            cellRenderer = new ThumbnailListCellRenderer();\n            ImageComponent imageComponent = cellRenderer.getImageComponent();\n\n            VirtualFileManager.getInstance().addVirtualFileListener(vfsListener);\n\n            Options options = OptionsManager.getInstance().getOptions();\n            EditorOptions editorOptions = options.getEditorOptions();\n            // Set options\n            TransparencyChessboardOptions chessboardOptions = editorOptions.getTransparencyChessboardOptions();\n            imageComponent.setTransparencyChessboardVisible(chessboardOptions.isShowDefault());\n            imageComponent.setTransparencyChessboardCellSize(chessboardOptions.getCellSize());\n            imageComponent.setTransparencyChessboardWhiteColor(chessboardOptions.getWhiteColor());\n            imageComponent.setTransparencyChessboardBlankColor(chessboardOptions.getBlackColor());\n\n            options.addPropertyChangeListener(optionsListener);\n\n            list = new JList();\n            list.setModel(new DefaultListModel());\n            list.setLayoutOrientation(JList.HORIZONTAL_WRAP);\n            list.setVisibleRowCount(-1);\n            list.setCellRenderer(cellRenderer);\n\n            list.addMouseListener(new ThumbnailsMouseAdapter());\n\n            ThumbnailComponentUI ui = (ThumbnailComponentUI)UIManager.getUI(cellRenderer);\n            Dimension preferredSize = ui.getPreferredSize(cellRenderer);\n\n            list.setFixedCellWidth(preferredSize.width);\n            list.setFixedCellHeight(preferredSize.height);\n\n\n            JScrollPane scrollPane = new JScrollPane(\n                list, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER\n            );\n\n            ActionManager actionManager = ActionManager.getInstance();\n            ActionGroup actionGroup = (ActionGroup)actionManager.getAction(ThumbnailsActions.GROUP_TOOLBAR);\n            ActionToolbar actionToolbar = actionManager.createActionToolbar(\n                ThumbnailsActions.GROUP_TOOLBAR, actionGroup, true\n            );\n\n            JComponent toolbar = actionToolbar.getComponent();\n\n            FocusRequester focusRequester = new FocusRequester();\n            toolbar.addMouseListener(focusRequester);\n            scrollPane.addMouseListener(focusRequester);\n\n            add(toolbar, BorderLayout.NORTH);\n            add(scrollPane, BorderLayout.CENTER);\n\n            refresh();\n        }\n    }","id":29600,"modified_method":"private void createUI() {\n        if (cellRenderer == null || list == null) {\n            cellRenderer = new ThumbnailListCellRenderer();\n            ImageComponent imageComponent = cellRenderer.getImageComponent();\n\n            VirtualFileManager.getInstance().addVirtualFileListener(vfsListener);\n\n            Options options = OptionsManager.getInstance().getOptions();\n            EditorOptions editorOptions = options.getEditorOptions();\n            // Set options\n            TransparencyChessboardOptions chessboardOptions = editorOptions.getTransparencyChessboardOptions();\n            imageComponent.setTransparencyChessboardVisible(chessboardOptions.isShowDefault());\n            imageComponent.setTransparencyChessboardCellSize(chessboardOptions.getCellSize());\n            imageComponent.setTransparencyChessboardWhiteColor(chessboardOptions.getWhiteColor());\n            imageComponent.setTransparencyChessboardBlankColor(chessboardOptions.getBlackColor());\n\n            options.addPropertyChangeListener(optionsListener);\n\n            list = new JList();\n            list.setModel(new DefaultListModel());\n            list.setLayoutOrientation(JList.HORIZONTAL_WRAP);\n            list.setVisibleRowCount(-1);\n            list.setCellRenderer(cellRenderer);\n\n            list.addMouseListener(new ThumbnailsMouseAdapter());\n\n            ThumbnailComponentUI componentUI = (ThumbnailComponentUI)UIManager.getUI(cellRenderer);\n            Dimension preferredSize = componentUI.getPreferredSize(cellRenderer);\n\n            list.setFixedCellWidth(preferredSize.width);\n            list.setFixedCellHeight(preferredSize.height);\n\n\n            JScrollPane scrollPane = new JScrollPane(\n                list, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER\n            );\n\n            ActionManager actionManager = ActionManager.getInstance();\n            ActionGroup actionGroup = (ActionGroup)actionManager.getAction(ThumbnailsActions.GROUP_TOOLBAR);\n            ActionToolbar actionToolbar = actionManager.createActionToolbar(\n                ThumbnailsActions.GROUP_TOOLBAR, actionGroup, true\n            );\n\n            JComponent toolbar = actionToolbar.getComponent();\n\n            FocusRequester focusRequester = new FocusRequester();\n            toolbar.addMouseListener(focusRequester);\n            scrollPane.addMouseListener(focusRequester);\n\n            add(toolbar, BorderLayout.NORTH);\n            add(scrollPane, BorderLayout.CENTER);\n        }\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void mouseClicked(MouseEvent e) {\n            if (MouseEvent.BUTTON1 == e.getButton() && e.getClickCount() == 2) {\n                // Double click\n                VirtualFile selected = (VirtualFile)list.getSelectedValue();\n                if (selected.isDirectory()) {\n                    thumbnailView.setRoot(selected);\n                } else {\n                    FileEditorManager fileEditorManager = FileEditorManager.getInstance(thumbnailView.getProject());\n                    fileEditorManager.openFile(selected, true);\n                }\n                e.consume();\n            }\n            if (MouseEvent.BUTTON3 == e.getButton() && e.getClickCount() == 1) {\n                // Single right click\n                ActionManager actionManager = ActionManager.getInstance();\n                ActionGroup actionGroup = (ActionGroup)actionManager.getAction(ThumbnailsActions.GROUP_POPUP_MENU);\n                ActionPopupMenu menu = actionManager.createActionPopupMenu(ThumbnailsActions.GROUP_POPUP_MENU, actionGroup);\n                JPopupMenu popupMenu = menu.getComponent();\n                popupMenu.pack();\n                popupMenu.show(e.getComponent(), e.getX(), e.getY());\n\n                e.consume();\n            }\n        }","id":29601,"modified_method":"public void mouseClicked(MouseEvent e) {\n            if (MouseEvent.BUTTON1 == e.getButton() && e.getClickCount() == 2) {\n                // Double click\n                VirtualFile selected = (VirtualFile)list.getSelectedValue();\n                if (selected.isDirectory()) {\n                    thumbnailView.setRoot(selected);\n                } else {\n                    FileEditorManager fileEditorManager = FileEditorManager.getInstance(thumbnailView.getProject());\n                    fileEditorManager.openFile(selected, true);\n                }\n                e.consume();\n            }\n            if (MouseEvent.BUTTON3 == e.getButton() && e.getClickCount() == 1) {\n                // Single right click\n                ActionManager actionManager = ActionManager.getInstance();\n                ActionGroup actionGroup = (ActionGroup)actionManager.getAction(ThumbnailsActions.GROUP_POPUP);\n                ActionPopupMenu menu = actionManager.createActionPopupMenu(ThumbnailsActions.ACTION_PLACE, actionGroup);\n                JPopupMenu popupMenu = menu.getComponent();\n                popupMenu.pack();\n                popupMenu.show(e.getComponent(), e.getX(), e.getY());\n\n                e.consume();\n            }\n        }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setTransparencyChessboardVisible(boolean visible) {\n        cellRenderer.getImageComponent().setTransparencyChessboardVisible(visible);\n        list.repaint();\n    }","id":29602,"modified_method":"public void setTransparencyChessboardVisible(boolean visible) {\n        createUI();\n        cellRenderer.getImageComponent().setTransparencyChessboardVisible(visible);\n        list.repaint();\n    }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void navigate(boolean requestFocus) {\n            if (files != null) {\n                FileEditorManager manager = FileEditorManager.getInstance(thumbnailView.getProject());\n                if (files.length > 2) {\n                    for (VirtualFile file : files) {\n                        manager.openFile(file, false);\n                    }\n                } else {\n                    manager.openFile(files[0], true);\n                }\n            }\n        }","id":29603,"modified_method":"public void navigate(boolean requestFocus) {\n            if (file != null) {\n                FileEditorManager manager = FileEditorManager.getInstance(thumbnailView.getProject());\n                manager.openFile(file, true);\n            }\n        }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean canNavigateToSource() {\n            return files != null;\n        }","id":29604,"modified_method":"public boolean canNavigateToSource() {\n            return file != null;\n        }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void contentsChanged(VirtualFileEvent event) {\n            VirtualFile file = event.getFile();\n            if (list != null) {\n                int index = ((DefaultListModel)list.getModel()).indexOf(file);\n                if (index != -1) {\n                    Rectangle cellBounds = list.getCellBounds(index, index);\n                    list.repaint(cellBounds);\n                }\n            }\n        }","id":29605,"modified_method":"public ThumbnailNavigatable(VirtualFile file) {\n            this.file = file;\n        }","commit_id":"e1491c31ef6a2fe07ef86dc2aefa89337b20eb74","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private VirtualFile[] getSelectedFilesInt() {\n    if (myTreeIsUpdating || !myUiUpdater.isEmpty()) {\n      if (isTextFieldActive() && !StringUtil.isEmpty(myPathTextField.getTextFieldText())) {\n        LookupFile toFind = myPathTextField.getFile();\n        if (toFind instanceof LocalFsFinder.VfsFile && toFind.exists()) {\n          VirtualFile file = ((LocalFsFinder.VfsFile)toFind).getFile();\n          if (file != null) {\n            return new VirtualFile[]{file};\n          }\n        }\n      }\n      return VirtualFile.EMPTY_ARRAY;\n    }\n\n    final List<VirtualFile> selectedFiles = Arrays.asList(myFileSystemTree.getSelectedFiles());\n    return VfsUtilCore.toVirtualFileArray(FileChooserUtil.getChosenFiles(myChooserDescriptor, selectedFiles));\n  }","id":29606,"modified_method":"private VirtualFile[] getSelectedFilesInt() {\n    if (myTreeIsUpdating || !myUiUpdater.isEmpty()) {\n      if (isTextFieldActive() && !StringUtil.isEmpty(myPathTextField.getTextFieldText())) {\n        LookupFile toFind = myPathTextField.getFile();\n        if (toFind instanceof LocalFsFinder.VfsFile && toFind.exists()) {\n          VirtualFile file = ((LocalFsFinder.VfsFile)toFind).getFile();\n          if (file != null) {\n            return new VirtualFile[]{file};\n          }\n        }\n      }\n      return VirtualFile.EMPTY_ARRAY;\n    }\n\n    return myFileSystemTree.getSelectedFiles();\n  }","commit_id":"0f17e3dcbe16d5b1fd239a8a6815a0d6b5ec8f87","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doOKAction() {\n    if (!isOKActionEnabled()) {\n      return;\n    }\n\n    if (isTextFieldActive()) {\n      final String text = myPathTextField.getTextFieldText();\n      final LookupFile file = myPathTextField.getFile();\n      if (text == null || file == null || !file.exists()) {\n        setErrorText(\"Specified path cannot be found\");\n        return;\n      }\n    }\n\n    final VirtualFile[] files = getSelectedFilesInt();\n    if (files.length == 0) {\n      myChosenFiles = VirtualFile.EMPTY_ARRAY;\n      close(CANCEL_EXIT_CODE);\n      return;\n    }\n\n    try {\n      myChooserDescriptor.validateSelectedFiles(files);\n    }\n    catch (Exception e) {\n      Messages.showErrorDialog(getContentPane(), e.getMessage(), getTitle());\n      return;\n    }\n\n    myChosenFiles = files;\n    storeSelection(files[files.length - 1]);\n\n    super.doOKAction();\n  }","id":29607,"modified_method":"protected void doOKAction() {\n    if (!isOKActionEnabled()) {\n      return;\n    }\n\n    if (isTextFieldActive()) {\n      final String text = myPathTextField.getTextFieldText();\n      final LookupFile file = myPathTextField.getFile();\n      if (text == null || file == null || !file.exists()) {\n        setErrorText(\"Specified path cannot be found\");\n        return;\n      }\n    }\n\n    final List<VirtualFile> selectedFiles = Arrays.asList(getSelectedFilesInt());\n    final VirtualFile[] files = VfsUtilCore.toVirtualFileArray(FileChooserUtil.getChosenFiles(myChooserDescriptor, selectedFiles));\n    if (files.length == 0) {\n      myChosenFiles = VirtualFile.EMPTY_ARRAY;\n      close(CANCEL_EXIT_CODE);\n      return;\n    }\n\n    try {\n      myChooserDescriptor.validateSelectedFiles(files);\n    }\n    catch (Exception e) {\n      Messages.showErrorDialog(getContentPane(), e.getMessage(), getTitle());\n      return;\n    }\n\n    myChosenFiles = files;\n    storeSelection(files[files.length - 1]);\n\n    super.doOKAction();\n  }","commit_id":"0f17e3dcbe16d5b1fd239a8a6815a0d6b5ec8f87","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Collection<VirtualFile> selectFilesToProcess(final List<VirtualFile> files,\n                                                      final String title,\n                                                      @Nullable final String prompt,\n                                                      final String singleFileTitle,\n                                                      final String singleFilePromptTemplate,\n                                                      final VcsShowConfirmationOption confirmationOption) {\n    if (files.size() == 1 && singleFilePromptTemplate != null) {\n      String filePrompt = MessageFormat.format(singleFilePromptTemplate, files.get(0).getPresentableUrl());\n      if (ConfirmationDialog\n        .requestForConfirmation(confirmationOption, myProject, filePrompt, singleFileTitle, Messages.getQuestionIcon())) {\n        return files;\n      }\n      return null;\n    }\n\n    SelectFilesDialog dlg = new SelectFilesDialog(myProject, files, prompt, confirmationOption);\n    dlg.setTitle(title);\n    dlg.show();\n    return dlg.isOK() ? dlg.getSelectedFiles() : null;\n  }","id":29608,"modified_method":"@Nullable\n  public Collection<VirtualFile> selectFilesToProcess(final List<VirtualFile> files,\n                                                      final String title,\n                                                      @Nullable final String prompt,\n                                                      final String singleFileTitle,\n                                                      final String singleFilePromptTemplate,\n                                                      final VcsShowConfirmationOption confirmationOption) {\n    if (files.size() == 1 && singleFilePromptTemplate != null) {\n      String filePrompt = MessageFormat.format(singleFilePromptTemplate, files.get(0).getPresentableUrl());\n      if (ConfirmationDialog\n        .requestForConfirmation(confirmationOption, myProject, filePrompt, singleFileTitle, Messages.getQuestionIcon())) {\n        return files;\n      }\n      return null;\n    }\n\n    SelectFilesDialog dlg = new SelectFilesDialog(myProject, files, prompt, confirmationOption);\n    dlg.setTitle(title);\n    dlg.show();\n    if (dlg.isOK()) {\n      final Collection<VirtualFile> selection = dlg.getSelectedFiles();\n      // return items in the same order as they were passed to us\n      final List<VirtualFile> result = new ArrayList<VirtualFile>();\n      for(VirtualFile file: files) {\n        if (selection.contains(file)) {\n          result.add(file);\n        }\n      }\n      return result;\n    }\n    return null;\n  }","commit_id":"607b4ac772030b0c5239941d159f2649a605cc49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void replace(PropertyContext propertyContext, ConnectionResult connectionResult, XFormsModelSubmission.SubmissionParameters p, XFormsModelSubmission.SecondPassParameters p2) throws IOException {\n\n        // When we get here, we are in a mode where we need to send the reply directly to an external context, if any.\n\n        // \"the event xforms-submit-done may be dispatched\"\n        if (!p.isDeferredSubmissionSecondPassReplaceAll) // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n            dispatchSubmitDone(propertyContext, connectionResult);\n\n        // Remember that we got a submission producing output\n        containingDocument.setGotSubmissionReplaceAll();\n\n        // Get response from containing document\n        final ExternalContext.Response response = containingDocument.getResponse();\n\n        // Set content-type\n        response.setContentType(connectionResult.getResponseContentType());\n\n        // Forward headers to response\n        connectionResult.forwardHeaders(response);\n\n        // Forward content to response\n        final OutputStream outputStream = response.getOutputStream();\n        NetUtils.copyStream(connectionResult.getResponseInputStream(), outputStream);\n\n        // End document and close\n        outputStream.flush();\n        outputStream.close();\n\n        // TODO: [#306918] RFE: Must be able to do replace=\"all\" during initialization.\n        // http://forge.objectweb.org/tracker/index.php?func=detail&aid=306918&group_id=168&atid=350207\n        // Suggestion is to write either binary or XML to processor output ContentHandler,\n        // and make sure the code which would output the XHTML+XForms is disabled.\n    }","id":29609,"modified_method":"public Runnable replace(PropertyContext propertyContext, ConnectionResult connectionResult, XFormsModelSubmission.SubmissionParameters p, XFormsModelSubmission.SecondPassParameters p2) throws IOException {\n\n        // When we get here, we are in a mode where we need to send the reply directly to an external context, if any.\n\n        // Remember that we got a submission producing output\n        containingDocument.setGotSubmissionReplaceAll();\n\n        // Get response from containing document\n        final ExternalContext.Response response = containingDocument.getResponse();\n\n        // Set content-type\n        response.setContentType(connectionResult.getResponseContentType());\n\n        // Forward headers to response\n        connectionResult.forwardHeaders(response);\n\n        // Forward content to response\n        final OutputStream outputStream = response.getOutputStream();\n        NetUtils.copyStream(connectionResult.getResponseInputStream(), outputStream);\n\n        // End document and close\n        outputStream.flush();\n        outputStream.close();\n\n        // TODO: [#306918] RFE: Must be able to do replace=\"all\" during initialization.\n        // http://forge.objectweb.org/tracker/index.php?func=detail&aid=306918&group_id=168&atid=350207\n        // Suggestion is to write either binary or XML to processor output ContentHandler,\n        // and make sure the code which would output the XHTML+XForms is disabled.\n\n        // \"the event xforms-submit-done may be dispatched\"\n        // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n        if (!p.isDeferredSubmissionSecondPassReplaceAll) {\n            return dispatchSubmitDone(propertyContext, connectionResult);\n        } else {\n            return null;\n        }\n    }","commit_id":"a770782b45e5d9c5dd2ed5a938c492cdfd5e3238","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"protected void dispatchSubmitDone(PropertyContext propertyContext, ConnectionResult connectionResult) {\n        submission.getXBLContainer(containingDocument)\n                .dispatchEvent(propertyContext, new XFormsSubmitDoneEvent(containingDocument, submission, connectionResult));\n    }","id":29610,"modified_method":"protected Runnable dispatchSubmitDone(final PropertyContext propertyContext, final ConnectionResult connectionResult) {\n        return new Runnable() {\n            public void run() {\n                submission.getXBLContainer(containingDocument)\n                    .dispatchEvent(propertyContext, new XFormsSubmitDoneEvent(containingDocument, submission, connectionResult));\n            }\n        };\n    }","commit_id":"a770782b45e5d9c5dd2ed5a938c492cdfd5e3238","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void replace(PropertyContext propertyContext, ConnectionResult connectionResult, XFormsModelSubmission.SubmissionParameters p, XFormsModelSubmission.SecondPassParameters p2) {\n\n        // Set new instance document to replace the one submitted\n\n        final XFormsInstance replaceInstanceNoTargetref = submission.findReplaceInstanceNoTargetref(p.refInstance);\n        if (replaceInstanceNoTargetref == null) {\n\n            // Replacement instance or node was specified but not found\n            //\n            // Not sure what's the right thing to do with 1.1, but this could be done\n            // as part of the model's static analysis if the instance value is not\n            // obtained through AVT, and dynamically otherwise. However, in the dynamic\n            // case, I think that this should be a (currently non-specified by XForms)\n            // xforms-binding-error.\n\n            submission.getXBLContainer(containingDocument).dispatchEvent(propertyContext, new XFormsBindingExceptionEvent(containingDocument, submission));\n        } else {\n\n            final NodeInfo destinationNodeInfo = submission.evaluateTargetRef(propertyContext,\n                    p.xpathContext, replaceInstanceNoTargetref, p.submissionElementContextItem);\n\n            if (destinationNodeInfo == null) {\n                // Throw target-error\n\n                // XForms 1.1: \"If the processing of the targetref attribute fails,\n                // then submission processing ends after dispatching the event\n                // xforms-submit-error with an error-type of target-error.\"\n\n                throw new XFormsSubmissionException(submission, \"targetref attribute doesn't point to an element for replace=\\\"instance\\\".\", \"processing targetref attribute\",\n                        new XFormsSubmitErrorEvent(containingDocument, propertyContext, submission, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR, connectionResult));\n            }\n\n            // This is the instance which is effectively going to be updated\n            final XFormsInstance updatedInstance = containingDocument.getInstanceForNode(destinationNodeInfo);\n            if (updatedInstance == null) {\n                throw new XFormsSubmissionException(submission, \"targetref attribute doesn't point to an element in an existing instance for replace=\\\"instance\\\".\", \"processing targetref attribute\",\n                        new XFormsSubmitErrorEvent(containingDocument, propertyContext, submission, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR, connectionResult));\n            }\n\n            // Whether the destination node is the root element of an instance\n            final boolean isDestinationRootElement = updatedInstance.getInstanceRootElementInfo().isSameNodeInfo(destinationNodeInfo);\n            if (p2.isReadonly && !isDestinationRootElement) {\n                // Only support replacing the root element of an instance when using a shared instance\n                throw new XFormsSubmissionException(submission, \"targetref attribute must point to instance root element when using read-only instance replacement.\", \"processing targetref attribute\",\n                        new XFormsSubmitErrorEvent(containingDocument, propertyContext, submission, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR, connectionResult));\n            }\n\n            final IndentedLogger detailsLogger = getDetailsLogger(p, p2);\n\n            // Obtain root element to insert\n            final NodeInfo newDocumentRootElement;\n            final XFormsInstance newInstance;\n            {\n                // Create resulting instance whether entire instance is replaced or not, because this:\n                // 1. Wraps a Document within a DocumentInfo if needed\n                // 2. Performs text nodes adjustments if needed\n                if (!p2.isReadonly) {\n                    // Resulting instance must not be read-only\n\n                    if (detailsLogger.isDebugEnabled())\n                        detailsLogger.logDebug(\"\", \"replacing instance with mutable instance\",\n                            \"instance\", updatedInstance.getEffectiveId());\n\n                    newInstance = new XFormsInstance(updatedInstance.getEffectiveModelId(), updatedInstance.getId(),\n                            (Document) resultingDocument, connectionResult.resourceURI, resultingRequestBodyHash, p2.username, p2.password,\n                            p2.isCache, p2.timeToLive, updatedInstance.getValidation(), p2.isHandleXInclude, XFormsProperties.isExposeXPathTypes(containingDocument));\n                } else {\n                    // Resulting instance must be read-only\n\n                    if (detailsLogger.isDebugEnabled())\n                        detailsLogger.logDebug(\"\", \"replacing instance with read-only instance\",\n                            \"instance\", updatedInstance.getEffectiveId());\n\n                    newInstance = new ReadonlyXFormsInstance(updatedInstance.getEffectiveModelId(), updatedInstance.getId(),\n                            (DocumentInfo) resultingDocument, connectionResult.resourceURI, resultingRequestBodyHash, p2.username, p2.password,\n                            p2.isCache, p2.timeToLive, updatedInstance.getValidation(), p2.isHandleXInclude, XFormsProperties.isExposeXPathTypes(containingDocument));\n                }\n                newDocumentRootElement = newInstance.getInstanceRootElementInfo();\n            }\n\n            // Perform insert/delete. This will dispatch xforms-insert/xforms-delete events.\n            // \"the replacement is performed by an XForms action that performs some\n            // combination of node insertion and deletion operations that are\n            // performed by the insert action (10.3 The insert Element) and the\n            // delete action\"\n\n            if (isDestinationRootElement) {\n                // Optimized insertion for instance root element replacement\n\n                // Handle new instance and associated event markings\n                final XFormsModel replaceModel = newInstance.getModel(containingDocument);\n                replaceModel.handleUpdatedInstance(newInstance);\n\n                // Dispatch xforms-delete event\n                // NOTE: Do NOT dispatch so we are compatible with the regular root element replacement\n                // (see below). In the future, we might want to dispatch this, especially if\n                // XFormsInsertAction dispatches xforms-delete when removing the root element\n                //updatedInstance.getXBLContainer(containingDocument).dispatchEvent(pipelineContext, new XFormsDeleteEvent(updatedInstance, Collections.singletonList(destinationNodeInfo), 1));\n\n                // Dispatch xforms-insert event\n                // NOTE: use the root node as insert location as it seems to make more sense than pointing to the earlier root element\n                newInstance.getXBLContainer(containingDocument).dispatchEvent(propertyContext,\n                    new XFormsInsertEvent(containingDocument, newInstance, Collections.singletonList((Item) newDocumentRootElement), null, newDocumentRootElement.getDocumentRoot(),\n                            \"after\", null, null, true));\n\n            } else {\n                // Generic insertion\n\n                final List<NodeInfo> destinationCollection = Collections.singletonList(destinationNodeInfo);\n\n                // Perform the insertion\n\n                // Insert before the target node, so that the position of the inserted node\n                // wrt its parent does not change after the target node is removed\n                XFormsInsertAction.doInsert(propertyContext, containingDocument, detailsLogger, \"before\",\n                        destinationCollection, destinationNodeInfo.getParent(),\n                        Collections.singletonList(newDocumentRootElement), 1, false, true);\n\n                if (!destinationNodeInfo.getParent().isSameNodeInfo(destinationNodeInfo.getDocumentRoot())) {\n                    // The node to replace is NOT a root element\n\n                    // Perform the deletion of the selected node\n                    XFormsDeleteAction.doDelete(propertyContext, containingDocument, detailsLogger, destinationCollection, 1, true);\n                }\n\n                // Perform model instance update\n                // Handle new instance and associated event markings\n                // NOTE: The inserted node NodeWrapper.index might be out of date at this point because:\n                // * doInsert() dispatches an event which might itself change the instance\n                // * doDelete() does as well\n                // Does this mean that we should check that the node is still where it should be?\n                final XFormsModel updatedModel = updatedInstance.getModel(containingDocument);\n                updatedModel.handleUpdatedInstance(updatedInstance);\n            }\n\n            // Dispatch xforms-submit-done\n            dispatchSubmitDone(propertyContext, connectionResult);\n        }\n    }","id":29611,"modified_method":"public Runnable replace(final PropertyContext propertyContext, final ConnectionResult connectionResult, XFormsModelSubmission.SubmissionParameters p, XFormsModelSubmission.SecondPassParameters p2) {\n\n        // Set new instance document to replace the one submitted\n\n        final XFormsInstance replaceInstanceNoTargetref = submission.findReplaceInstanceNoTargetref(p.refInstance);\n        if (replaceInstanceNoTargetref == null) {\n\n            // Replacement instance or node was specified but not found\n            //\n            // Not sure what's the right thing to do with 1.1, but this could be done\n            // as part of the model's static analysis if the instance value is not\n            // obtained through AVT, and dynamically otherwise. However, in the dynamic\n            // case, I think that this should be a (currently non-specified by XForms)\n            // xforms-binding-error.\n\n            submission.getXBLContainer(containingDocument).dispatchEvent(propertyContext, new XFormsBindingExceptionEvent(containingDocument, submission));\n            return null;\n        } else {\n\n            final NodeInfo destinationNodeInfo = submission.evaluateTargetRef(propertyContext,\n                    p.xpathContext, replaceInstanceNoTargetref, p.submissionElementContextItem);\n\n            if (destinationNodeInfo == null) {\n                // Throw target-error\n\n                // XForms 1.1: \"If the processing of the targetref attribute fails,\n                // then submission processing ends after dispatching the event\n                // xforms-submit-error with an error-type of target-error.\"\n\n                throw new XFormsSubmissionException(submission, \"targetref attribute doesn't point to an element for replace=\\\"instance\\\".\", \"processing targetref attribute\",\n                        new XFormsSubmitErrorEvent(containingDocument, propertyContext, submission, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR, connectionResult));\n            }\n\n            // This is the instance which is effectively going to be updated\n            final XFormsInstance updatedInstance = containingDocument.getInstanceForNode(destinationNodeInfo);\n            if (updatedInstance == null) {\n                throw new XFormsSubmissionException(submission, \"targetref attribute doesn't point to an element in an existing instance for replace=\\\"instance\\\".\", \"processing targetref attribute\",\n                        new XFormsSubmitErrorEvent(containingDocument, propertyContext, submission, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR, connectionResult));\n            }\n\n            // Whether the destination node is the root element of an instance\n            final boolean isDestinationRootElement = updatedInstance.getInstanceRootElementInfo().isSameNodeInfo(destinationNodeInfo);\n            if (p2.isReadonly && !isDestinationRootElement) {\n                // Only support replacing the root element of an instance when using a shared instance\n                throw new XFormsSubmissionException(submission, \"targetref attribute must point to instance root element when using read-only instance replacement.\", \"processing targetref attribute\",\n                        new XFormsSubmitErrorEvent(containingDocument, propertyContext, submission, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR, connectionResult));\n            }\n\n            final IndentedLogger detailsLogger = getDetailsLogger(p, p2);\n\n            // Obtain root element to insert\n            final NodeInfo newDocumentRootElement;\n            final XFormsInstance newInstance;\n            {\n                // Create resulting instance whether entire instance is replaced or not, because this:\n                // 1. Wraps a Document within a DocumentInfo if needed\n                // 2. Performs text nodes adjustments if needed\n                if (!p2.isReadonly) {\n                    // Resulting instance must not be read-only\n\n                    if (detailsLogger.isDebugEnabled())\n                        detailsLogger.logDebug(\"\", \"replacing instance with mutable instance\",\n                            \"instance\", updatedInstance.getEffectiveId());\n\n                    newInstance = new XFormsInstance(updatedInstance.getEffectiveModelId(), updatedInstance.getId(),\n                            (Document) resultingDocument, connectionResult.resourceURI, resultingRequestBodyHash, p2.username, p2.password,\n                            p2.isCache, p2.timeToLive, updatedInstance.getValidation(), p2.isHandleXInclude, XFormsProperties.isExposeXPathTypes(containingDocument));\n                } else {\n                    // Resulting instance must be read-only\n\n                    if (detailsLogger.isDebugEnabled())\n                        detailsLogger.logDebug(\"\", \"replacing instance with read-only instance\",\n                            \"instance\", updatedInstance.getEffectiveId());\n\n                    newInstance = new ReadonlyXFormsInstance(updatedInstance.getEffectiveModelId(), updatedInstance.getId(),\n                            (DocumentInfo) resultingDocument, connectionResult.resourceURI, resultingRequestBodyHash, p2.username, p2.password,\n                            p2.isCache, p2.timeToLive, updatedInstance.getValidation(), p2.isHandleXInclude, XFormsProperties.isExposeXPathTypes(containingDocument));\n                }\n                newDocumentRootElement = newInstance.getInstanceRootElementInfo();\n            }\n\n            // Perform insert/delete. This will dispatch xforms-insert/xforms-delete events.\n            // \"the replacement is performed by an XForms action that performs some\n            // combination of node insertion and deletion operations that are\n            // performed by the insert action (10.3 The insert Element) and the\n            // delete action\"\n\n            if (isDestinationRootElement) {\n                // Optimized insertion for instance root element replacement\n\n                // Handle new instance and associated event markings\n                final XFormsModel replaceModel = newInstance.getModel(containingDocument);\n                replaceModel.handleUpdatedInstance(newInstance);\n\n                // Dispatch xforms-delete event\n                // NOTE: Do NOT dispatch so we are compatible with the regular root element replacement\n                // (see below). In the future, we might want to dispatch this, especially if\n                // XFormsInsertAction dispatches xforms-delete when removing the root element\n                //updatedInstance.getXBLContainer(containingDocument).dispatchEvent(pipelineContext, new XFormsDeleteEvent(updatedInstance, Collections.singletonList(destinationNodeInfo), 1));\n\n                // Dispatch xforms-insert event\n                // NOTE: use the root node as insert location as it seems to make more sense than pointing to the earlier root element\n                newInstance.getXBLContainer(containingDocument).dispatchEvent(propertyContext,\n                    new XFormsInsertEvent(containingDocument, newInstance, Collections.singletonList((Item) newDocumentRootElement), null, newDocumentRootElement.getDocumentRoot(),\n                            \"after\", null, null, true));\n\n            } else {\n                // Generic insertion\n\n                final List<NodeInfo> destinationCollection = Collections.singletonList(destinationNodeInfo);\n\n                // Perform the insertion\n\n                // Insert before the target node, so that the position of the inserted node\n                // wrt its parent does not change after the target node is removed\n                XFormsInsertAction.doInsert(propertyContext, containingDocument, detailsLogger, \"before\",\n                        destinationCollection, destinationNodeInfo.getParent(),\n                        Collections.singletonList(newDocumentRootElement), 1, false, true);\n\n                if (!destinationNodeInfo.getParent().isSameNodeInfo(destinationNodeInfo.getDocumentRoot())) {\n                    // The node to replace is NOT a root element\n\n                    // Perform the deletion of the selected node\n                    XFormsDeleteAction.doDelete(propertyContext, containingDocument, detailsLogger, destinationCollection, 1, true);\n                }\n\n                // Perform model instance update\n                // Handle new instance and associated event markings\n                // NOTE: The inserted node NodeWrapper.index might be out of date at this point because:\n                // * doInsert() dispatches an event which might itself change the instance\n                // * doDelete() does as well\n                // Does this mean that we should check that the node is still where it should be?\n                final XFormsModel updatedModel = updatedInstance.getModel(containingDocument);\n                updatedModel.handleUpdatedInstance(updatedInstance);\n            }\n\n            // Dispatch xforms-submit-done\n            return dispatchSubmitDone(propertyContext, connectionResult);\n        }\n    }","commit_id":"a770782b45e5d9c5dd2ed5a938c492cdfd5e3238","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void replace(PropertyContext propertyContext, ConnectionResult connectionResult, XFormsModelSubmission.SubmissionParameters p, XFormsModelSubmission.SecondPassParameters p2) {\n        // Just notify that processing is terminated by dispatching xforms-submit-done\n        dispatchSubmitDone(propertyContext, connectionResult);\n    }","id":29612,"modified_method":"public Runnable replace(PropertyContext propertyContext, ConnectionResult connectionResult, XFormsModelSubmission.SubmissionParameters p, XFormsModelSubmission.SecondPassParameters p2) {\n        // Just notify that processing is terminated by dispatching xforms-submit-done\n        return dispatchSubmitDone(propertyContext, connectionResult);\n    }","commit_id":"a770782b45e5d9c5dd2ed5a938c492cdfd5e3238","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void replace(PropertyContext propertyContext, ConnectionResult connectionResult, XFormsModelSubmission.SubmissionParameters p, XFormsModelSubmission.SecondPassParameters p2) throws IOException {\n\n        final ExternalContext externalContext = (ExternalContext) propertyContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n        final ExternalContext.Response response = externalContext.getResponse();\n\n        // Forward headers to response\n        connectionResult.forwardHeaders(response);\n\n        // Forward redirect\n        response.setStatus(connectionResult.statusCode);\n    }","id":29613,"modified_method":"public Runnable replace(PropertyContext propertyContext, ConnectionResult connectionResult, XFormsModelSubmission.SubmissionParameters p, XFormsModelSubmission.SecondPassParameters p2) throws IOException {\n\n        final ExternalContext externalContext = (ExternalContext) propertyContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n        final ExternalContext.Response response = externalContext.getResponse();\n\n        // Forward headers to response\n        connectionResult.forwardHeaders(response);\n\n        // Forward redirect\n        response.setStatus(connectionResult.statusCode);\n\n        return null;\n    }","commit_id":"a770782b45e5d9c5dd2ed5a938c492cdfd5e3238","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void replace(PropertyContext propertyContext, ConnectionResult connectionResult, XFormsModelSubmission.SubmissionParameters p, XFormsModelSubmission.SecondPassParameters p2) throws IOException {\n\n        // XForms 1.1: \"If the replace attribute contains the value \"text\" and the submission response conforms to an\n        // XML mediatype (as defined by the content type specifiers in [RFC 3023]) or a text media type (as defined by\n        // a content type specifier of text/*), then the response data is encoded as text and replaces the content of\n        // the replacement target node.\"\n\n        // Find target location\n        final NodeInfo destinationNodeInfo;\n        if (submission.getTargetref() != null) {\n            // Evaluate destination node\n            final Object destinationObject\n                    = XPathCache.evaluateSingle(propertyContext, p.xpathContext, p.refNodeInfo, submission.getTargetref());\n\n            if (destinationObject instanceof NodeInfo) {\n                destinationNodeInfo = (NodeInfo) destinationObject;\n                if (destinationNodeInfo.getNodeKind() != org.w3c.dom.Document.ELEMENT_NODE && destinationNodeInfo.getNodeKind() != org.w3c.dom.Document.ATTRIBUTE_NODE) {\n                    // Throw target-error\n\n                    // XForms 1.1: \"If the processing of the targetref attribute fails,\n                    // then submission processing ends after dispatching the event\n                    // xforms-submit-error with an error-type of target-error.\"\n                    throw new XFormsSubmissionException(submission, \"targetref attribute doesn't point to an element or attribute for replace=\\\"text\\\".\", \"processing targetref attribute\",\n                            new XFormsSubmitErrorEvent(containingDocument, propertyContext, submission, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR, connectionResult));\n                }\n            } else {\n                // Throw target-error\n                // TODO: also do this for readonly situation\n\n                // XForms 1.1: \"If the processing of the targetref attribute fails, then\n                // submission processing ends after dispatching the event\n                // xforms-submit-error with an error-type of target-error.\"\n                throw new XFormsSubmissionException(submission, \"targetref attribute doesn't point to a node for replace=\\\"text\\\".\", \"processing targetref attribute\",\n                        new XFormsSubmitErrorEvent(containingDocument, propertyContext, submission, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR, connectionResult));\n            }\n        } else {\n            // Handle default destination\n            destinationNodeInfo = submission.findReplaceInstanceNoTargetref(p.refInstance).getInstanceRootElementInfo();\n        }\n\n        // Set value into the instance\n        // NOTE: Here we decided to use the actions logger, by compatibility with xforms:setvalue. Anything we would like to log in \"submission\" mode?\n        XFormsSetvalueAction.doSetValue(propertyContext, containingDocument, containingDocument.getIndentedLogger(XFormsActions.LOGGING_CATEGORY), submission, destinationNodeInfo, responseBody, null, false);\n\n        // Dispatch xforms-submit-done\n        dispatchSubmitDone(propertyContext, connectionResult);\n    }","id":29614,"modified_method":"public Runnable replace(PropertyContext propertyContext, ConnectionResult connectionResult, XFormsModelSubmission.SubmissionParameters p, XFormsModelSubmission.SecondPassParameters p2) throws IOException {\n\n        // XForms 1.1: \"If the replace attribute contains the value \"text\" and the submission response conforms to an\n        // XML mediatype (as defined by the content type specifiers in [RFC 3023]) or a text media type (as defined by\n        // a content type specifier of text/*), then the response data is encoded as text and replaces the content of\n        // the replacement target node.\"\n\n        // Find target location\n        final NodeInfo destinationNodeInfo;\n        if (submission.getTargetref() != null) {\n            // Evaluate destination node\n            final Object destinationObject\n                    = XPathCache.evaluateSingle(propertyContext, p.xpathContext, p.refNodeInfo, submission.getTargetref());\n\n            if (destinationObject instanceof NodeInfo) {\n                destinationNodeInfo = (NodeInfo) destinationObject;\n                if (destinationNodeInfo.getNodeKind() != org.w3c.dom.Document.ELEMENT_NODE && destinationNodeInfo.getNodeKind() != org.w3c.dom.Document.ATTRIBUTE_NODE) {\n                    // Throw target-error\n\n                    // XForms 1.1: \"If the processing of the targetref attribute fails,\n                    // then submission processing ends after dispatching the event\n                    // xforms-submit-error with an error-type of target-error.\"\n                    throw new XFormsSubmissionException(submission, \"targetref attribute doesn't point to an element or attribute for replace=\\\"text\\\".\", \"processing targetref attribute\",\n                            new XFormsSubmitErrorEvent(containingDocument, propertyContext, submission, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR, connectionResult));\n                }\n            } else {\n                // Throw target-error\n                // TODO: also do this for readonly situation\n\n                // XForms 1.1: \"If the processing of the targetref attribute fails, then\n                // submission processing ends after dispatching the event\n                // xforms-submit-error with an error-type of target-error.\"\n                throw new XFormsSubmissionException(submission, \"targetref attribute doesn't point to a node for replace=\\\"text\\\".\", \"processing targetref attribute\",\n                        new XFormsSubmitErrorEvent(containingDocument, propertyContext, submission, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR, connectionResult));\n            }\n        } else {\n            // Handle default destination\n            destinationNodeInfo = submission.findReplaceInstanceNoTargetref(p.refInstance).getInstanceRootElementInfo();\n        }\n\n        // Set value into the instance\n        // NOTE: Here we decided to use the actions logger, by compatibility with xforms:setvalue. Anything we would like to log in \"submission\" mode?\n        XFormsSetvalueAction.doSetValue(propertyContext, containingDocument, containingDocument.getIndentedLogger(XFormsActions.LOGGING_CATEGORY), submission, destinationNodeInfo, responseBody, null, false);\n\n        // Dispatch xforms-submit-done\n        return dispatchSubmitDone(propertyContext, connectionResult);\n    }","commit_id":"a770782b45e5d9c5dd2ed5a938c492cdfd5e3238","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void doSubmitReplace(PropertyContext propertyContext, XFormsEvent event) {\n        final XXFormsSubmitReplaceEvent replaceEvent = (XXFormsSubmitReplaceEvent) event;\n\n        // Big bag of initial runtime parameters\n        final SubmissionParameters p = new SubmissionParameters(propertyContext, event.getEventName());\n        final SecondPassParameters p2 = new SecondPassParameters(propertyContext, p);\n        final SubmissionResult submissionResult = replaceEvent.getSubmissionResult();\n        handleSubmissionResult(propertyContext, p, p2, submissionResult);\n    }","id":29615,"modified_method":"private void doSubmitReplace(PropertyContext propertyContext, XFormsEvent event) {\n        final XXFormsSubmitReplaceEvent replaceEvent = (XXFormsSubmitReplaceEvent) event;\n\n        // Big bag of initial runtime parameters\n        final SubmissionParameters p = new SubmissionParameters(propertyContext, event.getEventName());\n        final SecondPassParameters p2 = new SecondPassParameters(propertyContext, p);\n        final SubmissionResult submissionResult = replaceEvent.getSubmissionResult();\n\n        final Runnable submitDoneRunnable = handleSubmissionResult(propertyContext, p, p2, submissionResult);\n\n        // Execute submit done runnable if any\n        if (submitDoneRunnable != null) {\n            // Do this outside the handleSubmissionResult catch block so that if a problem occurs during dispatching\n            // xforms-submit-done we don't dispatch xforms-submit-error (which would be illegal)\n            submitDoneRunnable.run();\n        }\n    }","commit_id":"a770782b45e5d9c5dd2ed5a938c492cdfd5e3238","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void doSubmit(PropertyContext propertyContext, XFormsEvent event) {\n        containingDocument.setGotSubmission();\n\n        final IndentedLogger indentedLogger = getIndentedLogger();\n\n        // Variables declared here as they are used in a catch/finally block\n        SubmissionParameters p = null;\n        String resolvedActionOrResource = null;\n\n        // Make sure submission element info is extracted\n        extractSubmissionElement();\n\n        try {\n            // Big bag of initial runtime parameters\n            p = new SubmissionParameters(propertyContext, event.getEventName());\n\n            if (indentedLogger.isDebugEnabled()) {\n                final String message = p.isDeferredSubmissionFirstPass ? \"submission first pass\" : p.isDeferredSubmissionSecondPass ? \"submission second pass\" : \"submission\";\n                indentedLogger.startHandleOperation(\"\", message, \"id\", getEffectiveId());\n            }\n\n            if (p.isDeferredSubmissionSecondPass)\n                containingDocument.setGotSubmissionSecondPass();\n\n            // If a submission requiring a second pass was already set, then we ignore a subsequent submission but\n            // issue a warning\n            {\n                final XFormsModelSubmission existingSubmission = containingDocument.getClientActiveSubmission();\n                if (p.isDeferredSubmission && existingSubmission != null) {\n                    indentedLogger.logWarning(\"\", \"another submission requiring a second pass already exists\",\n                            \"existing submission\", existingSubmission.getEffectiveId(),\n                            \"new submission\", this.getEffectiveId());\n                    return;\n                }\n            }\n\n            /* ***** Update data model ****************************************************************************** */\n\n            // \"The data model is updated\"\n            final XFormsModel modelForInstance;\n            if (p.refInstance != null) {\n                modelForInstance = p.refInstance.getModel(containingDocument);\n                {\n                    // NOTE: XForms 1.1 seems to say this should happen regardless of whether we serialize or not. If\n                    // the instance is not serialized and if no instance data is otherwise used for the submission,\n                    // this seems however unneeded.\n\n                    // TODO: XForms 1.1 says that we should rebuild/recalculate the \"model containing this submission\".\n                    modelForInstance.rebuildRecalculateIfNeeded(propertyContext);\n                }\n            } else {\n                // Case where no instance was found\n                modelForInstance = null;\n            }\n\n            /* ***** Handle deferred submission ********************************************************************* */\n\n            // Resolve the target AVT because XFormsServer requires it for deferred submission\n            resolvedXXFormsTarget = XFormsUtils.resolveAttributeValueTemplates(propertyContext, p.xpathContext, p.refNodeInfo, avtXXFormsTarget);\n\n            // Deferred submission: end of the first pass\n            if (p.isDeferredSubmissionFirstPass) {\n\n                // Create document to submit here because in case of error, an Ajax response will still be produced\n                if (serialize) {\n                    createDocumentToSubmit(propertyContext, indentedLogger, p.refNodeInfo, p.refInstance, modelForInstance, p.resolvedValidate, p.resolvedRelevant);\n                }\n\n                // When replace=\"all\", we wait for the submission of an XXFormsSubmissionEvent from the client\n                containingDocument.setClientActiveSubmission(this);\n                return;\n            }\n\n            /* ***** Submission second pass ************************************************************************* */\n\n            // Compute parameters only needed during second pass\n            final SecondPassParameters p2 = new SecondPassParameters(propertyContext, p);\n            resolvedActionOrResource = p2.actionOrResource; // in case of exception\n\n            /* ***** Serialization ********************************************************************************** */\n\n            // Get serialization requested from @method and @serialization attributes\n            final String requestedSerialization = getRequestedSerialization(p2.serialization, p.resolvedMethod);\n\n            final Document documentToSubmit;\n            if (serialize) {\n                // Handle uploaded files if any\n                final Element filesElement = (event instanceof XXFormsSubmitEvent) ? ((XXFormsSubmitEvent) event).getFilesElement() : null;\n                if (filesElement != null) {\n                    // Handle all file elements\n\n                    // NOTE: We used to request handling of temp files only if NOT replace=\"all\". Guessing the\n                    // rationale was that user would be navigating to new page anyway. However, this was not a\n                    // correct assumption: the page might load in another window/tab, result in an file being\n                    // downloaded, or simply the file might be used by the next page.\n                    XFormsUploadControl.handleFileElement(propertyContext, containingDocument, filesElement, null, true);\n                }\n\n                // Check if a submission requires file upload information\n                if (requestedSerialization.startsWith(\"multipart/\")) {\n                    // Annotate before re-rooting/pruning\n                    XFormsSubmissionUtils.annotateBoundRelevantUploadControls(propertyContext, containingDocument, p.refInstance);\n                }\n\n                // Create document to submit\n                documentToSubmit = createDocumentToSubmit(propertyContext, indentedLogger, p.refNodeInfo, p.refInstance, modelForInstance, p.resolvedValidate, p.resolvedRelevant);\n\n            } else {\n                // Don't recreate document\n                documentToSubmit = null;\n            }\n\n            final String overriddenSerializedData;\n            if (serialize && !p.isDeferredSubmissionSecondPassReplaceAll) { // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                // Fire xforms-submit-serialize\n\n                // \"The event xforms-submit-serialize is dispatched. If the submission-body property of the event\n                // is changed from the initial value of empty string, then the content of the submission-body\n                // property string is used as the submission serialization. Otherwise, the submission serialization\n                // consists of a serialization of the selected instance data according to the rules stated at 11.9\n                // Submission Options.\"\n\n                final XFormsSubmitSerializeEvent serializeEvent = new XFormsSubmitSerializeEvent(containingDocument, XFormsModelSubmission.this, p.refNodeInfo, requestedSerialization);\n                container.dispatchEvent(propertyContext, serializeEvent);\n\n                // TODO: rest of submission should happen upon default action of event\n\n                overriddenSerializedData = serializeEvent.getSerializedData();\n            } else {\n                overriddenSerializedData = null;\n            }\n\n            // Serialize\n            final SerializationParameters sp = new SerializationParameters(propertyContext, p, p2,\n                    requestedSerialization, documentToSubmit, overriddenSerializedData);\n\n            /* ***** Execute submission ***************************************************************************** */\n\n            // Result information\n            SubmissionResult submissionResult = null;\n\n            /* ***** Submission connection ************************************************************************** */\n\n            // Iterate through submissions and run the first match\n            for (Submission submission: submissions) {\n                if (submission.isMatch(propertyContext, p, p2, sp)) {\n                    if (indentedLogger.isDebugEnabled())\n                        indentedLogger.startHandleOperation(\"\", \"connecting\", \"type\", submission.getType());\n                    try {\n                        submissionResult = submission.connect(propertyContext, p, p2, sp);\n                        break;\n                    } finally {\n                        if (indentedLogger.isDebugEnabled())\n                            indentedLogger.endHandleOperation(\"submitted asynchronously\", Boolean.toString(submissionResult == null));\n                    }\n                }\n            }\n\n            /* ***** Submission result processing ******************************************************************* */\n            handleSubmissionResult(propertyContext, p, p2, submissionResult);\n\n        } catch (Throwable throwable) {\n            /* ***** Handle errors ********************************************************************************** */\n            if (p != null && p.isDeferredSubmissionSecondPassReplaceAll && XFormsProperties.isOptimizeLocalSubmissionForward(containingDocument)) {\n                // It doesn't serve any purpose here to dispatch an event, so we just propagate the exception\n                throw new XFormsSubmissionException(this, throwable, \"Error while processing xforms:submission\", \"processing submission\");\n            } else {\n                // Any exception will cause an error event to be dispatched\n                sendSubmitError(propertyContext, resolvedActionOrResource, throwable);\n            }\n        } finally {\n            // Log total time spent in submission\n            if (indentedLogger.isDebugEnabled()) {\n                indentedLogger.endHandleOperation();\n            }\n        }\n    }","id":29616,"modified_method":"private void doSubmit(PropertyContext propertyContext, XFormsEvent event) {\n        containingDocument.setGotSubmission();\n\n        final IndentedLogger indentedLogger = getIndentedLogger();\n\n        // Variables declared here as they are used in a catch/finally block\n        SubmissionParameters p = null;\n        String resolvedActionOrResource = null;\n\n        // Make sure submission element info is extracted\n        extractSubmissionElement();\n\n        Runnable submitDoneRunnable = null;\n        try {\n            try {\n                // Big bag of initial runtime parameters\n                p = new SubmissionParameters(propertyContext, event.getEventName());\n\n                if (indentedLogger.isDebugEnabled()) {\n                    final String message = p.isDeferredSubmissionFirstPass ? \"submission first pass\" : p.isDeferredSubmissionSecondPass ? \"submission second pass\" : \"submission\";\n                    indentedLogger.startHandleOperation(\"\", message, \"id\", getEffectiveId());\n                }\n\n                if (p.isDeferredSubmissionSecondPass)\n                    containingDocument.setGotSubmissionSecondPass();\n\n                // If a submission requiring a second pass was already set, then we ignore a subsequent submission but\n                // issue a warning\n                {\n                    final XFormsModelSubmission existingSubmission = containingDocument.getClientActiveSubmission();\n                    if (p.isDeferredSubmission && existingSubmission != null) {\n                        indentedLogger.logWarning(\"\", \"another submission requiring a second pass already exists\",\n                                \"existing submission\", existingSubmission.getEffectiveId(),\n                                \"new submission\", this.getEffectiveId());\n                        return;\n                    }\n                }\n\n                /* ***** Update data model ****************************************************************************** */\n\n                // \"The data model is updated\"\n                final XFormsModel modelForInstance;\n                if (p.refInstance != null) {\n                    modelForInstance = p.refInstance.getModel(containingDocument);\n                    {\n                        // NOTE: XForms 1.1 seems to say this should happen regardless of whether we serialize or not. If\n                        // the instance is not serialized and if no instance data is otherwise used for the submission,\n                        // this seems however unneeded.\n\n                        // TODO: XForms 1.1 says that we should rebuild/recalculate the \"model containing this submission\".\n                        modelForInstance.rebuildRecalculateIfNeeded(propertyContext);\n                    }\n                } else {\n                    // Case where no instance was found\n                    modelForInstance = null;\n                }\n\n                /* ***** Handle deferred submission ********************************************************************* */\n\n                // Resolve the target AVT because XFormsServer requires it for deferred submission\n                resolvedXXFormsTarget = XFormsUtils.resolveAttributeValueTemplates(propertyContext, p.xpathContext, p.refNodeInfo, avtXXFormsTarget);\n\n                // Deferred submission: end of the first pass\n                if (p.isDeferredSubmissionFirstPass) {\n\n                    // Create document to submit here because in case of error, an Ajax response will still be produced\n                    if (serialize) {\n                        createDocumentToSubmit(propertyContext, indentedLogger, p.refNodeInfo, p.refInstance, modelForInstance, p.resolvedValidate, p.resolvedRelevant);\n                    }\n\n                    // When replace=\"all\", we wait for the submission of an XXFormsSubmissionEvent from the client\n                    containingDocument.setClientActiveSubmission(this);\n                    return;\n                }\n\n                /* ***** Submission second pass ************************************************************************* */\n\n                // Compute parameters only needed during second pass\n                final SecondPassParameters p2 = new SecondPassParameters(propertyContext, p);\n                resolvedActionOrResource = p2.actionOrResource; // in case of exception\n\n                /* ***** Serialization ********************************************************************************** */\n\n                // Get serialization requested from @method and @serialization attributes\n                final String requestedSerialization = getRequestedSerialization(p2.serialization, p.resolvedMethod);\n\n                final Document documentToSubmit;\n                if (serialize) {\n                    // Handle uploaded files if any\n                    final Element filesElement = (event instanceof XXFormsSubmitEvent) ? ((XXFormsSubmitEvent) event).getFilesElement() : null;\n                    if (filesElement != null) {\n                        // Handle all file elements\n\n                        // NOTE: We used to request handling of temp files only if NOT replace=\"all\". Guessing the\n                        // rationale was that user would be navigating to new page anyway. However, this was not a\n                        // correct assumption: the page might load in another window/tab, result in an file being\n                        // downloaded, or simply the file might be used by the next page.\n                        XFormsUploadControl.handleFileElement(propertyContext, containingDocument, filesElement, null, true);\n                    }\n\n                    // Check if a submission requires file upload information\n                    if (requestedSerialization.startsWith(\"multipart/\")) {\n                        // Annotate before re-rooting/pruning\n                        XFormsSubmissionUtils.annotateBoundRelevantUploadControls(propertyContext, containingDocument, p.refInstance);\n                    }\n\n                    // Create document to submit\n                    documentToSubmit = createDocumentToSubmit(propertyContext, indentedLogger, p.refNodeInfo, p.refInstance, modelForInstance, p.resolvedValidate, p.resolvedRelevant);\n\n                } else {\n                    // Don't recreate document\n                    documentToSubmit = null;\n                }\n\n                final String overriddenSerializedData;\n                if (serialize && !p.isDeferredSubmissionSecondPassReplaceAll) { // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                    // Fire xforms-submit-serialize\n\n                    // \"The event xforms-submit-serialize is dispatched. If the submission-body property of the event\n                    // is changed from the initial value of empty string, then the content of the submission-body\n                    // property string is used as the submission serialization. Otherwise, the submission serialization\n                    // consists of a serialization of the selected instance data according to the rules stated at 11.9\n                    // Submission Options.\"\n\n                    final XFormsSubmitSerializeEvent serializeEvent = new XFormsSubmitSerializeEvent(containingDocument, XFormsModelSubmission.this, p.refNodeInfo, requestedSerialization);\n                    container.dispatchEvent(propertyContext, serializeEvent);\n\n                    // TODO: rest of submission should happen upon default action of event\n\n                    overriddenSerializedData = serializeEvent.getSerializedData();\n                } else {\n                    overriddenSerializedData = null;\n                }\n\n                // Serialize\n                final SerializationParameters sp = new SerializationParameters(propertyContext, p, p2,\n                        requestedSerialization, documentToSubmit, overriddenSerializedData);\n\n                /* ***** Execute submission ***************************************************************************** */\n\n                // Result information\n                SubmissionResult submissionResult = null;\n\n                /* ***** Submission connection ************************************************************************** */\n\n                // Iterate through submissions and run the first match\n                for (Submission submission: submissions) {\n                    if (submission.isMatch(propertyContext, p, p2, sp)) {\n                        if (indentedLogger.isDebugEnabled())\n                            indentedLogger.startHandleOperation(\"\", \"connecting\", \"type\", submission.getType());\n                        try {\n                            submissionResult = submission.connect(propertyContext, p, p2, sp);\n                            break;\n                        } finally {\n                            if (indentedLogger.isDebugEnabled())\n                                indentedLogger.endHandleOperation(\"submitted asynchronously\", Boolean.toString(submissionResult == null));\n                        }\n                    }\n                }\n\n                /* ***** Submission result processing ******************************************************************* */\n                submitDoneRunnable = handleSubmissionResult(propertyContext, p, p2, submissionResult);\n\n            } catch (Throwable throwable) {\n                /* ***** Handle errors ********************************************************************************** */\n                if (p != null && p.isDeferredSubmissionSecondPassReplaceAll && XFormsProperties.isOptimizeLocalSubmissionForward(containingDocument)) {\n                    // It doesn't serve any purpose here to dispatch an event, so we just propagate the exception\n                    throw new XFormsSubmissionException(this, throwable, \"Error while processing xforms:submission\", \"processing submission\");\n                } else {\n                    // Any exception will cause an error event to be dispatched\n                    sendSubmitError(propertyContext, resolvedActionOrResource, throwable);\n                }\n            }\n        } finally {\n            // Log total time spent in submission\n            if (indentedLogger.isDebugEnabled()) {\n                indentedLogger.endHandleOperation();\n            }\n        }\n\n        // Execute submit done runnable if any\n        if (submitDoneRunnable != null) {\n            // Do this outside the above catch block so that if a problem occurs during dispatching xforms-submit-done\n            // we don't dispatch xforms-submit-error (which would be illegal)\n            submitDoneRunnable.run();\n        }\n    }","commit_id":"a770782b45e5d9c5dd2ed5a938c492cdfd5e3238","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void handleSubmissionResult(PropertyContext propertyContext, SubmissionParameters p, SecondPassParameters p2, SubmissionResult submissionResult) {\n        if (submissionResult != null) { // submissionResult is null in case the submission is running asynchronously\n            try {\n                final IndentedLogger indentedLogger = getIndentedLogger();\n                if (indentedLogger.isDebugEnabled())\n                    indentedLogger.startHandleOperation(\"\", \"handling result\");\n                try {\n                    // Get fresh XPath context because function context might have changed\n                    // NOTE: It is not ideal that we have to do this!\n                    p.initializeXPathContext(propertyContext);\n                    // Process the different types of response\n                    if (submissionResult.getReplacer() != null) {\n                        // Replacer provided, perform replacement\n                        submissionResult.getReplacer().replace(propertyContext, submissionResult.getConnectionResult(), p, p2);\n                    } else if (submissionResult.getThrowable() != null) {\n                        // Propagate throwable, which might have come from a separate thread\n                        sendSubmitError(propertyContext, submissionResult.getThrowable(), submissionResult);\n                    } else {\n                        // Should not happen\n                    }\n                } finally {\n                    if (indentedLogger.isDebugEnabled())\n                        indentedLogger.endHandleOperation();\n\n                    // Clean-up result\n                    submissionResult.close();\n                }\n            } catch (Throwable throwable) {\n                // Any exception will cause an error event to be dispatched\n                sendSubmitError(propertyContext, throwable, submissionResult);\n            }\n        }\n    }","id":29617,"modified_method":"private Runnable handleSubmissionResult(PropertyContext propertyContext, SubmissionParameters p, SecondPassParameters p2, SubmissionResult submissionResult) {\n        Runnable submitDoneRunnable = null;\n        if (submissionResult != null) { // submissionResult is null in case the submission is running asynchronously\n            try {\n                final IndentedLogger indentedLogger = getIndentedLogger();\n                if (indentedLogger.isDebugEnabled())\n                    indentedLogger.startHandleOperation(\"\", \"handling result\");\n                try {\n                    // Get fresh XPath context because function context might have changed\n                    // NOTE: It is not ideal that we have to do this!\n                    p.initializeXPathContext(propertyContext);\n                    // Process the different types of response\n                    if (submissionResult.getReplacer() != null) {\n                        // Replacer provided, perform replacement\n                        submitDoneRunnable = submissionResult.getReplacer().replace(propertyContext, submissionResult.getConnectionResult(), p, p2);\n                    } else if (submissionResult.getThrowable() != null) {\n                        // Propagate throwable, which might have come from a separate thread\n                        sendSubmitError(propertyContext, submissionResult.getThrowable(), submissionResult);\n                    } else {\n                        // Should not happen\n                    }\n                } finally {\n                    if (indentedLogger.isDebugEnabled())\n                        indentedLogger.endHandleOperation();\n\n                    // Clean-up result\n                    submissionResult.close();\n                }\n            } catch (Throwable throwable) {\n                // Any exception will cause an error event to be dispatched\n                sendSubmitError(propertyContext, throwable, submissionResult);\n            }\n        }\n        return submitDoneRunnable;\n    }","commit_id":"a770782b45e5d9c5dd2ed5a938c492cdfd5e3238","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n\t * Determines if there is a type converter available in the specified context and attempts to use it to convert the\n\t * supplied value to the specified type. Throws an exception if conversion is not possible.\n\t * @param context the evaluation context that may define a type converter\n\t * @param typedValue the value to convert and a type descriptor describing it\n\t * @param targetType the type to attempt conversion to\n\t * @return the converted value\n\t * @throws EvaluationException if there is a problem during conversion or conversion of the value to the specified\n\t * type is not supported\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> T convertTypedValue(EvaluationContext context, TypedValue typedValue, Class<T> targetType) {\n\t\tObject value = typedValue.getValue();\n\t\tif (targetType == null || ClassUtils.isAssignableValue(targetType, value)) {\n\t\t\treturn (T) value;\n\t\t}\n\t\tif (context != null) {\n\t\t\treturn (T) context.getTypeConverter().convertValue(value, typedValue.getTypeDescriptor(), TypeDescriptor.valueOf(targetType));\n\t\t}\n\t\tthrow new EvaluationException(\"Cannot convert value '\" + value + \"' to type '\" + targetType.getName() + \"'\");\n\t}","id":29618,"modified_method":"/**\n\t * Determines if there is a type converter available in the specified context and attempts to use it to convert the\n\t * supplied value to the specified type. Throws an exception if conversion is not possible.\n\t * @param context the evaluation context that may define a type converter\n\t * @param typedValue the value to convert and a type descriptor describing it\n\t * @param targetType the type to attempt conversion to\n\t * @return the converted value\n\t * @throws EvaluationException if there is a problem during conversion or conversion of the value to the specified\n\t * type is not supported\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> T convertTypedValue(EvaluationContext context, TypedValue typedValue, Class<T> targetType) {\n\t\tObject value = typedValue.getValue();\n\t\tif ((targetType == null) || (value != null && ClassUtils.isAssignableValue(targetType, value))) {\n\t\t\treturn (T) value;\n\t\t}\n\t\tif (context != null) {\n\t\t\treturn (T) context.getTypeConverter().convertValue(value, typedValue.getTypeDescriptor(), TypeDescriptor.valueOf(targetType));\n\t\t}\n\t\tthrow new EvaluationException(\"Cannot convert value '\" + value + \"' to type '\" + targetType.getName() + \"'\");\n\t}","commit_id":"759c9b35cd4d74aff7b912324751b334bf598f47","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tboolean leftValue;\n\t\tboolean rightValue;\n\n\t\ttry {\n\t\t\tTypedValue typedValue = getLeftOperand().getValueInternal(state);\n\t\t\tthis.assertTypedValueNotNull(typedValue);\n\t\t\tleftValue = (Boolean)state.convertValue(typedValue, TypeDescriptor.valueOf(Boolean.class));\n\t\t}\n\t\tcatch (SpelEvaluationException ee) {\n\t\t\tee.setPosition(getLeftOperand().getStartPosition());\n\t\t\tthrow ee;\n\t\t}\n\n\t\tif (leftValue == false) {\n\t\t\treturn BooleanTypedValue.forValue(false); // no need to evaluate right operand\n\t\t}\n\n\t\ttry {\n\t\t\tTypedValue typedValue = getRightOperand().getValueInternal(state);\n\t\t\tthis.assertTypedValueNotNull(typedValue);\n\t\t\trightValue = (Boolean)state.convertValue(typedValue, TypeDescriptor.valueOf(Boolean.class));\n\t\t}\n\t\tcatch (SpelEvaluationException ee) {\n\t\t\tee.setPosition(getRightOperand().getStartPosition());\n\t\t\tthrow ee;\n\t\t}\n\n\t\treturn /* leftValue && */BooleanTypedValue.forValue(rightValue);\n\t}","id":29619,"modified_method":"@Override\n\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tif (getBooleanValue(state, getLeftOperand()) == false) {\n\t\t\t// no need to evaluate right operand\n\t\t\treturn BooleanTypedValue.FALSE;\n\t\t}\n\t\treturn BooleanTypedValue.forValue(getBooleanValue(state, getRightOperand()));\n\t}","commit_id":"759c9b35cd4d74aff7b912324751b334bf598f47","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void assertTypedValueNotNull(TypedValue typedValue) {\n\t\tif (TypedValue.NULL.equals(typedValue)) {\n\t\t\tthrow new SpelEvaluationException(SpelMessage.TYPE_CONVERSION_ERROR, \"null\", \"boolean\");\n\t\t}\n\t}","id":29620,"modified_method":"private void assertValueNotNull(Boolean value) {\n\t\tif (value == null) {\n\t\t\tthrow new SpelEvaluationException(SpelMessage.TYPE_CONVERSION_ERROR, \"null\", \"boolean\");\n\t\t}\n\t}","commit_id":"759c9b35cd4d74aff7b912324751b334bf598f47","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void assertTypedValueNotNull(TypedValue typedValue) {\n\t\tif (TypedValue.NULL.equals(typedValue)) {\n\t\t\tthrow new SpelEvaluationException(SpelMessage.TYPE_CONVERSION_ERROR, \"null\", \"boolean\");\n\t\t}\n\t}","id":29621,"modified_method":"private void assertValueNotNull(Boolean value) {\n\t\tif (value == null) {\n\t\t\tthrow new SpelEvaluationException(SpelMessage.TYPE_CONVERSION_ERROR, \"null\", \"boolean\");\n\t\t}\n\t}","commit_id":"759c9b35cd4d74aff7b912324751b334bf598f47","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic BooleanTypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tboolean leftValue;\n\t\tboolean rightValue;\n\t\ttry {\n\t\t\tTypedValue typedValue = getLeftOperand().getValueInternal(state);\n\t\t\tthis.assertTypedValueNotNull(typedValue);\n\t\t\tleftValue = (Boolean)state.convertValue(typedValue, TypeDescriptor.valueOf(Boolean.class));\n\t\t}\n\t\tcatch (SpelEvaluationException see) {\n\t\t\tsee.setPosition(getLeftOperand().getStartPosition());\n\t\t\tthrow see;\n\t\t}\n\n\t\tif (leftValue == true) {\n\t\t\treturn BooleanTypedValue.TRUE; // no need to evaluate right operand\n\t\t}\n\n\t\ttry {\n\t\t\tTypedValue typedValue = getRightOperand().getValueInternal(state);\n\t\t\tthis.assertTypedValueNotNull(typedValue);\n\t\t\trightValue = (Boolean)state.convertValue(typedValue, TypeDescriptor.valueOf(Boolean.class));\n\t\t}\n\t\tcatch (SpelEvaluationException see) {\n\t\t\tsee.setPosition(getRightOperand().getStartPosition()); // TODO end positions here and in similar situations\n\t\t\tthrow see;\n\t\t}\n\n\t\treturn BooleanTypedValue.forValue(leftValue || rightValue);\n\t}","id":29622,"modified_method":"@Override\n\tpublic BooleanTypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tif (getBooleanValue(state, getLeftOperand())) {\n\t\t\t// no need to evaluate right operand\n\t\t\treturn BooleanTypedValue.TRUE;\n\t\t}\n\t\treturn BooleanTypedValue.forValue(getBooleanValue(state, getRightOperand()));\n\t}","commit_id":"759c9b35cd4d74aff7b912324751b334bf598f47","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic BooleanTypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\ttry {\n\t\t\tTypedValue typedValue = children[0].getValueInternal(state);\n\t\t\tif (TypedValue.NULL.equals(typedValue)) {\n\t\t\t\tthrow new SpelEvaluationException(SpelMessage.TYPE_CONVERSION_ERROR, \"null\", \"boolean\");\n\t\t\t}\n\t\t\tboolean value = (Boolean) state.convertValue(typedValue, TypeDescriptor.valueOf(Boolean.class));\n\t\t\treturn BooleanTypedValue.forValue(!value);\n\t\t}\n\t\tcatch (SpelEvaluationException see) {\n\t\t\tsee.setPosition(getChild(0).getStartPosition());\n\t\t\tthrow see;\n\t\t}\n\t}","id":29623,"modified_method":"@Override\n\tpublic BooleanTypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\ttry {\n\t\t\tBoolean value = children[0].getValue(state, Boolean.class);\n\t\t\tif (value == null) {\n\t\t\t\tthrow new SpelEvaluationException(SpelMessage.TYPE_CONVERSION_ERROR, \"null\", \"boolean\");\n\t\t\t}\n\t\t\treturn BooleanTypedValue.forValue(!value);\n\t\t}\n\t\tcatch (SpelEvaluationException see) {\n\t\t\tsee.setPosition(getChild(0).getStartPosition());\n\t\t\tthrow see;\n\t\t}\n\t}","commit_id":"759c9b35cd4d74aff7b912324751b334bf598f47","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tprotected final <T> T getValue(ExpressionState state, Class<T> desiredReturnType) throws EvaluationException {\n\t\tObject result = getValueInternal(state).getValue();\n\t\tif (result != null && desiredReturnType != null) {\n\t\t\tClass<?> resultType = result.getClass();\n\t\t\tif (desiredReturnType.isAssignableFrom(resultType)) {\n\t\t\t\treturn (T) result;\n\t\t\t}\n\t\t\t// Attempt conversion to the requested type, may throw an exception\n\t\t\treturn ExpressionUtils.convert(state.getEvaluationContext(), result, desiredReturnType);\n\t\t}\n\t\treturn (T) result;\n\t}","id":29624,"modified_method":"protected final <T> T getValue(ExpressionState state, Class<T> desiredReturnType) throws EvaluationException {\n\t\treturn ExpressionUtils.convertTypedValue(state.getEvaluationContext(), getValueInternal(state), desiredReturnType);\n\t}","commit_id":"759c9b35cd4d74aff7b912324751b334bf598f47","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Nullable\n  public static StringPartInfo findStringPart(@NotNull PsiFile file, int startOffset, int endOffset) {\n    final PsiElement start = file.findElementAt(startOffset);\n    final PsiElement fin = file.findElementAt(endOffset);\n    if (start == null || fin == null) return null;\n\n    final PsiElement parent = PsiTreeUtil.findCommonParent(start, fin);\n\n    if (parent != null && parent.getParent() instanceof GrLiteral) {\n      return new StringPartInfo((GrLiteral)parent.getParent(), new TextRange(startOffset, endOffset));\n    }\n    return null;\n  }","id":29625,"modified_method":"@Nullable\n  public static StringPartInfo findStringPart(@NotNull PsiFile file, int startOffset, int endOffset) {\n    final PsiElement start = file.findElementAt(startOffset);\n    final PsiElement fin = file.findElementAt(endOffset - 1);\n    if (start == null || fin == null) return null;\n\n    final PsiElement parent = PsiTreeUtil.findCommonParent(start, fin);\n\n    if (parent != null && parent.getParent() instanceof GrLiteral) {\n      return new StringPartInfo((GrLiteral)parent.getParent(), new TextRange(startOffset, endOffset));\n    }\n    return null;\n  }","commit_id":"85eb5e46f74053d6c127c87630b9b93d4dea1cd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static GrExpression processLiteral(final String varName, final StringPartInfo stringPart, final Project project) {\n    Data data = new Data(stringPart);\n    String startQuote = data.getStartQuote();\n    TextRange range = data.getRange();\n    String literalText = data.getText();\n    String endQuote = data.getEndQuote();\n\n    String prefix = literalText.substring(0, range.getStartOffset()) + endQuote;\n    String suffix = startQuote + literalText.substring(range.getEndOffset());\n\n    final GrExpression concatenation =\n      GroovyPsiElementFactory.getInstance(project).createExpressionFromText(prefix + \"+\" + varName + \"+\" + suffix);\n\n    final GrExpression concat = stringPart.getLiteral().replaceWithExpression(concatenation, false);\n    return ((GrBinaryExpression)((GrBinaryExpression)concat).getLeftOperand()).getRightOperand();\n  }","id":29626,"modified_method":"@NotNull\n  public static GrExpression processLiteral(final String varName, final StringPartInfo stringPart, final Project project) {\n    Data data = new Data(stringPart);\n    String startQuote = data.getStartQuote();\n    TextRange range = data.getRange();\n    String literalText = data.getText();\n    String endQuote = data.getEndQuote();\n\n    String prefix = literalText.substring(0, range.getStartOffset()) ;\n    String suffix =  literalText.substring(range.getEndOffset());\n\n    StringBuilder buffer = new StringBuilder();\n    if (!prefix.equals(startQuote)) {\n      buffer.append(prefix).append(endQuote).append('+');\n    }\n    buffer.append(varName);\n    if (!suffix.equals(endQuote)) {\n      buffer.append('+').append(startQuote).append(suffix);\n    }\n\n    final GrExpression concatenation = GroovyPsiElementFactory.getInstance(project).createExpressionFromText(buffer);\n\n    final GrExpression concat = stringPart.getLiteral().replaceWithExpression(concatenation, false);\n    if (concat instanceof GrReferenceExpression) {\n      return concat;\n    }\n    else {\n      assert concat instanceof GrBinaryExpression;\n      final GrExpression left = ((GrBinaryExpression)concat).getLeftOperand();\n      if (left instanceof GrReferenceExpression) {\n        return left;\n      }\n      else {\n        assert left instanceof GrBinaryExpression;\n        final GrExpression right = ((GrBinaryExpression)left).getRightOperand();\n        assert right != null;\n        return right;\n      }\n    }\n  }","commit_id":"85eb5e46f74053d6c127c87630b9b93d4dea1cd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean applyInstanceofOrNull(DfaRelationValue dfaCond) {\n    DfaVariableValue dfaVar = (DfaVariableValue)dfaCond.getLeftOperand();\n    DfaTypeValue dfaType = (DfaTypeValue)dfaCond.getRightOperand();\n\n    final DfaVariableState varState = getVariableState(dfaVar);\n    varState.setNullable(varState.isNullable() || dfaType.isNullable());\n    if (!isNotNull(dfaVar)) return true;\n    return varState.setInstanceofValue(dfaType);\n  }","id":29627,"modified_method":"public boolean applyInstanceofOrNull(DfaRelationValue dfaCond) {\n    DfaValue left = dfaCond.getLeftOperand();\n    if (left instanceof DfaBoxedValue) {\n      left = ((DfaBoxedValue)left).getWrappedValue();\n    }\n    else if (left instanceof DfaUnboxedValue) {\n      left = ((DfaUnboxedValue)left).getVariable();\n    }\n\n    DfaVariableValue dfaVar = (DfaVariableValue)left;\n    DfaTypeValue dfaType = (DfaTypeValue)dfaCond.getRightOperand();\n\n    final DfaVariableState varState = getVariableState(dfaVar);\n    varState.setNullable(varState.isNullable() || dfaType.isNullable());\n    if (!isNotNull(dfaVar)) return true;\n    return varState.setInstanceofValue(dfaType);\n  }","commit_id":"223b0c7310bd44244aafb5f7c60a23108e7e8688","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(obj instanceof TypeDescriptor)) {\n\t\t\treturn false;\n\t\t}\n\t\tTypeDescriptor other = (TypeDescriptor) obj;\n\t\tif (!ObjectUtils.nullSafeEquals(getType(), other.getType())) {\n\t\t\treturn false;\n\t\t}\n\t\tAnnotation[] ann = getAnnotations();\n\t\tAnnotation[] otherAnn = other.getAnnotations();\n\t\tif (ann.length != otherAnn.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < ann.length; i++) {\n\t\t\tif (!ann[i].annotationType().equals(otherAnn[i].annotationType())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (isCollection() || isArray()) {\n\t\t\treturn ObjectUtils.nullSafeEquals(getElementTypeDescriptor(), other.getElementTypeDescriptor());\n\t\t}\n\t\telse if (isMap()) {\n\t\t\treturn ObjectUtils.nullSafeEquals(getMapKeyTypeDescriptor(), other.getMapKeyTypeDescriptor()) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(getMapValueTypeDescriptor(), other.getMapValueTypeDescriptor());\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}","id":29628,"modified_method":"public boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(obj instanceof TypeDescriptor)) {\n\t\t\treturn false;\n\t\t}\n\t\tTypeDescriptor other = (TypeDescriptor) obj;\n\t\tif (!ObjectUtils.nullSafeEquals(getType(), other.getType())) {\n\t\t\treturn false;\n\t\t}\n\t\tAnnotation[] annotations = getAnnotations();\n\t\tif (annotations.length != other.getAnnotations().length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (Annotation ann : annotations) {\n\t\t\tif (other.getAnnotation(ann.annotationType()) == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (isCollection() || isArray()) {\n\t\t\treturn ObjectUtils.nullSafeEquals(getElementTypeDescriptor(), other.getElementTypeDescriptor());\n\t\t}\n\t\telse if (isMap()) {\n\t\t\treturn ObjectUtils.nullSafeEquals(getMapKeyTypeDescriptor(), other.getMapKeyTypeDescriptor()) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(getMapValueTypeDescriptor(), other.getMapValueTypeDescriptor());\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}","commit_id":"9e21d2f74127b73e7ef8bab6bb1446f137970fb9","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n   * Returns all annotations for <code>listOwner<\/code>, possibly walking up the method hierarchy.\n   *\n   * @see com.intellij.codeInsight.AnnotationUtil#isAnnotated(com.intellij.psi.PsiModifierListOwner, java.lang.String, boolean)\n   */\n  private static PsiAnnotation[] getAnnotations(@NotNull final PsiModifierListOwner listOwner, final boolean inHierarchy) {\n    final PsiModifierList modifierList = listOwner.getModifierList();\n    if (modifierList == null) {\n      return PsiAnnotation.EMPTY_ARRAY;\n    }\n    if (!inHierarchy) {\n      return modifierList.getAnnotations();\n    }\n    return CachedValuesManager.getCachedValue(listOwner, new CachedValueProvider<PsiAnnotation[]>() {\n      @Nullable\n      @Override\n      public Result<PsiAnnotation[]> compute() {\n        return Result.create(getHierarchyAnnotations(listOwner, modifierList), PsiModificationTracker.MODIFICATION_COUNT);\n      }\n    });\n  }","id":29629,"modified_method":"/**\n   * Returns all annotations for <code>listOwner<\/code>, possibly walking up the method hierarchy.\n   *\n   * @see com.intellij.codeInsight.AnnotationUtil#isAnnotated(com.intellij.psi.PsiModifierListOwner, java.lang.String, boolean)\n   */\n  private static PsiAnnotation[] getAnnotations(@NotNull final PsiModifierListOwner listOwner, final boolean inHierarchy) {\n    final PsiModifierList modifierList = listOwner.getModifierList();\n    if (!inHierarchy) {\n      return modifierList == null ? PsiAnnotation.EMPTY_ARRAY : modifierList.getAnnotations();\n    }\n    return CachedValuesManager.getCachedValue(listOwner, new CachedValueProvider<PsiAnnotation[]>() {\n      @Nullable\n      @Override\n      public Result<PsiAnnotation[]> compute() {\n        return Result.create(getHierarchyAnnotations(listOwner), PsiModificationTracker.MODIFICATION_COUNT);\n      }\n    });\n  }","commit_id":"7816ad746702870e9e0417829c77dc8747aec8ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiAnnotation[] getHierarchyAnnotations(PsiModifierListOwner listOwner, PsiModifierList modifierList) {\n    final Set<PsiAnnotation> all = new HashSet<PsiAnnotation>() {\n      public boolean add(PsiAnnotation o) {\n        // don't overwrite \"higher level\" annotations\n        return !contains(o) && super.add(o);\n      }\n    };\n    if (listOwner instanceof PsiMethod) {\n      ContainerUtil.addAll(all, modifierList.getAnnotations());\n      SuperMethodsSearch.search((PsiMethod)listOwner, null, true, true).forEach(new Processor<MethodSignatureBackedByPsiMethod>() {\n        public boolean process(final MethodSignatureBackedByPsiMethod superMethod) {\n          ContainerUtil.addAll(all, superMethod.getMethod().getModifierList().getAnnotations());\n          return true;\n        }\n      });\n      return all.toArray(new PsiAnnotation[all.size()]);\n    }\n    if (listOwner instanceof PsiParameter) {\n      PsiParameter parameter = (PsiParameter)listOwner;\n      PsiElement declarationScope = parameter.getDeclarationScope();\n      PsiParameterList parameterList;\n      if (declarationScope instanceof PsiMethod && parameter.getParent() == (parameterList = ((PsiMethod)declarationScope).getParameterList())) {\n        PsiMethod method = (PsiMethod)declarationScope;\n        final int parameterIndex = parameterList.getParameterIndex(parameter);\n        ContainerUtil.addAll(all, modifierList.getAnnotations());\n        SuperMethodsSearch.search(method, null, true, true).forEach(new Processor<MethodSignatureBackedByPsiMethod>() {\n          public boolean process(final MethodSignatureBackedByPsiMethod superMethod) {\n            PsiParameter superParameter = superMethod.getMethod().getParameterList().getParameters()[parameterIndex];\n            PsiModifierList modifierList = superParameter.getModifierList();\n            if (modifierList != null) {\n              ContainerUtil.addAll(all, modifierList.getAnnotations());\n            }\n            return true;\n          }\n        });\n        return all.toArray(new PsiAnnotation[all.size()]);\n      }\n    }\n    return modifierList.getAnnotations();\n  }","id":29630,"modified_method":"private static PsiAnnotation[] getHierarchyAnnotations(PsiModifierListOwner listOwner) {\n    PsiModifierList modifierList = listOwner.getModifierList();\n\n    final Set<PsiAnnotation> all = new HashSet<PsiAnnotation>() {\n      public boolean add(PsiAnnotation o) {\n        // don't overwrite \"higher level\" annotations\n        return !contains(o) && super.add(o);\n      }\n    };\n    if (listOwner instanceof PsiMethod) {\n      if (modifierList != null) {\n        ContainerUtil.addAll(all, modifierList.getAnnotations());\n      }\n      SuperMethodsSearch.search((PsiMethod)listOwner, null, true, true).forEach(new Processor<MethodSignatureBackedByPsiMethod>() {\n        public boolean process(final MethodSignatureBackedByPsiMethod superMethod) {\n          ContainerUtil.addAll(all, superMethod.getMethod().getModifierList().getAnnotations());\n          return true;\n        }\n      });\n      return all.toArray(new PsiAnnotation[all.size()]);\n    }\n    if (listOwner instanceof PsiParameter) {\n      PsiParameter parameter = (PsiParameter)listOwner;\n      PsiElement declarationScope = parameter.getDeclarationScope();\n      PsiParameterList parameterList;\n      if (declarationScope instanceof PsiMethod && parameter.getParent() == (parameterList = ((PsiMethod)declarationScope).getParameterList())) {\n        PsiMethod method = (PsiMethod)declarationScope;\n        final int parameterIndex = parameterList.getParameterIndex(parameter);\n        if (modifierList != null) {\n          ContainerUtil.addAll(all, modifierList.getAnnotations());\n        }\n        SuperMethodsSearch.search(method, null, true, true).forEach(new Processor<MethodSignatureBackedByPsiMethod>() {\n          public boolean process(final MethodSignatureBackedByPsiMethod superMethod) {\n            PsiParameter superParameter = superMethod.getMethod().getParameterList().getParameters()[parameterIndex];\n            PsiModifierList modifierList = superParameter.getModifierList();\n            if (modifierList != null) {\n              ContainerUtil.addAll(all, modifierList.getAnnotations());\n            }\n            return true;\n          }\n        });\n        return all.toArray(new PsiAnnotation[all.size()]);\n      }\n    }\n    return modifierList == null ? PsiAnnotation.EMPTY_ARRAY : modifierList.getAnnotations();\n  }","commit_id":"7816ad746702870e9e0417829c77dc8747aec8ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void updateMethodPresentation(PsiMethod method, PsiSubstitutor substitutor, ParameterInfoUIContext context) {\n    CodeInsightSettings settings = CodeInsightSettings.getInstance();\n\n    if (!method.isValid()) {\n      context.setUIComponentEnabled(false);\n      return;\n    }\n\n    StringBuilder buffer = new StringBuilder();\n\n    if (settings.SHOW_FULL_SIGNATURES_IN_PARAMETER_INFO) {\n      if (!method.isConstructor()) {\n        PsiType returnType = method.getReturnType();\n        if (substitutor != null) {\n          returnType = substitutor.substitute(returnType);\n        }\n\n        appendModifierList(buffer, method.getModifierList());\n        buffer.append(returnType.getPresentableText());\n        buffer.append(\" \");\n      }\n      buffer.append(method.getName());\n      buffer.append(\"(\");\n    }\n\n    final int currentParameter = context.getCurrentParameterIndex();\n\n    PsiParameter[] parms = method.getParameterList().getParameters();\n    int numParams = parms.length;\n    int highlightStartOffset = -1;\n    int highlightEndOffset = -1;\n    if (numParams > 0) {\n      for (int j = 0; j < numParams; j++) {\n        PsiParameter param = parms[j];\n\n        int startOffset = buffer.length();\n\n        if (param.isValid()) {\n          PsiType paramType = param.getType();\n          if (substitutor != null) {\n            paramType = substitutor.substitute(paramType);\n          }\n          appendModifierList(buffer, param.getModifierList());\n          buffer.append(paramType.getPresentableText());\n          String name = param.getName();\n          if (name != null) {\n            buffer.append(\" \");\n            buffer.append(name);\n          }\n        }\n\n        int endOffset = buffer.length();\n\n        if (j < numParams - 1) {\n          buffer.append(\", \");\n        }\n\n        if (context.isUIComponentEnabled() &&\n            (j == currentParameter || j == numParams - 1 && param.isVarArgs() && currentParameter >= numParams)) {\n          highlightStartOffset = startOffset;\n          highlightEndOffset = endOffset;\n        }\n      }\n    }\n    else {\n      buffer.append(CodeInsightBundle.message(\"parameter.info.no.parameters\"));\n    }\n\n    if (settings.SHOW_FULL_SIGNATURES_IN_PARAMETER_INFO) {\n      buffer.append(\")\");\n    }\n\n    context.setupUIComponentPresentation(\n      buffer.toString(),\n      highlightStartOffset,\n      highlightEndOffset,\n      !context.isUIComponentEnabled(),\n      method.isDeprecated(),\n      false,\n      context.getDefaultParameterColor()\n    );\n  }","id":29631,"modified_method":"public static void updateMethodPresentation(PsiMethod method, PsiSubstitutor substitutor, ParameterInfoUIContext context) {\n    CodeInsightSettings settings = CodeInsightSettings.getInstance();\n\n    if (!method.isValid()) {\n      context.setUIComponentEnabled(false);\n      return;\n    }\n\n    StringBuilder buffer = new StringBuilder();\n\n    if (settings.SHOW_FULL_SIGNATURES_IN_PARAMETER_INFO) {\n      if (!method.isConstructor()) {\n        PsiType returnType = method.getReturnType();\n        if (substitutor != null) {\n          returnType = substitutor.substitute(returnType);\n        }\n\n        appendModifierList(buffer, method);\n        buffer.append(returnType.getPresentableText());\n        buffer.append(\" \");\n      }\n      buffer.append(method.getName());\n      buffer.append(\"(\");\n    }\n\n    final int currentParameter = context.getCurrentParameterIndex();\n\n    PsiParameter[] parms = method.getParameterList().getParameters();\n    int numParams = parms.length;\n    int highlightStartOffset = -1;\n    int highlightEndOffset = -1;\n    if (numParams > 0) {\n      for (int j = 0; j < numParams; j++) {\n        PsiParameter param = parms[j];\n\n        int startOffset = buffer.length();\n\n        if (param.isValid()) {\n          PsiType paramType = param.getType();\n          if (substitutor != null) {\n            paramType = substitutor.substitute(paramType);\n          }\n          appendModifierList(buffer, param);\n          buffer.append(paramType.getPresentableText());\n          String name = param.getName();\n          if (name != null) {\n            buffer.append(\" \");\n            buffer.append(name);\n          }\n        }\n\n        int endOffset = buffer.length();\n\n        if (j < numParams - 1) {\n          buffer.append(\", \");\n        }\n\n        if (context.isUIComponentEnabled() &&\n            (j == currentParameter || j == numParams - 1 && param.isVarArgs() && currentParameter >= numParams)) {\n          highlightStartOffset = startOffset;\n          highlightEndOffset = endOffset;\n        }\n      }\n    }\n    else {\n      buffer.append(CodeInsightBundle.message(\"parameter.info.no.parameters\"));\n    }\n\n    if (settings.SHOW_FULL_SIGNATURES_IN_PARAMETER_INFO) {\n      buffer.append(\")\");\n    }\n\n    context.setupUIComponentPresentation(\n      buffer.toString(),\n      highlightStartOffset,\n      highlightEndOffset,\n      !context.isUIComponentEnabled(),\n      method.isDeprecated(),\n      false,\n      context.getDefaultParameterColor()\n    );\n  }","commit_id":"94857ea9634f1129a05f98f98bd1a145a332e179","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void appendModifierList(final StringBuilder buffer, final PsiModifierList list) {\n    if (list == null) return;\n    int lastSize = buffer.length();\n    for (PsiAnnotation a : list.getAnnotations()) {\n      if (lastSize != buffer.length()) buffer.append(\" \");\n      final PsiJavaCodeReferenceElement element = a.getNameReferenceElement();\n      if (element != null) buffer.append(\"@\").append(element.getText());\n    }\n    if (lastSize != buffer.length()) buffer.append(\" \");\n  }","id":29632,"modified_method":"private static void appendModifierList(@NotNull StringBuilder buffer, @NotNull PsiModifierListOwner owner) {\n    final PsiModifierList list = owner.getModifierList();\n    PsiAnnotation[] annotations = PsiAnnotation.EMPTY_ARRAY;\n    int lastSize = buffer.length();\n    if (list != null) {\n      annotations = list.getAnnotations();\n    }\n    final PsiAnnotation[] externalAnnotations = ExternalAnnotationsManager.getInstance(owner.getProject()).findExternalAnnotations(owner);\n    if (externalAnnotations != null) {\n      annotations = ArrayUtil.mergeArrays(annotations, externalAnnotations, PsiAnnotation.ARRAY_FACTORY);\n    }\n\n    for (PsiAnnotation a : annotations) {\n      if (lastSize != buffer.length()) buffer.append(\" \");\n      final PsiJavaCodeReferenceElement element = a.getNameReferenceElement();\n      if (element != null) buffer.append(\"@\").append(element.getReferenceName());\n    }\n    if (lastSize != buffer.length()) buffer.append(\" \");\n  }","commit_id":"94857ea9634f1129a05f98f98bd1a145a332e179","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiCall getCall(PsiExpressionList list) {\n    if (list.getParent() instanceof PsiMethodCallExpression) {\n      return (PsiCall)list.getParent();\n    }\n    else if (list.getParent() instanceof PsiNewExpression) {\n      return (PsiCall)list.getParent();\n    }\n    else if (list.getParent() instanceof PsiAnonymousClass) {\n      return (PsiCall)list.getParent().getParent();\n    }\n    else if (list.getParent() instanceof PsiEnumConstant) {\n      return (PsiCall)list.getParent();\n    }\n    else {\n      return null;\n    }\n  }","id":29633,"modified_method":"private static PsiCall getCall(PsiExpressionList list) {\n    if (list.getParent() instanceof PsiMethodCallExpression) {\n      return (PsiCall)list.getParent();\n    }\n    if (list.getParent() instanceof PsiNewExpression) {\n      return (PsiCall)list.getParent();\n    }\n    if (list.getParent() instanceof PsiAnonymousClass) {\n      return (PsiCall)list.getParent().getParent();\n    }\n    if (list.getParent() instanceof PsiEnumConstant) {\n      return (PsiCall)list.getParent();\n    }\n    return null;\n  }","commit_id":"94857ea9634f1129a05f98f98bd1a145a332e179","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getParametersForDocumentation(final Object p, final ParameterInfoContext context) {\n    if (p instanceof MethodCandidateInfo) {\n      return ((MethodCandidateInfo)p).getElement().getParameterList().getParameters();\n    }\n    else if (p instanceof PsiMethod) {\n      return ((PsiMethod)p).getParameterList().getParameters();\n    }\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","id":29634,"modified_method":"public Object[] getParametersForDocumentation(final Object p, final ParameterInfoContext context) {\n    if (p instanceof MethodCandidateInfo) {\n      return ((MethodCandidateInfo)p).getElement().getParameterList().getParameters();\n    }\n    if (p instanceof PsiMethod) {\n      return ((PsiMethod)p).getParameterList().getParameters();\n    }\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","commit_id":"94857ea9634f1129a05f98f98bd1a145a332e179","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Compute at a given locus.\n     *\n     * @param tracker the meta data tracker\n     * @param refContext the reference base\n     * @param fullContext contextual information around the locus\n     */\n    public Pair<List<Genotype>, GenotypeLocusData> map(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext fullContext) {\n        char ref = Character.toUpperCase(refContext.getBase());\n        if ( !BaseUtils.isRegularBase(ref) )\n            return null;\n\n        // remove mapping quality zero reads\n        AlignmentContext MQ0freeContext = filterAlignmentContext(fullContext);\n\n        // an optimization to speed things up when there is no coverage or when overly covered\n        if ( MQ0freeContext.getPileup().size() == 0 ||\n             (UAC.MAX_READS_IN_PILEUP > 0 && MQ0freeContext.getPileup().size() > UAC.MAX_READS_IN_PILEUP) )\n            return null;\n\n        DiploidGenotypePriors priors = new DiploidGenotypePriors(ref, UAC.heterozygosity, DiploidGenotypePriors.PROB_OF_TRISTATE_GENOTYPE);\n        Pair<List<Genotype>, GenotypeLocusData> call = gcm.calculateGenotype(tracker, ref, MQ0freeContext, priors);\n\n        // annotate the call, if possible\n        if ( call != null && call.second != null && call.second instanceof ArbitraryFieldsBacked ) {\n            Map<String, String> annotations = VariantAnnotator.getAnnotations(refContext, fullContext, call.second, call.first);\n            ((ArbitraryFieldsBacked)call.second).setFields(annotations);\n        }\n\n        return call;\n    }","id":29635,"modified_method":"/**\n     * Compute at a given locus.\n     *\n     * @param tracker the meta data tracker\n     * @param refContext the reference base\n     * @param fullContext contextual information around the locus\n     */\n    public Pair<List<Genotype>, GenotypeLocusData> map(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext fullContext) {\n        char ref = Character.toUpperCase(refContext.getBase());\n        if ( !BaseUtils.isRegularBase(ref) )\n            return null;\n\n        // remove mapping quality zero reads\n        AlignmentContext MQ0freeContext = filterAlignmentContext(fullContext);\n\n        // an optimization to speed things up when there is no coverage or when overly covered\n        if ( MQ0freeContext.getPileup().size() == 0 ||\n             (UAC.MAX_READS_IN_PILEUP > 0 && MQ0freeContext.getPileup().size() > UAC.MAX_READS_IN_PILEUP) )\n            return null;\n\n        DiploidGenotypePriors priors = new DiploidGenotypePriors(ref, UAC.heterozygosity, DiploidGenotypePriors.PROB_OF_TRISTATE_GENOTYPE);\n        Pair<List<Genotype>, GenotypeLocusData> call = gcm.calculateGenotype(tracker, ref, MQ0freeContext, priors);\n\n        // annotate the call, if possible\n        if ( call != null && call.second != null && call.second instanceof ArbitraryFieldsBacked ) {\n            Map<String, String> annotations;\n            if ( UAC.ALL_ANNOTATIONS )\n                annotations = VariantAnnotator.getAllAnnotations(refContext, fullContext, call.second, call.first);\n            else\n                annotations = VariantAnnotator.getAnnotations(refContext, fullContext, call.second, call.first);\n            ((ArbitraryFieldsBacked)call.second).setFields(annotations);\n        }\n\n        return call;\n    }","commit_id":"58937bf9ba4a233aa3c708635bd539524ccb3c4d","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Gets list of JAXRPC or JAXWS servlets meta data.\n     *\n     * @param unit deployment unit\n     * @param jaxws if passed value is <b>true<\/b> JAXWS servlets list will be returned, otherwise JAXRPC servlets list\n     * @return either JAXRPC or JAXWS servlets list\n     */\n    private static List<ServletMetaData> getWebServiceServlets(final DeploymentUnit unit, final boolean jaxws) {\n        final JBossWebMetaData jbossWebMD = getJBossWebMetaData(unit);\n        final List<Index> annotationIndexes = getRootAnnotationIndexes(unit);\n        return selectWebServiceServlets(annotationIndexes, jbossWebMD.getServlets(), jaxws);\n    }","id":29636,"modified_method":"/**\n     * Gets list of JAXRPC or JAXWS servlets meta data.\n     *\n     * @param unit deployment unit\n     * @param jaxws if passed value is <b>true<\/b> JAXWS servlets list will be returned, otherwise JAXRPC servlets list\n     * @return either JAXRPC or JAXWS servlets list\n     */\n    private static List<ServletMetaData> getWebServiceServlets(final DeploymentUnit unit, final boolean jaxws) {\n        final JBossWebMetaData jbossWebMD = getJBossWebMetaData(unit);\n        final CompositeIndex compositeIndex = ASHelper.getRequiredAttachment(unit, Attachments.COMPOSITE_ANNOTATION_INDEX);\n        return selectWebServiceServlets(compositeIndex, jbossWebMD.getServlets(), jaxws);\n    }","commit_id":"7d6f48cdcd563fe2af2fa44cc2da899c9216c1cc","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Return a new sublist of the provided ServletMetaData list including the WS servlet data only\n     *\n     * @param annotationIndex the annotation index to use for scanning for annotations\n     * @param smd the initial servlet metadata collection\n     * @param jaxws if passed value is <b>true<\/b> JAXWS servlets list will be returned, otherwise JAXRPC servlets list\n     * @return either JAXRPC or JAXWS servlets list\n     */\n    public static <T extends ServletMetaData> List<ServletMetaData> selectWebServiceServlets(final List<Index> indexes, final Collection<T> smd, final boolean jaxws) {\n        if (smd == null) return Collections.emptyList();\n\n        final List<ServletMetaData> endpoints = new ArrayList<ServletMetaData>();\n\n        for (final ServletMetaData servletMD : smd) {\n            final boolean isWebServiceEndpoint = isWebserviceEndpoint(servletMD, indexes);\n            final boolean isJaxwsEndpoint = jaxws && isWebServiceEndpoint;\n            final boolean isJaxrpcEndpoint = !jaxws && isWebServiceEndpoint;\n\n            if (isJaxwsEndpoint || isJaxrpcEndpoint) {\n                endpoints.add(servletMD);\n            }\n        }\n\n        return endpoints;\n    }","id":29637,"modified_method":"/**\n     * Return a new sublist of the provided ServletMetaData list including the WS servlet data only\n     *\n     * @param annotationIndex the annotation index to use for scanning for annotations\n     * @param smd the initial servlet metadata collection\n     * @param jaxws if passed value is <b>true<\/b> JAXWS servlets list will be returned, otherwise JAXRPC servlets list\n     * @return either JAXRPC or JAXWS servlets list\n     */\n    public static <T extends ServletMetaData> List<ServletMetaData> selectWebServiceServlets(final CompositeIndex index, final Collection<T> smd, final boolean jaxws) {\n        if (smd == null) return Collections.emptyList();\n\n        final List<ServletMetaData> endpoints = new ArrayList<ServletMetaData>();\n\n        for (final ServletMetaData servletMD : smd) {\n            final boolean isWebServiceEndpoint = isWebserviceEndpoint(servletMD, index);\n            final boolean isJaxwsEndpoint = jaxws && isWebServiceEndpoint;\n            final boolean isJaxrpcEndpoint = !jaxws && isWebServiceEndpoint;\n\n            if (isJaxwsEndpoint || isJaxrpcEndpoint) {\n                endpoints.add(servletMD);\n            }\n        }\n\n        return endpoints;\n    }","commit_id":"7d6f48cdcd563fe2af2fa44cc2da899c9216c1cc","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static boolean isWebserviceEndpoint(final ServletMetaData servletMD, final List<Index> annotationIndexes) {\n        final String endpointClassName = ASHelper.getEndpointName(servletMD);\n        if (isJSP(endpointClassName)) return false;\n\n        final DotName endpointDN = DotName.createSimple(endpointClassName);\n        ClassInfo endpointClassInfo = null;\n        for (final Index index : annotationIndexes) {\n            endpointClassInfo = index.getClassByName(endpointDN);\n            if (endpointClassInfo != null) {\n                if (endpointClassInfo.annotations().containsKey(WEB_SERVICE_ANNOTATION))\n                    return true;\n                if (endpointClassInfo.annotations().containsKey(WEB_SERVICE_PROVIDER_ANNOTATION))\n                    return true;\n            }\n        }\n\n        return false;\n    }","id":29638,"modified_method":"private static boolean isWebserviceEndpoint(final ServletMetaData servletMD, final CompositeIndex index) {\n        final String endpointClassName = ASHelper.getEndpointName(servletMD);\n        if (isJSP(endpointClassName)) return false;\n        final DotName endpointDotName = DotName.createSimple(endpointClassName);\n        final ClassInfo endpointClassInfo = index.getClassByName(endpointDotName);\n\n        if (endpointClassInfo != null) {\n            if (endpointClassInfo.annotations().containsKey(WEB_SERVICE_ANNOTATION))\n                return true;\n            if (endpointClassInfo.annotations().containsKey(WEB_SERVICE_PROVIDER_ANNOTATION))\n                return true;\n        }\n\n        return false;\n    }","commit_id":"7d6f48cdcd563fe2af2fa44cc2da899c9216c1cc","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static List<AnnotationInstance> getAnnotations(final DeploymentUnit unit, final DotName annotation) {\n       final List<AnnotationInstance> retVal = new LinkedList<AnnotationInstance>();\n       for (final Index index : ASHelper.getRootAnnotationIndexes(unit)) {\n           retVal.addAll(index.getAnnotations(annotation));\n       }\n       return retVal;\n   }","id":29639,"modified_method":"private static List<AnnotationInstance> getAnnotations(final DeploymentUnit unit, final DotName annotation) {\n       final CompositeIndex compositeIndex = ASHelper.getRequiredAttachment(unit, Attachments.COMPOSITE_ANNOTATION_INDEX);\n       return compositeIndex.getAnnotations(annotation);\n   }","commit_id":"7d6f48cdcd563fe2af2fa44cc2da899c9216c1cc","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n\t * Get all {@link Annotation Annotations} that are <em>present<\/em> on the\n\t * supplied {@link AnnotatedElement}.\n\t * <p>Meta-annotations will <em>not<\/em> be searched.\n\t * @param annotatedElement the Method, Constructor or Field to retrieve annotations from\n\t * @return the annotations found, an empty array, or {@code null} if not\n\t * resolvable (e.g. because nested Class values in annotation attributes\n\t * failed to resolve at runtime)\n\t * @since 4.0.8\n\t * @see AnnotatedElement#getAnnotations()\n\t */\n\tpublic static Annotation[] getAnnotations(AnnotatedElement annotatedElement) {\n\t\ttry {\n\t\t\treturn annotatedElement.getAnnotations();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\thandleIntrospectionFailure(annotatedElement, ex);\n\t\t}\n\t\treturn null;\n\t}","id":29640,"modified_method":"/**\n\t * Get all {@link Annotation Annotations} that are <em>present<\/em> on the\n\t * supplied {@link AnnotatedElement}.\n\t * <p>Meta-annotations will <em>not<\/em> be searched.\n\t * @param annotatedElement the Method, Constructor or Field to retrieve annotations from\n\t * @return the annotations found, an empty array, or {@code null} if not\n\t * resolvable (e.g. because nested Class values in annotation attributes\n\t * failed to resolve at runtime)\n\t * @since 4.0.8\n\t * @see AnnotatedElement#getAnnotations()\n\t */\n\tpublic static Annotation[] getAnnotations(AnnotatedElement annotatedElement) {\n\t\ttry {\n\t\t\treturn synthesizeAnnotationArray(annotatedElement.getAnnotations(), annotatedElement);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\thandleIntrospectionFailure(annotatedElement, ex);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"2451594cdd7ba4c99536571a998e90ae6dc8d5d8","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\t\tstatic Class<? extends Annotation> resolveContainerAnnotationType(Class<? extends Annotation> annotationType) {\n\t\t\ttry {\n\t\t\t\tAnnotation repeatable = getAnnotation(annotationType, REPEATABLE_CLASS_NAME);\n\t\t\t\tif (repeatable != null) {\n\t\t\t\t\tObject value = AnnotationUtils.getValue(repeatable);\n\t\t\t\t\treturn (Class<? extends Annotation>) value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\thandleIntrospectionFailure(annotationType, e);\n\t\t\t}\n\t\t\treturn null;\n\t\t}","id":29641,"modified_method":"/**\n\t\t * @since 4.2\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tstatic Class<? extends Annotation> resolveContainerAnnotationType(Class<? extends Annotation> annotationType) {\n\t\t\ttry {\n\t\t\t\tAnnotation repeatable = getAnnotation(annotationType, REPEATABLE_CLASS_NAME);\n\t\t\t\tif (repeatable != null) {\n\t\t\t\t\tObject value = AnnotationUtils.getValue(repeatable);\n\t\t\t\t\treturn (Class<? extends Annotation>) value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\thandleIntrospectionFailure(annotationType, e);\n\t\t\t}\n\t\t\treturn null;\n\t\t}","commit_id":"2451594cdd7ba4c99536571a998e90ae6dc8d5d8","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Get all {@link Annotation Annotations} that are <em>present<\/em> on the\n\t * supplied {@link Method}.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Meta-annotations will <em>not<\/em> be searched.\n\t * @param method the Method to retrieve annotations from\n\t * @return the annotations found, an empty array, or {@code null} if not\n\t * resolvable (e.g. because nested Class values in annotation attributes\n\t * failed to resolve at runtime)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\n\t * @see AnnotatedElement#getAnnotations()\n\t */\n\tpublic static Annotation[] getAnnotations(Method method) {\n\t\ttry {\n\t\t\treturn BridgeMethodResolver.findBridgedMethod(method).getAnnotations();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\thandleIntrospectionFailure(method, ex);\n\t\t}\n\t\treturn null;\n\t}","id":29642,"modified_method":"/**\n\t * Get all {@link Annotation Annotations} that are <em>present<\/em> on the\n\t * supplied {@link Method}.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Meta-annotations will <em>not<\/em> be searched.\n\t * @param method the Method to retrieve annotations from\n\t * @return the annotations found, an empty array, or {@code null} if not\n\t * resolvable (e.g. because nested Class values in annotation attributes\n\t * failed to resolve at runtime)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\n\t * @see AnnotatedElement#getAnnotations()\n\t */\n\tpublic static Annotation[] getAnnotations(Method method) {\n\t\ttry {\n\t\t\treturn synthesizeAnnotationArray(BridgeMethodResolver.findBridgedMethod(method).getAnnotations(), method);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\thandleIntrospectionFailure(method, ex);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"2451594cdd7ba4c99536571a998e90ae6dc8d5d8","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected void waitForServiceState(ServiceName serviceName, State expectedState, long timeout) throws IOException, InterruptedException {\n\n        ObjectName objectName = ManagedServiceContainer.OBJECT_NAME;\n        MBeanServerConnection mbeanServer = getMBeanServerConnection();\n        ManagedServiceContainer proxy = MBeanProxy.get(mbeanServer, objectName, ManagedServiceContainer.class);\n\n        State currentState = State.valueOf(proxy.getState(serviceName.getCanonicalName()));\n        while (timeout > 0 && currentState != expectedState) {\n            Thread.sleep(100);\n            timeout -= 100;\n            currentState = State.valueOf(proxy.getState(serviceName.getCanonicalName()));\n        }\n        if (currentState != expectedState)\n            throw new IllegalStateException(\"Unexpected state for [\" + serviceName + \"] - \" + currentState);\n    }","id":29643,"modified_method":"protected void waitForServiceState(ServiceName serviceName, State expectedState, long timeout) throws IOException, InterruptedException {\n\n        ObjectName objectName = OBJECT_NAME;\n        MBeanServerConnection mbeanServer = getMBeanServerConnection();\n        ServiceContainerMXBean proxy = MBeanProxy.get(mbeanServer, objectName, ServiceContainerMXBean.class);\n\n        State currentState = State.valueOf(proxy.getServiceStatus(serviceName.getCanonicalName()).getStateName());\n        while (timeout > 0 && currentState != expectedState) {\n            // TODO: Change this to use mbean notifications\n            Thread.sleep(100);\n            timeout -= 100;\n            currentState = State.valueOf(proxy.getServiceStatus(serviceName.getCanonicalName()).getStateName());\n        }\n        if (currentState != expectedState)\n            throw new IllegalStateException(\"Unexpected state for [\" + serviceName + \"] - \" + currentState);\n    }","commit_id":"acc18145fb9a61a8f631303f063bc3a9d511fd5f","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void startOSGiSubsystem() throws IOException, InterruptedException {\n\n        ObjectName objectName = ManagedServiceContainer.OBJECT_NAME;\n        waitForMBean(objectName, 5000);\n\n        MBeanServerConnection mbeanServer = getMBeanServerConnection();\n        ManagedServiceContainer proxy = MBeanProxy.get(mbeanServer, objectName, ManagedServiceContainer.class);\n        ServiceName serviceName = ServiceName.JBOSS.append(\"osgi\", \"context\");\n        if (State.valueOf(proxy.getState(serviceName.getCanonicalName())) != State.UP) {\n            proxy.setMode(serviceName.getCanonicalName(), Mode.ACTIVE.toString());\n            waitForServiceState(serviceName, State.UP, 5000);\n        }\n    }","id":29644,"modified_method":"private void startOSGiSubsystem() throws IOException, InterruptedException {\n\n        ObjectName objectName = OBJECT_NAME;\n        waitForMBean(objectName, 5000);\n\n        MBeanServerConnection mbeanServer = getMBeanServerConnection();\n        ServiceContainerMXBean proxy = MBeanProxy.get(mbeanServer, objectName, ServiceContainerMXBean.class);\n        ServiceName serviceName = ServiceName.JBOSS.append(\"osgi\", \"context\");\n        if (State.valueOf(proxy.getServiceStatus(serviceName.getCanonicalName()).getStateName()) != State.UP) {\n            proxy.setServiceMode(serviceName.getCanonicalName(), Mode.ACTIVE.toString());\n            waitForServiceState(serviceName, State.UP, 5000);\n        }\n    }","commit_id":"acc18145fb9a61a8f631303f063bc3a9d511fd5f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public AsyncFuture<ServerController> start(final Configuration configuration, final List<ServiceActivator> extraServices) {\n        if (configuration == null) {\n            throw new IllegalArgumentException(\"configuration is null\");\n        }\n        final ModuleLoader moduleLoader = configuration.getModuleLoader();\n        final ServerEnvironment serverEnvironment = configuration.getServerEnvironment();\n        final String name = serverEnvironment.getServerName();\n        final ServerConfigurationPersister configurationPersister = configuration.getConfigurationPersister();\n        if (moduleLoader == null) {\n            throw new IllegalArgumentException(\"moduleLoader is null\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"name is null\");\n        }\n        if (serverEnvironment == null) {\n            throw new IllegalArgumentException(\"serverEnvironment is null\");\n        }\n        if (configurationPersister == null) {\n            throw new IllegalArgumentException(\"configurationPersister is null\");\n        }\n        final ServiceContainer container = ServiceContainer.Factory.create();\n        final int threads = Runtime.getRuntime().availableProcessors();\n        container.setExecutor(new ThreadPoolExecutor(threads, threads, Long.MAX_VALUE, TimeUnit.NANOSECONDS, new LinkedBlockingQueue<Runnable>()));\n\n        final StartTask future = new StartTask(container);\n        final ServiceTarget tracker = container.subTarget();\n        final Service<ServerController> serverControllerService = new ServerControllerService(configuration, extraServices);\n        container.addListener(new BootstrapListener(future, serverControllerService, container, configuration.getStartTime()));\n        tracker.addService(ServerControllerService.JBOSS_AS_NAME, serverControllerService).install();\n        return future;\n    }","id":29645,"modified_method":"public AsyncFuture<ServerController> start(final Configuration configuration, final List<ServiceActivator> extraServices) {\n        if (configuration == null) {\n            throw new IllegalArgumentException(\"configuration is null\");\n        }\n        final ModuleLoader moduleLoader = configuration.getModuleLoader();\n        final ServerEnvironment serverEnvironment = configuration.getServerEnvironment();\n        final String name = serverEnvironment.getServerName();\n        final ServerConfigurationPersister configurationPersister = configuration.getConfigurationPersister();\n        if (moduleLoader == null) {\n            throw new IllegalArgumentException(\"moduleLoader is null\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"name is null\");\n        }\n        if (serverEnvironment == null) {\n            throw new IllegalArgumentException(\"serverEnvironment is null\");\n        }\n        if (configurationPersister == null) {\n            throw new IllegalArgumentException(\"configurationPersister is null\");\n        }\n        final ServiceContainer container = ServiceContainer.Factory.create(\"jbossas\");\n        final int threads = Runtime.getRuntime().availableProcessors();\n        container.setExecutor(new ThreadPoolExecutor(threads, threads, Long.MAX_VALUE, TimeUnit.NANOSECONDS, new LinkedBlockingQueue<Runnable>()));\n\n        final StartTask future = new StartTask(container);\n        final ServiceTarget tracker = container.subTarget();\n        final Service<ServerController> serverControllerService = new ServerControllerService(configuration, extraServices);\n        container.addListener(new BootstrapListener(future, serverControllerService, container, configuration.getStartTime()));\n        tracker.addService(ServerControllerService.JBOSS_AS_NAME, serverControllerService).install();\n        return future;\n    }","commit_id":"acc18145fb9a61a8f631303f063bc3a9d511fd5f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected <P> void applyUpdate(final UpdateContext updateContext, final UpdateResultHandler<? super Void, P> resultHandler, final P param) {\n        final ServiceTarget target = updateContext.getServiceTarget();\n\n        MBeanServerService.addService(target);\n        ManagedServiceContainerService.addService(target);\n\n    }","id":29646,"modified_method":"@Override\n    protected <P> void applyUpdate(final UpdateContext updateContext, final UpdateResultHandler<? super Void, P> resultHandler, final P param) {\n        final ServiceTarget target = updateContext.getServiceTarget();\n\n        MBeanServerService.addService(target);\n\n    }","commit_id":"acc18145fb9a61a8f631303f063bc3a9d511fd5f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Create a  module from the attached module config and attache the built module..\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        final DeploymentModuleLoader deploymentModuleLoader  = phaseContext.getDeploymentUnit().getAttachment(Attachments.DEPLOYMENT_MODULE_LOADER);\n        if(deploymentModuleLoader == null) {\n            return;\n        }\n\n        final ResourceRoot mainRoot = phaseContext.getAttachment(Attachments.DEPLOYMENT_ROOT);\n\n        if (mainRoot == null) {\n            return;\n        }\n\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        final List<ResourceRoot> additionalRoots = phaseContext.getAttachment(Attachments.RESOURCE_ROOTS);\n        final List<ModuleDependency> dependencies = phaseContext.getAttachment(Attachments.MODULE_DEPENDENCIES);\n\n        // TODO: account for nested DUs here\n        final ModuleIdentifier moduleIdentifier = ModuleIdentifier.create(\"deployment.\" + deploymentUnit.getName());\n\n        final ModuleSpec.Builder specBuilder = ModuleSpec.build(moduleIdentifier);\n\n        // Add internal resource roots\n        addResourceRoot(specBuilder, mainRoot);\n        for (ResourceRoot additionalRoot : additionalRoots) {\n            addResourceRoot(specBuilder, additionalRoot);\n        }\n\n        // Add external resource roots\n        // TODO: Class-Path items\n        // TODO: Extension-List items\n\n        // Add all module dependencies\n        // TODO: read this from config\n        final boolean childFirst = false;\n        if (childFirst) {\n            specBuilder.addDependency(DependencySpec.createLocalDependencySpec());\n        }\n        for (ModuleDependency dependency : dependencies) {\n            final List<FilterSpecification> importFilters = dependency.getImportFilters();\n            final List<FilterSpecification> exportFilters = dependency.getExportFilters();\n            final PathFilter importFilter;\n            final PathFilter exportFilter;\n            final MultiplePathFilterBuilder importBuilder = PathFilters.multiplePathFilterBuilder(true);\n            for (FilterSpecification filter : importFilters) {\n                importBuilder.addFilter(filter.getPathFilter(), filter.isInclude());\n            }\n            importBuilder.addFilter(PathFilters.getMetaInfFilter(), false);\n            if (dependency.isImportServices()) {\n                importBuilder.addFilter(PathFilters.getMetaInfServicesFilter(), true);\n            }\n            importBuilder.addFilter(PathFilters.getMetaInfSubdirectoriesFilter(), false);\n            importFilter = importBuilder.create();\n            if (exportFilters.isEmpty()) {\n                exportFilter = PathFilters.acceptAll();\n            } else {\n                final MultiplePathFilterBuilder exportBuilder = PathFilters.multiplePathFilterBuilder(dependency.isExport());\n                for (FilterSpecification filter : exportFilters) {\n                    exportBuilder.addFilter(filter.getPathFilter(), filter.isInclude());\n                }\n                exportFilter = exportBuilder.create();\n            }\n            DependencySpec depSpec = DependencySpec.createModuleDependencySpec(importFilter, exportFilter, dependency.getModuleLoader(), dependency.getIdentifier(), dependency.isOptional());\n            specBuilder.addDependency(depSpec);\n        }\n        if (! childFirst) {\n            specBuilder.addDependency(DependencySpec.createLocalDependencySpec());\n        }\n\n        final ModuleSpec moduleSpec = specBuilder.create();\n\n        deploymentModuleLoader.addModuleSpec(moduleSpec);\n\n        try {\n            final Module module = deploymentModuleLoader.loadModule(moduleIdentifier);\n            phaseContext.getDeploymentUnit().putAttachment(Attachments.MODULE, module);\n        } catch (ModuleLoadException e) {\n            throw new DeploymentUnitProcessingException(\"Failed to load module: \" + moduleIdentifier, e);\n        }\n    }","id":29647,"modified_method":"/**\n     * Create a  module from the attached module config and attache the built module..\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        final DeploymentModuleLoader deploymentModuleLoader  = phaseContext.getDeploymentUnit().getAttachment(Attachments.DEPLOYMENT_MODULE_LOADER);\n        if(deploymentModuleLoader == null) {\n            return;\n        }\n\n        final ResourceRoot mainRoot = phaseContext.getAttachment(Attachments.DEPLOYMENT_ROOT);\n\n        if (mainRoot == null) {\n            return;\n        }\n\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        final List<ResourceRoot> additionalRoots = phaseContext.getAttachment(Attachments.RESOURCE_ROOTS);\n        final List<ModuleDependency> dependencies = phaseContext.getAttachment(Attachments.MODULE_DEPENDENCIES);\n\n        // TODO: account for nested DUs here\n        final ModuleIdentifier moduleIdentifier = ModuleIdentifier.create(\"deployment.\" + deploymentUnit.getName());\n\n        final ModuleSpec.Builder specBuilder = ModuleSpec.build(moduleIdentifier);\n\n        // Add internal resource roots\n        addResourceRoot(specBuilder, mainRoot);\n        for (ResourceRoot additionalRoot : additionalRoots) {\n            addResourceRoot(specBuilder, additionalRoot);\n        }\n\n        // Add external resource roots\n        // TODO: Class-Path items\n        // TODO: Extension-List items\n\n        // Add all module dependencies\n        // TODO: read this from config\n        final boolean childFirst = false;\n        if (childFirst) {\n            specBuilder.addDependency(DependencySpec.createLocalDependencySpec());\n        }\n        for (ModuleDependency dependency : dependencies) {\n            final List<FilterSpecification> importFilters = dependency.getImportFilters();\n            final List<FilterSpecification> exportFilters = dependency.getExportFilters();\n            final PathFilter importFilter;\n            final PathFilter exportFilter;\n            final MultiplePathFilterBuilder importBuilder = PathFilters.multiplePathFilterBuilder(true);\n            for (FilterSpecification filter : importFilters) {\n                importBuilder.addFilter(filter.getPathFilter(), filter.isInclude());\n            }\n            if (dependency.isImportServices()) {\n                importBuilder.addFilter(PathFilters.getMetaInfServicesFilter(), true);\n            }\n            importBuilder.addFilter(PathFilters.getMetaInfSubdirectoriesFilter(), false);\n            importBuilder.addFilter(PathFilters.getMetaInfFilter(), false);\n            importFilter = importBuilder.create();\n            if (exportFilters.isEmpty()) {\n                exportFilter = PathFilters.acceptAll();\n            } else {\n                final MultiplePathFilterBuilder exportBuilder = PathFilters.multiplePathFilterBuilder(dependency.isExport());\n                for (FilterSpecification filter : exportFilters) {\n                    exportBuilder.addFilter(filter.getPathFilter(), filter.isInclude());\n                }\n                exportFilter = exportBuilder.create();\n            }\n            DependencySpec depSpec = DependencySpec.createModuleDependencySpec(importFilter, exportFilter, dependency.getModuleLoader(), dependency.getIdentifier(), dependency.isOptional());\n            specBuilder.addDependency(depSpec);\n        }\n        if (! childFirst) {\n            specBuilder.addDependency(DependencySpec.createLocalDependencySpec());\n        }\n\n        final ModuleSpec moduleSpec = specBuilder.create();\n\n        deploymentModuleLoader.addModuleSpec(moduleSpec);\n\n        try {\n            final Module module = deploymentModuleLoader.loadModule(moduleIdentifier);\n            phaseContext.getDeploymentUnit().putAttachment(Attachments.MODULE, module);\n        } catch (ModuleLoadException e) {\n            throw new DeploymentUnitProcessingException(\"Failed to load module: \" + moduleIdentifier, e);\n        }\n    }","commit_id":"acc18145fb9a61a8f631303f063bc3a9d511fd5f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void shouldFailCompileProcedureWithSchemaConflict() throws Throwable\n    {\n        exception.expect( ProcedureException.class );\n        exception.expectMessage( \"Conflicting procedure annotation, PerformsWrites and mode = SCHEMA.\" );\n        procs.register( ProcedureWithSchemaConflictAnnotation.class );\n    }","id":29648,"modified_method":"@Test\n    public void shouldFailCompileProcedureWithSchemaConflict() throws Throwable\n    {\n        exception.expect( ProcedureException.class );\n        exception.expectMessage( \"Conflicting procedure annotation, cannot use PerformsWrites and mode\" );\n        procs.register( ProcedureWithSchemaConflictAnnotation.class );\n    }","commit_id":"302c4ee0de750e7f59e1b0c9f089995bbf43e70a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFailCompileProcedureWithDBMSConflict() throws Throwable\n    {\n        exception.expect( ProcedureException.class );\n        exception.expectMessage( \"Conflicting procedure annotation, PerformsWrites and mode = DBMS.\" );\n        procs.register( ProcedureWithDBMSConflictAnnotation.class );\n    }","id":29649,"modified_method":"@Test\n    public void shouldFailCompileProcedureWithDBMSConflict() throws Throwable\n    {\n        exception.expect( ProcedureException.class );\n        exception.expectMessage( \"Conflicting procedure annotation, cannot use PerformsWrites and mode\" );\n        procs.register( ProcedureWithDBMSConflictAnnotation.class );\n    }","commit_id":"302c4ee0de750e7f59e1b0c9f089995bbf43e70a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCompileProcedureWithPerformsWrites() throws Throwable\n    {\n        procs.register( ProcedureWithPerformsWritesAndRead.class );\n        assertNotNull( procs.get( new ProcedureSignature.ProcedureName( \"org.neo4j.kernel.impl.proc\".split( \"\\\\.\" ),\n                \"shouldCompile\" ) ) );\n        assertNotNull( procs.get( new ProcedureSignature.ProcedureName( \"org.neo4j.kernel.impl.proc\".split( \"\\\\.\" ),\n                \"shouldCompileToo\" ) ) );\n    }","id":29650,"modified_method":"@Test\n    public void shouldFailCompileProcedureWithWriteConflict() throws Throwable\n    {\n        exception.expect( ProcedureException.class );\n        exception.expectMessage( \"Conflicting procedure annotation, cannot use PerformsWrites and mode\" );\n        procs.register( ProcedureWithWriteConflictAnnotation.class );\n    }","commit_id":"302c4ee0de750e7f59e1b0c9f089995bbf43e70a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private ReflectiveProcedure compileProcedure( Class<?> procDefinition, MethodHandle constructor, Method method )\n            throws ProcedureException, IllegalAccessException\n    {\n        ProcedureName procName = extractName( procDefinition, method );\n\n        List<FieldSignature> inputSignature = inputSignatureDeterminer.signatureFor( method );\n        OutputMapper outputMapper = outputMappers.mapper( method );\n        MethodHandle procedureMethod = lookup.unreflect( method );\n        List<FieldInjections.FieldSetter> setters = fieldInjections.setters( procDefinition );\n\n        ProcedureSignature.Mode mode = ProcedureSignature.Mode.READ_ONLY;\n        Procedure procedure = method.getAnnotation( Procedure.class );\n        if ( procedure.mode().equals( Procedure.Mode.DBMS ) )\n        {\n            mode = ProcedureSignature.Mode.DBMS;\n        }\n        else if ( procedure.mode().equals( Procedure.Mode.SCHEMA ) )\n        {\n            mode = ProcedureSignature.Mode.SCHEMA_WRITE;\n        }\n        else if ( procedure.mode().equals( Procedure.Mode.WRITE ) )\n        {\n            mode = ProcedureSignature.Mode.READ_WRITE;\n        }\n        if ( method.isAnnotationPresent( PerformsWrites.class ) )\n        {\n            if ( mode == ProcedureSignature.Mode.DBMS || mode == ProcedureSignature.Mode.SCHEMA_WRITE )\n            {\n                throw new ProcedureException( Status.Procedure.ProcedureRegistrationFailed,\n                        \"Conflicting procedure annotation, PerformsWrites and mode = %s.\", procedure.mode() );\n            }\n            else\n            {\n                mode = ProcedureSignature.Mode.READ_WRITE;\n            }\n        }\n\n        ProcedureSignature signature = new ProcedureSignature( procName, inputSignature, outputMapper.signature(), mode );\n\n        return new ReflectiveProcedure( signature, constructor, procedureMethod, outputMapper, setters );\n    }","id":29651,"modified_method":"private ReflectiveProcedure compileProcedure( Class<?> procDefinition, MethodHandle constructor, Method method )\n            throws ProcedureException, IllegalAccessException\n    {\n        ProcedureName procName = extractName( procDefinition, method );\n\n        List<FieldSignature> inputSignature = inputSignatureDeterminer.signatureFor( method );\n        OutputMapper outputMapper = outputMappers.mapper( method );\n        MethodHandle procedureMethod = lookup.unreflect( method );\n        List<FieldInjections.FieldSetter> setters = fieldInjections.setters( procDefinition );\n\n        ProcedureSignature.Mode mode = ProcedureSignature.Mode.READ_ONLY;\n        Procedure procedure = method.getAnnotation( Procedure.class );\n        if ( procedure.mode().equals( Procedure.Mode.DBMS ) )\n        {\n            mode = ProcedureSignature.Mode.DBMS;\n        }\n        else if ( procedure.mode().equals( Procedure.Mode.SCHEMA ) )\n        {\n            mode = ProcedureSignature.Mode.SCHEMA_WRITE;\n        }\n        else if ( procedure.mode().equals( Procedure.Mode.WRITE ) )\n        {\n            mode = ProcedureSignature.Mode.READ_WRITE;\n        }\n        if ( method.isAnnotationPresent( PerformsWrites.class ) )\n        {\n            if ( !procedure.mode().equals( Procedure.Mode.DEFAULT ) )\n            {\n                throw new ProcedureException( Status.Procedure.ProcedureRegistrationFailed,\n                        \"Conflicting procedure annotation, cannot use PerformsWrites and mode\" );\n            }\n            else\n            {\n                mode = ProcedureSignature.Mode.READ_WRITE;\n            }\n        }\n\n        ProcedureSignature signature = new ProcedureSignature( procName, inputSignature, outputMapper.signature(), mode );\n\n        return new ReflectiveProcedure( signature, constructor, procedureMethod, outputMapper, setters );\n    }","commit_id":"302c4ee0de750e7f59e1b0c9f089995bbf43e70a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public RESTActionConfig(\n\t\tClass<?> actionClass, Method actionMethod, String path, String method) {\n\n\t\t_actionClass = actionClass;\n\t\t_actionMethod = actionMethod;\n\t\t_path = path;\n\t\t_method = method;\n\n\t\t_parameterNames = MethodParameterNamesResolverUtil.\n\t\t\tresolveParameterNames(actionMethod);\n\t\t_parameterTypes = actionMethod.getParameterTypes();\n\n\t\tStringBundler sb = new StringBundler(_parameterNames.length * 2 + 2);\n\n\t\tsb.append(_path);\n\t\tsb.append('+');\n\t\tsb.append(_parameterNames.length);\n\t\tsb.append('+');\n\t\tfor (String parameterName : _parameterNames) {\n\t\t\tsb.append(parameterName);\n\t\t\tsb.append('+');\n\t\t}\n\n\t\t_pathForCompare = sb.toString();\n\t}","id":29652,"modified_method":"public RESTActionConfig(\n\t\tClass<?> actionClass, Method actionMethod, String path, String method) {\n\n\t\t_actionClass = actionClass;\n\t\t_actionMethod = actionMethod;\n\t\t_path = path;\n\t\t_method = method;\n\n\t\t_parameterNames = MethodParameterNamesResolverUtil.\n\t\t\tresolveParameterNames(actionMethod);\n\t\t_parameterTypes = actionMethod.getParameterTypes();\n\n\t\tStringBundler sb = new StringBundler(_parameterNames.length * 2 + 4);\n\n\t\tsb.append(_path);\n\t\tsb.append(CharPool.PLUS);\n\t\tsb.append(_parameterNames.length);\n\t\tsb.append(CharPool.PLUS);\n\n\t\tfor (String parameterName : _parameterNames) {\n\t\t\tsb.append(parameterName);\n\t\t\tsb.append(CharPool.PLUS);\n\t\t}\n\n\t\t_fullPath = sb.toString();\n\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int compareTo(RESTActionConfig restActionConfig) {\n\t\treturn _pathForCompare.compareTo(restActionConfig._pathForCompare);\n\t}","id":29653,"modified_method":"public int compareTo(RESTActionConfig restActionConfig) {\n\t\treturn _fullPath.compareTo(restActionConfig._fullPath);\n\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String toString() {\n\t\tfinal StringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"RESTActionConfig{\");\n\t\tsb.append(_actionClass.getSimpleName());\n\t\tsb.append('#');\n\t\tsb.append(_actionMethod.getName());\n\t\tsb.append('(');\n\t\tfor (int i = 0; i < _parameterNames.length; i++) {\n\t\t\tif (i != 0) {\n\t\t\t\tsb.append(\", \");\n\t\t\t}\n\t\t\tsb.append(_parameterNames[i]);\n\t\t}\n\t\tsb.append(')');\n\t\tsb.append(\"--->\");\n\t\tsb.append(_method);\n\t\tsb.append(' ');\n\t\tsb.append(_path);\n\t\tsb.append('}');\n\t\treturn sb.toString();\n\t}","id":29654,"modified_method":"public String toString() {\n\t\tStringBundler sb = new StringBundler(11);\n\n\t\tsb.append(\"{actionClass=\");\n\t\tsb.append(_actionClass);\n\t\tsb.append(\", actionMethod=\");\n\t\tsb.append(_actionMethod);\n\t\tsb.append(\", fullPath=\");\n\t\tsb.append(_fullPath);\n\t\tsb.append(\", method=\");\n\t\tsb.append(_method);\n\t\tsb.append(\", parameterNames=\");\n\t\tsb.append(_parameterNames);\n\t\tsb.append(\", parameterTypes=\");\n\t\tsb.append(_parameterTypes);\n\t\tsb.append(\", path=\");\n\t\tsb.append(_path);\n\t\tsb.append(\"}\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Object[] _prepareParameters() {\n\t\tString[] parameterNames = _restActionConfig.getParameterNames();\n\t\tClass<?>[] parameterTypes = _restActionConfig.getParameterTypes();\n\n\t\tObject[] parameters = new Object[parameterNames.length];\n\n\t\tfor (int i = 0; i < parameterNames.length; i++) {\n\t\t\tString parameterName = parameterNames[i];\n\n\t\t\tObject value = _restActionParameters.lookupParameter(parameterName);\n\n\t\t\tObject parameterValue = null;\n\n\t\t\tif (value != null) {\n\n\t\t\t\tClass<?> parameterType = parameterTypes[i];\n\n\t\t\t\tparameterValue = ReflectUtil.castType(value, parameterType);\n\t\t\t}\n\n\t\t\tparameters[i] = parameterValue;\n\t\t}\n\n\t\treturn parameters;\n\t}","id":29655,"modified_method":"private Object[] _prepareParameters() {\n\t\tString[] parameterNames = _restActionConfig.getParameterNames();\n\t\tClass<?>[] parameterTypes = _restActionConfig.getParameterTypes();\n\n\t\tObject[] parameters = new Object[parameterNames.length];\n\n\t\tfor (int i = 0; i < parameterNames.length; i++) {\n\t\t\tString parameterName = parameterNames[i];\n\n\t\t\tObject value = _restActionParameters.getParameter(parameterName);\n\n\t\t\tObject parameterValue = null;\n\n\t\t\tif (value != null) {\n\t\t\t\tClass<?> parameterType = parameterTypes[i];\n\n\t\t\t\tparameterValue = ReflectUtil.castType(value, parameterType);\n\t\t\t}\n\n\t\t\tparameters[i] = parameterValue;\n\t\t}\n\n\t\treturn parameters;\n\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void collectFromRequestParameters(HttpServletRequest request) {\n\n\t\tEnumeration<String> paramNamesEnumeration = request.getParameterNames();\n\n\t\twhile (paramNamesEnumeration.hasMoreElements()) {\n\n\t\t\tString parameterName = paramNamesEnumeration.nextElement();\n\n\t\t\tString[] parameterValues =\n\t\t\t\trequest.getParameterValues(parameterName);\n\n\t\t\tObject value = null;\n\n\t\t\tif (parameterValues.length == 1) {\n\t\t\t\tvalue = parameterValues[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = parameterValues;\n\t\t\t}\n\n\t\t\t_addNameValue(parameterName, value);\n\t\t}\n\t}","id":29656,"modified_method":"private void _collectFromRequestParameters(HttpServletRequest request) {\n\t\tEnumeration<String> enu = request.getParameterNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString parameterName = enu.nextElement();\n\n\t\t\tString[] parameterValues = request.getParameterValues(\n\t\t\t\tparameterName);\n\n\t\t\tObject value = null;\n\n\t\t\tif (parameterValues.length == 1) {\n\t\t\t\tvalue = parameterValues[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = parameterValues;\n\t\t\t}\n\n\t\t\tObjectValuePair<String, Object> objectValuePair =\n\t\t\t\tnew ObjectValuePair<String, Object>(parameterName, value);\n\n\t\t\t_parameters.add(objectValuePair);\n\t\t}\n\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void collectFromPath(String pathParameters) {\n\n\t\tif (pathParameters == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (pathParameters.startsWith(StringPool.SLASH)) {\n\t\t\tpathParameters = pathParameters.substring(1);\n\t\t}\n\n\t\tString[] chunks = StringUtil.split(pathParameters, StringPool.SLASH);\n\n\t\tint i = 0;\n\n\t\tint total = (chunks.length / 2) * 2;\n\n\t\twhile (i < total) {\n\t\t\tString name = chunks[i];\n\n\t\t\tname = name.replace('-', ' ');\n\n\t\t\tname = jodd.util.StringUtil.wordsToCamelCase(name);\n\n\t\t\tString value = chunks[i + 1];\n\n\t\t\t_addNameValue(name, value);\n\n\t\t\ti += 2;\n\t\t}\n\t}","id":29657,"modified_method":"private void _collectFromPath(String pathParameters) {\n\t\tif (pathParameters == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (pathParameters.startsWith(StringPool.SLASH)) {\n\t\t\tpathParameters = pathParameters.substring(1);\n\t\t}\n\n\t\tString[] pathParametersParts = StringUtil.split(\n\t\t\tpathParameters, StringPool.SLASH);\n\n\t\tint length = (pathParametersParts.length / 2) * 2;\n\n\t\tfor (int i = 0; i < length;) {\n\t\t\tString name = pathParametersParts[i];\n\n\t\t\tname = name.replace(CharPool.DASH, CharPool.SPACE);\n\n\t\t\tname = jodd.util.StringUtil.wordsToCamelCase(name);\n\n\t\t\tString value = pathParametersParts[i + 1];\n\n\t\t\tObjectValuePair<String, Object> objectValuePair =\n\t\t\t\tnew ObjectValuePair<String, Object>(name, value);\n\n\t\t\t_parameters.add(objectValuePair);\n\n\t\t\ti += 2;\n\t\t}\n\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String[] extractParameterNames() {\n\t\tString[] names = new String[_parameters.size()];\n\n\t\tint i = 0;\n\n\t\tfor (NameValue nameValue : _parameters) {\n\n\t\t\tnames[i] = nameValue.getName();\n\n\t\t\ti++;\n\t\t}\n\t\treturn names;\n\t}","id":29658,"modified_method":"public String[] getParameterNames() {\n\t\tString[] names = new String[_parameters.size()];\n\n\t\tint i = 0;\n\n\t\tfor (ObjectValuePair<String, Object> parameter : _parameters) {\n\t\t\tnames[i] = parameter.getKey();\n\n\t\t\ti++;\n\t\t}\n\n\t\treturn names;\n\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void collectAll(HttpServletRequest request, String pathParameters) {\n\t\tcollectFromPath(pathParameters);\n\t\tcollectFromRequestParameters(request);\n\t}","id":29659,"modified_method":"public void collectAll(HttpServletRequest request, String pathParameters) {\n\t\t_collectFromPath(pathParameters);\n\t\t_collectFromRequestParameters(request);\n\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object lookupParameter(String name) {\n\t\tfor (NameValue nameValue : _parameters) {\n\t\t\tif (nameValue.getName().equals(name)) {\n\t\t\t\treturn nameValue.getValue();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":29660,"modified_method":"public Object getParameter(String name) {\n\t\tfor (ObjectValuePair<String, Object> parameter : _parameters) {\n\t\t\tif (parameter.getKey().equals(name)) {\n\t\t\t\treturn parameter.getValue();\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private int _indexOfPathParameters(String path) {\n\n\t\tint index = path.indexOf('/', 1);\n\n\t\tindex = path.indexOf('/', index + 1);\n\n\t\treturn index;\n\t}","id":29661,"modified_method":"private int _getPathParametersIndex(String path) {\n\t\tint index = path.indexOf(CharPool.SLASH, 1);\n\n\t\tindex = path.indexOf(CharPool.SLASH, index + 1);\n\n\t\treturn index;\n\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected int compare(int index, String element) {\n\t\t\tRESTActionConfig rac = _restActionConfig.get(index);\n\n\t\t\treturn rac.getPath().compareTo(element);\n\t\t}","id":29662,"modified_method":"protected int compare(int index, String element) {\n\t\t\tRESTActionConfig restActionConfig = _restActionConfig.get(index);\n\n\t\t\tString path = restActionConfig.getPath();\n\n\t\t\treturn path.compareTo(element);\n\t\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public RESTAction lookup(HttpServletRequest request) {\n\n\t\tString path = GetterUtil.getString(request.getPathInfo());\n\n\t\tString method = GetterUtil.getString(request.getMethod());\n\n\t\tString pathParameters = null;\n\n\t\tint pathParametersIndex = _indexOfPathParameters(path);\n\n\t\tif (pathParametersIndex != -1) {\n\t\t\tpathParameters = path.substring(pathParametersIndex);\n\n\t\t\tpath = path.substring(0, pathParametersIndex);\n\t\t}\n\n\t\tRESTActionParameters restActionParameters = new RESTActionParameters();\n\n\t\trestActionParameters.collectAll(request, pathParameters);\n\n\t\tString parameterNames[] = restActionParameters.extractParameterNames();\n\n\t\tint index = _lookup(path, method, parameterNames);\n\n\t\tif (index == -1) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\"No REST action associated with path \" + path +\n\t\t\t\t\t\" and method \" + method);\n\t\t}\n\n\t\tRESTActionConfig restActionConfig = _restActionConfig.get(index);\n\n\t\treturn new RESTActionImpl(restActionConfig, restActionParameters);\n\t}","id":29663,"modified_method":"public RESTAction lookup(HttpServletRequest request) {\n\t\tString path = GetterUtil.getString(request.getPathInfo());\n\n\t\tString method = GetterUtil.getString(request.getMethod());\n\n\t\tString pathParameters = null;\n\n\t\tint pathParametersIndex = _getPathParametersIndex(path);\n\n\t\tif (pathParametersIndex != -1) {\n\t\t\tpathParameters = path.substring(pathParametersIndex);\n\n\t\t\tpath = path.substring(0, pathParametersIndex);\n\t\t}\n\n\t\tRESTActionParameters restActionParameters = new RESTActionParameters();\n\n\t\trestActionParameters.collectAll(request, pathParameters);\n\n\t\tString[] parameterNames = restActionParameters.getParameterNames();\n\n\t\tint restActionConfigIndex = _getRESTActionConfigIndex(\n\t\t\tpath, method, parameterNames);\n\n\t\tif (restActionConfigIndex == -1) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\"No REST action associated with path \" + path +\n\t\t\t\t\t\" and method \" + method);\n\t\t}\n\n\t\tRESTActionConfig restActionConfig = _restActionConfig.get(\n\t\t\trestActionConfigIndex);\n\n\t\treturn new RESTActionImpl(restActionConfig, restActionParameters);\n\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _onRESTClass(String className) throws Exception {\n\t\tClass<?> actionClass = _classLoader.loadClass(className);\n\n\t\tif (!_isRESTClass(actionClass)) {\n\t\t\treturn;\n\t\t}\n\n\t\tRESTMode classScanMode = RESTMode.MANUAL;\n\n\t\tREST restClassAnnotation = actionClass.getAnnotation(REST.class);\n\n\t\tif (restClassAnnotation != null) {\n\t\t\tclassScanMode = restClassAnnotation.mode();\n\t\t}\n\n\t\tMethod[] methods = actionClass.getMethods();\n\n\t\tfor (Method method : methods) {\n\n\t\t\tif (!method.getDeclaringClass().equals(actionClass)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean registerMethod = false;\n\n\t\t\tREST restMethodAnnotation = method.getAnnotation(REST.class);\n\n\t\t\tif (classScanMode == RESTMode.AUTO) {\n\n\t\t\t\tregisterMethod = true;\n\n\t\t\t\tif ((restMethodAnnotation != null)\n\t\t\t\t\t&& (restMethodAnnotation.mode() == RESTMode.IGNORE)) {\n\n\t\t\t\t\tregisterMethod = false;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif (restMethodAnnotation != null\n\t\t\t\t\t&& restMethodAnnotation.mode() != RESTMode.IGNORE) {\n\n\t\t\t\t\tregisterMethod = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (registerMethod) {\n\t\t\t\t_registerRESTAction(actionClass, method);\n\t\t\t}\n\t\t}\n\t}","id":29664,"modified_method":"private void _onRESTClass(String className) throws Exception {\n\t\tClass<?> actionClass = _classLoader.loadClass(className);\n\n\t\tif (!_isRESTClass(actionClass)) {\n\t\t\treturn;\n\t\t}\n\n\t\tREST restClassAnnotation = actionClass.getAnnotation(REST.class);\n\n\t\tRESTMode restClassRestMode = RESTMode.MANUAL;\n\n\t\tif (restClassAnnotation != null) {\n\t\t\trestClassRestMode = restClassAnnotation.mode();\n\t\t}\n\n\t\tMethod[] methods = actionClass.getMethods();\n\n\t\tfor (Method method : methods) {\n\t\t\tClass<?> methodDeclaringClass = method.getDeclaringClass();\n\n\t\t\tif (!methodDeclaringClass.equals(actionClass)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean registerMethod = false;\n\n\t\t\tREST restMethodAnnotation = method.getAnnotation(REST.class);\n\n\t\t\tif (restClassRestMode.equals(RESTMode.AUTO)) {\n\t\t\t\tregisterMethod = true;\n\n\t\t\t\tif (restMethodAnnotation != null) {\n\t\t\t\t\tRESTMode restMethodRestMode = restMethodAnnotation.mode();\n\n\t\t\t\t\tif (restMethodRestMode.equals(RESTMode.IGNORE)) {\n\t\t\t\t\t\tregisterMethod = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (restMethodAnnotation != null) {\n\t\t\t\t\tRESTMode restMethodRestMode = restMethodAnnotation.mode();\n\n\t\t\t\t\tif (!restMethodRestMode.equals(RESTMode.IGNORE)) {\n\t\t\t\t\t\tregisterMethod = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (registerMethod) {\n\t\t\t\t_registerRESTAction(actionClass, method);\n\t\t\t}\n\t\t}\n\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Class _loadUtilClass(Class implementationClass)\n\t\tthrows ClassNotFoundException {\n\n\t\tClass utilClass = _utilClasses.get(implementationClass);\n\n\t\tif (utilClass == null) {\n\t\t\tString utilClassName = implementationClass.getName();\n\n\t\t\tif (utilClassName.endsWith(\"Impl\")) {\n\t\t\t\tutilClassName = utilClassName.substring(\n\t\t\t\t\t0, utilClassName.length() - 4);\n\n\t\t\t\tutilClassName += \"Util\";\n\t\t\t}\n\n\t\t\tutilClassName = StringUtil.replace(utilClassName, \".impl.\", \".\");\n\n\t\t\tutilClass = _classLoader.loadClass(utilClassName);\n\n\t\t\t_utilClasses.put(implementationClass, utilClass);\n\t\t}\n\n\t\treturn utilClass;\n\t}","id":29665,"modified_method":"private Class<?> _loadUtilClass(Class<?> implementationClass)\n\t\tthrows ClassNotFoundException {\n\n\t\tClass<?> utilClass = _utilClasses.get(implementationClass);\n\n\t\tif (utilClass != null) {\n\t\t\treturn utilClass;\n\t\t}\n\n\t\tString utilClassName = implementationClass.getName();\n\n\t\tif (utilClassName.endsWith(\"Impl\")) {\n\t\t\tutilClassName = utilClassName.substring(\n\t\t\t\t0, utilClassName.length() - 4);\n\n\t\t\tutilClassName += \"Util\";\n\t\t}\n\n\t\tutilClassName = StringUtil.replace(utilClassName, \".impl.\", \".\");\n\n\t\tutilClass = _classLoader.loadClass(utilClassName);\n\n\t\t_utilClasses.put(implementationClass, utilClass);\n\n\t\treturn utilClass;\n\t}","commit_id":"6c2244a57bbc623ab3c57b6082b5c0e19854a3f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Modifies a present access control entry for a resource.<p>\n     * \n     * @param request the Http servlet request\n     * @return true if the modification worked, otherwise false \n     */\n    public boolean actionModifyAce(HttpServletRequest request) {\n\n        String file = getParamResource();\n\n        // get request parameters\n        String name = getParamName();\n        String type = getParamType();\n        String inherit = request.getParameter(PARAM_INHERIT);\n        String overWriteInherited = request.getParameter(PARAM_OVERWRITEINHERITED);\n        String responsible = request.getParameter(PARAM_RESPONSIBLE);\n\n        // get the new permissions\n        Set permissionKeys = CmsPermissionSet.getPermissionKeys();\n        int allowValue = 0;\n        int denyValue = 0;\n        String key, param;\n        int value, paramInt;\n\n        Iterator i = permissionKeys.iterator();\n        // loop through all possible permissions \n        while (i.hasNext()) {\n            key = (String)i.next();\n            value = CmsPermissionSet.getPermissionValue(key);\n            // set the right allowed and denied permissions from request parameters\n            try {\n                param = request.getParameter(value + PERMISSION_ALLOW);\n                paramInt = Integer.parseInt(param);\n                allowValue |= paramInt;\n            } catch (Exception e) {\n                // can usually be ignored\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(e.getLocalizedMessage());\n                }\n            }\n            try {\n                param = request.getParameter(value + PERMISSION_DENY);\n                paramInt = Integer.parseInt(param);\n                denyValue |= paramInt;\n            } catch (Exception e) {\n                // can usually be ignored\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(e.getLocalizedMessage());\n                }\n            }\n        }\n\n        // get the current Ace to get the current ace flags\n        try {\n            List allEntries = getCms().getAccessControlEntries(file, false);\n            int flags = 0;\n            for (int k = 0; k < allEntries.size(); k++) {\n                CmsAccessControlEntry curEntry = (CmsAccessControlEntry)allEntries.get(k);\n                String curType = getEntryType(curEntry.getFlags(), false);\n                I_CmsPrincipal p = getCms().lookupPrincipal(curEntry.getPrincipal());\n                if (((p != null) && p.getName().equals(name) && curType.equals(type))) {\n                    flags = curEntry.getFlags();\n                    break;\n                } else if (p == null) {\n                    // check if it is the case of a role\n                    CmsRole role = CmsRole.valueOfId(curEntry.getPrincipal());\n                    if ((role != null) && name.equals(role.getRoleName())) {\n                        flags = curEntry.getFlags();\n                        break;\n                    } else if ((curEntry.getPrincipal().equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID) && name.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_NAME))\n                        || (curEntry.getPrincipal().equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_ID) && name.equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_NAME))) {\n                        flags = curEntry.getFlags();\n                        break;\n                    }\n                }\n            }\n\n            // modify the ace flags to determine inheritance of the current ace\n            if (Boolean.valueOf(inherit).booleanValue()) {\n                flags |= CmsAccessControlEntry.ACCESS_FLAGS_INHERIT;\n            } else {\n                flags &= ~CmsAccessControlEntry.ACCESS_FLAGS_INHERIT;\n            }\n\n            // modify the ace flags to determine overwriting of inherited ace\n            if (Boolean.valueOf(overWriteInherited).booleanValue()) {\n                flags |= CmsAccessControlEntry.ACCESS_FLAGS_OVERWRITE;\n            } else {\n                flags &= ~CmsAccessControlEntry.ACCESS_FLAGS_OVERWRITE;\n            }\n\n            if (Boolean.valueOf(responsible).booleanValue()) {\n                flags |= CmsAccessControlEntry.ACCESS_FLAGS_RESPONSIBLE;\n            } else {\n                flags &= ~CmsAccessControlEntry.ACCESS_FLAGS_RESPONSIBLE;\n            }\n\n            // lock resource if autolock is enabled\n            checkLock(getParamResource());\n            // try to change the access entry   \n            if (name.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID.toString())) {\n                getCms().chacc(\n                    file,\n                    type,\n                    CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_NAME,\n                    allowValue,\n                    denyValue,\n                    flags);\n            } else if (name.equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_ID.toString())) {\n                getCms().chacc(\n                    file,\n                    type,\n                    CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_NAME,\n                    allowValue,\n                    denyValue,\n                    flags);\n            } else {\n                getCms().chacc(file, type, name, allowValue, denyValue, flags);\n            }\n            return true;\n        } catch (CmsException e) {\n            m_errorMessages.add(key(Messages.ERR_CHACC_MODIFY_ENTRY_0));\n            if (LOG.isErrorEnabled()) {\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n            return false;\n        }\n    }","id":29666,"modified_method":"/**\n     * Modifies a present access control entry for a resource.<p>\n     * \n     * @param request the Http servlet request\n     * @return true if the modification worked, otherwise false \n     */\n    public boolean actionModifyAce(HttpServletRequest request) {\n\n        String file = getParamResource();\n\n        // get request parameters\n        String name = getParamName();\n        String type = getParamType();\n        String inherit = request.getParameter(PARAM_INHERIT);\n        String overWriteInherited = request.getParameter(PARAM_OVERWRITEINHERITED);\n        String responsible = request.getParameter(PARAM_RESPONSIBLE);\n\n        // get the new permissions\n        Set permissionKeys = CmsPermissionSet.getPermissionKeys();\n        int allowValue = 0;\n        int denyValue = 0;\n        String key, param;\n        int value, paramInt;\n\n        Iterator i = permissionKeys.iterator();\n        // loop through all possible permissions \n        while (i.hasNext()) {\n            key = (String)i.next();\n            value = CmsPermissionSet.getPermissionValue(key);\n            // set the right allowed and denied permissions from request parameters\n            try {\n                param = request.getParameter(value + PERMISSION_ALLOW);\n                paramInt = Integer.parseInt(param);\n                allowValue |= paramInt;\n            } catch (Exception e) {\n                // can usually be ignored\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(e.getLocalizedMessage());\n                }\n            }\n            try {\n                param = request.getParameter(value + PERMISSION_DENY);\n                paramInt = Integer.parseInt(param);\n                denyValue |= paramInt;\n            } catch (Exception e) {\n                // can usually be ignored\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(e.getLocalizedMessage());\n                }\n            }\n        }\n\n        // get the current Ace to get the current ace flags\n        try {\n            List allEntries = getCms().getAccessControlEntries(file, false);\n            int flags = 0;\n            for (int k = 0; k < allEntries.size(); k++) {\n                CmsAccessControlEntry curEntry = (CmsAccessControlEntry)allEntries.get(k);\n                String curType = getEntryType(curEntry.getFlags(), false);\n                I_CmsPrincipal p;\n                try {\n                    p = CmsPrincipal.readPrincipalIncludingHistory(getCms(), curEntry.getPrincipal());\n                } catch (CmsException e) {\n                    p = null;\n                }\n                if (((p != null) && p.getName().equals(name) && curType.equals(type))) {\n                    flags = curEntry.getFlags();\n                    break;\n                } else if (p == null) {\n                    // check if it is the case of a role\n                    CmsRole role = CmsRole.valueOfId(curEntry.getPrincipal());\n                    if ((role != null) && name.equals(role.getRoleName())) {\n                        flags = curEntry.getFlags();\n                        break;\n                    } else if ((curEntry.getPrincipal().equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID) && name.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_NAME))\n                        || (curEntry.getPrincipal().equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_ID) && name.equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_NAME))) {\n                        flags = curEntry.getFlags();\n                        break;\n                    }\n                }\n            }\n\n            // modify the ace flags to determine inheritance of the current ace\n            if (Boolean.valueOf(inherit).booleanValue()) {\n                flags |= CmsAccessControlEntry.ACCESS_FLAGS_INHERIT;\n            } else {\n                flags &= ~CmsAccessControlEntry.ACCESS_FLAGS_INHERIT;\n            }\n\n            // modify the ace flags to determine overwriting of inherited ace\n            if (Boolean.valueOf(overWriteInherited).booleanValue()) {\n                flags |= CmsAccessControlEntry.ACCESS_FLAGS_OVERWRITE;\n            } else {\n                flags &= ~CmsAccessControlEntry.ACCESS_FLAGS_OVERWRITE;\n            }\n\n            if (Boolean.valueOf(responsible).booleanValue()) {\n                flags |= CmsAccessControlEntry.ACCESS_FLAGS_RESPONSIBLE;\n            } else {\n                flags &= ~CmsAccessControlEntry.ACCESS_FLAGS_RESPONSIBLE;\n            }\n\n            // lock resource if autolock is enabled\n            checkLock(getParamResource());\n            // try to change the access entry   \n            if (name.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID.toString())) {\n                getCms().chacc(\n                    file,\n                    type,\n                    CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_NAME,\n                    allowValue,\n                    denyValue,\n                    flags);\n            } else if (name.equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_ID.toString())) {\n                getCms().chacc(\n                    file,\n                    type,\n                    CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_NAME,\n                    allowValue,\n                    denyValue,\n                    flags);\n            } else {\n                getCms().chacc(file, type, name, allowValue, denyValue, flags);\n            }\n            return true;\n        } catch (CmsException e) {\n            m_errorMessages.add(key(Messages.ERR_CHACC_MODIFY_ENTRY_0));\n            if (LOG.isErrorEnabled()) {\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n            return false;\n        }\n    }","commit_id":"ef54b93aa239993a1627b2a83b388dc1334bf30a","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates an HTML input form for the current access control entry.<p>\n     * \n     * @param entry the current access control entry\n     * @param editable boolean to determine if the form is editable\n     * @param extendedView boolean to determine if the view is selectable with DHTML\n     * @param inheritRes the resource name from which the ace is inherited\n     * @return StringBuffer with HTML code of the form\n     */\n    private StringBuffer buildPermissionEntryForm(\n        CmsAccessControlEntry entry,\n        boolean editable,\n        boolean extendedView,\n        String inheritRes) {\n\n        StringBuffer result = new StringBuffer(8);\n\n        // get name and type of the current entry\n        I_CmsPrincipal principal = getCms().lookupPrincipal(entry.getPrincipal());\n        String id = (principal != null) ? principal.getName() : entry.getPrincipal().toString();\n        String name;\n        String ou = null;\n        int flags = 0;\n        if (principal instanceof CmsGroup) {\n            name = key(org.opencms.security.Messages.GUI_ORGUNIT_DISPLAY_NAME_2, new Object[] {\n                ((CmsGroup)principal).getDescription(getLocale()),\n                principal.getSimpleName()});\n            ou = CmsOrganizationalUnit.getParentFqn(id);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_GROUP;\n        } else if (principal instanceof CmsUser) {\n            name = ((CmsUser)principal).getFullName();\n            ou = CmsOrganizationalUnit.getParentFqn(id);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_USER;\n        } else if ((id != null) && id.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID.toString())) {\n            name = key(Messages.GUI_LABEL_ALLOTHERS_0);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_ALLOTHERS;\n        } else if ((id != null) && id.equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_ID.toString())) {\n            name = key(Messages.GUI_LABEL_OVERWRITEALL_0);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_OVERWRITE_ALL;\n        } else {\n            // check if it is the case of a role\n            CmsRole role = CmsRole.valueOfId(entry.getPrincipal());\n            if (role != null) {\n                name = role.getName(getLocale());\n                id = role.getRoleName();\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_ROLE;\n            } else {\n                name = entry.getPrincipal().toString();\n            }\n        }\n\n        if ((flags > 0) && ((entry.getFlags() & flags) == 0)) {\n            // the flag is set to the wrong principal type\n            if (LOG.isErrorEnabled()) {\n                LOG.error(Messages.get().getBundle(getLocale()).key(Messages.ERR_INVALID_ACE_1, entry.toString()));\n            }\n            entry = new CmsAccessControlEntry(\n                entry.getResource(),\n                entry.getPrincipal(),\n                entry.getAllowedPermissions(),\n                entry.getDeniedPermissions(),\n                (entry.getFlags() | flags));\n        } else if (entry.getFlags() < CmsAccessControlEntry.ACCESS_FLAGS_USER) {\n            // the flag is set to NO principal type\n            if (LOG.isErrorEnabled()) {\n                LOG.error(Messages.get().getBundle(getLocale()).key(Messages.ERR_INVALID_ACE_1, entry.toString()));\n            }\n            entry = new CmsAccessControlEntry(\n                entry.getResource(),\n                entry.getPrincipal(),\n                entry.getAllowedPermissions(),\n                entry.getDeniedPermissions(),\n                (entry.getFlags() | CmsAccessControlEntry.ACCESS_FLAGS_GROUP));\n        }\n\n        String type = getEntryType(entry.getFlags(), false);\n\n        if (id == null) {\n            id = \"\";\n        }\n\n        // set the parameters for the hidden fields\n        setParamType(type);\n        setParamName(id);\n\n        // set id value for html attributes\n        String idValue = type + id + entry.getResource();\n\n        // get the localized type label\n        int typeInt = getEntryTypeInt(entry.getFlags());\n        String typeLocalized = UNKNOWN_TYPE;\n        if (typeInt >= 0) {\n            typeLocalized = getTypesLocalized()[typeInt];\n        }\n\n        // determine the right image to display\n        String typeImg = getTypes(true)[0];\n        if (typeInt >= 0) {\n            typeImg = getEntryType(entry.getFlags(), true).toLowerCase();\n        }\n\n        // get all permissions of the current entry\n        CmsPermissionSet permissions = entry.getPermissions();\n\n        // build String for disabled check boxes\n        String disabled = \"\";\n        if (!editable || (typeInt < 0)) {\n            disabled = \" disabled=\\\"disabled\\\"\";\n        }\n\n        // build the heading\n        if (!id.equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_ID.toString())) {\n            result.append(dialogRow(HTML_START));\n            if (extendedView) {\n                // for extended view, add toggle symbol and link to output\n                result.append(\"<a href=\\\"javascript:toggleDetail('\").append(idValue).append(\"');\\\">\");\n                result.append(\"<img src=\\\"\").append(getSkinUri()).append(\n                    \"commons/plus.png\\\" class=\\\"noborder\\\" id=\\\"ic-\").append(idValue).append(\"\\\"><\/a>\");\n            } else {\n                result.append(\"<img src='\").append(getSkinUri()).append(\n                    \"explorer/project_none.gif' class='noborder' width='16' height='16' >\");\n            }\n            result.append(\"<img src=\\\"\").append(getSkinUri()).append(\"commons/\");\n            result.append(typeImg);\n            result.append(\".png\\\" class=\\\"noborder\\\" width=\\\"16\\\" height=\\\"16\\\" alt=\\\"\");\n            result.append(typeLocalized);\n            result.append(\"\\\" title=\\\"\");\n            result.append(typeLocalized);\n            result.append(\"\\\">&nbsp;<span class=\\\"textbold\\\">\");\n            result.append(name);\n            result.append(\"<\/span>\");\n            if (!id.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID.toString())) {\n                if (extendedView) {\n                    // for extended view, add short permissions\n                    result.append(\"&nbsp;(\").append(entry.getPermissions().getPermissionString()).append(\")\");\n                }\n                try {\n                    if ((ou != null)\n                        && (OpenCms.getOrgUnitManager().getOrganizationalUnits(getCms(), \"\", true).size() > 1)) {\n                        result.append(\"<br>\");\n                        result.append(\"<img src='\").append(getSkinUri()).append(\n                            \"explorer/project_none.gif' class='noborder' width='16' height='16' >\");\n                        result.append(\"<img src='\").append(getSkinUri()).append(\n                            \"explorer/project_none.gif' class='noborder' width='16' height='16' >\");\n                        result.append(\"&nbsp;\");\n                        try {\n                            result.append(OpenCms.getOrgUnitManager().readOrganizationalUnit(getCms(), ou).getDisplayName(\n                                getLocale()));\n                        } catch (CmsException e) {\n                            result.append(ou);\n                        }\n                    }\n                } catch (CmsException e) {\n                    // should never happen\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(e.getLocalizedMessage());\n                    }\n                }\n            }\n            result.append(dialogRow(HTML_END));\n            if (extendedView) {\n                // show the resource from which the ace is inherited if present\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(inheritRes)) {\n                    result.append(\"<div class=\\\"dialogpermissioninherit\\\">\");\n                    result.append(\"<img src='\").append(getSkinUri()).append(\n                        \"explorer/project_none.gif' class='noborder' width='16' height='16' >\");\n                    result.append(\"&nbsp;\");\n                    result.append(key(Messages.GUI_PERMISSION_INHERITED_FROM_1, new Object[] {inheritRes}));\n                    result.append(\"<\/div>\\n\");\n                }\n                result.append(\"<div id =\\\"\").append(idValue).append(\"\\\" class=\\\"hide\\\">\");\n            }\n            result.append(\"<table class=\\\"dialogpermissiondetails\\\">\\n\");\n\n            // build the form depending on the editable flag\n            if (editable) {\n                result.append(\"<form action=\\\"\").append(getDialogUri()).append(\n                    \"\\\" method=\\\"post\\\" class=\\\"nomargin\\\" name=\\\"set\").append(idValue).append(\"\\\">\\n\");\n                // set parameters to show correct hidden input fields\n                setParamAction(DIALOG_SET);\n                result.append(paramsAsHidden());\n            } else {\n                result.append(\"<form class=\\\"nomargin\\\">\\n\");\n            }\n\n            // build headings for permission descriptions\n            result.append(\"<tr>\\n\");\n            result.append(\"\\t<td class=\\\"dialogpermissioncell\\\"><span class=\\\"textbold\\\" unselectable=\\\"on\\\">\");\n            result.append(key(Messages.GUI_PERMISSION_0)).append(\"<\/span><\/td>\\n\");\n            result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\"><span class=\\\"textbold\\\" unselectable=\\\"on\\\">\");\n            result.append(key(Messages.GUI_PERMISSION_ALLOWED_0)).append(\"<\/span><\/td>\\n\");\n            result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\"><span class=\\\"textbold\\\" unselectable=\\\"on\\\">\");\n            result.append(key(Messages.GUI_PERMISSION_DENIED_0)).append(\"<\/span><\/td>\\n\");\n            result.append(\"<\/tr>\");\n\n            Iterator i = m_permissionKeys.iterator();\n\n            // show all possible permissions in the form\n            while (i.hasNext()) {\n                String key = (String)i.next();\n                int value = CmsPermissionSet.getPermissionValue(key);\n                String keyMessage = key(key);\n                result.append(\"<tr>\\n\");\n                result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">\").append(keyMessage).append(\"<\/td>\\n\");\n                result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\"><input type=\\\"checkbox\\\" name=\\\"\");\n                result.append(value).append(PERMISSION_ALLOW).append(\"\\\" value=\\\"\").append(value).append(\"\\\"\").append(\n                    disabled);\n                if (isAllowed(permissions, value)) {\n                    result.append(\" checked=\\\"checked\\\"\");\n                }\n                result.append(\"><\/td>\\n\");\n                result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\"><input type=\\\"checkbox\\\" name=\\\"\");\n                result.append(value).append(PERMISSION_DENY).append(\"\\\" value=\\\"\").append(value).append(\"\\\"\").append(\n                    disabled);\n                if (isDenied(permissions, value)) {\n                    result.append(\" checked=\\\"checked\\\"\");\n                }\n                result.append(\"><\/td>\\n\");\n                result.append(\"<\/tr>\\n\");\n            }\n\n            // show overwrite check box and buttons only for editable entries\n            if (editable) {\n                // do not show the responsible option for the 'all others' ace\n                if (!id.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID.toString())) {\n                    // show owner check box\n                    result.append(\"<tr>\\n\");\n                    result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">\").append(key(Messages.GUI_LABEL_RESPONSIBLE_0)).append(\n                        \"<\/td>\\n\");\n                    result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\">\");\n                    result.append(\"<input type=\\\"checkbox\\\" name=\\\"\").append(PARAM_RESPONSIBLE).append(\n                        \"\\\" value=\\\"true\\\"\").append(disabled);\n                    if (isResponsible(entry.getFlags())) {\n                        result.append(\" checked=\\\"checked\\\"\");\n                    }\n                    result.append(\"><\/td>\\n\");\n                    result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">&nbsp;<\/td>\\n\");\n                    result.append(\"<\/tr>\\n\");\n                }\n                // show overwrite inherited check box\n                result.append(\"<tr>\\n\");\n                result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">\").append(\n                    key(Messages.GUI_PERMISSION_OVERWRITE_INHERITED_0)).append(\"<\/td>\\n\");\n                result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\">\");\n                result.append(\"<input type=\\\"checkbox\\\" name=\\\"\").append(PARAM_OVERWRITEINHERITED).append(\n                    \"\\\" value=\\\"true\\\"\").append(disabled);\n                if (isOverWritingInherited(entry.getFlags())) {\n                    result.append(\" checked=\\\"checked\\\"\");\n                }\n                result.append(\"><\/td>\\n\");\n                result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">&nbsp;<\/td>\\n\");\n                result.append(\"<\/tr>\\n\");\n\n                // show inherit permissions check box on folders\n                if (getInheritOption()) {\n                    result.append(\"<tr>\\n\");\n                    result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">\").append(\n                        key(Messages.GUI_PERMISSION_INHERIT_ON_SUBFOLDERS_0)).append(\"<\/td>\\n\");\n                    result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\">\");\n                    result.append(\"<input type=\\\"checkbox\\\" name=\\\"\").append(PARAM_INHERIT).append(\"\\\" value=\\\"true\\\"\").append(\n                        disabled);\n                    if (entry.isInheriting()) {\n                        result.append(\" checked=\\\"checked\\\"\");\n                    }\n                    result.append(\"><\/td>\\n\");\n                    result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">&nbsp;<\/td>\\n\");\n                    result.append(\"<\/tr>\\n\");\n                }\n\n                // show \"set\" and \"delete\" buttons    \n                result.append(\"<tr>\\n\");\n                result.append(\"\\t<td>&nbsp;<\/td>\\n\");\n                result.append(\"\\t<td class=\\\"textcenter\\\"><input class=\\\"dialogbutton\\\" type=\\\"submit\\\" value=\\\"\").append(\n                    key(Messages.GUI_LABEL_SET_0)).append(\"\\\"><\/form><\/td>\\n\");\n                result.append(\"\\t<td class=\\\"textcenter\\\">\\n\");\n                // build the form for the \"delete\" button            \n                result.append(\"\\t\\t<form class=\\\"nomargin\\\" action=\\\"\").append(getDialogUri()).append(\n                    \"\\\" method=\\\"post\\\" name=\\\"delete\").append(idValue).append(\"\\\">\\n\");\n                // set parameters to show correct hidden input fields\n                setParamAction(DIALOG_DELETE);\n                result.append(paramsAsHidden());\n                result.append(\"\\t\\t<input class=\\\"dialogbutton\\\" type=\\\"submit\\\" value=\\\"\").append(\n                    key(Messages.GUI_LABEL_DELETE_0)).append(\"\\\">\\n\");\n                result.append(\"\\t\\t<\/form>\\n\");\n                result.append(\"\\t<\/td>\\n\");\n                result.append(\"<\/tr>\\n\");\n            } else {\n                // close the form\n                result.append(\"<\/form>\\n\");\n            }\n\n            result.append(\"<\/table>\\n\");\n            if (extendedView) {\n                // close the hidden div for extended view\n                result.append(\"<\/div>\");\n            }\n        } else {\n            result.append(dialogRow(HTML_START));\n\n            result.append(\"<table style='margin-left: 13px;' class=\\\"dialogpermissiondetails\\\">\\n\");\n            // build headings for permission descriptions\n            result.append(\"<tr>\\n\");\n            result.append(\"\\t<td style=\\\"width: 280px;\\\"><span class=\\\"textbold\\\" unselectable=\\\"on\\\">\");\n\n            result.append(\"<img src=\\\"\").append(getSkinUri()).append(\"commons/\");\n            result.append(typeImg);\n            result.append(\".png\\\" class=\\\"noborder\\\" width=\\\"16\\\" height=\\\"16\\\" alt=\\\"\");\n            result.append(typeLocalized);\n            result.append(\"\\\" title=\\\"\");\n            result.append(typeLocalized);\n            result.append(\"\\\">&nbsp;<span class=\\\"textbold\\\">\");\n            result.append(name);\n            result.append(\"<\/span><\/td>\\n\");\n            result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\"><span class=\\\"textbold\\\" unselectable=\\\"on\\\">\");\n            if (editable) {\n                // build the form for the \"delete\" button            \n                result.append(\"\\t\\t<form class=\\\"nomargin\\\" action=\\\"\").append(getDialogUri()).append(\n                    \"\\\" method=\\\"post\\\" name=\\\"delete\").append(idValue).append(\"\\\">\\n\");\n                // set parameters to show correct hidden input fields\n                setParamAction(DIALOG_DELETE);\n                result.append(paramsAsHidden());\n                result.append(\"\\t\\t<input class=\\\"dialogbutton\\\" type=\\\"submit\\\" value=\\\"\").append(\n                    key(Messages.GUI_LABEL_DELETE_0)).append(\"\\\">\\n\");\n                result.append(\"\\t\\t<\/form>\\n\");\n            }\n            result.append(\"<\/td>\\n\");\n            result.append(\"<\/tr>\");\n            result.append(\"<\/table>\\n\");\n            result.append(dialogRow(HTML_END));\n\n        }\n        return result;\n    }","id":29667,"modified_method":"/**\n     * Creates an HTML input form for the current access control entry.<p>\n     * \n     * @param entry the current access control entry\n     * @param editable boolean to determine if the form is editable\n     * @param extendedView boolean to determine if the view is selectable with DHTML\n     * @param inheritRes the resource name from which the ace is inherited\n     * @return StringBuffer with HTML code of the form\n     */\n    private StringBuffer buildPermissionEntryForm(\n        CmsAccessControlEntry entry,\n        boolean editable,\n        boolean extendedView,\n        String inheritRes) {\n\n        StringBuffer result = new StringBuffer(8);\n\n        // get name and type of the current entry\n        I_CmsPrincipal principal;\n        try {\n            principal = CmsPrincipal.readPrincipalIncludingHistory(getCms(), entry.getPrincipal());\n        } catch (CmsException e) {\n            principal = null;\n        }\n\n        String id = (principal != null) ? principal.getName() : entry.getPrincipal().toString();\n        String name;\n        String ou = null;\n        int flags = 0;\n        if ((principal != null) && principal.isGroup()) {\n            name = key(org.opencms.security.Messages.GUI_ORGUNIT_DISPLAY_NAME_2, new Object[] {\n                ((CmsGroup)principal).getDescription(getLocale()),\n                principal.getSimpleName()});\n            ou = CmsOrganizationalUnit.getParentFqn(id);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_GROUP;\n        } else if ((principal != null) && principal.isUser()) {\n            name = ((CmsUser)principal).getFullName();\n            ou = CmsOrganizationalUnit.getParentFqn(id);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_USER;\n        } else if ((id != null) && id.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID.toString())) {\n            name = key(Messages.GUI_LABEL_ALLOTHERS_0);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_ALLOTHERS;\n        } else if ((id != null) && id.equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_ID.toString())) {\n            name = key(Messages.GUI_LABEL_OVERWRITEALL_0);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_OVERWRITE_ALL;\n        } else {\n            // check if it is the case of a role\n            CmsRole role = CmsRole.valueOfId(entry.getPrincipal());\n            if (role != null) {\n                name = role.getName(getLocale());\n                id = role.getRoleName();\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_ROLE;\n            } else {\n                name = entry.getPrincipal().toString();\n            }\n        }\n\n        if ((flags > 0) && ((entry.getFlags() & flags) == 0)) {\n            // the flag is set to the wrong principal type\n            if (LOG.isErrorEnabled()) {\n                LOG.error(Messages.get().getBundle(getLocale()).key(Messages.ERR_INVALID_ACE_1, entry.toString()));\n            }\n            entry = new CmsAccessControlEntry(\n                entry.getResource(),\n                entry.getPrincipal(),\n                entry.getAllowedPermissions(),\n                entry.getDeniedPermissions(),\n                (entry.getFlags() | flags));\n        } else if (entry.getFlags() < CmsAccessControlEntry.ACCESS_FLAGS_USER) {\n            // the flag is set to NO principal type\n            if (LOG.isErrorEnabled()) {\n                LOG.error(Messages.get().getBundle(getLocale()).key(Messages.ERR_INVALID_ACE_1, entry.toString()));\n            }\n            entry = new CmsAccessControlEntry(\n                entry.getResource(),\n                entry.getPrincipal(),\n                entry.getAllowedPermissions(),\n                entry.getDeniedPermissions(),\n                (entry.getFlags() | CmsAccessControlEntry.ACCESS_FLAGS_GROUP));\n        }\n\n        String type = getEntryType(entry.getFlags(), false);\n\n        if (id == null) {\n            id = \"\";\n        }\n\n        // set the parameters for the hidden fields\n        setParamType(type);\n        setParamName(id);\n\n        // set id value for html attributes\n        String idValue = type + id + entry.getResource();\n\n        // get the localized type label\n        int typeInt = getEntryTypeInt(entry.getFlags());\n        String typeLocalized = UNKNOWN_TYPE;\n        if (typeInt >= 0) {\n            typeLocalized = getTypesLocalized()[typeInt];\n        }\n\n        // determine the right image to display\n        String typeImg = getTypes(true)[0];\n        if (typeInt >= 0) {\n            typeImg = getEntryType(entry.getFlags(), true).toLowerCase();\n        }\n\n        // get all permissions of the current entry\n        CmsPermissionSet permissions = entry.getPermissions();\n\n        // build String for disabled check boxes\n        String disabled = \"\";\n        if (!editable || (typeInt < 0)) {\n            disabled = \" disabled=\\\"disabled\\\"\";\n        }\n\n        // build the heading\n        if (!id.equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_ID.toString())) {\n            result.append(dialogRow(HTML_START));\n            if (extendedView) {\n                // for extended view, add toggle symbol and link to output\n                result.append(\"<a href=\\\"javascript:toggleDetail('\").append(idValue).append(\"');\\\">\");\n                result.append(\"<img src=\\\"\").append(getSkinUri()).append(\n                    \"commons/plus.png\\\" class=\\\"noborder\\\" id=\\\"ic-\").append(idValue).append(\"\\\"><\/a>\");\n            } else {\n                result.append(\"<img src='\").append(getSkinUri()).append(\n                    \"explorer/project_none.gif' class='noborder' width='16' height='16' >\");\n            }\n            result.append(\"<img src=\\\"\").append(getSkinUri()).append(\"commons/\");\n            result.append(typeImg);\n            result.append(\".png\\\" class=\\\"noborder\\\" width=\\\"16\\\" height=\\\"16\\\" alt=\\\"\");\n            result.append(typeLocalized);\n            result.append(\"\\\" title=\\\"\");\n            result.append(typeLocalized);\n            result.append(\"\\\">&nbsp;<span class=\\\"textbold\\\">\");\n            result.append(name);\n            result.append(\"<\/span>\");\n            if (!id.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID.toString())) {\n                if (extendedView) {\n                    // for extended view, add short permissions\n                    result.append(\"&nbsp;(\").append(entry.getPermissions().getPermissionString()).append(\")\");\n                }\n                try {\n                    if ((ou != null)\n                        && (OpenCms.getOrgUnitManager().getOrganizationalUnits(getCms(), \"\", true).size() > 1)) {\n                        result.append(\"<br>\");\n                        result.append(\"<img src='\").append(getSkinUri()).append(\n                            \"explorer/project_none.gif' class='noborder' width='16' height='16' >\");\n                        result.append(\"<img src='\").append(getSkinUri()).append(\n                            \"explorer/project_none.gif' class='noborder' width='16' height='16' >\");\n                        result.append(\"&nbsp;\");\n                        try {\n                            result.append(OpenCms.getOrgUnitManager().readOrganizationalUnit(getCms(), ou).getDisplayName(\n                                getLocale()));\n                        } catch (CmsException e) {\n                            result.append(ou);\n                        }\n                    }\n                } catch (CmsException e) {\n                    // should never happen\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(e.getLocalizedMessage());\n                    }\n                }\n            }\n            result.append(dialogRow(HTML_END));\n            if (extendedView) {\n                // show the resource from which the ace is inherited if present\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(inheritRes)) {\n                    result.append(\"<div class=\\\"dialogpermissioninherit\\\">\");\n                    result.append(\"<img src='\").append(getSkinUri()).append(\n                        \"explorer/project_none.gif' class='noborder' width='16' height='16' >\");\n                    result.append(\"&nbsp;\");\n                    result.append(key(Messages.GUI_PERMISSION_INHERITED_FROM_1, new Object[] {inheritRes}));\n                    result.append(\"<\/div>\\n\");\n                }\n                result.append(\"<div id =\\\"\").append(idValue).append(\"\\\" class=\\\"hide\\\">\");\n            }\n            result.append(\"<table class=\\\"dialogpermissiondetails\\\">\\n\");\n\n            // build the form depending on the editable flag\n            if (editable) {\n                result.append(\"<form action=\\\"\").append(getDialogUri()).append(\n                    \"\\\" method=\\\"post\\\" class=\\\"nomargin\\\" name=\\\"set\").append(idValue).append(\"\\\">\\n\");\n                // set parameters to show correct hidden input fields\n                setParamAction(DIALOG_SET);\n                result.append(paramsAsHidden());\n            } else {\n                result.append(\"<form class=\\\"nomargin\\\">\\n\");\n            }\n\n            // build headings for permission descriptions\n            result.append(\"<tr>\\n\");\n            result.append(\"\\t<td class=\\\"dialogpermissioncell\\\"><span class=\\\"textbold\\\" unselectable=\\\"on\\\">\");\n            result.append(key(Messages.GUI_PERMISSION_0)).append(\"<\/span><\/td>\\n\");\n            result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\"><span class=\\\"textbold\\\" unselectable=\\\"on\\\">\");\n            result.append(key(Messages.GUI_PERMISSION_ALLOWED_0)).append(\"<\/span><\/td>\\n\");\n            result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\"><span class=\\\"textbold\\\" unselectable=\\\"on\\\">\");\n            result.append(key(Messages.GUI_PERMISSION_DENIED_0)).append(\"<\/span><\/td>\\n\");\n            result.append(\"<\/tr>\");\n\n            Iterator i = m_permissionKeys.iterator();\n\n            // show all possible permissions in the form\n            while (i.hasNext()) {\n                String key = (String)i.next();\n                int value = CmsPermissionSet.getPermissionValue(key);\n                String keyMessage = key(key);\n                result.append(\"<tr>\\n\");\n                result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">\").append(keyMessage).append(\"<\/td>\\n\");\n                result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\"><input type=\\\"checkbox\\\" name=\\\"\");\n                result.append(value).append(PERMISSION_ALLOW).append(\"\\\" value=\\\"\").append(value).append(\"\\\"\").append(\n                    disabled);\n                if (isAllowed(permissions, value)) {\n                    result.append(\" checked=\\\"checked\\\"\");\n                }\n                result.append(\"><\/td>\\n\");\n                result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\"><input type=\\\"checkbox\\\" name=\\\"\");\n                result.append(value).append(PERMISSION_DENY).append(\"\\\" value=\\\"\").append(value).append(\"\\\"\").append(\n                    disabled);\n                if (isDenied(permissions, value)) {\n                    result.append(\" checked=\\\"checked\\\"\");\n                }\n                result.append(\"><\/td>\\n\");\n                result.append(\"<\/tr>\\n\");\n            }\n\n            // show overwrite check box and buttons only for editable entries\n            if (editable) {\n                // do not show the responsible option for the 'all others' ace\n                if (!id.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID.toString())) {\n                    // show owner check box\n                    result.append(\"<tr>\\n\");\n                    result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">\").append(key(Messages.GUI_LABEL_RESPONSIBLE_0)).append(\n                        \"<\/td>\\n\");\n                    result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\">\");\n                    result.append(\"<input type=\\\"checkbox\\\" name=\\\"\").append(PARAM_RESPONSIBLE).append(\n                        \"\\\" value=\\\"true\\\"\").append(disabled);\n                    if (isResponsible(entry.getFlags())) {\n                        result.append(\" checked=\\\"checked\\\"\");\n                    }\n                    result.append(\"><\/td>\\n\");\n                    result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">&nbsp;<\/td>\\n\");\n                    result.append(\"<\/tr>\\n\");\n                }\n                // show overwrite inherited check box\n                result.append(\"<tr>\\n\");\n                result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">\").append(\n                    key(Messages.GUI_PERMISSION_OVERWRITE_INHERITED_0)).append(\"<\/td>\\n\");\n                result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\">\");\n                result.append(\"<input type=\\\"checkbox\\\" name=\\\"\").append(PARAM_OVERWRITEINHERITED).append(\n                    \"\\\" value=\\\"true\\\"\").append(disabled);\n                if (isOverWritingInherited(entry.getFlags())) {\n                    result.append(\" checked=\\\"checked\\\"\");\n                }\n                result.append(\"><\/td>\\n\");\n                result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">&nbsp;<\/td>\\n\");\n                result.append(\"<\/tr>\\n\");\n\n                // show inherit permissions check box on folders\n                if (getInheritOption()) {\n                    result.append(\"<tr>\\n\");\n                    result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">\").append(\n                        key(Messages.GUI_PERMISSION_INHERIT_ON_SUBFOLDERS_0)).append(\"<\/td>\\n\");\n                    result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\">\");\n                    result.append(\"<input type=\\\"checkbox\\\" name=\\\"\").append(PARAM_INHERIT).append(\"\\\" value=\\\"true\\\"\").append(\n                        disabled);\n                    if (entry.isInheriting()) {\n                        result.append(\" checked=\\\"checked\\\"\");\n                    }\n                    result.append(\"><\/td>\\n\");\n                    result.append(\"\\t<td class=\\\"dialogpermissioncell\\\">&nbsp;<\/td>\\n\");\n                    result.append(\"<\/tr>\\n\");\n                }\n\n                // show \"set\" and \"delete\" buttons    \n                result.append(\"<tr>\\n\");\n                result.append(\"\\t<td>&nbsp;<\/td>\\n\");\n                result.append(\"\\t<td class=\\\"textcenter\\\"><input class=\\\"dialogbutton\\\" type=\\\"submit\\\" value=\\\"\").append(\n                    key(Messages.GUI_LABEL_SET_0)).append(\"\\\"><\/form><\/td>\\n\");\n                result.append(\"\\t<td class=\\\"textcenter\\\">\\n\");\n                // build the form for the \"delete\" button            \n                result.append(\"\\t\\t<form class=\\\"nomargin\\\" action=\\\"\").append(getDialogUri()).append(\n                    \"\\\" method=\\\"post\\\" name=\\\"delete\").append(idValue).append(\"\\\">\\n\");\n                // set parameters to show correct hidden input fields\n                setParamAction(DIALOG_DELETE);\n                result.append(paramsAsHidden());\n                result.append(\"\\t\\t<input class=\\\"dialogbutton\\\" type=\\\"submit\\\" value=\\\"\").append(\n                    key(Messages.GUI_LABEL_DELETE_0)).append(\"\\\">\\n\");\n                result.append(\"\\t\\t<\/form>\\n\");\n                result.append(\"\\t<\/td>\\n\");\n                result.append(\"<\/tr>\\n\");\n            } else {\n                // close the form\n                result.append(\"<\/form>\\n\");\n            }\n\n            result.append(\"<\/table>\\n\");\n            if (extendedView) {\n                // close the hidden div for extended view\n                result.append(\"<\/div>\");\n            }\n        } else {\n            result.append(dialogRow(HTML_START));\n\n            result.append(\"<table style='margin-left: 13px;' class=\\\"dialogpermissiondetails\\\">\\n\");\n            // build headings for permission descriptions\n            result.append(\"<tr>\\n\");\n            result.append(\"\\t<td style=\\\"width: 280px;\\\"><span class=\\\"textbold\\\" unselectable=\\\"on\\\">\");\n\n            result.append(\"<img src=\\\"\").append(getSkinUri()).append(\"commons/\");\n            result.append(typeImg);\n            result.append(\".png\\\" class=\\\"noborder\\\" width=\\\"16\\\" height=\\\"16\\\" alt=\\\"\");\n            result.append(typeLocalized);\n            result.append(\"\\\" title=\\\"\");\n            result.append(typeLocalized);\n            result.append(\"\\\">&nbsp;<span class=\\\"textbold\\\">\");\n            result.append(name);\n            result.append(\"<\/span><\/td>\\n\");\n            result.append(\"\\t<td class=\\\"dialogpermissioncell textcenter\\\"><span class=\\\"textbold\\\" unselectable=\\\"on\\\">\");\n            if (editable) {\n                // build the form for the \"delete\" button            \n                result.append(\"\\t\\t<form class=\\\"nomargin\\\" action=\\\"\").append(getDialogUri()).append(\n                    \"\\\" method=\\\"post\\\" name=\\\"delete\").append(idValue).append(\"\\\">\\n\");\n                // set parameters to show correct hidden input fields\n                setParamAction(DIALOG_DELETE);\n                result.append(paramsAsHidden());\n                result.append(\"\\t\\t<input class=\\\"dialogbutton\\\" type=\\\"submit\\\" value=\\\"\").append(\n                    key(Messages.GUI_LABEL_DELETE_0)).append(\"\\\">\\n\");\n                result.append(\"\\t\\t<\/form>\\n\");\n            }\n            result.append(\"<\/td>\\n\");\n            result.append(\"<\/tr>\");\n            result.append(\"<\/table>\\n\");\n            result.append(dialogRow(HTML_END));\n\n        }\n        return result;\n    }","commit_id":"ef54b93aa239993a1627b2a83b388dc1334bf30a","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Builds a String with HTML code to display the responsibles of a resource.<p>\n     * \n     * @param show true the responsible list is open\n     * @return HTML code for the responsibles of the current resource\n     */\n    public String buildResponsibleList(boolean show) {\n\n        List parentResources = new ArrayList();\n        Map responsibles = new HashMap();\n        CmsObject cms = getCms();\n        try {\n            // get all parent folders of the current file\n            parentResources = cms.readPath(getParamResource(), CmsResourceFilter.IGNORE_EXPIRATION);\n        } catch (CmsException e) {\n            // can usually be ignored\n            if (LOG.isInfoEnabled()) {\n                LOG.info(e.getLocalizedMessage());\n            }\n        }\n\n        String resourceRootPath = cms.getRequestContext().addSiteRoot(getParamResource());\n        String site = cms.getRequestContext().getSiteRoot();\n        try {\n            cms.getRequestContext().setSiteRoot(\"\");\n            Iterator i = parentResources.iterator();\n            while (i.hasNext()) {\n                CmsResource resource = (CmsResource)i.next();\n                try {\n                    String rootPath = resource.getRootPath();\n                    Iterator entries = cms.getAccessControlEntries(rootPath, false).iterator();\n                    while (entries.hasNext()) {\n                        CmsAccessControlEntry ace = (CmsAccessControlEntry)entries.next();\n                        if (ace.isResponsible()) {\n                            I_CmsPrincipal principal = cms.lookupPrincipal(ace.getPrincipal());\n                            if (principal != null) {\n                                responsibles.put(principal, rootPath);\n                            } else {\n                                responsibles.put(ace.getPrincipal(), rootPath);\n                            }\n                        }\n                    }\n                } catch (CmsException e) {\n                    // can usually be ignored\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(e.getLocalizedMessage());\n                    }\n                }\n            }\n            if (responsibles.size() == 0) {\n                return key(Messages.GUI_AVAILABILITY_NO_RESPONSIBLES_0);\n            }\n            StringBuffer result = new StringBuffer(512);\n            result.append(dialogToggleStart(key(Messages.GUI_AVAILABILITY_RESPONSIBLES_0), \"responsibles\", show));\n\n            result.append(dialogWhiteBoxStart());\n            i = responsibles.entrySet().iterator();\n            while (i.hasNext()) {\n                Map.Entry entry = (Map.Entry)i.next();\n                String name;\n                String ou = null;\n                String image;\n                if (entry.getKey() instanceof I_CmsPrincipal) {\n                    I_CmsPrincipal principal = (I_CmsPrincipal)entry.getKey();\n                    if (principal instanceof CmsGroup) {\n                        name = ((CmsGroup)principal).getDescription(getLocale())\n                            + \" (\"\n                            + principal.getSimpleName()\n                            + \")\";\n                        image = \"commons/group.png\";\n                    } else {\n                        name = ((CmsUser)principal).getFullName();\n                        image = \"commons/user.png\";\n                    }\n                    ou = principal.getOuFqn();\n                } else {\n                    // check if it is the case of a role\n                    CmsRole role = CmsRole.valueOfId((CmsUUID)entry.getKey());\n                    if (role != null) {\n                        name = role.getName(getLocale());\n                        image = \"commons/role.png\";\n                    } else {\n                        name = entry.getKey().toString();\n                        image = \"explorer/project_none.gif\";\n                    }\n                }\n                result.append(\"<div class=\\\"dialogrow\\\"><img src=\\\"\");\n                result.append(getSkinUri());\n                result.append(image);\n                result.append(\"\\\" class='noborder' width='16' height='16' alt='Principal' title='Principal'>&nbsp;<span class=\\\"textbold\\\">\");\n                result.append(name);\n                result.append(\"<\/span>\");\n                if (\"long\".equals(getSettings().getPermissionDetailView())) {\n                    String resourceName = (String)entry.getValue();\n                    if (!resourceRootPath.equals(resourceName)) {\n                        result.append(\"<div class=\\\"dialogpermissioninherit\\\">\");\n                        result.append(key(Messages.GUI_PERMISSION_INHERITED_FROM_1, new Object[] {resourceName}));\n                        result.append(\"<\/div>\");\n                    }\n                }\n                try {\n                    if ((ou != null)\n                        && (OpenCms.getOrgUnitManager().getOrganizationalUnits(getCms(), \"\", true).size() > 1)) {\n                        result.append(\"<br>\");\n                        result.append(\"<img src='\").append(getSkinUri()).append(\n                            \"explorer/project_none.gif' class='noborder' width='16' height='16' >\");\n                        result.append(\"<img src='\").append(getSkinUri()).append(\n                            \"explorer/project_none.gif' class='noborder' width='16' height='16' >\");\n                        result.append(\"&nbsp;\");\n                        try {\n                            result.append(OpenCms.getOrgUnitManager().readOrganizationalUnit(getCms(), ou).getDisplayName(\n                                getLocale()));\n                        } catch (CmsException e) {\n                            result.append(ou);\n                        }\n                    }\n                } catch (CmsException e) {\n                    // should never happen\n                    if (LOG.isErrorEnabled()) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                    }\n                }\n                result.append(\"<\/div>\\n\");\n            }\n            result.append(dialogWhiteBoxEnd());\n            result.append(\"<\/div>\\n\");\n            return result.toString();\n        } finally {\n            cms.getRequestContext().setSiteRoot(site);\n        }\n    }","id":29668,"modified_method":"/**\n     * Builds a String with HTML code to display the responsibles of a resource.<p>\n     * \n     * @param show true the responsible list is open\n     * @return HTML code for the responsibles of the current resource\n     */\n    public String buildResponsibleList(boolean show) {\n\n        List parentResources = new ArrayList();\n        Map responsibles = new HashMap();\n        CmsObject cms = getCms();\n        try {\n            // get all parent folders of the current file\n            parentResources = cms.readPath(getParamResource(), CmsResourceFilter.IGNORE_EXPIRATION);\n        } catch (CmsException e) {\n            // can usually be ignored\n            if (LOG.isInfoEnabled()) {\n                LOG.info(e.getLocalizedMessage());\n            }\n        }\n\n        String resourceRootPath = cms.getRequestContext().addSiteRoot(getParamResource());\n        String site = cms.getRequestContext().getSiteRoot();\n        try {\n            cms.getRequestContext().setSiteRoot(\"\");\n            Iterator i = parentResources.iterator();\n            while (i.hasNext()) {\n                CmsResource resource = (CmsResource)i.next();\n                try {\n                    String rootPath = resource.getRootPath();\n                    Iterator entries = cms.getAccessControlEntries(rootPath, false).iterator();\n                    while (entries.hasNext()) {\n                        CmsAccessControlEntry ace = (CmsAccessControlEntry)entries.next();\n                        if (ace.isResponsible()) {\n                            try {\n                                responsibles.put(\n                                    CmsPrincipal.readPrincipalIncludingHistory(cms, ace.getPrincipal()),\n                                    rootPath);\n                            } catch (CmsDbEntryNotFoundException e) {\n                                responsibles.put(ace.getPrincipal(), rootPath);\n                            }\n                        }\n                    }\n                } catch (CmsException e) {\n                    // can usually be ignored\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(e.getLocalizedMessage());\n                    }\n                }\n            }\n            if (responsibles.size() == 0) {\n                return key(Messages.GUI_AVAILABILITY_NO_RESPONSIBLES_0);\n            }\n            StringBuffer result = new StringBuffer(512);\n            result.append(dialogToggleStart(key(Messages.GUI_AVAILABILITY_RESPONSIBLES_0), \"responsibles\", show));\n\n            result.append(dialogWhiteBoxStart());\n            i = responsibles.entrySet().iterator();\n            while (i.hasNext()) {\n                Map.Entry entry = (Map.Entry)i.next();\n                String name;\n                String ou = null;\n                String image;\n                if (entry.getKey() instanceof I_CmsPrincipal) {\n                    I_CmsPrincipal principal = (I_CmsPrincipal)entry.getKey();\n                    if (principal instanceof CmsGroup) {\n                        name = ((CmsGroup)principal).getDescription(getLocale())\n                            + \" (\"\n                            + principal.getSimpleName()\n                            + \")\";\n                        image = \"commons/group.png\";\n                    } else {\n                        name = ((CmsUser)principal).getFullName();\n                        image = \"commons/user.png\";\n                    }\n                    ou = principal.getOuFqn();\n                } else {\n                    // check if it is the case of a role\n                    CmsRole role = CmsRole.valueOfId((CmsUUID)entry.getKey());\n                    if (role != null) {\n                        name = role.getName(getLocale());\n                        image = \"commons/role.png\";\n                    } else {\n                        name = entry.getKey().toString();\n                        image = \"explorer/project_none.gif\";\n                    }\n                }\n                result.append(\"<div class=\\\"dialogrow\\\"><img src=\\\"\");\n                result.append(getSkinUri());\n                result.append(image);\n                result.append(\"\\\" class='noborder' width='16' height='16' alt='Principal' title='Principal'>&nbsp;<span class=\\\"textbold\\\">\");\n                result.append(name);\n                result.append(\"<\/span>\");\n                if (\"long\".equals(getSettings().getPermissionDetailView())) {\n                    String resourceName = (String)entry.getValue();\n                    if (!resourceRootPath.equals(resourceName)) {\n                        result.append(\"<div class=\\\"dialogpermissioninherit\\\">\");\n                        result.append(key(Messages.GUI_PERMISSION_INHERITED_FROM_1, new Object[] {resourceName}));\n                        result.append(\"<\/div>\");\n                    }\n                }\n                try {\n                    if ((ou != null)\n                        && (OpenCms.getOrgUnitManager().getOrganizationalUnits(getCms(), \"\", true).size() > 1)) {\n                        result.append(\"<br>\");\n                        result.append(\"<img src='\").append(getSkinUri()).append(\n                            \"explorer/project_none.gif' class='noborder' width='16' height='16' >\");\n                        result.append(\"<img src='\").append(getSkinUri()).append(\n                            \"explorer/project_none.gif' class='noborder' width='16' height='16' >\");\n                        result.append(\"&nbsp;\");\n                        try {\n                            result.append(OpenCms.getOrgUnitManager().readOrganizationalUnit(getCms(), ou).getDisplayName(\n                                getLocale()));\n                        } catch (CmsException e) {\n                            result.append(ou);\n                        }\n                    }\n                } catch (CmsException e) {\n                    // should never happen\n                    if (LOG.isErrorEnabled()) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                    }\n                }\n                result.append(\"<\/div>\\n\");\n            }\n            result.append(dialogWhiteBoxEnd());\n            result.append(\"<\/div>\\n\");\n            return result.toString();\n        } finally {\n            cms.getRequestContext().setSiteRoot(site);\n        }\n    }","commit_id":"ef54b93aa239993a1627b2a83b388dc1334bf30a","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see #buildPermissionEntryForm(CmsAccessControlEntry, boolean, boolean, String)\n     *\n     * @param id the UUID of the principal of the permission set\n     * @param curSet the current permission set \n     * @param editable boolean to determine if the form is editable\n     * @param extendedView boolean to determine if the view is selectable with DHTML\n     * @return String with HTML code of the form\n     */\n    private StringBuffer buildPermissionEntryForm(\n        CmsUUID id,\n        CmsPermissionSet curSet,\n        boolean editable,\n        boolean extendedView) {\n\n        String fileName = getParamResource();\n        int flags = 0;\n        try {\n            I_CmsPrincipal p = getCms().lookupPrincipal(id);\n            if ((p != null) && p.isGroup()) {\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_GROUP;\n            } else if ((p != null) && p.isUser()) {\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_USER;\n            } else if ((p == null) && id.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID)) {\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_ALLOTHERS;\n            } else if ((p == null) && id.equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_ID)) {\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_OVERWRITE_ALL;\n            } else {\n                // check if it is the case of a role\n                CmsRole role = CmsRole.valueOfId(id);\n                if (role != null) {\n                    flags = CmsAccessControlEntry.ACCESS_FLAGS_ROLE;\n                }\n            }\n\n            CmsResource res = getCms().readResource(fileName, CmsResourceFilter.ALL);\n            CmsAccessControlEntry entry = new CmsAccessControlEntry(res.getResourceId(), id, curSet, flags);\n            return buildPermissionEntryForm(entry, editable, extendedView, null);\n        } catch (CmsException e) {\n            // can usually be ignored\n            if (LOG.isInfoEnabled()) {\n                LOG.info(e.getLocalizedMessage());\n            }\n            return new StringBuffer(\"\");\n        }\n    }","id":29669,"modified_method":"/**\n     * @see #buildPermissionEntryForm(CmsAccessControlEntry, boolean, boolean, String)\n     *\n     * @param id the UUID of the principal of the permission set\n     * @param curSet the current permission set \n     * @param editable boolean to determine if the form is editable\n     * @param extendedView boolean to determine if the view is selectable with DHTML\n     * @return String with HTML code of the form\n     */\n    private StringBuffer buildPermissionEntryForm(\n        CmsUUID id,\n        CmsPermissionSet curSet,\n        boolean editable,\n        boolean extendedView) {\n\n        String fileName = getParamResource();\n        int flags = 0;\n        try {\n            I_CmsPrincipal p;\n            try {\n                p = CmsPrincipal.readPrincipalIncludingHistory(getCms(), id);\n            } catch (CmsException e) {\n                p = null;\n            }\n            if ((p != null) && p.isGroup()) {\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_GROUP;\n            } else if ((p != null) && p.isUser()) {\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_USER;\n            } else if ((p == null) && id.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID)) {\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_ALLOTHERS;\n            } else if ((p == null) && id.equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_ID)) {\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_OVERWRITE_ALL;\n            } else {\n                // check if it is the case of a role\n                CmsRole role = CmsRole.valueOfId(id);\n                if (role != null) {\n                    flags = CmsAccessControlEntry.ACCESS_FLAGS_ROLE;\n                }\n            }\n\n            CmsResource res = getCms().readResource(fileName, CmsResourceFilter.ALL);\n            CmsAccessControlEntry entry = new CmsAccessControlEntry(res.getResourceId(), id, curSet, flags);\n            return buildPermissionEntryForm(entry, editable, extendedView, null);\n        } catch (CmsException e) {\n            // can usually be ignored\n            if (LOG.isInfoEnabled()) {\n                LOG.info(e.getLocalizedMessage());\n            }\n            return new StringBuffer(\"\");\n        }\n    }","commit_id":"ef54b93aa239993a1627b2a83b388dc1334bf30a","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testSendMulticastMessage1() throws Exception {\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tMessage message = createMessage();\n\n\t\tclusterLinkImpl.sendMulticastMessage(message, Priority.LEVEL1);\n\n\t\tclusterLinkImpl.destroy();\n\t}","id":29670,"modified_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testSendMulticastMessage1() throws Exception {\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tclusterLinkImpl.sendMulticastMessage(message, Priority.LEVEL1);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testDestroy1() throws Exception {\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tclusterLinkImpl.destroy();\n\t}","id":29671,"modified_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testDestroy1() throws Exception {\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testGetChannel() throws Exception {\n\t\tJDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.FINE);\n\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\tAssert.assertEquals(2, jChannels.size());\n\n\t\tJChannel jChannel = jChannels.get(0);\n\n\t\tAssert.assertSame(\n\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL1));\n\t\tAssert.assertSame(\n\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL2));\n\t\tAssert.assertSame(\n\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL3));\n\t\tAssert.assertSame(\n\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL4));\n\t\tAssert.assertSame(\n\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL5));\n\n\t\tjChannel = jChannels.get(1);\n\n\t\tAssert.assertSame(\n\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL6));\n\t\tAssert.assertSame(\n\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL7));\n\t\tAssert.assertSame(\n\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL8));\n\t\tAssert.assertSame(\n\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL9));\n\t\tAssert.assertSame(\n\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL10));\n\n\t\tclusterLinkImpl.destroy();\n\t}","id":29672,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testGetChannel() throws Exception {\n\t\tJDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.FINE);\n\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tAssert.assertEquals(2, jChannels.size());\n\n\t\t\tJChannel jChannel = jChannels.get(0);\n\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL1));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL2));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL3));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL4));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL5));\n\n\t\t\tjChannel = jChannels.get(1);\n\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL6));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL7));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL8));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL9));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL10));\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendUnicastMessage3() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\tMessage message = createMessage();\n\n\t\tJChannel jChannel = jChannels.get(0);\n\n\t\tjChannel.close();\n\n\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.WARNING);\n\n\t\tclusterLinkImpl.sendUnicastMessage(\n\t\t\tnew AddressImpl(new MockAddress()), message, Priority.LEVEL1);\n\n\t\tassertLogger(\n\t\t\tlogRecords, \"Unable to send unicast message \" + message,\n\t\t\tIllegalStateException.class);\n\n\t\tclusterLinkImpl.destroy();\n\t}","id":29673,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendUnicastMessage3() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tJChannel jChannel = jChannels.get(0);\n\n\t\t\tjChannel.close();\n\n\t\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tClusterLinkImpl.class.getName(), Level.WARNING);\n\n\t\t\tclusterLinkImpl.sendUnicastMessage(\n\t\t\t\tnew AddressImpl(new MockAddress()), message, Priority.LEVEL1);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to send unicast message \" + message,\n\t\t\t\tIllegalStateException.class);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testGetTransportAddressesByPriority1() throws Exception {\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tList<Address> addresses = clusterLinkImpl.getTransportAddresses(\n\t\t\tPriority.LEVEL1);\n\n\t\tAssert.assertSame(Collections.emptyList(), addresses);\n\n\t\tclusterLinkImpl.destroy();\n\t}","id":29674,"modified_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testGetTransportAddressesByPriority1() throws Exception {\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<Address> addresses = clusterLinkImpl.getTransportAddresses(\n\t\t\t\tPriority.LEVEL1);\n\n\t\t\tAssert.assertSame(Collections.emptyList(), addresses);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendMulticastMessage3() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tMessage message = createMessage();\n\n\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\tJChannel jChannel = jChannels.get(0);\n\n\t\tjChannel.close();\n\n\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.WARNING);\n\n\t\tclusterLinkImpl.sendMulticastMessage(message, Priority.LEVEL1);\n\n\t\tassertLogger(\n\t\t\tlogRecords, \"Unable to send multicast message \" + message,\n\t\t\tIllegalStateException.class);\n\n\t\tclusterLinkImpl.destroy();\n\t}","id":29675,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendMulticastMessage3() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tJChannel jChannel = jChannels.get(0);\n\n\t\t\tjChannel.close();\n\n\t\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tClusterLinkImpl.class.getName(), Level.WARNING);\n\n\t\t\tclusterLinkImpl.sendMulticastMessage(message, Priority.LEVEL1);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to send multicast message \" + message,\n\t\t\t\tIllegalStateException.class);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendUnicastMessage4() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\tMessage message = createMessage();\n\n\t\tJChannel jChannel = jChannels.get(0);\n\n\t\tjChannel.disconnect();\n\n\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.WARNING);\n\n\t\tclusterLinkImpl.sendUnicastMessage(\n\t\t\tnew AddressImpl(new MockAddress()), message, Priority.LEVEL1);\n\n\t\tassertLogger(\n\t\t\tlogRecords, \"Unable to send unicast message \" + message,\n\t\t\tIllegalStateException.class);\n\n\t\tclusterLinkImpl.destroy();\n\t}","id":29676,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendUnicastMessage4() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tJChannel jChannel = jChannels.get(0);\n\n\t\t\tjChannel.disconnect();\n\n\t\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tClusterLinkImpl.class.getName(), Level.WARNING);\n\n\t\t\tclusterLinkImpl.sendUnicastMessage(\n\t\t\t\tnew AddressImpl(new MockAddress()), message, Priority.LEVEL1);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to send unicast message \" + message,\n\t\t\t\tIllegalStateException.class);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testGetLocalTransportAddresses1() throws Exception {\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tList<Address> addresses = clusterLinkImpl.getLocalTransportAddresses();\n\n\t\tAssert.assertSame(Collections.emptyList(), addresses);\n\n\t\tclusterLinkImpl.destroy();\n\t}","id":29677,"modified_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testGetLocalTransportAddresses1() throws Exception {\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<Address> addresses =\n\t\t\t\tclusterLinkImpl.getLocalTransportAddresses();\n\n\t\t\tAssert.assertSame(Collections.emptyList(), addresses);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testSendUnicastMessage1() throws Exception {\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tMessage message = createMessage();\n\n\t\tclusterLinkImpl.sendUnicastMessage(\n\t\t\tnew AddressImpl(new MockAddress()), message, Priority.LEVEL1);\n\n\t\tclusterLinkImpl.destroy();\n\t}","id":29678,"modified_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testSendUnicastMessage1() throws Exception {\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tclusterLinkImpl.sendUnicastMessage(\n\t\t\t\tnew AddressImpl(new MockAddress()), message, Priority.LEVEL1);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendUnicastMessage2() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tClusterLinkImpl clusterLinkImpl1 = getClusterLinkImpl();\n\t\tClusterLinkImpl clusterLinkImpl2 = getClusterLinkImpl();\n\n\t\tList<JChannel> jChannels1 = getJChannels(clusterLinkImpl1);\n\t\tList<JChannel> jChannels2 = getJChannels(clusterLinkImpl2);\n\n\t\tTestReceiver testReceiver1 = getTestReceiver(jChannels1, 0);\n\t\tTestReceiver testReceiver2 = getTestReceiver(jChannels2, 0);\n\n\t\tMessage message = createMessage();\n\n\t\tclusterLinkImpl1.sendUnicastMessage(\n\t\t\tnew AddressImpl(jChannels2.get(0).getAddress()), message,\n\t\t\tPriority.LEVEL1);\n\n\t\tString localMessage1 = testReceiver1.waitLocalMessage();\n\t\tString remoteMessage1 = testReceiver1.waitRemoteMessage();\n\t\tString localMessage2 = testReceiver2.waitLocalMessage();\n\t\tString remoteMessage2 = testReceiver2.waitRemoteMessage();\n\n\t\tString messageKey = (String)message.getPayload();\n\n\t\tAssert.assertNull(localMessage1);\n\t\tAssert.assertNull(remoteMessage1);\n\t\tAssert.assertNull(localMessage2);\n\t\tAssert.assertEquals(messageKey, remoteMessage2);\n\n\t\tclusterLinkImpl1.destroy();\n\t\tclusterLinkImpl2.destroy();\n\t}","id":29679,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendUnicastMessage2() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tClusterLinkImpl clusterLinkImpl1 = null;\n\t\tClusterLinkImpl clusterLinkImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl1 = getClusterLinkImpl();\n\t\t\tclusterLinkImpl2 = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels1 = getJChannels(clusterLinkImpl1);\n\t\t\tList<JChannel> jChannels2 = getJChannels(clusterLinkImpl2);\n\n\t\t\tTestReceiver testReceiver1 = getTestReceiver(jChannels1, 0);\n\t\t\tTestReceiver testReceiver2 = getTestReceiver(jChannels2, 0);\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tclusterLinkImpl1.sendUnicastMessage(\n\t\t\t\tnew AddressImpl(jChannels2.get(0).getAddress()), message,\n\t\t\t\tPriority.LEVEL1);\n\n\t\t\tString localMessage1 = testReceiver1.waitLocalMessage();\n\t\t\tString remoteMessage1 = testReceiver1.waitRemoteMessage();\n\t\t\tString localMessage2 = testReceiver2.waitLocalMessage();\n\t\t\tString remoteMessage2 = testReceiver2.waitRemoteMessage();\n\n\t\t\tString messageKey = (String)message.getPayload();\n\n\t\t\tAssert.assertNull(localMessage1);\n\t\t\tAssert.assertNull(remoteMessage1);\n\t\t\tAssert.assertNull(localMessage2);\n\t\t\tAssert.assertEquals(messageKey, remoteMessage2);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl1 != null) {\n\t\t\t\tclusterLinkImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterLinkImpl2 != null) {\n\t\t\t\tclusterLinkImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testDestroy2() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\tAssert.assertEquals(2, jChannels.size());\n\n\t\tJChannel jChannel = jChannels.get(0);\n\n\t\tAssert.assertTrue(isOpen(jChannel));\n\n\t\tjChannel = jChannels.get(1);\n\n\t\tAssert.assertTrue(isOpen(jChannel));\n\n\t\tclusterLinkImpl.destroy();\n\n\t\tjChannels = getJChannels(clusterLinkImpl);\n\n\t\tAssert.assertEquals(2, jChannels.size());\n\n\t\tjChannel = jChannels.get(0);\n\n\t\tAssert.assertFalse(isOpen(jChannel));\n\n\t\tjChannel = jChannels.get(1);\n\n\t\tAssert.assertFalse(isOpen(jChannel));\n\t}","id":29680,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testDestroy2() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tAssert.assertEquals(2, jChannels.size());\n\n\t\t\tJChannel jChannel = jChannels.get(0);\n\n\t\t\tAssert.assertTrue(isOpen(jChannel));\n\n\t\t\tjChannel = jChannels.get(1);\n\n\t\t\tAssert.assertTrue(isOpen(jChannel));\n\n\t\t\tclusterLinkImpl.destroy();\n\n\t\t\tjChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tAssert.assertEquals(2, jChannels.size());\n\n\t\t\tjChannel = jChannels.get(0);\n\n\t\t\tAssert.assertFalse(isOpen(jChannel));\n\n\t\t\tjChannel = jChannels.get(1);\n\n\t\t\tAssert.assertFalse(isOpen(jChannel));\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendMulticastMessage4() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\tMessage message = createMessage();\n\n\t\tJChannel jChannel = jChannels.get(0);\n\n\t\tjChannel.disconnect();\n\n\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.WARNING);\n\n\t\tclusterLinkImpl.sendMulticastMessage(message, Priority.LEVEL1);\n\n\t\tassertLogger(\n\t\t\tlogRecords, \"Unable to send multicast message \" + message,\n\t\t\tIllegalStateException.class);\n\n\t\tclusterLinkImpl.destroy();\n\t}","id":29681,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendMulticastMessage4() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tJChannel jChannel = jChannels.get(0);\n\n\t\t\tjChannel.disconnect();\n\n\t\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tClusterLinkImpl.class.getName(), Level.WARNING);\n\n\t\t\tclusterLinkImpl.sendMulticastMessage(message, Priority.LEVEL1);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to send multicast message \" + message,\n\t\t\t\tIllegalStateException.class);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendMulticastMessage2() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tClusterLinkImpl clusterLinkImpl1 = getClusterLinkImpl();\n\t\tClusterLinkImpl clusterLinkImpl2 = getClusterLinkImpl();\n\t\tClusterLinkImpl clusterLinkImpl3 = getClusterLinkImpl();\n\n\t\tList<JChannel> jChannels1 = getJChannels(clusterLinkImpl1);\n\t\tList<JChannel> jChannels2 = getJChannels(clusterLinkImpl2);\n\t\tList<JChannel> jChannels3 = getJChannels(clusterLinkImpl3);\n\n\t\tTestReceiver testReceiver1 = getTestReceiver(jChannels1, 0);\n\t\tTestReceiver testReceiver2 = getTestReceiver(jChannels2, 0);\n\t\tTestReceiver testReceiver3 = getTestReceiver(jChannels3, 0);\n\n\t\tMessage message = createMessage();\n\n\t\tclusterLinkImpl1.sendMulticastMessage(message, Priority.LEVEL1);\n\n\t\tString localMessage1 = testReceiver1.waitLocalMessage();\n\t\tString remoteMessage1 = testReceiver1.waitRemoteMessage();\n\n\t\tString localMessage2 = testReceiver2.waitLocalMessage();\n\t\tString remoteMessage2 = testReceiver2.waitRemoteMessage();\n\n\t\tString localMessage3 = testReceiver3.waitLocalMessage();\n\t\tString remoteMessage3 = testReceiver3.waitRemoteMessage();\n\n\t\tString messageKey = (String)message.getPayload();\n\n\t\tAssert.assertEquals(messageKey, localMessage1);\n\t\tAssert.assertNull(remoteMessage1);\n\t\tAssert.assertNull(localMessage2);\n\t\tAssert.assertEquals(messageKey, remoteMessage2);\n\t\tAssert.assertNull(localMessage3);\n\t\tAssert.assertEquals(messageKey, remoteMessage3);\n\n\t\tclusterLinkImpl1.destroy();\n\t\tclusterLinkImpl2.destroy();\n\t\tclusterLinkImpl3.destroy();\n\t}","id":29682,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendMulticastMessage2() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tClusterLinkImpl clusterLinkImpl1 = null;\n\t\tClusterLinkImpl clusterLinkImpl2 = null;\n\t\tClusterLinkImpl clusterLinkImpl3 = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl1 = getClusterLinkImpl();\n\t\t\tclusterLinkImpl2 = getClusterLinkImpl();\n\t\t\tclusterLinkImpl3 = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels1 = getJChannels(clusterLinkImpl1);\n\t\t\tList<JChannel> jChannels2 = getJChannels(clusterLinkImpl2);\n\t\t\tList<JChannel> jChannels3 = getJChannels(clusterLinkImpl3);\n\n\t\t\tTestReceiver testReceiver1 = getTestReceiver(jChannels1, 0);\n\t\t\tTestReceiver testReceiver2 = getTestReceiver(jChannels2, 0);\n\t\t\tTestReceiver testReceiver3 = getTestReceiver(jChannels3, 0);\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tclusterLinkImpl1.sendMulticastMessage(message, Priority.LEVEL1);\n\n\t\t\tString localMessage1 = testReceiver1.waitLocalMessage();\n\t\t\tString remoteMessage1 = testReceiver1.waitRemoteMessage();\n\n\t\t\tString localMessage2 = testReceiver2.waitLocalMessage();\n\t\t\tString remoteMessage2 = testReceiver2.waitRemoteMessage();\n\n\t\t\tString localMessage3 = testReceiver3.waitLocalMessage();\n\t\t\tString remoteMessage3 = testReceiver3.waitRemoteMessage();\n\n\t\t\tString messageKey = (String)message.getPayload();\n\n\t\t\tAssert.assertEquals(messageKey, localMessage1);\n\t\t\tAssert.assertNull(remoteMessage1);\n\t\t\tAssert.assertNull(localMessage2);\n\t\t\tAssert.assertEquals(messageKey, remoteMessage2);\n\t\t\tAssert.assertNull(localMessage3);\n\t\t\tAssert.assertEquals(messageKey, remoteMessage3);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl1 != null) {\n\t\t\t\tclusterLinkImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterLinkImpl2 != null) {\n\t\t\t\tclusterLinkImpl2.destroy();\n\t\t\t}\n\n\t\t\tif (clusterLinkImpl3 != null) {\n\t\t\t\tclusterLinkImpl3.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testGetTransportAddressesByPriority2() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tClusterLinkImpl clusterLinkImpl1 = getClusterLinkImpl();\n\t\tClusterLinkImpl clusterLinkImpl2 = getClusterLinkImpl();\n\n\t\tList<JChannel> jChannels1 = getJChannels(clusterLinkImpl1);\n\n\t\tAssert.assertEquals(2, jChannels1.size());\n\n\t\tList<JChannel> jChannels2 = getJChannels(clusterLinkImpl2);\n\n\t\tAssert.assertEquals(2, jChannels2.size());\n\n\t\tList<Address> addresses1 = clusterLinkImpl1.getTransportAddresses(\n\t\t\tPriority.LEVEL1);\n\n\t\tAssert.assertEquals(2, addresses1.size());\n\n\t\tList<Address> addresses2 = clusterLinkImpl1.getTransportAddresses(\n\t\t\tPriority.LEVEL6);\n\n\t\tAssert.assertEquals(2, addresses2.size());\n\n\t\tAssert.assertEquals(\n\t\t\tgetJGroupsAddress(jChannels1, 0), getRealAddress(addresses1, 0));\n\t\tAssert.assertEquals(\n\t\t\tgetJGroupsAddress(jChannels1, 1), getRealAddress(addresses2, 0));\n\t\tAssert.assertEquals(\n\t\t\tgetJGroupsAddress(jChannels2, 0), getRealAddress(addresses1, 1));\n\t\tAssert.assertEquals(\n\t\t\tgetJGroupsAddress(jChannels2, 1), getRealAddress(addresses2, 1));\n\n\t\tclusterLinkImpl1.destroy();\n\t\tclusterLinkImpl2.destroy();\n\t}","id":29683,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testGetTransportAddressesByPriority2() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tClusterLinkImpl clusterLinkImpl1 = null;\n\t\tClusterLinkImpl clusterLinkImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl1 = getClusterLinkImpl();\n\t\t\tclusterLinkImpl2 = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels1 = getJChannels(clusterLinkImpl1);\n\n\t\t\tAssert.assertEquals(2, jChannels1.size());\n\n\t\t\tList<JChannel> jChannels2 = getJChannels(clusterLinkImpl2);\n\n\t\t\tAssert.assertEquals(2, jChannels2.size());\n\n\t\t\tList<Address> addresses1 = clusterLinkImpl1.getTransportAddresses(\n\t\t\t\tPriority.LEVEL1);\n\n\t\t\tAssert.assertEquals(2, addresses1.size());\n\n\t\t\tList<Address> addresses2 = clusterLinkImpl1.getTransportAddresses(\n\t\t\t\tPriority.LEVEL6);\n\n\t\t\tAssert.assertEquals(2, addresses2.size());\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tgetJGroupsAddress(jChannels1, 0),\n\t\t\t\tgetRealAddress(addresses1, 0));\n\t\t\tAssert.assertEquals(\n\t\t\t\tgetJGroupsAddress(jChannels1, 1),\n\t\t\t\tgetRealAddress(addresses2, 0));\n\t\t\tAssert.assertEquals(\n\t\t\t\tgetJGroupsAddress(jChannels2, 0),\n\t\t\t\tgetRealAddress(addresses1, 1));\n\t\t\tAssert.assertEquals(\n\t\t\t\tgetJGroupsAddress(jChannels2, 1),\n\t\t\t\tgetRealAddress(addresses2, 1));\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl1 != null) {\n\t\t\t\tclusterLinkImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterLinkImpl2 != null) {\n\t\t\t\tclusterLinkImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testGetLocalTransportAddresses2() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tList<Address> addresses = clusterLinkImpl.getLocalTransportAddresses();\n\n\t\tAssert.assertEquals(2, addresses.size());\n\n\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\tAssert.assertSame(\n\t\t\tgetJGroupsAddress(jChannels, 0), getRealAddress(addresses, 0));\n\t\tAssert.assertSame(\n\t\t\tgetJGroupsAddress(jChannels, 1), getRealAddress(addresses, 1));\n\n\t\tclusterLinkImpl.destroy();\n\t}","id":29684,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testGetLocalTransportAddresses2() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<Address> addresses =\n\t\t\t\tclusterLinkImpl.getLocalTransportAddresses();\n\n\t\t\tAssert.assertEquals(2, addresses.size());\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tAssert.assertSame(\n\t\t\t\tgetJGroupsAddress(jChannels, 0), getRealAddress(addresses, 0));\n\t\t\tAssert.assertSame(\n\t\t\t\tgetJGroupsAddress(jChannels, 1), getRealAddress(addresses, 1));\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"cc5279e5635b05c13bcf38a036a8ab3b4f5616a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void surfaceCreated () {\r\n\t\tif (spriteBatch != null) return;\r\n\t\tspriteBatch = new SpriteBatch();\r\n\r\n\t\tlogoSprite = new Sprite(Gdx.graphics.newTexture(Gdx.files.getFileHandle(\"data/badlogic.jpg\", FileType.Internal),\r\n\t\t\tTextureFilter.Linear, TextureFilter.Linear, TextureWrap.ClampToEdge, TextureWrap.ClampToEdge));\r\n\t\tlogoSprite.setColor(1, 1, 1, 0.5f);\r\n\r\n\t\tfont = new BitmapFont(Gdx.files.getFileHandle(\"data/verdana39.fnt\", FileType.Internal), Gdx.files.getFileHandle(\r\n\t\t\t\"data/verdana39.png\", FileType.Internal));\r\n\r\n\t\tGdx.input.addInputListener(new InputAdapter() {\r\n\t\t\tpublic boolean touchDown (int x, int y, int pointer) {\r\n\t\t\t\trenderMode = (renderMode + 1) % 2;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tcache1 = font.cacheText(null, \"(cached)\", 10, 76, Color.WHITE);\r\n\r\n\t\tString text = \"Sphinx of black quartz,\\njudge my vow.\";\r\n\t\tcache2 = font.cacheMultiLineText(null, text, 5, 310, Color.RED, 470, BitmapFont.HAlignment.LEFT);\r\n\r\n\t\ttext = \"How quickly\\ndaft jumping zebras vex.\";\r\n\t\tcache3 = font.cacheMultiLineText(null, text, 5, 210, blue, 470, BitmapFont.HAlignment.CENTER);\r\n\r\n\t\ttext = \"Kerning: LYA moo\";\r\n\t\tcache4 = font.cacheText(null, text, 210, 76, Color.WHITE, 0, text.length() - 3);\r\n\t}","id":29685,"modified_method":"public void surfaceCreated () {\r\n\t\tif (spriteBatch != null) return;\r\n\t\tspriteBatch = new SpriteBatch();\r\n\r\n\t\tlogoSprite = new Sprite(Gdx.graphics.newTexture(Gdx.files.getFileHandle(\"data/badlogic.jpg\", FileType.Internal),\r\n\t\t\tTextureFilter.Linear, TextureFilter.Linear, TextureWrap.ClampToEdge, TextureWrap.ClampToEdge));\r\n\t\tlogoSprite.setColor(1, 1, 1, 0.5f);\r\n\r\n\t\tfont = new BitmapFont(Gdx.files.getFileHandle(\"data/verdana39.fnt\", FileType.Internal), Gdx.files.getFileHandle(\r\n\t\t\t\"data/verdana39.png\", FileType.Internal));\r\n\r\n\t\tGdx.input.addInputListener(new InputAdapter() {\r\n\t\t\tpublic boolean touchDown (int x, int y, int pointer) {\r\n\t\t\t\trenderMode = (renderMode + 1) % 2;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\t\tcache1 = font.newCache( );\r\n\t\tcache2 = font.newCache( );\r\n\t\tcache3 = font.newCache( );\r\n\t\tcache4 = font.newCache( );\r\n\t\t\r\n\t\tfont.cacheText(cache1, \"(cached)\", 10, 76, Color.WHITE);\r\n\r\n\t\tString text = \"Sphinx of black quartz,\\njudge my vow.\";\r\n\t\tfont.cacheMultiLineText(cache2, text, 5, 310, Color.RED, 470, BitmapFont.HAlignment.LEFT);\r\n\r\n\t\ttext = \"How quickly\\ndaft jumping zebras vex.\";\r\n\t\tfont.cacheMultiLineText(cache3, text, 5, 210, blue, 470, BitmapFont.HAlignment.CENTER);\r\n\r\n\t\ttext = \"Kerning: LYA moo\";\r\n\t\tfont.cacheText(cache4, text, 210, 76, Color.WHITE, 0, text.length() - 3);\r\n\t}","commit_id":"70e151f1774d7f0c74a4cf414bdbd3597014e9d2","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void renderNormal () {\r\n\t\tfont.draw(spriteBatch, \"(normal)\", 10, 76, Color.WHITE);\r\n\r\n\t\tString text = \"Sphinx of black quartz,\\njudge my vow.\";\r\n\t\tfont.drawMultiLineText(spriteBatch, text, 5, 310, Color.RED);\r\n\r\n\t\ttext = \"How quickly\\ndaft jumping zebras vex.\";\r\n\t\tfont.drawMultiLineText(spriteBatch, text, 5, 210, blue, 470, BitmapFont.HAlignment.CENTER);\r\n\r\n\t\ttext = \"Kerning: LYA moo\";\r\n\t\tfont.draw(spriteBatch, text, 210, 76, Color.WHITE, 0, text.length() - 3);\r\n\t}","id":29686,"modified_method":"private void renderNormal () {\r\n\t\tfont.draw(spriteBatch, \"(normal)\", 10, 76, Color.WHITE);\r\n\r\n\t\tString text = \"Sphinx of black quartz,\\njudge my vow.\";\r\n\t\tfont.drawMultiLineText(spriteBatch, text, 5, 310, Color.RED);\r\n\r\n\t\ttext = \"How quickly\\ndaft jumping zebras vex.\";\r\n\t\tfont.drawMultiLineText(spriteBatch, text, 5, 210, blue, 470, BitmapFont.HAlignment.RIGHT);\r\n\r\n\t\ttext = \"Kerning: LYA moo\";\r\n\t\tfont.draw(spriteBatch, text, 210, 76, Color.WHITE, 0, text.length() - 3);\r\n\t}","commit_id":"70e151f1774d7f0c74a4cf414bdbd3597014e9d2","url":"https://github.com/libgdx/libgdx"},{"original_method":"public static void toChildCoordinates( Actor child, float x, float y, Vector2 out )\r\n\t{\r\n\t\tif( child.rotation == 0 )\r\n\t\t{\r\n\t\t\tif( child.scaleX == 1 && child.scaleY == 1 )\r\n\t\t\t{\r\n\t\t\t\tout.x = x - child.x;\r\n\t\t\t\tout.y = y - child.y;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif( child.originX == 0 && child.originY == 0 )\r\n\t\t\t\t{\r\n\t\t\t\t\tout.x = (x - child.x) / child.scaleX;\r\n\t\t\t\t\tout.y = (y - child.y) / child.scaleY;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tout.x = x / child.scaleX - (child.x - child.originX);\r\n\t\t\t\t\tout.x = x / child.scaleX - (child.x - child.originX);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfinal float cos = (float)Math.cos( (float)Math.toRadians(child.rotation) );\r\n\t\t\tfinal float sin = (float)Math.sin( (float)Math.toRadians(child.rotation) );\r\n\t\t\t\r\n\t\t\tif( child.scaleX == 1 && child.scaleY == 1 )\r\n\t\t\t{\r\n\t\t\t\tif( child.originX == 0 && child.originY == 0 )\r\n\t\t\t\t{\t\r\n\t\t\t\t\tfloat tox = x - child.x;\r\n\t\t\t\t\tfloat toy = y - child.y;\r\n\t\t\t\t\t\r\n\t\t\t\t\tout.x = tox * cos + toy * sin;\r\n\t\t\t\t\tout.y = tox * -sin + toy * cos;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tfinal float worldOriginX = child.x + child.originX;\r\n\t\t\t\t\tfinal float worldOriginY = child.y + child.originY;\r\n\t\t\t\t\tfloat fx = -child.originX;\r\n\t\t\t\t\tfloat fy = -child.originY;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfloat x1 = cos * fx - sin * fy;\r\n\t\t\t\t\tfloat y1 = sin * fx + cos * fy;\r\n\t\t\t\t\tx1 += worldOriginX; y1 += worldOriginY;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfloat tox = x - x1;\r\n\t\t\t\t\tfloat toy = y - y1;\r\n\t\t\t\t\t\r\n\t\t\t\t\tout.x = tox * cos + toy * sin;\r\n\t\t\t\t\tout.y = tox * -sin + toy * cos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif( child.originX == 0 && child.originY == 0 )\r\n\t\t\t\t{\t\r\n\t\t\t\t\tfloat tox = x - child.x;\r\n\t\t\t\t\tfloat toy = y - child.y;\r\n\t\t\t\t\t\r\n\t\t\t\t\tout.x = tox * cos + toy * sin;\r\n\t\t\t\t\tout.y = tox * -sin + toy * cos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tout.x /= child.scaleX;\r\n\t\t\t\t\tout.y /= child.scaleY;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat srefX = child.originX * child.scaleX;\r\n\t\t\t\t\tfloat srefY = child.originY * child.scaleY;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfinal float worldOriginX = child.x + srefX;\r\n\t\t\t\t\tfinal float worldOriginY = child.y + srefY;\r\n\t\t\t\t\tfloat fx = -srefX;\r\n\t\t\t\t\tfloat fy = -srefY;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfloat x1 = cos * fx - sin * fy;\r\n\t\t\t\t\tfloat y1 = sin * fx + cos * fy;\r\n\t\t\t\t\tx1 += worldOriginX; y1 += worldOriginY;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfloat tox = x - x1;\r\n\t\t\t\t\tfloat toy = y - y1;\r\n\t\t\t\t\t\r\n\t\t\t\t\tout.x = tox * cos + toy * sin;\r\n\t\t\t\t\tout.y = tox * -sin + toy * cos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tout.x /= child.scaleX;\r\n\t\t\t\t\tout.y /= child.scaleY;\r\n\t\t\t\t\t\r\n//\t\t\t\t\tfloat srefX = child.originX * child.scaleY;\r\n//\t\t\t\t\tfloat srefY = child.originY * child.scaleX;\r\n//\t\t\t\t\t\r\n//\t\t\t\t\tfloat refX = -sin * srefX + cos * srefY;\r\n//\t\t\t\t\tfloat refY =  cos * srefX + sin * srefY;\r\n//\t\t\t\t\t\r\n//\t\t\t\t\tfloat px = child.x + child.originX - refX;\r\n//\t\t\t\t\tfloat py = child.y + child.originY - refY;\r\n//\t\t\t\t\t\r\n//\t\t\t\t\tfloat tox = x - px;\r\n//\t\t\t\t\tfloat toy = y - py;\r\n//\t\t\t\t\t\r\n//\t\t\t\t\tout.x = tox * cos + toy * sin;\r\n//\t\t\t\t\tout.y = tox * -sin + toy * cos;\r\n//\t\t\t\t\t\r\n//\t\t\t\t\tout.x /= child.scaleX;\r\n//\t\t\t\t\tout.y /= child.scaleY;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":29687,"modified_method":"public static void toChildCoordinates( Actor child, float x, float y, Vector2 out )\r\n\t{\r\n\t\tif( child.rotation == 0 )\r\n\t\t{\r\n\t\t\tif( child.scaleX == 1 && child.scaleY == 1 )\r\n\t\t\t{\r\n\t\t\t\tout.x = x - child.x;\r\n\t\t\t\tout.y = y - child.y;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif( child.originX == 0 && child.originY == 0 )\r\n\t\t\t\t{\r\n\t\t\t\t\tout.x = (x - child.x) / child.scaleX;\r\n\t\t\t\t\tout.y = (y - child.y) / child.scaleY;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tout.x = x / child.scaleX - (child.x - child.originX);\r\n\t\t\t\t\tout.x = x / child.scaleX - (child.x - child.originX);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfinal float cos = (float)Math.cos( (float)Math.toRadians(child.rotation) );\r\n\t\t\tfinal float sin = (float)Math.sin( (float)Math.toRadians(child.rotation) );\r\n\t\t\t\r\n\t\t\tif( child.scaleX == 1 && child.scaleY == 1 )\r\n\t\t\t{\r\n\t\t\t\tif( child.originX == 0 && child.originY == 0 )\r\n\t\t\t\t{\t\r\n\t\t\t\t\tfloat tox = x - child.x;\r\n\t\t\t\t\tfloat toy = y - child.y;\r\n\t\t\t\t\t\r\n\t\t\t\t\tout.x = tox * cos + toy * sin;\r\n\t\t\t\t\tout.y = tox * -sin + toy * cos;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tfinal float worldOriginX = child.x + child.originX;\r\n\t\t\t\t\tfinal float worldOriginY = child.y + child.originY;\r\n\t\t\t\t\tfloat fx = -child.originX;\r\n\t\t\t\t\tfloat fy = -child.originY;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfloat x1 = cos * fx - sin * fy;\r\n\t\t\t\t\tfloat y1 = sin * fx + cos * fy;\r\n\t\t\t\t\tx1 += worldOriginX; y1 += worldOriginY;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfloat tox = x - x1;\r\n\t\t\t\t\tfloat toy = y - y1;\r\n\t\t\t\t\t\r\n\t\t\t\t\tout.x = tox * cos + toy * sin;\r\n\t\t\t\t\tout.y = tox * -sin + toy * cos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif( child.originX == 0 && child.originY == 0 )\r\n\t\t\t\t{\t\r\n\t\t\t\t\tfloat tox = x - child.x;\r\n\t\t\t\t\tfloat toy = y - child.y;\r\n\t\t\t\t\t\r\n\t\t\t\t\tout.x = tox * cos + toy * sin;\r\n\t\t\t\t\tout.y = tox * -sin + toy * cos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tout.x /= child.scaleX;\r\n\t\t\t\t\tout.y /= child.scaleY;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat srefX = child.originX * child.scaleX;\r\n\t\t\t\t\tfloat srefY = child.originY * child.scaleY;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfinal float worldOriginX = child.x + child.originX;\r\n\t\t\t\t\tfinal float worldOriginY = child.y + child.originY;\r\n\t\t\t\t\tfloat fx = -srefX;\r\n\t\t\t\t\tfloat fy = -srefY;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfloat x1 = cos * fx - sin * fy;\r\n\t\t\t\t\tfloat y1 = sin * fx + cos * fy;\r\n\t\t\t\t\tx1 += worldOriginX; y1 += worldOriginY;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfloat tox = x - x1;\r\n\t\t\t\t\tfloat toy = y - y1;\r\n\t\t\t\t\t\r\n\t\t\t\t\tout.x = tox * cos + toy * sin;\r\n\t\t\t\t\tout.y = tox * -sin + toy * cos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tout.x /= child.scaleX;\r\n\t\t\t\t\tout.y /= child.scaleY;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"70e151f1774d7f0c74a4cf414bdbd3597014e9d2","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void surfaceCreated() \r\n\t{\r\n\t\tif( uiTexture == null )\r\n\t\t{\r\n\t\t\tGdx.input.addInputListener( this );\r\n\t\t\t\r\n\t\t\tuiTexture = Gdx.graphics.newTexture( Gdx.files.getFileHandle( \"data/uitexture.png\", FileType.Internal ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tTextureFilter.Linear, TextureFilter.Linear,\r\n\t\t\t\t\t\t\t\t\t\t\t\tTextureWrap.ClampToEdge, TextureWrap.ClampToEdge );\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tui = new Stage( 480, 320, false );\r\n\t\t\tatlas = new TextureAtlas( uiTexture );\r\n\t\t\tatlas.addRegion( \"blend\", 0, 0, 64, 32 );\r\n\t\t\tatlas.addRegion( \"!blend\", 0, 32, 64, 32 );\r\n\t\t\tatlas.addRegion( \"rotate\", 64, 0, 64, 32 );\r\n\t\t\tatlas.addRegion( \"scale\", 64, 32, 64, 32 );\r\n\t\t\tatlas.addRegion( \"button\", 0, 64, 64, 32 );\r\n\t\t\tatlas.addRegion( \"buttonDown\", -2, 62, 64, 32 );\r\n\t\t\t\r\n\t\t\tImage img1 = new Image( \"image1\", atlas.getRegion( \"blend\" ) );\r\n\t\t\timg1.action( Sequence.$( \r\n\t\t\t\t\t\t\t\t\t\tDelay.$( MoveTo.$( 100, 100, 1 ), 2 ),\r\n\t\t\t\t\t\t\t\t\t\tScaleTo.$( 0.5f, 0.5f, 1 ),\r\n\t\t\t\t\t\t\t\t\t\tFadeOut.$( 0.5f ),\r\n\t\t\t\t\t\t\t\t\t\tDelay.$( \r\n\t\t\t\t\t\t\t\t\t\t\t\t Parallel.$( \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t RotateTo.$( 360, 1 ), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t FadeIn.$( 1 ),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t ScaleTo.$( 1, 1, 1 ))\r\n\t\t\t\t\t\t\t\t\t\t\t\t, 1 )\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t);\r\n//\t\t\tui.addActor( img1 );\r\n\t\t\t\r\n\t\t\tGroup group = new Group( \"group\" );\r\n\t\t\tgroup.rotation = 45;\t\t\t\r\n\t\t\tgroup.width = 64; group.height = 32 * 3;\r\n\t\t\tgroup.originX = group.width / 2; group.originY = group.height / 2;\r\n\t\t\tgroup.x = 100;\r\n\t\t\tgroup.y = 150;\r\n\t\t\tgroup.scaleX = 2f; group.scaleY = 2;\r\n\t\t\tButton button = new Button( \"button\", atlas.getRegion( \"button\" ), atlas.getRegion( \"buttonDown\" ) );\t\t\t\r\n\t\t\tgroup.addActor( button );\r\n//\t\t\tgroup.action( RotateTo.$( 720, 4 ) );\r\n\t\t\tui.addActor( group );\r\n\t\t\t\r\n\t\t\tLinearGroup linear = new LinearGroup( \"linear\", 64, 32 * 3, LinearGroupLayout.Vertical );\r\n\t\t\tlinear.x = 200; linear.y = 150; linear.scaleX = linear.scaleY = 1;\r\n\t\t\tlinear.addActor( new Button( \"blend\", atlas.getRegion( \"blend\" ) ) );\r\n\t\t\tlinear.addActor( new Button( \"scale\", atlas.getRegion( \"scale\" ) ) );\r\n\t\t\tlinear.addActor( new Button( \"rotate\", atlas.getRegion( \"rotate\" ) ) );\r\n//\t\t\tlinear.rotation = 720;\r\n//\t\t\tlinear.action( Parallel.$( RotateTo.$( 720, 2 ) ) );\t\t\t\r\n\t\t\t\r\n//\t\t\tui.addActor( linear );\r\n//\t\t\tui.getRoot().rotation = 720;\r\n\t\t\t\r\n\t\t\tGroup.enableDebugging( \"data/debug.png\" );\r\n\t\t}\r\n\t}","id":29688,"modified_method":"@Override\r\n\tpublic void surfaceCreated() \r\n\t{\r\n\t\tif( uiTexture == null )\r\n\t\t{\r\n\t\t\tGdx.input.addInputListener( this );\r\n\t\t\t\r\n\t\t\tuiTexture = Gdx.graphics.newTexture( Gdx.files.getFileHandle( \"data/uitexture.png\", FileType.Internal ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tTextureFilter.Linear, TextureFilter.Linear,\r\n\t\t\t\t\t\t\t\t\t\t\t\tTextureWrap.ClampToEdge, TextureWrap.ClampToEdge );\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tui = new Stage( 480, 320, false );\r\n\t\t\tatlas = new TextureAtlas( uiTexture );\r\n\t\t\tatlas.addRegion( \"blend\", 0, 0, 64, 32 );\r\n\t\t\tatlas.addRegion( \"blendDown\", -1, -1, 64, 32 );\r\n\t\t\tatlas.addRegion( \"rotate\", 64, 0, 64, 32 );\r\n\t\t\tatlas.addRegion( \"rotateDown\", 63, -1, 64, 32 );\r\n\t\t\tatlas.addRegion( \"scale\", 64, 32, 64, 32 );\r\n\t\t\tatlas.addRegion( \"scaleDown\", 63, 31, 64, 32 );\r\n\t\t\tatlas.addRegion( \"button\", 0, 64, 64, 32 );\r\n\t\t\tatlas.addRegion( \"buttonDown\", -1, 63, 64, 32 );\r\n\t\t\t\r\n\t\t\tImage img1 = new Image( \"image1\", atlas.getRegion( \"blend\" ) );\r\n\t\t\timg1.action( Sequence.$( \r\n\t\t\t\t\t\t\t\t\t\tDelay.$( MoveTo.$( 100, 100, 1 ), 2 ),\r\n\t\t\t\t\t\t\t\t\t\tScaleTo.$( 0.5f, 0.5f, 1 ),\r\n\t\t\t\t\t\t\t\t\t\tFadeOut.$( 0.5f ),\r\n\t\t\t\t\t\t\t\t\t\tDelay.$( \r\n\t\t\t\t\t\t\t\t\t\t\t\t Parallel.$( \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t RotateTo.$( 360, 1 ), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t FadeIn.$( 1 ),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t ScaleTo.$( 1, 1, 1 ))\r\n\t\t\t\t\t\t\t\t\t\t\t\t, 1 )\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t);\r\n\t\t\tui.addActor( img1 );\r\n\t\t\t\r\n\t\t\tButton button = new Button( \"button\", atlas.getRegion( \"button\" ), atlas.getRegion( \"buttonDown\" ) );\t\t\t\r\n\t\t\tui.addActor( button );\r\n\t\t\t\r\n\t\t\tLinearGroup linear = new LinearGroup( \"linear\", 64, 32 * 3, LinearGroupLayout.Vertical );\r\n\t\t\tlinear.x = 200; linear.y = 150; linear.scaleX = linear.scaleY = 0;\r\n\t\t\tlinear.addActor( new Button( \"blend\", atlas.getRegion( \"blend\" ), atlas.getRegion( \"blendDown\" )  ) );\r\n\t\t\tlinear.addActor( new Button( \"scale\", atlas.getRegion( \"scale\" ), atlas.getRegion( \"scaleDown\" ) ) );\r\n\t\t\tlinear.addActor( new Button( \"rotate\", atlas.getRegion( \"rotate\" ), atlas.getRegion( \"rotateDown\" ) ) );\r\n\t\t\tlinear.action( Parallel.$( ScaleTo.$( 1, 1, 2 ), RotateTo.$( 720, 2 ) ) );\t\t\t\r\n\t\t\t\r\n\t\t\tui.addActor( linear );\r\n\r\n\t\t\t\r\n//\t\t\tGroup.enableDebugging( \"data/debug.png\" );\r\n\t\t}\r\n\t}","commit_id":"70e151f1774d7f0c74a4cf414bdbd3597014e9d2","url":"https://github.com/libgdx/libgdx"},{"original_method":"public FontCache cacheMultiLineText (FontCache cache, CharSequence str, int width, de.matthiasmann.twl.HAlignment align) {\n\t\tif (cache == null) cache = new GdxFontCache(this, str.length());\n\t\treturn (GdxFontCache)bitmapFont.cacheMultiLineText((GdxFontCache)cache, str, 0, 0, com.badlogic.gdx.graphics.Color.WHITE,\n\t\t\twidth, HAlignment.values()[align.ordinal()]);\n\t}","id":29689,"modified_method":"public FontCache cacheMultiLineText (FontCache cache, CharSequence str, int width, de.matthiasmann.twl.HAlignment align) {\n\t\tif (cache == null) cache = new GdxFontCache();\n\t\tBitmapFontCache bitmapCache = ((GdxFontCache)cache).bitmapCache;\n\t\tbitmapFont.cacheMultiLineText(bitmapCache, str, 0, 0, com.badlogic.gdx.graphics.Color.WHITE, width,\n\t\t\tHAlignment.values()[align.ordinal()]);\n\t\treturn cache;\n\t}","commit_id":"e6e8226e7e7a601b758690593c0930c03c8d1333","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void draw (AnimationState as, int x, int y) {\n\t\t\ty = Gdx.graphics.getHeight() - y;\n\t\t\tGdxFont.FontState fontState = font.evalFontState(as);\n\t\t\tTwlRenderer renderer = font.renderer;\n\t\t\tsetColor(renderer.getColor(fontState.color));\n\t\t\tsetPosition(x + fontState.offsetX, y + fontState.offsetY);\n\t\t\tdraw(renderer.spriteBatch);\n\t\t}","id":29690,"modified_method":"public void draw (AnimationState as, int x, int y) {\n\t\t\ty = Gdx.graphics.getHeight() - y;\n\t\t\tGdxFont.FontState fontState = evalFontState(as);\n\t\t\tbitmapCache.setColor(renderer.getColor(fontState.color));\n\t\t\tbitmapCache.setPosition(x + fontState.offsetX, y + fontState.offsetY);\n\t\t\tbitmapCache.draw(renderer.spriteBatch);\n\t\t}","commit_id":"e6e8226e7e7a601b758690593c0930c03c8d1333","url":"https://github.com/libgdx/libgdx"},{"original_method":"public FontCache cacheText (FontCache cache, CharSequence str, int start, int end) {\n\t\tif (cache == null) cache = new GdxFontCache(this, str.length());\n\t\treturn (GdxFontCache)bitmapFont\n\t\t\t.cacheText((GdxFontCache)cache, str, 0, 0, com.badlogic.gdx.graphics.Color.WHITE, start, end);\n\t}","id":29691,"modified_method":"public FontCache cacheText (FontCache cache, CharSequence str, int start, int end) {\n\t\tif (cache == null) cache = new GdxFontCache();\n\t\tBitmapFontCache bitmapCache = ((GdxFontCache)cache).bitmapCache;\n\t\tbitmapFont.cacheText(bitmapCache, str, 0, 0, com.badlogic.gdx.graphics.Color.WHITE, start, end);\n\t\treturn cache;\n\t}","commit_id":"e6e8226e7e7a601b758690593c0930c03c8d1333","url":"https://github.com/libgdx/libgdx"},{"original_method":"public GdxFontCache (GdxFont font, int glyphCount) {\n\t\t\tsuper(font.bitmapFont.getTexture(), glyphCount);\n\t\t\tthis.font = font;\n\t\t}","id":29692,"modified_method":"public GdxFontCache () {\n\t\t\tbitmapCache = bitmapFont.newCache();\n\t\t}","commit_id":"e6e8226e7e7a601b758690593c0930c03c8d1333","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n  public void setText(final String text) {\n    getChildComponent().setText(text);\n\n    Editor editor = getChildComponent().getEditor();\n    if (editor != null) {\n      collapseIfPossible(editor, myExternalSystemId, myProject);\n    }\n  }","id":29693,"modified_method":"@Override\n  public void setText(final String text) {\n    getChildComponent().getTextField().setText(text);\n\n    Editor editor = getChildComponent().getTextField().getEditor();\n    if (editor != null) {\n      collapseIfPossible(editor, myExternalSystemId, myProject);\n    }\n  }","commit_id":"d341182d402f03b3fd349d526bf47d20a08bf618","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ExternalProjectPathField(@NotNull Project project,\n                                  @NotNull ProjectSystemId externalSystemId,\n                                  @NotNull FileChooserDescriptor descriptor,\n                                  @NotNull String fileChooserTitle)\n  {\n    super(createTextField(project, externalSystemId), new MyBrowseListener(descriptor, fileChooserTitle, project));\n    ActionListener[] listeners = getButton().getActionListeners();\n    for (ActionListener listener : listeners) {\n      if (listener instanceof MyBrowseListener) {\n        ((MyBrowseListener)listener).setPathField(getChildComponent());\n        break;\n      }\n    }\n    myProject = project;\n    myExternalSystemId = externalSystemId;\n  }","id":29694,"modified_method":"public ExternalProjectPathField(@NotNull Project project,\n                                  @NotNull ProjectSystemId externalSystemId,\n                                  @NotNull FileChooserDescriptor descriptor,\n                                  @NotNull String fileChooserTitle)\n  {\n    super(createPanel(project, externalSystemId), new MyBrowseListener(descriptor, fileChooserTitle, project));\n    ActionListener[] listeners = getButton().getActionListeners();\n    for (ActionListener listener : listeners) {\n      if (listener instanceof MyBrowseListener) {\n        ((MyBrowseListener)listener).setPathField(getChildComponent().getTextField());\n        break;\n      }\n    }\n    myProject = project;\n    myExternalSystemId = externalSystemId;\n  }","commit_id":"d341182d402f03b3fd349d526bf47d20a08bf618","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getText() {\n    return getChildComponent().getText();\n  }","id":29695,"modified_method":"@Override\n  public String getText() {\n    return getChildComponent().getTextField().getText();\n  }","commit_id":"d341182d402f03b3fd349d526bf47d20a08bf618","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected NSMutableDictionary<String, Object> rowFromStoredValues(NSMutableDictionary<String, Object> rawRow, EOEntity entity) {\n    NSMutableDictionary<String, Object> row = new NSMutableDictionary<String, Object>(rawRow.count()); \n    for (EOAttribute attribute : (NSArray<EOAttribute>)entity.attributesToFetch()) {\n      Object value = rawRow.objectForKey(attribute.columnName());\n      if (attribute.isDerived()) {\n        if (!attribute.isFlattened()) {\n          // Evaluate derived attribute expression\n\n          /*\n          //This is a hack to support SQL string concatenation in derived attributes\n          String expression = attribute.definition().replaceAll(\"\\\\|\\\\|\", \"+ '' +\");\n          try {\n            value = Ognl.getValue(expression, rawRow);\n          } catch (Throwable t) {\n            t.printStackTrace();\n          }\n          */\n        } else {\n          String dstKey = attribute.definition();\n          value = rawRow.objectForKey(dstKey);\n        }\n      }\n      row.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attribute.name());\n    }\n    return row;\n  }","id":29696,"modified_method":"protected NSMutableDictionary<String, Object> rowFromStoredValues(NSMutableDictionary<String, Object> rawRow, EOEntity entity) {\n    NSMutableDictionary<String, Object> row = new NSMutableDictionary<String, Object>(rawRow.count()); \n    for (EOAttribute attribute : (NSArray<EOAttribute>)entity.attributesToFetch()) {\n      Object value = rawRow.objectForKey(attribute.columnName());\n      if (attribute.isDerived()) {\n        if (!attribute.isFlattened()) {\n          try {\n            // Evaluate derived attribute expression\n            // This is a hack to support SQL string concatenation in derived attributes\n            String expression = attribute.definition().replaceAll(\"\\\\|\\\\|\", \"+ '' +\");\n            value = Ognl.getValue(expression, rawRow);\n            \n          } catch (Throwable t) {\n            t.printStackTrace();\n          }\n        } else {\n          String dstKey = attribute.definition();\n          value = rawRow.objectForKey(dstKey);\n        }\n      }\n      row.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attribute.name());\n    }\n    return row;\n  }","commit_id":"c93cb43d67aba70f9777ecd14a5052d6e7ec8937","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void insertRow(NSDictionary<String, Object> row, EOEntity entity) {\n    try {\n      NSMutableDictionary<String, Object> mutableRow = new NSMutableDictionary<String, Object>(row.size());\n      for (Enumeration e = entity.attributes().objectEnumerator(); e.hasMoreElements();) {\n        EOAttribute attribute = (EOAttribute) e.nextElement();\n        Object value = row.objectForKey(attribute.name());\n        if (!attribute.isDerived())\n          mutableRow.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attribute.columnName());\n      }\n      _insertRow(mutableRow, entity);\n    }\n    catch (EOGeneralAdaptorException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n      throw new EOGeneralAdaptorException(\"Failed to insert '\" + entity.name() + \"' with row \" + row + \": \" + e.getMessage());\n    }\n  }","id":29697,"modified_method":"public void insertRow(NSDictionary<String, Object> row, EOEntity entity) {\n    try {\n      NSMutableDictionary<String, Object> mutableRow = new NSMutableDictionary<String, Object>(row.size());\n      for (Enumeration e = entity.attributes().objectEnumerator(); e.hasMoreElements();) {\n        EOAttribute attribute = (EOAttribute) e.nextElement();\n        Object value = row.objectForKey(attribute.name());\n        if (!(attribute.isDerived() || attribute.isReadOnly()))\n          mutableRow.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attribute.columnName());\n      }\n      _insertRow(mutableRow, entity);\n    }\n    catch (EOGeneralAdaptorException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n      throw new EOGeneralAdaptorException(\"Failed to insert '\" + entity.name() + \"' with row \" + row + \": \" + e.getMessage());\n    }\n  }","commit_id":"c93cb43d67aba70f9777ecd14a5052d6e7ec8937","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected NSMutableDictionary<String, Object> rowFromStoredValues(NSMutableDictionary<String, Object> rawRow, EOEntity entity) {\n    NSMutableDictionary<String, Object> row = new NSMutableDictionary<String, Object>(rawRow.count()); \n    for (EOAttribute attribute : entity.attributesToFetch()) {\n      Object value = rawRow.objectForKey(attribute.columnName());\n      if (attribute.isDerived()) {\n        if (!attribute.isFlattened()) {\n          // Evaluate derived attribute expression\n\n          /*\n          //This is a hack to support SQL string concatenation in derived attributes\n          String expression = attribute.definition().replaceAll(\"\\\\|\\\\|\", \"+ '' +\");\n          try {\n            value = Ognl.getValue(expression, rawRow);\n          } catch (Throwable t) {\n            t.printStackTrace();\n          }\n          */\n        } else {\n          String dstKey = attribute.definition();\n          value = rawRow.objectForKey(dstKey);\n        }\n      }\n      row.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attribute.name());\n    }\n    return row;\n  }","id":29698,"modified_method":"protected NSMutableDictionary<String, Object> rowFromStoredValues(NSMutableDictionary<String, Object> rawRow, EOEntity entity) {\n    NSMutableDictionary<String, Object> row = new NSMutableDictionary<String, Object>(rawRow.count()); \n    for (EOAttribute attribute : entity.attributesToFetch()) {\n      Object value = rawRow.objectForKey(attribute.columnName());\n      if (attribute.isDerived()) {\n        if (!attribute.isFlattened()) {\n          try {\n            // Evaluate derived attribute expression\n            // This is a hack to support SQL string concatenation in derived attributes\n            String expression = attribute.definition().replaceAll(\"\\\\|\\\\|\", \"+ '' +\");\n            value = Ognl.getValue(expression, rawRow);\n            \n          } catch (Throwable t) {\n            t.printStackTrace();\n          }\n        } else {\n          String dstKey = attribute.definition();\n          value = rawRow.objectForKey(dstKey);\n        }\n      }\n      row.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attribute.name());\n    }\n    return row;\n  }","commit_id":"3acafe5142b18bf2a0ef0d1db4ad5ef136672eaa","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void insertRow(NSDictionary<String, Object> row, EOEntity entity) {\n    try {\n      NSMutableDictionary<String, Object> mutableRow = new NSMutableDictionary<String, Object>(row.size());\n      for (Enumeration e = entity.attributes().objectEnumerator(); e.hasMoreElements();) {\n        EOAttribute attribute = (EOAttribute) e.nextElement();\n        Object value = row.objectForKey(attribute.name());\n        if (!attribute.isDerived())\n          mutableRow.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attribute.columnName());\n      }\n      _insertRow(mutableRow, entity);\n    }\n    catch (EOGeneralAdaptorException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n      throw new EOGeneralAdaptorException(\"Failed to insert '\" + entity.name() + \"' with row \" + row + \": \" + e.getMessage());\n    }\n  }","id":29699,"modified_method":"public void insertRow(NSDictionary<String, Object> row, EOEntity entity) {\n    try {\n      NSMutableDictionary<String, Object> mutableRow = new NSMutableDictionary<String, Object>(row.size());\n      for (Enumeration e = entity.attributes().objectEnumerator(); e.hasMoreElements();) {\n        EOAttribute attribute = (EOAttribute) e.nextElement();\n        Object value = row.objectForKey(attribute.name());\n        if (!(attribute.isDerived() || attribute.isReadOnly()))\n          mutableRow.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attribute.columnName());\n      }\n      _insertRow(mutableRow, entity);\n    }\n    catch (EOGeneralAdaptorException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n      throw new EOGeneralAdaptorException(\"Failed to insert '\" + entity.name() + \"' with row \" + row + \": \" + e.getMessage());\n    }\n  }","commit_id":"3acafe5142b18bf2a0ef0d1db4ad5ef136672eaa","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void resolveLazyCrossReference(InternalEObject source, EStructuralFeature crossRef) {\n\t\tif (crossRef.isDerived())\n\t\t\treturn;\n\t\tif (crossRef.isMany()) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tInternalEList<EObject> list = (InternalEList<EObject>) source.eGet(crossRef);\n\t\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\t\tEObject proxy = list.basicGet(i);\n\t\t\t\tif (proxy.eIsProxy()) {\n\t\t\t\t\tURI proxyURI = ((InternalEObject) proxy).eProxyURI();\n\t\t\t\t\tif (getURI().equals(proxyURI.trimFragment())) {\n\t\t\t\t\t\tfinal String fragment = proxyURI.fragment();\n\t\t\t\t\t\tif (getEncoder().isCrossLinkFragment(this, fragment)) {\n\t\t\t\t\t\t\tEObject target = getEObject(fragment);\n\t\t\t\t\t\t\tif (target != null) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tsource.eSetDeliver(false);\n\t\t\t\t\t\t\t\t\tlist.setUnique(i, target);\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\tsource.eSetDeliver(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tEObject proxy = (EObject) source.eGet(crossRef, false);\n\t\t\tif (proxy != null && proxy.eIsProxy()) {\n\t\t\t\tURI proxyURI = ((InternalEObject) proxy).eProxyURI();\n\t\t\t\tif (getURI().equals(proxyURI.trimFragment())) {\n\t\t\t\t\tfinal String fragment = proxyURI.fragment();\n\t\t\t\t\tif (getEncoder().isCrossLinkFragment(this, fragment)) {\n\t\t\t\t\t\tEObject target = getEObject(fragment);\n\t\t\t\t\t\tif (target != null) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tsource.eSetDeliver(false);\n\t\t\t\t\t\t\t\tsource.eSet(crossRef, target);\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tsource.eSetDeliver(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":29700,"modified_method":"protected void resolveLazyCrossReference(InternalEObject source, EStructuralFeature crossRef) {\n\t\tif (crossRef.isDerived() \n\t\t\t\t|| (crossRef instanceof EReference && !((EReference)crossRef).isResolveProxies())\n\t\t\t\t|| crossRef.isTransient())\n\t\t\treturn;\n\t\tif (crossRef.isMany()) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tInternalEList<EObject> list = (InternalEList<EObject>) source.eGet(crossRef);\n\t\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\t\tEObject proxy = list.basicGet(i);\n\t\t\t\tif (proxy.eIsProxy()) {\n\t\t\t\t\tURI proxyURI = ((InternalEObject) proxy).eProxyURI();\n\t\t\t\t\tif (getURI().equals(proxyURI.trimFragment())) {\n\t\t\t\t\t\tfinal String fragment = proxyURI.fragment();\n\t\t\t\t\t\tif (getEncoder().isCrossLinkFragment(this, fragment)) {\n\t\t\t\t\t\t\tEObject target = getEObject(fragment);\n\t\t\t\t\t\t\tif (target != null) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tsource.eSetDeliver(false);\n\t\t\t\t\t\t\t\t\tlist.setUnique(i, target);\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\tsource.eSetDeliver(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tEObject proxy = (EObject) source.eGet(crossRef, false);\n\t\t\tif (proxy != null && proxy.eIsProxy()) {\n\t\t\t\tURI proxyURI = ((InternalEObject) proxy).eProxyURI();\n\t\t\t\tif (getURI().equals(proxyURI.trimFragment())) {\n\t\t\t\t\tfinal String fragment = proxyURI.fragment();\n\t\t\t\t\tif (getEncoder().isCrossLinkFragment(this, fragment)) {\n\t\t\t\t\t\tEObject target = getEObject(fragment);\n\t\t\t\t\t\tif (target != null) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tsource.eSetDeliver(false);\n\t\t\t\t\t\t\t\tsource.eSet(crossRef, target);\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tsource.eSetDeliver(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"10a13bf1e7bf9ec9f02d64a7de6c97791a032d98","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public String getUrl() {\n    return \"trello.com\";\n  }","id":29701,"modified_method":"@Override\n  public String getUrl() {\n    return \"https://api.trello.com\";\n  }","commit_id":"c6f0821bd8e9e3704c6bbb6e471c59511598e015","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public CancellableConnection createCancellableConnection() {\n    final GetMethod method = new GetMethod(TRELLO_API_BASE_URL + \"/members/me/cards?limit=1\");\n    configureHttpMethod(method);\n    return new HttpTestConnection<GetMethod>(method) {\n      @Override\n      protected void doTest(GetMethod method) throws Exception {\n        executeMethod(method);\n      }\n    };\n  }","id":29702,"modified_method":"@Nullable\n  @Override\n  public CancellableConnection createCancellableConnection() {\n    return new HttpTestConnection(new HttpGet(getRestApiUrl(\"me\", \"cards\") + \"?limit=1\"));\n  }","commit_id":"c6f0821bd8e9e3704c6bbb6e471c59511598e015","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private <T> T makeRequestAndDeserializeJsonResponse(@NotNull String url, @NotNull Class<T> cls) throws Exception {\n    final String entityStream = makeRequest(url);\n    return TrelloUtil.GSON.fromJson(entityStream, cls);\n  }","id":29703,"modified_method":"@NotNull\n  private <T> T makeRequestAndDeserializeJsonResponse(@NotNull String url, @NotNull Class<T> cls) throws Exception {\n    return executeMethod(new HttpGet(url), new GsonSingleObjectDeserializer<T>(TrelloUtil.GSON, cls));\n  }","commit_id":"c6f0821bd8e9e3704c6bbb6e471c59511598e015","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private <T> T makeRequestAndDeserializeJsonResponse(@NotNull String url, @NotNull Type type) throws Exception {\n    final String entityStream = makeRequest(url);\n    // javac 1.6.0_23 bug workaround\n    // TrelloRepository.java:286: type parameters of <T>T cannot be determined; no unique maximal instance exists for type variable T with upper bounds T,java.lang.Object\n    //noinspection unchecked\n    return (T)TrelloUtil.GSON.fromJson(entityStream, type);\n  }","id":29704,"modified_method":"@NotNull\n  private <T> List<T> makeRequestAndDeserializeJsonResponse(@NotNull String url, @NotNull TypeToken<List<T>> type) throws Exception {\n    return executeMethod(new HttpGet(url), new GsonMultipleObjectsDeserializer<T>(TrelloUtil.GSON, type));\n  }","commit_id":"c6f0821bd8e9e3704c6bbb6e471c59511598e015","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Creates a new {@code HttpClient} instance.\n     *\n     * @param settings The settings to use for setting up the client or {@code null}.\n     * @param url The {@code URL} to use for setting up the client or {@code null}.\n     *\n     * @return A new {@code HttpClient} instance.\n     *\n     * @see #DEFAULT_TIMEOUT\n     * @since 2.8\n     */\n    private static HttpClient createHttpClient( Settings settings, URL url )\n    {\n        HttpClient httpClient = new HttpClient( new MultiThreadedHttpConnectionManager() );\n        httpClient.getHttpConnectionManager().getParams().setConnectionTimeout( DEFAULT_TIMEOUT );\n        httpClient.getHttpConnectionManager().getParams().setSoTimeout( DEFAULT_TIMEOUT );\n        httpClient.getParams().setBooleanParameter( HttpClientParams.ALLOW_CIRCULAR_REDIRECTS, true );\n\n        // Some web servers don't allow the default user-agent sent by httpClient\n        httpClient.getParams().setParameter( HttpMethodParams.USER_AGENT,\n                                             \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)\" );\n\n        if ( settings != null && settings.getActiveProxy() != null )\n        {\n            Proxy activeProxy = settings.getActiveProxy();\n\n            ProxyInfo proxyInfo = new ProxyInfo();\n            proxyInfo.setNonProxyHosts( activeProxy.getNonProxyHosts() );\n\n            if ( StringUtils.isNotEmpty( activeProxy.getHost() )\n                 && ( url == null || !ProxyUtils.validateNonProxyHosts( proxyInfo, url.getHost() ) ) )\n            {\n                httpClient.getHostConfiguration().setProxy( activeProxy.getHost(), activeProxy.getPort() );\n\n                if ( StringUtils.isNotEmpty( activeProxy.getUsername() ) && activeProxy.getPassword() != null )\n                {\n                    Credentials credentials =\n                        new UsernamePasswordCredentials( activeProxy.getUsername(), activeProxy.getPassword() );\n\n                    httpClient.getState().setProxyCredentials( AuthScope.ANY, credentials );\n                }\n            }\n        }\n\n        return httpClient;\n    }","id":29705,"modified_method":"/**\n     * Creates a new {@code HttpClient} instance.\n     *\n     * @param settings The settings to use for setting up the client or {@code null}.\n     * @param url The {@code URL} to use for setting up the client or {@code null}.\n     *\n     * @return A new {@code HttpClient} instance.\n     *\n     * @see #DEFAULT_TIMEOUT\n     * @since 2.8\n     */\n    private static HttpClient createHttpClient( Settings settings, URL url )\n    {\n        DefaultHttpClient httpClient = new DefaultHttpClient( new PoolingClientConnectionManager() );\n        httpClient.getParams().setIntParameter( CoreConnectionPNames.SO_TIMEOUT, DEFAULT_TIMEOUT );\n        httpClient.getParams().setIntParameter( CoreConnectionPNames.CONNECTION_TIMEOUT, DEFAULT_TIMEOUT );\n        httpClient.getParams().setBooleanParameter( ClientPNames.ALLOW_CIRCULAR_REDIRECTS, true );\n\n        // Some web servers don't allow the default user-agent sent by httpClient\n        httpClient.getParams().setParameter( CoreProtocolPNames.USER_AGENT,\n                                             \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)\" );\n\n        if ( settings != null && settings.getActiveProxy() != null )\n        {\n            Proxy activeProxy = settings.getActiveProxy();\n\n            ProxyInfo proxyInfo = new ProxyInfo();\n            proxyInfo.setNonProxyHosts( activeProxy.getNonProxyHosts() );\n\n            if ( StringUtils.isNotEmpty( activeProxy.getHost() )\n                 && ( url == null || !ProxyUtils.validateNonProxyHosts( proxyInfo, url.getHost() ) ) )\n            {\n                HttpHost proxy = new HttpHost(activeProxy.getHost(), activeProxy.getPort());\n                httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);\n\n                if ( StringUtils.isNotEmpty( activeProxy.getUsername() ) && activeProxy.getPassword() != null )\n                {\n                    Credentials credentials =\n                        new UsernamePasswordCredentials( activeProxy.getUsername(), activeProxy.getPassword() );\n\n                    httpClient.getCredentialsProvider().setCredentials(AuthScope.ANY, credentials);\n                }\n            }\n        }\n\n        return httpClient;\n    }","commit_id":"18380273f4d4b3bcd1bbe599e8c0a68d98aed367","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Validates an <code>URL<\/code> to point to a valid <code>package-list<\/code> resource.\n     *\n     * @param url The URL to validate.\n     * @param settings The user settings used to configure the connection to the URL or {@code null}.\n     * @param validateContent <code>true<\/code> to validate the content of the <code>package-list<\/code> resource;\n     * <code>false<\/code> to only check the existence of the <code>package-list<\/code> resource.\n     *\n     * @return <code>true<\/code> if <code>url<\/code> points to a valid <code>package-list<\/code> resource;\n     * <code>false<\/code> else.\n     *\n     * @throws IOException if reading the resource fails.\n     *\n     * @see #createHttpClient(org.apache.maven.settings.Settings, java.net.URL)\n     *\n     * @since 2.8\n     */\n    protected static boolean isValidPackageList( URL url, Settings settings, boolean validateContent )\n        throws IOException\n    {\n        if ( url == null )\n        {\n            throw new IllegalArgumentException( \"The url is null\" );\n        }\n\n        BufferedReader reader = null;\n        GetMethod httpMethod = null;\n\n        try\n        {\n            if ( \"file\".equals( url.getProtocol() ) )\n            {\n                // Intentionally using the platform default encoding here since this is what Javadoc uses internally.\n                reader = new BufferedReader( new InputStreamReader( url.openStream() ) );\n            }\n            else\n            {\n                // http, https...\n                HttpClient httpClient = createHttpClient( settings, url );\n\n                httpMethod = new GetMethod( url.toString() );\n                int status;\n                try\n                {\n                    status = httpClient.executeMethod( httpMethod );\n                }\n                catch ( SocketTimeoutException e )\n                {\n                    // could be a sporadic failure, one more retry before we give up\n                    status = httpClient.executeMethod( httpMethod );\n                }\n\n                if ( status != HttpStatus.SC_OK )\n                {\n                    throw new FileNotFoundException(\n                        \"Unexpected HTTP status code \" + status + \" getting resource \" + url.toExternalForm() + \".\" );\n\n                }\n\n                // Intentionally using the platform default encoding here since this is what Javadoc uses internally.\n                reader = new BufferedReader( new InputStreamReader( httpMethod.getResponseBodyAsStream() ) );\n            }\n\n            if ( validateContent )\n            {\n                String line;\n                while ( ( line = reader.readLine() ) != null )\n                {\n                    if ( !isValidPackageName( line ) )\n                    {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        }\n        finally\n        {\n            IOUtil.close( reader );\n\n            if ( httpMethod != null )\n            {\n                httpMethod.releaseConnection();\n            }\n        }\n    }","id":29706,"modified_method":"/**\n     * Validates an <code>URL<\/code> to point to a valid <code>package-list<\/code> resource.\n     *\n     * @param url The URL to validate.\n     * @param settings The user settings used to configure the connection to the URL or {@code null}.\n     * @param validateContent <code>true<\/code> to validate the content of the <code>package-list<\/code> resource;\n     * <code>false<\/code> to only check the existence of the <code>package-list<\/code> resource.\n     *\n     * @return <code>true<\/code> if <code>url<\/code> points to a valid <code>package-list<\/code> resource;\n     * <code>false<\/code> else.\n     *\n     * @throws IOException if reading the resource fails.\n     *\n     * @see #createHttpClient(org.apache.maven.settings.Settings, java.net.URL)\n     *\n     * @since 2.8\n     */\n    protected static boolean isValidPackageList( URL url, Settings settings, boolean validateContent )\n        throws IOException\n    {\n        if ( url == null )\n        {\n            throw new IllegalArgumentException( \"The url is null\" );\n        }\n\n        BufferedReader reader = null;\n        HttpGet httpMethod = null;\n        HttpClient httpClient = null;\n\n        try\n        {\n            if ( \"file\".equals( url.getProtocol() ) )\n            {\n                // Intentionally using the platform default encoding here since this is what Javadoc uses internally.\n                reader = new BufferedReader( new InputStreamReader( url.openStream() ) );\n            }\n            else\n            {\n                // http, https...\n                httpClient = createHttpClient( settings, url );\n\n                httpMethod = new HttpGet( url.toString() );\n                HttpResponse response;\n                try\n                {\n                    response = httpClient.execute( httpMethod );\n                }\n                catch ( SocketTimeoutException e )\n                {\n                    // could be a sporadic failure, one more retry before we give up\n                    response = httpClient.execute( httpMethod );\n                }\n\n                int status = response.getStatusLine().getStatusCode();\n                if ( status != HttpStatus.SC_OK )\n                {\n                    throw new FileNotFoundException(\n                        \"Unexpected HTTP status code \" + status + \" getting resource \" + url.toExternalForm() + \".\" );\n                }\n\n                // Intentionally using the platform default encoding here since this is what Javadoc uses internally.\n                reader = new BufferedReader( new InputStreamReader( response.getEntity().getContent() ) );\n            }\n\n            if ( validateContent )\n            {\n                String line;\n                while ( ( line = reader.readLine() ) != null )\n                {\n                    if ( !isValidPackageName( line ) )\n                    {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        }\n        finally\n        {\n            IOUtil.close( reader );\n\n            if ( httpMethod != null )\n            {\n                httpMethod.releaseConnection();\n            }\n            if ( httpClient != null )\n            {\n                httpClient.getConnectionManager().shutdown();\n            }\n        }\n    }","commit_id":"18380273f4d4b3bcd1bbe599e8c0a68d98aed367","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n    public void close() {\n        method.abort();\n    }","id":29707,"modified_method":"@Override\n    public void close() {\n        try {\n            EntityUtils.consume(response.getEntity());\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"public InputStream openStream() throws IOException {\n        LOGGER.debug(\"Attempting to download resource {}.\", source);\n        return method.getResponseBodyAsStream();\n    }","id":29708,"modified_method":"public InputStream openStream() throws IOException {\n        LOGGER.debug(\"Attempting to download resource {}.\", source);\n        return response.getEntity().getContent();\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"public long getLastModified() {\n        Header responseHeader = method.getResponseHeader(\"last-modified\");\n        if (responseHeader == null) {\n            return 0;\n        }\n        try {\n            return Date.parse(responseHeader.getValue());\n        } catch (Exception e) {\n            return 0;\n        }\n    }","id":29709,"modified_method":"public long getLastModified() {\n        Header responseHeader = response.getFirstHeader(\"last-modified\");\n        if (responseHeader == null) {\n            return 0;\n        }\n        try {\n            return Date.parse(responseHeader.getValue());\n        } catch (Exception e) {\n            return 0;\n        }\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"public long getContentLength() {\n        return method.getResponseContentLength();\n    }","id":29710,"modified_method":"public long getContentLength() {\n        return response.getEntity().getContentLength();\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"public HttpGetResource(String source, HttpMethodBase method) {\n        this.source = source;\n        this.method = method;\n    }","id":29711,"modified_method":"public HttpGetResource(String source, HttpResponse response) {\n        this.source = source;\n        this.response = response;\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"private int executeMethod(HttpMethod method) throws IOException {\n        LOGGER.debug(\"Performing HTTP GET: {}\", method.getURI());\n        configureProxyIfRequired(method);\n        return client.executeMethod(method);\n    }","id":29712,"modified_method":"private HttpResponse executeMethod(HttpUriRequest method) throws IOException {\n        LOGGER.debug(\"Performing HTTP GET: {}\", method.getURI());\n        HttpResponse httpResponse = client.execute(method);\n        // Consume content for non-successful, responses. This avoids the connection being left open.\n        if (!wasSuccessful(httpResponse)) {\n            EntityUtils.consume(httpResponse.getEntity());\n            return httpResponse;\n        }\n        return httpResponse;\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"public HttpResourceCollection(HttpSettings httpSettings, ExternalArtifactCache externalArtifactCache) {\n        PasswordCredentials credentials = httpSettings.getCredentials();\n        if (GUtil.isTrue(credentials.getUsername())) {\n            client.getParams().setAuthenticationPreemptive(true);\n            client.getState().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(credentials.getUsername(), credentials.getPassword()));\n        }\n        this.proxySettings = httpSettings.getProxySettings();\n        this.externalArtifactCache = externalArtifactCache;\n    }","id":29713,"modified_method":"public HttpResourceCollection(HttpSettings httpSettings, ExternalArtifactCache externalArtifactCache) {\n        PasswordCredentials credentials = httpSettings.getCredentials();\n        if (GUtil.isTrue(credentials.getUsername())) {\n            httpClientCredentials = new UsernamePasswordCredentials(credentials.getUsername(), credentials.getPassword());\n        } else {\n            httpClientCredentials = null;\n        }\n        this.externalArtifactCache = externalArtifactCache;\n\n        // Use standard JVM proxy settings\n        ProxySelectorRoutePlanner routePlanner = new ProxySelectorRoutePlanner(client.getConnectionManager().getSchemeRegistry(), ProxySelector.getDefault());\n        client.setRoutePlanner(routePlanner);\n\n        client.setHttpRequestRetryHandler(new HttpRequestRetryHandler() {\n            public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {\n                return false;\n            }\n        });\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"private HttpResource initGet(String source, List<CachedArtifact> candidates) {\n        // First see if we can use any of the candidates directly.\n        if (candidates.size() > 0) {\n            CachedHttpResource cachedResource = findCachedResource(source, candidates);\n            if (cachedResource != null) {\n                return cachedResource;\n            }\n        }\n\n        GetMethod method = new GetMethod(source);\n        configureMethod(method);\n        int result;\n        try {\n            result = executeMethod(method);\n        } catch (IOException e) {\n            throw new UncheckedIOException(String.format(\"Could not GET '%s'.\", source), e);\n        }\n        if (result == 404) {\n            LOGGER.info(\"Resource missing. [HTTP GET: {}]\", source);\n            return new MissingHttpResource(source);\n        }\n        if (!wasSuccessful(result)) {\n            LOGGER.info(\"Failed to get resource: {} ({}). [HTTP GET: {}]\", new Object[]{result, method.getStatusText(), source});\n            throw new UncheckedIOException(String.format(\"Could not GET '%s'. Received status code %s from server: %s\", source, result, method.getStatusText()));\n        }\n        LOGGER.info(\"Resource found. [HTTP GET: {}]\", source);\n        return new HttpGetResource(source, method);\n    }","id":29714,"modified_method":"private HttpResource initGet(String source, List<CachedArtifact> candidates) {\n        // First see if we can use any of the candidates directly.\n        if (candidates.size() > 0) {\n            CachedHttpResource cachedResource = findCachedResource(source, candidates);\n            if (cachedResource != null) {\n                return cachedResource;\n            }\n        }\n\n        HttpGet request = new HttpGet(source);\n        configureMethod(request);\n        HttpResponse response;\n        try {\n            response = executeMethod(request);\n        } catch (IOException e) {\n            throw new UncheckedIOException(String.format(\"Could not GET '%s'.\", source), e);\n        }\n        if (wasMissing(response)) {\n            LOGGER.info(\"Resource missing. [HTTP GET: {}]\", source);\n            return new MissingHttpResource(source);\n        }\n        if (!wasSuccessful(response)) {\n            LOGGER.info(\"Failed to get resource: {}. [HTTP GET: {}]\", response.getStatusLine(), source);\n            throw new UncheckedIOException(String.format(\"Could not GET '%s'. Received status code %s from server: %s\",\n                                                         source, response.getStatusLine().getStatusCode(), response.getStatusLine().getReasonPhrase()));\n        }\n        LOGGER.info(\"Resource found. [HTTP GET: {}]\", source);\n        return new HttpGetResource(source, response);\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureMethod(HttpMethod method) {\n        method.setRequestHeader(\"User-Agent\", \"Gradle/\" + GradleVersion.current().getVersion());\n        method.setRequestHeader(\"Accept-Encoding\", \"identity\");\n        method.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, new HttpMethodRetryHandler() {\n            public boolean retryMethod(HttpMethod method, IOException exception, int executionCount) {\n                return false;\n            }\n        });\n    }","id":29715,"modified_method":"private void configureMethod(HttpRequest method) {\n        method.addHeader(\"User-Agent\", \"Gradle/\" + GradleVersion.current().getVersion());\n        method.addHeader(\"Accept-Encoding\", \"identity\");\n\n        // Do preemptive authentication\n        if (httpClientCredentials != null) {\n            try {\n                method.addHeader(new BasicScheme().authenticate(httpClientCredentials, method));\n            } catch (AuthenticationException e) {\n                throw UncheckedException.asUncheckedException(e);\n            }\n        }\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"private String downloadChecksum(String checksumUrl) {\n        GetMethod get = new GetMethod(checksumUrl);\n        configureMethod(get);\n        try {\n            int result = executeMethod(get);\n            if (wasSuccessful(result)) {\n                return WharfUtils.getCleanChecksum(get.getResponseBodyAsString());\n            }\n            if (result != 404) {\n                LOGGER.info(\"Request for checksum at {} failed: {}\", checksumUrl, get.getStatusText());\n            }\n            return null;\n        } catch (IOException e) {\n            LOGGER.warn(\"Checksum missing at {} due to: {}\", checksumUrl, e.getMessage());\n            return null;\n        } finally {\n            get.releaseConnection();\n        }\n    }","id":29716,"modified_method":"private String downloadChecksum(String checksumUrl) {\n        HttpGet get = new HttpGet(checksumUrl);\n        configureMethod(get);\n        try {\n            HttpResponse httpResponse = executeMethod(get);\n            if (wasSuccessful(httpResponse)) {\n                String checksumValue = EntityUtils.toString(httpResponse.getEntity());\n                return WharfUtils.getCleanChecksum(checksumValue);\n            }\n            if (!wasMissing(httpResponse)) {\n                LOGGER.info(\"Request for checksum at {} failed: {}\", checksumUrl, httpResponse.getStatusLine());\n            }\n            return null;\n        } catch (IOException e) {\n            LOGGER.warn(\"Checksum missing at {} due to: {}\", checksumUrl, e.getMessage());\n            return null;\n        } finally {\n            // TODO:DAZ Don't need this\n            get.abort();\n        }\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"public HttpResource getResource(final String source, ArtifactRevisionId artifactId) throws IOException {\n        LOGGER.debug(\"Constructing GET resource: {}\", source);\n\n        List<CachedArtifact> cachedArtifacts = new ArrayList<CachedArtifact>();\n        externalArtifactCache.addMatchingCachedArtifacts(artifactId, cachedArtifacts);\n\n        HttpResource resource = initGet(source, cachedArtifacts);\n        resources.put(source, resource);\n        return resource;\n    }","id":29717,"modified_method":"public HttpResource getResource(final String source, ArtifactRevisionId artifactId) throws IOException {\n        // TODO:DAZ Add failsafe resource cleanup.\n\n        LOGGER.debug(\"Constructing GET resource: {}\", source);\n\n        List<CachedArtifact> cachedArtifacts = new ArrayList<CachedArtifact>();\n        externalArtifactCache.addMatchingCachedArtifacts(artifactId, cachedArtifacts);\n\n        HttpResource resource = initGet(source, cachedArtifacts);\n        return resource;\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"public long getContentLength() {\n            return source.length();\n        }","id":29718,"modified_method":"private boolean wasSuccessful(HttpResponse response) {\n        int statusCode = response.getStatusLine().getStatusCode();\n        return statusCode >= 200 && statusCode < 300;\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"private void doPut(File source, String destination) throws IOException {\n        PutMethod method = new PutMethod(destination);\n        configureMethod(method);\n        method.setRequestEntity(new FileRequestEntity(source));\n        int result = executeMethod(method);\n        if (!wasSuccessful(result)) {\n            throw new IOException(String.format(\"Could not PUT '%s'. Received status code %s from server: %s\", destination, result, method.getStatusText()));\n        }\n    }","id":29719,"modified_method":"private void doPut(File source, String destination) throws IOException {\n        HttpPut method = new HttpPut(destination);\n        configureMethod(method);\n        method.setEntity(new FileEntity(source, \"application/octet-stream\"));\n        LOGGER.debug(\"Performing HTTP PUT: {}\", method.getURI());\n        HttpResponse response = client.execute(method);\n        if (!wasSuccessful(response)) {\n            throw new IOException(String.format(\"Could not PUT '%s'. Received status code %s from server: %s\",\n                                                destination, response.getStatusLine().getStatusCode(), response.getStatusLine().getReasonPhrase()));\n        }\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"private HttpResource initHead(String source) {\n        HeadMethod method = new HeadMethod(source);\n        configureMethod(method);\n        int result;\n        try {\n            result = executeMethod(method);\n        } catch (IOException e) {\n            throw new UncheckedIOException(String.format(\"Could not HEAD '%s'.\", source), e);\n        }\n        if (result == 404) {\n            LOGGER.info(\"Resource missing. [HTTP HEAD: {}]\", source);\n            return new MissingHttpResource(source);\n        }\n        if (!wasSuccessful(result)) {\n            LOGGER.info(\"Failed to get resource: {} ({}). [HTTP HEAD: {}]\", new Object[]{result, method.getStatusText(), source});\n            throw new UncheckedIOException(String.format(\"Could not HEAD '%s'. Received status code %s from server: %s\", source, result, method.getStatusText()));\n        }\n        LOGGER.info(\"Resource found. [HTTP HEAD: {}]\", source);\n        return new HttpGetResource(source, method);\n    }","id":29720,"modified_method":"private HttpResource initHead(String source) {\n        HttpHead request = new HttpHead(source);\n        return processHttpRequest(source, request);\n    }","commit_id":"71c9b220276b43c066ab21f2f99c6cc7a3a74594","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public long getLength()\n    {\n        GetMethod getMethod;\n        try {\n            getMethod =\n                this.repository.getRESTResource(this.repository.getExtensionFileUriBuider(), this.id.getId(),\n                    this.id.getVersion().getValue());\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to acess extension [\" + this + \"]\");\n        }\n\n        long size = getMethod.getResponseContentLength();\n\n        getMethod.abort();\n\n        return size;\n    }","id":29721,"modified_method":"@Override\n    public long getLength()\n    {\n        HttpResponse response;\n        try {\n            response =\n                this.repository.getRESTResource(this.repository.getExtensionFileUriBuider(), this.id.getId(), this.id\n                    .getVersion().getValue());\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to acess extension [\" + this + \"]\");\n        }\n\n        HttpEntity entity = response.getEntity();\n\n        long size = entity.getContentLength();\n\n        try {\n            EntityUtils.consume(entity);\n        } catch (Exception e) {\n            // Ignore\n        }\n\n        return size;\n    }","commit_id":"37c3e4abf38d36f8a2717365a584a538a5b3e6ef","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private HttpClient createClient()\n    {\n        HttpClient httpClient = new HttpClient();\n\n        return httpClient;\n    }","id":29722,"modified_method":"private HttpClient createClient()\n    {\n        HttpClient httpClient = new DefaultHttpClient();\n\n        return httpClient;\n    }","commit_id":"37c3e4abf38d36f8a2717365a584a538a5b3e6ef","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected GetMethod getRESTResource(UriBuilder builder, Object... values) throws IOException, IOException\n    {\n        String url;\n        try {\n            url = builder.build(values).toString();\n        } catch (Exception e) {\n            throw new IOException(\"Failed to build REST URL\", e);\n        }\n\n        HttpClient httpClient = createClient();\n\n        GetMethod getMethod = new GetMethod(url.toString());\n        getMethod.addRequestHeader(\"Accept\", MediaType.APPLICATION_XML.toString());\n        try {\n            httpClient.executeMethod(getMethod);\n        } catch (Exception e) {\n            throw new IOException(\"Failed to request [\" + getMethod.getURI() + \"]\", e);\n        }\n\n        if (getMethod.getStatusCode() != HttpStatus.SC_OK) {\n            throw new IOException(\"Invalid answer (\" + getMethod.getStatusCode() + \") fo the server when requesting\");\n        }\n\n        return getMethod;\n    }","id":29723,"modified_method":"protected HttpResponse getRESTResource(UriBuilder builder, Object... values) throws IOException, IOException\n    {\n        String url;\n        try {\n            url = builder.build(values).toString();\n        } catch (Exception e) {\n            throw new IOException(\"Failed to build REST URL\", e);\n        }\n\n        HttpClient httpClient = createClient();\n\n        HttpGet getMethod = new HttpGet(url.toString());\n        getMethod.addHeader(\"Accept\", MediaType.APPLICATION_XML.toString());\n        HttpResponse response;\n        try {\n            response = httpClient.execute(getMethod);\n        } catch (Exception e) {\n            throw new IOException(\"Failed to request [\" + getMethod.getURI() + \"]\", e);\n        }\n\n        if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {\n            throw new IOException(\"Invalid answer (\" + response.getStatusLine().getStatusCode()\n                + \") fo the server when requesting\");\n        }\n\n        return response;\n    }","commit_id":"37c3e4abf38d36f8a2717365a584a538a5b3e6ef","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected InputStream getRESTResourceAsStream(UriBuilder builder, Object... values) throws IOException, IOException\n    {\n        return getRESTResource(builder, values).getResponseBodyAsStream();\n    }","id":29724,"modified_method":"protected InputStream getRESTResourceAsStream(UriBuilder builder, Object... values) throws IOException, IOException\n    {\n        return getRESTResource(builder, values).getEntity().getContent();\n    }","commit_id":"37c3e4abf38d36f8a2717365a584a538a5b3e6ef","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public MavenExecutionResponse execute( MavenExecutionRequest request ) throws ReactorException\n    {\n        EventDispatcher dispatcher = request.getEventDispatcher();\n        String event = MavenEvents.REACTOR_EXECUTION;\n\n        // TODO: goals are outer loop\n        dispatcher.dispatchStart( event, request.getBaseDirectory() );\n        try\n        {\n            List projects;\n\n            try\n            {\n                projects = collectProjects( request.getFiles(), request.getLocalRepository(), request.isRecursive() );\n\n                projects = MavenProject.getSortedProjects( projects );\n\n                if ( projects.isEmpty() )\n                {\n                    projects.add( projectBuilder.buildStandaloneSuperProject( request.getLocalRepository() ) );\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new ReactorException( \"Error processing projects for the reactor: \", e );\n            }\n            catch ( ProjectBuildingException e )\n            {\n                throw new ReactorException( \"Error processing projects for the reactor: \", e );\n            }\n            catch ( CycleDetectedException e )\n            {\n                throw new ReactorException( \"Error processing projects for the reactor: \", e );\n            }\n\n            for ( Iterator iterator = projects.iterator(); iterator.hasNext(); )\n            {\n                MavenProject project = (MavenProject) iterator.next();\n\n                line();\n\n                getLogger().info( \"Building \" + project.getName() );\n\n                line();\n\n                try\n                {\n                    MavenExecutionResponse response = processProject( request, project, dispatcher, request.getGoals() );\n                    if ( response.isExecutionFailure() )\n                    {\n                        return response;\n                    }\n                }\n                catch ( Exception e )\n                {\n                    throw new ReactorException( \"Error executing project within the reactor\", e );\n                }\n            }\n\n            dispatcher.dispatchEnd( event, request.getBaseDirectory() );\n\n            // TODO: not really satisfactory\n            return null;\n        }\n        catch ( ReactorException e )\n        {\n            dispatcher.dispatchError( event, request.getBaseDirectory(), e );\n\n            throw e;\n        }\n    }","id":29725,"modified_method":"public MavenExecutionResponse execute( MavenExecutionRequest request ) throws ReactorException\n    {\n        if ( request.getGoals().isEmpty() )\n        {\n            throw new ReactorException( \"You must specify at least one goal. Try 'install'.\" );\n        }\n\n        EventDispatcher dispatcher = request.getEventDispatcher();\n        String event = MavenEvents.REACTOR_EXECUTION;\n\n        // TODO: goals are outer loop\n        dispatcher.dispatchStart( event, request.getBaseDirectory() );\n        try\n        {\n            List projects;\n\n            try\n            {\n                projects = collectProjects( request.getFiles(), request.getLocalRepository(), request.isRecursive() );\n\n                projects = MavenProject.getSortedProjects( projects );\n\n                if ( projects.isEmpty() )\n                {\n                    projects.add( projectBuilder.buildStandaloneSuperProject( request.getLocalRepository() ) );\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new ReactorException( \"Error processing projects for the reactor: \", e );\n            }\n            catch ( ProjectBuildingException e )\n            {\n                throw new ReactorException( \"Error processing projects for the reactor: \", e );\n            }\n            catch ( CycleDetectedException e )\n            {\n                throw new ReactorException( \"Error processing projects for the reactor: \", e );\n            }\n\n            for ( Iterator iterator = projects.iterator(); iterator.hasNext(); )\n            {\n                MavenProject project = (MavenProject) iterator.next();\n\n                line();\n\n                getLogger().info( \"Building \" + project.getName() );\n\n                line();\n\n                try\n                {\n                    MavenExecutionResponse response = processProject( request, project, dispatcher, request.getGoals() );\n                    if ( response.isExecutionFailure() )\n                    {\n                        return response;\n                    }\n                }\n                catch ( Exception e )\n                {\n                    throw new ReactorException( \"Error executing project within the reactor\", e );\n                }\n            }\n\n            dispatcher.dispatchEnd( event, request.getBaseDirectory() );\n\n            // TODO: not really satisfactory\n            return null;\n        }\n        catch ( ReactorException e )\n        {\n            dispatcher.dispatchError( event, request.getBaseDirectory(), e );\n\n            throw e;\n        }\n    }","commit_id":"f8ba3a48d1129c5da6cbd6e9b11dead587289e20","url":"https://github.com/apache/maven"},{"original_method":"private MavenProject build( File projectDescriptor, ArtifactRepository localRepository,\n                                boolean resolveDependencies, boolean sourceProject )\n        throws ProjectBuildingException\n    {\n        try\n        {\n            Model superModel = getSuperModel();\n            \n            LinkedList lineage = new LinkedList();\n\n            List aggregatedRemoteWagonRepositories = buildArtifactRepositories( superModel.getRepositories() );\n            MavenProject project = assembleLineage( projectDescriptor, localRepository, lineage,\n                                                    aggregatedRemoteWagonRepositories );\n\n            Model previous = superModel;\n\n            for ( Iterator i = lineage.iterator(); i.hasNext(); )\n            {\n                Model current = ( (MavenProject) i.next() ).getModel();\n\n                modelInheritanceAssembler.assembleModelInheritance( current, previous );\n\n                previous = current;\n            }\n            \n            project = processProjectLogic( project, localRepository, aggregatedRemoteWagonRepositories,\n                                           resolveDependencies, sourceProject );\n\n            return project;\n        }\n        catch ( Exception e )\n        {\n            throw new ProjectBuildingException( \"Error building project from \" + projectDescriptor, e );\n        }\n    }","id":29726,"modified_method":"private MavenProject build( Model model, ArtifactRepository localRepository, boolean resolveDependencies )\n        throws ProjectBuildingException\n    {\n        Model superModel = getSuperModel();\n\n        LinkedList lineage = new LinkedList();\n\n        List aggregatedRemoteWagonRepositories = buildArtifactRepositories( superModel.getRepositories() );\n\n        MavenProject project = assembleLineage( model, lineage, aggregatedRemoteWagonRepositories, localRepository );\n\n        Model previous = superModel;\n\n        for ( Iterator i = lineage.iterator(); i.hasNext(); )\n        {\n            Model current = ( (MavenProject) i.next() ).getModel();\n\n            modelInheritanceAssembler.assembleModelInheritance( current, previous );\n\n            previous = current;\n        }\n\n        try\n        {\n            project = processProjectLogic( project, localRepository, aggregatedRemoteWagonRepositories,\n                                           resolveDependencies );\n        }\n        catch ( ModelInterpolationException e )\n        {\n            throw new ProjectBuildingException( \"Error building project: \" + model.getId(), e );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ProjectBuildingException( \"Error building project: \" + model.getId(), e );\n        }\n\n        return project;\n    }","commit_id":"f8ba3a48d1129c5da6cbd6e9b11dead587289e20","url":"https://github.com/apache/maven"},{"original_method":"private File findParentModel( Parent parent, List remoteArtifactRepositories, ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        Artifact artifact = artifactFactory.createArtifact( parent.getGroupId(), parent.getArtifactId(),\n                                                            parent.getVersion(), null, \"pom\", null );\n\n        try\n        {\n            artifactResolver.resolve( artifact, remoteArtifactRepositories, localRepository );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            // @todo use parent.toString() if modello could generate it, or specify in a code segment\n            throw new ProjectBuildingException( \"Missing parent POM: \" + parent.getGroupId() + \":\" +\n                                                parent.getArtifactId() + \"-\" + parent.getVersion(), e );\n        }\n\n        return artifact.getFile();\n    }","id":29727,"modified_method":"private Model findModelFromRepository( Artifact artifact, List remoteArtifactRepositories,\n                                           ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        Model model = getCachedModel( artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion() );\n        if ( model == null )\n        {\n            try\n            {\n                artifactResolver.resolve( artifact, remoteArtifactRepositories, localRepository );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new ProjectBuildingException( \"Unable to find artifact: \" + artifact.toString() );\n            }\n            model = readModel( artifact.getFile() );\n        }\n        return model;\n    }","commit_id":"f8ba3a48d1129c5da6cbd6e9b11dead587289e20","url":"https://github.com/apache/maven"},{"original_method":"private Model readModel( File file )\n        throws ProjectBuildingException\n    {\n        FileReader reader = null;\n        try\n        {\n            reader = new FileReader( file );\n            return modelReader.read( reader );\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new ProjectBuildingException( \"Could not find the model file '\" + file.getAbsolutePath() + \"'.\" );\n        }\n        catch ( Exception e )\n        {\n            throw new ProjectBuildingException(\n                \"Error while reading model from file '\" + file.getAbsolutePath() + \"'.\", e );\n        }\n        finally\n        {\n            IOUtil.close( reader );\n        }\n    }","id":29728,"modified_method":"private Model readModel( File file )\n        throws ProjectBuildingException\n    {\n        FileReader reader = null;\n        try\n        {\n            reader = new FileReader( file );\n            Model model = modelReader.read( reader );\n            return model;\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new ProjectBuildingException( \"Could not find the model file '\" + file.getAbsolutePath() + \"'.\" );\n        }\n        catch ( Exception e )\n        {\n            throw new ProjectBuildingException(\n                \"Error while reading model from file '\" + file.getAbsolutePath() + \"'.\", e );\n        }\n        finally\n        {\n            IOUtil.close( reader );\n        }\n    }","commit_id":"f8ba3a48d1129c5da6cbd6e9b11dead587289e20","url":"https://github.com/apache/maven"},{"original_method":"public MavenProject buildStandaloneSuperProject( ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        Model superModel = getSuperModel();\n\n        superModel.setGroupId( STANDALONE_SUPERPOM_GROUPID );\n\n        superModel.setArtifactId( STANDALONE_SUPERPOM_ARTIFACTID );\n\n        superModel.setVersion( STANDALONE_SUPERPOM_VERSION );\n\n        MavenProject project = new MavenProject( superModel );\n\n        try\n        {\n            project.setFile( new File( \".\", \"pom.xml\" ) );\n\n            List remoteRepositories = buildArtifactRepositories( superModel.getRepositories() );\n\n            project = processProjectLogic( project, localRepository, remoteRepositories, false, false );\n\n            return project;\n        }\n        catch ( ModelInterpolationException e )\n        {\n            throw new ProjectBuildingException( \"Error building super-project\", e );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ProjectBuildingException( \"Error building super-project\", e );\n        }\n    }","id":29729,"modified_method":"public MavenProject buildStandaloneSuperProject( ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        Model superModel = getSuperModel();\n\n        superModel.setGroupId( STANDALONE_SUPERPOM_GROUPID );\n\n        superModel.setArtifactId( STANDALONE_SUPERPOM_ARTIFACTID );\n\n        superModel.setVersion( STANDALONE_SUPERPOM_VERSION );\n\n        MavenProject project = new MavenProject( superModel );\n\n        try\n        {\n            project.setFile( new File( \".\", \"pom.xml\" ) );\n\n            List remoteRepositories = buildArtifactRepositories( superModel.getRepositories() );\n\n            project = processProjectLogic( project, localRepository, remoteRepositories, false );\n\n            return project;\n        }\n        catch ( ModelInterpolationException e )\n        {\n            throw new ProjectBuildingException( \"Error building super-project\", e );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ProjectBuildingException( \"Error building super-project\", e );\n        }\n    }","commit_id":"f8ba3a48d1129c5da6cbd6e9b11dead587289e20","url":"https://github.com/apache/maven"},{"original_method":"private MavenProject processProjectLogic( MavenProject project, ArtifactRepository localRepository,\n                                              List remoteRepositories, boolean resolveDependencies,\n                                              boolean sourceProject )\n        throws ProjectBuildingException, ModelInterpolationException, ArtifactResolutionException\n    {\n        Model model = project.getModel();\n        \n        String cacheKey = createCacheKey( model.getGroupId(), model.getArtifactId(), model.getVersion() );\n        \n        // [jc] This needs to be moved below the interpolation and defaults\n        // injection steps, especially since the interpolator returns a different\n        // instance of the Model. HOWEVER, I cannot move this caching step to\n        // the appropriate place, since it results in inconsistent artifact \n        // naming between the jar:jar and install:install steps for some reason.\n        // \n        // So, instead I'm commenting out the part of the MavenMetadataSource\n        // that looks up the cached model, and leaving this caching step right\n        // here...at least until I have more time to look at why this cannot be\n        // moved down.\n        Model cachedModel = (Model) modelCache.get( cacheKey );\n        if ( cachedModel == null || sourceProject )\n        {\n            modelCache.put( cacheKey, model );\n        }\n\n        model = modelInterpolator.interpolate( model );\n\n        // interpolation is before injection, because interpolation is off-limits in the injected variables\n        modelDefaultsInjector.injectDefaults( model );\n\n        MavenProject parentProject = project.getParent();\n\n        File projectDescriptor = project.getFile();\n        if ( sourceProject )\n        {\n            pathTranslator.alignToBaseDirectory( model, projectDescriptor );\n        }\n\n        project = new MavenProject( model );\n\n        try\n        {\n            project.setPluginArtifactRepositories( buildPluginRepositories( model.getPluginRepositories() ) );\n        }\n        catch ( Exception e )\n        {\n            throw new ProjectBuildingException( \"Error building plugin repository list.\", e );\n        }\n\n        DistributionManagement dm = model.getDistributionManagement();\n        if ( dm != null )\n        {\n            try\n            {\n                project.setDistributionManagementArtifactRepository( buildDistributionManagementRepository(\n                    dm.getRepository() ) );\n            }\n            catch ( Exception e )\n            {\n                throw new ProjectBuildingException( \"Error building distribution management repository.\", e );\n            }\n        }\n\n        project.setFile( projectDescriptor );\n        project.setParent( parentProject );\n        project.setRemoteArtifactRepositories( remoteRepositories );\n        project.setArtifacts( artifactFactory.createArtifacts( project.getDependencies(), localRepository, null ) );\n\n        // ----------------------------------------------------------------------\n        // Typically when the project builder is being used from maven proper\n        // the transitive dependencies will not be resolved here because this\n        // requires a lot of work when we may only be interested in running\n        // something simple like 'm2 clean'. So the artifact collector is used\n        // in the dependency resolution phase if it is required by any of the\n        // goals being executed. But when used as a component in another piece\n        // of code people may just want to build maven projects and have the\n        // dependencies resolved for whatever reason: this is why we keep\n        // this snippet of code here.\n        // ----------------------------------------------------------------------\n\n        if ( resolveDependencies )\n        {\n            MavenMetadataSource sourceReader = new MavenMetadataSource( artifactResolver, this );\n\n            ArtifactResolutionResult result = artifactResolver.resolveTransitively( project.getArtifacts(),\n                                                                                    remoteRepositories,\n                                                                                    localRepository, sourceReader );\n\n            project.addArtifacts( result.getArtifacts().values() );\n        }\n\n        ModelValidationResult validationResult = validator.validate( model );\n\n        if ( validationResult.getMessageCount() > 0 )\n        {\n            throw new ProjectBuildingException( \"Exception while building project: \" + validationResult.toString() );\n        }\n\n        project.addCompileSourceRoot( project.getBuild().getSourceDirectory() );\n        project.addScriptSourceRoot( project.getBuild().getScriptSourceDirectory() );\n        project.addTestCompileSourceRoot( project.getBuild().getTestSourceDirectory() );\n\n        return project;\n    }","id":29730,"modified_method":"/**\n     * @todo can this take in a model instead of a project and still be successful?\n     * @todo In fact, does project REALLY need a MavenProject as a parent? Couldn't it have just a wrapper around a\n     * model that supported parents which were also the wrapper so that inheritence was assembled. We don't really need\n     * the resolved source roots, etc for the parent - that occurs for the parent when it is constructed independently\n     * and projects are not cached or reused\n     */\n    private MavenProject processProjectLogic( MavenProject project, ArtifactRepository localRepository,\n                                              List remoteRepositories, boolean resolveDependencies )\n        throws ProjectBuildingException, ModelInterpolationException, ArtifactResolutionException\n    {\n        Model model = project.getModel();\n        String key = createCacheKey( model.getGroupId(), model.getArtifactId(), model.getVersion() );\n        Model cachedModel = (Model) modelCache.get( key );\n        if ( cachedModel == null )\n        {\n            modelCache.put( cacheKey, model );\n        }\n\n        model = modelInterpolator.interpolate( model );\n\n        // interpolation is before injection, because interpolation is off-limits in the injected variables\n        modelDefaultsInjector.injectDefaults( model );\n\n        MavenProject parentProject = project.getParent();\n\n        project = new MavenProject( model );\n\n        try\n        {\n            project.setPluginArtifactRepositories( buildPluginRepositories( model.getPluginRepositories() ) );\n        }\n        catch ( Exception e )\n        {\n            throw new ProjectBuildingException( \"Error building plugin repository list.\", e );\n        }\n\n        DistributionManagement dm = model.getDistributionManagement();\n        if ( dm != null )\n        {\n            try\n            {\n                project.setDistributionManagementArtifactRepository( buildDistributionManagementRepository(\n                    dm.getRepository() ) );\n            }\n            catch ( Exception e )\n            {\n                throw new ProjectBuildingException( \"Error building distribution management repository.\", e );\n            }\n        }\n\n        project.setParent( parentProject );\n        project.setRemoteArtifactRepositories( remoteRepositories );\n        project.setArtifacts( artifactFactory.createArtifacts( project.getDependencies(), localRepository, null ) );\n\n        // ----------------------------------------------------------------------\n        // Typically when the project builder is being used from maven proper\n        // the transitive dependencies will not be resolved here because this\n        // requires a lot of work when we may only be interested in running\n        // something simple like 'm2 clean'. So the artifact collector is used\n        // in the dependency resolution phase if it is required by any of the\n        // goals being executed. But when used as a component in another piece\n        // of code people may just want to build maven projects and have the\n        // dependencies resolved for whatever reason: this is why we keep\n        // this snippet of code here.\n        // ----------------------------------------------------------------------\n\n        if ( resolveDependencies )\n        {\n            MavenMetadataSource sourceReader = new MavenMetadataSource( artifactResolver, this );\n\n            ArtifactResolutionResult result = artifactResolver.resolveTransitively( project.getArtifacts(),\n                                                                                    remoteRepositories,\n                                                                                    localRepository, sourceReader );\n\n            project.addArtifacts( result.getArtifacts().values() );\n        }\n\n        ModelValidationResult validationResult = validator.validate( model );\n\n        if ( validationResult.getMessageCount() > 0 )\n        {\n            throw new ProjectBuildingException( \"Exception while building project: \" + validationResult.toString() );\n        }\n\n        return project;\n    }","commit_id":"f8ba3a48d1129c5da6cbd6e9b11dead587289e20","url":"https://github.com/apache/maven"},{"original_method":"private MavenProject assembleLineage( Model model, ArtifactRepository localRepository, LinkedList lineage,\n                                          List aggregatedRemoteWagonRepositories )\n        throws ProjectBuildingException\n    {\n        aggregatedRemoteWagonRepositories.addAll( buildArtifactRepositories( model.getRepositories() ) );\n\n        MavenProject project = new MavenProject( model );\n\n        lineage.addFirst( project );\n\n        Parent parentModel = model.getParent();\n\n        if ( parentModel != null )\n        {\n            if ( StringUtils.isEmpty( parentModel.getGroupId() ) )\n            {\n                throw new ProjectBuildingException( \"Missing groupId element from parent element\" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getArtifactId() ) )\n            {\n                throw new ProjectBuildingException( \"Missing artifactId element from parent element\" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getVersion() ) )\n            {\n                throw new ProjectBuildingException( \"Missing version element from parent element\" );\n            }\n\n            //!! (**)\n            // ----------------------------------------------------------------------\n            // Do we have the necessary information to actually find the parent\n            // POMs here?? I don't think so ... Say only one remote repository is\n            // specified and that is ibiblio then this model that we just read doesn't\n            // have any repository information ... I think we might have to inherit\n            // as we go in order to do this.\n            // ----------------------------------------------------------------------\n\n            MavenProject parent;\n            Model cachedModel = getCachedModel( parentModel.getGroupId(), parentModel.getArtifactId(),\n                                                parentModel.getVersion() );\n            if ( cachedModel == null )\n            {\n                File parentPom = findParentModel( parentModel, aggregatedRemoteWagonRepositories, localRepository );\n\n                parent = assembleLineage( parentPom, localRepository, lineage, aggregatedRemoteWagonRepositories );\n            }\n            else\n            {\n                parent = assembleLineage( cachedModel, localRepository, lineage, aggregatedRemoteWagonRepositories );\n            }\n            project.setParent( parent );\n        }\n\n        return project;\n    }","id":29731,"modified_method":"private MavenProject assembleLineage( Model model, LinkedList lineage, List aggregatedRemoteWagonRepositories,\n                                          ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        aggregatedRemoteWagonRepositories.addAll( buildArtifactRepositories( model.getRepositories() ) );\n\n        MavenProject project = new MavenProject( model );\n\n        lineage.addFirst( project );\n\n        Parent parentModel = model.getParent();\n\n        if ( parentModel != null )\n        {\n            if ( StringUtils.isEmpty( parentModel.getGroupId() ) )\n            {\n                throw new ProjectBuildingException( \"Missing groupId element from parent element\" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getArtifactId() ) )\n            {\n                throw new ProjectBuildingException( \"Missing artifactId element from parent element\" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getVersion() ) )\n            {\n                throw new ProjectBuildingException( \"Missing version element from parent element\" );\n            }\n\n            //!! (**)\n            // ----------------------------------------------------------------------\n            // Do we have the necessary information to actually find the parent\n            // POMs here?? I don't think so ... Say only one remote repository is\n            // specified and that is ibiblio then this model that we just read doesn't\n            // have any repository information ... I think we might have to inherit\n            // as we go in order to do this.\n            // ----------------------------------------------------------------------\n\n            Artifact artifact = artifactFactory.createArtifact( parentModel.getGroupId(), parentModel.getArtifactId(),\n                                                                parentModel.getVersion(), null, \"pom\", null );\n\n            model = findModelFromRepository( artifact, aggregatedRemoteWagonRepositories, localRepository );\n\n            MavenProject parent = assembleLineage( model, lineage, aggregatedRemoteWagonRepositories, localRepository );\n\n            project.setParent( parent );\n        }\n\n        return project;\n    }","commit_id":"f8ba3a48d1129c5da6cbd6e9b11dead587289e20","url":"https://github.com/apache/maven"},{"original_method":"public MavenProject buildFromRepository( Artifact artifact, ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        return build( artifact.getFile(), localRepository, false, false );\n    }","id":29732,"modified_method":"public MavenProject buildFromRepository( Artifact artifact, List remoteArtifactRepositories,\n                                             ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        Model model = findModelFromRepository( artifact, remoteArtifactRepositories, localRepository );\n\n        return build( model, localRepository, false );\n    }","commit_id":"f8ba3a48d1129c5da6cbd6e9b11dead587289e20","url":"https://github.com/apache/maven"},{"original_method":"public MavenProject build( File project, ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        return build( project, localRepository, false, true );\n    }","id":29733,"modified_method":"public MavenProject build( File projectDescriptor, ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        return buildFromSourceFile( projectDescriptor, localRepository, false );\n    }","commit_id":"f8ba3a48d1129c5da6cbd6e9b11dead587289e20","url":"https://github.com/apache/maven"},{"original_method":"public MavenProject buildWithDependencies( File project, ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        return build( project, localRepository, true, true );\n    }","id":29734,"modified_method":"public MavenProject buildWithDependencies( File projectDescriptor, ArtifactRepository localRepository )\n        throws ProjectBuildingException\n    {\n        return buildFromSourceFile( projectDescriptor, localRepository, true );\n    }","commit_id":"f8ba3a48d1129c5da6cbd6e9b11dead587289e20","url":"https://github.com/apache/maven"},{"original_method":"public Model getCachedModel( String groupId, String artifactId, String version )\n    {\n        return (Model) modelCache.get( createCacheKey( groupId, artifactId, version ) );\n    }","id":29735,"modified_method":"private Model getCachedModel( String groupId, String artifactId, String version )\n    {\n        return (Model) modelCache.get( createCacheKey( groupId, artifactId, version ) );\n    }","commit_id":"f8ba3a48d1129c5da6cbd6e9b11dead587289e20","url":"https://github.com/apache/maven"},{"original_method":"public Set retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n        throws ArtifactMetadataRetrievalException\n    {\n        List dependencies = null;\n\n        // [jc] Commenting this out, because the place where the model is \n        // cached in the project builder has not accounted for interpolation or\n        // defaults injection. This wouldn't be a problem, except that the \n        // interpolation step actually returns a different instance of the \n        // model than was input, thus rendering the old version of the model\n        // stale. To test this, you have to create an artifact whose pom uses\n        // managed dependencies, then depend on that artifact from another\n        // project. The first plugin to refer to this dependency will work fine, \n        // but subsequent plugins referring to the dep will retrieved a cached\n        // copy of the model that has no versions, etc. defined because that\n        // model instance has not had defaults injected or interpolations \n        // resolved. See note in DefaultMavenProjectBuilder, line 170 for \n        // further discussion.\n        \n        if ( mavenProjectBuilder != null )\n        {\n            Model model = mavenProjectBuilder.getCachedModel( artifact.getGroupId(), artifact.getArtifactId(),\n                                                              artifact.getVersion() );\n            if ( model != null )\n            {\n                dependencies = model.getDependencies();\n            }\n        }\n\n        if ( dependencies == null )\n        {\n            Artifact metadataArtifact = artifactFactory.createArtifact( artifact.getGroupId(),\n                                                                        artifact.getArtifactId(),\n                                                                        artifact.getBaseVersion(), artifact.getScope(),\n                                                                        \"pom\", null );\n\n            try\n            {\n                artifactResolver.resolve( metadataArtifact, remoteRepositories, localRepository );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new ArtifactMetadataRetrievalException( \"Error while resolving metadata artifact\", e );\n            }\n\n            // [jdcasey/03-Feb-2005]: Replacing with ProjectBuilder, to enable\n            // post-processing and inheritance calculation before retrieving the\n            // associated artifacts. This should improve consistency.\n            if ( mavenProjectBuilder != null )\n            {\n                try\n                {\n                    MavenProject p = mavenProjectBuilder.buildFromRepository( metadataArtifact, localRepository );\n                    dependencies = p.getDependencies();\n                }\n                catch ( ProjectBuildingException e )\n                {\n                    throw new ArtifactMetadataRetrievalException( \"Unable to read the metadata file\", e );\n                }\n            }\n            else\n            {\n                FileReader reader = null;\n                try\n                {\n                    reader = new FileReader( metadataArtifact.getFile() );\n                    Model model = this.reader.read( reader );\n                    dependencies = model.getDependencies();\n                }\n                catch ( Exception e )\n                {\n                    throw new ArtifactMetadataRetrievalException( \"Unable to read the metadata file\", e );\n                }\n                finally\n                {\n                    IoUtils.close( reader );\n                }\n            }\n        }\n        return artifactFactory.createArtifacts( dependencies, localRepository, artifact.getScope() );\n    }","id":29736,"modified_method":"public Set retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n        throws ArtifactMetadataRetrievalException\n    {\n        Artifact metadataArtifact = artifactFactory.createArtifact( artifact.getGroupId(), artifact.getArtifactId(),\n                                                                    artifact.getBaseVersion(), artifact.getScope(),\n                                                                    \"pom\", null );\n\n        List dependencies = null;\n\n        // Use the ProjectBuilder, to enable post-processing and inheritance calculation before retrieving the\n        // associated artifacts.\n        if ( mavenProjectBuilder != null )\n        {\n            try\n            {\n                MavenProject p = mavenProjectBuilder.buildFromRepository( metadataArtifact, remoteRepositories,\n                                                                          localRepository );\n                dependencies = p.getDependencies();\n            }\n            catch ( ProjectBuildingException e )\n            {\n                throw new ArtifactMetadataRetrievalException( \"Unable to read the metadata file\", e );\n            }\n        }\n        else\n        {\n            // there is code in plexus that uses this (though it shouldn't) so we\n            // need to be able to not have a project builder\n            // TODO: remove - which then makes this a very thin wrapper around a project builder - is it needed?\n\n            try\n            {\n                artifactResolver.resolve( metadataArtifact, remoteRepositories, localRepository );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new ArtifactMetadataRetrievalException( \"Error while resolving metadata artifact\", e );\n            }\n\n            FileReader reader = null;\n            try\n            {\n                reader = new FileReader( metadataArtifact.getFile() );\n                Model model = this.reader.read( reader );\n                dependencies = model.getDependencies();\n            }\n            catch ( Exception e )\n            {\n                throw new ArtifactMetadataRetrievalException( \"Unable to read the metadata file\", e );\n            }\n            finally\n            {\n                IoUtils.close( reader );\n            }\n        }\n        return artifactFactory.createArtifacts( dependencies, localRepository, artifact.getScope() );\n    }","commit_id":"f8ba3a48d1129c5da6cbd6e9b11dead587289e20","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * @noinspection CollectionDeclaredAsConcreteClass\n     */\n    private MavenProject assembleLineage( Model model,\n                                          LinkedList lineage,\n                                          ArtifactRepository localRepository,\n                                          File projectDir,\n                                          List parentSearchRepositories,\n                                          Set aggregatedRemoteWagonRepositories,\n                                          ProfileManager externalProfileManager,\n                                          boolean strict )\n        throws ProjectBuildingException, InvalidRepositoryException\n    {\n        if ( !model.getRepositories().isEmpty() )\n        {\n            List respositories = buildArtifactRepositories( model );\n\n            for ( Iterator it = respositories.iterator(); it.hasNext(); )\n            {\n                ArtifactRepository repository = (ArtifactRepository) it.next();\n\n                if ( !aggregatedRemoteWagonRepositories.contains( repository ) )\n                {\n                    aggregatedRemoteWagonRepositories.add( repository );\n                }\n            }\n        }\n\n        ProfileManager profileManager = new DefaultProfileManager( container );\n\n        if ( externalProfileManager != null )\n        {\n            profileManager.explicitlyActivate( externalProfileManager.getExplicitlyActivatedIds() );\n\n            profileManager.explicitlyDeactivate( externalProfileManager.getExplicitlyDeactivatedIds() );\n        }\n\n        List activeProfiles;\n\n        try\n        {\n            profileManager.addProfiles( model.getProfiles() );\n\n            loadProjectExternalProfiles( profileManager, projectDir );\n\n            activeProfiles = injectActiveProfiles( profileManager, model );\n        }\n        catch ( ProfileActivationException e )\n        {\n            String projectId = safeVersionlessKey( model.getGroupId(), model.getArtifactId() );\n\n            throw new ProjectBuildingException( projectId, \"Failed to activate local (project-level) build profiles: \" + e.getMessage(), e );\n        }\n\n        MavenProject project = new MavenProject( model );\n\n        project.setActiveProfiles( activeProfiles );\n\n        lineage.addFirst( project );\n\n        Parent parentModel = model.getParent();\n\n        if ( parentModel != null )\n        {\n            String projectId = safeVersionlessKey( model.getGroupId(), model.getArtifactId() );\n\n            if ( StringUtils.isEmpty( parentModel.getGroupId() ) )\n            {\n                throw new ProjectBuildingException( projectId, \"Missing groupId element from parent element\" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getArtifactId() ) )\n            {\n                throw new ProjectBuildingException( projectId, \"Missing artifactId element from parent element\" );\n            }\n            else if ( parentModel.getGroupId().equals( model.getGroupId() ) &&\n                parentModel.getArtifactId().equals( model.getArtifactId() ) )\n            {\n                throw new ProjectBuildingException( projectId, \"Parent element is a duplicate of \" + \"the current project \" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getVersion() ) )\n            {\n                throw new ProjectBuildingException( projectId, \"Missing version element from parent element\" );\n            }\n\n            String parentKey = createCacheKey( parentModel.getGroupId(), parentModel.getArtifactId(), parentModel.getVersion() );\n            MavenProject parentProject = (MavenProject)projectCache.get( parentKey );\n\n            // the only way this will have a value is if we find the parent on disk...\n            File parentDescriptor = null;\n\n            if ( parentProject != null )\n            {\n                model = parentProject.getOriginalModel();\n\n                parentDescriptor = parentProject.getFile();\n            }\n            else\n            {\n                model = null;\n            }\n\n            String parentRelativePath = parentModel.getRelativePath();\n\n            // if we can't find a cached model matching the parent spec, then let's try to look on disk using\n            // <relativePath/>\n            if ( model == null && projectDir != null && StringUtils.isNotEmpty( parentRelativePath ) )\n            {\n                parentDescriptor = new File( projectDir, parentRelativePath );\n\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Searching for parent-POM: \" + parentModel.getId() + \" of project: \" + project.getId() + \" in relative path: \" + parentRelativePath );\n                }\n\n                if ( parentDescriptor.isDirectory() )\n                {\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"Path specified in <relativePath/> (\" + parentRelativePath +\n                            \") is a directory. Searching for 'pom.xml' within this directory.\" );\n                    }\n\n                    parentDescriptor = new File( parentDescriptor, \"pom.xml\" );\n\n                    if ( !parentDescriptor.exists() )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Parent-POM: \" + parentModel.getId() + \" for project: \" + project.getId() + \" cannot be loaded from relative path: \" + parentDescriptor + \"; path does not exist.\" );\n                        }\n\n                        parentDescriptor = null;\n                    }\n                }\n\n                try\n                {\n                    parentDescriptor = parentDescriptor.getCanonicalFile();\n                }\n                catch ( IOException e )\n                {\n                    getLogger().debug( \"Failed to canonicalize potential parent POM: \\'\" + parentDescriptor + \"\\'\", e );\n\n                    parentDescriptor = null;\n                }\n\n                if ( parentDescriptor != null && parentDescriptor.exists() )\n                {\n                    Model candidateParent = readModel( projectId, parentDescriptor, strict );\n\n                    String candidateParentGroupId = candidateParent.getGroupId();\n                    if ( candidateParentGroupId == null && candidateParent.getParent() != null )\n                    {\n                        candidateParentGroupId = candidateParent.getParent().getGroupId();\n                    }\n\n                    String candidateParentVersion = candidateParent.getVersion();\n                    if ( candidateParentVersion == null && candidateParent.getParent() != null )\n                    {\n                        candidateParentVersion = candidateParent.getParent().getVersion();\n                    }\n\n                    if ( parentModel.getGroupId().equals( candidateParentGroupId ) &&\n                        parentModel.getArtifactId().equals( candidateParent.getArtifactId() ) &&\n                        parentModel.getVersion().equals( candidateParentVersion ) )\n                    {\n                        model = candidateParent;\n\n                        getLogger().debug( \"Using parent-POM from the project hierarchy at: \\'\" +\n                            parentModel.getRelativePath() + \"\\' for project: \" + project.getId() );\n                    }\n                    else\n                    {\n                        getLogger().debug( \"Invalid parent-POM referenced by relative path '\" +\n                            parentModel.getRelativePath() + \"' in parent specification in \" + project.getId() + \":\" +\n                            \"\\n  Specified: \" + parentModel.getId() + \"\\n  Found:     \" + candidateParent.getId() );\n                    }\n                }\n                else if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Parent-POM: \" + parentModel.getId() + \" not found in relative path: \" + parentRelativePath );\n                }\n            }\n\n            Artifact parentArtifact = null;\n\n            // only resolve the parent model from the repository system if we didn't find it on disk...\n            if ( model == null )\n            {\n                //!! (**)\n                // ----------------------------------------------------------------------\n                // Do we have the necessary information to actually find the parent\n                // POMs here?? I don't think so ... Say only one remote repository is\n                // specified and that is ibiblio then this model that we just read doesn't\n                // have any repository information ... I think we might have to inherit\n                // as we go in order to do this.\n                // ----------------------------------------------------------------------\n\n                // we must add the repository this POM was found in too, by chance it may be located where the parent is\n                // we can't query the parent to ask where it is :)\n                List remoteRepositories = new ArrayList( aggregatedRemoteWagonRepositories );\n                remoteRepositories.addAll( parentSearchRepositories );\n\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug(\n                                       \"Retrieving parent-POM: \" + parentModel.getId() + \" for project: \"\n                                           + project.getId() + \" from the repository.\" );\n                }\n\n                parentArtifact = artifactFactory.createParentArtifact( parentModel.getGroupId(),\n                                                                       parentModel.getArtifactId(),\n                                                                       parentModel.getVersion() );\n\n                try\n                {\n                    model = findModelFromRepository( parentArtifact, remoteRepositories, localRepository, false );\n                }\n                catch( ProjectBuildingException e )\n                {\n                    throw new ProjectBuildingException( project.getId(), \"Cannot find parent: \" + e.getProjectId() + \" for project: \" + project.getId(), e );\n                }\n            }\n\n            if ( model != null && !\"pom\".equals( model.getPackaging() ) )\n            {\n                throw new ProjectBuildingException( projectId, \"Parent: \" + model.getId() + \" of project: \" +\n                    projectId + \" has wrong packaging: \" + model.getPackaging() + \". Must be 'pom'.\" );\n            }\n\n            File parentProjectDir = null;\n            if ( parentDescriptor != null )\n            {\n                parentProjectDir = parentDescriptor.getParentFile();\n            }\n\n            parentProject = assembleLineage( model, lineage, localRepository, parentProjectDir,\n                                                   parentSearchRepositories, aggregatedRemoteWagonRepositories,\n                                                   externalProfileManager, strict );\n            parentProject.setFile( parentDescriptor );\n\n            project.setParent( parentProject );\n\n            project.setParentArtifact( parentArtifact );\n\n        }\n\n        return project;\n    }","id":29737,"modified_method":"/**\n     * @noinspection CollectionDeclaredAsConcreteClass\n     */\n    private MavenProject assembleLineage( Model model,\n                                          LinkedList lineage,\n                                          ArtifactRepository localRepository,\n                                          File projectDir,\n                                          List parentSearchRepositories,\n                                          Set aggregatedRemoteWagonRepositories,\n                                          ProfileManager externalProfileManager,\n                                          boolean strict )\n        throws ProjectBuildingException, InvalidRepositoryException\n    {\n        if ( !model.getRepositories().isEmpty() )\n        {\n            List respositories = buildArtifactRepositories( model );\n\n            for ( Iterator it = respositories.iterator(); it.hasNext(); )\n            {\n                ArtifactRepository repository = (ArtifactRepository) it.next();\n\n                if ( !aggregatedRemoteWagonRepositories.contains( repository ) )\n                {\n                    aggregatedRemoteWagonRepositories.add( repository );\n                }\n            }\n        }\n\n        ProfileManager profileManager = new DefaultProfileManager( container );\n\n        if ( externalProfileManager != null )\n        {\n            profileManager.explicitlyActivate( externalProfileManager.getExplicitlyActivatedIds() );\n\n            profileManager.explicitlyDeactivate( externalProfileManager.getExplicitlyDeactivatedIds() );\n        }\n\n        List activeProfiles;\n\n        try\n        {\n            profileManager.addProfiles( model.getProfiles() );\n\n            loadProjectExternalProfiles( profileManager, projectDir );\n\n            activeProfiles = injectActiveProfiles( profileManager, model );\n        }\n        catch ( ProfileActivationException e )\n        {\n            String projectId = safeVersionlessKey( model.getGroupId(), model.getArtifactId() );\n\n            throw new ProjectBuildingException( projectId, \"Failed to activate local (project-level) build profiles: \" + e.getMessage(), e );\n        }\n\n        MavenProject project = new MavenProject( model );\n\n        project.setActiveProfiles( activeProfiles );\n\n        lineage.addFirst( project );\n\n        Parent parentModel = model.getParent();\n\n        if ( parentModel != null )\n        {\n            String projectId = safeVersionlessKey( model.getGroupId(), model.getArtifactId() );\n\n            if ( StringUtils.isEmpty( parentModel.getGroupId() ) )\n            {\n                throw new ProjectBuildingException( projectId, \"Missing groupId element from parent element\" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getArtifactId() ) )\n            {\n                throw new ProjectBuildingException( projectId, \"Missing artifactId element from parent element\" );\n            }\n            else if ( parentModel.getGroupId().equals( model.getGroupId() ) &&\n                parentModel.getArtifactId().equals( model.getArtifactId() ) )\n            {\n                throw new ProjectBuildingException( projectId, \"Parent element is a duplicate of \" + \"the current project \" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getVersion() ) )\n            {\n                throw new ProjectBuildingException( projectId, \"Missing version element from parent element\" );\n            }\n\n            // the only way this will have a value is if we find the parent on disk...\n            File parentDescriptor = null;\n\n            model = null;\n\n            String parentRelativePath = parentModel.getRelativePath();\n\n            // if we can't find a cached model matching the parent spec, then let's try to look on disk using\n            // <relativePath/>\n            if ( model == null && projectDir != null && StringUtils.isNotEmpty( parentRelativePath ) )\n            {\n                parentDescriptor = new File( projectDir, parentRelativePath );\n\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Searching for parent-POM: \" + parentModel.getId() + \" of project: \" + project.getId() + \" in relative path: \" + parentRelativePath );\n                }\n\n                if ( parentDescriptor.isDirectory() )\n                {\n                    if ( getLogger().isDebugEnabled() )\n                    {\n                        getLogger().debug( \"Path specified in <relativePath/> (\" + parentRelativePath +\n                            \") is a directory. Searching for 'pom.xml' within this directory.\" );\n                    }\n\n                    parentDescriptor = new File( parentDescriptor, \"pom.xml\" );\n\n                    if ( !parentDescriptor.exists() )\n                    {\n                        if ( getLogger().isDebugEnabled() )\n                        {\n                            getLogger().debug( \"Parent-POM: \" + parentModel.getId() + \" for project: \" + project.getId() + \" cannot be loaded from relative path: \" + parentDescriptor + \"; path does not exist.\" );\n                        }\n\n                        parentDescriptor = null;\n                    }\n                }\n\n                try\n                {\n                    parentDescriptor = parentDescriptor.getCanonicalFile();\n                }\n                catch ( IOException e )\n                {\n                    getLogger().debug( \"Failed to canonicalize potential parent POM: \\'\" + parentDescriptor + \"\\'\", e );\n\n                    parentDescriptor = null;\n                }\n\n                if ( parentDescriptor != null && parentDescriptor.exists() )\n                {\n                    Model candidateParent = readModel( projectId, parentDescriptor, strict );\n\n                    String candidateParentGroupId = candidateParent.getGroupId();\n                    if ( candidateParentGroupId == null && candidateParent.getParent() != null )\n                    {\n                        candidateParentGroupId = candidateParent.getParent().getGroupId();\n                    }\n\n                    String candidateParentVersion = candidateParent.getVersion();\n                    if ( candidateParentVersion == null && candidateParent.getParent() != null )\n                    {\n                        candidateParentVersion = candidateParent.getParent().getVersion();\n                    }\n\n                    if ( parentModel.getGroupId().equals( candidateParentGroupId ) &&\n                        parentModel.getArtifactId().equals( candidateParent.getArtifactId() ) &&\n                        parentModel.getVersion().equals( candidateParentVersion ) )\n                    {\n                        model = candidateParent;\n\n                        getLogger().debug( \"Using parent-POM from the project hierarchy at: \\'\" +\n                            parentModel.getRelativePath() + \"\\' for project: \" + project.getId() );\n                    }\n                    else\n                    {\n                        getLogger().debug( \"Invalid parent-POM referenced by relative path '\" +\n                            parentModel.getRelativePath() + \"' in parent specification in \" + project.getId() + \":\" +\n                            \"\\n  Specified: \" + parentModel.getId() + \"\\n  Found:     \" + candidateParent.getId() );\n                    }\n                }\n                else if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug( \"Parent-POM: \" + parentModel.getId() + \" not found in relative path: \" + parentRelativePath );\n                }\n            }\n\n            Artifact parentArtifact = null;\n\n            // only resolve the parent model from the repository system if we didn't find it on disk...\n            if ( model == null )\n            {\n                //!! (**)\n                // ----------------------------------------------------------------------\n                // Do we have the necessary information to actually find the parent\n                // POMs here?? I don't think so ... Say only one remote repository is\n                // specified and that is ibiblio then this model that we just read doesn't\n                // have any repository information ... I think we might have to inherit\n                // as we go in order to do this.\n                // ----------------------------------------------------------------------\n\n                // we must add the repository this POM was found in too, by chance it may be located where the parent is\n                // we can't query the parent to ask where it is :)\n                List remoteRepositories = new ArrayList( aggregatedRemoteWagonRepositories );\n                remoteRepositories.addAll( parentSearchRepositories );\n\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug(\n                                       \"Retrieving parent-POM: \" + parentModel.getId() + \" for project: \"\n                                           + project.getId() + \" from the repository.\" );\n                }\n\n                parentArtifact = artifactFactory.createParentArtifact( parentModel.getGroupId(),\n                                                                       parentModel.getArtifactId(),\n                                                                       parentModel.getVersion() );\n\n                try\n                {\n                    model = findModelFromRepository( parentArtifact, remoteRepositories, localRepository, false );\n                }\n                catch( ProjectBuildingException e )\n                {\n                    throw new ProjectBuildingException( project.getId(), \"Cannot find parent: \" + e.getProjectId() + \" for project: \" + project.getId(), e );\n                }\n            }\n\n            if ( model != null && !\"pom\".equals( model.getPackaging() ) )\n            {\n                throw new ProjectBuildingException( projectId, \"Parent: \" + model.getId() + \" of project: \" +\n                    projectId + \" has wrong packaging: \" + model.getPackaging() + \". Must be 'pom'.\" );\n            }\n\n            File parentProjectDir = null;\n            if ( parentDescriptor != null )\n            {\n                parentProjectDir = parentDescriptor.getParentFile();\n            }\n            MavenProject parent = assembleLineage( model, lineage, localRepository, parentProjectDir,\n                                                   parentSearchRepositories, aggregatedRemoteWagonRepositories,\n                                                   externalProfileManager, strict );\n            parent.setFile( parentDescriptor );\n\n            project.setParent( parent );\n\n            project.setParentArtifact( parentArtifact );\n        }\n\n        return project;\n    }","commit_id":"1c23ee16a4d80186a6d4ec77eb6ea3d2d8e09231","url":"https://github.com/apache/maven"},{"original_method":"public MavenProject getCachedProject( String groupId, String artifactId, String version )\n    {\n        return (MavenProject) projectCache.get( createCacheKey( groupId, artifactId, version ) );\n    }","id":29738,"modified_method":"public Model getCachedModel( String groupId, String artifactId, String version )\n    {\n        return (Model) modelCache.get( createCacheKey( groupId, artifactId, version ) );\n    }","commit_id":"fea9f2ac5363953d7b654d956df293b33093c6ef","url":"https://github.com/apache/maven"},{"original_method":"private MavenProject assembleLineage( File projectDescriptor, ArtifactRepository localRepository,\n                                          LinkedList lineage, List aggregatedRemoteWagonRepositories )\n        throws ProjectBuildingException\n    {\n        Model model = readModel( projectDescriptor );\n\n        MavenProject project = new MavenProject( model );\n\n        lineage.addFirst( project );\n\n        project.setFile( projectDescriptor );\n\n        Parent parentModel = model.getParent();\n\n        if ( parentModel != null )\n        {\n            if ( StringUtils.isEmpty( parentModel.getGroupId() ) )\n            {\n                throw new ProjectBuildingException( \"Missing groupId element from parent element\" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getArtifactId() ) )\n            {\n                throw new ProjectBuildingException( \"Missing artifactId element from parent element\" );\n            }\n            else if ( StringUtils.isEmpty( parentModel.getVersion() ) )\n            {\n                throw new ProjectBuildingException( \"Missing version element from parent element\" );\n            }\n\n            //!! (**)\n            // ----------------------------------------------------------------------\n            // Do we have the necessary information to actually find the parent\n            // POMs here?? I don't think so ... Say only one remote repository is\n            // specified and that is ibiblio then this model that we just read doesn't\n            // have any repository information ... I think we might have to inherit\n            // as we go in order to do this.\n            // ----------------------------------------------------------------------\n\n            aggregatedRemoteWagonRepositories.addAll( buildArtifactRepositories( model.getRepositories() ) );\n\n            MavenProject parent = getCachedProject( parentModel.getGroupId(), parentModel.getArtifactId(),\n                                                    parentModel.getVersion() );\n            if ( parent == null )\n            {\n                File parentPom = findParentModel( parentModel, aggregatedRemoteWagonRepositories, localRepository );\n\n                parent = assembleLineage( parentPom, localRepository, lineage, aggregatedRemoteWagonRepositories );\n            }\n            project.setParent( parent );\n        }\n\n        return project;\n    }","id":29739,"modified_method":"private MavenProject assembleLineage( File projectDescriptor, ArtifactRepository localRepository,\n                                          LinkedList lineage, List aggregatedRemoteWagonRepositories )\n        throws ProjectBuildingException\n    {\n        Model model = readModel( projectDescriptor );\n        MavenProject project = assembleLineage( model, localRepository, lineage, aggregatedRemoteWagonRepositories );\n        project.setFile( projectDescriptor );\n\n        return project;\n\n    }","commit_id":"fea9f2ac5363953d7b654d956df293b33093c6ef","url":"https://github.com/apache/maven"},{"original_method":"private MavenProject processProjectLogic( MavenProject project, ArtifactRepository localRepository,\n                                              boolean resolveDependencies, boolean sourceProject )\n        throws ProjectBuildingException, ModelInterpolationException, ArtifactResolutionException\n    {\n        Model model = modelInterpolator.interpolate( project.getModel() );\n\n        // interpolation is before injection, because interpolation is off-limits in the injected variables\n        modelDefaultsInjector.injectDefaults( model );\n\n        MavenProject parentProject = project.getParent();\n\n        File projectDescriptor = project.getFile();\n        if ( sourceProject )\n        {\n            pathTranslator.alignToBaseDirectory( model, projectDescriptor );\n        }\n\n        project = new MavenProject( model );\n        project.setFile( projectDescriptor );\n        project.setParent( parentProject );\n        project.setArtifacts( artifactFactory.createArtifacts( project.getDependencies(), localRepository, null ) );\n\n        String key = createCacheKey( project.getGroupId(), project.getArtifactId(), project.getVersion() );\n        MavenProject cachedProject = (MavenProject) projectCache.get( key );\n        if ( cachedProject == null || sourceProject )\n        {\n            projectCache.put( key, project );\n        }\n\n        // ----------------------------------------------------------------------\n        // Typically when the project builder is being used from maven proper\n        // the transitive dependencies will not be resolved here because this\n        // requires a lot of work when we may only be interested in running\n        // something simple like 'm2 clean'. So the artifact collector is used\n        // in the dependency resolution phase if it is required by any of the\n        // goals being executed. But when used as a component in another piece\n        // of code people may just want to build maven projects and have the\n        // dependencies resolved for whatever reason: this is why we keep\n        // this snippet of code here.\n        // ----------------------------------------------------------------------\n\n        if ( resolveDependencies )\n        {\n            List repos = buildArtifactRepositories( project.getRepositories() );\n\n            MavenMetadataSource sourceReader = new MavenMetadataSource( artifactResolver, this );\n\n            ArtifactResolutionResult result = artifactResolver.resolveTransitively( project.getArtifacts(), repos,\n                                                                                    localRepository, sourceReader );\n\n            project.getArtifacts().addAll( result.getArtifacts().values() );\n        }\n\n        ModelValidationResult validationResult = validator.validate( project.getModel() );\n\n        if ( validationResult.getMessageCount() > 0 )\n        {\n            throw new ProjectBuildingException( \"Exception while building project: \" + validationResult.toString() );\n        }\n\n        project.addCompileSourceRoot( project.getBuild().getSourceDirectory() );\n        project.addScriptSourceRoot( project.getBuild().getScriptSourceDirectory() );\n        project.addTestCompileSourceRoot( project.getBuild().getTestSourceDirectory() );\n\n        return project;\n    }","id":29740,"modified_method":"private MavenProject processProjectLogic( MavenProject project, ArtifactRepository localRepository,\n                                              boolean resolveDependencies, boolean sourceProject )\n        throws ProjectBuildingException, ModelInterpolationException, ArtifactResolutionException\n    {\n        Model model = project.getModel();\n        String key = createCacheKey( model.getGroupId(), model.getArtifactId(), model.getVersion() );\n        Model cachedModel = (Model) modelCache.get( key );\n        if ( cachedModel == null || sourceProject )\n        {\n            modelCache.put( key, model );\n        }\n\n        model = modelInterpolator.interpolate( model );\n\n        // interpolation is before injection, because interpolation is off-limits in the injected variables\n        modelDefaultsInjector.injectDefaults( model );\n\n        MavenProject parentProject = project.getParent();\n\n        File projectDescriptor = project.getFile();\n        if ( sourceProject )\n        {\n            pathTranslator.alignToBaseDirectory( model, projectDescriptor );\n        }\n\n        project = new MavenProject( model );\n        project.setFile( projectDescriptor );\n        project.setParent( parentProject );\n        project.setArtifacts( artifactFactory.createArtifacts( project.getDependencies(), localRepository, null ) );\n\n        // ----------------------------------------------------------------------\n        // Typically when the project builder is being used from maven proper\n        // the transitive dependencies will not be resolved here because this\n        // requires a lot of work when we may only be interested in running\n        // something simple like 'm2 clean'. So the artifact collector is used\n        // in the dependency resolution phase if it is required by any of the\n        // goals being executed. But when used as a component in another piece\n        // of code people may just want to build maven projects and have the\n        // dependencies resolved for whatever reason: this is why we keep\n        // this snippet of code here.\n        // ----------------------------------------------------------------------\n\n        if ( resolveDependencies )\n        {\n            List repos = buildArtifactRepositories( project.getRepositories() );\n\n            MavenMetadataSource sourceReader = new MavenMetadataSource( artifactResolver, this );\n\n            ArtifactResolutionResult result = artifactResolver.resolveTransitively( project.getArtifacts(), repos,\n                                                                                    localRepository, sourceReader );\n\n            project.getArtifacts().addAll( result.getArtifacts().values() );\n        }\n\n        ModelValidationResult validationResult = validator.validate( model );\n\n        if ( validationResult.getMessageCount() > 0 )\n        {\n            throw new ProjectBuildingException( \"Exception while building project: \" + validationResult.toString() );\n        }\n\n        project.addCompileSourceRoot( project.getBuild().getSourceDirectory() );\n        project.addScriptSourceRoot( project.getBuild().getScriptSourceDirectory() );\n        project.addTestCompileSourceRoot( project.getBuild().getTestSourceDirectory() );\n\n        return project;\n    }","commit_id":"fea9f2ac5363953d7b654d956df293b33093c6ef","url":"https://github.com/apache/maven"},{"original_method":"public Set retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n        throws ArtifactMetadataRetrievalException\n    {\n        try\n        {\n            List dependencies = null;\n\n            if ( mavenProjectBuilder != null )\n            {\n                MavenProject project = mavenProjectBuilder.getCachedProject( artifact.getGroupId(),\n                                                                             artifact.getArtifactId(),\n                                                                             artifact.getVersion() );\n                if ( project != null )\n                {\n                    dependencies = project.getDependencies();\n                }\n            }\n\n            if ( dependencies == null )\n            {\n                Artifact metadataArtifact = artifactFactory.createArtifact( artifact.getGroupId(),\n                                                                            artifact.getArtifactId(),\n                                                                            artifact.getVersion(), artifact.getScope(),\n                                                                            \"pom\", \"pom\", null );\n\n                artifactResolver.resolve( metadataArtifact, remoteRepositories, localRepository );\n\n                // [jdcasey/03-Feb-2005]: Replacing with ProjectBuilder, to enable\n                // post-processing and inheritance calculation before retrieving the\n                // associated artifacts. This should improve consistency.\n                try\n                {\n                    if ( mavenProjectBuilder != null )\n                    {\n                        MavenProject p = mavenProjectBuilder.buildFromRepository( metadataArtifact, localRepository );\n                        dependencies = p.getDependencies();\n                    }\n                    else\n                    {\n                        Model model = reader.read( new FileReader( metadataArtifact.getFile() ) );\n                        dependencies = model.getDependencies();\n                    }\n                }\n                catch ( Exception e )\n                {\n                    throw new ArtifactMetadataRetrievalException(\n                        \"Cannot read artifact source: \" + metadataArtifact.getPath(), e );\n                }\n            }\n            return artifactFactory.createArtifacts( dependencies, localRepository, artifact.getScope() );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ArtifactMetadataRetrievalException( \"Error while resolving metadata artifact\", e );\n        }\n    }","id":29741,"modified_method":"public Set retrieve( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n        throws ArtifactMetadataRetrievalException\n    {\n        try\n        {\n            List dependencies = null;\n\n            if ( mavenProjectBuilder != null )\n            {\n                Model model = mavenProjectBuilder.getCachedModel( artifact.getGroupId(), artifact.getArtifactId(),\n                                                                  artifact.getVersion() );\n                if ( model != null )\n                {\n                    dependencies = model.getDependencies();\n                }\n            }\n\n            if ( dependencies == null )\n            {\n                Artifact metadataArtifact = artifactFactory.createArtifact( artifact.getGroupId(),\n                                                                            artifact.getArtifactId(),\n                                                                            artifact.getVersion(), artifact.getScope(),\n                                                                            \"pom\", \"pom\", null );\n\n                artifactResolver.resolve( metadataArtifact, remoteRepositories, localRepository );\n\n                // [jdcasey/03-Feb-2005]: Replacing with ProjectBuilder, to enable\n                // post-processing and inheritance calculation before retrieving the\n                // associated artifacts. This should improve consistency.\n                try\n                {\n                    if ( mavenProjectBuilder != null )\n                    {\n                        MavenProject p = mavenProjectBuilder.buildFromRepository( metadataArtifact, localRepository );\n                        dependencies = p.getDependencies();\n                    }\n                    else\n                    {\n                        Model model = reader.read( new FileReader( metadataArtifact.getFile() ) );\n                        dependencies = model.getDependencies();\n                    }\n                }\n                catch ( Exception e )\n                {\n                    throw new ArtifactMetadataRetrievalException(\n                        \"Cannot read artifact source: \" + metadataArtifact.getPath(), e );\n                }\n            }\n            return artifactFactory.createArtifacts( dependencies, localRepository, artifact.getScope() );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new ArtifactMetadataRetrievalException( \"Error while resolving metadata artifact\", e );\n        }\n    }","commit_id":"fea9f2ac5363953d7b654d956df293b33093c6ef","url":"https://github.com/apache/maven"},{"original_method":"@Test\n    @org.junit.Ignore\n    public void testSignedEncryptedSOAP12Fault() throws Exception {\n        Document doc = readDocument(\"wsse-response-fault.xml\");\n\n        SoapMessage msg = getSoapMessageForDom(doc, SOAPConstants.SOAP_1_2_PROTOCOL);\n        SOAPMessage saajMsg = msg.getContent(SOAPMessage.class);\n        doc = saajMsg.getSOAPPart();\n        \n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, \n                              WSHandlerConstants.SIGNATURE + \" \"  + WSHandlerConstants.ENCRYPT);\n        inHandler.setProperty(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inHandler.setProperty(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        inHandler.setProperty(WSHandlerConstants.PW_CALLBACK_CLASS, TestPwdCallback.class.getName());\n        inHandler.setProperty(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        inmsg.put(SecurityConstants.RETURN_SECURITY_ERROR, Boolean.TRUE);\n        \n        try {\n            inHandler.handleMessage(inmsg);\n            StaxUtils.print(saajMsg.getSOAPPart());\n            \n            fail(\"Expected failure on a SOAP Fault\");\n        } catch (SoapFault fault) {\n            fault.printStackTrace();\n            // TODO assertTrue(fault.getReason().startsWith(\n               // \"An error was discovered processing the <wsse:Security> header\"));\n            QName faultCode = new QName(WSConstants.WSSE_NS, \"InvalidSecurity\");\n            assertTrue(fault.getFaultCode().equals(faultCode));\n        }\n    }","id":29742,"modified_method":"@Test\n    public void testSignedEncryptedSOAP12Fault() throws Exception {\n        Document doc = readDocument(\"wsse-response-fault.xml\");\n\n        SoapMessage msg = getSoapMessageForDom(doc, SOAPConstants.SOAP_1_2_PROTOCOL);\n        SOAPMessage saajMsg = msg.getContent(SOAPMessage.class);\n        doc = saajMsg.getSOAPPart();\n        \n        byte[] docbytes = getMessageBytes(doc);\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(new ByteArrayInputStream(docbytes));\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        doc = StaxUtils.read(db, reader, false);\n\n        WSS4JInInterceptor inHandler = new WSS4JInInterceptor();\n\n        SoapMessage inmsg = new SoapMessage(new MessageImpl());\n        Exchange ex = new ExchangeImpl();\n        ex.setInMessage(inmsg);\n        inmsg.setContent(SOAPMessage.class, saajMsg);\n\n        inHandler.setProperty(WSHandlerConstants.ACTION, \n                              WSHandlerConstants.SIGNATURE + \" \"  + WSHandlerConstants.ENCRYPT);\n        inHandler.setProperty(WSHandlerConstants.DEC_PROP_FILE, \"insecurity.properties\");\n        inHandler.setProperty(WSHandlerConstants.SIG_VER_PROP_FILE, \"insecurity.properties\");\n        inHandler.setProperty(WSHandlerConstants.PW_CALLBACK_CLASS, TestPwdCallback.class.getName());\n        inHandler.setProperty(\n            WSHandlerConstants.PW_CALLBACK_CLASS, \n            \"org.apache.cxf.ws.security.wss4j.TestPwdCallback\"\n        );\n        \n        inHandler.handleMessage(inmsg);\n        // StaxUtils.print(saajMsg.getSOAPPart());\n    }","commit_id":"94b837228a1d9c706aa235bfe23b827eb04da63c","url":"https://github.com/apache/cxf"},{"original_method":"/** Internal method to serialize and send a message. This method is not reentrant */\n    void send(Message msg) throws Exception {\n        IpAddress  dest=(IpAddress)msg.getDest(); // guaranteed to be non-null\n        IpAddress  src=(IpAddress)msg.getSrc();\n        Buffer buf;\n\n        if(!dest.isMulticastAddress()) { // unicast\n            msg.setDest(null);\n            msg.setSrc(null);\n        }\n        else {  // multicast\n            msg.setDest(null);\n            IpAddress src_addr=(IpAddress)msg.getSrc();\n            if(src_addr != null)\n                msg.setSrc(new IpAddress(src_addr.getPort(), false));\n        }\n\n        buf=messageToBuffer(msg);\n        msg.setDest(dest);\n        msg.setSrc(src);\n        doSend(buf, dest.getIpAddress(), dest.getPort());\n    }","id":29743,"modified_method":"/** Internal method to serialize and send a message. This method is not reentrant */\n    void send(Message msg) throws Exception {\n        Buffer     buf;\n        IpAddress  dest=(IpAddress)msg.getDest(); // guaranteed to be non-null\n        IpAddress  src=(IpAddress)msg.getSrc();\n        buf=messageToBuffer(msg, dest, src);\n        doSend(buf, dest.getIpAddress(), dest.getPort());\n    }","commit_id":"4634758b0538888408c01e7a1f9ad72805c9a366","url":"https://github.com/belaban/JGroups"},{"original_method":"List bufferToList(DataInputStream instream) throws IOException, IllegalAccessException, InstantiationException {\n        List l=new List();\n        DataInputStream dis=null;\n        int len;\n        Message msg;\n\n        try {\n            len=instream.readInt();\n            for(int i=0; i < len; i++) {\n                msg=new Message();\n                msg.readFrom(instream);\n                l.add(msg);\n            }\n            return l;\n        }\n        finally {\n            if(dis != null)\n                dis.close();\n        }\n    }","id":29744,"modified_method":"List bufferToList(DataInputStream instream, IpAddress dest, InetAddress sender, int port)\n            throws IOException, IllegalAccessException, InstantiationException {\n        List l=new List();\n        DataInputStream dis=null;\n        int len;\n        Message msg;\n\n        try {\n            len=instream.readInt();\n            for(int i=0; i < len; i++) {\n                msg=new Message();\n                msg.readFrom(instream);\n                setAddresses(msg, dest, sender, port);\n                l.add(msg);\n            }\n            return l;\n        }\n        finally {\n            if(dis != null)\n                dis.close();\n        }\n    }","commit_id":"4634758b0538888408c01e7a1f9ad72805c9a366","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Processes a packet read from either the multicast or unicast socket. Needs to be synchronized because\n     * mcast or unicast socket reads can be concurrent\n     */\n    void handleIncomingUdpPacket(IpAddress dest, InetAddress sender, int port, byte[] data) {\n        ByteArrayInputStream inp_stream=null;\n        DataInputStream      inp=null;\n        Message              msg=null;\n        List                 l;  // used if bundling is enabled\n\n        try {\n            // skip the first n bytes (default: 4), this is the version info\n            inp_stream=new ByteArrayInputStream(data, VERSION_LENGTH, data.length - VERSION_LENGTH);\n            inp=new DataInputStream(inp_stream);\n            // inp=new ObjectInputStream(new BufferedInputStream(inp_stream));\n            // BufferedInputStream above makes no diff\n\n            // inp=new ObjectInputStream(inp_stream);\n            // inp=new MagicObjectInputStream(inp_stream);\n            if(enable_bundling) {\n                // l=new List();\n                // l.readExternal(inp);\n                l=bufferToList(inp);\n                for(Enumeration en=l.elements(); en.hasMoreElements();) {\n                    msg=(Message)en.nextElement();\n                    try {\n                        handleMessage(msg);\n                    }\n                    catch(Throwable t) {\n                        if(log.isErrorEnabled()) log.error(\"failure: \" + t.toString());\n                    }\n                }\n            }\n            else {\n                // msg=new Message();\n                // msg.readExternal(inp);\n                msg=bufferToMessage(inp);\n\n                // set the source address if not set\n                IpAddress src_addr=(IpAddress)msg.getSrc();\n                if(src_addr == null) {\n                    try {msg.setSrc(new IpAddress(sender, port));} catch(Throwable t) {}\n                }\n                else {\n                    if(src_addr.getIpAddress() == null) {\n                        try {msg.setSrc(new IpAddress(sender, src_addr.getPort()));} catch(Throwable t) {}\n                    }\n                }\n\n                // set the destination address\n                if(msg.getDest() == null && dest != null)\n                    msg.setDest(dest);\n\n                handleMessage(msg);\n            }\n        }\n        catch(Throwable e) {\n            if(log.isErrorEnabled()) log.error(\"exception in processing incoming packet\", e);\n        }\n        finally {\n            closeInputStream(inp);\n            closeInputStream(inp_stream);\n        }\n    }","id":29745,"modified_method":"/**\n     * Processes a packet read from either the multicast or unicast socket. Needs to be synchronized because\n     * mcast or unicast socket reads can be concurrent\n     */\n    void handleIncomingUdpPacket(IpAddress dest, InetAddress sender, int port, byte[] data) {\n        ByteArrayInputStream inp_stream=null;\n        DataInputStream      inp=null;\n        Message              msg=null;\n        List                 l;  // used if bundling is enabled\n\n        try {\n            // skip the first n bytes (default: 4), this is the version info\n            inp_stream=new ByteArrayInputStream(data, VERSION_LENGTH, data.length - VERSION_LENGTH);\n            inp=new DataInputStream(inp_stream);\n            // inp=new ObjectInputStream(new BufferedInputStream(inp_stream));\n            // BufferedInputStream above makes no diff\n\n            // inp=new ObjectInputStream(inp_stream);\n            // inp=new MagicObjectInputStream(inp_stream);\n            if(enable_bundling) {\n                // l=new List();\n                // l.readExternal(inp);\n                l=bufferToList(inp, dest, sender, port);\n                for(Enumeration en=l.elements(); en.hasMoreElements();) {\n                    msg=(Message)en.nextElement();\n                    try {\n                        handleMessage(msg);\n                    }\n                    catch(Throwable t) {\n                        if(log.isErrorEnabled()) log.error(\"failure: \" + t.toString());\n                    }\n                }\n            }\n            else {\n                // msg=new Message();\n                // msg.readExternal(inp);\n                msg=bufferToMessage(inp, dest, sender, port);\n                handleMessage(msg);\n            }\n        }\n        catch(Throwable e) {\n            if(log.isErrorEnabled()) log.error(\"exception in processing incoming packet\", e);\n        }\n        finally {\n            closeInputStream(inp);\n            closeInputStream(inp_stream);\n        }\n    }","commit_id":"4634758b0538888408c01e7a1f9ad72805c9a366","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void handleMessage(Message msg) throws Exception {\n            Address        dst=msg.getDest();\n            long           len;\n            List           tmp;\n\n            len=msg.size(); // todo: use msg.getLength() instead of msg.getSize()\n            if(len > max_bundle_size)\n                throw new Exception(\"UDP.BundlingOutgoingPacketHandler.handleMessage(): \" +\n                        \"message size (\" + len + \") is greater than UDP fragmentation size. \" +\n                        \"Set the fragmentation/bundle size in FRAG and UDP correctly\");\n\n            if(total_bytes + len >= max_bundle_size) {\n                if(log.isTraceEnabled()) log.trace(\"sending \" + total_bytes + \" bytes\");\n                bundleAndSend(); // send all pending message and clear table\n                total_bytes=0;\n                stopTimer(); // this is more of a reset than a stop\n            }\n\n            synchronized(msgs) {\n                tmp=(List)msgs.get(dst);\n                if(tmp == null) {\n                    tmp=new List();\n                    msgs.put(dst, tmp);\n                }\n                tmp.add(msg);\n                total_bytes+=len;\n            }\n            startTimer(); // doesn't start if already running\n        }","id":29746,"modified_method":"protected void handleMessage(Message msg) throws Exception {\n            Address        dst=msg.getDest();\n            long           len;\n            List           tmp;\n\n            len=msg.size(); // todo: use msg.getLength() instead of msg.getSize()\n            if(len > max_bundle_size)\n                throw new Exception(\"UDP.BundlingOutgoingPacketHandler.handleMessage(): \" +\n                        \"message size (\" + len + \") is greater than UDP fragmentation size. \" +\n                        \"Set the fragmentation/bundle size in FRAG and UDP correctly\");\n\n            if(log.isTraceEnabled())\n                log.trace(\"accumulated bytes: \" + total_bytes);\n            if(total_bytes + len >= max_bundle_size) {\n                if(log.isTraceEnabled()) log.trace(\"sending \" + total_bytes + \" bytes\");\n                bundleAndSend(); // send all pending message and clear table\n                total_bytes=0;\n                stopTimer(); // this is more of a reset than a stop\n            }\n\n            synchronized(msgs) {\n                tmp=(List)msgs.get(dst);\n                if(tmp == null) {\n                    tmp=new List();\n                    msgs.put(dst, tmp);\n                }\n                tmp.add(msg);\n                total_bytes+=len;\n            }\n            startTimer(); // doesn't start if already running\n        }","commit_id":"4634758b0538888408c01e7a1f9ad72805c9a366","url":"https://github.com/belaban/JGroups"},{"original_method":"void stopTimer() {\n            synchronized(task_mutex) {\n                if(task != null) {\n                    task.cancel();\n                    task=null;\n                }\n            }\n        }","id":29747,"modified_method":"void stopTimer() {\n            synchronized(task_mutex) {\n                if(task != null) {\n                    task.cancel();\n                    task=null;\n                    if(log.isTraceEnabled())\n                        log.trace(\"stopped bundling task\");\n                }\n            }\n        }","commit_id":"4634758b0538888408c01e7a1f9ad72805c9a366","url":"https://github.com/belaban/JGroups"},{"original_method":"void startTimer() {\n            synchronized(task_mutex) {\n                if(task == null || task.cancelled()) {\n                    task=new MyTask();\n                    timer.add(task);\n                }\n            }\n        }","id":29748,"modified_method":"void startTimer() {\n            synchronized(task_mutex) {\n                if(task == null || task.cancelled()) {\n                    task=new MyTask();\n                    timer.add(task);\n                    if(log.isTraceEnabled())\n                        log.trace(\"started bundling task\");\n                }\n            }\n        }","commit_id":"4634758b0538888408c01e7a1f9ad72805c9a366","url":"https://github.com/belaban/JGroups"},{"original_method":"Message bufferToMessage(DataInputStream instream) throws IOException, IllegalAccessException, InstantiationException {\n        Message retval=new Message();\n        retval.readFrom(instream);\n        return retval;\n    }","id":29749,"modified_method":"Message bufferToMessage(DataInputStream instream, IpAddress dest, InetAddress sender, int port)\n            throws IOException, IllegalAccessException, InstantiationException {\n        Message msg=new Message();\n        msg.readFrom(instream);\n        setAddresses(msg, dest, sender, port);\n        return msg;\n    }","commit_id":"4634758b0538888408c01e7a1f9ad72805c9a366","url":"https://github.com/belaban/JGroups"},{"original_method":"void doSend(Buffer buf, InetAddress dest, int port) throws IOException {\n        DatagramPacket       packet;\n\n        // packet=new DatagramPacket(data, data.length, dest, port);\n        packet=new DatagramPacket(buf.getBuf(), buf.getOffset(), buf.getLength(), dest, port);\n        if(dest.isMulticastAddress() && mcast_send_sock != null) { // mcast_recv_sock might be null if ip_mcast is false\n            mcast_send_sock.send(packet);\n        }\n        else {\n            if(sock != null)\n                sock.send(packet);\n        }\n    }","id":29750,"modified_method":"Buffer messageToBuffer(Message msg, IpAddress dest, IpAddress src) throws IOException {\n        Buffer retval=null;\n        out_stream.reset();\n        out_stream.write(Version.version_id, 0, Version.version_id.length); // write the version\n        DataOutputStream out=new DataOutputStream(out_stream);\n\n        nullAddresses(msg, dest, src);\n        msg.writeTo(out);\n        revertAddresses(msg, dest, src);\n\n        out.close(); // flushes contents to out_stream\n        retval=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n        return retval;\n    }","commit_id":"4634758b0538888408c01e7a1f9ad72805c9a366","url":"https://github.com/belaban/JGroups"},{"original_method":"void bundleAndSend() {\n            Map.Entry      entry;\n            IpAddress      dst;\n            Buffer         buffer;\n            InetAddress    addr;\n            int            port;\n            List           l;\n\n            if(log.isTraceEnabled()) log.trace(\"\\nsending msgs:\\n\" + dumpMessages(msgs));\n            synchronized(msgs) {\n                // stopTimer();\n                if(msgs.size() == 0)\n                    return;\n\n                for(Iterator it=msgs.entrySet().iterator(); it.hasNext();) {\n                    entry=(Map.Entry)it.next();\n                    dst=(IpAddress)entry.getKey();\n                    addr=dst.getIpAddress();\n                    port=dst.getPort();\n                    l=(List)entry.getValue();\n                    try {\n                        buffer=listToBuffer(l);\n                        doSend(buffer, addr, port);\n                    }\n                    catch(IOException e) {\n                        if(log.isErrorEnabled()) log.error(\"exception sending msg (to dest=\" + dst + \"): \" + e);\n                    }\n                }\n                msgs.clear();\n            }\n        }","id":29751,"modified_method":"void bundleAndSend() {\n            Map.Entry      entry;\n            IpAddress      dst;\n            Buffer         buffer;\n            InetAddress    addr;\n            int            port;\n            List           l;\n\n            if(log.isTraceEnabled()) log.trace(\"sending msgs: \" + dumpMessages(msgs));\n            synchronized(msgs) {\n                // stopTimer();\n                if(msgs.size() == 0)\n                    return;\n\n                for(Iterator it=msgs.entrySet().iterator(); it.hasNext();) {\n                    entry=(Map.Entry)it.next();\n                    dst=(IpAddress)entry.getKey();\n                    addr=dst.getIpAddress();\n                    port=dst.getPort();\n                    l=(List)entry.getValue();\n                    try {\n                        buffer=listToBuffer(l, dst);\n                        doSend(buffer, addr, port);\n                    }\n                    catch(IOException e) {\n                        if(log.isErrorEnabled()) log.error(\"exception sending msg (to dest=\" + dst + \"): \" + e);\n                    }\n                }\n                msgs.clear();\n            }\n        }","commit_id":"4634758b0538888408c01e7a1f9ad72805c9a366","url":"https://github.com/belaban/JGroups"},{"original_method":"Buffer listToBuffer(List l) throws IOException {\n        Buffer retval=null;\n        Message msg;\n        int len=l != null? l.size() : 0;\n        DataOutputStream out=null;\n        out_stream.reset();\n        out_stream.write(Version.version_id, 0, Version.version_id.length); // write the version\n        out=new DataOutputStream(out_stream);\n        out.writeInt(len);\n        for(Enumeration en=l.elements(); en.hasMoreElements();) {\n            msg=(Message)en.nextElement();\n            msg.writeTo(out);\n        }\n        out.close(); // flush contents to outstream\n        retval=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n        return retval;\n    }","id":29752,"modified_method":"Buffer listToBuffer(List l, IpAddress dest) throws IOException {\n        Buffer retval=null;\n        IpAddress src;\n        Message msg;\n        int len=l != null? l.size() : 0;\n        DataOutputStream out=null;\n        out_stream.reset();\n        out_stream.write(Version.version_id, 0, Version.version_id.length); // write the version\n        out=new DataOutputStream(out_stream);\n        out.writeInt(len);\n        for(Enumeration en=l.elements(); en.hasMoreElements();) {\n            msg=(Message)en.nextElement();\n            src=(IpAddress)msg.getSrc();\n            nullAddresses(msg, dest, src);\n            msg.writeTo(out);\n            revertAddresses(msg, dest, src);\n        }\n        out.close(); // flush contents to outstream\n        retval=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n        return retval;\n    }","commit_id":"4634758b0538888408c01e7a1f9ad72805c9a366","url":"https://github.com/belaban/JGroups"},{"original_method":"void doSend(Buffer buf, InetAddress dest, int port) throws IOException {\n        DatagramPacket       packet;\n\n        // packet=new DatagramPacket(data, data.length, dest, port);\n        packet=new DatagramPacket(buf.getBuf(), buf.getOffset(), buf.getLength(), dest, port);\n        if(dest.isMulticastAddress() && mcast_send_sock != null) { // mcast_recv_sock might be null if ip_mcast is false\n            mcast_send_sock.send(packet);\n        }\n        else {\n            if(sock != null)\n                sock.send(packet);\n        }\n    }","id":29753,"modified_method":"Buffer messageToBuffer(Message msg, IpAddress dest, IpAddress src) throws IOException {\n        Buffer retval=null;\n        out_stream.reset();\n        out_stream.write(Version.version_id, 0, Version.version_id.length); // write the version\n        DataOutputStream out=new DataOutputStream(out_stream);\n\n        nullAddresses(msg, dest, src);\n        msg.writeTo(out);\n        revertAddresses(msg, dest, src);\n\n        out.close(); // flushes contents to out_stream\n        retval=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n        return retval;\n    }","commit_id":"97f9a594e41730b9e09e8e3a430a7c2386cac6c2","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void handleMessage(Message msg) throws Exception {\n            Address        dst=msg.getDest();\n            long           len;\n            List           tmp;\n\n            len=msg.size(); // todo: use msg.getLength() instead of msg.getSize()\n            if(len > max_bundle_size)\n                throw new Exception(\"UDP.BundlingOutgoingPacketHandler.handleMessage(): \" +\n                        \"message size (\" + len + \") is greater than UDP fragmentation size. \" +\n                        \"Set the fragmentation/bundle size in FRAG and UDP correctly\");\n\n            if(total_bytes + len >= max_bundle_size) {\n                if(log.isTraceEnabled()) log.trace(\"sending \" + total_bytes + \" bytes\");\n                bundleAndSend(); // send all pending message and clear table\n                total_bytes=0;\n                stopTimer(); // this is more of a reset than a stop\n            }\n\n            synchronized(msgs) {\n                tmp=(List)msgs.get(dst);\n                if(tmp == null) {\n                    tmp=new List();\n                    msgs.put(dst, tmp);\n                }\n                tmp.add(msg);\n                total_bytes+=len;\n            }\n            startTimer(); // doesn't start if already running\n        }","id":29754,"modified_method":"protected void handleMessage(Message msg) throws Exception {\n            Address        dst=msg.getDest();\n            long           len;\n            List           tmp;\n\n            len=msg.size(); // todo: use msg.getLength() instead of msg.getSize()\n            if(len > max_bundle_size)\n                throw new Exception(\"UDP.BundlingOutgoingPacketHandler.handleMessage(): \" +\n                        \"message size (\" + len + \") is greater than UDP fragmentation size. \" +\n                        \"Set the fragmentation/bundle size in FRAG and UDP correctly\");\n\n            if(log.isTraceEnabled())\n                log.trace(\"accumulated bytes: \" + total_bytes);\n            if(total_bytes + len >= max_bundle_size) {\n                if(log.isTraceEnabled()) log.trace(\"sending \" + total_bytes + \" bytes\");\n                bundleAndSend(); // send all pending message and clear table\n                total_bytes=0;\n                stopTimer(); // this is more of a reset than a stop\n            }\n\n            synchronized(msgs) {\n                tmp=(List)msgs.get(dst);\n                if(tmp == null) {\n                    tmp=new List();\n                    msgs.put(dst, tmp);\n                }\n                tmp.add(msg);\n                total_bytes+=len;\n            }\n            startTimer(); // doesn't start if already running\n        }","commit_id":"97f9a594e41730b9e09e8e3a430a7c2386cac6c2","url":"https://github.com/belaban/JGroups"},{"original_method":"void startTimer() {\n            synchronized(task_mutex) {\n                if(task == null || task.cancelled()) {\n                    task=new MyTask();\n                    timer.add(task);\n                }\n            }\n        }","id":29755,"modified_method":"void startTimer() {\n            synchronized(task_mutex) {\n                if(task == null || task.cancelled()) {\n                    task=new MyTask();\n                    timer.add(task);\n                    if(log.isTraceEnabled())\n                        log.trace(\"started bundling task\");\n                }\n            }\n        }","commit_id":"97f9a594e41730b9e09e8e3a430a7c2386cac6c2","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Processes a packet read from either the multicast or unicast socket. Needs to be synchronized because\n     * mcast or unicast socket reads can be concurrent\n     */\n    void handleIncomingUdpPacket(IpAddress dest, InetAddress sender, int port, byte[] data) {\n        ByteArrayInputStream inp_stream=null;\n        DataInputStream      inp=null;\n        Message              msg=null;\n        List                 l;  // used if bundling is enabled\n\n        try {\n            // skip the first n bytes (default: 4), this is the version info\n            inp_stream=new ByteArrayInputStream(data, VERSION_LENGTH, data.length - VERSION_LENGTH);\n            inp=new DataInputStream(inp_stream);\n            // inp=new ObjectInputStream(new BufferedInputStream(inp_stream));\n            // BufferedInputStream above makes no diff\n\n            // inp=new ObjectInputStream(inp_stream);\n            // inp=new MagicObjectInputStream(inp_stream);\n            if(enable_bundling) {\n                // l=new List();\n                // l.readExternal(inp);\n                l=bufferToList(inp);\n                for(Enumeration en=l.elements(); en.hasMoreElements();) {\n                    msg=(Message)en.nextElement();\n                    try {\n                        handleMessage(msg);\n                    }\n                    catch(Throwable t) {\n                        if(log.isErrorEnabled()) log.error(\"failure: \" + t.toString());\n                    }\n                }\n            }\n            else {\n                // msg=new Message();\n                // msg.readExternal(inp);\n                msg=bufferToMessage(inp);\n\n                // set the source address if not set\n                IpAddress src_addr=(IpAddress)msg.getSrc();\n                if(src_addr == null) {\n                    try {msg.setSrc(new IpAddress(sender, port));} catch(Throwable t) {}\n                }\n                else {\n                    if(src_addr.getIpAddress() == null) {\n                        try {msg.setSrc(new IpAddress(sender, src_addr.getPort()));} catch(Throwable t) {}\n                    }\n                }\n\n                // set the destination address\n                if(msg.getDest() == null && dest != null)\n                    msg.setDest(dest);\n\n                handleMessage(msg);\n            }\n        }\n        catch(Throwable e) {\n            if(log.isErrorEnabled()) log.error(\"exception in processing incoming packet\", e);\n        }\n        finally {\n            closeInputStream(inp);\n            closeInputStream(inp_stream);\n        }\n    }","id":29756,"modified_method":"/**\n     * Processes a packet read from either the multicast or unicast socket. Needs to be synchronized because\n     * mcast or unicast socket reads can be concurrent\n     */\n    void handleIncomingUdpPacket(IpAddress dest, InetAddress sender, int port, byte[] data) {\n        ByteArrayInputStream inp_stream=null;\n        DataInputStream      inp=null;\n        Message              msg=null;\n        List                 l;  // used if bundling is enabled\n\n        try {\n            // skip the first n bytes (default: 4), this is the version info\n            inp_stream=new ByteArrayInputStream(data, VERSION_LENGTH, data.length - VERSION_LENGTH);\n            inp=new DataInputStream(inp_stream);\n            // inp=new ObjectInputStream(new BufferedInputStream(inp_stream));\n            // BufferedInputStream above makes no diff\n\n            // inp=new ObjectInputStream(inp_stream);\n            // inp=new MagicObjectInputStream(inp_stream);\n            if(enable_bundling) {\n                // l=new List();\n                // l.readExternal(inp);\n                l=bufferToList(inp, dest, sender, port);\n                for(Enumeration en=l.elements(); en.hasMoreElements();) {\n                    msg=(Message)en.nextElement();\n                    try {\n                        handleMessage(msg);\n                    }\n                    catch(Throwable t) {\n                        if(log.isErrorEnabled()) log.error(\"failure: \" + t.toString());\n                    }\n                }\n            }\n            else {\n                // msg=new Message();\n                // msg.readExternal(inp);\n                msg=bufferToMessage(inp, dest, sender, port);\n                handleMessage(msg);\n            }\n        }\n        catch(Throwable e) {\n            if(log.isErrorEnabled()) log.error(\"exception in processing incoming packet\", e);\n        }\n        finally {\n            closeInputStream(inp);\n            closeInputStream(inp_stream);\n        }\n    }","commit_id":"97f9a594e41730b9e09e8e3a430a7c2386cac6c2","url":"https://github.com/belaban/JGroups"},{"original_method":"void bundleAndSend() {\n            Map.Entry      entry;\n            IpAddress      dst;\n            Buffer         buffer;\n            InetAddress    addr;\n            int            port;\n            List           l;\n\n            if(log.isTraceEnabled()) log.trace(\"\\nsending msgs:\\n\" + dumpMessages(msgs));\n            synchronized(msgs) {\n                // stopTimer();\n                if(msgs.size() == 0)\n                    return;\n\n                for(Iterator it=msgs.entrySet().iterator(); it.hasNext();) {\n                    entry=(Map.Entry)it.next();\n                    dst=(IpAddress)entry.getKey();\n                    addr=dst.getIpAddress();\n                    port=dst.getPort();\n                    l=(List)entry.getValue();\n                    try {\n                        buffer=listToBuffer(l);\n                        doSend(buffer, addr, port);\n                    }\n                    catch(IOException e) {\n                        if(log.isErrorEnabled()) log.error(\"exception sending msg (to dest=\" + dst + \"): \" + e);\n                    }\n                }\n                msgs.clear();\n            }\n        }","id":29757,"modified_method":"void bundleAndSend() {\n            Map.Entry      entry;\n            IpAddress      dst;\n            Buffer         buffer;\n            InetAddress    addr;\n            int            port;\n            List           l;\n\n            if(log.isTraceEnabled()) log.trace(\"sending msgs: \" + dumpMessages(msgs));\n            synchronized(msgs) {\n                // stopTimer();\n                if(msgs.size() == 0)\n                    return;\n\n                for(Iterator it=msgs.entrySet().iterator(); it.hasNext();) {\n                    entry=(Map.Entry)it.next();\n                    dst=(IpAddress)entry.getKey();\n                    addr=dst.getIpAddress();\n                    port=dst.getPort();\n                    l=(List)entry.getValue();\n                    try {\n                        buffer=listToBuffer(l, dst);\n                        doSend(buffer, addr, port);\n                    }\n                    catch(IOException e) {\n                        if(log.isErrorEnabled()) log.error(\"exception sending msg (to dest=\" + dst + \"): \" + e);\n                    }\n                }\n                msgs.clear();\n            }\n        }","commit_id":"97f9a594e41730b9e09e8e3a430a7c2386cac6c2","url":"https://github.com/belaban/JGroups"},{"original_method":"Buffer listToBuffer(List l) throws IOException {\n        Buffer retval=null;\n        Message msg;\n        int len=l != null? l.size() : 0;\n        DataOutputStream out=null;\n        out_stream.reset();\n        out_stream.write(Version.version_id, 0, Version.version_id.length); // write the version\n        out=new DataOutputStream(out_stream);\n        out.writeInt(len);\n        for(Enumeration en=l.elements(); en.hasMoreElements();) {\n            msg=(Message)en.nextElement();\n            msg.writeTo(out);\n        }\n        out.close(); // flush contents to outstream\n        retval=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n        return retval;\n    }","id":29758,"modified_method":"Buffer listToBuffer(List l, IpAddress dest) throws IOException {\n        Buffer retval=null;\n        IpAddress src;\n        Message msg;\n        int len=l != null? l.size() : 0;\n        DataOutputStream out=null;\n        out_stream.reset();\n        out_stream.write(Version.version_id, 0, Version.version_id.length); // write the version\n        out=new DataOutputStream(out_stream);\n        out.writeInt(len);\n        for(Enumeration en=l.elements(); en.hasMoreElements();) {\n            msg=(Message)en.nextElement();\n            src=(IpAddress)msg.getSrc();\n            nullAddresses(msg, dest, src);\n            msg.writeTo(out);\n            revertAddresses(msg, dest, src);\n        }\n        out.close(); // flush contents to outstream\n        retval=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n        return retval;\n    }","commit_id":"97f9a594e41730b9e09e8e3a430a7c2386cac6c2","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Internal method to serialize and send a message. This method is not reentrant */\n    void send(Message msg) throws Exception {\n        IpAddress  dest=(IpAddress)msg.getDest(); // guaranteed to be non-null\n        IpAddress  src=(IpAddress)msg.getSrc();\n        Buffer buf;\n\n        if(!dest.isMulticastAddress()) { // unicast\n            msg.setDest(null);\n            msg.setSrc(null);\n        }\n        else {  // multicast\n            msg.setDest(null);\n            IpAddress src_addr=(IpAddress)msg.getSrc();\n            if(src_addr != null)\n                msg.setSrc(new IpAddress(src_addr.getPort(), false));\n        }\n\n        buf=messageToBuffer(msg);\n        msg.setDest(dest);\n        msg.setSrc(src);\n        doSend(buf, dest.getIpAddress(), dest.getPort());\n    }","id":29759,"modified_method":"/** Internal method to serialize and send a message. This method is not reentrant */\n    void send(Message msg) throws Exception {\n        Buffer     buf;\n        IpAddress  dest=(IpAddress)msg.getDest(); // guaranteed to be non-null\n        IpAddress  src=(IpAddress)msg.getSrc();\n        buf=messageToBuffer(msg, dest, src);\n        doSend(buf, dest.getIpAddress(), dest.getPort());\n    }","commit_id":"97f9a594e41730b9e09e8e3a430a7c2386cac6c2","url":"https://github.com/belaban/JGroups"},{"original_method":"List bufferToList(DataInputStream instream) throws IOException, IllegalAccessException, InstantiationException {\n        List l=new List();\n        DataInputStream dis=null;\n        int len;\n        Message msg;\n\n        try {\n            len=instream.readInt();\n            for(int i=0; i < len; i++) {\n                msg=new Message();\n                msg.readFrom(instream);\n                l.add(msg);\n            }\n            return l;\n        }\n        finally {\n            if(dis != null)\n                dis.close();\n        }\n    }","id":29760,"modified_method":"List bufferToList(DataInputStream instream, IpAddress dest, InetAddress sender, int port)\n            throws IOException, IllegalAccessException, InstantiationException {\n        List l=new List();\n        DataInputStream dis=null;\n        int len;\n        Message msg;\n\n        try {\n            len=instream.readInt();\n            for(int i=0; i < len; i++) {\n                msg=new Message();\n                msg.readFrom(instream);\n                setAddresses(msg, dest, sender, port);\n                l.add(msg);\n            }\n            return l;\n        }\n        finally {\n            if(dis != null)\n                dis.close();\n        }\n    }","commit_id":"97f9a594e41730b9e09e8e3a430a7c2386cac6c2","url":"https://github.com/belaban/JGroups"},{"original_method":"void stopTimer() {\n            synchronized(task_mutex) {\n                if(task != null) {\n                    task.cancel();\n                    task=null;\n                }\n            }\n        }","id":29761,"modified_method":"void stopTimer() {\n            synchronized(task_mutex) {\n                if(task != null) {\n                    task.cancel();\n                    task=null;\n                    if(log.isTraceEnabled())\n                        log.trace(\"stopped bundling task\");\n                }\n            }\n        }","commit_id":"97f9a594e41730b9e09e8e3a430a7c2386cac6c2","url":"https://github.com/belaban/JGroups"},{"original_method":"Message bufferToMessage(DataInputStream instream) throws IOException, IllegalAccessException, InstantiationException {\n        Message retval=new Message();\n        retval.readFrom(instream);\n        return retval;\n    }","id":29762,"modified_method":"Message bufferToMessage(DataInputStream instream, IpAddress dest, InetAddress sender, int port)\n            throws IOException, IllegalAccessException, InstantiationException {\n        Message msg=new Message();\n        msg.readFrom(instream);\n        setAddresses(msg, dest, sender, port);\n        return msg;\n    }","commit_id":"97f9a594e41730b9e09e8e3a430a7c2386cac6c2","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n    public void onEvent(MessageEvent event, long sequence, boolean endOfBatch) throws Exception {\n        // Because Trisha said so. (http://code.google.com/p/disruptor/wiki/FrequentlyAskedQuestions)\n        if ((sequence % numberOfConsumers) != ordinal) {\n            return;\n        }\n\n        processBufferWatermark.decrementAndGet();\n        \n        incomingMessages.mark();\n        final Timer.Context tcx = processTime.time();\n\n        Message msg = event.getMessage();\n\n        LOG.debug(\"Starting to process message <{}>.\", msg.getId());\n\n        try {\n            handleMessage(msg);\n        } catch (Exception e) {\n            LOG.warn(\"Unable to process message <{}>: {}\", msg.getId(), e);\n        } finally {\n            outgoingMessages.mark();\n            tcx.stop();\n        }\n\n        LOG.debug(\"Finished processing message <{}>. Writing to output buffer.\", msg.getId());\n        handleMessage(msg);\n\n        outgoingMessages.mark();\n        tcx.stop();\n    }","id":29763,"modified_method":"@Override\n    public void onEvent(MessageEvent event, long sequence, boolean endOfBatch) throws Exception {\n        // Because Trisha said so. (http://code.google.com/p/disruptor/wiki/FrequentlyAskedQuestions)\n        if ((sequence % numberOfConsumers) != ordinal) {\n            return;\n        }\n\n        processBufferWatermark.decrementAndGet();\n        \n        incomingMessages.mark();\n        final Timer.Context tcx = processTime.time();\n\n        Message msg = event.getMessage();\n\n        LOG.debug(\"Starting to process message <{}>.\", msg.getId());\n\n        try {\n            LOG.debug(\"Finished processing message <{}>. Writing to output buffer.\", msg.getId());\n            handleMessage(msg);\n        } catch (Exception e) {\n            LOG.warn(\"Unable to process message <{}>: {}\", msg.getId(), e);\n        } finally {\n            outgoingMessages.mark();\n            tcx.stop();\n        }\n    }","commit_id":"03fe0cf7d3238103e4f3472d7435da112f6840c2","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n  public List<ComponentAdapter> getComponentAdaptersOfType(final Class componentType) {\n    if (componentType == null) return Collections.emptyList();\n    if (componentType == String.class) return Collections.emptyList();\n\n    List<ComponentAdapter> result = new SmartList<ComponentAdapter>();\n\n    final ComponentAdapter cacheHit = classNameToAdapter.get(componentType.getName());\n    if (cacheHit != null) {\n      result.add(cacheHit);\n    }\n\n    appendNonAssignableAdaptersOfType(componentType, result);\n    return result;\n  }","id":29764,"modified_method":"@Override\n  public List<ComponentAdapter> getComponentAdaptersOfType(final Class componentType) {\n    if (componentType == null || componentType == String.class) {\n      return Collections.emptyList();\n    }\n\n    List<ComponentAdapter> result = new SmartList<ComponentAdapter>();\n\n    final ComponentAdapter cacheHit = classNameToAdapter.get(componentType.getName());\n    if (cacheHit != null) {\n      result.add(cacheHit);\n    }\n\n    appendNonAssignableAdaptersOfType(componentType, result);\n    return result;\n  }","commit_id":"9f24659cd7dbe973d3f5a5e35e86c12fa1449874","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public ComponentAdapter getComponentAdapterOfType(Class componentType) {\n    // See http://jira.codehaus.org/secure/ViewIssue.jspa?key=PICO-115\n    ComponentAdapter adapterByKey = getComponentAdapter(componentType);\n    if (adapterByKey != null) {\n      return adapterByKey;\n    }\n\n    List<ComponentAdapter> found = getComponentAdaptersOfType(componentType);\n\n    if (found.size() == 1) {\n      return found.get(0);\n    }\n    if (found.isEmpty()) {\n      if (parent != null) {\n        return parent.getComponentAdapterOfType(componentType);\n      }\n      return null;\n    }\n    Class[] foundClasses = new Class[found.size()];\n    for (int i = 0; i < foundClasses.length; i++) {\n      foundClasses[i] = found.get(i).getComponentImplementation();\n    }\n\n    throw new AmbiguousComponentResolutionException(componentType, foundClasses);\n  }","id":29765,"modified_method":"@Override\n  @Nullable\n  public ComponentAdapter getComponentAdapterOfType(@NotNull Class componentType) {\n    // See http://jira.codehaus.org/secure/ViewIssue.jspa?key=PICO-115\n    ComponentAdapter adapterByKey = getComponentAdapter(componentType);\n    if (adapterByKey != null) {\n      return adapterByKey;\n    }\n\n    List<ComponentAdapter> found = getComponentAdaptersOfType(componentType);\n    if (found.size() == 1) {\n      return found.get(0);\n    }\n    if (found.isEmpty()) {\n      return parent == null ? null : parent.getComponentAdapterOfType(componentType);\n    }\n\n    Class[] foundClasses = new Class[found.size()];\n    for (int i = 0; i < foundClasses.length; i++) {\n      foundClasses[i] = found.get(i).getComponentImplementation();\n    }\n    throw new AmbiguousComponentResolutionException(componentType, foundClasses);\n  }","commit_id":"9f24659cd7dbe973d3f5a5e35e86c12fa1449874","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void accept(PicoVisitor visitor) {\n    visitor.visitContainer(this);\n    final List<ComponentAdapter> adapters = new ArrayList<ComponentAdapter>(getComponentAdapters());\n    for (final ComponentAdapter adapter : adapters) {\n      adapter.accept(visitor);\n    }\n    final List<PicoContainer> allChildren = new ArrayList<PicoContainer>(children);\n    for (PicoContainer child : allChildren) {\n      child.accept(visitor);\n    }\n  }","id":29766,"modified_method":"@Override\n  public void accept(PicoVisitor visitor) {\n    visitor.visitContainer(this);\n\n    for (ComponentAdapter adapter : getComponentAdapters()) {\n      adapter.accept(visitor);\n    }\n    for (PicoContainer child : new SmartList<PicoContainer>(children)) {\n      child.accept(visitor);\n    }\n  }","commit_id":"9f24659cd7dbe973d3f5a5e35e86c12fa1449874","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void appendNonAssignableAdaptersOfType(@NotNull Class componentType, @NotNull List<ComponentAdapter> result) {\n    List<ComponentAdapter> comp = new ArrayList<ComponentAdapter>();\n    for (final ComponentAdapter componentAdapter : nonAssignableComponentAdapters.get()) {\n      if (ReflectionUtil.isAssignable(componentType, componentAdapter.getComponentImplementation())) {\n        comp.add(componentAdapter);\n      }\n    }\n    for (int i = comp.size() - 1; i >= 0; i--) {\n      ComponentAdapter adapter = comp.get(i);\n      result.add(adapter);\n    }\n  }","id":29767,"modified_method":"private void appendNonAssignableAdaptersOfType(@NotNull Class componentType, @NotNull List<ComponentAdapter> result) {\n    List<ComponentAdapter> comp = new ArrayList<ComponentAdapter>();\n    for (final ComponentAdapter componentAdapter : nonAssignableComponentAdapters.get()) {\n      if (ReflectionUtil.isAssignable(componentType, componentAdapter.getComponentImplementation())) {\n        comp.add(componentAdapter);\n      }\n    }\n    for (int i = comp.size() - 1; i >= 0; i--) {\n      result.add(comp.get(i));\n    }\n  }","commit_id":"9f24659cd7dbe973d3f5a5e35e86c12fa1449874","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Object getLocalInstance(final ComponentAdapter componentAdapter) {\n    PicoException firstLevelException = null;\n    Object instance = null;\n    try {\n      instance = componentAdapter.getComponentInstance(this);\n    }\n    catch (PicoInitializationException e) {\n      firstLevelException = e;\n    }\n    catch (PicoIntrospectionException e) {\n      firstLevelException = e;\n    }\n    if (firstLevelException != null) {\n      if (parent != null) {\n        instance = parent.getComponentInstance(componentAdapter.getComponentKey());\n        if (instance != null) {\n          return instance;\n        }\n      }\n\n      throw firstLevelException;\n    }\n\n    return instance;\n  }","id":29768,"modified_method":"private Object getLocalInstance(@NotNull ComponentAdapter componentAdapter) {\n    PicoException firstLevelException;\n    try {\n      return componentAdapter.getComponentInstance(this);\n    }\n    catch (PicoInitializationException e) {\n      firstLevelException = e;\n    }\n    catch (PicoIntrospectionException e) {\n      firstLevelException = e;\n    }\n\n    if (parent != null) {\n      Object instance = parent.getComponentInstance(componentAdapter.getComponentKey());\n      if (instance != null) {\n        return instance;\n      }\n    }\n\n    throw firstLevelException;\n  }","commit_id":"9f24659cd7dbe973d3f5a5e35e86c12fa1449874","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public final ComponentAdapter getComponentAdapter(Object componentKey) {\n    ComponentAdapter adapter = getFromCache(componentKey);\n    if (adapter == null && parent != null) {\n      adapter = parent.getComponentAdapter(componentKey);\n    }\n    return adapter;\n  }","id":29769,"modified_method":"@Override\n  @Nullable\n  public final ComponentAdapter getComponentAdapter(Object componentKey) {\n    ComponentAdapter adapter = getFromCache(componentKey);\n    if (adapter == null && parent != null) {\n      return parent.getComponentAdapter(componentKey);\n    }\n    return adapter;\n  }","commit_id":"9f24659cd7dbe973d3f5a5e35e86c12fa1449874","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public ComponentAdapter unregisterComponentByInstance(@NotNull Object componentInstance) {\n    Collection<ComponentAdapter> adapters = getComponentAdapters();\n\n    for (final ComponentAdapter adapter : adapters) {\n      final Object o = getInstance(adapter);\n      if (o != null && o.equals(componentInstance)) {\n        return unregisterComponent(adapter.getComponentKey());\n      }\n    }\n    return null;\n  }","id":29770,"modified_method":"@Override\n  @Nullable\n  public ComponentAdapter unregisterComponentByInstance(@NotNull Object componentInstance) {\n    for (ComponentAdapter adapter : getComponentAdapters()) {\n      Object o = getInstance(adapter);\n      if (o != null && o.equals(componentInstance)) {\n        return unregisterComponent(adapter.getComponentKey());\n      }\n    }\n    return null;\n  }","commit_id":"9f24659cd7dbe973d3f5a5e35e86c12fa1449874","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private ComponentAdapter getFromCache(final Object componentKey) {\n    ComponentAdapter adapter = componentKeyToAdapterCache.get(componentKey);\n    if (adapter != null) return adapter;\n\n    if (componentKey instanceof Class) {\n      Class klass = (Class)componentKey;\n      return componentKeyToAdapterCache.get(klass.getName());\n    }\n\n    return null;\n  }","id":29771,"modified_method":"@Nullable\n  private ComponentAdapter getFromCache(final Object componentKey) {\n    ComponentAdapter adapter = componentKeyToAdapterCache.get(componentKey);\n    if (adapter != null) {\n      return adapter;\n    }\n\n    if (componentKey instanceof Class) {\n      return componentKeyToAdapterCache.get(((Class)componentKey).getName());\n    }\n\n    return null;\n  }","commit_id":"9f24659cd7dbe973d3f5a5e35e86c12fa1449874","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public <T> T lookup(String name, Class<T> type) {\n        try {\n            Object value = applicationContext.getBean(name, type);\n            return type.cast(value);\n        } catch (NoSuchBeanDefinitionException e) {\n            return null;\n        } catch (BeanNotOfRequiredTypeException e) {\n            return null;\n        }\n    }","id":29772,"modified_method":"public <T> T lookup(String name, Class<T> type) {\n        Object answer;\n        try {\n            answer = applicationContext.getBean(name, type);\n        } catch (NoSuchBeanDefinitionException e) {\n            return null;\n        } catch (BeanNotOfRequiredTypeException e) {\n            return null;\n        }\n\n        // just to be safe\n        if (answer == null) {\n            return null;\n        }\n\n        try {\n            return type.cast(answer);\n        } catch (Throwable e) {\n            String msg = \"Found bean: \" + name + \" in ApplicationContext: \" + applicationContext\n                    + \" of type: \" + answer.getClass().getName() + \" expected type was: \" + type;\n            throw new NoSuchBeanException(name, msg, e);\n        }\n    }","commit_id":"8146e08a5365c6cba3a3a4d42a32f582c1e7c74a","url":"https://github.com/apache/camel"},{"original_method":"public <T> T lookup(String name, Class<T> type) {\n        try {\n            return type.cast(blueprintContainer.getComponentInstance(name));\n        } catch (NoSuchComponentException e) {\n            return null;\n        }\n    }","id":29773,"modified_method":"public <T> T lookup(String name, Class<T> type) {\n        Object answer;\n        try {\n            answer = blueprintContainer.getComponentInstance(name);\n        } catch (NoSuchComponentException e) {\n            return null;\n        }\n\n        // just to be safe\n        if (answer == null) {\n            return null;\n        }\n\n        try {\n            return type.cast(answer);\n        } catch (Throwable e) {\n            String msg = \"Found bean: \" + name + \" in BlueprintContainer: \" + blueprintContainer\n                    + \" of type: \" + answer.getClass().getName() + \" expected type was: \" + type;\n            throw new NoSuchBeanException(name, msg, e);\n        }\n    }","commit_id":"8146e08a5365c6cba3a3a4d42a32f582c1e7c74a","url":"https://github.com/apache/camel"},{"original_method":"public <T> T lookup(String name, Class<T> type) {\n        T answer = null;\n        for (Registry registry : registryList) {\n            answer = registry.lookup(name, type);\n            if (answer != null) {\n                break;\n            }\n        }\n        return answer;\n    }","id":29774,"modified_method":"public <T> T lookup(String name, Class<T> type) {\n        T answer = null;\n        for (Registry registry : registryList) {\n            try {\n                answer = registry.lookup(name, type);\n                if (answer != null) {\n                    break;\n                }\n            } catch (Throwable e) {\n                // do not double wrap the exception\n                if (e instanceof NoSuchBeanException) {\n                    throw (NoSuchBeanException) e;\n                }\n                throw new NoSuchBeanException(name, \"Cannot lookup: \" + name + \" from registry: \" + registry\n                        + \" with expected type: \" + type + \" due: \" + e.getMessage(), e);\n            }\n        }\n        return answer;\n    }","commit_id":"8146e08a5365c6cba3a3a4d42a32f582c1e7c74a","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Creates the HttpClientConfigurer based on the given parameters\n     *\n     * @param parameters the map of parameters\n     * @param secure whether the endpoint is secure (eg https4)\n     * @return the configurer\n     */\n    protected HttpClientConfigurer createHttpClientConfigurer(Map<String, Object> parameters, boolean secure) {\n        // prefer to use endpoint configured over component configured\n        HttpClientConfigurer configurer = resolveAndRemoveReferenceParameter(parameters, \"httpClientConfigurerRef\", HttpClientConfigurer.class);\n        if (configurer == null) {\n            // try without ref\n            configurer = resolveAndRemoveReferenceParameter(parameters, \"httpClientConfigurer\", HttpClientConfigurer.class);\n            \n            if (configurer == null) {\n                // fallback to component configured\n                configurer = getHttpClientConfigurer();\n            }\n        }\n\n        configurer = configureBasicAuthentication(parameters, configurer);\n        configurer = configureHttpProxy(parameters, configurer, secure);\n\n        return configurer;\n    }","id":29775,"modified_method":"/**\n     * Creates the HttpClientConfigurer based on the given parameters\n     *\n     * @param parameters the map of parameters\n     * @param secure whether the endpoint is secure (eg https4)\n     * @return the configurer\n     * @throws Exception is thrown if error creating configurer\n     */\n    protected HttpClientConfigurer createHttpClientConfigurer(Map<String, Object> parameters, boolean secure) throws Exception {\n        // prefer to use endpoint configured over component configured\n        HttpClientConfigurer configurer = resolveAndRemoveReferenceParameter(parameters, \"httpClientConfigurerRef\", HttpClientConfigurer.class);\n        if (configurer == null) {\n            // try without ref\n            configurer = resolveAndRemoveReferenceParameter(parameters, \"httpClientConfigurer\", HttpClientConfigurer.class);\n            \n            if (configurer == null) {\n                // fallback to component configured\n                configurer = getHttpClientConfigurer();\n            }\n        }\n\n        configurer = configureBasicAuthentication(parameters, configurer);\n        configurer = configureHttpProxy(parameters, configurer, secure);\n\n        return configurer;\n    }","commit_id":"8146e08a5365c6cba3a3a4d42a32f582c1e7c74a","url":"https://github.com/apache/camel"},{"original_method":"private HttpClientConfigurer configureHttpProxy(Map<String, Object> parameters, HttpClientConfigurer configurer, boolean secure) {\n        String proxyAuthScheme = getAndRemoveParameter(parameters, \"proxyAuthScheme\", String.class);\n        if (proxyAuthScheme == null) {\n            // fallback and use either http4 or https4 depending on secure\n            proxyAuthScheme = secure ? \"https4\" : \"http4\";\n        }\n        String proxyAuthHost = getAndRemoveParameter(parameters, \"proxyAuthHost\", String.class);\n        Integer proxyAuthPort = getAndRemoveParameter(parameters, \"proxyAuthPort\", Integer.class);\n        \n        if (proxyAuthHost != null && proxyAuthPort != null) {\n            String proxyAuthUsername = getAndRemoveParameter(parameters, \"proxyAuthUsername\", String.class);\n            String proxyAuthPassword = getAndRemoveParameter(parameters, \"proxyAuthPassword\", String.class);\n            String proxyAuthDomain = getAndRemoveParameter(parameters, \"proxyAuthDomain\", String.class);\n            String proxyAuthNtHost = getAndRemoveParameter(parameters, \"proxyAuthNtHost\", String.class);\n\n            if (proxyAuthUsername != null && proxyAuthPassword != null) {\n                return CompositeHttpConfigurer.combineConfigurers(\n                    configurer, new ProxyHttpClientConfigurer(proxyAuthHost, proxyAuthPort, proxyAuthScheme, proxyAuthUsername, proxyAuthPassword, proxyAuthDomain, proxyAuthNtHost));\n            } else {\n                return CompositeHttpConfigurer.combineConfigurers(configurer, new ProxyHttpClientConfigurer(proxyAuthHost, proxyAuthPort, proxyAuthScheme));\n            }\n        }\n        \n        return configurer;\n    }","id":29776,"modified_method":"private HttpClientConfigurer configureHttpProxy(Map<String, Object> parameters, HttpClientConfigurer configurer, boolean secure) throws Exception {\n        String proxyAuthScheme = getAndRemoveParameter(parameters, \"proxyAuthScheme\", String.class);\n        if (proxyAuthScheme == null) {\n            // fallback and use either http4 or https4 depending on secure\n            proxyAuthScheme = secure ? \"https4\" : \"http4\";\n        }\n        String proxyAuthHost = getAndRemoveParameter(parameters, \"proxyAuthHost\", String.class);\n        Integer proxyAuthPort = getAndRemoveParameter(parameters, \"proxyAuthPort\", Integer.class);\n        \n        if (proxyAuthHost != null && proxyAuthPort != null) {\n            String proxyAuthUsername = getAndRemoveParameter(parameters, \"proxyAuthUsername\", String.class);\n            String proxyAuthPassword = getAndRemoveParameter(parameters, \"proxyAuthPassword\", String.class);\n            String proxyAuthDomain = getAndRemoveParameter(parameters, \"proxyAuthDomain\", String.class);\n            String proxyAuthNtHost = getAndRemoveParameter(parameters, \"proxyAuthNtHost\", String.class);\n\n            // register scheme for proxy\n            registerPort(secure, x509HostnameVerifier, proxyAuthPort, sslContextParameters);\n\n            if (proxyAuthUsername != null && proxyAuthPassword != null) {\n                return CompositeHttpConfigurer.combineConfigurers(\n                    configurer, new ProxyHttpClientConfigurer(proxyAuthHost, proxyAuthPort, proxyAuthScheme, proxyAuthUsername, proxyAuthPassword, proxyAuthDomain, proxyAuthNtHost));\n            } else {\n                return CompositeHttpConfigurer.combineConfigurers(configurer, new ProxyHttpClientConfigurer(proxyAuthHost, proxyAuthPort, proxyAuthScheme));\n            }\n        }\n        \n        return configurer;\n    }","commit_id":"8146e08a5365c6cba3a3a4d42a32f582c1e7c74a","url":"https://github.com/apache/camel"},{"original_method":"public <T> T lookup(String name, Class<T> type) {\n        Object value = lookup(name);\n        return type.cast(value);\n    }","id":29777,"modified_method":"public <T> T lookup(String name, Class<T> type) {\n        Object answer = lookup(name);\n\n        // just to be safe\n        if (answer == null) {\n            return null;\n        }\n\n        try {\n            return type.cast(answer);\n        } catch (Throwable e) {\n            String msg = \"Found bean: \" + name + \" in JNDI Context: \" + context\n                    + \" of type: \" + answer.getClass().getName() + \" expected type was: \" + type;\n            throw new NoSuchBeanException(name, msg, e);\n        }\n    }","commit_id":"8146e08a5365c6cba3a3a4d42a32f582c1e7c74a","url":"https://github.com/apache/camel"},{"original_method":"public <T> T lookup(String name, Class<T> type) {\n        Object o = lookup(name);\n        return type.cast(o);\n    }","id":29778,"modified_method":"public <T> T lookup(String name, Class<T> type) {\n        Object answer = lookup(name);\n\n        // just to be safe\n        if (answer == null) {\n            return null;\n        }\n\n        try {\n            return type.cast(answer);\n        } catch (Throwable e) {\n            String msg = \"Found bean: \" + name + \" in SimpleRegistry: \" + this\n                    + \" of type: \" + answer.getClass().getName() + \" expected type was: \" + type;\n            throw new NoSuchBeanException(name, msg, e);\n        }\n    }","commit_id":"8146e08a5365c6cba3a3a4d42a32f582c1e7c74a","url":"https://github.com/apache/camel"},{"original_method":"public void testLookupByNameAndWrongType() {\n        try {\n            registry.lookup(\"a\", Float.class);\n            fail();\n        } catch (ClassCastException e) {\n            // expected\n        }\n    }","id":29779,"modified_method":"public void testLookupByNameAndWrongType() {\n        try {\n            registry.lookup(\"a\", Float.class);\n            fail();\n        } catch (NoSuchBeanException e) {\n            // expected\n            assertEquals(\"a\", e.getName());\n            assertTrue(e.getMessage().endsWith(\"of type: java.lang.String expected type was: class java.lang.Float\"));\n        }\n    }","commit_id":"8146e08a5365c6cba3a3a4d42a32f582c1e7c74a","url":"https://github.com/apache/camel"},{"original_method":"private void installEP(final ExtensionPointName<ServiceDescriptor> pointName, final ComponentManager componentManager) {\n    myExtensionPointName = pointName;\n    final ExtensionPoint<ServiceDescriptor> extensionPoint = Extensions.getArea(null).getExtensionPoint(pointName);\n    assert extensionPoint != null;\n\n    final MutablePicoContainer picoContainer = (MutablePicoContainer)componentManager.getPicoContainer();\n\n    myExtensionPointListener = new ExtensionPointListener<ServiceDescriptor>() {\n      public void extensionAdded(final ServiceDescriptor descriptor, final PluginDescriptor pluginDescriptor) {\n        picoContainer.registerComponent(new MyComponentAdapter(descriptor, pluginDescriptor));\n      }\n\n      public void extensionRemoved(final ServiceDescriptor extension, final PluginDescriptor pluginDescriptor) {\n        picoContainer.unregisterComponent(extension.getServiceInterface());\n      }\n    };\n    extensionPoint.addExtensionPointListener(myExtensionPointListener);\n  }","id":29780,"modified_method":"private void installEP(final ExtensionPointName<ServiceDescriptor> pointName, final ComponentManager componentManager) {\n    myExtensionPointName = pointName;\n    final ExtensionPoint<ServiceDescriptor> extensionPoint = Extensions.getArea(null).getExtensionPoint(pointName);\n    assert extensionPoint != null;\n\n    final MutablePicoContainer picoContainer = (MutablePicoContainer)componentManager.getPicoContainer();\n\n    myExtensionPointListener = new ExtensionPointListener<ServiceDescriptor>() {\n      public void extensionAdded(final ServiceDescriptor descriptor, final PluginDescriptor pluginDescriptor) {\n        picoContainer.registerComponent(new MyComponentAdapter(descriptor, pluginDescriptor, componentManager));\n      }\n\n      public void extensionRemoved(final ServiceDescriptor extension, final PluginDescriptor pluginDescriptor) {\n        picoContainer.unregisterComponent(extension.getServiceInterface());\n      }\n    };\n    extensionPoint.addExtensionPointListener(myExtensionPointListener);\n  }","commit_id":"a6a7c8bc5e785f5797b8a0e83400a591c6093bde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MyComponentAdapter(final ServiceDescriptor descriptor, final PluginDescriptor pluginDescriptor) {\n      myDescriptor = descriptor;\n      myPluginDescriptor = pluginDescriptor;\n      myDelegate = null;\n    }","id":29781,"modified_method":"public MyComponentAdapter(final ServiceDescriptor descriptor, final PluginDescriptor pluginDescriptor, ComponentManager componentManager) {\n      myDescriptor = descriptor;\n      myPluginDescriptor = pluginDescriptor;\n      myComponentManager = componentManager;\n      myDelegate = null;\n    }","commit_id":"a6a7c8bc5e785f5797b8a0e83400a591c6093bde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object getComponentInstance(final PicoContainer container) throws PicoInitializationException, PicoIntrospectionException {\n      return getDelegate().getComponentInstance(container);\n    }","id":29782,"modified_method":"public Object getComponentInstance(final PicoContainer container) throws PicoInitializationException, PicoIntrospectionException {\n      final Object componentInstance = getDelegate().getComponentInstance(container);\n\n      if (!myRegisteredInDisposer) {\n        if (componentInstance instanceof Disposable) {\n          Disposer.register(myComponentManager, (Disposable)componentInstance);\n        }\n        myRegisteredInDisposer = true;\n      }\n\n      return componentInstance;\n    }","commit_id":"a6a7c8bc5e785f5797b8a0e83400a591c6093bde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            // Is there a consumer registered for the request.\n            HttpConsumer consumer = resolve(request);\n            if (consumer == null) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n\n            final Continuation continuation = ContinuationSupport.getContinuation(request, null);\n            if (continuation.isNew()) {\n\n                // Have the camel process the HTTP exchange.\n                // final HttpExchange exchange = new HttpExchange(consumer.getEndpoint(), request, response);\n                // boolean sync = consumer.getAsyncProcessor().process(exchange, new AsyncCallback() {\n                //     public void done(boolean sync) {\n                //        if (sync) {\n                //            return;\n                //        }\n                //        continuation.setObject(exchange);\n                //        continuation.resume();\n                //    }\n                //});\n\n                //if (!sync) {\n                    // Wait for the exchange to get processed.\n                    // This might block until it completes or it might return via an exception and\n                    // then this method is re-invoked once the the exchange has finished processing\n                //    continuation.suspend(0);\n                //}\n\n                // HC: The getBinding() is interesting because it illustrates the\n                // impedance miss-match between HTTP's stream oriented protocol, and\n                // Camels more message oriented protocol exchanges.\n\n                // now lets output to the response\n                //consumer.getBinding().writeResponse(exchange, response);\n                return;\n            }\n\n            if (continuation.isResumed()) {\n                HttpExchange exchange = (HttpExchange)continuation.getObject();\n                // now lets output to the response\n                consumer.getBinding().writeResponse(exchange, response);\n                return;\n            }\n\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }","id":29783,"modified_method":"@Override\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            // Is there a consumer registered for the request.\n            HttpConsumer consumer = resolve(request);\n            if (consumer == null) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n\n            final Continuation continuation = ContinuationSupport.getContinuation(request, null);\n            if (continuation.isNew()) {\n                // Have the camel process the HTTP exchange.\n                // final DefaultExchange exchange = new DefaultExchange(consumer.getEndpoint(), ExchangePattern.InOut);\n                // exchange.setProperty(HttpConstants.SERVLET_REQUEST, request);\n                // exchange.setProperty(HttpConstants.SERVLET_RESPONSE, response);\n                // exchange.setIn(new HttpMessage(exchange, request));\n                // boolean sync = consumer.getAsyncProcessor().process(exchange, new AsyncCallback() {\n                //     public void done(boolean sync) {\n                //        if (sync) {\n                //            return;\n                //        }\n                //        continuation.setObject(exchange);\n                //        continuation.resume();\n                //    }\n                //});\n\n                //if (!sync) {\n                    // Wait for the exchange to get processed.\n                    // This might block until it completes or it might return via an exception and\n                    // then this method is re-invoked once the the exchange has finished processing\n                //    continuation.suspend(0);\n                //}\n\n                // HC: The getBinding() is interesting because it illustrates the\n                // impedance miss-match between HTTP's stream oriented protocol, and\n                // Camels more message oriented protocol exchanges.\n\n                // now lets output to the response\n                //consumer.getBinding().writeResponse(exchange, response);\n                return;\n            }\n\n            if (continuation.isResumed()) {\n                Exchange exchange = (Exchange)continuation.getObject();\n                // now lets output to the response\n                consumer.getBinding().writeResponse(exchange, response);\n                return;\n            }\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n\n            // Is there a consumer registered for the request.\n            HttpConsumer consumer = resolve(request);\n            if (consumer == null) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n\n            // Have the camel process the HTTP exchange.\n            HttpExchange exchange = new HttpExchange(consumer.getEndpoint(), request, response);\n            consumer.getProcessor().process(exchange);\n\n            // HC: The getBinding() is interesting because it illustrates the\n            // impedance miss-match between\n            // HTTP's stream oriented protocol, and Camels more message oriented\n            // protocol exchanges.\n\n            // now lets output to the response\n            consumer.getBinding().writeResponse(exchange, response);\n\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }","id":29784,"modified_method":"@Override\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n\n            // Is there a consumer registered for the request.\n            HttpConsumer consumer = resolve(request);\n            if (consumer == null) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n\n            // Have the camel process the HTTP exchange.\n            DefaultExchange exchange = new DefaultExchange(consumer.getEndpoint(), ExchangePattern.InOut);\n            exchange.setProperty(HttpConstants.SERVLET_REQUEST, request);\n            exchange.setProperty(HttpConstants.SERVLET_RESPONSE, response);\n            exchange.setIn(new HttpMessage(exchange, request));\n            consumer.getProcessor().process(exchange);\n\n            // HC: The getBinding() is interesting because it illustrates the\n            // impedance miss-match between\n            // HTTP's stream oriented protocol, and Camels more message oriented\n            // protocol exchanges.\n\n            // now lets output to the response\n            consumer.getBinding().writeResponse(exchange, response);\n\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"public void writeResponse(HttpExchange exchange, HttpServletResponse response) throws IOException {\n        if (exchange.isFailed()) {\n            if (exchange.hasFault()) {\n                doWriteFaultResponse(exchange.getFault(), response, exchange);\n            } else {\n                doWriteExceptionResponse(exchange.getException(), response);\n            }\n        } else {\n            // just copy the protocol relates header\n            copyProtocolHeaders(exchange.getIn(), exchange.getOut());\n            Message out = exchange.getOut();            \n            if (out != null) {\n                doWriteResponse(out, response, exchange);\n            }\n        }\n    }","id":29785,"modified_method":"public void writeResponse(Exchange exchange, HttpServletResponse response) throws IOException {\n        if (exchange.isFailed()) {\n            if (exchange.hasFault()) {\n                doWriteFaultResponse(exchange.getFault(), response, exchange);\n            } else {\n                doWriteExceptionResponse(exchange.getException(), response);\n            }\n        } else {\n            // just copy the protocol relates header\n            copyProtocolHeaders(exchange.getIn(), exchange.getOut());\n            Message out = exchange.getOut();            \n            if (out != null) {\n                doWriteResponse(out, response, exchange);\n            }\n        }\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"public HttpExchange createExchange(HttpServletRequest request, HttpServletResponse response) {\n        return new HttpExchange(this, request, response);\n    }","id":29786,"modified_method":"public Exchange createExchange(HttpServletRequest request, HttpServletResponse response) {\n        DefaultExchange exchange = new DefaultExchange(this, ExchangePattern.InOut);\n        exchange.setProperty(HttpConstants.SERVLET_REQUEST, request);\n        exchange.setProperty(HttpConstants.SERVLET_RESPONSE, response);\n        exchange.setIn(new HttpMessage(exchange, request));\n        return exchange;\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"public Exchange createExchange(ExchangePattern pattern) {\n        return new HttpExchange(this, pattern);\n    }","id":29787,"modified_method":"public Exchange createExchange(ExchangePattern pattern) {\n        return new DefaultExchange(this, pattern);\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected Object createBody() {\n        try {\n            return getExchange().getEndpoint().getBinding().parseBody(this);\n        } catch (IOException e) {\n            throw new RuntimeCamelException(e);\n        }\n    }","id":29788,"modified_method":"@Override\n    protected Object createBody() {\n        try {\n            return getEndpoint().getBinding().parseBody(this);\n        } catch (IOException e) {\n            throw new RuntimeCamelException(e);\n        }\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"public HttpMessage(HttpExchange exchange, HttpServletRequest request) {\n        setExchange(exchange);\n        this.request = request;\n\n        // use binding to read the request allowing end users to use their\n        // implementation of the binding\n        getExchange().getEndpoint().getBinding().readRequest(request, this);\n    }","id":29789,"modified_method":"public HttpMessage(Exchange exchange, HttpServletRequest request) {\n        setExchange(exchange);\n        this.request = request;\n\n        // use binding to read the request allowing end users to use their\n        // implementation of the binding\n        getEndpoint().getBinding().readRequest(request, this);\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"public Exchange receiveNoWait() {\n        HttpExchange exchange = (HttpExchange) endpoint.createExchange();\n        HttpMethod method = createMethod();\n\n        try {\n            int responseCode = httpClient.executeMethod(method);\n            // lets store the result in the output message.\n            LoadingByteArrayOutputStream bos = new LoadingByteArrayOutputStream();\n            InputStream is = method.getResponseBodyAsStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n            } finally {\n                is.close();\n            }\n            Message message = exchange.getIn();\n            message.setBody(bos.createInputStream());\n\n            // lets set the headers\n            Header[] headers = method.getResponseHeaders();\n            HeaderFilterStrategy strategy = endpoint.getHeaderFilterStrategy();\n            for (Header header : headers) {\n                String name = header.getName();\n                String value = header.getValue();\n                if (strategy != null && !strategy.applyFilterToExternalHeaders(name, value, exchange)) {\n                    message.setHeader(name, value);\n                }\n            }\n        \n            message.setHeader(Exchange.HTTP_RESPONSE_CODE, responseCode);\n            return exchange;\n        } catch (IOException e) {\n            throw new RuntimeCamelException(e);\n        } finally {\n            method.releaseConnection();\n        }\n    }","id":29790,"modified_method":"public Exchange receiveNoWait() {\n        Exchange exchange = endpoint.createExchange();\n        HttpMethod method = createMethod();\n\n        try {\n            int responseCode = httpClient.executeMethod(method);\n            // lets store the result in the output message.\n            LoadingByteArrayOutputStream bos = new LoadingByteArrayOutputStream();\n            InputStream is = method.getResponseBodyAsStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n            } finally {\n                is.close();\n            }\n            Message message = exchange.getIn();\n            message.setBody(bos.createInputStream());\n\n            // lets set the headers\n            Header[] headers = method.getResponseHeaders();\n            HeaderFilterStrategy strategy = endpoint.getHeaderFilterStrategy();\n            for (Header header : headers) {\n                String name = header.getName();\n                String value = header.getValue();\n                if (strategy != null && !strategy.applyFilterToExternalHeaders(name, value, exchange)) {\n                    message.setHeader(name, value);\n                }\n            }\n        \n            message.setHeader(Exchange.HTTP_RESPONSE_CODE, responseCode);\n            return exchange;\n        } catch (IOException e) {\n            throw new RuntimeCamelException(e);\n        } finally {\n            method.releaseConnection();\n        }\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testNoDataDefaultIsGet() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", null);\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(null);\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29791,"modified_method":"@Test\n    public void testNoDataDefaultIsGet() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", null);\n\n        Exchange exchange = producer.createExchange();\n        exchange.getIn().setBody(null);\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWithQueryInHeaderOverrideEndpoint() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com?q=Donkey\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", \"q=Camel\");\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(Exchange.HTTP_QUERY, \"q=Camel\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29792,"modified_method":"@Test\n    public void testWithQueryInHeaderOverrideEndpoint() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com?q=Donkey\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", \"q=Camel\");\n\n        Exchange exchange = producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(Exchange.HTTP_QUERY, \"q=Camel\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testDataDefaultIsPost() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"POST\", null);\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(\"This is some data to post\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29793,"modified_method":"@Test\n    public void testDataDefaultIsPost() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"POST\", null);\n\n        Exchange exchange = producer.createExchange();\n        exchange.getIn().setBody(\"This is some data to post\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWithEndpointQuery() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com?q=Camel\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", \"q=Camel\");\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29794,"modified_method":"@Test\n    public void testWithEndpointQuery() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com?q=Camel\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", \"q=Camel\");\n\n        Exchange exchange = producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWithMethodPostInHeader() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"POST\", null);\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(Exchange.HTTP_METHOD, POST);\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29795,"modified_method":"@Test\n    public void testWithMethodPostInHeader() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"POST\", null);\n\n        Exchange exchange = producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(Exchange.HTTP_METHOD, POST);\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWithQueryInHeader() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", \"q=Camel\");\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(Exchange.HTTP_QUERY, \"q=Camel\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29796,"modified_method":"@Test\n    public void testWithQueryInHeader() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", \"q=Camel\");\n\n        Exchange exchange = producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(Exchange.HTTP_QUERY, \"q=Camel\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWithMethodGetInHeader() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", null);\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(Exchange.HTTP_METHOD, GET);\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29797,"modified_method":"@Test\n    public void testWithMethodGetInHeader() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", null);\n\n        Exchange exchange = producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(Exchange.HTTP_METHOD, GET);\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() {\n                // enable strem cache\n                context.setStreamCaching(true);\n\n                from(\"jetty:http://localhost:9080/test\").to(\"mock:a\");\n\n                Processor proc = new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        try {\n                            HttpSession session =\n                                ((HttpExchange)exchange).getRequest().getSession();\n                            assertNotNull(\"we should get session here\", session);\n                        } catch (Exception e) {\n                            exchange.getFault().setBody(e);\n                        }\n                        exchange.getOut().setBody(\"<b>Hello World<\/b>\");\n                    }\n                };\n                \n                Processor printProcessor = new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        Message out = exchange.getOut();\n                        out.copyFrom(exchange.getIn());\n                        log.info(\"The body's object is \" + exchange.getIn().getBody());\n                        log.info(\"Process body = \" + exchange.getIn().getBody(String.class));\n                        InputStreamCache cache = out.getBody(InputStreamCache.class);\n                        cache.reset();\n                    }               \n                };\n                from(\"jetty:http://localhost:9080/hello?sessionSupport=true\").process(proc);\n                \n                from(\"jetty:http://localhost:9080/echo\").process(printProcessor).process(printProcessor);\n            }\n        };\n    }","id":29798,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() {\n                // enable strem cache\n                context.setStreamCaching(true);\n\n                from(\"jetty:http://localhost:9080/test\").to(\"mock:a\");\n\n                Processor proc = new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        try {\n                            HttpServletRequest request = (HttpServletRequest)\n                                exchange.getProperty(HttpConstants.SERVLET_REQUEST);\n                            HttpSession session = request.getSession();\n                            assertNotNull(\"we should get session here\", session);\n                        } catch (Exception e) {\n                            exchange.getFault().setBody(e);\n                        }\n                        exchange.getOut().setBody(\"<b>Hello World<\/b>\");\n                    }\n                };\n                \n                Processor printProcessor = new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        Message out = exchange.getOut();\n                        out.copyFrom(exchange.getIn());\n                        log.info(\"The body's object is \" + exchange.getIn().getBody());\n                        log.info(\"Process body = \" + exchange.getIn().getBody(String.class));\n                        InputStreamCache cache = out.getBody(InputStreamCache.class);\n                        cache.reset();\n                    }               \n                };\n                from(\"jetty:http://localhost:9080/hello?sessionSupport=true\").process(proc);\n                \n                from(\"jetty:http://localhost:9080/echo\").process(printProcessor).process(printProcessor);\n            }\n        };\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {\n            HttpExchange http = (HttpExchange) exchange;\n            Assert.assertNotNull(http.getRequest());\n            Assert.assertEquals(\"uno\", http.getRequest().getParameter(\"one\"));\n            Assert.assertEquals(\"dos\", http.getRequest().getParameter(\"two\"));\n\n            exchange.getOut().setBody(\"Bye World\");\n            exchange.getOut().setHeader(\"one\", \"einz\");\n            exchange.getOut().setHeader(\"two\", \"twei\");\n        }","id":29799,"modified_method":"public void process(Exchange exchange) throws Exception {\n            HttpServletRequest request = (HttpServletRequest)\n                exchange.getProperty(HttpConstants.SERVLET_REQUEST);\n            Assert.assertNotNull(request);\n            Assert.assertEquals(\"uno\", request.getParameter(\"one\"));\n            Assert.assertEquals(\"dos\", request.getParameter(\"two\"));\n\n            exchange.getOut().setBody(\"Bye World\");\n            exchange.getOut().setHeader(\"one\", \"eins\");\n            exchange.getOut().setHeader(\"two\", \"zwei\");\n        }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testHttpGetWithParamsViaHeader() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Bye World\");\n        mock.expectedHeaderReceived(\"one\", \"einz\");\n        mock.expectedHeaderReceived(\"two\", \"twei\");\n\n        template.requestBodyAndHeader(serverUri, \"Hello World\", Exchange.HTTP_QUERY, \"one=uno&two=dos\");\n\n        assertMockEndpointsSatisfied();\n    }","id":29800,"modified_method":"@Test\n    public void testHttpGetWithParamsViaHeader() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Bye World\");\n        mock.expectedHeaderReceived(\"one\", \"eins\");\n        mock.expectedHeaderReceived(\"two\", \"zwei\");\n\n        template.requestBodyAndHeader(serverUri, \"Hello World\", Exchange.HTTP_QUERY, \"one=uno&two=dos\");\n\n        assertMockEndpointsSatisfied();\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testHttpGetWithParamsViaURI() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Bye World\");\n        mock.expectedHeaderReceived(\"one\", \"einz\");\n        mock.expectedHeaderReceived(\"two\", \"twei\");\n\n        template.requestBody(serverUri + \"?one=uno&two=dos\", \"Hello World\");\n\n        assertMockEndpointsSatisfied();\n    }","id":29801,"modified_method":"@Test\n    public void testHttpGetWithParamsViaURI() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Bye World\");\n        mock.expectedHeaderReceived(\"one\", \"eins\");\n        mock.expectedHeaderReceived(\"two\", \"zwei\");\n\n        template.requestBody(serverUri + \"?one=uno&two=dos\", \"Hello World\");\n\n        assertMockEndpointsSatisfied();\n    }","commit_id":"2d506015b56874299f8ba7127d94fe63c2287dca","url":"https://github.com/apache/camel"},{"original_method":"public boolean send(Message<?> message) throws MessageRejectedException, MessageDeliveryException {\n        ExchangePattern pattern;\n        boolean result = false;\n        if (isExpectReply()) {\n            pattern = ExchangePattern.InOut;\n        } else {\n            pattern = ExchangePattern.InOnly;\n        }\n        Exchange inExchange = new SpringIntegrationExchange(this, pattern);        \n        SpringIntegrationBinding.storeToCamelMessage(message, inExchange.getIn());\n        Exchange outExchange = getCamelTemplate().send(getCamelEndpointUri(), inExchange);\n        if (outExchange.getFault() != null) {\n            result = true;\n        }\n        Message response = null;\n        if (isExpectReply()) {\n            //Check the message header for the return address\n            response = SpringIntegrationBinding.storeToSpringIntegrationMessage(outExchange.getOut());\n            if (replyChannel == null) {\n                MessageChannel messageReplyChannel = (MessageChannel) message.getHeaders().get(MessageHeaders.REPLY_CHANNEL);\n                if (messageReplyChannel != null) {\n                    result = messageReplyChannel.send(response);\n                } else {\n                    throw new MessageDeliveryException(response, \"Can't find reply channel from the CamelTargetAdapter or MessageHeaders\");\n                }\n            } else {\n                result = replyChannel.send(response);\n            }\n        }\n        return result;\n    }","id":29802,"modified_method":"public boolean send(Message<?> message) throws MessageRejectedException, MessageDeliveryException {\n        ExchangePattern pattern;\n        boolean result = false;\n        if (isExpectReply()) {\n            pattern = ExchangePattern.InOut;\n        } else {\n            pattern = ExchangePattern.InOnly;\n        }\n        Exchange inExchange = new DefaultExchange(getCamelContext(), pattern);        \n        SpringIntegrationBinding.storeToCamelMessage(message, inExchange.getIn());\n        Exchange outExchange = getCamelTemplate().send(getCamelEndpointUri(), inExchange);\n        if (outExchange.getFault() != null) {\n            result = true;\n        }\n        Message response = null;\n        if (isExpectReply()) {\n            //Check the message header for the return address\n            response = SpringIntegrationBinding.storeToSpringIntegrationMessage(outExchange.getOut());\n            if (replyChannel == null) {\n                MessageChannel messageReplyChannel = (MessageChannel) message.getHeaders().get(MessageHeaders.REPLY_CHANNEL);\n                if (messageReplyChannel != null) {\n                    result = messageReplyChannel.send(response);\n                } else {\n                    throw new MessageDeliveryException(response, \"Can't find reply channel from the CamelTargetAdapter or MessageHeaders\");\n                }\n            } else {\n                result = replyChannel.send(response);\n            }\n        }\n        return result;\n    }","commit_id":"19748ab2148b11e1925b87bfd07a537a4840c720","url":"https://github.com/apache/camel"},{"original_method":"public void handleMessage(org.springframework.integration.core.Message<?> siInMessage) {        \n        SpringIntegrationExchange  exchange = (SpringIntegrationExchange) getEndpoint().createExchange();\n        exchange.setIn(new SpringIntegrationMessage(siInMessage));\n        try {\n            getProcessor().process(exchange);\n        } catch (Exception e) {\n            //TODO need to find a way to deal with this exception\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n        if (endpoint.isInOut()) {\n            // get the output channel from message header\n            Object returnAddress = siInMessage.getHeaders().getReplyChannel();\n            MessageChannel reply = null;\n\n            if (returnAddress != null) {\n                if (returnAddress instanceof String) {\n                    reply = (MessageChannel)context.getApplicationContext().getBean((String)returnAddress);\n                } else if (returnAddress instanceof MessageChannel) {\n                    reply = (MessageChannel) returnAddress;\n                }\n            } else {\n                if (outputChannel != null) {\n                    // using the outputChannel\n                    reply = outputChannel;\n                } else {\n                    if (ObjectHelper.isEmpty(endpoint.getOutputChannel())) {\n                        outputChannel = (MessageChannel) channelResolver.resolveChannelName(endpoint.getOutputChannel());\n                        ObjectHelper.notNull(inputChannel, \"The outputChannel with the name [\" + endpoint.getOutputChannel() + \"]\");\n                        reply = outputChannel;\n                    } else {\n                        throw new RuntimeCamelException(\"Can't find the right outputChannelName\");\n                    }\n                }\n            }\n            // put the message back the outputChannel if we need\n            org.springframework.integration.core.Message siOutMessage =\n                SpringIntegrationBinding.storeToSpringIntegrationMessage(exchange.getOut());\n            reply.send(siOutMessage);\n        }        \n    }","id":29803,"modified_method":"public void handleMessage(org.springframework.integration.core.Message<?> siInMessage) {        \n        Exchange  exchange = getEndpoint().createExchange();\n        exchange.setIn(new SpringIntegrationMessage(siInMessage));\n        try {\n            getProcessor().process(exchange);\n        } catch (Exception e) {\n            //TODO need to find a way to deal with this exception\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n        if (endpoint.isInOut()) {\n            // get the output channel from message header\n            Object returnAddress = siInMessage.getHeaders().getReplyChannel();\n            MessageChannel reply = null;\n\n            if (returnAddress != null) {\n                if (returnAddress instanceof String) {\n                    reply = (MessageChannel)context.getApplicationContext().getBean((String)returnAddress);\n                } else if (returnAddress instanceof MessageChannel) {\n                    reply = (MessageChannel) returnAddress;\n                }\n            } else {\n                if (outputChannel != null) {\n                    // using the outputChannel\n                    reply = outputChannel;\n                } else {\n                    if (ObjectHelper.isEmpty(endpoint.getOutputChannel())) {\n                        outputChannel = (MessageChannel) channelResolver.resolveChannelName(endpoint.getOutputChannel());\n                        ObjectHelper.notNull(inputChannel, \"The outputChannel with the name [\" + endpoint.getOutputChannel() + \"]\");\n                        reply = outputChannel;\n                    } else {\n                        throw new RuntimeCamelException(\"Can't find the right outputChannelName\");\n                    }\n                }\n            }\n            // put the message back the outputChannel if we need\n            org.springframework.integration.core.Message siOutMessage =\n                SpringIntegrationBinding.storeToSpringIntegrationMessage(exchange.getOut());\n            reply.send(siOutMessage);\n        }        \n    }","commit_id":"19748ab2148b11e1925b87bfd07a537a4840c720","url":"https://github.com/apache/camel"},{"original_method":"public Exchange createExchange(ExchangePattern pattern) {\n        return new SpringIntegrationExchange(this, pattern);\n    }","id":29804,"modified_method":"public Exchange createExchange(ExchangePattern pattern) {\n        return new DefaultExchange(this, pattern);\n    }","commit_id":"19748ab2148b11e1925b87bfd07a537a4840c720","url":"https://github.com/apache/camel"},{"original_method":"public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (!isStarted()) {\n            throw new IllegalStateException(\"The endpoint is not active: \" + getEndpoint().getEndpointUri());\n        }\n        BeanInvocation invocation = new BeanInvocation(method, args);\n        BeanExchange exchange = (BeanExchange) getEndpoint().createExchange();\n        exchange.setInvocation(invocation);\n        getProcessor().process(exchange);\n        Throwable fault = exchange.getException();\n        if (fault != null) {\n            throw new InvocationTargetException(fault);\n        }\n        return exchange.getOut().getBody();\n    }","id":29805,"modified_method":"public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (!isStarted()) {\n            throw new IllegalStateException(\"The endpoint is not active: \" + getEndpoint().getEndpointUri());\n        }\n        BeanInvocation invocation = new BeanInvocation(method, args);\n        Exchange exchange = getEndpoint().createExchange();\n        exchange.getIn().setBody(invocation);\n        getProcessor().process(exchange);\n        Throwable fault = exchange.getException();\n        if (fault != null) {\n            throw new InvocationTargetException(fault);\n        }\n        return exchange.getOut().getBody();\n    }","commit_id":"14cb8d5be24c74b16acda202aaacd37f67607c02","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Exchange createExchange(ExchangePattern pattern) {\n        return new BeanExchange(getCamelContext(), pattern);\n    }","id":29806,"modified_method":"@Override\n    public Exchange createExchange(ExchangePattern pattern) {\n        return new DefaultExchange(getCamelContext(), pattern);\n    }","commit_id":"14cb8d5be24c74b16acda202aaacd37f67607c02","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public void onFailure(Exchange exchange) {\n        onCompletion((GenericFileExchange<T>) exchange);\n    }","id":29807,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public void onFailure(Exchange exchange) {\n        onCompletion(exchange);\n    }","commit_id":"76502c12a585dd0c3f7a7ea92a4bd938e3a0811b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Strategy when the file was not processed and a rollback should be executed.\n     *\n     * @param processStrategy the strategy to perform the commit\n     * @param exchange        the exchange\n     * @param file            the file processed\n     */\n    protected void processStrategyRollback(GenericFileProcessStrategy<T> processStrategy,\n                                           GenericFileExchange<T> exchange, GenericFile<T> file) {\n        if (log.isWarnEnabled()) {\n            log.warn(\"Rolling back remote file strategy: \" + processStrategy + \" for file: \" + file);\n        }\n        try {\n            processStrategy.rollback(operations, endpoint, exchange, file);\n        } catch (Exception e) {\n            handleException(e);\n        }\n    }","id":29808,"modified_method":"/**\n     * Strategy when the file was not processed and a rollback should be executed.\n     *\n     * @param processStrategy the strategy to perform the commit\n     * @param exchange        the exchange\n     * @param file            the file processed\n     */\n    protected void processStrategyRollback(GenericFileProcessStrategy<T> processStrategy,\n                                           Exchange exchange, GenericFile<T> file) {\n        if (log.isWarnEnabled()) {\n            log.warn(\"Rolling back remote file strategy: \" + processStrategy + \" for file: \" + file);\n        }\n        try {\n            processStrategy.rollback(operations, endpoint, exchange, file);\n        } catch (Exception e) {\n            handleException(e);\n        }\n    }","commit_id":"76502c12a585dd0c3f7a7ea92a4bd938e3a0811b","url":"https://github.com/apache/camel"},{"original_method":"protected void onCompletion(GenericFileExchange<T> exchange) {\n        GenericFileProcessStrategy<T> processStrategy = endpoint.getGenericFileProcessStrategy();\n\n        // after processing\n        final GenericFile<T> file = exchange.getGenericFile();\n        boolean failed = exchange.isFailed();\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Done processing file: \" + file + \" using exchange: \" + exchange);\n        }\n\n        // commit or rollback\n        boolean committed = false;\n        try {\n            if (!failed) {\n                // commit the file strategy if there was no failure or already handled by the DeadLetterChannel\n                processStrategyCommit(processStrategy, exchange, file);\n                committed = true;\n            } else {\n                if (exchange.getException() != null) {\n                    // if the failure was an exception then handle it\n                    handleException(exchange.getException());\n                }\n            }\n        } finally {\n            if (!committed) {\n                processStrategyRollback(processStrategy, exchange, file);\n            }\n\n            // remove file from the in progress list as its no longer in progress\n            endpoint.getInProgressRepository().remove(file.getFileName());\n        }\n    }","id":29809,"modified_method":"protected void onCompletion(Exchange exchange) {\n        GenericFileProcessStrategy<T> processStrategy = endpoint.getGenericFileProcessStrategy();\n\n        // after processing\n        final GenericFile<T> file = (GenericFile<T>) exchange.getProperty(FileComponent.FILE_EXCHANGE_FILE);\n        boolean failed = exchange.isFailed();\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Done processing file: \" + file + \" using exchange: \" + exchange);\n        }\n\n        // commit or rollback\n        boolean committed = false;\n        try {\n            if (!failed) {\n                // commit the file strategy if there was no failure or already handled by the DeadLetterChannel\n                processStrategyCommit(processStrategy, exchange, file);\n                committed = true;\n            } else {\n                if (exchange.getException() != null) {\n                    // if the failure was an exception then handle it\n                    handleException(exchange.getException());\n                }\n            }\n        } finally {\n            if (!committed) {\n                processStrategyRollback(processStrategy, exchange, file);\n            }\n\n            // remove file from the in progress list as its no longer in progress\n            endpoint.getInProgressRepository().remove(file.getFileName());\n        }\n    }","commit_id":"76502c12a585dd0c3f7a7ea92a4bd938e3a0811b","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public void onComplete(Exchange exchange) {\n        onCompletion((GenericFileExchange<T>) exchange);\n    }","id":29810,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public void onComplete(Exchange exchange) {\n        onCompletion(exchange);\n    }","commit_id":"76502c12a585dd0c3f7a7ea92a4bd938e3a0811b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Strategy when the file was processed and a commit should be executed.\n     *\n     * @param processStrategy the strategy to perform the commit\n     * @param exchange        the exchange\n     * @param file            the file processed\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy,\n                                         GenericFileExchange<T> exchange, GenericFile<T> file) {\n        if (endpoint.isIdempotent()) {\n            // only add to idempotent repository if we could process the file\n            // only use the filename as the key as the file could be moved into a done folder\n            endpoint.getIdempotentRepository().add(file.getFileName());\n        }\n\n        try {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Committing remote file strategy: \" + processStrategy + \" for file: \" + file);\n            }\n            processStrategy.commit(operations, endpoint, exchange, file);\n        } catch (Exception e) {\n            handleException(e);\n        }\n    }","id":29811,"modified_method":"/**\n     * Strategy when the file was processed and a commit should be executed.\n     *\n     * @param processStrategy the strategy to perform the commit\n     * @param exchange        the exchange\n     * @param file            the file processed\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy,\n                                         Exchange exchange, GenericFile<T> file) {\n        if (endpoint.isIdempotent()) {\n            // only add to idempotent repository if we could process the file\n            // only use the filename as the key as the file could be moved into a done folder\n            endpoint.getIdempotentRepository().add(file.getFileName());\n        }\n\n        try {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Committing remote file strategy: \" + processStrategy + \" for file: \" + file);\n            }\n            processStrategy.commit(operations, endpoint, exchange, file);\n        } catch (Exception e) {\n            handleException(e);\n        }\n    }","commit_id":"76502c12a585dd0c3f7a7ea92a4bd938e3a0811b","url":"https://github.com/apache/camel"},{"original_method":"protected void writeFile(GenericFileExchange<T> exchange, String fileName) throws GenericFileOperationFailedException {\n        InputStream payload = exchange.getIn().getBody(InputStream.class);\n        try {\n            // build directory if auto create is enabled\n            if (endpoint.isAutoCreate()) {\n                // use java.io.File to compute the file path\n                File file = new File(fileName);\n                String directory = file.getParent();\n                boolean absolute = file.isAbsolute();\n                if (directory != null) {\n                    if (!operations.buildDirectory(directory, absolute)) {\n                        log.debug(\"Cannot build directory [\" + directory + \"] (could be because of denied permissions)\");\n                    }\n                }\n            }\n\n            // upload\n            if (log.isTraceEnabled()) {\n                log.trace(\"About to write [\" + fileName + \"] to [\" + getEndpoint() + \"] from exchange [\" + exchange + \"]\");\n            }\n\n            boolean success = operations.storeFile(fileName, exchange);\n            if (!success) {\n                throw new GenericFileOperationFailedException(\"Error writing file [\" + fileName + \"]\");\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"Wrote [\" + fileName + \"] to [\" + getEndpoint() + \"]\");\n            }\n\n        } finally {\n            ObjectHelper.close(payload, \"Closing payload\", log);\n        }\n\n    }","id":29812,"modified_method":"protected void writeFile(Exchange exchange, String fileName) throws GenericFileOperationFailedException {\n        InputStream payload = exchange.getIn().getBody(InputStream.class);\n        try {\n            // build directory if auto create is enabled\n            if (endpoint.isAutoCreate()) {\n                // use java.io.File to compute the file path\n                File file = new File(fileName);\n                String directory = file.getParent();\n                boolean absolute = file.isAbsolute();\n                if (directory != null) {\n                    if (!operations.buildDirectory(directory, absolute)) {\n                        log.debug(\"Cannot build directory [\" + directory + \"] (could be because of denied permissions)\");\n                    }\n                }\n            }\n\n            // upload\n            if (log.isTraceEnabled()) {\n                log.trace(\"About to write [\" + fileName + \"] to [\" + getEndpoint() + \"] from exchange [\" + exchange + \"]\");\n            }\n\n            boolean success = operations.storeFile(fileName, exchange);\n            if (!success) {\n                throw new GenericFileOperationFailedException(\"Error writing file [\" + fileName + \"]\");\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"Wrote [\" + fileName + \"] to [\" + getEndpoint() + \"]\");\n            }\n\n        } finally {\n            ObjectHelper.close(payload, \"Closing payload\", log);\n        }\n\n    }","commit_id":"76502c12a585dd0c3f7a7ea92a4bd938e3a0811b","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public void process(Exchange exchange) throws Exception {\n        GenericFileExchange<T> fileExchange = (GenericFileExchange<T>) endpoint.createExchange(exchange);\n        processExchange(fileExchange);\n        ExchangeHelper.copyResults(exchange, fileExchange);\n    }","id":29813,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public void process(Exchange exchange) throws Exception {\n        Exchange fileExchange = endpoint.createExchange(exchange);\n        processExchange(fileExchange);\n        ExchangeHelper.copyResults(exchange, fileExchange);\n    }","commit_id":"76502c12a585dd0c3f7a7ea92a4bd938e3a0811b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * If we fail writing out a file, we will call this method. This hook is\n     * provided to disconnect from servers or clean up files we created (if needed).\n     */\n    protected void handleFailedWrite(GenericFileExchange<T> exchange, Exception exception) throws Exception {\n        throw exception;\n    }","id":29814,"modified_method":"/**\n     * If we fail writing out a file, we will call this method. This hook is\n     * provided to disconnect from servers or clean up files we created (if needed).\n     */\n    protected void handleFailedWrite(Exchange exchange, Exception exception) throws Exception {\n        throw exception;\n    }","commit_id":"76502c12a585dd0c3f7a7ea92a4bd938e3a0811b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Perform the work to process the fileExchange\n     *\n     * @param exchange fileExchange\n     * @throws Exception is thrown if some error\n     */\n    protected void processExchange(GenericFileExchange<T> exchange) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Processing \" + exchange);\n        }\n\n        try {\n            String target = createFileName(exchange);\n\n            preWriteCheck();\n\n            // should we write to a temporary name and then afterwards rename to real target\n            boolean writeAsTempAndRename = ObjectHelper.isNotEmpty(endpoint.getTempPrefix());\n            String tempTarget = null;\n            if (writeAsTempAndRename) {\n                // compute temporary name with the temp prefix\n                tempTarget = createTempFileName(target);\n            }\n\n            // upload the file\n            writeFile(exchange, tempTarget != null ? tempTarget : target);\n\n            // if we did write to a temporary name then rename it to the real\n            // name after we have written the file\n            if (tempTarget != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Renaming file: [\" + tempTarget + \"] to: [\" + target + \"]\");\n                }\n                boolean renamed = operations.renameFile(tempTarget, target);\n                if (!renamed) {\n                    throw new GenericFileOperationFailedException(\"Cannot rename file from: \" + tempTarget + \" to: \" + target);\n                }\n            }\n\n            // lets store the name we really used in the header, so end-users\n            // can retrieve it\n            exchange.getIn().setHeader(Exchange.FILE_NAME_PRODUCED, target);\n        } catch (Exception e) {\n            handleFailedWrite(exchange, e);\n        }\n    }","id":29815,"modified_method":"/**\n     * Perform the work to process the fileExchange\n     *\n     * @param exchange fileExchange\n     * @throws Exception is thrown if some error\n     */\n    protected void processExchange(Exchange exchange) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Processing \" + exchange);\n        }\n\n        try {\n            String target = createFileName(exchange);\n\n            preWriteCheck();\n\n            // should we write to a temporary name and then afterwards rename to real target\n            boolean writeAsTempAndRename = ObjectHelper.isNotEmpty(endpoint.getTempPrefix());\n            String tempTarget = null;\n            if (writeAsTempAndRename) {\n                // compute temporary name with the temp prefix\n                tempTarget = createTempFileName(target);\n            }\n\n            // upload the file\n            writeFile(exchange, tempTarget != null ? tempTarget : target);\n\n            // if we did write to a temporary name then rename it to the real\n            // name after we have written the file\n            if (tempTarget != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Renaming file: [\" + tempTarget + \"] to: [\" + target + \"]\");\n                }\n                boolean renamed = operations.renameFile(tempTarget, target);\n                if (!renamed) {\n                    throw new GenericFileOperationFailedException(\"Cannot rename file from: \" + tempTarget + \" to: \" + target);\n                }\n            }\n\n            // lets store the name we really used in the header, so end-users\n            // can retrieve it\n            exchange.getIn().setHeader(Exchange.FILE_NAME_PRODUCED, target);\n        } catch (Exception e) {\n            handleFailedWrite(exchange, e);\n        }\n    }","commit_id":"76502c12a585dd0c3f7a7ea92a4bd938e3a0811b","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public void process(Exchange exchange) throws Exception {\n        Exchange remoteExchange = getEndpoint().createExchange(exchange);\n        processExchange((GenericFileExchange<T>)remoteExchange);\n        ExchangeHelper.copyResults(exchange, remoteExchange);\n    }","id":29816,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public void process(Exchange exchange) throws Exception {\n        Exchange remoteExchange = getEndpoint().createExchange(exchange);\n        processExchange(remoteExchange);\n        ExchangeHelper.copyResults(exchange, remoteExchange);\n    }","commit_id":"76502c12a585dd0c3f7a7ea92a4bd938e3a0811b","url":"https://github.com/apache/camel"},{"original_method":"public E createExchange() {\n        return (E) endpoint.createExchange();\n    }","id":29817,"modified_method":"public Exchange createExchange() {\n        return endpoint.createExchange();\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public E createExchange(ExchangePattern pattern) {\n        return (E) endpoint.createExchange(pattern);\n    }","id":29818,"modified_method":"public Exchange createExchange(ExchangePattern pattern) {\n        return endpoint.createExchange(pattern);\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public E createExchange(E exchange) {\n        return (E) endpoint.createExchange(exchange);\n    }","id":29819,"modified_method":"public Exchange createExchange(Exchange exchange) {\n        return endpoint.createExchange(exchange);\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"protected void poll() throws Exception {\n        while (true) {\n            E exchange = pollingConsumer.receiveNoWait();\n            if (exchange == null) {\n                break;\n            }\n\n            // if the result of the polled exchange has output we should create a new exchange and\n            // use the output as input to the next processor\n            Message out = exchange.getOut(false);\n            if (out != null) {\n                // lets create a new exchange\n                E newExchange = (E) getEndpoint().createExchange();\n                newExchange.getIn().copyFrom(out);\n                exchange = newExchange;\n            }\n            getProcessor().process(exchange);\n        }\n    }","id":29820,"modified_method":"protected void poll() throws Exception {\n        while (true) {\n            E exchange = (E) pollingConsumer.receiveNoWait();\n            if (exchange == null) {\n                break;\n            }\n\n            // if the result of the polled exchange has output we should create a new exchange and\n            // use the output as input to the next processor\n            Message out = exchange.getOut(false);\n            if (out != null) {\n                // lets create a new exchange\n                E newExchange = (E) getEndpoint().createExchange();\n                newExchange.getIn().copyFrom(out);\n                exchange = newExchange;\n            }\n            getProcessor().process(exchange);\n        }\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public E receive(long timeout) {\n        try {\n            return queue.poll(timeout, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            handleInteruptedException(e);\n            return null;\n        }\n    }","id":29821,"modified_method":"public Exchange receive(long timeout) {\n        try {\n            return queue.poll(timeout, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            handleInteruptedException(e);\n            return null;\n        }\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public E receive() {\n        while (isRunAllowed()) {\n            try {\n                return queue.take();\n            } catch (InterruptedException e) {\n                handleInteruptedException(e);\n            }\n        }\n        LOG.debug(\"Consumer is not running, so returning null\");\n        return null;\n    }","id":29822,"modified_method":"public Exchange receive() {\n        while (isRunAllowed()) {\n            try {\n                return queue.take();\n            } catch (InterruptedException e) {\n                handleInteruptedException(e);\n            }\n        }\n        LOG.debug(\"Consumer is not running, so returning null\");\n        return null;\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public E receiveNoWait() {\n        return receive(0);\n    }","id":29823,"modified_method":"public Exchange receiveNoWait() {\n        return receive(0);\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public HttpExchange receive(long timeout) {\n        return receiveNoWait();\n    }","id":29824,"modified_method":"public Exchange receive(long timeout) {\n        return receiveNoWait();\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public HttpExchange receiveNoWait() {\n        HttpExchange exchange = (HttpExchange) endpoint.createExchange();\n        HttpMethod method = createMethod();\n\n        try {\n            int responseCode = httpClient.executeMethod(method);\n            // lets store the result in the output message.\n            LoadingByteArrayOutputStream bos = new LoadingByteArrayOutputStream();\n            InputStream is = method.getResponseBodyAsStream();\n            IOUtils.copy(is, bos);\n            bos.flush();\n            is.close();\n            Message message = exchange.getIn();\n            message.setBody(bos.createInputStream());\n\n            // lets set the headers\n            Header[] headers = method.getResponseHeaders();\n            HeaderFilterStrategy strategy = endpoint.getHeaderFilterStrategy();\n            for (Header header : headers) {\n                String name = header.getName();\n                String value = header.getValue();\n                if (strategy != null && !strategy.applyFilterToExternalHeaders(name, value)) {\n                    message.setHeader(name, value);\n                }\n            }\n        \n            message.setHeader(\"http.responseCode\", responseCode);\n            return exchange;\n        } catch (IOException e) {\n            throw new RuntimeCamelException(e);\n        } finally {\n            method.releaseConnection();\n        }\n    }","id":29825,"modified_method":"public Exchange receiveNoWait() {\n        HttpExchange exchange = (HttpExchange) endpoint.createExchange();\n        HttpMethod method = createMethod();\n\n        try {\n            int responseCode = httpClient.executeMethod(method);\n            // lets store the result in the output message.\n            LoadingByteArrayOutputStream bos = new LoadingByteArrayOutputStream();\n            InputStream is = method.getResponseBodyAsStream();\n            IOUtils.copy(is, bos);\n            bos.flush();\n            is.close();\n            Message message = exchange.getIn();\n            message.setBody(bos.createInputStream());\n\n            // lets set the headers\n            Header[] headers = method.getResponseHeaders();\n            HeaderFilterStrategy strategy = endpoint.getHeaderFilterStrategy();\n            for (Header header : headers) {\n                String name = header.getName();\n                String value = header.getValue();\n                if (strategy != null && !strategy.applyFilterToExternalHeaders(name, value)) {\n                    message.setHeader(name, value);\n                }\n            }\n        \n            message.setHeader(\"http.responseCode\", responseCode);\n            return exchange;\n        } catch (IOException e) {\n            throw new RuntimeCamelException(e);\n        } finally {\n            method.releaseConnection();\n        }\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public HttpExchange receive() {\n        return receiveNoWait();\n    }","id":29826,"modified_method":"public Exchange receive() {\n        return receiveNoWait();\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public void testWithQueryInHeader() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", \"q=Camel\");\n\n        HttpExchange exchange = producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(HttpProducer.QUERY, \"q=Camel\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29827,"modified_method":"public void testWithQueryInHeader() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", \"q=Camel\");\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(HttpProducer.QUERY, \"q=Camel\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public void testWithEndpointQuery() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com?q=Camel\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", \"q=Camel\");\n\n        HttpExchange exchange = producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29828,"modified_method":"public void testWithEndpointQuery() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com?q=Camel\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", \"q=Camel\");\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public void testNoDataDefaultIsGet() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", null);\n\n        HttpExchange exchange = producer.createExchange();\n        exchange.getIn().setBody(null);\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29829,"modified_method":"public void testNoDataDefaultIsGet() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", null);\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(null);\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public void testWithMethodPostInHeader() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"POST\", null);\n\n        HttpExchange exchange = producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(HTTP_METHOD, POST);\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29830,"modified_method":"public void testWithMethodPostInHeader() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"POST\", null);\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(HTTP_METHOD, POST);\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public void testWithMethodGetInHeader() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", null);\n\n        HttpExchange exchange = producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(HTTP_METHOD, GET);\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29831,"modified_method":"public void testWithMethodGetInHeader() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", null);\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(HTTP_METHOD, GET);\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public void testWithQueryInHeaderOverrideEndpoint() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com?q=Donkey\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", \"q=Camel\");\n\n        HttpExchange exchange = producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(HttpProducer.QUERY, \"q=Camel\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29832,"modified_method":"public void testWithQueryInHeaderOverrideEndpoint() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com?q=Donkey\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"GET\", \"q=Camel\");\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(\"\");\n        exchange.getIn().setHeader(HttpProducer.QUERY, \"q=Camel\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public void testDataDefaultIsPost() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"POST\", null);\n\n        HttpExchange exchange = producer.createExchange();\n        exchange.getIn().setBody(\"This is some data to post\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","id":29833,"modified_method":"public void testDataDefaultIsPost() throws Exception {\n        HttpComponent component = new HttpComponent();\n        component.setCamelContext(context);\n        HttpEndpoint endpoiont = (HttpEndpoint) component.createEndpoint(\"http://www.google.com\");\n        MyHttpProducer producer = new MyHttpProducer(endpoiont, \"POST\", null);\n\n        HttpExchange exchange = (HttpExchange) producer.createExchange();\n        exchange.getIn().setBody(\"This is some data to post\");\n        try {\n            producer.process(exchange);\n            fail(\"Should have thrown HttpOperationFailedException\");\n        } catch (HttpOperationFailedException e) {\n            assertEquals(500, e.getStatusCode());\n        }\n        producer.stop();\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public JmsExchange receiveNoWait() {\n        return receive(0);\n    }","id":29834,"modified_method":"public Exchange receiveNoWait() {\n        return receive(0);\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public JmsExchange receive() {\n        return receive(-1);\n    }","id":29835,"modified_method":"public Exchange receive() {\n        return receive(-1);\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"public JmsExchange receive(long timeout) {\n        setReceiveTimeout(timeout);\n        Message message = template.receive();\n        if (message != null) {\n            return getEndpoint().createExchange(message);\n        }\n        return null;\n    }","id":29836,"modified_method":"public Exchange receive(long timeout) {\n        setReceiveTimeout(timeout);\n        Message message = template.receive();\n        if (message != null) {\n            return getEndpoint().createExchange(message);\n        }\n        return null;\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Sends an exchange to an endpoint using a supplied\n     * {@link Processor} to populate the exchange\n     *\n     * @param endpoint the endpoint to send the exchange to\n     * @param pattern the message {@link ExchangePattern} such as\n     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}\n     * @param processor the transformer used to populate the new exchange\n     */\n    public E send(Endpoint<E> endpoint, ExchangePattern pattern, Processor processor) {\n        try {\n            Producer<E> producer = getProducer(endpoint);\n            E exchange = producer.createExchange(pattern);\n            return sendExchange(endpoint, producer, processor, exchange);\n        } catch (Exception e) {\n            throw wrapRuntimeCamelException(e);\n        }\n    }","id":29837,"modified_method":"/**\n     * Sends an exchange to an endpoint using a supplied\n     * {@link Processor} to populate the exchange\n     *\n     * @param endpoint the endpoint to send the exchange to\n     * @param pattern the message {@link ExchangePattern} such as\n     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}\n     * @param processor the transformer used to populate the new exchange\n     */\n    public E send(Endpoint<E> endpoint, ExchangePattern pattern, Processor processor) {\n        try {\n            Producer<E> producer = getProducer(endpoint);\n            E exchange = (E) producer.createExchange(pattern);\n            return sendExchange(endpoint, producer, processor, exchange);\n        } catch (Exception e) {\n            throw wrapRuntimeCamelException(e);\n        }\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Sends an exchange to an endpoint using a supplied\n     * {@link Processor} to populate the exchange\n     *\n     * @param endpoint the endpoint to send the exchange to\n     * @param processor the transformer used to populate the new exchange\n     */\n    public E send(Endpoint<E> endpoint, Processor processor) {\n        try {\n            Producer<E> producer = getProducer(endpoint);\n            E exchange = producer.createExchange();\n            return sendExchange(endpoint, producer, processor, exchange);\n        } catch (Exception e) {\n            throw wrapRuntimeCamelException(e);\n        }\n    }","id":29838,"modified_method":"/**\n     * Sends an exchange to an endpoint using a supplied\n     * {@link Processor} to populate the exchange\n     *\n     * @param endpoint the endpoint to send the exchange to\n     * @param processor the transformer used to populate the new exchange\n     */\n    public E send(Endpoint<E> endpoint, Processor processor) {\n        try {\n            Producer<E> producer = getProducer(endpoint);\n            E exchange = (E) producer.createExchange();\n            return sendExchange(endpoint, producer, processor, exchange);\n        } catch (Exception e) {\n            throw wrapRuntimeCamelException(e);\n        }\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Sends an exchange to an endpoint using a supplied\n     * {@link Processor} to populate the exchange.  The callback\n     * will be called when the exchange is completed.\n     *\n     * @param endpoint the endpoint to send the exchange to\n     * @param processor the transformer used to populate the new exchange\n     */\n    public E send(Endpoint<E> endpoint, Processor processor, AsyncCallback callback) {\n        try {\n            Producer<E> producer = getProducer(endpoint);\n            E exchange = producer.createExchange();\n            boolean sync = sendExchange(endpoint, producer, processor, exchange, callback);\n            setProcessedSync(exchange, sync);\n            return exchange;\n        } catch (Exception e) {\n            throw wrapRuntimeCamelException(e);\n        }\n    }","id":29839,"modified_method":"/**\n     * Sends an exchange to an endpoint using a supplied\n     * {@link Processor} to populate the exchange.  The callback\n     * will be called when the exchange is completed.\n     *\n     * @param endpoint the endpoint to send the exchange to\n     * @param processor the transformer used to populate the new exchange\n     */\n    public E send(Endpoint<E> endpoint, Processor processor, AsyncCallback callback) {\n        try {\n            Producer<E> producer = getProducer(endpoint);\n            E exchange = (E) producer.createExchange();\n            boolean sync = sendExchange(endpoint, producer, processor, exchange, callback);\n            setProcessedSync(exchange, sync);\n            return exchange;\n        } catch (Exception e) {\n            throw wrapRuntimeCamelException(e);\n        }\n    }","commit_id":"89fcd7500607e878f6e164a51bf130b98581ef15","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Returns a new sory by file language expression\n     *\n     * @param expression the file language expression\n     * @param reverse    true to reverse order\n     * @param ignoreCase ignore case if comparing strings\n     * @return the comparator\n     */\n    public static Comparator<GenericFileExchange> sortByFileLanguage(final String expression, final boolean reverse,\n                                                                    final boolean ignoreCase) {\n        return sortByFileLanguage(expression, reverse, ignoreCase, null);\n    }","id":29840,"modified_method":"/**\n     * Returns a new sory by file language expression\n     *\n     * @param expression the file language expression\n     * @param reverse    true to reverse order\n     * @param ignoreCase ignore case if comparing strings\n     * @return the comparator\n     */\n    public static Comparator<Exchange> sortByFileLanguage(\n        final String expression, final boolean reverse, final boolean ignoreCase) {\n        return sortByFileLanguage(expression, reverse, ignoreCase, null);\n    }","commit_id":"32ec6c09c3bc5d2b4b19ebf37a1b5690c9f9cddd","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Returns a new sory by file language expression\n     *\n     * @param expression the file language expression\n     * @param reverse    true to reverse order\n     * @return the comparator\n     */\n    public static Comparator<GenericFileExchange> sortByFileLanguage(final String expression, final boolean reverse) {\n        return sortByFileLanguage(expression, reverse, false, null);\n    }","id":29841,"modified_method":"/**\n     * Returns a new sory by file language expression\n     *\n     * @param expression the file language expression\n     * @param reverse    true to reverse order\n     * @return the comparator\n     */\n    public static Comparator<Exchange> sortByFileLanguage(final String expression, final boolean reverse) {\n        return sortByFileLanguage(expression, reverse, false, null);\n    }","commit_id":"32ec6c09c3bc5d2b4b19ebf37a1b5690c9f9cddd","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Returns a new sory by file language expression\n     *\n     * @param expression the file language expression\n     * @param reverse    true to reverse order\n     * @param ignoreCase ignore case if comparing strings\n     * @param nested     nested comparator for sub group sorting, can be null\n     * @return the comparator\n     */\n    public static Comparator<GenericFileExchange> sortByFileLanguage(\n        final String expression, final boolean reverse,\n        final boolean ignoreCase, final Comparator<GenericFileExchange> nested) {\n        \n        return new Comparator<GenericFileExchange>() {\n            public int compare(GenericFileExchange o1, GenericFileExchange o2) {\n                final Expression exp = FileLanguage.file(expression);\n                Object result1 = exp.evaluate(o1, Object.class);\n                Object result2 = exp.evaluate(o2, Object.class);\n                int answer = ObjectHelper.compare(result1, result2, ignoreCase);\n                // if equal then sub sort by nested comparator\n                if (answer == 0 && nested != null) {\n                    answer = nested.compare(o1, o2);\n                }\n                return reverse ? -1 * answer : answer;\n            }\n\n            public String toString() {\n                return expression + (nested != null ? \";\" + nested.toString() : \"\");\n            }\n        };\n    }","id":29842,"modified_method":"/**\n     * Returns a new sory by file language expression\n     *\n     * @param expression the file language expression\n     * @param reverse    true to reverse order\n     * @param ignoreCase ignore case if comparing strings\n     * @param nested     nested comparator for sub group sorting, can be null\n     * @return the comparator\n     */\n    public static Comparator<Exchange> sortByFileLanguage(\n        final String expression, final boolean reverse,\n        final boolean ignoreCase, final Comparator<Exchange> nested) {\n        \n        return new Comparator<Exchange>() {\n            public int compare(Exchange o1, Exchange o2) {\n                final Expression exp = FileLanguage.file(expression);\n                Object result1 = exp.evaluate(o1, Object.class);\n                Object result2 = exp.evaluate(o2, Object.class);\n                int answer = ObjectHelper.compare(result1, result2, ignoreCase);\n                // if equal then sub sort by nested comparator\n                if (answer == 0 && nested != null) {\n                    answer = nested.compare(o1, o2);\n                }\n                return reverse ? -1 * answer : answer;\n            }\n\n            public String toString() {\n                return expression + (nested != null ? \";\" + nested.toString() : \"\");\n            }\n        };\n    }","commit_id":"32ec6c09c3bc5d2b4b19ebf37a1b5690c9f9cddd","url":"https://github.com/apache/camel"},{"original_method":"public Exchange createExchange() {\n        // create the file\n        String uri = \"file://target/filelanguage?fileExist=Override\";\n        template.sendBodyAndHeader(uri, \"Hello World\", Exchange.FILE_NAME, \"test/hello.txt\");\n\n        // get the file handle\n        file = new File(\"target/filelanguage/test/hello.txt\");\n        GenericFile<File> gf = FileConsumer.asGenericFile(\"target/filelanguage\", file);\n\n        FileEndpoint endpoint = getMandatoryEndpoint(uri, FileEndpoint.class);\n\n        GenericFileExchange<File> answer = endpoint.createExchange(gf);\n        endpoint.configureMessage(gf, answer.getIn());\n\n        Calendar cal = GregorianCalendar.getInstance();\n        cal.set(1974, Calendar.APRIL, 20);\n        answer.getIn().setHeader(\"birthday\", cal.getTime());\n\n        cal.set(2008, Calendar.AUGUST, 8);\n        answer.getOut().setHeader(\"special\", cal.getTime());\n        return answer;\n    }","id":29843,"modified_method":"public Exchange createExchange() {\n        // create the file\n        String uri = \"file://target/filelanguage?fileExist=Override\";\n        template.sendBodyAndHeader(uri, \"Hello World\", Exchange.FILE_NAME, \"test/hello.txt\");\n\n        // get the file handle\n        file = new File(\"target/filelanguage/test/hello.txt\");\n        GenericFile<File> gf = FileConsumer.asGenericFile(\"target/filelanguage\", file);\n\n        FileEndpoint endpoint = getMandatoryEndpoint(uri, FileEndpoint.class);\n\n        Exchange answer = endpoint.createExchange(gf);\n        endpoint.configureMessage(gf, answer.getIn());\n\n        Calendar cal = GregorianCalendar.getInstance();\n        cal.set(1974, Calendar.APRIL, 20);\n        answer.getIn().setHeader(\"birthday\", cal.getTime());\n\n        cal.set(2008, Calendar.AUGUST, 8);\n        answer.getOut().setHeader(\"special\", cal.getTime());\n        return answer;\n    }","commit_id":"32ec6c09c3bc5d2b4b19ebf37a1b5690c9f9cddd","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public void process(Exchange exchange) throws Exception {\n        GenericFileExchange remoteExchange = (GenericFileExchange) getEndpoint().createExchange(exchange);\n        processExchange(remoteExchange);\n        ExchangeHelper.copyResults(exchange, remoteExchange);\n    }","id":29844,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public void process(Exchange exchange) throws Exception {\n        Exchange remoteExchange = getEndpoint().createExchange(exchange);\n        processExchange((GenericFileExchange<T>)remoteExchange);\n        ExchangeHelper.copyResults(exchange, remoteExchange);\n    }","commit_id":"32ec6c09c3bc5d2b4b19ebf37a1b5690c9f9cddd","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * The file could not be written. We need to disconnect from the remote server.\n     */\n    protected void handleFailedWrite(GenericFileExchange<T> exchange, Exception exception) throws Exception {\n        loggedIn = false;\n        if (isStopping() || isStopped()) {\n            // if we are stopping then ignore any exception during a poll\n            log.debug(\"Exception occured during stopping: \" + exception.getMessage());\n        } else {\n            log.debug(\"Exception occured during processing. \", exception);\n            disconnect();\n            // Rethrow to signify that we didn't poll\n            throw exception;\n        }\n    }","id":29845,"modified_method":"/**\n     * The file could not be written. We need to disconnect from the remote server.\n     */\n    protected void handleFailedWrite(Exchange exchange, Exception exception) throws Exception {\n        loggedIn = false;\n        if (isStopping() || isStopped()) {\n            // if we are stopping then ignore any exception during a poll\n            log.debug(\"Exception occured during stopping: \" + exception.getMessage());\n        } else {\n            log.debug(\"Exception occured during processing. \", exception);\n            disconnect();\n            // Rethrow to signify that we didn't poll\n            throw exception;\n        }\n    }","commit_id":"32ec6c09c3bc5d2b4b19ebf37a1b5690c9f9cddd","url":"https://github.com/apache/camel"},{"original_method":"public Artifact createMainArtifact(ParsedMavenPom builder)\n    {\n        return new DefaultArtifact(builder.getGroup(), builder.getArtifactId(), VersionRange.createFromVersion(builder.getVersion()),\n                null, builder.getPackaging(), null, artifactHandler(builder.getPackaging()));\n    }","id":29846,"modified_method":"private Artifact createMainArtifact(ParsedMavenPom pom) {\n        return new DefaultArtifact(pom.getGroup(), pom.getArtifactId(), VersionRange.createFromVersion(pom.getVersion()),\n                null, pom.getPackaging(), null, artifactHandler(pom.getPackaging()));\n    }","commit_id":"249cae836d069ce588d4bef13fdcb13b815c35d8","url":"https://github.com/gradle/gradle"},{"original_method":"public LocalRepository getLocalRepository() {\n        if (localRepository == null) {\n            localRepository = getDefaultLocalRepository();\n        }\n        return localRepository;\n    }","id":29847,"modified_method":"public LocalRepository getLocalRepository() {\n        LocalRepository localRepository = new LocalRepository();\n        localRepository.setId(\"local\");\n        localRepository.setPath(new File(settings.getLocalRepository()));\n        return localRepository;\n    }","commit_id":"249cae836d069ce588d4bef13fdcb13b815c35d8","url":"https://github.com/gradle/gradle"},{"original_method":"public Artifact createAttachedArtifact(Artifact mainArtifact, String type, String classifier) {\n        return new AttachedArtifact(mainArtifact, type, classifier, artifactHandler(type));\n    }","id":29848,"modified_method":"private Artifact createAttachedArtifact(Artifact mainArtifact, String type, String classifier) {\n        return new AttachedArtifact(mainArtifact, type, classifier, artifactHandler(type));\n    }","commit_id":"249cae836d069ce588d4bef13fdcb13b815c35d8","url":"https://github.com/gradle/gradle"},{"original_method":"protected Object lookup(String role) {\n        try {\n            return getContainer().lookup(role);\n        } catch (ComponentLookupException e) {\n            throw new BuildException(\"Unable to find component: \" + role, e);\n        }\n    }","id":29849,"modified_method":"protected Object lookup(String role) {\n        try {\n            return getContainer().lookup(role);\n        } catch (ComponentLookupException e) {\n            throw new GradleException(\"Unable to find component: \" + role, e);\n        }\n    }","commit_id":"249cae836d069ce588d4bef13fdcb13b815c35d8","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * @noinspection RefusedBequest\n     */\n    public void execute() {\n        ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();\n        try {\n            if (plexusClassLoader != null) {\n                Thread.currentThread().setContextClassLoader(plexusClassLoader);\n            }\n            doExecute();\n        } finally {\n            plexusClassLoader = Thread.currentThread().getContextClassLoader();\n            Thread.currentThread().setContextClassLoader(originalClassLoader);\n        }\n    }","id":29850,"modified_method":"public void execute() {\n        ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();\n        try {\n            if (plexusClassLoader != null) {\n                Thread.currentThread().setContextClassLoader(plexusClassLoader);\n            }\n            publish();\n        } finally {\n            plexusClassLoader = Thread.currentThread().getContextClassLoader();\n            Thread.currentThread().setContextClassLoader(originalClassLoader);\n        }\n    }","commit_id":"249cae836d069ce588d4bef13fdcb13b815c35d8","url":"https://github.com/gradle/gradle"},{"original_method":"protected Object lookup(String role,\n                            String roleHint) {\n        try {\n            return getContainer().lookup(role, roleHint);\n        } catch (ComponentLookupException e) {\n            throw new BuildException(\"Unable to find component: \" + role + \"[\" + roleHint + \"]\", e);\n        }\n    }","id":29851,"modified_method":"protected Object lookup(String role, String roleHint) {\n        try {\n            return getContainer().lookup(role, roleHint);\n        } catch (ComponentLookupException e) {\n            throw new GradleException(\"Unable to find component: \" + role + \"[\" + roleHint + \"]\", e);\n        }\n    }","commit_id":"249cae836d069ce588d4bef13fdcb13b815c35d8","url":"https://github.com/gradle/gradle"},{"original_method":"public synchronized Settings getSettings() {\n        return settings;\n    }","id":29852,"modified_method":"public Settings getSettings() {\n        return settings;\n    }","commit_id":"249cae836d069ce588d4bef13fdcb13b815c35d8","url":"https://github.com/gradle/gradle"},{"original_method":"public void initSettings(File settingsFile) {\n        this.settings = new MavenSettingsLoader().loadSettings(settingsFile);\n\n        WagonManager wagonManager = (WagonManager) lookup(WagonManager.ROLE);\n        wagonManager.setDownloadMonitor(new LoggingTransferListener());\n    }","id":29853,"modified_method":"public void initSettings(File settingsFile) {\n        this.settings = new MavenSettingsLoader().loadSettings(settingsFile);\n\n        WagonManager wagonManager = (WagonManager) lookup(WagonManager.ROLE);\n        wagonManager.setDownloadMonitor(new LoggingMavenTransferListener());\n    }","commit_id":"249cae836d069ce588d4bef13fdcb13b815c35d8","url":"https://github.com/gradle/gradle"},{"original_method":"private ArtifactRepository getRemoteArtifactRepository(Artifact artifact) {\n        if (remoteSnapshotRepository == null) {\n            remoteSnapshotRepository = remoteRepository;\n        }\n\n        ArtifactRepository deploymentRepository;\n        if (artifact.isSnapshot() && remoteSnapshotRepository != null) {\n            deploymentRepository = createDeploymentArtifactRepository(remoteSnapshotRepository);\n        } else if (remoteRepository != null) {\n            deploymentRepository = createDeploymentArtifactRepository(remoteRepository);\n        } else {\n            throw new BuildException(\"A remoteRepository element is required to deploy\");\n        }\n\n        return deploymentRepository;\n    }","id":29854,"modified_method":"private ArtifactRepository getRemoteArtifactRepository(Artifact artifact) {\n\n        if (artifact.isSnapshot() && remoteSnapshotRepository != null) {\n            return createDeploymentArtifactRepository(remoteSnapshotRepository);\n        }\n\n        if (remoteRepository == null) {\n            throw new GradleException(\"Must specify a repository for deployment\");\n        }\n\n        return createDeploymentArtifactRepository(remoteRepository);\n    }","commit_id":"249cae836d069ce588d4bef13fdcb13b815c35d8","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Create a core-Maven deployment ArtifactRepository from a Maven Ant Tasks's RemoteRepository definition.\n     *\n     * @param repository the remote repository as defined in Ant\n     * @return the corresponding ArtifactRepository\n     */\n    protected ArtifactRepository createDeploymentArtifactRepository(RemoteRepository repository) {\n        if (repository.getId().equals(repository.getUrl())) {\n            // MANTTASKS-103: avoid default id set to the url, since it is used for maven-metadata-<id>.xml\n            repository.setId(\"remote\");\n        }\n\n        updateRepositoryWithSettings(repository);\n\n        ArtifactRepositoryLayout repositoryLayout =\n                (ArtifactRepositoryLayout) lookup(ArtifactRepositoryLayout.ROLE, repository.getLayout());\n\n        ArtifactRepositoryFactory repositoryFactory = null;\n\n        ArtifactRepository artifactRepository;\n\n        try {\n            repositoryFactory = getArtifactRepositoryFactory(repository);\n\n            artifactRepository =\n                    repositoryFactory.createDeploymentArtifactRepository(repository.getId(), repository.getUrl(),\n                            repositoryLayout, uniqueVersion);\n        } finally {\n            releaseArtifactRepositoryFactory(repositoryFactory);\n        }\n\n        return artifactRepository;\n    }","id":29855,"modified_method":"/**\n     * Create a core-Maven deployment ArtifactRepository from a Maven Ant Tasks's RemoteRepository definition.\n     *\n     * @param repository the remote repository as defined in Ant\n     * @return the corresponding ArtifactRepository\n     */\n    private ArtifactRepository createDeploymentArtifactRepository(RemoteRepository repository) {\n        if (repository.getId().equals(repository.getUrl())) {\n            // MANTTASKS-103: avoid default id set to the url, since it is used for maven-metadata-<id>.xml\n            repository.setId(\"remote\");\n        }\n\n        ArtifactRepositoryLayout repositoryLayout = (ArtifactRepositoryLayout) lookup(ArtifactRepositoryLayout.ROLE, repository.getLayout());\n        ArtifactRepositoryFactory repositoryFactory = null;\n\n        try {\n            repositoryFactory = getArtifactRepositoryFactory(repository);\n            return repositoryFactory.createDeploymentArtifactRepository(repository.getId(), repository.getUrl(), repositoryLayout, uniqueVersion);\n        } finally {\n            releaseArtifactRepositoryFactory(repositoryFactory);\n        }\n    }","commit_id":"249cae836d069ce588d4bef13fdcb13b815c35d8","url":"https://github.com/gradle/gradle"},{"original_method":"protected void doPublish(Artifact artifact, File pomFile, ArtifactRepository localRepo) {\n        ArtifactDeployer deployer = (ArtifactDeployer) lookup(ArtifactDeployer.ROLE);\n        ArtifactRepository deploymentRepository = getRemoteArtifactRepository(artifact);\n        log(\"Deploying to \" + deploymentRepository.getUrl(), Project.MSG_INFO);\n\n        try {\n            deployer.deploy(pomFile, artifact, deploymentRepository, localRepo);\n        } catch (ArtifactDeploymentException e) {\n            throw new BuildException(\"Error deploying artifact '\" + artifact.getDependencyConflictId() + \"': \" + e.getMessage(), e);\n        }\n    }","id":29856,"modified_method":"protected void doPublish(Artifact artifact, File pomFile, ArtifactRepository localRepo) {\n        ArtifactDeployer deployer = (ArtifactDeployer) lookup(ArtifactDeployer.ROLE);\n        ArtifactRepository deploymentRepository = getRemoteArtifactRepository(artifact);\n\n        LOGGER.info(\"Deploying to \" + deploymentRepository.getUrl());\n\n        try {\n            deployer.deploy(pomFile, artifact, deploymentRepository, localRepo);\n        } catch (ArtifactDeploymentException e) {\n            throw new BuildException(\"Error deploying artifact '\" + artifact.getDependencyConflictId() + \"': \" + e.getMessage(), e);\n        }\n    }","commit_id":"249cae836d069ce588d4bef13fdcb13b815c35d8","url":"https://github.com/gradle/gradle"},{"original_method":"public void addRead( SAMRecord newRead ) {\n        if ( DEBUG ) logger.info(\"New read pos \" + newRead.getAlignmentStart() + \" OP = \" + newRead.getAttribute(\"OP\"));\n\n        //final long curTime = timer.currentTime();\n        //if ( curTime - lastProgressPrintTime > PROGRESS_PRINT_FREQUENCY ) {\n        //    lastProgressPrintTime = curTime;\n        //    System.out.println(\"WaitingReads.size = \" + waitingReads.size() + \", forMateMatching.size = \" + forMateMatching.size());\n        //}\n\n        // if the new read is on a different contig or we have too many reads, then we need to flush the queue and clear the map\n        boolean tooManyReads = getNReadsInQueue() >= MAX_RECORDS_IN_MEMORY;\n        if ( tooManyReads || (getNReadsInQueue() > 0 && waitingReads.peek().getReferenceIndex() != newRead.getReferenceIndex()) ) {\n            if ( DEBUG ) logger.warn(\"Flushing queue on \" + (tooManyReads ? \"too many reads\" : (\"move to new contig: \" + newRead.getReferenceName())) + \" at \" + newRead.getAlignmentStart());\n\n            while ( getNReadsInQueue() > 1 ) {\n                // emit to disk\n                writeRead(waitingReads.remove());\n            }\n\n            SAMRecord lastRead = waitingReads.remove();\n            lastLocFlushed = (lastRead.getReferenceIndex() == -1) ? null : genomeLocParser.createGenomeLoc(lastRead);\n            writeRead(lastRead);\n\n            if ( !tooManyReads )\n                forMateMatching.clear();\n        }\n\n        // fix mates, as needed\n        // Since setMateInfo can move reads, we potentially need to remove the mate, and requeue\n        // it to ensure proper sorting\n        if ( newRead.getReadPairedFlag() ) {\n            SAMRecord mate = forMateMatching.get(newRead.getReadName());\n            if ( mate != null ) {\n                // Frustratingly, Picard's setMateInfo() method unaligns (by setting the reference contig\n                // to '*') read pairs when both of their flags have the unmapped bit set.  This is problematic\n                // when trying to emit reads in coordinate order because all of a sudden we have reads in the\n                // middle of the bam file that now belong at the end - and any mapped reads that get emitted\n                // after them trigger an exception in the writer.  For our purposes, because we shouldn't be\n                // moving read pairs when they are both unmapped anyways, we'll just not run fix mates on them.\n                boolean doNotFixMates = newRead.getReadUnmappedFlag() && mate.getReadUnmappedFlag();\n                if ( !doNotFixMates ) {\n\n                    boolean reQueueMate = mate.getReadUnmappedFlag() && ! newRead.getReadUnmappedFlag();\n                    if ( reQueueMate ) {\n                        // the mate was unmapped, but newRead was mapped, so the mate may have been moved\n                        // to be next-to newRead, so needs to be reinserted into the waitingReads queue\n                        // note -- this must be called before the setMateInfo call below\n                        if ( ! waitingReads.remove(mate) )\n                            // we must have hit a region with too much depth and flushed the queue\n                            reQueueMate = false;\n                    }\n\n                    // we've already seen our mate -- set the mate info and remove it from the map\n                    SamPairUtil.setMateInfo(mate, newRead, null);\n                    if ( reQueueMate ) waitingReads.add(mate);\n                }\n\n                forMateMatching.remove(newRead.getReadName());\n            } else {\n                forMateMatching.put(newRead.getReadName(), newRead);\n            }\n        }\n\n        waitingReads.add(newRead);\n\n        if ( ++counter % EMIT_FREQUENCY == 0 ) {\n            while ( ! waitingReads.isEmpty() ) { // there's something in the queue\n                SAMRecord read = waitingReads.peek();\n\n                if ( noReadCanMoveBefore(read.getAlignmentStart(), newRead) &&\n                        (iSizeTooBigToMove(read)                                           // we won't try to move such a read\n                                || ! read.getReadPairedFlag()                                     // we're not a paired read\n                                || read.getReadUnmappedFlag() && read.getMateUnmappedFlag()       // both reads are unmapped\n                                || noReadCanMoveBefore(read.getMateAlignmentStart(), newRead ) ) ) { // we're already past where the mate started\n\n                    // remove reads from the map that we have emitted -- useful for case where the mate never showed up\n                    forMateMatching.remove(read.getReadName());\n\n                    if ( DEBUG )\n                        logger.warn(String.format(\"EMIT!  At %d: read %s at %d with isize %d, mate start %d, op = %s\",\n                                newRead.getAlignmentStart(), read.getReadName(), read.getAlignmentStart(),\n                                read.getInferredInsertSize(), read.getMateAlignmentStart(), read.getAttribute(\"OP\")));\n                    // emit to disk\n                    writeRead(waitingReads.remove());\n                } else {\n                    if ( DEBUG )\n                        logger.warn(String.format(\"At %d: read %s at %d with isize %d couldn't be emited, mate start %d\",\n                                newRead.getAlignmentStart(), read.getReadName(), read.getAlignmentStart(), read.getInferredInsertSize(), read.getMateAlignmentStart()));\n                    break;\n                }\n            }\n\n            if ( DEBUG ) logger.warn(String.format(\"At %d: Done with emit cycle\", newRead.getAlignmentStart()));\n        }\n    }","id":29857,"modified_method":"public void addRead( SAMRecord newRead ) {\n        if ( DEBUG ) logger.info(\"New read pos \" + newRead.getAlignmentStart() + \" OP = \" + newRead.getAttribute(\"OP\"));\n\n        //final long curTime = timer.currentTime();\n        //if ( curTime - lastProgressPrintTime > PROGRESS_PRINT_FREQUENCY ) {\n        //    lastProgressPrintTime = curTime;\n        //    System.out.println(\"WaitingReads.size = \" + waitingReads.size() + \", forMateMatching.size = \" + forMateMatching.size());\n        //}\n\n        // if the new read is on a different contig or we have too many reads, then we need to flush the queue and clear the map\n        boolean tooManyReads = getNReadsInQueue() >= MAX_RECORDS_IN_MEMORY;\n        if ( tooManyReads || (getNReadsInQueue() > 0 && waitingReads.peek().getReferenceIndex() != newRead.getReferenceIndex()) ) {\n            if ( DEBUG ) logger.warn(\"Flushing queue on \" + (tooManyReads ? \"too many reads\" : (\"move to new contig: \" + newRead.getReferenceName())) + \" at \" + newRead.getAlignmentStart());\n\n            while ( getNReadsInQueue() > 1 ) {\n                // emit to disk\n                writeRead(waitingReads.remove());\n            }\n\n            SAMRecord lastRead = waitingReads.remove();\n            lastLocFlushed = (lastRead.getReferenceIndex() == -1) ? null : genomeLocParser.createGenomeLoc(lastRead);\n            writeRead(lastRead);\n\n            if ( !tooManyReads )\n                forMateMatching.clear();\n        }\n\n        // fix mates, as needed\n        // Since setMateInfo can move reads, we potentially need to remove the mate, and requeue\n        // it to ensure proper sorting\n        if ( newRead.getReadPairedFlag() ) {\n            SAMRecord mate = forMateMatching.get(newRead.getReadName());\n            if ( mate != null ) {\n                // 1. Frustratingly, Picard's setMateInfo() method unaligns (by setting the reference contig\n                // to '*') read pairs when both of their flags have the unmapped bit set.  This is problematic\n                // when trying to emit reads in coordinate order because all of a sudden we have reads in the\n                // middle of the bam file that now belong at the end - and any mapped reads that get emitted\n                // after them trigger an exception in the writer.  For our purposes, because we shouldn't be\n                // moving read pairs when they are both unmapped anyways, we'll just not run fix mates on them.\n                // 2. Furthermore, when reads get mapped to the junction of two chromosomes (e.g. MT since it\n                // is actually circular DNA), their unmapped bit is set, but they are given legitimate coordinates.\n                // The Picard code will come in and move the read all the way back to its mate (which can be\n                // arbitrarily far away).  However, we do still want to move legitimately unmapped reads whose\n                // mates are mapped, so the compromise will be that if the mate is still in the queue then we'll\n                // move the read and otherwise we won't.\n                boolean doNotFixMates = newRead.getReadUnmappedFlag() && (mate.getReadUnmappedFlag() || !waitingReads.contains(mate));\n                if ( !doNotFixMates ) {\n\n                    boolean reQueueMate = mate.getReadUnmappedFlag() && ! newRead.getReadUnmappedFlag();\n                    if ( reQueueMate ) {\n                        // the mate was unmapped, but newRead was mapped, so the mate may have been moved\n                        // to be next-to newRead, so needs to be reinserted into the waitingReads queue\n                        // note -- this must be called before the setMateInfo call below\n                        if ( ! waitingReads.remove(mate) )\n                            // we must have hit a region with too much depth and flushed the queue\n                            reQueueMate = false;\n                    }\n\n                    // we've already seen our mate -- set the mate info and remove it from the map\n                    SamPairUtil.setMateInfo(mate, newRead, null);\n                    if ( reQueueMate ) waitingReads.add(mate);\n                }\n\n                forMateMatching.remove(newRead.getReadName());\n            } else {\n                forMateMatching.put(newRead.getReadName(), newRead);\n            }\n        }\n\n        waitingReads.add(newRead);\n\n        if ( ++counter % EMIT_FREQUENCY == 0 ) {\n            while ( ! waitingReads.isEmpty() ) { // there's something in the queue\n                SAMRecord read = waitingReads.peek();\n\n                if ( noReadCanMoveBefore(read.getAlignmentStart(), newRead) &&\n                        (iSizeTooBigToMove(read)                                           // we won't try to move such a read\n                                || ! read.getReadPairedFlag()                                     // we're not a paired read\n                                || read.getReadUnmappedFlag() && read.getMateUnmappedFlag()       // both reads are unmapped\n                                || noReadCanMoveBefore(read.getMateAlignmentStart(), newRead ) ) ) { // we're already past where the mate started\n\n                    // remove reads from the map that we have emitted -- useful for case where the mate never showed up\n                    forMateMatching.remove(read.getReadName());\n\n                    if ( DEBUG )\n                        logger.warn(String.format(\"EMIT!  At %d: read %s at %d with isize %d, mate start %d, op = %s\",\n                                newRead.getAlignmentStart(), read.getReadName(), read.getAlignmentStart(),\n                                read.getInferredInsertSize(), read.getMateAlignmentStart(), read.getAttribute(\"OP\")));\n                    // emit to disk\n                    writeRead(waitingReads.remove());\n                } else {\n                    if ( DEBUG )\n                        logger.warn(String.format(\"At %d: read %s at %d with isize %d couldn't be emited, mate start %d\",\n                                newRead.getAlignmentStart(), read.getReadName(), read.getAlignmentStart(), read.getInferredInsertSize(), read.getMateAlignmentStart()));\n                    break;\n                }\n            }\n\n            if ( DEBUG ) logger.warn(String.format(\"At %d: Done with emit cycle\", newRead.getAlignmentStart()));\n        }\n    }","commit_id":"ab6a8151845dfd01321bd3d9866f33483c5a2141","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static void checkAlignmentDisagreesWithHeader( SAMFileHeader header, SAMRecord read ) {\n        SAMSequenceRecord contigHeader = header.getSequence( read.getReferenceIndex() );\n        if( !read.getReadUnmappedFlag() && read.getAlignmentStart() > contigHeader.getSequenceLength() )\n            throw new SAMReadValidationException(\"Read is aligned to a point after the end of the contig\");\n    }","id":29858,"modified_method":"/**\n     * Check to ensure that the alignment makes sense based on the contents of the header.\n     * @param header The SAM file header.\n     * @param read The read to verify.\n     */\n    private static void checkAlignmentDisagreesWithHeader( SAMFileHeader header, SAMRecord read ) {\n        if( read.getReferenceIndex() == SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX && read.getAlignmentStart() != SAMRecord.NO_ALIGNMENT_START )\n            throw new SAMReadValidationException(\"Read is aligned to nonexistent contig\");\n        SAMSequenceRecord contigHeader = header.getSequence( read.getReferenceIndex() );\n        if( read.getReadUnmappedFlag() && read.getAlignmentStart() > contigHeader.getSequenceLength() )\n            throw new SAMReadValidationException(\"Read is aligned to a point after the end of the contig\");\n    }","commit_id":"cac04a407a7039428d5f6ab121b34ea20fabc1b9","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected <M, T> T fullInputTraversal(LocusWindowWalker<M, T> walker, List<GenomeLoc> locations, T sum) {\n        ArrayList<LocusContext> nextLociToCarry = new ArrayList<LocusContext>();\n\n        // set everything up\n        GenomeLoc currentInterval = (locations.size() > 0 ? locations.get(0) : null);\n        int locationsIndex = 0;\n        ArrayList<SAMRecord> intervalReads = new ArrayList<SAMRecord>();\n        Iterator<SAMRecord> readIter = samReader.iterator();\n\n        while (readIter.hasNext()) {\n            TraversalStatistics.nRecords++;\n            SAMRecord read = readIter.next();\n\n            // if there are no locations or we're past the last one or it's unmapped, then act on the read separately\n            if ( currentInterval == null || read.getReadUnmappedFlag() ) {\n                if ( nextLociToCarry.size() > 0 ) {\n                    sum = carryWalkerOverInterval(walker, sum, nextLociToCarry.get(0));\n                    for (int i=1; i < nextLociToCarry.size(); i++)\n                        walker.nonIntervalReadAction(nextLociToCarry.get(i).getReads().get(0));\n                    nextLociToCarry.clear();\n                }\n                walker.nonIntervalReadAction(read);\n            }\n            else {\n                GenomeLoc loc = new GenomeLoc(read);\n                // if we're in the current interval, add it to the list\n                if ( currentInterval.overlapsP(loc) ) {\n                    intervalReads.add(read);\n                }\n                // if we're not yet in the interval, act on the read separately\n                else if ( currentInterval.isPast(loc) ) {\n                    if ( nextLociToCarry.size() == 0 ) {\n                        walker.nonIntervalReadAction(read);\n                    } else {\n                        ArrayList<SAMRecord> list = new ArrayList<SAMRecord>();\n                        list.add(read);\n                        nextLociToCarry.add(new LocusContext(loc, list, null));\n                    }                        \n                }\n                // otherwise, we're past the interval so first deal with the collected reads and then this one\n                else {\n                    if ( intervalReads.size() > 0 ) {\n                        Iterator<SAMRecord> wrappedIter = wrapReadsIterator(intervalReads.iterator(), false);\n                        LocusContext locus = getLocusContext(wrappedIter, currentInterval);\n\n                        if ( nextLociToCarry.size() == 0 ) {\n                            nextLociToCarry.add(locus);\n                        } else if ( nextLociToCarry.get(0).getLocation().overlapsP(locus.getLocation()) ) {\n                            LocusContext newLocus = merge(nextLociToCarry.get(0), locus);\n                            for (int i=1; i < nextLociToCarry.size(); i++)\n                                newLocus = merge(newLocus, nextLociToCarry.get(i));    \n                            nextLociToCarry.clear();\n                            nextLociToCarry.add(newLocus);\n                        } else {\n                            sum = carryWalkerOverInterval(walker, sum, nextLociToCarry.get(0));\n                            for (int i=1; i < nextLociToCarry.size(); i++)\n                                walker.nonIntervalReadAction(nextLociToCarry.get(i).getReads().get(0));\n                            nextLociToCarry.clear();\n                            nextLociToCarry.add(locus);\n                        }\n\n                        // then prepare for the next interval\n                        intervalReads.clear();\n                    }\n                    currentInterval = (++locationsIndex < locations.size() ? locations.get(locationsIndex) : null);\n\n                    if ( nextLociToCarry.size() == 0 ) {\n                        walker.nonIntervalReadAction(read);\n                    } else {\n                        ArrayList<SAMRecord> list = new ArrayList<SAMRecord>();\n                        list.add(read);\n                        nextLociToCarry.add(new LocusContext(loc, list, null));\n                    }\n                }\n            }\n        }\n        // some cleanup\n        if ( intervalReads.size() > 0 ) {\n            Iterator<SAMRecord> wrappedIter = wrapReadsIterator(intervalReads.iterator(), false);\n            LocusContext locus = getLocusContext(wrappedIter, currentInterval);\n            if ( nextLociToCarry.size() == 0 ) {\n                nextLociToCarry.add(locus);\n            } else if ( nextLociToCarry.get(0).getLocation().overlapsP(locus.getLocation()) ) {\n                LocusContext newLocus = merge(nextLociToCarry.get(0), locus);\n                for (int i=1; i < nextLociToCarry.size(); i++)\n                    newLocus = merge(newLocus, nextLociToCarry.get(i));\n                nextLociToCarry.clear();\n                nextLociToCarry.add(newLocus);\n            } else {\n                sum = carryWalkerOverInterval(walker, sum, nextLociToCarry.get(0));\n                for (int i=1; i < nextLociToCarry.size(); i++)\n                    walker.nonIntervalReadAction(nextLociToCarry.get(i).getReads().get(0));\n                nextLociToCarry.clear();\n                nextLociToCarry.add(locus);\n            }\n        }\n        if ( nextLociToCarry.size() > 0 ) {\n            sum = carryWalkerOverInterval(walker, sum, nextLociToCarry.get(0));\n            for (int i=1; i < nextLociToCarry.size(); i++)\n                walker.nonIntervalReadAction(nextLociToCarry.get(i).getReads().get(0));\n        }\n\n        return sum;\n    }","id":29859,"modified_method":"protected <M, T> T fullInputTraversal(LocusWindowWalker<M, T> walker, List<GenomeLoc> locations, T sum) {\n        ArrayList<LocusContext> nextLociToCarry = new ArrayList<LocusContext>();\n\n        // set everything up\n        GenomeLoc currentInterval = (locations.size() > 0 ? locations.get(0) : null);\n        int locationsIndex = 0;\n        ArrayList<SAMRecord> intervalReads = new ArrayList<SAMRecord>();\n        Iterator<SAMRecord> readIter = samReader.iterator();\n\n        while (readIter.hasNext()) {\n            TraversalStatistics.nRecords++;\n            SAMRecord read = readIter.next();\n\n            // apparently, unmapped reads can occur anywhere in the file!\n            if ( read.getReadUnmappedFlag() ) {\n                walker.nonIntervalReadAction(read);\n                continue;\n            }\n\n            // if there are no locations or we're past the last one, then act on the read separately\n            if ( currentInterval == null ) {\n                if ( nextLociToCarry.size() > 0 ) {\n                    sum = carryWalkerOverInterval(walker, sum, nextLociToCarry.get(0));\n                    for (int i=1; i < nextLociToCarry.size(); i++)\n                        walker.nonIntervalReadAction(nextLociToCarry.get(i).getReads().get(0));\n                    nextLociToCarry.clear();\n                }\n                walker.nonIntervalReadAction(read);\n            }\n            else {\n                GenomeLoc loc = new GenomeLoc(read);\n                // if we're in the current interval, add it to the list\n                if ( currentInterval.overlapsP(loc) ) {\n                    intervalReads.add(read);\n                }\n                // if we're not yet in the interval, act on the read separately\n                else if ( currentInterval.isPast(loc) ) {\n                    if ( nextLociToCarry.size() == 0 ) {\n                        walker.nonIntervalReadAction(read);\n                    } else {\n                        ArrayList<SAMRecord> list = new ArrayList<SAMRecord>();\n                        list.add(read);\n                        nextLociToCarry.add(new LocusContext(loc, list, null));\n                    }                        \n                }\n                // otherwise, we're past the interval so first deal with the collected reads and then this one\n                else {\n                    if ( intervalReads.size() > 0 ) {\n                        Iterator<SAMRecord> wrappedIter = wrapReadsIterator(intervalReads.iterator(), false);\n                        LocusContext locus = getLocusContext(wrappedIter, currentInterval);\n\n                        if ( nextLociToCarry.size() == 0 ) {\n                            nextLociToCarry.add(locus);\n                        } else if ( nextLociToCarry.get(0).getLocation().overlapsP(locus.getLocation()) ) {\n                            LocusContext newLocus = merge(nextLociToCarry.get(0), locus);\n                            for (int i=1; i < nextLociToCarry.size(); i++)\n                                newLocus = merge(newLocus, nextLociToCarry.get(i));    \n                            nextLociToCarry.clear();\n                            nextLociToCarry.add(newLocus);\n                        } else {\n                            sum = carryWalkerOverInterval(walker, sum, nextLociToCarry.get(0));\n                            for (int i=1; i < nextLociToCarry.size(); i++)\n                                walker.nonIntervalReadAction(nextLociToCarry.get(i).getReads().get(0));\n                            nextLociToCarry.clear();\n                            nextLociToCarry.add(locus);\n                        }\n\n                        // then prepare for the next interval\n                        intervalReads.clear();\n                    }\n                    currentInterval = (++locationsIndex < locations.size() ? locations.get(locationsIndex) : null);\n\n                    if ( nextLociToCarry.size() == 0 ) {\n                        walker.nonIntervalReadAction(read);\n                    } else {\n                        ArrayList<SAMRecord> list = new ArrayList<SAMRecord>();\n                        list.add(read);\n                        nextLociToCarry.add(new LocusContext(loc, list, null));\n                    }\n                }\n            }\n        }\n        // some cleanup\n        if ( intervalReads.size() > 0 ) {\n            Iterator<SAMRecord> wrappedIter = wrapReadsIterator(intervalReads.iterator(), false);\n            LocusContext locus = getLocusContext(wrappedIter, currentInterval);\n            if ( nextLociToCarry.size() == 0 ) {\n                nextLociToCarry.add(locus);\n            } else if ( nextLociToCarry.get(0).getLocation().overlapsP(locus.getLocation()) ) {\n                LocusContext newLocus = merge(nextLociToCarry.get(0), locus);\n                for (int i=1; i < nextLociToCarry.size(); i++)\n                    newLocus = merge(newLocus, nextLociToCarry.get(i));\n                nextLociToCarry.clear();\n                nextLociToCarry.add(newLocus);\n            } else {\n                sum = carryWalkerOverInterval(walker, sum, nextLociToCarry.get(0));\n                for (int i=1; i < nextLociToCarry.size(); i++)\n                    walker.nonIntervalReadAction(nextLociToCarry.get(i).getReads().get(0));\n                nextLociToCarry.clear();\n                nextLociToCarry.add(locus);\n            }\n        }\n        if ( nextLociToCarry.size() > 0 ) {\n            sum = carryWalkerOverInterval(walker, sum, nextLociToCarry.get(0));\n            for (int i=1; i < nextLociToCarry.size(); i++)\n                walker.nonIntervalReadAction(nextLociToCarry.get(i).getReads().get(0));\n        }\n\n        return sum;\n    }","commit_id":"45eeefbb80f13303b9036837321fcc8a415cf20d","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n\tpublic List<Role> getGroupRelatedRoles(long groupId)\n\t\tthrows PortalException {\n\n\t\tList<Role> roles = new ArrayList<>();\n\n\t\tGroup group = groupLocalService.getGroup(groupId);\n\n\t\tif (group.isStagingGroup()) {\n\t\t\tgroup = group.getLiveGroup();\n\t\t}\n\n\t\tint[] types = RoleConstants.TYPES_REGULAR;\n\n\t\tif (group.isOrganization()) {\n\t\t\tif (group.isSite()) {\n\t\t\t\ttypes = RoleConstants.TYPES_ORGANIZATION_AND_REGULAR_AND_SITE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttypes = RoleConstants.TYPES_ORGANIZATION_AND_REGULAR;\n\t\t\t}\n\t\t}\n\t\telse if (group.isLayout() || group.isLayoutSetPrototype() ||\n\t\t\t\t group.isSite() || group.isUser()) {\n\n\t\t\ttypes = RoleConstants.TYPES_REGULAR_AND_SITE;\n\t\t}\n\n\t\troles.addAll(getRoles(group.getCompanyId(), types));\n\n\t\troles.addAll(getTeamRoles(groupId));\n\n\t\treturn roles;\n\t}","id":29860,"modified_method":"@Override\n\tpublic List<Role> getGroupRelatedRoles(long groupId)\n\t\tthrows PortalException {\n\n\t\tList<Role> roles = new ArrayList<>();\n\n\t\tGroup group = groupLocalService.getGroup(groupId);\n\n\t\tif (group.isStagingGroup()) {\n\t\t\tgroup = group.getLiveGroup();\n\t\t}\n\n\t\tint[] types = RoleConstants.TYPES_REGULAR;\n\n\t\tif (group.isOrganization() && group.isSite()) {\n\t\t\ttypes = RoleConstants.TYPES_ORGANIZATION_AND_REGULAR_AND_SITE;\n\t\t}\n\t\telse if (group.isOrganization()) {\n\t\t\ttypes = RoleConstants.TYPES_ORGANIZATION_AND_REGULAR;\n\t\t}\n\t\telse if (group.isLayout() || group.isLayoutSetPrototype() ||\n\t\t\t\t group.isSite() || group.isUser()) {\n\n\t\t\ttypes = RoleConstants.TYPES_REGULAR_AND_SITE;\n\t\t}\n\n\t\troles.addAll(getRoles(group.getCompanyId(), types));\n\n\t\troles.addAll(getTeamRoles(groupId));\n\n\t\treturn roles;\n\t}","commit_id":"349761fa2fb335538c5ef3b54477cadf93a73643","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ThemeDisplay initThemeDisplay(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\t// Company\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong companyId = company.getCompanyId();\n\n\t\t// CDN host\n\n\t\tString cdnHost = null;\n\n\t\tif (request.isSecure()) {\n\t\t\tcdnHost = PortalUtil.getCDNHostHttps(companyId);\n\t\t}\n\t\telse {\n\t\t\tcdnHost = PortalUtil.getCDNHostHttp(companyId);\n\t\t}\n\n\t\tcdnHost = ParamUtil.getString(request, \"cdn_host\", cdnHost);\n\n\t\t// Portal URL\n\n\t\tString portalURL = PortalUtil.getPortalURL(request);\n\n\t\t// Paths\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\t\tString friendlyURLPrivateGroupPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup();\n\t\tString friendlyURLPrivateUserPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateUser();\n\t\tString friendlyURLPublicPath = PortalUtil.getPathFriendlyURLPublic();\n\t\tString imagePath = cdnHost.concat(PortalUtil.getPathImage());\n\t\tString mainPath = PortalUtil.getPathMain();\n\n\t\tString i18nPath = (String)request.getAttribute(WebKeys.I18N_PATH);\n\n\t\tif (Validator.isNotNull(i18nPath)) {\n\t\t\tif (Validator.isNotNull(contextPath)) {\n\t\t\t\tString i18nContextPath = contextPath.concat(i18nPath);\n\n\t\t\t\tfriendlyURLPrivateGroupPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateGroupPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPrivateUserPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateUserPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPublicPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPublicPath, contextPath, i18nContextPath);\n\t\t\t\tmainPath = StringUtil.replaceFirst(\n\t\t\t\t\tmainPath, contextPath, i18nContextPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfriendlyURLPrivateGroupPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateGroupPath);\n\t\t\t\tfriendlyURLPrivateUserPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateUserPath);\n\t\t\t\tfriendlyURLPublicPath = i18nPath.concat(friendlyURLPublicPath);\n\t\t\t\tmainPath = i18nPath.concat(mainPath);\n\t\t\t}\n\t\t}\n\n\t\t// Company logo\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(imagePath);\n\t\tsb.append(\"/company_logo?img_id=\");\n\t\tsb.append(company.getLogoId());\n\t\tsb.append(\"&t=\");\n\t\tsb.append(WebServerServletTokenUtil.getToken(company.getLogoId()));\n\n\t\tString companyLogo = sb.toString();\n\n\t\tint companyLogoHeight = 0;\n\t\tint companyLogoWidth = 0;\n\n\t\tImage companyLogoImage = ImageLocalServiceUtil.getCompanyLogo(\n\t\t\tcompany.getLogoId());\n\n\t\tif (companyLogoImage != null) {\n\t\t\tcompanyLogoHeight = companyLogoImage.getHeight();\n\t\t\tcompanyLogoWidth = companyLogoImage.getWidth();\n\t\t}\n\n\t\tString realCompanyLogo = companyLogo;\n\t\tint realCompanyLogoHeight = companyLogoHeight;\n\t\tint realCompanyLogoWidth = companyLogoWidth;\n\n\t\t// User\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.getUser(request);\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(nsue.getMessage());\n\t\t\t}\n\n\t\t\tlong userId = PortalUtil.getUserId(request);\n\n\t\t\tif (userId > 0) {\n\t\t\t\tsession.invalidate();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tboolean signedIn = false;\n\n\t\tif (user == null) {\n\t\t\tuser = company.getDefaultUser();\n\t\t}\n\t\telse if (!user.isDefaultUser()) {\n\t\t\tsignedIn = true;\n\t\t}\n\n\t\tif (PropsValues.BROWSER_CACHE_SIGNED_IN_DISABLED && signedIn) {\n\t\t\tresponse.setDateHeader(HttpHeaders.EXPIRES, 0);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.CACHE_CONTROL,\n\t\t\t\tHttpHeaders.CACHE_CONTROL_NO_CACHE_VALUE);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.PRAGMA, HttpHeaders.PRAGMA_NO_CACHE_VALUE);\n\t\t}\n\n\t\tUser realUser = user;\n\n\t\tLong realUserId = (Long)session.getAttribute(WebKeys.USER_ID);\n\n\t\tif (realUserId != null) {\n\t\t\tif (user.getUserId() != realUserId.longValue()) {\n\t\t\t\trealUser = UserLocalServiceUtil.getUserById(\n\t\t\t\t\trealUserId.longValue());\n\t\t\t}\n\t\t}\n\n\t\tString doAsUserId = ParamUtil.getString(request, \"doAsUserId\");\n\t\tString doAsUserLanguageId = ParamUtil.getString(\n\t\t\trequest, \"doAsUserLanguageId\");\n\t\tlong doAsGroupId = ParamUtil.getLong(request, \"doAsGroupId\");\n\t\tlong refererPlid = ParamUtil.getLong(request, \"refererPlid\");\n\t\tString controlPanelCategory = ParamUtil.getString(\n\t\t\trequest, \"controlPanelCategory\");\n\n\t\t// Permission checker\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionCheckerFactoryUtil.create(user, true);\n\n\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t// Locale\n\n\t\tLocale locale = (Locale)session.getAttribute(Globals.LOCALE_KEY);\n\n\t\tif (Validator.isNotNull(doAsUserLanguageId)) {\n\t\t\tlocale = LocaleUtil.fromLanguageId(doAsUserLanguageId);\n\t\t}\n\n\t\tString i18nLanguageId = (String)request.getAttribute(\n\t\t\tWebKeys.I18N_LANGUAGE_ID);\n\n\t\tif (Validator.isNotNull(i18nLanguageId)) {\n\t\t\tlocale = LocaleUtil.fromLanguageId(i18nLanguageId);\n\t\t}\n\t\telse if (locale == null) {\n\t\t\tif (signedIn) {\n\t\t\t\tlocale = user.getLocale();\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// User previously set their preferred language\n\n\t\t\t\tString languageId = CookieKeys.getCookie(\n\t\t\t\t\trequest, CookieKeys.GUEST_LANGUAGE_ID);\n\n\t\t\t\tif (Validator.isNotNull(languageId)) {\n\t\t\t\t\tlocale = LocaleUtil.fromLanguageId(languageId);\n\t\t\t\t}\n\n\t\t\t\t// Get locale from the request\n\n\t\t\t\tif ((locale == null) && PropsValues.LOCALE_DEFAULT_REQUEST) {\n\t\t\t\t\tlocale = request.getLocale();\n\t\t\t\t}\n\n\t\t\t\t// Get locale from the default user\n\n\t\t\t\tif (locale == null) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\n\t\t\t\tif (Validator.isNull(locale.getCountry())) {\n\n\t\t\t\t\t// Locales must contain a country code\n\n\t\t\t\t\tlocale = LanguageUtil.getLocale(locale.getLanguage());\n\t\t\t\t}\n\n\t\t\t\tif (!LanguageUtil.isAvailableLocale(locale)) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession.setAttribute(Globals.LOCALE_KEY, locale);\n\n\t\t\tLanguageUtil.updateCookie(request, response, locale);\n\t\t}\n\n\t\t// Cookie support\n\n\t\ttry {\n\n\t\t\t// LEP-4069\n\n\t\t\tCookieKeys.validateSupportCookie(request);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tCookieKeys.addSupportCookie(request, response);\n\t\t}\n\n\t\t// Time zone\n\n\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\tif (timeZone == null) {\n\t\t\ttimeZone = company.getTimeZone();\n\t\t}\n\n\t\t// Layouts\n\n\t\tif (signedIn) {\n\t\t\tupdateUserLayouts(user);\n\t\t}\n\n\t\tLayout layout = null;\n\t\tList<Layout> layouts = null;\n\n\t\tlong plid = ParamUtil.getLong(request, \"p_l_id\");\n\n\t\tif (plid > 0) {\n\t\t\tlayout = LayoutLocalServiceUtil.getLayout(plid);\n\t\t}\n\t\telse {\n\t\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\t\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\t\trequest, \"privateLayout\");\n\t\t\tlong layoutId = ParamUtil.getLong(request, \"layoutId\");\n\n\t\t\tif ((groupId > 0) && layoutId > 0) {\n\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tgroupId, privateLayout, layoutId);\n\t\t\t}\n\t\t}\n\n\t\t// Dynamic Site Template\n\n\t\tif (layout != null) {\n\t\t\ttry {\n\t\t\t\tif (processLayoutSetPrototype(user, layout)) {\n\t\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(layout.getPlid());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"Failed to process dynamic site templates: \" +\n\t\t\t\t\t\te.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\tGroup group = layout.getGroup();\n\n\t\t\tif (!signedIn && PropsValues.AUTH_FORWARD_BY_REDIRECT) {\n\t\t\t\trequest.setAttribute(WebKeys.REQUESTED_LAYOUT, layout);\n\t\t\t}\n\n\t\t\tboolean isViewableGroup = LayoutPermissionUtil.contains(\n\t\t\t\tpermissionChecker, layout, controlPanelCategory,\n\t\t\t\tActionKeys.VIEW);\n\t\t\tboolean isViewableStaging = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\tActionKeys.VIEW_STAGING);\n\n\t\t\tif (isViewableStaging) {\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\t\t\t}\n\t\t\telse if (!isViewableGroup && group.isStagingGroup()) {\n\t\t\t\tlayout = null;\n\t\t\t}\n\t\t\telse if (!isViewableGroup) {\n\t\t\t\tsb = new StringBundler(6);\n\n\t\t\t\tsb.append(\"User \");\n\t\t\t\tsb.append(user.getUserId());\n\t\t\t\tsb.append(\" is not allowed to access the \");\n\t\t\t\tsb.append(layout.isPrivateLayout() ? \"private\": \"public\");\n\t\t\t\tsb.append(\" pages of group \");\n\t\t\t\tsb.append(layout.getGroupId());\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t}\n\n\t\t\t\tthrow new NoSuchLayoutException(sb.toString());\n\t\t\t}\n\t\t\telse if (isViewableGroup &&\n\t\t\t\t\t!LayoutPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\tlayout = null;\n\t\t\t}\n\t\t\telse if (group.isLayoutPrototype()) {\n\t\t\t\tlayouts = new ArrayList<Layout>();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\tif (!group.isControlPanel()) {\n\t\t\t\t\tdoAsGroupId = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<Layout> unfilteredLayouts = layouts;\n\n\t\tif (layout == null) {\n\t\t\tObject[] defaultLayout = getDefaultLayout(request, user, signedIn);\n\n\t\t\tlayout = (Layout)defaultLayout[0];\n\t\t\tlayouts = (List<Layout>)defaultLayout[1];\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT_DEFAULT, Boolean.TRUE);\n\t\t}\n\n\t\tObject[] viewableLayouts = getViewableLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts);\n\n\t\tString layoutSetLogo = null;\n\n\t\tlayout = (Layout)viewableLayouts[0];\n\t\tlayouts = (List<Layout>)viewableLayouts[1];\n\n\t\tGroup group = null;\n\n\t\tif (layout != null) {\n\t\t\tgroup = layout.getGroup();\n\n\t\t\tif (!group.isControlPanel()) {\n\t\t\t\trememberVisitedGroupIds(request, group.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet = null;\n\n\t\tlayouts = mergeAdditionalLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts);\n\n\t\tLayoutSet layoutSet = null;\n\n\t\tboolean hasCustomizeLayoutPermission = false;\n\t\tboolean hasUpdateLayoutPermission = false;\n\n\t\tboolean customizedView = SessionParamUtil.getBoolean(\n\t\t\trequest, \"customized_view\", true);\n\n\t\tif (layout != null) {\n\t\t\thasCustomizeLayoutPermission = LayoutPermissionUtil.contains(\n\t\t\t\tpermissionChecker, layout, ActionKeys.CUSTOMIZE);\n\t\t\thasUpdateLayoutPermission = LayoutPermissionUtil.contains(\n\t\t\t\tpermissionChecker, layout, ActionKeys.UPDATE);\n\n\t\t\tlayoutSet = layout.getLayoutSet();\n\n\t\t\tif (company.isSiteLogo()) {\n\t\t\t\tlong logoId = 0;\n\n\t\t\t\tif (layoutSet.isLogo()) {\n\t\t\t\t\tlogoId = layoutSet.getLogoId();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLayoutSet siblingLayoutSet =\n\t\t\t\t\t\tLayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\t\t\tlayout.getGroupId(), !layout.isPrivateLayout());\n\n\t\t\t\t\tif (siblingLayoutSet.isLogo()) {\n\t\t\t\t\t\tlogoId = siblingLayoutSet.getLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logoId > 0) {\n\t\t\t\t\tsb = new StringBundler(5);\n\n\t\t\t\t\tsb.append(imagePath);\n\t\t\t\t\tsb.append(\"/layout_set_logo?img_id=\");\n\t\t\t\t\tsb.append(logoId);\n\t\t\t\t\tsb.append(\"&t=\");\n\t\t\t\t\tsb.append(WebServerServletTokenUtil.getToken(logoId));\n\n\t\t\t\t\tlayoutSetLogo = sb.toString();\n\n\t\t\t\t\tImage layoutSetLogoImage =\n\t\t\t\t\t\tImageLocalServiceUtil.getCompanyLogo(logoId);\n\n\t\t\t\t\tcompanyLogo = layoutSetLogo;\n\t\t\t\t\tcompanyLogoHeight = layoutSetLogoImage.getHeight();\n\t\t\t\t\tcompanyLogoWidth = layoutSetLogoImage.getWidth();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplid = layout.getPlid();\n\n\t\t\t// Updates to shared layouts are not reflected until the next time\n\t\t\t// the user logs in because group layouts are cached in the session\n\n\t\t\tlayout = (Layout)layout.clone();\n\n\t\t\tlayoutTypePortlet = (LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tboolean customizable = layoutTypePortlet.isCustomizable();\n\n\t\t\tif (!customizable ||\n\t\t\t\t(group.isLayoutPrototype() || group.isLayoutSetPrototype())) {\n\n\t\t\t\tcustomizedView = false;\n\t\t\t}\n\n\t\t\tlayoutTypePortlet.setCustomizedView(customizedView);\n\t\t\tlayoutTypePortlet.setUpdatePermission(hasUpdateLayoutPermission);\n\n\t\t\tif (signedIn && customizable && customizedView &&\n\t\t\t\thasCustomizeLayoutPermission) {\n\n\t\t\t\tPortalPreferences portalPreferences =\n\t\t\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t\t\tcompanyId, user.getUserId(), true);\n\n\t\t\t\tlayoutTypePortlet.setPortalPreferences(portalPreferences);\n\t\t\t}\n\n\t\t\tLayoutClone layoutClone = LayoutCloneFactory.getInstance();\n\n\t\t\tif (layoutClone != null) {\n\t\t\t\tString typeSettings = layoutClone.get(request, plid);\n\n\t\t\t\tif (typeSettings != null) {\n\t\t\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\t\t\tnew UnicodeProperties(true);\n\n\t\t\t\t\ttypeSettingsProperties.load(typeSettings);\n\n\t\t\t\t\tString stateMax = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MAX);\n\t\t\t\t\tString stateMin = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MIN);\n\t\t\t\t\tString modeAbout = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_ABOUT);\n\t\t\t\t\tString modeConfig = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_CONFIG);\n\t\t\t\t\tString modeEdit = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT);\n\t\t\t\t\tString modeEditDefaults =\n\t\t\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_DEFAULTS);\n\t\t\t\t\tString modeEditGuest = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_GUEST);\n\t\t\t\t\tString modeHelp = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_HELP);\n\t\t\t\t\tString modePreview = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PREVIEW);\n\t\t\t\t\tString modePrint = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PRINT);\n\n\t\t\t\t\tlayoutTypePortlet.setStateMax(stateMax);\n\t\t\t\t\tlayoutTypePortlet.setStateMin(stateMin);\n\t\t\t\t\tlayoutTypePortlet.setModeAbout(modeAbout);\n\t\t\t\t\tlayoutTypePortlet.setModeConfig(modeConfig);\n\t\t\t\t\tlayoutTypePortlet.setModeEdit(modeEdit);\n\t\t\t\t\tlayoutTypePortlet.setModeEditDefaults(modeEditDefaults);\n\t\t\t\t\tlayoutTypePortlet.setModeEditGuest(modeEditGuest);\n\t\t\t\t\tlayoutTypePortlet.setModeHelp(modeHelp);\n\t\t\t\t\tlayoutTypePortlet.setModePreview(modePreview);\n\t\t\t\t\tlayoutTypePortlet.setModePrint(modePrint);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT, layout);\n\t\t\trequest.setAttribute(WebKeys.LAYOUTS, layouts);\n\n\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\tpermissionChecker.setCheckGuest(false);\n\t\t\t}\n\t\t}\n\n\t\t// Scope\n\n\t\tlong scopeGroupId = PortalUtil.getScopeGroupId(request);\n\t\tlong parentGroupId = PortalUtil.getParentGroupId(scopeGroupId);\n\n\t\t// Theme and color scheme\n\n\t\tTheme theme = null;\n\t\tColorScheme colorScheme = null;\n\n\t\tboolean wapTheme = BrowserSnifferUtil.isWap(request);\n\n\t\tif ((layout != null) && group.isControlPanel()) {\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\t\t\tString colorSchemeId =\n\t\t\t\tColorSchemeImpl.getDefaultRegularColorSchemeId();\n\n\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\tcompanyId, themeId, wapTheme);\n\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, wapTheme);\n\n\t\t\tif (!wapTheme && theme.isWapTheme()) {\n\t\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tPropsValues.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID, false);\n\t\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, false);\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.THEME, theme);\n\t\t\trequest.setAttribute(WebKeys.COLOR_SCHEME, colorScheme);\n\t\t}\n\n\t\tboolean themeCssFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"css_fast_load\", PropsValues.THEME_CSS_FAST_LOAD);\n\t\tboolean themeImagesFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"images_fast_load\", PropsValues.THEME_IMAGES_FAST_LOAD);\n\n\t\tboolean themeJsBarebone = PropsValues.JAVASCRIPT_BAREBONE_ENABLED;\n\n\t\tif (themeJsBarebone) {\n\t\t\tif (signedIn) {\n\t\t\t\tthemeJsBarebone = false;\n\t\t\t}\n\t\t}\n\n\t\tboolean themeJsFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"js_fast_load\", PropsValues.JAVASCRIPT_FAST_LOAD);\n\n\t\tString lifecycle = ParamUtil.getString(request, \"p_p_lifecycle\", \"0\");\n\n\t\tlifecycle = ParamUtil.getString(request, \"p_t_lifecycle\", lifecycle);\n\n\t\tboolean isolated = ParamUtil.getBoolean(request, \"p_p_isolated\");\n\n\t\tString facebookCanvasPageURL = (String)request.getAttribute(\n\t\t\tWebKeys.FACEBOOK_CANVAS_PAGE_URL);\n\n\t\tboolean widget = false;\n\n\t\tBoolean widgetObj = (Boolean)request.getAttribute(WebKeys.WIDGET);\n\n\t\tif (widgetObj != null) {\n\t\t\twidget = widgetObj.booleanValue();\n\t\t}\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\n\t\t// Set the CDN host, portal URL, and Facebook application ID first\n\t\t// because other methods (setLookAndFeel) depend on them being set\n\n\t\tthemeDisplay.setCDNHost(cdnHost);\n\t\tthemeDisplay.setPortalURL(portalURL);\n\t\tthemeDisplay.setFacebookCanvasPageURL(facebookCanvasPageURL);\n\t\tthemeDisplay.setWidget(widget);\n\n\t\tthemeDisplay.setCompany(company);\n\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\tthemeDisplay.setCompanyLogoHeight(companyLogoHeight);\n\t\tthemeDisplay.setCompanyLogoWidth(companyLogoWidth);\n\t\tthemeDisplay.setRealCompanyLogo(realCompanyLogo);\n\t\tthemeDisplay.setRealCompanyLogoHeight(realCompanyLogoHeight);\n\t\tthemeDisplay.setRealCompanyLogoWidth(realCompanyLogoWidth);\n\t\tthemeDisplay.setUser(user);\n\t\tthemeDisplay.setRealUser(realUser);\n\t\tthemeDisplay.setDoAsUserId(doAsUserId);\n\t\tthemeDisplay.setDoAsUserLanguageId(doAsUserLanguageId);\n\t\tthemeDisplay.setDoAsGroupId(doAsGroupId);\n\t\tthemeDisplay.setRefererPlid(refererPlid);\n\t\tthemeDisplay.setControlPanelCategory(controlPanelCategory);\n\t\tthemeDisplay.setLayoutSet(layoutSet);\n\t\tthemeDisplay.setLayoutSetLogo(layoutSetLogo);\n\t\tthemeDisplay.setLayout(layout);\n\t\tthemeDisplay.setLayouts(layouts);\n\t\tthemeDisplay.setUnfilteredLayouts(unfilteredLayouts);\n\t\tthemeDisplay.setPlid(plid);\n\t\tthemeDisplay.setLayoutTypePortlet(layoutTypePortlet);\n\t\tthemeDisplay.setScopeGroupId(scopeGroupId);\n\t\tthemeDisplay.setParentGroupId(parentGroupId);\n\t\tthemeDisplay.setSignedIn(signedIn);\n\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\t\tthemeDisplay.setLocale(locale);\n\t\tthemeDisplay.setLanguageId(LocaleUtil.toLanguageId(locale));\n\t\tthemeDisplay.setI18nLanguageId(i18nLanguageId);\n\t\tthemeDisplay.setI18nPath(i18nPath);\n\t\tthemeDisplay.setTimeZone(timeZone);\n\t\tthemeDisplay.setLookAndFeel(contextPath, theme, colorScheme);\n\t\tthemeDisplay.setThemeCssFastLoad(themeCssFastLoad);\n\t\tthemeDisplay.setThemeImagesFastLoad(themeImagesFastLoad);\n\t\tthemeDisplay.setThemeJsBarebone(themeJsBarebone);\n\t\tthemeDisplay.setThemeJsFastLoad(themeJsFastLoad);\n\t\tthemeDisplay.setServerName(request.getServerName());\n\t\tthemeDisplay.setServerPort(request.getServerPort());\n\t\tthemeDisplay.setSecure(PortalUtil.isSecure(request));\n\t\tthemeDisplay.setLifecycle(lifecycle);\n\t\tthemeDisplay.setLifecycleAction(lifecycle.equals(\"1\"));\n\t\tthemeDisplay.setLifecycleRender(lifecycle.equals(\"0\"));\n\t\tthemeDisplay.setLifecycleResource(lifecycle.equals(\"2\"));\n\t\tthemeDisplay.setStateExclusive(LiferayWindowState.isExclusive(request));\n\t\tthemeDisplay.setStateMaximized(LiferayWindowState.isMaximized(request));\n\t\tthemeDisplay.setStatePopUp(LiferayWindowState.isPopUp(request));\n\t\tthemeDisplay.setIsolated(isolated);\n\t\tthemeDisplay.setPathApplet(contextPath.concat(\"/applets\"));\n\t\tthemeDisplay.setPathCms(contextPath.concat(\"/cms\"));\n\t\tthemeDisplay.setPathContext(contextPath);\n\t\tthemeDisplay.setPathFlash(contextPath.concat(\"/flash\"));\n\t\tthemeDisplay.setPathFriendlyURLPrivateGroup(\n\t\t\tfriendlyURLPrivateGroupPath);\n\t\tthemeDisplay.setPathFriendlyURLPrivateUser(friendlyURLPrivateUserPath);\n\t\tthemeDisplay.setPathFriendlyURLPublic(friendlyURLPublicPath);\n\t\tthemeDisplay.setPathImage(imagePath);\n\t\tthemeDisplay.setPathJavaScript(\n\t\t\tcdnHost.concat(contextPath).concat(\"/html/js\"));\n\t\tthemeDisplay.setPathMain(mainPath);\n\t\tthemeDisplay.setPathSound(contextPath.concat(\"/html/sound\"));\n\n\t\t// Icons\n\n\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\tthemeDisplay.setShowControlPanelIcon(signedIn);\n\t\tthemeDisplay.setShowHomeIcon(true);\n\t\tthemeDisplay.setShowMyAccountIcon(signedIn);\n\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\tthemeDisplay.setShowPortalIcon(true);\n\t\tthemeDisplay.setShowSignInIcon(!signedIn);\n\t\tthemeDisplay.setShowSignOutIcon(signedIn);\n\n\t\tboolean showSiteContentIcon = false;\n\n\t\tlong controlPanelPlid = 0;\n\n\t\tif (signedIn) {\n\t\t\tGroup controlPanelGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\tcompanyId, GroupConstants.CONTROL_PANEL);\n\n\t\t\tcontrolPanelPlid = LayoutLocalServiceUtil.getDefaultPlid(\n\t\t\t\tcontrolPanelGroup.getGroupId(), true);\n\n\t\t\tList<Portlet> siteContentPortlets =\n\t\t\t\tPortalUtil.getControlPanelPortlets(\n\t\t\t\t\tPortletCategoryKeys.CONTENT, themeDisplay);\n\n\t\t\tPortlet groupPagesPortlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\tPortletKeys.GROUP_PAGES);\n\n\t\t\tsiteContentPortlets.remove(groupPagesPortlet);\n\n\t\t\tPortlet siteMembershipsAdminPortlet =\n\t\t\t\tPortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tPortletKeys.SITE_MEMBERSHIPS_ADMIN);\n\n\t\t\tsiteContentPortlets.remove(siteMembershipsAdminPortlet);\n\n\t\t\tPortlet siteSettingsPortlet =\n\t\t\t\tPortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tPortletKeys.SITE_SETTINGS);\n\n\t\t\tsiteContentPortlets.remove(siteSettingsPortlet);\n\n\t\t\tshowSiteContentIcon = PortletPermissionUtil.contains(\n\t\t\t\tpermissionChecker, controlPanelGroup.getGroupId(),\n\t\t\t\tcontrolPanelPlid, siteContentPortlets, ActionKeys.VIEW);\n\t\t}\n\n\t\tthemeDisplay.setShowSiteContentIcon(showSiteContentIcon);\n\n\t\tthemeDisplay.setShowStagingIcon(false);\n\n\t\t// Session\n\n\t\tif (PropsValues.SESSION_ENABLE_URL_WITH_SESSION_ID &&\n\t\t\t!CookieKeys.hasSessionId(request)) {\n\n\t\t\tthemeDisplay.setAddSessionIdToURL(true);\n\t\t\tthemeDisplay.setSessionId(session.getId());\n\t\t}\n\n\t\t// URLs\n\n\t\tString urlControlPanel = friendlyURLPrivateGroupPath.concat(\n\t\t\tGroupConstants.CONTROL_PANEL_FRIENDLY_URL);\n\n\t\tif (Validator.isNotNull(doAsUserId)) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsUserId\", doAsUserId);\n\t\t}\n\n\t\tif (scopeGroupId > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsGroupId\", scopeGroupId);\n\t\t}\n\n\t\tif (refererPlid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", refererPlid);\n\t\t}\n\t\telse if (plid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", plid);\n\t\t}\n\n\t\tif (themeDisplay.isAddSessionIdToURL()) {\n\t\t\turlControlPanel = PortalUtil.getURLWithSessionId(\n\t\t\t\turlControlPanel, session.getId());\n\t\t}\n\n\t\tthemeDisplay.setURLControlPanel(urlControlPanel);\n\n\t\tString siteContentURL = urlControlPanel;\n\n\t\tsiteContentURL = HttpUtil.addParameter(\n\t\t\tsiteContentURL, \"controlPanelCategory\",\n\t\t\tPortletCategoryKeys.CONTENT);\n\n\t\tthemeDisplay.setURLSiteContent(siteContentURL);\n\n\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\tthemeDisplay.setURLCurrent(currentURL);\n\n\t\tString urlHome = PortalUtil.getHomeURL(request);\n\n\t\tthemeDisplay.setURLHome(urlHome);\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypePortlet()) {\n\t\t\t\tboolean freeformLayout =\n\t\t\t\t\tlayoutTypePortlet.getLayoutTemplateId().equals(\n\t\t\t\t\t\t\"freeform\");\n\n\t\t\t\tthemeDisplay.setFreeformLayout(freeformLayout);\n\n\t\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(true);\n\n\t\t\t\t\tif (!group.isUser()) {\n\t\t\t\t\t\tthemeDisplay.setShowPageCustomizationIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.toggle('\".concat(\n\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION).concat(\"');\"));\n\n\t\t\t\t\tthemeDisplay.setURLLayoutTemplates(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.showTemplates();\");\n\t\t\t\t}\n\n\t\t\t\tif (hasCustomizeLayoutPermission && customizedView) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.toggle('\".concat(\n\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION).concat(\"');\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (signedIn) {\n\t\t\t\tif (group.isUser()) {\n\t\t\t\t\tif ((layout.isPrivateLayout() &&\n\t\t\t\t\t\t !PropsValues.LAYOUT_USER_PRIVATE_LAYOUTS_MODIFIABLE) ||\n\t\t\t\t\t\t(layout.isPublicLayout() &&\n\t\t\t\t\t\t !PropsValues.LAYOUT_USER_PUBLIC_LAYOUTS_MODIFIABLE)) {\n\n\t\t\t\t\t\thasUpdateLayoutPermission = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\n\t\t\t\tPortletURL pageSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tpageSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tpageSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/layouts_admin/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tpageSettingsURL.setParameter(\"closeRedirect\", currentURL);\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tpageSettingsURL.setParameter(\"selPlid\", String.valueOf(plid));\n\n\t\t\t\tthemeDisplay.setURLPageSettings(pageSettingsURL);\n\n\t\t\t\tif (group.isSite() &&\n\t\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, scopeGroupId,\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS)) {\n\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(true);\n\n\t\t\t\t\tPortletURL manageSiteMembershipsURL = new PortletURLImpl(\n\t\t\t\t\t\trequest, PortletKeys.SITE_MEMBERSHIPS_ADMIN,\n\t\t\t\t\t\tcontrolPanelPlid, PortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\t\tmanageSiteMembershipsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site_assignments\");\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\n\t\t\t\t\tthemeDisplay.setURLManageSiteMemberships(\n\t\t\t\t\t\tmanageSiteMembershipsURL);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean hasAddLayoutGroupPermission =\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.ADD_LAYOUT);\n\t\t\tboolean hasAddLayoutLayoutPermission =\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.ADD_LAYOUT);\n\t\t\tboolean hasManageLayoutsGroupPermission =\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.MANAGE_LAYOUTS);\n\t\t\tboolean hasManageStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.MANAGE_STAGING);\n\t\t\tboolean hasPublishStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.PUBLISH_STAGING);\n\t\t\tboolean hasUpdateGroupPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.UPDATE);\n\t\t\tboolean hasViewStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.VIEW_STAGING);\n\n\t\t\tif (!group.isControlPanel() && !group.isUser() &&\n\t\t\t\t!group.isUserGroup() && hasUpdateGroupPermission) {\n\n\t\t\t\tthemeDisplay.setShowSiteSettingsIcon(true);\n\n\t\t\t\tPortletURL siteSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_SETTINGS, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tsiteSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site\");\n\t\t\t\tsiteSettingsURL.setParameter(\"closeRedirect\", currentURL);\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\n\t\t\t\tthemeDisplay.setURLSiteSettings(siteSettingsURL);\n\t\t\t}\n\n\t\t\tif (!group.isLayoutPrototype() &&\n\t\t\t\t(hasAddLayoutGroupPermission || hasAddLayoutLayoutPermission ||\n\t\t\t\t hasManageLayoutsGroupPermission || hasUpdateGroupPermission)) {\n\n\t\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(true);\n\n\t\t\t\tPortletURL siteMapSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteMapSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tsiteMapSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/layouts_admin/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\"closeRedirect\", currentURL);\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\n\t\t\t\tthemeDisplay.setURLSiteMapSettings(siteMapSettingsURL);\n\t\t\t}\n\n\t\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\tif (group.isControlPanel()) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\t// LEP-4987\n\n\t\t\tif (group.isStaged() || group.isStagingGroup()) {\n\t\t\t\tif (hasManageStagingPermission || hasPublishStagingPermission ||\n\t\t\t\t\thasUpdateLayoutPermission || hasViewStagingPermission) {\n\n\t\t\t\t\tthemeDisplay.setShowStagingIcon(true);\n\t\t\t\t}\n\n\t\t\t\tif (hasPublishStagingPermission) {\n\t\t\t\t\tPortletURL publishToLiveURL = new PortletURLImpl(\n\t\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, plid,\n\t\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tpublishToLiveURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.EXCLUSIVE);\n\t\t\t\t\tpublishToLiveURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/layouts_admin/publish_layouts\");\n\n\t\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t\t}\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\"pagesRedirect\", currentURL);\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\n\t\t\t\t\tthemeDisplay.setURLPublishToLive(publishToLiveURL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPortletURLImpl myAccountURL = new PortletURLImpl(\n\t\t\t\trequest, PortletKeys.MY_ACCOUNT, controlPanelPlid,\n\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\tmyAccountURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\tmyAccountURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\tif (scopeGroupId > 0) {\n\t\t\t\tmyAccountURL.setDoAsGroupId(scopeGroupId);\n\t\t\t}\n\n\t\t\tif (refererPlid > 0) {\n\t\t\t\tmyAccountURL.setRefererPlid(refererPlid);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmyAccountURL.setRefererPlid(plid);\n\t\t\t}\n\n\t\t\tmyAccountURL.setParameter(\"struts_action\", \"/my_account/edit_user\");\n\n\t\t\tthemeDisplay.setURLMyAccount(myAccountURL);\n\t\t}\n\n\t\tif ((!user.isActive()) ||\n\t\t\t(PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.TERMS_OF_USE_REQUIRED) &&\n\t\t\t !user.isAgreedToTermsOfUse())) {\n\n\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutPrototype()) {\n\t\t\tthemeDisplay.setShowControlPanelIcon(false);\n\t\t\tthemeDisplay.setShowHomeIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\t\t\tthemeDisplay.setShowPortalIcon(false);\n\t\t\tthemeDisplay.setShowSignInIcon(false);\n\t\t\tthemeDisplay.setShowSignOutIcon(false);\n\t\t\tthemeDisplay.setShowSiteContentIcon(false);\n\t\t\tthemeDisplay.setShowStagingIcon(false);\n\t\t}\n\n\t\tthemeDisplay.setURLPortal(portalURL.concat(contextPath));\n\n\t\tString urlSignIn = mainPath.concat(\"/portal/login\");\n\n\t\tif (layout != null) {\n\t\t\turlSignIn = HttpUtil.addParameter(\n\t\t\t\turlSignIn, \"p_l_id\", layout.getPlid());\n\t\t}\n\n\t\tthemeDisplay.setURLSignIn(urlSignIn);\n\n\t\tthemeDisplay.setURLSignOut(mainPath.concat(\"/portal/logout\"));\n\n\t\tPortletURL updateManagerURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.UPDATE_MANAGER, plid,\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tupdateManagerURL.setWindowState(WindowState.MAXIMIZED);\n\t\tupdateManagerURL.setPortletMode(PortletMode.VIEW);\n\n\t\tupdateManagerURL.setParameter(\"struts_action\", \"/update_manager/view\");\n\n\t\tthemeDisplay.setURLUpdateManager(updateManagerURL);\n\n\t\treturn themeDisplay;\n\t}","id":29861,"modified_method":"public ThemeDisplay initThemeDisplay(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\t// Company\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong companyId = company.getCompanyId();\n\n\t\t// CDN host\n\n\t\tString cdnHost = null;\n\n\t\tif (request.isSecure()) {\n\t\t\tcdnHost = PortalUtil.getCDNHostHttps(companyId);\n\t\t}\n\t\telse {\n\t\t\tcdnHost = PortalUtil.getCDNHostHttp(companyId);\n\t\t}\n\n\t\tcdnHost = ParamUtil.getString(request, \"cdn_host\", cdnHost);\n\n\t\t// Portal URL\n\n\t\tString portalURL = PortalUtil.getPortalURL(request);\n\n\t\t// Paths\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\t\tString friendlyURLPrivateGroupPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup();\n\t\tString friendlyURLPrivateUserPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateUser();\n\t\tString friendlyURLPublicPath = PortalUtil.getPathFriendlyURLPublic();\n\t\tString imagePath = cdnHost.concat(PortalUtil.getPathImage());\n\t\tString mainPath = PortalUtil.getPathMain();\n\n\t\tString i18nPath = (String)request.getAttribute(WebKeys.I18N_PATH);\n\n\t\tif (Validator.isNotNull(i18nPath)) {\n\t\t\tif (Validator.isNotNull(contextPath)) {\n\t\t\t\tString i18nContextPath = contextPath.concat(i18nPath);\n\n\t\t\t\tfriendlyURLPrivateGroupPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateGroupPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPrivateUserPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateUserPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPublicPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPublicPath, contextPath, i18nContextPath);\n\t\t\t\tmainPath = StringUtil.replaceFirst(\n\t\t\t\t\tmainPath, contextPath, i18nContextPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfriendlyURLPrivateGroupPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateGroupPath);\n\t\t\t\tfriendlyURLPrivateUserPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateUserPath);\n\t\t\t\tfriendlyURLPublicPath = i18nPath.concat(friendlyURLPublicPath);\n\t\t\t\tmainPath = i18nPath.concat(mainPath);\n\t\t\t}\n\t\t}\n\n\t\t// Company logo\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(imagePath);\n\t\tsb.append(\"/company_logo?img_id=\");\n\t\tsb.append(company.getLogoId());\n\t\tsb.append(\"&t=\");\n\t\tsb.append(WebServerServletTokenUtil.getToken(company.getLogoId()));\n\n\t\tString companyLogo = sb.toString();\n\n\t\tint companyLogoHeight = 0;\n\t\tint companyLogoWidth = 0;\n\n\t\tImage companyLogoImage = ImageLocalServiceUtil.getCompanyLogo(\n\t\t\tcompany.getLogoId());\n\n\t\tif (companyLogoImage != null) {\n\t\t\tcompanyLogoHeight = companyLogoImage.getHeight();\n\t\t\tcompanyLogoWidth = companyLogoImage.getWidth();\n\t\t}\n\n\t\tString realCompanyLogo = companyLogo;\n\t\tint realCompanyLogoHeight = companyLogoHeight;\n\t\tint realCompanyLogoWidth = companyLogoWidth;\n\n\t\t// User\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.getUser(request);\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(nsue.getMessage());\n\t\t\t}\n\n\t\t\tlong userId = PortalUtil.getUserId(request);\n\n\t\t\tif (userId > 0) {\n\t\t\t\tsession.invalidate();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tboolean signedIn = false;\n\n\t\tif (user == null) {\n\t\t\tuser = company.getDefaultUser();\n\t\t}\n\t\telse if (!user.isDefaultUser()) {\n\t\t\tsignedIn = true;\n\t\t}\n\n\t\tif (PropsValues.BROWSER_CACHE_SIGNED_IN_DISABLED && signedIn) {\n\t\t\tresponse.setDateHeader(HttpHeaders.EXPIRES, 0);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.CACHE_CONTROL,\n\t\t\t\tHttpHeaders.CACHE_CONTROL_NO_CACHE_VALUE);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.PRAGMA, HttpHeaders.PRAGMA_NO_CACHE_VALUE);\n\t\t}\n\n\t\tUser realUser = user;\n\n\t\tLong realUserId = (Long)session.getAttribute(WebKeys.USER_ID);\n\n\t\tif (realUserId != null) {\n\t\t\tif (user.getUserId() != realUserId.longValue()) {\n\t\t\t\trealUser = UserLocalServiceUtil.getUserById(\n\t\t\t\t\trealUserId.longValue());\n\t\t\t}\n\t\t}\n\n\t\tString doAsUserId = ParamUtil.getString(request, \"doAsUserId\");\n\t\tString doAsUserLanguageId = ParamUtil.getString(\n\t\t\trequest, \"doAsUserLanguageId\");\n\t\tlong doAsGroupId = ParamUtil.getLong(request, \"doAsGroupId\");\n\t\tlong refererPlid = ParamUtil.getLong(request, \"refererPlid\");\n\t\tString controlPanelCategory = ParamUtil.getString(\n\t\t\trequest, \"controlPanelCategory\");\n\n\t\t// Permission checker\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionCheckerFactoryUtil.create(user, true);\n\n\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t// Locale\n\n\t\tLocale locale = (Locale)session.getAttribute(Globals.LOCALE_KEY);\n\n\t\tif (Validator.isNotNull(doAsUserLanguageId)) {\n\t\t\tlocale = LocaleUtil.fromLanguageId(doAsUserLanguageId);\n\t\t}\n\n\t\tString i18nLanguageId = (String)request.getAttribute(\n\t\t\tWebKeys.I18N_LANGUAGE_ID);\n\n\t\tif (Validator.isNotNull(i18nLanguageId)) {\n\t\t\tlocale = LocaleUtil.fromLanguageId(i18nLanguageId);\n\t\t}\n\t\telse if (locale == null) {\n\t\t\tif (signedIn) {\n\t\t\t\tlocale = user.getLocale();\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// User previously set their preferred language\n\n\t\t\t\tString languageId = CookieKeys.getCookie(\n\t\t\t\t\trequest, CookieKeys.GUEST_LANGUAGE_ID);\n\n\t\t\t\tif (Validator.isNotNull(languageId)) {\n\t\t\t\t\tlocale = LocaleUtil.fromLanguageId(languageId);\n\t\t\t\t}\n\n\t\t\t\t// Get locale from the request\n\n\t\t\t\tif ((locale == null) && PropsValues.LOCALE_DEFAULT_REQUEST) {\n\t\t\t\t\tlocale = request.getLocale();\n\t\t\t\t}\n\n\t\t\t\t// Get locale from the default user\n\n\t\t\t\tif (locale == null) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\n\t\t\t\tif (Validator.isNull(locale.getCountry())) {\n\n\t\t\t\t\t// Locales must contain a country code\n\n\t\t\t\t\tlocale = LanguageUtil.getLocale(locale.getLanguage());\n\t\t\t\t}\n\n\t\t\t\tif (!LanguageUtil.isAvailableLocale(locale)) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession.setAttribute(Globals.LOCALE_KEY, locale);\n\n\t\t\tLanguageUtil.updateCookie(request, response, locale);\n\t\t}\n\n\t\t// Cookie support\n\n\t\ttry {\n\n\t\t\t// LEP-4069\n\n\t\t\tCookieKeys.validateSupportCookie(request);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tCookieKeys.addSupportCookie(request, response);\n\t\t}\n\n\t\t// Time zone\n\n\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\tif (timeZone == null) {\n\t\t\ttimeZone = company.getTimeZone();\n\t\t}\n\n\t\t// Layouts\n\n\t\tif (signedIn) {\n\t\t\tupdateUserLayouts(user);\n\t\t}\n\n\t\tLayout layout = null;\n\t\tList<Layout> layouts = null;\n\n\t\tlong plid = ParamUtil.getLong(request, \"p_l_id\");\n\n\t\tif (plid > 0) {\n\t\t\tlayout = LayoutLocalServiceUtil.getLayout(plid);\n\t\t}\n\t\telse {\n\t\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\t\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\t\trequest, \"privateLayout\");\n\t\t\tlong layoutId = ParamUtil.getLong(request, \"layoutId\");\n\n\t\t\tif ((groupId > 0) && layoutId > 0) {\n\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tgroupId, privateLayout, layoutId);\n\t\t\t}\n\t\t}\n\n\t\t// Dynamic Site Template\n\n\t\tif (layout != null) {\n\t\t\ttry {\n\t\t\t\tif (processLayoutSetPrototype(user, layout)) {\n\t\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(layout.getPlid());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"Failed to process dynamic site templates: \" +\n\t\t\t\t\t\te.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\tGroup group = layout.getGroup();\n\n\t\t\tif (!signedIn && PropsValues.AUTH_FORWARD_BY_REDIRECT) {\n\t\t\t\trequest.setAttribute(WebKeys.REQUESTED_LAYOUT, layout);\n\t\t\t}\n\n\t\t\tboolean isViewableGroup = LayoutPermissionUtil.contains(\n\t\t\t\tpermissionChecker, layout, controlPanelCategory,\n\t\t\t\tActionKeys.VIEW);\n\t\t\tboolean isViewableStaging = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\tActionKeys.VIEW_STAGING);\n\n\t\t\tif (isViewableStaging) {\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\t\t\t}\n\t\t\telse if (!isViewableGroup && group.isStagingGroup()) {\n\t\t\t\tlayout = null;\n\t\t\t}\n\t\t\telse if (!isViewableGroup) {\n\t\t\t\tsb = new StringBundler(6);\n\n\t\t\t\tsb.append(\"User \");\n\t\t\t\tsb.append(user.getUserId());\n\t\t\t\tsb.append(\" is not allowed to access the \");\n\t\t\t\tsb.append(layout.isPrivateLayout() ? \"private\": \"public\");\n\t\t\t\tsb.append(\" pages of group \");\n\t\t\t\tsb.append(layout.getGroupId());\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t}\n\n\t\t\t\tthrow new NoSuchLayoutException(sb.toString());\n\t\t\t}\n\t\t\telse if (isViewableGroup &&\n\t\t\t\t\t!LayoutPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\tlayout = null;\n\t\t\t}\n\t\t\telse if (group.isLayoutPrototype()) {\n\t\t\t\tlayouts = new ArrayList<Layout>();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\tif (!group.isControlPanel()) {\n\t\t\t\t\tdoAsGroupId = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<Layout> unfilteredLayouts = layouts;\n\n\t\tif (layout == null) {\n\t\t\tObject[] defaultLayout = getDefaultLayout(request, user, signedIn);\n\n\t\t\tlayout = (Layout)defaultLayout[0];\n\t\t\tlayouts = (List<Layout>)defaultLayout[1];\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT_DEFAULT, Boolean.TRUE);\n\t\t}\n\n\t\tObject[] viewableLayouts = getViewableLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts);\n\n\t\tString layoutSetLogo = null;\n\n\t\tlayout = (Layout)viewableLayouts[0];\n\t\tlayouts = (List<Layout>)viewableLayouts[1];\n\n\t\tGroup group = null;\n\n\t\tif (layout != null) {\n\t\t\tgroup = layout.getGroup();\n\n\t\t\tif (!group.isControlPanel()) {\n\t\t\t\trememberVisitedGroupIds(request, group.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet = null;\n\n\t\tlayouts = mergeAdditionalLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts);\n\n\t\tLayoutSet layoutSet = null;\n\n\t\tboolean hasCustomizeLayoutPermission = false;\n\t\tboolean hasUpdateLayoutPermission = false;\n\n\t\tboolean customizedView = SessionParamUtil.getBoolean(\n\t\t\trequest, \"customized_view\", true);\n\n\t\tif (layout != null) {\n\t\t\thasCustomizeLayoutPermission = LayoutPermissionUtil.contains(\n\t\t\t\tpermissionChecker, layout, ActionKeys.CUSTOMIZE);\n\t\t\thasUpdateLayoutPermission = LayoutPermissionUtil.contains(\n\t\t\t\tpermissionChecker, layout, ActionKeys.UPDATE);\n\n\t\t\tlayoutSet = layout.getLayoutSet();\n\n\t\t\tif (company.isSiteLogo()) {\n\t\t\t\tlong logoId = 0;\n\n\t\t\t\tif (layoutSet.isLogo()) {\n\t\t\t\t\tlogoId = layoutSet.getLogoId();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLayoutSet siblingLayoutSet =\n\t\t\t\t\t\tLayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\t\t\tlayout.getGroupId(), !layout.isPrivateLayout());\n\n\t\t\t\t\tif (siblingLayoutSet.isLogo()) {\n\t\t\t\t\t\tlogoId = siblingLayoutSet.getLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logoId > 0) {\n\t\t\t\t\tsb = new StringBundler(5);\n\n\t\t\t\t\tsb.append(imagePath);\n\t\t\t\t\tsb.append(\"/layout_set_logo?img_id=\");\n\t\t\t\t\tsb.append(logoId);\n\t\t\t\t\tsb.append(\"&t=\");\n\t\t\t\t\tsb.append(WebServerServletTokenUtil.getToken(logoId));\n\n\t\t\t\t\tlayoutSetLogo = sb.toString();\n\n\t\t\t\t\tImage layoutSetLogoImage =\n\t\t\t\t\t\tImageLocalServiceUtil.getCompanyLogo(logoId);\n\n\t\t\t\t\tcompanyLogo = layoutSetLogo;\n\t\t\t\t\tcompanyLogoHeight = layoutSetLogoImage.getHeight();\n\t\t\t\t\tcompanyLogoWidth = layoutSetLogoImage.getWidth();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplid = layout.getPlid();\n\n\t\t\t// Updates to shared layouts are not reflected until the next time\n\t\t\t// the user logs in because group layouts are cached in the session\n\n\t\t\tlayout = (Layout)layout.clone();\n\n\t\t\tlayoutTypePortlet = (LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tboolean customizable = layoutTypePortlet.isCustomizable();\n\n\t\t\tif (!customizable ||\n\t\t\t\t(group.isLayoutPrototype() || group.isLayoutSetPrototype())) {\n\n\t\t\t\tcustomizedView = false;\n\t\t\t}\n\n\t\t\tlayoutTypePortlet.setCustomizedView(customizedView);\n\t\t\tlayoutTypePortlet.setUpdatePermission(hasUpdateLayoutPermission);\n\n\t\t\tif (signedIn && customizable && customizedView &&\n\t\t\t\thasCustomizeLayoutPermission) {\n\n\t\t\t\tPortalPreferences portalPreferences =\n\t\t\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t\t\tcompanyId, user.getUserId(), true);\n\n\t\t\t\tlayoutTypePortlet.setPortalPreferences(portalPreferences);\n\t\t\t}\n\n\t\t\tLayoutClone layoutClone = LayoutCloneFactory.getInstance();\n\n\t\t\tif (layoutClone != null) {\n\t\t\t\tString typeSettings = layoutClone.get(request, plid);\n\n\t\t\t\tif (typeSettings != null) {\n\t\t\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\t\t\tnew UnicodeProperties(true);\n\n\t\t\t\t\ttypeSettingsProperties.load(typeSettings);\n\n\t\t\t\t\tString stateMax = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MAX);\n\t\t\t\t\tString stateMin = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MIN);\n\t\t\t\t\tString modeAbout = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_ABOUT);\n\t\t\t\t\tString modeConfig = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_CONFIG);\n\t\t\t\t\tString modeEdit = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT);\n\t\t\t\t\tString modeEditDefaults =\n\t\t\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_DEFAULTS);\n\t\t\t\t\tString modeEditGuest = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_GUEST);\n\t\t\t\t\tString modeHelp = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_HELP);\n\t\t\t\t\tString modePreview = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PREVIEW);\n\t\t\t\t\tString modePrint = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PRINT);\n\n\t\t\t\t\tlayoutTypePortlet.setStateMax(stateMax);\n\t\t\t\t\tlayoutTypePortlet.setStateMin(stateMin);\n\t\t\t\t\tlayoutTypePortlet.setModeAbout(modeAbout);\n\t\t\t\t\tlayoutTypePortlet.setModeConfig(modeConfig);\n\t\t\t\t\tlayoutTypePortlet.setModeEdit(modeEdit);\n\t\t\t\t\tlayoutTypePortlet.setModeEditDefaults(modeEditDefaults);\n\t\t\t\t\tlayoutTypePortlet.setModeEditGuest(modeEditGuest);\n\t\t\t\t\tlayoutTypePortlet.setModeHelp(modeHelp);\n\t\t\t\t\tlayoutTypePortlet.setModePreview(modePreview);\n\t\t\t\t\tlayoutTypePortlet.setModePrint(modePrint);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT, layout);\n\t\t\trequest.setAttribute(WebKeys.LAYOUTS, layouts);\n\n\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\tpermissionChecker.setCheckGuest(false);\n\t\t\t}\n\t\t}\n\n\t\t// Scope\n\n\t\tlong scopeGroupId = PortalUtil.getScopeGroupId(request);\n\t\tlong parentGroupId = PortalUtil.getParentGroupId(scopeGroupId);\n\n\t\t// Theme and color scheme\n\n\t\tTheme theme = null;\n\t\tColorScheme colorScheme = null;\n\n\t\tboolean wapTheme = BrowserSnifferUtil.isWap(request);\n\n\t\tif ((layout != null) && group.isControlPanel()) {\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\t\t\tString colorSchemeId =\n\t\t\t\tColorSchemeImpl.getDefaultRegularColorSchemeId();\n\n\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\tcompanyId, themeId, wapTheme);\n\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, wapTheme);\n\n\t\t\tif (!wapTheme && theme.isWapTheme()) {\n\t\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tPropsValues.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID, false);\n\t\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, false);\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.THEME, theme);\n\t\t\trequest.setAttribute(WebKeys.COLOR_SCHEME, colorScheme);\n\t\t}\n\n\t\tboolean themeCssFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"css_fast_load\", PropsValues.THEME_CSS_FAST_LOAD);\n\t\tboolean themeImagesFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"images_fast_load\", PropsValues.THEME_IMAGES_FAST_LOAD);\n\n\t\tboolean themeJsBarebone = PropsValues.JAVASCRIPT_BAREBONE_ENABLED;\n\n\t\tif (themeJsBarebone) {\n\t\t\tif (signedIn) {\n\t\t\t\tthemeJsBarebone = false;\n\t\t\t}\n\t\t}\n\n\t\tboolean themeJsFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"js_fast_load\", PropsValues.JAVASCRIPT_FAST_LOAD);\n\n\t\tString lifecycle = ParamUtil.getString(request, \"p_p_lifecycle\", \"0\");\n\n\t\tlifecycle = ParamUtil.getString(request, \"p_t_lifecycle\", lifecycle);\n\n\t\tboolean isolated = ParamUtil.getBoolean(request, \"p_p_isolated\");\n\n\t\tString facebookCanvasPageURL = (String)request.getAttribute(\n\t\t\tWebKeys.FACEBOOK_CANVAS_PAGE_URL);\n\n\t\tboolean widget = false;\n\n\t\tBoolean widgetObj = (Boolean)request.getAttribute(WebKeys.WIDGET);\n\n\t\tif (widgetObj != null) {\n\t\t\twidget = widgetObj.booleanValue();\n\t\t}\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\n\t\t// Set the CDN host, portal URL, and Facebook application ID first\n\t\t// because other methods (setLookAndFeel) depend on them being set\n\n\t\tthemeDisplay.setCDNHost(cdnHost);\n\t\tthemeDisplay.setPortalURL(portalURL);\n\t\tthemeDisplay.setFacebookCanvasPageURL(facebookCanvasPageURL);\n\t\tthemeDisplay.setWidget(widget);\n\n\t\tthemeDisplay.setCompany(company);\n\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\tthemeDisplay.setCompanyLogoHeight(companyLogoHeight);\n\t\tthemeDisplay.setCompanyLogoWidth(companyLogoWidth);\n\t\tthemeDisplay.setRealCompanyLogo(realCompanyLogo);\n\t\tthemeDisplay.setRealCompanyLogoHeight(realCompanyLogoHeight);\n\t\tthemeDisplay.setRealCompanyLogoWidth(realCompanyLogoWidth);\n\t\tthemeDisplay.setUser(user);\n\t\tthemeDisplay.setRealUser(realUser);\n\t\tthemeDisplay.setDoAsUserId(doAsUserId);\n\t\tthemeDisplay.setDoAsUserLanguageId(doAsUserLanguageId);\n\t\tthemeDisplay.setDoAsGroupId(doAsGroupId);\n\t\tthemeDisplay.setRefererPlid(refererPlid);\n\t\tthemeDisplay.setControlPanelCategory(controlPanelCategory);\n\t\tthemeDisplay.setLayoutSet(layoutSet);\n\t\tthemeDisplay.setLayoutSetLogo(layoutSetLogo);\n\t\tthemeDisplay.setLayout(layout);\n\t\tthemeDisplay.setLayouts(layouts);\n\t\tthemeDisplay.setUnfilteredLayouts(unfilteredLayouts);\n\t\tthemeDisplay.setPlid(plid);\n\t\tthemeDisplay.setLayoutTypePortlet(layoutTypePortlet);\n\t\tthemeDisplay.setScopeGroupId(scopeGroupId);\n\t\tthemeDisplay.setParentGroupId(parentGroupId);\n\t\tthemeDisplay.setSignedIn(signedIn);\n\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\t\tthemeDisplay.setLocale(locale);\n\t\tthemeDisplay.setLanguageId(LocaleUtil.toLanguageId(locale));\n\t\tthemeDisplay.setI18nLanguageId(i18nLanguageId);\n\t\tthemeDisplay.setI18nPath(i18nPath);\n\t\tthemeDisplay.setTimeZone(timeZone);\n\t\tthemeDisplay.setLookAndFeel(contextPath, theme, colorScheme);\n\t\tthemeDisplay.setThemeCssFastLoad(themeCssFastLoad);\n\t\tthemeDisplay.setThemeImagesFastLoad(themeImagesFastLoad);\n\t\tthemeDisplay.setThemeJsBarebone(themeJsBarebone);\n\t\tthemeDisplay.setThemeJsFastLoad(themeJsFastLoad);\n\t\tthemeDisplay.setServerName(request.getServerName());\n\t\tthemeDisplay.setServerPort(request.getServerPort());\n\t\tthemeDisplay.setSecure(PortalUtil.isSecure(request));\n\t\tthemeDisplay.setLifecycle(lifecycle);\n\t\tthemeDisplay.setLifecycleAction(lifecycle.equals(\"1\"));\n\t\tthemeDisplay.setLifecycleRender(lifecycle.equals(\"0\"));\n\t\tthemeDisplay.setLifecycleResource(lifecycle.equals(\"2\"));\n\t\tthemeDisplay.setStateExclusive(LiferayWindowState.isExclusive(request));\n\t\tthemeDisplay.setStateMaximized(LiferayWindowState.isMaximized(request));\n\t\tthemeDisplay.setStatePopUp(LiferayWindowState.isPopUp(request));\n\t\tthemeDisplay.setIsolated(isolated);\n\t\tthemeDisplay.setPathApplet(contextPath.concat(\"/applets\"));\n\t\tthemeDisplay.setPathCms(contextPath.concat(\"/cms\"));\n\t\tthemeDisplay.setPathContext(contextPath);\n\t\tthemeDisplay.setPathFlash(contextPath.concat(\"/flash\"));\n\t\tthemeDisplay.setPathFriendlyURLPrivateGroup(\n\t\t\tfriendlyURLPrivateGroupPath);\n\t\tthemeDisplay.setPathFriendlyURLPrivateUser(friendlyURLPrivateUserPath);\n\t\tthemeDisplay.setPathFriendlyURLPublic(friendlyURLPublicPath);\n\t\tthemeDisplay.setPathImage(imagePath);\n\t\tthemeDisplay.setPathJavaScript(\n\t\t\tcdnHost.concat(contextPath).concat(\"/html/js\"));\n\t\tthemeDisplay.setPathMain(mainPath);\n\t\tthemeDisplay.setPathSound(contextPath.concat(\"/html/sound\"));\n\n\t\t// Icons\n\n\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\tthemeDisplay.setShowControlPanelIcon(signedIn);\n\t\tthemeDisplay.setShowHomeIcon(true);\n\t\tthemeDisplay.setShowMyAccountIcon(signedIn);\n\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\tthemeDisplay.setShowPortalIcon(true);\n\t\tthemeDisplay.setShowSignInIcon(!signedIn);\n\t\tthemeDisplay.setShowSignOutIcon(signedIn);\n\n\t\tboolean showSiteContentIcon = false;\n\n\t\tlong controlPanelPlid = 0;\n\n\t\tif (signedIn) {\n\t\t\tGroup controlPanelGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\tcompanyId, GroupConstants.CONTROL_PANEL);\n\n\t\t\tcontrolPanelPlid = LayoutLocalServiceUtil.getDefaultPlid(\n\t\t\t\tcontrolPanelGroup.getGroupId(), true);\n\n\t\t\tList<Portlet> siteContentPortlets =\n\t\t\t\tPortalUtil.getControlPanelPortlets(\n\t\t\t\t\tPortletCategoryKeys.CONTENT, themeDisplay);\n\n\t\t\tPortlet groupPagesPortlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\tPortletKeys.GROUP_PAGES);\n\n\t\t\tsiteContentPortlets.remove(groupPagesPortlet);\n\n\t\t\tPortlet siteMembershipsAdminPortlet =\n\t\t\t\tPortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tPortletKeys.SITE_MEMBERSHIPS_ADMIN);\n\n\t\t\tsiteContentPortlets.remove(siteMembershipsAdminPortlet);\n\n\t\t\tPortlet siteSettingsPortlet =\n\t\t\t\tPortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tPortletKeys.SITE_SETTINGS);\n\n\t\t\tsiteContentPortlets.remove(siteSettingsPortlet);\n\n\t\t\tshowSiteContentIcon = PortletPermissionUtil.contains(\n\t\t\t\tpermissionChecker, controlPanelGroup.getGroupId(),\n\t\t\t\tcontrolPanelPlid, siteContentPortlets, ActionKeys.VIEW);\n\t\t}\n\n\t\tthemeDisplay.setShowSiteContentIcon(showSiteContentIcon);\n\n\t\tthemeDisplay.setShowStagingIcon(false);\n\n\t\t// Session\n\n\t\tif (PropsValues.SESSION_ENABLE_URL_WITH_SESSION_ID &&\n\t\t\t!CookieKeys.hasSessionId(request)) {\n\n\t\t\tthemeDisplay.setAddSessionIdToURL(true);\n\t\t\tthemeDisplay.setSessionId(session.getId());\n\t\t}\n\n\t\t// URLs\n\n\t\tString urlControlPanel = friendlyURLPrivateGroupPath.concat(\n\t\t\tGroupConstants.CONTROL_PANEL_FRIENDLY_URL);\n\n\t\tif (Validator.isNotNull(doAsUserId)) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsUserId\", doAsUserId);\n\t\t}\n\n\t\tif (scopeGroupId > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsGroupId\", scopeGroupId);\n\t\t}\n\n\t\tif (refererPlid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", refererPlid);\n\t\t}\n\t\telse if (plid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", plid);\n\t\t}\n\n\t\tif (themeDisplay.isAddSessionIdToURL()) {\n\t\t\turlControlPanel = PortalUtil.getURLWithSessionId(\n\t\t\t\turlControlPanel, session.getId());\n\t\t}\n\n\t\tthemeDisplay.setURLControlPanel(urlControlPanel);\n\n\t\tString siteContentURL = urlControlPanel;\n\n\t\tsiteContentURL = HttpUtil.addParameter(\n\t\t\tsiteContentURL, \"controlPanelCategory\",\n\t\t\tPortletCategoryKeys.CONTENT);\n\n\t\tthemeDisplay.setURLSiteContent(siteContentURL);\n\n\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\tthemeDisplay.setURLCurrent(currentURL);\n\n\t\tString urlHome = PortalUtil.getHomeURL(request);\n\n\t\tthemeDisplay.setURLHome(urlHome);\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypePortlet()) {\n\t\t\t\tboolean freeformLayout =\n\t\t\t\t\tlayoutTypePortlet.getLayoutTemplateId().equals(\n\t\t\t\t\t\t\"freeform\");\n\n\t\t\t\tthemeDisplay.setFreeformLayout(freeformLayout);\n\n\t\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(true);\n\n\t\t\t\t\tif (!group.isUser()) {\n\t\t\t\t\t\tthemeDisplay.setShowPageCustomizationIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.toggle('\".concat(\n\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION).concat(\"');\"));\n\n\t\t\t\t\tthemeDisplay.setURLLayoutTemplates(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.showTemplates();\");\n\t\t\t\t}\n\n\t\t\t\tif (hasCustomizeLayoutPermission && customizedView) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.toggle('\".concat(\n\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION).concat(\"');\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (signedIn) {\n\t\t\t\tif (group.isUser()) {\n\t\t\t\t\tif ((layout.isPrivateLayout() &&\n\t\t\t\t\t\t !PropsValues.LAYOUT_USER_PRIVATE_LAYOUTS_MODIFIABLE) ||\n\t\t\t\t\t\t(layout.isPublicLayout() &&\n\t\t\t\t\t\t !PropsValues.LAYOUT_USER_PUBLIC_LAYOUTS_MODIFIABLE)) {\n\n\t\t\t\t\t\thasUpdateLayoutPermission = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\n\t\t\t\tPortletURL pageSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tpageSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tpageSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/layouts_admin/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tpageSettingsURL.setParameter(\"closeRedirect\", currentURL);\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tpageSettingsURL.setParameter(\"selPlid\", String.valueOf(plid));\n\n\t\t\t\tthemeDisplay.setURLPageSettings(pageSettingsURL);\n\n\t\t\t\tGroup liveGroup = null;\n\n\t\t\t\tif (group.isStagingGroup()) {\n\t\t\t\t\tliveGroup = group.getLiveGroup();\n\t\t\t\t}\n\n\t\t\t\tif ((group.isSite() || liveGroup.isSite()) &&\n\t\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, scopeGroupId,\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS)) {\n\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(true);\n\n\t\t\t\t\tPortletURL manageSiteMembershipsURL = new PortletURLImpl(\n\t\t\t\t\t\trequest, PortletKeys.SITE_MEMBERSHIPS_ADMIN,\n\t\t\t\t\t\tcontrolPanelPlid, PortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\t\tmanageSiteMembershipsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site_assignments\");\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\n\t\t\t\t\tthemeDisplay.setURLManageSiteMemberships(\n\t\t\t\t\t\tmanageSiteMembershipsURL);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean hasAddLayoutGroupPermission =\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.ADD_LAYOUT);\n\t\t\tboolean hasAddLayoutLayoutPermission =\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.ADD_LAYOUT);\n\t\t\tboolean hasManageLayoutsGroupPermission =\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.MANAGE_LAYOUTS);\n\t\t\tboolean hasManageStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.MANAGE_STAGING);\n\t\t\tboolean hasPublishStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.PUBLISH_STAGING);\n\t\t\tboolean hasUpdateGroupPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.UPDATE);\n\t\t\tboolean hasViewStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.VIEW_STAGING);\n\n\t\t\tif (!group.isControlPanel() && !group.isUser() &&\n\t\t\t\t!group.isUserGroup() && hasUpdateGroupPermission) {\n\n\t\t\t\tthemeDisplay.setShowSiteSettingsIcon(true);\n\n\t\t\t\tPortletURL siteSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_SETTINGS, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tsiteSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site\");\n\t\t\t\tsiteSettingsURL.setParameter(\"closeRedirect\", currentURL);\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\n\t\t\t\tthemeDisplay.setURLSiteSettings(siteSettingsURL);\n\t\t\t}\n\n\t\t\tif (!group.isLayoutPrototype() &&\n\t\t\t\t(hasAddLayoutGroupPermission || hasAddLayoutLayoutPermission ||\n\t\t\t\t hasManageLayoutsGroupPermission || hasUpdateGroupPermission)) {\n\n\t\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(true);\n\n\t\t\t\tPortletURL siteMapSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteMapSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tsiteMapSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/layouts_admin/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\"closeRedirect\", currentURL);\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\n\t\t\t\tthemeDisplay.setURLSiteMapSettings(siteMapSettingsURL);\n\t\t\t}\n\n\t\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\tif (group.isControlPanel()) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\t// LEP-4987\n\n\t\t\tif (group.isStaged() || group.isStagingGroup()) {\n\t\t\t\tif (hasManageStagingPermission || hasPublishStagingPermission ||\n\t\t\t\t\thasUpdateLayoutPermission || hasViewStagingPermission) {\n\n\t\t\t\t\tthemeDisplay.setShowStagingIcon(true);\n\t\t\t\t}\n\n\t\t\t\tif (hasPublishStagingPermission) {\n\t\t\t\t\tPortletURL publishToLiveURL = new PortletURLImpl(\n\t\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, plid,\n\t\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tpublishToLiveURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.EXCLUSIVE);\n\t\t\t\t\tpublishToLiveURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/layouts_admin/publish_layouts\");\n\n\t\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t\t}\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\"pagesRedirect\", currentURL);\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\n\t\t\t\t\tthemeDisplay.setURLPublishToLive(publishToLiveURL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPortletURLImpl myAccountURL = new PortletURLImpl(\n\t\t\t\trequest, PortletKeys.MY_ACCOUNT, controlPanelPlid,\n\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\tmyAccountURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\tmyAccountURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\tif (scopeGroupId > 0) {\n\t\t\t\tmyAccountURL.setDoAsGroupId(scopeGroupId);\n\t\t\t}\n\n\t\t\tif (refererPlid > 0) {\n\t\t\t\tmyAccountURL.setRefererPlid(refererPlid);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmyAccountURL.setRefererPlid(plid);\n\t\t\t}\n\n\t\t\tmyAccountURL.setParameter(\"struts_action\", \"/my_account/edit_user\");\n\n\t\t\tthemeDisplay.setURLMyAccount(myAccountURL);\n\t\t}\n\n\t\tif ((!user.isActive()) ||\n\t\t\t(PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.TERMS_OF_USE_REQUIRED) &&\n\t\t\t !user.isAgreedToTermsOfUse())) {\n\n\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutPrototype()) {\n\t\t\tthemeDisplay.setShowControlPanelIcon(false);\n\t\t\tthemeDisplay.setShowHomeIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\t\t\tthemeDisplay.setShowPortalIcon(false);\n\t\t\tthemeDisplay.setShowSignInIcon(false);\n\t\t\tthemeDisplay.setShowSignOutIcon(false);\n\t\t\tthemeDisplay.setShowSiteContentIcon(false);\n\t\t\tthemeDisplay.setShowStagingIcon(false);\n\t\t}\n\n\t\tthemeDisplay.setURLPortal(portalURL.concat(contextPath));\n\n\t\tString urlSignIn = mainPath.concat(\"/portal/login\");\n\n\t\tif (layout != null) {\n\t\t\turlSignIn = HttpUtil.addParameter(\n\t\t\t\turlSignIn, \"p_l_id\", layout.getPlid());\n\t\t}\n\n\t\tthemeDisplay.setURLSignIn(urlSignIn);\n\n\t\tthemeDisplay.setURLSignOut(mainPath.concat(\"/portal/logout\"));\n\n\t\tPortletURL updateManagerURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.UPDATE_MANAGER, plid,\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tupdateManagerURL.setWindowState(WindowState.MAXIMIZED);\n\t\tupdateManagerURL.setPortletMode(PortletMode.VIEW);\n\n\t\tupdateManagerURL.setParameter(\"struts_action\", \"/update_manager/view\");\n\n\t\tthemeDisplay.setURLUpdateManager(updateManagerURL);\n\n\t\treturn themeDisplay;\n\t}","commit_id":"2ddb99501e2055c4c6ea3b6704705fe5e0bc3c9f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Returns a range of all the site groups for which the user has control\n\t * panel access.\n\t *\n\t * @param  portlets the portlets to manage\n\t * @param  max the upper bound of the range of groups to consider (not\n\t *         inclusive)\n\t * @return the range of site groups for which the user has Control Panel\n\t *         access\n\t * @throws PortalException if a portal exception occurred\n\t * @throws SystemException if a system exception occurred\n\t */\n\t@Override\n\tpublic List<Group> getManageableSiteGroups(\n\t\t\tCollection<Portlet> portlets, int max)\n\t\tthrows PortalException, SystemException {\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tif (permissionChecker.isCompanyAdmin()) {\n\t\t\tLinkedHashMap<String, Object> params =\n\t\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\t\tparams.put(\"site\", Boolean.TRUE);\n\n\t\t\treturn groupLocalService.search(\n\t\t\t\tpermissionChecker.getCompanyId(), null, null, null, params,\n\t\t\t\ttrue, 0, max);\n\t\t}\n\n\t\tList<Group> groups = new UniqueList<Group>();\n\n\t\tgroups.addAll(getUserPlacesGroups(null, max));\n\n\t\tIterator<Group> itr = groups.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tGroup group = itr.next();\n\n\t\t\tif (!group.isSite() ||\n\t\t\t\t!PortletPermissionUtil.hasControlPanelAccessPermission(\n\t\t\t\t\tpermissionChecker, group.getGroupId(), portlets)) {\n\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn groups;\n\t}","id":29862,"modified_method":"/**\n\t * Returns a range of all the site groups for which the user has control\n\t * panel access.\n\t *\n\t * @param  portlets the portlets to manage\n\t * @param  max the upper bound of the range of groups to consider (not\n\t *         inclusive)\n\t * @return the range of site groups for which the user has Control Panel\n\t *         access\n\t * @throws PortalException if a portal exception occurred\n\t * @throws SystemException if a system exception occurred\n\t */\n\t@Override\n\tpublic List<Group> getManageableSiteGroups(\n\t\t\tCollection<Portlet> portlets, int max)\n\t\tthrows PortalException, SystemException {\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tif (permissionChecker.isCompanyAdmin()) {\n\t\t\tLinkedHashMap<String, Object> params =\n\t\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\t\tparams.put(\"site\", Boolean.TRUE);\n\n\t\t\treturn groupLocalService.search(\n\t\t\t\tpermissionChecker.getCompanyId(), null, null, null, params,\n\t\t\t\ttrue, 0, max);\n\t\t}\n\n\t\tList<Group> groups = new UniqueList<Group>();\n\n\t\tList<Group> userPlacesGroups = getUserPlacesGroups(null, max);\n\n\t\tIterator<Group> itr = userPlacesGroups.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tGroup group = itr.next();\n\n\t\t\tif (group.isSite() &&\n\t\t\t\tPortletPermissionUtil.hasControlPanelAccessPermission(\n\t\t\t\t\tpermissionChecker, group.getGroupId(), portlets)) {\n\n\t\t\t\tgroups.add(group);\n\t\t\t}\n\t\t}\n\n\t\treturn groups;\n\t}","commit_id":"f74f8775262d88b3365856e6f164c594735f5b35","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private boolean nsServerExists(String serverName) throws ExecutionException {\n        try {\n            if (com.citrix.netscaler.nitro.resource.config.basic.server.get(_netscalerService, serverName) != null) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (nitro_exception e) {\n            if (e.getErrorCode() == NitroError.NS_RESOURCE_NOT_EXISTS) {\n                return false;\n            } else {\n                throw new ExecutionException(e.getMessage());\n            }\n        } catch (Exception e) {\n            throw new ExecutionException(e.getMessage());\n        }\n    }","id":29863,"modified_method":"private boolean nsServerExists(String serverName) throws ExecutionException {\n        try {\n            if (com.citrix.netscaler.nitro.resource.config.basic.server.get(_netscalerService, serverName) != null) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (nitro_exception e) {\n            if (e.getErrorCode() == NitroError.NS_RESOURCE_NOT_EXISTS) {\n                return false;\n            } else {\n                throw new ExecutionException(\"Failed to verify Server \" + serverName + \" exists on the NetScaler device due to \" + e.getMessage());\n            }\n        } catch (Exception e) {\n            throw new ExecutionException(\"Failed to verify Server \" + serverName + \" exists on the NetScaler device due to \" + e.getMessage());\n        }\n    }","commit_id":"7add26e5dbd040ee84cb20a03bfa23378512f460","url":"https://github.com/apache/cloudstack"},{"original_method":"private boolean nsVlanExists(long vlanTag) {\n        try {\n            if (vlan.get(_netscalerService, new Long(vlanTag)) != null) {\n                return true;\n            }\n            return false;\n        } catch (Exception e) {\n            return false;\n        }\n    }","id":29864,"modified_method":"private boolean nsVlanExists(long vlanTag) throws ExecutionException {\n        try {\n            if (vlan.get(_netscalerService, new Long(vlanTag)) != null) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (nitro_exception e) {\n            if (e.getErrorCode() == NitroError.NS_RESOURCE_NOT_EXISTS) {\n                return false;\n            } else {\n                throw new ExecutionException(\"Failed to verify  VLAN exists on the NetScaler device due to \" + e.getMessage());\n            }\n        } catch (Exception e) {\n            throw new ExecutionException(\"Failed to verify  VLAN exists on the NetScaler device due to \" + e.getMessage());\n        }\n    }","commit_id":"7add26e5dbd040ee84cb20a03bfa23378512f460","url":"https://github.com/apache/cloudstack"},{"original_method":"private void addGuestVlanAndSubnet(long vlanTag, String vlanSelfIp, String vlanNetmask, boolean guestVlan) throws ExecutionException {\n        try {\n            if (!nsVlanExists(vlanTag)) {\n                // add new vlan\n                vlan vlanObj = new vlan();\n                vlanObj.set_id(vlanTag);\n                apiCallResult = vlan.add(_netscalerService, vlanObj);\n                if (apiCallResult.errorcode != 0) {\n                    throw new ExecutionException(\"Failed to add new vlan with tag:\" + vlanTag + \"due to\" + apiCallResult.message);\n                }\n            \n                // add self-ip and subnet to the Netscaler\n                nsip selfIp = new nsip();\n                selfIp.set_ipaddress(vlanSelfIp);\n                selfIp.set_netmask(vlanNetmask);\n                selfIp.set_type(\"SNIP\");\n                apiCallResult = nsip.add(_netscalerService, selfIp);\n                if (apiCallResult.errorcode != 0) {\n                    throw new ExecutionException(\"Failed to add new self-ip due to \"+ apiCallResult.message);\n                }\n\n                //bind the vlan to guest subnet\n                vlan_nsip_binding ipVlanBinding = new vlan_nsip_binding();\n                ipVlanBinding.set_id(vlanTag);\n                ipVlanBinding.set_ipaddress(vlanSelfIp);\n                ipVlanBinding.set_netmask(vlanNetmask);\n                apiCallResult = vlan_nsip_binding.add(_netscalerService, ipVlanBinding);\n                if (apiCallResult.errorcode != 0) {\n                    throw new ExecutionException(\"Failed to bind vlan with tag:\" + vlanTag + \" to the subnet due to\" + apiCallResult.message);\n                }\n\n                // bind vlan to the private interface\n                vlan_interface_binding vlanBinding = new vlan_interface_binding();\n                if (guestVlan) {\n                    vlanBinding.set_ifnum(_privateInterface);\n                } else {\n                    vlanBinding.set_ifnum(_publicInterface);\n                }\n                vlanBinding.set_tagged(true);\n                vlanBinding.set_id(vlanTag);\n                try {\n                    apiCallResult = vlan_interface_binding.add(_netscalerService, vlanBinding);\n                } catch (nitro_exception e)  {\n                    // FIXME: Vlan binding (subsequent unbind) to an interfaces will fail on the VPX created on Xen server and on \n                    // NetScaler SDX appliance till the VPX fix to handle VLAN's is released. Relaxing this restriction NetScaler until then\n                    if (!(_deviceName.equalsIgnoreCase(\"NetscalerVPXLoadBalancer\") && e.getErrorCode() == NitroError.NS_OPERATION_NOT_PERMITTED)) {\n                        throw new ExecutionException(\"Failed to bind vlan to the interface while implementing guest network on the Netscaler device due to \" + e.getMessage());\n                    }\n                }\n\n                if (apiCallResult.errorcode != 0) {\n                    String vlanInterface = guestVlan ? _privateInterface : _publicInterface;\n                    throw new ExecutionException(\"Failed to bind vlan with tag:\" + vlanTag + \" with the interface \" + vlanInterface + \" due to \" + apiCallResult.message);\n                }\n            }\n        }  catch (nitro_exception e) {\n            throw new ExecutionException(\"Failed to implement guest network on the Netscaler device due to \" + e.getMessage());\n        }  catch (Exception e) {\n            throw new ExecutionException(\"Failed to implement guest network on the Netscaler device \" + e.getMessage());\n        }\n    }","id":29865,"modified_method":"private void addGuestVlanAndSubnet(long vlanTag, String vlanSelfIp, String vlanNetmask, boolean guestVlan) throws ExecutionException {\n        try {\n            // add vlan object for guest VLAN\n            if (!nsVlanExists(vlanTag)) {\n                try {\n                    vlan vlanObj = new vlan();\n                    vlanObj.set_id(vlanTag);\n                    apiCallResult = vlan.add(_netscalerService, vlanObj);\n                    if (apiCallResult.errorcode != 0) {\n                        throw new ExecutionException(\"Failed to add new vlan with tag:\" + vlanTag + \"on the NetScaler device due to \" +  apiCallResult.message);\n                    }\n                } catch (nitro_exception e) {\n                    throw new ExecutionException(\"Failed to add new vlan with tag:\" + vlanTag + \"on the NetScaler device due to \" + e.getMessage());\n                }\n            }\n\n            // add subnet IP object for this guest network\n            if (!nsSnipExists(vlanSelfIp)) {\n                try {\n                    nsip selfIp = new nsip();\n                    selfIp.set_ipaddress(vlanSelfIp);\n                    selfIp.set_netmask(vlanNetmask);\n                    selfIp.set_type(\"SNIP\");\n                    apiCallResult = nsip.add(_netscalerService, selfIp);\n                    if (apiCallResult.errorcode != 0) {\n                        throw new ExecutionException(\"Failed to add SNIP object for the guest network on the Netscaler device due to \"+ apiCallResult.message);\n                    }\n                } catch (nitro_exception e) {\n                    throw new ExecutionException(\"Failed to add SNIP object for the guest network on the Netscaler device due to \" + e.getMessage());\n                }\n            }\n\n            // bind the vlan object to subnet IP object\n            if (!nsVlanNsipBindingExists(vlanTag, vlanSelfIp)) {\n                try {\n                    vlan_nsip_binding ipVlanBinding = new vlan_nsip_binding();\n                    ipVlanBinding.set_id(vlanTag);\n                    ipVlanBinding.set_ipaddress(vlanSelfIp);\n                    ipVlanBinding.set_netmask(vlanNetmask);\n                    apiCallResult = vlan_nsip_binding.add(_netscalerService, ipVlanBinding);\n                    if (apiCallResult.errorcode != 0) {\n                        throw new ExecutionException(\"Failed to bind VLAN with tag:\" + vlanTag + \" to the subnet due to \" + apiCallResult.message);\n                    }\n                } catch (nitro_exception e) {\n                    throw new ExecutionException(\"Failed to bind VLAN with tage:\"+ vlanTag + \" to the subnet due to \" + e.getMessage());\n                }\n            }\n\n            // bind vlan object to the private interface\n            try {\n                vlan_interface_binding vlanBinding = new vlan_interface_binding();\n                if (guestVlan) {\n                    vlanBinding.set_ifnum(_privateInterface);\n                } else {\n                    vlanBinding.set_ifnum(_publicInterface);\n                }\n                vlanBinding.set_tagged(true);\n                vlanBinding.set_id(vlanTag);\n                apiCallResult = vlan_interface_binding.add(_netscalerService, vlanBinding);\n                if (apiCallResult.errorcode != 0) {\n                    String vlanInterface = guestVlan ? _privateInterface : _publicInterface;\n                    throw new ExecutionException(\"Failed to bind vlan with tag:\" + vlanTag + \" with the interface \" + vlanInterface + \" due to \" + apiCallResult.message);\n                }\n            } catch (nitro_exception e)  {\n                if (!(e.getErrorCode() == NitroError.NS_INTERFACE_ALREADY_BOUND_TO_VLAN)) {\n                    throw new ExecutionException(\"Failed to bind VLAN \"+ vlanTag + \" with interface on the Netscaler device due to \" + e.getMessage());\n                }\n            }\n        }  catch (nitro_exception e) {\n            throw new ExecutionException(\"Failed to implement guest network on the Netscaler device due to \" + e.getMessage());\n        }  catch (Exception e) {\n            throw new ExecutionException(\"Failed to implement guest network on the Netscaler device due to \" + e.getMessage());\n        }\n    }","commit_id":"7add26e5dbd040ee84cb20a03bfa23378512f460","url":"https://github.com/apache/cloudstack"},{"original_method":"public ORawBuffer read(final int iClusterId, final long iPosition) {\r\n\t\ttry {\r\n\r\n\t\t\tfinal String recId = ORecordId.generateString(iClusterId, iPosition);\r\n\r\n\t\t\t// SEARCH IT IN CACHE\r\n\t\t\tORawBuffer result;\r\n\r\n\t\t\tif (useCache) {\r\n\t\t\t\tresult = getCache().findRecord(recId);\r\n\r\n\t\t\t\tif (result != null)\r\n\t\t\t\t\treturn result;\r\n\t\t\t} else\r\n\t\t\t\tresult = null;\r\n\r\n\t\t\tresult = storage.readRecord(id, iClusterId, iPosition);\r\n\r\n\t\t\tif (useCache)\r\n\t\t\t\tgetCache().addRecord(recId, result);\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t} catch (Throwable t) {\r\n\t\t\tthrow new ODatabaseException(\"Error on retrieving record #\" + iPosition + \" in cluster '\"\r\n\t\t\t\t\t+ storage.getPhysicalClusterNameById(iClusterId) + \"'\", t);\r\n\t\t}\r\n\t}","id":29866,"modified_method":"public ORawBuffer read(final int iClusterId, final long iPosition) {\r\n\t\ttry {\r\n\r\n\t\t\tfinal String recId = ORecordId.generateString(iClusterId, iPosition);\r\n\r\n\t\t\t// SEARCH IT IN CACHE\r\n\t\t\tORawBuffer result;\r\n\r\n\t\t\tif (useCache) {\r\n\t\t\t\t// FIND IN CACHE\r\n\t\t\t\tresult = getCache().findRecord(recId);\r\n\r\n\t\t\t\tif (result != null)\r\n\t\t\t\t\t// FOUND: JUST RETURN IT\r\n\t\t\t\t\treturn result;\r\n\t\t\t}\r\n\r\n\t\t\tresult = storage.readRecord(id, iClusterId, iPosition);\r\n\r\n\t\t\tif (useCache)\r\n\t\t\t\t// ADD THE RECORD TO THE LOCAL CACHE\r\n\t\t\t\tgetCache().addRecord(recId, result);\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t} catch (Throwable t) {\r\n\t\t\tthrow new ODatabaseException(\"Error on retrieving record #\" + iPosition + \" in cluster '\"\r\n\t\t\t\t\t+ storage.getPhysicalClusterNameById(iClusterId) + \"'\", t);\r\n\t\t}\r\n\t}","commit_id":"bba882835ac20934e47e57aa712af25bf45559e1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public long save(final int iClusterId, final long iPosition, final byte[] iContent, final int iVersion, final byte iRecordType) {\r\n\t\ttry {\r\n\t\t\tif (iPosition == ORID.CLUSTER_POS_INVALID)\r\n\t\t\t\treturn storage.createRecord(iClusterId, iContent, iRecordType);\r\n\r\n\t\t\tint newVersion = storage.updateRecord(id, iClusterId, iPosition, iContent, iVersion, iRecordType);\r\n\t\t\tif (newVersion > -1)\r\n\t\t\t\treturn newVersion * -1 - 2;\r\n\r\n\t\t} catch (Throwable t) {\r\n\t\t\tthrow new ODatabaseException(\"Error on saving record in cluster id: \" + iClusterId + \", position: \" + iPosition, t);\r\n\t\t}\r\n\t\treturn ORID.CLUSTER_POS_INVALID;\r\n\t}","id":29867,"modified_method":"public long save(final int iClusterId, long iPosition, final byte[] iContent, final int iVersion, final byte iRecordType) {\r\n\t\ttry {\r\n\t\t\tif (iPosition == ORID.CLUSTER_POS_INVALID) {\r\n\t\t\t\t// CREATE\r\n\t\t\t\tiPosition = storage.createRecord(iClusterId, iContent, iRecordType);\r\n\r\n\t\t\t\tif (useCache)\r\n\t\t\t\t\t// ADD/UPDATE IT IN CACHE\r\n\t\t\t\t\tgetCache().addRecord(ORecordId.generateString(iClusterId, iPosition), new ORawBuffer(iContent, 0, iRecordType));\r\n\r\n\t\t\t\treturn iPosition;\r\n\t\t\t} else {\r\n\t\t\t\t// UPDATE\r\n\t\t\t\tint newVersion = storage.updateRecord(id, iClusterId, iPosition, iContent, iVersion, iRecordType);\r\n\r\n\t\t\t\tif (useCache)\r\n\t\t\t\t\t// ADD/UPDATE IT IN CACHE\r\n\t\t\t\t\tgetCache().addRecord(ORecordId.generateString(iClusterId, iPosition), new ORawBuffer(iContent, newVersion, iRecordType));\r\n\r\n\t\t\t\treturn newVersion;\r\n\t\t\t}\r\n\t\t} catch (Throwable t) {\r\n\t\t\tthrow new ODatabaseException(\"Error on saving record in cluster id: \" + iClusterId + \", position: \" + iPosition, t);\r\n\t\t}\r\n\t}","commit_id":"bba882835ac20934e47e57aa712af25bf45559e1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void executeSaveRecord(final REC iContent, String iClusterName, final int iVersion, final byte iRecordType) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tif (!iContent.isDirty())\r\n\t\t\treturn;\r\n\r\n\t\tfinal ORecordId rid = (ORecordId) iContent.getIdentity();\r\n\r\n\t\tif (rid == null)\r\n\t\t\tthrow new ODatabaseException(\r\n\t\t\t\t\t\"Can't create record because it has no identity. Probably is not a regular record or contains projections of fields rather than a full record\");\r\n\r\n\t\ttry {\r\n\t\t\tfinal int clusterId;\r\n\r\n\t\t\tboolean isNew = !rid.isValid();\r\n\t\t\tif (isNew) {\r\n\t\t\t\tclusterId = iClusterName != null ? getClusterIdByName(iClusterName) : getDefaultClusterId();\r\n\r\n\t\t\t\t// CHECK ACCESS ON CLUSTER\r\n\t\t\t\tcheckSecurity(OUser.CLUSTER + \".\" + clusterId, OUser.CREATE);\r\n\t\t\t} else {\r\n\t\t\t\t// if (iClusterName != null)\r\n\t\t\t\t// throw new IllegalArgumentException(\"Can't specify the cluster on update but only on creation\");\r\n\r\n\t\t\t\tclusterId = rid.clusterId;\r\n\r\n\t\t\t\t// CHECK ACCESS ON CLUSTER\r\n\t\t\t\tcheckSecurity(OUser.CLUSTER + \".\" + clusterId, OUser.UPDATE);\r\n\t\t\t}\r\n\r\n\t\t\tfinal byte[] stream = iContent.toStream();\r\n\r\n\t\t\tlong clusterPosition = underlying.save(clusterId, rid.getClusterPosition(), stream, iVersion, iContent.getRecordType());\r\n\r\n\t\t\tif (clusterPosition < -1)\r\n\t\t\t\tiContent.fill(iContent.getDatabase(), rid.getClusterId(), rid.getClusterPosition(), (int) clusterPosition * -1 - 2);\r\n\r\n\t\t\tif (!rid.isValid()) {\r\n\t\t\t\trid.clusterId = clusterId;\r\n\t\t\t\trid.clusterPosition = clusterPosition;\r\n\t\t\t}\r\n\r\n\t\t\t// ADD/UPDATE IT IN CACHE\r\n\t\t\tif (underlying.isUseCache())\r\n\t\t\t\tgetCache().addRecord(rid.toString(), new ORawBuffer(stream, isNew ? 0 : iVersion, iRecordType));\r\n\r\n\t\t\tiContent.unsetDirty();\r\n\t\t} catch (ODatabaseException e) {\r\n\t\t\t// RE-THROW THE EXCEPTION\r\n\t\t\tthrow e;\r\n\t\t} catch (Throwable t) {\r\n\t\t\t// WRAP IT AS ODATABASE EXCEPTION\r\n\t\t\tthrow new ODatabaseException(\"Error on saving record in cluster #\" + iContent.getIdentity().getClusterId(), t);\r\n\t\t}\r\n\t}","id":29868,"modified_method":"public void executeSaveRecord(final REC iContent, String iClusterName, final int iVersion, final byte iRecordType) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tif (!iContent.isDirty())\r\n\t\t\treturn;\r\n\r\n\t\tfinal ORecordId rid = (ORecordId) iContent.getIdentity();\r\n\r\n\t\tif (rid == null)\r\n\t\t\tthrow new ODatabaseException(\r\n\t\t\t\t\t\"Can't create record because it has no identity. Probably is not a regular record or contains projections of fields rather than a full record\");\r\n\r\n\t\ttry {\r\n\t\t\tfinal int clusterId;\r\n\r\n\t\t\tboolean isNew = !rid.isValid();\r\n\t\t\tif (isNew) {\r\n\t\t\t\tclusterId = iClusterName != null ? getClusterIdByName(iClusterName) : getDefaultClusterId();\r\n\r\n\t\t\t\t// CHECK ACCESS ON CLUSTER\r\n\t\t\t\tcheckSecurity(OUser.CLUSTER + \".\" + clusterId, OUser.CREATE);\r\n\t\t\t} else {\r\n\t\t\t\tclusterId = rid.clusterId;\r\n\r\n\t\t\t\t// CHECK ACCESS ON CLUSTER\r\n\t\t\t\tcheckSecurity(OUser.CLUSTER + \".\" + clusterId, OUser.UPDATE);\r\n\t\t\t}\r\n\r\n\t\t\tfinal byte[] stream = iContent.toStream();\r\n\r\n\t\t\t// SAVE IT\r\n\t\t\tlong result = underlying.save(clusterId, rid.getClusterPosition(), stream, iVersion, iContent.getRecordType());\r\n\r\n\t\t\tif (isNew)\r\n\t\t\t\t// UPDATE INFORMATION: CLUSTER ID+POSITION\r\n\t\t\t\tiContent.fill(iContent.getDatabase(), clusterId, result, 0);\r\n\t\t\telse\r\n\t\t\t\t// UPDATE INFORMATION: VERSION\r\n\t\t\t\tiContent.fill(iContent.getDatabase(), clusterId, rid.getClusterPosition(), (int) result);\r\n\r\n\t\t\tiContent.unsetDirty();\r\n\t\t} catch (ODatabaseException e) {\r\n\t\t\t// RE-THROW THE EXCEPTION\r\n\t\t\tthrow e;\r\n\t\t} catch (Throwable t) {\r\n\t\t\t// WRAP IT AS ODATABASE EXCEPTION\r\n\t\t\tthrow new ODatabaseException(\"Error on saving record in cluster #\" + iContent.getIdentity().getClusterId(), t);\r\n\t\t}\r\n\t}","commit_id":"bba882835ac20934e47e57aa712af25bf45559e1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\t@Override\n\tprotected void execute() throws Exception {\n\t\tcommandType = -1;\n\n\t\tlong clock = 0;\n\n\t\ttry {\n\t\t\tcommandType = channel.readByte();\n\n\t\t\tclock = System.currentTimeMillis();\n\n\t\t\tswitch (commandType) {\n\n\t\t\tcase OChannelBinaryProtocol.CONNECT: {\n\t\t\t\tuser = channel.readString();\n\t\t\t\tpasswd = channel.readString();\n\t\t\t\tsendOk();\n\t\t\t\tchannel.writeString(connection.id);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DB_OPEN: {\n\t\t\t\tString dbURL = channel.readString();\n\t\t\t\tString dbName = dbURL.substring(dbURL.lastIndexOf(\":\") + 1);\n\n\t\t\t\tuser = channel.readString();\n\t\t\t\tpasswd = channel.readString();\n\n\t\t\t\t// SEARCH THE DB IN MEMORY FIRST\n\t\t\t\tconnection.database = (ODatabaseDocumentTx) OServerMain.server().getMemoryDatabases().get(dbName);\n\n\t\t\t\tif (connection.database == null)\n\t\t\t\t\t// SEARCH THE DB IN LOCAL FS\n\t\t\t\t\tconnection.database = new ODatabaseDocumentTx(OServerMain.server().getStoragePath(dbName));\n\n\t\t\t\tif (connection.database.isClosed())\n\t\t\t\t\tif (connection.database.getStorage() instanceof OStorageMemory)\n\t\t\t\t\t\tconnection.database.create();\n\t\t\t\t\telse\n\t\t\t\t\t\tconnection.database.open(user, passwd);\n\n\t\t\t\tunderlyingDatabase = ((ODatabaseRaw) ((ODatabaseComplex<?>) connection.database.getUnderlying()).getUnderlying());\n\n\t\t\t\tif (!(underlyingDatabase.getStorage() instanceof OStorageMemory) && !loadUserFromSchema(user, passwd)) {\n\t\t\t\t\tsendError(new OSecurityAccessException(\"Access denied to database '\" + connection.database.getName() + \"' for user: \"\n\t\t\t\t\t\t\t+ user));\n\t\t\t\t} else {\n\t\t\t\t\tsendOk();\n\t\t\t\t\tchannel.writeString(connection.id);\n\t\t\t\t\tchannel.writeInt(connection.database.getClusterNames().size());\n\t\t\t\t\tfor (OCluster c : ((OStorage) connection.database.getStorage()).getClusters()) {\n\t\t\t\t\t\tchannel.writeString(c.getName());\n\t\t\t\t\t\tchannel.writeInt(c.getId());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DB_CREATE: {\n\t\t\t\tString dbName = channel.readString();\n\t\t\t\tString storageMode = channel.readString();\n\n\t\t\t\tfinal String path;\n\t\t\t\tfinal String realPath;\n\n\t\t\t\tif (storageMode.equals(OEngineLocal.NAME)) {\n\t\t\t\t\tif (OServerMain.server().existsStoragePath(dbName))\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Database '\" + dbName + \"' already exists.\");\n\n\t\t\t\t\tpath = storageMode + \":${ORIENT_HOME}/databases/\" + dbName + \"/\" + dbName;\n\t\t\t\t\trealPath = OSystemVariableResolver.resolveSystemVariables(path);\n\t\t\t\t} else if (storageMode.equals(OEngineMemory.NAME)) {\n\t\t\t\t\tif (OServerMain.server().getMemoryDatabases().containsKey(dbName))\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Database '\" + dbName + \"' already exists.\");\n\n\t\t\t\t\tpath = storageMode + \":\" + dbName;\n\t\t\t\t\trealPath = path;\n\t\t\t\t} else\n\t\t\t\t\tthrow new IllegalArgumentException(\"Can't create databse: storage mode '\" + storageMode + \"' is not supported.\");\n\n\t\t\t\tconnection.database = new ODatabaseDocumentTx(realPath);\n\t\t\t\tconnection.database.create();\n\n\t\t\t\tif (storageMode.equals(OEngineLocal.NAME)) {\n\t\t\t\t\t// CLOSE IT BECAUSE IT WILL BE OPEN AT FIRST USE\n\t\t\t\t\tconnection.database.close();\n\n\t\t\t\t} else if (storageMode.equals(OEngineMemory.NAME)) {\n\t\t\t\t\t// SAVE THE DB IN MEMORY\n\t\t\t\t\tOServerMain.server().getMemoryDatabases().put(dbName, connection.database);\n\t\t\t\t}\n\n\t\t\t\tunderlyingDatabase = ((ODatabaseRaw) ((ODatabaseComplex<?>) connection.database.getUnderlying()).getUnderlying());\n\n\t\t\t\tsendOk();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DB_CLOSE:\n\t\t\t\t// connection.storage.close();\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.DB_EXIST:\n\t\t\t\tchannel.writeByte((byte) (connection.database.exists() ? 1 : 0));\n\n\t\t\t\tsendOk();\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.CLUSTER_COUNT:\n\t\t\t\tint[] ids = new int[channel.readShort()];\n\t\t\t\tfor (int i = 0; i < ids.length; ++i)\n\t\t\t\t\tids[i] = channel.readShort();\n\n\t\t\t\tlong count = connection.database.countClusterElements(ids);\n\n\t\t\t\tsendOk();\n\t\t\t\tchannel.writeLong(count);\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.CLUSTER_PHYSICAL_ADD: {\n\t\t\t\tfinal int num = connection.database.addPhysicalCluster(channel.readString(), channel.readString(), channel.readInt());\n\n\t\t\t\tsendOk();\n\t\t\t\tchannel.writeShort((short) num);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.CLUSTER_LOGICAL_ADD: {\n\t\t\t\tfinal int num = connection.database.addLogicalCluster(channel.readString(), connection.database.getDefaultClusterId());\n\n\t\t\t\tsendOk();\n\t\t\t\tOClusterLogical cluster = (OClusterLogical) connection.database.getStorage().getClusterById(num);\n\t\t\t\tchannel.writeShort((short) num);\n\t\t\t\tchannel.writeString(cluster.getRID().toString());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.RECORD_LOAD:\n\t\t\t\tfinal ORawBuffer record = underlyingDatabase.read(channel.readShort(), channel.readLong());\n\t\t\t\tsendOk();\n\t\t\t\tif (record != null) {\n\t\t\t\t\tchannel.writeByte((byte) 1);\n\t\t\t\t\tchannel.writeBytes(record.buffer);\n\t\t\t\t\tchannel.writeInt(record.version);\n\t\t\t\t\tchannel.writeByte(record.recordType);\n\t\t\t\t} else\n\t\t\t\t\tchannel.writeByte((byte) 0);\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.RECORD_CREATE:\n\t\t\t\tfinal long location = underlyingDatabase.save(channel.readShort(), ORID.CLUSTER_POS_INVALID, channel.readBytes(), -1,\n\t\t\t\t\t\tchannel.readByte());\n\t\t\t\tsendOk();\n\t\t\t\tchannel.writeLong(location);\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.RECORD_UPDATE:\n\t\t\t\tfinal int clusterId = channel.readShort();\n\t\t\t\tfinal long position = channel.readLong();\n\n\t\t\t\tlong newVersion = underlyingDatabase.save(clusterId, position, channel.readBytes(), channel.readInt(), channel.readByte());\n\n\t\t\t\t// TODO: Handle it by using triggers\n\t\t\t\tif (clusterId == connection.database.getMetadata().getSchemaClusterId())\n\t\t\t\t\tif (position == OSchema.CLASSES_RECORD_NUM)\n\t\t\t\t\t\tconnection.database.getMetadata().loadSchema();\n\t\t\t\t\telse if (position == OSecurity.SECURITY_RECORD_NUM)\n\t\t\t\t\t\tconnection.database.getMetadata().loadSecurity();\n\n\t\t\t\tsendOk();\n\n\t\t\t\tchannel.writeInt((int) (newVersion * -1 - 2));\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.RECORD_DELETE:\n\t\t\t\tunderlyingDatabase.delete(channel.readShort(), channel.readLong(), channel.readInt());\n\t\t\t\tsendOk();\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.COUNT: {\n\t\t\t\tfinal String clusterName = channel.readString();\n\t\t\t\tfinal long size = connection.database.countClusterElements(clusterName);\n\n\t\t\t\tsendOk();\n\n\t\t\t\tchannel.writeLong(size);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.COMMAND: {\n\t\t\t\tfinal boolean asynch = channel.readByte() == 'a';\n\n\t\t\t\tfinal OCommandRequestAbstract command = (OCommandRequestAbstract) OStreamSerializerAnyStreamable.INSTANCE\n\t\t\t\t\t\t.fromStream(channel.readBytes());\n\n\t\t\t\tif (asynch) {\n\t\t\t\t\t// ASYNCHRONOUS\n\t\t\t\t\tfinal StringBuilder empty = new StringBuilder();\n\n\t\t\t\t\tcommand.setResultListener(new OCommandResultListener() {\n\t\t\t\t\t\tprivate int\titems\t= 0;\n\n\t\t\t\t\t\tpublic boolean result(final Object iRecord) {\n\t\t\t\t\t\t\tif (items == 0)\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tsendOk();\n\t\t\t\t\t\t\t\t\tempty.append(\"-\");\n\t\t\t\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (command.getLimit() > -1 && items > command.getLimit())\n\t\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tchannel.writeByte((byte) 1);\n\t\t\t\t\t\t\t\titems++;\n\t\t\t\t\t\t\t\twriteRecord((ORecordInternal<?>) iRecord);\n\t\t\t\t\t\t\t\tchannel.flush();\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t((OCommandRequestInternal<ODatabaseRecord<?>>) connection.database.command(command)).execute();\n\n\t\t\t\t\tif (empty.length() == 0)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsendOk();\n\t\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\t}\n\n\t\t\t\t\tchannel.writeByte((byte) 0);\n\t\t\t\t} else {\n\t\t\t\t\t// SYNCHRONOUS\n\t\t\t\t\tfinal Object result = ((OCommandRequestInternal<ODatabaseRecord<?>>) connection.database.command(command)).execute();\n\n\t\t\t\t\tsendOk();\n\n\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\t// NULL VALUE\n\t\t\t\t\t\tchannel.writeByte((byte) 'n');\n\t\t\t\t\t\tchannel.writeBytes(null);\n\t\t\t\t\t} else if (result instanceof ORecord<?>) {\n\t\t\t\t\t\t// RECORD\n\t\t\t\t\t\tchannel.writeByte((byte) 'r');\n\t\t\t\t\t\twriteRecord((ORecordInternal<?>) result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// ANY OTHER (INCLUDING LITERALS)\n\t\t\t\t\t\tchannel.writeByte((byte) 'a');\n\t\t\t\t\t\tchannel.writeBytes(OStreamSerializerAnyRuntime.INSTANCE.toStream(result));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DICTIONARY_LOOKUP: {\n\t\t\t\tString key = channel.readString();\n\n\t\t\t\tORecordInternal<?> value = connection.database.getDictionary().get(key);\n\n\t\t\t\tsendOk();\n\n\t\t\t\twriteRecord(value);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DICTIONARY_PUT: {\n\t\t\t\tString key = channel.readString();\n\t\t\t\tORecordInternal<?> value = ORecordFactory.getRecord(channel.readByte());\n\n\t\t\t\tfinal ORecordId rid = new ORecordId(channel.readString());\n\t\t\t\tvalue.setIdentity(rid.clusterId, rid.clusterPosition);\n\t\t\t\tvalue.setDatabase(connection.database);\n\n\t\t\t\tvalue = connection.database.getDictionary().putRecord(key, value);\n\n\t\t\t\tsendOk();\n\n\t\t\t\twriteRecord(value);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DICTIONARY_REMOVE: {\n\t\t\t\tString key = channel.readString();\n\t\t\t\tORecordInternal<?> value = connection.database.getDictionary().remove(key);\n\n\t\t\t\tsendOk();\n\n\t\t\t\twriteRecord(value);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DICTIONARY_SIZE: {\n\t\t\t\tsendOk();\n\t\t\t\tchannel.writeInt(connection.database.getDictionary().size());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DICTIONARY_KEYS: {\n\t\t\t\tsendOk();\n\t\t\t\tchannel.writeCollectionString(connection.database.getDictionary().keySet());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.TX_COMMIT:\n\t\t\t\t((OStorageLocal) connection.database.getStorage()).commit(connection.database.getId(), new OTransactionOptimisticProxy(\n\t\t\t\t\t\t(ODatabaseRecordTx) connection.database.getUnderlying(), channel));\n\n\t\t\t\tsendOk();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tOLogManager.instance().error(this, \"Request not supported. Code: \" + commandType);\n\n\t\t\t\tchannel.clearInput();\n\t\t\t\tsendError(null);\n\t\t\t}\n\t\t} catch (EOFException eof) {\n\t\t\tshutdown();\n\t\t} catch (SocketException e) {\n\t\t\tshutdown();\n\t\t} catch (OException e) {\n\t\t\tsendError(e);\n\t\t} catch (Throwable t) {\n\t\t\tOLogManager.instance().error(this, \"Error on executing request\", t);\n\t\t\tsendError(t);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tchannel.flush();\n\t\t\t} catch (Throwable t) {\n\t\t\t\tOLogManager.instance().debug(this, \"Error on send data over the network\", t);\n\t\t\t}\n\n\t\t\tOSerializationThreadLocal.INSTANCE.get().clear();\n\n\t\t\tlastCommandExecutionTime = System.currentTimeMillis() - clock;\n\t\t\ttotalCommandExecutionTime += lastCommandExecutionTime;\n\n\t\t\tlastCommandType = commandType;\n\t\t}\n\t}","id":29869,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t@Override\n\tprotected void execute() throws Exception {\n\t\tcommandType = -1;\n\n\t\tlong clock = 0;\n\n\t\ttry {\n\t\t\tcommandType = channel.readByte();\n\n\t\t\tclock = System.currentTimeMillis();\n\n\t\t\tswitch (commandType) {\n\n\t\t\tcase OChannelBinaryProtocol.CONNECT: {\n\t\t\t\tuser = channel.readString();\n\t\t\t\tpasswd = channel.readString();\n\t\t\t\tsendOk();\n\t\t\t\tchannel.writeString(connection.id);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DB_OPEN: {\n\t\t\t\tString dbURL = channel.readString();\n\t\t\t\tString dbName = dbURL.substring(dbURL.lastIndexOf(\":\") + 1);\n\n\t\t\t\tuser = channel.readString();\n\t\t\t\tpasswd = channel.readString();\n\n\t\t\t\t// SEARCH THE DB IN MEMORY FIRST\n\t\t\t\tconnection.database = (ODatabaseDocumentTx) OServerMain.server().getMemoryDatabases().get(dbName);\n\n\t\t\t\tif (connection.database == null)\n\t\t\t\t\t// SEARCH THE DB IN LOCAL FS\n\t\t\t\t\tconnection.database = new ODatabaseDocumentTx(OServerMain.server().getStoragePath(dbName));\n\n\t\t\t\tif (connection.database.isClosed())\n\t\t\t\t\tif (connection.database.getStorage() instanceof OStorageMemory)\n\t\t\t\t\t\tconnection.database.create();\n\t\t\t\t\telse\n\t\t\t\t\t\tconnection.database.open(user, passwd);\n\n\t\t\t\tunderlyingDatabase = ((ODatabaseRaw) ((ODatabaseComplex<?>) connection.database.getUnderlying()).getUnderlying());\n\n\t\t\t\tif (!(underlyingDatabase.getStorage() instanceof OStorageMemory) && !loadUserFromSchema(user, passwd)) {\n\t\t\t\t\tsendError(new OSecurityAccessException(\"Access denied to database '\" + connection.database.getName() + \"' for user: \"\n\t\t\t\t\t\t\t+ user));\n\t\t\t\t} else {\n\t\t\t\t\tsendOk();\n\t\t\t\t\tchannel.writeString(connection.id);\n\t\t\t\t\tchannel.writeInt(connection.database.getClusterNames().size());\n\t\t\t\t\tfor (OCluster c : ((OStorage) connection.database.getStorage()).getClusters()) {\n\t\t\t\t\t\tchannel.writeString(c.getName());\n\t\t\t\t\t\tchannel.writeInt(c.getId());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DB_CREATE: {\n\t\t\t\tString dbName = channel.readString();\n\t\t\t\tString storageMode = channel.readString();\n\n\t\t\t\tfinal String path;\n\t\t\t\tfinal String realPath;\n\n\t\t\t\tif (storageMode.equals(OEngineLocal.NAME)) {\n\t\t\t\t\tif (OServerMain.server().existsStoragePath(dbName))\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Database '\" + dbName + \"' already exists.\");\n\n\t\t\t\t\tpath = storageMode + \":${ORIENT_HOME}/databases/\" + dbName + \"/\" + dbName;\n\t\t\t\t\trealPath = OSystemVariableResolver.resolveSystemVariables(path);\n\t\t\t\t} else if (storageMode.equals(OEngineMemory.NAME)) {\n\t\t\t\t\tif (OServerMain.server().getMemoryDatabases().containsKey(dbName))\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Database '\" + dbName + \"' already exists.\");\n\n\t\t\t\t\tpath = storageMode + \":\" + dbName;\n\t\t\t\t\trealPath = path;\n\t\t\t\t} else\n\t\t\t\t\tthrow new IllegalArgumentException(\"Can't create databse: storage mode '\" + storageMode + \"' is not supported.\");\n\n\t\t\t\tconnection.database = new ODatabaseDocumentTx(realPath);\n\t\t\t\tconnection.database.create();\n\n\t\t\t\tif (storageMode.equals(OEngineLocal.NAME)) {\n\t\t\t\t\t// CLOSE IT BECAUSE IT WILL BE OPEN AT FIRST USE\n\t\t\t\t\tconnection.database.close();\n\n\t\t\t\t} else if (storageMode.equals(OEngineMemory.NAME)) {\n\t\t\t\t\t// SAVE THE DB IN MEMORY\n\t\t\t\t\tOServerMain.server().getMemoryDatabases().put(dbName, connection.database);\n\t\t\t\t}\n\n\t\t\t\tunderlyingDatabase = ((ODatabaseRaw) ((ODatabaseComplex<?>) connection.database.getUnderlying()).getUnderlying());\n\n\t\t\t\tsendOk();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DB_CLOSE:\n\t\t\t\t// connection.storage.close();\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.DB_EXIST:\n\t\t\t\tchannel.writeByte((byte) (connection.database.exists() ? 1 : 0));\n\n\t\t\t\tsendOk();\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.CLUSTER_COUNT:\n\t\t\t\tint[] ids = new int[channel.readShort()];\n\t\t\t\tfor (int i = 0; i < ids.length; ++i)\n\t\t\t\t\tids[i] = channel.readShort();\n\n\t\t\t\tlong count = connection.database.countClusterElements(ids);\n\n\t\t\t\tsendOk();\n\t\t\t\tchannel.writeLong(count);\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.CLUSTER_PHYSICAL_ADD: {\n\t\t\t\tfinal int num = connection.database.addPhysicalCluster(channel.readString(), channel.readString(), channel.readInt());\n\n\t\t\t\tsendOk();\n\t\t\t\tchannel.writeShort((short) num);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.CLUSTER_LOGICAL_ADD: {\n\t\t\t\tfinal int num = connection.database.addLogicalCluster(channel.readString(), connection.database.getDefaultClusterId());\n\n\t\t\t\tsendOk();\n\t\t\t\tOClusterLogical cluster = (OClusterLogical) connection.database.getStorage().getClusterById(num);\n\t\t\t\tchannel.writeShort((short) num);\n\t\t\t\tchannel.writeString(cluster.getRID().toString());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.RECORD_LOAD:\n\t\t\t\tfinal ORawBuffer record = underlyingDatabase.read(channel.readShort(), channel.readLong());\n\t\t\t\tsendOk();\n\t\t\t\tif (record != null) {\n\t\t\t\t\tchannel.writeByte((byte) 1);\n\t\t\t\t\tchannel.writeBytes(record.buffer);\n\t\t\t\t\tchannel.writeInt(record.version);\n\t\t\t\t\tchannel.writeByte(record.recordType);\n\t\t\t\t} else\n\t\t\t\t\tchannel.writeByte((byte) 0);\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.RECORD_CREATE:\n\t\t\t\tfinal long location = underlyingDatabase.save(channel.readShort(), ORID.CLUSTER_POS_INVALID, channel.readBytes(), -1,\n\t\t\t\t\t\tchannel.readByte());\n\t\t\t\tsendOk();\n\t\t\t\tchannel.writeLong(location);\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.RECORD_UPDATE:\n\t\t\t\tfinal int clusterId = channel.readShort();\n\t\t\t\tfinal long position = channel.readLong();\n\n\t\t\t\tlong newVersion = underlyingDatabase.save(clusterId, position, channel.readBytes(), channel.readInt(), channel.readByte());\n\n\t\t\t\t// TODO: Handle it by using triggers\n\t\t\t\tif (clusterId == connection.database.getMetadata().getSchemaClusterId())\n\t\t\t\t\tif (position == OSchema.CLASSES_RECORD_NUM)\n\t\t\t\t\t\tconnection.database.getMetadata().loadSchema();\n\t\t\t\t\telse if (position == OSecurity.SECURITY_RECORD_NUM)\n\t\t\t\t\t\tconnection.database.getMetadata().loadSecurity();\n\n\t\t\t\tsendOk();\n\n\t\t\t\tchannel.writeInt((int) newVersion);\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.RECORD_DELETE:\n\t\t\t\tunderlyingDatabase.delete(channel.readShort(), channel.readLong(), channel.readInt());\n\t\t\t\tsendOk();\n\t\t\t\tbreak;\n\n\t\t\tcase OChannelBinaryProtocol.COUNT: {\n\t\t\t\tfinal String clusterName = channel.readString();\n\t\t\t\tfinal long size = connection.database.countClusterElements(clusterName);\n\n\t\t\t\tsendOk();\n\n\t\t\t\tchannel.writeLong(size);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.COMMAND: {\n\t\t\t\tfinal boolean asynch = channel.readByte() == 'a';\n\n\t\t\t\tfinal OCommandRequestAbstract command = (OCommandRequestAbstract) OStreamSerializerAnyStreamable.INSTANCE\n\t\t\t\t\t\t.fromStream(channel.readBytes());\n\n\t\t\t\tif (asynch) {\n\t\t\t\t\t// ASYNCHRONOUS\n\t\t\t\t\tfinal StringBuilder empty = new StringBuilder();\n\n\t\t\t\t\tcommand.setResultListener(new OCommandResultListener() {\n\t\t\t\t\t\tprivate int\titems\t= 0;\n\n\t\t\t\t\t\tpublic boolean result(final Object iRecord) {\n\t\t\t\t\t\t\tif (items == 0)\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tsendOk();\n\t\t\t\t\t\t\t\t\tempty.append(\"-\");\n\t\t\t\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (command.getLimit() > -1 && items > command.getLimit())\n\t\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tchannel.writeByte((byte) 1);\n\t\t\t\t\t\t\t\titems++;\n\t\t\t\t\t\t\t\twriteRecord((ORecordInternal<?>) iRecord);\n\t\t\t\t\t\t\t\tchannel.flush();\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t((OCommandRequestInternal<ODatabaseRecord<?>>) connection.database.command(command)).execute();\n\n\t\t\t\t\tif (empty.length() == 0)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsendOk();\n\t\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\t}\n\n\t\t\t\t\tchannel.writeByte((byte) 0);\n\t\t\t\t} else {\n\t\t\t\t\t// SYNCHRONOUS\n\t\t\t\t\tfinal Object result = ((OCommandRequestInternal<ODatabaseRecord<?>>) connection.database.command(command)).execute();\n\n\t\t\t\t\tsendOk();\n\n\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\t// NULL VALUE\n\t\t\t\t\t\tchannel.writeByte((byte) 'n');\n\t\t\t\t\t\tchannel.writeBytes(null);\n\t\t\t\t\t} else if (result instanceof ORecord<?>) {\n\t\t\t\t\t\t// RECORD\n\t\t\t\t\t\tchannel.writeByte((byte) 'r');\n\t\t\t\t\t\twriteRecord((ORecordInternal<?>) result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// ANY OTHER (INCLUDING LITERALS)\n\t\t\t\t\t\tchannel.writeByte((byte) 'a');\n\t\t\t\t\t\tchannel.writeBytes(OStreamSerializerAnyRuntime.INSTANCE.toStream(result));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DICTIONARY_LOOKUP: {\n\t\t\t\tString key = channel.readString();\n\n\t\t\t\tORecordInternal<?> value = connection.database.getDictionary().get(key);\n\n\t\t\t\tsendOk();\n\n\t\t\t\twriteRecord(value);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DICTIONARY_PUT: {\n\t\t\t\tString key = channel.readString();\n\t\t\t\tORecordInternal<?> value = ORecordFactory.getRecord(channel.readByte());\n\n\t\t\t\tfinal ORecordId rid = new ORecordId(channel.readString());\n\t\t\t\tvalue.setIdentity(rid.clusterId, rid.clusterPosition);\n\t\t\t\tvalue.setDatabase(connection.database);\n\n\t\t\t\tvalue = connection.database.getDictionary().putRecord(key, value);\n\n\t\t\t\tsendOk();\n\n\t\t\t\twriteRecord(value);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DICTIONARY_REMOVE: {\n\t\t\t\tString key = channel.readString();\n\t\t\t\tORecordInternal<?> value = connection.database.getDictionary().remove(key);\n\n\t\t\t\tsendOk();\n\n\t\t\t\twriteRecord(value);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DICTIONARY_SIZE: {\n\t\t\t\tsendOk();\n\t\t\t\tchannel.writeInt(connection.database.getDictionary().size());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.DICTIONARY_KEYS: {\n\t\t\t\tsendOk();\n\t\t\t\tchannel.writeCollectionString(connection.database.getDictionary().keySet());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase OChannelBinaryProtocol.TX_COMMIT:\n\t\t\t\t((OStorageLocal) connection.database.getStorage()).commit(connection.database.getId(), new OTransactionOptimisticProxy(\n\t\t\t\t\t\t(ODatabaseRecordTx) connection.database.getUnderlying(), channel));\n\n\t\t\t\tsendOk();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tOLogManager.instance().error(this, \"Request not supported. Code: \" + commandType);\n\n\t\t\t\tchannel.clearInput();\n\t\t\t\tsendError(null);\n\t\t\t}\n\t\t} catch (EOFException eof) {\n\t\t\tshutdown();\n\t\t} catch (SocketException e) {\n\t\t\tshutdown();\n\t\t} catch (OException e) {\n\t\t\tsendError(e);\n\t\t} catch (Throwable t) {\n\t\t\tOLogManager.instance().error(this, \"Error on executing request\", t);\n\t\t\tsendError(t);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tchannel.flush();\n\t\t\t} catch (Throwable t) {\n\t\t\t\tOLogManager.instance().debug(this, \"Error on send data over the network\", t);\n\t\t\t}\n\n\t\t\tOSerializationThreadLocal.INSTANCE.get().clear();\n\n\t\t\tlastCommandExecutionTime = System.currentTimeMillis() - clock;\n\t\t\ttotalCommandExecutionTime += lastCommandExecutionTime;\n\n\t\t\tlastCommandType = commandType;\n\t\t}\n\t}","commit_id":"bba882835ac20934e47e57aa712af25bf45559e1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test(dependsOnMethods = \"createSchema\")\r\n\tpublic void checkSchema() {\r\n\t\tdatabase = new ODatabaseFlat(url);\r\n\t\tdatabase.open(\"admin\", \"admin\");\r\n\r\n\t\tOSchema schema = database.getMetadata().getSchema();\r\n\r\n\t\tassert schema != null;\r\n\t\tassert schema.getClass(\"Profile\") != null;\r\n\t\tassert schema.getClass(\"Profile\").getProperty(\"nick\").getType() == OType.STRING;\r\n\t\tassert schema.getClass(\"Profile\").getProperty(\"name\").getType() == OType.STRING;\r\n\t\tassert schema.getClass(\"Profile\").getProperty(\"surname\").getType() == OType.STRING;\r\n\t\tassert schema.getClass(\"Profile\").getProperty(\"addresses\").getType() == OType.EMBEDDEDLIST;\r\n\t\tassert schema.getClass(\"Profile\").getProperty(\"registeredOn\").getType() == OType.DATE;\r\n\t\tassert schema.getClass(\"Profile\").getProperty(\"lastAccessOn\").getType() == OType.DATE;\r\n\r\n\t\tassert schema.getClass(\"Whiz\") != null;\r\n\t\tassert schema.getClass(\"whiz\").getProperty(\"account\").getType() == OType.LINK;\r\n\t\tassert schema.getClass(\"whiz\").getProperty(\"account\").getLinkedClass().getName().equalsIgnoreCase(\"Profile\");\r\n\t\tassert schema.getClass(\"WHIZ\").getProperty(\"date\").getType() == OType.DATE;\r\n\t\tassert schema.getClass(\"WHIZ\").getProperty(\"text\").getType() == OType.STRING;\r\n\t\tassert schema.getClass(\"WHIZ\").getProperty(\"text\").isMandatory();\r\n\t\tassert schema.getClass(\"WHIZ\").getProperty(\"text\").getMin().equals(\"1\");\r\n\t\tassert schema.getClass(\"WHIZ\").getProperty(\"text\").getMax().equals(\"140\");\r\n\t\tassert schema.getClass(\"whiz\").getProperty(\"replyTo\").getType() == OType.LINK;\r\n\t\tassert schema.getClass(\"Whiz\").getProperty(\"replyTo\").getLinkedClass().getName().equalsIgnoreCase(\"Profile\");\r\n\r\n\t\tdatabase.close();\r\n\t}","id":29870,"modified_method":"@Test(dependsOnMethods = \"createSchema\")\r\n\tpublic void checkSchema() {\r\n\t\tdatabase = new ODatabaseFlat(url);\r\n\t\tdatabase.open(\"admin\", \"admin\");\r\n\r\n\t\tOSchema schema = database.getMetadata().getSchema();\r\n\r\n\t\tassert schema != null;\r\n\t\tassert schema.getClass(\"Profile\") != null;\r\n\t\tassert schema.getClass(\"Profile\").getProperty(\"nick\").getType() == OType.STRING;\r\n\t\tassert schema.getClass(\"Profile\").getProperty(\"name\").getType() == OType.STRING;\r\n\t\tassert schema.getClass(\"Profile\").getProperty(\"surname\").getType() == OType.STRING;\r\n\t\tassert schema.getClass(\"Profile\").getProperty(\"registeredOn\").getType() == OType.DATE;\r\n\t\tassert schema.getClass(\"Profile\").getProperty(\"lastAccessOn\").getType() == OType.DATE;\r\n\r\n\t\tassert schema.getClass(\"Whiz\") != null;\r\n\t\tassert schema.getClass(\"whiz\").getProperty(\"account\").getType() == OType.LINK;\r\n\t\tassert schema.getClass(\"whiz\").getProperty(\"account\").getLinkedClass().getName().equalsIgnoreCase(\"Profile\");\r\n\t\tassert schema.getClass(\"WHIZ\").getProperty(\"date\").getType() == OType.DATE;\r\n\t\tassert schema.getClass(\"WHIZ\").getProperty(\"text\").getType() == OType.STRING;\r\n\t\tassert schema.getClass(\"WHIZ\").getProperty(\"text\").isMandatory();\r\n\t\tassert schema.getClass(\"WHIZ\").getProperty(\"text\").getMin().equals(\"1\");\r\n\t\tassert schema.getClass(\"WHIZ\").getProperty(\"text\").getMax().equals(\"140\");\r\n\t\tassert schema.getClass(\"whiz\").getProperty(\"replyTo\").getType() == OType.LINK;\r\n\t\tassert schema.getClass(\"Whiz\").getProperty(\"replyTo\").getLinkedClass().getName().equalsIgnoreCase(\"Profile\");\r\n\r\n\t\tdatabase.close();\r\n\t}","commit_id":"bba882835ac20934e47e57aa712af25bf45559e1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void createSchema() {\r\n\t\tdatabase = new ODatabaseFlat(url);\r\n\t\tdatabase.open(\"admin\", \"admin\");\r\n\r\n\t\tif (database.getMetadata().getSchema().existsClass(\"Account\"))\r\n\t\t\treturn;\r\n\r\n\t\tdatabase.getStorage().addCluster(\"csv\");\r\n\t\tdatabase.getStorage().addCluster(\"flat\");\r\n\t\tdatabase.getStorage().addCluster(\"binary\");\r\n\r\n\t\tOClass account = database.getMetadata().getSchema().createClass(\"Account\", database.getStorage().addCluster(\"account\"));\r\n\t\taccount.createProperty(\"id\", OType.INTEGER);\r\n\r\n\t\tOClass profile = database.getMetadata().getSchema().createClass(\"Profile\", database.getStorage().addCluster(\"profile\"));\r\n\t\tprofile.createProperty(\"nick\", OType.STRING).setMin(\"3\").setMax(\"30\");\r\n\t\tprofile.createProperty(\"name\", OType.STRING).setMin(\"3\").setMax(\"30\");\r\n\t\tprofile.createProperty(\"surname\", OType.STRING).setMin(\"3\").setMax(\"30\");\r\n\t\tprofile.createProperty(\"addresses\", OType.EMBEDDEDLIST);\r\n\t\tprofile.createProperty(\"registeredOn\", OType.DATE).setMin(\"2010-01-01 00:00:00\");\r\n\t\tprofile.createProperty(\"lastAccessOn\", OType.DATE).setMin(\"2010-01-01 00:00:00\");\r\n\r\n\t\tOClass whiz = database.getMetadata().getSchema().createClass(\"Whiz\");\r\n\t\twhiz.createProperty(\"account\", OType.LINK, profile).setMandatory(true).setNotNull(true);\r\n\t\twhiz.createProperty(\"date\", OType.DATE).setMin(\"2010-01-01 00:00:00\");\r\n\t\twhiz.createProperty(\"text\", OType.STRING).setMandatory(true).setMin(\"1\").setMax(\"140\");\r\n\t\twhiz.createProperty(\"replyTo\", OType.LINK, profile);\r\n\r\n\t\tdatabase.getMetadata().getSchema().save();\r\n\t\tdatabase.close();\r\n\t}","id":29871,"modified_method":"public void createSchema() {\r\n\t\tdatabase = new ODatabaseFlat(url);\r\n\t\tdatabase.open(\"admin\", \"admin\");\r\n\r\n\t\tif (database.getMetadata().getSchema().existsClass(\"Account\"))\r\n\t\t\treturn;\r\n\r\n\t\tdatabase.getStorage().addCluster(\"csv\");\r\n\t\tdatabase.getStorage().addCluster(\"flat\");\r\n\t\tdatabase.getStorage().addCluster(\"binary\");\r\n\r\n\t\tOClass account = database.getMetadata().getSchema().createClass(\"Account\", database.getStorage().addCluster(\"account\"));\r\n\t\taccount.createProperty(\"id\", OType.INTEGER);\r\n\r\n\t\tOClass profile = database.getMetadata().getSchema().createClass(\"Profile\", database.getStorage().addCluster(\"profile\"));\r\n\t\tprofile.createProperty(\"nick\", OType.STRING).setMin(\"3\").setMax(\"30\");\r\n\t\tprofile.createProperty(\"name\", OType.STRING).setMin(\"3\").setMax(\"30\");\r\n\t\tprofile.createProperty(\"surname\", OType.STRING).setMin(\"3\").setMax(\"30\");\r\n\t\tprofile.createProperty(\"registeredOn\", OType.DATE).setMin(\"2010-01-01 00:00:00\");\r\n\t\tprofile.createProperty(\"lastAccessOn\", OType.DATE).setMin(\"2010-01-01 00:00:00\");\r\n\r\n\t\tOClass whiz = database.getMetadata().getSchema().createClass(\"Whiz\");\r\n\t\twhiz.createProperty(\"account\", OType.LINK, profile).setMandatory(true).setNotNull(true);\r\n\t\twhiz.createProperty(\"date\", OType.DATE).setMin(\"2010-01-01 00:00:00\");\r\n\t\twhiz.createProperty(\"text\", OType.STRING).setMandatory(true).setMin(\"1\").setMax(\"140\");\r\n\t\twhiz.createProperty(\"replyTo\", OType.LINK, profile);\r\n\r\n\t\tdatabase.getMetadata().getSchema().save();\r\n\t\tdatabase.close();\r\n\t}","commit_id":"bba882835ac20934e47e57aa712af25bf45559e1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testDbCreationNoSecurity() throws IOException {\r\n\t\tif (url.startsWith(OEngineMemory.NAME))\r\n\t\t\tOGlobalConfiguration.STORAGE_KEEP_OPEN.setValue(true);\r\n\r\n\t\tif (!url.startsWith(OEngineRemote.NAME)) {\r\n\t\t\tdatabase = new ODatabaseObjectTx(url);\r\n\t\t\tdatabase.setProperty(\"security\", Boolean.FALSE);\r\n\t\t\tODatabaseHelper.createDatabase(database, url);\r\n\t\t\tODatabaseHelper.deleteDatabase(database);\r\n\t\t}\r\n\t}","id":29872,"modified_method":"public void testDbCreationNoSecurity() throws IOException {\r\n\t\tif (url.startsWith(OEngineMemory.NAME))\r\n\t\t\tOGlobalConfiguration.STORAGE_KEEP_OPEN.setValue(true);\r\n\r\n\t\tif (!url.startsWith(OEngineRemote.NAME)) {\r\n\t\t\tdatabase = new ODatabaseObjectTx(url);\r\n\t\t\tdatabase.setProperty(\"security\", Boolean.FALSE);\r\n\r\n\t\t\tODatabaseHelper.deleteDatabase(database);\r\n\t\t\tODatabaseHelper.createDatabase(database, url);\r\n\t\t\tODatabaseHelper.deleteDatabase(database);\r\n\t\t}\r\n\t}","commit_id":"0caea16f03f68b0f98f4c9ceff75f3f9b7f8c370","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private int moveRecord(final long iSourcePosition, final long iDestinationPosition) throws IOException {\r\n\t\t// GET RECORD TO MOVE\r\n\t\tfinal long[] pos = getRelativePosition(iSourcePosition);\r\n\t\tfinal OFile file = files[(int) pos[0]];\r\n\r\n\t\tfinal int recordSize = file.readInt(pos[1]);\r\n\r\n\t\tif (recordSize < 0)\r\n\t\t\t// FOUND HOLE\r\n\t\t\treturn -1;\r\n\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tfinal short clusterId = file.readShort(pos[1] + OConstants.SIZE_INT);\r\n\t\tfinal long clusterPosition = file.readLong(pos[1] + OConstants.SIZE_INT + OConstants.SIZE_SHORT);\r\n\r\n\t\tfinal byte[] content = new byte[recordSize];\r\n\t\tfile.read(pos[1] + RECORD_FIX_SIZE, content, recordSize);\r\n\r\n\t\tif (clusterId > -1) {\r\n\t\t\t// CHANGE THE POINTMENT OF CLUSTER TO THE NEW POSITION. -1 MEANS TEMP RECORD\r\n\t\t\tfinal OCluster cluster = storage.getClusterById(clusterId);\r\n\t\t\tfinal OPhysicalPosition ppos = cluster.getPhysicalPosition(clusterPosition, new OPhysicalPosition());\r\n\r\n\t\t\tif (ppos.dataPosition != iSourcePosition)\r\n\t\t\t\tthrow new OStorageException(\"Found corrupted record hole for rid \" + clusterId + \":\" + clusterPosition\r\n\t\t\t\t\t\t+ \": data position is wrong: \" + ppos.dataPosition + \"<->\" + iSourcePosition);\r\n\r\n\t\t\tcluster.setPhysicalPosition(clusterPosition, iDestinationPosition);\r\n\t\t}\r\n\r\n\t\twriteRecord(getRelativePosition(iDestinationPosition), clusterId, clusterPosition, content);\r\n\r\n\t\tOProfiler.getInstance().stopChrono(PROFILER_MOVE_RECORD, timer);\r\n\r\n\t\treturn recordSize + RECORD_FIX_SIZE;\r\n\t}","id":29873,"modified_method":"private int moveRecord(final long iSourcePosition, final long iDestinationPosition) throws IOException {\r\n\t\t// GET RECORD TO MOVE\r\n\t\tfinal long[] pos = getRelativePosition(iSourcePosition);\r\n\t\tfinal OFile file = files[(int) pos[0]];\r\n\r\n\t\tfinal int recordSize = file.readInt(pos[1]);\r\n\r\n\t\tif (recordSize < 0)\r\n\t\t\t// FOUND HOLE\r\n\t\t\treturn -1;\r\n\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tfinal short clusterId = file.readShort(pos[1] + OConstants.SIZE_INT);\r\n\t\tfinal long clusterPosition = file.readLong(pos[1] + OConstants.SIZE_INT + OConstants.SIZE_SHORT);\r\n\r\n\t\tfinal byte[] content = new byte[recordSize];\r\n\t\tfile.read(pos[1] + RECORD_FIX_SIZE, content, recordSize);\r\n\r\n\t\tif (clusterId > -1) {\r\n\t\t\t// CHANGE THE POINTMENT OF CLUSTER TO THE NEW POSITION. -1 MEANS TEMP RECORD\r\n\t\t\tfinal OCluster cluster = storage.getClusterById(clusterId);\r\n\t\t\tfinal OPhysicalPosition ppos = cluster.getPhysicalPosition(clusterPosition, new OPhysicalPosition());\r\n\r\n\t\t\tif (ppos.dataPosition != iSourcePosition)\r\n\t\t\t\tOLogManager.instance().warn(this,\r\n\t\t\t\t\t\t\"Found corrupted record hole for rid %d:%d: data position is wrong: %d <-> %d. Auto fixed by writing position %d\",\r\n\t\t\t\t\t\tclusterId, clusterPosition, ppos.dataPosition, iSourcePosition, iDestinationPosition);\r\n\r\n\t\t\tcluster.setPhysicalPosition(clusterPosition, iDestinationPosition);\r\n\t\t}\r\n\r\n\t\twriteRecord(getRelativePosition(iDestinationPosition), clusterId, clusterPosition, content);\r\n\r\n\t\tOProfiler.getInstance().stopChrono(PROFILER_MOVE_RECORD, timer);\r\n\r\n\t\treturn recordSize + RECORD_FIX_SIZE;\r\n\t}","commit_id":"0caea16f03f68b0f98f4c9ceff75f3f9b7f8c370","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void writeRecord(final long[] iFilePosition, final int iClusterSegment, final long iClusterPosition,\r\n\t\t\tfinal byte[] iContent) throws IOException {\r\n\t\tfinal OFile file = files[(int) iFilePosition[0]];\r\n\r\n\t\tfile.writeInt(iFilePosition[1], iContent.length);\r\n\t\tfile.writeShort(iFilePosition[1] + OConstants.SIZE_INT, (short) iClusterSegment);\r\n\t\tfile.writeLong(iFilePosition[1] + OConstants.SIZE_INT + OConstants.SIZE_SHORT, iClusterPosition);\r\n\r\n\t\tfile.write(iFilePosition[1] + RECORD_FIX_SIZE, iContent);\r\n\t}","id":29874,"modified_method":"protected void writeRecord(final long[] iFilePosition, final int iClusterSegment, final long iClusterPosition,\r\n\t\t\tfinal byte[] iContent) throws IOException {\r\n\t\tfinal OFile file = files[(int) iFilePosition[0]];\r\n\r\n\t\tfile.writeInt(iFilePosition[1], iContent.length);\r\n\t\tfile.writeShort(iFilePosition[1] + OConstants.SIZE_INT, (short) iClusterSegment);\r\n\t\tTestSimulateError.onDataLocalWriteRecord(this, iFilePosition, iClusterSegment, iClusterPosition, iContent);\r\n\t\tfile.writeLong(iFilePosition[1] + OConstants.SIZE_INT + OConstants.SIZE_SHORT, iClusterPosition);\r\n\r\n\t\tfile.write(iFilePosition[1] + RECORD_FIX_SIZE, iContent);\r\n\t}","commit_id":"0caea16f03f68b0f98f4c9ceff75f3f9b7f8c370","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected long createRecord(final int iTxId, final OCluster iClusterSegment, final ORecordId iRid, final byte[] iContent,\r\n\t\t\tfinal byte iRecordType) throws IOException {\r\n\t\tiRid.clusterPosition = -1;\r\n\r\n\t\ttry {\r\n\t\t\t// SAVE INTO THE LOG THE POSITION OF THE RECORD JUST CREATED. IF TX FAILS AT THIS POINT A GHOST RECORD IS CREATED UNTIL DEFRAG\r\n\t\t\ttxSegment.addLog(OTxSegment.OPERATION_CREATE, iTxId, iRid.clusterId, iRid.clusterPosition, iRecordType, 0, null);\r\n\r\n\t\t\treturn storage.createRecord(iClusterSegment, iContent, iRecordType);\r\n\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on creating entry in log segment: \" + iClusterSegment, e,\r\n\t\t\t\t\tOTransactionException.class);\r\n\t\t}\r\n\r\n\t\treturn iRid.clusterPosition;\r\n\t}","id":29875,"modified_method":"protected long createRecord(final int iTxId, final OCluster iClusterSegment, final ORecordId iRid, final byte[] iContent,\r\n\t\t\tfinal byte iRecordType) throws IOException {\r\n\t\tiRid.clusterPosition = -1;\r\n\r\n\t\ttry {\r\n\t\t\t// SAVE INTO THE LOG THE POSITION OF THE RECORD JUST CREATED. IF TX FAILS AT THIS POINT A GHOST RECORD IS CREATED UNTIL DEFRAG\r\n\t\t\ttxSegment.addLog(OTxSegment.OPERATION_CREATE, iTxId, iRid.clusterId, iRid.clusterPosition, iRecordType, 0, null);\r\n\r\n\t\t\tiRid.clusterPosition = storage.createRecord(iClusterSegment, iContent, iRecordType);\r\n\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on creating entry in log segment: \" + iClusterSegment, e,\r\n\t\t\t\t\tOTransactionException.class);\r\n\t\t}\r\n\r\n\t\treturn iRid.clusterPosition;\r\n\t}","commit_id":"0caea16f03f68b0f98f4c9ceff75f3f9b7f8c370","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\r\n\tpublic void testRollbackWithCopyCacheStrategy() throws IOException {\r\n\t\tdatabase1 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\tdatabase1.getLevel2Cache().setStrategy(STRATEGY.COPY_RECORD);\r\n\r\n\t\t// Create docA.\r\n\t\tODocument vDocA_db1 = database1.newInstance();\r\n\t\tvDocA_db1.field(NAME, \"docA\");\r\n\t\tvDocA_db1.save();\r\n\r\n\t\t// Keep the IDs.\r\n\t\tORID vDocA_Rid = vDocA_db1.getIdentity().copy();\r\n\r\n\t\tdatabase2.begin(TXTYPE.OPTIMISTIC);\r\n\t\ttry {\r\n\t\t\t// Get docA and update in db2 transaction context\r\n\t\t\tODocument vDocA_db2 = database2.load(vDocA_Rid);\r\n\t\t\tvDocA_db2.field(NAME, \"docA_v2\");\r\n\t\t\tvDocA_db2.save();\r\n\r\n\t\t\tdatabase1.begin(TXTYPE.OPTIMISTIC);\r\n\t\t\ttry {\r\n\t\t\t\tvDocA_db1.field(NAME, \"docA_v3\");\r\n\t\t\t\tvDocA_db1.save();\r\n\t\t\t\tdatabase1.commit();\r\n\t\t\t} catch (OConcurrentModificationException e) {\r\n\t\t\t\tAssert.fail(\"Should not failed here...\");\r\n\t\t\t}\r\n\t\t\tAssert.assertEquals(vDocA_db1.field(NAME), \"docA_v3\");\r\n\r\n\t\t\t// Will throw OConcurrentModificationException\r\n\t\t\tdatabase2.commit();\r\n\t\t\tAssert.fail(\"Should throw OConcurrentModificationException\");\r\n\t\t} catch (OConcurrentModificationException e) {\r\n\t\t\tdatabase2.rollback();\r\n\t\t}\r\n\r\n\t\t// Force reload all (to be sure it is not a cache problem)\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.close();\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\t// docB should be in the last state : \"docA_v3\"\r\n\t\tODocument vDocB_db2 = database2.load(vDocA_Rid);\r\n\t\tAssert.assertEquals(vDocB_db2.field(NAME), \"docA_v3\");\r\n\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.close();\r\n\t}","id":29876,"modified_method":"@Test\r\n\tpublic void test3RollbackWithCopyCacheStrategy() throws IOException {\r\n\t\tdatabase1 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\tdatabase1.getLevel2Cache().setStrategy(STRATEGY.COPY_RECORD);\r\n\r\n\t\t// Create docA.\r\n\t\tODocument vDocA_db1 = database1.newInstance();\r\n\t\tvDocA_db1.field(NAME, \"docA\");\r\n\t\tvDocA_db1.save();\r\n\r\n\t\t// Keep the IDs.\r\n\t\tORID vDocA_Rid = vDocA_db1.getIdentity().copy();\r\n\r\n\t\tdatabase2.begin(TXTYPE.OPTIMISTIC);\r\n\t\ttry {\r\n\t\t\t// Get docA and update in db2 transaction context\r\n\t\t\tODocument vDocA_db2 = database2.load(vDocA_Rid);\r\n\t\t\tvDocA_db2.field(NAME, \"docA_v2\");\r\n\t\t\tvDocA_db2.save();\r\n\r\n\t\t\tdatabase1.begin(TXTYPE.OPTIMISTIC);\r\n\t\t\ttry {\r\n\t\t\t\tvDocA_db1.field(NAME, \"docA_v3\");\r\n\t\t\t\tvDocA_db1.save();\r\n\t\t\t\tdatabase1.commit();\r\n\t\t\t} catch (OConcurrentModificationException e) {\r\n\t\t\t\tAssert.fail(\"Should not failed here...\");\r\n\t\t\t}\r\n\t\t\tAssert.assertEquals(vDocA_db1.field(NAME), \"docA_v3\");\r\n\r\n\t\t\t// Will throw OConcurrentModificationException\r\n\t\t\tdatabase2.commit();\r\n\t\t\tAssert.fail(\"Should throw OConcurrentModificationException\");\r\n\t\t} catch (OConcurrentModificationException e) {\r\n\t\t\tdatabase2.rollback();\r\n\t\t}\r\n\r\n\t\t// Force reload all (to be sure it is not a cache problem)\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.close();\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\t// docB should be in the last state : \"docA_v3\"\r\n\t\tODocument vDocB_db2 = database2.load(vDocA_Rid);\r\n\t\tAssert.assertEquals(vDocB_db2.field(NAME), \"docA_v3\");\r\n\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.close();\r\n\t}","commit_id":"0caea16f03f68b0f98f4c9ceff75f3f9b7f8c370","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\r\n\tpublic void testRollbackOnConcurrentException() throws IOException {\r\n\t\tdatabase1 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\tdatabase1.begin(TXTYPE.OPTIMISTIC);\r\n\r\n\t\t// Create docA.\r\n\t\tODocument vDocA_db1 = database1.newInstance();\r\n\t\tvDocA_db1.field(NAME, \"docA\");\r\n\t\tvDocA_db1.save();\r\n\r\n\t\t// Create docB.\r\n\t\tODocument vDocB_db1 = database1.newInstance();\r\n\t\tvDocB_db1.field(NAME, \"docB\");\r\n\t\tvDocB_db1.save();\r\n\r\n\t\tdatabase1.commit();\r\n\r\n\t\t// Keep the IDs.\r\n\t\tORID vDocA_Rid = vDocA_db1.getIdentity().copy();\r\n\t\tORID vDocB_Rid = vDocB_db1.getIdentity().copy();\r\n\r\n\t\tdatabase2.begin(TXTYPE.OPTIMISTIC);\r\n\t\ttry {\r\n\t\t\t// Get docA and update in db2 transaction context\r\n\t\t\tODocument vDocA_db2 = database2.load(vDocA_Rid);\r\n\t\t\tvDocA_db2.field(NAME, \"docA_v2\");\r\n\t\t\tvDocA_db2.save();\r\n\r\n\t\t\t// Concurrent update docA via database1 -> will throw OConcurrentModificationException at database2.commit().\r\n\t\t\tdatabase1.begin(TXTYPE.OPTIMISTIC);\r\n\t\t\ttry {\r\n\t\t\t\tvDocA_db1.field(NAME, \"docA_v3\");\r\n\t\t\t\tvDocA_db1.save();\r\n\t\t\t\tdatabase1.commit();\r\n\t\t\t} catch (OConcurrentModificationException e) {\r\n\t\t\t\tAssert.fail(\"Should not failed here...\");\r\n\t\t\t}\r\n\t\t\tAssert.assertEquals(vDocA_db1.field(NAME), \"docA_v3\");\r\n\r\n\t\t\t// Update docB in db2 transaction context -> should be rollbacked.\r\n\t\t\tODocument vDocB_db2 = database2.load(vDocB_Rid);\r\n\t\t\tvDocB_db2.field(NAME, \"docB_UpdatedInTranscationThatWillBeRollbacked\");\r\n\t\t\tvDocB_db2.save();\r\n\r\n\t\t\t// Will throw OConcurrentModificationException\r\n\t\t\tdatabase2.commit();\r\n\t\t\tAssert.fail(\"Should throw OConcurrentModificationException\");\r\n\t\t} catch (OConcurrentModificationException e) {\r\n\t\t\tdatabase2.rollback();\r\n\t\t}\r\n\r\n\t\t// Force reload all (to be sure it is not a cache problem)\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.getStorage().close();\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\t// docB should be in the first state : \"docB\"\r\n\t\tODocument vDocB_db2 = database2.load(vDocB_Rid);\r\n\t\tAssert.assertEquals(vDocB_db2.field(NAME), \"docB\");\r\n\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.close();\r\n\t}","id":29877,"modified_method":"@Test\r\n\tpublic void test1RollbackOnConcurrentException() throws IOException {\r\n\t\tdatabase1 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\tdatabase1.begin(TXTYPE.OPTIMISTIC);\r\n\r\n\t\t// Create docA.\r\n\t\tODocument vDocA_db1 = database1.newInstance();\r\n\t\tvDocA_db1.field(NAME, \"docA\");\r\n\t\tvDocA_db1.save();\r\n\r\n\t\t// Create docB.\r\n\t\tODocument vDocB_db1 = database1.newInstance();\r\n\t\tvDocB_db1.field(NAME, \"docB\");\r\n\t\tvDocB_db1.save();\r\n\r\n\t\tdatabase1.commit();\r\n\r\n\t\t// Keep the IDs.\r\n\t\tORID vDocA_Rid = vDocA_db1.getIdentity().copy();\r\n\t\tORID vDocB_Rid = vDocB_db1.getIdentity().copy();\r\n\r\n\t\tdatabase2.begin(TXTYPE.OPTIMISTIC);\r\n\t\ttry {\r\n\t\t\t// Get docA and update in db2 transaction context\r\n\t\t\tODocument vDocA_db2 = database2.load(vDocA_Rid);\r\n\t\t\tvDocA_db2.field(NAME, \"docA_v2\");\r\n\t\t\tvDocA_db2.save();\r\n\r\n\t\t\t// Concurrent update docA via database1 -> will throw OConcurrentModificationException at database2.commit().\r\n\t\t\tdatabase1.begin(TXTYPE.OPTIMISTIC);\r\n\t\t\ttry {\r\n\t\t\t\tvDocA_db1.field(NAME, \"docA_v3\");\r\n\t\t\t\tvDocA_db1.save();\r\n\t\t\t\tdatabase1.commit();\r\n\t\t\t} catch (OConcurrentModificationException e) {\r\n\t\t\t\tAssert.fail(\"Should not failed here...\");\r\n\t\t\t}\r\n\t\t\tAssert.assertEquals(vDocA_db1.field(NAME), \"docA_v3\");\r\n\r\n\t\t\t// Update docB in db2 transaction context -> should be rollbacked.\r\n\t\t\tODocument vDocB_db2 = database2.load(vDocB_Rid);\r\n\t\t\tvDocB_db2.field(NAME, \"docB_UpdatedInTranscationThatWillBeRollbacked\");\r\n\t\t\tvDocB_db2.save();\r\n\r\n\t\t\t// Will throw OConcurrentModificationException\r\n\t\t\tdatabase2.commit();\r\n\t\t\tAssert.fail(\"Should throw OConcurrentModificationException\");\r\n\t\t} catch (OConcurrentModificationException e) {\r\n\t\t\tdatabase2.rollback();\r\n\t\t}\r\n\r\n\t\t// Force reload all (to be sure it is not a cache problem)\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.getStorage().close();\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\t// docB should be in the first state : \"docB\"\r\n\t\tODocument vDocB_db2 = database2.load(vDocB_Rid);\r\n\t\tAssert.assertEquals(vDocB_db2.field(NAME), \"docB\");\r\n\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.close();\r\n\t}","commit_id":"0caea16f03f68b0f98f4c9ceff75f3f9b7f8c370","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\r\n\tpublic void testRollbackWithPin() throws IOException {\r\n\t\tdatabase1 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\t// Create docA.\r\n\t\tODocument vDocA_db1 = database1.newInstance();\r\n\t\tvDocA_db1.field(NAME, \"docA\");\r\n\t\tvDocA_db1.unpin();\r\n\t\tvDocA_db1.save();\r\n\r\n\t\t// Keep the IDs.\r\n\t\tORID vDocA_Rid = vDocA_db1.getIdentity().copy();\r\n\r\n\t\tdatabase2.begin(TXTYPE.OPTIMISTIC);\r\n\t\ttry {\r\n\t\t\t// Get docA and update in db2 transaction context\r\n\t\t\tODocument vDocA_db2 = database2.load(vDocA_Rid);\r\n\t\t\tvDocA_db2.field(NAME, \"docA_v2\");\r\n\t\t\tvDocA_db2.save();\r\n\r\n\t\t\tdatabase1.begin(TXTYPE.OPTIMISTIC);\r\n\t\t\ttry {\r\n\t\t\t\tvDocA_db1.field(NAME, \"docA_v3\");\r\n\t\t\t\tvDocA_db1.save();\r\n\t\t\t\tdatabase1.commit();\r\n\t\t\t} catch (OConcurrentModificationException e) {\r\n\t\t\t\tAssert.fail(\"Should not failed here...\");\r\n\t\t\t}\r\n\t\t\tAssert.assertEquals(vDocA_db1.field(NAME), \"docA_v3\");\r\n\r\n\t\t\t// Will throw OConcurrentModificationException\r\n\t\t\tdatabase2.commit();\r\n\t\t\tAssert.fail(\"Should throw OConcurrentModificationException\");\r\n\t\t} catch (OConcurrentModificationException e) {\r\n\t\t\tdatabase2.rollback();\r\n\t\t}\r\n\r\n\t\t// Force reload all (to be sure it is not a cache problem)\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.close();\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\t// docB should be in the last state : \"docA_v3\"\r\n\t\tODocument vDocB_db2 = database2.load(vDocA_Rid);\r\n\t\tAssert.assertEquals(vDocB_db2.field(NAME), \"docA_v3\");\r\n\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.close();\r\n\t}","id":29878,"modified_method":"@Test\r\n\tpublic void test4RollbackWithPin() throws IOException {\r\n\t\tdatabase1 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\t// Create docA.\r\n\t\tODocument vDocA_db1 = database1.newInstance();\r\n\t\tvDocA_db1.field(NAME, \"docA\");\r\n\t\tvDocA_db1.unpin();\r\n\t\tvDocA_db1.save();\r\n\r\n\t\t// Keep the IDs.\r\n\t\tORID vDocA_Rid = vDocA_db1.getIdentity().copy();\r\n\r\n\t\tdatabase2.begin(TXTYPE.OPTIMISTIC);\r\n\t\ttry {\r\n\t\t\t// Get docA and update in db2 transaction context\r\n\t\t\tODocument vDocA_db2 = database2.load(vDocA_Rid);\r\n\t\t\tvDocA_db2.field(NAME, \"docA_v2\");\r\n\t\t\tvDocA_db2.save();\r\n\r\n\t\t\tdatabase1.begin(TXTYPE.OPTIMISTIC);\r\n\t\t\ttry {\r\n\t\t\t\tvDocA_db1.field(NAME, \"docA_v3\");\r\n\t\t\t\tvDocA_db1.save();\r\n\t\t\t\tdatabase1.commit();\r\n\t\t\t} catch (OConcurrentModificationException e) {\r\n\t\t\t\tAssert.fail(\"Should not failed here...\");\r\n\t\t\t}\r\n\t\t\tAssert.assertEquals(vDocA_db1.field(NAME), \"docA_v3\");\r\n\r\n\t\t\t// Will throw OConcurrentModificationException\r\n\t\t\tdatabase2.commit();\r\n\t\t\tAssert.fail(\"Should throw OConcurrentModificationException\");\r\n\t\t} catch (OConcurrentModificationException e) {\r\n\t\t\tdatabase2.rollback();\r\n\t\t}\r\n\r\n\t\t// Force reload all (to be sure it is not a cache problem)\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.close();\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\t// docB should be in the last state : \"docA_v3\"\r\n\t\tODocument vDocB_db2 = database2.load(vDocA_Rid);\r\n\t\tAssert.assertEquals(vDocB_db2.field(NAME), \"docA_v3\");\r\n\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.close();\r\n\t}","commit_id":"0caea16f03f68b0f98f4c9ceff75f3f9b7f8c370","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\r\n\tpublic void testCacheUpdatedMultipleDbs() {\r\n\t\tdatabase1 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\t// Create docA in db1\r\n\t\tdatabase1.begin(TXTYPE.OPTIMISTIC);\r\n\t\tODocument vDocA_db1 = database1.newInstance();\r\n\t\tvDocA_db1.field(NAME, \"docA\");\r\n\t\tvDocA_db1.save();\r\n\t\tdatabase1.commit();\r\n\r\n\t\t// Keep the ID.\r\n\t\tORID vDocA_Rid = vDocA_db1.getIdentity().copy();\r\n\r\n\t\t// Update docA in db2\r\n\t\tdatabase2.begin(TXTYPE.OPTIMISTIC);\r\n\t\tODocument vDocA_db2 = database2.load(vDocA_Rid);\r\n\t\tvDocA_db2.field(NAME, \"docA_v2\");\r\n\t\tvDocA_db2.save();\r\n\t\tdatabase2.commit();\r\n\r\n\t\t// Later... read docA with db1.\r\n\t\tdatabase1.begin(TXTYPE.OPTIMISTIC);\r\n\t\tODocument vDocA_db1_later = database1.load(vDocA_Rid, null, true);\r\n\t\tAssert.assertEquals(vDocA_db1_later.field(NAME), \"docA_v2\");\r\n\t\tdatabase1.commit();\r\n\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.close();\r\n\t}","id":29879,"modified_method":"@Test\r\n\tpublic void test5CacheUpdatedMultipleDbs() {\r\n\t\tdatabase1 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\t\tdatabase2 = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\r\n\t\t// Create docA in db1\r\n\t\tdatabase1.begin(TXTYPE.OPTIMISTIC);\r\n\t\tODocument vDocA_db1 = database1.newInstance();\r\n\t\tvDocA_db1.field(NAME, \"docA\");\r\n\t\tvDocA_db1.save();\r\n\t\tdatabase1.commit();\r\n\r\n\t\t// Keep the ID.\r\n\t\tORID vDocA_Rid = vDocA_db1.getIdentity().copy();\r\n\r\n\t\t// Update docA in db2\r\n\t\tdatabase2.begin(TXTYPE.OPTIMISTIC);\r\n\t\tODocument vDocA_db2 = database2.load(vDocA_Rid);\r\n\t\tvDocA_db2.field(NAME, \"docA_v2\");\r\n\t\tvDocA_db2.save();\r\n\t\tdatabase2.commit();\r\n\r\n\t\t// Later... read docA with db1.\r\n\t\tdatabase1.begin(TXTYPE.OPTIMISTIC);\r\n\t\tODocument vDocA_db1_later = database1.load(vDocA_Rid, null, true);\r\n\t\tAssert.assertEquals(vDocA_db1_later.field(NAME), \"docA_v2\");\r\n\t\tdatabase1.commit();\r\n\r\n\t\tdatabase1.close();\r\n\t\tdatabase2.close();\r\n\t}","commit_id":"0caea16f03f68b0f98f4c9ceff75f3f9b7f8c370","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * Installs the specified artifact to the local repository. This method serves basically the same purpose as\n     * {@link #installArtifact(File, Artifact, ArtifactRepository)} but is meant for artifacts that have been resolved\n     * from the user's local repository (and not the current build outputs). The subtle difference here is that\n     * artifacts from the repository have already undergone transformations and these manipulations should not be redone\n     * by the artifact installer. For this reason, this method performs plain copy operations to install the artifacts.\n     * \n     * @param file The file associated with the artifact, must not be <code>null<\/code>.\n     * @param artifact The artifact to install, must not be <code>null<\/code>.\n     * @param testRepository The local repository to install the artifact to, must not be <code>null<\/code>.\n     * @throws MojoExecutionException If the artifact could not be installed (e.g. has no associated file).\n     */\n    private void stageArtifact( File file, Artifact artifact, ArtifactRepository testRepository )\n        throws MojoExecutionException\n    {\n        try\n        {\n            if ( file == null )\n            {\n                throw new IllegalStateException( \"Artifact has no associated file: \" + file );\n            }\n            if ( !file.isFile() )\n            {\n                throw new IllegalStateException( \"Artifact is not fully assembled: \" + file );\n            }\n\n            if ( installedArtifacts.add( artifact.getId() ) )\n            {\n                File destination = new File( testRepository.getBasedir(), testRepository.pathOf( artifact ) );\n\n                getLog().debug( \"Installing \" + file + \" to \" + destination );\n\n                FileUtils.copyFile( file, destination );\n\n                for ( Iterator it = artifact.getMetadataList().iterator(); it.hasNext(); )\n                {\n                    ArtifactMetadata metadata = (ArtifactMetadata) it.next();\n                    metadata.storeInLocalRepository( testRepository, testRepository );\n                }\n            }\n            else\n            {\n                getLog().debug( \"Not re-installing \" + artifact + \", \" + file );\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Failed to stage artifact: \" + artifact, e );\n        }\n    }","id":29880,"modified_method":"/**\n     * Installs the specified artifact to the local repository. This method serves basically the same purpose as\n     * {@link #installArtifact(File, Artifact, ArtifactRepository)} but is meant for artifacts that have been resolved\n     * from the user's local repository (and not the current build outputs). The subtle difference here is that\n     * artifacts from the repository have already undergone transformations and these manipulations should not be redone\n     * by the artifact installer. For this reason, this method performs plain copy operations to install the artifacts.\n     * \n     * @param file The file associated with the artifact, must not be <code>null<\/code>.\n     * @param artifact The artifact to install, must not be <code>null<\/code>.\n     * @param testRepository The local repository to install the artifact to, must not be <code>null<\/code>.\n     * @throws MojoExecutionException If the artifact could not be installed (e.g. has no associated file).\n     */\n    private void copyArtifact( File file, Artifact artifact, ArtifactRepository testRepository )\n        throws MojoExecutionException\n    {\n        try\n        {\n            if ( file == null )\n            {\n                throw new IllegalStateException( \"Artifact has no associated file: \" + file );\n            }\n            if ( !file.isFile() )\n            {\n                throw new IllegalStateException( \"Artifact is not fully assembled: \" + file );\n            }\n\n            if ( copiedArtifacts.add( artifact.getId() ) )\n            {\n                File destination = new File( testRepository.getBasedir(), testRepository.pathOf( artifact ) );\n\n                getLog().debug( \"Installing \" + file + \" to \" + destination );\n\n                copyFileIfDifferent( file, destination );\n\n                for ( Iterator it = artifact.getMetadataList().iterator(); it.hasNext(); )\n                {\n                    ArtifactMetadata metadata = (ArtifactMetadata) it.next();\n                    metadata.storeInLocalRepository( testRepository, testRepository );\n                }\n            }\n            else\n            {\n                getLog().debug( \"Not re-installing \" + artifact + \", \" + file );\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Failed to stage artifact: \" + artifact, e );\n        }\n    }","commit_id":"18ed12ce5486ddf9ace106c8de2434eced830379","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Installs the dependent projects from the reactor to the local repository. The dependencies on other modules from\n     * the reactor must be installed or the forked IT builds will fail when using a clean repository.\n     * \n     * @param mvnProject The project whose dependent projects should be installed, must not be <code>null<\/code>.\n     * @param reactorProjects The set of projects in the reactor build, must not be <code>null<\/code>.\n     * @param testRepository The local repository to install the POMs to, must not be <code>null<\/code>.\n     * @throws MojoExecutionException If any dependency could not be installed.\n     */\n    private void installProjectDependencies( MavenProject mvnProject, Collection reactorProjects,\n                                             ArtifactRepository testRepository )\n        throws MojoExecutionException\n    {\n        // index available reactor projects\n        Map projects = new HashMap();\n        for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n        {\n            MavenProject reactorProject = (MavenProject) it.next();\n            String id = reactorProject.getGroupId() + ':' + reactorProject.getArtifactId();\n            projects.put( id, reactorProject );\n        }\n\n        // collect transitive dependencies (even those that don't contribute to the class path like POMs)\n        Collection artifacts = mvnProject.getArtifacts();\n        Collection dependencies = new LinkedHashSet();\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            String id = ArtifactUtils.versionlessKey( artifact );\n            dependencies.add( id );\n        }\n\n        // install dependencies\n        try\n        {\n            // install dependencies from reactor\n            for ( Iterator it = dependencies.iterator(); it.hasNext(); )\n            {\n                String id = (String) it.next();\n                MavenProject requiredProject = (MavenProject) projects.remove( id );\n                if ( requiredProject != null )\n                {\n                    it.remove();\n                    installProjectArtifacts( requiredProject, testRepository );\n                    installProjectParents( requiredProject, testRepository );\n                }\n            }\n\n            // install remaining dependencies from local repository\n            for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n                String id = ArtifactUtils.versionlessKey( artifact );\n\n                if ( dependencies.contains( id ) )\n                {\n                    // workaround for MNG-2961 to ensure the base version does not contain a timestamp\n                    artifact.isSnapshot();\n\n                    Artifact depArtifact =\n                        artifactFactory.createArtifactWithClassifier( artifact.getGroupId(),\n                                                                      artifact.getArtifactId(),\n                                                                      artifact.getBaseVersion(), artifact.getType(),\n                                                                      artifact.getClassifier() );\n\n                    File artifactFile = artifact.getFile();\n\n                    Artifact pomArtifact =\n                        artifactFactory.createArtifact( artifact.getGroupId(), artifact.getArtifactId(),\n                                                        artifact.getBaseVersion(), null, \"pom\" );\n\n                    File pomFile = new File( localRepository.getBasedir(), localRepository.pathOf( pomArtifact ) );\n                    if ( pomFile.isFile() )\n                    {\n                        if ( !pomFile.equals( artifactFile ) )\n                        {\n                            depArtifact.addMetadata( new ProjectArtifactMetadata( depArtifact, pomFile ) );\n                        }\n                        stageParentPoms( pomFile, testRepository );\n                    }\n\n                    stageArtifact( artifactFile, depArtifact, testRepository );\n                }\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Failed to install project dependencies: \" + mvnProject, e );\n        }\n    }","id":29881,"modified_method":"/**\n     * Installs the dependent projects from the reactor to the local repository. The dependencies on other modules from\n     * the reactor must be installed or the forked IT builds will fail when using a clean repository.\n     * \n     * @param mvnProject The project whose dependent projects should be installed, must not be <code>null<\/code>.\n     * @param reactorProjects The set of projects in the reactor build, must not be <code>null<\/code>.\n     * @param testRepository The local repository to install the POMs to, must not be <code>null<\/code>.\n     * @throws MojoExecutionException If any dependency could not be installed.\n     */\n    private void installProjectDependencies( MavenProject mvnProject, Collection reactorProjects,\n                                             ArtifactRepository testRepository )\n        throws MojoExecutionException\n    {\n        // index available reactor projects\n        Map projects = new HashMap();\n        for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n        {\n            MavenProject reactorProject = (MavenProject) it.next();\n\n            String projectId =\n                reactorProject.getGroupId() + ':' + reactorProject.getArtifactId() + ':' + reactorProject.getVersion();\n\n            projects.put( projectId, reactorProject );\n        }\n\n        // group transitive dependencies (even those that don't contribute to the class path like POMs) ...\n        Collection artifacts = mvnProject.getArtifacts();\n        // ... into dependencies that were resolved from reactor projects ...\n        Collection dependencyProjects = new LinkedHashSet();\n        // ... and those that were resolved from the (local) repo\n        Collection dependencyArtifacts = new LinkedHashSet();\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n\n            // workaround for MNG-2961 to ensure the base version does not contain a timestamp\n            artifact.isSnapshot();\n\n            String projectId = artifact.getGroupId() + ':' + artifact.getArtifactId() + ':' + artifact.getBaseVersion();\n\n            if ( projects.containsKey( projectId ) )\n            {\n                dependencyProjects.add( projectId );\n            }\n            else\n            {\n                dependencyArtifacts.add( artifact );\n            }\n        }\n\n        // install dependencies\n        try\n        {\n            // copy dependencies that where resolved from the local repo\n            for ( Iterator it = dependencyArtifacts.iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n\n                Artifact depArtifact =\n                    artifactFactory.createArtifactWithClassifier( artifact.getGroupId(), artifact.getArtifactId(),\n                                                                  artifact.getBaseVersion(), artifact.getType(),\n                                                                  artifact.getClassifier() );\n\n                File artifactFile = artifact.getFile();\n\n                Artifact pomArtifact =\n                    artifactFactory.createProjectArtifact( depArtifact.getGroupId(), depArtifact.getArtifactId(),\n                                                           depArtifact.getBaseVersion() );\n\n                File pomFile = new File( localRepository.getBasedir(), localRepository.pathOf( pomArtifact ) );\n\n                if ( pomFile.isFile() )\n                {\n                    if ( !pomFile.equals( artifactFile ) )\n                    {\n                        copyArtifact( pomFile, pomArtifact, testRepository );\n                    }\n                    copyParentPoms( pomFile, testRepository );\n                }\n\n                copyArtifact( artifactFile, depArtifact, testRepository );\n            }\n\n            // install dependencies that were resolved from the reactor\n            for ( Iterator it = dependencyProjects.iterator(); it.hasNext(); )\n            {\n                String projectId = (String) it.next();\n\n                MavenProject dependencyProject = (MavenProject) projects.get( projectId );\n\n                installProjectArtifacts( dependencyProject, testRepository );\n                installProjectParents( dependencyProject, testRepository );\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Failed to install project dependencies: \" + mvnProject, e );\n        }\n    }","commit_id":"18ed12ce5486ddf9ace106c8de2434eced830379","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Installs the specified artifact to the local repository. Note: This method should only be used for artifacts that\n     * originate from the current (reactor) build. Artifacts that have been grabbed from the user's local repository\n     * should be installed to the test repository via {@link #stageArtifact(File, Artifact, ArtifactRepository)}.\n     * \n     * @param file The file associated with the artifact, must not be <code>null<\/code>. This is in most cases the value\n     *            of <code>artifact.getFile()<\/code> with the exception of the main artifact from a project with\n     *            packaging \"pom\". Projects with packaging \"pom\" have no main artifact file. They have however artifact\n     *            metadata (e.g. site descriptors) which needs to be installed.\n     * @param artifact The artifact to install, must not be <code>null<\/code>.\n     * @param testRepository The local repository to install the artifact to, must not be <code>null<\/code>.\n     * @throws MojoExecutionException If the artifact could not be installed (e.g. has no associated file).\n     */\n    private void installArtifact( File file, Artifact artifact, ArtifactRepository testRepository )\n        throws MojoExecutionException\n    {\n        try\n        {\n            if ( file == null )\n            {\n                throw new IllegalStateException( \"Artifact has no associated file: \" + file );\n            }\n            if ( !file.isFile() )\n            {\n                throw new IllegalStateException( \"Artifact is not fully assembled: \" + file );\n            }\n\n            if ( installedArtifacts.add( artifact.getId() ) )\n            {\n                installer.install( file, artifact, testRepository );\n            }\n            else\n            {\n                getLog().debug( \"Not re-installing \" + artifact + \", \" + file );\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Failed to install artifact: \" + artifact, e );\n        }\n    }","id":29882,"modified_method":"/**\n     * Installs the specified artifact to the local repository. Note: This method should only be used for artifacts that\n     * originate from the current (reactor) build. Artifacts that have been grabbed from the user's local repository\n     * should be installed to the test repository via {@link #copyArtifact(File, Artifact, ArtifactRepository)}.\n     * \n     * @param file The file associated with the artifact, must not be <code>null<\/code>. This is in most cases the value\n     *            of <code>artifact.getFile()<\/code> with the exception of the main artifact from a project with\n     *            packaging \"pom\". Projects with packaging \"pom\" have no main artifact file. They have however artifact\n     *            metadata (e.g. site descriptors) which needs to be installed.\n     * @param artifact The artifact to install, must not be <code>null<\/code>.\n     * @param testRepository The local repository to install the artifact to, must not be <code>null<\/code>.\n     * @throws MojoExecutionException If the artifact could not be installed (e.g. has no associated file).\n     */\n    private void installArtifact( File file, Artifact artifact, ArtifactRepository testRepository )\n        throws MojoExecutionException\n    {\n        try\n        {\n            if ( file == null )\n            {\n                throw new IllegalStateException( \"Artifact has no associated file: \" + file );\n            }\n            if ( !file.isFile() )\n            {\n                throw new IllegalStateException( \"Artifact is not fully assembled: \" + file );\n            }\n\n            if ( installedArtifacts.add( artifact.getId() ) )\n            {\n                installer.install( file, artifact, testRepository );\n            }\n            else\n            {\n                getLog().debug( \"Not re-installing \" + artifact + \", \" + file );\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Failed to install artifact: \" + artifact, e );\n        }\n    }","commit_id":"18ed12ce5486ddf9ace106c8de2434eced830379","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Installs the specified POM and all its parent POMs to the local repository.\n     * \n     * @param groupId The group id of the POM which should be installed, must not be <code>null<\/code>.\n     * @param artifactId The artifact id of the POM which should be installed, must not be <code>null<\/code>.\n     * @param version The version of the POM which should be installed, must not be <code>null<\/code>.\n     * @param testRepository The local repository to install the POMs to, must not be <code>null<\/code>.\n     * @throws MojoExecutionException If any (existing) parent POM could not be installed.\n     */\n    private void stageParentPoms( String groupId, String artifactId, String version, ArtifactRepository testRepository )\n        throws MojoExecutionException\n    {\n        Artifact pomArtifact = artifactFactory.createProjectArtifact( groupId, artifactId, version );\n\n        if ( installedArtifacts.contains( pomArtifact.getId() ) )\n        {\n            getLog().debug( \"Not re-installing \" + pomArtifact );\n            return;\n        }\n\n        File pomFile = new File( localRepository.getBasedir(), localRepository.pathOf( pomArtifact ) );\n        if ( pomFile.isFile() )\n        {\n            stageArtifact( pomFile, pomArtifact, testRepository );\n            stageParentPoms( pomFile, testRepository );\n        }\n    }","id":29883,"modified_method":"/**\n     * Installs the specified POM and all its parent POMs to the local repository.\n     * \n     * @param groupId The group id of the POM which should be installed, must not be <code>null<\/code>.\n     * @param artifactId The artifact id of the POM which should be installed, must not be <code>null<\/code>.\n     * @param version The version of the POM which should be installed, must not be <code>null<\/code>.\n     * @param testRepository The local repository to install the POMs to, must not be <code>null<\/code>.\n     * @throws MojoExecutionException If any (existing) parent POM could not be installed.\n     */\n    private void copyParentPoms( String groupId, String artifactId, String version, ArtifactRepository testRepository )\n        throws MojoExecutionException\n    {\n        Artifact pomArtifact = artifactFactory.createProjectArtifact( groupId, artifactId, version );\n\n        if ( installedArtifacts.contains( pomArtifact.getId() ) )\n        {\n            getLog().debug( \"Not re-installing \" + pomArtifact );\n            return;\n        }\n\n        File pomFile = new File( localRepository.getBasedir(), localRepository.pathOf( pomArtifact ) );\n        if ( pomFile.isFile() )\n        {\n            copyArtifact( pomFile, pomArtifact, testRepository );\n            copyParentPoms( pomFile, testRepository );\n        }\n    }","commit_id":"18ed12ce5486ddf9ace106c8de2434eced830379","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Performs this mojo's tasks.\n     * \n     * @throws MojoExecutionException If the artifacts could not be installed.\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( skipInstallation )\n        {\n            getLog().info( \"Skipping artifact installation per configuration.\" );\n            return;\n        }\n\n        ArtifactRepository testRepository = createTestRepository();\n\n        installedArtifacts = new HashSet();\n\n        installProjectArtifacts( project, testRepository );\n        installProjectParents( project, testRepository );\n        installProjectDependencies( project, reactorProjects, testRepository );\n    }","id":29884,"modified_method":"/**\n     * Performs this mojo's tasks.\n     * \n     * @throws MojoExecutionException If the artifacts could not be installed.\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( skipInstallation )\n        {\n            getLog().info( \"Skipping artifact installation per configuration.\" );\n            return;\n        }\n\n        ArtifactRepository testRepository = createTestRepository();\n\n        installedArtifacts = new HashSet();\n        copiedArtifacts = new HashSet();\n\n        installProjectDependencies( project, reactorProjects, testRepository );\n        installProjectParents( project, testRepository );\n        installProjectArtifacts( project, testRepository );\n    }","commit_id":"18ed12ce5486ddf9ace106c8de2434eced830379","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Installs all parent POMs of the specified POM file that are available in the local repository.\n     * \n     * @param pomFile The path to the POM file whose parents should be installed, must not be <code>null<\/code>.\n     * @param testRepository The local repository to install the POMs to, must not be <code>null<\/code>.\n     * @throws MojoExecutionException If any (existing) parent POM could not be installed.\n     */\n    private void stageParentPoms( File pomFile, ArtifactRepository testRepository )\n        throws MojoExecutionException\n    {\n        Model model = PomUtils.loadPom( pomFile );\n        Parent parent = model.getParent();\n        if ( parent != null )\n        {\n            stageParentPoms( parent.getGroupId(), parent.getArtifactId(), parent.getVersion(), testRepository );\n        }\n    }","id":29885,"modified_method":"/**\n     * Installs all parent POMs of the specified POM file that are available in the local repository.\n     * \n     * @param pomFile The path to the POM file whose parents should be installed, must not be <code>null<\/code>.\n     * @param testRepository The local repository to install the POMs to, must not be <code>null<\/code>.\n     * @throws MojoExecutionException If any (existing) parent POM could not be installed.\n     */\n    private void copyParentPoms( File pomFile, ArtifactRepository testRepository )\n        throws MojoExecutionException\n    {\n        Model model = PomUtils.loadPom( pomFile );\n        Parent parent = model.getParent();\n        if ( parent != null )\n        {\n            copyParentPoms( parent.getGroupId(), parent.getArtifactId(), parent.getVersion(), testRepository );\n        }\n    }","commit_id":"18ed12ce5486ddf9ace106c8de2434eced830379","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Installs the (locally reachable) parent POMs of the specified project to the local repository. The parent POMs\n     * from the reactor must be installed or the forked IT builds will fail when using a clean repository.\n     * \n     * @param mvnProject The project whose parent POMs should be installed, must not be <code>null<\/code>.\n     * @param testRepository The local repository to install the POMs to, must not be <code>null<\/code>.\n     * @throws MojoExecutionException If any POM could not be installed.\n     */\n    private void installProjectParents( MavenProject mvnProject, ArtifactRepository testRepository )\n        throws MojoExecutionException\n    {\n        try\n        {\n            for ( MavenProject parent = mvnProject.getParent(); parent != null; parent = parent.getParent() )\n            {\n                if ( parent.getFile() == null )\n                {\n                    stageParentPoms( parent.getGroupId(), parent.getArtifactId(), parent.getVersion(), testRepository );\n                    break;\n                }\n                installProjectPom( parent, testRepository );\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Failed to install project parents: \" + mvnProject, e );\n        }\n    }","id":29886,"modified_method":"/**\n     * Installs the (locally reachable) parent POMs of the specified project to the local repository. The parent POMs\n     * from the reactor must be installed or the forked IT builds will fail when using a clean repository.\n     * \n     * @param mvnProject The project whose parent POMs should be installed, must not be <code>null<\/code>.\n     * @param testRepository The local repository to install the POMs to, must not be <code>null<\/code>.\n     * @throws MojoExecutionException If any POM could not be installed.\n     */\n    private void installProjectParents( MavenProject mvnProject, ArtifactRepository testRepository )\n        throws MojoExecutionException\n    {\n        try\n        {\n            for ( MavenProject parent = mvnProject.getParent(); parent != null; parent = parent.getParent() )\n            {\n                if ( parent.getFile() == null )\n                {\n                    copyParentPoms( parent.getGroupId(), parent.getArtifactId(), parent.getVersion(), testRepository );\n                    break;\n                }\n                installProjectPom( parent, testRepository );\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Failed to install project parents: \" + mvnProject, e );\n        }\n    }","commit_id":"18ed12ce5486ddf9ace106c8de2434eced830379","url":"https://github.com/apache/maven-plugins"},{"original_method":"public String getDistributionRepository(GradleVersion version) {\n        if (version.compareTo(GradleVersion.version(\"0.9\")) >= 0) {\n            if (version.isSnapshot()) {\n                String ver = \"1.0-milestone-4-20110623211531+0200\"; //last snapshot released to the old snapshot repo\n                if (version.compareTo(GradleVersion.version(ver)) <= 0) {\n                    return DEPRECATED_ARTIFACTORY_SNAPSHOT_REPOSITORY;\n                } else {\n                    return ARTIFACTORY_SNAPSHOT_REPOSITORY;\n                }\n            }\n            return ARTIFACTORY_RELEASE_REPOSITORY;\n        } else {\n            if (version.isSnapshot()) {\n                return CODEHAUS_SNAPSHOT_REPOSITORY;\n            }\n            return CODEHAUS_RELEASE_REPOSITORY;\n        }\n    }","id":29887,"modified_method":"public String getDistributionRepository(GradleVersion version) {\n        if (version.isSnapshot()) {\n            return S3_SNAPSHOT_REPOSITORY;\n        } else {\n            return S3_RELEASE_REPOSITORY;\n        }\n    }","commit_id":"5e3202286fa522686b9efa28b208480706b51243","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testDownloadsFromReleaseRepositoryForReleaseVersions() {\n        wrapper.setGradleVersion(\"0.9.1\");\n        assertEquals(\"http://repo.gradle.org/gradle/distributions\", wrapper.getUrlRoot());\n        assertEquals(\"http://repo.gradle.org/gradle/distributions/gradle-0.9.1-bin.zip\", wrapper.getDistributionUrl());\n    }","id":29888,"modified_method":"@Test\n    public void testDownloadsFromReleaseRepositoryForReleaseVersions() {\n        wrapper.setGradleVersion(\"0.9.1\");\n        assertEquals(\"http://downloads.gradle.org/distributions\", wrapper.getUrlRoot());\n        assertEquals(\"http://downloads.gradle.org/distributions/gradle-0.9.1-bin.zip\", wrapper.getDistributionUrl());\n    }","commit_id":"5e3202286fa522686b9efa28b208480706b51243","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testUsesExplicitlyDefinedDistributionUrl() {\n        wrapper.setGradleVersion(\"0.9\");\n        wrapper.setDistributionUrl(\"http://some-url\");\n        assertEquals(\"http://repo.gradle.org/gradle/distributions\", wrapper.getUrlRoot());\n        assertEquals(\"http://some-url\", wrapper.getDistributionUrl());\n    }","id":29889,"modified_method":"@Test\n    public void testUsesExplicitlyDefinedDistributionUrl() {\n        wrapper.setGradleVersion(\"0.9\");\n        wrapper.setDistributionUrl(\"http://some-url\");\n        assertEquals(\"http://downloads.gradle.org/distributions\", wrapper.getUrlRoot());\n        assertEquals(\"http://some-url\", wrapper.getDistributionUrl());\n    }","commit_id":"5e3202286fa522686b9efa28b208480706b51243","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testDownloadsFromReleaseRepositoryForPreviewReleaseVersions() {\n        wrapper.setGradleVersion(\"1.0-milestone-1\");\n        assertEquals(\"http://repo.gradle.org/gradle/distributions\", wrapper.getUrlRoot());\n        assertEquals(\"http://repo.gradle.org/gradle/distributions/gradle-1.0-milestone-1-bin.zip\", wrapper.getDistributionUrl());\n    }","id":29890,"modified_method":"@Test\n    public void testDownloadsFromReleaseRepositoryForPreviewReleaseVersions() {\n        wrapper.setGradleVersion(\"1.0-milestone-1\");\n        assertEquals(\"http://downloads.gradle.org/distributions\", wrapper.getUrlRoot());\n        assertEquals(\"http://downloads.gradle.org/distributions/gradle-1.0-milestone-1-bin.zip\", wrapper.getDistributionUrl());\n    }","commit_id":"5e3202286fa522686b9efa28b208480706b51243","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testDownloadsFromSnapshotRepositoryForSnapshotVersions() {\n        wrapper.setGradleVersion(\"0.9.1-20101224110000+1100\");\n        assertEquals(\"http://repo.gradle.org/gradle/distributions/gradle-snapshots\", wrapper.getUrlRoot());\n        assertEquals(\"http://repo.gradle.org/gradle/distributions/gradle-snapshots/gradle-0.9.1-20101224110000+1100-bin.zip\", wrapper.getDistributionUrl());\n    }","id":29891,"modified_method":"@Test\n    public void testDownloadsFromSnapshotRepositoryForSnapshotVersions() {\n        wrapper.setGradleVersion(\"0.9.1-20101224110000+1100\");\n        assertEquals(\"http://downloads.gradle.org/distributions-snapshots\", wrapper.getUrlRoot());\n        assertEquals(\"http://downloads.gradle.org/distributions-snapshots/gradle-0.9.1-20101224110000+1100-bin.zip\", wrapper.getDistributionUrl());\n    }","commit_id":"5e3202286fa522686b9efa28b208480706b51243","url":"https://github.com/gradle/gradle"},{"original_method":"protected String resolveVersion( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n        throws ArtifactMetadataRetrievalException\n    {\n        RepositoryMetadata metadata;\n        if ( !artifact.isSnapshot() || Artifact.LATEST_VERSION.equals( artifact.getBaseVersion() ) )\n        {\n            metadata = new ArtifactRepositoryMetadata( artifact );\n        }\n        else\n        {\n            metadata = new SnapshotArtifactRepositoryMetadata( artifact );\n        }\n\n        repositoryMetadataManager.resolve( metadata, remoteRepositories, localRepository );\n\n        Metadata repoMetadata = metadata.getMetadata();\n        String version = null;\n        if ( repoMetadata != null && repoMetadata.getVersioning() != null )\n        {\n            version = constructVersion( repoMetadata.getVersioning(), artifact.getBaseVersion() );\n        }\n\n        if ( version == null )\n        {\n            version = resolveLegacyVersion( artifact, localRepository, remoteRepositories );\n            if ( version == null )\n            {\n                version = artifact.getBaseVersion();\n            }\n        }\n\n        // TODO: also do this logging for other metadata?\n        // TODO: figure out way to avoid duplicated message\n        if ( getLogger().isDebugEnabled() )\n        {\n            if ( !version.equals( artifact.getBaseVersion() ) )\n            {\n                String message = artifact.getArtifactId() + \": resolved to version \" + version;\n                if ( artifact.getRepository() != null )\n                {\n                    message += \" from repository \" + artifact.getRepository().getId();\n                }\n                else\n                {\n                    message += \" from local repository\";\n                }\n                getLogger().debug( message );\n            }\n            else\n            {\n                // Locally installed file is newer, don't use the resolved version\n                getLogger().debug( artifact.getArtifactId() + \": using locally installed snapshot\" );\n            }\n        }\n        return version;\n    }","id":29892,"modified_method":"protected String resolveVersion( Artifact artifact, ArtifactRepository localRepository, List remoteRepositories )\n        throws ArtifactMetadataRetrievalException\n    {\n        RepositoryMetadata metadata;\n        if ( artifact.isSnapshot() )\n        {\n            metadata = new SnapshotArtifactRepositoryMetadata( artifact );\n        }\n        else\n        {\n            metadata = new ArtifactRepositoryMetadata( artifact );\n        }\n\n        repositoryMetadataManager.resolve( metadata, remoteRepositories, localRepository );\n\n        Metadata repoMetadata = metadata.getMetadata();\n        String version = null;\n        if ( repoMetadata != null && repoMetadata.getVersioning() != null )\n        {\n            version = constructVersion( repoMetadata.getVersioning(), artifact.getBaseVersion() );\n        }\n\n        if ( version == null )\n        {\n            version = resolveLegacyVersion( artifact, localRepository, remoteRepositories );\n            if ( version == null )\n            {\n                version = artifact.getBaseVersion();\n            }\n        }\n\n        // TODO: also do this logging for other metadata?\n        // TODO: figure out way to avoid duplicated message\n        if ( getLogger().isDebugEnabled() )\n        {\n            if ( !version.equals( artifact.getBaseVersion() ) )\n            {\n                String message = artifact.getArtifactId() + \": resolved to version \" + version;\n                if ( artifact.getRepository() != null )\n                {\n                    message += \" from repository \" + artifact.getRepository().getId();\n                }\n                else\n                {\n                    message += \" from local repository\";\n                }\n                getLogger().debug( message );\n            }\n            else\n            {\n                // Locally installed file is newer, don't use the resolved version\n                getLogger().debug( artifact.getArtifactId() + \": using locally installed snapshot\" );\n            }\n        }\n        return version;\n    }","commit_id":"b94672b9e44c5de231aa85e254bfc2aeb66a4810","url":"https://github.com/apache/maven"},{"original_method":"public void transformForResolve( Artifact artifact, List remoteRepositories, ArtifactRepository localRepository )\n        throws ArtifactMetadataRetrievalException\n    {\n        if ( artifact.isSnapshot() )\n        {\n            String version = resolveVersion( artifact, localRepository, remoteRepositories );\n            artifact.updateVersion( version, localRepository );\n        }\n    }","id":29893,"modified_method":"public void transformForResolve( Artifact artifact, List remoteRepositories, ArtifactRepository localRepository )\n        throws ArtifactMetadataRetrievalException\n    {\n        // Only select snapshots that are unresolved (eg 1.0-SNAPSHOT, not 1.0-20050607.123456)\n        if ( artifact.isSnapshot() && artifact.getBaseVersion().equals( artifact.getVersion() ) )\n        {\n            String version = resolveVersion( artifact, localRepository, remoteRepositories );\n            artifact.updateVersion( version, localRepository );\n        }\n    }","commit_id":"b94672b9e44c5de231aa85e254bfc2aeb66a4810","url":"https://github.com/apache/maven"},{"original_method":"private static boolean checkArtifact( Artifact artifact, Map originalVersions )\n    {\n        String versionlessArtifactKey = ArtifactUtils.versionlessKey( artifact.getGroupId(), artifact.getArtifactId() );\n\n        // We are only looking at dependencies external to the project - ignore anything found in the reactor as\n        // it's version will be updated\n        return !artifact.getVersion().equals( originalVersions.get( versionlessArtifactKey ) ) &&\n            ArtifactUtils.isSnapshot( artifact.getVersion() );\n    }","id":29894,"modified_method":"private static boolean checkArtifact( Artifact artifact, Map originalVersions )\n    {\n        String versionlessArtifactKey = ArtifactUtils.versionlessKey( artifact.getGroupId(), artifact.getArtifactId() );\n\n        // We are only looking at dependencies external to the project - ignore anything found in the reactor as\n        // it's version will be updated\n        return artifact.isSnapshot() &&\n            !artifact.getBaseVersion().equals( originalVersions.get( versionlessArtifactKey ) );\n    }","commit_id":"10b4eea19f7548d58435b4e43de1bf4748edcb46","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** The function implementation.\n   * <p>It introduces blocking call which after finish of\n   * the function performs cleanup.\n   * <\/p><p>\n   * The method should not handle exceptions which it cannot handle and should let\n   * them to propagate to upper levels.\n   * <\/p>\n   */\n  public final void exec() {\n    try {\n      execImpl();\n    } finally {\n      cleanup(); // Perform job cleanup\n    }\n  }","id":29895,"modified_method":"/**\n   * Train a Deep Learning model, assumes that all members are populated\n   */\n  public final void exec() {\n    checkJob();\n    DeepLearningModel cp = null;\n    if (checkpoint == null) cp = initModel();\n    else {\n      final DeepLearningModel previous = DKV.get(checkpoint).get();\n      if (previous == null) throw new IllegalArgumentException(\"Checkpoint not found.\");\n      Log.info(\"Resuming from checkpoint.\");\n      if (source == null || !Arrays.equals(source._key._kb, previous.model_info().get_params().source._key._kb)) {\n        throw new IllegalArgumentException(\"source must be the same as for the checkpointed model.\");\n      }\n      if (response == null || !Arrays.equals(response._key._kb, previous.model_info().get_params().response._key._kb)) {\n        throw new IllegalArgumentException(\"response must be the same as for the checkpointed model.\");\n      }\n      if (ArrayUtils.difference(ignored_cols, previous.model_info().get_params().ignored_cols).length != 0\n              || ArrayUtils.difference(previous.model_info().get_params().ignored_cols, ignored_cols).length != 0) {\n        ignored_cols = previous.model_info().get_params().ignored_cols;\n        Log.warn(\"Automatically re-using ignored_cols from the checkpointed model.\");\n      }\n      if ((validation!=null) != (previous.model_info().get_params().validation != null)\n              || (validation != null && validation._key != null && previous.model_info().get_params().validation._key != null\n              && !Arrays.equals(validation._key._kb, previous.model_info().get_params().validation._key._kb))) {\n        throw new IllegalArgumentException(\"validation must be the same as for the checkpointed model.\");\n      }\n      if (classification != previous.model_info().get_params().classification) {\n        Log.warn(\"Automatically switching to \" + ((classification=!classification) ? \"classification\" : \"regression\") + \" (same as the checkpointed model).\");\n      }\n      epochs += previous.epoch_counter; //add new epochs to existing model\n      Log.info(\"Adding \" + String.format(\"%.3f\", previous.epoch_counter) + \" epochs from the checkpointed model.\");\n      try {\n        final DataInfo dataInfo = prepareDataInfo();\n        cp = new DeepLearningModel(previous, dest(), self(), dataInfo);\n        cp.write_lock(self());\n        assert(DKV.get(cp._key) != null);\n        assert(_state==JobState.RUNNING);\n        final DeepLearning mp = cp.model_info().get_params();\n        Object A = mp, B = this;\n        for (Field fA : A.getClass().getDeclaredFields()) {\n          if (ArrayUtils.contains(cp_modifiable, fA.getName())) {\n            if (!expert_mode && ArrayUtils.contains(expert_options, fA.getName())) continue;\n            for (Field fB : B.getClass().getDeclaredFields()) {\n              if (fA.equals(fB)) {\n                try {\n                  if (fB.get(B) == null || fA.get(A) == null || !fA.get(A).toString().equals(fB.get(B).toString())) { // if either of the two parameters is null, skip the toString()\n                    if (fA.get(A) == null && fB.get(B) == null) continue; //if both parameters are null, we don't need to do anything\n                    Log.info(\"Applying user-requested modification of '\" + fA.getName() + \"': \" + fA.get(A) + \" -> \" + fB.get(B));\n                    fA.set(A, fB.get(B));\n                  }\n                } catch (IllegalAccessException e) {\n                  e.printStackTrace();\n                }\n              }\n            }\n          }\n        }\n        cp.update(self());\n      }\n      finally {\n        if (cp != null) cp.unlock(self());\n      }\n    }\n    trainModel(cp);\n    remove();\n  }","commit_id":"51f360b1e2833f78b8515bebef5fc3d7e384e19b","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Train a Deep Learning neural net model\n   * @param model Input model (e.g., from initModel(), or from a previous training run)\n   * @return Trained model\n   */\n  public final DeepLearningModel trainModel(DeepLearningModel model) {\n    Frame validScoreFrame = null;\n    Frame train, trainScoreFrame;\n    try {\n      lock_data();\n//      if (checkpoint == null && !quiet_mode) logStart(); //if checkpoint is given, some Job's params might be uninitialized (but the restarted model's parameters are correct)\n      if (model == null) {\n        model = DKV.get(dest()).get();\n      }\n      model.write_lock(self());\n      final DeepLearning mp = model.model_info().get_params(); //use the model's parameters for everything below - NOT the job's parameters (can be different after checkpoint restart)\n\n      ValidationAdapter validAdapter = new ValidationAdapter(validation, classification);\n      validAdapter.prepareValidationWithModel(model);\n\n      final long model_size = model.model_info().size();\n      if (!quiet_mode) Log.info(\"Number of model parameters (weights/biases): \" + String.format(\"%,d\", model_size));\n      train = model.model_info().data_info()._adaptedFrame;\n      if (mp.force_load_balance) train = updateFrame(train, reBalance(train, mp.replicate_training_data /*rebalance into only 4*cores per node*/));\n      float[] trainSamplingFactors;\n      if (mp.classification && mp.balance_classes) {\n        trainSamplingFactors = new float[train.lastVec().domain().length]; //leave initialized to 0 -> will be filled up below\n        train = updateFrame(train, sampleFrameStratified(\n                train, train.lastVec(), trainSamplingFactors, (long)(mp.max_after_balance_size*train.numRows()), mp.seed, true, false));\n        model.setModelClassDistribution(new MRUtils.ClassDist(train.lastVec()).doAll(train.lastVec()).rel_dist());\n      }\n      model.training_rows = train.numRows();\n      trainScoreFrame = sampleFrame(train, mp.score_training_samples, mp.seed); //training scoring dataset is always sampled uniformly from the training dataset\n      if (train != trainScoreFrame) ltrash(trainScoreFrame);\n\n      if (!quiet_mode) Log.info(\"Number of chunks of the training data: \" + train.anyVec().nChunks());\n      if (validation != null) {\n        Frame adaptedValid = validAdapter.getValidation();\n        if (validAdapter.getValidAdaptor().needsAdaptation2CM()) {\n\n          int rIndex = 0;\n          for( int i = 0; i < source.vecs().length; i++ ) {\n            if (source.vecs()[i] == response) rIndex = i;\n          }\n          final String responseName = source._names != null && rIndex >= 0 ? source._names[rIndex] : \"response\";\n          adaptedValid.add(validAdapter.getValidAdaptor().adaptedValidationResponse(responseName), validAdapter.getValidAdaptor().getAdaptedValidationResponse2CM());\n        }\n        // validation scoring dataset can be sampled in multiple ways from the given validation dataset\n        if (mp.classification && mp.balance_classes && mp.score_validation_sampling == ClassSamplingMethod.Stratified) {\n          validScoreFrame = updateFrame(adaptedValid, sampleFrameStratified(adaptedValid, adaptedValid.lastVec(), null,\n                  mp.score_validation_samples > 0 ? mp.score_validation_samples : adaptedValid.numRows(), mp.seed+1, false /* no oversampling */, false));\n        } else {\n          validScoreFrame = updateFrame(adaptedValid, sampleFrame(adaptedValid, mp.score_validation_samples, mp.seed+1));\n        }\n        if (mp.force_load_balance) validScoreFrame = updateFrame(validScoreFrame, reBalance(validScoreFrame, false /*always split up globally since scoring should be distributed*/));\n        if (!quiet_mode) Log.info(\"Number of chunks of the validation data: \" + validScoreFrame.anyVec().nChunks());\n      }\n\n      // Set train_samples_per_iteration size (cannot be done earlier since this depends on whether stratified sampling is done)\n      mp.actual_train_samples_per_iteration = computeTrainSamplesPerIteration(mp.train_samples_per_iteration, train.numRows(), mp.replicate_training_data, mp.quiet_mode);\n      // Determine whether shuffling is enforced\n      if(mp.replicate_training_data && (mp.actual_train_samples_per_iteration == train.numRows()*H2O.CLOUD.size()) && !mp.shuffle_training_data && H2O.CLOUD.size() > 1) {\n        Log.warn(\"Enabling training data shuffling, because all nodes train on the full dataset (replicated training data).\");\n        mp.shuffle_training_data = true;\n      }\n      final float rowUsageFraction = computeRowUsageFraction(train.numRows(), mp.actual_train_samples_per_iteration, mp.replicate_training_data);\n\n      if (!mp.quiet_mode) Log.info(\"Initial model:\\n\" + model.model_info());\n      Log.info(\"Starting to train the Deep Learning model.\");\n\n      //main loop\n      do model.set_model_info(H2O.CLOUD.size() > 1 && mp.replicate_training_data ? ( mp.single_node_mode ?\n              new DeepLearningTask2(train, model.model_info(), rowUsageFraction).doAll(Key.make()).model_info() : //replicated data + single node mode\n              new DeepLearningTask2(train, model.model_info(), rowUsageFraction).doAllNodes().model_info() ) : //replicated data + multi-node mode\n              new DeepLearningTask(model.model_info(), rowUsageFraction).doAll(train).model_info()); //distributed data (always in multi-node mode)\n      while (model.doScoring(train, trainScoreFrame, validScoreFrame, self(), validAdapter.getValidAdaptor()));\n\n      _state = JobState.DONE; //for JSON REST response\n      model.get_params()._state = _state; //for parameter JSON on the HTML page\n      Log.info(\"Finished training the Deep Learning model.\");\n      return model;\n    }\n    catch(JobCancelledException ex) {\n      model = DKV.get(dest()).get();\n      _state = JobState.CANCELLED; //for JSON REST response\n      model.get_params()._state = _state; //for parameter JSON on the HTML page\n      Log.info(\"Deep Learning model building was cancelled.\");\n      return model;\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      throw t;\n    }\n    finally {\n      if (model != null) model.unlock(self());\n      unlock_data();\n    }\n  }","id":29896,"modified_method":"/**\n   * Train a Deep Learning neural net model\n   * @param model Input model (e.g., from initModel(), or from a previous training run)\n   * @return Trained model\n   */\n  public final DeepLearningModel trainModel(DeepLearningModel model) {\n    Frame validScoreFrame = null;\n    Frame train, trainScoreFrame;\n    try {\n      lock_data();\n//      if (checkpoint == null && !quiet_mode) logStart(); //if checkpoint is given, some Job's params might be uninitialized (but the restarted model's parameters are correct)\n      if (model == null) {\n        model = DKV.get(dest()).get();\n      }\n      model.write_lock(self());\n      final DeepLearning mp = model.model_info().get_params(); //use the model's parameters for everything below - NOT the job's parameters (can be different after checkpoint restart)\n\n      ValidationAdapter validAdapter = new ValidationAdapter(validation, classification);\n      validAdapter.prepareValidationWithModel(model);\n\n      final long model_size = model.model_info().size();\n      if (!quiet_mode) Log.info(\"Number of model parameters (weights/biases): \" + String.format(\"%,d\", model_size));\n      train = model.model_info().data_info()._adaptedFrame;\n      if (mp.force_load_balance) train = reBalance(train, mp.replicate_training_data /*rebalance into only 4*cores per node*/);\n      float[] trainSamplingFactors;\n      if (mp.classification && mp.balance_classes) {\n        trainSamplingFactors = new float[train.lastVec().domain().length]; //leave initialized to 0 -> will be filled up below\n        train = sampleFrameStratified(\n                train, train.lastVec(), trainSamplingFactors, (long)(mp.max_after_balance_size*train.numRows()), mp.seed, true, false);\n        model.setModelClassDistribution(new MRUtils.ClassDist(train.lastVec()).doAll(train.lastVec()).rel_dist());\n      }\n      model.training_rows = train.numRows();\n      trainScoreFrame = sampleFrame(train, mp.score_training_samples, mp.seed); //training scoring dataset is always sampled uniformly from the training dataset\n\n      if (!quiet_mode) Log.info(\"Number of chunks of the training data: \" + train.anyVec().nChunks());\n      if (validation != null) {\n        Frame adaptedValid = validAdapter.getValidation();\n        if (validAdapter.getValidAdaptor().needsAdaptation2CM()) {\n\n          int rIndex = 0;\n          for( int i = 0; i < source.vecs().length; i++ ) {\n            if (source.vecs()[i] == response) rIndex = i;\n          }\n          final String responseName = source._names != null && rIndex >= 0 ? source._names[rIndex] : \"response\";\n          adaptedValid.add(validAdapter.getValidAdaptor().adaptedValidationResponse(responseName), validAdapter.getValidAdaptor().getAdaptedValidationResponse2CM());\n        }\n        // validation scoring dataset can be sampled in multiple ways from the given validation dataset\n        if (mp.classification && mp.balance_classes && mp.score_validation_sampling == ClassSamplingMethod.Stratified) {\n          validScoreFrame = sampleFrameStratified(adaptedValid, adaptedValid.lastVec(), null,\n                  mp.score_validation_samples > 0 ? mp.score_validation_samples : adaptedValid.numRows(), mp.seed+1, false /* no oversampling */, false);\n        } else {\n          validScoreFrame = sampleFrame(adaptedValid, mp.score_validation_samples, mp.seed+1);\n        }\n        if (mp.force_load_balance) validScoreFrame = reBalance(validScoreFrame, false /*always split up globally since scoring should be distributed*/);\n        if (!quiet_mode) Log.info(\"Number of chunks of the validation data: \" + validScoreFrame.anyVec().nChunks());\n      }\n\n      // Set train_samples_per_iteration size (cannot be done earlier since this depends on whether stratified sampling is done)\n      mp.actual_train_samples_per_iteration = computeTrainSamplesPerIteration(mp.train_samples_per_iteration, train.numRows(), mp.replicate_training_data, mp.quiet_mode);\n      // Determine whether shuffling is enforced\n      if(mp.replicate_training_data && (mp.actual_train_samples_per_iteration == train.numRows()*H2O.CLOUD.size()) && !mp.shuffle_training_data && H2O.CLOUD.size() > 1) {\n        Log.warn(\"Enabling training data shuffling, because all nodes train on the full dataset (replicated training data).\");\n        mp.shuffle_training_data = true;\n      }\n      final float rowUsageFraction = computeRowUsageFraction(train.numRows(), mp.actual_train_samples_per_iteration, mp.replicate_training_data);\n\n      if (!mp.quiet_mode) Log.info(\"Initial model:\\n\" + model.model_info());\n      Log.info(\"Starting to train the Deep Learning model.\");\n\n      //main loop\n      do model.set_model_info(H2O.CLOUD.size() > 1 && mp.replicate_training_data ? ( mp.single_node_mode ?\n              new DeepLearningTask2(train, model.model_info(), rowUsageFraction).doAll(Key.make()).model_info() : //replicated data + single node mode\n              new DeepLearningTask2(train, model.model_info(), rowUsageFraction).doAllNodes().model_info() ) : //replicated data + multi-node mode\n              new DeepLearningTask(model.model_info(), rowUsageFraction).doAll(train).model_info()); //distributed data (always in multi-node mode)\n      while (model.doScoring(train, trainScoreFrame, validScoreFrame, self(), validAdapter.getValidAdaptor()));\n\n      _state = JobState.DONE; //for JSON REST response\n      model.get_params()._state = _state; //for parameter JSON on the HTML page\n      Log.info(\"Finished training the Deep Learning model.\");\n      return model;\n    }\n    catch(JobCancelledException ex) {\n      model = DKV.get(dest()).get();\n      _state = JobState.CANCELLED; //for JSON REST response\n      model.get_params()._state = _state; //for parameter JSON on the HTML page\n      Log.info(\"Deep Learning model building was cancelled.\");\n      return model;\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      throw t;\n    }\n    finally {\n      if (model != null) model.unlock(self());\n      unlock_data();\n    }\n  }","commit_id":"51f360b1e2833f78b8515bebef5fc3d7e384e19b","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public DeepLearning(Key destination_key) {\n    super(destination_key, \"Deep Learning\");\n  }","id":29897,"modified_method":"public DeepLearning(Key destination_key) {\n    super(destination_key, \"Deep Learning\");\n    Scope.enter();\n  }","commit_id":"51f360b1e2833f78b8515bebef5fc3d7e384e19b","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Helper to create a DataInfo object from the source and response\n   * @return DataInfo object\n   */\n  private DataInfo prepareDataInfo() {\n    final boolean del_enum_resp = (classification && !response.isEnum());\n    final Frame train = FrameTask.DataInfo.prepareFrame(source, response, ignored_cols, classification, ignore_const_cols, true /*drop >20% NA cols*/);\n    final DataInfo dinfo = new FrameTask.DataInfo(train, 1, false, true, !classification);\n    final Vec resp = dinfo._adaptedFrame.lastVec(); //convention from DataInfo: response is the last Vec\n    assert(!classification ^ resp.isEnum()) : \"Must have enum response for classification!\"; //either regression or enum response\n    if (del_enum_resp) ltrash(resp);\n    return dinfo;\n  }","id":29898,"modified_method":"/**\n   * Helper to create a DataInfo object from the source and response\n   * @return DataInfo object\n   */\n  private DataInfo prepareDataInfo() {\n//    final boolean del_enum_resp = (classification && !response.isEnum());\n    final Frame train = FrameTask.DataInfo.prepareFrame(source, response, ignored_cols, classification, ignore_const_cols, true /*drop >20% NA cols*/);\n    final DataInfo dinfo = new FrameTask.DataInfo(train, 1, false, true, !classification);\n    final Vec resp = dinfo._adaptedFrame.lastVec(); //convention from DataInfo: response is the last Vec\n    assert(!classification ^ resp.isEnum()) : \"Must have enum response for classification!\"; //either regression or enum response\n//    if (del_enum_resp) ltrash(resp);\n    return dinfo;\n  }","commit_id":"51f360b1e2833f78b8515bebef5fc3d7e384e19b","url":"https://github.com/h2oai/h2o-3"},{"original_method":"void runFraction(float fraction) {\n    long seed0 = 0xDECAF;\n    int num_runs = 0;\n    for (int repeat = 0; repeat < 5; ++repeat) {\n      // Testing different things\n      // Note: Microsoft reference implementation is only for Tanh + MSE, rectifier and MCE are implemented by 0xdata (trivial).\n      // Note: Initial weight distributions are copied, but what is tested is the stability behavior.\n\n      DeepLearning.Activation[] activations = {DeepLearning.Activation.Tanh, DeepLearning.Activation.Rectifier};\n      DeepLearning.Loss[] losses = {DeepLearning.Loss.MeanSquare, DeepLearning.Loss.CrossEntropy};\n      DeepLearning.InitialWeightDistribution[] dists = {\n              DeepLearning.InitialWeightDistribution.Normal,\n              DeepLearning.InitialWeightDistribution.Uniform,\n              DeepLearning.InitialWeightDistribution.UniformAdaptive\n      };\n      final long seed = seed0 + repeat;\n      Random rng = new Random(seed);\n\n      double[] initial_weight_scales = {1e-4 + rng.nextDouble()};\n      double[] holdout_ratios = {0.1 + rng.nextDouble() * 0.8};\n      double[] momenta = {rng.nextDouble() * 0.99};\n      int[] hiddens = {1, 2 + rng.nextInt(50)};\n      int[] epochs = {1, 2 + rng.nextInt(50)};\n      double[] rates = {0.01, 1e-5 + rng.nextDouble() * .1};\n\n      for (DeepLearning.Activation activation : activations) {\n        for (DeepLearning.Loss loss : losses) {\n          for (DeepLearning.InitialWeightDistribution dist : dists) {\n            for (double scale : initial_weight_scales) {\n              for (double holdout_ratio : holdout_ratios) {\n                for (double momentum : momenta) {\n                  for (int hidden : hiddens) {\n                    for (int epoch : epochs) {\n                      for (double rate : rates) {\n                        for (boolean sparse : new boolean[]{true,false}) {\n                          for (boolean col_major : new boolean[]{false}) {\n                            if (col_major && !sparse) continue;\n                            num_runs++;\n                            if (fraction < rng.nextFloat()) continue;\n                            Log.info(\"\");\n                            Log.info(\"STARTING.\");\n                            Log.info(\"Running with \" + activation.name() + \" activation function and \" + loss.name() + \" loss function.\");\n                            Log.info(\"Initialization with \" + dist.name() + \" distribution and \" + scale + \" scale, holdout ratio \" + holdout_ratio);\n                            Log.info(\"Using \" + hidden + \" hidden layers and momentum: \" + momentum);\n                            Log.info(\"Using seed \" + seed);\n\n                            NFSFileVec nfs = NFSFileVec.make(find_test_file(PATH));\n                            Frame frame = water.parser.ParseDataset2.parse(Key.make(\"iris_nn2\"), nfs._key);\n\n                            Frame fr = null;\n                            DeepLearning p;\n                            Random rand;\n\n                            int trial = 0;\n                            FrameTask.DataInfo dinfo;\n                            do {\n                              Log.info(\"Trial #\" + ++trial);\n                              if (_train != null) _train.delete();\n                              if (_test != null) _test.delete();\n                              if (fr != null) fr.delete();\n\n                              rand = RandomUtils.getDeterRNG(seed);\n\n                              double[][] rows = new double[(int) frame.numRows()][frame.numCols()];\n                              String[] names = new String[frame.numCols()];\n                              for (int c = 0; c < frame.numCols(); c++) {\n                                names[c] = \"ColumnName\" + c;\n                                for (int r = 0; r < frame.numRows(); r++)\n                                  rows[r][c] = frame.vecs()[c].at(r);\n                              }\n\n                              for (int i = rows.length - 1; i >= 0; i--) {\n                                int shuffle = rand.nextInt(i + 1);\n                                double[] row = rows[shuffle];\n                                rows[shuffle] = rows[i];\n                                rows[i] = row;\n                              }\n\n                              int limit = (int) (frame.numRows() * holdout_ratio);\n                              _train = frame(names, water.util.ArrayUtils.subarray(rows, 0, limit));\n                              _test  = frame(names, water.util.ArrayUtils.subarray(rows, limit, (int) frame.numRows() - limit));\n\n                              p = new DeepLearning(Key.make());\n                              p.source = _train;\n                              p.response = _train.lastVec();\n                              p.ignored_cols = null;\n                              p.ignore_const_cols = true;\n                              fr = FrameTask.DataInfo.prepareFrame(p.source, p.response, p.ignored_cols, true, p.ignore_const_cols);\n                              dinfo = new FrameTask.DataInfo(fr, 1, false, true);\n                            }\n                            // must have all output classes in training data (since that's what the reference implementation has hardcoded)\n                            while (dinfo._adaptedFrame.lastVec().domain().length < 3);\n\n                            // use the same seed for the reference implementation\n                            DeepLearningMLPReference ref = new DeepLearningMLPReference();\n                            ref.init(activation, RandomUtils.getDeterRNG(seed), holdout_ratio, hidden);\n\n//                            p.best_model_key = null;\n                            p.best_model_key = Key.make(\"best_DLIris.hex\");\n                            p.seed = seed;\n                            p.hidden = new int[]{hidden};\n                            p.adaptive_rate = false;\n                            p.rho = 0;\n                            p.epsilon = 0;\n                            p.rate = rate / (1 - momentum); //adapt to (1-m) correction that's done inside (only for constant momentum!)\n                            p.activation = activation;\n                            p.max_w2 = Float.POSITIVE_INFINITY;\n                            p.epochs = epoch;\n                            p.input_dropout_ratio = 0;\n                            p.rate_annealing = 0; //do not change - not implemented in reference\n                            p.l1 = 0;\n                            p.loss = loss;\n                            p.l2 = 0;\n                            p.momentum_stable = momentum; //reference only supports constant momentum\n                            p.momentum_start = p.momentum_stable; //do not change - not implemented in reference\n                            p.momentum_ramp = 0; //do not change - not implemented in reference\n                            p.initial_weight_distribution = dist;\n                            p.initial_weight_scale = scale;\n                            p.classification = true;\n                            p.diagnostics = true;\n                            p.validation = null;\n                            p.quiet_mode = true;\n                            p.fast_mode = false; //to be the same as reference\n//                      p.fast_mode = true; //to be the same as old NeuralNet code\n                            p.nesterov_accelerated_gradient = false; //to be the same as reference\n//                        p.nesterov_accelerated_gradient = true; //to be the same as old NeuralNet code\n                            p.train_samples_per_iteration = 0; //sync once per period\n                            p.ignore_const_cols = false;\n                            p.shuffle_training_data = false;\n                            p.classification_stop = -1; //don't stop early -> need to compare against reference, which doesn't stop either\n                            p.force_load_balance = false; //keep just 1 chunk for reproducibility\n                            p.replicate_training_data = false;\n                            p.single_node_mode = true;\n                            p.sparse = sparse;\n                            p.col_major = col_major;\n                            DeepLearningModel mymodel = p.initModel(); //randomize weights, but don't start training yet\n\n                            Neurons[] neurons = DeepLearningTask.makeNeuronsForTraining(mymodel.model_info());\n\n                            // use the same random weights for the reference implementation\n                            Neurons l = neurons[1];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n//                          System.out.println(\"initial weight[\" + o + \"]=\" + l._w[o * l._previous._a.length + i]);\n                                ref._nn.ihWeights[i][o] = l._w.get(o, i);\n                              }\n                              ref._nn.hBiases[o] = l._b.get(o);\n//                        System.out.println(\"initial bias[\" + o + \"]=\" + l._b[o]);\n                            }\n                            l = neurons[2];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n//                          System.out.println(\"initial weight[\" + o + \"]=\" + l._w[o * l._previous._a.length + i]);\n                                ref._nn.hoWeights[i][o] = l._w.get(o, i);\n                              }\n                              ref._nn.oBiases[o] = l._b.get(o);\n//                        System.out.println(\"initial bias[\" + o + \"]=\" + l._b[o]);\n                            }\n\n                            // Train the Reference\n                            ref.train((int) p.epochs, rate, p.momentum_stable, loss);\n\n                            // Train H2O\n                            mymodel = p.trainModel(mymodel);\n\n                            /**\n                             * Tolerances (should ideally be super tight -> expect the same double/float precision math inside both algos)\n                             */\n                            final double abseps = 1e-4;\n                            final double releps = 1e-4;\n\n                            /**\n                             * Compare weights and biases in hidden layer\n                             */\n                            neurons = DeepLearningTask.makeNeuronsForTesting(mymodel.model_info()); //link the weights to the neurons, for easy access\n                            l = neurons[1];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n                                double a = ref._nn.ihWeights[i][o];\n                                double b = l._w.get(o, i);\n                                compareVal(a, b, abseps, releps);\n//                          System.out.println(\"weight[\" + o + \"]=\" + b);\n                              }\n                              double ba = ref._nn.hBiases[o];\n                              double bb = l._b.get(o);\n                              compareVal(ba, bb, abseps, releps);\n                            }\n                            Log.info(\"Weights and biases for hidden layer: PASS\");\n\n                            /**\n                             * Compare weights and biases for output layer\n                             */\n                            l = neurons[2];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n                                double a = ref._nn.hoWeights[i][o];\n                                double b = l._w.get(o, i);\n                                compareVal(a, b, abseps, releps);\n                              }\n                              double ba = ref._nn.oBiases[o];\n                              double bb = l._b.get(o);\n                              compareVal(ba, bb, abseps, releps);\n                            }\n                            Log.info(\"Weights and biases for output layer: PASS\");\n\n                            /**\n                             * Compare predictions\n                             * Note: Reference and H2O each do their internal data normalization,\n                             * so we must use their \"own\" test data, which is assumed to be created correctly.\n                             */\n                            // H2O predictions\n                            Frame fpreds = mymodel.score(_test); //[0] is label, [1]...[4] are the probabilities\n\n                            for (int i = 0; i < _test.numRows(); ++i) {\n                              // Reference predictions\n                              double[] xValues = new double[neurons[0]._a.size()];\n                              System.arraycopy(ref._testData[i], 0, xValues, 0, xValues.length);\n                              double[] ref_preds = ref._nn.ComputeOutputs(xValues);\n\n                              // find the label\n                              // do the same as H2O here (compare float values and break ties based on row number)\n                              float[] preds = new float[ref_preds.length + 1];\n                              for (int j = 0; j < ref_preds.length; ++j) preds[j + 1] = (float) ref_preds[j];\n                              preds[0] = water.util.ModelUtils.getPrediction(preds, i);\n\n                              // compare predicted label\n                              assertTrue(preds[0] == (int) fpreds.vecs()[0].at(i));\n//                          // compare predicted probabilities\n//                          for (int j=0; j<ref_preds.length; ++j) {\n//                            compareVal((float)(ref_preds[j]), fpreds.vecs()[1+j].at(i), abseps, releps);\n//                          }\n                            }\n                            fpreds.delete();\n                            Log.info(\"Predicted values: PASS\");\n\n                            /**\n                             * Compare (self-reported) scoring\n                             */\n                            final double trainErr = ref._nn.Accuracy(ref._trainData);\n                            final double testErr = ref._nn.Accuracy(ref._testData);\n                            final Frame trainPredict = mymodel.score(_train, false);\n                            final double myTrainErr = mymodel.calcError(_train, _train.lastVec(), trainPredict, trainPredict, \"Final training error:\",\n                                    true, p.max_confusion_matrix_size, new ConfusionMatrix(), null, null);\n                            final Frame testPredict = mymodel.score(_test, false);\n                            final double myTestErr = mymodel.calcError(_test, _test.lastVec(), testPredict, testPredict, \"Final testing error:\",\n                                    true, p.max_confusion_matrix_size, new ConfusionMatrix(), null, null);\n                            Log.info(\"H2O  training error : \" + myTrainErr * 100 + \"%, test error: \" + myTestErr * 100 + \"%\");\n                            Log.info(\"REF  training error : \" + trainErr * 100 + \"%, test error: \" + testErr * 100 + \"%\");\n                            compareVal(trainErr, myTrainErr, abseps, releps);\n                            compareVal(testErr, myTestErr, abseps, releps);\n                            Log.info(\"Scoring: PASS\");\n\n                            if (p.best_model_key != null) {\n                              // get the actual best error on training data\n                              float best_err = Float.MAX_VALUE;\n                              for (DeepLearningModel.Errors err : mymodel.scoring_history()) {\n                                best_err = Math.min(best_err, (float)err.train_err); //multi-class classification\n                              }\n                              Log.info(\"Actual best error : \" + best_err * 100 + \"%.\");\n\n                              // get the error reported by the stored best model\n                              DeepLearningModel bestmodel = DKV.get(p.best_model_key).get();\n                              final Frame bestPredict = bestmodel.score(_train, false);\n                              final double bestErr = bestmodel.calcError(_train, _train.lastVec(), bestPredict, bestPredict, \"Best error:\",\n                                      true, p.max_confusion_matrix_size, new ConfusionMatrix(), null, null);\n                              Log.info(\"Best_model's error : \" + bestErr * 100 + \"%.\");\n                              compareVal(bestErr, best_err, abseps, releps);\n                              bestmodel.delete();\n                              bestPredict.delete();\n                            }\n\n                            // cleanup\n                            mymodel.delete();\n                            _train.delete();\n                            _test.delete();\n                            frame.delete();\n                            fr.delete();\n                            p.remove();\n                            p.cleanup();\n                            trainPredict.delete();\n                            testPredict.delete();\n                            Log.info(\"Parameters combination \" + num_runs + \": PASS\");\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }","id":29899,"modified_method":"void runFraction(float fraction) {\n    long seed0 = 0xDECAF;\n    int num_runs = 0;\n    for (int repeat = 0; repeat < 5; ++repeat) {\n      // Testing different things\n      // Note: Microsoft reference implementation is only for Tanh + MSE, rectifier and MCE are implemented by 0xdata (trivial).\n      // Note: Initial weight distributions are copied, but what is tested is the stability behavior.\n\n      DeepLearning.Activation[] activations = {DeepLearning.Activation.Tanh, DeepLearning.Activation.Rectifier};\n      DeepLearning.Loss[] losses = {DeepLearning.Loss.MeanSquare, DeepLearning.Loss.CrossEntropy};\n      DeepLearning.InitialWeightDistribution[] dists = {\n              DeepLearning.InitialWeightDistribution.Normal,\n              DeepLearning.InitialWeightDistribution.Uniform,\n              DeepLearning.InitialWeightDistribution.UniformAdaptive\n      };\n      final long seed = seed0 + repeat;\n      Random rng = new Random(seed);\n\n      double[] initial_weight_scales = {1e-4 + rng.nextDouble()};\n      double[] holdout_ratios = {0.1 + rng.nextDouble() * 0.8};\n      double[] momenta = {rng.nextDouble() * 0.99};\n      int[] hiddens = {1, 2 + rng.nextInt(50)};\n      int[] epochs = {1, 2 + rng.nextInt(50)};\n      double[] rates = {0.01, 1e-5 + rng.nextDouble() * .1};\n\n      for (DeepLearning.Activation activation : activations) {\n        for (DeepLearning.Loss loss : losses) {\n          for (DeepLearning.InitialWeightDistribution dist : dists) {\n            for (double scale : initial_weight_scales) {\n              for (double holdout_ratio : holdout_ratios) {\n                for (double momentum : momenta) {\n                  for (int hidden : hiddens) {\n                    for (int epoch : epochs) {\n                      for (double rate : rates) {\n                        for (boolean sparse : new boolean[]{true,false}) {\n                          for (boolean col_major : new boolean[]{false}) {\n                            if (col_major && !sparse) continue;\n                            num_runs++;\n                            if (fraction < rng.nextFloat()) continue;\n                            Log.info(\"\");\n                            Log.info(\"STARTING.\");\n                            Log.info(\"Running with \" + activation.name() + \" activation function and \" + loss.name() + \" loss function.\");\n                            Log.info(\"Initialization with \" + dist.name() + \" distribution and \" + scale + \" scale, holdout ratio \" + holdout_ratio);\n                            Log.info(\"Using \" + hidden + \" hidden layers and momentum: \" + momentum);\n                            Log.info(\"Using seed \" + seed);\n\n                            NFSFileVec nfs = NFSFileVec.make(find_test_file(PATH));\n                            Frame frame = water.parser.ParseDataset2.parse(Key.make(\"iris_nn2\"), nfs._key);\n\n                            Frame fr = null;\n                            DeepLearning p;\n                            Random rand;\n\n                            int trial = 0;\n                            FrameTask.DataInfo dinfo;\n                            do {\n                              Log.info(\"Trial #\" + ++trial);\n                              if (_train != null) _train.delete();\n                              if (_test != null) _test.delete();\n                              if (fr != null) fr.delete();\n\n                              rand = RandomUtils.getDeterRNG(seed);\n\n                              double[][] rows = new double[(int) frame.numRows()][frame.numCols()];\n                              String[] names = new String[frame.numCols()];\n                              for (int c = 0; c < frame.numCols(); c++) {\n                                names[c] = \"ColumnName\" + c;\n                                for (int r = 0; r < frame.numRows(); r++)\n                                  rows[r][c] = frame.vecs()[c].at(r);\n                              }\n\n                              for (int i = rows.length - 1; i >= 0; i--) {\n                                int shuffle = rand.nextInt(i + 1);\n                                double[] row = rows[shuffle];\n                                rows[shuffle] = rows[i];\n                                rows[i] = row;\n                              }\n\n                              int limit = (int) (frame.numRows() * holdout_ratio);\n                              _train = frame(names, water.util.ArrayUtils.subarray(rows, 0, limit));\n                              _test  = frame(names, water.util.ArrayUtils.subarray(rows, limit, (int) frame.numRows() - limit));\n\n                              p = new DeepLearning(Key.make());\n                              p.source = _train;\n                              p.response = _train.lastVec();\n                              p.ignored_cols = null;\n                              p.ignore_const_cols = true;\n                              fr = FrameTask.DataInfo.prepareFrame(p.source, p.response, p.ignored_cols, true, p.ignore_const_cols);\n                              dinfo = new FrameTask.DataInfo(fr, 1, false, true);\n                            }\n                            // must have all output classes in training data (since that's what the reference implementation has hardcoded)\n                            while (dinfo._adaptedFrame.lastVec().domain().length < 3);\n\n                            // use the same seed for the reference implementation\n                            DeepLearningMLPReference ref = new DeepLearningMLPReference();\n                            ref.init(activation, RandomUtils.getDeterRNG(seed), holdout_ratio, hidden);\n\n//                            p.best_model_key = null;\n                            p.best_model_key = Key.make(\"best_DLIris.hex\");\n                            p.seed = seed;\n                            p.hidden = new int[]{hidden};\n                            p.adaptive_rate = false;\n                            p.rho = 0;\n                            p.epsilon = 0;\n                            p.rate = rate / (1 - momentum); //adapt to (1-m) correction that's done inside (only for constant momentum!)\n                            p.activation = activation;\n                            p.max_w2 = Float.POSITIVE_INFINITY;\n                            p.epochs = epoch;\n                            p.input_dropout_ratio = 0;\n                            p.rate_annealing = 0; //do not change - not implemented in reference\n                            p.l1 = 0;\n                            p.loss = loss;\n                            p.l2 = 0;\n                            p.momentum_stable = momentum; //reference only supports constant momentum\n                            p.momentum_start = p.momentum_stable; //do not change - not implemented in reference\n                            p.momentum_ramp = 0; //do not change - not implemented in reference\n                            p.initial_weight_distribution = dist;\n                            p.initial_weight_scale = scale;\n                            p.classification = true;\n                            p.diagnostics = true;\n                            p.validation = null;\n                            p.quiet_mode = true;\n                            p.fast_mode = false; //to be the same as reference\n//                      p.fast_mode = true; //to be the same as old NeuralNet code\n                            p.nesterov_accelerated_gradient = false; //to be the same as reference\n//                        p.nesterov_accelerated_gradient = true; //to be the same as old NeuralNet code\n                            p.train_samples_per_iteration = 0; //sync once per period\n                            p.ignore_const_cols = false;\n                            p.shuffle_training_data = false;\n                            p.classification_stop = -1; //don't stop early -> need to compare against reference, which doesn't stop either\n                            p.force_load_balance = false; //keep just 1 chunk for reproducibility\n                            p.replicate_training_data = false;\n                            p.single_node_mode = true;\n                            p.sparse = sparse;\n                            p.col_major = col_major;\n                            DeepLearningModel mymodel = p.initModel(); //randomize weights, but don't start training yet\n\n                            Neurons[] neurons = DeepLearningTask.makeNeuronsForTraining(mymodel.model_info());\n\n                            // use the same random weights for the reference implementation\n                            Neurons l = neurons[1];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n//                          System.out.println(\"initial weight[\" + o + \"]=\" + l._w[o * l._previous._a.length + i]);\n                                ref._nn.ihWeights[i][o] = l._w.get(o, i);\n                              }\n                              ref._nn.hBiases[o] = l._b.get(o);\n//                        System.out.println(\"initial bias[\" + o + \"]=\" + l._b[o]);\n                            }\n                            l = neurons[2];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n//                          System.out.println(\"initial weight[\" + o + \"]=\" + l._w[o * l._previous._a.length + i]);\n                                ref._nn.hoWeights[i][o] = l._w.get(o, i);\n                              }\n                              ref._nn.oBiases[o] = l._b.get(o);\n//                        System.out.println(\"initial bias[\" + o + \"]=\" + l._b[o]);\n                            }\n\n                            // Train the Reference\n                            ref.train((int) p.epochs, rate, p.momentum_stable, loss);\n\n                            // Train H2O\n                            mymodel = p.trainModel(mymodel);\n\n                            /**\n                             * Tolerances (should ideally be super tight -> expect the same double/float precision math inside both algos)\n                             */\n                            final double abseps = 1e-4;\n                            final double releps = 1e-4;\n\n                            /**\n                             * Compare weights and biases in hidden layer\n                             */\n                            neurons = DeepLearningTask.makeNeuronsForTesting(mymodel.model_info()); //link the weights to the neurons, for easy access\n                            l = neurons[1];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n                                double a = ref._nn.ihWeights[i][o];\n                                double b = l._w.get(o, i);\n                                compareVal(a, b, abseps, releps);\n//                          System.out.println(\"weight[\" + o + \"]=\" + b);\n                              }\n                              double ba = ref._nn.hBiases[o];\n                              double bb = l._b.get(o);\n                              compareVal(ba, bb, abseps, releps);\n                            }\n                            Log.info(\"Weights and biases for hidden layer: PASS\");\n\n                            /**\n                             * Compare weights and biases for output layer\n                             */\n                            l = neurons[2];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n                                double a = ref._nn.hoWeights[i][o];\n                                double b = l._w.get(o, i);\n                                compareVal(a, b, abseps, releps);\n                              }\n                              double ba = ref._nn.oBiases[o];\n                              double bb = l._b.get(o);\n                              compareVal(ba, bb, abseps, releps);\n                            }\n                            Log.info(\"Weights and biases for output layer: PASS\");\n\n                            /**\n                             * Compare predictions\n                             * Note: Reference and H2O each do their internal data normalization,\n                             * so we must use their \"own\" test data, which is assumed to be created correctly.\n                             */\n                            // H2O predictions\n                            Frame fpreds = mymodel.score(_test); //[0] is label, [1]...[4] are the probabilities\n\n                            for (int i = 0; i < _test.numRows(); ++i) {\n                              // Reference predictions\n                              double[] xValues = new double[neurons[0]._a.size()];\n                              System.arraycopy(ref._testData[i], 0, xValues, 0, xValues.length);\n                              double[] ref_preds = ref._nn.ComputeOutputs(xValues);\n\n                              // find the label\n                              // do the same as H2O here (compare float values and break ties based on row number)\n                              float[] preds = new float[ref_preds.length + 1];\n                              for (int j = 0; j < ref_preds.length; ++j) preds[j + 1] = (float) ref_preds[j];\n                              preds[0] = water.util.ModelUtils.getPrediction(preds, i);\n\n                              // compare predicted label\n                              assertTrue(preds[0] == (int) fpreds.vecs()[0].at(i));\n//                          // compare predicted probabilities\n//                          for (int j=0; j<ref_preds.length; ++j) {\n//                            compareVal((float)(ref_preds[j]), fpreds.vecs()[1+j].at(i), abseps, releps);\n//                          }\n                            }\n                            fpreds.delete();\n                            Log.info(\"Predicted values: PASS\");\n\n                            /**\n                             * Compare (self-reported) scoring\n                             */\n                            final double trainErr = ref._nn.Accuracy(ref._trainData);\n                            final double testErr = ref._nn.Accuracy(ref._testData);\n                            final Frame trainPredict = mymodel.score(_train, false);\n                            final double myTrainErr = mymodel.calcError(_train, _train.lastVec(), trainPredict, trainPredict, \"Final training error:\",\n                                    true, p.max_confusion_matrix_size, new ConfusionMatrix(), null, null);\n                            final Frame testPredict = mymodel.score(_test, false);\n                            final double myTestErr = mymodel.calcError(_test, _test.lastVec(), testPredict, testPredict, \"Final testing error:\",\n                                    true, p.max_confusion_matrix_size, new ConfusionMatrix(), null, null);\n                            Log.info(\"H2O  training error : \" + myTrainErr * 100 + \"%, test error: \" + myTestErr * 100 + \"%\");\n                            Log.info(\"REF  training error : \" + trainErr * 100 + \"%, test error: \" + testErr * 100 + \"%\");\n                            compareVal(trainErr, myTrainErr, abseps, releps);\n                            compareVal(testErr, myTestErr, abseps, releps);\n                            Log.info(\"Scoring: PASS\");\n\n                            if (p.best_model_key != null) {\n                              // get the actual best error on training data\n                              float best_err = Float.MAX_VALUE;\n                              for (DeepLearningModel.Errors err : mymodel.scoring_history()) {\n                                best_err = Math.min(best_err, (float)err.train_err); //multi-class classification\n                              }\n                              Log.info(\"Actual best error : \" + best_err * 100 + \"%.\");\n\n                              // get the error reported by the stored best model\n                              DeepLearningModel bestmodel = DKV.get(p.best_model_key).get();\n                              final Frame bestPredict = bestmodel.score(_train, false);\n                              final double bestErr = bestmodel.calcError(_train, _train.lastVec(), bestPredict, bestPredict, \"Best error:\",\n                                      true, p.max_confusion_matrix_size, new ConfusionMatrix(), null, null);\n                              Log.info(\"Best_model's error : \" + bestErr * 100 + \"%.\");\n                              compareVal(bestErr, best_err, abseps, releps);\n                              bestmodel.delete();\n                              bestPredict.delete();\n                            }\n\n                            // cleanup\n                            mymodel.delete();\n                            _train.delete();\n                            _test.delete();\n                            frame.delete();\n                            fr.delete();\n                            p.remove();\n                            trainPredict.delete();\n                            testPredict.delete();\n                            Log.info(\"Parameters combination \" + num_runs + \": PASS\");\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"51f360b1e2833f78b8515bebef5fc3d7e384e19b","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Train a Deep Learning neural net model\n   * @param model Input model (e.g., from initModel(), or from a previous training run)\n   * @return Trained model\n   */\n  public final DeepLearningModel trainModel(DeepLearningModel model) {\n    Frame valid, validScoreFrame = null;\n    Frame train, trainScoreFrame;\n    try {\n      lock_data();\n      logStart();\n      if (model == null) {\n        model = UKV.get(dest());\n      }\n      model.write_lock(self());\n      prepareValidationWithModel(model);\n      final long model_size = model.model_info().size();\n      Log.info(\"Number of model parameters (weights/biases): \" + String.format(\"%,d\", model_size));\n//      Log.info(\"Memory usage of the model: \" + String.format(\"%.2f\", (double)model_size*Float.SIZE / (1<<23)) + \" MB.\");\n      train = model.model_info().data_info()._adaptedFrame;\n      train = updateFrame(train, reBalance(train, seed));\n      float[] trainSamplingFactors;\n      if (classification && balance_classes) {\n        trainSamplingFactors = new float[train.lastVec().domain().length]; //leave initialized to 0 -> will be filled up below\n        train = updateFrame(train, sampleFrameStratified(\n                train, train.lastVec(), trainSamplingFactors, (long)(max_after_balance_size*train.numRows()), seed, true, false));\n        model.setModelClassDistribution(new MRUtils.ClassDist(train.lastVec()).doAll(train.lastVec()).rel_dist());\n      }\n      model.training_rows = train.numRows();\n      trainScoreFrame = sampleFrame(train, score_training_samples, seed); //training scoring dataset is always sampled uniformly from the training dataset\n      if (train != trainScoreFrame) ltrash(trainScoreFrame);\n\n      Log.info(\"Number of chunks of the training data: \" + train.anyVec().nChunks());\n      if (validation != null) {\n        Frame adaptedValid = getValidation();\n        if (getValidAdaptor().needsAdaptation2CM()) {\n          adaptedValid.add(getValidAdaptor().adaptedValidationResponse(_responseName), getValidAdaptor().getAdaptedValidationResponse2CM());\n        }\n        valid = updateFrame(adaptedValid, reBalance(adaptedValid, seed+1)); //rebalance for load balancing, shuffle for \"fairness\"\n        // validation scoring dataset can be sampled in multiple ways from the given validation dataset\n        if (classification && balance_classes && score_validation_sampling == ClassSamplingMethod.Stratified) {\n          validScoreFrame = sampleFrameStratified(valid, valid.lastVec(), null,\n                  score_validation_samples > 0 ? score_validation_samples : valid.numRows(), seed+1, false /* no oversampling */, false);\n        } else {\n          validScoreFrame = sampleFrame(valid, score_validation_samples, seed+1);\n        }\n        if (valid != validScoreFrame) ltrash(validScoreFrame);\n        Log.info(\"Number of chunks of the validation data: \" + valid.anyVec().nChunks());\n      }\n      if (mini_batch > train.numRows()) {\n        Log.warn(\"Setting mini_batch (\" + mini_batch\n                + \") to the number of rows of the training data (\" + (mini_batch=train.numRows()) + \").\");\n      }\n      // determines the number of rows processed during DeepLearningTask, affects synchronization (happens at the end of each DeepLearningTask)\n      final float sync_fraction = mini_batch == 0l ? 1.0f : (float)mini_batch / train.numRows();\n\n      if (!quiet_mode) Log.info(\"Initial model:\\n\" + model.model_info());\n\n      Log.info(\"Starting to train the Deep Learning model.\");\n\n      //main loop\n      do model.set_model_info(new DeepLearningTask(model.model_info(), sync_fraction).doAll(train).model_info());\n      while (model.doScoring(train, trainScoreFrame, validScoreFrame, self(), getValidAdaptor()));\n\n      Log.info(\"Finished training the Deep Learning model.\");\n      return model;\n    }\n    catch(JobCancelledException ex) {\n      Log.info(\"Deep Learning model building was cancelled.\");\n      model = UKV.get(dest());\n      return model;\n    }\n    catch(Exception ex) {\n      ex.printStackTrace();\n      throw new RuntimeException(ex);\n    }\n    finally {\n      if (model != null) model.unlock(self());\n      unlock_data();\n      emptyLTrash();\n    }\n  }","id":29900,"modified_method":"/**\n   * Train a Deep Learning neural net model\n   * @param model Input model (e.g., from initModel(), or from a previous training run)\n   * @return Trained model\n   */\n  public final DeepLearningModel trainModel(DeepLearningModel model) {\n    Frame validScoreFrame = null;\n    Frame train, trainScoreFrame;\n    try {\n      lock_data();\n      logStart();\n      if (model == null) {\n        model = UKV.get(dest());\n      }\n      model.write_lock(self());\n      prepareValidationWithModel(model);\n      final long model_size = model.model_info().size();\n      Log.info(\"Number of model parameters (weights/biases): \" + String.format(\"%,d\", model_size));\n//      Log.info(\"Memory usage of the model: \" + String.format(\"%.2f\", (double)model_size*Float.SIZE / (1<<23)) + \" MB.\");\n      train = model.model_info().data_info()._adaptedFrame;\n      train = updateFrame(train, reBalance(train, seed));\n      float[] trainSamplingFactors;\n      if (classification && balance_classes) {\n        trainSamplingFactors = new float[train.lastVec().domain().length]; //leave initialized to 0 -> will be filled up below\n        train = updateFrame(train, sampleFrameStratified(\n                train, train.lastVec(), trainSamplingFactors, (long)(max_after_balance_size*train.numRows()), seed, true, false));\n        model.setModelClassDistribution(new MRUtils.ClassDist(train.lastVec()).doAll(train.lastVec()).rel_dist());\n      }\n      model.training_rows = train.numRows();\n      trainScoreFrame = sampleFrame(train, score_training_samples, seed); //training scoring dataset is always sampled uniformly from the training dataset\n      if (train != trainScoreFrame) ltrash(trainScoreFrame);\n\n      Log.info(\"Number of chunks of the training data: \" + train.anyVec().nChunks());\n      if (validation != null) {\n        Frame adaptedValid = getValidation();\n        if (getValidAdaptor().needsAdaptation2CM()) {\n          adaptedValid.add(getValidAdaptor().adaptedValidationResponse(_responseName), getValidAdaptor().getAdaptedValidationResponse2CM());\n        }\n        validScoreFrame = updateFrame(adaptedValid, reBalance(adaptedValid, seed+1)); //rebalance for load balancing, shuffle for \"fairness\"\n        // validation scoring dataset can be sampled in multiple ways from the given validation dataset\n        if (classification && balance_classes && score_validation_sampling == ClassSamplingMethod.Stratified) {\n          validScoreFrame = updateFrame(validScoreFrame, sampleFrameStratified(validScoreFrame, validScoreFrame.lastVec(), null,\n                  score_validation_samples > 0 ? score_validation_samples : validScoreFrame.numRows(), seed+1, false /* no oversampling */, false));\n        } else {\n          validScoreFrame = updateFrame(validScoreFrame, sampleFrame(validScoreFrame, score_validation_samples, seed+1));\n        }\n        Log.info(\"Number of chunks of the validation data: \" + validScoreFrame.anyVec().nChunks());\n      }\n      if (mini_batch > train.numRows()) {\n        Log.warn(\"Setting mini_batch (\" + mini_batch\n                + \") to the number of rows of the training data (\" + (mini_batch=train.numRows()) + \").\");\n      }\n      // determines the number of rows processed during DeepLearningTask, affects synchronization (happens at the end of each DeepLearningTask)\n      final float sync_fraction = mini_batch == 0l ? 1.0f : (float)mini_batch / train.numRows();\n\n      if (!quiet_mode) Log.info(\"Initial model:\\n\" + model.model_info());\n\n      Log.info(\"Starting to train the Deep Learning model.\");\n\n      //main loop\n      do model.set_model_info(new DeepLearningTask(model.model_info(), sync_fraction).doAll(train).model_info());\n      while (model.doScoring(train, trainScoreFrame, validScoreFrame, self(), getValidAdaptor()));\n\n      Log.info(\"Finished training the Deep Learning model.\");\n      return model;\n    }\n    catch(JobCancelledException ex) {\n      Log.info(\"Deep Learning model building was cancelled.\");\n      model = UKV.get(dest());\n      return model;\n    }\n    catch(Exception ex) {\n      ex.printStackTrace();\n      throw new RuntimeException(ex);\n    }\n    finally {\n      if (model != null) model.unlock(self());\n      unlock_data();\n      emptyLTrash();\n    }\n  }","commit_id":"268869d31ba6e23535b2689d0af9a4448a8c6b5a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void writeHeaders(StompHeaderAccessor headers, Message<byte[]> message, DataOutputStream output)\n\t\t\tthrows IOException {\n\n\t\tMap<String,List<String>> stompHeaders = headers.toStompHeaderMap();\n\t\tif (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {\n\t\t\tlogger.trace(\"Encoded heartbeat\");\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Encoded STOMP command=\" + headers.getCommand() + \" headers=\" + stompHeaders);\n\t\t}\n\t\tboolean escapeHeaders = shouldEscapeHeaders(headers);\n\t\tfor (Entry<String, List<String>> entry : stompHeaders.entrySet()) {\n\t\t\tbyte[] key = toUtf8Bytes(entry.getKey(), escapeHeaders);\n\t\t\tfor (String value : entry.getValue()) {\n\t\t\t\toutput.write(key);\n\t\t\t\toutput.write(COLON);\n\t\t\t\toutput.write(toUtf8Bytes(value, escapeHeaders));\n\t\t\t\toutput.write(LF);\n\t\t\t}\n\t\t}\n\t\tif ((headers.getCommand() == StompCommand.SEND) || (headers.getCommand() == StompCommand.MESSAGE) ||\n\t\t\t\t(headers.getCommand() == StompCommand.ERROR)) {\n\n\t\t\tint contentLength = message.getPayload().length;\n\t\t\toutput.write(\"content-length:\".getBytes(UTF8_CHARSET));\n\t\t\toutput.write(Integer.toString(contentLength).getBytes(UTF8_CHARSET));\n\t\t\toutput.write(LF);\n\t\t}\n\t}","id":29901,"modified_method":"private void writeHeaders(StompHeaderAccessor headers, Message<byte[]> message, DataOutputStream output)\n\t\t\tthrows IOException {\n\n\t\tStompCommand command = headers.getCommand();\n\t\tMap<String,List<String>> stompHeaders = headers.toStompHeaderMap();\n\t\tboolean shouldEscape = (command != StompCommand.CONNECT && command != StompCommand.CONNECTED);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Encoded STOMP \" + command + \", headers=\" + stompHeaders);\n\t\t}\n\n\t\tfor (Entry<String, List<String>> entry : stompHeaders.entrySet()) {\n\t\t\tbyte[] key = encodeHeaderString(entry.getKey(), shouldEscape);\n\t\t\tfor (String value : entry.getValue()) {\n\t\t\t\toutput.write(key);\n\t\t\t\toutput.write(COLON);\n\t\t\t\toutput.write(encodeHeaderString(value, shouldEscape));\n\t\t\t\toutput.write(LF);\n\t\t\t}\n\t\t}\n\t\tif (command.requiresContentLength()) {\n\t\t\tint contentLength = message.getPayload().length;\n\t\t\toutput.write(\"content-length:\".getBytes(UTF8_CHARSET));\n\t\t\toutput.write(Integer.toString(contentLength).getBytes(UTF8_CHARSET));\n\t\t\toutput.write(LF);\n\t\t}\n\t}","commit_id":"75439c7836f745354425dfe167fe6997a21bda7b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Encodes the given STOMP {@code message} into a {@code byte[]}\n\t * @param message the message to encode\n\t * @return the encoded message\n\t */\n\tpublic byte[] encode(Message<byte[]> message) {\n\t\ttry {\n\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(256);\n\t\t\tDataOutputStream output = new DataOutputStream(baos);\n\n\t\t\tStompHeaderAccessor headers = StompHeaderAccessor.wrap(message);\n\t\t\tif (isHeartbeat(headers)) {\n\t\t\t\toutput.write(message.getPayload());\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriteCommand(headers, output);\n\t\t\t\twriteHeaders(headers, message, output);\n\t\t\t\toutput.write(LF);\n\t\t\t\twriteBody(message, output);\n\t\t\t\toutput.write((byte)0);\n\t\t\t}\n\n\t\t\treturn baos.toByteArray();\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new StompConversionException(\"Failed to encode STOMP frame\",  e);\n\t\t}\n\t}","id":29902,"modified_method":"/**\n\t * Encodes the given STOMP {@code message} into a {@code byte[]}\n\t * @param message the message to encode\n\t * @return the encoded message\n\t */\n\tpublic byte[] encode(Message<byte[]> message) {\n\t\ttry {\n\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(128 + message.getPayload().length);\n\t\t\tDataOutputStream output = new DataOutputStream(baos);\n\n\t\t\tStompHeaderAccessor headers = StompHeaderAccessor.wrap(message);\n\t\t\tif (SimpMessageType.HEARTBEAT == headers.getMessageType()) {\n\t\t\t\tlogger.trace(\"Encoded heartbeat\");\n\t\t\t\toutput.write(message.getPayload());\n\t\t\t}\n\t\t\telse {\n\t\t\t\toutput.write(headers.getCommand().toString().getBytes(UTF8_CHARSET));\n\t\t\t\toutput.write(LF);\n\t\t\t\twriteHeaders(headers, message, output);\n\t\t\t\toutput.write(LF);\n\t\t\t\twriteBody(message, output);\n\t\t\t\toutput.write((byte) 0);\n\t\t\t}\n\n\t\t\treturn baos.toByteArray();\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new StompConversionException(\"Failed to encode STOMP frame\",  e);\n\t\t}\n\t}","commit_id":"75439c7836f745354425dfe167fe6997a21bda7b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private static void handleJetBrainsProtocolCommand() {\n    String command = JetBrainsProtocolHandler.getCommand();\n    if (command != null) {\n      try {\n        if (command.equals(\"checkout\")) {\n          String vcs = JetBrainsProtocolHandler.getMainParameter();\n          if (vcs != null) {\n            AnAction group = ActionManager.getInstance().getAction(\"NewProjectFromVCS\");\n            if (group instanceof ActionGroup) {\n              AnActionEvent e =\n                new AnActionEvent(null, DataManager.getInstance().getDataContext(), ActionPlaces.WELCOME_SCREEN, new Presentation(),\n                                  ActionManager.getInstance(), 0);\n              for (AnAction action : ((ActionGroup)group).getChildren(e)) {\n                if (vcs.equalsIgnoreCase(action.getTemplatePresentation().getText())) {\n                  action.actionPerformed(e);\n                  break;\n                }\n              }\n            }\n          }\n        } else if (command.equals(\"open\")) {\n          String path = URLDecoder.decode(JetBrainsProtocolHandler.getMainParameter());\n          if (path.startsWith(LocalFileSystem.PROTOCOL_PREFIX)) {\n            path = path.substring(LocalFileSystem.PROTOCOL_PREFIX.length());\n          }\n          ProjectUtil.openProject(path, null, true);\n        }\n      }\n      finally {\n        JetBrainsProtocolHandler.clear();\n      }\n    }\n  }","id":29903,"modified_method":"private static void handleJetBrainsProtocolCommand() {\n    JBProtocolCommand command = JBProtocolCommand.findCommand(JetBrainsProtocolHandler.getCommand());\n    if (command != null) {\n      try {\n        command.perform(JetBrainsProtocolHandler.getMainParameter(), JetBrainsProtocolHandler.getParameters());\n      }\n      finally {\n        JetBrainsProtocolHandler.clear();\n      }\n    }\n  }","commit_id":"e52320bca617c7b988a4a663f283b54acaddaef1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void clear() {\n    System.setProperty(COMMAND, \"\");\n  }","id":29904,"modified_method":"public static void clear() {\n    ourCommand = null;\n  }","commit_id":"e52320bca617c7b988a4a663f283b54acaddaef1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static String getCommand() {\n    return System.getProperty(COMMAND);\n  }","id":29905,"modified_method":"@Nullable\n  public static String getCommand() {\n    init();\n    return ourCommand;\n  }","commit_id":"e52320bca617c7b988a4a663f283b54acaddaef1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getMainParameter() {\n    return System.getProperty(MAIN_PARAMETER);\n  }","id":29906,"modified_method":"public static String getMainParameter() {\n    init();\n    return ourMainParameter;\n  }","commit_id":"e52320bca617c7b988a4a663f283b54acaddaef1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void processJetBrainsLauncherParameters(String url) {\n    url = url.substring(PROTOCOL.length());\n    String platformPrefix = url.substring(0, url.indexOf('/'));\n    url = url.substring(platformPrefix.length() + 1);\n    String command = url.substring(0, url.indexOf('/'));\n    url = url.substring(command.length() + 1);\n    List<String> strings = StringUtil.split(url, \"?\");\n    String arg = strings.get(0);\n    System.setProperty(MAIN_PARAMETER, arg);\n    System.setProperty(COMMAND, command);\n\n    if (strings.size() > 1) {\n      List<String> keyValues = StringUtil.split(StringUtil.join(ContainerUtil.subList(strings, 1), \"?\"), \"&\");\n      for (String keyValue : keyValues) {\n        if (keyValue.contains(\"=\")) {\n          int ind = keyValue.indexOf('=');\n          System.setProperty(keyValue.substring(0, ind), keyValue.substring(ind + 1));\n        } else {\n          System.setProperty(keyValue, \"\");\n        }\n      }\n    }\n  }","id":29907,"modified_method":"public static void processJetBrainsLauncherParameters(String url) {\n    System.setProperty(JetBrainsProtocolHandler.class.getName(), url);\n    url = url.substring(PROTOCOL.length());\n    String platformPrefix = url.substring(0, url.indexOf('/'));\n    url = url.substring(platformPrefix.length() + 1);\n    String command = url.substring(0, url.indexOf('/'));\n    url = url.substring(command.length() + 1);\n    List<String> strings = StringUtil.split(url, \"?\");\n    ourMainParameter = strings.get(0);\n    ourCommand = command;\n\n    if (strings.size() > 1) {\n      List<String> keyValues = StringUtil.split(StringUtil.join(ContainerUtil.subList(strings, 1), \"?\"), \"&\");\n      for (String keyValue : keyValues) {\n        if (keyValue.contains(\"=\")) {\n          int ind = keyValue.indexOf('=');\n          String key = keyValue.substring(0, ind);\n          String value = keyValue.substring(ind + 1);\n          if (REQUIRED_PLUGINS_KEY.equals(key)) {\n            System.setProperty(key, value);\n          } else {\n            ourParameters.put(key, value);\n          }\n        } else {\n          ourParameters.put(keyValue, \"\");\n        }\n      }\n    }\n\n    initialized = true;\n  }","commit_id":"e52320bca617c7b988a4a663f283b54acaddaef1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void threadSuspended(final PyThreadInfo threadInfo) {\n    if (mySuspendedThread != null) {\n      // todo: XDebugSession supports only one suspend context \n      final ResumeCommand command = new ResumeCommand(myDebugger, threadInfo.getId(), ResumeCommand.Mode.RESUME);\n      myDebugger.execute(command);\n      return;\n    }\n    mySuspendedThread = threadInfo;\n\n    final List<PyStackFrameInfo> frames = threadInfo.getFrames();\n    if (frames != null) {\n      final PySuspendContext suspendContext = new PySuspendContext(this, threadInfo);\n\n      XLineBreakpoint breakpoint = null;\n      if (threadInfo.isStopOnBreakpoint()) {\n        final PySourcePosition position = frames.get(0).getPosition();\n        breakpoint = myRegisteredBreakpoints.get(position);\n        if (breakpoint == null) {\n          final RemoveBreakpointCommand command = new RemoveBreakpointCommand(myDebugger, position.getFile(), position.getLine());\n          myDebugger.execute(command);  // remove temp. breakpoint\n        }\n      }\n\n      if (breakpoint != null) {\n        if (!getSession().breakpointReached(breakpoint, suspendContext)) {\n          resume();\n        }\n      }\n      else {\n        getSession().positionReached(suspendContext);\n      }\n    }\n  }","id":29908,"modified_method":"@Override\n  public void threadSuspended(final PyThreadInfo threadInfo) {\n    if (!mySuspendedThreads.contains(threadInfo)) {\n      mySuspendedThreads.add(threadInfo);\n\n      final List<PyStackFrameInfo> frames = threadInfo.getFrames();\n      if (frames != null) {\n        final PySuspendContext suspendContext = new PySuspendContext(this, threadInfo);\n\n        XLineBreakpoint breakpoint = null;\n        if (threadInfo.isStopOnBreakpoint()) {\n          final PySourcePosition position = frames.get(0).getPosition();\n          breakpoint = myRegisteredBreakpoints.get(position);\n          if (breakpoint == null) {\n            final RemoveBreakpointCommand command = new RemoveBreakpointCommand(myDebugger, position.getFile(), position.getLine());\n            myDebugger.execute(command);  // remove temp. breakpoint\n          }\n        }\n\n        if (breakpoint != null) {\n          if (!getSession().breakpointReached(breakpoint, suspendContext)) {\n            resume();\n          }\n        }\n        else {\n          getSession().positionReached(suspendContext);\n        }\n      }\n    }\n  }","commit_id":"ce8d980d3b7784e39a2fe08aafc69596f79dc12d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void runToPosition(@NotNull final XSourcePosition position) {\n    if (myDebugger.isConnected() && mySuspendedThread != null) {\n      final PySourcePosition pyPosition = myPositionConverter.convert(position);\n      final SetBreakpointCommand command = new SetBreakpointCommand(myDebugger, pyPosition.getFile(), pyPosition.getLine());\n      myDebugger.execute(command);  // set temp. breakpoint\n      resume(ResumeCommand.Mode.RESUME);\n    }\n  }","id":29909,"modified_method":"@Override\n  public void runToPosition(@NotNull final XSourcePosition position) {\n    if (myDebugger.isConnected() && !mySuspendedThreads.isEmpty()) {\n      final PySourcePosition pyPosition = myPositionConverter.convert(position);\n      final SetBreakpointCommand command = new SetBreakpointCommand(myDebugger, pyPosition.getFile(), pyPosition.getLine());\n      myDebugger.execute(command);  // set temp. breakpoint\n      resume(ResumeCommand.Mode.RESUME);\n    }\n  }","commit_id":"ce8d980d3b7784e39a2fe08aafc69596f79dc12d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void resume(final ResumeCommand.Mode mode) {\n    if (myDebugger.isConnected() && mySuspendedThread != null) {\n      final ResumeCommand command = new ResumeCommand(myDebugger, mySuspendedThread.getId(), mode);\n      mySuspendedThread = null;\n      myDebugger.execute(command);\n    }\n  }","id":29910,"modified_method":"private void resume(final ResumeCommand.Mode mode) {\n    if (myDebugger.isConnected()) {\n      for (PyThreadInfo suspendedThread : mySuspendedThreads) {\n        final ResumeCommand command = new ResumeCommand(myDebugger, suspendedThread.getId(), mode);\n        myDebugger.execute(command);\n      }\n    }\n  }","commit_id":"ce8d980d3b7784e39a2fe08aafc69596f79dc12d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private CommandLinePatcher createDebugServerPatcher(final PythonCommandLineState pyState, final int serverLocalPort) {\n    return new CommandLinePatcher() {\n      public void patchCommandLine(GeneralCommandLine commandLine) {\n\n        final String[] debugger_args = new String[]{\n          PythonHelpersLocator.getHelperPath(\"pydev/pydevd.py\"),\n          \"--client\", \"127.0.0.1\",\n          \"--port\", String.valueOf(serverLocalPort),\n          \"--file\"\n        };\n        // script name is the last parameter; all other params are for python interpreter; insert just before name\n        final ParametersList parameters_list = commandLine.getParametersList();\n\n        ParamsGroup debug_params = parameters_list.getParamsGroup(PythonCommandLineState.GROUP_DEBUGGER);\n        assert debug_params != null;\n        ParamsGroup exe_params = parameters_list.getParamsGroup(PythonCommandLineState.GROUP_EXE_OPTIONS);\n        assert exe_params != null;\n\n        final PythonSdkFlavor flavor = pyState.getConfig().getSdkFlavor();\n        if (flavor != null) {\n          for (String option : flavor.getExtraDebugOptions()) exe_params.addParameter(option);\n        }\n        for (String s : debugger_args) debug_params.addParameter(s);\n      }\n    };\n  }","id":29911,"modified_method":"private CommandLinePatcher createDebugServerPatcher(final PythonCommandLineState pyState, final int serverLocalPort) {\n    return new CommandLinePatcher() {\n      public void patchCommandLine(GeneralCommandLine commandLine) {\n\n        final String[] debugger_args = new String[]{\n          PythonHelpersLocator.getHelperPath(\"pydev/pydevd.py\"),\n          \"--client\", \"127.0.0.1\",\n          \"--port\", String.valueOf(serverLocalPort),\n          \"--DEBUG_RECORD_SOCKET_READS\",\n          \"--file\"\n        };\n        // script name is the last parameter; all other params are for python interpreter; insert just before name\n        final ParametersList parameters_list = commandLine.getParametersList();\n\n        ParamsGroup debug_params = parameters_list.getParamsGroup(PythonCommandLineState.GROUP_DEBUGGER);\n        assert debug_params != null;\n        ParamsGroup exe_params = parameters_list.getParamsGroup(PythonCommandLineState.GROUP_EXE_OPTIONS);\n        assert exe_params != null;\n\n        final PythonSdkFlavor flavor = pyState.getConfig().getSdkFlavor();\n        if (flavor != null) {\n          for (String option : flavor.getExtraDebugOptions()) exe_params.addParameter(option);\n        }\n        for (String s : debugger_args) debug_params.addParameter(s);\n      }\n    };\n  }","commit_id":"ce8d980d3b7784e39a2fe08aafc69596f79dc12d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public XExecutionStack[] getExecutionStacks() {\n    return super.getExecutionStacks();\n    /*\n    final Collection<PyThreadInfo> threads = myDebugProcess.getThreads();\n    if (threads.size() < 1) {\n      return XExecutionStack.EMPTY_ARRAY;\n    }\n    else {\n      XExecutionStack[] stacks = new XExecutionStack[threads.size()];\n      int i = 0;\n      for (PyThreadInfo thread : threads) {\n        stacks[i++] = new PyExecutionStack(myDebugProcess, thread);\n      }\n      return stacks;\n    }\n    */\n  }","id":29912,"modified_method":"@Override\n  public XExecutionStack[] getExecutionStacks() {\n    final Collection<PyThreadInfo> threads = myDebugProcess.getThreads();\n    if (threads.size() < 1) {\n      return XExecutionStack.EMPTY_ARRAY;\n    }\n    else {\n      XExecutionStack[] stacks = new XExecutionStack[threads.size()];\n      int i = 0;\n      for (PyThreadInfo thread : threads) {\n        stacks[i++] = new PyExecutionStack(myDebugProcess, thread);\n      }\n      return stacks;\n    }\n  }","commit_id":"ce8d980d3b7784e39a2fe08aafc69596f79dc12d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PySuspendContext(@NotNull final PyDebugProcess debugProcess, @NotNull final PyThreadInfo threadInfo) {\n    myActiveStack = new PyExecutionStack(debugProcess, threadInfo);\n  }","id":29913,"modified_method":"public PySuspendContext(@NotNull final PyDebugProcess debugProcess, @NotNull final PyThreadInfo threadInfo) {\n    myDebugProcess = debugProcess;\n    myActiveStack = new PyExecutionStack(debugProcess, threadInfo);\n  }","commit_id":"ce8d980d3b7784e39a2fe08aafc69596f79dc12d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processThreadEvent(ProtocolFrame frame) throws PyDebuggerException {\n      switch (frame.getCommand()) {\n        case AbstractCommand.CREATE_THREAD: {\n          final PyThreadInfo thread = ProtocolParser.parseThread(frame.getPayload(), myDebugProcess.getPositionConverter());\n          if (!thread.getId().equals(\"-1\")) {  // ignore pydevd threads\n            myThreads.put(thread.getId(), thread);\n          }\n          break;\n        }\n        case AbstractCommand.SUSPEND_THREAD: {\n          final PyThreadInfo event = ProtocolParser.parseThread(frame.getPayload(), myDebugProcess.getPositionConverter());\n          final PyThreadInfo thread = myThreads.get(event.getId());\n          if (thread != null) {\n            thread.updateState(PyThreadInfo.State.SUSPENDED, event.getFrames());\n            myDebugProcess.threadSuspended(thread);\n          }\n          break;\n        }\n        case AbstractCommand.RESUME_THREAD: {\n          final String id = frame.getPayload().split(\"\\t\")[0];\n          final PyThreadInfo thread = myThreads.get(id);\n          if (thread != null) {\n            thread.updateState(PyThreadInfo.State.RUNNING, null);\n          }\n          break;\n        }\n        case AbstractCommand.KILL_THREAD: {\n          final String id = frame.getPayload();\n          final PyThreadInfo thread = myThreads.get(id);\n          if (thread != null) {\n            thread.updateState(PyThreadInfo.State.KILLED, null);\n            myThreads.remove(id);\n          }\n          break;\n        }\n      }\n    }","id":29914,"modified_method":"private void processThreadEvent(ProtocolFrame frame) throws PyDebuggerException {\n      switch (frame.getCommand()) {\n        case AbstractCommand.CREATE_THREAD: {\n          final PyThreadInfo thread = parseThreadEvent(frame);\n          if (!thread.isPydevThread()) {  // ignore pydevd threads\n            myThreads.put(thread.getId(), thread);\n          }\n          break;\n        }\n        case AbstractCommand.SUSPEND_THREAD: {\n          final PyThreadInfo event = parseThreadEvent(frame);\n          final PyThreadInfo thread = myThreads.get(event.getId());\n          if (thread != null) {\n            thread.updateState(PyThreadInfo.State.SUSPENDED, event.getFrames());\n            myDebugProcess.threadSuspended(thread);\n          }\n          break;\n        }\n        case AbstractCommand.RESUME_THREAD: {\n          final String id = ProtocolParser.getThreadId(frame.getPayload());\n          final PyThreadInfo thread = myThreads.get(id);\n          if (thread != null) {\n            thread.updateState(PyThreadInfo.State.RUNNING, null);\n            myDebugProcess.threadResumed(thread);\n          }\n          break;\n        }\n        case AbstractCommand.KILL_THREAD: {\n          final String id = frame.getPayload();\n          final PyThreadInfo thread = myThreads.get(id);\n          if (thread != null) {\n            thread.updateState(PyThreadInfo.State.KILLED, null);\n            myThreads.remove(id);\n          }\n          break;\n        }\n      }\n    }","commit_id":"ce8d980d3b7784e39a2fe08aafc69596f79dc12d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processResponse(final String line) {\n      try {\n        final ProtocolFrame frame = new ProtocolFrame(line);\n        logFrame(frame, false);\n\n        if (frame.getCommand() == AbstractCommand.CREATE_THREAD ||\n            frame.getCommand() == AbstractCommand.KILL_THREAD ||\n            frame.getCommand() == AbstractCommand.RESUME_THREAD ||\n            frame.getCommand() == AbstractCommand.SUSPEND_THREAD) {\n          processThreadEvent(frame);\n        }\n        else {\n          placeResponse(frame.getSequence(), frame);\n        }\n      }\n      catch (Throwable t) {\n        // shouldn't interrupt reader thread\n        LOG.error(t);\n      }\n    }","id":29915,"modified_method":"private void processResponse(final String line) {\n      try {\n        final ProtocolFrame frame = new ProtocolFrame(line);\n        logFrame(frame, false);\n\n        if (AbstractThreadCommand.isThreadCommand(frame.getCommand())) {\n          processThreadEvent(frame);\n        }\n        else {\n          placeResponse(frame.getSequence(), frame);\n        }\n      }\n      catch (Throwable t) {\n        // shouldn't interrupt reader thread\n        LOG.error(t);\n      }\n    }","commit_id":"ce8d980d3b7784e39a2fe08aafc69596f79dc12d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setEndStateInfo(ExecHandleState newState, int exitCode, Throwable failureCause) {\n        ShutdownHookActionRegister.removeAction(shutdownHookAction);\n\n        ExecResultImpl result;\n        ExecHandleState currentState;\n        lock.lock();\n        try {\n            currentState = this.state;\n            ExecException wrappedException = null;\n            if (failureCause != null) {\n                if (currentState == ExecHandleState.STARTING) {\n                    wrappedException = new ExecException(String.format(\"A problem occurred starting %s.\",\n                            displayName), failureCause);\n                } else {\n                    wrappedException = new ExecException(String.format(\n                            \"A problem occurred waiting for %s to complete.\", displayName), failureCause);\n                }\n            }\n            setState(newState);\n            execResult = new ExecResultImpl(exitCode, wrappedException);\n            result = execResult;\n        } finally {\n            lock.unlock();\n        }\n\n        LOGGER.debug(\"Process: {} was: {}; is now: {}; Result: {}\", displayName, currentState, newState, execResult);\n\n        if (currentState != ExecHandleState.DETACHED && newState != ExecHandleState.DETACHED) {\n            broadcast.getSource().executionFinished(this, result);\n        }\n        executor.requestStop();\n    }","id":29916,"modified_method":"private void setEndStateInfo(ExecHandleState newState, int exitValue, Throwable failureCause) {\n        ShutdownHookActionRegister.removeAction(shutdownHookAction);\n\n        ExecResultImpl result;\n        ExecHandleState currentState;\n        lock.lock();\n        try {\n            currentState = this.state;\n            ExecException wrappedException = null;\n            if (failureCause != null) {\n                if (currentState == ExecHandleState.STARTING) {\n                    wrappedException = new ExecException(String.format(\"A problem occurred starting process '%s'\",\n                            displayName), failureCause);\n                } else {\n                    wrappedException = new ExecException(String.format(\n                            \"A problem occurred waiting for process '%s' to complete.\", displayName), failureCause);\n                }\n            }\n            setState(newState);\n            execResult = new ExecResultImpl(exitValue, wrappedException);\n            result = execResult;\n        } finally {\n            lock.unlock();\n        }\n\n        LOGGER.info(\"Process '{}' finished with exit value {} (state: {})\", displayName, exitValue, newState);\n\n        if (currentState != ExecHandleState.DETACHED && newState != ExecHandleState.DETACHED) {\n            broadcast.getSource().executionFinished(this, result);\n        }\n        executor.requestStop();\n    }","commit_id":"03612cdb3083d7a487f87defc581375e684031a0","url":"https://github.com/gradle/gradle"},{"original_method":"public ExecHandle start() {\n        lock.lock();\n        try {\n            ProcessParentingInitializer.intitialize();\n            if (!stateIn(ExecHandleState.INIT)) {\n                throw new IllegalStateException(\"already started!\");\n            }\n            setState(ExecHandleState.STARTING);\n\n            execHandleRunner = new ExecHandleRunner(this, streamsHandler);\n            execHandleRunner.start();\n\n            if (execResult != null) {\n                execResult.rethrowFailure();\n            }\n\n            LOGGER.debug(\"Started {}.\", displayName);\n        } finally {\n            lock.unlock();\n        }\n        return this;\n    }","id":29917,"modified_method":"public ExecHandle start() {\n        LOGGER.info(\"Starting process '{}'. Working directory: {} Command: {}\",\n                displayName, directory, command + ' ' + Joiner.on(' ').useForNull(\"null\").join(arguments));\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Environment for process '{}': {}\", displayName, environment);\n        }\n        lock.lock();\n        try {\n            ProcessParentingInitializer.intitialize();\n            if (!stateIn(ExecHandleState.INIT)) {\n                throw new IllegalStateException(String.format(\"Cannot start process '%s' because it has already been started\", displayName));\n            }\n            setState(ExecHandleState.STARTING);\n\n            execHandleRunner = new ExecHandleRunner(this, streamsHandler);\n            execHandleRunner.start();\n\n            if (execResult != null) {\n                execResult.rethrowFailure();\n            }\n\n            LOGGER.info(\"Successfully started process '{}'\", displayName);\n        } finally {\n            lock.unlock();\n        }\n        return this;\n    }","commit_id":"03612cdb3083d7a487f87defc581375e684031a0","url":"https://github.com/gradle/gradle"},{"original_method":"public ExecResult assertNormalExitValue() throws ExecException {\n            if (exitValue != 0) {\n                throw new ExecException(String.format(\"%s finished with (non-zero) exit value %d.\", StringUtils.capitalize(displayName), exitValue));\n            }\n            return this;\n        }","id":29918,"modified_method":"public ExecResult assertNormalExitValue() throws ExecException {\n            if (exitValue != 0) {\n                throw new ExecException(String.format(\"Process '%s' finished with non-zero exit value %d\", displayName, exitValue));\n            }\n            return this;\n        }","commit_id":"03612cdb3083d7a487f87defc581375e684031a0","url":"https://github.com/gradle/gradle"},{"original_method":"public void abort() {\n        lock.lock();\n        try {\n            if (state == ExecHandleState.SUCCEEDED) {\n                return;\n            }\n            if (!stateIn(ExecHandleState.STARTED, ExecHandleState.DETACHED)) {\n                throw new IllegalStateException(\"not in started or detached state!\");\n            }\n            this.execHandleRunner.abortProcess();\n        } finally {\n            lock.unlock();\n        }\n    }","id":29919,"modified_method":"public void abort() {\n        lock.lock();\n        try {\n            if (state == ExecHandleState.SUCCEEDED) {\n                return;\n            }\n            if (!stateIn(ExecHandleState.STARTED, ExecHandleState.DETACHED)) {\n                throw new IllegalStateException(String.format(\"Cannot abort process '%s' because it is not in started or detached state\", displayName));\n            }\n            this.execHandleRunner.abortProcess();\n        } finally {\n            lock.unlock();\n        }\n    }","commit_id":"03612cdb3083d7a487f87defc581375e684031a0","url":"https://github.com/gradle/gradle"},{"original_method":"public ProcessBuilder createProcessBuilder(ProcessSettings processSettings) {\n        final List<String> commandWithArguments = new ArrayList<String>();\n        final String command = processSettings.getCommand();\n        commandWithArguments.add(command);\n        final List<String> arguments = processSettings.getArguments();\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"creating process builder for {}\", processSettings);\n            LOGGER.debug(\"in directory {}\", processSettings.getDirectory());\n            int argumentIndex = 0;\n            for (String argument : arguments) {\n                LOGGER.debug(\"with argument#{} = {}\", argumentIndex, argument);\n                argumentIndex++;\n            }\n        }\n        commandWithArguments.addAll(arguments);\n        \n        final ProcessBuilder processBuilder = new ProcessBuilder(commandWithArguments);\n\n        processBuilder.directory(processSettings.getDirectory());\n        final Map<String, String> environment = processBuilder.environment();\n        environment.clear();\n        environment.putAll(processSettings.getEnvironment());\n\n        processBuilder.redirectErrorStream(processSettings.getRedirectErrorStream());\n\n        return processBuilder;\n    }","id":29920,"modified_method":"public ProcessBuilder createProcessBuilder(ProcessSettings processSettings) {\n        List<String> commandWithArguments = new ArrayList<String>();\n        commandWithArguments.add(processSettings.getCommand());\n        commandWithArguments.addAll(processSettings.getArguments());\n\n        ProcessBuilder processBuilder = new ProcessBuilder(commandWithArguments);\n        processBuilder.directory(processSettings.getDirectory());\n        processBuilder.redirectErrorStream(processSettings.getRedirectErrorStream());\n\n        Map<String, String> environment = processBuilder.environment();\n        environment.clear();\n        environment.putAll(processSettings.getEnvironment());\n\n        return processBuilder;\n    }","commit_id":"03612cdb3083d7a487f87defc581375e684031a0","url":"https://github.com/gradle/gradle"},{"original_method":"public Dataset<String, String> getBiasedDataset(ObjectBank<List<IN>> data, Index<String> featureIndex, Index<String> classIndex) {\n    makeAnswerArraysAndTagIndex(data);\n\n    Index<String> origFeatIndex = new HashIndex<String>(featureIndex.objectsList()); // mg2009: TODO: check\n\n    int size = 0;\n    for (List<IN> doc : data) {\n      size += doc.size();\n    }\n\n    System.err.println(\"Making Dataset...\");\n    Dataset<String, String> train = new Dataset<String, String>(size, featureIndex, classIndex);\n\n    for (List<IN> doc : data) {\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n\n      for (int i = 0, dsize = doc.size(); i < dsize; i++) {\n        Datum<String, String> d = makeDatum(doc, i, featureFactories);\n        Collection<String> newFeats = new ArrayList<String>();\n        for (String f : d.asFeatures()) {\n          if ( ! origFeatIndex.contains(f)) {\n            newFeats.add(f);\n          }\n        }\n//        System.err.println(d.label()+\"\\t\"+d.asFeatures()+\"\\n\\t\"+newFeats);\n//        d = new BasicDatum(newFeats, d.label());\n        train.add(d);\n      }\n\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n    }\n\n    System.err.println(\"done.\");\n\n    if (flags.featThreshFile != null) {\n      System.err.println(\"applying thresholds...\");\n      List<Pair<Pattern, Integer>> thresh = getThresholds(flags.featThreshFile);\n      train.applyFeatureCountThreshold(thresh);\n    } else if (flags.featureThreshold > 1) {\n      System.err.println(\"Removing Features with counts < \" + flags.featureThreshold);\n      train.applyFeatureCountThreshold(flags.featureThreshold);\n    }\n    train.summaryStatistics();\n    return train;\n  }","id":29921,"modified_method":"public Dataset<String, String> getBiasedDataset(ObjectBank<List<IN>> data, Index<String> featureIndex, Index<String> classIndex) {\n    makeAnswerArraysAndTagIndex(data);\n\n    Index<String> origFeatIndex = new HashIndex<String>(featureIndex.objectsList()); // mg2009: TODO: check\n\n    int size = 0;\n    for (List<IN> doc : data) {\n      size += doc.size();\n    }\n\n    System.err.print(\"Making Dataset ... \");\n    System.err.flush();\n    Dataset<String, String> train = new Dataset<String, String>(size, featureIndex, classIndex);\n\n    for (List<IN> doc : data) {\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n\n      for (int i = 0, dsize = doc.size(); i < dsize; i++) {\n        Datum<String, String> d = makeDatum(doc, i, featureFactories);\n        Collection<String> newFeats = new ArrayList<String>();\n        for (String f : d.asFeatures()) {\n          if ( ! origFeatIndex.contains(f)) {\n            newFeats.add(f);\n          }\n        }\n//        System.err.println(d.label()+\"\\t\"+d.asFeatures()+\"\\n\\t\"+newFeats);\n//        d = new BasicDatum(newFeats, d.label());\n        train.add(d);\n      }\n\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n    }\n\n    System.err.println(\"done.\");\n\n    if (flags.featThreshFile != null) {\n      System.err.println(\"applying thresholds...\");\n      List<Pair<Pattern, Integer>> thresh = getThresholds(flags.featThreshFile);\n      train.applyFeatureCountThreshold(thresh);\n    } else if (flags.featureThreshold > 1) {\n      System.err.println(\"Removing Features with counts < \" + flags.featureThreshold);\n      train.applyFeatureCountThreshold(flags.featureThreshold);\n    }\n    train.summaryStatistics();\n    return train;\n  }","commit_id":"90ad6472dfc5e50097c0dae835d86f31509d8bdc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static List<Pair<Pattern, Integer>> getThresholds(String filename) {\n    try {\n      BufferedReader in = IOUtils.readerFromString(filename);\n      List<Pair<Pattern, Integer>> thresholds = new ArrayList<>();\n      for (String line; (line = in.readLine()) != null; ) {\n        int i = line.lastIndexOf(' ');\n        Pattern p = Pattern.compile(line.substring(0, i));\n        //System.err.println(\":\"+line.substring(0,i)+\":\");\n        Integer t = Integer.valueOf(line.substring(i + 1));\n        Pair<Pattern, Integer> pair = new Pair<Pattern, Integer>(p, t);\n        thresholds.add(pair);\n      }\n      in.close();\n      return thresholds;\n    } catch (Exception e) {\n      throw new RuntimeException(\"Error reading threshold file\", e);\n    }\n  }","id":29922,"modified_method":"private static List<Pair<Pattern, Integer>> getThresholds(String filename) {\n    BufferedReader in = null;\n    try {\n      in = IOUtils.readerFromString(filename);\n      List<Pair<Pattern, Integer>> thresholds = new ArrayList<>();\n      for (String line; (line = in.readLine()) != null; ) {\n        int i = line.lastIndexOf(' ');\n        Pattern p = Pattern.compile(line.substring(0, i));\n        //System.err.println(\":\"+line.substring(0,i)+\":\");\n        Integer t = Integer.valueOf(line.substring(i + 1));\n        Pair<Pattern, Integer> pair = new Pair<Pattern, Integer>(p, t);\n        thresholds.add(pair);\n      }\n      in.close();\n      return thresholds;\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Error reading threshold file\", e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(in);\n    }\n  }","commit_id":"90ad6472dfc5e50097c0dae835d86f31509d8bdc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n     * Build a Scorer.\n     *\n     * @param lineInfos  List of INN data items to classify\n     * @param classifier The trained Classifier\n     * @param pre        Number of previous tags that condition current tag\n     * @param post       Number of following tags that condition previous tag\n     *                   (if pre and post are both nonzero, then you have a\n     *                   dependency network tagger)\n     */\n    Scorer(List<INN> lineInfos, Index<String> tagIndex, CMMClassifier<INN> classifier, int pre, int post, Set<List<String>> legalTags) {\n      if (VERBOSE) {\n        System.err.println(\"Built Scorer for \" + lineInfos.size() + \" words, clique pre=\" + pre + \" post=\" + post);\n      }\n      this.pre = pre;\n      this.post = post;\n      this.lineInfos = lineInfos;\n      this.tagIndex = tagIndex;\n      this.classifier = classifier;\n      this.legalTags = legalTags;\n      backgroundTags = new int[]{tagIndex.indexOf(classifier.flags.backgroundSymbol)};\n    }","id":29923,"modified_method":"/**\n     * Build a Scorer.\n     *\n     * @param lineInfos  List of INN data items to classify\n     * @param classifier The trained Classifier\n     * @param pre        Number of previous tags that condition current tag\n     * @param post       Number of following tags that condition previous tag\n     *                   (if pre and post are both nonzero, then you have a\n     *                   dependency network tagger)\n     */\n    Scorer(List<INN> lineInfos, Index<String> tagIndex, CMMClassifier<INN> classifier, int pre, int post, Set<List<String>> legalTags) {\n      if (VERBOSE) {\n        System.err.println(\"Built Scorer for \" + lineInfos.size() + \" words, clique pre=\" + pre + \" post=\" + post);\n      }\n      this.pre = pre;\n      this.post = post;\n      this.lineInfos = lineInfos;\n      this.tagIndex = tagIndex;\n      this.classifier = classifier;\n      this.legalTags = legalTags;\n      backgroundTags = new int[]{tagIndex.indexOf(classifier.flags.backgroundSymbol)};\n      tagArray = buildTagArray(tagIndex.size());\n    }","commit_id":"90ad6472dfc5e50097c0dae835d86f31509d8bdc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void trainSemiSup(Dataset<String, String> data, Dataset<String, String> biasedData, double[][] confusionMatrix) {\n    int prior = LogPrior.LogPriorType.QUADRATIC.ordinal();\n    if (flags.useHuber) {\n      prior = LogPrior.LogPriorType.HUBER.ordinal();\n    } else if (flags.useQuartic) {\n      prior = LogPrior.LogPriorType.QUARTIC.ordinal();\n    }\n\n    LinearClassifierFactory<String, String> lcf;\n    lcf = new LinearClassifierFactory<String, String>(flags.tolerance, flags.useSum, prior, flags.sigma, flags.epsilon, flags.QNsize);\n    if (flags.useQN) {\n      lcf.useQuasiNewton();\n    } else{\n      lcf.useConjugateGradientAscent();\n    }\n\n    this.classifier = (LinearClassifier<String, String>) lcf.trainClassifierSemiSup(data, biasedData, confusionMatrix, null);\n  }","id":29924,"modified_method":"private void trainSemiSup(Dataset<String, String> data, Dataset<String, String> biasedData, double[][] confusionMatrix) {\n    int prior = LogPrior.LogPriorType.QUADRATIC.ordinal();\n    if (flags.useHuber) {\n      prior = LogPrior.LogPriorType.HUBER.ordinal();\n    } else if (flags.useQuartic) {\n      prior = LogPrior.LogPriorType.QUARTIC.ordinal();\n    }\n\n    LinearClassifierFactory<String, String> lcf;\n    lcf = new LinearClassifierFactory<>(flags.tolerance, flags.useSum, prior, flags.sigma, flags.epsilon, flags.QNsize);\n    if (flags.useQN) {\n      lcf.useQuasiNewton();\n    } else{\n      lcf.useConjugateGradientAscent();\n    }\n\n    this.classifier = (LinearClassifier<String, String>) lcf.trainClassifierSemiSup(data, biasedData, confusionMatrix, null);\n  }","commit_id":"90ad6472dfc5e50097c0dae835d86f31509d8bdc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void trainSemiSup() {\n    DocumentReaderAndWriter<IN> readerAndWriter = makeReaderAndWriter();\n\n    String filename = flags.trainFile;\n    String biasedFilename = flags.biasedTrainFile;\n\n    ObjectBank<List<IN>> data =\n      makeObjectBankFromFile(filename, readerAndWriter);\n    ObjectBank<List<IN>> biasedData =\n      makeObjectBankFromFile(biasedFilename, readerAndWriter);\n\n    Index<String> featureIndex = new HashIndex<String>();\n    Index<String> classIndex = new HashIndex<String>();\n\n    Dataset<String, String> dataset = getDataset(data, featureIndex, classIndex);\n    Dataset<String, String> biasedDataset = getBiasedDataset(biasedData, featureIndex, classIndex);\n\n    double[][] confusionMatrix = new double[classIndex.size()][classIndex.size()];\n\n    for (int i = 0; i < confusionMatrix.length; i++) {\n      Arrays.fill(confusionMatrix[i], 0.0);\n      confusionMatrix[i][i] = 1.0;\n    }\n\n    String cm = flags.confusionMatrix;\n    String[] bits = cm.split(\":\");\n    for (String bit : bits) {\n      String[] bits1 = bit.split(\"\\\\|\");\n      int i1 = classIndex.indexOf(bits1[0]);\n      int i2 = classIndex.indexOf(bits1[1]);\n      double d = Double.parseDouble(bits1[2]);\n      confusionMatrix[i2][i1] = d;\n    }\n\n    for (double[] row : confusionMatrix) {\n      ArrayMath.normalize(row);\n    }\n\n    for (int i = 0; i < confusionMatrix.length; i++) {\n      for (int j = 0; j < i; j++) {\n        double d = confusionMatrix[i][j];\n        confusionMatrix[i][j] = confusionMatrix[j][i];\n        confusionMatrix[j][i] = d;\n      }\n    }\n\n    for (int i = 0; i < confusionMatrix.length; i++) {\n      for (int j = 0; j < confusionMatrix.length; j++) {\n        System.err.println(\"P(\"+classIndex.get(j)+ '|' +classIndex.get(i)+\") = \"+confusionMatrix[j][i]);\n      }\n    }\n\n    trainSemiSup(dataset, biasedDataset, confusionMatrix);\n  }","id":29925,"modified_method":"public void trainSemiSup() {\n    DocumentReaderAndWriter<IN> readerAndWriter = makeReaderAndWriter();\n\n    String filename = flags.trainFile;\n    String biasedFilename = flags.biasedTrainFile;\n\n    ObjectBank<List<IN>> data =\n      makeObjectBankFromFile(filename, readerAndWriter);\n    ObjectBank<List<IN>> biasedData =\n      makeObjectBankFromFile(biasedFilename, readerAndWriter);\n\n    Index<String> featureIndex = new HashIndex<>();\n    Index<String> classIndex = new HashIndex<>();\n\n    Dataset<String, String> dataset = getDataset(data, featureIndex, classIndex);\n    Dataset<String, String> biasedDataset = getBiasedDataset(biasedData, featureIndex, classIndex);\n\n    double[][] confusionMatrix = new double[classIndex.size()][classIndex.size()];\n\n    for (int i = 0; i < confusionMatrix.length; i++) {\n      Arrays.fill(confusionMatrix[i], 0.0);\n      confusionMatrix[i][i] = 1.0;\n    }\n\n    String cm = flags.confusionMatrix;\n    String[] bits = cm.split(\":\");\n    for (String bit : bits) {\n      String[] bits1 = bit.split(\"\\\\|\");\n      int i1 = classIndex.indexOf(bits1[0]);\n      int i2 = classIndex.indexOf(bits1[1]);\n      double d = Double.parseDouble(bits1[2]);\n      confusionMatrix[i2][i1] = d;\n    }\n\n    for (double[] row : confusionMatrix) {\n      ArrayMath.normalize(row);\n    }\n\n    for (int i = 0; i < confusionMatrix.length; i++) {\n      for (int j = 0; j < i; j++) {\n        double d = confusionMatrix[i][j];\n        confusionMatrix[i][j] = confusionMatrix[j][i];\n        confusionMatrix[j][i] = d;\n      }\n    }\n\n    for (int i = 0; i < confusionMatrix.length; i++) {\n      for (int j = 0; j < confusionMatrix.length; j++) {\n        System.err.println(\"P(\"+classIndex.get(j)+ '|' +classIndex.get(i)+\") = \"+confusionMatrix[j][i]);\n      }\n    }\n\n    trainSemiSup(dataset, biasedDataset, confusionMatrix);\n  }","commit_id":"90ad6472dfc5e50097c0dae835d86f31509d8bdc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"void buildTagArray() {\n      int sz = tagIndex.size();\n      tagArray = new int[sz];\n      for (int i = 0; i < sz; i++) {\n        tagArray[i] = i;\n      }\n    }","id":29926,"modified_method":"private static int[] buildTagArray(int sz) {\n      int[] temp = new int[sz];\n      for (int i = 0; i < sz; i++) {\n        temp[i] = i;\n      }\n      return temp;\n    }","commit_id":"90ad6472dfc5e50097c0dae835d86f31509d8bdc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** This routine builds the <code>answerArrays<\/code> which give the\n   *  empirically legal label sequences (of length (order) at most\n   *  <code>flags.maxLeft<\/code>) and the <code>classIndex<\/code>,\n   *  which indexes known answer classes.\n   *\n   * @param docs The training data: A List of List of CoreLabel\n   */\n  private void makeAnswerArraysAndTagIndex(Collection<List<IN>> docs) {\n    if (answerArrays == null) {\n      answerArrays = Generics.newHashSet();\n    }\n    if (classIndex == null) {\n      classIndex = new HashIndex<String>();\n    }\n\n    for (List<IN> doc : docs) {\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n\n      int leng = doc.size();\n      for (int start = 0; start < leng; start++) {\n        for (int diff = 1; diff <= flags.maxLeft && start + diff <= leng; diff++) {\n          String[] seq = new String[diff];\n          for (int i = start; i < start + diff; i++) {\n            seq[i - start] = doc.get(i).get(CoreAnnotations.AnswerAnnotation.class);\n          }\n          answerArrays.add(Arrays.asList(seq));\n        }\n      }\n      for (int i = 0; i < leng; i++) {\n        CoreLabel wordInfo = doc.get(i);\n        classIndex.add(wordInfo.get(CoreAnnotations.AnswerAnnotation.class));\n      }\n\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n    }\n  }","id":29927,"modified_method":"/** This routine builds the <code>answerArrays<\/code> which give the\n   *  empirically legal label sequences (of length (order) at most\n   *  <code>flags.maxLeft<\/code>) and the <code>classIndex<\/code>,\n   *  which indexes known answer classes.\n   *\n   * @param docs The training data: A List of List of CoreLabel\n   */\n  private void makeAnswerArraysAndTagIndex(Collection<List<IN>> docs) {\n    if (answerArrays == null) {\n      answerArrays = Generics.newHashSet();\n    }\n    if (classIndex == null) {\n      classIndex = new HashIndex<String>();\n    }\n\n    for (List<IN> doc : docs) {\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n\n      int leng = doc.size();\n      for (int start = 0; start < leng; start++) {\n        for (int diff = 1; diff <= flags.maxLeft && start + diff <= leng; diff++) {\n          String[] seq = new String[diff];\n          for (int i = start; i < start + diff; i++) {\n            seq[i - start] = doc.get(i).get(CoreAnnotations.AnswerAnnotation.class);\n          }\n          answerArrays.add(Arrays.asList(seq));\n        }\n      }\n      for (IN wordInfo : doc) {\n        classIndex.add(wordInfo.get(CoreAnnotations.AnswerAnnotation.class));\n      }\n\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n    }\n  }","commit_id":"90ad6472dfc5e50097c0dae835d86f31509d8bdc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n    public int[] getPossibleValues(int position) {\n      //             if (position == 0 || position == lineInfos.size() - 1) {\n      //                 int[] a = new int[1];\n      //                 a[0] = tagIndex.indexOf(BACKGROUND);\n      //                 return a;\n      //             }\n      if (tagArray == null) {\n        buildTagArray();\n      }\n      if (position < pre) {\n        return backgroundTags;\n      }\n      return tagArray;\n    }","id":29928,"modified_method":"@Override\n    public int[] getPossibleValues(int position) {\n      // if (position == 0 || position == lineInfos.size() - 1) {\n      //   int[] a = new int[1];\n      //   a[0] = tagIndex.indexOf(BACKGROUND);\n      //   return a;\n      // }\n      // if (tagArray == null) {\n      //   buildTagArray();\n      // }\n      if (position < pre) {\n        return backgroundTags;\n      }\n      return tagArray;\n    }","commit_id":"90ad6472dfc5e50097c0dae835d86f31509d8bdc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Build a Dataset from some data. Used for training a classifier.\n   *\n   * By passing in extra featureIndex and classIndex, you can get a Dataset based on featureIndex and\n   * classIndex\n   *\n   * @param data This variable is a list of lists of CoreLabel.  That is,\n   *             it is a collection of documents, each of which is represented\n   *             as a sequence of CoreLabel objects.\n   * @param classIndex if you want to get a Dataset based on featureIndex and\n   *                    classIndex in an existing origDataset\n   * @return The Dataset which is an efficient encoding of the information\n   *         in a List of Datums\n   */\n  public Dataset<String, String> getDataset(Collection<List<IN>> data, Index<String> featureIndex, Index<String> classIndex) {\n    makeAnswerArraysAndTagIndex(data);\n\n    int size = 0;\n    for (List<IN> doc : data) {\n      size += doc.size();\n    }\n\n    System.err.println(\"Making Dataset...\");\n    Dataset<String, String> train;\n    if (featureIndex != null && classIndex != null) {\n      System.err.println(\"Using feature/class Index from existing Dataset...\");\n      System.err.println(\"(This is used when getting Dataset from adaptation set. We want to make the index consistent.)\"); //pichuan\n      train = new Dataset<String, String>(size, featureIndex, classIndex);\n    } else {\n      train = new Dataset<String, String>(size);\n    }\n\n    for (List<IN> doc : data) {\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n\n      for (int i = 0, dsize = doc.size(); i < dsize; i++) {\n        Datum<String, String> d = makeDatum(doc, i, featureFactories);\n\n        //CoreLabel fl = doc.get(i);\n\n        train.add(d);\n      }\n\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n    }\n\n    System.err.println(\"done.\");\n\n    if (flags.featThreshFile != null) {\n      System.err.println(\"applying thresholds...\");\n      List<Pair<Pattern, Integer>> thresh = getThresholds(flags.featThreshFile);\n      train.applyFeatureCountThreshold(thresh);\n    } else if (flags.featureThreshold > 1) {\n      System.err.println(\"Removing Features with counts < \" + flags.featureThreshold);\n      train.applyFeatureCountThreshold(flags.featureThreshold);\n    }\n    train.summaryStatistics();\n    return train;\n  }","id":29929,"modified_method":"/**\n   * Build a Dataset from some data. Used for training a classifier.\n   *\n   * By passing in extra featureIndex and classIndex, you can get a Dataset based on featureIndex and\n   * classIndex\n   *\n   * @param data This variable is a list of lists of CoreLabel.  That is,\n   *             it is a collection of documents, each of which is represented\n   *             as a sequence of CoreLabel objects.\n   * @param classIndex if you want to get a Dataset based on featureIndex and\n   *                    classIndex in an existing origDataset\n   * @return The Dataset which is an efficient encoding of the information\n   *         in a List of Datums\n   */\n  public Dataset<String, String> getDataset(Collection<List<IN>> data, Index<String> featureIndex, Index<String> classIndex) {\n    makeAnswerArraysAndTagIndex(data);\n\n    int size = 0;\n    for (List<IN> doc : data) {\n      size += doc.size();\n    }\n\n    System.err.print(\"Making Dataset ... \");\n    System.err.flush();\n    Dataset<String, String> train;\n    if (featureIndex != null && classIndex != null) {\n      System.err.println(\"  Using feature/class Index from existing Dataset...\");\n      System.err.println(\"  (This is used when getting Dataset from adaptation set. We want to make the index consistent.)\"); //pichuan\n      train = new Dataset<String, String>(size, featureIndex, classIndex);\n    } else {\n      train = new Dataset<String, String>(size);\n    }\n\n    for (List<IN> doc : data) {\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n\n      for (int i = 0, dsize = doc.size(); i < dsize; i++) {\n        Datum<String, String> d = makeDatum(doc, i, featureFactories);\n\n        //CoreLabel fl = doc.get(i);\n\n        train.add(d);\n      }\n\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n    }\n\n    System.err.println(\"done.\");\n\n    if (flags.featThreshFile != null) {\n      System.err.println(\"applying thresholds...\");\n      List<Pair<Pattern, Integer>> thresh = getThresholds(flags.featThreshFile);\n      train.applyFeatureCountThreshold(thresh);\n    } else if (flags.featureThreshold > 1) {\n      System.err.println(\"Removing Features with counts < \" + flags.featureThreshold);\n      train.applyFeatureCountThreshold(flags.featureThreshold);\n    }\n    train.summaryStatistics();\n    return train;\n  }","commit_id":"90ad6472dfc5e50097c0dae835d86f31509d8bdc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static List<Pair<Pattern, Integer>> getThresholds(String filename) {\n    try {\n      BufferedReader in = IOUtils.readerFromString(filename);\n      List<Pair<Pattern, Integer>> thresholds = new ArrayList<>();\n      for (String line; (line = in.readLine()) != null; ) {\n        int i = line.lastIndexOf(' ');\n        Pattern p = Pattern.compile(line.substring(0, i));\n        //System.err.println(\":\"+line.substring(0,i)+\":\");\n        Integer t = Integer.valueOf(line.substring(i + 1));\n        Pair<Pattern, Integer> pair = new Pair<Pattern, Integer>(p, t);\n        thresholds.add(pair);\n      }\n      in.close();\n      return thresholds;\n    } catch (Exception e) {\n      throw new RuntimeException(\"Error reading threshold file\", e);\n    }\n  }","id":29930,"modified_method":"private static List<Pair<Pattern, Integer>> getThresholds(String filename) {\n    BufferedReader in = null;\n    try {\n      in = IOUtils.readerFromString(filename);\n      List<Pair<Pattern, Integer>> thresholds = new ArrayList<>();\n      for (String line; (line = in.readLine()) != null; ) {\n        int i = line.lastIndexOf(' ');\n        Pattern p = Pattern.compile(line.substring(0, i));\n        //System.err.println(\":\"+line.substring(0,i)+\":\");\n        Integer t = Integer.valueOf(line.substring(i + 1));\n        Pair<Pattern, Integer> pair = new Pair<Pattern, Integer>(p, t);\n        thresholds.add(pair);\n      }\n      in.close();\n      return thresholds;\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Error reading threshold file\", e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(in);\n    }\n  }","commit_id":"f1033d62c72d888ca56e6c1c6d850e47ae73328f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n    public int[] getPossibleValues(int position) {\n      //             if (position == 0 || position == lineInfos.size() - 1) {\n      //                 int[] a = new int[1];\n      //                 a[0] = tagIndex.indexOf(BACKGROUND);\n      //                 return a;\n      //             }\n      if (tagArray == null) {\n        buildTagArray();\n      }\n      if (position < pre) {\n        return backgroundTags;\n      }\n      return tagArray;\n    }","id":29931,"modified_method":"@Override\n    public int[] getPossibleValues(int position) {\n      // if (position == 0 || position == lineInfos.size() - 1) {\n      //   int[] a = new int[1];\n      //   a[0] = tagIndex.indexOf(BACKGROUND);\n      //   return a;\n      // }\n      // if (tagArray == null) {\n      //   buildTagArray();\n      // }\n      if (position < pre) {\n        return backgroundTags;\n      }\n      return tagArray;\n    }","commit_id":"f1033d62c72d888ca56e6c1c6d850e47ae73328f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n     * Build a Scorer.\n     *\n     * @param lineInfos  List of INN data items to classify\n     * @param classifier The trained Classifier\n     * @param pre        Number of previous tags that condition current tag\n     * @param post       Number of following tags that condition previous tag\n     *                   (if pre and post are both nonzero, then you have a\n     *                   dependency network tagger)\n     */\n    Scorer(List<INN> lineInfos, Index<String> tagIndex, CMMClassifier<INN> classifier, int pre, int post, Set<List<String>> legalTags) {\n      if (VERBOSE) {\n        System.err.println(\"Built Scorer for \" + lineInfos.size() + \" words, clique pre=\" + pre + \" post=\" + post);\n      }\n      this.pre = pre;\n      this.post = post;\n      this.lineInfos = lineInfos;\n      this.tagIndex = tagIndex;\n      this.classifier = classifier;\n      this.legalTags = legalTags;\n      backgroundTags = new int[]{tagIndex.indexOf(classifier.flags.backgroundSymbol)};\n    }","id":29932,"modified_method":"/**\n     * Build a Scorer.\n     *\n     * @param lineInfos  List of INN data items to classify\n     * @param classifier The trained Classifier\n     * @param pre        Number of previous tags that condition current tag\n     * @param post       Number of following tags that condition previous tag\n     *                   (if pre and post are both nonzero, then you have a\n     *                   dependency network tagger)\n     */\n    Scorer(List<INN> lineInfos, Index<String> tagIndex, CMMClassifier<INN> classifier, int pre, int post, Set<List<String>> legalTags) {\n      if (VERBOSE) {\n        System.err.println(\"Built Scorer for \" + lineInfos.size() + \" words, clique pre=\" + pre + \" post=\" + post);\n      }\n      this.pre = pre;\n      this.post = post;\n      this.lineInfos = lineInfos;\n      this.tagIndex = tagIndex;\n      this.classifier = classifier;\n      this.legalTags = legalTags;\n      backgroundTags = new int[]{tagIndex.indexOf(classifier.flags.backgroundSymbol)};\n      tagArray = buildTagArray(tagIndex.size());\n    }","commit_id":"f1033d62c72d888ca56e6c1c6d850e47ae73328f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void trainSemiSup(Dataset<String, String> data, Dataset<String, String> biasedData, double[][] confusionMatrix) {\n    int prior = LogPrior.LogPriorType.QUADRATIC.ordinal();\n    if (flags.useHuber) {\n      prior = LogPrior.LogPriorType.HUBER.ordinal();\n    } else if (flags.useQuartic) {\n      prior = LogPrior.LogPriorType.QUARTIC.ordinal();\n    }\n\n    LinearClassifierFactory<String, String> lcf;\n    lcf = new LinearClassifierFactory<String, String>(flags.tolerance, flags.useSum, prior, flags.sigma, flags.epsilon, flags.QNsize);\n    if (flags.useQN) {\n      lcf.useQuasiNewton();\n    } else{\n      lcf.useConjugateGradientAscent();\n    }\n\n    this.classifier = (LinearClassifier<String, String>) lcf.trainClassifierSemiSup(data, biasedData, confusionMatrix, null);\n  }","id":29933,"modified_method":"private void trainSemiSup(Dataset<String, String> data, Dataset<String, String> biasedData, double[][] confusionMatrix) {\n    int prior = LogPrior.LogPriorType.QUADRATIC.ordinal();\n    if (flags.useHuber) {\n      prior = LogPrior.LogPriorType.HUBER.ordinal();\n    } else if (flags.useQuartic) {\n      prior = LogPrior.LogPriorType.QUARTIC.ordinal();\n    }\n\n    LinearClassifierFactory<String, String> lcf;\n    lcf = new LinearClassifierFactory<>(flags.tolerance, flags.useSum, prior, flags.sigma, flags.epsilon, flags.QNsize);\n    if (flags.useQN) {\n      lcf.useQuasiNewton();\n    } else{\n      lcf.useConjugateGradientAscent();\n    }\n\n    this.classifier = (LinearClassifier<String, String>) lcf.trainClassifierSemiSup(data, biasedData, confusionMatrix, null);\n  }","commit_id":"f1033d62c72d888ca56e6c1c6d850e47ae73328f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** This routine builds the <code>answerArrays<\/code> which give the\n   *  empirically legal label sequences (of length (order) at most\n   *  <code>flags.maxLeft<\/code>) and the <code>classIndex<\/code>,\n   *  which indexes known answer classes.\n   *\n   * @param docs The training data: A List of List of CoreLabel\n   */\n  private void makeAnswerArraysAndTagIndex(Collection<List<IN>> docs) {\n    if (answerArrays == null) {\n      answerArrays = Generics.newHashSet();\n    }\n    if (classIndex == null) {\n      classIndex = new HashIndex<String>();\n    }\n\n    for (List<IN> doc : docs) {\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n\n      int leng = doc.size();\n      for (int start = 0; start < leng; start++) {\n        for (int diff = 1; diff <= flags.maxLeft && start + diff <= leng; diff++) {\n          String[] seq = new String[diff];\n          for (int i = start; i < start + diff; i++) {\n            seq[i - start] = doc.get(i).get(CoreAnnotations.AnswerAnnotation.class);\n          }\n          answerArrays.add(Arrays.asList(seq));\n        }\n      }\n      for (int i = 0; i < leng; i++) {\n        CoreLabel wordInfo = doc.get(i);\n        classIndex.add(wordInfo.get(CoreAnnotations.AnswerAnnotation.class));\n      }\n\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n    }\n  }","id":29934,"modified_method":"/** This routine builds the <code>answerArrays<\/code> which give the\n   *  empirically legal label sequences (of length (order) at most\n   *  <code>flags.maxLeft<\/code>) and the <code>classIndex<\/code>,\n   *  which indexes known answer classes.\n   *\n   * @param docs The training data: A List of List of CoreLabel\n   */\n  private void makeAnswerArraysAndTagIndex(Collection<List<IN>> docs) {\n    if (answerArrays == null) {\n      answerArrays = Generics.newHashSet();\n    }\n    if (classIndex == null) {\n      classIndex = new HashIndex<String>();\n    }\n\n    for (List<IN> doc : docs) {\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n\n      int leng = doc.size();\n      for (int start = 0; start < leng; start++) {\n        for (int diff = 1; diff <= flags.maxLeft && start + diff <= leng; diff++) {\n          String[] seq = new String[diff];\n          for (int i = start; i < start + diff; i++) {\n            seq[i - start] = doc.get(i).get(CoreAnnotations.AnswerAnnotation.class);\n          }\n          answerArrays.add(Arrays.asList(seq));\n        }\n      }\n      for (IN wordInfo : doc) {\n        classIndex.add(wordInfo.get(CoreAnnotations.AnswerAnnotation.class));\n      }\n\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n    }\n  }","commit_id":"f1033d62c72d888ca56e6c1c6d850e47ae73328f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void trainSemiSup() {\n    DocumentReaderAndWriter<IN> readerAndWriter = makeReaderAndWriter();\n\n    String filename = flags.trainFile;\n    String biasedFilename = flags.biasedTrainFile;\n\n    ObjectBank<List<IN>> data =\n      makeObjectBankFromFile(filename, readerAndWriter);\n    ObjectBank<List<IN>> biasedData =\n      makeObjectBankFromFile(biasedFilename, readerAndWriter);\n\n    Index<String> featureIndex = new HashIndex<String>();\n    Index<String> classIndex = new HashIndex<String>();\n\n    Dataset<String, String> dataset = getDataset(data, featureIndex, classIndex);\n    Dataset<String, String> biasedDataset = getBiasedDataset(biasedData, featureIndex, classIndex);\n\n    double[][] confusionMatrix = new double[classIndex.size()][classIndex.size()];\n\n    for (int i = 0; i < confusionMatrix.length; i++) {\n      Arrays.fill(confusionMatrix[i], 0.0);\n      confusionMatrix[i][i] = 1.0;\n    }\n\n    String cm = flags.confusionMatrix;\n    String[] bits = cm.split(\":\");\n    for (String bit : bits) {\n      String[] bits1 = bit.split(\"\\\\|\");\n      int i1 = classIndex.indexOf(bits1[0]);\n      int i2 = classIndex.indexOf(bits1[1]);\n      double d = Double.parseDouble(bits1[2]);\n      confusionMatrix[i2][i1] = d;\n    }\n\n    for (double[] row : confusionMatrix) {\n      ArrayMath.normalize(row);\n    }\n\n    for (int i = 0; i < confusionMatrix.length; i++) {\n      for (int j = 0; j < i; j++) {\n        double d = confusionMatrix[i][j];\n        confusionMatrix[i][j] = confusionMatrix[j][i];\n        confusionMatrix[j][i] = d;\n      }\n    }\n\n    for (int i = 0; i < confusionMatrix.length; i++) {\n      for (int j = 0; j < confusionMatrix.length; j++) {\n        System.err.println(\"P(\"+classIndex.get(j)+ '|' +classIndex.get(i)+\") = \"+confusionMatrix[j][i]);\n      }\n    }\n\n    trainSemiSup(dataset, biasedDataset, confusionMatrix);\n  }","id":29935,"modified_method":"public void trainSemiSup() {\n    DocumentReaderAndWriter<IN> readerAndWriter = makeReaderAndWriter();\n\n    String filename = flags.trainFile;\n    String biasedFilename = flags.biasedTrainFile;\n\n    ObjectBank<List<IN>> data =\n      makeObjectBankFromFile(filename, readerAndWriter);\n    ObjectBank<List<IN>> biasedData =\n      makeObjectBankFromFile(biasedFilename, readerAndWriter);\n\n    Index<String> featureIndex = new HashIndex<>();\n    Index<String> classIndex = new HashIndex<>();\n\n    Dataset<String, String> dataset = getDataset(data, featureIndex, classIndex);\n    Dataset<String, String> biasedDataset = getBiasedDataset(biasedData, featureIndex, classIndex);\n\n    double[][] confusionMatrix = new double[classIndex.size()][classIndex.size()];\n\n    for (int i = 0; i < confusionMatrix.length; i++) {\n      Arrays.fill(confusionMatrix[i], 0.0);\n      confusionMatrix[i][i] = 1.0;\n    }\n\n    String cm = flags.confusionMatrix;\n    String[] bits = cm.split(\":\");\n    for (String bit : bits) {\n      String[] bits1 = bit.split(\"\\\\|\");\n      int i1 = classIndex.indexOf(bits1[0]);\n      int i2 = classIndex.indexOf(bits1[1]);\n      double d = Double.parseDouble(bits1[2]);\n      confusionMatrix[i2][i1] = d;\n    }\n\n    for (double[] row : confusionMatrix) {\n      ArrayMath.normalize(row);\n    }\n\n    for (int i = 0; i < confusionMatrix.length; i++) {\n      for (int j = 0; j < i; j++) {\n        double d = confusionMatrix[i][j];\n        confusionMatrix[i][j] = confusionMatrix[j][i];\n        confusionMatrix[j][i] = d;\n      }\n    }\n\n    for (int i = 0; i < confusionMatrix.length; i++) {\n      for (int j = 0; j < confusionMatrix.length; j++) {\n        System.err.println(\"P(\"+classIndex.get(j)+ '|' +classIndex.get(i)+\") = \"+confusionMatrix[j][i]);\n      }\n    }\n\n    trainSemiSup(dataset, biasedDataset, confusionMatrix);\n  }","commit_id":"f1033d62c72d888ca56e6c1c6d850e47ae73328f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"void buildTagArray() {\n      int sz = tagIndex.size();\n      tagArray = new int[sz];\n      for (int i = 0; i < sz; i++) {\n        tagArray[i] = i;\n      }\n    }","id":29936,"modified_method":"private static int[] buildTagArray(int sz) {\n      int[] temp = new int[sz];\n      for (int i = 0; i < sz; i++) {\n        temp[i] = i;\n      }\n      return temp;\n    }","commit_id":"f1033d62c72d888ca56e6c1c6d850e47ae73328f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Dataset<String, String> getBiasedDataset(ObjectBank<List<IN>> data, Index<String> featureIndex, Index<String> classIndex) {\n    makeAnswerArraysAndTagIndex(data);\n\n    Index<String> origFeatIndex = new HashIndex<String>(featureIndex.objectsList()); // mg2009: TODO: check\n\n    int size = 0;\n    for (List<IN> doc : data) {\n      size += doc.size();\n    }\n\n    System.err.println(\"Making Dataset...\");\n    Dataset<String, String> train = new Dataset<String, String>(size, featureIndex, classIndex);\n\n    for (List<IN> doc : data) {\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n\n      for (int i = 0, dsize = doc.size(); i < dsize; i++) {\n        Datum<String, String> d = makeDatum(doc, i, featureFactories);\n        Collection<String> newFeats = new ArrayList<String>();\n        for (String f : d.asFeatures()) {\n          if ( ! origFeatIndex.contains(f)) {\n            newFeats.add(f);\n          }\n        }\n//        System.err.println(d.label()+\"\\t\"+d.asFeatures()+\"\\n\\t\"+newFeats);\n//        d = new BasicDatum(newFeats, d.label());\n        train.add(d);\n      }\n\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n    }\n\n    System.err.println(\"done.\");\n\n    if (flags.featThreshFile != null) {\n      System.err.println(\"applying thresholds...\");\n      List<Pair<Pattern, Integer>> thresh = getThresholds(flags.featThreshFile);\n      train.applyFeatureCountThreshold(thresh);\n    } else if (flags.featureThreshold > 1) {\n      System.err.println(\"Removing Features with counts < \" + flags.featureThreshold);\n      train.applyFeatureCountThreshold(flags.featureThreshold);\n    }\n    train.summaryStatistics();\n    return train;\n  }","id":29937,"modified_method":"public Dataset<String, String> getBiasedDataset(ObjectBank<List<IN>> data, Index<String> featureIndex, Index<String> classIndex) {\n    makeAnswerArraysAndTagIndex(data);\n\n    Index<String> origFeatIndex = new HashIndex<String>(featureIndex.objectsList()); // mg2009: TODO: check\n\n    int size = 0;\n    for (List<IN> doc : data) {\n      size += doc.size();\n    }\n\n    System.err.print(\"Making Dataset ... \");\n    System.err.flush();\n    Dataset<String, String> train = new Dataset<String, String>(size, featureIndex, classIndex);\n\n    for (List<IN> doc : data) {\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n\n      for (int i = 0, dsize = doc.size(); i < dsize; i++) {\n        Datum<String, String> d = makeDatum(doc, i, featureFactories);\n        Collection<String> newFeats = new ArrayList<String>();\n        for (String f : d.asFeatures()) {\n          if ( ! origFeatIndex.contains(f)) {\n            newFeats.add(f);\n          }\n        }\n//        System.err.println(d.label()+\"\\t\"+d.asFeatures()+\"\\n\\t\"+newFeats);\n//        d = new BasicDatum(newFeats, d.label());\n        train.add(d);\n      }\n\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n    }\n\n    System.err.println(\"done.\");\n\n    if (flags.featThreshFile != null) {\n      System.err.println(\"applying thresholds...\");\n      List<Pair<Pattern, Integer>> thresh = getThresholds(flags.featThreshFile);\n      train.applyFeatureCountThreshold(thresh);\n    } else if (flags.featureThreshold > 1) {\n      System.err.println(\"Removing Features with counts < \" + flags.featureThreshold);\n      train.applyFeatureCountThreshold(flags.featureThreshold);\n    }\n    train.summaryStatistics();\n    return train;\n  }","commit_id":"f1033d62c72d888ca56e6c1c6d850e47ae73328f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Build a Dataset from some data. Used for training a classifier.\n   *\n   * By passing in extra featureIndex and classIndex, you can get a Dataset based on featureIndex and\n   * classIndex\n   *\n   * @param data This variable is a list of lists of CoreLabel.  That is,\n   *             it is a collection of documents, each of which is represented\n   *             as a sequence of CoreLabel objects.\n   * @param classIndex if you want to get a Dataset based on featureIndex and\n   *                    classIndex in an existing origDataset\n   * @return The Dataset which is an efficient encoding of the information\n   *         in a List of Datums\n   */\n  public Dataset<String, String> getDataset(Collection<List<IN>> data, Index<String> featureIndex, Index<String> classIndex) {\n    makeAnswerArraysAndTagIndex(data);\n\n    int size = 0;\n    for (List<IN> doc : data) {\n      size += doc.size();\n    }\n\n    System.err.println(\"Making Dataset...\");\n    Dataset<String, String> train;\n    if (featureIndex != null && classIndex != null) {\n      System.err.println(\"Using feature/class Index from existing Dataset...\");\n      System.err.println(\"(This is used when getting Dataset from adaptation set. We want to make the index consistent.)\"); //pichuan\n      train = new Dataset<String, String>(size, featureIndex, classIndex);\n    } else {\n      train = new Dataset<String, String>(size);\n    }\n\n    for (List<IN> doc : data) {\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n\n      for (int i = 0, dsize = doc.size(); i < dsize; i++) {\n        Datum<String, String> d = makeDatum(doc, i, featureFactories);\n\n        //CoreLabel fl = doc.get(i);\n\n        train.add(d);\n      }\n\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n    }\n\n    System.err.println(\"done.\");\n\n    if (flags.featThreshFile != null) {\n      System.err.println(\"applying thresholds...\");\n      List<Pair<Pattern, Integer>> thresh = getThresholds(flags.featThreshFile);\n      train.applyFeatureCountThreshold(thresh);\n    } else if (flags.featureThreshold > 1) {\n      System.err.println(\"Removing Features with counts < \" + flags.featureThreshold);\n      train.applyFeatureCountThreshold(flags.featureThreshold);\n    }\n    train.summaryStatistics();\n    return train;\n  }","id":29938,"modified_method":"/**\n   * Build a Dataset from some data. Used for training a classifier.\n   *\n   * By passing in extra featureIndex and classIndex, you can get a Dataset based on featureIndex and\n   * classIndex\n   *\n   * @param data This variable is a list of lists of CoreLabel.  That is,\n   *             it is a collection of documents, each of which is represented\n   *             as a sequence of CoreLabel objects.\n   * @param classIndex if you want to get a Dataset based on featureIndex and\n   *                    classIndex in an existing origDataset\n   * @return The Dataset which is an efficient encoding of the information\n   *         in a List of Datums\n   */\n  public Dataset<String, String> getDataset(Collection<List<IN>> data, Index<String> featureIndex, Index<String> classIndex) {\n    makeAnswerArraysAndTagIndex(data);\n\n    int size = 0;\n    for (List<IN> doc : data) {\n      size += doc.size();\n    }\n\n    System.err.print(\"Making Dataset ... \");\n    System.err.flush();\n    Dataset<String, String> train;\n    if (featureIndex != null && classIndex != null) {\n      System.err.println(\"  Using feature/class Index from existing Dataset...\");\n      System.err.println(\"  (This is used when getting Dataset from adaptation set. We want to make the index consistent.)\"); //pichuan\n      train = new Dataset<String, String>(size, featureIndex, classIndex);\n    } else {\n      train = new Dataset<String, String>(size);\n    }\n\n    for (List<IN> doc : data) {\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n\n      for (int i = 0, dsize = doc.size(); i < dsize; i++) {\n        Datum<String, String> d = makeDatum(doc, i, featureFactories);\n\n        //CoreLabel fl = doc.get(i);\n\n        train.add(d);\n      }\n\n      if (flags.useReverse) {\n        Collections.reverse(doc);\n      }\n    }\n\n    System.err.println(\"done.\");\n\n    if (flags.featThreshFile != null) {\n      System.err.println(\"applying thresholds...\");\n      List<Pair<Pattern, Integer>> thresh = getThresholds(flags.featThreshFile);\n      train.applyFeatureCountThreshold(thresh);\n    } else if (flags.featureThreshold > 1) {\n      System.err.println(\"Removing Features with counts < \" + flags.featureThreshold);\n      train.applyFeatureCountThreshold(flags.featureThreshold);\n    }\n    train.summaryStatistics();\n    return train;\n  }","commit_id":"f1033d62c72d888ca56e6c1c6d850e47ae73328f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private AndroidEnvironment() {\n    System.err.println(\"Starting up AndroidEnvironment\");\n    killAdbServer();\n    try {\n      new ProcessHelper(\"adb\", \"start-server\").execute();\n    } catch (final Exception e) {\n      e.printStackTrace(System.err);\n    }\n    Runtime.getRuntime().addShutdownHook(\n      new Thread(\"AndroidEnvironment Shutdown\") {\n        @Override\n        public void run() {\n          shutdown();\n        }\n      });\n  }","id":29939,"modified_method":"private AndroidEnvironment() {\n    System.err.println(\"Starting up AndroidEnvironment\");\n    killAdbServer();\n    System.err.print(\"Starting up fresh adb server...\");\n    System.err.flush();\n    try {\n      new ProcessHelper(\"adb\", \"start-server\").execute();\n      System.err.println(\"OK.\");\n    } catch (final Exception e) {\n      System.err.println(\"failed.\");\n      System.err.println();\n      e.printStackTrace(System.err);\n    }\n    Runtime.getRuntime().addShutdownHook(\n      new Thread(\"AndroidEnvironment Shutdown\") {\n        @Override\n        public void run() {\n          shutdown();\n        }\n      });\n  }","commit_id":"f83aea0944f634c3c5b7419ebd24bb2f5d704b1a","url":"https://github.com/processing/processing"},{"original_method":"public static void killAdbServer() {\n    System.err.println(\"Attempting to shut down existing adb server...\");\n    try {\n      new ProcessHelper(\"adb\", \"kill-server\").execute();\n      System.err.println(\"...it's dead, or at least not at all well.\");\n    } catch (final Exception e) {\n      e.printStackTrace(System.err);\n    }\n  }","id":29940,"modified_method":"public static void killAdbServer() {\n    System.err.print(\"Shutting down any existing adb server...\");\n    System.err.flush();\n    try {\n      new ProcessHelper(\"adb\", \"kill-server\").execute();\n      System.err.println(\"OK.\");\n    } catch (final Exception e) {\n      System.err.println(\"failed.\");\n      System.err.println();\n      e.printStackTrace(System.err);\n    }\n  }","commit_id":"f83aea0944f634c3c5b7419ebd24bb2f5d704b1a","url":"https://github.com/processing/processing"},{"original_method":"static void launch() throws IOException {\n    String portString = Preferences.get(\"android.emulator.port\");\n    if (portString == null) {\n      portString = \"5566\";\n      Preferences.set(\"android.emulator.port\", portString);\n    }\n\n    // # starts and uses port 5554 for communication (ut not logs)\n    // emulator -avd gee1 -port 5554\n    // # only informative messages and up (emulator -help-logcat for more info)\n    // emulator -avd gee1 -logcat '*:i'\n    // # faster boot\n    // emulator -avd gee1 -logcat '*:i' -no-boot-anim\n    // # only get System.out and System.err\n    // emulator -avd gee1 -logcat 'System.*:i' -no-boot-anim\n    // # though lots of messages aren't through System.*, so that's not great\n    // # need to instead use the adb interface\n\n    // launch emulator because it's not running yet\n    final String[] cmd = new String[] {\n      \"emulator\", \"-avd\", AVD.ECLAIR.name, \"-port\", portString, \"-no-boot-anim\" };\n    System.err.println(\"Launching emulator\");\n    final Process p = Runtime.getRuntime().exec(cmd);\n    // \"emulator: ERROR: the user data image is used by another emulator. aborting\"\n    // make sure that the streams are drained properly\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        p.destroy();\n      }\n    });\n    new StreamPump(p.getInputStream()).addTarget(System.out).start();\n    new StreamPump(p.getErrorStream()).addTarget(System.err).start();\n    new Thread(new Runnable() {\n      public void run() {\n        try {\n          System.err.println(\"Starting to wait for emulator process.\");\n          final int result = p.waitFor();\n          System.err.println(\"Emulator process exited with \" + result);\n        } catch (final InterruptedException e) {\n          System.err.println(\"Emulator interrupted.\");\n        }\n      }\n    }, \"Emulator Babysitter\").start();\n  }","id":29941,"modified_method":"static void launch() throws IOException {\n    String portString = Preferences.get(\"android.emulator.port\");\n    if (portString == null) {\n      portString = \"5566\";\n      Preferences.set(\"android.emulator.port\", portString);\n    }\n\n    // # starts and uses port 5554 for communication (ut not logs)\n    // emulator -avd gee1 -port 5554\n    // # only informative messages and up (emulator -help-logcat for more info)\n    // emulator -avd gee1 -logcat '*:i'\n    // # faster boot\n    // emulator -avd gee1 -logcat '*:i' -no-boot-anim\n    // # only get System.out and System.err\n    // emulator -avd gee1 -logcat 'System.*:i' -no-boot-anim\n    // # though lots of messages aren't through System.*, so that's not great\n    // # need to instead use the adb interface\n\n    // launch emulator because it's not running yet\n    final String[] cmd = new String[] {\n      \"emulator\", \"-avd\", AVD.ECLAIR.name, \"-port\", portString, \"-no-boot-anim\" };\n    System.err.println(\"Launching emulator\");\n    final Process p = Runtime.getRuntime().exec(cmd);\n    // \"emulator: ERROR: the user data image is used by another emulator. aborting\"\n    // make sure that the streams are drained properly\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        p.destroy();\n      }\n    });\n    new StreamPump(p.getInputStream()).addTarget(System.out).start();\n    new StreamPump(p.getErrorStream()).addTarget(System.err).start();\n    new Thread(new Runnable() {\n      public void run() {\n        try {\n          System.err.println(\"Starting to wait for emulator process.\");\n          final int result = p.waitFor();\n          System.err.println(\"Emulator process exited \"\n              + ((result == 0) ? \"normally\" : \" with status \" + result) + \".\");\n        } catch (final InterruptedException e) {\n          System.err.println(\"Emulator was interrupted.\");\n        }\n      }\n    }, \"Emulator Babysitter\").start();\n  }","commit_id":"f83aea0944f634c3c5b7419ebd24bb2f5d704b1a","url":"https://github.com/processing/processing"},{"original_method":"private void configureGantStarter(JavaParameters params, final Module module) throws CantRunException {\n    // add GantStarter parameters\n\n    String gantHome = GantConfigUtils.getInstance().getSDKInstallPath(module);\n    final String confpath = gantHome + GANT_STARTER_CONF;\n    params.getVMParametersList().add(DGROOVY_STARTER_CONF + confpath);\n\n    params.getProgramParametersList().add(\"--main\");\n    params.getProgramParametersList().add(GANT_MAIN);\n    params.getProgramParametersList().add(\"--conf\");\n    params.getProgramParametersList().add(confpath);\n    params.getProgramParametersList().add(\"--classpath\");\n\n    // Clear module libraries from JDK's occurrences\n    final JavaParameters tmp = new JavaParameters();\n    tmp.configureByModule(module, JavaParameters.JDK_AND_CLASSES);\n    StringBuffer buffer = RunnerUtil.getClearClassPathString(tmp, module);\n\n    params.getProgramParametersList().add(buffer.toString());\n    if (isDebugEnabled) {\n      params.getProgramParametersList().add(\"--debug\");\n    }\n\n    //addScriptEncodingSettings(params);\n  }","id":29942,"modified_method":"private void configureGantStarter(JavaParameters params, final Module module, String confpath) throws CantRunException {\n    params.getProgramParametersList().add(\"--main\");\n    params.getProgramParametersList().add(GANT_MAIN);\n    params.getProgramParametersList().add(\"--conf\");\n    params.getProgramParametersList().add(confpath);\n    params.getProgramParametersList().add(\"--classpath\");\n\n    // Clear module libraries from JDK's occurrences\n    final JavaParameters tmp = new JavaParameters();\n    tmp.configureByModule(module, JavaParameters.JDK_AND_CLASSES);\n    StringBuffer buffer = RunnerUtil.getClearClassPathString(tmp, module);\n\n    params.getProgramParametersList().add(buffer.toString());\n    if (isDebugEnabled) {\n      params.getProgramParametersList().add(\"--debug\");\n    }\n  }","commit_id":"640cf20241e0310fdfef89a1d5cdc5d3806544b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void configureJavaParams(JavaParameters params, Module module) throws CantRunException {\n\n    // Setting up classpath\n    RunnerUtil.configureScriptSystemClassPath(params, module);\n\n    params.setWorkingDirectory(getAbsoluteWorkDir());\n\n    //add starter configuration parameters\n    String gantHome = GantConfigUtils.getInstance().getSDKInstallPath(module);\n    final String confpath = gantHome + GANT_STARTER_CONF;\n\n    // -Dant.home\n    params.getVMParametersList().addParametersString(\"-Dant.home=\" + antHome);\n    // -Dgant.home\n    params.getVMParametersList().addParametersString(DGANT_HOME + \"\\\"\" + gantHome + \"\\\"\");\n    // -Dscript/name\n    params.getVMParametersList()\n      .addParametersString(DSCRIPT_NAME + \"\\\"\" + gantHome + File.separator + \"bin\" + File.separator + \"gant\" + \"\\\"\");\n    // -Dprogram.name\n    params.getVMParametersList().addParametersString(DPROGRAM_NAME + \"gant\");\n    // -Dgroovy.starter.conf\n    params.getVMParametersList().add(DGROOVY_STARTER_CONF + confpath);\n    // -Dgroovy.home\n    final String path = GroovyConfigUtils.getInstance().getSDKInstallPath(module);\n    params.getVMParametersList()\n      .add(DGROOVY_HOME + (path.length() == 0 ? GrailsConfigUtils.getInstance().getSDKInstallPath(module) : path));\n    // -Dtools.jar\n    Sdk jdk = params.getJdk();\n    if (jdk != null && jdk.getSdkType() instanceof JavaSdkType) {\n      String toolsPath = ((JavaSdkType)jdk.getSdkType()).getToolsPath(jdk);\n      if (toolsPath != null) {\n        params.getVMParametersList().add(DTOOLS_JAR + toolsPath);\n      }\n    }\n\n    // add user parameters\n    params.getVMParametersList().addParametersString(vmParams);\n\n    // set starter class\n    params.setMainClass(GANT_STARTER);\n  }","id":29943,"modified_method":"private void configureJavaParams(JavaParameters params, Module module, String confpath) throws CantRunException {\n    RunnerUtil.configureScriptSystemClassPath(params, module);\n\n    params.setWorkingDirectory(getAbsoluteWorkDir());\n\n    String gantHome = GantConfigUtils.getInstance().getSDKInstallPath(module);\n\n    params.getVMParametersList().addParametersString(\"-Dant.home=\" + antHome);\n    params.getVMParametersList().addParametersString(\"-Dgant.home=\" + \"\\\"\" + gantHome + \"\\\"\");\n    params.getVMParametersList().addParametersString(\"-Dscript.name=\" + \"\\\"\" + gantHome + File.separator + \"bin\" + File.separator + \"gant\" + \"\\\"\");\n    params.getVMParametersList().addParametersString(\"-Dprogram.name=\" + \"gant\");\n    params.getVMParametersList().add(GroovyScriptRunConfiguration.DGROOVY_STARTER_CONF + confpath);\n\n    params.getVMParametersList().add(GroovyScriptRunConfiguration.DGROOVY_HOME + LibrariesUtil.getGroovyHomePath(module));\n\n    // -Dtools.jar\n    Sdk jdk = params.getJdk();\n    if (jdk != null && jdk.getSdkType() instanceof JavaSdkType) {\n      String toolsPath = ((JavaSdkType)jdk.getSdkType()).getToolsPath(jdk);\n      if (toolsPath != null) {\n        params.getVMParametersList().add(GroovyScriptRunConfiguration.DTOOLS_JAR + toolsPath);\n      }\n    }\n\n    // add user parameters\n    params.getVMParametersList().addParametersString(vmParams);\n\n    // set starter class\n    params.setMainClass(GANT_STARTER);\n  }","commit_id":"640cf20241e0310fdfef89a1d5cdc5d3806544b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RunProfileState getState(@NotNull Executor executor, @NotNull ExecutionEnvironment environment) throws ExecutionException {\n    final Module module = getModule();\n    if (module == null) {\n      throw new ExecutionException(\"Module is not specified\");\n    }\n\n    if (!GroovyConfigUtils.getInstance().isSDKConfiguredToRun(module) && !GrailsConfigUtils.getInstance().isSDKConfiguredToRun(module)) {\n      //throw new ExecutionException(\"Gant is not configured\");\n      Messages.showErrorDialog(module.getProject(),\n                               ExecutionBundle.message(\"error.running.configuration.with.error.error.message\", getName(),\n                                                       \"Groovy is not configured\"), ExecutionBundle.message(\"run.error.message.title\"));\n\n      ModulesConfigurator.showDialog(module.getProject(), module.getName(), ClasspathEditor.NAME, false);\n      return null;\n    }\n\n    if (!GantConfigUtils.getInstance().isSDKConfiguredToRun(module)) {\n      //throw new ExecutionException(\"Gant is not configured\");\n      Messages.showErrorDialog(module.getProject(),\n                               ExecutionBundle.message(\"error.running.configuration.with.error.error.message\", getName(),\n                                                       \"Gant is not configured\"), ExecutionBundle.message(\"run.error.message.title\"));\n\n      int result = Messages\n        .showOkCancelDialog(GantBundle.message(\"gant.configure.facet.question.text\"), GantBundle.message(\"gant.configure.facet.question\"),\n                            GantIcons.GANT_ICON_16x16);\n      if (result == 0) {\n        ModulesConfigurator.showDialog(module.getProject(), module.getName(), ClasspathEditor.NAME, false);\n      }\n      return null;\n    }\n\n    final ModuleRootManager rootManager = ModuleRootManager.getInstance(module);\n    final Sdk sdk = rootManager.getSdk();\n    if (sdk == null || !(sdk.getSdkType() instanceof JavaSdkType)) {\n      throw CantRunException.noJdkForModule(getModule());\n    }\n\n    final JavaCommandLineState state = new JavaCommandLineState(environment) {\n      protected JavaParameters createJavaParameters() throws ExecutionException {\n        JavaParameters params = new JavaParameters();\n\n        configureJavaParams(params, module);\n        configureGantStarter(params, module);\n        configureScript(params);\n\n        return params;\n      }\n    };\n\n    state.setConsoleBuilder(TextConsoleBuilderFactory.getInstance().createBuilder(getProject()));\n    return state;\n\n  }","id":29944,"modified_method":"@Nullable\n  public RunProfileState getState(@NotNull Executor executor, @NotNull ExecutionEnvironment environment) throws ExecutionException {\n    final Module module = getModule();\n    if (module == null) {\n      throw new ExecutionException(\"Module is not specified\");\n    }\n\n    if (LibrariesUtil.getGroovyHomePath(module) == null) {\n      //throw new ExecutionException(\"Gant is not configured\");\n      Messages.showErrorDialog(module.getProject(),\n                               ExecutionBundle.message(\"error.running.configuration.with.error.error.message\", getName(),\n                                                       \"Groovy is not configured\"), ExecutionBundle.message(\"run.error.message.title\"));\n\n      ModulesConfigurator.showDialog(module.getProject(), module.getName(), ClasspathEditor.NAME, false);\n      return null;\n    }\n\n    if (!GantConfigUtils.getInstance().isSDKConfiguredToRun(module)) {\n      int result = Messages\n        .showOkCancelDialog(GantBundle.message(\"gant.configure.facet.question.text\"), GantBundle.message(\"gant.configure.facet.question\"),\n                            GantIcons.GANT_ICON_16x16);\n      if (result == 0) {\n        ModulesConfigurator.showDialog(module.getProject(), module.getName(), ClasspathEditor.NAME, false);\n      }\n      if (!GantConfigUtils.getInstance().isSDKConfiguredToRun(module)) {\n        return null;\n      }\n    }\n\n    final ModuleRootManager rootManager = ModuleRootManager.getInstance(module);\n    final Sdk sdk = rootManager.getSdk();\n    if (sdk == null || !(sdk.getSdkType() instanceof JavaSdkType)) {\n      throw CantRunException.noJdkForModule(module);\n    }\n\n    final JavaCommandLineState state = new JavaCommandLineState(environment) {\n      protected JavaParameters createJavaParameters() throws ExecutionException {\n        JavaParameters params = new JavaParameters();\n\n        String gantHome = GantConfigUtils.getInstance().getSDKInstallPath(module);\n        String confpath = gantHome + GANT_STARTER_CONF;\n        if (!new File(confpath).exists()) {\n          confpath = GroovyScriptRunConfiguration.getConfPath(gantHome);\n        }\n\n        configureJavaParams(params, module, confpath);\n        configureGantStarter(params, module, confpath);\n        configureScript(params);\n\n        return params;\n      }\n    };\n\n    state.setConsoleBuilder(TextConsoleBuilderFactory.getInstance().createBuilder(getProject()));\n    return state;\n\n  }","commit_id":"640cf20241e0310fdfef89a1d5cdc5d3806544b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getConfPath(String groovyHome) {\n    String confpath = groovyHome + GROOVY_STARTER_CONF;\n    if (new File(confpath).exists()) {\n      return confpath;\n    }\n\n    try {\n      final String jarPath = PathUtil.getJarPathForClass(getClass());\n      if (new File(jarPath).isFile()) { //jar; distribution mode\n        return new File(jarPath, \"../groovy-starter.conf\").getCanonicalPath();\n      }\n\n      //else, it's directory in out, development mode\n      return new File(jarPath, \"conf/groovy-starter.conf\").getCanonicalPath();\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","id":29945,"modified_method":"public static String getConfPath(String groovyHome) {\n    String confpath = groovyHome + GROOVY_STARTER_CONF;\n    if (new File(confpath).exists()) {\n      return confpath;\n    }\n\n    try {\n      final String jarPath = PathUtil.getJarPathForClass(GroovyScriptRunConfiguration.class);\n      if (new File(jarPath).isFile()) { //jar; distribution mode\n        return new File(jarPath, \"../groovy-starter.conf\").getCanonicalPath();\n      }\n\n      //else, it's directory in out, development mode\n      return new File(jarPath, \"conf/groovy-starter.conf\").getCanonicalPath();\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"640cf20241e0310fdfef89a1d5cdc5d3806544b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getGroovyOrGrailsLibraryHome(VirtualFile[] classRoots) {\n    String path = \"\";\n    for (VirtualFile file : classRoots) {\n      if (GroovyConfigUtils.isGroovyAllJar(file.getName())) {\n        String jarPath = file.getPresentableUrl();\n        File realFile = new File(jarPath);\n        if (realFile.exists()) {\n          File parentFile = realFile.getParentFile();\n          if (parentFile != null) {\n            if (parentFile.isDirectory() && !(\"lib\".equals(parentFile.getName()) || \"embeddable\".equals(parentFile.getName())) /*for non-traditional distributions*/) {\n              path = parentFile.getPath();\n            }\n            else {\n              File libHome = parentFile.getParentFile();\n              if (libHome != null) {\n                path = libHome.getPath();\n              }\n            }\n          }\n        }\n      }\n    }\n    return path;\n  }","id":29946,"modified_method":"public static String getGroovyOrGrailsLibraryHome(VirtualFile[] classRoots) {\n    for (VirtualFile file : classRoots) {\n      if (GroovyConfigUtils.isGroovyAllJar(file.getName())) {\n        String jarPath = file.getPresentableUrl();\n        File realFile = new File(jarPath);\n        if (realFile.exists()) {\n          File parentFile = realFile.getParentFile();\n          if (parentFile != null) {\n            if (parentFile.isDirectory() && !(\"lib\".equals(parentFile.getName()) || \"embeddable\".equals(parentFile.getName())) /*for non-traditional distributions*/) {\n              return parentFile.getPath();\n            }\n            else {\n              File libHome = parentFile.getParentFile();\n              if (libHome != null) {\n                return libHome.getPath();\n              }\n            }\n          }\n        }\n      }\n    }\n    return \"\";\n  }","commit_id":"640cf20241e0310fdfef89a1d5cdc5d3806544b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void patchJavaParameters(@Nullable final Module module, JavaParameters javaParameters) {\n    if (module != null && PsiUtil.isIdeaProject(module.getProject()) &&\n        !javaParameters.getVMParametersList().hasParameter(JAVA_SYSTEM_CLASS_LOADER_PROPERTY)) {\n      final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(module.getProject());\n      final String qualifiedName = UrlClassLoader.class.getName();\n      final PsiClass urlLoaderClass = ApplicationManager.getApplication().runReadAction(new Computable<PsiClass>() {\n        @Override\n        public PsiClass compute() {\n          return psiFacade.findClass(qualifiedName, GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module));\n        }\n      });\n      if (urlLoaderClass != null) {\n        javaParameters.getVMParametersList().add(\"-D\" + JAVA_SYSTEM_CLASS_LOADER_PROPERTY + \"=\" + UrlClassLoader.class.getName());\n      }\n    }\n    Sdk jdk = javaParameters.getJdk();\n    jdk = IdeaJdk.findIdeaJdk(jdk);\n    if (jdk == null) return;\n\n    @NonNls String libPath = jdk.getHomePath() + File.separator + \"lib\";\n    \n    final ParametersList vm = javaParameters.getVMParametersList();\n    vm.add(\"-Xbootclasspath/a:\" + libPath + File.separator + \"boot.jar\");\n    if (!vm.hasProperty(\"idea.load.plugins.id\") && module != null && PluginModuleType.isOfType(module)) {\n      final String id = DescriptorUtil.getPluginId(module);\n      if (id != null) {\n        vm.defineProperty(\"idea.load.plugins.id\", id);\n      }\n    }\n\n    final File sandboxHome = getSandboxPath(jdk);\n    if (sandboxHome != null) {\n      if (!vm.hasProperty(\"idea.home.path\")) {\n        File homeDir = new File(sandboxHome, \"test\");\n        FileUtil.createDirectory(homeDir);\n        vm.defineProperty(\"idea.home.path\", homeDir.getAbsolutePath());\n      }\n      if (!vm.hasProperty(\"idea.plugins.path\")) {\n        vm.defineProperty(\"idea.plugins.path\", new File(sandboxHome, \"plugins\").getAbsolutePath());\n      }\n    }\n\n    javaParameters.getClassPath().addFirst(libPath + File.separator + \"idea.jar\");\n    javaParameters.getClassPath().addFirst(libPath + File.separator + \"resources.jar\");\n    javaParameters.getClassPath().addFirst(((JavaSdkType)jdk.getSdkType()).getToolsPath(jdk));\n  }","id":29947,"modified_method":"public void patchJavaParameters(@Nullable final Module module, JavaParameters javaParameters) {\n    if (module != null && PsiUtil.isIdeaProject(module.getProject()) && !javaParameters.getVMParametersList().hasParameter(SYSTEM_CL_PROPERTY)) {\n      final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(module.getProject());\n      final String qualifiedName = UrlClassLoader.class.getName();\n      final PsiClass urlLoaderClass = ApplicationManager.getApplication().runReadAction(new Computable<PsiClass>() {\n        @Override\n        public PsiClass compute() {\n          return psiFacade.findClass(qualifiedName, GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module));\n        }\n      });\n      if (urlLoaderClass != null) {\n        javaParameters.getVMParametersList().addProperty(SYSTEM_CL_PROPERTY, qualifiedName);\n      }\n    }\n    Sdk jdk = javaParameters.getJdk();\n    jdk = IdeaJdk.findIdeaJdk(jdk);\n    if (jdk == null) return;\n\n    String libPath = jdk.getHomePath() + File.separator + \"lib\";\n    \n    final ParametersList vm = javaParameters.getVMParametersList();\n    vm.add(\"-Xbootclasspath/a:\" + libPath + File.separator + \"boot.jar\");\n    if (!vm.hasProperty(\"idea.load.plugins.id\") && module != null && PluginModuleType.isOfType(module)) {\n      final String id = DescriptorUtil.getPluginId(module);\n      if (id != null) {\n        vm.defineProperty(\"idea.load.plugins.id\", id);\n      }\n    }\n\n    final File sandboxHome = getSandboxPath(jdk);\n    if (sandboxHome != null) {\n      if (!vm.hasProperty(\"idea.home.path\")) {\n        File homeDir = new File(sandboxHome, \"test\");\n        FileUtil.createDirectory(homeDir);\n        vm.defineProperty(\"idea.home.path\", homeDir.getAbsolutePath());\n      }\n      if (!vm.hasProperty(\"idea.plugins.path\")) {\n        vm.defineProperty(\"idea.plugins.path\", new File(sandboxHome, \"plugins\").getAbsolutePath());\n      }\n    }\n\n    javaParameters.getClassPath().addFirst(libPath + File.separator + \"idea.jar\");\n    javaParameters.getClassPath().addFirst(libPath + File.separator + \"resources.jar\");\n    javaParameters.getClassPath().addFirst(((JavaSdkType)jdk.getSdkType()).getToolsPath(jdk));\n  }","commit_id":"9e77cfdff7209a21b945be59fa461c6860621851","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static File getSandboxPath(final Sdk jdk) {\n    String sandboxHome = ((Sandbox)jdk.getSdkAdditionalData()).getSandboxHome();\n    if (sandboxHome != null) {\n      try {\n        return new File(sandboxHome).getCanonicalFile();\n      }\n      catch (IOException e) {\n        return new File(sandboxHome).getAbsoluteFile();\n      }\n    }\n    return null;\n  }","id":29948,"modified_method":"@Nullable\n  private static File getSandboxPath(final Sdk jdk) {\n    SdkAdditionalData additionalData = jdk.getSdkAdditionalData();\n    if (additionalData instanceof Sandbox) {\n      String sandboxHome = ((Sandbox)additionalData).getSandboxHome();\n      if (sandboxHome != null) {\n        return new File(FileUtil.toCanonicalPath(sandboxHome));\n      }\n    }\n\n    return null;\n  }","commit_id":"9e77cfdff7209a21b945be59fa461c6860621851","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void resizeFile(long newSize) throws IOException {\n    RandomAccessFile raf = new RandomAccessFile(myFile, RW);\n    mySize = -1;\n    try {\n      raf.setLength(newSize);\n    }\n    finally {\n      raf.close();\n    }\n    mySize = newSize;\n  }","id":29949,"modified_method":"private void resizeFile(long newSize) throws IOException {\n    mySize = -1;\n    RandomAccessFile raf = new RandomAccessFile(myFile, RW);\n    try {\n      raf.setLength(newSize);\n    }\n    finally {\n      raf.close();\n    }\n    mySize = newSize;\n  }","commit_id":"9e77cfdff7209a21b945be59fa461c6860621851","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    private ByteBufferWrapper createValue(Integer key) {\n      final int storageIndex = key & FILE_INDEX_MASK;\n      PagedFileStorage owner = getRegisteredPagedFileStorageByIndex(storageIndex);\n      assert owner != null: \"No storage for index \" + storageIndex;\n      checkThreadAccess(owner.myStorageLockContext);\n      long off = (long)(key & MAX_PAGES_COUNT) * owner.myPageSize;\n      long ownerLength = owner.length();\n      if (off > ownerLength) {\n        throw new IndexOutOfBoundsException(\"off=\" + off + \" key.owner.length()=\" + ownerLength);\n      }\n\n      int min = (int)Math.min(ownerLength - off, owner.myPageSize);\n      ByteBufferWrapper wrapper = ByteBufferWrapper.readWriteDirect(owner.myFile, off, min);\n      Throwable oome = null;\n      while (true) {\n        try {\n          // ensure it's allocated\n          wrapper.getBuffer();\n          if (oome != null) {\n            LOG.info(\"Successfully recovered OOME in memory mapping: -Xmx=\" + Runtime.getRuntime().maxMemory() / MB + \"MB \" +\n                     \"new size limit: \" + mySizeLimit / MB + \"MB \" +\n                     \"trying to allocate \" + wrapper.myLength + \" block\");\n          }\n          return wrapper;\n        }\n        catch (IOException e) {\n          throw new MappingFailedException(\"Cannot map buffer\", e);\n        } catch (OutOfMemoryError e) {\n          oome = e;\n          if (mySizeLimit > LOWER_LIMIT) {\n            mySizeLimit -= owner.myPageSize;\n          }\n          long newSize = mySize - owner.myPageSize;\n          if (newSize < 0) {\n            LOG.info(\"Currently allocated:\"+mySize);\n            LOG.info(\"Mapping failed due to OOME. Current buffers: \" + mySegments);\n            LOG.info(oome);\n            try {\n              Class<?> aClass = Class.forName(\"java.nio.Bits\");\n              Field reservedMemory = aClass.getDeclaredField(\"reservedMemory\");\n              reservedMemory.setAccessible(true);\n              Field maxMemory = aClass.getDeclaredField(\"maxMemory\");\n              maxMemory.setAccessible(true);\n              synchronized (aClass) {\n                LOG.info(\"Max memory:\"+maxMemory.get(null) + \", reserved memory:\" + reservedMemory.get(null));\n              }\n            }\n            catch (Throwable t) {\n\n            }\n            throw new MappingFailedException(\n              \"Cannot recover from OOME in memory mapping: -Xmx=\" + Runtime.getRuntime().maxMemory() / MB + \"MB \" +\n              \"new size limit: \" + mySizeLimit / MB + \"MB \" +\n              \"trying to allocate \" + wrapper.myLength + \" block\", e);\n          }\n          ensureSize(newSize); // next try\n        }\n      }\n    }","id":29950,"modified_method":"@NotNull\n    private ByteBufferWrapper createValue(Integer key) {\n      final int storageIndex = key & FILE_INDEX_MASK;\n      PagedFileStorage owner = getRegisteredPagedFileStorageByIndex(storageIndex);\n      assert owner != null: \"No storage for index \" + storageIndex;\n      checkThreadAccess(owner.myStorageLockContext);\n      long off = (long)(key & MAX_PAGES_COUNT) * owner.myPageSize;\n      long ownerLength = owner.length();\n      if (off > ownerLength) {\n        throw new IndexOutOfBoundsException(\"off=\" + off + \" key.owner.length()=\" + ownerLength);\n      }\n\n      int min = (int)Math.min(ownerLength - off, owner.myPageSize);\n      ByteBufferWrapper wrapper = ByteBufferWrapper.readWriteDirect(owner.myFile, off, min);\n      Throwable oome = null;\n      while (true) {\n        try {\n          // ensure it's allocated\n          wrapper.getBuffer();\n          if (oome != null) {\n            LOG.info(\"Successfully recovered OOME in memory mapping: -Xmx=\" + Runtime.getRuntime().maxMemory() / MB + \"MB \" +\n                     \"new size limit: \" + mySizeLimit / MB + \"MB \" +\n                     \"trying to allocate \" + wrapper.myLength + \" block\");\n          }\n          return wrapper;\n        }\n        catch (IOException e) {\n          throw new MappingFailedException(\"Cannot map buffer\", e);\n        }\n        catch (OutOfMemoryError e) {\n          oome = e;\n          if (mySizeLimit > LOWER_LIMIT) {\n            mySizeLimit -= owner.myPageSize;\n          }\n          long newSize = mySize - owner.myPageSize;\n          if (newSize < 0) {\n            LOG.info(\"Currently allocated:\"+mySize);\n            LOG.info(\"Mapping failed due to OOME. Current buffers: \" + mySegments);\n            LOG.info(oome);\n            try {\n              Class<?> aClass = Class.forName(\"java.nio.Bits\");\n              Field reservedMemory = aClass.getDeclaredField(\"reservedMemory\");\n              reservedMemory.setAccessible(true);\n              Field maxMemory = aClass.getDeclaredField(\"maxMemory\");\n              maxMemory.setAccessible(true);\n              Object max, reserved;\n              //noinspection SynchronizationOnLocalVariableOrMethodParameter\n              synchronized (aClass) {\n                max = maxMemory.get(null);\n                reserved = reservedMemory.get(null);\n              }\n              LOG.info(\"Max memory:\" + max + \", reserved memory:\" + reserved);\n            }\n            catch (Throwable ignored) { }\n            throw new MappingFailedException(\n              \"Cannot recover from OOME in memory mapping: -Xmx=\" + Runtime.getRuntime().maxMemory() / MB + \"MB \" +\n              \"new size limit: \" + mySizeLimit / MB + \"MB \" +\n              \"trying to allocate \" + wrapper.myLength + \" block\", e);\n          }\n          ensureSize(newSize); // next try\n        }\n      }\n    }","commit_id":"9e77cfdff7209a21b945be59fa461c6860621851","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"IOResourceOpenedButNotSafelyClosed\"})\n  public Map<CompilerMessageCategory, List<String>> execute(@NotNull Module module,\n                                                            @NotNull IAndroidTarget target,\n                                                            @NotNull String outputDir,\n                                                            @NotNull String... compileTargets) {\n    String outFile = outputDir + File.separatorChar + \"classes.dex\";\n\n    final Map<CompilerMessageCategory, List<String>> messages = new HashMap<CompilerMessageCategory, List<String>>(2);\n    messages.put(CompilerMessageCategory.ERROR, new ArrayList<String>());\n    messages.put(CompilerMessageCategory.INFORMATION, new ArrayList<String>());\n    messages.put(CompilerMessageCategory.WARNING, new ArrayList<String>());\n\n    String dxJarPath = target.getPath(IAndroidTarget.DX_JAR);\n    File dxJar = new File(dxJarPath);\n    if (!dxJar.isFile()) {\n      messages.get(CompilerMessageCategory.ERROR).add(AndroidBundle.message(\"android.file.not.exist.error\", dxJarPath));\n      return messages;\n    }\n\n    JavaParameters parameters = new JavaParameters();\n    Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n\n    // dex runs after simple java compilation, so JDK must be specified\n    assert sdk != null;\n\n    parameters.setJdk(sdk);\n    parameters.setMainClass(DEX_MAIN);\n    ParametersList params = parameters.getProgramParametersList();\n    //params.add(\"--verbose\");\n    params.add(\"--no-strict\");\n    params.add(\"--output=\" + outFile);\n    params.addAll(compileTargets);\n    parameters.getVMParametersList().add(\"-Xmx1024M\");\n    parameters.getClassPath().add(dxJar);\n    Process process = null;\n    try {\n      GeneralCommandLine commandLine = CommandLineBuilder.createFromJavaParameters(parameters, true);\n      LOG.info(commandLine.getCommandLineString());\n      process = commandLine.createProcess();\n    }\n    catch (ExecutionException e) {\n      messages.get(CompilerMessageCategory.ERROR).add(\"ExecutionException: \" + e.getMessage());\n      LOG.info(e);\n    }\n\n    final OSProcessHandler handler = new OSProcessHandler(process, \"\");\n    handler.addProcessListener(new ProcessAdapter() {\n      @Override\n      public void onTextAvailable(ProcessEvent event, Key outputType) {\n        String[] msgs = event.getText().split(\"\\\\n\");\n        for (String msg : msgs) {\n          msg = msg.trim();\n          if (outputType == ProcessOutputTypes.STDERR) {\n            if (msg.toLowerCase().startsWith(\"warning\")) {\n              messages.get(CompilerMessageCategory.WARNING).add(msg);\n            }\n            else {\n              messages.get(CompilerMessageCategory.ERROR).add(msg);\n            }\n          }\n          else if (outputType == ProcessOutputTypes.STDOUT) {\n            if (!msg.toLowerCase().startsWith(\"processing\")) {\n              messages.get(CompilerMessageCategory.INFORMATION).add(msg);\n            }\n          }\n          LOG.info(msg);\n        }\n      }\n    });\n\n    handler.startNotify();\n    handler.waitFor();\n\n    return messages;\n  }","id":29951,"modified_method":"@SuppressWarnings({\"IOResourceOpenedButNotSafelyClosed\"})\n  public Map<CompilerMessageCategory, List<String>> execute(@NotNull Module module,\n                                                            @NotNull IAndroidTarget target,\n                                                            @NotNull String outputDir,\n                                                            @NotNull String... compileTargets) {\n    String outFile = outputDir + File.separatorChar + \"classes.dex\";\n\n    final Map<CompilerMessageCategory, List<String>> messages = new HashMap<CompilerMessageCategory, List<String>>(2);\n    messages.put(CompilerMessageCategory.ERROR, new ArrayList<String>());\n    messages.put(CompilerMessageCategory.INFORMATION, new ArrayList<String>());\n    messages.put(CompilerMessageCategory.WARNING, new ArrayList<String>());\n\n    String dxJarPath = target.getPath(IAndroidTarget.DX_JAR);\n    File dxJar = new File(dxJarPath);\n    if (!dxJar.isFile()) {\n      messages.get(CompilerMessageCategory.ERROR).add(AndroidBundle.message(\"android.file.not.exist.error\", dxJarPath));\n      return messages;\n    }\n\n    JavaParameters parameters = new JavaParameters();\n    Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n\n    // dex runs after simple java compilation, so JDK must be specified\n    assert sdk != null;\n\n    parameters.setJdk(sdk);\n    parameters.setMainClass(DEX_MAIN);\n    ParametersList programParamList = parameters.getProgramParametersList();\n    //params.add(\"--verbose\");\n    programParamList.add(\"--no-strict\");\n    programParamList.add(\"--output=\" + outFile);\n    programParamList.addAll(compileTargets);\n    ParametersList vmParamList = parameters.getVMParametersList();\n\n    AndroidDexCompilerConfiguration configuration = AndroidDexCompilerConfiguration.getInstance(module.getProject());\n    String additionalVmParams = configuration.VM_OPTIONS;\n    if (additionalVmParams.length() > 0) {\n      vmParamList.addParametersString(additionalVmParams);\n    }\n    if (!hasXmxParam(vmParamList)) {\n      vmParamList.add(\"-Xmx\" + configuration.MAX_HEAP_SIZE + \"M\");\n    }\n    parameters.getClassPath().add(dxJar);\n    Process process = null;\n    try {\n      GeneralCommandLine commandLine = CommandLineBuilder.createFromJavaParameters(parameters, true);\n      LOG.info(commandLine.getCommandLineString());\n      process = commandLine.createProcess();\n    }\n    catch (ExecutionException e) {\n      messages.get(CompilerMessageCategory.ERROR).add(\"ExecutionException: \" + e.getMessage());\n      LOG.info(e);\n    }\n\n    final OSProcessHandler handler = new OSProcessHandler(process, \"\");\n    handler.addProcessListener(new ProcessAdapter() {\n      @Override\n      public void onTextAvailable(ProcessEvent event, Key outputType) {\n        String[] msgs = event.getText().split(\"\\\\n\");\n        for (String msg : msgs) {\n          msg = msg.trim();\n          if (outputType == ProcessOutputTypes.STDERR) {\n            if (msg.toLowerCase().startsWith(\"warning\")) {\n              messages.get(CompilerMessageCategory.WARNING).add(msg);\n            }\n            else {\n              messages.get(CompilerMessageCategory.ERROR).add(msg);\n            }\n          }\n          else if (outputType == ProcessOutputTypes.STDOUT) {\n            if (!msg.toLowerCase().startsWith(\"processing\")) {\n              messages.get(CompilerMessageCategory.INFORMATION).add(msg);\n            }\n          }\n          LOG.info(msg);\n        }\n      }\n    });\n\n    handler.startNotify();\n    handler.waitFor();\n\n    return messages;\n  }","commit_id":"16904399545d8091d9276b8c476e5147006c74a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComponent getResourceListPane() {\n        Vector columnNamesVector = new Vector();\n        columnNamesVector.add(\"Selection\");\n        columnNamesVector.add(\"Display Name\");\n        columnNamesVector.add(\"Size \");\n        columnNamesVector.add(\"Status\");\n        resourceVector = new Vector();   \n        setLocalResourceVector(resourceVector,VUE.getActiveMap());\n        resourceTableModel = new ResourceTableModel(resourceVector, columnNamesVector);\n        resourceTable = new JTable(resourceTableModel);\n        resourceTable.setPreferredScrollableViewportSize(new Dimension(500,100));\n      //  resourceList.setDefaultRenderer(String.class,resourceTableCellRenderer);\n        return new JScrollPane(resourceTable);  \n    }","id":29952,"modified_method":"private JComponent getResourceListPane() {\n        Vector columnNamesVector = new Vector();\n        columnNamesVector.add(\"Selection\");\n        columnNamesVector.add(\"Display Name\");\n        columnNamesVector.add(\"Size \");\n        columnNamesVector.add(\"Status\");\n        resourceVector = new Vector();   \n        setLocalResourceVector(resourceVector,VUE.getActiveMap());\n        resourceTableModel = new ResourceTableModel(resourceVector, columnNamesVector);\n        resourceTable = new JTable(resourceTableModel);\n        \n        // setting the cell sizes\n        TableColumn column = null;\n        Component comp = null;\n        int headerWidth;\n        int cellWidth;\n        TableCellRenderer headerRenderer = resourceTable.getTableHeader().getDefaultRenderer();\n        resourceTable.getColumnModel().getColumn(0).setPreferredWidth(12);\n        for (int i = 1; i < 4; i++) {\n            column = resourceTable.getColumnModel().getColumn(i);\n            comp = headerRenderer.getTableCellRendererComponent(null, column.getHeaderValue(),false, false, 0, 0);\n            headerWidth = comp.getPreferredSize().width;\n           // comp = resourceTable.getDefaultRenderer(resourceTableModel.getColumnClass(i)).getTableCellRendererComponent(resourceTable,resourceTableModel.longValues[i],false, false, 0, i);\n            cellWidth = resourceTableModel.longValues[i].length();\n            column.setPreferredWidth(Math.max(headerWidth, cellWidth));\n       }\n        resourceTable.setPreferredScrollableViewportSize(new Dimension(500,100));\n      //  resourceList.setDefaultRenderer(String.class,resourceTableCellRenderer);\n        return new JScrollPane(resourceTable);  \n    }","commit_id":"38879610d28d1655d507214df616491435ae9b7a","url":"https://github.com/VUE/VUE"},{"original_method":"public void publishCMap() {\n        try {\n            File savedCMap = createIMSCP();\n            Properties metadata = new Properties();\n            String pid = getDR().ingest(savedCMap.getName(), \"obj-vue-concept-map-mc.xml\", savedCMap, metadata).getIdString();\n          \n            System.out.println(\"Published CMap: id = \"+pid);\n        } catch (Exception ex) {\n             VueUtil.alert(null, \"Publish Not Supported:\"+ex.getMessage(), \"Publish Error\");\n        }\n   \n    }","id":29953,"modified_method":"public void publishCMap() {\n        try {\n            File savedCMap = createIMSCP();\n            Properties metadata = new Properties();\n            String pid = getDR().ingest(savedCMap.getName(), \"obj-vue-concept-map-mc.xml\", savedCMap, metadata).getIdString();\n          \n            System.out.println(\"Published CMap: id = \"+pid);\n        } catch (Exception ex) {\n             VueUtil.alert(null, \"Publish Not Supported:\"+ex.getMessage(), \"Publish Error\");\n             ex.printStackTrace();\n        }\n   \n    }","commit_id":"38879610d28d1655d507214df616491435ae9b7a","url":"https://github.com/VUE/VUE"},{"original_method":"private void setLocalResourceVector(Vector vector,LWContainer map) {\n       Iterator i = map.getChildIterator();\n       while(i.hasNext()) {\n           LWComponent component = (LWComponent) i.next();\n           if(component.hasResource()){\n               Resource resource = component.getResource();\n               if(resource.getType() == Resource.FILE) {\n                    File file = new File(resource.getSpec());\n                    if(file.isFile()) {\n                        Vector row = new Vector();\n                        row.add(new Boolean(true));\n                        row.add(resource);\n                        row.add(new Long(file.length()));\n                        row.add(\"Ready\");\n                        vector.add(row);\n                    }\n               }\n           }\n           if(component instanceof LWContainer) {\n                setLocalResourceVector(vector,(LWContainer)component);\n           }\n       }\n    }","id":29954,"modified_method":"private void setLocalResourceVector(Vector vector,LWContainer map) {\n       Iterator i = map.getChildIterator();\n       while(i.hasNext()) {\n           LWComponent component = (LWComponent) i.next();\n           if(component.hasResource()){\n               Resource resource = component.getResource();\n               if(resource.getType() == Resource.URL) {\n                   try {\n                        System.out.println(\"Resource = \"+resource.getSpec());\n                        File file = new File(new URL(resource.getSpec()).getFile());\n                        if(file.isFile()) {\n                            Vector row = new Vector();\n                            row.add(new Boolean(true));\n                            row.add(resource.getSpec());\n                            row.add(new Long(file.length()));\n                            row.add(\"Ready\");\n                            vector.add(row);\n                        }\n                   }catch (Exception ex) {\n                       System.out.println(\"Publisher.setLocalResourceVector: Resource \"+resource.getSpec()+ ex);\n                   }\n               }\n           }\n           if(component instanceof LWContainer) {\n                setLocalResourceVector(vector,(LWContainer)component);\n           }\n       }\n    }","commit_id":"38879610d28d1655d507214df616491435ae9b7a","url":"https://github.com/VUE/VUE"},{"original_method":"private File createIMSCP() throws IOException,URISyntaxException {\n        \n        LWMap map = tufts.vue.VUE.getActiveMap();\n        IMSCP imscp = new IMSCP();\n        saveActiveMap();\n        System.out.println(\"Writing Active Map : \"+activeMapFile.getName());\n        imscp.putEntry(IMSCP.MAP_FILE,activeMapFile);        \n        Iterator i = resourceVector.iterator();       \n        while(i.hasNext()) {\n            Vector vector = (Vector)i.next();\n            Resource r = (Resource)(vector.elementAt(1));\n            Boolean b = (Boolean)(vector.elementAt(0));\n\n            File file = new File(r.getSpec());\n\n\n            if(file.isFile() && b.booleanValue()) {\n                 System.out.println(\"Resource = \" + r+\" FileName = \"+file.getName()+\" index =\"+resourceVector.indexOf(vector));\n                 resourceTable.setValueAt(\"Processing\",resourceVector.indexOf(vector),STATUS_COL);\n                 imscp.putEntry(IMSCP.RESOURCE_FILES+\"/\"+file.getName(),file);\n                 resourceTable.setValueAt(\"Done\",resourceVector.indexOf(vector),STATUS_COL);\n            }    \n           \n        }   \n        imscp.closeZOS();\n        return imscp.getFile();\n        \n    }","id":29955,"modified_method":"private File createIMSCP() throws IOException,URISyntaxException {\n        \n        LWMap map = tufts.vue.VUE.getActiveMap();\n        IMSCP imscp = new IMSCP();\n        saveActiveMap();\n        System.out.println(\"Writing Active Map : \"+activeMapFile.getName());\n        imscp.putEntry(IMSCP.MAP_FILE,activeMapFile);        \n        Iterator i = resourceVector.iterator();       \n        while(i.hasNext()) {\n            Vector vector = (Vector)i.next();\n            Boolean b = (Boolean)(vector.elementAt(0));\n            File file = new File((String)vector.elementAt(1));\n            if(file.isFile() && b.booleanValue()) {\n                 System.out.println(\"FileName = \"+file.getName()+\" index =\"+resourceVector.indexOf(vector));\n                 resourceTable.setValueAt(\"Processing\",resourceVector.indexOf(vector),STATUS_COL);\n                 imscp.putEntry(IMSCP.RESOURCE_FILES+\"/\"+file.getName(),file);\n                 resourceTable.setValueAt(\"Done\",resourceVector.indexOf(vector),STATUS_COL);\n            }    \n           \n        }   \n        imscp.closeZOS();\n        return imscp.getFile();\n        \n    }","commit_id":"38879610d28d1655d507214df616491435ae9b7a","url":"https://github.com/VUE/VUE"},{"original_method":"public static void main(String args[]) {\n        if(args.length != 1) {\n            System.err.println(\"Configurator <string>\");\n            System.exit(0);\n        }\n        String config_str=args[0];\n        Configurator conf=new Configurator();\n        Vector protocol_configs;\n        Vector protocols=null;\n        Protocol protocol_stack;\n\n\n        try {\n            protocol_configs=conf.parseConfigurations(config_str);\n            protocols=conf.createProtocols(protocol_configs, null);\n            if(protocols == null)\n                return;\n            protocol_stack=conf.connectProtocols(protocols);\n            Thread.sleep(3000);\n            conf.destroyProtocolStack(protocol_stack);\n            // conf.stopProtocolStackInternal(protocol_stack);\n        }\n        catch(Exception e) {\n            System.err.println(e);\n        }\n\n        System.err.println(protocols);\n    }","id":29956,"modified_method":"public static void main(String args[]) {\n        if(args.length != 1) {\n            System.err.println(\"Configurator <string>\");\n            System.exit(0);\n        }\n        String config_str=args[0];\n        Configurator conf=new Configurator();\n        Vector<ProtocolConfiguration> protocol_configs;\n        Vector<Protocol> protocols=null;\n        Protocol protocol_stack;\n\n\n        try {\n            protocol_configs=Configurator.parseConfigurations(config_str);\n            protocols=conf.createProtocols(protocol_configs, null);\n            if(protocols == null)\n                return;\n            protocol_stack=Configurator.connectProtocols(protocols);\n            Thread.sleep(3000);\n            Configurator.destroyProtocolStack(protocol_stack);\n            // conf.stopProtocolStackInternal(protocol_stack);\n        }\n        catch(Exception e) {\n            System.err.println(e);\n        }\n\n        System.err.println(protocols);\n    }","commit_id":"5885988996b3baf1311961a5bb6452e03d7ec9bc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Takes vector of ProtocolConfigurations, iterates through it, creates Protocol for\n     * each ProtocolConfiguration and returns all Protocols in a vector.\n     * @param protocol_configs Vector of ProtocolConfigurations\n     * @param stack The protocol stack\n     * @return Vector of Protocols\n     */\n    private Vector createProtocols(Vector protocol_configs, ProtocolStack stack) throws Exception {\n        Vector retval=new Vector();\n        ProtocolConfiguration protocol_config;\n        Protocol layer;\n\n        for(int i=0; i < protocol_configs.size(); i++) {\n            protocol_config=(ProtocolConfiguration)protocol_configs.elementAt(i);\n            layer=protocol_config.createLayer(stack);\n            if(layer == null)\n                return null;\n            retval.addElement(layer);\n        }\n        sanityCheck(retval);\n        return retval;\n    }","id":29957,"modified_method":"/**\n     * Takes vector of ProtocolConfigurations, iterates through it, creates Protocol for\n     * each ProtocolConfiguration and returns all Protocols in a vector.\n     * @param protocol_configs Vector of ProtocolConfigurations\n     * @param stack The protocol stack\n     * @return Vector of Protocols\n     */\n    private Vector<Protocol> createProtocols(Vector<ProtocolConfiguration> protocol_configs, ProtocolStack stack) throws Exception {\n        Vector<Protocol> retval=new Vector<Protocol>();\n        ProtocolConfiguration protocol_config;\n        Protocol layer;\n\n        for(int i=0; i < protocol_configs.size(); i++) {\n            protocol_config=protocol_configs.elementAt(i);\n            layer=protocol_config.createLayer(stack);\n            if(layer == null)\n                return null;\n            retval.addElement(layer);\n        }\n        sanityCheck(retval);\n        return retval;\n    }","commit_id":"5885988996b3baf1311961a5bb6452e03d7ec9bc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Return a number of ProtocolConfigurations in a vector\n     * @param configuration protocol-stack configuration string\n     * @return Vector of ProtocolConfigurations\n     */\n    public Vector parseConfigurations(String configuration) throws Exception {\n        Vector retval=new Vector();\n        Vector component_strings=parseComponentStrings(configuration, \":\");\n        String component_string;\n        ProtocolConfiguration protocol_config;\n\n        if(component_strings == null)\n            return null;\n        for(int i=0; i < component_strings.size(); i++) {\n            component_string=(String)component_strings.elementAt(i);\n            protocol_config=new ProtocolConfiguration(component_string);\n            retval.addElement(protocol_config);\n        }\n        return retval;\n    }","id":29958,"modified_method":"/**\n     * Return a number of ProtocolConfigurations in a vector\n     * @param configuration protocol-stack configuration string\n     * @return Vector of ProtocolConfigurations\n     */\n    public static Vector<ProtocolConfiguration> parseConfigurations(String configuration) throws Exception {\n        Vector<ProtocolConfiguration> retval=new Vector<ProtocolConfiguration>();\n        Vector protocol_string=parseProtocols(configuration);\n        String component_string;\n        ProtocolConfiguration protocol_config;\n\n        if(protocol_string == null)\n            return null;\n        for(int i=0; i < protocol_string.size(); i++) {\n            component_string=(String)protocol_string.elementAt(i);\n            protocol_config=new ProtocolConfiguration(component_string);\n            retval.addElement(protocol_config);\n        }\n        return retval;\n    }","commit_id":"5885988996b3baf1311961a5bb6452e03d7ec9bc","url":"https://github.com/belaban/JGroups"},{"original_method":"void setContents(String config_str) throws Exception {\n            int index=config_str.indexOf('(');  // e.g. \"UDP(in_port=3333)\"\n            int end_index=config_str.lastIndexOf(')');\n\n            if(index == -1) {\n                protocol_name=config_str;\n            }\n            else {\n                if(end_index == -1) {\n                    throw new Exception(\"Configurator.ProtocolConfiguration.setContents(): closing ')' \" +\n                                        \"not found in \" + config_str + \": properties cannot be set !\");\n                }\n                else {\n                    properties_str=config_str.substring(index + 1, end_index);\n                    protocol_name=config_str.substring(0, index);\n                }\n            }\n\n            /* \"in_port=5555;out_port=6666\" */\n            if(properties_str != null) {\n                Vector components=parseComponentStrings(properties_str, \";\");\n                if(!components.isEmpty()) {\n                    for(int i=0; i < components.size(); i++) {\n                        String name, value, comp=(String)components.elementAt(i);\n                        index=comp.indexOf('=');\n                        if(index == -1) {\n                            throw new Exception(\"Configurator.ProtocolConfiguration.setContents(): \" +\n                                                \"'=' not found in \" + comp);\n                        }\n                        name=comp.substring(0, index);\n                        value=comp.substring(index + 1, comp.length());\n                        properties.put(name, value);\n                    }\n                }\n            }\n        }","id":29959,"modified_method":"void setContents(String config_str) throws Exception {\n            int index=config_str.indexOf('(');  // e.g. \"UDP(in_port=3333)\"\n            int end_index=config_str.lastIndexOf(')');\n\n            if(index == -1) {\n                protocol_name=config_str;\n            }\n            else {\n                if(end_index == -1) {\n                    throw new Exception(\"Configurator.ProtocolConfiguration.setContents(): closing ')' \" +\n                                        \"not found in \" + config_str + \": properties cannot be set !\");\n                }\n                else {\n                    properties_str=config_str.substring(index + 1, end_index);\n                    protocol_name=config_str.substring(0, index);\n                }\n            }\n\n            /* \"in_port=5555;out_port=6666\" */\n            if(properties_str != null) {\n                String[] components=properties_str.split(\";\");\n                for(int i=0; i < components.length; i++) {\n                    String name, value, comp=components[i];\n                    index=comp.indexOf('=');\n                    if(index == -1) {\n                        throw new Exception(\"Configurator.ProtocolConfiguration.setContents(): '=' not found in \" + comp);\n                    }\n                    name=comp.substring(0, index);\n                    value=comp.substring(index + 1, comp.length());\n                    properties.put(name, value);\n                }\n            }\n        }","commit_id":"5885988996b3baf1311961a5bb6452e03d7ec9bc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Throws an exception if sanity check fails. Possible sanity check is uniqueness of all protocol\n     names.\n     */\n    public void sanityCheck(Vector protocols) throws Exception {\n        Vector names=new Vector();\n        Protocol prot;\n        String name;\n        ProtocolReq req;\n        Vector req_list=new Vector();\n        int evt_type;\n\n        // Checks for unique names\n        for(int i=0; i < protocols.size(); i++) {\n            prot=(Protocol)protocols.elementAt(i);\n            name=prot.getName();\n            for(int j=0; j < names.size(); j++) {\n                if(name.equals(names.elementAt(j))) {\n                    throw new Exception(\"Configurator.sanityCheck(): protocol name \" + name +\n                                        \" has been used more than once; protocol names have to be unique !\");\n                }\n            }\n            names.addElement(name);\n        }\n\n\n        // Checks whether all requirements of all layers are met\n        for(int i=0; i < protocols.size(); i++) {\n            prot=(Protocol)protocols.elementAt(i);\n            req=new ProtocolReq(prot.getName());\n            req.up_reqs=prot.requiredUpServices();\n            req.down_reqs=prot.requiredDownServices();\n            req.up_provides=prot.providedUpServices();\n            req.down_provides=prot.providedDownServices();\n            req_list.addElement(req);\n        }\n\n\n        for(int i=0; i < req_list.size(); i++) {\n            req=(ProtocolReq)req_list.elementAt(i);\n\n            // check whether layers above this one provide corresponding down services\n            if(req.up_reqs != null) {\n                for(int j=0; j < req.up_reqs.size(); j++) {\n                    evt_type=((Integer)req.up_reqs.elementAt(j)).intValue();\n\n                    if(!providesDownServices(i, req_list, evt_type)) {\n                        throw new Exception(\"Configurator.sanityCheck(): event \" +\n                                            Event.type2String(evt_type) + \" is required by \" +\n                                            req.name + \", but not provided by any of the layers above\");\n                    }\n                }\n            }\n\n            // check whether layers below this one provide corresponding up services\n            if(req.down_reqs != null) {  // check whether layers above this one provide up_reqs\n                for(int j=0; j < req.down_reqs.size(); j++) {\n                    evt_type=((Integer)req.down_reqs.elementAt(j)).intValue();\n\n                    if(!providesUpServices(i, req_list, evt_type)) {\n                        throw new Exception(\"Configurator.sanityCheck(): event \" +\n                                            Event.type2String(evt_type) + \" is required by \" +\n                                            req.name + \", but not provided by any of the layers below\");\n                    }\n                }\n            }\n\n        }\n    }","id":29960,"modified_method":"/**\n     Throws an exception if sanity check fails. Possible sanity check is uniqueness of all protocol\n     names.\n     */\n    public static void sanityCheck(Vector<Protocol> protocols) throws Exception {\n        Vector<String> names=new Vector<String>();\n        Protocol prot;\n        String name;\n        ProtocolReq req;\n        Vector<ProtocolReq> req_list=new Vector<ProtocolReq>();\n        int evt_type;\n\n        // Checks for unique names\n        for(int i=0; i < protocols.size(); i++) {\n            prot=protocols.elementAt(i);\n            name=prot.getName();\n            for(int j=0; j < names.size(); j++) {\n                if(name.equals(names.elementAt(j))) {\n                    throw new Exception(\"Configurator.sanityCheck(): protocol name \" + name +\n                                        \" has been used more than once; protocol names have to be unique !\");\n                }\n            }\n            names.addElement(name);\n        }\n\n\n        // Checks whether all requirements of all layers are met\n        for(int i=0; i < protocols.size(); i++) {\n            prot=protocols.elementAt(i);\n            req=new ProtocolReq(prot.getName());\n            req.up_reqs=prot.requiredUpServices();\n            req.down_reqs=prot.requiredDownServices();\n            req.up_provides=prot.providedUpServices();\n            req.down_provides=prot.providedDownServices();\n            req_list.addElement(req);\n        }\n\n\n        for(int i=0; i < req_list.size(); i++) {\n            req=req_list.elementAt(i);\n\n            // check whether layers above this one provide corresponding down services\n            if(req.up_reqs != null) {\n                for(int j=0; j < req.up_reqs.size(); j++) {\n                    evt_type=((Integer)req.up_reqs.elementAt(j)).intValue();\n\n                    if(!providesDownServices(i, req_list, evt_type)) {\n                        throw new Exception(\"Configurator.sanityCheck(): event \" +\n                                            Event.type2String(evt_type) + \" is required by \" +\n                                            req.name + \", but not provided by any of the layers above\");\n                    }\n                }\n            }\n\n            // check whether layers below this one provide corresponding up services\n            if(req.down_reqs != null) {  // check whether layers above this one provide up_reqs\n                for(int j=0; j < req.down_reqs.size(); j++) {\n                    evt_type=((Integer)req.down_reqs.elementAt(j)).intValue();\n\n                    if(!providesUpServices(i, req_list, evt_type)) {\n                        throw new Exception(\"Configurator.sanityCheck(): event \" +\n                                            Event.type2String(evt_type) + \" is required by \" +\n                                            req.name + \", but not provided by any of the layers below\");\n                    }\n                }\n            }\n\n        }\n    }","commit_id":"5885988996b3baf1311961a5bb6452e03d7ec9bc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * The configuration string has a number of entries, separated by a ':' (colon).\n     * Each entry consists of the name of the protocol, followed by an optional configuration\n     * of that protocol. The configuration is enclosed in parentheses, and contains entries\n     * which are name/value pairs connected with an assignment sign (=) and separated by\n     * a semicolon.\n     * <pre>UDP(in_port=5555;out_port=4445):FRAG(frag_size=1024)<\/pre><p>\n     * The <em>first<\/em> entry defines the <em>bottommost<\/em> layer, the string is parsed\n     * left to right and the protocol stack constructed bottom up. Example: the string\n     * \"UDP(in_port=5555):FRAG(frag_size=32000):DEBUG\" results is the following stack:<pre>\n     *\n     *   -----------------------\n     *  | DEBUG                 |\n     *  |-----------------------|\n     *  | FRAG frag_size=32000  |\n     *  |-----------------------|\n     *  | UDP in_port=32000     |\n     *   -----------------------\n     * <\/pre>\n     */\n    public Protocol setupProtocolStack(String configuration, ProtocolStack st) throws Exception {\n        Protocol protocol_stack=null;\n        Vector protocol_configs;\n        Vector protocols;\n\n        protocol_configs=parseConfigurations(configuration);\n        protocols=createProtocols(protocol_configs, st);\n        if(protocols == null)\n            return null;\n        protocol_stack=connectProtocols(protocols);\n        return protocol_stack;\n    }","id":29961,"modified_method":"/**\n     * The configuration string has a number of entries, separated by a ':' (colon).\n     * Each entry consists of the name of the protocol, followed by an optional configuration\n     * of that protocol. The configuration is enclosed in parentheses, and contains entries\n     * which are name/value pairs connected with an assignment sign (=) and separated by\n     * a semicolon.\n     * <pre>UDP(in_port=5555;out_port=4445):FRAG(frag_size=1024)<\/pre><p>\n     * The <em>first<\/em> entry defines the <em>bottommost<\/em> layer, the string is parsed\n     * left to right and the protocol stack constructed bottom up. Example: the string\n     * \"UDP(in_port=5555):FRAG(frag_size=32000):DEBUG\" results is the following stack:<pre>\n     *\n     *   -----------------------\n     *  | DEBUG                 |\n     *  |-----------------------|\n     *  | FRAG frag_size=32000  |\n     *  |-----------------------|\n     *  | UDP in_port=32000     |\n     *   -----------------------\n     * <\/pre>\n     */\n    public Protocol setupProtocolStack(String configuration, ProtocolStack st) throws Exception {\n        Protocol protocol_stack=null;\n        Vector<ProtocolConfiguration> protocol_configs;\n        Vector<Protocol> protocols;\n\n        protocol_configs=parseConfigurations(configuration);\n        protocols=createProtocols(protocol_configs, st);\n        if(protocols == null)\n            return null;\n        protocol_stack=connectProtocols(protocols);\n        return protocol_stack;\n    }","commit_id":"5885988996b3baf1311961a5bb6452e03d7ec9bc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a new protocol given the protocol specification.\n     * @param prot_spec The specification of the protocol. Same convention as for specifying a protocol stack.\n     *                  An exception will be thrown if the class cannot be created. Example:\n     *                  <pre>\"VERIFY_SUSPECT(timeout=1500)\"<\/pre> Note that no colons (:) have to be\n     *                  specified\n     * @return Protocol The newly created protocol\n     * @exception Exception Will be thrown when the new protocol cannot be created\n     */\n    public Protocol createProtocol(String prot_spec) throws Exception {\n        return conf.createProtocol(prot_spec, this);\n    }","id":29962,"modified_method":"/**\n     * Creates a new protocol given the protocol specification.\n     * @param prot_spec The specification of the protocol. Same convention as for specifying a protocol stack.\n     *                  An exception will be thrown if the class cannot be created. Example:\n     *                  <pre>\"VERIFY_SUSPECT(timeout=1500)\"<\/pre> Note that no colons (:) have to be\n     *                  specified\n     * @return Protocol The newly created protocol\n     * @exception Exception Will be thrown when the new protocol cannot be created\n     */\n    public Protocol createProtocol(String prot_spec) throws Exception {\n        return Configurator.createProtocol(prot_spec, this);\n    }","commit_id":"5885988996b3baf1311961a5bb6452e03d7ec9bc","url":"https://github.com/belaban/JGroups"},{"original_method":"public void destroy() {\n        if(top_prot != null) {\n            conf.destroyProtocolStack(top_prot);           // destroys msg queues and threads\n            top_prot=null;\n        }        \n        try {\n            timer.stop();\n        }\n        catch(Exception ex) {\n        }        \n    }","id":29963,"modified_method":"public void destroy() {\n        if(top_prot != null) {\n            Configurator.destroyProtocolStack(top_prot);           // destroys msg queues and threads\n            top_prot=null;\n        }        \n        try {\n            timer.stop();\n        }\n        catch(Exception ex) {\n        }        \n    }","commit_id":"5885988996b3baf1311961a5bb6452e03d7ec9bc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Iterates through all the protocols <em>from top to bottom<\/em> and does the following:\n     * <ol>\n     * <li>Waits until all messages in the down queue have been flushed (ie., size is 0)\n     * <li>Calls stop() on the protocol\n     * <\/ol>\n     */\n    public void stopStack() {       \n        if(stopped) return;\n        conf.stopProtocolStack(top_prot);\n        stopped=true;\n    }","id":29964,"modified_method":"/**\n     * Iterates through all the protocols <em>from top to bottom<\/em> and does the following:\n     * <ol>\n     * <li>Waits until all messages in the down queue have been flushed (ie., size is 0)\n     * <li>Calls stop() on the protocol\n     * <\/ol>\n     */\n    public void stopStack() {       \n        if(stopped) return;\n        Configurator.stopProtocolStack(top_prot);\n        stopped=true;\n    }","commit_id":"5885988996b3baf1311961a5bb6452e03d7ec9bc","url":"https://github.com/belaban/JGroups"},{"original_method":"public void setup() throws Exception {\n        if(top_prot == null) {\n            top_prot=conf.setupProtocolStack(setup_string, this);\n            top_prot.setUpProtocol(this);\n            bottom_prot=conf.getBottommostProtocol(top_prot);\n            conf.initProtocolStack(bottom_prot);         // calls init() on each protocol, from bottom to top\n        }\n    }","id":29965,"modified_method":"public void setup() throws Exception {\n        if(top_prot == null) {\n            top_prot=conf.setupProtocolStack(setup_string, this);\n            top_prot.setUpProtocol(this);\n            bottom_prot=Configurator.getBottommostProtocol(top_prot);\n            Configurator.initProtocolStack(bottom_prot);         // calls init() on each protocol, from bottom to top\n        }\n    }","commit_id":"5885988996b3baf1311961a5bb6452e03d7ec9bc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Inserts an already created (and initialized) protocol into the protocol list. Sets the links\n     * to the protocols above and below correctly and adjusts the linked list of protocols accordingly.\n     * Note that this method may change the value of top_prot or bottom_prot.\n     * @param prot The protocol to be inserted. Before insertion, a sanity check will ensure that none\n     *             of the existing protocols have the same name as the new protocol.\n     * @param position Where to place the protocol with respect to the neighbor_prot (ABOVE, BELOW)\n     * @param neighbor_prot The name of the neighbor protocol. An exception will be thrown if this name\n     *                      is not found\n     * @exception Exception Will be thrown when the new protocol cannot be created, or inserted.\n     */\n    public void insertProtocol(Protocol prot, int position, String neighbor_prot) throws Exception {\n        conf.insertProtocol(prot, position, neighbor_prot, this);\n    }","id":29966,"modified_method":"/**\n     * Inserts an already created (and initialized) protocol into the protocol list. Sets the links\n     * to the protocols above and below correctly and adjusts the linked list of protocols accordingly.\n     * Note that this method may change the value of top_prot or bottom_prot.\n     * @param prot The protocol to be inserted. Before insertion, a sanity check will ensure that none\n     *             of the existing protocols have the same name as the new protocol.\n     * @param position Where to place the protocol with respect to the neighbor_prot (ABOVE, BELOW)\n     * @param neighbor_prot The name of the neighbor protocol. An exception will be thrown if this name\n     *                      is not found\n     * @exception Exception Will be thrown when the new protocol cannot be created, or inserted.\n     */\n    public void insertProtocol(Protocol prot, int position, String neighbor_prot) throws Exception {\n        Configurator.insertProtocol(prot, position, neighbor_prot, this);\n    }","commit_id":"5885988996b3baf1311961a5bb6452e03d7ec9bc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Start all layers. The {@link Protocol#start()} method is called in each protocol,\n     * <em>from top to bottom<\/em>.\n     * Each layer can perform some initialization, e.g. create a multicast socket\n     */\n    public void startStack() throws Exception {\n        if(stopped == false) return;\n\n        timer.start();\n        conf.startProtocolStack(top_prot);\n        stopped=false;\n    }","id":29967,"modified_method":"/**\n     * Start all layers. The {@link Protocol#start()} method is called in each protocol,\n     * <em>from top to bottom<\/em>.\n     * Each layer can perform some initialization, e.g. create a multicast socket\n     */\n    public void startStack() throws Exception {\n        if(stopped == false) return;\n\n        timer.start();\n        Configurator.startProtocolStack(top_prot);\n        stopped=false;\n    }","commit_id":"5885988996b3baf1311961a5bb6452e03d7ec9bc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes a protocol from the stack. Stops the protocol and readjusts the linked lists of\n     * protocols.\n     * @param prot_name The name of the protocol. Since all protocol names in a stack have to be unique\n     *                  (otherwise the stack won't be created), the name refers to just 1 protocol.\n     * @exception Exception Thrown if the protocol cannot be stopped correctly.\n     */\n    public Protocol removeProtocol(String prot_name) throws Exception {\n        return conf.removeProtocol(top_prot, prot_name);\n    }","id":29968,"modified_method":"/**\n     * Removes a protocol from the stack. Stops the protocol and readjusts the linked lists of\n     * protocols.\n     * @param prot_name The name of the protocol. Since all protocol names in a stack have to be unique\n     *                  (otherwise the stack won't be created), the name refers to just 1 protocol.\n     * @exception Exception Thrown if the protocol cannot be stopped correctly.\n     */\n    public Protocol removeProtocol(String prot_name) throws Exception {\n        return Configurator.removeProtocol(top_prot, prot_name);\n    }","commit_id":"5885988996b3baf1311961a5bb6452e03d7ec9bc","url":"https://github.com/belaban/JGroups"},{"original_method":"public void reset() {\n    final String text = (myTemplate == null) ? \"\" : myTemplate.getText();\n    String name = (myTemplate == null) ? \"\" : myTemplate.getName();\n    String extension = (myTemplate == null) ? \"\" : myTemplate.getExtension();\n    String description = (myTemplate == null) ? \"\" : myTemplate.getDescription();\n    if (description == null) {\n      description = \"\";\n    }\n    if ((description.length() == 0) && (myDefaultDescription != null)) {\n      try {\n        description = new String(myDefaultDescription.contentsToCharArray());\n      }\n      catch (IOException e) {\n        LOG.error(e);\n      }\n    }\n    boolean adjust = (myTemplate == null) ? false : myTemplate.isAdjust();\n    setHighlighter();\n    myNameField.setText(name);\n    myExtensionField.setText(extension);\n    myAdjustBox.setSelected(adjust);\n    String desc = description.length() > 0 ? description : \"<html><\/html>\";\n\n    // [myakovlev] do not delete these stupid lines! Or you get Exception!\n    myDescriptionComponent.setContentType(\"text/plain\");\n    myDescriptionComponent.setEditable(true);\n    myDescriptionComponent.setText(desc);\n    myDescriptionComponent.setContentType(\"text/html\");\n    myDescriptionComponent.setText(desc);\n    myDescriptionComponent.setCaretPosition(0);\n    myDescriptionComponent.setEditable(false);\n\n    CommandProcessor.getInstance().executeCommand(null, new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            final Document document = myTemplateEditor.getDocument();\n            document.replaceString(0, document.getTextLength(), text);\n            UndoManager.getGlobalInstance().undoableActionPerformed(new NonUndoableAction() {\n              public DocumentReference[] getAffectedDocuments() {\n                return new DocumentReference[] {DocumentReferenceByDocument.createDocumentReference(document)};\n              }\n\n              public boolean isComplex() {\n                return false;\n              }\n            });\n          }\n        });\n      }\n    }, \"\", null);\n\n    myNameField.setEditable((myTemplate != null) && (!myTemplate.isDefault()));\n    myExtensionField.setEditable((myTemplate != null) && (!myTemplate.isDefault()));\n    myModified = false;\n  }","id":29969,"modified_method":"public void reset() {\n    final String text = (myTemplate == null) ? \"\" : myTemplate.getText();\n    String name = (myTemplate == null) ? \"\" : myTemplate.getName();\n    String extension = (myTemplate == null) ? \"\" : myTemplate.getExtension();\n    String description = (myTemplate == null) ? \"\" : myTemplate.getDescription();\n    if (description == null) {\n      description = \"\";\n    }\n    if ((description.length() == 0) && (myDefaultDescription != null)) {\n      try {\n        description = new String(myDefaultDescription.contentsToCharArray());\n      }\n      catch (IOException e) {\n        LOG.error(e);\n      }\n    }\n    boolean adjust = (myTemplate != null) && myTemplate.isAdjust();\n    setHighlighter();\n    myNameField.setText(name);\n    myExtensionField.setText(extension);\n    myAdjustBox.setSelected(adjust);\n    String desc = description.length() > 0 ? description : \"<html><\/html>\";\n\n    // [myakovlev] do not delete these stupid lines! Or you get Exception!\n    myDescriptionComponent.setContentType(\"text/plain\");\n    myDescriptionComponent.setEditable(true);\n    myDescriptionComponent.setText(desc);\n    myDescriptionComponent.setContentType(\"text/html\");\n    myDescriptionComponent.setText(desc);\n    myDescriptionComponent.setCaretPosition(0);\n    myDescriptionComponent.setEditable(false);\n\n    CommandProcessor.getInstance().executeCommand(null, new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            final Document document = myTemplateEditor.getDocument();\n            document.replaceString(0, document.getTextLength(), text);\n            UndoManager.getGlobalInstance().undoableActionPerformed(new NonUndoableAction() {\n              public DocumentReference[] getAffectedDocuments() {\n                return new DocumentReference[] {DocumentReferenceByDocument.createDocumentReference(document)};\n              }\n\n              public boolean isComplex() {\n                return false;\n              }\n            });\n          }\n        });\n      }\n    }, \"\", null);\n\n    myNameField.setEditable((myTemplate != null) && (!myTemplate.isDefault()));\n    myExtensionField.setEditable((myTemplate != null) && (!myTemplate.isDefault()));\n    myModified = false;\n  }","commit_id":"cc77296a585b0cd4b12c420e09ec3fd8327b7d12","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void onNameChanged() {\n    ChangeEvent event = new ChangeEvent(this);\n    for (int i = 0; i < myChangeListeners.size(); i++) {\n      ChangeListener changeListener = (ChangeListener)myChangeListeners.elementAt(i);\n      changeListener.stateChanged(event);\n    }\n  }","id":29970,"modified_method":"private void onNameChanged() {\n    ChangeEvent event = new ChangeEvent(this);\n    for (int i = 0; i < myChangeListeners.size(); i++) {\n      ChangeListener changeListener = myChangeListeners.elementAt(i);\n      changeListener.stateChanged(event);\n    }\n  }","commit_id":"cc77296a585b0cd4b12c420e09ec3fd8327b7d12","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JComponent createComponent() {\n    myMainPanel = new JPanel(new GridBagLayout());\n    myTemplateEditor = createEditor();\n    myNameField = new JTextField();\n    myExtensionField = new JTextField();\n    mySplitter = new Splitter(true, 0.66f);\n\n    myDescriptionComponent = new JEditorPane(\"text/html\", \"<html><\/html>\");\n    myDescriptionComponent.setEditable(false);\n//    myDescriptionComponent.setMargin(new Insets(2, 2, 2, 2));\n\n//    myDescriptionComponent = new JLabel();\n//    myDescriptionComponent.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));\n//    myDescriptionComponent.setVerticalAlignment(SwingConstants.TOP);\n\n    myAdjustBox = new JCheckBox(\"Reformat according to style\");\n    myTopPanel = new JPanel(new GridBagLayout());\n\n    JPanel secondPanel = new JPanel(new GridBagLayout());\n    secondPanel.add(new JLabel(\"Description:\"),\n                    new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE,\n                                           new Insets(0, 0, 2, 0), 0, 0));\n    secondPanel.add(new JScrollPane(myDescriptionComponent),\n                    new GridBagConstraints(0, 1, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.BOTH,\n                                           new Insets(2, 0, 0, 0), 0, 0));\n\n    myMainPanel.add(myTopPanel,\n                    new GridBagConstraints(0, 0, 4, 1, 1.0, 0.0, GridBagConstraints.CENTER,\n                                           GridBagConstraints.HORIZONTAL, new Insets(0, 0, 2, 0), 0, 0));\n    myMainPanel.add(myAdjustBox,\n                    new GridBagConstraints(0, 1, 4, 1, 0.0, 0.0, GridBagConstraints.WEST,\n                                           GridBagConstraints.HORIZONTAL, new Insets(2, 0, 2, 0), 0, 0));\n    myMainPanel.add(mySplitter,\n                    new GridBagConstraints(0, 2, 4, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.BOTH,\n                                           new Insets(2, 0, 0, 0), 0, 0));\n    mySplitter.setFirstComponent(myTemplateEditor.getComponent());\n    mySplitter.setSecondComponent(secondPanel);\n    setShowInternalMessage(null);\n    myTemplateEditor.getDocument().addDocumentListener(new DocumentAdapter() {\n      public void documentChanged(DocumentEvent e) {\n        onTextChanged();\n      }\n    });\n    myNameField.addFocusListener(new FocusAdapter() {\n      public void focusLost(FocusEvent e) {\n        onNameChanged();\n      }\n    });\n    myExtensionField.addFocusListener(new FocusAdapter() {\n      public void focusLost(FocusEvent e) {\n        onNameChanged();\n      }\n    });\n    return myMainPanel;\n  }","id":29971,"modified_method":"public JComponent createComponent() {\n    myMainPanel = new JPanel(new GridBagLayout());\n    myTemplateEditor = createEditor();\n    myNameField = new JTextField();\n    myExtensionField = new JTextField();\n    final Splitter splitter = new Splitter(true, 0.66f);\n\n    myDescriptionComponent = new JEditorPane(\"text/html\", \"<html><\/html>\");\n    myDescriptionComponent.setEditable(false);\n//    myDescriptionComponent.setMargin(new Insets(2, 2, 2, 2));\n\n//    myDescriptionComponent = new JLabel();\n//    myDescriptionComponent.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));\n//    myDescriptionComponent.setVerticalAlignment(SwingConstants.TOP);\n\n    myAdjustBox = new JCheckBox(\"Reformat according to style\");\n    myTopPanel = new JPanel(new GridBagLayout());\n\n    JPanel secondPanel = new JPanel(new GridBagLayout());\n    secondPanel.add(new JLabel(\"Description:\"),\n                    new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE,\n                                           new Insets(0, 0, 2, 0), 0, 0));\n    secondPanel.add(new JScrollPane(myDescriptionComponent),\n                    new GridBagConstraints(0, 1, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.BOTH,\n                                           new Insets(2, 0, 0, 0), 0, 0));\n\n    myMainPanel.add(myTopPanel,\n                    new GridBagConstraints(0, 0, 4, 1, 1.0, 0.0, GridBagConstraints.CENTER,\n                                           GridBagConstraints.HORIZONTAL, new Insets(0, 0, 2, 0), 0, 0));\n    myMainPanel.add(myAdjustBox,\n                    new GridBagConstraints(0, 1, 4, 1, 0.0, 0.0, GridBagConstraints.WEST,\n                                           GridBagConstraints.HORIZONTAL, new Insets(2, 0, 2, 0), 0, 0));\n    myMainPanel.add(splitter,\n                    new GridBagConstraints(0, 2, 4, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.BOTH,\n                                           new Insets(2, 0, 0, 0), 0, 0));\n    splitter.setFirstComponent(myTemplateEditor.getComponent());\n    splitter.setSecondComponent(secondPanel);\n    setShowInternalMessage(null);\n    myTemplateEditor.getDocument().addDocumentListener(new DocumentAdapter() {\n      public void documentChanged(DocumentEvent e) {\n        onTextChanged();\n      }\n    });\n    myNameField.addFocusListener(new FocusAdapter() {\n      public void focusLost(FocusEvent e) {\n        onNameChanged();\n      }\n    });\n    myExtensionField.addFocusListener(new FocusAdapter() {\n      public void focusLost(FocusEvent e) {\n        onNameChanged();\n      }\n    });\n    return myMainPanel;\n  }","commit_id":"cc77296a585b0cd4b12c420e09ec3fd8327b7d12","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setHighlighter() {\n    FileType fileType;\n    if (myTemplate != null) {\n      String extension = myTemplate.getExtension();\n      fileType = FileTypeManager.getInstance().getFileTypeByExtension(extension);\n    }\n    else {\n      fileType = StdFileTypes.PLAIN_TEXT;\n    }\n\n    SyntaxHighlighter originalHighlighter = fileType.getHighlighter(null);\n    LexerEditorHighlighter highlighter = new LexerEditorHighlighter(new TemplateHighlighter(originalHighlighter), EditorColorsManager.getInstance().getGlobalScheme());\n    ((EditorEx)myTemplateEditor).setHighlighter(highlighter);\n    ((EditorEx)myTemplateEditor).repaint(0, myTemplateEditor.getDocument().getTextLength());\n  }","id":29972,"modified_method":"private void setHighlighter() {\n    FileType fileType;\n    if (myTemplate != null) {\n      String extension = myTemplate.getExtension();\n      fileType = FileTypeManager.getInstance().getFileTypeByExtension(extension);\n    }\n    else {\n      fileType = StdFileTypes.PLAIN_TEXT;\n    }\n\n    SyntaxHighlighter originalHighlighter = fileType.getHighlighter(null);\n    if (originalHighlighter == null) originalHighlighter = new PlainSyntaxHighlighter();\n    LexerEditorHighlighter highlighter = new LexerEditorHighlighter(new TemplateHighlighter(originalHighlighter), EditorColorsManager.getInstance().getGlobalScheme());\n    ((EditorEx)myTemplateEditor).setHighlighter(highlighter);\n    ((EditorEx)myTemplateEditor).repaint(0, myTemplateEditor.getDocument().getTextLength());\n  }","commit_id":"cc77296a585b0cd4b12c420e09ec3fd8327b7d12","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Sends the new view and digest to all subgroup coordinors in coords. Each coord will in turn\n     * <ol>\n     * <li>cast the new view and digest to all the members of its subgroup (MergeView)\n     * <li>on reception of the view, if it is a MergeView, each member will set the digest and install\n     *     the new view\n     * <\/ol>\n     */\n    private void sendMergeView(Vector coords, MergeData combined_merge_data) {\n        Message msg;\n        GMS.GmsHeader hdr;\n        Address coord;\n        View v;\n        Digest d;\n\n        if(coords == null || combined_merge_data == null)\n            return;\n\n        v=combined_merge_data.view;\n        d=combined_merge_data.digest;\n        if(v == null || d == null) {\n            if(log.isErrorEnabled()) log.error(\"view or digest is null, cannot send consolidated merge view/digest\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"sending merge view \" + v.getVid() + \" to coordinators \" + coords);\n\n        for(int i=0; i < coords.size(); i++) {\n            coord=(Address)coords.elementAt(i);\n            msg=new Message(coord, null, null);\n            hdr=new GMS.GmsHeader(GMS.GmsHeader.INSTALL_MERGE_VIEW);\n            hdr.view=v;\n            hdr.my_digest=d;\n            hdr.merge_id=merge_id;\n            msg.putHeader(gms.getName(), hdr);\n            gms.getDownProtocol().down(new Event(Event.MSG, msg));\n        }\n    }","id":29973,"modified_method":"/**\n     * Sends the new view and digest to all subgroup coordinors in coords. Each coord will in turn\n     * <ol>\n     * <li>cast the new view and digest to all the members of its subgroup (MergeView)\n     * <li>on reception of the view, if it is a MergeView, each member will set the digest and install\n     *     the new view\n     * <\/ol>\n     */\n    private void sendMergeView(Vector<Address> coords, MergeData combined_merge_data) {                      \n        View v;\n        Digest d;\n\n        if(coords == null || combined_merge_data == null)\n            return;\n\n        v=combined_merge_data.view;\n        d=combined_merge_data.digest;\n        if(v == null || d == null) {\n            if(log.isErrorEnabled()) log.error(\"view or digest is null, cannot send consolidated merge view/digest\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"sending merge view \" + v.getVid() + \" to coordinators \" + coords);\n\n        for(Address coord:coords) {            \n            Message msg=new Message(coord, null, null);\n            GMS.GmsHeader hdr=new GMS.GmsHeader(GMS.GmsHeader.INSTALL_MERGE_VIEW);\n            hdr.view=v;\n            hdr.my_digest=d;\n            hdr.merge_id=merge_id;\n            msg.putHeader(gms.getName(), hdr);\n            gms.getDownProtocol().down(new Event(Event.MSG, msg));\n        }\n    }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Merge all digests into one. For each sender, the new value is min(low_seqno), max(high_seqno),\n     * max(high_seqno_seen). This method has a lock on merge_rsps\n     */\n    private Digest consolidateDigests(Vector<MergeData> merge_rsps, int num_mbrs) {\n        MergeData data;\n        Digest tmp_digest;\n        MutableDigest retval=new MutableDigest(num_mbrs);\n\n        for(int i=0; i < merge_rsps.size(); i++) {\n            data=merge_rsps.elementAt(i);\n            tmp_digest=data.getDigest();\n            if(tmp_digest == null) {\n                if(log.isErrorEnabled()) log.error(\"tmp_digest == null; skipping\");\n                continue;\n            }\n            retval.merge(tmp_digest);\n        }\n        return retval.copy();\n    }","id":29974,"modified_method":"/**\n     * Merge all digests into one. For each sender, the new value is min(low_seqno), max(high_seqno),\n     * max(high_seqno_seen). This method has a lock on merge_rsps\n     */\n    private Digest consolidateDigests(Vector<MergeData> merge_rsps, int num_mbrs) {               \n        MutableDigest retval=new MutableDigest(num_mbrs);\n\n        for(MergeData data:merge_rsps) {            \n            Digest tmp_digest=data.getDigest();\n            if(tmp_digest == null) {\n                if(log.isErrorEnabled()) log.error(\"tmp_digest == null; skipping\");\n                continue;\n            }\n            retval.merge(tmp_digest);\n        }\n        return retval.copy();\n    }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends a MERGE_REQ to all coords and populates a list of MergeData (in merge_rsps). Returns after coords.size()\n     * response have been received, or timeout msecs have elapsed (whichever is first).<p>\n     * If a subgroup coordinator rejects the MERGE_REQ (e.g. because of participation in a different merge),\n     * <em>that member will be removed from coords !<\/em>\n     * @param coords A list of Addresses of subgroup coordinators (inluding myself)\n     * @param timeout Max number of msecs to wait for the merge responses from the subgroup coords\n     */\n    private void getMergeDataFromSubgroupCoordinators(Vector coords, long timeout) {\n        Message msg;\n        GMS.GmsHeader hdr;\n\n        long curr_time, time_to_wait, end_time, start, stop;\n        int num_rsps_expected;\n\n        if(coords == null || coords.size() <= 1) {\n            if(log.isErrorEnabled()) log.error(\"coords == null or size <= 1\");\n            return;\n        }\n\n        start=System.currentTimeMillis();\n        MergeData tmp;\n        synchronized(merge_rsps) {\n            merge_rsps.removeAllElements();\n            if(log.isDebugEnabled()) log.debug(\"sending MERGE_REQ to \" + coords);\n            Address coord;\n            for(int i=0; i < coords.size(); i++) {\n                coord=(Address)coords.elementAt(i);\n                \n                // this allows UNICAST to remove coord from previous_members in case of a merge\n                gms.getDownProtocol().down(new Event(Event.ENABLE_UNICASTS_TO, coord));\n\n                msg=new Message(coord, null, null);\n                msg.setFlag(Message.OOB);\n                hdr=new GMS.GmsHeader(GMS.GmsHeader.MERGE_REQ);\n                hdr.mbr=gms.local_addr;\n                hdr.merge_id=merge_id;\n                msg.putHeader(gms.getName(), hdr);\n                gms.getDownProtocol().down(new Event(Event.MSG, msg));\n            }\n\n            // wait until num_rsps_expected >= num_rsps or timeout elapsed\n            num_rsps_expected=coords.size();\n            curr_time=System.currentTimeMillis();\n            end_time=curr_time + timeout;\n            while(end_time > curr_time) {\n                time_to_wait=end_time - curr_time;\n                if(log.isDebugEnabled()) log.debug(\"waiting \" + time_to_wait + \" msecs for merge responses\");\n                if(merge_rsps.size() < num_rsps_expected) {\n                    try {\n                        merge_rsps.wait(time_to_wait);\n                    }\n                    catch(Exception ex) {\n                    }\n                }\n                if(log.isDebugEnabled())\n                    log.debug(\"num_rsps_expected=\" + num_rsps_expected + \", actual responses=\" + merge_rsps.size());\n\n                if(merge_rsps.size() >= num_rsps_expected)\n                    break;\n                curr_time=System.currentTimeMillis();\n            }\n            stop=System.currentTimeMillis();\n            if(log.isTraceEnabled())\n                log.trace(\"collected \" + merge_rsps.size() + \" merge response(s) in \" + (stop-start) + \"ms\");\n        }\n    }","id":29975,"modified_method":"/**\n     * Sends a MERGE_REQ to all coords and populates a list of MergeData (in merge_rsps). Returns after coords.size()\n     * response have been received, or timeout msecs have elapsed (whichever is first).<p>\n     * If a subgroup coordinator rejects the MERGE_REQ (e.g. because of participation in a different merge),\n     * <em>that member will be removed from coords !<\/em>\n     * @param coords A list of Addresses of subgroup coordinators (inluding myself)\n     * @param timeout Max number of msecs to wait for the merge responses from the subgroup coords\n     */\n    private void getMergeDataFromSubgroupCoordinators(Vector<Address> coords, long timeout) {\n        Message msg;\n        GMS.GmsHeader hdr;\n\n        long curr_time, time_to_wait, end_time, start, stop;\n        int num_rsps_expected;        \n\n        start=System.currentTimeMillis();        \n        synchronized(merge_rsps) {\n            merge_rsps.removeAllElements();\n            if(log.isDebugEnabled()) log.debug(\"sending MERGE_REQ to \" + coords);            \n            for(Address coord:coords) {               \n                // this allows UNICAST to remove coord from previous_members in case of a merge\n                gms.getDownProtocol().down(new Event(Event.ENABLE_UNICASTS_TO, coord));\n\n                msg=new Message(coord, null, null);\n                msg.setFlag(Message.OOB);\n                hdr=new GMS.GmsHeader(GMS.GmsHeader.MERGE_REQ);\n                hdr.mbr=gms.local_addr;\n                hdr.merge_id=merge_id;\n                msg.putHeader(gms.getName(), hdr);\n                gms.getDownProtocol().down(new Event(Event.MSG, msg));\n            }\n\n            // wait until num_rsps_expected >= num_rsps or timeout elapsed\n            num_rsps_expected=coords.size();\n            curr_time=System.currentTimeMillis();\n            end_time=curr_time + timeout;\n            while(end_time > curr_time) {\n                time_to_wait=end_time - curr_time;\n                if(log.isDebugEnabled()) log.debug(\"waiting \" + time_to_wait + \" msecs for merge responses\");\n                if(merge_rsps.size() < num_rsps_expected) {\n                    try {\n                        merge_rsps.wait(time_to_wait);\n                    }\n                    catch(Exception ex) {\n                    }\n                }\n                if(log.isDebugEnabled())\n                    log.debug(\"num_rsps_expected=\" + num_rsps_expected + \", actual responses=\" + merge_rsps.size());\n\n                if(merge_rsps.size() >= num_rsps_expected)\n                    break;\n                curr_time=System.currentTimeMillis();\n            }\n            stop=System.currentTimeMillis();\n            if(log.isTraceEnabled())\n                log.trace(\"collected \" + merge_rsps.size() + \" merge response(s) in \" + (stop-start) + \"ms\");\n        }\n    }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n         * Runs the merge protocol as a leader\n         */\n        public void run() {\n            if(merging == true) {\n                if(log.isWarnEnabled()) log.warn(\"merge is already in progress, terminating\");\n                return;\n            }\n\n            if(log.isDebugEnabled()) log.debug(\"merge task started, coordinators are \" + this.coords);\n            try {\n\n                /* 1. Generate a merge_id that uniquely identifies the merge in progress */\n                setMergeId(generateMergeId());\n\n                /* 2. Fetch the current Views/Digests from all subgroup coordinators */\n                getMergeDataFromSubgroupCoordinators(coords, gms.merge_timeout);\n\n                /* 3. Remove rejected MergeData elements from merge_rsp and coords (so we'll send the new view only\n                   to members who accepted the merge request) */\n                MergeData combined_merge_data=null;\n                boolean abort_merge=false;\n                synchronized(merge_rsps) {\n                    removeRejectedMergeRequests(coords);\n                    if(merge_rsps.size() <= 1) {\n                        if(log.isWarnEnabled())\n                            log.warn(\"merge responses from subgroup coordinators <= 1 (\" + merge_rsps + \"). Cancelling merge\");\n                        abort_merge=true;\n                    }\n                    else {\n                        /* 4. Combine all views and digests into 1 View/1 Digest */\n                        combined_merge_data=consolidateMergeData(merge_rsps);\n                        if(combined_merge_data == null) {\n                            if(log.isErrorEnabled()) log.error(\"combined_merge_data == null\");\n                            abort_merge=true;\n                        }\n                    }\n                }\n\n                if(abort_merge) {\n                    sendMergeCancelledMessage(coords, merge_id);\n                    return;\n                }\n\n                /* 5. Don't allow JOINs or LEAVEs until we are done with the merge. Suspend() will clear the\n                      view handler queue, so no requests beyond this current MERGE request will be processed */\n                gms.getViewHandler().suspend(merge_id);\n\n                /* 6. Send the new View/Digest to all coordinators (including myself). On reception, they will\n                   install the digest and view in all of their subgroup members */\n                sendMergeView(coords, combined_merge_data);\n            }\n            catch(Throwable ex) {                \n                if(log.isErrorEnabled()) log.error(\"exception while merging\", ex);\n                sendMergeCancelledMessage(coords, merge_id);\n            }\n            finally {               \n                stopMergeCanceller(); // this is probably not necessary\n                merging=false;\n                merge_leader=null;\n                if(log.isDebugEnabled()) log.debug(\"merge task terminated\");\n                t=null;\n            }\n        }","id":29976,"modified_method":"/**\n         * Runs the merge protocol as a leader\n         */\n        public void run() {\n            if(merging == true) {\n                if(log.isWarnEnabled()) log.warn(\"merge is already in progress, terminating\");\n                return;\n            }\n            \n            if(coords == null || coords.size() <= 1) {\n                if(log.isErrorEnabled()) log.error(\"coords == null or size <= 1\");\n                return;\n            }\n\n            if(log.isDebugEnabled()) log.debug(\"merge task started, coordinators are \" + this.coords);\n            try {\n\n                /* 1. Generate a merge_id that uniquely identifies the merge in progress */\n                setMergeId(generateMergeId());\n\n                /* 2. Fetch the current Views/Digests from all subgroup coordinators */\n                getMergeDataFromSubgroupCoordinators(coords, gms.merge_timeout);\n\n                /* 3. Remove rejected MergeData elements from merge_rsp and coords (so we'll send the new view only\n                   to members who accepted the merge request) */\n                MergeData combined_merge_data=null;\n                boolean abort_merge=false;\n                synchronized(merge_rsps) {\n                    removeRejectedMergeRequests(coords);\n                    if(merge_rsps.size() <= 1) {\n                        if(log.isWarnEnabled())\n                            log.warn(\"merge responses from subgroup coordinators <= 1 (\" + merge_rsps + \"). Cancelling merge\");\n                        abort_merge=true;\n                    }\n                    else {\n                        /* 4. Combine all views and digests into 1 View/1 Digest */\n                        combined_merge_data=consolidateMergeData(merge_rsps);\n                        if(combined_merge_data == null) {\n                            if(log.isErrorEnabled()) log.error(\"combined_merge_data == null\");\n                            abort_merge=true;\n                        }\n                    }\n                }\n\n                if(abort_merge) {\n                    sendMergeCancelledMessage(coords, merge_id);\n                    return;\n                }\n\n                /* 5. Don't allow JOINs or LEAVEs until we are done with the merge. Suspend() will clear the\n                      view handler queue, so no requests beyond this current MERGE request will be processed */\n                gms.getViewHandler().suspend(merge_id);\n\n                /* 6. Send the new View/Digest to all coordinators (including myself). On reception, they will\n                   install the digest and view in all of their subgroup members */\n                sendMergeView(coords, combined_merge_data);\n            }\n            catch(Throwable ex) {                \n                if(log.isErrorEnabled()) log.error(\"exception while merging\", ex);\n                sendMergeCancelledMessage(coords, merge_id);\n            }\n            finally {               \n                stopMergeCanceller(); // this is probably not necessary\n                merging=false;\n                merge_leader=null;\n                if(log.isDebugEnabled()) log.debug(\"merge task terminated\");\n                t=null;\n            }\n        }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendMergeCancelledMessage(Vector coords, ViewId merge_id) {\n        Message msg;\n        GMS.GmsHeader hdr;\n        Address coord;\n\n        if(coords == null || merge_id == null) {\n            if(log.isErrorEnabled()) log.error(\"coords or merge_id == null\");\n            return;\n        }\n        for(int i=0; i < coords.size(); i++) {\n            coord=(Address)coords.elementAt(i);\n            msg=new Message(coord, null, null);\n            // msg.setFlag(Message.OOB);\n            hdr=new GMS.GmsHeader(GMS.GmsHeader.CANCEL_MERGE);\n            hdr.merge_id=merge_id;\n            msg.putHeader(gms.getName(), hdr);\n            gms.getDownProtocol().down(new Event(Event.MSG, msg));\n        }\n    }","id":29977,"modified_method":"public void start(Vector<Address> groupCoord) {\n            this.coords = groupCoord != null ? new Vector<Address>(groupCoord) : null;\n            if(!isRunning()) {              \n                t=gms.getProtocolStack().getThreadFactory().newThread(this, \"MergeTask\");               \n                t.setDaemon(true);\n                t.start();\n            }\n        }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Removed rejected merge requests from merge_rsps and coords. This method has a lock on merge_rsps */\n    private void removeRejectedMergeRequests(Vector coords) {\n        MergeData data;\n        for(Iterator it=merge_rsps.iterator(); it.hasNext();) {\n            data=(MergeData)it.next();\n            if(data.merge_rejected) {\n                if(data.getSender() != null && coords != null)\n                    coords.removeElement(data.getSender());\n                it.remove();\n                if(log.isDebugEnabled()) log.debug(\"removed element \" + data);\n            }\n        }\n    }","id":29978,"modified_method":"/** Removed rejected merge requests from merge_rsps and coords. This method has a lock on merge_rsps */\n    private void removeRejectedMergeRequests(Vector<Address> coords) {        \n        for(Iterator<MergeData> it=merge_rsps.iterator(); it.hasNext();) {\n            MergeData data=it.next();\n            if(data.merge_rejected) {\n                if(data.getSender() != null && coords != null)\n                    coords.removeElement(data.getSender());\n                it.remove();\n                if(log.isDebugEnabled()) log.debug(\"removed element \" + data);\n            }\n        }\n    }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Merge all MergeData. All MergeData elements should be disjunct (both views and digests). However,\n     * this method is prepared to resolve duplicate entries (for the same member). Resolution strategy for\n     * views is to merge only 1 of the duplicate members. Resolution strategy for digests is to take the higher\n     * seqnos for duplicate digests.<p>\n     * After merging all members into a Membership and subsequent sorting, the first member of the sorted membership\n     * will be the new coordinator. This method has a lock on merge_rsps.\n     * @param merge_rsps A list of MergeData items. Elements with merge_rejected=true were removed before. Is guaranteed\n     *          not to be null and to contain at least 1 member.\n     */\n    private MergeData consolidateMergeData(Vector<MergeData> merge_rsps) {\n        MergeData ret;\n        MergeData tmp_data;\n        long logical_time=0; // for new_vid\n        ViewId new_vid, tmp_vid;\n        MergeView new_view;\n        View tmp_view;\n        Membership new_mbrs=new Membership();\n        int num_mbrs;\n        Address new_coord;\n        Vector<View> subgroups=new Vector<View>(11);\n        // contains a list of Views, each View is a subgroup\n\n        for(int i=0; i < merge_rsps.size(); i++) {\n            tmp_data=merge_rsps.elementAt(i);\n            if(log.isDebugEnabled()) log.debug(\"merge data is \" + tmp_data);\n            tmp_view=tmp_data.getView();\n            if(tmp_view != null) {\n                tmp_vid=tmp_view.getVid();\n                if(tmp_vid != null) {\n                    // compute the new view id (max of all vids +1)\n                    logical_time=Math.max(logical_time, tmp_vid.getId());\n                }\n                // merge all membership lists into one (prevent duplicates)\n                new_mbrs.add(tmp_view.getMembers());\n                subgroups.addElement((View)tmp_view.clone());\n            }\n        }\n\n        // the new coordinator is the first member of the consolidated & sorted membership list\n        new_mbrs.sort();\n        num_mbrs=new_mbrs.size();\n        new_coord=num_mbrs > 0? (Address)new_mbrs.elementAt(0) : null;\n        if(new_coord == null) {\n            if(log.isErrorEnabled()) log.error(\"new_coord == null\");\n            return null;\n        }\n        // should be the highest view ID seen up to now plus 1\n        new_vid=new ViewId(new_coord, logical_time + 1);\n\n        // determine the new view\n        new_view=new MergeView(new_vid, new_mbrs.getMembers(), subgroups);\n        if(log.isDebugEnabled()) log.debug(\"new merged view will be \" + new_view);\n\n        // determine the new digest\n        Digest new_digest=consolidateDigests(merge_rsps, num_mbrs);\n        if(new_digest == null) {\n            if(log.isErrorEnabled()) log.error(\"digest could not be consolidated\");\n            return null;\n        }\n        if(log.isDebugEnabled()) log.debug(\"consolidated digest=\" + new_digest);\n        ret=new MergeData(gms.local_addr, new_view, new_digest);\n        return ret;\n    }","id":29979,"modified_method":"/**\n     * Merge all MergeData. All MergeData elements should be disjunct (both views and digests). However,\n     * this method is prepared to resolve duplicate entries (for the same member). Resolution strategy for\n     * views is to merge only 1 of the duplicate members. Resolution strategy for digests is to take the higher\n     * seqnos for duplicate digests.<p>\n     * After merging all members into a Membership and subsequent sorting, the first member of the sorted membership\n     * will be the new coordinator. This method has a lock on merge_rsps.\n     * @param merge_rsps A list of MergeData items. Elements with merge_rejected=true were removed before. Is guaranteed\n     *          not to be null and to contain at least 1 member.\n     */\n    private MergeData consolidateMergeData(Vector<MergeData> merge_rsps) {\n        MergeData ret;       \n        long logical_time=0; // for new_vid\n        ViewId new_vid, tmp_vid;\n        MergeView new_view;\n        View tmp_view;\n        Membership new_mbrs=new Membership();       \n        Address new_coord;\n        Vector<View> subgroups=new Vector<View>(11);\n        // contains a list of Views, each View is a subgroup\n\n        for(MergeData tmp_data:merge_rsps) {           \n            if(log.isDebugEnabled()) log.debug(\"merge data is \" + tmp_data);\n            tmp_view=tmp_data.getView();\n            if(tmp_view != null) {\n                tmp_vid=tmp_view.getVid();\n                if(tmp_vid != null) {\n                    // compute the new view id (max of all vids +1)\n                    logical_time=Math.max(logical_time, tmp_vid.getId());\n                }\n                // merge all membership lists into one (prevent duplicates)\n                new_mbrs.add(tmp_view.getMembers());\n                subgroups.addElement((View)tmp_view.clone());\n            }\n        }\n\n        // the new coordinator is the first member of the consolidated & sorted membership list\n        new_mbrs.sort();       \n        new_coord = new_mbrs.size() > 0 ? new_mbrs.elementAt(0) : null;\n        if(new_coord == null) {\n            if(log.isErrorEnabled()) log.error(\"new_coord == null\");\n            return null;\n        }\n        // should be the highest view ID seen up to now plus 1\n        new_vid=new ViewId(new_coord, logical_time + 1);\n\n        // determine the new view\n        new_view=new MergeView(new_vid, new_mbrs.getMembers(), subgroups);\n        if(log.isDebugEnabled()) log.debug(\"new merged view will be \" + new_view);\n\n        // determine the new digest\n        Digest new_digest=consolidateDigests(merge_rsps, new_mbrs.size());\n        if(new_digest == null) {\n            if(log.isErrorEnabled()) log.error(\"digest could not be consolidated\");\n            return null;\n        }\n        if(log.isDebugEnabled()) log.debug(\"consolidated digest=\" + new_digest);\n        ret=new MergeData(gms.local_addr, new_view, new_digest);\n        return ret;\n    }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Called by the GMS when a VIEW is received.\n     * @param new_view The view to be installed\n     * @param digest   If view is a MergeView, digest contains the seqno digest of all members and has to\n     *                 be set by GMS\n     */\n    public void handleViewChange(View new_view, Digest digest) {\n        Vector mbrs=new_view.getMembers();\n        if(log.isDebugEnabled()) {\n            if(digest != null)\n                log.debug(\"view=\" + new_view + \", digest=\" + digest);\n            else\n                log.debug(\"view=\" + new_view);\n        }\n\n        if(leaving && !mbrs.contains(gms.local_addr))\n            return;\n        gms.installView(new_view, digest);\n    }","id":29980,"modified_method":"/**\n     * Called by the GMS when a VIEW is received.\n     * @param new_view The view to be installed\n     * @param digest   If view is a MergeView, digest contains the seqno digest of all members and has to\n     *                 be set by GMS\n     */\n    public void handleViewChange(View new_view, Digest digest) {\n        Vector<Address> mbrs=new_view.getMembers();\n        if(log.isDebugEnabled()) {\n            if(digest != null)\n                log.debug(\"view=\" + new_view + \", digest=\" + digest);\n            else\n                log.debug(\"view=\" + new_view);\n        }\n\n        if(leaving && !mbrs.contains(gms.local_addr))\n            return;\n        gms.installView(new_view, digest);\n    }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a member ship object with the initial members.\n     * The Address references are copied out of the vector, so that the\n     * vector passed in as parameters is not the same reference as the vector\n     * that the membership class is using\n     *\n     * @param initial_members - a list of members that belong to this membership\n     */\n    public Membership(Collection initial_members) {\n        if(initial_members != null)\n            add(initial_members);\n    }","id":29981,"modified_method":"/**\n     * Creates a member ship object with the initial members.\n     * The Address references are copied out of the vector, so that the\n     * vector passed in as parameters is not the same reference as the vector\n     * that the membership class is using\n     *\n     * @param initial_members - a list of members that belong to this membership\n     */\n    public Membership(Collection<Address> initial_members) {\n        if(initial_members != null)\n            add(initial_members);\n    }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Clear the membership and adds all members of v\n     * This method will clear out all the old members of this membership by\n     * invoking the <code>Clear<\/code> method.\n     * Then it will add all the all members provided in the vector v\n     *\n     * @param v - a vector containing all the members this membership will contain\n     */\n    public void set(Collection v) {\n        clear();\n        if(v != null) {\n            add(v);\n        }\n    }","id":29982,"modified_method":"/**\n     * Clear the membership and adds all members of v\n     * This method will clear out all the old members of this membership by\n     * invoking the <code>Clear<\/code> method.\n     * Then it will add all the all members provided in the vector v\n     *\n     * @param v - a vector containing all the members this membership will contain\n     */\n    public void set(Collection<Address> v) {\n        clear();\n        if(v != null) {\n            add(v);\n        }\n    }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * removes all the members contained in v from this membership\n     *\n     * @param v - a vector containing all the members to be removed\n     */\n    public void remove(Collection v) {\n        if(v != null) {\n            synchronized(members) {\n                members.removeAll(v);\n            }\n        }\n    }","id":29983,"modified_method":"/**\n     * removes all the members contained in v from this membership\n     *\n     * @param v - a vector containing all the members to be removed\n     */\n    public void remove(Collection<Address> v) {\n        if(v != null) {\n            synchronized(members) {\n                members.removeAll(v);\n            }\n        }\n    }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds a list of members to this membership\n     *\n     * @param v - a vector containing Address objects\n     * @throws ClassCastException if v contains objects that don't implement the Address interface\n     * @see #add\n     */\n    public final void add(Collection v) {\n        if(v != null) {\n            for(Iterator it=v.iterator(); it.hasNext();) {\n                Address addr=(Address)it.next();\n                add(addr);\n            }\n        }\n    }","id":29984,"modified_method":"/**\n     * Adds a list of members to this membership\n     *\n     * @param v - a vector containing Address objects\n     * @throws ClassCastException if v contains objects that don't implement the Address interface\n     * @see #add\n     */\n    public final void add(Collection<Address> v) {\n        if(v != null) {\n            for(Iterator<Address> it=v.iterator(); it.hasNext();) {\n                Address addr=it.next();\n                add(addr);\n            }\n        }\n    }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the component at the specified index\n     *\n     * @param index - 0..size()-1\n     * @throws ArrayIndexOutOfBoundsException - if the index is negative or not less than the current size of this Membership object.\n     * @see java.util.Vector#elementAt\n     */\n\n    public Object elementAt(int index) {\n        synchronized(members) {\n            return members.get(index);\n        }\n    }","id":29985,"modified_method":"/**\n     * Returns the component at the specified index\n     *\n     * @param index - 0..size()-1\n     * @throws ArrayIndexOutOfBoundsException - if the index is negative or not less than the current size of this Membership object.\n     * @see java.util.Vector#elementAt\n     */\n\n    public Address elementAt(int index) {\n        synchronized(members) {\n            return members.get(index);\n        }\n    }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * merges membership with the new members and removes suspects\n     * The Merge method will remove all the suspects and add in the new members.\n     * It will do it in the order\n     * 1. Remove suspects\n     * 2. Add new members\n     * the order is very important to notice.\n     *\n     * @param new_mems - a vector containing a list of members (Address) to be added to this membership\n     * @param suspects - a vector containing a list of members (Address) to be removed from this membership\n     */\n    public void merge(Collection new_mems, Collection suspects) {\n        remove(suspects);\n        add(new_mems);\n    }","id":29986,"modified_method":"/**\n     * merges membership with the new members and removes suspects\n     * The Merge method will remove all the suspects and add in the new members.\n     * It will do it in the order\n     * 1. Remove suspects\n     * 2. Add new members\n     * the order is very important to notice.\n     *\n     * @param new_mems - a vector containing a list of members (Address) to be added to this membership\n     * @param suspects - a vector containing a list of members (Address) to be removed from this membership\n     */\n    public void merge(Collection<Address> new_mems, Collection<Address> suspects) {\n        remove(suspects);\n        add(new_mems);\n    }","commit_id":"29af317256bd7e110bb4c912a09935abdea150cc","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void main(String args[]) {\n        if(args.length != 1) {\n            System.err.println(\"Configurator <string>\");\n            System.exit(0);\n        }\n        String config_str=args[0];\n        Configurator conf=new Configurator();\n        Vector protocol_configs;\n        Vector protocols=null;\n        Protocol protocol_stack;\n\n\n        try {\n            protocol_configs=conf.parseConfigurations(config_str);\n            protocols=conf.createProtocols(protocol_configs, null);\n            if(protocols == null)\n                return;\n            protocol_stack=conf.connectProtocols(protocols);\n            Thread.sleep(3000);\n            conf.destroyProtocolStack(protocol_stack);\n            // conf.stopProtocolStackInternal(protocol_stack);\n        }\n        catch(Exception e) {\n            System.err.println(e);\n        }\n\n        System.err.println(protocols);\n    }","id":29987,"modified_method":"public static void main(String args[]) {\n        if(args.length != 1) {\n            System.err.println(\"Configurator <string>\");\n            System.exit(0);\n        }\n        String config_str=args[0];\n        Configurator conf=new Configurator();\n        Vector<ProtocolConfiguration> protocol_configs;\n        Vector<Protocol> protocols=null;\n        Protocol protocol_stack;\n\n\n        try {\n            protocol_configs=Configurator.parseConfigurations(config_str);\n            protocols=conf.createProtocols(protocol_configs, null);\n            if(protocols == null)\n                return;\n            protocol_stack=Configurator.connectProtocols(protocols);\n            Thread.sleep(3000);\n            Configurator.destroyProtocolStack(protocol_stack);\n            // conf.stopProtocolStackInternal(protocol_stack);\n        }\n        catch(Exception e) {\n            System.err.println(e);\n        }\n\n        System.err.println(protocols);\n    }","commit_id":"b38d9c326ea0cf52558602857744ab4e92c2798f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * The configuration string has a number of entries, separated by a ':' (colon).\n     * Each entry consists of the name of the protocol, followed by an optional configuration\n     * of that protocol. The configuration is enclosed in parentheses, and contains entries\n     * which are name/value pairs connected with an assignment sign (=) and separated by\n     * a semicolon.\n     * <pre>UDP(in_port=5555;out_port=4445):FRAG(frag_size=1024)<\/pre><p>\n     * The <em>first<\/em> entry defines the <em>bottommost<\/em> layer, the string is parsed\n     * left to right and the protocol stack constructed bottom up. Example: the string\n     * \"UDP(in_port=5555):FRAG(frag_size=32000):DEBUG\" results is the following stack:<pre>\n     *\n     *   -----------------------\n     *  | DEBUG                 |\n     *  |-----------------------|\n     *  | FRAG frag_size=32000  |\n     *  |-----------------------|\n     *  | UDP in_port=32000     |\n     *   -----------------------\n     * <\/pre>\n     */\n    public Protocol setupProtocolStack(String configuration, ProtocolStack st) throws Exception {\n        Protocol protocol_stack=null;\n        Vector protocol_configs;\n        Vector protocols;\n\n        protocol_configs=parseConfigurations(configuration);\n        protocols=createProtocols(protocol_configs, st);\n        if(protocols == null)\n            return null;\n        protocol_stack=connectProtocols(protocols);\n        return protocol_stack;\n    }","id":29988,"modified_method":"/**\n     * The configuration string has a number of entries, separated by a ':' (colon).\n     * Each entry consists of the name of the protocol, followed by an optional configuration\n     * of that protocol. The configuration is enclosed in parentheses, and contains entries\n     * which are name/value pairs connected with an assignment sign (=) and separated by\n     * a semicolon.\n     * <pre>UDP(in_port=5555;out_port=4445):FRAG(frag_size=1024)<\/pre><p>\n     * The <em>first<\/em> entry defines the <em>bottommost<\/em> layer, the string is parsed\n     * left to right and the protocol stack constructed bottom up. Example: the string\n     * \"UDP(in_port=5555):FRAG(frag_size=32000):DEBUG\" results is the following stack:<pre>\n     *\n     *   -----------------------\n     *  | DEBUG                 |\n     *  |-----------------------|\n     *  | FRAG frag_size=32000  |\n     *  |-----------------------|\n     *  | UDP in_port=32000     |\n     *   -----------------------\n     * <\/pre>\n     */\n    public Protocol setupProtocolStack(String configuration, ProtocolStack st) throws Exception {\n        Protocol protocol_stack=null;\n        Vector<ProtocolConfiguration> protocol_configs;\n        Vector<Protocol> protocols;\n\n        protocol_configs=parseConfigurations(configuration);\n        protocols=createProtocols(protocol_configs, st);\n        if(protocols == null)\n            return null;\n        protocol_stack=connectProtocols(protocols);\n        return protocol_stack;\n    }","commit_id":"b38d9c326ea0cf52558602857744ab4e92c2798f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Return a number of ProtocolConfigurations in a vector\n     * @param configuration protocol-stack configuration string\n     * @return Vector of ProtocolConfigurations\n     */\n    public Vector parseConfigurations(String configuration) throws Exception {\n        Vector retval=new Vector();\n        Vector component_strings=parseComponentStrings(configuration, \":\");\n        String component_string;\n        ProtocolConfiguration protocol_config;\n\n        if(component_strings == null)\n            return null;\n        for(int i=0; i < component_strings.size(); i++) {\n            component_string=(String)component_strings.elementAt(i);\n            protocol_config=new ProtocolConfiguration(component_string);\n            retval.addElement(protocol_config);\n        }\n        return retval;\n    }","id":29989,"modified_method":"/**\n     * Return a number of ProtocolConfigurations in a vector\n     * @param configuration protocol-stack configuration string\n     * @return Vector of ProtocolConfigurations\n     */\n    public static Vector<ProtocolConfiguration> parseConfigurations(String configuration) throws Exception {\n        Vector<ProtocolConfiguration> retval=new Vector<ProtocolConfiguration>();\n        Vector protocol_string=parseProtocols(configuration);\n        String component_string;\n        ProtocolConfiguration protocol_config;\n\n        if(protocol_string == null)\n            return null;\n        for(int i=0; i < protocol_string.size(); i++) {\n            component_string=(String)protocol_string.elementAt(i);\n            protocol_config=new ProtocolConfiguration(component_string);\n            retval.addElement(protocol_config);\n        }\n        return retval;\n    }","commit_id":"b38d9c326ea0cf52558602857744ab4e92c2798f","url":"https://github.com/belaban/JGroups"},{"original_method":"void setContents(String config_str) throws Exception {\n            int index=config_str.indexOf('(');  // e.g. \"UDP(in_port=3333)\"\n            int end_index=config_str.lastIndexOf(')');\n\n            if(index == -1) {\n                protocol_name=config_str;\n            }\n            else {\n                if(end_index == -1) {\n                    throw new Exception(\"Configurator.ProtocolConfiguration.setContents(): closing ')' \" +\n                                        \"not found in \" + config_str + \": properties cannot be set !\");\n                }\n                else {\n                    properties_str=config_str.substring(index + 1, end_index);\n                    protocol_name=config_str.substring(0, index);\n                }\n            }\n\n            /* \"in_port=5555;out_port=6666\" */\n            if(properties_str != null) {\n                Vector components=parseComponentStrings(properties_str, \";\");\n                if(!components.isEmpty()) {\n                    for(int i=0; i < components.size(); i++) {\n                        String name, value, comp=(String)components.elementAt(i);\n                        index=comp.indexOf('=');\n                        if(index == -1) {\n                            throw new Exception(\"Configurator.ProtocolConfiguration.setContents(): \" +\n                                                \"'=' not found in \" + comp);\n                        }\n                        name=comp.substring(0, index);\n                        value=comp.substring(index + 1, comp.length());\n                        properties.put(name, value);\n                    }\n                }\n            }\n        }","id":29990,"modified_method":"void setContents(String config_str) throws Exception {\n            int index=config_str.indexOf('(');  // e.g. \"UDP(in_port=3333)\"\n            int end_index=config_str.lastIndexOf(')');\n\n            if(index == -1) {\n                protocol_name=config_str;\n            }\n            else {\n                if(end_index == -1) {\n                    throw new Exception(\"Configurator.ProtocolConfiguration.setContents(): closing ')' \" +\n                                        \"not found in \" + config_str + \": properties cannot be set !\");\n                }\n                else {\n                    properties_str=config_str.substring(index + 1, end_index);\n                    protocol_name=config_str.substring(0, index);\n                }\n            }\n\n            /* \"in_port=5555;out_port=6666\" */\n            if(properties_str != null) {\n                String[] components=properties_str.split(\";\");\n                for(int i=0; i < components.length; i++) {\n                    String name, value, comp=components[i];\n                    index=comp.indexOf('=');\n                    if(index == -1) {\n                        throw new Exception(\"Configurator.ProtocolConfiguration.setContents(): '=' not found in \" + comp);\n                    }\n                    name=comp.substring(0, index);\n                    value=comp.substring(index + 1, comp.length());\n                    properties.put(name, value);\n                }\n            }\n        }","commit_id":"b38d9c326ea0cf52558602857744ab4e92c2798f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Takes vector of ProtocolConfigurations, iterates through it, creates Protocol for\n     * each ProtocolConfiguration and returns all Protocols in a vector.\n     * @param protocol_configs Vector of ProtocolConfigurations\n     * @param stack The protocol stack\n     * @return Vector of Protocols\n     */\n    private Vector createProtocols(Vector protocol_configs, ProtocolStack stack) throws Exception {\n        Vector retval=new Vector();\n        ProtocolConfiguration protocol_config;\n        Protocol layer;\n\n        for(int i=0; i < protocol_configs.size(); i++) {\n            protocol_config=(ProtocolConfiguration)protocol_configs.elementAt(i);\n            layer=protocol_config.createLayer(stack);\n            if(layer == null)\n                return null;\n            retval.addElement(layer);\n        }\n        sanityCheck(retval);\n        return retval;\n    }","id":29991,"modified_method":"/**\n     * Takes vector of ProtocolConfigurations, iterates through it, creates Protocol for\n     * each ProtocolConfiguration and returns all Protocols in a vector.\n     * @param protocol_configs Vector of ProtocolConfigurations\n     * @param stack The protocol stack\n     * @return Vector of Protocols\n     */\n    private Vector<Protocol> createProtocols(Vector<ProtocolConfiguration> protocol_configs, ProtocolStack stack) throws Exception {\n        Vector<Protocol> retval=new Vector<Protocol>();\n        ProtocolConfiguration protocol_config;\n        Protocol layer;\n\n        for(int i=0; i < protocol_configs.size(); i++) {\n            protocol_config=protocol_configs.elementAt(i);\n            layer=protocol_config.createLayer(stack);\n            if(layer == null)\n                return null;\n            retval.addElement(layer);\n        }\n        sanityCheck(retval);\n        return retval;\n    }","commit_id":"b38d9c326ea0cf52558602857744ab4e92c2798f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Throws an exception if sanity check fails. Possible sanity check is uniqueness of all protocol\n     names.\n     */\n    public void sanityCheck(Vector protocols) throws Exception {\n        Vector names=new Vector();\n        Protocol prot;\n        String name;\n        ProtocolReq req;\n        Vector req_list=new Vector();\n        int evt_type;\n\n        // Checks for unique names\n        for(int i=0; i < protocols.size(); i++) {\n            prot=(Protocol)protocols.elementAt(i);\n            name=prot.getName();\n            for(int j=0; j < names.size(); j++) {\n                if(name.equals(names.elementAt(j))) {\n                    throw new Exception(\"Configurator.sanityCheck(): protocol name \" + name +\n                                        \" has been used more than once; protocol names have to be unique !\");\n                }\n            }\n            names.addElement(name);\n        }\n\n\n        // Checks whether all requirements of all layers are met\n        for(int i=0; i < protocols.size(); i++) {\n            prot=(Protocol)protocols.elementAt(i);\n            req=new ProtocolReq(prot.getName());\n            req.up_reqs=prot.requiredUpServices();\n            req.down_reqs=prot.requiredDownServices();\n            req.up_provides=prot.providedUpServices();\n            req.down_provides=prot.providedDownServices();\n            req_list.addElement(req);\n        }\n\n\n        for(int i=0; i < req_list.size(); i++) {\n            req=(ProtocolReq)req_list.elementAt(i);\n\n            // check whether layers above this one provide corresponding down services\n            if(req.up_reqs != null) {\n                for(int j=0; j < req.up_reqs.size(); j++) {\n                    evt_type=((Integer)req.up_reqs.elementAt(j)).intValue();\n\n                    if(!providesDownServices(i, req_list, evt_type)) {\n                        throw new Exception(\"Configurator.sanityCheck(): event \" +\n                                            Event.type2String(evt_type) + \" is required by \" +\n                                            req.name + \", but not provided by any of the layers above\");\n                    }\n                }\n            }\n\n            // check whether layers below this one provide corresponding up services\n            if(req.down_reqs != null) {  // check whether layers above this one provide up_reqs\n                for(int j=0; j < req.down_reqs.size(); j++) {\n                    evt_type=((Integer)req.down_reqs.elementAt(j)).intValue();\n\n                    if(!providesUpServices(i, req_list, evt_type)) {\n                        throw new Exception(\"Configurator.sanityCheck(): event \" +\n                                            Event.type2String(evt_type) + \" is required by \" +\n                                            req.name + \", but not provided by any of the layers below\");\n                    }\n                }\n            }\n\n        }\n    }","id":29992,"modified_method":"/**\n     Throws an exception if sanity check fails. Possible sanity check is uniqueness of all protocol\n     names.\n     */\n    public static void sanityCheck(Vector<Protocol> protocols) throws Exception {\n        Vector<String> names=new Vector<String>();\n        Protocol prot;\n        String name;\n        ProtocolReq req;\n        Vector<ProtocolReq> req_list=new Vector<ProtocolReq>();\n        int evt_type;\n\n        // Checks for unique names\n        for(int i=0; i < protocols.size(); i++) {\n            prot=protocols.elementAt(i);\n            name=prot.getName();\n            for(int j=0; j < names.size(); j++) {\n                if(name.equals(names.elementAt(j))) {\n                    throw new Exception(\"Configurator.sanityCheck(): protocol name \" + name +\n                                        \" has been used more than once; protocol names have to be unique !\");\n                }\n            }\n            names.addElement(name);\n        }\n\n\n        // Checks whether all requirements of all layers are met\n        for(int i=0; i < protocols.size(); i++) {\n            prot=protocols.elementAt(i);\n            req=new ProtocolReq(prot.getName());\n            req.up_reqs=prot.requiredUpServices();\n            req.down_reqs=prot.requiredDownServices();\n            req.up_provides=prot.providedUpServices();\n            req.down_provides=prot.providedDownServices();\n            req_list.addElement(req);\n        }\n\n\n        for(int i=0; i < req_list.size(); i++) {\n            req=req_list.elementAt(i);\n\n            // check whether layers above this one provide corresponding down services\n            if(req.up_reqs != null) {\n                for(int j=0; j < req.up_reqs.size(); j++) {\n                    evt_type=((Integer)req.up_reqs.elementAt(j)).intValue();\n\n                    if(!providesDownServices(i, req_list, evt_type)) {\n                        throw new Exception(\"Configurator.sanityCheck(): event \" +\n                                            Event.type2String(evt_type) + \" is required by \" +\n                                            req.name + \", but not provided by any of the layers above\");\n                    }\n                }\n            }\n\n            // check whether layers below this one provide corresponding up services\n            if(req.down_reqs != null) {  // check whether layers above this one provide up_reqs\n                for(int j=0; j < req.down_reqs.size(); j++) {\n                    evt_type=((Integer)req.down_reqs.elementAt(j)).intValue();\n\n                    if(!providesUpServices(i, req_list, evt_type)) {\n                        throw new Exception(\"Configurator.sanityCheck(): event \" +\n                                            Event.type2String(evt_type) + \" is required by \" +\n                                            req.name + \", but not provided by any of the layers below\");\n                    }\n                }\n            }\n\n        }\n    }","commit_id":"b38d9c326ea0cf52558602857744ab4e92c2798f","url":"https://github.com/belaban/JGroups"},{"original_method":"public void destroy() {\n        if(top_prot != null) {\n            conf.destroyProtocolStack(top_prot);           // destroys msg queues and threads\n            top_prot=null;\n        }        \n        try {\n            timer.stop();\n        }\n        catch(Exception ex) {\n        }        \n    }","id":29993,"modified_method":"public void destroy() {\n        if(top_prot != null) {\n            Configurator.destroyProtocolStack(top_prot);           // destroys msg queues and threads\n            top_prot=null;\n        }        \n        try {\n            timer.stop();\n        }\n        catch(Exception ex) {\n        }        \n    }","commit_id":"b38d9c326ea0cf52558602857744ab4e92c2798f","url":"https://github.com/belaban/JGroups"},{"original_method":"public void setup() throws Exception {\n        if(top_prot == null) {\n            top_prot=conf.setupProtocolStack(setup_string, this);\n            top_prot.setUpProtocol(this);\n            bottom_prot=conf.getBottommostProtocol(top_prot);\n            conf.initProtocolStack(bottom_prot);         // calls init() on each protocol, from bottom to top\n        }\n    }","id":29994,"modified_method":"public void setup() throws Exception {\n        if(top_prot == null) {\n            top_prot=conf.setupProtocolStack(setup_string, this);\n            top_prot.setUpProtocol(this);\n            bottom_prot=Configurator.getBottommostProtocol(top_prot);\n            Configurator.initProtocolStack(bottom_prot);         // calls init() on each protocol, from bottom to top\n        }\n    }","commit_id":"b38d9c326ea0cf52558602857744ab4e92c2798f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Start all layers. The {@link Protocol#start()} method is called in each protocol,\n     * <em>from top to bottom<\/em>.\n     * Each layer can perform some initialization, e.g. create a multicast socket\n     */\n    public void startStack() throws Exception {\n        if(stopped == false) return;\n\n        timer.start();\n        conf.startProtocolStack(top_prot);\n        stopped=false;\n    }","id":29995,"modified_method":"/**\n     * Start all layers. The {@link Protocol#start()} method is called in each protocol,\n     * <em>from top to bottom<\/em>.\n     * Each layer can perform some initialization, e.g. create a multicast socket\n     */\n    public void startStack() throws Exception {\n        if(stopped == false) return;\n\n        timer.start();\n        Configurator.startProtocolStack(top_prot);\n        stopped=false;\n    }","commit_id":"b38d9c326ea0cf52558602857744ab4e92c2798f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Inserts an already created (and initialized) protocol into the protocol list. Sets the links\n     * to the protocols above and below correctly and adjusts the linked list of protocols accordingly.\n     * Note that this method may change the value of top_prot or bottom_prot.\n     * @param prot The protocol to be inserted. Before insertion, a sanity check will ensure that none\n     *             of the existing protocols have the same name as the new protocol.\n     * @param position Where to place the protocol with respect to the neighbor_prot (ABOVE, BELOW)\n     * @param neighbor_prot The name of the neighbor protocol. An exception will be thrown if this name\n     *                      is not found\n     * @exception Exception Will be thrown when the new protocol cannot be created, or inserted.\n     */\n    public void insertProtocol(Protocol prot, int position, String neighbor_prot) throws Exception {\n        conf.insertProtocol(prot, position, neighbor_prot, this);\n    }","id":29996,"modified_method":"/**\n     * Inserts an already created (and initialized) protocol into the protocol list. Sets the links\n     * to the protocols above and below correctly and adjusts the linked list of protocols accordingly.\n     * Note that this method may change the value of top_prot or bottom_prot.\n     * @param prot The protocol to be inserted. Before insertion, a sanity check will ensure that none\n     *             of the existing protocols have the same name as the new protocol.\n     * @param position Where to place the protocol with respect to the neighbor_prot (ABOVE, BELOW)\n     * @param neighbor_prot The name of the neighbor protocol. An exception will be thrown if this name\n     *                      is not found\n     * @exception Exception Will be thrown when the new protocol cannot be created, or inserted.\n     */\n    public void insertProtocol(Protocol prot, int position, String neighbor_prot) throws Exception {\n        Configurator.insertProtocol(prot, position, neighbor_prot, this);\n    }","commit_id":"b38d9c326ea0cf52558602857744ab4e92c2798f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a new protocol given the protocol specification.\n     * @param prot_spec The specification of the protocol. Same convention as for specifying a protocol stack.\n     *                  An exception will be thrown if the class cannot be created. Example:\n     *                  <pre>\"VERIFY_SUSPECT(timeout=1500)\"<\/pre> Note that no colons (:) have to be\n     *                  specified\n     * @return Protocol The newly created protocol\n     * @exception Exception Will be thrown when the new protocol cannot be created\n     */\n    public Protocol createProtocol(String prot_spec) throws Exception {\n        return conf.createProtocol(prot_spec, this);\n    }","id":29997,"modified_method":"/**\n     * Creates a new protocol given the protocol specification.\n     * @param prot_spec The specification of the protocol. Same convention as for specifying a protocol stack.\n     *                  An exception will be thrown if the class cannot be created. Example:\n     *                  <pre>\"VERIFY_SUSPECT(timeout=1500)\"<\/pre> Note that no colons (:) have to be\n     *                  specified\n     * @return Protocol The newly created protocol\n     * @exception Exception Will be thrown when the new protocol cannot be created\n     */\n    public Protocol createProtocol(String prot_spec) throws Exception {\n        return Configurator.createProtocol(prot_spec, this);\n    }","commit_id":"b38d9c326ea0cf52558602857744ab4e92c2798f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Iterates through all the protocols <em>from top to bottom<\/em> and does the following:\n     * <ol>\n     * <li>Waits until all messages in the down queue have been flushed (ie., size is 0)\n     * <li>Calls stop() on the protocol\n     * <\/ol>\n     */\n    public void stopStack() {       \n        if(stopped) return;\n        conf.stopProtocolStack(top_prot);\n        stopped=true;\n    }","id":29998,"modified_method":"/**\n     * Iterates through all the protocols <em>from top to bottom<\/em> and does the following:\n     * <ol>\n     * <li>Waits until all messages in the down queue have been flushed (ie., size is 0)\n     * <li>Calls stop() on the protocol\n     * <\/ol>\n     */\n    public void stopStack() {       \n        if(stopped) return;\n        Configurator.stopProtocolStack(top_prot);\n        stopped=true;\n    }","commit_id":"b38d9c326ea0cf52558602857744ab4e92c2798f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes a protocol from the stack. Stops the protocol and readjusts the linked lists of\n     * protocols.\n     * @param prot_name The name of the protocol. Since all protocol names in a stack have to be unique\n     *                  (otherwise the stack won't be created), the name refers to just 1 protocol.\n     * @exception Exception Thrown if the protocol cannot be stopped correctly.\n     */\n    public Protocol removeProtocol(String prot_name) throws Exception {\n        return conf.removeProtocol(top_prot, prot_name);\n    }","id":29999,"modified_method":"/**\n     * Removes a protocol from the stack. Stops the protocol and readjusts the linked lists of\n     * protocols.\n     * @param prot_name The name of the protocol. Since all protocol names in a stack have to be unique\n     *                  (otherwise the stack won't be created), the name refers to just 1 protocol.\n     * @exception Exception Thrown if the protocol cannot be stopped correctly.\n     */\n    public Protocol removeProtocol(String prot_name) throws Exception {\n        return Configurator.removeProtocol(top_prot, prot_name);\n    }","commit_id":"b38d9c326ea0cf52558602857744ab4e92c2798f","url":"https://github.com/belaban/JGroups"}]